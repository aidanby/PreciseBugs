{"buggy_code": ["# Makefile for Vim on Unix and Unix-like systems\tvim:ts=8:sw=8:tw=78\n#\n# This Makefile is loosely based on the GNU Makefile conventions found in\n# standards.info.\n#\n# Compiling Vim, summary:\n#\n#\t3. make\n#\t5. make install\n#\n# Compiling Vim, details:\n#\n# Edit this file for adjusting to your system. You should not need to edit any\n# other file for machine specific things!\n# The name of this file MUST be Makefile (note the uppercase 'M').\n#\n# 1. Edit this Makefile  {{{1\n#\tThe defaults for Vim should work on most machines, but you may want to\n#\tuncomment some lines or make other changes below to tune it to your\n#\tsystem, compiler or preferences.  Uncommenting means that the '#' in\n#\tthe first column of a line is removed.\n#\t- If you want a version of Vim that is small and starts up quickly,\n#\t  you might want to disable the GUI, X11, Perl, Python and Tcl.\n#\t- Uncomment the line with --disable-gui if you have Motif, GTK and/or\n#\t  Athena but don't want to make gvim (the GUI version of Vim with nice\n#\t  menus and scrollbars, but makes Vim bigger and startup slower).\n#\t- Uncomment --disable-darwin if on Mac OS X but you want to compile a\n#\t  Unix version.\n#\t- Uncomment the line \"CONF_OPT_X = --without-x\" if you have X11 but\n#\t  want to disable using X11 libraries.\tThis speeds up starting Vim,\n#\t  but the window title will not be set and the X11 selection can not\n#\t  be used.\n#\t- Uncomment the line \"CONF_OPT_XSMP = --disable-xsmp\" if you have the\n#\t  X11 Session Management Protocol (XSMP) library (libSM) but do not\n#\t  want to use it.\n#\t  This can speedup Vim startup but Vim loses the ability to catch the\n#\t  user logging out from session-managers like GNOME and work\n#\t  could be lost.\n#\t- Uncomment one or more of these lines to include an interface;\n#\t  each makes Vim quite a bit bigger:\n#\t\t--enable-luainterp\tfor Lua interpreter\n#\t\t--enable-mzschemeinterp\tfor MzScheme interpreter\n#\t\t--enable-perlinterp\tfor Perl interpreter\n#\t\t--enable-python3interp\tfor Python3 interpreter\n#\t\t--enable-pythoninterp\tfor Python interpreter\n#\t\t--enable-rubyinterp\tfor Ruby interpreter\n#\t\t--enable-tclinterp\tfor Tcl interpreter\n#\t\t--enable-cscope\t\tfor Cscope interface\n#\t- Uncomment one of the lines with --with-features= to enable a set of\n#\t  features (but not the interfaces just mentioned).\n#\t- Uncomment the line with --disable-acl to disable ACL support even\n#\t  though your system supports it.\n#\t- Uncomment the line with --disable-gpm to disable gpm support\n#\t  even though you have gpm libraries and includes.\n#\t- Uncomment the line with --disable-sysmouse to disable sysmouse\n#\t  support even though you have /dev/sysmouse and includes.\n#\t- Uncomment one of the lines with CFLAGS and/or CC if you have\n#\t  something very special or want to tune the optimizer.\n#\t- Search for the name of your system to see if it needs anything\n#\t  special.\n#\t- A few versions of make use '.include \"file\"' instead of 'include\n#\t  file'.  Adjust the include line below if yours does.\n#\n# 2. Edit feature.h  {{{1\n#\tOnly if you do not agree with the default compile features, e.g.:\n#\t- you want Vim to be as vi compatible as it can be\n#\t- you want to use Emacs tags files\n#\t- you want right-to-left editing (Hebrew)\n#\t- you want 'langmap' support (Greek)\n#\t- you want to remove features to make Vim smaller\n#\n# 3. \"make\"  {{{1\n#\tWill first run ./configure with the options in this file. Then it will\n#\tstart make again on this Makefile to do the compiling. You can also do\n#\tthis in two steps with:\n#\t\tmake config\n#\t\tmake\n#\tThe configuration phase creates/overwrites auto/config.h and\n#\tauto/config.mk.\n#\tThe configure script is created with \"make autoconf\".  It can detect\n#\tdifferent features of your system and act accordingly.  However, it is\n#\tnot correct for all systems.  Check this:\n#\t- If you have X windows, but configure could not find it or reported\n#\t  another include/library directory then you wanted to use, you have\n#\t  to set CONF_OPT_X below.  You might also check the installation of\n#\t  xmkmf.\n#\t- If you have --enable-gui=motif and have Motif on your system, but\n#\t  configure reports \"checking for location of gui... <not found>\", you\n#\t  have to set GUI_INC_LOC and GUI_LIB_LOC below.\n#\tIf you changed something, do this to run configure again:\n#\t\tmake reconfig\n#\n#\t- If you do not trust the automatic configuration code, then inspect\n#\t  auto/config.h and auto/config.mk, before starting the actual build\n#\t  phase. If possible edit this Makefile, rather than auto/config.mk --\n#\t  especially look at the definition of VIMLOC below. Note that the\n#\t  configure phase overwrites auto/config.mk and auto/config.h again.\n#\t- If you get error messages, find out what is wrong and try to correct\n#\t  it in this Makefile. You may need to do \"make reconfig\" when you\n#\t  change anything that configure uses (e.g. switching from an old C\n#\t  compiler to an ANSI C compiler). Only when auto/configure does\n#\t  something wrong you may need to change one of the other files. If\n#\t  you find a clean way to fix the problem, consider sending a note to\n#\t  the author of autoconf (bug-gnu-utils@prep.ai.mit.edu) or Vim\n#\t  (Bram@vim.org). Don't bother to do that when you made a hack\n#\t  solution for a non-standard system.\n#\n# 4. \"make test\"  {{{1\n#\tThis is optional.  This will run Vim scripts on a number of test\n#\tfiles, and compare the produced output with the expected output.\n#\tIf all is well, you will get the \"ALL DONE\" message in the end.  If a\n#\ttest fails you get \"TEST FAILURE\".  See below (search for \"/^test\").\n#\n# 5. \"make install\"  {{{1\n#\tIf the new Vim seems to be working OK you can install it and the\n#\tdocumentation in the appropriate location. The default is\n#\t\"/usr/local\".  Change \"prefix\" below to change the location.\n#\t\"auto/pathdef.c\" will be compiled again after changing this to make\n#\tthe executable know where the help files are located.\n#\tNote that any existing executable is removed or overwritten.  If you\n#\twant to keep it you will have to make a backup copy first.\n#\tThe runtime files are in a different directory for each version.  You\n#\tmight want to delete an older version.\n#\tIf you don't want to install everything, there are other targets:\n#\t\tmake installvim\t\tonly installs Vim, not the tools\n#\t\tmake installvimbin\tonly installs the Vim executable\n#\t\tmake installruntime\tinstalls most of the runtime files\n#\t\tmake installrtbase\tonly installs the Vim help and\n#\t\t\t\t\t\t\truntime files\n#\t\tmake installlinks\tonly installs the Vim binary links\n#\t\tmake installmanlinks\tonly installs the Vim manpage links\n#\t\tmake installmacros\tonly installs the Vim macros\n#\t\tmake installpack\tonly installs the packages\n#\t\tmake installtutorbin\tonly installs the Vim tutor program\n#\t\tmake installtutor\tonly installs the Vim tutor files\n#\t\tmake installspell\tonly installs the spell files\n#\t\tmake installtools\tonly installs xxd\n#\tIf you install Vim, not to install for real but to prepare a package\n#\tor RPM, set DESTDIR to the root of the tree.\n#\n# 6. Use Vim until a new version comes out.  {{{1\n#\n# 7. \"make uninstall_runtime\"  {{{1\n#\tWill remove the runtime files for the current version.\tThis is safe\n#\tto use while another version is being used, only version-specific\n#\tfiles will be deleted.\n#\tTo remove the runtime files of another version:\n#\t\tmake uninstall_runtime VIMRTDIR=/vim54\n#\tIf you want to delete all installed files, use:\n#\t\tmake uninstall\n#\tNote that this will delete files that have the same name for any\n#\tversion, thus you might need to do a \"make install\" soon after this.\n#\tBe careful not to remove a version of Vim that is still being used!\n#\tTo find out which files and directories will be deleted, use:\n#\t\tmake -n uninstall\n# }}}\n#\n### This Makefile has been successfully tested on many systems. {{{\n### Only the ones that require special options are mentioned here.\n### Check the (*) column for remarks, listed below.\n### Later code changes may cause small problems, otherwise Vim is supposed to\n### compile and run without problems.\n\n#system:\t      configurations:\t\t     version (*) tested by:\n#-------------\t      ------------------------\t     -------  -  ----------\n#AIX 3.2.5\t      cc (not gcc)   -\t\t\t4.5  (M) Will Fiveash\n#AIX 4\t\t      cc\t     +X11 -GUI\t\t3.27 (4) Axel Kielhorn\n#AIX 4.1.4\t      cc\t     +X11 +GUI\t\t4.5  (5) Nico Bakker\n#AIX 4.2.1\t      cc\t\t\t\t5.2k (C) Will Fiveash\n#AIX 4.3.3.12\t      xic 3.6.6\t\t\t\t5.6  (5) David R. Favor\n#A/UX 3.1.1\t      gcc\t     +X11\t\t4.0  (6) Jim Jagielski\n#BeOS PR\t      mwcc DR3\t\t\t\t5.0n (T) Olaf Seibert\n#BSDI 2.1 (x86)       shlicc2 gcc-2.6.3 -X11 X11R6\t4.5  (1) Jos Backus\n#BSD/OS 3.0 (x86)     gcc gcc-2.7.2.1 -X11 X11R6\t4.6c (1) Jos Backus\n#CX/UX 6.2\t      cc\t     +X11 +GUI_Mofif\t5.4  (V) Kipp E. Howard\n#DG/UX 5.4*\t      gcc 2.5.8      GUI\t\t5.0e (H) Jonas Schlein\n#DG/UX 5.4R4.20       gcc 2.7.2      GUI\t\t5.0s (H) Rocky Olive\n#HP-UX (most)\t      c89 cc\t\t\t\t5.1  (2) Bram Moolenaar\n#HP-UX_9.04\t      cc\t     +X11 +Motif\t5.0  (2) Carton Lao\n#Irix 6.3 (O2)\t      cc\t     ?\t\t\t4.5  (L) Edouard Poor\n#Irix 6.4\t      cc\t     ?\t\t\t5.0m (S) Rick Sayre\n#Irix 6.5\t      cc\t     ?\t\t\t6.0  (S) David Harrison\n#Irix 64 bit\t\t\t\t\t\t4.5  (K) Jon Wright\n#Linux 2.0\t      gcc-2.7.2      Infomagic Motif\t4.3  (3) Ronald Rietman\n#Linux 2.0.31\t      gcc\t     +X11 +GUI Athena\t5.0w (U) Darren Hiebert\n#LynxOS 3.0.1\t      2.9-gnupro-98r2 +X11 +GUI Athena  5.7.1(O) Lorenz Hahn\n#LynxOS 3.1.0\t      2.9-gnupro-98r2 +X11 +GUI Athena  5.7.1(O) Lorenz Hahn\n#NEC UP4800 UNIX_SV 4.2MP  cc\t     +X11R6 Motif,Athena4.6b (Q) Lennart Schultz\n#NetBSD 1.0A\t      gcc-2.4.5      -X11 -GUI\t\t3.21 (X) Juergen Weigert\n#QNX 4.2\t      wcc386-10.6    -X11\t\t4.2  (D) G.F. Desrochers\n#QNX 4.23\t      Watcom\t     -X11\t\t4.2  (F) John Oleynick\n#SCO Unix v3.2.5      cc\t     +X11 Motif\t\t3.27 (C) M. Kuperblum\n#SCO Open Server 5    gcc 2.7.2.3    +X11 +GUI Motif\t5.3  (A) Glauber Ribeiro\n#SINIX-N 5.43 RM400 R4000   cc\t     +X11 +GUI\t\t5.0l (I) Martin Furter\n#SINIX-Z 5.42 i386    gcc 2.7.2.3    +X11 +GUI Motif\t5.1  (I) Joachim Fehn\n#SINIX-Y 5.43 RM600 R4000  gcc 2.7.2.3 +X11 +GUI Motif\t5.1  (I) Joachim Fehn\n#Reliant/SINIX 5.44   cc\t     +X11 +GUI\t\t5.5a (I) B. Pruemmer\n#SNI Targon31 TOS 4.1.11 gcc-2.4.5   +X11 -GUI\t\t4.6c (B) Paul Slootman\n#Solaris 2.4 (Sparc)  cc\t     +X11 +GUI\t\t3.29 (9) Glauber\n#Solaris 2.4/2.5      clcc\t     +X11 -GUI openwin\t3.20 (7) Robert Colon\n#Solaris 2.5 (sun4m)  cc (SC4.0)     +X11R6 +GUI (CDE)\t4.6b (E) Andrew Large\n#Solaris 2.5\t      cc\t     +X11 +GUI Athena\t4.2  (9) Sonia Heimann\n#Solaris 2.5\t      gcc 2.5.6      +X11 Motif\t\t5.0m (R) Ant. Colombo\n#Solaris 2.6\t      gcc 2.8.1      ncurses\t\t5.3  (G) Larry W. Virden\n#Solaris with -lthread\t\t\t\t\t5.5  (W) K. Nagano\n#Solaris\t      gcc\t\t\t\t     (b) Riccardo\n#SunOS 4.1.x\t\t\t     +X11 -GUI\t\t5.1b (J) Bram Moolenaar\n#SunOS 4.1.3_U1 (sun4c) gcc\t     +X11 +GUI Athena\t5.0w (J) Darren Hiebert\n#SUPER-UX 6.2 (NEC SX-4) cc\t     +X11R6 Motif,Athena4.6b (P) Lennart Schultz\n#Tandem/NSK\t\t\t\t\t\t     (c) Matthew Woehlke\n#Unisys 6035\t      cc\t     +X11 Motif\t\t5.3  (8) Glauber Ribeiro\n#ESIX V4.2\t      cc\t     +X11\t\t6.0  (a) Reinhard Wobst\n#Mac OS X 10.[23]     gcc\t     Carbon\t\t6.2  (x) Bram Moolenaar\n# }}}\n\n# (*)  Remarks: {{{\n#\n# (1)  Uncomment line below for shlicc2\n# (2)  HPUX with compile problems or wrong digraphs, uncomment line below\n# (3)  Infomagic Motif needs GUI_LIB_LOC and GUI_INC_LOC set, see below.\n#      And add \"-lXpm\" to MOTIF_LIBS2.\n# (4)  For cc the optimizer must be disabled (use CFLAGS= after running\n#      configure) (symptom: \":set termcap\" output looks weird).\n# (5)  Compiler may need extra argument, see below.\n# (6)  See below for a few lines to uncomment\n# (7)  See below for lines which enable the use of clcc\n# (8)  Needs some EXTRA_LIBS, search for Unisys below\n# (9)  Needs an extra compiler flag to compile gui_at_sb.c, see below.\n# (A)  May need EXTRA_LIBS, see below\n# (B)  Can't compile GUI because there is no waitpid()...  Disable GUI below.\n# (C)  Force the use of curses instead of termcap, see below.\n# (D)  Uncomment lines below for QNX\n# (E)  You might want to use termlib instead of termcap, see below.\n# (F)  See below for instructions.\n# (G)  Using ncurses version 4.2 has reported to cause a crash.  Use the\n#      Sun curses library instead.\n# (H)  See line for EXTRA_LIBS below.\n# (I)  SINIX-N 5.42 and 5.43 need some EXTRA_LIBS.  Also for Reliant-Unix.\n# (J)  If you get undefined symbols, see below for a solution.\n# (K)  See lines to uncomment below for machines with 64 bit pointers.\n# (L)  For Silicon Graphics O2 workstations remove \"-lnsl\" from auto/config.mk\n# (M)  gcc version cygnus-2.0.1 does NOT work (symptom: \"dl\" deletes two\n#      characters instead of one).\n# (N)  SCO with decmouse.\n# (O)  LynxOS needs EXTRA_LIBS, see below.\n# (P)  For SuperUX 6.2 on NEC SX-4 see a few lines below to uncomment.\n# (Q)  For UNIXSVR 4.2MP on NEC UP4800 see below for lines to uncomment.\n# (R)  For Solaris 2.5 (or 2.5.1) with gcc > 2.5.6, uncomment line below.\n# (S)  For Irix 6.x with MipsPro compiler, use -OPT:Olimit.  See line below.\n# (T)  See ../doc/os_beos.txt.\n# (U)  Must uncomment CONF_OPT_PYTHON option below to disable Python\n#      detection, since the configure script runs into an error when it\n#      detects Python (probably because of the bash shell).\n# (V)  See lines to uncomment below.\n# (X)  Need to use the .include \"auto/config.mk\" line below\n# (Y)  See line with c89 below\n# (Z)  See lines with cc or c89 below\n# (a)  See line with EXTRA_LIBS below.\n# (b)  When using gcc with the Solaris linker, make sure you don't use GNU\n#      strip, otherwise the binary may not run: \"Cannot find ELF\".\n# (c)  Add -lfloss to EXTRA_LIBS, see below.\n# (x)  When you get warnings for precompiled header files, run\n#      \"sudo fixPrecomps\".  Also see CONF_OPT_DARWIN below.\n# }}}\n\n\n#DO NOT CHANGE the next line, we need it for configure to find the compiler\n#instead of using the default from the \"make\" program.\n#Use a line further down to change the value for CC.\nCC=\n\n# Change and use these defines if configure cannot find your Motif stuff.\n# Unfortunately there is no \"standard\" location for Motif. {{{\n# These defines can contain a single directory (recommended) or a list of\n# directories (for when you are working with several systems). The LAST\n# directory that exists is used.\n# When changed, run \"make reconfig\" next!\n#GUI_INC_LOC = -I/usr/include/Motif2.0 -I/usr/include/Motif1.2\n#GUI_LIB_LOC = -L/usr/lib/Motif2.0 -L/usr/lib/Motif1.2\n### Use these two lines for Infomagic Motif (3)\n#GUI_INC_LOC = -I/usr/X11R6/include\n#GUI_LIB_LOC = -L/usr/X11R6/lib\n# }}}\n\n# Defaults used when auto/config.mk does not exist.\nsrcdir = .\nVIMNAME = vim\nEXNAME = ex\nVIEWNAME = view\n\n######################## auto/config.mk ######################## {{{1\n# At this position auto/config.mk is included. When starting from the\n# toplevel Makefile it is almost empty. After running auto/configure it\n# contains settings that have been discovered for your system. Settings below\n# this include override settings in auto/config.mk!\n\n# Note: If make fails because auto/config.mk does not exist (it is not\n# included in the repository), do:\n#    cp config.mk.dist auto/config.mk\n\n# (X) How to include auto/config.mk depends on the version of \"make\" you have,\n#     if the current choice doesn't work, try the other one.\n\ninclude auto/config.mk\n#.include \"auto/config.mk\"\nCClink = $(CC)\n\n#}}}\n\n# Include the configuration choices first, so we can override everything\n# below. As shipped, this file contains a target that causes to run\n# configure. Once configure was run, this file contains a list of\n# make variables with predefined values instead. Thus any second invocation\n# of make, will build Vim.\n\n# CONFIGURE - configure arguments {{{1\n# You can give a lot of options to configure.\n# Change this to your desire and do 'make config' afterwards\n\n# examples (can only use one!):\n#CONF_ARGS = --exec-prefix=/usr\n#CONF_ARGS = --with-vim-name=vim7 --with-ex-name=ex7 --with-view-name=view7\n#CONF_ARGS = --with-global-runtime=/etc/vim\n#CONF_ARGS = --with-local-dir=/usr/share\n#CONF_ARGS = --without-local-dir\n\n# Use this one if you distribute a modified version of Vim.\n#CONF_ARGS = --with-modified-by=\"John Doe\"\n\n# GUI - For creating Vim with GUI (gvim) (B)\n# Uncomment this line when you don't want to get the GUI version, although you\n# have GTK, Motif and/or Athena.  Also use --without-x if you don't want X11\n# at all.\n#CONF_OPT_GUI = --disable-gui\n\n# Uncomment one of these lines if you have that GUI but don't want to use it.\n# The automatic check will use another one that can be found.\n# Gnome is disabled by default, because it may cause trouble.\n#\n# When both GTK+ 2 and GTK+ 3 are possible then GTK+ 2 will be selected.\n# To use GTK+ 3 instead use --enable-gui=gtk3 (see below).\n#CONF_OPT_GUI = --disable-gtk2-check\n#CONF_OPT_GUI = --enable-gnome-check\n#CONF_OPT_GUI = --disable-gtk3-check\n#CONF_OPT_GUI = --disable-motif-check\n#CONF_OPT_GUI = --disable-athena-check\n#CONF_OPT_GUI = --disable-nextaw-check\n\n# Uncomment one of these lines to select a specific GUI to use.\n# When using \"yes\" or nothing, configure will use the first one found: GTK+,\n# Motif or Athena.\n#\n# GTK versions that are known not to work 100% are rejected.\n# Use \"--disable-gtktest\" to accept them anyway.\n# For GTK 1 use Vim 7.2.\n#\n# GNOME means GTK with Gnome support.  If using GTK and --enable-gnome-check\n# is used then GNOME will automatically be used if it is found.  If you have\n# GNOME, but do not want to use it (e.g., want a GTK-only version), then use\n# --enable-gui=gtk or leave out --enable-gnome-check.\n#\n# GNOME makes sense only for GTK+ 2.  Avoid use of --enable-gnome-check with\n# GTK+ 3 build, as the functionality of GNOME is already incooperated into\n# GTK+ 3.\n#\n# If the selected GUI isn't found, the GUI is disabled automatically\n#CONF_OPT_GUI = --enable-gui=gtk2\n#CONF_OPT_GUI = --enable-gui=gtk2 --disable-gtktest\n#CONF_OPT_GUI = --enable-gui=gnome2\n#CONF_OPT_GUI = --enable-gui=gnome2 --disable-gtktest\n#CONF_OPT_GUI = --enable-gui=gtk3\n#CONF_OPT_GUI = --enable-gui=gtk3 --disable-gtktest\n#CONF_OPT_GUI = --enable-gui=motif\n#CONF_OPT_GUI = --enable-gui=motif --with-motif-lib=\"-static -lXm -shared\"\n#CONF_OPT_GUI = --enable-gui=athena\n#CONF_OPT_GUI = --enable-gui=nextaw\n\n# Carbon GUI for Mac OS X\n#CONF_OPT_GUI = --enable-gui=carbon\n\n# Uncomment this line to run an individual test with gvim.\n#GUI_TESTARG = GUI_FLAG=-g \n\n# DARWIN - detecting Mac OS X\n# Uncomment this line when you want to compile a Unix version of Vim on\n# Darwin.  None of the Mac specific options or files will be used.\n#CONF_OPT_DARWIN = --disable-darwin\n\n# Select the architecture supported.  Default is to build for the current\n# platform.  Use \"both\" for a universal binary.  That probably doesn't work\n# when including Perl, Python, etc.\n#CONF_OPT_DARWIN = --with-mac-arch=i386\n#CONF_OPT_DARWIN = --with-mac-arch=ppc\n#CONF_OPT_DARWIN = --with-mac-arch=both\n\n# Uncomment the next line to fail if one of the requested language interfaces\n# cannot be configured.  Without this Vim will be build anyway, without\n# the failing interfaces.\n#CONF_OPT_FAIL = --enable-fail-if-missing\n\n# LUA\n# Uncomment one of these when you want to include the Lua interface.\n# First one is for static linking, second one for dynamic loading.\n# Use --with-luajit if you want to use LuaJIT instead of Lua.\n# Set PATH environment variable to find lua or luajit executable.\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n#CONF_OPT_LUA = --enable-luainterp\n#CONF_OPT_LUA = --enable-luainterp=dynamic\n#CONF_OPT_LUA = --enable-luainterp --with-luajit\n#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit\n# Lua installation dir (when not set uses $LUA_PREFIX or defaults to /usr)\n#CONF_OPT_LUA_PREFIX = --with-lua-prefix=/usr/local\n\n# MZSCHEME\n# Uncomment this when you want to include the MzScheme interface.\n# NOTE: does not work well together with valgrind.\n#CONF_OPT_MZSCHEME = --enable-mzschemeinterp\n# PLT/mrscheme/drscheme Home dir; the PLTHOME environment variable also works\n#CONF_OPT_PLTHOME  = --with-plthome=/usr/local/plt\n#CONF_OPT_PLTHOME  = --with-plthome=/usr/local/drscheme\n#CONF_OPT_PLTHOME  = --with-plthome=/home/me/mz\n\n# PERL\n# Uncomment one of these when you want to include the Perl interface.\n# First one is for static linking, second one for dynamic loading.\n# The Perl option sometimes causes problems, because it adds extra flags\n#\n# to the command line.\tIf you see strange flags during compilation, check in\n# auto/config.mk where they come from.  If it's PERL_CFLAGS, try commenting\n# the next line.\n# When you get an error for a missing \"perl.exp\" file, try creating an empty\n# one: \"touch perl.exp\".\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n#CONF_OPT_PERL = --enable-perlinterp\n#CONF_OPT_PERL = --enable-perlinterp=dynamic\n\n# PYTHON\n# Uncomment lines here when you want to include the Python interface.\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n# NOTE: This may cause threading to be enabled, which has side effects (such\n# as using different libraries and debugging becomes more difficult).\n# For Python3 support make a symbolic link in /usr/local/bin:\n#\tln -s python3 python3.1\n# If both python2.x and python3.x are enabled then the linking will be via\n# dlopen(), dlsym(), dlclose(), i.e. pythonX.Y.so must be available\n# However, this may still cause problems, such as \"import termios\" failing.\n# Build two separate versions of Vim in that case.\n#CONF_OPT_PYTHON = --enable-pythoninterp\n#CONF_OPT_PYTHON = --enable-pythoninterp=dynamic\n#CONF_OPT_PYTHON3 = --enable-python3interp\n#CONF_OPT_PYTHON3 = --enable-python3interp=dynamic\n\n# RUBY\n# Uncomment this when you want to include the Ruby interface.\n# First one for static linking, second one for loading when used.\n# Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n#CONF_OPT_RUBY = --enable-rubyinterp\n#CONF_OPT_RUBY = --enable-rubyinterp=dynamic\n#CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1\n\n# TCL\n# Uncomment this when you want to include the Tcl interface.\n# First one is for static linking, second one for dynamic loading.\n#CONF_OPT_TCL = --enable-tclinterp\n#CONF_OPT_TCL = --enable-tclinterp=dynamic\n#CONF_OPT_TCL = --enable-tclinterp --with-tclsh=tclsh8.4\n\n# CSCOPE\n# Uncomment this when you want to include the Cscope interface.\n#CONF_OPT_CSCOPE = --enable-cscope\n\n# WORKSHOP - Sun Visual Workshop interface.  Only works with Motif!\n#CONF_OPT_WORKSHOP = --enable-workshop\n\n# NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.\n# Motif version must have XPM libraries (see |workshop-xpm|).\n# Uncomment this when you do not want the netbeans interface.\n#CONF_OPT_NETBEANS = --disable-netbeans\n\n# CHANNEL - inter process communication. Same conditions as NetBeans.\n# Uncomment this when you do not want inter process communication.\n#CONF_OPT_CHANNEL = --disable-channel\n\n# TERMINAL - Terminal emulator support, :terminal command.  Requires the\n# channel feature. The default is enable for when using \"huge\" features.\n# Uncomment the first line when you want terminal emulator support for\n# not-huge builds.  Uncomment the second line when you don't want terminal\n# emulator support in the huge build.\n#CONF_OPT_TERMINAL = --enable-terminal\n#CONF_OPT_TERMINAL = --disable-terminal\n\n# MULTIBYTE - To edit multi-byte characters.\n# Uncomment this when you want to edit a multibyte language.\n# It's automatically enabled with normal features, GTK or IME support.\n# Note: Compile on a machine where setlocale() actually works, otherwise the\n# configure tests may fail.\n#CONF_OPT_MULTIBYTE = --enable-multibyte\n\n# NLS - National Language Support\n# Uncomment this when you do not want to support translated messages, even\n# though configure can find support for it.\n#CONF_OPT_NLS = --disable-nls\n\n# XIM - X Input Method.  Special character input support for X11 (Chinese,\n# Japanese, special symbols, etc).  Also needed for dead-key support.\n# When omitted it's automatically enabled for the X-windows GUI.\n# HANGUL - Input Hangul (Korean) language using internal routines.\n# Uncomment one of these when you want to input a multibyte language.\n#CONF_OPT_INPUT = --enable-xim\n#CONF_OPT_INPUT = --disable-xim\n#CONF_OPT_INPUT = --enable-hangulinput\n\n# FONTSET - X fontset support for output of languages with many characters.\n# Uncomment this when you want to output a multibyte language.\n#CONF_OPT_OUTPUT = --enable-fontset\n\n# ACL - Uncomment this when you do not want to include ACL support, even\n# though your system does support it.  E.g., when it's buggy.\n#CONF_OPT_ACL = --disable-acl\n\n# gpm - For mouse support on Linux console via gpm\n# Uncomment this when you do not want to include gpm support, even\n# though you have gpm libraries and includes.\n#CONF_OPT_GPM = --disable-gpm\n\n# sysmouse - For mouse support on FreeBSD and DragonFly console via sysmouse\n# Uncomment this when you do not want do include sysmouse support, even\n# though you have /dev/sysmouse and includes.\n#CONF_OPT_SYSMOUSE = --disable-sysmouse\n\n# FEATURES - For creating Vim with more or less features\n# Uncomment one of these lines when you want to include few to many features.\n# The default is \"huge\" for most systems.\n#CONF_OPT_FEAT = --with-features=tiny\n#CONF_OPT_FEAT = --with-features=small\n#CONF_OPT_FEAT = --with-features=normal\n#CONF_OPT_FEAT = --with-features=big\n#CONF_OPT_FEAT = --with-features=huge\n\n# COMPILED BY - For including a specific e-mail address for \":version\".\n#CONF_OPT_COMPBY = \"--with-compiledby=John Doe <JohnDoe@yahoo.com>\"\n\n# X WINDOWS DISABLE - For creating a plain Vim without any X11 related fancies\n# (otherwise Vim configure will try to include xterm titlebar access)\n# Also disable the GUI above, otherwise it will be included anyway.\n# When both GUI and X11 have been disabled this may save about 15% of the\n# code and make Vim startup quicker.\n#CONF_OPT_X = --without-x\n\n# X WINDOWS DIRECTORY - specify X directories\n# If configure can't find you X stuff, or if you have multiple X11 derivatives\n# installed, you may wish to specify which one to use.\n# Select nothing to let configure choose.\n# This here selects openwin (as found on sun).\n#XROOT = /usr/openwin\n#CONF_OPT_X = --x-include=$(XROOT)/include --x-libraries=$(XROOT)/lib\n\n# X11 Session Management Protocol support\n# Vim will try to use XSMP to catch the user logging out if there are unsaved\n# files.  Uncomment this line to disable that (it prevents vim trying to open\n# communications with the session manager).\n#CONF_OPT_XSMP = --disable-xsmp\n\n# You may wish to include xsmp but use exclude xsmp-interact if the logout\n# XSMP functionality does not work well with your session-manager (at time of\n# writing, this would be early GNOME-1 gnome-session: it 'freezes' other\n# applications after Vim has cancelled a logout (until Vim quits).  This\n# *might* be the Vim code, but is more likely a bug in early GNOME-1.\n# This disables the dialog that asks you if you want to save files or not.\n#CONF_OPT_XSMP = --disable-xsmp-interact\n\n# COMPILER - Name of the compiler {{{1\n# The default from configure will mostly be fine, no need to change this, just\n# an example. If a compiler is defined here, configure will use it rather than\n# probing for one. It is dangerous to change this after configure was run.\n# Make will use your choice then -- but beware: Many things may change with\n# another compiler.  It is wise to run 'make reconfig' to start all over\n# again.\n#CC = cc\n#CC = gcc\n#CC = clang\n\n# COMPILER FLAGS - change as you please. Either before running {{{1\n# configure or afterwards. For examples see below.\n# When using -g with some older versions of Linux you might get a\n# statically linked executable.\n# When not defined, configure will try to use -O2 -g for gcc and -O for cc.\n#CFLAGS = -g\n#CFLAGS = -O\n\n# Optimization limits - depends on the compiler.  Automatic check in configure\n# doesn't work very well, because many compilers only give a warning for\n# unrecognized arguments.\n#CFLAGS = -O -OPT:Olimit=2600\n#CFLAGS = -O -Olimit 2000\n#CFLAGS = -O -FOlimit,2000\n\n# Often used for GCC: mixed optimizing, lot of optimizing, debugging\n#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes\n#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wmissing-prototypes\n#CFLAGS = -g -Wall -Wmissing-prototypes\n#CFLAGS = -O6 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes\n#CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes\n#CFLAGS = -g -O2 '-DSTARTUPTIME=\"vimstartup\"' -fno-strength-reduce -Wall -Wmissing-prototypes\n\n# Use this with GCC to check for mistakes, unused arguments, etc.\n#CFLAGS = -g -Wall -Wextra -Wshadow -Wmissing-prototypes -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1\n# Add -Wpedantic to find // comments and other C99 constructs.\n# Better disable Perl and Python to avoid a lot of warnings.\n#CFLAGS = -g -Wall -Wextra -Wshadow -Wmissing-prototypes -Wpedantic -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1\n#CFLAGS = -g -O2 -Wall -Wextra -Wmissing-prototypes -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -DU_DEBUG\n#PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers\n#MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter\n\n# EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond\n# allocated memory (and makes every malloc()/free() very slow).\n# Electric Fence is free (search ftp sites).\n# You may want to set the EF_PROTECT_BELOW environment variable to check the\n# other side of allocated memory.\n# On FreeBSD you might need to enlarge the number of mmaps allowed.  Do this\n# as root: sysctl -w vm.max_proc_mmap=30000\n#EXTRA_LIBS = /usr/local/lib/libefence.a\n\n# Autoconf binary.\nAUTOCONF = autoconf\n\n# PURIFY - remove the # to use the \"purify\" program (hoi Nia++!)\n#PURIFY = purify\n\n# VALGRIND - remove the # to use valgrind for memory leaks and access errors.\n#\t     Used for the unittest targets.\n# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=25 --log-file=valgrind.$@\n\n# NBDEBUG - debugging the netbeans interface.\n#EXTRA_DEFS = -DNBDEBUG\n\n# }}}\n\n# LINT - for running lint\n#  For standard Unix lint\nLINT = lint\nLINT_OPTIONS = -beprxzF\n#  For splint\n#  It doesn't work well, crashes on include files and non-ascii characters.\n#LINT = splint\n#LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999\n\n# PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.\n# Might not work with GUI or Perl.\n# For unknown reasons adding \"-lc\" fixes a linking problem with some versions\n# of GCC.  That's probably a bug in the \"-pg\" implementation.\n# After running Vim see the profile result with: gprof vim gmon.out | vim -\n# Need to recompile everything after changing this: \"make clean\" \"make\".\n#PROFILE_CFLAGS = -pg -g -DWE_ARE_PROFILING\n#PROFILE_LIBS = -pg\n#PROFILE_LIBS = -pg -lc\n\n\n# TEST COVERAGE - Uncomment the two lines below the explanation to get code\n# coverage information. (provided by Yegappan Lakshmanan)\n# 1. make clean, run configure and build Vim as usual.\n# 2. Generate the baseline code coverage information:\n#\t$ lcov -c -i -b . -d objects -o objects/coverage_base.info\n# 3. Run \"make test\" to run the unit tests.  The code coverage information will\n#    be generated in the src/objects directory.\n# 4. Generate the code coverage information from the tests:\n#\t$ lcov -c -b . -d objects/ -o objects/coverage_test.info\n# 5. Combine the baseline and test code coverage data:\n#\t$ lcov -a objects/coverage_base.info -a objects/coverage_test.info -o objects/coverage_total.info\n# 6. Process the test coverage data and generate a report in html:\n#\t$ genhtml objects/coverage_total.info -o objects\n# 7. Open the objects/index.html file in a web browser to view the coverage\n#    information.\n#\n# PROFILE_CFLAGS=-g -O0 -fprofile-arcs -ftest-coverage\n# LDFLAGS=--coverage\n\n\n# Uncomment one of the next two lines to compile Vim with the\n# address sanitizer or with the undefined sanitizer.  Works with gcc and\n# clang.  May make Vim twice as slow.  Errors reported on stderr.\n# More at: https://code.google.com/p/address-sanitizer/\n#SANITIZER_CFLAGS = -g -O0 -fsanitize=address -fno-omit-frame-pointer\n#SANITIZER_CFLAGS = -g -O0 -fsanitize=undefined -fno-omit-frame-pointer\nSANITIZER_LIBS = $(SANITIZER_CFLAGS)\n\n# MEMORY LEAK DETECTION\n# Requires installing the ccmalloc library.\n# Configuration is in the .ccmalloc or ~/.ccmalloc file.\n# Doesn't work very well, since memory linked to from global variables\n# (in libraries) is also marked as leaked memory.\n#LEAK_CFLAGS = -DEXITFREE\n#LEAK_LIBS = -lccmalloc\n\n# Uncomment this line to have Vim call abort() when an internal error is\n# detected.  Useful when using a tool to find errors.\n#ABORT_CLFAGS = -DABORT_ON_INTERNAL_ERROR\n\n#####################################################\n###  Specific systems, check if yours is listed!  ### {{{\n#####################################################\n\n### Uncomment things here only if the values chosen by configure are wrong.\n### It's better to adjust configure.ac and \"make autoconf\", if you can!\n### Then send the required changes to configure.ac to the bugs list.\n\n### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries\n###\n#CC = shlicc2\n#CFLAGS = -O2 -g -m486 -Wall -Wshadow -Wmissing-prototypes -fno-builtin\n\n### (2) HP-UX with a non-ANSI cc, use the c89 ANSI compiler\n###\tThe first probably works on all systems\n###\tThe second should work a bit better on newer systems\n###\tThe third should work a bit better on HPUX 11.11\n###\tInformation provided by: Richard Allen <ra@rhi.hi.is>\n#CC = c89 -D_HPUX_SOURCE\n#CC = c89 -O +Onolimit +ESlit -D_HPUX_SOURCE\n#CC = c89 -O +Onolimit +ESlit +e -D_HPUX_SOURCE\n\n### (2) For HP-UX: Enable the use of a different set of digraphs.  Use this\n###\twhen the default (ISO) digraphs look completely wrong.\n###\tAfter changing this do \"touch digraph.c; make\".\n#EXTRA_DEFS = -DHPUX_DIGRAPHS\n\n### (2) For HP-UX: 9.04 cpp default macro definition table of 128000 bytes\n###\tis too small to compile many routines.\tIt produces too much defining\n###\tand no space errors.\n###\tUncomment the following to specify a larger macro definition table.\n#CFLAGS = -Wp,-H256000\n\n### (2) For HP-UX 10.20 using the HP cc, with X11R6 and Motif 1.2, with\n###\tlibraries in /usr/lib instead of /lib (avoiding transition links).\n###\tInformation provided by: David Green\n#XROOT = /usr\n#CONF_OPT_X = --x-include=$(XROOT)/include/X11R6 --x-libraries=$(XROOT)/lib/X11R6\n#GUI_INC_LOC = -I/usr/include/Motif1.2\n#GUI_LIB_LOC = -L/usr/lib/Motif1.2_R6\n\n### (5) AIX 4.1.4 with cc\n#CFLAGS = -O -qmaxmem=8192\n\n###     AIX with c89 (Walter Briscoe)\n#CC = c89\n#CPPFLAGS = -D_ALL_SOURCE\n\n###     AIX 4.3.3.12 with xic 3.6.6 (David R. Favor)\n#       needed to avoid a problem where strings.h gets included\n#CFLAGS = -qsrcmsg -O2 -qmaxmem=8192 -D__STR31__\n\n### (W) Solaris with multi-threaded libraries (-lthread):\n###\tIf suspending doesn't work properly, try using this line:\n#EXTRA_DEFS = -D_REENTRANT\n\n### (7) Solaris 2.4/2.5 with Centerline compiler\n#CC = clcc\n#X_LIBS_DIR = -L/usr/openwin/lib -R/usr/openwin/lib\n#CFLAGS = -O\n\n### (9) Solaris 2.x with cc (SunPro), using Athena.\n###\tOnly required for compiling gui_at_sb.c.\n###\tSymptom: \"identifier redeclared: vim_XawScrollbarSetThumb\"\n###\tUse one of the lines (either Full ANSI or no ANSI at all)\n#CFLAGS = $(CFLAGS) -Xc\n#CFLAGS = $(CFLAGS) -Xs\n\n### Solaris 2.3 with X11 and specific cc\n#CC=/opt/SUNWspro/bin/cc -O -Xa -v -R/usr/openwin/lib\n\n### Solaris with /usr/ucb/cc (it is rejected by autoconf as \"cc\")\n#CC\t    = /usr/ucb/cc\n#EXTRA_LIBS = -R/usr/ucblib\n\n### Solaris with Forte Developer and FEAT_SUN_WORKSHOP\n# The Xpm library is available from http://koala.ilog.fr/ftp/pub/xpm.\n#CC\t\t= cc\n#XPM_DIR\t\t= /usr/local/xpm/xpm-3.4k-solaris\n#XPM_LIB\t\t= -L$(XPM_DIR)/lib -R$(XPM_DIR)/lib -lXpm\n#XPM_IPATH\t= -I$(XPM_DIR)/include\n#EXTRA_LIBS\t= $(XPM_LIB)\n#EXTRA_IPATHS\t= $(XPM_IPATH)\n#EXTRA_DEFS\t= -xCC -DHAVE_X11_XPM_H\n\n### Solaris with workshop compilers: Vim is unstable when compiled with\n# \"-fast\".  Use this instead. (Shea Martin)\n#CFLAGS = -x02 -xtarget=ultra\n\n### (R) for Solaris 2.5 (or 2.5.1) with gcc > 2.5.6 you might need this:\n#LDFLAGS = -lw -ldl -lXmu\n#GUI_LIB_LOC = -L/usr/local/lib\n\n### (8) Unisys 6035 (Glauber Ribeiro)\n#EXTRA_LIBS = -lnsl -lsocket -lgen\n\n### When builtin functions cause problems with gcc (for Sun 4.1.x)\n#CFLAGS = -O2 -Wall -traditional -Wno-implicit\n\n### Apollo DOMAIN (with SYSTYPE = bsd4.3) (TESTED for version 3.0)\n#EXTRA_DEFS = -DDOMAIN\n#CFLAGS= -O -A systype,bsd4.3\n\n### Coherent 4.2.10 on Intel 386 platform\n#EXTRA_DEFS = -Dvoid=int\n#EXTRA_LIBS = -lterm -lsocket\n\n### SCO 3.2, with different library name for terminfo\n#EXTRA_LIBS = -ltinfo\n\n### UTS2 for Amdahl UTS 2.1.x\n#EXTRA_DEFS = -DUTS2\n#EXTRA_LIBS = -lsocket\n\n### UTS4 for Amdahl UTS 4.x\n#EXTRA_DEFS = -DUTS4 -Xa\n\n### USL for Unix Systems Laboratories (SYSV 4.2)\n#EXTRA_DEFS = -DUSL\n\n### (6)  A/UX 3.1.1 with gcc (Jim Jagielski)\n#CC= gcc -D_POSIX_SOURCE\n#CFLAGS= -O2\n#EXTRA_LIBS = -lposix -lbsd -ltermcap -lX11\n\n### (A)  Some versions of SCO Open Server 5 (Jan Christiaan van Winkel)\n###\t Also use the CONF_TERM_LIB below!\n#EXTRA_LIBS = -lgen\n\n### (D)  QNX (by G.F. Desrochers)\n#CFLAGS = -g -O -mf -4\n\n### (F)  QNX (by John Oleynick)\n# 1. If you don't have an X server: Comment out CONF_OPT_GUI and uncomment\n#    CONF_OPT_X = --without-x.\n# 2. make config\n# 3. edit auto/config.mk and remove -ldir and -ltermcap from LIBS.  It doesn't\n#\thave -ldir (does config find it somewhere?) and -ltermcap has at\n#\tleast one problem so I use termlib.o instead.  The problem with\n#\ttermcap is that it segfaults if you call it with the name of\n#\ta non-existent terminal type.\n# 4. edit auto/config.h and add #define USE_TMPNAM\n# 5. add termlib.o to OBJ\n# 6. make\n\n### (H)  for Data general DG/UX 5.4.2 and 5.4R3.10 (Jonas J. Schlein)\n#EXTRA_LIBS = -lgen\n\n### (I) SINIX-N 5.42 or 5.43 RM400 R4000 (also SINIX-Y and SINIX-Z)\n#EXTRA_LIBS = -lgen -lnsl\n###   For SINIX-Y this is needed for the right prototype of gettimeofday()\n#EXTRA_DEFS = -D_XPG_IV\n\n### (I) Reliant-Unix (aka SINIX) 5.44 with standard cc\n#\tUse both \"-F O3\" lines for optimization or the \"-g\" line for debugging\n#EXTRA_LIBS = -lgen -lsocket -lnsl -lSM -lICE\n#CFLAGS = -F O3 -DSINIXN\n#LDFLAGS = -F O3\n#CFLAGS = -g -DSINIXN\n\n### (P)  SCO 3.2.42, with different termcap names for some useful keys DJB\n#EXTRA_DEFS = -DSCOKEYS -DNETTERM_MOUSE -DDEC_MOUSE -DXTERM_MOUSE -DHAVE_GETTIMEOFDAY\n#EXTRA_LIBS = -lsocket -ltermcap -lmalloc -lc_s\n\n### (P)  SuperUX 6.2 on NEC SX-4 (Lennart Schultz)\n#GUI_INC_LOC = -I/usr/include\n#GUI_LIB_LOC = -L/usr/lib\n#EXTRA_LIBS = -lgen\n\n### (Q) UNIXSVR 4.2MP on NEC UP4800 (Lennart Schultz)\n#GUI_INC_LOC = -I/usr/necccs/include\n#GUI_LIB_LOC = -L/usr/necccs/lib/X11R6\n#XROOT = /usr/necccs\n#CONF_OPT_X = --x-include=$(XROOT)/include --x-libraries=$(XROOT)/lib/X11R6\n#EXTRA_LIBS = -lsocket -lgen\n\n### Irix 4.0 & 5.2 (Silicon Graphics Machines, __sgi will be defined)\n# Not needed for Irix 5.3, Ives Aerts reported\n#EXTRA_LIBS = -lmalloc -lc_s\n# Irix 4.0, when regexp and regcmp cannot be found when linking:\n#EXTRA_LIBS = -lmalloc -lc_s -lPW\n\n### (S) Irix 6.x (MipsPro compiler): Uses different Olimit flag:\n# Note:\tThis newer option style is used with the MipsPro compilers ONLY if\n#\tyou are compiling an \"n32\" or \"64\" ABI binary (use either a -n32\n#\tflag or a -64 flag for CFLAGS).  If you explicitly use a -o32 flag,\n#\tthen the CFLAGS option format will be the typical style (i.e.\n#\t-Olimit 3000).\n#CFLAGS = -OPT:Olimit=3000 -O\n\n### (S) Irix 6.5 with MipsPro C compiler.  Try this as a test to see new\n#\tcompiler features!  Beware, the optimization is EXTREMELY thorough\n#\tand takes quite a long time.\n# Note: See the note above.  Here, the -mips3 option automatically\n#\tenables either the \"n32\" or \"64\" ABI, depending on what machine you\n#\tare compiling on (n32 is explicitly enabled here, just to make sure).\n#CFLAGS = -OPT:Olimit=3500 -O -n32 -mips3 -IPA:aggr_cprop=ON -INLINE:dfe=ON:list=ON:must=screen_char,out_char,ui_write,out_flush\n#LDFLAGS= -OPT:Olimit=3500 -O -n32 -mips3 -IPA:aggr_cprop=ON -INLINE:dfe=ON:list=ON:must=screen_char,out_char,ui_write,out_flush\n\n### (K) for SGI Irix machines with 64 bit pointers (\"uname -s\" says IRIX64)\n###\tSuggested by Jon Wright <jon@gate.sinica.edu.tw>.\n###\tTested on R8000 IRIX6.1 Power Indigo2.\n###\tCheck /etc/compiler.defaults for your compiler settings.\n# either (for 64 bit pointers) uncomment the following line\n#GUI_LIB_LOC = -L/usr/lib64\n# then\n# 1) make config\n# 2) edit auto/config.mk and delete the -lelf entry in the LIBS line\n# 3) make\n#\n# or (for 32bit pointers) uncomment the following line\n#EXTRA_DEFS = -n32\n#GUI_LIB_LOC = -L/usr/lib32\n# then\n# 1) make config\n# 2) edit auto/config.mk, add -n32 to LDFLAGS\n# 3) make\n#\n#Alternatively: use -o32 instead of -n32.\n###\n\n### (C)  On SCO Unix v3.2.5 (and probably other versions) the termcap library,\n###\t which is found by configure, doesn't work correctly.  Symptom is the\n###\t error message \"Termcap entry too long\".  Uncomment the next line.\n###\t On AIX 4.2.1 (and other versions probably), libtermcap is reported\n###\t not to display properly.\n### after changing this, you need to do \"make reconfig\".\n#CONF_TERM_LIB = --with-tlib=curses\n\n### (E)  If you want to use termlib library instead of the automatically found\n###\t one.  After changing this, you need to do \"make reconfig\".\n#CONF_TERM_LIB = --with-tlib=termlib\n\n### (a)  ESIX V4.2 (Reinhard Wobst)\n#EXTRA_LIBS = -lnsl -lsocket -lgen -lXIM -lXmu -lXext\n\n### (c)  Tandem/NSK (Matthew Woehlke)\n#EXTRA_LIBS = -lfloss\n\n### If you want to use ncurses library instead of the automatically found one\n### after changing this, you need to do \"make reconfig\".\n#CONF_TERM_LIB = --with-tlib=ncurses\n\n### For GCC on MS-Windows, the \".exe\" suffix will be added.\n#EXEEXT = .exe\n#LNKEXT = .exe\n\n### (O)  For LynxOS 2.5.0, tested on PC.\n#EXTRA_LIBS = -lXext -lSM -lICE -lbsd\n###\t For LynxOS 3.0.1, tested on PPC\n#EXTRA_LIBS= -lXext -lSM -lICE -lnetinet -lXmu -liberty -lX11\n###\t For LynxOS 3.1.0, tested on PC\n#EXTRA_LIBS= -lXext -lSM -lICE -lnetinet -lXmu\n\n\n### (V)  For CX/UX 6.2\t(on Harris/Concurrent NightHawk 4800, 5800). Remove\n###\t -Qtarget if only in a 5800 environment.  (Kipp E. Howard)\n#CFLAGS = -O -Qtarget=m88110compat\n#EXTRA_LIBS = -lgen\n\n# The value of QUOTESED comes from auto/config.mk.\n# Uncomment the next line to use the default value.\n# QUOTESED = sed -e 's/[\\\\\"]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";$$/\";/'\n\n##################### end of system specific lines ################### }}}\n\n### Names of the programs and targets  {{{1\nVIMTARGET\t= $(VIMNAME)$(EXEEXT)\nEXTARGET\t= $(EXNAME)$(LNKEXT)\nVIEWTARGET\t= $(VIEWNAME)$(LNKEXT)\nGVIMNAME\t= g$(VIMNAME)\nGVIMTARGET\t= $(GVIMNAME)$(LNKEXT)\nGVIEWNAME\t= g$(VIEWNAME)\nGVIEWTARGET\t= $(GVIEWNAME)$(LNKEXT)\nRVIMNAME\t= r$(VIMNAME)\nRVIMTARGET\t= $(RVIMNAME)$(LNKEXT)\nRVIEWNAME\t= r$(VIEWNAME)\nRVIEWTARGET\t= $(RVIEWNAME)$(LNKEXT)\nRGVIMNAME\t= r$(GVIMNAME)\nRGVIMTARGET\t= $(RGVIMNAME)$(LNKEXT)\nRGVIEWNAME\t= r$(GVIEWNAME)\nRGVIEWTARGET\t= $(RGVIEWNAME)$(LNKEXT)\nVIMDIFFNAME\t= $(VIMNAME)diff\nGVIMDIFFNAME\t= g$(VIMDIFFNAME)\nVIMDIFFTARGET\t= $(VIMDIFFNAME)$(LNKEXT)\nGVIMDIFFTARGET\t= $(GVIMDIFFNAME)$(LNKEXT)\nEVIMNAME\t= e$(VIMNAME)\nEVIMTARGET\t= $(EVIMNAME)$(LNKEXT)\nEVIEWNAME\t= e$(VIEWNAME)\nEVIEWTARGET\t= $(EVIEWNAME)$(LNKEXT)\n\n### Names of the tools that are also made  {{{1\nTOOLS = xxd/xxd$(EXEEXT)\n\n### Installation directories.  The defaults come from configure. {{{1\n#\n### prefix\tthe top directory for the data (default \"/usr/local\")\n#\n# Uncomment the next line to install Vim in your home directory.\n#prefix = $(HOME)\n\n### exec_prefix\tis the top directory for the executable (default $(prefix))\n#\n# Uncomment the next line to install the Vim executable in \"/usr/machine/bin\"\n#exec_prefix = /usr/machine\n\n### BINDIR\tdir for the executable\t (default \"$(exec_prefix)/bin\")\n### MANDIR\tdir for the manual pages (default \"$(prefix)/man\")\n### DATADIR\tdir for the other files  (default \"$(prefix)/lib\" or\n#\t\t\t\t\t\t  \"$(prefix)/share\")\n# They may be different when using different architectures for the\n# executable and a common directory for the other files.\n#\n# Uncomment the next line to install Vim in \"/usr/bin\"\n#BINDIR   = /usr/bin\n# Uncomment the next line to install Vim manuals in \"/usr/share/man/man1\"\n#MANDIR   = /usr/share/man\n# Uncomment the next line to install Vim help files in \"/usr/share/vim\"\n#DATADIR  = /usr/share\n\n### DESTDIR\troot of the installation tree.  This is prepended to the other\n#\t\tdirectories.  This directory must exist.\n#DESTDIR  = ~/pkg/vim\n\n### Directory of the man pages\nMAN1DIR = /man1\n\n### Vim version (adjusted by a script)\nVIMMAJOR = 8\nVIMMINOR = 0\n\n### Location of Vim files (should not need to be changed, and  {{{1\n### some things might not work when they are changed!)\nVIMDIR = /vim\nVIMRTDIR = /vim$(VIMMAJOR)$(VIMMINOR)\nHELPSUBDIR = /doc\nCOLSUBDIR = /colors\nSYNSUBDIR = /syntax\nINDSUBDIR = /indent\nAUTOSUBDIR = /autoload\nPLUGSUBDIR = /plugin\nFTPLUGSUBDIR = /ftplugin\nLANGSUBDIR = /lang\nCOMPSUBDIR = /compiler\nKMAPSUBDIR = /keymap\nMACROSUBDIR = /macros\nPACKSUBDIR = /pack\nTOOLSSUBDIR = /tools\nTUTORSUBDIR = /tutor\nSPELLSUBDIR = /spell\nPRINTSUBDIR = /print\nPODIR = po\n\n### VIMLOC\tcommon root of the Vim files (all versions)\n### VIMRTLOC\tcommon root of the runtime Vim files (this version)\n### VIMRCLOC\tcompiled-in location for global [g]vimrc files (all versions)\n### VIMRUNTIMEDIR  compiled-in location for runtime files (optional)\n### HELPSUBLOC\tlocation for help files\n### COLSUBLOC\tlocation for colorscheme files\n### SYNSUBLOC\tlocation for syntax files\n### INDSUBLOC\tlocation for indent files\n### AUTOSUBLOC\tlocation for standard autoload files\n### PLUGSUBLOC\tlocation for standard plugin files\n### FTPLUGSUBLOC  location for ftplugin files\n### LANGSUBLOC\tlocation for language files\n### COMPSUBLOC\tlocation for compiler files\n### KMAPSUBLOC\tlocation for keymap files\n### MACROSUBLOC\tlocation for macro files\n### PACKSUBLOC\tlocation for packages\n### TOOLSSUBLOC\tlocation for tools files\n### TUTORSUBLOC\tlocation for tutor files\n### SPELLSUBLOC\tlocation for spell files\n### PRINTSUBLOC\tlocation for PostScript files (prolog, latin1, ..)\n### SCRIPTLOC\tlocation for script files (menu.vim, bugreport.vim, ..)\n### You can override these if you want to install them somewhere else.\n### Edit feature.h for compile-time settings.\nVIMLOC\t\t= $(DATADIR)$(VIMDIR)\nVIMRTLOC\t= $(DATADIR)$(VIMDIR)$(VIMRTDIR)\nVIMRCLOC\t= $(VIMLOC)\nHELPSUBLOC\t= $(VIMRTLOC)$(HELPSUBDIR)\nCOLSUBLOC\t= $(VIMRTLOC)$(COLSUBDIR)\nSYNSUBLOC\t= $(VIMRTLOC)$(SYNSUBDIR)\nINDSUBLOC\t= $(VIMRTLOC)$(INDSUBDIR)\nAUTOSUBLOC\t= $(VIMRTLOC)$(AUTOSUBDIR)\nPLUGSUBLOC\t= $(VIMRTLOC)$(PLUGSUBDIR)\nFTPLUGSUBLOC\t= $(VIMRTLOC)$(FTPLUGSUBDIR)\nLANGSUBLOC\t= $(VIMRTLOC)$(LANGSUBDIR)\nCOMPSUBLOC\t= $(VIMRTLOC)$(COMPSUBDIR)\nKMAPSUBLOC\t= $(VIMRTLOC)$(KMAPSUBDIR)\nMACROSUBLOC\t= $(VIMRTLOC)$(MACROSUBDIR)\nPACKSUBLOC\t= $(VIMRTLOC)$(PACKSUBDIR)\nTOOLSSUBLOC\t= $(VIMRTLOC)$(TOOLSSUBDIR)\nTUTORSUBLOC\t= $(VIMRTLOC)$(TUTORSUBDIR)\nSPELLSUBLOC\t= $(VIMRTLOC)$(SPELLSUBDIR)\nPRINTSUBLOC\t= $(VIMRTLOC)$(PRINTSUBDIR)\nSCRIPTLOC\t= $(VIMRTLOC)\n\n### Only set VIMRUNTIMEDIR when VIMRTLOC is set to a different location and\n### the runtime directory is not below it.\n#VIMRUNTIMEDIR = $(VIMRTLOC)\n\n### Name of the defaults/evim/mswin file target.\nVIM_DEFAULTS_FILE = $(DESTDIR)$(SCRIPTLOC)/defaults.vim\nEVIM_FILE\t= $(DESTDIR)$(SCRIPTLOC)/evim.vim\nMSWIN_FILE\t= $(DESTDIR)$(SCRIPTLOC)/mswin.vim\n\n### Name of the menu file target.\nSYS_MENU_FILE\t= $(DESTDIR)$(SCRIPTLOC)/menu.vim\nSYS_SYNMENU_FILE = $(DESTDIR)$(SCRIPTLOC)/synmenu.vim\nSYS_DELMENU_FILE = $(DESTDIR)$(SCRIPTLOC)/delmenu.vim\n\n### Name of the bugreport file target.\nSYS_BUGR_FILE\t= $(DESTDIR)$(SCRIPTLOC)/bugreport.vim\n\n### Name of the rgb.txt file target.\nSYS_RGB_FILE   = $(DESTDIR)$(SCRIPTLOC)/rgb.txt\n\n### Name of the file type detection file target.\nSYS_FILETYPE_FILE = $(DESTDIR)$(SCRIPTLOC)/filetype.vim\n\n### Name of the file type detection file target.\nSYS_FTOFF_FILE\t= $(DESTDIR)$(SCRIPTLOC)/ftoff.vim\n\n### Name of the file type detection script file target.\nSYS_SCRIPTS_FILE = $(DESTDIR)$(SCRIPTLOC)/scripts.vim\n\n### Name of the ftplugin-on file target.\nSYS_FTPLUGIN_FILE = $(DESTDIR)$(SCRIPTLOC)/ftplugin.vim\n\n### Name of the ftplugin-off file target.\nSYS_FTPLUGOF_FILE = $(DESTDIR)$(SCRIPTLOC)/ftplugof.vim\n\n### Name of the indent-on file target.\nSYS_INDENT_FILE = $(DESTDIR)$(SCRIPTLOC)/indent.vim\n\n### Name of the indent-off file target.\nSYS_INDOFF_FILE = $(DESTDIR)$(SCRIPTLOC)/indoff.vim\n\n### Name of the option window script file target.\nSYS_OPTWIN_FILE = $(DESTDIR)$(SCRIPTLOC)/optwin.vim\n\n# Program to install the program in the target directory.  Could also be \"mv\".\nINSTALL_PROG\t= cp\n\n# Program to install the data in the target directory.\tCannot be \"mv\"!\nINSTALL_DATA\t= cp\nINSTALL_DATA_R\t= cp -r\n\n### Program to run on installed binary.  Use the second one to disable strip.\n#STRIP = strip\n#STRIP = /bin/true\n\n### Permissions for binaries  {{{1\nBINMOD = 755\n\n### Permissions for man page\nMANMOD = 644\n\n### Permissions for help files\nHELPMOD = 644\n\n### Permissions for Perl and shell scripts\nSCRIPTMOD = 755\n\n### Permission for Vim script files (menu.vim, bugreport.vim, ..)\nVIMSCRIPTMOD = 644\n\n### Permissions for all directories that are created\nDIRMOD = 755\n\n### Permissions for all other files that are created\nFILEMOD = 644\n\n# Where to copy the man and help files from\nHELPSOURCE = ../runtime/doc\n\n# Where to copy the script files from (menu, bugreport)\nSCRIPTSOURCE = ../runtime\n\n# Where to copy the colorscheme files from\nCOLSOURCE = ../runtime/colors\n\n# Where to copy the syntax files from\nSYNSOURCE = ../runtime/syntax\n\n# Where to copy the indent files from\nINDSOURCE = ../runtime/indent\n\n# Where to copy the standard plugin files from\nAUTOSOURCE = ../runtime/autoload\n\n# Where to copy the standard plugin files from\nPLUGSOURCE = ../runtime/plugin\n\n# Where to copy the ftplugin files from\nFTPLUGSOURCE = ../runtime/ftplugin\n\n# Where to copy the macro files from\nMACROSOURCE = ../runtime/macros\n\n# Where to copy the package files from\nPACKSOURCE = ../runtime/pack\n\n# Where to copy the tools files from\nTOOLSSOURCE = ../runtime/tools\n\n# Where to copy the tutor files from\nTUTORSOURCE = ../runtime/tutor\n\n# Where to copy the spell files from\nSPELLSOURCE = ../runtime/spell\n\n# Where to look for language specific files\nLANGSOURCE = ../runtime/lang\n\n# Where to look for compiler files\nCOMPSOURCE = ../runtime/compiler\n\n# Where to look for keymap files\nKMAPSOURCE = ../runtime/keymap\n\n# Where to look for print resource files\nPRINTSOURCE = ../runtime/print\n\n# If you are using Linux, you might want to use this to make vim the\n# default vi editor, it will create a link from vi to Vim when doing\n# \"make install\".  An existing file will be overwritten!\n# When not using it, some make programs can't handle an undefined $(LINKIT).\n#LINKIT = ln -f -s $(DEST_BIN)/$(VIMTARGET) $(DESTDIR)/usr/bin/vi\nLINKIT = @echo >/dev/null\n\n###\n### GRAPHICAL USER INTERFACE (GUI).  {{{1\n### 'configure --enable-gui' can enable one of these for you if you did set\n### a corresponding CONF_OPT_GUI above and have X11.\n### Override configures choice by uncommenting all the following lines.\n### As they are, the GUI is disabled.  Replace \"NONE\" with \"ATHENA\" or \"MOTIF\"\n### for enabling the Athena or Motif GUI.\n#GUI_SRC\t= $(NONE_SRC)\n#GUI_OBJ\t= $(NONE_OBJ)\n#GUI_DEFS\t= $(NONE_DEFS)\n#GUI_IPATH\t= $(NONE_IPATH)\n#GUI_LIBS_DIR\t= $(NONE_LIBS_DIR)\n#GUI_LIBS1\t= $(NONE_LIBS1)\n#GUI_LIBS2\t= $(NONE_LIBS2)\n#GUI_INSTALL    = $(NONE_INSTALL)\n#GUI_TARGETS\t= $(NONE_TARGETS)\n#GUI_MAN_TARGETS= $(NONE_MAN_TARGETS)\n#GUI_TESTTARGET = $(NONE_TESTTARGET)\n#GUI_BUNDLE\t= $(NONE_BUNDLE)\n\n# Without a GUI install the normal way.\nNONE_INSTALL = install_normal\n\n### GTK GUI\nGTK_SRC\t\t= gui.c gui_gtk.c gui_gtk_x11.c gui_gtk_f.c \\\n\t\t\tgui_beval.c $(GRESOURCE_SRC)\nGTK_OBJ\t\t= objects/gui.o objects/gui_gtk.o objects/gui_gtk_x11.o \\\n\t\t\tobjects/gui_gtk_f.o \\\n\t\t\tobjects/gui_beval.o $(GRESOURCE_OBJ)\nGTK_DEFS\t= -DFEAT_GUI_GTK $(NARROW_PROTO)\nGTK_IPATH\t= $(GUI_INC_LOC)\nGTK_LIBS_DIR\t= $(GUI_LIB_LOC)\nGTK_LIBS1\t=\nGTK_LIBS2\t= $(GTK_LIBNAME)\nGTK_INSTALL     = install_normal install_gui_extra\nGTK_TARGETS\t= installglinks\nGTK_MAN_TARGETS = yes\nGTK_TESTTARGET  = gui\nGTK_BUNDLE\t=\n\n### Motif GUI\nMOTIF_SRC\t= gui.c gui_motif.c gui_x11.c gui_beval.c \\\n\t\t\tgui_xmdlg.c gui_xmebw.c\nMOTIF_OBJ\t= objects/gui.o objects/gui_motif.o objects/gui_x11.o \\\n\t\t\tobjects/gui_beval.o \\\n\t\t\tobjects/gui_xmdlg.o objects/gui_xmebw.o\nMOTIF_DEFS\t= -DFEAT_GUI_MOTIF $(NARROW_PROTO)\nMOTIF_IPATH\t= $(GUI_INC_LOC)\nMOTIF_LIBS_DIR\t= $(GUI_LIB_LOC)\nMOTIF_LIBS1\t=\nMOTIF_LIBS2\t= $(MOTIF_LIBNAME) -lXt\nMOTIF_INSTALL   = install_normal install_gui_extra\nMOTIF_TARGETS\t= installglinks\nMOTIF_MAN_TARGETS = yes\nMOTIF_TESTTARGET = gui\nMOTIF_BUNDLE\t=\n\n### Athena GUI\n### Use Xaw3d to make the menus look a little bit nicer\n#XAW_LIB = -lXaw3d\nXAW_LIB = -lXaw\n\n### When using Xaw3d, uncomment/comment the following lines to also get the\n### scrollbars from Xaw3d.\n#ATHENA_SRC\t= gui.c gui_athena.c gui_x11.c gui_beval.c gui_at_fs.c\n#ATHENA_OBJ\t= objects/gui.o objects/gui_athena.o objects/gui_x11.o \\\n#\t\t\tobjects/gui_beval.o objects/gui_at_fs.o\n#ATHENA_DEFS\t= -DFEAT_GUI_ATHENA $(NARROW_PROTO) \\\n#\t\t    -Dvim_scrollbarWidgetClass=scrollbarWidgetClass \\\n#\t\t    -Dvim_XawScrollbarSetThumb=XawScrollbarSetThumb\nATHENA_SRC\t= gui.c gui_athena.c gui_x11.c gui_beval.c \\\n\t\t\tgui_at_sb.c gui_at_fs.c\nATHENA_OBJ\t= objects/gui.o objects/gui_athena.o objects/gui_x11.o \\\n\t\t\tobjects/gui_beval.o \\\n\t\t\tobjects/gui_at_sb.o objects/gui_at_fs.o\nATHENA_DEFS\t= -DFEAT_GUI_ATHENA $(NARROW_PROTO)\n\nATHENA_IPATH\t= $(GUI_INC_LOC)\nATHENA_LIBS_DIR = $(GUI_LIB_LOC)\nATHENA_LIBS1\t= $(XAW_LIB)\nATHENA_LIBS2\t= -lXt\nATHENA_INSTALL  = install_normal install_gui_extra\nATHENA_TARGETS\t= installglinks\nATHENA_MAN_TARGETS = yes\nATHENA_TESTTARGET = gui\nATHENA_BUNDLE\t=\n\n### neXtaw GUI\nNEXTAW_LIB = -lneXtaw\n\nNEXTAW_SRC\t= gui.c gui_athena.c gui_x11.c gui_beval.c gui_at_fs.c\nNEXTAW_OBJ\t= objects/gui.o objects/gui_athena.o objects/gui_x11.o \\\n\t\t\tobjects/gui_beval.o objects/gui_at_fs.o\nNEXTAW_DEFS\t= -DFEAT_GUI_ATHENA -DFEAT_GUI_NEXTAW $(NARROW_PROTO)\n\nNEXTAW_IPATH\t= $(GUI_INC_LOC)\nNEXTAW_LIBS_DIR = $(GUI_LIB_LOC)\nNEXTAW_LIBS1\t= $(NEXTAW_LIB)\nNEXTAW_LIBS2\t= -lXt\nNEXTAW_INSTALL  =  install_normal install_gui_extra\nNEXTAW_TARGETS\t=  installglinks\nNEXTAW_MAN_TARGETS = yes\nNEXTAW_TESTTARGET = gui\nNEXTAW_BUNDLE\t=\n\n### (J)  Sun OpenWindows 3.2 (SunOS 4.1.x) or earlier that produce these ld\n#\t errors:  ld: Undefined symbol\n#\t\t      _get_wmShellWidgetClass\n#\t\t      _get_applicationShellWidgetClass\n# then you need to get patches 100512-02 and 100573-03 from Sun.  In the\n# meantime, uncomment the following GUI_X_LIBS definition as a workaround:\n#GUI_X_LIBS = -Bstatic -lXmu -Bdynamic -lXext\n# If you also get cos, sin etc. as undefined symbols, try uncommenting this\n# too:\n#EXTRA_LIBS = /usr/openwin/lib/libXmu.sa -lm\n\n# PHOTON GUI\nPHOTONGUI_SRC\t= gui.c gui_photon.c\nPHOTONGUI_OBJ\t= objects/gui.o objects/gui_photon.o\nPHOTONGUI_DEFS\t= -DFEAT_GUI_PHOTON\nPHOTONGUI_IPATH\t=\nPHOTONGUI_LIBS_DIR =\nPHOTONGUI_LIBS1\t= -lph -lphexlib\nPHOTONGUI_LIBS2\t=\nPHOTONGUI_INSTALL = install_normal install_gui_extra\nPHOTONGUI_TARGETS = installglinks\nPHOTONGUI_MAN_TARGETS = yes\nPHOTONGUI_TESTTARGET = gui\nPHOTONGUI_BUNDLE =\n\n# CARBON GUI\nCARBONGUI_SRC\t= gui.c gui_mac.c\nCARBONGUI_OBJ\t= objects/gui.o objects/gui_mac.o\nCARBONGUI_DEFS\t= -DFEAT_GUI_MAC -fno-common -fpascal-strings \\\n\t\t  -Wall -Wno-unknown-pragmas \\\n\t\t  -mdynamic-no-pic -pipe\nCARBONGUI_IPATH\t= -I. -Iproto\nCARBONGUI_LIBS_DIR =\nCARBONGUI_LIBS1\t= -framework Carbon\nCARBONGUI_LIBS2\t=\nCARBONGUI_INSTALL = install_macosx\nCARBONGUI_TARGETS =\nCARBONGUI_MAN_TARGETS =\nCARBONGUI_TESTTARGET = gui\nCARBONGUI_BUNDLE = gui_bundle\nAPPDIR = $(VIMNAME).app\nCARBONGUI_TESTARG = VIMPROG=../$(APPDIR)/Contents/MacOS/$(VIMTARGET)\n\n# All GUI files\nALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c\nALL_GUI_PRO  = gui.pro gui_gtk.pro gui_motif.pro gui_xmdlg.pro gui_athena.pro gui_gtk_x11.pro gui_x11.pro gui_w32.pro gui_photon.pro\n\n# }}}\n\nTERM_DEPS = \\\n\tlibvterm/include/vterm.h \\\n\tlibvterm/include/vterm_keycodes.h \\\n\tlibvterm/src/rect.h \\\n\tlibvterm/src/utf8.h \\\n\tlibvterm/src/vterm_internal.h\n\n### Command to create dependencies based on #include \"...\"\n### prototype headers are ignored due to -DPROTO, system\n### headers #include <...> are ignored if we use the -MM option, as\n### e.g. provided by gcc-cpp.\n### Include FEAT_GUI to get dependency on gui.h\n### Need to change \"-I /<path>\" to \"-isystem /<path>\" for GCC 3.x.\nCPP_DEPEND = $(CC) -I$(srcdir) -M$(CPP_MM) \\\n\t\t`echo \"$(DEPEND_CFLAGS)\" $(DEPEND_CFLAGS_FILTER)`\n\n# flags for cproto\n#     This is for cproto 3 patchlevel 8 or below\n#     __inline, __attribute__ and __extension__ are not recognized by cproto\n#     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.\n#NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \\\n#\t  -D\"__attribute__\\\\(x\\\\)=\" -D\"__asm__\\\\(x\\\\)=\" \\\n#\t  -D__extension__= -D__restrict=\"\" \\\n#\t  -D__gnuc_va_list=char -D__builtin_va_list=char\n\n#\n#     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)\n#     __inline and __attribute__ are now recognized by cproto\n#     -D\"foo()=\" is not supported by all compilers so do not use it\nNO_ATTR=\n#\n# Use this for cproto 3 patchlevel 6 or below (use \"cproto -V\" to check):\n# PROTO_FLAGS = -f4 -d -E\"$(CPP)\" $(NO_ATTR)\n#\n# Use this for cproto 3 patchlevel 7 or above (use \"cproto -V\" to check):\nPROTO_FLAGS = -d -E\"$(CPP)\" $(NO_ATTR)\n\n\n################################################\n##   no changes required below this line      ##\n################################################\n\nSHELL = /bin/sh\n\n# We would normally use \"mkdir -p\" but it doesn't work properly everywhere.\n# Using AC_PROG_MKDIR_P in configure.ac has a problem with the \"auto\"\n# directory.  Always use the install-sh script, it's slower but reliable.\nMKDIR_P = $(SHELL) install-sh -c -d\n\n.SUFFIXES:\n.SUFFIXES: .c .o .pro\n\nPRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)\nPOST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)\n\nALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(ABORT_CLFAGS) $(POST_DEFS)\n\n# Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together\n# with \"-E\".\nOSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)\n\nLINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(TCL_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca\n\nLINT_EXTRA = -DHANGUL_INPUT -D\"__attribute__(x)=\"\n\nDEPEND_CFLAGS = -DPROTO -DDEPEND -DFEAT_GUI $(LINT_CFLAGS)\n\n# Note: MZSCHEME_LIBS must come before LIBS, because LIBS adds -lm which is\n# needed by racket.\nALL_LIB_DIRS = $(GUI_LIBS_DIR) $(X_LIBS_DIR)\nALL_LIBS = \\\n\t   $(GUI_LIBS1) \\\n\t   $(GUI_X_LIBS) \\\n\t   $(GUI_LIBS2) \\\n\t   $(X_PRE_LIBS) \\\n\t   $(X_LIBS) \\\n\t   $(X_EXTRA_LIBS) \\\n\t   $(MZSCHEME_LIBS) \\\n\t   $(LIBS) \\\n\t   $(EXTRA_LIBS) \\\n\t   $(LUA_LIBS) \\\n\t   $(PERL_LIBS) \\\n\t   $(PYTHON_LIBS) \\\n\t   $(PYTHON3_LIBS) \\\n\t   $(TCL_LIBS) \\\n\t   $(RUBY_LIBS) \\\n\t   $(PROFILE_LIBS) \\\n\t   $(SANITIZER_LIBS) \\\n\t   $(LEAK_LIBS)\n\n# abbreviations\nDEST_BIN = $(DESTDIR)$(BINDIR)\nDEST_VIM = $(DESTDIR)$(VIMLOC)\nDEST_RT = $(DESTDIR)$(VIMRTLOC)\nDEST_HELP = $(DESTDIR)$(HELPSUBLOC)\nDEST_COL = $(DESTDIR)$(COLSUBLOC)\nDEST_SYN = $(DESTDIR)$(SYNSUBLOC)\nDEST_IND = $(DESTDIR)$(INDSUBLOC)\nDEST_AUTO = $(DESTDIR)$(AUTOSUBLOC)\nDEST_PLUG = $(DESTDIR)$(PLUGSUBLOC)\nDEST_FTP = $(DESTDIR)$(FTPLUGSUBLOC)\nDEST_LANG = $(DESTDIR)$(LANGSUBLOC)\nDEST_COMP = $(DESTDIR)$(COMPSUBLOC)\nDEST_KMAP = $(DESTDIR)$(KMAPSUBLOC)\nDEST_MACRO = $(DESTDIR)$(MACROSUBLOC)\nDEST_PACK = $(DESTDIR)$(PACKSUBLOC)\nDEST_TOOLS = $(DESTDIR)$(TOOLSSUBLOC)\nDEST_TUTOR = $(DESTDIR)$(TUTORSUBLOC)\nDEST_SPELL = $(DESTDIR)$(SPELLSUBLOC)\nDEST_SCRIPT = $(DESTDIR)$(SCRIPTLOC)\nDEST_PRINT = $(DESTDIR)$(PRINTSUBLOC)\nDEST_MAN_TOP = $(DESTDIR)$(MANDIR)\n\n# We assume that the \".../man/xx/man1/\" directory is for latin1 manual pages.\n# Some systems use UTF-8, but these should find the \".../man/xx.UTF-8/man1/\"\n# directory first.\n# FreeBSD uses \".../man/xx.ISO8859-1/man1\" for latin1, use that one too.\nDEST_MAN = $(DEST_MAN_TOP)$(MAN1DIR)\nDEST_MAN_FR = $(DEST_MAN_TOP)/fr$(MAN1DIR)\nDEST_MAN_FR_I = $(DEST_MAN_TOP)/fr.ISO8859-1$(MAN1DIR)\nDEST_MAN_FR_U = $(DEST_MAN_TOP)/fr.UTF-8$(MAN1DIR)\nDEST_MAN_IT = $(DEST_MAN_TOP)/it$(MAN1DIR)\nDEST_MAN_IT_I = $(DEST_MAN_TOP)/it.ISO8859-1$(MAN1DIR)\nDEST_MAN_IT_U = $(DEST_MAN_TOP)/it.UTF-8$(MAN1DIR)\nDEST_MAN_JA_U = $(DEST_MAN_TOP)/ja$(MAN1DIR)\nDEST_MAN_PL = $(DEST_MAN_TOP)/pl$(MAN1DIR)\nDEST_MAN_PL_I = $(DEST_MAN_TOP)/pl.ISO8859-2$(MAN1DIR)\nDEST_MAN_PL_U = $(DEST_MAN_TOP)/pl.UTF-8$(MAN1DIR)\nDEST_MAN_RU = $(DEST_MAN_TOP)/ru.KOI8-R$(MAN1DIR)\nDEST_MAN_RU_U = $(DEST_MAN_TOP)/ru.UTF-8$(MAN1DIR)\n\n#\t     BASIC_SRC: files that are always used\n#\t       GUI_SRC: extra GUI files for current configuration\n#\t   ALL_GUI_SRC: all GUI files for Unix\n#\n#\t\t   SRC: files used for current configuration\n#\t      TAGS_SRC: source files used for make tags\n#\t     TAGS_INCL: include files used for make tags\n#\t       ALL_SRC: source files used for make depend and make lint\n\nTAGS_INCL = *.h\n\nBASIC_SRC = \\\n\tarabic.c \\\n\tblowfish.c \\\n\tbuffer.c \\\n\tcharset.c \\\n\tcrypt.c \\\n\tcrypt_zip.c \\\n\tdict.c \\\n\tdiff.c \\\n\tdigraph.c \\\n\tedit.c \\\n\teval.c \\\n\tevalfunc.c \\\n\tex_cmds.c \\\n\tex_cmds2.c \\\n\tex_docmd.c \\\n\tex_eval.c \\\n\tex_getln.c \\\n\tfarsi.c \\\n\tfileio.c \\\n\tfold.c \\\n\tgetchar.c \\\n\thardcopy.c \\\n\thashtab.c \\\n\tif_cscope.c \\\n\tif_xcmdsrv.c \\\n\tjson.c \\\n\tlist.c \\\n\tmain.c \\\n\tmark.c \\\n\tmemfile.c \\\n\tmemline.c \\\n\tmenu.c \\\n\tmessage.c \\\n\tmisc1.c \\\n\tmisc2.c \\\n\tmove.c \\\n\tmbyte.c \\\n\tnormal.c \\\n\tops.c \\\n\toption.c \\\n\tos_unix.c \\\n\tauto/pathdef.c \\\n\tpopupmnu.c \\\n\tpty.c \\\n\tquickfix.c \\\n\tregexp.c \\\n\tscreen.c \\\n\tsearch.c \\\n\tsha256.c \\\n\tspell.c \\\n\tspellfile.c \\\n\tsyntax.c \\\n\ttag.c \\\n\tterm.c \\\n\tterminal.c \\\n\tui.c \\\n\tundo.c \\\n\tuserfunc.c \\\n\tversion.c \\\n\twindow.c \\\n\t$(OS_EXTRA_SRC)\n\nSRC =\t$(BASIC_SRC) \\\n\t$(GUI_SRC) \\\n\t$(TERM_SRC) \\\n\t$(HANGULIN_SRC) \\\n\t$(LUA_SRC) \\\n\t$(MZSCHEME_SRC) \\\n\t$(PERL_SRC) \\\n\t$(PYTHON_SRC) $(PYTHON3_SRC) \\\n\t$(TCL_SRC) \\\n\t$(RUBY_SRC) \\\n\t$(WORKSHOP_SRC) \\\n\t$(WSDEBUG_SRC)\n\nTAGS_SRC = *.c *.cpp if_perl.xs\n\nEXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \\\n\t    if_python.c if_python3.c if_tcl.c if_ruby.c \\\n\t    gui_beval.c workshop.c wsdebug.c integration.c \\\n\t    netbeans.c channel.c \\\n\t    $(GRESOURCE_SRC)\n\n# Unittest files\nJSON_TEST_SRC = json_test.c\nJSON_TEST_TARGET = json_test$(EXEEXT)\nKWORD_TEST_SRC = kword_test.c\nKWORD_TEST_TARGET = kword_test$(EXEEXT)\nMEMFILE_TEST_SRC = memfile_test.c\nMEMFILE_TEST_TARGET = memfile_test$(EXEEXT)\nMESSAGE_TEST_SRC = message_test.c\nMESSAGE_TEST_TARGET = message_test$(EXEEXT)\n\nUNITTEST_SRC = $(JSON_TEST_SRC) $(KWORD_TEST_SRC) $(MEMFILE_TEST_SRC) $(MESSAGE_TEST_SRC)\nUNITTEST_TARGETS = $(JSON_TEST_TARGET) $(KWORD_TEST_TARGET) $(MEMFILE_TEST_TARGET) $(MESSAGE_TEST_TARGET)\nRUN_UNITTESTS = run_json_test run_kword_test run_memfile_test run_message_test\n\n# All sources, also the ones that are not configured\nALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)\n\n# Which files to check with lint.  Select one of these three lines.  ALL_SRC\n# checks more, but may not work well for checking a GUI that wasn't configured.\n# The perl sources also don't work well with lint.\nLINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) \\\n\t   $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \\\n\t   $(WORKSHOP_SRC) $(WSDEBUG_SRC) \\\n\t   $(NETBEANS_SRC) $(CHANNEL_SRC) $(TERM_SRC)\n#LINT_SRC = $(SRC)\n#LINT_SRC = $(ALL_SRC)\n#LINT_SRC = $(BASIC_SRC)\n\nOBJ_COMMON = \\\n\tobjects/arabic.o \\\n\tobjects/buffer.o \\\n\tobjects/blowfish.o \\\n\tobjects/crypt.o \\\n\tobjects/crypt_zip.o \\\n\tobjects/dict.o \\\n\tobjects/diff.o \\\n\tobjects/digraph.o \\\n\tobjects/edit.o \\\n\tobjects/eval.o \\\n\tobjects/evalfunc.o \\\n\tobjects/ex_cmds.o \\\n\tobjects/ex_cmds2.o \\\n\tobjects/ex_docmd.o \\\n\tobjects/ex_eval.o \\\n\tobjects/ex_getln.o \\\n\tobjects/farsi.o \\\n\tobjects/fileio.o \\\n\tobjects/fold.o \\\n\tobjects/getchar.o \\\n\tobjects/hardcopy.o \\\n\tobjects/hashtab.o \\\n\t$(HANGULIN_OBJ) \\\n\tobjects/if_cscope.o \\\n\tobjects/if_xcmdsrv.o \\\n\tobjects/list.o \\\n\tobjects/mark.o \\\n\tobjects/memline.o \\\n\tobjects/menu.o \\\n\tobjects/misc1.o \\\n\tobjects/misc2.o \\\n\tobjects/move.o \\\n\tobjects/mbyte.o \\\n\tobjects/normal.o \\\n\tobjects/ops.o \\\n\tobjects/option.o \\\n\tobjects/os_unix.o \\\n\tobjects/pathdef.o \\\n\tobjects/popupmnu.o \\\n\tobjects/pty.o \\\n\tobjects/quickfix.o \\\n\tobjects/regexp.o \\\n\tobjects/screen.o \\\n\tobjects/search.o \\\n\tobjects/sha256.o \\\n\tobjects/spell.o \\\n\tobjects/spellfile.o \\\n\tobjects/syntax.o \\\n\tobjects/tag.o \\\n\tobjects/term.o \\\n\tobjects/terminal.o \\\n\tobjects/ui.o \\\n\tobjects/undo.o \\\n\tobjects/userfunc.o \\\n\tobjects/version.o \\\n\tobjects/window.o \\\n\t$(GUI_OBJ) \\\n\t$(TERM_OBJ) \\\n\t$(LUA_OBJ) \\\n\t$(MZSCHEME_OBJ) \\\n\t$(PERL_OBJ) \\\n\t$(PYTHON_OBJ) \\\n\t$(PYTHON3_OBJ) \\\n\t$(TCL_OBJ) \\\n\t$(RUBY_OBJ) \\\n\t$(OS_EXTRA_OBJ) \\\n\t$(WORKSHOP_OBJ) \\\n\t$(NETBEANS_OBJ) \\\n\t$(CHANNEL_OBJ) \\\n\t$(WSDEBUG_OBJ)\n\n# The files included by tests are not in OBJ_COMMON.\nOBJ_MAIN = \\\n\tobjects/charset.o \\\n\tobjects/json.o \\\n\tobjects/main.o \\\n\tobjects/memfile.o \\\n\tobjects/message.o\n\nOBJ = $(OBJ_COMMON) $(OBJ_MAIN)\n\nOBJ_JSON_TEST = \\\n\tobjects/charset.o \\\n\tobjects/memfile.o \\\n\tobjects/message.o \\\n\tobjects/json_test.o\n\nJSON_TEST_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST)\n\nOBJ_KWORD_TEST = \\\n\tobjects/json.o \\\n\tobjects/memfile.o \\\n\tobjects/message.o \\\n\tobjects/kword_test.o\n\nKWORD_TEST_OBJ = $(OBJ_COMMON) $(OBJ_KWORD_TEST)\n\nOBJ_MEMFILE_TEST = \\\n\tobjects/charset.o \\\n\tobjects/json.o \\\n\tobjects/message.o \\\n\tobjects/memfile_test.o\n\nMEMFILE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MEMFILE_TEST)\n\nOBJ_MESSAGE_TEST = \\\n\tobjects/charset.o \\\n\tobjects/json.o \\\n\tobjects/memfile.o \\\n\tobjects/message_test.o\n\nMESSAGE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MESSAGE_TEST)\n\nALL_OBJ = $(OBJ_COMMON) \\\n\t  $(OBJ_MAIN) \\\n\t  $(OBJ_JSON_TEST) \\\n\t  $(OBJ_KWORD_TEST) \\\n\t  $(OBJ_MEMFILE_TEST) \\\n\t  $(OBJ_MESSAGE_TEST)\n\n\nPRO_AUTO = \\\n\tarabic.pro \\\n\tblowfish.pro \\\n\tbuffer.pro \\\n\tcharset.pro \\\n\tcrypt.pro \\\n\tcrypt_zip.pro \\\n\tdict.pro \\\n\tdiff.pro \\\n\tdigraph.pro \\\n\tedit.pro \\\n\teval.pro \\\n\tevalfunc.pro \\\n\tex_cmds.pro \\\n\tex_cmds2.pro \\\n\tex_docmd.pro \\\n\tex_eval.pro \\\n\tex_getln.pro \\\n\tfarsi.pro \\\n\tfileio.pro \\\n\tfold.pro \\\n\tgetchar.pro \\\n\thardcopy.pro \\\n\thashtab.pro \\\n\thangulin.pro \\\n\tif_cscope.pro \\\n\tif_lua.pro \\\n\tif_mzsch.pro \\\n\tif_python.pro \\\n\tif_python3.pro \\\n\tif_ruby.pro \\\n\tif_xcmdsrv.pro \\\n\tjson.pro \\\n\tlist.pro \\\n\tmain.pro \\\n\tmark.pro \\\n\tmbyte.pro \\\n\tmemfile.pro \\\n\tmemline.pro \\\n\tmenu.pro \\\n\tmessage.pro \\\n\tmisc1.pro \\\n\tmisc2.pro \\\n\tmove.pro \\\n\tnormal.pro \\\n\tops.pro \\\n\toption.pro \\\n\tos_mac_conv.pro \\\n\tos_unix.pro \\\n\tpopupmnu.pro \\\n\tpty.pro \\\n\tquickfix.pro \\\n\tregexp.pro \\\n\tscreen.pro \\\n\tsearch.pro \\\n\tsha256.pro \\\n\tspell.pro \\\n\tspellfile.pro \\\n\tsyntax.pro \\\n\ttag.pro \\\n\tterm.pro \\\n\tterminal.pro \\\n\ttermlib.pro \\\n\tui.pro \\\n\tundo.pro \\\n\tuserfunc.pro \\\n\tversion.pro \\\n\twindow.pro \\\n\tgui_beval.pro \\\n\tworkshop.pro \\\n\tnetbeans.pro \\\n\tchannel.pro \\\n\t$(ALL_GUI_PRO) \\\n\t$(TCL_PRO)\n\n# Resources used for the Mac are in one directory.\nRSRC_DIR = os_mac_rsrc\n\nPRO_MANUAL = os_amiga.pro os_win32.pro \\\n\tos_mswin.pro winclip.pro os_beos.pro os_vms.pro $(PERL_PRO)\n\n# Default target is making the executable and tools\nall: $(VIMTARGET) $(TOOLS) languages $(GUI_BUNDLE)\n\ntools: $(TOOLS)\n\n# Run configure with all the setting from above.\n#\n# Note: auto/config.h doesn't depend on configure, because running configure\n# doesn't always update auto/config.h.  The timestamp isn't changed if the\n# file contents didn't change (to avoid recompiling everything).  Including a\n# dependency on auto/config.h would cause running configure each time when\n# auto/config.h isn't updated.  The dependency on auto/config.mk should make\n# sure configure is run when it's needed.\n#\n# Remove the config.cache every time, once in a while it causes problems that\n# are very hard to figure out.\n#\nconfig auto/config.mk: auto/configure config.mk.in config.h.in\n\t-rm -f auto/config.cache\n\tif test \"X$(MAKECMDGOALS)\" != \"Xclean\" \\\n\t\t-a \"X$(MAKECMDGOALS)\" != \"Xdistclean\" \\\n\t\t-a \"X$(MAKECMDGOALS)\" != \"Xautoconf\" \\\n\t\t-a \"X$(MAKECMDGOALS)\" != \"Xreconfig\"; then \\\n\t    GUI_INC_LOC=\"$(GUI_INC_LOC)\" GUI_LIB_LOC=\"$(GUI_LIB_LOC)\" \\\n\t\tCC=\"$(CC)\" CPPFLAGS=\"$(CPPFLAGS)\" CFLAGS=\"$(CFLAGS)\" \\\n\t\tLDFLAGS=\"$(LDFLAGS)\" $(CONF_SHELL) srcdir=\"$(srcdir)\" \\\n\t\t./configure $(CONF_OPT_GUI) $(CONF_OPT_X) $(CONF_OPT_XSMP) \\\n\t\t$(CONF_OPT_DARWIN) $(CONF_OPT_FAIL) \\\n\t\t$(CONF_OPT_PERL) $(CONF_OPT_PYTHON) $(CONF_OPT_PYTHON3) \\\n\t\t$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \\\n\t\t$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \\\n\t\t$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \\\n\t\t$(CONF_OPT_FEAT) $(CONF_TERM_LIB) \\\n\t\t$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \\\n\t\t$(CONF_OPT_CHANNEL) $(CONF_OPT_TERMINAL) \\\n\t\t$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \\\n\t\t$(CONF_OPT_LUA) $(CONF_OPT_LUA_PREFIX) \\\n\t\t$(CONF_OPT_SYSMOUSE); \\\n\tfi\n\n# Use \"make reconfig\" to rerun configure without cached values.\n# When config.h changes, most things will be recompiled automatically.\n# Invoke $(MAKE) to run config with the empty auto/config.mk.\n# Invoke $(MAKE) to build all with the filled auto/config.mk.\nreconfig: scratch clean\n\t$(MAKE) -f Makefile config\n\t$(MAKE) -f Makefile all\n\n# Run autoconf to produce auto/configure.\n# Note:\n# - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of\n#   producing auto/configure.\n# - autoconf is not run automatically, because a patch usually changes both\n#   configure.ac and auto/configure but can't update the timestamps.  People\n#   who do not have (the correct version of) autoconf would run into trouble.\n#\n# Two tricks are required to make autoconf put its output in the \"auto\" dir:\n# - Temporarily move the ./configure script to ./configure.save.  Don't\n#   overwrite it, it's probably the result of an aborted autoconf.\n# - Use sed to change ./config.log to auto/config.log in the configure script.\n# Autoconf 2.5x (2.59 at least) produces a few more files that we need to take\n# care of:\n# - configure.lineno: has the line numbers replaced with $LINENO.  That\n#   improves patches a LOT, thus use it instead (until someone says it doesn't\n#   work on some system).\n# - autom4te.cache directory is created and not cleaned up.  Delete it.\n# - Uses \">config.log\" instead of \"./config.log\".\nautoconf:\n\tif test ! -f configure.save; then mv configure configure.save; fi\n\t$(AUTOCONF)\n\tsed -e 's+>config.log+>auto/config.log+' -e 's+\\./config.log+auto/config.log+' configure > auto/configure\n\tchmod 755 auto/configure\n\tmv -f configure.save configure\n\t-rm -rf autom4te.cache\n\t-rm -f auto/config.status auto/config.cache\n\n# Run vim script to generate the Ex command lookup table.\n# This only needs to be run when a command name has been added or changed.\n# If this fails because you don't have Vim yet, first build and install Vim\n# without changes.\ncmdidxs: ex_cmds.h\n\tvim -u NONE -i NONE -X -S create_cmdidxs.vim\n\n\n# The normal command to compile a .c file to its .o file.\n# Without or with ALL_CFLAGS.\nCCC_NF = $(CC) -c -I$(srcdir)\nCCC = $(CCC_NF) $(ALL_CFLAGS)\n\n\n# Link the target for normal use or debugging.\n# A shell script is used to try linking without unnecessary libraries.\n$(VIMTARGET): auto/config.mk objects $(OBJ) version.c version.h\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(VIMTARGET) $(OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\nxxd/xxd$(EXEEXT): xxd/xxd.c\n\tcd xxd; CC=\"$(CC)\" CFLAGS=\"$(CPPFLAGS) $(CFLAGS)\" LDFLAGS=\"$(LDFLAGS)\" \\\n\t\t$(MAKE) -f Makefile\n\n# Build the language specific files if they were unpacked.\n# Generate the converted .mo files separately, it's no problem if this fails.\nlanguages:\n\t@if test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t\tcd $(PODIR); \\\n\t\t  CC=\"$(CC)\" $(MAKE) prefix=$(DESTDIR)$(prefix); \\\n\tfi\n\t-@if test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t\tcd $(PODIR); \\\n\t\t  CC=\"$(CC)\" $(MAKE) prefix=$(DESTDIR)$(prefix) converted; \\\n\tfi\n\n# Update the *.po files for changes in the sources.  Only run manually.\nupdate-po:\n\tcd $(PODIR); CC=\"$(CC)\" $(MAKE) prefix=$(DESTDIR)$(prefix) update-po\n\n# Generate function prototypes.  This is not needed to compile vim, but if\n# you want to use it, cproto is out there on the net somewhere -- Webb\n#\n# When generating os_amiga.pro and os_win32.pro there will be a\n# few include files that can not be found, that's OK.\n\nproto: $(PRO_AUTO) $(PRO_MANUAL)\n\n# Filter out arguments that cproto doesn't support.\n# Don't pass \"-pthread\", \"-fwrapv\" and similar arguments to cproto, it sees\n# them as a list of individual flags.\n# The -E\"gcc -E\" argument must be separate to avoid problems with shell\n# quoting.\nCPROTO = cproto $(PROTO_FLAGS) -DPROTO \\\n\t `echo '$(LINT_CFLAGS)' | sed -e 's/ -[a-z-]\\+//g'`\n\n### Would be nice if this would work for \"normal\" make.\n### Currently it only works for (Free)BSD make.\n#$(PRO_AUTO): $$(*F).c\n#\t$(CPROTO) -DFEAT_GUI $(*F).c > $@\n\n# Always define FEAT_GUI.  This may generate a few warnings if it's also\n# defined in auto/config.h, you can ignore that.\n.c.pro:\n\t$(CPROTO) -DFEAT_GUI $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_amiga.pro: os_amiga.c\n\t$(CPROTO) -DAMIGA -UHAVE_CONFIG_H -DBPTR=char* $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_win32.pro: os_win32.c\n\t$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_mswin.pro: os_mswin.c\n\t$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nwinclip.pro: winclip.c\n\t$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_beos.pro: os_beos.c\n\t$(CPROTO) -D__BEOS__ -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_vms.pro: os_vms.c\n# must use os_vms_conf.h for auto/config.h\n\tmv auto/config.h auto/config.h.save\n\tcp os_vms_conf.h auto/config.h\n\t$(CPROTO) -DVMS -UFEAT_GUI_ATHENA -UFEAT_GUI_NEXTAW -UFEAT_GUI_MOTIF -UFEAT_GUI_GTK $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\trm auto/config.h\n\tmv auto/config.h.save auto/config.h\n\n# if_perl.pro is special: Use the generated if_perl.c for input and remove\n# prototypes for local functions.\nif_perl.pro: auto/if_perl.c\n\t$(CPROTO) -DFEAT_GUI auto/if_perl.c | sed \"/_VI/d\" > proto/$@\n\ngui_gtk_gresources.pro: auto/gui_gtk_gresources.c\n\t$(CPROTO) -DFEAT_GUI $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nnotags:\n\t-rm -f tags\n\n# Note: tags is made for the currently configured version, can't include both\n#\tMotif and Athena GUI\n# You can ignore error messages for missing files.\ntags TAGS: notags\n\t$(TAGPRG) $(TAGS_SRC) $(TAGS_INCL)\n\n# Make a highlight file for types.  Requires Exuberant ctags and awk\ntypes: types.vim\ntypes.vim: $(TAGS_SRC) $(TAGS_INCL)\n\tctags --c-kinds=gstu -o- $(TAGS_SRC) $(TAGS_INCL) |\\\n\t\tawk 'BEGIN{printf(\"syntax keyword Type\\t\")}\\\n\t\t\t{printf(\"%s \", $$1)}END{print \"\"}' > $@\n\techo \"syn keyword Constant OK FAIL TRUE FALSE MAYBE\" >> $@\n\n# TESTING\n#\n# Execute the test scripts and the unittests.\ntest check: scripttests unittests\n\n# Execute the test scripts.  Run these after compiling Vim, before installing.\n# This doesn't depend on $(VIMTARGET), because that won't work when configure\n# wasn't run yet.  Restart make to build it instead.\n#\n# This will produce a lot of garbage on your screen, including a few error\n# messages.  Don't worry about that.\n# If there is a real error, there will be a difference between \"testXX.out\" and\n# a \"testXX.ok\" file.\n# If everything is alright, the final message will be \"ALL DONE\".  If not you\n# get \"TEST FAILURE\".\n#\nscripttests:\n\t$(MAKE) -f Makefile $(VIMTARGET)\n\tif test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t\tcd $(PODIR); $(MAKE) -f Makefile check VIM=../$(VIMTARGET); \\\n\tfi\n\t-if test $(VIMTARGET) != vim -a ! -r vim; then \\\n\t\tln -s $(VIMTARGET) vim; \\\n\tfi\n\tcd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\n# Run the tests with the GUI.  Assumes vim/gvim was already built\ntestgui:\n\tcd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) GUI_FLAG=-g $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\nbenchmark:\n\tcd testdir; $(MAKE) -f Makefile benchmark VIMPROG=../$(VIMTARGET) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\nunittesttargets:\n\t$(MAKE) -f Makefile $(UNITTEST_TARGETS)\n\n# Execute the unittests one by one.\nunittest unittests: $(RUN_UNITTESTS)\n\nrun_json_test: $(JSON_TEST_TARGET)\n\t$(VALGRIND) ./$(JSON_TEST_TARGET) || exit 1; echo $* passed;\n\nrun_kword_test: $(KWORD_TEST_TARGET)\n\t$(VALGRIND) ./$(KWORD_TEST_TARGET) || exit 1; echo $* passed;\n\nrun_memfile_test: $(MEMFILE_TEST_TARGET)\n\t$(VALGRIND) ./$(MEMFILE_TEST_TARGET) || exit 1; echo $* passed;\n\nrun_message_test: $(MESSAGE_TEST_TARGET)\n\t$(VALGRIND) ./$(MESSAGE_TEST_TARGET) || exit 1; echo $* passed;\n\n# Run individual OLD style test.\n# These do not depend on the executable, compile it when needed.\ntest1 \\\n\ttest_changelist \\\n\ttest_close_count \\\n\ttest_erasebackword \\\n\ttest_eval \\\n\ttest_fixeol \\\n\ttest_insertcount \\\n\ttest_listchars \\\n\ttest_search_mbyte \\\n\ttest_wordcount \\\n\ttest3 test11 test14 test15 test17 \\\n\ttest29 test30 test36 test37 test39 \\\n\ttest42 test44 test48 test49 \\\n\ttest50 test52 test55 test59 \\\n\ttest64 test68 test69 \\\n\ttest70 test72 test73 \\\n\ttest85 test86 test87 test88 \\\n\ttest94 test95 test99 test108:\n\tcd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\n# Run individual NEW style test.\n# These do not depend on the executable, compile it when needed.\ntest_arglist \\\n\ttest_arabic \\\n\ttest_assert \\\n\ttest_assign \\\n\ttest_autochdir \\\n\ttest_autocmd \\\n\ttest_backspace_opt \\\n\ttest_breakindent \\\n\ttest_bufline \\\n\ttest_bufwintabinfo \\\n\ttest_cd \\\n\ttest_cdo \\\n\ttest_changedtick \\\n\ttest_channel \\\n\ttest_charsearch \\\n\ttest_charsearch_utf8 \\\n\ttest_cindent \\\n\ttest_clientserver \\\n\ttest_cmdline \\\n\ttest_command_count \\\n\ttest_comparators \\\n\ttest_crypt \\\n\ttest_cscope \\\n\ttest_cursor_func \\\n\ttest_curswant \\\n\ttest_delete \\\n\ttest_diffmode \\\n\ttest_digraph \\\n\ttest_display \\\n\ttest_edit \\\n\ttest_escaped_glob \\\n\ttest_ex_undo \\\n\ttest_ex_z \\\n\ttest_exec_while_if \\\n\ttest_execute_func \\\n\ttest_exists \\\n\ttest_exists_autocmd \\\n\ttest_expand \\\n\ttest_expand_dllpath \\\n\ttest_expr \\\n\ttest_expr_utf8 \\\n\ttest_farsi \\\n\ttest_feedkeys \\\n\ttest_file_perm \\\n\ttest_file_size \\\n\ttest_fileformat \\\n\ttest_filetype \\\n\ttest_filter_cmd \\\n\ttest_filter_map \\\n\ttest_findfile \\\n\ttest_float_func \\\n\ttest_fnameescape \\\n\ttest_fnamemodify \\\n\ttest_fold \\\n\ttest_functions \\\n\ttest_ga \\\n\ttest_getcwd \\\n\ttest_getvar \\\n\ttest_gf \\\n\ttest_glob2regpat \\\n\ttest_global \\\n\ttest_gn \\\n\ttest_goto \\\n\ttest_gui \\\n\ttest_gui_init \\\n\ttest_hardcopy \\\n\ttest_help \\\n\ttest_help_tagjump \\\n\ttest_hide \\\n\ttest_highlight \\\n\ttest_history \\\n\ttest_hlsearch \\\n\ttest_increment \\\n\ttest_increment_dbcs \\\n\ttest_ins_complete \\\n\ttest_job_fails \\\n\ttest_join \\\n\ttest_json \\\n\ttest_jumps \\\n\ttest_lambda \\\n\ttest_langmap \\\n\ttest_largefile \\\n\ttest_let \\\n\ttest_lineending \\\n\ttest_lispwords \\\n\ttest_listlbr \\\n\ttest_listlbr_utf8 \\\n\ttest_lua \\\n\ttest_makeencoding \\\n\ttest_man \\\n\ttest_maparg \\\n\ttest_mapping \\\n\ttest_marks \\\n\ttest_match \\\n\ttest_matchadd_conceal \\\n\ttest_matchadd_conceal_utf8 \\\n\ttest_menu \\\n\ttest_messages \\\n\ttest_mksession \\\n\ttest_mksession_utf8 \\\n\ttest_nested_function \\\n\ttest_netbeans \\\n\ttest_normal \\\n\ttest_number \\\n\ttest_options \\\n\ttest_packadd \\\n\ttest_partial \\\n\ttest_paste \\\n\ttest_perl \\\n\ttest_plus_arg_edit \\\n\ttest_popup \\\n\ttest_preview \\\n\ttest_profile \\\n\ttest_put \\\n\ttest_python2 \\\n\ttest_python3 \\\n\ttest_pyx2 \\\n\ttest_pyx3 \\\n\ttest_quickfix \\\n\ttest_quotestar \\\n\ttest_recover \\\n\ttest_regex_char_classes \\\n\ttest_regexp_latin \\\n\ttest_regexp_utf8 \\\n\ttest_registers \\\n\ttest_reltime \\\n\ttest_retab \\\n\ttest_ruby \\\n\ttest_scroll_opt \\\n\ttest_scrollbind \\\n\ttest_search \\\n\ttest_searchpos \\\n\ttest_set \\\n\ttest_sha256 \\\n\ttest_signs \\\n\ttest_smartindent \\\n\ttest_sort \\\n\ttest_source_utf8 \\\n\ttest_spell \\\n\ttest_startup \\\n\ttest_startup_utf8 \\\n\ttest_stat \\\n\ttest_statusline \\\n\ttest_substitute \\\n\ttest_syn_attr \\\n\ttest_syntax \\\n\ttest_system \\\n\ttest_tabline \\\n\ttest_tabpage \\\n\ttest_tagcase \\\n\ttest_tagjump \\\n\ttest_taglist \\\n\ttest_tcl \\\n\ttest_terminal \\\n\ttest_terminal_fail \\\n\ttest_textobjects \\\n\ttest_timers \\\n\ttest_true_false \\\n\ttest_undo \\\n\ttest_unlet \\\n\ttest_usercommands \\\n\ttest_utf8 \\\n\ttest_utf8_comparisons \\\n\ttest_viminfo \\\n\ttest_vimscript \\\n\ttest_virtualedit \\\n\ttest_visual \\\n\ttest_winbar \\\n\ttest_winbuf_close \\\n\ttest_window_cmd \\\n\ttest_window_id \\\n\ttest_windows_home \\\n\ttest_writefile \\\n\ttest_alot_latin \\\n\ttest_alot_utf8 \\\n\ttest_alot:\n\tcd testdir; rm -f $@.res test.log messages; $(MAKE) -f Makefile $@.res VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\t@if test -f testdir/test.log; then \\\n\t\tcat testdir/test.log; \\\n\tfi\n\tcat testdir/messages\n\nnewtests:\n\tcd testdir; rm -f $@.res test.log messages; $(MAKE) -f Makefile newtestssilent VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\t@if test -f testdir/test.log; then \\\n\t\tcat testdir/test.log; \\\n\tfi\n\tcat testdir/messages\n\ntestclean:\n\tcd testdir; $(MAKE) -f Makefile clean\n\tif test -d $(PODIR); then \\\n\t\tcd $(PODIR); $(MAKE) checkclean; \\\n\tfi\n\n# Unittests\n# It's build just like Vim to satisfy all dependencies.\n$(JSON_TEST_TARGET): auto/config.mk objects $(JSON_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(JSON_TEST_TARGET) $(JSON_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n$(KWORD_TEST_TARGET): auto/config.mk objects $(KWORD_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(KWORD_TEST_TARGET) $(KWORD_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n$(MEMFILE_TEST_TARGET): auto/config.mk objects $(MEMFILE_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(MEMFILE_TEST_TARGET) $(MEMFILE_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n$(MESSAGE_TEST_TARGET): auto/config.mk objects $(MESSAGE_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(MESSAGE_TEST_TARGET) $(MESSAGE_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n# install targets\n\ninstall: $(GUI_INSTALL)\n\ninstall_normal: installvim installtools $(INSTALL_LANGS) install-icons\n\ninstall_gui_extra: installgtutorbin\n\ninstallvim: installvimbin installtutorbin \\\n\t\tinstallruntime installlinks installmanlinks\n\n#\n# Avoid overwriting an existing executable, somebody might be running it and\n# overwriting it could cause it to crash.  Deleting it is OK, it won't be\n# really deleted until all running processes for it have exited.  It is\n# renamed first, in case the deleting doesn't work.\n#\n# If you want to keep an older version, rename it before running \"make\n# install\".\n#\ninstallvimbin: $(VIMTARGET) $(DESTDIR)$(exec_prefix) $(DEST_BIN)\n\t-if test -f $(DEST_BIN)/$(VIMTARGET); then \\\n\t  mv -f $(DEST_BIN)/$(VIMTARGET) $(DEST_BIN)/$(VIMNAME).rm; \\\n\t  rm -f $(DEST_BIN)/$(VIMNAME).rm; \\\n\tfi\n\t$(INSTALL_PROG) $(VIMTARGET) $(DEST_BIN)\n\t$(STRIP) $(DEST_BIN)/$(VIMTARGET)\n\tchmod $(BINMOD) $(DEST_BIN)/$(VIMTARGET)\n# may create a link to the new executable from /usr/bin/vi\n\t-$(LINKIT)\n\n# Long list of arguments for the shell script that installs the manual pages\n# for one language.\nINSTALLMANARGS = $(VIMLOC) $(SCRIPTLOC) $(VIMRCLOC) $(HELPSOURCE) $(MANMOD) \\\n\t\t$(VIMNAME) $(VIMDIFFNAME) $(EVIMNAME)\n\n# Install most of the runtime files\ninstallruntime: installrtbase installmacros installpack installtutor installspell\n\n# install the help files; first adjust the contents for the final location\ninstallrtbase: $(HELPSOURCE)/vim.1 $(DEST_VIM) $(DEST_RT) \\\n\t\t$(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) \\\n\t\t$(DEST_FTP) $(DEST_AUTO) $(DEST_AUTO)/xml $(DEST_PLUG) \\\n\t\t$(DEST_TUTOR) $(DEST_SPELL) $(DEST_COMP)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN) \"\" $(INSTALLMANARGS)\n# Generate the help tags with \":helptags\" to handle all languages.\n# Move the distributed tags file aside and restore it, to avoid it being\n# different from the repository.\n\tcd $(HELPSOURCE); if test -z \"$(CROSS_COMPILING)\" -a -f tags; then \\\n\t\tmv -f tags tags.dist; fi\n\t@echo generating help tags\n\t-@cd $(HELPSOURCE); if test -z \"$(CROSS_COMPILING)\"; then \\\n\t\t$(MAKE) VIMEXE=$(DEST_BIN)/$(VIMTARGET) vimtags; fi\n\tcd $(HELPSOURCE); \\\n\t\tfiles=`ls *.txt tags`; \\\n\t\tfiles=\"$$files `ls *.??x tags-?? 2>/dev/null || true`\"; \\\n\t\t$(INSTALL_DATA) $$files  $(DEST_HELP); \\\n\t\tcd $(DEST_HELP); \\\n\t\tchmod $(HELPMOD) $$files\n\t$(INSTALL_DATA)  $(HELPSOURCE)/*.pl $(DEST_HELP)\n\tchmod $(SCRIPTMOD) $(DEST_HELP)/*.pl\n\tcd $(HELPSOURCE); if test -f tags.dist; then mv -f tags.dist tags; fi\n# install the menu files\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/menu.vim $(SYS_MENU_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_MENU_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/synmenu.vim $(SYS_SYNMENU_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_SYNMENU_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/delmenu.vim $(SYS_DELMENU_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_DELMENU_FILE)\n# install the defaults/evim/mswin file\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/defaults.vim $(VIM_DEFAULTS_FILE)\n\tchmod $(VIMSCRIPTMOD) $(VIM_DEFAULTS_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/evim.vim $(EVIM_FILE)\n\tchmod $(VIMSCRIPTMOD) $(EVIM_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/mswin.vim $(MSWIN_FILE)\n\tchmod $(VIMSCRIPTMOD) $(MSWIN_FILE)\n# install the rgb.txt file\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(SYS_RGB_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_RGB_FILE)\n# install the bugreport file\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/bugreport.vim $(SYS_BUGR_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_BUGR_FILE)\n# install the example vimrc files\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/vimrc_example.vim $(DEST_SCRIPT)\n\tchmod $(VIMSCRIPTMOD) $(DEST_SCRIPT)/vimrc_example.vim\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/gvimrc_example.vim $(DEST_SCRIPT)\n\tchmod $(VIMSCRIPTMOD) $(DEST_SCRIPT)/gvimrc_example.vim\n# install the file type detection files\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/filetype.vim $(SYS_FILETYPE_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FILETYPE_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/ftoff.vim $(SYS_FTOFF_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FTOFF_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/scripts.vim $(SYS_SCRIPTS_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_SCRIPTS_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/ftplugin.vim $(SYS_FTPLUGIN_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FTPLUGIN_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/ftplugof.vim $(SYS_FTPLUGOF_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FTPLUGOF_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/indent.vim $(SYS_INDENT_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_INDENT_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/indoff.vim $(SYS_INDOFF_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_INDOFF_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/optwin.vim $(SYS_OPTWIN_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_OPTWIN_FILE)\n# install the print resource files\n\tcd $(PRINTSOURCE); $(INSTALL_DATA) *.ps $(DEST_PRINT)\n\tcd $(DEST_PRINT); chmod $(FILEMOD) *.ps\n# install the colorscheme files\n\tcd $(COLSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_COL)\n\tcd $(DEST_COL); chmod $(HELPMOD) *.vim README.txt\n# install the syntax files\n\tcd $(SYNSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_SYN)\n\tcd $(DEST_SYN); chmod $(HELPMOD) *.vim README.txt\n# install the indent files\n\tcd $(INDSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_IND)\n\tcd $(DEST_IND); chmod $(HELPMOD) *.vim README.txt\n# install the standard autoload files\n\tcd $(AUTOSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_AUTO)\n\tcd $(DEST_AUTO); chmod $(HELPMOD) *.vim README.txt\n\tcd $(AUTOSOURCE)/xml; $(INSTALL_DATA) *.vim $(DEST_AUTO)/xml\n\tcd $(DEST_AUTO)/xml; chmod $(HELPMOD) *.vim\n# install the standard plugin files\n\tcd $(PLUGSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_PLUG)\n\tcd $(DEST_PLUG); chmod $(HELPMOD) *.vim README.txt\n# install the ftplugin files\n\tcd $(FTPLUGSOURCE); $(INSTALL_DATA) *.vim README.txt logtalk.dict $(DEST_FTP)\n\tcd $(DEST_FTP); chmod $(HELPMOD) *.vim README.txt\n# install the compiler files\n\tcd $(COMPSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_COMP)\n\tcd $(DEST_COMP); chmod $(HELPMOD) *.vim README.txt\n\ninstallmacros: $(DEST_VIM) $(DEST_RT) $(DEST_MACRO)\n\t$(INSTALL_DATA_R) $(MACROSOURCE)/* $(DEST_MACRO)\n\tchmod $(DIRMOD) `find $(DEST_MACRO) -type d -print`\n\tchmod $(FILEMOD) `find $(DEST_MACRO) -type f -print`\n\tchmod $(SCRIPTMOD) $(DEST_MACRO)/less.sh\n# When using CVS some CVS directories might have been copied.\n# Also delete AAPDIR and *.info files.\n\tcvs=`find $(DEST_MACRO) \\( -name CVS -o -name AAPDIR -o -name \"*.info\" \\) -print`; \\\n\t      if test -n \"$$cvs\"; then \\\n\t\t rm -rf $$cvs; \\\n\t      fi\n\ninstallpack: $(DEST_VIM) $(DEST_RT) $(DEST_PACK)\n\t$(INSTALL_DATA_R) $(PACKSOURCE)/* $(DEST_PACK)\n\tchmod $(DIRMOD) `find $(DEST_PACK) -type d -print`\n\tchmod $(FILEMOD) `find $(DEST_PACK) -type f -print`\n\n# install the tutor files\ninstalltutorbin: $(DEST_VIM)\n\t$(INSTALL_DATA) vimtutor $(DEST_BIN)/$(VIMNAME)tutor\n\tchmod $(SCRIPTMOD) $(DEST_BIN)/$(VIMNAME)tutor\n\ninstallgtutorbin: $(DEST_VIM)\n\t$(INSTALL_DATA) gvimtutor $(DEST_BIN)/$(GVIMNAME)tutor\n\tchmod $(SCRIPTMOD) $(DEST_BIN)/$(GVIMNAME)tutor\n\ninstalltutor: $(DEST_RT) $(DEST_TUTOR)\n\t-$(INSTALL_DATA) $(TUTORSOURCE)/README* $(TUTORSOURCE)/tutor* $(DEST_TUTOR)\n\t-rm -f $(DEST_TUTOR)/*.info\n\tchmod $(HELPMOD) $(DEST_TUTOR)/*\n\n# Install the spell files, if they exist.  This assumes at least the English\n# spell file is there.\ninstallspell: $(DEST_VIM) $(DEST_RT) $(DEST_SPELL)\n\tif test -f $(SPELLSOURCE)/en.latin1.spl; then \\\n\t  $(INSTALL_DATA) $(SPELLSOURCE)/*.spl $(SPELLSOURCE)/*.sug $(SPELLSOURCE)/*.vim $(DEST_SPELL); \\\n\t  chmod $(HELPMOD) $(DEST_SPELL)/*.spl $(DEST_SPELL)/*.sug $(DEST_SPELL)/*.vim; \\\n\tfi\n\n# install helper program xxd\ninstalltools: $(TOOLS) $(DESTDIR)$(exec_prefix) $(DEST_BIN) \\\n\t\t$(TOOLSSOURCE) $(DEST_VIM) $(DEST_RT) $(DEST_TOOLS) \\\n\t\t$(INSTALL_TOOL_LANGS)\n\tif test -f $(DEST_BIN)/xxd$(EXEEXT); then \\\n\t  mv -f $(DEST_BIN)/xxd$(EXEEXT) $(DEST_BIN)/xxd.rm; \\\n\t  rm -f $(DEST_BIN)/xxd.rm; \\\n\tfi\n\t$(INSTALL_PROG) xxd/xxd$(EXEEXT) $(DEST_BIN)\n\t$(STRIP) $(DEST_BIN)/xxd$(EXEEXT)\n\tchmod $(BINMOD) $(DEST_BIN)/xxd$(EXEEXT)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN) \"\" $(INSTALLMANARGS)\n\n# install the runtime tools\n\t$(INSTALL_DATA_R) $(TOOLSSOURCE)/* $(DEST_TOOLS)\n# When using CVS some CVS directories might have been copied.\n\tcvs=`find $(DEST_TOOLS) \\( -name CVS -o -name AAPDIR \\) -print`; \\\n\t      if test -n \"$$cvs\"; then \\\n\t\t rm -rf $$cvs; \\\n\t      fi\n\t-chmod $(FILEMOD) $(DEST_TOOLS)/*\n# replace the path in some tools\n\tperlpath=`./which.sh perl` && sed -e \"s+/usr/bin/perl+$$perlpath+\" $(TOOLSSOURCE)/efm_perl.pl >$(DEST_TOOLS)/efm_perl.pl\n\tawkpath=`./which.sh nawk` && sed -e \"s+/usr/bin/nawk+$$awkpath+\" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; if test -z \"$$awkpath\"; then \\\n\t\tawkpath=`./which.sh gawk` && sed -e \"s+/usr/bin/nawk+$$awkpath+\" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; if test -z \"$$awkpath\"; then \\\n\t\tawkpath=`./which.sh awk` && sed -e \"s+/usr/bin/nawk+$$awkpath+\" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; fi; fi\n\t-chmod $(SCRIPTMOD) `grep -l \"^#!\" $(DEST_TOOLS)/*`\n\n# install the language specific files for tools, if they were unpacked\ninstall-tool-languages:\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR_I) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR_U) \"-fr.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT_I) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT_U) \"-it.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_JA_U) \"-ja.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL_I) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL_U) \"-pl.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_RU) \"-ru\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_RU_U) \"-ru.UTF-8\" $(INSTALLMANARGS)\n\n# install the language specific files, if they were unpacked\ninstall-languages: languages $(DEST_LANG) $(DEST_KMAP)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_FR) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_FR_I) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_FR_U) \"-fr.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_IT) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_IT_I) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_IT_U) \"-it.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_JA_U) \"-ja.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_PL) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_PL_I) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_PL_U) \"-pl.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_RU) \"-ru\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_RU_U) \"-ru.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_JA_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU_U) $(INSTALLMLARGS)\n\tif test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t   cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) LOCALEDIR=$(DEST_LANG) \\\n\t   INSTALL_DATA=$(INSTALL_DATA) FILEMOD=$(FILEMOD) install; \\\n\tfi\n\tif test -d $(LANGSOURCE); then \\\n\t   $(INSTALL_DATA) $(LANGSOURCE)/README.txt $(LANGSOURCE)/*.vim $(DEST_LANG); \\\n\t   chmod $(FILEMOD) $(DEST_LANG)/README.txt $(DEST_LANG)/*.vim; \\\n\tfi\n\tif test -d $(KMAPSOURCE); then \\\n\t   $(INSTALL_DATA) $(KMAPSOURCE)/README.txt $(KMAPSOURCE)/*.vim $(DEST_KMAP); \\\n\t   chmod $(FILEMOD) $(DEST_KMAP)/README.txt $(DEST_KMAP)/*.vim; \\\n\tfi\n\n# Install the icons for KDE, if the directory exists and the icon doesn't.\n# Always when $(DESTDIR) is not empty.\nICON48PATH = $(DESTDIR)$(DATADIR)/icons/hicolor/48x48/apps\nICON32PATH = $(DESTDIR)$(DATADIR)/icons/locolor/32x32/apps\nICON16PATH = $(DESTDIR)$(DATADIR)/icons/locolor/16x16/apps\nICONTHEMEPATH = $(DATADIR)/icons/hicolor\nDESKTOPPATH = $(DESTDIR)$(DATADIR)/applications\nKDEPATH = $(HOME)/.kde/share/icons\ninstall-icons:\n\tif test -n \"$(DESTDIR)\"; then \\\n\t\t$(MKDIR_P) $(ICON48PATH) $(ICON32PATH) \\\n\t\t$(ICON16PATH) $(DESKTOPPATH); \\\n\tfi\n\n\tif test -d $(ICON48PATH) -a -w $(ICON48PATH) \\\n\t\t-a ! -f $(ICON48PATH)/gvim.png; then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim48x48.png $(ICON48PATH)/gvim.png; \\\n\t   if test -z \"$(DESTDIR)\" -a -x \"$(GTK_UPDATE_ICON_CACHE)\" \\\n\t\t   -a -w $(ICONTHEMEPATH) \\\n\t\t   -a -f $(ICONTHEMEPATH)/index.theme; then \\\n\t\t$(GTK_UPDATE_ICON_CACHE) -q $(ICONTHEMEPATH); \\\n\t   fi \\\n\tfi\n\tif test -d $(ICON32PATH) -a -w $(ICON32PATH) \\\n\t\t-a ! -f $(ICON32PATH)/gvim.png; then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim32x32.png $(ICON32PATH)/gvim.png; \\\n\tfi\n\tif test -d $(ICON16PATH) -a -w $(ICON16PATH) \\\n\t\t-a ! -f $(ICON16PATH)/gvim.png; then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim16x16.png $(ICON16PATH)/gvim.png; \\\n\tfi\n\tif test -d $(DESKTOPPATH) -a -w $(DESKTOPPATH); then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim.desktop \\\n\t\t$(SCRIPTSOURCE)/gvim.desktop \\\n\t\t$(DESKTOPPATH); \\\n\t   if test -z \"$(DESTDIR)\" -a -x \"$(UPDATE_DESKTOP_DATABASE)\"; then \\\n\t      $(UPDATE_DESKTOP_DATABASE) -q $(DESKTOPPATH); \\\n\t   fi \\\n\tfi\n\n$(HELPSOURCE)/vim.1 $(MACROSOURCE) $(TOOLSSOURCE):\n\t@echo Runtime files not found.\n\t@echo You need to unpack the runtime archive before running \"make install\".\n\ttest -f error\n\n$(DESTDIR)$(exec_prefix) $(DEST_BIN) \\\n\t\t$(DEST_VIM) $(DEST_RT) $(DEST_HELP) \\\n\t\t$(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) $(DEST_FTP) \\\n\t\t$(DEST_LANG) $(DEST_KMAP) $(DEST_COMP) $(DEST_MACRO) \\\n\t\t$(DEST_PACK) $(DEST_TOOLS) $(DEST_TUTOR) $(DEST_SPELL) \\\n\t\t$(DEST_AUTO) $(DEST_AUTO)/xml $(DEST_PLUG):\n\t$(MKDIR_P) $@\n\t-chmod $(DIRMOD) $@\n\n# create links from various names to vim.  This is only done when the links\n# (or executables with the same name) don't exist yet.\ninstalllinks: $(GUI_TARGETS) \\\n\t\t\t$(DEST_BIN)/$(EXTARGET) \\\n\t\t\t$(DEST_BIN)/$(VIEWTARGET) \\\n\t\t\t$(DEST_BIN)/$(RVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(RVIEWTARGET) \\\n\t\t\t$(INSTALLVIMDIFF)\n\ninstallglinks: $(DEST_BIN)/$(GVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(GVIEWTARGET) \\\n\t\t\t$(DEST_BIN)/$(RGVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(RGVIEWTARGET) \\\n\t\t\t$(DEST_BIN)/$(EVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(EVIEWTARGET) \\\n\t\t\t$(INSTALLGVIMDIFF)\n\ninstallvimdiff: $(DEST_BIN)/$(VIMDIFFTARGET)\ninstallgvimdiff: $(DEST_BIN)/$(GVIMDIFFTARGET)\n\n$(DEST_BIN)/$(EXTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(EXTARGET)\n\n$(DEST_BIN)/$(VIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(VIEWTARGET)\n\n$(DEST_BIN)/$(GVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIMTARGET)\n\n$(DEST_BIN)/$(GVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIEWTARGET)\n\n$(DEST_BIN)/$(RVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RVIMTARGET)\n\n$(DEST_BIN)/$(RVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RVIEWTARGET)\n\n$(DEST_BIN)/$(RGVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RGVIMTARGET)\n\n$(DEST_BIN)/$(RGVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RGVIEWTARGET)\n\n$(DEST_BIN)/$(VIMDIFFTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(VIMDIFFTARGET)\n\n$(DEST_BIN)/$(GVIMDIFFTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIMDIFFTARGET)\n\n$(DEST_BIN)/$(EVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(EVIMTARGET)\n\n$(DEST_BIN)/$(EVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(EVIEWTARGET)\n\n# Create links for the manual pages with various names to vim.\tThis is only\n# done when the links (or manpages with the same name) don't exist yet.\n\nINSTALLMLARGS = $(VIMNAME) $(VIMDIFFNAME) $(EVIMNAME) \\\n\t\t$(EXNAME) $(VIEWNAME) $(RVIMNAME) $(RVIEWNAME) \\\n\t\t$(GVIMNAME) $(GVIEWNAME) $(RGVIMNAME) $(RGVIEWNAME) \\\n\t\t$(GVIMDIFFNAME) $(EVIEWNAME)\n\ninstallmanlinks:\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN) $(INSTALLMLARGS)\n\nuninstall: uninstall_runtime\n\t-rm -f $(DEST_BIN)/$(VIMTARGET)\n\t-rm -f $(DEST_BIN)/vimtutor\n\t-rm -f $(DEST_BIN)/gvimtutor\n\t-rm -f $(DEST_BIN)/$(EXTARGET) $(DEST_BIN)/$(VIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(GVIMTARGET) $(DEST_BIN)/$(GVIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(RVIMTARGET) $(DEST_BIN)/$(RVIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(RGVIMTARGET) $(DEST_BIN)/$(RGVIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(VIMDIFFTARGET) $(DEST_BIN)/$(GVIMDIFFTARGET)\n\t-rm -f $(DEST_BIN)/$(EVIMTARGET) $(DEST_BIN)/$(EVIEWTARGET)\n\t-rm -f $(DEST_BIN)/xxd$(EXEEXT)\n\n# Note: the \"rmdir\" will fail if any files were added after \"make install\"\nuninstall_runtime:\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR_I) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT_I) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_JA_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL_I) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_RU) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_RU_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_JA_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU_U) $(INSTALLMLARGS)\n\t-rm -f $(DEST_MAN)/xxd.1\n\t-rm -f $(DEST_MAN_FR)/xxd.1 $(DEST_MAN_FR_I)/xxd.1 $(DEST_MAN_FR_U)/xxd.1\n\t-rm -f $(DEST_MAN_IT)/xxd.1 $(DEST_MAN_IT_I)/xxd.1 $(DEST_MAN_IT_U)/xxd.1\n\t-rm -f $(DEST_MAN_JA_U)/xxd.1\n\t-rm -f $(DEST_MAN_PL)/xxd.1 $(DEST_MAN_PL_I)/xxd.1 $(DEST_MAN_PL_U)/xxd.1\n\t-rm -f $(DEST_MAN_RU)/xxd.1 $(DEST_MAN_RU_U)/xxd.1\n\t-rm -f $(DEST_HELP)/*.txt $(DEST_HELP)/tags $(DEST_HELP)/*.pl\n\t-rm -f $(DEST_HELP)/*.??x $(DEST_HELP)/tags-??\n\t-rm -f $(SYS_RGB_FILE)\n\t-rm -f $(SYS_MENU_FILE) $(SYS_SYNMENU_FILE) $(SYS_DELMENU_FILE)\n\t-rm -f $(SYS_BUGR_FILE) $(VIM_DEFAULTS_FILE) $(EVIM_FILE) $(MSWIN_FILE)\n\t-rm -f $(DEST_SCRIPT)/gvimrc_example.vim $(DEST_SCRIPT)/vimrc_example.vim\n\t-rm -f $(SYS_FILETYPE_FILE) $(SYS_FTOFF_FILE) $(SYS_SCRIPTS_FILE)\n\t-rm -f $(SYS_INDOFF_FILE) $(SYS_INDENT_FILE)\n\t-rm -f $(SYS_FTPLUGOF_FILE) $(SYS_FTPLUGIN_FILE)\n\t-rm -f $(SYS_OPTWIN_FILE)\n\t-rm -f $(DEST_COL)/*.vim $(DEST_COL)/README.txt\n\t-rm -f $(DEST_SYN)/*.vim $(DEST_SYN)/README.txt\n\t-rm -f $(DEST_IND)/*.vim $(DEST_IND)/README.txt\n\t-rm -rf $(DEST_MACRO)\n\t-rm -rf $(DEST_PACK)\n\t-rm -rf $(DEST_TUTOR)\n\t-rm -rf $(DEST_SPELL)\n\t-rm -rf $(DEST_TOOLS)\n\t-rm -rf $(DEST_LANG)\n\t-rm -rf $(DEST_KMAP)\n\t-rm -rf $(DEST_COMP)\n\t-rm -f $(DEST_PRINT)/*.ps\n\t-rmdir $(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND)\n\t-rm -rf $(DEST_FTP)/*.vim $(DEST_FTP)/README.txt $(DEST_FTP)/logtalk.dict\n\t-rm -f $(DEST_AUTO)/*.vim $(DEST_AUTO)/README.txt $(DEST_AUTO)/xml/*.vim\n\t-rm -f $(DEST_PLUG)/*.vim $(DEST_PLUG)/README.txt\n\t-rmdir $(DEST_FTP) $(DEST_AUTO)/xml $(DEST_AUTO) $(DEST_PLUG) $(DEST_RT)\n#\tThis will fail when other Vim versions are installed, no worries.\n\t-rmdir $(DEST_VIM)\n\n# Clean up all the files that have been produced, except configure's.\n# We support common typing mistakes for Juergen! :-)\nclean celan: testclean\n\t-rm -f *.o core $(VIMTARGET).core $(VIMTARGET) vim xxd/*.o\n\t-rm -rf objects\n\t-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c auto/gui_gtk_gresources.c auto/gui_gtk_gresources.h\n\t-rm -f conftest* *~ auto/link.sed\n\t-rm -f testdir/opt_test.vim\n\t-rm -f $(UNITTEST_TARGETS)\n\t-rm -f runtime pixmaps\n\t-rm -rf $(APPDIR)\n\t-rm -rf mzscheme_base.c\n\tif test -d $(PODIR); then \\\n\t\tcd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \\\n\tfi\n\n# Make a shadow directory for compilation on another system or with different\n# features.\nSHADOWDIR = shadow\n\nshadow:\truntime pixmaps\n\t$(MKDIR_P) $(SHADOWDIR)\n\tcd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../libvterm ../vimtutor ../gvimtutor ../install-sh .\n\tmkdir $(SHADOWDIR)/auto\n\tcd $(SHADOWDIR)/auto; ln -s ../../auto/configure .\n\t$(MKDIR_P) $(SHADOWDIR)/po\n\tcd $(SHADOWDIR)/po; ln -s ../../po/*.po ../../po/*.mak ../../po/*.vim ../../po/Makefile .\n\tcd $(SHADOWDIR); rm -f auto/link.sed\n\tcp Makefile configure $(SHADOWDIR)\n\trm -f $(SHADOWDIR)/auto/config.mk $(SHADOWDIR)/config.mk.dist\n\tcp config.mk.dist $(SHADOWDIR)/auto/config.mk\n\tcp config.mk.dist $(SHADOWDIR)\n\t$(MKDIR_P) $(SHADOWDIR)/xxd\n\tcd $(SHADOWDIR)/xxd; ln -s ../../xxd/*.[ch] ../../xxd/Make* .\n\tif test -d $(RSRC_DIR); then \\\n\t\tcd $(SHADOWDIR); \\\n\t\tln -s ../infplist.xml .; \\\n\t\tln -s ../$(RSRC_DIR) ../os_mac.rsr.hqx ../dehqx.py .; \\\n\tfi\n\t$(MKDIR_P) $(SHADOWDIR)/testdir\n\tcd $(SHADOWDIR)/testdir; ln -s ../../testdir/Makefile \\\n\t\t\t\t ../../testdir/Make_all.mak \\\n\t\t\t\t ../../testdir/README.txt \\\n\t\t\t\t ../../testdir/*.in \\\n\t\t\t\t ../../testdir/*.vim \\\n\t\t\t\t ../../testdir/*.py \\\n\t\t\t\t ../../testdir/python* \\\n\t\t\t\t ../../testdir/pyxfile \\\n\t\t\t\t ../../testdir/sautest \\\n\t\t\t\t ../../testdir/samples \\\n\t\t\t\t ../../testdir/test83-tags? \\\n\t\t\t\t ../../testdir/*.ok .\n\n# Link needed for doing \"make install\" in a shadow directory.\nruntime:\n\t-ln -s ../runtime .\n\n# Link needed for doing \"make\" using GTK in a shadow directory.\npixmaps:\n\t-ln -s ../pixmaps .\n\n# Update the synmenu.vim file with the latest Syntax menu.\n# This is only needed when runtime/makemenu.vim was changed.\nmenu: ./vim ../runtime/makemenu.vim\n\t./vim -u ../runtime/makemenu.vim\n\n# Start configure from scratch\nscrub scratch:\n\t-rm -f auto/config.status auto/config.cache config.log auto/config.log\n\t-rm -f auto/config.h auto/link.log auto/link.sed auto/config.mk\n\ttouch auto/config.h\n\tcp config.mk.dist auto/config.mk\n\ndistclean: clean scratch\n\t-rm -f tags\n\ndist: distclean\n\t@echo\n\t@echo Making the distribution has to be done in the top directory\n\nmdepend:\n\t-@rm -f Makefile~\n\tcp Makefile Makefile~\n\tsed -e '/\\#\\#\\# Dependencies/q' < Makefile > tmp_make\n\t@for i in $(ALL_SRC) ; do \\\n\t  echo \"$$i\" ; \\\n\t  echo `echo \"$$i\" | sed -e 's/[^ ]*\\.c$$/objects\\/\\1.o/'`\": $$i\" `\\\n\t    $(CPP) $$i |\\\n\t    grep '^# .*\"\\./.*\\.h\"' |\\\n\t    sort -t'\"' -u +1 -2 |\\\n\t    sed -e 's/.*\"\\.\\/\\(.*\\)\".*/\\1/'\\\n\t    ` >> tmp_make ; \\\n\tdone\n\tmv tmp_make Makefile\n\ndepend:\n\t-@rm -f Makefile~\n\tcp Makefile Makefile~\n\tsed -e '/\\#\\#\\# Dependencies/q' < Makefile > tmp_make\n\t-for i in $(ALL_SRC); do echo $$i; \\\n\t\t$(CPP_DEPEND) $$i | \\\n\t\tsed -e 's+^\\([^ ]*\\.o\\)+objects/\\1+' >> tmp_make; done\n\tmv tmp_make Makefile\n\n# Run lint.  Clean up the *.ln files that are sometimes left behind.\nlint:\n\t$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)\n\t-rm -f *.ln\n\n# Check dosinst.c with lint.\nlintinstall:\n\t$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c\n\t-rm -f dosinst.ln\n\n###########################################################################\n\n.c.o:\n\t$(CCC) $<\n\nauto/if_perl.c: if_perl.xs\n\t$(PERL) -e 'unless ( $$] >= 5.005 ) { for (qw(na defgv errgv)) { print \"#define PL_$$_ $$_\\n\" }}' > $@\n\t$(PERL) $(PERL_XSUBPP) -prototypes -typemap \\\n\t    $(PERLLIB)/ExtUtils/typemap if_perl.xs >> $@\n\nauto/osdef.h: auto/config.h osdef.sh osdef1.h.in osdef2.h.in\n\tCC=\"$(CC) $(OSDEF_CFLAGS)\" srcdir=$(srcdir) sh $(srcdir)/osdef.sh\n\nauto/pathdef.c: Makefile auto/config.mk\n\t-@echo creating $@\n\t-@echo '/* pathdef.c */' > $@\n\t-@echo '/* This file is automatically created by Makefile' >> $@\n\t-@echo ' * DO NOT EDIT!  Change Makefile only. */' >> $@\n\t-@echo '#include \"vim.h\"' >> $@\n\t-@echo 'char_u *default_vim_dir = (char_u *)\"$(VIMRCLOC)\";' | $(QUOTESED) >> $@\n\t-@echo 'char_u *default_vimruntime_dir = (char_u *)\"$(VIMRUNTIMEDIR)\";' | $(QUOTESED) >> $@\n\t-@echo 'char_u *all_cflags = (char_u *)\"$(CC) -c -I$(srcdir) $(ALL_CFLAGS)\";' | $(QUOTESED) >>  $@\n\t-@echo 'char_u *all_lflags = (char_u *)\"$(CC) $(ALL_LIB_DIRS) $(LDFLAGS) -o $(VIMTARGET) $(ALL_LIBS) \";' | $(QUOTESED) >>  $@\n\t-@echo 'char_u *compiled_user = (char_u *)\"' | tr -d $(NL) >> $@\n\t-@if test -n \"$(COMPILEDBY)\"; then \\\n\t\techo \"$(COMPILEDBY)\" | tr -d $(NL) >> $@; \\\n\t\telse ((logname) 2>/dev/null || whoami) | tr -d $(NL) >> $@; fi\n\t-@echo '\";' >> $@\n\t-@echo 'char_u *compiled_sys = (char_u *)\"' | tr -d $(NL) >> $@\n\t-@if test -z \"$(COMPILEDBY)\"; then hostname | tr -d $(NL) >> $@; fi\n\t-@echo '\";' >> $@\n\t-@sh $(srcdir)/pathdef.sh\n\nGUI_GTK_RES_INPUTS = \\\n\t../pixmaps/stock_vim_build_tags.png \\\n\t../pixmaps/stock_vim_find_help.png \\\n\t../pixmaps/stock_vim_save_all.png \\\n\t../pixmaps/stock_vim_session_load.png \\\n\t../pixmaps/stock_vim_session_new.png \\\n\t../pixmaps/stock_vim_session_save.png \\\n\t../pixmaps/stock_vim_shell.png \\\n\t../pixmaps/stock_vim_window_maximize.png \\\n\t../pixmaps/stock_vim_window_maximize_width.png \\\n\t../pixmaps/stock_vim_window_minimize.png \\\n\t../pixmaps/stock_vim_window_minimize_width.png \\\n\t../pixmaps/stock_vim_window_split.png \\\n\t../pixmaps/stock_vim_window_split_vertical.png\n\nauto/gui_gtk_gresources.c: gui_gtk_res.xml $(GUI_GTK_RES_INPUTS)\n\t$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=../pixmaps --generate --c-name=gui_gtk --manual-register gui_gtk_res.xml\nauto/gui_gtk_gresources.h: gui_gtk_res.xml $(GUI_GTK_RES_INPUTS)\n\tif test -z \"$(GLIB_COMPILE_RESOURCES)\"; then touch $@; else \\\n\t\t$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=../pixmaps --generate --c-name=gui_gtk --manual-register gui_gtk_res.xml; \\\n\tfi\n\n# All the object files are put in the \"objects\" directory.  Since not all make\n# commands understand putting object files in another directory, it must be\n# specified for each file separately.\n\nobjects: objects/.dirstamp\n\nobjects/.dirstamp:\n\t$(MKDIR_P) objects\n\ttouch objects/.dirstamp\n\n# All object files depend on the objects directory, so that parallel make\n# works.  Can't depend on the directory itself, its timestamp changes all the\n# time.\n$(ALL_OBJ): objects/.dirstamp\n\nobjects/arabic.o: arabic.c\n\t$(CCC) -o $@ arabic.c\n\nobjects/blowfish.o: blowfish.c\n\t$(CCC) -o $@ blowfish.c\n\nobjects/buffer.o: buffer.c\n\t$(CCC) -o $@ buffer.c\n\nobjects/charset.o: charset.c\n\t$(CCC) -o $@ charset.c\n\nobjects/crypt.o: crypt.c\n\t$(CCC) -o $@ crypt.c\n\nobjects/crypt_zip.o: crypt_zip.c\n\t$(CCC) -o $@ crypt_zip.c\n\nobjects/dict.o: dict.c\n\t$(CCC) -o $@ dict.c\n\nobjects/diff.o: diff.c\n\t$(CCC) -o $@ diff.c\n\nobjects/digraph.o: digraph.c\n\t$(CCC) -o $@ digraph.c\n\nobjects/edit.o: edit.c\n\t$(CCC) -o $@ edit.c\n\nobjects/eval.o: eval.c\n\t$(CCC) -o $@ eval.c\n\nobjects/evalfunc.o: evalfunc.c\n\t$(CCC) -o $@ evalfunc.c\n\nobjects/ex_cmds.o: ex_cmds.c\n\t$(CCC) -o $@ ex_cmds.c\n\nobjects/ex_cmds2.o: ex_cmds2.c\n\t$(CCC) -o $@ ex_cmds2.c\n\nobjects/ex_docmd.o: ex_docmd.c\n\t$(CCC) -o $@ ex_docmd.c\n\nobjects/ex_eval.o: ex_eval.c\n\t$(CCC) -o $@ ex_eval.c\n\nobjects/ex_getln.o: ex_getln.c\n\t$(CCC) -o $@ ex_getln.c\n\nobjects/farsi.o: farsi.c\n\t$(CCC) -o $@ farsi.c\n\nobjects/fileio.o: fileio.c\n\t$(CCC) -o $@ fileio.c\n\nobjects/fold.o: fold.c\n\t$(CCC) -o $@ fold.c\n\nobjects/getchar.o: getchar.c\n\t$(CCC) -o $@ getchar.c\n\nobjects/hardcopy.o: hardcopy.c\n\t$(CCC) -o $@ hardcopy.c\n\nobjects/hashtab.o: hashtab.c\n\t$(CCC) -o $@ hashtab.c\n\nobjects/gui.o: gui.c\n\t$(CCC) -o $@ gui.c\n\nobjects/gui_at_fs.o: gui_at_fs.c\n\t$(CCC) -o $@ gui_at_fs.c\n\nobjects/gui_at_sb.o: gui_at_sb.c\n\t$(CCC) -o $@ gui_at_sb.c\n\nobjects/gui_athena.o: gui_athena.c\n\t$(CCC) -o $@ gui_athena.c\n\nobjects/gui_beval.o: gui_beval.c\n\t$(CCC) -o $@ gui_beval.c\n\nobjects/gui_gtk.o: gui_gtk.c\n\t$(CCC) -o $@ gui_gtk.c\n\nobjects/gui_gtk_f.o: gui_gtk_f.c\n\t$(CCC) -o $@ gui_gtk_f.c\n\nobjects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c\n\t$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/gui_gtk_gresources.c\n\nobjects/gui_gtk_x11.o: gui_gtk_x11.c\n\t$(CCC) -o $@ gui_gtk_x11.c\n\nobjects/gui_motif.o: gui_motif.c\n\t$(CCC) -o $@ gui_motif.c\n\nobjects/gui_xmdlg.o: gui_xmdlg.c\n\t$(CCC) -o $@ gui_xmdlg.c\n\nobjects/gui_xmebw.o: gui_xmebw.c\n\t$(CCC) -o $@ gui_xmebw.c\n\nobjects/gui_x11.o: gui_x11.c\n\t$(CCC) -o $@ gui_x11.c\n\nobjects/gui_photon.o: gui_photon.c\n\t$(CCC) -o $@ gui_photon.c\n\nobjects/gui_mac.o: gui_mac.c\n\t$(CCC) -o $@ gui_mac.c\n\nobjects/hangulin.o: hangulin.c\n\t$(CCC) -o $@ hangulin.c\n\nobjects/if_cscope.o: if_cscope.c\n\t$(CCC) -o $@ if_cscope.c\n\nobjects/if_xcmdsrv.o: if_xcmdsrv.c\n\t$(CCC) -o $@ if_xcmdsrv.c\n\nobjects/if_lua.o: if_lua.c\n\t$(CCC_NF) $(LUA_CFLAGS) $(ALL_CFLAGS) -o $@ if_lua.c\n\nobjects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)\n\t$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c\n\nmzscheme_base.c:\n\t$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base\n\nobjects/if_perl.o: auto/if_perl.c\n\t$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/if_perl.c\n\nobjects/if_perlsfio.o: if_perlsfio.c\n\t$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ if_perlsfio.c\n\nobjects/py_getpath.o: $(PYTHON_CONFDIR)/getpath.c\n\t$(CCC_NF) $(PYTHON_CFLAGS) $(ALL_CFLAGS) -o $@ \\\n\t\t$(PYTHON_CONFDIR)/getpath.c \\\n\t\t-I$(PYTHON_CONFDIR) -DHAVE_CONFIG_H -DNO_MAIN \\\n\t\t$(PYTHON_GETPATH_CFLAGS)\n\nobjects/if_python.o: if_python.c if_py_both.h\n\t$(CCC_NF) $(PYTHON_CFLAGS) $(PYTHON_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python.c\n\nobjects/if_python3.o: if_python3.c if_py_both.h\n\t$(CCC_NF) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python3.c\n\nobjects/if_ruby.o: if_ruby.c\n\t$(CCC_NF) $(RUBY_CFLAGS) $(ALL_CFLAGS) -o $@ if_ruby.c\n\nobjects/if_tcl.o: if_tcl.c\n\t$(CCC_NF) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ if_tcl.c\n\nobjects/integration.o: integration.c\n\t$(CCC) -o $@ integration.c\n\nobjects/json.o: json.c\n\t$(CCC) -o $@ json.c\n\nobjects/json_test.o: json_test.c\n\t$(CCC) -o $@ json_test.c\n\nobjects/kword_test.o: kword_test.c\n\t$(CCC) -o $@ kword_test.c\n\nobjects/list.o: list.c\n\t$(CCC) -o $@ list.c\n\nobjects/main.o: main.c\n\t$(CCC) -o $@ main.c\n\nobjects/mark.o: mark.c\n\t$(CCC) -o $@ mark.c\n\nobjects/memfile.o: memfile.c\n\t$(CCC) -o $@ memfile.c\n\nobjects/memfile_test.o: memfile_test.c\n\t$(CCC) -o $@ memfile_test.c\n\nobjects/memline.o: memline.c\n\t$(CCC) -o $@ memline.c\n\nobjects/menu.o: menu.c\n\t$(CCC) -o $@ menu.c\n\nobjects/message.o: message.c\n\t$(CCC) -o $@ message.c\n\nobjects/message_test.o: message_test.c\n\t$(CCC) -o $@ message_test.c\n\nobjects/misc1.o: misc1.c\n\t$(CCC) -o $@ misc1.c\n\nobjects/misc2.o: misc2.c\n\t$(CCC) -o $@ misc2.c\n\nobjects/move.o: move.c\n\t$(CCC) -o $@ move.c\n\nobjects/mbyte.o: mbyte.c\n\t$(CCC) -o $@ mbyte.c\n\nobjects/normal.o: normal.c\n\t$(CCC) -o $@ normal.c\n\nobjects/ops.o: ops.c\n\t$(CCC) -o $@ ops.c\n\nobjects/option.o: option.c\n\t$(CCC_NF) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(RUBY_CFLAGS) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ option.c\n\nobjects/os_beos.o: os_beos.c\n\t$(CCC) -o $@ os_beos.c\n\nobjects/os_qnx.o: os_qnx.c\n\t$(CCC) -o $@ os_qnx.c\n\nobjects/os_macosx.o: os_macosx.m\n\t$(CCC) -o $@ os_macosx.m\n\nobjects/os_mac_conv.o: os_mac_conv.c\n\t$(CCC) -o $@ os_mac_conv.c\n\nobjects/os_unix.o: os_unix.c\n\t$(CCC) -o $@ os_unix.c\n\nobjects/os_mswin.o: os_mswin.c\n\t$(CCC) -o $@ os_mswin.c\n\nobjects/winclip.o: winclip.c\n\t$(CCC) -o $@ winclip.c\n\nobjects/pathdef.o: auto/pathdef.c\n\t$(CCC) -o $@ auto/pathdef.c\n\nobjects/popupmnu.o: popupmnu.c\n\t$(CCC) -o $@ popupmnu.c\n\nobjects/pty.o: pty.c\n\t$(CCC) -o $@ pty.c\n\nobjects/quickfix.o: quickfix.c\n\t$(CCC) -o $@ quickfix.c\n\nobjects/regexp.o: regexp.c regexp_nfa.c\n\t$(CCC) -o $@ regexp.c\n\nobjects/screen.o: screen.c\n\t$(CCC) -o $@ screen.c\n\nobjects/search.o: search.c\n\t$(CCC) -o $@ search.c\n\nobjects/sha256.o: sha256.c\n\t$(CCC) -o $@ sha256.c\n\nobjects/spell.o: spell.c\n\t$(CCC) -o $@ spell.c\n\nobjects/spellfile.o: spellfile.c\n\t$(CCC) -o $@ spellfile.c\n\nobjects/syntax.o: syntax.c\n\t$(CCC) -o $@ syntax.c\n\nobjects/tag.o: tag.c\n\t$(CCC) -o $@ tag.c\n\nobjects/term.o: term.c\n\t$(CCC) -o $@ term.c\n\nobjects/terminal.o: terminal.c $(TERM_DEPS)\n\t$(CCC) -o $@ terminal.c\n\nobjects/ui.o: ui.c\n\t$(CCC) -o $@ ui.c\n\nobjects/undo.o: undo.c\n\t$(CCC) -o $@ undo.c\n\nobjects/userfunc.o: userfunc.c\n\t$(CCC) -o $@ userfunc.c\n\nobjects/window.o: window.c\n\t$(CCC) -o $@ window.c\n\nobjects/workshop.o: workshop.c\n\t$(CCC) -o $@ workshop.c\n\nobjects/wsdebug.o: wsdebug.c\n\t$(CCC) -o $@ wsdebug.c\n\nobjects/netbeans.o: netbeans.c\n\t$(CCC) -o $@ netbeans.c\n\nobjects/channel.o: channel.c\n\t$(CCC) -o $@ channel.c\n\nMakefile:\n\t@echo The name of the makefile MUST be \"Makefile\" (with capital M)!!!!\n\nCCCTERM = $(CCC_NF) -Ilibvterm/include $(ALL_CFLAGS) -DINLINE=\"\" \\\n\t  -DVSNPRINTF=vim_vsnprintf \\\n\t  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \\\n\t  -DWCWIDTH_FUNCTION=utf_uint2cells\n\nobjects/term_encoding.o: libvterm/src/encoding.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/encoding.c\n\nobjects/term_keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/keyboard.c\n\nobjects/term_mouse.o: libvterm/src/mouse.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/mouse.c\n\nobjects/term_parser.o: libvterm/src/parser.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/parser.c\n\nobjects/term_pen.o: libvterm/src/pen.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/pen.c\n\nobjects/term_screen.o: libvterm/src/screen.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/screen.c\n\nobjects/term_state.o: libvterm/src/state.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/state.c\n\nobjects/term_unicode.o: libvterm/src/unicode.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/unicode.c\n\nobjects/term_vterm.o: libvterm/src/vterm.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/vterm.c\n\n###############################################################################\n### MacOS X installation\n###\n### This installs a runnable Vim.app in $(prefix)\n\nREZ    = /Developer/Tools/Rez\nRESDIR = $(APPDIR)/Contents/Resources\nVERSION = $(VIMMAJOR).$(VIMMINOR)\n\n### Common flags\nM4FLAGSX = $(M4FLAGS) -DAPP_EXE=$(VIMNAME) -DAPP_NAME=$(VIMNAME) \\\n\t\t-DAPP_VER=$(VERSION)\n\ninstall_macosx: gui_bundle\n# Remove the link to the runtime dir, don't want to copy all of that.\n\t-rm $(RESDIR)/vim/runtime\n\t$(INSTALL_DATA_R) $(APPDIR) $(DESTDIR)$(prefix)\n# Generate the help tags file now, it won't work with \"make installruntime\".\n\t-@srcdir=`pwd`; cd $(HELPSOURCE); $(MAKE) VIMEXE=$$srcdir/$(VIMTARGET) vimtags\n# Install the runtime files.  Recursive!\n\t$(MKDIR_P) $(DESTDIR)$(prefix)/$(RESDIR)/vim/runtime\n\tsrcdir=`pwd`; $(MAKE) -f Makefile installruntime \\\n\t\tVIMEXE=$$srcdir/$(VIMTARGET) \\\n\t\tprefix=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR) \\\n\t\texec_prefix=$(DESTDIR)$(prefix)/$(APPDIR)/Contents \\\n\t\tBINDIR=$(DESTDIR)$(prefix)/$(APPDIR)/Contents/MacOS \\\n\t\tVIMLOC=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR) \\\n\t\tVIMRTLOC=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR)/runtime\n# Put the link back.\n\tln -s `pwd`/../runtime $(RESDIR)/vim\n# Copy rgb.txt, Mac doesn't always have X11\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(DESTDIR)$(prefix)/$(RESDIR)/vim/runtime\n# TODO: Create the vimtutor and/or gvimtutor application.\n\ngui_bundle: $(RESDIR) bundle-dir bundle-executable bundle-info bundle-resource \\\n\tbundle-language\n\n$(RESDIR):\n\t$(MKDIR_P) $@\n\nbundle-dir: $(APPDIR)/Contents $(VIMTARGET)\n# Make a link to the runtime directory, so that we can try out the executable\n# without installing it.\n\t$(MKDIR_P) $(RESDIR)/vim\n\t-ln -s `pwd`/../runtime $(RESDIR)/vim\n\nbundle-executable: $(VIMTARGET)\n\t$(MKDIR_P) $(APPDIR)/Contents/MacOS\n\tcp $(VIMTARGET) $(APPDIR)/Contents/MacOS/$(VIMTARGET)\n\nbundle-info:  bundle-dir\n\t@echo \"Creating PkgInfo\"\n\t@echo -n \"APPLVIM!\" > $(APPDIR)/Contents/PkgInfo\n\t@echo \"Creating Info.plist\"\n\tm4 $(M4FLAGSX) infplist.xml > $(APPDIR)/Contents/Info.plist\n\nbundle-resource: bundle-dir bundle-rsrc\n\tcp -f $(RSRC_DIR)/*.icns $(RESDIR)\n\n### Classic resources\n# Resource fork (in the form of a .rsrc file) for Classic Vim (Mac OS 9)\n# This file is also required for OS X Vim.\nbundle-rsrc: os_mac.rsr.hqx\n\t@echo \"Creating resource fork\"\n\tpython dehqx.py $<\n\trm -f gui_mac.rsrc\n\tmv gui_mac.rsrc.rsrcfork $(RESDIR)/$(VIMNAME).rsrc\n\n# po/Make_osx.pl says something about generating a Mac message file\n# for Ukrainian.  Would somebody using Mac OS X in Ukrainian\n# *really* be upset that Carbon Vim was not localised in\n# Ukrainian?\n#\n#bundle-language: bundle-dir po/Make_osx.pl\n#\tcd po && perl Make_osx.pl --outdir ../$(RESDIR) $(MULTILANG)\nbundle-language: bundle-dir\n\n$(APPDIR)/Contents:\n\t$(MKDIR_P) $(APPDIR)/Contents/MacOS\n\t$(MKDIR_P) $(RESDIR)/English.lproj\n\n\n###############################################################################\n### (automatically generated by 'make depend')\n### Dependencies:\nobjects/arabic.o: arabic.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/blowfish.o: blowfish.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/buffer.o: buffer.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/charset.o: charset.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/crypt.o: crypt.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/crypt_zip.o: crypt_zip.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/dict.o: dict.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/diff.o: diff.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/digraph.o: digraph.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/edit.o: edit.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/eval.o: eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/evalfunc.o: evalfunc.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/ex_cmds.o: ex_cmds.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/ex_cmds2.o: ex_cmds2.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/ex_docmd.o: ex_docmd.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h ex_cmdidxs.h\nobjects/ex_eval.o: ex_eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/ex_getln.o: ex_getln.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/farsi.o: farsi.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/fileio.o: fileio.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/fold.o: fold.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/getchar.o: getchar.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/hardcopy.o: hardcopy.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/hashtab.o: hashtab.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/if_cscope.o: if_cscope.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_cscope.h\nobjects/if_xcmdsrv.o: if_xcmdsrv.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/json.o: json.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/list.o: list.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/main.o: main.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/mark.o: mark.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/memfile.o: memfile.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/memline.o: memline.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/menu.o: menu.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/message.o: message.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/misc1.o: misc1.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/misc2.o: misc2.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/move.o: move.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/mbyte.o: mbyte.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/normal.o: normal.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/ops.o: ops.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/option.o: option.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/os_unix.o: os_unix.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h os_unixx.h\nobjects/pathdef.o: auto/pathdef.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/popupmnu.o: popupmnu.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/quickfix.o: quickfix.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/regexp.o: regexp.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h regexp_nfa.c\nobjects/screen.o: screen.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/search.o: search.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/sha256.o: sha256.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/spell.o: spell.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/spellfile.o: spellfile.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/syntax.o: syntax.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/tag.o: tag.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/term.o: term.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/terminal.o: terminal.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/ui.o: ui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/undo.o: undo.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/userfunc.o: userfunc.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/version.o: version.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/window.o: window.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/gui.o: gui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/gui_gtk.o: gui_gtk.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h gui_gtk_f.h\nobjects/gui_gtk_f.o: gui_gtk_f.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_gtk_f.h\nobjects/gui_motif.o: gui_motif.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_xmebw.h ../pixmaps/alert.xpm \\\n ../pixmaps/error.xpm ../pixmaps/generic.xpm ../pixmaps/info.xpm \\\n ../pixmaps/quest.xpm gui_x11_pm.h ../pixmaps/tb_new.xpm \\\n ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm ../pixmaps/tb_save.xpm \\\n ../pixmaps/tb_print.xpm ../pixmaps/tb_cut.xpm ../pixmaps/tb_copy.xpm \\\n ../pixmaps/tb_paste.xpm ../pixmaps/tb_find.xpm \\\n ../pixmaps/tb_find_next.xpm ../pixmaps/tb_find_prev.xpm \\\n ../pixmaps/tb_find_help.xpm ../pixmaps/tb_exit.xpm \\\n ../pixmaps/tb_undo.xpm ../pixmaps/tb_redo.xpm ../pixmaps/tb_help.xpm \\\n ../pixmaps/tb_macro.xpm ../pixmaps/tb_make.xpm \\\n ../pixmaps/tb_save_all.xpm ../pixmaps/tb_jump.xpm \\\n ../pixmaps/tb_ctags.xpm ../pixmaps/tb_load_session.xpm \\\n ../pixmaps/tb_save_session.xpm ../pixmaps/tb_new_session.xpm \\\n ../pixmaps/tb_blank.xpm ../pixmaps/tb_maximize.xpm \\\n ../pixmaps/tb_split.xpm ../pixmaps/tb_minimize.xpm \\\n ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \\\n ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \\\n ../pixmaps/tb_minwidth.xpm\nobjects/gui_xmdlg.o: gui_xmdlg.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/gui_xmebw.o: gui_xmebw.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_xmebwp.h gui_xmebw.h\nobjects/gui_athena.o: gui_athena.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_at_sb.h gui_x11_pm.h \\\n ../pixmaps/tb_new.xpm ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm \\\n ../pixmaps/tb_save.xpm ../pixmaps/tb_print.xpm ../pixmaps/tb_cut.xpm \\\n ../pixmaps/tb_copy.xpm ../pixmaps/tb_paste.xpm ../pixmaps/tb_find.xpm \\\n ../pixmaps/tb_find_next.xpm ../pixmaps/tb_find_prev.xpm \\\n ../pixmaps/tb_find_help.xpm ../pixmaps/tb_exit.xpm \\\n ../pixmaps/tb_undo.xpm ../pixmaps/tb_redo.xpm ../pixmaps/tb_help.xpm \\\n ../pixmaps/tb_macro.xpm ../pixmaps/tb_make.xpm \\\n ../pixmaps/tb_save_all.xpm ../pixmaps/tb_jump.xpm \\\n ../pixmaps/tb_ctags.xpm ../pixmaps/tb_load_session.xpm \\\n ../pixmaps/tb_save_session.xpm ../pixmaps/tb_new_session.xpm \\\n ../pixmaps/tb_blank.xpm ../pixmaps/tb_maximize.xpm \\\n ../pixmaps/tb_split.xpm ../pixmaps/tb_minimize.xpm \\\n ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \\\n ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \\\n ../pixmaps/tb_minwidth.xpm\nobjects/gui_gtk_x11.o: gui_gtk_x11.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h auto/gui_gtk_gresources.h gui_gtk_f.h \\\n ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm\nobjects/gui_x11.o: gui_x11.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h ../runtime/vim32x32.xpm \\\n ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm\nobjects/gui_at_sb.o: gui_at_sb.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_at_sb.h\nobjects/gui_at_fs.o: gui_at_fs.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_at_sb.h\nobjects/pty.o: pty.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/json_test.o: json_test.c main.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h json.c\nobjects/kword_test.o: kword_test.c main.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h charset.c\nobjects/memfile_test.o: memfile_test.c main.c vim.h auto/config.h feature.h \\\n os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \\\n structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \\\n ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h memfile.c\nobjects/message_test.o: message_test.c main.c vim.h auto/config.h feature.h \\\n os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \\\n structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \\\n ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h message.c\nobjects/hangulin.o: hangulin.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/if_lua.o: if_lua.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/if_mzsch.o: if_mzsch.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_mzsch.h\nobjects/if_perl.o: auto/if_perl.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/if_perlsfio.o: if_perlsfio.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/if_python.o: if_python.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_py_both.h\nobjects/if_python3.o: if_python3.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_py_both.h\nobjects/if_tcl.o: if_tcl.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/if_ruby.o: if_ruby.c auto/config.h vim.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/gui_beval.o: gui_beval.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/workshop.o: workshop.c auto/config.h integration.h vim.h feature.h \\\n os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \\\n structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \\\n ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h version.h \\\n workshop.h\nobjects/wsdebug.o: wsdebug.c\nobjects/integration.o: integration.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h integration.h\nobjects/netbeans.o: netbeans.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/channel.o: channel.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * fileio.c: read from and write to a file\n */\n\n#include \"vim.h\"\n\n#if defined(__TANDEM) || defined(__MINT__)\n# include <limits.h>\t\t/* for SSIZE_MAX */\n#endif\n\n#if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)\n# include <utime.h>\t\t/* for struct utimbuf */\n#endif\n\n#define BUFSIZE\t\t8192\t/* size of normal write buffer */\n#define SMBUFSIZE\t256\t/* size of emergency write buffer */\n\n/* Is there any system that doesn't have access()? */\n#define USE_MCH_ACCESS\n\n#ifdef FEAT_MBYTE\nstatic char_u *next_fenc(char_u **pp);\n# ifdef FEAT_EVAL\nstatic char_u *readfile_charconvert(char_u *fname, char_u *fenc, int *fdp);\n# endif\n#endif\n#ifdef FEAT_VIMINFO\nstatic void check_marks_read(void);\n#endif\n#ifdef FEAT_CRYPT\nstatic char_u *check_for_cryptkey(char_u *cryptkey, char_u *ptr, long *sizep, off_T *filesizep, int newfile, char_u *fname, int *did_ask);\n#endif\n#ifdef UNIX\nstatic void set_file_time(char_u *fname, time_t atime, time_t mtime);\n#endif\nstatic int set_rw_fname(char_u *fname, char_u *sfname);\nstatic int msg_add_fileformat(int eol_type);\nstatic void msg_add_eol(void);\nstatic int check_mtime(buf_T *buf, stat_T *s);\nstatic int time_differs(long t1, long t2);\n#ifdef FEAT_AUTOCMD\nstatic int apply_autocmds_exarg(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap);\nstatic int au_find_group(char_u *name);\n\n# define AUGROUP_DEFAULT    -1\t    /* default autocmd group */\n# define AUGROUP_ERROR\t    -2\t    /* erroneous autocmd group */\n# define AUGROUP_ALL\t    -3\t    /* all autocmd groups */\n#endif\n\n#if defined(FEAT_CRYPT) || defined(FEAT_MBYTE)\n# define HAS_BW_FLAGS\n# define FIO_LATIN1\t0x01\t/* convert Latin1 */\n# define FIO_UTF8\t0x02\t/* convert UTF-8 */\n# define FIO_UCS2\t0x04\t/* convert UCS-2 */\n# define FIO_UCS4\t0x08\t/* convert UCS-4 */\n# define FIO_UTF16\t0x10\t/* convert UTF-16 */\n# ifdef WIN3264\n#  define FIO_CODEPAGE\t0x20\t/* convert MS-Windows codepage */\n#  define FIO_PUT_CP(x) (((x) & 0xffff) << 16)\t/* put codepage in top word */\n#  define FIO_GET_CP(x)\t(((x)>>16) & 0xffff)\t/* get codepage from top word */\n# endif\n# ifdef MACOS_CONVERT\n#  define FIO_MACROMAN\t0x20\t/* convert MacRoman */\n# endif\n# define FIO_ENDIAN_L\t0x80\t/* little endian */\n# define FIO_ENCRYPTED\t0x1000\t/* encrypt written bytes */\n# define FIO_NOCONVERT\t0x2000\t/* skip encoding conversion */\n# define FIO_UCSBOM\t0x4000\t/* check for BOM at start of file */\n# define FIO_ALL\t-1\t/* allow all formats */\n#endif\n\n/* When converting, a read() or write() may leave some bytes to be converted\n * for the next call.  The value is guessed... */\n#define CONV_RESTLEN 30\n\n/* We have to guess how much a sequence of bytes may expand when converting\n * with iconv() to be able to allocate a buffer. */\n#define ICONV_MULT 8\n\n/*\n * Structure to pass arguments from buf_write() to buf_write_bytes().\n */\nstruct bw_info\n{\n    int\t\tbw_fd;\t\t/* file descriptor */\n    char_u\t*bw_buf;\t/* buffer with data to be written */\n    int\t\tbw_len;\t\t/* length of data */\n#ifdef HAS_BW_FLAGS\n    int\t\tbw_flags;\t/* FIO_ flags */\n#endif\n#ifdef FEAT_CRYPT\n    buf_T\t*bw_buffer;\t/* buffer being written */\n#endif\n#ifdef FEAT_MBYTE\n    char_u\tbw_rest[CONV_RESTLEN]; /* not converted bytes */\n    int\t\tbw_restlen;\t/* nr of bytes in bw_rest[] */\n    int\t\tbw_first;\t/* first write call */\n    char_u\t*bw_conv_buf;\t/* buffer for writing converted chars */\n    int\t\tbw_conv_buflen; /* size of bw_conv_buf */\n    int\t\tbw_conv_error;\t/* set for conversion error */\n    linenr_T\tbw_conv_error_lnum;  /* first line with error or zero */\n    linenr_T\tbw_start_lnum;  /* line number at start of buffer */\n# ifdef USE_ICONV\n    iconv_t\tbw_iconv_fd;\t/* descriptor for iconv() or -1 */\n# endif\n#endif\n};\n\nstatic int  buf_write_bytes(struct bw_info *ip);\n\n#ifdef FEAT_MBYTE\nstatic linenr_T readfile_linenr(linenr_T linecnt, char_u *p, char_u *endp);\nstatic int ucs2bytes(unsigned c, char_u **pp, int flags);\nstatic int need_conversion(char_u *fenc);\nstatic int get_fio_flags(char_u *ptr);\nstatic char_u *check_for_bom(char_u *p, long size, int *lenp, int flags);\nstatic int make_bom(char_u *buf, char_u *name);\n# ifdef WIN3264\nstatic int get_win_fio_flags(char_u *ptr);\n# endif\n# ifdef MACOS_CONVERT\nstatic int get_mac_fio_flags(char_u *ptr);\n# endif\n#endif\nstatic int move_lines(buf_T *frombuf, buf_T *tobuf);\n#ifdef TEMPDIRNAMES\nstatic void vim_settempdir(char_u *tempdir);\n#endif\n#ifdef FEAT_AUTOCMD\nstatic char *e_auchangedbuf = N_(\"E812: Autocommands changed buffer or buffer name\");\n#endif\n\n#ifdef FEAT_AUTOCMD\n/*\n * Set by the apply_autocmds_group function if the given event is equal to\n * EVENT_FILETYPE. Used by the readfile function in order to determine if\n * EVENT_BUFREADPOST triggered the EVENT_FILETYPE.\n *\n * Relying on this value requires one to reset it prior calling\n * apply_autocmds_group.\n */\nstatic int au_did_filetype INIT(= FALSE);\n#endif\n\n    void\nfilemess(\n    buf_T\t*buf,\n    char_u\t*name,\n    char_u\t*s,\n    int\t\tattr)\n{\n    int\t\tmsg_scroll_save;\n\n    if (msg_silent != 0)\n\treturn;\n    msg_add_fname(buf, name);\t    /* put file name in IObuff with quotes */\n    /* If it's extremely long, truncate it. */\n    if (STRLEN(IObuff) > IOSIZE - 80)\n\tIObuff[IOSIZE - 80] = NUL;\n    STRCAT(IObuff, s);\n    /*\n     * For the first message may have to start a new line.\n     * For further ones overwrite the previous one, reset msg_scroll before\n     * calling filemess().\n     */\n    msg_scroll_save = msg_scroll;\n    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\tmsg_scroll = FALSE;\n    if (!msg_scroll)\t/* wait a bit when overwriting an error msg */\n\tcheck_for_delay(FALSE);\n    msg_start();\n    msg_scroll = msg_scroll_save;\n    msg_scrolled_ign = TRUE;\n    /* may truncate the message to avoid a hit-return prompt */\n    msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);\n    msg_clr_eos();\n    out_flush();\n    msg_scrolled_ign = FALSE;\n}\n\n/*\n * Read lines from file \"fname\" into the buffer after line \"from\".\n *\n * 1. We allocate blocks with lalloc, as big as possible.\n * 2. Each block is filled with characters from the file with a single read().\n * 3. The lines are inserted in the buffer with ml_append().\n *\n * (caller must check that fname != NULL, unless READ_STDIN is used)\n *\n * \"lines_to_skip\" is the number of lines that must be skipped\n * \"lines_to_read\" is the number of lines that are appended\n * When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.\n *\n * flags:\n * READ_NEW\tstarting to edit a new buffer\n * READ_FILTER\treading filter output\n * READ_STDIN\tread from stdin instead of a file\n * READ_BUFFER\tread from curbuf instead of a file (converting after reading\n *\t\tstdin)\n * READ_DUMMY\tread into a dummy buffer (to check if file contents changed)\n * READ_KEEP_UNDO  don't clear undo info or read it from a file\n * READ_FIFO\tread from fifo/socket instead of a file\n *\n * return FAIL for failure, NOTDONE for directory (failure), or OK\n */\n    int\nreadfile(\n    char_u\t*fname,\n    char_u\t*sfname,\n    linenr_T\tfrom,\n    linenr_T\tlines_to_skip,\n    linenr_T\tlines_to_read,\n    exarg_T\t*eap,\t\t\t/* can be NULL! */\n    int\t\tflags)\n{\n    int\t\tfd = 0;\n    int\t\tnewfile = (flags & READ_NEW);\n    int\t\tcheck_readonly;\n    int\t\tfiltering = (flags & READ_FILTER);\n    int\t\tread_stdin = (flags & READ_STDIN);\n    int\t\tread_buffer = (flags & READ_BUFFER);\n    int\t\tread_fifo = (flags & READ_FIFO);\n    int\t\tset_options = newfile || read_buffer\n\t\t\t\t\t   || (eap != NULL && eap->read_edit);\n    linenr_T\tread_buf_lnum = 1;\t/* next line to read from curbuf */\n    colnr_T\tread_buf_col = 0;\t/* next char to read from this line */\n    char_u\tc;\n    linenr_T\tlnum = from;\n    char_u\t*ptr = NULL;\t\t/* pointer into read buffer */\n    char_u\t*buffer = NULL;\t\t/* read buffer */\n    char_u\t*new_buffer = NULL;\t/* init to shut up gcc */\n    char_u\t*line_start = NULL;\t/* init to shut up gcc */\n    int\t\twasempty;\t\t/* buffer was empty before reading */\n    colnr_T\tlen;\n    long\tsize = 0;\n    char_u\t*p;\n    off_T\tfilesize = 0;\n    int\t\tskip_read = FALSE;\n#ifdef FEAT_CRYPT\n    char_u\t*cryptkey = NULL;\n    int\t\tdid_ask_for_key = FALSE;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n    context_sha256_T sha_ctx;\n    int\t\tread_undo_file = FALSE;\n#endif\n    int\t\tsplit = 0;\t\t/* number of split lines */\n#define UNKNOWN\t 0x0fffffff\t\t/* file size is unknown */\n    linenr_T\tlinecnt;\n    int\t\terror = FALSE;\t\t/* errors encountered */\n    int\t\tff_error = EOL_UNKNOWN; /* file format with errors */\n    long\tlinerest = 0;\t\t/* remaining chars in line */\n#ifdef UNIX\n    int\t\tperm = 0;\n    int\t\tswap_mode = -1;\t\t/* protection bits for swap file */\n#else\n    int\t\tperm;\n#endif\n    int\t\tfileformat = 0;\t\t/* end-of-line format */\n    int\t\tkeep_fileformat = FALSE;\n    stat_T\tst;\n    int\t\tfile_readonly;\n    linenr_T\tskip_count = 0;\n    linenr_T\tread_count = 0;\n    int\t\tmsg_save = msg_scroll;\n    linenr_T\tread_no_eol_lnum = 0;   /* non-zero lnum when last line of\n\t\t\t\t\t * last read was missing the eol */\n    int\t\ttry_mac;\n    int\t\ttry_dos;\n    int\t\ttry_unix;\n    int\t\tfile_rewind = FALSE;\n#ifdef FEAT_MBYTE\n    int\t\tcan_retry;\n    linenr_T\tconv_error = 0;\t\t/* line nr with conversion error */\n    linenr_T\tillegal_byte = 0;\t/* line nr with illegal byte */\n    int\t\tkeep_dest_enc = FALSE;\t/* don't retry when char doesn't fit\n\t\t\t\t\t   in destination encoding */\n    int\t\tbad_char_behavior = BAD_REPLACE;\n\t\t\t\t\t/* BAD_KEEP, BAD_DROP or character to\n\t\t\t\t\t * replace with */\n    char_u\t*tmpname = NULL;\t/* name of 'charconvert' output file */\n    int\t\tfio_flags = 0;\n    char_u\t*fenc;\t\t\t/* fileencoding to use */\n    int\t\tfenc_alloced;\t\t/* fenc_next is in allocated memory */\n    char_u\t*fenc_next = NULL;\t/* next item in 'fencs' or NULL */\n    int\t\tadvance_fenc = FALSE;\n    long\treal_size = 0;\n# ifdef USE_ICONV\n    iconv_t\ticonv_fd = (iconv_t)-1;\t/* descriptor for iconv() or -1 */\n#  ifdef FEAT_EVAL\n    int\t\tdid_iconv = FALSE;\t/* TRUE when iconv() failed and trying\n\t\t\t\t\t   'charconvert' next */\n#  endif\n# endif\n    int\t\tconverted = FALSE;\t/* TRUE if conversion done */\n    int\t\tnotconverted = FALSE;\t/* TRUE if conversion wanted but it\n\t\t\t\t\t   wasn't possible */\n    char_u\tconv_rest[CONV_RESTLEN];\n    int\t\tconv_restlen = 0;\t/* nr of bytes in conv_rest[] */\n#endif\n#ifdef FEAT_AUTOCMD\n    buf_T\t*old_curbuf;\n    char_u\t*old_b_ffname;\n    char_u\t*old_b_fname;\n    int\t\tusing_b_ffname;\n    int\t\tusing_b_fname;\n#endif\n\n#ifdef FEAT_AUTOCMD\n    au_did_filetype = FALSE; /* reset before triggering any autocommands */\n#endif\n\n    curbuf->b_no_eol_lnum = 0;\t/* in case it was set by the previous read */\n\n    /*\n     * If there is no file name yet, use the one for the read file.\n     * BF_NOTEDITED is set to reflect this.\n     * Don't do this for a read from a filter.\n     * Only do this when 'cpoptions' contains the 'f' flag.\n     */\n    if (curbuf->b_ffname == NULL\n\t    && !filtering\n\t    && fname != NULL\n\t    && vim_strchr(p_cpo, CPO_FNAMER) != NULL\n\t    && !(flags & READ_DUMMY))\n    {\n\tif (set_rw_fname(fname, sfname) == FAIL)\n\t    return FAIL;\n    }\n\n#ifdef FEAT_AUTOCMD\n    /* Remember the initial values of curbuf, curbuf->b_ffname and\n     * curbuf->b_fname to detect whether they are altered as a result of\n     * executing nasty autocommands.  Also check if \"fname\" and \"sfname\"\n     * point to one of these values. */\n    old_curbuf = curbuf;\n    old_b_ffname = curbuf->b_ffname;\n    old_b_fname = curbuf->b_fname;\n    using_b_ffname = (fname == curbuf->b_ffname)\n\t\t\t\t\t      || (sfname == curbuf->b_ffname);\n    using_b_fname = (fname == curbuf->b_fname) || (sfname == curbuf->b_fname);\n#endif\n\n    /* After reading a file the cursor line changes but we don't want to\n     * display the line. */\n    ex_no_reprint = TRUE;\n\n    /* don't display the file info for another buffer now */\n    need_fileinfo = FALSE;\n\n    /*\n     * For Unix: Use the short file name whenever possible.\n     * Avoids problems with networks and when directory names are changed.\n     * Don't do this for MS-DOS, a \"cd\" in a sub-shell may have moved us to\n     * another directory, which we don't detect.\n     */\n    if (sfname == NULL)\n\tsfname = fname;\n#if defined(UNIX)\n    fname = sfname;\n#endif\n\n#ifdef FEAT_AUTOCMD\n    /*\n     * The BufReadCmd and FileReadCmd events intercept the reading process by\n     * executing the associated commands instead.\n     */\n    if (!filtering && !read_stdin && !read_buffer)\n    {\n\tpos_T\t    pos;\n\n\tpos = curbuf->b_op_start;\n\n\t/* Set '[ mark to the line above where the lines go (line 1 if zero). */\n\tcurbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n\tcurbuf->b_op_start.col = 0;\n\n\tif (newfile)\n\t{\n\t    if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap))\n#ifdef FEAT_EVAL\n\t\treturn aborting() ? FAIL : OK;\n#else\n\t\treturn OK;\n#endif\n\t}\n\telse if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,\n\t\t\t\t\t\t\t    FALSE, NULL, eap))\n#ifdef FEAT_EVAL\n\t    return aborting() ? FAIL : OK;\n#else\n\t    return OK;\n#endif\n\n\tcurbuf->b_op_start = pos;\n    }\n#endif\n\n    if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)\n\tmsg_scroll = FALSE;\t/* overwrite previous file message */\n    else\n\tmsg_scroll = TRUE;\t/* don't overwrite previous file message */\n\n    /*\n     * If the name ends in a path separator, we can't open it.  Check here,\n     * because reading the file may actually work, but then creating the swap\n     * file may destroy it!  Reported on MS-DOS and Win 95.\n     * If the name is too long we might crash further on, quit here.\n     */\n    if (fname != NULL && *fname != NUL)\n    {\n\tp = fname + STRLEN(fname);\n\tif (after_pathsep(fname, p) || STRLEN(fname) >= MAXPATHL)\n\t{\n\t    filemess(curbuf, fname, (char_u *)_(\"Illegal file name\"), 0);\n\t    msg_end();\n\t    msg_scroll = msg_save;\n\t    return FAIL;\n\t}\n    }\n\n    if (!read_stdin && !read_buffer && !read_fifo)\n    {\n#ifdef UNIX\n\t/*\n\t * On Unix it is possible to read a directory, so we have to\n\t * check for it before the mch_open().\n\t */\n\tperm = mch_getperm(fname);\n\tif (perm >= 0 && !S_ISREG(perm)\t\t    /* not a regular file ... */\n# ifdef S_ISFIFO\n\t\t      && !S_ISFIFO(perm)\t    /* ... or fifo */\n# endif\n# ifdef S_ISSOCK\n\t\t      && !S_ISSOCK(perm)\t    /* ... or socket */\n# endif\n# ifdef OPEN_CHR_FILES\n\t\t      && !(S_ISCHR(perm) && is_dev_fd_file(fname))\n\t\t\t/* ... or a character special file named /dev/fd/<n> */\n# endif\n\t\t\t\t\t\t)\n\t{\n\t    int retval = FAIL;\n\n\t    if (S_ISDIR(perm))\n\t    {\n\t\tfilemess(curbuf, fname, (char_u *)_(\"is a directory\"), 0);\n\t\tretval = NOTDONE;\n\t    }\n\t    else\n\t\tfilemess(curbuf, fname, (char_u *)_(\"is not a file\"), 0);\n\t    msg_end();\n\t    msg_scroll = msg_save;\n\t    return retval;\n\t}\n#endif\n#if defined(MSWIN)\n\t/*\n\t * MS-Windows allows opening a device, but we will probably get stuck\n\t * trying to read it.\n\t */\n\tif (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)\n\t{\n\t    filemess(curbuf, fname, (char_u *)_(\"is a device (disabled with 'opendevice' option)\"), 0);\n\t    msg_end();\n\t    msg_scroll = msg_save;\n\t    return FAIL;\n\t}\n#endif\n    }\n\n    /* Set default or forced 'fileformat' and 'binary'. */\n    set_file_options(set_options, eap);\n\n    /*\n     * When opening a new file we take the readonly flag from the file.\n     * Default is r/w, can be set to r/o below.\n     * Don't reset it when in readonly mode\n     * Only set/reset b_p_ro when BF_CHECK_RO is set.\n     */\n    check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));\n    if (check_readonly && !readonlymode)\n\tcurbuf->b_p_ro = FALSE;\n\n    if (newfile && !read_stdin && !read_buffer && !read_fifo)\n    {\n\t/* Remember time of file. */\n\tif (mch_stat((char *)fname, &st) >= 0)\n\t{\n\t    buf_store_time(curbuf, &st, fname);\n\t    curbuf->b_mtime_read = curbuf->b_mtime;\n#ifdef UNIX\n\t    /*\n\t     * Use the protection bits of the original file for the swap file.\n\t     * This makes it possible for others to read the name of the\n\t     * edited file from the swapfile, but only if they can read the\n\t     * edited file.\n\t     * Remove the \"write\" and \"execute\" bits for group and others\n\t     * (they must not write the swapfile).\n\t     * Add the \"read\" and \"write\" bits for the user, otherwise we may\n\t     * not be able to write to the file ourselves.\n\t     * Setting the bits is done below, after creating the swap file.\n\t     */\n\t    swap_mode = (st.st_mode & 0644) | 0600;\n#endif\n#ifdef FEAT_CW_EDITOR\n\t    /* Get the FSSpec on MacOS\n\t     * TODO: Update it properly when the buffer name changes\n\t     */\n\t    (void)GetFSSpecFromPath(curbuf->b_ffname, &curbuf->b_FSSpec);\n#endif\n#ifdef VMS\n\t    curbuf->b_fab_rfm = st.st_fab_rfm;\n\t    curbuf->b_fab_rat = st.st_fab_rat;\n\t    curbuf->b_fab_mrs = st.st_fab_mrs;\n#endif\n\t}\n\telse\n\t{\n\t    curbuf->b_mtime = 0;\n\t    curbuf->b_mtime_read = 0;\n\t    curbuf->b_orig_size = 0;\n\t    curbuf->b_orig_mode = 0;\n\t}\n\n\t/* Reset the \"new file\" flag.  It will be set again below when the\n\t * file doesn't exist. */\n\tcurbuf->b_flags &= ~(BF_NEW | BF_NEW_W);\n    }\n\n/*\n * for UNIX: check readonly with perm and mch_access()\n * for Amiga: check readonly by trying to open the file for writing\n */\n    file_readonly = FALSE;\n    if (read_stdin)\n    {\n#if defined(MSWIN)\n\t/* Force binary I/O on stdin to avoid CR-LF -> LF conversion. */\n\tsetmode(0, O_BINARY);\n#endif\n    }\n    else if (!read_buffer)\n    {\n#ifdef USE_MCH_ACCESS\n\tif (\n# ifdef UNIX\n\t    !(perm & 0222) ||\n# endif\n\t\t\t\tmch_access((char *)fname, W_OK))\n\t    file_readonly = TRUE;\n\tfd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n#else\n\tif (!newfile\n\t\t|| readonlymode\n\t\t|| (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0)\n\t{\n\t    file_readonly = TRUE;\n\t    /* try to open ro */\n\t    fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n\t}\n#endif\n    }\n\n    if (fd < 0)\t\t\t    /* cannot open at all */\n    {\n#ifndef UNIX\n\tint\tisdir_f;\n#endif\n\tmsg_scroll = msg_save;\n#ifndef UNIX\n\t/*\n\t * On Amiga we can't open a directory, check here.\n\t */\n\tisdir_f = (mch_isdir(fname));\n\tperm = mch_getperm(fname);  /* check if the file exists */\n\tif (isdir_f)\n\t{\n\t    filemess(curbuf, sfname, (char_u *)_(\"is a directory\"), 0);\n\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t}\n\telse\n#endif\n\t    if (newfile)\n\t    {\n\t\tif (perm < 0\n#ifdef ENOENT\n\t\t\t&& errno == ENOENT\n#endif\n\t\t   )\n\t\t{\n\t\t    /*\n\t\t     * Set the 'new-file' flag, so that when the file has\n\t\t     * been created by someone else, a \":w\" will complain.\n\t\t     */\n\t\t    curbuf->b_flags |= BF_NEW;\n\n\t\t    /* Create a swap file now, so that other Vims are warned\n\t\t     * that we are editing this file.  Don't do this for a\n\t\t     * \"nofile\" or \"nowrite\" buffer type. */\n#ifdef FEAT_QUICKFIX\n\t\t    if (!bt_dontwrite(curbuf))\n#endif\n\t\t    {\n\t\t\tcheck_need_swap(newfile);\n#ifdef FEAT_AUTOCMD\n\t\t\t/* SwapExists autocommand may mess things up */\n\t\t\tif (curbuf != old_curbuf\n\t\t\t\t|| (using_b_ffname\n\t\t\t\t\t&& (old_b_ffname != curbuf->b_ffname))\n\t\t\t\t|| (using_b_fname\n\t\t\t\t\t && (old_b_fname != curbuf->b_fname)))\n\t\t\t{\n\t\t\t    EMSG(_(e_auchangedbuf));\n\t\t\t    return FAIL;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    if (dir_of_file_exists(fname))\n\t\t\tfilemess(curbuf, sfname, (char_u *)_(\"[New File]\"), 0);\n\t\t    else\n\t\t\tfilemess(curbuf, sfname,\n\t\t\t\t\t   (char_u *)_(\"[New DIRECTORY]\"), 0);\n#ifdef FEAT_VIMINFO\n\t\t    /* Even though this is a new file, it might have been\n\t\t     * edited before and deleted.  Get the old marks. */\n\t\t    check_marks_read();\n#endif\n#ifdef FEAT_MBYTE\n\t\t    /* Set forced 'fileencoding'.  */\n\t\t    if (eap != NULL)\n\t\t\tset_forced_fenc(eap);\n#endif\n#ifdef FEAT_AUTOCMD\n\t\t    apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n#endif\n\t\t    /* remember the current fileformat */\n\t\t    save_file_ff(curbuf);\n\n#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)\n\t\t    if (aborting())   /* autocmds may abort script processing */\n\t\t\treturn FAIL;\n#endif\n\t\t    return OK;\t    /* a new file is not an error */\n\t\t}\n\t\telse\n\t\t{\n\t\t    filemess(curbuf, sfname, (char_u *)(\n# ifdef EFBIG\n\t\t\t    (errno == EFBIG) ? _(\"[File too big]\") :\n# endif\n# ifdef EOVERFLOW\n\t\t\t    (errno == EOVERFLOW) ? _(\"[File too big]\") :\n# endif\n\t\t\t\t\t\t_(\"[Permission Denied]\")), 0);\n\t\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t\t}\n\t    }\n\n\treturn FAIL;\n    }\n\n    /*\n     * Only set the 'ro' flag for readonly files the first time they are\n     * loaded.\tHelp files always get readonly mode\n     */\n    if ((check_readonly && file_readonly) || curbuf->b_help)\n\tcurbuf->b_p_ro = TRUE;\n\n    if (set_options)\n    {\n\t/* Don't change 'eol' if reading from buffer as it will already be\n\t * correctly set when reading stdin. */\n\tif (!read_buffer)\n\t{\n\t    curbuf->b_p_eol = TRUE;\n\t    curbuf->b_start_eol = TRUE;\n\t}\n#ifdef FEAT_MBYTE\n\tcurbuf->b_p_bomb = FALSE;\n\tcurbuf->b_start_bomb = FALSE;\n#endif\n    }\n\n    /* Create a swap file now, so that other Vims are warned that we are\n     * editing this file.\n     * Don't do this for a \"nofile\" or \"nowrite\" buffer type. */\n#ifdef FEAT_QUICKFIX\n    if (!bt_dontwrite(curbuf))\n#endif\n    {\n\tcheck_need_swap(newfile);\n#ifdef FEAT_AUTOCMD\n\tif (!read_stdin && (curbuf != old_curbuf\n\t\t|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n\t\t|| (using_b_fname && (old_b_fname != curbuf->b_fname))))\n\t{\n\t    EMSG(_(e_auchangedbuf));\n\t    if (!read_buffer)\n\t\tclose(fd);\n\t    return FAIL;\n\t}\n#endif\n#ifdef UNIX\n\t/* Set swap file protection bits after creating it. */\n\tif (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL\n\t\t\t  && curbuf->b_ml.ml_mfp->mf_fname != NULL)\n\t    (void)mch_setperm(curbuf->b_ml.ml_mfp->mf_fname, (long)swap_mode);\n#endif\n    }\n\n#if defined(HAS_SWAP_EXISTS_ACTION)\n    /* If \"Quit\" selected at ATTENTION dialog, don't load the file */\n    if (swap_exists_action == SEA_QUIT)\n    {\n\tif (!read_buffer && !read_stdin)\n\t    close(fd);\n\treturn FAIL;\n    }\n#endif\n\n    ++no_wait_return;\t    /* don't wait for return yet */\n\n    /*\n     * Set '[ mark to the line above where the lines go (line 1 if zero).\n     */\n    curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n    curbuf->b_op_start.col = 0;\n\n    try_mac = (vim_strchr(p_ffs, 'm') != NULL);\n    try_dos = (vim_strchr(p_ffs, 'd') != NULL);\n    try_unix = (vim_strchr(p_ffs, 'x') != NULL);\n\n#ifdef FEAT_AUTOCMD\n    if (!read_buffer)\n    {\n\tint\tm = msg_scroll;\n\tint\tn = msg_scrolled;\n\n\t/*\n\t * The file must be closed again, the autocommands may want to change\n\t * the file before reading it.\n\t */\n\tif (!read_stdin)\n\t    close(fd);\t\t/* ignore errors */\n\n\t/*\n\t * The output from the autocommands should not overwrite anything and\n\t * should not be overwritten: Set msg_scroll, restore its value if no\n\t * output was done.\n\t */\n\tmsg_scroll = TRUE;\n\tif (filtering)\n\t    apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (read_stdin)\n\t    apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (newfile)\n\t    apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse\n\t    apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,\n\t\t\t\t\t\t\t    FALSE, NULL, eap);\n\t/* autocommands may have changed it */\n\ttry_mac = (vim_strchr(p_ffs, 'm') != NULL);\n\ttry_dos = (vim_strchr(p_ffs, 'd') != NULL);\n\ttry_unix = (vim_strchr(p_ffs, 'x') != NULL);\n\n\tif (msg_scrolled == n)\n\t    msg_scroll = m;\n\n#ifdef FEAT_EVAL\n\tif (aborting())\t    /* autocmds may abort script processing */\n\t{\n\t    --no_wait_return;\n\t    msg_scroll = msg_save;\n\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t    return FAIL;\n\t}\n#endif\n\t/*\n\t * Don't allow the autocommands to change the current buffer.\n\t * Try to re-open the file.\n\t *\n\t * Don't allow the autocommands to change the buffer name either\n\t * (cd for example) if it invalidates fname or sfname.\n\t */\n\tif (!read_stdin && (curbuf != old_curbuf\n\t\t|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n\t\t|| (using_b_fname && (old_b_fname != curbuf->b_fname))\n\t\t|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))\n\t{\n\t    --no_wait_return;\n\t    msg_scroll = msg_save;\n\t    if (fd < 0)\n\t\tEMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));\n\t    else\n\t\tEMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));\n\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t    return FAIL;\n\t}\n    }\n#endif /* FEAT_AUTOCMD */\n\n    /* Autocommands may add lines to the file, need to check if it is empty */\n    wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n    if (!recoverymode && !filtering && !(flags & READ_DUMMY))\n    {\n\t/*\n\t * Show the user that we are busy reading the input.  Sometimes this\n\t * may take a while.  When reading from stdin another program may\n\t * still be running, don't move the cursor to the last line, unless\n\t * always using the GUI.\n\t */\n\tif (read_stdin)\n\t{\n#ifndef ALWAYS_USE_GUI\n\t    mch_msg(_(\"Vim: Reading from stdin...\\n\"));\n#endif\n#ifdef FEAT_GUI\n\t    /* Also write a message in the GUI window, if there is one. */\n\t    if (gui.in_use && !gui.dying && !gui.starting)\n\t    {\n\t\tp = (char_u *)_(\"Reading from stdin...\");\n\t\tgui_write(p, (int)STRLEN(p));\n\t    }\n#endif\n\t}\n\telse if (!read_buffer)\n\t    filemess(curbuf, sfname, (char_u *)\"\", 0);\n    }\n\n    msg_scroll = FALSE;\t\t\t/* overwrite the file message */\n\n    /*\n     * Set linecnt now, before the \"retry\" caused by a wrong guess for\n     * fileformat, and after the autocommands, which may change them.\n     */\n    linecnt = curbuf->b_ml.ml_line_count;\n\n#ifdef FEAT_MBYTE\n    /* \"++bad=\" argument. */\n    if (eap != NULL && eap->bad_char != 0)\n    {\n\tbad_char_behavior = eap->bad_char;\n\tif (set_options)\n\t    curbuf->b_bad_char = eap->bad_char;\n    }\n    else\n\tcurbuf->b_bad_char = 0;\n\n    /*\n     * Decide which 'encoding' to use or use first.\n     */\n    if (eap != NULL && eap->force_enc != 0)\n    {\n\tfenc = enc_canonize(eap->cmd + eap->force_enc);\n\tfenc_alloced = TRUE;\n\tkeep_dest_enc = TRUE;\n    }\n    else if (curbuf->b_p_bin)\n    {\n\tfenc = (char_u *)\"\";\t\t/* binary: don't convert */\n\tfenc_alloced = FALSE;\n    }\n    else if (curbuf->b_help)\n    {\n\tchar_u\t    firstline[80];\n\tint\t    fc;\n\n\t/* Help files are either utf-8 or latin1.  Try utf-8 first, if this\n\t * fails it must be latin1.\n\t * Always do this when 'encoding' is \"utf-8\".  Otherwise only do\n\t * this when needed to avoid [converted] remarks all the time.\n\t * It is needed when the first line contains non-ASCII characters.\n\t * That is only in *.??x files. */\n\tfenc = (char_u *)\"latin1\";\n\tc = enc_utf8;\n\tif (!c && !read_stdin)\n\t{\n\t    fc = fname[STRLEN(fname) - 1];\n\t    if (TOLOWER_ASC(fc) == 'x')\n\t    {\n\t\t/* Read the first line (and a bit more).  Immediately rewind to\n\t\t * the start of the file.  If the read() fails \"len\" is -1. */\n\t\tlen = read_eintr(fd, firstline, 80);\n\t\tvim_lseek(fd, (off_T)0L, SEEK_SET);\n\t\tfor (p = firstline; p < firstline + len; ++p)\n\t\t    if (*p >= 0x80)\n\t\t    {\n\t\t\tc = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\n\tif (c)\n\t{\n\t    fenc_next = fenc;\n\t    fenc = (char_u *)\"utf-8\";\n\n\t    /* When the file is utf-8 but a character doesn't fit in\n\t     * 'encoding' don't retry.  In help text editing utf-8 bytes\n\t     * doesn't make sense. */\n\t    if (!enc_utf8)\n\t\tkeep_dest_enc = TRUE;\n\t}\n\tfenc_alloced = FALSE;\n    }\n    else if (*p_fencs == NUL)\n    {\n\tfenc = curbuf->b_p_fenc;\t/* use format from buffer */\n\tfenc_alloced = FALSE;\n    }\n    else\n    {\n\tfenc_next = p_fencs;\t\t/* try items in 'fileencodings' */\n\tfenc = next_fenc(&fenc_next);\n\tfenc_alloced = TRUE;\n    }\n#endif\n\n    /*\n     * Jump back here to retry reading the file in different ways.\n     * Reasons to retry:\n     * - encoding conversion failed: try another one from \"fenc_next\"\n     * - BOM detected and fenc was set, need to setup conversion\n     * - \"fileformat\" check failed: try another\n     *\n     * Variables set for special retry actions:\n     * \"file_rewind\"\tRewind the file to start reading it again.\n     * \"advance_fenc\"\tAdvance \"fenc\" using \"fenc_next\".\n     * \"skip_read\"\tRe-use already read bytes (BOM detected).\n     * \"did_iconv\"\ticonv() conversion failed, try 'charconvert'.\n     * \"keep_fileformat\" Don't reset \"fileformat\".\n     *\n     * Other status indicators:\n     * \"tmpname\"\tWhen != NULL did conversion with 'charconvert'.\n     *\t\t\tOutput file has to be deleted afterwards.\n     * \"iconv_fd\"\tWhen != -1 did conversion with iconv().\n     */\nretry:\n\n    if (file_rewind)\n    {\n\tif (read_buffer)\n\t{\n\t    read_buf_lnum = 1;\n\t    read_buf_col = 0;\n\t}\n\telse if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0)\n\t{\n\t    /* Can't rewind the file, give up. */\n\t    error = TRUE;\n\t    goto failed;\n\t}\n\t/* Delete the previously read lines. */\n\twhile (lnum > from)\n\t    ml_delete(lnum--, FALSE);\n\tfile_rewind = FALSE;\n#ifdef FEAT_MBYTE\n\tif (set_options)\n\t{\n\t    curbuf->b_p_bomb = FALSE;\n\t    curbuf->b_start_bomb = FALSE;\n\t}\n\tconv_error = 0;\n#endif\n    }\n\n    /*\n     * When retrying with another \"fenc\" and the first time \"fileformat\"\n     * will be reset.\n     */\n    if (keep_fileformat)\n\tkeep_fileformat = FALSE;\n    else\n    {\n\tif (eap != NULL && eap->force_ff != 0)\n\t{\n\t    fileformat = get_fileformat_force(curbuf, eap);\n\t    try_unix = try_dos = try_mac = FALSE;\n\t}\n\telse if (curbuf->b_p_bin)\n\t    fileformat = EOL_UNIX;\t\t/* binary: use Unix format */\n\telse if (*p_ffs == NUL)\n\t    fileformat = get_fileformat(curbuf);/* use format from buffer */\n\telse\n\t    fileformat = EOL_UNKNOWN;\t\t/* detect from file */\n    }\n\n#ifdef FEAT_MBYTE\n# ifdef USE_ICONV\n    if (iconv_fd != (iconv_t)-1)\n    {\n\t/* aborted conversion with iconv(), close the descriptor */\n\ticonv_close(iconv_fd);\n\ticonv_fd = (iconv_t)-1;\n    }\n# endif\n\n    if (advance_fenc)\n    {\n\t/*\n\t * Try the next entry in 'fileencodings'.\n\t */\n\tadvance_fenc = FALSE;\n\n\tif (eap != NULL && eap->force_enc != 0)\n\t{\n\t    /* Conversion given with \"++cc=\" wasn't possible, read\n\t     * without conversion. */\n\t    notconverted = TRUE;\n\t    conv_error = 0;\n\t    if (fenc_alloced)\n\t\tvim_free(fenc);\n\t    fenc = (char_u *)\"\";\n\t    fenc_alloced = FALSE;\n\t}\n\telse\n\t{\n\t    if (fenc_alloced)\n\t\tvim_free(fenc);\n\t    if (fenc_next != NULL)\n\t    {\n\t\tfenc = next_fenc(&fenc_next);\n\t\tfenc_alloced = (fenc_next != NULL);\n\t    }\n\t    else\n\t    {\n\t\tfenc = (char_u *)\"\";\n\t\tfenc_alloced = FALSE;\n\t    }\n\t}\n\tif (tmpname != NULL)\n\t{\n\t    mch_remove(tmpname);\t\t/* delete converted file */\n\t    vim_free(tmpname);\n\t    tmpname = NULL;\n\t}\n    }\n\n    /*\n     * Conversion may be required when the encoding of the file is different\n     * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.\n     */\n    fio_flags = 0;\n    converted = need_conversion(fenc);\n    if (converted)\n    {\n\n\t/* \"ucs-bom\" means we need to check the first bytes of the file\n\t * for a BOM. */\n\tif (STRCMP(fenc, ENC_UCSBOM) == 0)\n\t    fio_flags = FIO_UCSBOM;\n\n\t/*\n\t * Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be\n\t * done.  This is handled below after read().  Prepare the\n\t * fio_flags to avoid having to parse the string each time.\n\t * Also check for Unicode to Latin1 conversion, because iconv()\n\t * appears not to handle this correctly.  This works just like\n\t * conversion to UTF-8 except how the resulting character is put in\n\t * the buffer.\n\t */\n\telse if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0)\n\t    fio_flags = get_fio_flags(fenc);\n\n# ifdef WIN3264\n\t/*\n\t * Conversion from an MS-Windows codepage to UTF-8 or another codepage\n\t * is handled with MultiByteToWideChar().\n\t */\n\tif (fio_flags == 0)\n\t    fio_flags = get_win_fio_flags(fenc);\n# endif\n\n# ifdef MACOS_CONVERT\n\t/* Conversion from Apple MacRoman to latin1 or UTF-8 */\n\tif (fio_flags == 0)\n\t    fio_flags = get_mac_fio_flags(fenc);\n# endif\n\n# ifdef USE_ICONV\n\t/*\n\t * Try using iconv() if we can't convert internally.\n\t */\n\tif (fio_flags == 0\n#  ifdef FEAT_EVAL\n\t\t&& !did_iconv\n#  endif\n\t\t)\n\t    iconv_fd = (iconv_t)my_iconv_open(\n\t\t\t\t  enc_utf8 ? (char_u *)\"utf-8\" : p_enc, fenc);\n# endif\n\n# ifdef FEAT_EVAL\n\t/*\n\t * Use the 'charconvert' expression when conversion is required\n\t * and we can't do it internally or with iconv().\n\t */\n\tif (fio_flags == 0 && !read_stdin && !read_buffer && *p_ccv != NUL\n\t\t\t\t\t\t    && !read_fifo\n#  ifdef USE_ICONV\n\t\t\t\t\t\t    && iconv_fd == (iconv_t)-1\n#  endif\n\t\t)\n\t{\n#  ifdef USE_ICONV\n\t    did_iconv = FALSE;\n#  endif\n\t    /* Skip conversion when it's already done (retry for wrong\n\t     * \"fileformat\"). */\n\t    if (tmpname == NULL)\n\t    {\n\t\ttmpname = readfile_charconvert(fname, fenc, &fd);\n\t\tif (tmpname == NULL)\n\t\t{\n\t\t    /* Conversion failed.  Try another one. */\n\t\t    advance_fenc = TRUE;\n\t\t    if (fd < 0)\n\t\t    {\n\t\t\t/* Re-opening the original file failed! */\n\t\t\tEMSG(_(\"E202: Conversion made file unreadable!\"));\n\t\t\terror = TRUE;\n\t\t\tgoto failed;\n\t\t    }\n\t\t    goto retry;\n\t\t}\n\t    }\n\t}\n\telse\n# endif\n\t{\n\t    if (fio_flags == 0\n# ifdef USE_ICONV\n\t\t    && iconv_fd == (iconv_t)-1\n# endif\n\t       )\n\t    {\n\t\t/* Conversion wanted but we can't.\n\t\t * Try the next conversion in 'fileencodings' */\n\t\tadvance_fenc = TRUE;\n\t\tgoto retry;\n\t    }\n\t}\n    }\n\n    /* Set \"can_retry\" when it's possible to rewind the file and try with\n     * another \"fenc\" value.  It's FALSE when no other \"fenc\" to try, reading\n     * stdin or fixed at a specific encoding. */\n    can_retry = (*fenc != NUL && !read_stdin && !read_fifo && !keep_dest_enc);\n#endif\n\n    if (!skip_read)\n    {\n\tlinerest = 0;\n\tfilesize = 0;\n\tskip_count = lines_to_skip;\n\tread_count = lines_to_read;\n#ifdef FEAT_MBYTE\n\tconv_restlen = 0;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\tread_undo_file = (newfile && (flags & READ_KEEP_UNDO) == 0\n\t\t\t\t  && curbuf->b_ffname != NULL\n\t\t\t\t  && curbuf->b_p_udf\n\t\t\t\t  && !filtering\n\t\t\t\t  && !read_fifo\n\t\t\t\t  && !read_stdin\n\t\t\t\t  && !read_buffer);\n\tif (read_undo_file)\n\t    sha256_start(&sha_ctx);\n#endif\n#ifdef FEAT_CRYPT\n\tif (curbuf->b_cryptstate != NULL)\n\t{\n\t    /* Need to free the state, but keep the key, don't want to ask for\n\t     * it again. */\n\t    crypt_free_state(curbuf->b_cryptstate);\n\t    curbuf->b_cryptstate = NULL;\n\t}\n#endif\n    }\n\n    while (!error && !got_int)\n    {\n\t/*\n\t * We allocate as much space for the file as we can get, plus\n\t * space for the old line plus room for one terminating NUL.\n\t * The amount is limited by the fact that read() only can read\n\t * upto max_unsigned characters (and other things).\n\t */\n#if VIM_SIZEOF_INT <= 2\n\tif (linerest >= 0x7ff0)\n\t{\n\t    ++split;\n\t    *ptr = NL;\t\t    /* split line by inserting a NL */\n\t    size = 1;\n\t}\n\telse\n#endif\n\t{\n\t    if (!skip_read)\n\t    {\n#if VIM_SIZEOF_INT > 2\n# if defined(SSIZE_MAX) && (SSIZE_MAX < 0x10000L)\n\t\tsize = SSIZE_MAX;\t\t    /* use max I/O size, 52K */\n# else\n\t\tsize = 0x10000L;\t\t    /* use buffer >= 64K */\n# endif\n#else\n\t\tsize = 0x7ff0L - linerest;\t    /* limit buffer to 32K */\n#endif\n\n\t\tfor ( ; size >= 10; size = (long)((long_u)size >> 1))\n\t\t{\n\t\t    if ((new_buffer = lalloc((long_u)(size + linerest + 1),\n\t\t\t\t\t\t\t      FALSE)) != NULL)\n\t\t\tbreak;\n\t\t}\n\t\tif (new_buffer == NULL)\n\t\t{\n\t\t    do_outofmem_msg((long_u)(size * 2 + linerest + 1));\n\t\t    error = TRUE;\n\t\t    break;\n\t\t}\n\t\tif (linerest)\t/* copy characters from the previous buffer */\n\t\t    mch_memmove(new_buffer, ptr - linerest, (size_t)linerest);\n\t\tvim_free(buffer);\n\t\tbuffer = new_buffer;\n\t\tptr = buffer + linerest;\n\t\tline_start = buffer;\n\n#ifdef FEAT_MBYTE\n\t\t/* May need room to translate into.\n\t\t * For iconv() we don't really know the required space, use a\n\t\t * factor ICONV_MULT.\n\t\t * latin1 to utf-8: 1 byte becomes up to 2 bytes\n\t\t * utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes\n\t\t * become up to 4 bytes, size must be multiple of 2\n\t\t * ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be\n\t\t * multiple of 2\n\t\t * ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be\n\t\t * multiple of 4 */\n\t\treal_size = (int)size;\n# ifdef USE_ICONV\n\t\tif (iconv_fd != (iconv_t)-1)\n\t\t    size = size / ICONV_MULT;\n\t\telse\n# endif\n\t\t    if (fio_flags & FIO_LATIN1)\n\t\t    size = size / 2;\n\t\telse if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n\t\t    size = (size * 2 / 3) & ~1;\n\t\telse if (fio_flags & FIO_UCS4)\n\t\t    size = (size * 2 / 3) & ~3;\n\t\telse if (fio_flags == FIO_UCSBOM)\n\t\t    size = size / ICONV_MULT;\t/* worst case */\n# ifdef WIN3264\n\t\telse if (fio_flags & FIO_CODEPAGE)\n\t\t    size = size / ICONV_MULT;\t/* also worst case */\n# endif\n# ifdef MACOS_CONVERT\n\t\telse if (fio_flags & FIO_MACROMAN)\n\t\t    size = size / ICONV_MULT;\t/* also worst case */\n# endif\n#endif\n\n#ifdef FEAT_MBYTE\n\t\tif (conv_restlen > 0)\n\t\t{\n\t\t    /* Insert unconverted bytes from previous line. */\n\t\t    mch_memmove(ptr, conv_rest, conv_restlen);\n\t\t    ptr += conv_restlen;\n\t\t    size -= conv_restlen;\n\t\t}\n#endif\n\n\t\tif (read_buffer)\n\t\t{\n\t\t    /*\n\t\t     * Read bytes from curbuf.  Used for converting text read\n\t\t     * from stdin.\n\t\t     */\n\t\t    if (read_buf_lnum > from)\n\t\t\tsize = 0;\n\t\t    else\n\t\t    {\n\t\t\tint\tn, ni;\n\t\t\tlong\ttlen;\n\n\t\t\ttlen = 0;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    p = ml_get(read_buf_lnum) + read_buf_col;\n\t\t\t    n = (int)STRLEN(p);\n\t\t\t    if ((int)tlen + n + 1 > size)\n\t\t\t    {\n\t\t\t\t/* Filled up to \"size\", append partial line.\n\t\t\t\t * Change NL to NUL to reverse the effect done\n\t\t\t\t * below. */\n\t\t\t\tn = (int)(size - tlen);\n\t\t\t\tfor (ni = 0; ni < n; ++ni)\n\t\t\t\t{\n\t\t\t\t    if (p[ni] == NL)\n\t\t\t\t\tptr[tlen++] = NUL;\n\t\t\t\t    else\n\t\t\t\t\tptr[tlen++] = p[ni];\n\t\t\t\t}\n\t\t\t\tread_buf_col += n;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t/* Append whole line and new-line.  Change NL\n\t\t\t\t * to NUL to reverse the effect done below. */\n\t\t\t\tfor (ni = 0; ni < n; ++ni)\n\t\t\t\t{\n\t\t\t\t    if (p[ni] == NL)\n\t\t\t\t\tptr[tlen++] = NUL;\n\t\t\t\t    else\n\t\t\t\t\tptr[tlen++] = p[ni];\n\t\t\t\t}\n\t\t\t\tptr[tlen++] = NL;\n\t\t\t\tread_buf_col = 0;\n\t\t\t\tif (++read_buf_lnum > from)\n\t\t\t\t{\n\t\t\t\t    /* When the last line didn't have an\n\t\t\t\t     * end-of-line don't add it now either. */\n\t\t\t\t    if (!curbuf->b_p_eol)\n\t\t\t\t\t--tlen;\n\t\t\t\t    size = tlen;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Read bytes from the file.\n\t\t     */\n\t\t    size = read_eintr(fd, ptr, size);\n\t\t}\n\n#ifdef FEAT_CRYPT\n\t\t/*\n\t\t * At start of file: Check for magic number of encryption.\n\t\t */\n\t\tif (filesize == 0 && size > 0)\n\t\t    cryptkey = check_for_cryptkey(cryptkey, ptr, &size,\n\t\t\t\t\t\t  &filesize, newfile, sfname,\n\t\t\t\t\t\t  &did_ask_for_key);\n\t\t/*\n\t\t * Decrypt the read bytes.  This is done before checking for\n\t\t * EOF because the crypt layer may be buffering.\n\t\t */\n\t\tif (cryptkey != NULL && curbuf->b_cryptstate != NULL\n\t\t\t\t\t\t\t\t   && size > 0)\n\t\t{\n\t\t    if (crypt_works_inplace(curbuf->b_cryptstate))\n\t\t    {\n\t\t\tcrypt_decode_inplace(curbuf->b_cryptstate, ptr, size);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tchar_u\t*newptr = NULL;\n\t\t\tint\tdecrypted_size;\n\n\t\t\tdecrypted_size = crypt_decode_alloc(\n\t\t\t\t    curbuf->b_cryptstate, ptr, size, &newptr);\n\n\t\t\t/* If the crypt layer is buffering, not producing\n\t\t\t * anything yet, need to read more. */\n\t\t\tif (size > 0 && decrypted_size == 0)\n\t\t\t    continue;\n\n\t\t\tif (linerest == 0)\n\t\t\t{\n\t\t\t    /* Simple case: reuse returned buffer (may be\n\t\t\t     * NULL, checked later). */\n\t\t\t    new_buffer = newptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    long_u\tnew_size;\n\n\t\t\t    /* Need new buffer to add bytes carried over. */\n\t\t\t    new_size = (long_u)(decrypted_size + linerest + 1);\n\t\t\t    new_buffer = lalloc(new_size, FALSE);\n\t\t\t    if (new_buffer == NULL)\n\t\t\t    {\n\t\t\t\tdo_outofmem_msg(new_size);\n\t\t\t\terror = TRUE;\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\t    mch_memmove(new_buffer, buffer, linerest);\n\t\t\t    if (newptr != NULL)\n\t\t\t\tmch_memmove(new_buffer + linerest, newptr,\n\t\t\t\t\t\t\t      decrypted_size);\n\t\t\t}\n\n\t\t\tif (new_buffer != NULL)\n\t\t\t{\n\t\t\t    vim_free(buffer);\n\t\t\t    buffer = new_buffer;\n\t\t\t    new_buffer = NULL;\n\t\t\t    line_start = buffer;\n\t\t\t    ptr = buffer + linerest;\n\t\t\t}\n\t\t\tsize = decrypted_size;\n\t\t    }\n\t\t}\n#endif\n\n\t\tif (size <= 0)\n\t\t{\n\t\t    if (size < 0)\t\t    /* read error */\n\t\t\terror = TRUE;\n#ifdef FEAT_MBYTE\n\t\t    else if (conv_restlen > 0)\n\t\t    {\n\t\t\t/*\n\t\t\t * Reached end-of-file but some trailing bytes could\n\t\t\t * not be converted.  Truncated file?\n\t\t\t */\n\n\t\t\t/* When we did a conversion report an error. */\n\t\t\tif (fio_flags != 0\n# ifdef USE_ICONV\n\t\t\t\t|| iconv_fd != (iconv_t)-1\n# endif\n\t\t\t   )\n\t\t\t{\n\t\t\t    if (can_retry)\n\t\t\t\tgoto rewind_retry;\n\t\t\t    if (conv_error == 0)\n\t\t\t\tconv_error = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t\t\t- linecnt + 1;\n\t\t\t}\n\t\t\t/* Remember the first linenr with an illegal byte */\n\t\t\telse if (illegal_byte == 0)\n\t\t\t    illegal_byte = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t\t\t- linecnt + 1;\n\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t{\n\t\t\t    *(ptr - conv_restlen) = NUL;\n\t\t\t    conv_restlen = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    /* Replace the trailing bytes with the replacement\n\t\t\t     * character if we were converting; if we weren't,\n\t\t\t     * leave the UTF8 checking code to do it, as it\n\t\t\t     * works slightly differently. */\n\t\t\t    if (bad_char_behavior != BAD_KEEP && (fio_flags != 0\n# ifdef USE_ICONV\n\t\t\t\t    || iconv_fd != (iconv_t)-1\n# endif\n\t\t\t       ))\n\t\t\t    {\n\t\t\t\twhile (conv_restlen > 0)\n\t\t\t\t{\n\t\t\t\t    *(--ptr) = bad_char_behavior;\n\t\t\t\t    --conv_restlen;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    fio_flags = 0;\t/* don't convert this */\n# ifdef USE_ICONV\n\t\t\t    if (iconv_fd != (iconv_t)-1)\n\t\t\t    {\n\t\t\t\ticonv_close(iconv_fd);\n\t\t\t\ticonv_fd = (iconv_t)-1;\n\t\t\t    }\n# endif\n\t\t\t}\n\t\t    }\n#endif\n\t\t}\n\t    }\n\t    skip_read = FALSE;\n\n#ifdef FEAT_MBYTE\n\t    /*\n\t     * At start of file (or after crypt magic number): Check for BOM.\n\t     * Also check for a BOM for other Unicode encodings, but not after\n\t     * converting with 'charconvert' or when a BOM has already been\n\t     * found.\n\t     */\n\t    if ((filesize == 0\n# ifdef FEAT_CRYPT\n\t\t   || (cryptkey != NULL\n\t\t\t&& filesize == crypt_get_header_len(\n\t\t\t\t\t\t crypt_get_method_nr(curbuf)))\n# endif\n\t\t       )\n\t\t    && (fio_flags == FIO_UCSBOM\n\t\t\t|| (!curbuf->b_p_bomb\n\t\t\t    && tmpname == NULL\n\t\t\t    && (*fenc == 'u' || (*fenc == NUL && enc_utf8)))))\n\t    {\n\t\tchar_u\t*ccname;\n\t\tint\tblen;\n\n\t\t/* no BOM detection in a short file or in binary mode */\n\t\tif (size < 2 || curbuf->b_p_bin)\n\t\t    ccname = NULL;\n\t\telse\n\t\t    ccname = check_for_bom(ptr, size, &blen,\n\t\t      fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));\n\t\tif (ccname != NULL)\n\t\t{\n\t\t    /* Remove BOM from the text */\n\t\t    filesize += blen;\n\t\t    size -= blen;\n\t\t    mch_memmove(ptr, ptr + blen, (size_t)size);\n\t\t    if (set_options)\n\t\t    {\n\t\t\tcurbuf->b_p_bomb = TRUE;\n\t\t\tcurbuf->b_start_bomb = TRUE;\n\t\t    }\n\t\t}\n\n\t\tif (fio_flags == FIO_UCSBOM)\n\t\t{\n\t\t    if (ccname == NULL)\n\t\t    {\n\t\t\t/* No BOM detected: retry with next encoding. */\n\t\t\tadvance_fenc = TRUE;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/* BOM detected: set \"fenc\" and jump back */\n\t\t\tif (fenc_alloced)\n\t\t\t    vim_free(fenc);\n\t\t\tfenc = ccname;\n\t\t\tfenc_alloced = FALSE;\n\t\t    }\n\t\t    /* retry reading without getting new bytes or rewinding */\n\t\t    skip_read = TRUE;\n\t\t    goto retry;\n\t\t}\n\t    }\n\n\t    /* Include not converted bytes. */\n\t    ptr -= conv_restlen;\n\t    size += conv_restlen;\n\t    conv_restlen = 0;\n#endif\n\t    /*\n\t     * Break here for a read error or end-of-file.\n\t     */\n\t    if (size <= 0)\n\t\tbreak;\n\n#ifdef FEAT_MBYTE\n\n# ifdef USE_ICONV\n\t    if (iconv_fd != (iconv_t)-1)\n\t    {\n\t\t/*\n\t\t * Attempt conversion of the read bytes to 'encoding' using\n\t\t * iconv().\n\t\t */\n\t\tconst char\t*fromp;\n\t\tchar\t\t*top;\n\t\tsize_t\t\tfrom_size;\n\t\tsize_t\t\tto_size;\n\n\t\tfromp = (char *)ptr;\n\t\tfrom_size = size;\n\t\tptr += size;\n\t\ttop = (char *)ptr;\n\t\tto_size = real_size - size;\n\n\t\t/*\n\t\t * If there is conversion error or not enough room try using\n\t\t * another conversion.  Except for when there is no\n\t\t * alternative (help files).\n\t\t */\n\t\twhile ((iconv(iconv_fd, (void *)&fromp, &from_size,\n\t\t\t\t\t\t\t       &top, &to_size)\n\t\t\t    == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n\t\t\t\t\t\t  || from_size > CONV_RESTLEN)\n\t\t{\n\t\t    if (can_retry)\n\t\t\tgoto rewind_retry;\n\t\t    if (conv_error == 0)\n\t\t\tconv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t  ptr, (char_u *)top);\n\n\t\t    /* Deal with a bad byte and continue with the next. */\n\t\t    ++fromp;\n\t\t    --from_size;\n\t\t    if (bad_char_behavior == BAD_KEEP)\n\t\t    {\n\t\t\t*top++ = *(fromp - 1);\n\t\t\t--to_size;\n\t\t    }\n\t\t    else if (bad_char_behavior != BAD_DROP)\n\t\t    {\n\t\t\t*top++ = bad_char_behavior;\n\t\t\t--to_size;\n\t\t    }\n\t\t}\n\n\t\tif (from_size > 0)\n\t\t{\n\t\t    /* Some remaining characters, keep them for the next\n\t\t     * round. */\n\t\t    mch_memmove(conv_rest, (char_u *)fromp, from_size);\n\t\t    conv_restlen = (int)from_size;\n\t\t}\n\n\t\t/* move the linerest to before the converted characters */\n\t\tline_start = ptr - linerest;\n\t\tmch_memmove(line_start, buffer, (size_t)linerest);\n\t\tsize = (long)((char_u *)top - ptr);\n\t    }\n# endif\n\n# ifdef WIN3264\n\t    if (fio_flags & FIO_CODEPAGE)\n\t    {\n\t\tchar_u\t*src, *dst;\n\t\tWCHAR\tucs2buf[3];\n\t\tint\tucs2len;\n\t\tint\tcodepage = FIO_GET_CP(fio_flags);\n\t\tint\tbytelen;\n\t\tint\tfound_bad;\n\t\tchar\treplstr[2];\n\n\t\t/*\n\t\t * Conversion from an MS-Windows codepage or UTF-8 to UTF-8 or\n\t\t * a codepage, using standard MS-Windows functions.  This\n\t\t * requires two steps:\n\t\t * 1. convert from 'fileencoding' to ucs-2\n\t\t * 2. convert from ucs-2 to 'encoding'\n\t\t *\n\t\t * Because there may be illegal bytes AND an incomplete byte\n\t\t * sequence at the end, we may have to do the conversion one\n\t\t * character at a time to get it right.\n\t\t */\n\n\t\t/* Replacement string for WideCharToMultiByte(). */\n\t\tif (bad_char_behavior > 0)\n\t\t    replstr[0] = bad_char_behavior;\n\t\telse\n\t\t    replstr[0] = '?';\n\t\treplstr[1] = NUL;\n\n\t\t/*\n\t\t * Move the bytes to the end of the buffer, so that we have\n\t\t * room to put the result at the start.\n\t\t */\n\t\tsrc = ptr + real_size - size;\n\t\tmch_memmove(src, ptr, size);\n\n\t\t/*\n\t\t * Do the conversion.\n\t\t */\n\t\tdst = ptr;\n\t\tsize = size;\n\t\twhile (size > 0)\n\t\t{\n\t\t    found_bad = FALSE;\n\n#  ifdef CP_UTF8\t/* VC 4.1 doesn't define CP_UTF8 */\n\t\t    if (codepage == CP_UTF8)\n\t\t    {\n\t\t\t/* Handle CP_UTF8 input ourselves to be able to handle\n\t\t\t * trailing bytes properly.\n\t\t\t * Get one UTF-8 character from src. */\n\t\t\tbytelen = (int)utf_ptr2len_len(src, size);\n\t\t\tif (bytelen > size)\n\t\t\t{\n\t\t\t    /* Only got some bytes of a character.  Normally\n\t\t\t     * it's put in \"conv_rest\", but if it's too long\n\t\t\t     * deal with it as if they were illegal bytes. */\n\t\t\t    if (bytelen <= CONV_RESTLEN)\n\t\t\t\tbreak;\n\n\t\t\t    /* weird overlong byte sequence */\n\t\t\t    bytelen = size;\n\t\t\t    found_bad = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\t    u8c = utf_ptr2char(src);\n\n\t\t\t    if (u8c > 0xffff || (*src >= 0x80 && bytelen == 1))\n\t\t\t\tfound_bad = TRUE;\n\t\t\t    ucs2buf[0] = u8c;\n\t\t\t    ucs2len = 1;\n\t\t\t}\n\t\t    }\n\t\t    else\n#  endif\n\t\t    {\n\t\t\t/* We don't know how long the byte sequence is, try\n\t\t\t * from one to three bytes. */\n\t\t\tfor (bytelen = 1; bytelen <= size && bytelen <= 3;\n\t\t\t\t\t\t\t\t    ++bytelen)\n\t\t\t{\n\t\t\t    ucs2len = MultiByteToWideChar(codepage,\n\t\t\t\t\t\t\t MB_ERR_INVALID_CHARS,\n\t\t\t\t\t\t\t (LPCSTR)src, bytelen,\n\t\t\t\t\t\t\t\t   ucs2buf, 3);\n\t\t\t    if (ucs2len > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ucs2len == 0)\n\t\t\t{\n\t\t\t    /* If we have only one byte then it's probably an\n\t\t\t     * incomplete byte sequence.  Otherwise discard\n\t\t\t     * one byte as a bad character. */\n\t\t\t    if (size == 1)\n\t\t\t\tbreak;\n\t\t\t    found_bad = TRUE;\n\t\t\t    bytelen = 1;\n\t\t\t}\n\t\t    }\n\n\t\t    if (!found_bad)\n\t\t    {\n\t\t\tint\ti;\n\n\t\t\t/* Convert \"ucs2buf[ucs2len]\" to 'enc' in \"dst\". */\n\t\t\tif (enc_utf8)\n\t\t\t{\n\t\t\t    /* From UCS-2 to UTF-8.  Cannot fail. */\n\t\t\t    for (i = 0; i < ucs2len; ++i)\n\t\t\t\tdst += utf_char2bytes(ucs2buf[i], dst);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    BOOL\tbad = FALSE;\n\t\t\t    int\t\tdstlen;\n\n\t\t\t    /* From UCS-2 to \"enc_codepage\".  If the\n\t\t\t     * conversion uses the default character \"?\",\n\t\t\t     * the data doesn't fit in this encoding. */\n\t\t\t    dstlen = WideCharToMultiByte(enc_codepage, 0,\n\t\t\t\t    (LPCWSTR)ucs2buf, ucs2len,\n\t\t\t\t    (LPSTR)dst, (int)(src - dst),\n\t\t\t\t    replstr, &bad);\n\t\t\t    if (bad)\n\t\t\t\tfound_bad = TRUE;\n\t\t\t    else\n\t\t\t\tdst += dstlen;\n\t\t\t}\n\t\t    }\n\n\t\t    if (found_bad)\n\t\t    {\n\t\t\t/* Deal with bytes we can't convert. */\n\t\t\tif (can_retry)\n\t\t\t    goto rewind_retry;\n\t\t\tif (conv_error == 0)\n\t\t\t    conv_error = readfile_linenr(linecnt, ptr, dst);\n\t\t\tif (bad_char_behavior != BAD_DROP)\n\t\t\t{\n\t\t\t    if (bad_char_behavior == BAD_KEEP)\n\t\t\t    {\n\t\t\t\tmch_memmove(dst, src, bytelen);\n\t\t\t\tdst += bytelen;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\t*dst++ = bad_char_behavior;\n\t\t\t}\n\t\t    }\n\n\t\t    src += bytelen;\n\t\t    size -= bytelen;\n\t\t}\n\n\t\tif (size > 0)\n\t\t{\n\t\t    /* An incomplete byte sequence remaining. */\n\t\t    mch_memmove(conv_rest, src, size);\n\t\t    conv_restlen = size;\n\t\t}\n\n\t\t/* The new size is equal to how much \"dst\" was advanced. */\n\t\tsize = (long)(dst - ptr);\n\t    }\n\t    else\n# endif\n# ifdef MACOS_CONVERT\n\t    if (fio_flags & FIO_MACROMAN)\n\t    {\n\t\t/*\n\t\t * Conversion from Apple MacRoman char encoding to UTF-8 or\n\t\t * latin1.  This is in os_mac_conv.c.\n\t\t */\n\t\tif (macroman2enc(ptr, &size, real_size) == FAIL)\n\t\t    goto rewind_retry;\n\t    }\n\t    else\n# endif\n\t    if (fio_flags != 0)\n\t    {\n\t\tint\tu8c;\n\t\tchar_u\t*dest;\n\t\tchar_u\t*tail = NULL;\n\n\t\t/*\n\t\t * \"enc_utf8\" set: Convert Unicode or Latin1 to UTF-8.\n\t\t * \"enc_utf8\" not set: Convert Unicode to Latin1.\n\t\t * Go from end to start through the buffer, because the number\n\t\t * of bytes may increase.\n\t\t * \"dest\" points to after where the UTF-8 bytes go, \"p\" points\n\t\t * to after the next character to convert.\n\t\t */\n\t\tdest = ptr + real_size;\n\t\tif (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8)\n\t\t{\n\t\t    p = ptr + size;\n\t\t    if (fio_flags == FIO_UTF8)\n\t\t    {\n\t\t\t/* Check for a trailing incomplete UTF-8 sequence */\n\t\t\ttail = ptr + size - 1;\n\t\t\twhile (tail > ptr && (*tail & 0xc0) == 0x80)\n\t\t\t    --tail;\n\t\t\tif (tail + utf_byte2len(*tail) <= ptr + size)\n\t\t\t    tail = NULL;\n\t\t\telse\n\t\t\t    p = tail;\n\t\t    }\n\t\t}\n\t\telse if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n\t\t{\n\t\t    /* Check for a trailing byte */\n\t\t    p = ptr + (size & ~1);\n\t\t    if (size & 1)\n\t\t\ttail = p;\n\t\t    if ((fio_flags & FIO_UTF16) && p > ptr)\n\t\t    {\n\t\t\t/* Check for a trailing leading word */\n\t\t\tif (fio_flags & FIO_ENDIAN_L)\n\t\t\t{\n\t\t\t    u8c = (*--p << 8);\n\t\t\t    u8c += *--p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    u8c = *--p;\n\t\t\t    u8c += (*--p << 8);\n\t\t\t}\n\t\t\tif (u8c >= 0xd800 && u8c <= 0xdbff)\n\t\t\t    tail = p;\n\t\t\telse\n\t\t\t    p += 2;\n\t\t    }\n\t\t}\n\t\telse /*  FIO_UCS4 */\n\t\t{\n\t\t    /* Check for trailing 1, 2 or 3 bytes */\n\t\t    p = ptr + (size & ~3);\n\t\t    if (size & 3)\n\t\t\ttail = p;\n\t\t}\n\n\t\t/* If there is a trailing incomplete sequence move it to\n\t\t * conv_rest[]. */\n\t\tif (tail != NULL)\n\t\t{\n\t\t    conv_restlen = (int)((ptr + size) - tail);\n\t\t    mch_memmove(conv_rest, (char_u *)tail, conv_restlen);\n\t\t    size -= conv_restlen;\n\t\t}\n\n\n\t\twhile (p > ptr)\n\t\t{\n\t\t    if (fio_flags & FIO_LATIN1)\n\t\t\tu8c = *--p;\n\t\t    else if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n\t\t    {\n\t\t\tif (fio_flags & FIO_ENDIAN_L)\n\t\t\t{\n\t\t\t    u8c = (*--p << 8);\n\t\t\t    u8c += *--p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    u8c = *--p;\n\t\t\t    u8c += (*--p << 8);\n\t\t\t}\n\t\t\tif ((fio_flags & FIO_UTF16)\n\t\t\t\t\t    && u8c >= 0xdc00 && u8c <= 0xdfff)\n\t\t\t{\n\t\t\t    int u16c;\n\n\t\t\t    if (p == ptr)\n\t\t\t    {\n\t\t\t\t/* Missing leading word. */\n\t\t\t\tif (can_retry)\n\t\t\t\t    goto rewind_retry;\n\t\t\t\tif (conv_error == 0)\n\t\t\t\t    conv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t\t      ptr, p);\n\t\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t\t    continue;\n\t\t\t\tif (bad_char_behavior != BAD_KEEP)\n\t\t\t\t    u8c = bad_char_behavior;\n\t\t\t    }\n\n\t\t\t    /* found second word of double-word, get the first\n\t\t\t     * word and compute the resulting character */\n\t\t\t    if (fio_flags & FIO_ENDIAN_L)\n\t\t\t    {\n\t\t\t\tu16c = (*--p << 8);\n\t\t\t\tu16c += *--p;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tu16c = *--p;\n\t\t\t\tu16c += (*--p << 8);\n\t\t\t    }\n\t\t\t    u8c = 0x10000 + ((u16c & 0x3ff) << 10)\n\t\t\t\t\t\t\t      + (u8c & 0x3ff);\n\n\t\t\t    /* Check if the word is indeed a leading word. */\n\t\t\t    if (u16c < 0xd800 || u16c > 0xdbff)\n\t\t\t    {\n\t\t\t\tif (can_retry)\n\t\t\t\t    goto rewind_retry;\n\t\t\t\tif (conv_error == 0)\n\t\t\t\t    conv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t\t      ptr, p);\n\t\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t\t    continue;\n\t\t\t\tif (bad_char_behavior != BAD_KEEP)\n\t\t\t\t    u8c = bad_char_behavior;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (fio_flags & FIO_UCS4)\n\t\t    {\n\t\t\tif (fio_flags & FIO_ENDIAN_L)\n\t\t\t{\n\t\t\t    u8c = (unsigned)*--p << 24;\n\t\t\t    u8c += (unsigned)*--p << 16;\n\t\t\t    u8c += (unsigned)*--p << 8;\n\t\t\t    u8c += *--p;\n\t\t\t}\n\t\t\telse\t/* big endian */\n\t\t\t{\n\t\t\t    u8c = *--p;\n\t\t\t    u8c += (unsigned)*--p << 8;\n\t\t\t    u8c += (unsigned)*--p << 16;\n\t\t\t    u8c += (unsigned)*--p << 24;\n\t\t\t}\n\t\t    }\n\t\t    else    /* UTF-8 */\n\t\t    {\n\t\t\tif (*--p < 0x80)\n\t\t\t    u8c = *p;\n\t\t\telse\n\t\t\t{\n\t\t\t    len = utf_head_off(ptr, p);\n\t\t\t    p -= len;\n\t\t\t    u8c = utf_ptr2char(p);\n\t\t\t    if (len == 0)\n\t\t\t    {\n\t\t\t\t/* Not a valid UTF-8 character, retry with\n\t\t\t\t * another fenc when possible, otherwise just\n\t\t\t\t * report the error. */\n\t\t\t\tif (can_retry)\n\t\t\t\t    goto rewind_retry;\n\t\t\t\tif (conv_error == 0)\n\t\t\t\t    conv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t\t      ptr, p);\n\t\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t\t    continue;\n\t\t\t\tif (bad_char_behavior != BAD_KEEP)\n\t\t\t\t    u8c = bad_char_behavior;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (enc_utf8)\t/* produce UTF-8 */\n\t\t    {\n\t\t\tdest -= utf_char2len(u8c);\n\t\t\t(void)utf_char2bytes(u8c, dest);\n\t\t    }\n\t\t    else\t\t/* produce Latin1 */\n\t\t    {\n\t\t\t--dest;\n\t\t\tif (u8c >= 0x100)\n\t\t\t{\n\t\t\t    /* character doesn't fit in latin1, retry with\n\t\t\t     * another fenc when possible, otherwise just\n\t\t\t     * report the error. */\n\t\t\t    if (can_retry)\n\t\t\t\tgoto rewind_retry;\n\t\t\t    if (conv_error == 0)\n\t\t\t\tconv_error = readfile_linenr(linecnt, ptr, p);\n\t\t\t    if (bad_char_behavior == BAD_DROP)\n\t\t\t\t++dest;\n\t\t\t    else if (bad_char_behavior == BAD_KEEP)\n\t\t\t\t*dest = u8c;\n\t\t\t    else if (eap != NULL && eap->bad_char != 0)\n\t\t\t\t*dest = bad_char_behavior;\n\t\t\t    else\n\t\t\t\t*dest = 0xBF;\n\t\t\t}\n\t\t\telse\n\t\t\t    *dest = u8c;\n\t\t    }\n\t\t}\n\n\t\t/* move the linerest to before the converted characters */\n\t\tline_start = dest - linerest;\n\t\tmch_memmove(line_start, buffer, (size_t)linerest);\n\t\tsize = (long)((ptr + real_size) - dest);\n\t\tptr = dest;\n\t    }\n\t    else if (enc_utf8 && !curbuf->b_p_bin)\n\t    {\n\t\tint  incomplete_tail = FALSE;\n\n\t\t/* Reading UTF-8: Check if the bytes are valid UTF-8. */\n\t\tfor (p = ptr; ; ++p)\n\t\t{\n\t\t    int\t todo = (int)((ptr + size) - p);\n\t\t    int\t l;\n\n\t\t    if (todo <= 0)\n\t\t\tbreak;\n\t\t    if (*p >= 0x80)\n\t\t    {\n\t\t\t/* A length of 1 means it's an illegal byte.  Accept\n\t\t\t * an incomplete character at the end though, the next\n\t\t\t * read() will get the next bytes, we'll check it\n\t\t\t * then. */\n\t\t\tl = utf_ptr2len_len(p, todo);\n\t\t\tif (l > todo && !incomplete_tail)\n\t\t\t{\n\t\t\t    /* Avoid retrying with a different encoding when\n\t\t\t     * a truncated file is more likely, or attempting\n\t\t\t     * to read the rest of an incomplete sequence when\n\t\t\t     * we have already done so. */\n\t\t\t    if (p > ptr || filesize > 0)\n\t\t\t\tincomplete_tail = TRUE;\n\t\t\t    /* Incomplete byte sequence, move it to conv_rest[]\n\t\t\t     * and try to read the rest of it, unless we've\n\t\t\t     * already done so. */\n\t\t\t    if (p > ptr)\n\t\t\t    {\n\t\t\t\tconv_restlen = todo;\n\t\t\t\tmch_memmove(conv_rest, p, conv_restlen);\n\t\t\t\tsize -= conv_restlen;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (l == 1 || l > todo)\n\t\t\t{\n\t\t\t    /* Illegal byte.  If we can try another encoding\n\t\t\t     * do that, unless at EOF where a truncated\n\t\t\t     * file is more likely than a conversion error. */\n\t\t\t    if (can_retry && !incomplete_tail)\n\t\t\t\tbreak;\n# ifdef USE_ICONV\n\t\t\t    /* When we did a conversion report an error. */\n\t\t\t    if (iconv_fd != (iconv_t)-1 && conv_error == 0)\n\t\t\t\tconv_error = readfile_linenr(linecnt, ptr, p);\n# endif\n\t\t\t    /* Remember the first linenr with an illegal byte */\n\t\t\t    if (conv_error == 0 && illegal_byte == 0)\n\t\t\t\tillegal_byte = readfile_linenr(linecnt, ptr, p);\n\n\t\t\t    /* Drop, keep or replace the bad byte. */\n\t\t\t    if (bad_char_behavior == BAD_DROP)\n\t\t\t    {\n\t\t\t\tmch_memmove(p, p + 1, todo - 1);\n\t\t\t\t--p;\n\t\t\t\t--size;\n\t\t\t    }\n\t\t\t    else if (bad_char_behavior != BAD_KEEP)\n\t\t\t\t*p = bad_char_behavior;\n\t\t\t}\n\t\t\telse\n\t\t\t    p += l - 1;\n\t\t    }\n\t\t}\n\t\tif (p < ptr + size && !incomplete_tail)\n\t\t{\n\t\t    /* Detected a UTF-8 error. */\nrewind_retry:\n\t\t    /* Retry reading with another conversion. */\n# if defined(FEAT_EVAL) && defined(USE_ICONV)\n\t\t    if (*p_ccv != NUL && iconv_fd != (iconv_t)-1)\n\t\t\t/* iconv() failed, try 'charconvert' */\n\t\t\tdid_iconv = TRUE;\n\t\t    else\n# endif\n\t\t\t/* use next item from 'fileencodings' */\n\t\t\tadvance_fenc = TRUE;\n\t\t    file_rewind = TRUE;\n\t\t    goto retry;\n\t\t}\n\t    }\n#endif\n\n\t    /* count the number of characters (after conversion!) */\n\t    filesize += size;\n\n\t    /*\n\t     * when reading the first part of a file: guess EOL type\n\t     */\n\t    if (fileformat == EOL_UNKNOWN)\n\t    {\n\t\t/* First try finding a NL, for Dos and Unix */\n\t\tif (try_dos || try_unix)\n\t\t{\n\t\t    /* Reset the carriage return counter. */\n\t\t    if (try_mac)\n\t\t\ttry_mac = 1;\n\n\t\t    for (p = ptr; p < ptr + size; ++p)\n\t\t    {\n\t\t\tif (*p == NL)\n\t\t\t{\n\t\t\t    if (!try_unix\n\t\t\t\t    || (try_dos && p > ptr && p[-1] == CAR))\n\t\t\t\tfileformat = EOL_DOS;\n\t\t\t    else\n\t\t\t\tfileformat = EOL_UNIX;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (*p == CAR && try_mac)\n\t\t\t    try_mac++;\n\t\t    }\n\n\t\t    /* Don't give in to EOL_UNIX if EOL_MAC is more likely */\n\t\t    if (fileformat == EOL_UNIX && try_mac)\n\t\t    {\n\t\t\t/* Need to reset the counters when retrying fenc. */\n\t\t\ttry_mac = 1;\n\t\t\ttry_unix = 1;\n\t\t\tfor (; p >= ptr && *p != CAR; p--)\n\t\t\t    ;\n\t\t\tif (p >= ptr)\n\t\t\t{\n\t\t\t    for (p = ptr; p < ptr + size; ++p)\n\t\t\t    {\n\t\t\t\tif (*p == NL)\n\t\t\t\t    try_unix++;\n\t\t\t\telse if (*p == CAR)\n\t\t\t\t    try_mac++;\n\t\t\t    }\n\t\t\t    if (try_mac > try_unix)\n\t\t\t\tfileformat = EOL_MAC;\n\t\t\t}\n\t\t    }\n\t\t    else if (fileformat == EOL_UNKNOWN && try_mac == 1)\n\t\t\t/* Looking for CR but found no end-of-line markers at\n\t\t\t * all: use the default format. */\n\t\t\tfileformat = default_fileformat();\n\t\t}\n\n\t\t/* No NL found: may use Mac format */\n\t\tif (fileformat == EOL_UNKNOWN && try_mac)\n\t\t    fileformat = EOL_MAC;\n\n\t\t/* Still nothing found?  Use first format in 'ffs' */\n\t\tif (fileformat == EOL_UNKNOWN)\n\t\t    fileformat = default_fileformat();\n\n\t\t/* if editing a new file: may set p_tx and p_ff */\n\t\tif (set_options)\n\t\t    set_fileformat(fileformat, OPT_LOCAL);\n\t    }\n\t}\n\n\t/*\n\t * This loop is executed once for every character read.\n\t * Keep it fast!\n\t */\n\tif (fileformat == EOL_MAC)\n\t{\n\t    --ptr;\n\t    while (++ptr, --size >= 0)\n\t    {\n\t\t/* catch most common case first */\n\t\tif ((c = *ptr) != NUL && c != CAR && c != NL)\n\t\t    continue;\n\t\tif (c == NUL)\n\t\t    *ptr = NL;\t/* NULs are replaced by newlines! */\n\t\telse if (c == NL)\n\t\t    *ptr = CAR;\t/* NLs are replaced by CRs! */\n\t\telse\n\t\t{\n\t\t    if (skip_count == 0)\n\t\t    {\n\t\t\t*ptr = NUL;\t    /* end of line */\n\t\t\tlen = (colnr_T) (ptr - line_start + 1);\n\t\t\tif (ml_append(lnum, line_start, len, newfile) == FAIL)\n\t\t\t{\n\t\t\t    error = TRUE;\n\t\t\t    break;\n\t\t\t}\n#ifdef FEAT_PERSISTENT_UNDO\n\t\t\tif (read_undo_file)\n\t\t\t    sha256_update(&sha_ctx, line_start, len);\n#endif\n\t\t\t++lnum;\n\t\t\tif (--read_count == 0)\n\t\t\t{\n\t\t\t    error = TRUE;\t/* break loop */\n\t\t\t    line_start = ptr;\t/* nothing left to write */\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t--skip_count;\n\t\t    line_start = ptr + 1;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    --ptr;\n\t    while (++ptr, --size >= 0)\n\t    {\n\t\tif ((c = *ptr) != NUL && c != NL)  /* catch most common case */\n\t\t    continue;\n\t\tif (c == NUL)\n\t\t    *ptr = NL;\t/* NULs are replaced by newlines! */\n\t\telse\n\t\t{\n\t\t    if (skip_count == 0)\n\t\t    {\n\t\t\t*ptr = NUL;\t\t/* end of line */\n\t\t\tlen = (colnr_T)(ptr - line_start + 1);\n\t\t\tif (fileformat == EOL_DOS)\n\t\t\t{\n\t\t\t    if (ptr > line_start && ptr[-1] == CAR)\n\t\t\t    {\n\t\t\t\t/* remove CR before NL */\n\t\t\t\tptr[-1] = NUL;\n\t\t\t\t--len;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Reading in Dos format, but no CR-LF found!\n\t\t\t     * When 'fileformats' includes \"unix\", delete all\n\t\t\t     * the lines read so far and start all over again.\n\t\t\t     * Otherwise give an error message later.\n\t\t\t     */\n\t\t\t    else if (ff_error != EOL_DOS)\n\t\t\t    {\n\t\t\t\tif (   try_unix\n\t\t\t\t    && !read_stdin\n\t\t\t\t    && (read_buffer\n\t\t\t\t\t|| vim_lseek(fd, (off_T)0L, SEEK_SET)\n\t\t\t\t\t\t\t\t\t  == 0))\n\t\t\t\t{\n\t\t\t\t    fileformat = EOL_UNIX;\n\t\t\t\t    if (set_options)\n\t\t\t\t\tset_fileformat(EOL_UNIX, OPT_LOCAL);\n\t\t\t\t    file_rewind = TRUE;\n\t\t\t\t    keep_fileformat = TRUE;\n\t\t\t\t    goto retry;\n\t\t\t\t}\n\t\t\t\tff_error = EOL_DOS;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (ml_append(lnum, line_start, len, newfile) == FAIL)\n\t\t\t{\n\t\t\t    error = TRUE;\n\t\t\t    break;\n\t\t\t}\n#ifdef FEAT_PERSISTENT_UNDO\n\t\t\tif (read_undo_file)\n\t\t\t    sha256_update(&sha_ctx, line_start, len);\n#endif\n\t\t\t++lnum;\n\t\t\tif (--read_count == 0)\n\t\t\t{\n\t\t\t    error = TRUE;\t    /* break loop */\n\t\t\t    line_start = ptr;\t/* nothing left to write */\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t--skip_count;\n\t\t    line_start = ptr + 1;\n\t\t}\n\t    }\n\t}\n\tlinerest = (long)(ptr - line_start);\n\tui_breakcheck();\n    }\n\nfailed:\n    /* not an error, max. number of lines reached */\n    if (error && read_count == 0)\n\terror = FALSE;\n\n    /*\n     * If we get EOF in the middle of a line, note the fact and\n     * complete the line ourselves.\n     * In Dos format ignore a trailing CTRL-Z, unless 'binary' set.\n     */\n    if (!error\n\t    && !got_int\n\t    && linerest != 0\n\t    && !(!curbuf->b_p_bin\n\t\t&& fileformat == EOL_DOS\n\t\t&& *line_start == Ctrl_Z\n\t\t&& ptr == line_start + 1))\n    {\n\t/* remember for when writing */\n\tif (set_options)\n\t    curbuf->b_p_eol = FALSE;\n\t*ptr = NUL;\n\tlen = (colnr_T)(ptr - line_start + 1);\n\tif (ml_append(lnum, line_start, len, newfile) == FAIL)\n\t    error = TRUE;\n\telse\n\t{\n#ifdef FEAT_PERSISTENT_UNDO\n\t    if (read_undo_file)\n\t\tsha256_update(&sha_ctx, line_start, len);\n#endif\n\t    read_no_eol_lnum = ++lnum;\n\t}\n    }\n\n    if (set_options)\n\tsave_file_ff(curbuf);\t\t/* remember the current file format */\n\n#ifdef FEAT_CRYPT\n    if (curbuf->b_cryptstate != NULL)\n    {\n\tcrypt_free_state(curbuf->b_cryptstate);\n\tcurbuf->b_cryptstate = NULL;\n    }\n    if (cryptkey != NULL && cryptkey != curbuf->b_p_key)\n\tcrypt_free_key(cryptkey);\n    /* Don't set cryptkey to NULL, it's used below as a flag that\n     * encryption was used. */\n#endif\n\n#ifdef FEAT_MBYTE\n    /* If editing a new file: set 'fenc' for the current buffer.\n     * Also for \":read ++edit file\". */\n    if (set_options)\n\tset_string_option_direct((char_u *)\"fenc\", -1, fenc,\n\t\t\t\t\t\t       OPT_FREE|OPT_LOCAL, 0);\n    if (fenc_alloced)\n\tvim_free(fenc);\n# ifdef USE_ICONV\n    if (iconv_fd != (iconv_t)-1)\n    {\n\ticonv_close(iconv_fd);\n\ticonv_fd = (iconv_t)-1;\n    }\n# endif\n#endif\n\n    if (!read_buffer && !read_stdin)\n\tclose(fd);\t\t\t\t/* errors are ignored */\n#ifdef HAVE_FD_CLOEXEC\n    else\n    {\n\tint fdflags = fcntl(fd, F_GETFD);\n\tif (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)\n\t    (void)fcntl(fd, F_SETFD, fdflags | FD_CLOEXEC);\n    }\n#endif\n    vim_free(buffer);\n\n#ifdef HAVE_DUP\n    if (read_stdin)\n    {\n\t/* Use stderr for stdin, makes shell commands work. */\n\tclose(0);\n\tignored = dup(2);\n    }\n#endif\n\n#ifdef FEAT_MBYTE\n    if (tmpname != NULL)\n    {\n\tmch_remove(tmpname);\t\t/* delete converted file */\n\tvim_free(tmpname);\n    }\n#endif\n    --no_wait_return;\t\t\t/* may wait for return now */\n\n    /*\n     * In recovery mode everything but autocommands is skipped.\n     */\n    if (!recoverymode)\n    {\n\t/* need to delete the last line, which comes from the empty buffer */\n\tif (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY))\n\t{\n#ifdef FEAT_NETBEANS_INTG\n\t    netbeansFireChanges = 0;\n#endif\n\t    ml_delete(curbuf->b_ml.ml_line_count, FALSE);\n#ifdef FEAT_NETBEANS_INTG\n\t    netbeansFireChanges = 1;\n#endif\n\t    --linecnt;\n\t}\n\tlinecnt = curbuf->b_ml.ml_line_count - linecnt;\n\tif (filesize == 0)\n\t    linecnt = 0;\n\tif (newfile || read_buffer)\n\t{\n\t    redraw_curbuf_later(NOT_VALID);\n#ifdef FEAT_DIFF\n\t    /* After reading the text into the buffer the diff info needs to\n\t     * be updated. */\n\t    diff_invalidate(curbuf);\n#endif\n#ifdef FEAT_FOLDING\n\t    /* All folds in the window are invalid now.  Mark them for update\n\t     * before triggering autocommands. */\n\t    foldUpdateAll(curwin);\n#endif\n\t}\n\telse if (linecnt)\t\t/* appended at least one line */\n\t    appended_lines_mark(from, linecnt);\n\n#ifndef ALWAYS_USE_GUI\n\t/*\n\t * If we were reading from the same terminal as where messages go,\n\t * the screen will have been messed up.\n\t * Switch on raw mode now and clear the screen.\n\t */\n\tif (read_stdin)\n\t{\n\t    settmode(TMODE_RAW);\t/* set to raw mode */\n\t    starttermcap();\n\t    screenclear();\n\t}\n#endif\n\n\tif (got_int)\n\t{\n\t    if (!(flags & READ_DUMMY))\n\t    {\n\t\tfilemess(curbuf, sfname, (char_u *)_(e_interr), 0);\n\t\tif (newfile)\n\t\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t    }\n\t    msg_scroll = msg_save;\n#ifdef FEAT_VIMINFO\n\t    check_marks_read();\n#endif\n\t    return OK;\t\t/* an interrupt isn't really an error */\n\t}\n\n\tif (!filtering && !(flags & READ_DUMMY))\n\t{\n\t    msg_add_fname(curbuf, sfname);   /* fname in IObuff with quotes */\n\t    c = FALSE;\n\n#ifdef UNIX\n# ifdef S_ISFIFO\n\t    if (S_ISFIFO(perm))\t\t\t    /* fifo or socket */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[fifo/socket]\"));\n\t\tc = TRUE;\n\t    }\n# else\n#  ifdef S_IFIFO\n\t    if ((perm & S_IFMT) == S_IFIFO)\t    /* fifo */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[fifo]\"));\n\t\tc = TRUE;\n\t    }\n#  endif\n#  ifdef S_IFSOCK\n\t    if ((perm & S_IFMT) == S_IFSOCK)\t    /* or socket */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[socket]\"));\n\t\tc = TRUE;\n\t    }\n#  endif\n# endif\n# ifdef OPEN_CHR_FILES\n\t    if (S_ISCHR(perm))\t\t\t    /* or character special */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[character special]\"));\n\t\tc = TRUE;\n\t    }\n# endif\n#endif\n\t    if (curbuf->b_p_ro)\n\t    {\n\t\tSTRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));\n\t\tc = TRUE;\n\t    }\n\t    if (read_no_eol_lnum)\n\t    {\n\t\tmsg_add_eol();\n\t\tc = TRUE;\n\t    }\n\t    if (ff_error == EOL_DOS)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[CR missing]\"));\n\t\tc = TRUE;\n\t    }\n\t    if (split)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[long lines split]\"));\n\t\tc = TRUE;\n\t    }\n#ifdef FEAT_MBYTE\n\t    if (notconverted)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[NOT converted]\"));\n\t\tc = TRUE;\n\t    }\n\t    else if (converted)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[converted]\"));\n\t\tc = TRUE;\n\t    }\n#endif\n#ifdef FEAT_CRYPT\n\t    if (cryptkey != NULL)\n\t    {\n\t\tcrypt_append_msg(curbuf);\n\t\tc = TRUE;\n\t    }\n#endif\n#ifdef FEAT_MBYTE\n\t    if (conv_error != 0)\n\t    {\n\t\tsprintf((char *)IObuff + STRLEN(IObuff),\n\t\t       _(\"[CONVERSION ERROR in line %ld]\"), (long)conv_error);\n\t\tc = TRUE;\n\t    }\n\t    else if (illegal_byte > 0)\n\t    {\n\t\tsprintf((char *)IObuff + STRLEN(IObuff),\n\t\t\t _(\"[ILLEGAL BYTE in line %ld]\"), (long)illegal_byte);\n\t\tc = TRUE;\n\t    }\n\t    else\n#endif\n\t\tif (error)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[READ ERRORS]\"));\n\t\tc = TRUE;\n\t    }\n\t    if (msg_add_fileformat(fileformat))\n\t\tc = TRUE;\n#ifdef FEAT_CRYPT\n\t    if (cryptkey != NULL)\n\t\tmsg_add_lines(c, (long)linecnt, filesize\n\t\t\t - crypt_get_header_len(crypt_get_method_nr(curbuf)));\n\t    else\n#endif\n\t\tmsg_add_lines(c, (long)linecnt, filesize);\n\n\t    vim_free(keep_msg);\n\t    keep_msg = NULL;\n\t    msg_scrolled_ign = TRUE;\n#ifdef ALWAYS_USE_GUI\n\t    /* Don't show the message when reading stdin, it would end up in a\n\t     * message box (which might be shown when exiting!) */\n\t    if (read_stdin || read_buffer)\n\t\tp = msg_may_trunc(FALSE, IObuff);\n\t    else\n#endif\n\t\tp = msg_trunc_attr(IObuff, FALSE, 0);\n\t    if (read_stdin || read_buffer || restart_edit != 0\n\t\t    || (msg_scrolled != 0 && !need_wait_return))\n\t\t/* Need to repeat the message after redrawing when:\n\t\t * - When reading from stdin (the screen will be cleared next).\n\t\t * - When restart_edit is set (otherwise there will be a delay\n\t\t *   before redrawing).\n\t\t * - When the screen was scrolled but there is no wait-return\n\t\t *   prompt. */\n\t\tset_keep_msg(p, 0);\n\t    msg_scrolled_ign = FALSE;\n\t}\n\n\t/* with errors writing the file requires \":w!\" */\n\tif (newfile && (error\n#ifdef FEAT_MBYTE\n\t\t    || conv_error != 0\n\t\t    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)\n#endif\n\t\t    ))\n\t    curbuf->b_p_ro = TRUE;\n\n\tu_clearline();\t    /* cannot use \"U\" command after adding lines */\n\n\t/*\n\t * In Ex mode: cursor at last new line.\n\t * Otherwise: cursor at first new line.\n\t */\n\tif (exmode_active)\n\t    curwin->w_cursor.lnum = from + linecnt;\n\telse\n\t    curwin->w_cursor.lnum = from + 1;\n\tcheck_cursor_lnum();\n\tbeginline(BL_WHITE | BL_FIX);\t    /* on first non-blank */\n\n\t/*\n\t * Set '[ and '] marks to the newly read lines.\n\t */\n\tcurbuf->b_op_start.lnum = from + 1;\n\tcurbuf->b_op_start.col = 0;\n\tcurbuf->b_op_end.lnum = from + linecnt;\n\tcurbuf->b_op_end.col = 0;\n\n#ifdef WIN32\n\t/*\n\t * Work around a weird problem: When a file has two links (only\n\t * possible on NTFS) and we write through one link, then stat() it\n\t * through the other link, the timestamp information may be wrong.\n\t * It's correct again after reading the file, thus reset the timestamp\n\t * here.\n\t */\n\tif (newfile && !read_stdin && !read_buffer\n\t\t\t\t\t && mch_stat((char *)fname, &st) >= 0)\n\t{\n\t    buf_store_time(curbuf, &st, fname);\n\t    curbuf->b_mtime_read = curbuf->b_mtime;\n\t}\n#endif\n    }\n    msg_scroll = msg_save;\n\n#ifdef FEAT_VIMINFO\n    /*\n     * Get the marks before executing autocommands, so they can be used there.\n     */\n    check_marks_read();\n#endif\n\n    /*\n     * We remember if the last line of the read didn't have\n     * an eol even when 'binary' is off, to support turning 'fixeol' off,\n     * or writing the read again with 'binary' on.  The latter is required\n     * for \":autocmd FileReadPost *.gz set bin|'[,']!gunzip\" to work.\n     */\n    curbuf->b_no_eol_lnum = read_no_eol_lnum;\n\n    /* When reloading a buffer put the cursor at the first line that is\n     * different. */\n    if (flags & READ_KEEP_UNDO)\n\tu_find_first_changed();\n\n#ifdef FEAT_PERSISTENT_UNDO\n    /*\n     * When opening a new file locate undo info and read it.\n     */\n    if (read_undo_file)\n    {\n\tchar_u\thash[UNDO_HASH_SIZE];\n\n\tsha256_finish(&sha_ctx, hash);\n\tu_read_undo(NULL, hash, fname);\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    if (!read_stdin && !read_fifo && (!read_buffer || sfname != NULL))\n    {\n\tint m = msg_scroll;\n\tint n = msg_scrolled;\n\n\t/* Save the fileformat now, otherwise the buffer will be considered\n\t * modified if the format/encoding was automatically detected. */\n\tif (set_options)\n\t    save_file_ff(curbuf);\n\n\t/*\n\t * The output from the autocommands should not overwrite anything and\n\t * should not be overwritten: Set msg_scroll, restore its value if no\n\t * output was done.\n\t */\n\tmsg_scroll = TRUE;\n\tif (filtering)\n\t    apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (newfile || (read_buffer && sfname != NULL))\n\t{\n\t    apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\t    if (!au_did_filetype && *curbuf->b_p_ft != NUL)\n\t\t/*\n\t\t * EVENT_FILETYPE was not triggered but the buffer already has a\n\t\t * filetype. Trigger EVENT_FILETYPE using the existing filetype.\n\t\t */\n\t\tapply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft, curbuf->b_fname,\n\t\t\tTRUE, curbuf);\n\t}\n\telse\n\t    apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,\n\t\t\t\t\t\t\t    FALSE, NULL, eap);\n\tif (msg_scrolled == n)\n\t    msg_scroll = m;\n# ifdef FEAT_EVAL\n\tif (aborting())\t    /* autocmds may abort script processing */\n\t    return FAIL;\n# endif\n    }\n#endif\n\n    if (recoverymode && error)\n\treturn FAIL;\n    return OK;\n}\n\n#if defined(OPEN_CHR_FILES) || defined(PROTO)\n/*\n * Returns TRUE if the file name argument is of the form \"/dev/fd/\\d\\+\",\n * which is the name of files used for process substitution output by\n * some shells on some operating systems, e.g., bash on SunOS.\n * Do not accept \"/dev/fd/[012]\", opening these may hang Vim.\n */\n    int\nis_dev_fd_file(char_u *fname)\n{\n    return (STRNCMP(fname, \"/dev/fd/\", 8) == 0\n\t    && VIM_ISDIGIT(fname[8])\n\t    && *skipdigits(fname + 9) == NUL\n\t    && (fname[9] != NUL\n\t\t|| (fname[8] != '0' && fname[8] != '1' && fname[8] != '2')));\n}\n#endif\n\n#ifdef FEAT_MBYTE\n\n/*\n * From the current line count and characters read after that, estimate the\n * line number where we are now.\n * Used for error messages that include a line number.\n */\n    static linenr_T\nreadfile_linenr(\n    linenr_T\tlinecnt,\t/* line count before reading more bytes */\n    char_u\t*p,\t\t/* start of more bytes read */\n    char_u\t*endp)\t\t/* end of more bytes read */\n{\n    char_u\t*s;\n    linenr_T\tlnum;\n\n    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;\n    for (s = p; s < endp; ++s)\n\tif (*s == '\\n')\n\t    ++lnum;\n    return lnum;\n}\n#endif\n\n/*\n * Fill \"*eap\" to force the 'fileencoding', 'fileformat' and 'binary to be\n * equal to the buffer \"buf\".  Used for calling readfile().\n * Returns OK or FAIL.\n */\n    int\nprep_exarg(exarg_T *eap, buf_T *buf)\n{\n    eap->cmd = alloc((unsigned)(STRLEN(buf->b_p_ff)\n#ifdef FEAT_MBYTE\n\t\t+ STRLEN(buf->b_p_fenc)\n#endif\n\t\t\t\t\t\t + 15));\n    if (eap->cmd == NULL)\n\treturn FAIL;\n\n#ifdef FEAT_MBYTE\n    sprintf((char *)eap->cmd, \"e ++ff=%s ++enc=%s\", buf->b_p_ff, buf->b_p_fenc);\n    eap->force_enc = 14 + (int)STRLEN(buf->b_p_ff);\n    eap->bad_char = buf->b_bad_char;\n#else\n    sprintf((char *)eap->cmd, \"e ++ff=%s\", buf->b_p_ff);\n#endif\n    eap->force_ff = 7;\n\n    eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;\n    eap->read_edit = FALSE;\n    eap->forceit = FALSE;\n    return OK;\n}\n\n/*\n * Set default or forced 'fileformat' and 'binary'.\n */\n    void\nset_file_options(int set_options, exarg_T *eap)\n{\n    /* set default 'fileformat' */\n    if (set_options)\n    {\n\tif (eap != NULL && eap->force_ff != 0)\n\t    set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);\n\telse if (*p_ffs != NUL)\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n    /* set or reset 'binary' */\n    if (eap != NULL && eap->force_bin != 0)\n    {\n\tint\toldval = curbuf->b_p_bin;\n\n\tcurbuf->b_p_bin = (eap->force_bin == FORCE_BIN);\n\tset_options_bin(oldval, curbuf->b_p_bin, OPT_LOCAL);\n    }\n}\n\n#if defined(FEAT_MBYTE) || defined(PROTO)\n/*\n * Set forced 'fileencoding'.\n */\n    void\nset_forced_fenc(exarg_T *eap)\n{\n    if (eap->force_enc != 0)\n    {\n\tchar_u *fenc = enc_canonize(eap->cmd + eap->force_enc);\n\n\tif (fenc != NULL)\n\t    set_string_option_direct((char_u *)\"fenc\", -1,\n\t\t\t\t fenc, OPT_FREE|OPT_LOCAL, 0);\n\tvim_free(fenc);\n    }\n}\n\n/*\n * Find next fileencoding to use from 'fileencodings'.\n * \"pp\" points to fenc_next.  It's advanced to the next item.\n * When there are no more items, an empty string is returned and *pp is set to\n * NULL.\n * When *pp is not set to NULL, the result is in allocated memory.\n */\n    static char_u *\nnext_fenc(char_u **pp)\n{\n    char_u\t*p;\n    char_u\t*r;\n\n    if (**pp == NUL)\n    {\n\t*pp = NULL;\n\treturn (char_u *)\"\";\n    }\n    p = vim_strchr(*pp, ',');\n    if (p == NULL)\n    {\n\tr = enc_canonize(*pp);\n\t*pp += STRLEN(*pp);\n    }\n    else\n    {\n\tr = vim_strnsave(*pp, (int)(p - *pp));\n\t*pp = p + 1;\n\tif (r != NULL)\n\t{\n\t    p = enc_canonize(r);\n\t    vim_free(r);\n\t    r = p;\n\t}\n    }\n    if (r == NULL)\t/* out of memory */\n    {\n\tr = (char_u *)\"\";\n\t*pp = NULL;\n    }\n    return r;\n}\n\n# ifdef FEAT_EVAL\n/*\n * Convert a file with the 'charconvert' expression.\n * This closes the file which is to be read, converts it and opens the\n * resulting file for reading.\n * Returns name of the resulting converted file (the caller should delete it\n * after reading it).\n * Returns NULL if the conversion failed (\"*fdp\" is not set) .\n */\n    static char_u *\nreadfile_charconvert(\n    char_u\t*fname,\t\t/* name of input file */\n    char_u\t*fenc,\t\t/* converted from */\n    int\t\t*fdp)\t\t/* in/out: file descriptor of file */\n{\n    char_u\t*tmpname;\n    char_u\t*errmsg = NULL;\n\n    tmpname = vim_tempname('r', FALSE);\n    if (tmpname == NULL)\n\terrmsg = (char_u *)_(\"Can't find temp file for conversion\");\n    else\n    {\n\tclose(*fdp);\t\t/* close the input file, ignore errors */\n\t*fdp = -1;\n\tif (eval_charconvert(fenc, enc_utf8 ? (char_u *)\"utf-8\" : p_enc,\n\t\t\t\t\t\t      fname, tmpname) == FAIL)\n\t    errmsg = (char_u *)_(\"Conversion with 'charconvert' failed\");\n\tif (errmsg == NULL && (*fdp = mch_open((char *)tmpname,\n\t\t\t\t\t\t  O_RDONLY | O_EXTRA, 0)) < 0)\n\t    errmsg = (char_u *)_(\"can't read output of 'charconvert'\");\n    }\n\n    if (errmsg != NULL)\n    {\n\t/* Don't use emsg(), it breaks mappings, the retry with\n\t * another type of conversion might still work. */\n\tMSG(errmsg);\n\tif (tmpname != NULL)\n\t{\n\t    mch_remove(tmpname);\t/* delete converted file */\n\t    vim_free(tmpname);\n\t    tmpname = NULL;\n\t}\n    }\n\n    /* If the input file is closed, open it (caller should check for error). */\n    if (*fdp < 0)\n\t*fdp = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n\n    return tmpname;\n}\n# endif\n\n#endif\n\n#ifdef FEAT_VIMINFO\n/*\n * Read marks for the current buffer from the viminfo file, when we support\n * buffer marks and the buffer has a name.\n */\n    static void\ncheck_marks_read(void)\n{\n    if (!curbuf->b_marks_read && get_viminfo_parameter('\\'') > 0\n\t\t\t\t\t\t  && curbuf->b_ffname != NULL)\n\tread_viminfo(NULL, VIF_WANT_MARKS);\n\n    /* Always set b_marks_read; needed when 'viminfo' is changed to include\n     * the ' parameter after opening a buffer. */\n    curbuf->b_marks_read = TRUE;\n}\n#endif\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Check for magic number used for encryption.  Applies to the current buffer.\n * If found, the magic number is removed from ptr[*sizep] and *sizep and\n * *filesizep are updated.\n * Return the (new) encryption key, NULL for no encryption.\n */\n    static char_u *\ncheck_for_cryptkey(\n    char_u\t*cryptkey,\t/* previous encryption key or NULL */\n    char_u\t*ptr,\t\t/* pointer to read bytes */\n    long\t*sizep,\t\t/* length of read bytes */\n    off_T\t*filesizep,\t/* nr of bytes used from file */\n    int\t\tnewfile,\t/* editing a new buffer */\n    char_u\t*fname,\t\t/* file name to display */\n    int\t\t*did_ask)\t/* flag: whether already asked for key */\n{\n    int method = crypt_method_nr_from_magic((char *)ptr, *sizep);\n    int b_p_ro = curbuf->b_p_ro;\n\n    if (method >= 0)\n    {\n\t/* Mark the buffer as read-only until the decryption has taken place.\n\t * Avoids accidentally overwriting the file with garbage. */\n\tcurbuf->b_p_ro = TRUE;\n\n\t/* Set the cryptmethod local to the buffer. */\n\tcrypt_set_cm_option(curbuf, method);\n\tif (cryptkey == NULL && !*did_ask)\n\t{\n\t    if (*curbuf->b_p_key)\n\t\tcryptkey = curbuf->b_p_key;\n\t    else\n\t    {\n\t\t/* When newfile is TRUE, store the typed key in the 'key'\n\t\t * option and don't free it.  bf needs hash of the key saved.\n\t\t * Don't ask for the key again when first time Enter was hit.\n\t\t * Happens when retrying to detect encoding. */\n\t\tsmsg((char_u *)_(need_key_msg), fname);\n\t\tmsg_scroll = TRUE;\n\t\tcrypt_check_method(method);\n\t\tcryptkey = crypt_get_key(newfile, FALSE);\n\t\t*did_ask = TRUE;\n\n\t\t/* check if empty key entered */\n\t\tif (cryptkey != NULL && *cryptkey == NUL)\n\t\t{\n\t\t    if (cryptkey != curbuf->b_p_key)\n\t\t\tvim_free(cryptkey);\n\t\t    cryptkey = NULL;\n\t\t}\n\t    }\n\t}\n\n\tif (cryptkey != NULL)\n\t{\n\t    int header_len;\n\n\t    curbuf->b_cryptstate = crypt_create_from_header(\n\t\t\t\t\t\t       method, cryptkey, ptr);\n\t    crypt_set_cm_option(curbuf, method);\n\n\t    /* Remove cryptmethod specific header from the text. */\n\t    header_len = crypt_get_header_len(method);\n\t    if (*sizep <= header_len)\n\t\t/* invalid header, buffer can't be encrypted */\n\t\treturn NULL;\n\t    *filesizep += header_len;\n\t    *sizep -= header_len;\n\t    mch_memmove(ptr, ptr + header_len, (size_t)*sizep);\n\n\t    /* Restore the read-only flag. */\n\t    curbuf->b_p_ro = b_p_ro;\n\t}\n    }\n    /* When starting to edit a new file which does not have encryption, clear\n     * the 'key' option, except when starting up (called with -x argument) */\n    else if (newfile && *curbuf->b_p_key != NUL && !starting)\n\tset_option_value((char_u *)\"key\", 0L, (char_u *)\"\", OPT_LOCAL);\n\n    return cryptkey;\n}\n#endif  /* FEAT_CRYPT */\n\n#ifdef UNIX\n    static void\nset_file_time(\n    char_u  *fname,\n    time_t  atime,\t    /* access time */\n    time_t  mtime)\t    /* modification time */\n{\n# if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)\n    struct utimbuf  buf;\n\n    buf.actime\t= atime;\n    buf.modtime\t= mtime;\n    (void)utime((char *)fname, &buf);\n# else\n#  if defined(HAVE_UTIMES)\n    struct timeval  tvp[2];\n\n    tvp[0].tv_sec   = atime;\n    tvp[0].tv_usec  = 0;\n    tvp[1].tv_sec   = mtime;\n    tvp[1].tv_usec  = 0;\n#   ifdef NeXT\n    (void)utimes((char *)fname, tvp);\n#   else\n    (void)utimes((char *)fname, (const struct timeval *)&tvp);\n#   endif\n#  endif\n# endif\n}\n#endif /* UNIX */\n\n#if defined(VMS) && !defined(MIN)\n/* Older DECC compiler for VAX doesn't define MIN() */\n# define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n/*\n * Return TRUE if a file appears to be read-only from the file permissions.\n */\n    int\ncheck_file_readonly(\n    char_u\t*fname,\t\t/* full path to file */\n    int\t\tperm)\t\t/* known permissions on file */\n{\n#ifndef USE_MCH_ACCESS\n    int\t    fd = 0;\n#endif\n\n    return (\n#ifdef USE_MCH_ACCESS\n# ifdef UNIX\n\t(perm & 0222) == 0 ||\n# endif\n\tmch_access((char *)fname, W_OK)\n#else\n\t(fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0\n\t\t\t\t\t? TRUE : (close(fd), FALSE)\n#endif\n\t);\n}\n\n\n/*\n * buf_write() - write to file \"fname\" lines \"start\" through \"end\"\n *\n * We do our own buffering here because fwrite() is so slow.\n *\n * If \"forceit\" is true, we don't care for errors when attempting backups.\n * In case of an error everything possible is done to restore the original\n * file.  But when \"forceit\" is TRUE, we risk losing it.\n *\n * When \"reset_changed\" is TRUE and \"append\" == FALSE and \"start\" == 1 and\n * \"end\" == curbuf->b_ml.ml_line_count, reset curbuf->b_changed.\n *\n * This function must NOT use NameBuff (because it's called by autowrite()).\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nbuf_write(\n    buf_T\t    *buf,\n    char_u\t    *fname,\n    char_u\t    *sfname,\n    linenr_T\t    start,\n    linenr_T\t    end,\n    exarg_T\t    *eap,\t\t/* for forced 'ff' and 'fenc', can be\n\t\t\t\t\t   NULL! */\n    int\t\t    append,\t\t/* append to the file */\n    int\t\t    forceit,\n    int\t\t    reset_changed,\n    int\t\t    filtering)\n{\n    int\t\t    fd;\n    char_u\t    *backup = NULL;\n    int\t\t    backup_copy = FALSE; /* copy the original file? */\n    int\t\t    dobackup;\n    char_u\t    *ffname;\n    char_u\t    *wfname = NULL;\t/* name of file to write to */\n    char_u\t    *s;\n    char_u\t    *ptr;\n    char_u\t    c;\n    int\t\t    len;\n    linenr_T\t    lnum;\n    long\t    nchars;\n    char_u\t    *errmsg = NULL;\n    int\t\t    errmsg_allocated = FALSE;\n    char_u\t    *errnum = NULL;\n    char_u\t    *buffer;\n    char_u\t    smallbuf[SMBUFSIZE];\n    char_u\t    *backup_ext;\n    int\t\t    bufsize;\n    long\t    perm;\t\t    /* file permissions */\n    int\t\t    retval = OK;\n    int\t\t    newfile = FALSE;\t    /* TRUE if file doesn't exist yet */\n    int\t\t    msg_save = msg_scroll;\n    int\t\t    overwriting;\t    /* TRUE if writing over original */\n    int\t\t    no_eol = FALSE;\t    /* no end-of-line written */\n    int\t\t    device = FALSE;\t    /* writing to a device */\n    stat_T\t    st_old;\n    int\t\t    prev_got_int = got_int;\n    int\t\t    checking_conversion;\n    int\t\t    file_readonly = FALSE;  /* overwritten file is read-only */\n    static char\t    *err_readonly = \"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\";\n#if defined(UNIX)\t\t\t    /*XXX fix me sometime? */\n    int\t\t    made_writable = FALSE;  /* 'w' bit has been set */\n#endif\n\t\t\t\t\t/* writing everything */\n    int\t\t    whole = (start == 1 && end == buf->b_ml.ml_line_count);\n#ifdef FEAT_AUTOCMD\n    linenr_T\t    old_line_count = buf->b_ml.ml_line_count;\n#endif\n    int\t\t    attr;\n    int\t\t    fileformat;\n    int\t\t    write_bin;\n    struct bw_info  write_info;\t\t/* info for buf_write_bytes() */\n#ifdef FEAT_MBYTE\n    int\t\t    converted = FALSE;\n    int\t\t    notconverted = FALSE;\n    char_u\t    *fenc;\t\t/* effective 'fileencoding' */\n    char_u\t    *fenc_tofree = NULL; /* allocated \"fenc\" */\n#endif\n#ifdef HAS_BW_FLAGS\n    int\t\t    wb_flags = 0;\n#endif\n#ifdef HAVE_ACL\n    vim_acl_T\t    acl = NULL;\t\t/* ACL copied from original file to\n\t\t\t\t\t   backup or new file */\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n    int\t\t    write_undo_file = FALSE;\n    context_sha256_T sha_ctx;\n#endif\n    unsigned int    bkc = get_bkc_value(buf);\n\n    if (fname == NULL || *fname == NUL)\t/* safety check */\n\treturn FAIL;\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\t/* This can happen during startup when there is a stray \"w\" in the\n\t * vimrc file. */\n\tEMSG(_(e_emptybuf));\n\treturn FAIL;\n    }\n\n    /*\n     * Disallow writing from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_secure())\n\treturn FAIL;\n\n    /* Avoid a crash for a long name. */\n    if (STRLEN(fname) >= MAXPATHL)\n    {\n\tEMSG(_(e_longname));\n\treturn FAIL;\n    }\n\n#ifdef FEAT_MBYTE\n    /* must init bw_conv_buf and bw_iconv_fd before jumping to \"fail\" */\n    write_info.bw_conv_buf = NULL;\n    write_info.bw_conv_error = FALSE;\n    write_info.bw_conv_error_lnum = 0;\n    write_info.bw_restlen = 0;\n# ifdef USE_ICONV\n    write_info.bw_iconv_fd = (iconv_t)-1;\n# endif\n#endif\n#ifdef FEAT_CRYPT\n    write_info.bw_buffer = buf;\n#endif\n\n    /* After writing a file changedtick changes but we don't want to display\n     * the line. */\n    ex_no_reprint = TRUE;\n\n    /*\n     * If there is no file name yet, use the one for the written file.\n     * BF_NOTEDITED is set to reflect this (in case the write fails).\n     * Don't do this when the write is for a filter command.\n     * Don't do this when appending.\n     * Only do this when 'cpoptions' contains the 'F' flag.\n     */\n    if (buf->b_ffname == NULL\n\t    && reset_changed\n\t    && whole\n\t    && buf == curbuf\n#ifdef FEAT_QUICKFIX\n\t    && !bt_nofile(buf)\n#endif\n\t    && !filtering\n\t    && (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)\n\t    && vim_strchr(p_cpo, CPO_FNAMEW) != NULL)\n    {\n\tif (set_rw_fname(fname, sfname) == FAIL)\n\t    return FAIL;\n\tbuf = curbuf;\t    /* just in case autocmds made \"buf\" invalid */\n    }\n\n    if (sfname == NULL)\n\tsfname = fname;\n    /*\n     * For Unix: Use the short file name whenever possible.\n     * Avoids problems with networks and when directory names are changed.\n     * Don't do this for MS-DOS, a \"cd\" in a sub-shell may have moved us to\n     * another directory, which we don't detect\n     */\n    ffname = fname;\t\t\t    /* remember full fname */\n#ifdef UNIX\n    fname = sfname;\n#endif\n\n    if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)\n\toverwriting = TRUE;\n    else\n\toverwriting = FALSE;\n\n    if (exiting)\n\tsettmode(TMODE_COOK);\t    /* when exiting allow typeahead now */\n\n    ++no_wait_return;\t\t    /* don't wait for return yet */\n\n    /*\n     * Set '[ and '] marks to the lines to be written.\n     */\n    buf->b_op_start.lnum = start;\n    buf->b_op_start.col = 0;\n    buf->b_op_end.lnum = end;\n    buf->b_op_end.col = 0;\n\n#ifdef FEAT_AUTOCMD\n    {\n\taco_save_T\taco;\n\tint\t\tbuf_ffname = FALSE;\n\tint\t\tbuf_sfname = FALSE;\n\tint\t\tbuf_fname_f = FALSE;\n\tint\t\tbuf_fname_s = FALSE;\n\tint\t\tdid_cmd = FALSE;\n\tint\t\tnofile_err = FALSE;\n\tint\t\tempty_memline = (buf->b_ml.ml_mfp == NULL);\n\tbufref_T\tbufref;\n\n\t/*\n\t * Apply PRE autocommands.\n\t * Set curbuf to the buffer to be written.\n\t * Careful: The autocommands may call buf_write() recursively!\n\t */\n\tif (ffname == buf->b_ffname)\n\t    buf_ffname = TRUE;\n\tif (sfname == buf->b_sfname)\n\t    buf_sfname = TRUE;\n\tif (fname == buf->b_ffname)\n\t    buf_fname_f = TRUE;\n\tif (fname == buf->b_sfname)\n\t    buf_fname_s = TRUE;\n\n\t/* set curwin/curbuf to buf and save a few things */\n\taucmd_prepbuf(&aco, buf);\n\tset_bufref(&bufref, buf);\n\n\tif (append)\n\t{\n\t    if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,\n\t\t\t\t\t sfname, sfname, FALSE, curbuf, eap)))\n\t    {\n#ifdef FEAT_QUICKFIX\n\t\tif (overwriting && bt_nofile(curbuf))\n\t\t    nofile_err = TRUE;\n\t\telse\n#endif\n\t\t    apply_autocmds_exarg(EVENT_FILEAPPENDPRE,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    }\n\t}\n\telse if (filtering)\n\t{\n\t    apply_autocmds_exarg(EVENT_FILTERWRITEPRE,\n\t\t\t\t\t    NULL, sfname, FALSE, curbuf, eap);\n\t}\n\telse if (reset_changed && whole)\n\t{\n\t    int was_changed = curbufIsChanged();\n\n\t    did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    if (did_cmd)\n\t    {\n\t\tif (was_changed && !curbufIsChanged())\n\t\t{\n\t\t    /* Written everything correctly and BufWriteCmd has reset\n\t\t     * 'modified': Correct the undo information so that an\n\t\t     * undo now sets 'modified'. */\n\t\t    u_unchanged(curbuf);\n\t\t    u_update_save_nr(curbuf);\n\t\t}\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_QUICKFIX\n\t\tif (overwriting && bt_nofile(curbuf))\n\t\t    nofile_err = TRUE;\n\t\telse\n#endif\n\t\t    apply_autocmds_exarg(EVENT_BUFWRITEPRE,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    }\n\t}\n\telse\n\t{\n\t    if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,\n\t\t\t\t\t sfname, sfname, FALSE, curbuf, eap)))\n\t    {\n#ifdef FEAT_QUICKFIX\n\t\tif (overwriting && bt_nofile(curbuf))\n\t\t    nofile_err = TRUE;\n\t\telse\n#endif\n\t\t    apply_autocmds_exarg(EVENT_FILEWRITEPRE,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    }\n\t}\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\n\t/*\n\t * In three situations we return here and don't write the file:\n\t * 1. the autocommands deleted or unloaded the buffer.\n\t * 2. The autocommands abort script processing.\n\t * 3. If one of the \"Cmd\" autocommands was executed.\n\t */\n\tif (!bufref_valid(&bufref))\n\t    buf = NULL;\n\tif (buf == NULL || (buf->b_ml.ml_mfp == NULL && !empty_memline)\n\t\t\t\t       || did_cmd || nofile_err\n#ifdef FEAT_EVAL\n\t\t\t\t       || aborting()\n#endif\n\t\t\t\t       )\n\t{\n\t    --no_wait_return;\n\t    msg_scroll = msg_save;\n\t    if (nofile_err)\n\t\tEMSG(_(\"E676: No matching autocommands for acwrite buffer\"));\n\n\t    if (nofile_err\n#ifdef FEAT_EVAL\n\t\t    || aborting()\n#endif\n\t\t    )\n\t\t/* An aborting error, interrupt or exception in the\n\t\t * autocommands. */\n\t\treturn FAIL;\n\t    if (did_cmd)\n\t    {\n\t\tif (buf == NULL)\n\t\t    /* The buffer was deleted.  We assume it was written\n\t\t     * (can't retry anyway). */\n\t\t    return OK;\n\t\tif (overwriting)\n\t\t{\n\t\t    /* Assume the buffer was written, update the timestamp. */\n\t\t    ml_timestamp(buf);\n\t\t    if (append)\n\t\t\tbuf->b_flags &= ~BF_NEW;\n\t\t    else\n\t\t\tbuf->b_flags &= ~BF_WRITE_MASK;\n\t\t}\n\t\tif (reset_changed && buf->b_changed && !append\n\t\t\t&& (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))\n\t\t    /* Buffer still changed, the autocommands didn't work\n\t\t     * properly. */\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (!aborting())\n#endif\n\t\tEMSG(_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\n\t    return FAIL;\n\t}\n\n\t/*\n\t * The autocommands may have changed the number of lines in the file.\n\t * When writing the whole file, adjust the end.\n\t * When writing part of the file, assume that the autocommands only\n\t * changed the number of lines that are to be written (tricky!).\n\t */\n\tif (buf->b_ml.ml_line_count != old_line_count)\n\t{\n\t    if (whole)\t\t\t\t\t\t/* write all */\n\t\tend = buf->b_ml.ml_line_count;\n\t    else if (buf->b_ml.ml_line_count > old_line_count)\t/* more lines */\n\t\tend += buf->b_ml.ml_line_count - old_line_count;\n\t    else\t\t\t\t\t\t/* less lines */\n\t    {\n\t\tend -= old_line_count - buf->b_ml.ml_line_count;\n\t\tif (end < start)\n\t\t{\n\t\t    --no_wait_return;\n\t\t    msg_scroll = msg_save;\n\t\t    EMSG(_(\"E204: Autocommand changed number of lines in unexpected way\"));\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * The autocommands may have changed the name of the buffer, which may\n\t * be kept in fname, ffname and sfname.\n\t */\n\tif (buf_ffname)\n\t    ffname = buf->b_ffname;\n\tif (buf_sfname)\n\t    sfname = buf->b_sfname;\n\tif (buf_fname_f)\n\t    fname = buf->b_ffname;\n\tif (buf_fname_s)\n\t    fname = buf->b_sfname;\n    }\n#endif\n\n#ifdef FEAT_NETBEANS_INTG\n    if (netbeans_active() && isNetbeansBuffer(buf))\n    {\n\tif (whole)\n\t{\n\t    /*\n\t     * b_changed can be 0 after an undo, but we still need to write\n\t     * the buffer to NetBeans.\n\t     */\n\t    if (buf->b_changed || isNetbeansModified(buf))\n\t    {\n\t\t--no_wait_return;\t\t/* may wait for return now */\n\t\tmsg_scroll = msg_save;\n\t\tnetbeans_save_buffer(buf);\t/* no error checking... */\n\t\treturn retval;\n\t    }\n\t    else\n\t    {\n\t\terrnum = (char_u *)\"E656: \";\n\t\terrmsg = (char_u *)_(\"NetBeans disallows writes of unmodified buffers\");\n\t\tbuffer = NULL;\n\t\tgoto fail;\n\t    }\n\t}\n\telse\n\t{\n\t    errnum = (char_u *)\"E657: \";\n\t    errmsg = (char_u *)_(\"Partial writes disallowed for NetBeans buffers\");\n\t    buffer = NULL;\n\t    goto fail;\n\t}\n    }\n#endif\n\n    if (shortmess(SHM_OVER) && !exiting)\n\tmsg_scroll = FALSE;\t    /* overwrite previous file message */\n    else\n\tmsg_scroll = TRUE;\t    /* don't overwrite previous file message */\n    if (!filtering)\n\tfilemess(buf,\n#ifndef UNIX\n\t\tsfname,\n#else\n\t\tfname,\n#endif\n\t\t    (char_u *)\"\", 0);\t/* show that we are busy */\n    msg_scroll = FALSE;\t\t    /* always overwrite the file message now */\n\n    buffer = alloc(BUFSIZE);\n    if (buffer == NULL)\t\t    /* can't allocate big buffer, use small\n\t\t\t\t     * one (to be able to write when out of\n\t\t\t\t     * memory) */\n    {\n\tbuffer = smallbuf;\n\tbufsize = SMBUFSIZE;\n    }\n    else\n\tbufsize = BUFSIZE;\n\n    /*\n     * Get information about original file (if there is one).\n     */\n#if defined(UNIX)\n    st_old.st_dev = 0;\n    st_old.st_ino = 0;\n    perm = -1;\n    if (mch_stat((char *)fname, &st_old) < 0)\n\tnewfile = TRUE;\n    else\n    {\n\tperm = st_old.st_mode;\n\tif (!S_ISREG(st_old.st_mode))\t\t/* not a file */\n\t{\n\t    if (S_ISDIR(st_old.st_mode))\n\t    {\n\t\terrnum = (char_u *)\"E502: \";\n\t\terrmsg = (char_u *)_(\"is a directory\");\n\t\tgoto fail;\n\t    }\n\t    if (mch_nodetype(fname) != NODE_WRITABLE)\n\t    {\n\t\terrnum = (char_u *)\"E503: \";\n\t\terrmsg = (char_u *)_(\"is not a file or writable device\");\n\t\tgoto fail;\n\t    }\n\t    /* It's a device of some kind (or a fifo) which we can write to\n\t     * but for which we can't make a backup. */\n\t    device = TRUE;\n\t    newfile = TRUE;\n\t    perm = -1;\n\t}\n    }\n#else /* !UNIX */\n    /*\n     * Check for a writable device name.\n     */\n    c = mch_nodetype(fname);\n    if (c == NODE_OTHER)\n    {\n\terrnum = (char_u *)\"E503: \";\n\terrmsg = (char_u *)_(\"is not a file or writable device\");\n\tgoto fail;\n    }\n    if (c == NODE_WRITABLE)\n    {\n# if defined(MSWIN)\n\t/* MS-Windows allows opening a device, but we will probably get stuck\n\t * trying to write to it.  */\n\tif (!p_odev)\n\t{\n\t    errnum = (char_u *)\"E796: \";\n\t    errmsg = (char_u *)_(\"writing to device disabled with 'opendevice' option\");\n\t    goto fail;\n\t}\n# endif\n\tdevice = TRUE;\n\tnewfile = TRUE;\n\tperm = -1;\n    }\n    else\n    {\n\tperm = mch_getperm(fname);\n\tif (perm < 0)\n\t    newfile = TRUE;\n\telse if (mch_isdir(fname))\n\t{\n\t    errnum = (char_u *)\"E502: \";\n\t    errmsg = (char_u *)_(\"is a directory\");\n\t    goto fail;\n\t}\n\tif (overwriting)\n\t    (void)mch_stat((char *)fname, &st_old);\n    }\n#endif /* !UNIX */\n\n    if (!device && !newfile)\n    {\n\t/*\n\t * Check if the file is really writable (when renaming the file to\n\t * make a backup we won't discover it later).\n\t */\n\tfile_readonly = check_file_readonly(fname, (int)perm);\n\n\tif (!forceit && file_readonly)\n\t{\n\t    if (vim_strchr(p_cpo, CPO_FWRITE) != NULL)\n\t    {\n\t\terrnum = (char_u *)\"E504: \";\n\t\terrmsg = (char_u *)_(err_readonly);\n\t    }\n\t    else\n\t    {\n\t\terrnum = (char_u *)\"E505: \";\n\t\terrmsg = (char_u *)_(\"is read-only (add ! to override)\");\n\t    }\n\t    goto fail;\n\t}\n\n\t/*\n\t * Check if the timestamp hasn't changed since reading the file.\n\t */\n\tif (overwriting)\n\t{\n\t    retval = check_mtime(buf, &st_old);\n\t    if (retval == FAIL)\n\t\tgoto fail;\n\t}\n    }\n\n#ifdef HAVE_ACL\n    /*\n     * For systems that support ACL: get the ACL from the original file.\n     */\n    if (!newfile)\n\tacl = mch_get_acl(fname);\n#endif\n\n    /*\n     * If 'backupskip' is not empty, don't make a backup for some files.\n     */\n    dobackup = (p_wb || p_bk || *p_pm != NUL);\n#ifdef FEAT_WILDIGN\n    if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))\n\tdobackup = FALSE;\n#endif\n\n    /*\n     * Save the value of got_int and reset it.  We don't want a previous\n     * interruption cancel writing, only hitting CTRL-C while writing should\n     * abort it.\n     */\n    prev_got_int = got_int;\n    got_int = FALSE;\n\n    /* Mark the buffer as 'being saved' to prevent changed buffer warnings */\n    buf->b_saving = TRUE;\n\n    /*\n     * If we are not appending or filtering, the file exists, and the\n     * 'writebackup', 'backup' or 'patchmode' option is set, need a backup.\n     * When 'patchmode' is set also make a backup when appending.\n     *\n     * Do not make any backup, if 'writebackup' and 'backup' are both switched\n     * off.  This helps when editing large files on almost-full disks.\n     */\n    if (!(append && *p_pm == NUL) && !filtering && perm >= 0 && dobackup)\n    {\n#if defined(UNIX) || defined(WIN32)\n\tstat_T\t    st;\n#endif\n\n\tif ((bkc & BKC_YES) || append)\t/* \"yes\" */\n\t    backup_copy = TRUE;\n#if defined(UNIX) || defined(WIN32)\n\telse if ((bkc & BKC_AUTO))\t/* \"auto\" */\n\t{\n\t    int\t\ti;\n\n# ifdef UNIX\n\t    /*\n\t     * Don't rename the file when:\n\t     * - it's a hard link\n\t     * - it's a symbolic link\n\t     * - we don't have write permission in the directory\n\t     * - we can't set the owner/group of the new file\n\t     */\n\t    if (st_old.st_nlink > 1\n\t\t    || mch_lstat((char *)fname, &st) < 0\n\t\t    || st.st_dev != st_old.st_dev\n\t\t    || st.st_ino != st_old.st_ino\n#  ifndef HAVE_FCHOWN\n\t\t    || st.st_uid != st_old.st_uid\n\t\t    || st.st_gid != st_old.st_gid\n#  endif\n\t\t    )\n\t\tbackup_copy = TRUE;\n\t    else\n# else\n#  ifdef WIN32\n\t    /* On NTFS file systems hard links are possible. */\n\t    if (mch_is_linked(fname))\n\t\tbackup_copy = TRUE;\n\t    else\n#  endif\n# endif\n\t    {\n\t\t/*\n\t\t * Check if we can create a file and set the owner/group to\n\t\t * the ones from the original file.\n\t\t * First find a file name that doesn't exist yet (use some\n\t\t * arbitrary numbers).\n\t\t */\n\t\tSTRCPY(IObuff, fname);\n\t\tfor (i = 4913; ; i += 123)\n\t\t{\n\t\t    sprintf((char *)gettail(IObuff), \"%d\", i);\n\t\t    if (mch_lstat((char *)IObuff, &st) < 0)\n\t\t\tbreak;\n\t\t}\n\t\tfd = mch_open((char *)IObuff,\n\t\t\t\t    O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n\t\tif (fd < 0)\t/* can't write in directory */\n\t\t    backup_copy = TRUE;\n\t\telse\n\t\t{\n# ifdef UNIX\n#  ifdef HAVE_FCHOWN\n\t\t    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);\n#  endif\n\t\t    if (mch_stat((char *)IObuff, &st) < 0\n\t\t\t    || st.st_uid != st_old.st_uid\n\t\t\t    || st.st_gid != st_old.st_gid\n\t\t\t    || (long)st.st_mode != perm)\n\t\t\tbackup_copy = TRUE;\n# endif\n\t\t    /* Close the file before removing it, on MS-Windows we\n\t\t     * can't delete an open file. */\n\t\t    close(fd);\n\t\t    mch_remove(IObuff);\n# ifdef MSWIN\n\t\t    /* MS-Windows may trigger a virus scanner to open the\n\t\t     * file, we can't delete it then.  Keep trying for half a\n\t\t     * second. */\n\t\t    {\n\t\t\tint try;\n\n\t\t\tfor (try = 0; try < 10; ++try)\n\t\t\t{\n\t\t\t    if (mch_lstat((char *)IObuff, &st) < 0)\n\t\t\t\tbreak;\n\t\t\t    ui_delay(50L, TRUE);  /* wait 50 msec */\n\t\t\t    mch_remove(IObuff);\n\t\t\t}\n\t\t    }\n# endif\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Break symlinks and/or hardlinks if we've been asked to.\n\t */\n\tif ((bkc & BKC_BREAKSYMLINK) || (bkc & BKC_BREAKHARDLINK))\n\t{\n# ifdef UNIX\n\t    int\tlstat_res;\n\n\t    lstat_res = mch_lstat((char *)fname, &st);\n\n\t    /* Symlinks. */\n\t    if ((bkc & BKC_BREAKSYMLINK)\n\t\t    && lstat_res == 0\n\t\t    && st.st_ino != st_old.st_ino)\n\t\tbackup_copy = FALSE;\n\n\t    /* Hardlinks. */\n\t    if ((bkc & BKC_BREAKHARDLINK)\n\t\t    && st_old.st_nlink > 1\n\t\t    && (lstat_res != 0 || st.st_ino == st_old.st_ino))\n\t\tbackup_copy = FALSE;\n# else\n#  if defined(WIN32)\n\t    /* Symlinks. */\n\t    if ((bkc & BKC_BREAKSYMLINK) && mch_is_symbolic_link(fname))\n\t\tbackup_copy = FALSE;\n\n\t    /* Hardlinks. */\n\t    if ((bkc & BKC_BREAKHARDLINK) && mch_is_hard_link(fname))\n\t\tbackup_copy = FALSE;\n#  endif\n# endif\n\t}\n\n#endif\n\n\t/* make sure we have a valid backup extension to use */\n\tif (*p_bex == NUL)\n\t    backup_ext = (char_u *)\".bak\";\n\telse\n\t    backup_ext = p_bex;\n\n\tif (backup_copy\n\t\t&& (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) >= 0)\n\t{\n\t    int\t\tbfd;\n\t    char_u\t*copybuf, *wp;\n\t    int\t\tsome_error = FALSE;\n\t    stat_T\tst_new;\n\t    char_u\t*dirp;\n\t    char_u\t*rootname;\n#if defined(UNIX)\n\t    int\t\tdid_set_shortname;\n#endif\n\n\t    copybuf = alloc(BUFSIZE + 1);\n\t    if (copybuf == NULL)\n\t    {\n\t\tsome_error = TRUE;\t    /* out of memory */\n\t\tgoto nobackup;\n\t    }\n\n\t    /*\n\t     * Try to make the backup in each directory in the 'bdir' option.\n\t     *\n\t     * Unix semantics has it, that we may have a writable file,\n\t     * that cannot be recreated with a simple open(..., O_CREAT, ) e.g:\n\t     *  - the directory is not writable,\n\t     *  - the file may be a symbolic link,\n\t     *  - the file may belong to another user/group, etc.\n\t     *\n\t     * For these reasons, the existing writable file must be truncated\n\t     * and reused. Creation of a backup COPY will be attempted.\n\t     */\n\t    dirp = p_bdir;\n\t    while (*dirp)\n\t    {\n#ifdef UNIX\n\t\tst_new.st_ino = 0;\n\t\tst_new.st_dev = 0;\n\t\tst_new.st_gid = 0;\n#endif\n\n\t\t/*\n\t\t * Isolate one directory name, using an entry in 'bdir'.\n\t\t */\n\t\t(void)copy_option_part(&dirp, copybuf, BUFSIZE, \",\");\n\t\trootname = get_file_in_dir(fname, copybuf);\n\t\tif (rootname == NULL)\n\t\t{\n\t\t    some_error = TRUE;\t    /* out of memory */\n\t\t    goto nobackup;\n\t\t}\n\n#if defined(UNIX)\n\t\tdid_set_shortname = FALSE;\n#endif\n\n\t\t/*\n\t\t * May try twice if 'shortname' not set.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t    /*\n\t\t     * Make backup file name.\n\t\t     */\n\t\t    backup = buf_modname((buf->b_p_sn || buf->b_shortname),\n\t\t\t\t\t\t rootname, backup_ext, FALSE);\n\t\t    if (backup == NULL)\n\t\t    {\n\t\t\tvim_free(rootname);\n\t\t\tsome_error = TRUE;\t\t/* out of memory */\n\t\t\tgoto nobackup;\n\t\t    }\n\n\t\t    /*\n\t\t     * Check if backup file already exists.\n\t\t     */\n\t\t    if (mch_stat((char *)backup, &st_new) >= 0)\n\t\t    {\n#ifdef UNIX\n\t\t\t/*\n\t\t\t * Check if backup file is same as original file.\n\t\t\t * May happen when modname() gave the same file back.\n\t\t\t * E.g. silly link, or file name-length reached.\n\t\t\t * If we don't check here, we either ruin the file\n\t\t\t * when copying or erase it after writing. jw.\n\t\t\t */\n\t\t\tif (st_new.st_dev == st_old.st_dev\n\t\t\t\t\t    && st_new.st_ino == st_old.st_ino)\n\t\t\t{\n\t\t\t    vim_free(backup);\n\t\t\t    backup = NULL;\t/* no backup file to delete */\n\t\t\t    /*\n\t\t\t     * may try again with 'shortname' set\n\t\t\t     */\n\t\t\t    if (!(buf->b_shortname || buf->b_p_sn))\n\t\t\t    {\n\t\t\t\tbuf->b_shortname = TRUE;\n\t\t\t\tdid_set_shortname = TRUE;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t\t/* setting shortname didn't help */\n\t\t\t    if (did_set_shortname)\n\t\t\t\tbuf->b_shortname = FALSE;\n\t\t\t    break;\n\t\t\t}\n#endif\n\n\t\t\t/*\n\t\t\t * If we are not going to keep the backup file, don't\n\t\t\t * delete an existing one, try to use another name.\n\t\t\t * Change one character, just before the extension.\n\t\t\t */\n\t\t\tif (!p_bk)\n\t\t\t{\n\t\t\t    wp = backup + STRLEN(backup) - 1\n\t\t\t\t\t\t\t - STRLEN(backup_ext);\n\t\t\t    if (wp < backup)\t/* empty file name ??? */\n\t\t\t\twp = backup;\n\t\t\t    *wp = 'z';\n\t\t\t    while (*wp > 'a'\n\t\t\t\t    && mch_stat((char *)backup, &st_new) >= 0)\n\t\t\t\t--*wp;\n\t\t\t    /* They all exist??? Must be something wrong. */\n\t\t\t    if (*wp == 'a')\n\t\t\t    {\n\t\t\t\tvim_free(backup);\n\t\t\t\tbackup = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tvim_free(rootname);\n\n\t\t/*\n\t\t * Try to create the backup file\n\t\t */\n\t\tif (backup != NULL)\n\t\t{\n\t\t    /* remove old backup, if present */\n\t\t    mch_remove(backup);\n\t\t    /* Open with O_EXCL to avoid the file being created while\n\t\t     * we were sleeping (symlink hacker attack?) */\n\t\t    bfd = mch_open((char *)backup,\n\t\t\t\tO_WRONLY|O_CREAT|O_EXTRA|O_EXCL|O_NOFOLLOW,\n\t\t\t\t\t\t\t\t perm & 0777);\n\t\t    if (bfd < 0)\n\t\t    {\n\t\t\tvim_free(backup);\n\t\t\tbackup = NULL;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/* set file protection same as original file, but\n\t\t\t * strip s-bit */\n\t\t\t(void)mch_setperm(backup, perm & 0777);\n\n#ifdef UNIX\n\t\t\t/*\n\t\t\t * Try to set the group of the backup same as the\n\t\t\t * original file. If this fails, set the protection\n\t\t\t * bits for the group same as the protection bits for\n\t\t\t * others.\n\t\t\t */\n\t\t\tif (st_new.st_gid != st_old.st_gid\n# ifdef HAVE_FCHOWN  /* sequent-ptx lacks fchown() */\n\t\t\t\t&& fchown(bfd, (uid_t)-1, st_old.st_gid) != 0\n# endif\n\t\t\t\t\t\t)\n\t\t\t    mch_setperm(backup,\n\t\t\t\t\t  (perm & 0707) | ((perm & 07) << 3));\n# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n\t\t\tmch_copy_sec(fname, backup);\n# endif\n#endif\n\n\t\t\t/*\n\t\t\t * copy the file.\n\t\t\t */\n\t\t\twrite_info.bw_fd = bfd;\n\t\t\twrite_info.bw_buf = copybuf;\n#ifdef HAS_BW_FLAGS\n\t\t\twrite_info.bw_flags = FIO_NOCONVERT;\n#endif\n\t\t\twhile ((write_info.bw_len = read_eintr(fd, copybuf,\n\t\t\t\t\t\t\t\tBUFSIZE)) > 0)\n\t\t\t{\n\t\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t\t    {\n\t\t\t\terrmsg = (char_u *)_(\"E506: Can't write to backup file (add ! to override)\");\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    ui_breakcheck();\n\t\t\t    if (got_int)\n\t\t\t    {\n\t\t\t\terrmsg = (char_u *)_(e_interr);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (close(bfd) < 0 && errmsg == NULL)\n\t\t\t    errmsg = (char_u *)_(\"E507: Close error for backup file (add ! to override)\");\n\t\t\tif (write_info.bw_len < 0)\n\t\t\t    errmsg = (char_u *)_(\"E508: Can't read file for backup (add ! to override)\");\n#ifdef UNIX\n\t\t\tset_file_time(backup, st_old.st_atime, st_old.st_mtime);\n#endif\n#ifdef HAVE_ACL\n\t\t\tmch_set_acl(backup, acl);\n#endif\n#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n\t\t\tmch_copy_sec(fname, backup);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n    nobackup:\n\t    close(fd);\t\t/* ignore errors for closing read file */\n\t    vim_free(copybuf);\n\n\t    if (backup == NULL && errmsg == NULL)\n\t\terrmsg = (char_u *)_(\"E509: Cannot create backup file (add ! to override)\");\n\t    /* ignore errors when forceit is TRUE */\n\t    if ((some_error || errmsg != NULL) && !forceit)\n\t    {\n\t\tretval = FAIL;\n\t\tgoto fail;\n\t    }\n\t    errmsg = NULL;\n\t}\n\telse\n\t{\n\t    char_u\t*dirp;\n\t    char_u\t*p;\n\t    char_u\t*rootname;\n\n\t    /*\n\t     * Make a backup by renaming the original file.\n\t     */\n\t    /*\n\t     * If 'cpoptions' includes the \"W\" flag, we don't want to\n\t     * overwrite a read-only file.  But rename may be possible\n\t     * anyway, thus we need an extra check here.\n\t     */\n\t    if (file_readonly && vim_strchr(p_cpo, CPO_FWRITE) != NULL)\n\t    {\n\t\terrnum = (char_u *)\"E504: \";\n\t\terrmsg = (char_u *)_(err_readonly);\n\t\tgoto fail;\n\t    }\n\n\t    /*\n\t     *\n\t     * Form the backup file name - change path/fo.o.h to\n\t     * path/fo.o.h.bak Try all directories in 'backupdir', first one\n\t     * that works is used.\n\t     */\n\t    dirp = p_bdir;\n\t    while (*dirp)\n\t    {\n\t\t/*\n\t\t * Isolate one directory name and make the backup file name.\n\t\t */\n\t\t(void)copy_option_part(&dirp, IObuff, IOSIZE, \",\");\n\t\trootname = get_file_in_dir(fname, IObuff);\n\t\tif (rootname == NULL)\n\t\t    backup = NULL;\n\t\telse\n\t\t{\n\t\t    backup = buf_modname((buf->b_p_sn || buf->b_shortname),\n\t\t\t\t\t\t rootname, backup_ext, FALSE);\n\t\t    vim_free(rootname);\n\t\t}\n\n\t\tif (backup != NULL)\n\t\t{\n\t\t    /*\n\t\t     * If we are not going to keep the backup file, don't\n\t\t     * delete an existing one, try to use another name.\n\t\t     * Change one character, just before the extension.\n\t\t     */\n\t\t    if (!p_bk && mch_getperm(backup) >= 0)\n\t\t    {\n\t\t\tp = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);\n\t\t\tif (p < backup)\t/* empty file name ??? */\n\t\t\t    p = backup;\n\t\t\t*p = 'z';\n\t\t\twhile (*p > 'a' && mch_getperm(backup) >= 0)\n\t\t\t    --*p;\n\t\t\t/* They all exist??? Must be something wrong! */\n\t\t\tif (*p == 'a')\n\t\t\t{\n\t\t\t    vim_free(backup);\n\t\t\t    backup = NULL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (backup != NULL)\n\t\t{\n\t\t    /*\n\t\t     * Delete any existing backup and move the current version\n\t\t     * to the backup.\tFor safety, we don't remove the backup\n\t\t     * until the write has finished successfully. And if the\n\t\t     * 'backup' option is set, leave it around.\n\t\t     */\n\t\t    /*\n\t\t     * If the renaming of the original file to the backup file\n\t\t     * works, quit here.\n\t\t     */\n\t\t    if (vim_rename(fname, backup) == 0)\n\t\t\tbreak;\n\n\t\t    vim_free(backup);   /* don't do the rename below */\n\t\t    backup = NULL;\n\t\t}\n\t    }\n\t    if (backup == NULL && !forceit)\n\t    {\n\t\terrmsg = (char_u *)_(\"E510: Can't make backup file (add ! to override)\");\n\t\tgoto fail;\n\t    }\n\t}\n    }\n\n#if defined(UNIX)\n    /* When using \":w!\" and the file was read-only: make it writable */\n    if (forceit && perm >= 0 && !(perm & 0200) && st_old.st_uid == getuid()\n\t\t\t\t     && vim_strchr(p_cpo, CPO_FWRITE) == NULL)\n    {\n\tperm |= 0200;\n\t(void)mch_setperm(fname, perm);\n\tmade_writable = TRUE;\n    }\n#endif\n\n    /* When using \":w!\" and writing to the current file, 'readonly' makes no\n     * sense, reset it, unless 'Z' appears in 'cpoptions'.  */\n    if (forceit && overwriting && vim_strchr(p_cpo, CPO_KEEPRO) == NULL)\n    {\n\tbuf->b_p_ro = FALSE;\n#ifdef FEAT_TITLE\n\tneed_maketitle = TRUE;\t    /* set window title later */\n#endif\n\tstatus_redraw_all();\t    /* redraw status lines later */\n    }\n\n    if (end > buf->b_ml.ml_line_count)\n\tend = buf->b_ml.ml_line_count;\n    if (buf->b_ml.ml_flags & ML_EMPTY)\n\tstart = end + 1;\n\n    /*\n     * If the original file is being overwritten, there is a small chance that\n     * we crash in the middle of writing. Therefore the file is preserved now.\n     * This makes all block numbers positive so that recovery does not need\n     * the original file.\n     * Don't do this if there is a backup file and we are exiting.\n     */\n    if (reset_changed && !newfile && overwriting\n\t\t\t\t\t      && !(exiting && backup != NULL))\n    {\n\tml_preserve(buf, FALSE);\n\tif (got_int)\n\t{\n\t    errmsg = (char_u *)_(e_interr);\n\t    goto restore_backup;\n\t}\n    }\n\n#ifdef VMS\n    vms_remove_version(fname); /* remove version */\n#endif\n    /* Default: write the file directly.  May write to a temp file for\n     * multi-byte conversion. */\n    wfname = fname;\n\n#ifdef FEAT_MBYTE\n    /* Check for forced 'fileencoding' from \"++opt=val\" argument. */\n    if (eap != NULL && eap->force_enc != 0)\n    {\n\tfenc = eap->cmd + eap->force_enc;\n\tfenc = enc_canonize(fenc);\n\tfenc_tofree = fenc;\n    }\n    else\n\tfenc = buf->b_p_fenc;\n\n    /*\n     * Check if the file needs to be converted.\n     */\n    converted = need_conversion(fenc);\n\n    /*\n     * Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or\n     * Latin1 to Unicode conversion.  This is handled in buf_write_bytes().\n     * Prepare the flags for it and allocate bw_conv_buf when needed.\n     */\n    if (converted && (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0))\n    {\n\twb_flags = get_fio_flags(fenc);\n\tif (wb_flags & (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8))\n\t{\n\t    /* Need to allocate a buffer to translate into. */\n\t    if (wb_flags & (FIO_UCS2 | FIO_UTF16 | FIO_UTF8))\n\t\twrite_info.bw_conv_buflen = bufsize * 2;\n\t    else /* FIO_UCS4 */\n\t\twrite_info.bw_conv_buflen = bufsize * 4;\n\t    write_info.bw_conv_buf\n\t\t\t   = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\t    if (write_info.bw_conv_buf == NULL)\n\t\tend = 0;\n\t}\n    }\n\n# ifdef WIN3264\n    if (converted && wb_flags == 0 && (wb_flags = get_win_fio_flags(fenc)) != 0)\n    {\n\t/* Convert UTF-8 -> UCS-2 and UCS-2 -> DBCS.  Worst-case * 4: */\n\twrite_info.bw_conv_buflen = bufsize * 4;\n\twrite_info.bw_conv_buf\n\t\t\t    = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\tif (write_info.bw_conv_buf == NULL)\n\t    end = 0;\n    }\n# endif\n\n# ifdef MACOS_CONVERT\n    if (converted && wb_flags == 0 && (wb_flags = get_mac_fio_flags(fenc)) != 0)\n    {\n\twrite_info.bw_conv_buflen = bufsize * 3;\n\twrite_info.bw_conv_buf\n\t\t\t    = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\tif (write_info.bw_conv_buf == NULL)\n\t    end = 0;\n    }\n# endif\n\n# if defined(FEAT_EVAL) || defined(USE_ICONV)\n    if (converted && wb_flags == 0)\n    {\n#  ifdef USE_ICONV\n\t/*\n\t * Use iconv() conversion when conversion is needed and it's not done\n\t * internally.\n\t */\n\twrite_info.bw_iconv_fd = (iconv_t)my_iconv_open(fenc,\n\t\t\t\t\tenc_utf8 ? (char_u *)\"utf-8\" : p_enc);\n\tif (write_info.bw_iconv_fd != (iconv_t)-1)\n\t{\n\t    /* We're going to use iconv(), allocate a buffer to convert in. */\n\t    write_info.bw_conv_buflen = bufsize * ICONV_MULT;\n\t    write_info.bw_conv_buf\n\t\t\t   = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\t    if (write_info.bw_conv_buf == NULL)\n\t\tend = 0;\n\t    write_info.bw_first = TRUE;\n\t}\n#   ifdef FEAT_EVAL\n\telse\n#   endif\n#  endif\n\n#  ifdef FEAT_EVAL\n\t    /*\n\t     * When the file needs to be converted with 'charconvert' after\n\t     * writing, write to a temp file instead and let the conversion\n\t     * overwrite the original file.\n\t     */\n\t    if (*p_ccv != NUL)\n\t    {\n\t\twfname = vim_tempname('w', FALSE);\n\t\tif (wfname == NULL)\t/* Can't write without a tempfile! */\n\t\t{\n\t\t    errmsg = (char_u *)_(\"E214: Can't find temp file for writing\");\n\t\t    goto restore_backup;\n\t\t}\n\t    }\n#  endif\n    }\n# endif\n    if (converted && wb_flags == 0\n#  ifdef USE_ICONV\n\t    && write_info.bw_iconv_fd == (iconv_t)-1\n#  endif\n#  ifdef FEAT_EVAL\n\t    && wfname == fname\n#  endif\n\t    )\n    {\n\tif (!forceit)\n\t{\n\t    errmsg = (char_u *)_(\"E213: Cannot convert (add ! to write without conversion)\");\n\t    goto restore_backup;\n\t}\n\tnotconverted = TRUE;\n    }\n#endif\n\n    /*\n     * If conversion is taking place, we may first pretend to write and check\n     * for conversion errors.  Then loop again to write for real.\n     * When not doing conversion this writes for real right away.\n     */\n    for (checking_conversion = TRUE; ; checking_conversion = FALSE)\n    {\n\t/*\n\t * There is no need to check conversion when:\n\t * - there is no conversion\n\t * - we make a backup file, that can be restored in case of conversion\n\t *   failure.\n\t */\n#ifdef FEAT_MBYTE\n\tif (!converted || dobackup)\n#endif\n\t    checking_conversion = FALSE;\n\n\tif (checking_conversion)\n\t{\n\t    /* Make sure we don't write anything. */\n\t    fd = -1;\n\t    write_info.bw_fd = fd;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Open the file \"wfname\" for writing.\n\t     * We may try to open the file twice: If we can't write to the file\n\t     * and forceit is TRUE we delete the existing file and try to\n\t     * create a new one. If this still fails we may have lost the\n\t     * original file!  (this may happen when the user reached his\n\t     * quotum for number of files).\n\t     * Appending will fail if the file does not exist and forceit is\n\t     * FALSE.\n\t     */\n\t    while ((fd = mch_open((char *)wfname, O_WRONLY | O_EXTRA | (append\n\t\t\t\t? (forceit ? (O_APPEND | O_CREAT) : O_APPEND)\n\t\t\t\t: (O_CREAT | O_TRUNC))\n\t\t\t\t, perm < 0 ? 0666 : (perm & 0777))) < 0)\n\t    {\n\t\t/*\n\t\t * A forced write will try to create a new file if the old one\n\t\t * is still readonly. This may also happen when the directory\n\t\t * is read-only. In that case the mch_remove() will fail.\n\t\t */\n\t\tif (errmsg == NULL)\n\t\t{\n#ifdef UNIX\n\t\t    stat_T\tst;\n\n\t\t    /* Don't delete the file when it's a hard or symbolic link.\n\t\t     */\n\t\t    if ((!newfile && st_old.st_nlink > 1)\n\t\t\t    || (mch_lstat((char *)fname, &st) == 0\n\t\t\t\t&& (st.st_dev != st_old.st_dev\n\t\t\t\t    || st.st_ino != st_old.st_ino)))\n\t\t\terrmsg = (char_u *)_(\"E166: Can't open linked file for writing\");\n\t\t    else\n#endif\n\t\t    {\n\t\t\terrmsg = (char_u *)_(\"E212: Can't open file for writing\");\n\t\t\tif (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL\n\t\t\t\t\t\t\t\t  && perm >= 0)\n\t\t\t{\n#ifdef UNIX\n\t\t\t    /* we write to the file, thus it should be marked\n\t\t\t       writable after all */\n\t\t\t    if (!(perm & 0200))\n\t\t\t\tmade_writable = TRUE;\n\t\t\t    perm |= 0200;\n\t\t\t    if (st_old.st_uid != getuid()\n\t\t\t\t\t\t  || st_old.st_gid != getgid())\n\t\t\t\tperm &= 0777;\n#endif\n\t\t\t    if (!append)  /* don't remove when appending */\n\t\t\t\tmch_remove(wfname);\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t}\n\nrestore_backup:\n\t\t{\n\t\t    stat_T\tst;\n\n\t\t    /*\n\t\t     * If we failed to open the file, we don't need a backup.\n\t\t     * Throw it away.  If we moved or removed the original file\n\t\t     * try to put the backup in its place.\n\t\t     */\n\t\t    if (backup != NULL && wfname == fname)\n\t\t    {\n\t\t\tif (backup_copy)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * There is a small chance that we removed the\n\t\t\t     * original, try to move the copy in its place.\n\t\t\t     * This may not work if the vim_rename() fails.\n\t\t\t     * In that case we leave the copy around.\n\t\t\t     */\n\t\t\t    /* If file does not exist, put the copy in its\n\t\t\t     * place */\n\t\t\t    if (mch_stat((char *)fname, &st) < 0)\n\t\t\t\tvim_rename(backup, fname);\n\t\t\t    /* if original file does exist throw away the copy\n\t\t\t     */\n\t\t\t    if (mch_stat((char *)fname, &st) >= 0)\n\t\t\t\tmch_remove(backup);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    /* try to put the original file back */\n\t\t\t    vim_rename(backup, fname);\n\t\t\t}\n\t\t    }\n\n\t\t    /* if original file no longer exists give an extra warning\n\t\t     */\n\t\t    if (!newfile && mch_stat((char *)fname, &st) < 0)\n\t\t\tend = 0;\n\t\t}\n\n#ifdef FEAT_MBYTE\n\t\tif (wfname != fname)\n\t\t    vim_free(wfname);\n#endif\n\t\tgoto fail;\n\t    }\n\t    write_info.bw_fd = fd;\n\n#if defined(WIN3264)\n\t    if (backup != NULL && overwriting && !append)\n\t    {\n\t\tif (backup_copy)\n\t\t    (void)mch_copy_file_attribute(wfname, backup);\n\t\telse\n\t\t    (void)mch_copy_file_attribute(backup, wfname);\n\t    }\n\n\t    if (!overwriting && !append)\n\t    {\n\t\tif (buf->b_ffname != NULL)\n\t\t    (void)mch_copy_file_attribute(buf->b_ffname, wfname);\n\t\t/* Should copy resource fork */\n\t    }\n#endif\n\n#ifdef FEAT_CRYPT\n\t    if (*buf->b_p_key != NUL && !filtering)\n\t    {\n\t\tchar_u\t\t*header;\n\t\tint\t\theader_len;\n\n\t\tbuf->b_cryptstate = crypt_create_for_writing(\n\t\t\t\t\t\t      crypt_get_method_nr(buf),\n\t\t\t\t\t   buf->b_p_key, &header, &header_len);\n\t\tif (buf->b_cryptstate == NULL || header == NULL)\n\t\t    end = 0;\n\t\telse\n\t\t{\n\t\t    /* Write magic number, so that Vim knows how this file is\n\t\t     * encrypted when reading it back. */\n\t\t    write_info.bw_buf = header;\n\t\t    write_info.bw_len = header_len;\n\t\t    write_info.bw_flags = FIO_NOCONVERT;\n\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t\tend = 0;\n\t\t    wb_flags |= FIO_ENCRYPTED;\n\t\t    vim_free(header);\n\t\t}\n\t    }\n#endif\n\t}\n\terrmsg = NULL;\n\n\twrite_info.bw_buf = buffer;\n\tnchars = 0;\n\n\t/* use \"++bin\", \"++nobin\" or 'binary' */\n\tif (eap != NULL && eap->force_bin != 0)\n\t    write_bin = (eap->force_bin == FORCE_BIN);\n\telse\n\t    write_bin = buf->b_p_bin;\n\n#ifdef FEAT_MBYTE\n\t/*\n\t * The BOM is written just after the encryption magic number.\n\t * Skip it when appending and the file already existed, the BOM only\n\t * makes sense at the start of the file.\n\t */\n\tif (buf->b_p_bomb && !write_bin && (!append || perm < 0))\n\t{\n\t    write_info.bw_len = make_bom(buffer, fenc);\n\t    if (write_info.bw_len > 0)\n\t    {\n\t\t/* don't convert, do encryption */\n\t\twrite_info.bw_flags = FIO_NOCONVERT | wb_flags;\n\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t    end = 0;\n\t\telse\n\t\t    nchars += write_info.bw_len;\n\t    }\n\t}\n\twrite_info.bw_start_lnum = start;\n#endif\n\n#ifdef FEAT_PERSISTENT_UNDO\n\twrite_undo_file = (buf->b_p_udf\n\t\t\t    && overwriting\n\t\t\t    && !append\n\t\t\t    && !filtering\n\t\t\t    && reset_changed\n\t\t\t    && !checking_conversion);\n\tif (write_undo_file)\n\t    /* Prepare for computing the hash value of the text. */\n\t    sha256_start(&sha_ctx);\n#endif\n\n\twrite_info.bw_len = bufsize;\n#ifdef HAS_BW_FLAGS\n\twrite_info.bw_flags = wb_flags;\n#endif\n\tfileformat = get_fileformat_force(buf, eap);\n\ts = buffer;\n\tlen = 0;\n\tfor (lnum = start; lnum <= end; ++lnum)\n\t{\n\t    /*\n\t     * The next while loop is done once for each character written.\n\t     * Keep it fast!\n\t     */\n\t    ptr = ml_get_buf(buf, lnum, FALSE) - 1;\n#ifdef FEAT_PERSISTENT_UNDO\n\t    if (write_undo_file)\n\t\tsha256_update(&sha_ctx, ptr + 1,\n\t\t\t\t\t      (UINT32_T)(STRLEN(ptr + 1) + 1));\n#endif\n\t    while ((c = *++ptr) != NUL)\n\t    {\n\t\tif (c == NL)\n\t\t    *s = NUL;\t\t/* replace newlines with NULs */\n\t\telse if (c == CAR && fileformat == EOL_MAC)\n\t\t    *s = NL;\t\t/* Mac: replace CRs with NLs */\n\t\telse\n\t\t    *s = c;\n\t\t++s;\n\t\tif (++len != bufsize)\n\t\t    continue;\n\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t{\n\t\t    end = 0;\t\t/* write error: break loop */\n\t\t    break;\n\t\t}\n\t\tnchars += bufsize;\n\t\ts = buffer;\n\t\tlen = 0;\n#ifdef FEAT_MBYTE\n\t\twrite_info.bw_start_lnum = lnum;\n#endif\n\t    }\n\t    /* write failed or last line has no EOL: stop here */\n\t    if (end == 0\n\t\t    || (lnum == end\n\t\t\t&& (write_bin || !buf->b_p_fixeol)\n\t\t\t&& (lnum == buf->b_no_eol_lnum\n\t\t\t    || (lnum == buf->b_ml.ml_line_count\n\t\t\t\t\t\t\t   && !buf->b_p_eol))))\n\t    {\n\t\t++lnum;\t\t\t/* written the line, count it */\n\t\tno_eol = TRUE;\n\t\tbreak;\n\t    }\n\t    if (fileformat == EOL_UNIX)\n\t\t*s++ = NL;\n\t    else\n\t    {\n\t\t*s++ = CAR;\t\t    /* EOL_MAC or EOL_DOS: write CR */\n\t\tif (fileformat == EOL_DOS)  /* write CR-NL */\n\t\t{\n\t\t    if (++len == bufsize)\n\t\t    {\n\t\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t\t{\n\t\t\t    end = 0;\t/* write error: break loop */\n\t\t\t    break;\n\t\t\t}\n\t\t\tnchars += bufsize;\n\t\t\ts = buffer;\n\t\t\tlen = 0;\n\t\t    }\n\t\t    *s++ = NL;\n\t\t}\n\t    }\n\t    if (++len == bufsize && end)\n\t    {\n\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t{\n\t\t    end = 0;\t\t/* write error: break loop */\n\t\t    break;\n\t\t}\n\t\tnchars += bufsize;\n\t\ts = buffer;\n\t\tlen = 0;\n\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t{\n\t\t    end = 0;\t\t/* Interrupted, break loop */\n\t\t    break;\n\t\t}\n\t    }\n#ifdef VMS\n\t    /*\n\t     * On VMS there is a problem: newlines get added when writing\n\t     * blocks at a time. Fix it by writing a line at a time.\n\t     * This is much slower!\n\t     * Explanation: VAX/DECC RTL insists that records in some RMS\n\t     * structures end with a newline (carriage return) character, and\n\t     * if they don't it adds one.\n\t     * With other RMS structures it works perfect without this fix.\n\t     */\n\t    if (buf->b_fab_rfm == FAB$C_VFC\n\t\t    || ((buf->b_fab_rat & (FAB$M_FTN | FAB$M_CR)) != 0))\n\t    {\n\t\tint b2write;\n\n\t\tbuf->b_fab_mrs = (buf->b_fab_mrs == 0\n\t\t\t? MIN(4096, bufsize)\n\t\t\t: MIN(buf->b_fab_mrs, bufsize));\n\n\t\tb2write = len;\n\t\twhile (b2write > 0)\n\t\t{\n\t\t    write_info.bw_len = MIN(b2write, buf->b_fab_mrs);\n\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t    {\n\t\t\tend = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    b2write -= MIN(b2write, buf->b_fab_mrs);\n\t\t}\n\t\twrite_info.bw_len = bufsize;\n\t\tnchars += len;\n\t\ts = buffer;\n\t\tlen = 0;\n\t    }\n#endif\n\t}\n\tif (len > 0 && end > 0)\n\t{\n\t    write_info.bw_len = len;\n\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\tend = 0;\t\t    /* write error */\n\t    nchars += len;\n\t}\n\n\t/* Stop when writing done or an error was encountered. */\n\tif (!checking_conversion || end == 0)\n\t    break;\n\n\t/* If no error happened until now, writing should be ok, so loop to\n\t * really write the buffer. */\n    }\n\n    /* If we started writing, finish writing. Also when an error was\n     * encountered. */\n    if (!checking_conversion)\n    {\n#if defined(UNIX) && defined(HAVE_FSYNC)\n\t/*\n\t * On many journalling file systems there is a bug that causes both the\n\t * original and the backup file to be lost when halting the system\n\t * right after writing the file.  That's because only the meta-data is\n\t * journalled.  Syncing the file slows down the system, but assures it\n\t * has been written to disk and we don't lose it.\n\t * For a device do try the fsync() but don't complain if it does not\n\t * work (could be a pipe).\n\t * If the 'fsync' option is FALSE, don't fsync().  Useful for laptops.\n\t */\n\tif (p_fs && fsync(fd) != 0 && !device)\n\t{\n\t    errmsg = (char_u *)_(\"E667: Fsync failed\");\n\t    end = 0;\n\t}\n#endif\n\n#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n\t/* Probably need to set the security context. */\n\tif (!backup_copy)\n\t    mch_copy_sec(backup, wfname);\n#endif\n\n#ifdef UNIX\n\t/* When creating a new file, set its owner/group to that of the\n\t * original file.  Get the new device and inode number. */\n\tif (backup != NULL && !backup_copy)\n\t{\n# ifdef HAVE_FCHOWN\n\t    stat_T\tst;\n\n\t    /* don't change the owner when it's already OK, some systems remove\n\t     * permission or ACL stuff */\n\t    if (mch_stat((char *)wfname, &st) < 0\n\t\t    || st.st_uid != st_old.st_uid\n\t\t    || st.st_gid != st_old.st_gid)\n\t    {\n\t\tignored = fchown(fd, st_old.st_uid, st_old.st_gid);\n\t\tif (perm >= 0)\t/* set permission again, may have changed */\n\t\t    (void)mch_setperm(wfname, perm);\n\t    }\n# endif\n\t    buf_setino(buf);\n\t}\n\telse if (!buf->b_dev_valid)\n\t    /* Set the inode when creating a new file. */\n\t    buf_setino(buf);\n#endif\n\n\tif (close(fd) != 0)\n\t{\n\t    errmsg = (char_u *)_(\"E512: Close failed\");\n\t    end = 0;\n\t}\n\n#ifdef UNIX\n\tif (made_writable)\n\t    perm &= ~0200;\t/* reset 'w' bit for security reasons */\n#endif\n\tif (perm >= 0)\t\t/* set perm. of new file same as old file */\n\t    (void)mch_setperm(wfname, perm);\n#ifdef HAVE_ACL\n\t/*\n\t * Probably need to set the ACL before changing the user (can't set the\n\t * ACL on a file the user doesn't own).\n\t * On Solaris, with ZFS and the aclmode property set to \"discard\" (the\n\t * default), chmod() discards all part of a file's ACL that don't\n\t * represent the mode of the file.  It's non-trivial for us to discover\n\t * whether we're in that situation, so we simply always re-set the ACL.\n\t */\n# ifndef HAVE_SOLARIS_ZFS_ACL\n\tif (!backup_copy)\n# endif\n\t    mch_set_acl(wfname, acl);\n#endif\n#ifdef FEAT_CRYPT\n\tif (buf->b_cryptstate != NULL)\n\t{\n\t    crypt_free_state(buf->b_cryptstate);\n\t    buf->b_cryptstate = NULL;\n\t}\n#endif\n\n#if defined(FEAT_MBYTE) && defined(FEAT_EVAL)\n\tif (wfname != fname)\n\t{\n\t    /*\n\t     * The file was written to a temp file, now it needs to be\n\t     * converted with 'charconvert' to (overwrite) the output file.\n\t     */\n\t    if (end != 0)\n\t    {\n\t\tif (eval_charconvert(enc_utf8 ? (char_u *)\"utf-8\" : p_enc,\n\t\t\t\t\t\t  fenc, wfname, fname) == FAIL)\n\t\t{\n\t\t    write_info.bw_conv_error = TRUE;\n\t\t    end = 0;\n\t\t}\n\t    }\n\t    mch_remove(wfname);\n\t    vim_free(wfname);\n\t}\n#endif\n    }\n\n    if (end == 0)\n    {\n\t/*\n\t * Error encountered.\n\t */\n\tif (errmsg == NULL)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (write_info.bw_conv_error)\n\t    {\n\t\tif (write_info.bw_conv_error_lnum == 0)\n\t\t    errmsg = (char_u *)_(\"E513: write error, conversion failed (make 'fenc' empty to override)\");\n\t\telse\n\t\t{\n\t\t    errmsg_allocated = TRUE;\n\t\t    errmsg = alloc(300);\n\t\t    vim_snprintf((char *)errmsg, 300, _(\"E513: write error, conversion failed in line %ld (make 'fenc' empty to override)\"),\n\t\t\t\t\t (long)write_info.bw_conv_error_lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tif (got_int)\n\t\t    errmsg = (char_u *)_(e_interr);\n\t\telse\n\t\t    errmsg = (char_u *)_(\"E514: write error (file system full?)\");\n\t}\n\n\t/*\n\t * If we have a backup file, try to put it in place of the new file,\n\t * because the new file is probably corrupt.  This avoids losing the\n\t * original file when trying to make a backup when writing the file a\n\t * second time.\n\t * When \"backup_copy\" is set we need to copy the backup over the new\n\t * file.  Otherwise rename the backup file.\n\t * If this is OK, don't give the extra warning message.\n\t */\n\tif (backup != NULL)\n\t{\n\t    if (backup_copy)\n\t    {\n\t\t/* This may take a while, if we were interrupted let the user\n\t\t * know we got the message. */\n\t\tif (got_int)\n\t\t{\n\t\t    MSG(_(e_interr));\n\t\t    out_flush();\n\t\t}\n\t\tif ((fd = mch_open((char *)backup, O_RDONLY | O_EXTRA, 0)) >= 0)\n\t\t{\n\t\t    if ((write_info.bw_fd = mch_open((char *)fname,\n\t\t\t\t    O_WRONLY | O_CREAT | O_TRUNC | O_EXTRA,\n\t\t\t\t\t\t\t   perm & 0777)) >= 0)\n\t\t    {\n\t\t\t/* copy the file. */\n\t\t\twrite_info.bw_buf = smallbuf;\n#ifdef HAS_BW_FLAGS\n\t\t\twrite_info.bw_flags = FIO_NOCONVERT;\n#endif\n\t\t\twhile ((write_info.bw_len = read_eintr(fd, smallbuf,\n\t\t\t\t\t\t      SMBUFSIZE)) > 0)\n\t\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t\t\tbreak;\n\n\t\t\tif (close(write_info.bw_fd) >= 0\n\t\t\t\t\t\t   && write_info.bw_len == 0)\n\t\t\t    end = 1;\t\t/* success */\n\t\t    }\n\t\t    close(fd);\t/* ignore errors for closing read file */\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (vim_rename(backup, fname) == 0)\n\t\t    end = 1;\n\t    }\n\t}\n\tgoto fail;\n    }\n\n    lnum -= start;\t    /* compute number of written lines */\n    --no_wait_return;\t    /* may wait for return now */\n\n#if !(defined(UNIX) || defined(VMS))\n    fname = sfname;\t    /* use shortname now, for the messages */\n#endif\n    if (!filtering)\n    {\n\tmsg_add_fname(buf, fname);\t/* put fname in IObuff with quotes */\n\tc = FALSE;\n#ifdef FEAT_MBYTE\n\tif (write_info.bw_conv_error)\n\t{\n\t    STRCAT(IObuff, _(\" CONVERSION ERROR\"));\n\t    c = TRUE;\n\t    if (write_info.bw_conv_error_lnum != 0)\n\t\tvim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %ld;\"),\n\t\t\t(long)write_info.bw_conv_error_lnum);\n\t}\n\telse if (notconverted)\n\t{\n\t    STRCAT(IObuff, _(\"[NOT converted]\"));\n\t    c = TRUE;\n\t}\n\telse if (converted)\n\t{\n\t    STRCAT(IObuff, _(\"[converted]\"));\n\t    c = TRUE;\n\t}\n#endif\n\tif (device)\n\t{\n\t    STRCAT(IObuff, _(\"[Device]\"));\n\t    c = TRUE;\n\t}\n\telse if (newfile)\n\t{\n\t    STRCAT(IObuff, shortmess(SHM_NEW) ? _(\"[New]\") : _(\"[New File]\"));\n\t    c = TRUE;\n\t}\n\tif (no_eol)\n\t{\n\t    msg_add_eol();\n\t    c = TRUE;\n\t}\n\t/* may add [unix/dos/mac] */\n\tif (msg_add_fileformat(fileformat))\n\t    c = TRUE;\n#ifdef FEAT_CRYPT\n\tif (wb_flags & FIO_ENCRYPTED)\n\t{\n\t    crypt_append_msg(buf);\n\t    c = TRUE;\n\t}\n#endif\n\tmsg_add_lines(c, (long)lnum, nchars);\t/* add line/char count */\n\tif (!shortmess(SHM_WRITE))\n\t{\n\t    if (append)\n\t\tSTRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));\n\t    else\n\t\tSTRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [w]\") : _(\" written\"));\n\t}\n\n\tset_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);\n    }\n\n    /* When written everything correctly: reset 'modified'.  Unless not\n     * writing to the original file and '+' is not in 'cpoptions'. */\n    if (reset_changed && whole && !append\n#ifdef FEAT_MBYTE\n\t    && !write_info.bw_conv_error\n#endif\n\t    && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)\n\t    )\n    {\n\tunchanged(buf, TRUE);\n#ifdef FEAT_AUTOCMD\n\t/* b:changedtick is always incremented in unchanged() but that\n\t * should not trigger a TextChanged event. */\n\tif (last_changedtick + 1 == CHANGEDTICK(buf)\n\t\t\t\t\t       && last_changedtick_buf == buf)\n\t    last_changedtick = CHANGEDTICK(buf);\n#endif\n\tu_unchanged(buf);\n\tu_update_save_nr(buf);\n    }\n\n    /*\n     * If written to the current file, update the timestamp of the swap file\n     * and reset the BF_WRITE_MASK flags. Also sets buf->b_mtime.\n     */\n    if (overwriting)\n    {\n\tml_timestamp(buf);\n\tif (append)\n\t    buf->b_flags &= ~BF_NEW;\n\telse\n\t    buf->b_flags &= ~BF_WRITE_MASK;\n    }\n\n    /*\n     * If we kept a backup until now, and we are in patch mode, then we make\n     * the backup file our 'original' file.\n     */\n    if (*p_pm && dobackup)\n    {\n\tchar *org = (char *)buf_modname((buf->b_p_sn || buf->b_shortname),\n\t\t\t\t\t\t\t  fname, p_pm, FALSE);\n\n\tif (backup != NULL)\n\t{\n\t    stat_T\tst;\n\n\t    /*\n\t     * If the original file does not exist yet\n\t     * the current backup file becomes the original file\n\t     */\n\t    if (org == NULL)\n\t\tEMSG(_(\"E205: Patchmode: can't save original file\"));\n\t    else if (mch_stat(org, &st) < 0)\n\t    {\n\t\tvim_rename(backup, (char_u *)org);\n\t\tvim_free(backup);\t    /* don't delete the file */\n\t\tbackup = NULL;\n#ifdef UNIX\n\t\tset_file_time((char_u *)org, st_old.st_atime, st_old.st_mtime);\n#endif\n\t    }\n\t}\n\t/*\n\t * If there is no backup file, remember that a (new) file was\n\t * created.\n\t */\n\telse\n\t{\n\t    int empty_fd;\n\n\t    if (org == NULL\n\t\t    || (empty_fd = mch_open(org,\n\t\t\t\t      O_CREAT | O_EXTRA | O_EXCL | O_NOFOLLOW,\n\t\t\t\t\tperm < 0 ? 0666 : (perm & 0777))) < 0)\n\t      EMSG(_(\"E206: patchmode: can't touch empty original file\"));\n\t    else\n\t      close(empty_fd);\n\t}\n\tif (org != NULL)\n\t{\n\t    mch_setperm((char_u *)org, mch_getperm(fname) & 0777);\n\t    vim_free(org);\n\t}\n    }\n\n    /*\n     * Remove the backup unless 'backup' option is set\n     */\n    if (!p_bk && backup != NULL && mch_remove(backup) != 0)\n\tEMSG(_(\"E207: Can't delete backup file\"));\n\n#ifdef FEAT_SUN_WORKSHOP\n    if (usingSunWorkShop)\n\tworkshop_file_saved((char *) ffname);\n#endif\n\n    goto nofail;\n\n    /*\n     * Finish up.  We get here either after failure or success.\n     */\nfail:\n    --no_wait_return;\t\t/* may wait for return now */\nnofail:\n\n    /* Done saving, we accept changed buffer warnings again */\n    buf->b_saving = FALSE;\n\n    vim_free(backup);\n    if (buffer != smallbuf)\n\tvim_free(buffer);\n#ifdef FEAT_MBYTE\n    vim_free(fenc_tofree);\n    vim_free(write_info.bw_conv_buf);\n# ifdef USE_ICONV\n    if (write_info.bw_iconv_fd != (iconv_t)-1)\n    {\n\ticonv_close(write_info.bw_iconv_fd);\n\twrite_info.bw_iconv_fd = (iconv_t)-1;\n    }\n# endif\n#endif\n#ifdef HAVE_ACL\n    mch_free_acl(acl);\n#endif\n\n    if (errmsg != NULL)\n    {\n\tint numlen = errnum != NULL ? (int)STRLEN(errnum) : 0;\n\n\tattr = HL_ATTR(HLF_E);\t/* set highlight for error messages */\n\tmsg_add_fname(buf,\n#ifndef UNIX\n\t\tsfname\n#else\n\t\tfname\n#endif\n\t\t     );\t\t/* put file name in IObuff with quotes */\n\tif (STRLEN(IObuff) + STRLEN(errmsg) + numlen >= IOSIZE)\n\t    IObuff[IOSIZE - STRLEN(errmsg) - numlen - 1] = NUL;\n\t/* If the error message has the form \"is ...\", put the error number in\n\t * front of the file name. */\n\tif (errnum != NULL)\n\t{\n\t    STRMOVE(IObuff + numlen, IObuff);\n\t    mch_memmove(IObuff, errnum, (size_t)numlen);\n\t}\n\tSTRCAT(IObuff, errmsg);\n\temsg(IObuff);\n\tif (errmsg_allocated)\n\t    vim_free(errmsg);\n\n\tretval = FAIL;\n\tif (end == 0)\n\t{\n\t    MSG_PUTS_ATTR(_(\"\\nWARNING: Original file may be lost or damaged\\n\"),\n\t\t    attr | MSG_HIST);\n\t    MSG_PUTS_ATTR(_(\"don't quit the editor until the file is successfully written!\"),\n\t\t    attr | MSG_HIST);\n\n\t    /* Update the timestamp to avoid an \"overwrite changed file\"\n\t     * prompt when writing again. */\n\t    if (mch_stat((char *)fname, &st_old) >= 0)\n\t    {\n\t\tbuf_store_time(buf, &st_old, fname);\n\t\tbuf->b_mtime_read = buf->b_mtime;\n\t    }\n\t}\n    }\n    msg_scroll = msg_save;\n\n#ifdef FEAT_PERSISTENT_UNDO\n    /*\n     * When writing the whole file and 'undofile' is set, also write the undo\n     * file.\n     */\n    if (retval == OK && write_undo_file)\n    {\n\tchar_u\t    hash[UNDO_HASH_SIZE];\n\n\tsha256_finish(&sha_ctx, hash);\n\tu_write_undo(NULL, FALSE, buf, hash);\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n#ifdef FEAT_EVAL\n    if (!should_abort(retval))\n#else\n    if (!got_int)\n#endif\n    {\n\taco_save_T\taco;\n\n\tcurbuf->b_no_eol_lnum = 0;  /* in case it was set by the previous read */\n\n\t/*\n\t * Apply POST autocommands.\n\t * Careful: The autocommands may call buf_write() recursively!\n\t */\n\taucmd_prepbuf(&aco, buf);\n\n\tif (append)\n\t    apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (filtering)\n\t    apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (reset_changed && whole)\n\t    apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse\n\t    apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\n#ifdef FEAT_EVAL\n\tif (aborting())\t    /* autocmds may abort script processing */\n\t    retval = FALSE;\n#endif\n    }\n#endif\n\n    got_int |= prev_got_int;\n\n    return retval;\n}\n\n/*\n * Set the name of the current buffer.  Use when the buffer doesn't have a\n * name and a \":r\" or \":w\" command with a file name is used.\n */\n    static int\nset_rw_fname(char_u *fname, char_u *sfname)\n{\n#ifdef FEAT_AUTOCMD\n    buf_T\t*buf = curbuf;\n\n    /* It's like the unnamed buffer is deleted.... */\n    if (curbuf->b_p_bl)\n\tapply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);\n# ifdef FEAT_EVAL\n    if (aborting())\t    /* autocmds may abort script processing */\n\treturn FAIL;\n# endif\n    if (curbuf != buf)\n    {\n\t/* We are in another buffer now, don't do the renaming. */\n\tEMSG(_(e_auchangedbuf));\n\treturn FAIL;\n    }\n#endif\n\n    if (setfname(curbuf, fname, sfname, FALSE) == OK)\n\tcurbuf->b_flags |= BF_NOTEDITED;\n\n#ifdef FEAT_AUTOCMD\n    /* ....and a new named one is created */\n    apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);\n    if (curbuf->b_p_bl)\n\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n# ifdef FEAT_EVAL\n    if (aborting())\t    /* autocmds may abort script processing */\n\treturn FAIL;\n# endif\n\n    /* Do filetype detection now if 'filetype' is empty. */\n    if (*curbuf->b_p_ft == NUL)\n    {\n\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", FALSE, NULL);\n\tdo_modelines(0);\n    }\n#endif\n\n    return OK;\n}\n\n/*\n * Put file name into IObuff with quotes.\n */\n    void\nmsg_add_fname(buf_T *buf, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)\"-stdin-\";\n    home_replace(buf, fname, IObuff + 1, IOSIZE - 4, TRUE);\n    IObuff[0] = '\"';\n    STRCAT(IObuff, \"\\\" \");\n}\n\n/*\n * Append message for text mode to IObuff.\n * Return TRUE if something appended.\n */\n    static int\nmsg_add_fileformat(int eol_type)\n{\n#ifndef USE_CRNL\n    if (eol_type == EOL_DOS)\n    {\n\tSTRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[dos]\") : _(\"[dos format]\"));\n\treturn TRUE;\n    }\n#endif\n#ifndef USE_CR\n    if (eol_type == EOL_MAC)\n    {\n\tSTRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[mac]\") : _(\"[mac format]\"));\n\treturn TRUE;\n    }\n#endif\n#if defined(USE_CRNL) || defined(USE_CR)\n    if (eol_type == EOL_UNIX)\n    {\n\tSTRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[unix]\") : _(\"[unix format]\"));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\n/*\n * Append line and character count to IObuff.\n */\n    void\nmsg_add_lines(\n    int\t    insert_space,\n    long    lnum,\n    off_T   nchars)\n{\n    char_u  *p;\n\n    p = IObuff + STRLEN(IObuff);\n\n    if (insert_space)\n\t*p++ = ' ';\n    if (shortmess(SHM_LINES))\n\tvim_snprintf((char *)p, IOSIZE - (p - IObuff),\n\t\t\"%ldL, %lldC\", lnum, (varnumber_T)nchars);\n    else\n    {\n\tif (lnum == 1)\n\t    STRCPY(p, _(\"1 line, \"));\n\telse\n\t    sprintf((char *)p, _(\"%ld lines, \"), lnum);\n\tp += STRLEN(p);\n\tif (nchars == 1)\n\t    STRCPY(p, _(\"1 character\"));\n\telse\n\t    vim_snprintf((char *)p, IOSIZE - (p - IObuff),\n\t\t    _(\"%lld characters\"), (varnumber_T)nchars);\n    }\n}\n\n/*\n * Append message for missing line separator to IObuff.\n */\n    static void\nmsg_add_eol(void)\n{\n    STRCAT(IObuff, shortmess(SHM_LAST) ? _(\"[noeol]\") : _(\"[Incomplete last line]\"));\n}\n\n/*\n * Check modification time of file, before writing to it.\n * The size isn't checked, because using a tool like \"gzip\" takes care of\n * using the same timestamp but can't set the size.\n */\n    static int\ncheck_mtime(buf_T *buf, stat_T *st)\n{\n    if (buf->b_mtime_read != 0\n\t    && time_differs((long)st->st_mtime, buf->b_mtime_read))\n    {\n\tmsg_scroll = TRUE;\t    /* don't overwrite messages here */\n\tmsg_silent = 0;\t\t    /* must give this prompt */\n\t/* don't use emsg() here, don't want to flush the buffers */\n\tMSG_ATTR(_(\"WARNING: The file has been changed since reading it!!!\"),\n\t\t\t\t\t\t       HL_ATTR(HLF_E));\n\tif (ask_yesno((char_u *)_(\"Do you really want to write to it\"),\n\t\t\t\t\t\t\t\t TRUE) == 'n')\n\t    return FAIL;\n\tmsg_scroll = FALSE;\t    /* always overwrite the file message now */\n    }\n    return OK;\n}\n\n    static int\ntime_differs(long t1, long t2)\n{\n#if defined(__linux__) || defined(MSWIN)\n    /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store\n     * the seconds.  Since the roundoff is done when flushing the inode, the\n     * time may change unexpectedly by one second!!! */\n    return (t1 - t2 > 1 || t2 - t1 > 1);\n#else\n    return (t1 != t2);\n#endif\n}\n\n/*\n * Call write() to write a number of bytes to the file.\n * Handles encryption and 'encoding' conversion.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\nbuf_write_bytes(struct bw_info *ip)\n{\n    int\t\twlen;\n    char_u\t*buf = ip->bw_buf;\t/* data to write */\n    int\t\tlen = ip->bw_len;\t/* length of data */\n#ifdef HAS_BW_FLAGS\n    int\t\tflags = ip->bw_flags;\t/* extra flags */\n#endif\n\n#ifdef FEAT_MBYTE\n    /*\n     * Skip conversion when writing the crypt magic number or the BOM.\n     */\n    if (!(flags & FIO_NOCONVERT))\n    {\n\tchar_u\t\t*p;\n\tunsigned\tc;\n\tint\t\tn;\n\n\tif (flags & FIO_UTF8)\n\t{\n\t    /*\n\t     * Convert latin1 in the buffer to UTF-8 in the file.\n\t     */\n\t    p = ip->bw_conv_buf;\t/* translate to buffer */\n\t    for (wlen = 0; wlen < len; ++wlen)\n\t\tp += utf_char2bytes(buf[wlen], p);\n\t    buf = ip->bw_conv_buf;\n\t    len = (int)(p - ip->bw_conv_buf);\n\t}\n\telse if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1))\n\t{\n\t    /*\n\t     * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or\n\t     * Latin1 chars in the file.\n\t     */\n\t    if (flags & FIO_LATIN1)\n\t\tp = buf;\t/* translate in-place (can only get shorter) */\n\t    else\n\t\tp = ip->bw_conv_buf;\t/* translate to buffer */\n\t    for (wlen = 0; wlen < len; wlen += n)\n\t    {\n\t\tif (wlen == 0 && ip->bw_restlen != 0)\n\t\t{\n\t\t    int\t\tl;\n\n\t\t    /* Use remainder of previous call.  Append the start of\n\t\t     * buf[] to get a full sequence.  Might still be too\n\t\t     * short! */\n\t\t    l = CONV_RESTLEN - ip->bw_restlen;\n\t\t    if (l > len)\n\t\t\tl = len;\n\t\t    mch_memmove(ip->bw_rest + ip->bw_restlen, buf, (size_t)l);\n\t\t    n = utf_ptr2len_len(ip->bw_rest, ip->bw_restlen + l);\n\t\t    if (n > ip->bw_restlen + len)\n\t\t    {\n\t\t\t/* We have an incomplete byte sequence at the end to\n\t\t\t * be written.  We can't convert it without the\n\t\t\t * remaining bytes.  Keep them for the next call. */\n\t\t\tif (ip->bw_restlen + len > CONV_RESTLEN)\n\t\t\t    return FAIL;\n\t\t\tip->bw_restlen += len;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (n > 1)\n\t\t\tc = utf_ptr2char(ip->bw_rest);\n\t\t    else\n\t\t\tc = ip->bw_rest[0];\n\t\t    if (n >= ip->bw_restlen)\n\t\t    {\n\t\t\tn -= ip->bw_restlen;\n\t\t\tip->bw_restlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tip->bw_restlen -= n;\n\t\t\tmch_memmove(ip->bw_rest, ip->bw_rest + n,\n\t\t\t\t\t\t      (size_t)ip->bw_restlen);\n\t\t\tn = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    n = utf_ptr2len_len(buf + wlen, len - wlen);\n\t\t    if (n > len - wlen)\n\t\t    {\n\t\t\t/* We have an incomplete byte sequence at the end to\n\t\t\t * be written.  We can't convert it without the\n\t\t\t * remaining bytes.  Keep them for the next call. */\n\t\t\tif (len - wlen > CONV_RESTLEN)\n\t\t\t    return FAIL;\n\t\t\tip->bw_restlen = len - wlen;\n\t\t\tmch_memmove(ip->bw_rest, buf + wlen,\n\t\t\t\t\t\t      (size_t)ip->bw_restlen);\n\t\t\tbreak;\n\t\t    }\n\t\t    if (n > 1)\n\t\t\tc = utf_ptr2char(buf + wlen);\n\t\t    else\n\t\t\tc = buf[wlen];\n\t\t}\n\n\t\tif (ucs2bytes(c, &p, flags) && !ip->bw_conv_error)\n\t\t{\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    ip->bw_conv_error_lnum = ip->bw_start_lnum;\n\t\t}\n\t\tif (c == NL)\n\t\t    ++ip->bw_start_lnum;\n\t    }\n\t    if (flags & FIO_LATIN1)\n\t\tlen = (int)(p - buf);\n\t    else\n\t    {\n\t\tbuf = ip->bw_conv_buf;\n\t\tlen = (int)(p - ip->bw_conv_buf);\n\t    }\n\t}\n\n# ifdef WIN3264\n\telse if (flags & FIO_CODEPAGE)\n\t{\n\t    /*\n\t     * Convert UTF-8 or codepage to UCS-2 and then to MS-Windows\n\t     * codepage.\n\t     */\n\t    char_u\t*from;\n\t    size_t\tfromlen;\n\t    char_u\t*to;\n\t    int\t\tu8c;\n\t    BOOL\tbad = FALSE;\n\t    int\t\tneeded;\n\n\t    if (ip->bw_restlen > 0)\n\t    {\n\t\t/* Need to concatenate the remainder of the previous call and\n\t\t * the bytes of the current call.  Use the end of the\n\t\t * conversion buffer for this. */\n\t\tfromlen = len + ip->bw_restlen;\n\t\tfrom = ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n\t\tmch_memmove(from, ip->bw_rest, (size_t)ip->bw_restlen);\n\t\tmch_memmove(from + ip->bw_restlen, buf, (size_t)len);\n\t    }\n\t    else\n\t    {\n\t\tfrom = buf;\n\t\tfromlen = len;\n\t    }\n\n\t    to = ip->bw_conv_buf;\n\t    if (enc_utf8)\n\t    {\n\t\t/* Convert from UTF-8 to UCS-2, to the start of the buffer.\n\t\t * The buffer has been allocated to be big enough. */\n\t\twhile (fromlen > 0)\n\t\t{\n\t\t    n = (int)utf_ptr2len_len(from, (int)fromlen);\n\t\t    if (n > (int)fromlen)\t/* incomplete byte sequence */\n\t\t\tbreak;\n\t\t    u8c = utf_ptr2char(from);\n\t\t    *to++ = (u8c & 0xff);\n\t\t    *to++ = (u8c >> 8);\n\t\t    fromlen -= n;\n\t\t    from += n;\n\t\t}\n\n\t\t/* Copy remainder to ip->bw_rest[] to be used for the next\n\t\t * call. */\n\t\tif (fromlen > CONV_RESTLEN)\n\t\t{\n\t\t    /* weird overlong sequence */\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t\tmch_memmove(ip->bw_rest, from, fromlen);\n\t\tip->bw_restlen = (int)fromlen;\n\t    }\n\t    else\n\t    {\n\t\t/* Convert from enc_codepage to UCS-2, to the start of the\n\t\t * buffer.  The buffer has been allocated to be big enough. */\n\t\tip->bw_restlen = 0;\n\t\tneeded = MultiByteToWideChar(enc_codepage,\n\t\t\t     MB_ERR_INVALID_CHARS, (LPCSTR)from, (int)fromlen,\n\t\t\t\t\t\t\t\t     NULL, 0);\n\t\tif (needed == 0)\n\t\t{\n\t\t    /* When conversion fails there may be a trailing byte. */\n\t\t    needed = MultiByteToWideChar(enc_codepage,\n\t\t\t MB_ERR_INVALID_CHARS, (LPCSTR)from, (int)fromlen - 1,\n\t\t\t\t\t\t\t\t     NULL, 0);\n\t\t    if (needed == 0)\n\t\t    {\n\t\t\t/* Conversion doesn't work. */\n\t\t\tip->bw_conv_error = TRUE;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    /* Save the trailing byte for the next call. */\n\t\t    ip->bw_rest[0] = from[fromlen - 1];\n\t\t    ip->bw_restlen = 1;\n\t\t}\n\t\tneeded = MultiByteToWideChar(enc_codepage, MB_ERR_INVALID_CHARS,\n\t\t\t\t(LPCSTR)from, (int)(fromlen - ip->bw_restlen),\n\t\t\t\t\t\t\t  (LPWSTR)to, needed);\n\t\tif (needed == 0)\n\t\t{\n\t\t    /* Safety check: Conversion doesn't work. */\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t\tto += needed * 2;\n\t    }\n\n\t    fromlen = to - ip->bw_conv_buf;\n\t    buf = to;\n#  ifdef CP_UTF8\t/* VC 4.1 doesn't define CP_UTF8 */\n\t    if (FIO_GET_CP(flags) == CP_UTF8)\n\t    {\n\t\t/* Convert from UCS-2 to UTF-8, using the remainder of the\n\t\t * conversion buffer.  Fails when out of space. */\n\t\tfor (from = ip->bw_conv_buf; fromlen > 1; fromlen -= 2)\n\t\t{\n\t\t    u8c = *from++;\n\t\t    u8c += (*from++ << 8);\n\t\t    to += utf_char2bytes(u8c, to);\n\t\t    if (to + 6 >= ip->bw_conv_buf + ip->bw_conv_buflen)\n\t\t    {\n\t\t\tip->bw_conv_error = TRUE;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t\tlen = (int)(to - buf);\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/* Convert from UCS-2 to the codepage, using the remainder of\n\t\t * the conversion buffer.  If the conversion uses the default\n\t\t * character \"0\", the data doesn't fit in this encoding, so\n\t\t * fail. */\n\t\tlen = WideCharToMultiByte(FIO_GET_CP(flags), 0,\n\t\t\t(LPCWSTR)ip->bw_conv_buf, (int)fromlen / sizeof(WCHAR),\n\t\t\t(LPSTR)to, (int)(ip->bw_conv_buflen - fromlen), 0,\n\t\t\t\t\t\t\t\t\t&bad);\n\t\tif (bad)\n\t\t{\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n# endif\n\n# ifdef MACOS_CONVERT\n\telse if (flags & FIO_MACROMAN)\n\t{\n\t    /*\n\t     * Convert UTF-8 or latin1 to Apple MacRoman.\n\t     */\n\t    char_u\t*from;\n\t    size_t\tfromlen;\n\n\t    if (ip->bw_restlen > 0)\n\t    {\n\t\t/* Need to concatenate the remainder of the previous call and\n\t\t * the bytes of the current call.  Use the end of the\n\t\t * conversion buffer for this. */\n\t\tfromlen = len + ip->bw_restlen;\n\t\tfrom = ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n\t\tmch_memmove(from, ip->bw_rest, (size_t)ip->bw_restlen);\n\t\tmch_memmove(from + ip->bw_restlen, buf, (size_t)len);\n\t    }\n\t    else\n\t    {\n\t\tfrom = buf;\n\t\tfromlen = len;\n\t    }\n\n\t    if (enc2macroman(from, fromlen,\n\t\t\tip->bw_conv_buf, &len, ip->bw_conv_buflen,\n\t\t\tip->bw_rest, &ip->bw_restlen) == FAIL)\n\t    {\n\t\tip->bw_conv_error = TRUE;\n\t\treturn FAIL;\n\t    }\n\t    buf = ip->bw_conv_buf;\n\t}\n# endif\n\n# ifdef USE_ICONV\n\tif (ip->bw_iconv_fd != (iconv_t)-1)\n\t{\n\t    const char\t*from;\n\t    size_t\tfromlen;\n\t    char\t*to;\n\t    size_t\ttolen;\n\n\t    /* Convert with iconv(). */\n\t    if (ip->bw_restlen > 0)\n\t    {\n\t\tchar *fp;\n\n\t\t/* Need to concatenate the remainder of the previous call and\n\t\t * the bytes of the current call.  Use the end of the\n\t\t * conversion buffer for this. */\n\t\tfromlen = len + ip->bw_restlen;\n\t\tfp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n\t\tmch_memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);\n\t\tmch_memmove(fp + ip->bw_restlen, buf, (size_t)len);\n\t\tfrom = fp;\n\t\ttolen = ip->bw_conv_buflen - fromlen;\n\t    }\n\t    else\n\t    {\n\t\tfrom = (const char *)buf;\n\t\tfromlen = len;\n\t\ttolen = ip->bw_conv_buflen;\n\t    }\n\t    to = (char *)ip->bw_conv_buf;\n\n\t    if (ip->bw_first)\n\t    {\n\t\tsize_t\tsave_len = tolen;\n\n\t\t/* output the initial shift state sequence */\n\t\t(void)iconv(ip->bw_iconv_fd, NULL, NULL, &to, &tolen);\n\n\t\t/* There is a bug in iconv() on Linux (which appears to be\n\t\t * wide-spread) which sets \"to\" to NULL and messes up \"tolen\".\n\t\t */\n\t\tif (to == NULL)\n\t\t{\n\t\t    to = (char *)ip->bw_conv_buf;\n\t\t    tolen = save_len;\n\t\t}\n\t\tip->bw_first = FALSE;\n\t    }\n\n\t    /*\n\t     * If iconv() has an error or there is not enough room, fail.\n\t     */\n\t    if ((iconv(ip->bw_iconv_fd, (void *)&from, &fromlen, &to, &tolen)\n\t\t\t== (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n\t\t\t\t\t\t    || fromlen > CONV_RESTLEN)\n\t    {\n\t\tip->bw_conv_error = TRUE;\n\t\treturn FAIL;\n\t    }\n\n\t    /* copy remainder to ip->bw_rest[] to be used for the next call. */\n\t    if (fromlen > 0)\n\t\tmch_memmove(ip->bw_rest, (void *)from, fromlen);\n\t    ip->bw_restlen = (int)fromlen;\n\n\t    buf = ip->bw_conv_buf;\n\t    len = (int)((char_u *)to - ip->bw_conv_buf);\n\t}\n# endif\n    }\n#endif /* FEAT_MBYTE */\n\n    if (ip->bw_fd < 0)\n\t/* Only checking conversion, which is OK if we get here. */\n\treturn OK;\n\n#ifdef FEAT_CRYPT\n    if (flags & FIO_ENCRYPTED)\n    {\n\t/* Encrypt the data. Do it in-place if possible, otherwise use an\n\t * allocated buffer. */\n\tif (crypt_works_inplace(ip->bw_buffer->b_cryptstate))\n\t{\n\t    crypt_encode_inplace(ip->bw_buffer->b_cryptstate, buf, len);\n\t}\n\telse\n\t{\n\t    char_u *outbuf;\n\n\t    len = crypt_encode_alloc(curbuf->b_cryptstate, buf, len, &outbuf);\n\t    if (len == 0)\n\t\treturn OK;  /* Crypt layer is buffering, will flush later. */\n\t    wlen = write_eintr(ip->bw_fd, outbuf, len);\n\t    vim_free(outbuf);\n\t    return (wlen < len) ? FAIL : OK;\n\t}\n    }\n#endif\n\n    wlen = write_eintr(ip->bw_fd, buf, len);\n    return (wlen < len) ? FAIL : OK;\n}\n\n#ifdef FEAT_MBYTE\n/*\n * Convert a Unicode character to bytes.\n * Return TRUE for an error, FALSE when it's OK.\n */\n    static int\nucs2bytes(\n    unsigned\tc,\t\t/* in: character */\n    char_u\t**pp,\t\t/* in/out: pointer to result */\n    int\t\tflags)\t\t/* FIO_ flags */\n{\n    char_u\t*p = *pp;\n    int\t\terror = FALSE;\n    int\t\tcc;\n\n\n    if (flags & FIO_UCS4)\n    {\n\tif (flags & FIO_ENDIAN_L)\n\t{\n\t    *p++ = c;\n\t    *p++ = (c >> 8);\n\t    *p++ = (c >> 16);\n\t    *p++ = (c >> 24);\n\t}\n\telse\n\t{\n\t    *p++ = (c >> 24);\n\t    *p++ = (c >> 16);\n\t    *p++ = (c >> 8);\n\t    *p++ = c;\n\t}\n    }\n    else if (flags & (FIO_UCS2 | FIO_UTF16))\n    {\n\tif (c >= 0x10000)\n\t{\n\t    if (flags & FIO_UTF16)\n\t    {\n\t\t/* Make two words, ten bits of the character in each.  First\n\t\t * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */\n\t\tc -= 0x10000;\n\t\tif (c >= 0x100000)\n\t\t    error = TRUE;\n\t\tcc = ((c >> 10) & 0x3ff) + 0xd800;\n\t\tif (flags & FIO_ENDIAN_L)\n\t\t{\n\t\t    *p++ = cc;\n\t\t    *p++ = ((unsigned)cc >> 8);\n\t\t}\n\t\telse\n\t\t{\n\t\t    *p++ = ((unsigned)cc >> 8);\n\t\t    *p++ = cc;\n\t\t}\n\t\tc = (c & 0x3ff) + 0xdc00;\n\t    }\n\t    else\n\t\terror = TRUE;\n\t}\n\tif (flags & FIO_ENDIAN_L)\n\t{\n\t    *p++ = c;\n\t    *p++ = (c >> 8);\n\t}\n\telse\n\t{\n\t    *p++ = (c >> 8);\n\t    *p++ = c;\n\t}\n    }\n    else    /* Latin1 */\n    {\n\tif (c >= 0x100)\n\t{\n\t    error = TRUE;\n\t    *p++ = 0xBF;\n\t}\n\telse\n\t    *p++ = c;\n    }\n\n    *pp = p;\n    return error;\n}\n\n/*\n * Return TRUE if file encoding \"fenc\" requires conversion from or to\n * 'encoding'.\n */\n    static int\nneed_conversion(char_u *fenc)\n{\n    int\t\tsame_encoding;\n    int\t\tenc_flags;\n    int\t\tfenc_flags;\n\n    if (*fenc == NUL || STRCMP(p_enc, fenc) == 0)\n    {\n\tsame_encoding = TRUE;\n\tfenc_flags = 0;\n    }\n    else\n    {\n\t/* Ignore difference between \"ansi\" and \"latin1\", \"ucs-4\" and\n\t * \"ucs-4be\", etc. */\n\tenc_flags = get_fio_flags(p_enc);\n\tfenc_flags = get_fio_flags(fenc);\n\tsame_encoding = (enc_flags != 0 && fenc_flags == enc_flags);\n    }\n    if (same_encoding)\n    {\n\t/* Specified encoding matches with 'encoding'.  This requires\n\t * conversion when 'encoding' is Unicode but not UTF-8. */\n\treturn enc_unicode != 0;\n    }\n\n    /* Encodings differ.  However, conversion is not needed when 'enc' is any\n     * Unicode encoding and the file is UTF-8. */\n    return !(enc_utf8 && fenc_flags == FIO_UTF8);\n}\n\n/*\n * Check \"ptr\" for a unicode encoding and return the FIO_ flags needed for the\n * internal conversion.\n * if \"ptr\" is an empty string, use 'encoding'.\n */\n    static int\nget_fio_flags(char_u *ptr)\n{\n    int\t\tprop;\n\n    if (*ptr == NUL)\n\tptr = p_enc;\n\n    prop = enc_canon_props(ptr);\n    if (prop & ENC_UNICODE)\n    {\n\tif (prop & ENC_2BYTE)\n\t{\n\t    if (prop & ENC_ENDIAN_L)\n\t\treturn FIO_UCS2 | FIO_ENDIAN_L;\n\t    return FIO_UCS2;\n\t}\n\tif (prop & ENC_4BYTE)\n\t{\n\t    if (prop & ENC_ENDIAN_L)\n\t\treturn FIO_UCS4 | FIO_ENDIAN_L;\n\t    return FIO_UCS4;\n\t}\n\tif (prop & ENC_2WORD)\n\t{\n\t    if (prop & ENC_ENDIAN_L)\n\t\treturn FIO_UTF16 | FIO_ENDIAN_L;\n\t    return FIO_UTF16;\n\t}\n\treturn FIO_UTF8;\n    }\n    if (prop & ENC_LATIN1)\n\treturn FIO_LATIN1;\n    /* must be ENC_DBCS, requires iconv() */\n    return 0;\n}\n\n#ifdef WIN3264\n/*\n * Check \"ptr\" for a MS-Windows codepage name and return the FIO_ flags needed\n * for the conversion MS-Windows can do for us.  Also accept \"utf-8\".\n * Used for conversion between 'encoding' and 'fileencoding'.\n */\n    static int\nget_win_fio_flags(char_u *ptr)\n{\n    int\t\tcp;\n\n    /* Cannot do this when 'encoding' is not utf-8 and not a codepage. */\n    if (!enc_utf8 && enc_codepage <= 0)\n\treturn 0;\n\n    cp = encname2codepage(ptr);\n    if (cp == 0)\n    {\n#  ifdef CP_UTF8\t/* VC 4.1 doesn't define CP_UTF8 */\n\tif (STRCMP(ptr, \"utf-8\") == 0)\n\t    cp = CP_UTF8;\n\telse\n#  endif\n\t    return 0;\n    }\n    return FIO_PUT_CP(cp) | FIO_CODEPAGE;\n}\n#endif\n\n#ifdef MACOS_CONVERT\n/*\n * Check \"ptr\" for a Carbon supported encoding and return the FIO_ flags\n * needed for the internal conversion to/from utf-8 or latin1.\n */\n    static int\nget_mac_fio_flags(char_u *ptr)\n{\n    if ((enc_utf8 || STRCMP(p_enc, \"latin1\") == 0)\n\t\t\t\t     && (enc_canon_props(ptr) & ENC_MACROMAN))\n\treturn FIO_MACROMAN;\n    return 0;\n}\n#endif\n\n/*\n * Check for a Unicode BOM (Byte Order Mark) at the start of p[size].\n * \"size\" must be at least 2.\n * Return the name of the encoding and set \"*lenp\" to the length.\n * Returns NULL when no BOM found.\n */\n    static char_u *\ncheck_for_bom(\n    char_u\t*p,\n    long\tsize,\n    int\t\t*lenp,\n    int\t\tflags)\n{\n    char\t*name = NULL;\n    int\t\tlen = 2;\n\n    if (p[0] == 0xef && p[1] == 0xbb && size >= 3 && p[2] == 0xbf\n\t    && (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0))\n    {\n\tname = \"utf-8\";\t\t/* EF BB BF */\n\tlen = 3;\n    }\n    else if (p[0] == 0xff && p[1] == 0xfe)\n    {\n\tif (size >= 4 && p[2] == 0 && p[3] == 0\n\t    && (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L)))\n\t{\n\t    name = \"ucs-4le\";\t/* FF FE 00 00 */\n\t    len = 4;\n\t}\n\telse if (flags == (FIO_UCS2 | FIO_ENDIAN_L))\n\t    name = \"ucs-2le\";\t/* FF FE */\n\telse if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))\n\t    /* utf-16le is preferred, it also works for ucs-2le text */\n\t    name = \"utf-16le\";\t/* FF FE */\n    }\n    else if (p[0] == 0xfe && p[1] == 0xff\n\t    && (flags == FIO_ALL || flags == FIO_UCS2 || flags == FIO_UTF16))\n    {\n\t/* Default to utf-16, it works also for ucs-2 text. */\n\tif (flags == FIO_UCS2)\n\t    name = \"ucs-2\";\t/* FE FF */\n\telse\n\t    name = \"utf-16\";\t/* FE FF */\n    }\n    else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe\n\t    && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4))\n    {\n\tname = \"ucs-4\";\t\t/* 00 00 FE FF */\n\tlen = 4;\n    }\n\n    *lenp = len;\n    return (char_u *)name;\n}\n\n/*\n * Generate a BOM in \"buf[4]\" for encoding \"name\".\n * Return the length of the BOM (zero when no BOM).\n */\n    static int\nmake_bom(char_u *buf, char_u *name)\n{\n    int\t\tflags;\n    char_u\t*p;\n\n    flags = get_fio_flags(name);\n\n    /* Can't put a BOM in a non-Unicode file. */\n    if (flags == FIO_LATIN1 || flags == 0)\n\treturn 0;\n\n    if (flags == FIO_UTF8)\t/* UTF-8 */\n    {\n\tbuf[0] = 0xef;\n\tbuf[1] = 0xbb;\n\tbuf[2] = 0xbf;\n\treturn 3;\n    }\n    p = buf;\n    (void)ucs2bytes(0xfeff, &p, flags);\n    return (int)(p - buf);\n}\n#endif\n\n#if defined(FEAT_VIMINFO) || defined(FEAT_BROWSE) || \\\n    defined(FEAT_QUICKFIX) || defined(FEAT_AUTOCMD) || defined(PROTO)\n/*\n * Try to find a shortname by comparing the fullname with the current\n * directory.\n * Returns \"full_path\" or pointer into \"full_path\" if shortened.\n */\n    char_u *\nshorten_fname1(char_u *full_path)\n{\n    char_u\t*dirname;\n    char_u\t*p = full_path;\n\n    dirname = alloc(MAXPATHL);\n    if (dirname == NULL)\n\treturn full_path;\n    if (mch_dirname(dirname, MAXPATHL) == OK)\n    {\n\tp = shorten_fname(full_path, dirname);\n\tif (p == NULL || *p == NUL)\n\t    p = full_path;\n    }\n    vim_free(dirname);\n    return p;\n}\n#endif\n\n/*\n * Try to find a shortname by comparing the fullname with the current\n * directory.\n * Returns NULL if not shorter name possible, pointer into \"full_path\"\n * otherwise.\n */\n    char_u *\nshorten_fname(char_u *full_path, char_u *dir_name)\n{\n    int\t\tlen;\n    char_u\t*p;\n\n    if (full_path == NULL)\n\treturn NULL;\n    len = (int)STRLEN(dir_name);\n    if (fnamencmp(dir_name, full_path, len) == 0)\n    {\n\tp = full_path + len;\n#if defined(MSWIN)\n\t/*\n\t * MSWIN: when a file is in the root directory, dir_name will end in a\n\t * slash, since C: by itself does not define a specific dir. In this\n\t * case p may already be correct. <negri>\n\t */\n\tif (!((len > 2) && (*(p - 2) == ':')))\n#endif\n\t{\n\t    if (vim_ispathsep(*p))\n\t\t++p;\n#ifndef VMS   /* the path separator is always part of the path */\n\t    else\n\t\tp = NULL;\n#endif\n\t}\n    }\n#if defined(MSWIN)\n    /*\n     * When using a file in the current drive, remove the drive name:\n     * \"A:\\dir\\file\" -> \"\\dir\\file\".  This helps when moving a session file on\n     * a floppy from \"A:\\dir\" to \"B:\\dir\".\n     */\n    else if (len > 3\n\t    && TOUPPER_LOC(full_path[0]) == TOUPPER_LOC(dir_name[0])\n\t    && full_path[1] == ':'\n\t    && vim_ispathsep(full_path[2]))\n\tp = full_path + 2;\n#endif\n    else\n\tp = NULL;\n    return p;\n}\n\n/*\n * Shorten filenames for all buffers.\n * When \"force\" is TRUE: Use full path from now on for files currently being\n * edited, both for file name and swap file name.  Try to shorten the file\n * names a bit, if safe to do so.\n * When \"force\" is FALSE: Only try to shorten absolute file names.\n * For buffers that have buftype \"nofile\" or \"scratch\": never change the file\n * name.\n */\n    void\nshorten_fnames(int force)\n{\n    char_u\tdirname[MAXPATHL];\n    buf_T\t*buf;\n    char_u\t*p;\n\n    mch_dirname(dirname, MAXPATHL);\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_fname != NULL\n#ifdef FEAT_QUICKFIX\n\t\t&& !bt_nofile(buf)\n#endif\n\t\t&& !path_with_url(buf->b_fname)\n\t\t&& (force\n\t\t    || buf->b_sfname == NULL\n\t\t    || mch_isFullName(buf->b_sfname)))\n\t{\n\t    vim_free(buf->b_sfname);\n\t    buf->b_sfname = NULL;\n\t    p = shorten_fname(buf->b_ffname, dirname);\n\t    if (p != NULL)\n\t    {\n\t\tbuf->b_sfname = vim_strsave(p);\n\t\tbuf->b_fname = buf->b_sfname;\n\t    }\n\t    if (p == NULL || buf->b_fname == NULL)\n\t\tbuf->b_fname = buf->b_ffname;\n\t}\n\n\t/* Always make the swap file name a full path, a \"nofile\" buffer may\n\t * also have a swap file. */\n\tmf_fullname(buf->b_ml.ml_mfp);\n    }\n    status_redraw_all();\n    redraw_tabline = TRUE;\n}\n\n#if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \\\n\t|| defined(FEAT_GUI_MSWIN) \\\n\t|| defined(FEAT_GUI_MAC) \\\n\t|| defined(PROTO)\n/*\n * Shorten all filenames in \"fnames[count]\" by current directory.\n */\n    void\nshorten_filenames(char_u **fnames, int count)\n{\n    int\t\ti;\n    char_u\tdirname[MAXPATHL];\n    char_u\t*p;\n\n    if (fnames == NULL || count < 1)\n\treturn;\n    mch_dirname(dirname, sizeof(dirname));\n    for (i = 0; i < count; ++i)\n    {\n\tif ((p = shorten_fname(fnames[i], dirname)) != NULL)\n\t{\n\t    /* shorten_fname() returns pointer in given \"fnames[i]\".  If free\n\t     * \"fnames[i]\" first, \"p\" becomes invalid.  So we need to copy\n\t     * \"p\" first then free fnames[i]. */\n\t    p = vim_strsave(p);\n\t    vim_free(fnames[i]);\n\t    fnames[i] = p;\n\t}\n    }\n}\n#endif\n\n/*\n * add extension to file name - change path/fo.o.h to path/fo.o.h.ext or\n * fo_o_h.ext for MSDOS or when shortname option set.\n *\n * Assumed that fname is a valid name found in the filesystem we assure that\n * the return value is a different name and ends in 'ext'.\n * \"ext\" MUST be at most 4 characters long if it starts with a dot, 3\n * characters otherwise.\n * Space for the returned name is allocated, must be freed later.\n * Returns NULL when out of memory.\n */\n    char_u *\nmodname(\n    char_u *fname,\n    char_u *ext,\n    int\t    prepend_dot)\t/* may prepend a '.' to file name */\n{\n    return buf_modname((curbuf->b_p_sn || curbuf->b_shortname),\n\t\t\t\t\t\t     fname, ext, prepend_dot);\n}\n\n    char_u *\nbuf_modname(\n    int\t    shortname,\t\t/* use 8.3 file name */\n    char_u  *fname,\n    char_u  *ext,\n    int\t    prepend_dot)\t/* may prepend a '.' to file name */\n{\n    char_u\t*retval;\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*ptr;\n    int\t\tfnamelen, extlen;\n\n    extlen = (int)STRLEN(ext);\n\n    /*\n     * If there is no file name we must get the name of the current directory\n     * (we need the full path in case :cd is used).\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tretval = alloc((unsigned)(MAXPATHL + extlen + 3));\n\tif (retval == NULL)\n\t    return NULL;\n\tif (mch_dirname(retval, MAXPATHL) == FAIL ||\n\t\t\t\t     (fnamelen = (int)STRLEN(retval)) == 0)\n\t{\n\t    vim_free(retval);\n\t    return NULL;\n\t}\n\tif (!after_pathsep(retval, retval + fnamelen))\n\t{\n\t    retval[fnamelen++] = PATHSEP;\n\t    retval[fnamelen] = NUL;\n\t}\n\tprepend_dot = FALSE;\t    /* nothing to prepend a dot to */\n    }\n    else\n    {\n\tfnamelen = (int)STRLEN(fname);\n\tretval = alloc((unsigned)(fnamelen + extlen + 3));\n\tif (retval == NULL)\n\t    return NULL;\n\tSTRCPY(retval, fname);\n#ifdef VMS\n\tvms_remove_version(retval); /* we do not need versions here */\n#endif\n    }\n\n    /*\n     * search backwards until we hit a '/', '\\' or ':' replacing all '.'\n     * by '_' for MSDOS or when shortname option set and ext starts with a dot.\n     * Then truncate what is after the '/', '\\' or ':' to 8 characters for\n     * MSDOS and 26 characters for AMIGA, a lot more for UNIX.\n     */\n    for (ptr = retval + fnamelen; ptr > retval; MB_PTR_BACK(retval, ptr))\n    {\n\tif (*ext == '.'\n#ifdef USE_LONG_FNAME\n\t\t    && (!USE_LONG_FNAME || shortname)\n#else\n\t\t    && shortname\n#endif\n\t\t\t\t\t\t\t\t)\n\t    if (*ptr == '.')\t/* replace '.' by '_' */\n\t\t*ptr = '_';\n\tif (vim_ispathsep(*ptr))\n\t{\n\t    ++ptr;\n\t    break;\n\t}\n    }\n\n    /* the file name has at most BASENAMELEN characters. */\n    if (STRLEN(ptr) > (unsigned)BASENAMELEN)\n\tptr[BASENAMELEN] = '\\0';\n\n    s = ptr + STRLEN(ptr);\n\n    /*\n     * For 8.3 file names we may have to reduce the length.\n     */\n#ifdef USE_LONG_FNAME\n    if (!USE_LONG_FNAME || shortname)\n#else\n    if (shortname)\n#endif\n    {\n\t/*\n\t * If there is no file name, or the file name ends in '/', and the\n\t * extension starts with '.', put a '_' before the dot, because just\n\t * \".ext\" is invalid.\n\t */\n\tif (fname == NULL || *fname == NUL\n\t\t\t\t   || vim_ispathsep(fname[STRLEN(fname) - 1]))\n\t{\n\t    if (*ext == '.')\n\t\t*s++ = '_';\n\t}\n\t/*\n\t * If the extension starts with '.', truncate the base name at 8\n\t * characters\n\t */\n\telse if (*ext == '.')\n\t{\n\t    if ((size_t)(s - ptr) > (size_t)8)\n\t    {\n\t\ts = ptr + 8;\n\t\t*s = '\\0';\n\t    }\n\t}\n\t/*\n\t * If the extension doesn't start with '.', and the file name\n\t * doesn't have an extension yet, append a '.'\n\t */\n\telse if ((e = vim_strchr(ptr, '.')) == NULL)\n\t    *s++ = '.';\n\t/*\n\t * If the extension doesn't start with '.', and there already is an\n\t * extension, it may need to be truncated\n\t */\n\telse if ((int)STRLEN(e) + extlen > 4)\n\t    s = e + 4 - extlen;\n    }\n#if defined(USE_LONG_FNAME) || defined(WIN3264)\n    /*\n     * If there is no file name, and the extension starts with '.', put a\n     * '_' before the dot, because just \".ext\" may be invalid if it's on a\n     * FAT partition, and on HPFS it doesn't matter.\n     */\n    else if ((fname == NULL || *fname == NUL) && *ext == '.')\n\t*s++ = '_';\n#endif\n\n    /*\n     * Append the extension.\n     * ext can start with '.' and cannot exceed 3 more characters.\n     */\n    STRCPY(s, ext);\n\n    /*\n     * Prepend the dot.\n     */\n    if (prepend_dot && !shortname && *(e = gettail(retval)) != '.'\n#ifdef USE_LONG_FNAME\n\t    && USE_LONG_FNAME\n#endif\n\t\t\t\t)\n    {\n\tSTRMOVE(e + 1, e);\n\t*e = '.';\n    }\n\n    /*\n     * Check that, after appending the extension, the file name is really\n     * different.\n     */\n    if (fname != NULL && STRCMP(fname, retval) == 0)\n    {\n\t/* we search for a character that can be replaced by '_' */\n\twhile (--s >= ptr)\n\t{\n\t    if (*s != '_')\n\t    {\n\t\t*s = '_';\n\t\tbreak;\n\t    }\n\t}\n\tif (s < ptr)\t/* fname was \"________.<ext>\", how tricky! */\n\t    *ptr = 'v';\n    }\n    return retval;\n}\n\n/*\n * Like fgets(), but if the file line is too long, it is truncated and the\n * rest of the line is thrown away.  Returns TRUE for end-of-file.\n */\n    int\nvim_fgets(char_u *buf, int size, FILE *fp)\n{\n    char\t*eof;\n#define FGETS_SIZE 200\n    char\ttbuf[FGETS_SIZE];\n\n    buf[size - 2] = NUL;\n#ifdef USE_CR\n    eof = fgets_cr((char *)buf, size, fp);\n#else\n    eof = fgets((char *)buf, size, fp);\n#endif\n    if (buf[size - 2] != NUL && buf[size - 2] != '\\n')\n    {\n\tbuf[size - 1] = NUL;\t    /* Truncate the line */\n\n\t/* Now throw away the rest of the line: */\n\tdo\n\t{\n\t    tbuf[FGETS_SIZE - 2] = NUL;\n#ifdef USE_CR\n\t    ignoredp = fgets_cr((char *)tbuf, FGETS_SIZE, fp);\n#else\n\t    ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);\n#endif\n\t} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\\n');\n    }\n    return (eof == NULL);\n}\n\n#if defined(USE_CR) || defined(PROTO)\n/*\n * Like vim_fgets(), but accept any line terminator: CR, CR-LF or LF.\n * Returns TRUE for end-of-file.\n * Only used for the Mac, because it's much slower than vim_fgets().\n */\n    int\ntag_fgets(char_u *buf, int size, FILE *fp)\n{\n    int\t\ti = 0;\n    int\t\tc;\n    int\t\teof = FALSE;\n\n    for (;;)\n    {\n\tc = fgetc(fp);\n\tif (c == EOF)\n\t{\n\t    eof = TRUE;\n\t    break;\n\t}\n\tif (c == '\\r')\n\t{\n\t    /* Always store a NL for end-of-line. */\n\t    if (i < size - 1)\n\t\tbuf[i++] = '\\n';\n\t    c = fgetc(fp);\n\t    if (c != '\\n')\t/* Macintosh format: single CR. */\n\t\tungetc(c, fp);\n\t    break;\n\t}\n\tif (i < size - 1)\n\t    buf[i++] = c;\n\tif (c == '\\n')\n\t    break;\n    }\n    buf[i] = NUL;\n    return eof;\n}\n#endif\n\n/*\n * rename() only works if both files are on the same file system, this\n * function will (attempts to?) copy the file across if rename fails -- webb\n * Return -1 for failure, 0 for success.\n */\n    int\nvim_rename(char_u *from, char_u *to)\n{\n    int\t\tfd_in;\n    int\t\tfd_out;\n    int\t\tn;\n    char\t*errmsg = NULL;\n    char\t*buffer;\n#ifdef AMIGA\n    BPTR\tflock;\n#endif\n    stat_T\tst;\n    long\tperm;\n#ifdef HAVE_ACL\n    vim_acl_T\tacl;\t\t/* ACL from original file */\n#endif\n    int\t\tuse_tmp_file = FALSE;\n\n    /*\n     * When the names are identical, there is nothing to do.  When they refer\n     * to the same file (ignoring case and slash/backslash differences) but\n     * the file name differs we need to go through a temp file.\n     */\n    if (fnamecmp(from, to) == 0)\n    {\n\tif (p_fic && STRCMP(gettail(from), gettail(to)) != 0)\n\t    use_tmp_file = TRUE;\n\telse\n\t    return 0;\n    }\n\n    /*\n     * Fail if the \"from\" file doesn't exist.  Avoids that \"to\" is deleted.\n     */\n    if (mch_stat((char *)from, &st) < 0)\n\treturn -1;\n\n#ifdef UNIX\n    {\n\tstat_T\tst_to;\n\n\t/* It's possible for the source and destination to be the same file.\n\t * This happens when \"from\" and \"to\" differ in case and are on a FAT32\n\t * filesystem.  In that case go through a temp file name. */\n\tif (mch_stat((char *)to, &st_to) >= 0\n\t\t&& st.st_dev == st_to.st_dev\n\t\t&& st.st_ino == st_to.st_ino)\n\t    use_tmp_file = TRUE;\n    }\n#endif\n#ifdef WIN3264\n    {\n\tBY_HANDLE_FILE_INFORMATION info1, info2;\n\n\t/* It's possible for the source and destination to be the same file.\n\t * In that case go through a temp file name.  This makes rename(\"foo\",\n\t * \"./foo\") a no-op (in a complicated way). */\n\tif (win32_fileinfo(from, &info1) == FILEINFO_OK\n\t\t&& win32_fileinfo(to, &info2) == FILEINFO_OK\n\t\t&& info1.dwVolumeSerialNumber == info2.dwVolumeSerialNumber\n\t\t&& info1.nFileIndexHigh == info2.nFileIndexHigh\n\t\t&& info1.nFileIndexLow == info2.nFileIndexLow)\n\t    use_tmp_file = TRUE;\n    }\n#endif\n\n    if (use_tmp_file)\n    {\n\tchar\ttempname[MAXPATHL + 1];\n\n\t/*\n\t * Find a name that doesn't exist and is in the same directory.\n\t * Rename \"from\" to \"tempname\" and then rename \"tempname\" to \"to\".\n\t */\n\tif (STRLEN(from) >= MAXPATHL - 5)\n\t    return -1;\n\tSTRCPY(tempname, from);\n\tfor (n = 123; n < 99999; ++n)\n\t{\n\t    sprintf((char *)gettail((char_u *)tempname), \"%d\", n);\n\t    if (mch_stat(tempname, &st) < 0)\n\t    {\n\t\tif (mch_rename((char *)from, tempname) == 0)\n\t\t{\n\t\t    if (mch_rename(tempname, (char *)to) == 0)\n\t\t\treturn 0;\n\t\t    /* Strange, the second step failed.  Try moving the\n\t\t     * file back and return failure. */\n\t\t    mch_rename(tempname, (char *)from);\n\t\t    return -1;\n\t\t}\n\t\t/* If it fails for one temp name it will most likely fail\n\t\t * for any temp name, give up. */\n\t\treturn -1;\n\t    }\n\t}\n\treturn -1;\n    }\n\n    /*\n     * Delete the \"to\" file, this is required on some systems to make the\n     * mch_rename() work, on other systems it makes sure that we don't have\n     * two files when the mch_rename() fails.\n     */\n\n#ifdef AMIGA\n    /*\n     * With MSDOS-compatible filesystems (crossdos, messydos) it is possible\n     * that the name of the \"to\" file is the same as the \"from\" file, even\n     * though the names are different. To avoid the chance of accidentally\n     * deleting the \"from\" file (horror!) we lock it during the remove.\n     *\n     * When used for making a backup before writing the file: This should not\n     * happen with \":w\", because startscript() should detect this problem and\n     * set buf->b_shortname, causing modname() to return a correct \".bak\" file\n     * name.  This problem does exist with \":w filename\", but then the\n     * original file will be somewhere else so the backup isn't really\n     * important. If autoscripting is off the rename may fail.\n     */\n    flock = Lock((UBYTE *)from, (long)ACCESS_READ);\n#endif\n    mch_remove(to);\n#ifdef AMIGA\n    if (flock)\n\tUnLock(flock);\n#endif\n\n    /*\n     * First try a normal rename, return if it works.\n     */\n    if (mch_rename((char *)from, (char *)to) == 0)\n\treturn 0;\n\n    /*\n     * Rename() failed, try copying the file.\n     */\n    perm = mch_getperm(from);\n#ifdef HAVE_ACL\n    /* For systems that support ACL: get the ACL from the original file. */\n    acl = mch_get_acl(from);\n#endif\n    fd_in = mch_open((char *)from, O_RDONLY|O_EXTRA, 0);\n    if (fd_in == -1)\n    {\n#ifdef HAVE_ACL\n\tmch_free_acl(acl);\n#endif\n\treturn -1;\n    }\n\n    /* Create the new file with same permissions as the original. */\n    fd_out = mch_open((char *)to,\n\t\t       O_CREAT|O_EXCL|O_WRONLY|O_EXTRA|O_NOFOLLOW, (int)perm);\n    if (fd_out == -1)\n    {\n\tclose(fd_in);\n#ifdef HAVE_ACL\n\tmch_free_acl(acl);\n#endif\n\treturn -1;\n    }\n\n    buffer = (char *)alloc(BUFSIZE);\n    if (buffer == NULL)\n    {\n\tclose(fd_out);\n\tclose(fd_in);\n#ifdef HAVE_ACL\n\tmch_free_acl(acl);\n#endif\n\treturn -1;\n    }\n\n    while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)\n\tif (write_eintr(fd_out, buffer, n) != n)\n\t{\n\t    errmsg = _(\"E208: Error writing to \\\"%s\\\"\");\n\t    break;\n\t}\n\n    vim_free(buffer);\n    close(fd_in);\n    if (close(fd_out) < 0)\n\terrmsg = _(\"E209: Error closing \\\"%s\\\"\");\n    if (n < 0)\n    {\n\terrmsg = _(\"E210: Error reading \\\"%s\\\"\");\n\tto = from;\n    }\n#ifndef UNIX\t    /* for Unix mch_open() already set the permission */\n    mch_setperm(to, perm);\n#endif\n#ifdef HAVE_ACL\n    mch_set_acl(to, acl);\n    mch_free_acl(acl);\n#endif\n#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n    mch_copy_sec(from, to);\n#endif\n    if (errmsg != NULL)\n    {\n\tEMSG2(errmsg, to);\n\treturn -1;\n    }\n    mch_remove(from);\n    return 0;\n}\n\nstatic int already_warned = FALSE;\n\n/*\n * Check if any not hidden buffer has been changed.\n * Postpone the check if there are characters in the stuff buffer, a global\n * command is being executed, a mapping is being executed or an autocommand is\n * busy.\n * Returns TRUE if some message was written (screen should be redrawn and\n * cursor positioned).\n */\n    int\ncheck_timestamps(\n    int\t\tfocus)\t\t/* called for GUI focus event */\n{\n    buf_T\t*buf;\n    int\t\tdidit = 0;\n    int\t\tn;\n\n    /* Don't check timestamps while system() or another low-level function may\n     * cause us to lose and gain focus. */\n    if (no_check_timestamps > 0)\n\treturn FALSE;\n\n    /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus\n     * event and we would keep on checking if the file is steadily growing.\n     * Do check again after typing something. */\n    if (focus && did_check_timestamps)\n    {\n\tneed_check_timestamps = TRUE;\n\treturn FALSE;\n    }\n\n    if (!stuff_empty() || global_busy || !typebuf_typed()\n#ifdef FEAT_AUTOCMD\n\t\t\t|| autocmd_busy || curbuf_lock > 0 || allbuf_lock > 0\n#endif\n\t\t\t\t\t)\n\tneed_check_timestamps = TRUE;\t\t/* check later */\n    else\n    {\n\t++no_wait_return;\n\tdid_check_timestamps = TRUE;\n\talready_warned = FALSE;\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    /* Only check buffers in a window. */\n\t    if (buf->b_nwindows > 0)\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tn = buf_check_timestamp(buf, focus);\n\t\tif (didit < n)\n\t\t    didit = n;\n\t\tif (n > 0 && !bufref_valid(&bufref))\n\t\t{\n\t\t    /* Autocommands have removed the buffer, start at the\n\t\t     * first one again. */\n\t\t    buf = firstbuf;\n\t\t    continue;\n\t\t}\n\t    }\n\t}\n\t--no_wait_return;\n\tneed_check_timestamps = FALSE;\n\tif (need_wait_return && didit == 2)\n\t{\n\t    /* make sure msg isn't overwritten */\n\t    msg_puts((char_u *)\"\\n\");\n\t    out_flush();\n\t}\n    }\n    return didit;\n}\n\n/*\n * Move all the lines from buffer \"frombuf\" to buffer \"tobuf\".\n * Return OK or FAIL.  When FAIL \"tobuf\" is incomplete and/or \"frombuf\" is not\n * empty.\n */\n    static int\nmove_lines(buf_T *frombuf, buf_T *tobuf)\n{\n    buf_T\t*tbuf = curbuf;\n    int\t\tretval = OK;\n    linenr_T\tlnum;\n    char_u\t*p;\n\n    /* Copy the lines in \"frombuf\" to \"tobuf\". */\n    curbuf = tobuf;\n    for (lnum = 1; lnum <= frombuf->b_ml.ml_line_count; ++lnum)\n    {\n\tp = vim_strsave(ml_get_buf(frombuf, lnum, FALSE));\n\tif (p == NULL || ml_append(lnum - 1, p, 0, FALSE) == FAIL)\n\t{\n\t    vim_free(p);\n\t    retval = FAIL;\n\t    break;\n\t}\n\tvim_free(p);\n    }\n\n    /* Delete all the lines in \"frombuf\". */\n    if (retval != FAIL)\n    {\n\tcurbuf = frombuf;\n\tfor (lnum = curbuf->b_ml.ml_line_count; lnum > 0; --lnum)\n\t    if (ml_delete(lnum, FALSE) == FAIL)\n\t    {\n\t\t/* Oops!  We could try putting back the saved lines, but that\n\t\t * might fail again... */\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n    }\n\n    curbuf = tbuf;\n    return retval;\n}\n\n/*\n * Check if buffer \"buf\" has been changed.\n * Also check if the file for a new buffer unexpectedly appeared.\n * return 1 if a changed buffer was found.\n * return 2 if a message has been displayed.\n * return 0 otherwise.\n */\n    int\nbuf_check_timestamp(\n    buf_T\t*buf,\n    int\t\tfocus UNUSED)\t/* called for GUI focus event */\n{\n    stat_T\tst;\n    int\t\tstat_res;\n    int\t\tretval = 0;\n    char_u\t*path;\n    char_u\t*tbuf;\n    char\t*mesg = NULL;\n    char\t*mesg2 = \"\";\n    int\t\thelpmesg = FALSE;\n    int\t\treload = FALSE;\n    char\t*reason;\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n    int\t\tcan_reload = FALSE;\n#endif\n    off_T\torig_size = buf->b_orig_size;\n    int\t\torig_mode = buf->b_orig_mode;\n#ifdef FEAT_GUI\n    int\t\tsave_mouse_correct = need_mouse_correct;\n#endif\n#ifdef FEAT_AUTOCMD\n    static int\tbusy = FALSE;\n    int\t\tn;\n    char_u\t*s;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, buf);\n#endif\n\n    /* If there is no file name, the buffer is not loaded, 'buftype' is\n     * set, we are in the middle of a save or being called recursively: ignore\n     * this buffer. */\n    if (buf->b_ffname == NULL\n\t    || buf->b_ml.ml_mfp == NULL\n\t    || *buf->b_p_bt != NUL\n\t    || buf->b_saving\n#ifdef FEAT_AUTOCMD\n\t    || busy\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t    || isNetbeansBuffer(buf)\n#endif\n#ifdef FEAT_TERMINAL\n\t    || buf->b_term != NULL\n#endif\n\t    )\n\treturn 0;\n\n    if (       !(buf->b_flags & BF_NOTEDITED)\n\t    && buf->b_mtime != 0\n\t    && ((stat_res = mch_stat((char *)buf->b_ffname, &st)) < 0\n\t\t|| time_differs((long)st.st_mtime, buf->b_mtime)\n\t\t|| st.st_size != buf->b_orig_size\n#ifdef HAVE_ST_MODE\n\t\t|| (int)st.st_mode != buf->b_orig_mode\n#else\n\t\t|| mch_getperm(buf->b_ffname) != buf->b_orig_mode\n#endif\n\t\t))\n    {\n\tretval = 1;\n\n\t/* set b_mtime to stop further warnings (e.g., when executing\n\t * FileChangedShell autocmd) */\n\tif (stat_res < 0)\n\t{\n\t    buf->b_mtime = 0;\n\t    buf->b_orig_size = 0;\n\t    buf->b_orig_mode = 0;\n\t}\n\telse\n\t    buf_store_time(buf, &st, buf->b_ffname);\n\n\t/* Don't do anything for a directory.  Might contain the file\n\t * explorer. */\n\tif (mch_isdir(buf->b_fname))\n\t    ;\n\n\t/*\n\t * If 'autoread' is set, the buffer has no changes and the file still\n\t * exists, reload the buffer.  Use the buffer-local option value if it\n\t * was set, the global option value otherwise.\n\t */\n\telse if ((buf->b_p_ar >= 0 ? buf->b_p_ar : p_ar)\n\t\t\t\t       && !bufIsChanged(buf) && stat_res >= 0)\n\t    reload = TRUE;\n\telse\n\t{\n\t    if (stat_res < 0)\n\t\treason = \"deleted\";\n\t    else if (bufIsChanged(buf))\n\t\treason = \"conflict\";\n\t    else if (orig_size != buf->b_orig_size || buf_contents_changed(buf))\n\t\treason = \"changed\";\n\t    else if (orig_mode != buf->b_orig_mode)\n\t\treason = \"mode\";\n\t    else\n\t\treason = \"time\";\n\n#ifdef FEAT_AUTOCMD\n\t    /*\n\t     * Only give the warning if there are no FileChangedShell\n\t     * autocommands.\n\t     * Avoid being called recursively by setting \"busy\".\n\t     */\n\t    busy = TRUE;\n# ifdef FEAT_EVAL\n\t    set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);\n\t    set_vim_var_string(VV_FCS_CHOICE, (char_u *)\"\", -1);\n# endif\n\t    ++allbuf_lock;\n\t    n = apply_autocmds(EVENT_FILECHANGEDSHELL,\n\t\t\t\t      buf->b_fname, buf->b_fname, FALSE, buf);\n\t    --allbuf_lock;\n\t    busy = FALSE;\n\t    if (n)\n\t    {\n\t\tif (!bufref_valid(&bufref))\n\t\t    EMSG(_(\"E246: FileChangedShell autocommand deleted buffer\"));\n# ifdef FEAT_EVAL\n\t\ts = get_vim_var_str(VV_FCS_CHOICE);\n\t\tif (STRCMP(s, \"reload\") == 0 && *reason != 'd')\n\t\t    reload = TRUE;\n\t\telse if (STRCMP(s, \"ask\") == 0)\n\t\t    n = FALSE;\n\t\telse\n# endif\n\t\t    return 2;\n\t    }\n\t    if (!n)\n#endif\n\t    {\n\t\tif (*reason == 'd')\n\t\t    mesg = _(\"E211: File \\\"%s\\\" no longer available\");\n\t\telse\n\t\t{\n\t\t    helpmesg = TRUE;\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\t\t    can_reload = TRUE;\n#endif\n\t\t    /*\n\t\t     * Check if the file contents really changed to avoid\n\t\t     * giving a warning when only the timestamp was set (e.g.,\n\t\t     * checked out of CVS).  Always warn when the buffer was\n\t\t     * changed.\n\t\t     */\n\t\t    if (reason[2] == 'n')\n\t\t    {\n\t\t\tmesg = _(\"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");\n\t\t\tmesg2 = _(\"See \\\":help W12\\\" for more info.\");\n\t\t    }\n\t\t    else if (reason[1] == 'h')\n\t\t    {\n\t\t\tmesg = _(\"W11: Warning: File \\\"%s\\\" has changed since editing started\");\n\t\t\tmesg2 = _(\"See \\\":help W11\\\" for more info.\");\n\t\t    }\n\t\t    else if (*reason == 'm')\n\t\t    {\n\t\t\tmesg = _(\"W16: Warning: Mode of file \\\"%s\\\" has changed since editing started\");\n\t\t\tmesg2 = _(\"See \\\":help W16\\\" for more info.\");\n\t\t    }\n\t\t    else\n\t\t\t/* Only timestamp changed, store it to avoid a warning\n\t\t\t * in check_mtime() later. */\n\t\t\tbuf->b_mtime_read = buf->b_mtime;\n\t\t}\n\t    }\n\t}\n\n    }\n    else if ((buf->b_flags & BF_NEW) && !(buf->b_flags & BF_NEW_W)\n\t\t\t\t\t\t&& vim_fexists(buf->b_ffname))\n    {\n\tretval = 1;\n\tmesg = _(\"W13: Warning: File \\\"%s\\\" has been created after editing started\");\n\tbuf->b_flags |= BF_NEW_W;\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\tcan_reload = TRUE;\n#endif\n    }\n\n    if (mesg != NULL)\n    {\n\tpath = home_replace_save(buf, buf->b_fname);\n\tif (path != NULL)\n\t{\n\t    if (!helpmesg)\n\t\tmesg2 = \"\";\n\t    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)\n\t\t\t\t\t\t\t+ STRLEN(mesg2) + 2));\n\t    sprintf((char *)tbuf, mesg, path);\n#ifdef FEAT_EVAL\n\t    /* Set warningmsg here, before the unimportant and output-specific\n\t     * mesg2 has been appended. */\n\t    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);\n#endif\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\t    if (can_reload)\n\t    {\n\t\tif (*mesg2 != NUL)\n\t\t{\n\t\t    STRCAT(tbuf, \"\\n\");\n\t\t    STRCAT(tbuf, mesg2);\n\t\t}\n\t\tif (do_dialog(VIM_WARNING, (char_u *)_(\"Warning\"), tbuf,\n\t\t\t  (char_u *)_(\"&OK\\n&Load File\"), 1, NULL, TRUE) == 2)\n\t\t    reload = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (State > NORMAL_BUSY || (State & CMDLINE) || already_warned)\n\t    {\n\t\tif (*mesg2 != NUL)\n\t\t{\n\t\t    STRCAT(tbuf, \"; \");\n\t\t    STRCAT(tbuf, mesg2);\n\t\t}\n\t\tEMSG(tbuf);\n\t\tretval = 2;\n\t    }\n\t    else\n\t    {\n# ifdef FEAT_AUTOCMD\n\t\tif (!autocmd_busy)\n# endif\n\t\t{\n\t\t    msg_start();\n\t\t    msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);\n\t\t    if (*mesg2 != NUL)\n\t\t\tmsg_puts_attr((char_u *)mesg2,\n\t\t\t\t\t\t   HL_ATTR(HLF_W) + MSG_HIST);\n\t\t    msg_clr_eos();\n\t\t    (void)msg_end();\n\t\t    if (emsg_silent == 0)\n\t\t    {\n\t\t\tout_flush();\n# ifdef FEAT_GUI\n\t\t\tif (!focus)\n# endif\n\t\t\t    /* give the user some time to think about it */\n\t\t\t    ui_delay(1000L, TRUE);\n\n\t\t\t/* don't redraw and erase the message */\n\t\t\tredraw_cmdline = FALSE;\n\t\t    }\n\t\t}\n\t\talready_warned = TRUE;\n\t    }\n\n\t    vim_free(path);\n\t    vim_free(tbuf);\n\t}\n    }\n\n    if (reload)\n    {\n\t/* Reload the buffer. */\n\tbuf_reload(buf, orig_mode);\n#ifdef FEAT_PERSISTENT_UNDO\n\tif (buf->b_p_udf && buf->b_ffname != NULL)\n\t{\n\t    char_u\t    hash[UNDO_HASH_SIZE];\n\t    buf_T\t    *save_curbuf = curbuf;\n\n\t    /* Any existing undo file is unusable, write it now. */\n\t    curbuf = buf;\n\t    u_compute_hash(hash);\n\t    u_write_undo(NULL, FALSE, buf, hash);\n\t    curbuf = save_curbuf;\n\t}\n#endif\n    }\n\n#ifdef FEAT_AUTOCMD\n    /* Trigger FileChangedShell when the file was changed in any way. */\n    if (bufref_valid(&bufref) && retval != 0)\n\t(void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST,\n\t\t\t\t      buf->b_fname, buf->b_fname, FALSE, buf);\n#endif\n#ifdef FEAT_GUI\n    /* restore this in case an autocommand has set it; it would break\n     * 'mousefocus' */\n    need_mouse_correct = save_mouse_correct;\n#endif\n\n    return retval;\n}\n\n/*\n * Reload a buffer that is already loaded.\n * Used when the file was changed outside of Vim.\n * \"orig_mode\" is buf->b_orig_mode before the need for reloading was detected.\n * buf->b_orig_mode may have been reset already.\n */\n    void\nbuf_reload(buf_T *buf, int orig_mode)\n{\n    exarg_T\tea;\n    pos_T\told_cursor;\n    linenr_T\told_topline;\n    int\t\told_ro = buf->b_p_ro;\n    buf_T\t*savebuf;\n    bufref_T\tbufref;\n    int\t\tsaved = OK;\n    aco_save_T\taco;\n    int\t\tflags = READ_NEW;\n\n    /* set curwin/curbuf for \"buf\" and save some things */\n    aucmd_prepbuf(&aco, buf);\n\n    /* We only want to read the text from the file, not reset the syntax\n     * highlighting, clear marks, diff status, etc.  Force the fileformat\n     * and encoding to be the same. */\n    if (prep_exarg(&ea, buf) == OK)\n    {\n\told_cursor = curwin->w_cursor;\n\told_topline = curwin->w_topline;\n\n\tif (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur)\n\t{\n\t    /* Save all the text, so that the reload can be undone.\n\t     * Sync first so that this is a separate undo-able action. */\n\t    u_sync(FALSE);\n\t    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);\n\t    flags |= READ_KEEP_UNDO;\n\t}\n\n\t/*\n\t * To behave like when a new file is edited (matters for\n\t * BufReadPost autocommands) we first need to delete the current\n\t * buffer contents.  But if reading the file fails we should keep\n\t * the old contents.  Can't use memory only, the file might be\n\t * too big.  Use a hidden buffer to move the buffer contents to.\n\t */\n\tif (BUFEMPTY() || saved == FAIL)\n\t    savebuf = NULL;\n\telse\n\t{\n\t    /* Allocate a buffer without putting it in the buffer list. */\n\t    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n\t    set_bufref(&bufref, savebuf);\n\t    if (savebuf != NULL && buf == curbuf)\n\t    {\n\t\t/* Open the memline. */\n\t\tcurbuf = savebuf;\n\t\tcurwin->w_buffer = savebuf;\n\t\tsaved = ml_open(curbuf);\n\t\tcurbuf = buf;\n\t\tcurwin->w_buffer = buf;\n\t    }\n\t    if (savebuf == NULL || saved == FAIL || buf != curbuf\n\t\t\t\t      || move_lines(buf, savebuf) == FAIL)\n\t    {\n\t\tEMSG2(_(\"E462: Could not prepare for reloading \\\"%s\\\"\"),\n\t\t\t\t\t\t\t    buf->b_fname);\n\t\tsaved = FAIL;\n\t    }\n\t}\n\n\tif (saved == OK)\n\t{\n\t    curbuf->b_flags |= BF_CHECK_RO;\t/* check for RO again */\n#ifdef FEAT_AUTOCMD\n\t    keep_filetype = TRUE;\t\t/* don't detect 'filetype' */\n#endif\n\t    if (readfile(buf->b_ffname, buf->b_fname, (linenr_T)0,\n\t\t\t(linenr_T)0,\n\t\t\t(linenr_T)MAXLNUM, &ea, flags) != OK)\n\t    {\n#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t    EMSG2(_(\"E321: Could not reload \\\"%s\\\"\"), buf->b_fname);\n\t\tif (savebuf != NULL && bufref_valid(&bufref) && buf == curbuf)\n\t\t{\n\t\t    /* Put the text back from the save buffer.  First\n\t\t     * delete any lines that readfile() added. */\n\t\t    while (!BUFEMPTY())\n\t\t\tif (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)\n\t\t\t    break;\n\t\t    (void)move_lines(savebuf, buf);\n\t\t}\n\t    }\n\t    else if (buf == curbuf)  /* \"buf\" still valid */\n\t    {\n\t\t/* Mark the buffer as unmodified and free undo info. */\n\t\tunchanged(buf, TRUE);\n\t\tif ((flags & READ_KEEP_UNDO) == 0)\n\t\t{\n\t\t    u_blockfree(buf);\n\t\t    u_clearall(buf);\n\t\t}\n\t\telse\n\t\t{\n\t\t    /* Mark all undo states as changed. */\n\t\t    u_unchanged(curbuf);\n\t\t}\n\t    }\n\t}\n\tvim_free(ea.cmd);\n\n\tif (savebuf != NULL && bufref_valid(&bufref))\n\t    wipe_buffer(savebuf, FALSE);\n\n#ifdef FEAT_DIFF\n\t/* Invalidate diff info if necessary. */\n\tdiff_invalidate(curbuf);\n#endif\n\n\t/* Restore the topline and cursor position and check it (lines may\n\t * have been removed). */\n\tif (old_topline > curbuf->b_ml.ml_line_count)\n\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_topline = old_topline;\n\tcurwin->w_cursor = old_cursor;\n\tcheck_cursor();\n\tupdate_topline();\n#ifdef FEAT_AUTOCMD\n\tkeep_filetype = FALSE;\n#endif\n#ifdef FEAT_FOLDING\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    /* Update folds unless they are defined manually. */\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tif (wp->w_buffer == curwin->w_buffer\n\t\t\t&& !foldmethodIsManual(wp))\n\t\t    foldUpdateAll(wp);\n\t}\n#endif\n\t/* If the mode didn't change and 'readonly' was set, keep the old\n\t * value; the user probably used the \":view\" command.  But don't\n\t * reset it, might have had a read error. */\n\tif (orig_mode == curbuf->b_orig_mode)\n\t    curbuf->b_p_ro |= old_ro;\n\n\t/* Modelines must override settings done by autocommands. */\n\tdo_modelines(0);\n    }\n\n    /* restore curwin/curbuf and a few other things */\n    aucmd_restbuf(&aco);\n    /* Careful: autocommands may have made \"buf\" invalid! */\n}\n\n    void\nbuf_store_time(buf_T *buf, stat_T *st, char_u *fname UNUSED)\n{\n    buf->b_mtime = (long)st->st_mtime;\n    buf->b_orig_size = st->st_size;\n#ifdef HAVE_ST_MODE\n    buf->b_orig_mode = (int)st->st_mode;\n#else\n    buf->b_orig_mode = mch_getperm(fname);\n#endif\n}\n\n/*\n * Adjust the line with missing eol, used for the next write.\n * Used for do_filter(), when the input lines for the filter are deleted.\n */\n    void\nwrite_lnum_adjust(linenr_T offset)\n{\n    if (curbuf->b_no_eol_lnum != 0)\t/* only if there is a missing eol */\n\tcurbuf->b_no_eol_lnum += offset;\n}\n\n#if defined(TEMPDIRNAMES) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Delete \"name\" and everything in it, recursively.\n * return 0 for succes, -1 if some file was not deleted.\n */\n    int\ndelete_recursive(char_u *name)\n{\n    int result = 0;\n    char_u\t**files;\n    int\t\tfile_count;\n    int\t\ti;\n    char_u\t*exp;\n\n    /* A symbolic link to a directory itself is deleted, not the directory it\n     * points to. */\n    if (\n# if defined(UNIX) || defined(WIN32)\n\t mch_isrealdir(name)\n# else\n\t mch_isdir(name)\n# endif\n\t    )\n    {\n\tvim_snprintf((char *)NameBuff, MAXPATHL, \"%s/*\", name);\n\texp = vim_strsave(NameBuff);\n\tif (exp == NULL)\n\t    return -1;\n\tif (gen_expand_wildcards(1, &exp, &file_count, &files,\n\t      EW_DIR|EW_FILE|EW_SILENT|EW_ALLLINKS|EW_DODOT|EW_EMPTYOK) == OK)\n\t{\n\t    for (i = 0; i < file_count; ++i)\n\t\tif (delete_recursive(files[i]) != 0)\n\t\t    result = -1;\n\t    FreeWild(file_count, files);\n\t}\n\telse\n\t    result = -1;\n\tvim_free(exp);\n\t(void)mch_rmdir(name);\n    }\n    else\n\tresult = mch_remove(name) == 0 ? 0 : -1;\n\n    return result;\n}\n#endif\n\n#if defined(TEMPDIRNAMES) || defined(PROTO)\nstatic long\ttemp_count = 0;\t\t/* Temp filename counter. */\n\n/*\n * Delete the temp directory and all files it contains.\n */\n    void\nvim_deltempdir(void)\n{\n    if (vim_tempdir != NULL)\n    {\n\t/* remove the trailing path separator */\n\tgettail(vim_tempdir)[-1] = NUL;\n\tdelete_recursive(vim_tempdir);\n\tvim_free(vim_tempdir);\n\tvim_tempdir = NULL;\n    }\n}\n\n/*\n * Directory \"tempdir\" was created.  Expand this name to a full path and put\n * it in \"vim_tempdir\".  This avoids that using \":cd\" would confuse us.\n * \"tempdir\" must be no longer than MAXPATHL.\n */\n    static void\nvim_settempdir(char_u *tempdir)\n{\n    char_u\t*buf;\n\n    buf = alloc((unsigned)MAXPATHL + 2);\n    if (buf != NULL)\n    {\n\tif (vim_FullName(tempdir, buf, MAXPATHL, FALSE) == FAIL)\n\t    STRCPY(buf, tempdir);\n\tadd_pathsep(buf);\n\tvim_tempdir = vim_strsave(buf);\n\tvim_free(buf);\n    }\n}\n#endif\n\n/*\n * vim_tempname(): Return a unique name that can be used for a temp file.\n *\n * The temp file is NOT guaranteed to be created.  If \"keep\" is FALSE it is\n * guaranteed to NOT be created.\n *\n * The returned pointer is to allocated memory.\n * The returned pointer is NULL if no valid name was found.\n */\n    char_u  *\nvim_tempname(\n    int\t    extra_char UNUSED,  /* char to use in the name instead of '?' */\n    int\t    keep UNUSED)\n{\n#ifdef USE_TMPNAM\n    char_u\titmp[L_tmpnam];\t/* use tmpnam() */\n#else\n    char_u\titmp[TEMPNAMELEN];\n#endif\n\n#ifdef TEMPDIRNAMES\n    static char\t*(tempdirs[]) = {TEMPDIRNAMES};\n    int\t\ti;\n# ifndef EEXIST\n    stat_T\tst;\n# endif\n\n    /*\n     * This will create a directory for private use by this instance of Vim.\n     * This is done once, and the same directory is used for all temp files.\n     * This method avoids security problems because of symlink attacks et al.\n     * It's also a bit faster, because we only need to check for an existing\n     * file when creating the directory and not for each temp file.\n     */\n    if (vim_tempdir == NULL)\n    {\n\t/*\n\t * Try the entries in TEMPDIRNAMES to create the temp directory.\n\t */\n\tfor (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)\n\t{\n# ifndef HAVE_MKDTEMP\n\t    size_t\titmplen;\n\t    long\tnr;\n\t    long\toff;\n# endif\n\n\t    /* Expand $TMP, leave room for \"/v1100000/999999999\".\n\t     * Skip the directory check if the expansion fails. */\n\t    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);\n\t    if (itmp[0] != '$' && mch_isdir(itmp))\n\t    {\n\t\t/* directory exists */\n\t\tadd_pathsep(itmp);\n\n# ifdef HAVE_MKDTEMP\n\t\t{\n#  if defined(UNIX) || defined(VMS)\n\t\t    /* Make sure the umask doesn't remove the executable bit.\n\t\t     * \"repl\" has been reported to use \"177\". */\n\t\t    mode_t\tumask_save = umask(077);\n#  endif\n\t\t    /* Leave room for filename */\n\t\t    STRCAT(itmp, \"vXXXXXX\");\n\t\t    if (mkdtemp((char *)itmp) != NULL)\n\t\t\tvim_settempdir(itmp);\n#  if defined(UNIX) || defined(VMS)\n\t\t    (void)umask(umask_save);\n#  endif\n\t\t}\n# else\n\t\t/* Get an arbitrary number of up to 6 digits.  When it's\n\t\t * unlikely that it already exists it will be faster,\n\t\t * otherwise it doesn't matter.  The use of mkdir() avoids any\n\t\t * security problems because of the predictable number. */\n\t\tnr = (mch_get_pid() + (long)time(NULL)) % 1000000L;\n\t\titmplen = STRLEN(itmp);\n\n\t\t/* Try up to 10000 different values until we find a name that\n\t\t * doesn't exist. */\n\t\tfor (off = 0; off < 10000L; ++off)\n\t\t{\n\t\t    int\t\tr;\n#  if defined(UNIX) || defined(VMS)\n\t\t    mode_t\tumask_save;\n#  endif\n\n\t\t    sprintf((char *)itmp + itmplen, \"v%ld\", nr + off);\n#  ifndef EEXIST\n\t\t    /* If mkdir() does not set errno to EEXIST, check for\n\t\t     * existing file here.  There is a race condition then,\n\t\t     * although it's fail-safe. */\n\t\t    if (mch_stat((char *)itmp, &st) >= 0)\n\t\t\tcontinue;\n#  endif\n#  if defined(UNIX) || defined(VMS)\n\t\t    /* Make sure the umask doesn't remove the executable bit.\n\t\t     * \"repl\" has been reported to use \"177\". */\n\t\t    umask_save = umask(077);\n#  endif\n\t\t    r = vim_mkdir(itmp, 0700);\n#  if defined(UNIX) || defined(VMS)\n\t\t    (void)umask(umask_save);\n#  endif\n\t\t    if (r == 0)\n\t\t    {\n\t\t\tvim_settempdir(itmp);\n\t\t\tbreak;\n\t\t    }\n#  ifdef EEXIST\n\t\t    /* If the mkdir() didn't fail because the file/dir exists,\n\t\t     * we probably can't create any dir here, try another\n\t\t     * place. */\n\t\t    if (errno != EEXIST)\n#  endif\n\t\t\tbreak;\n\t\t}\n# endif /* HAVE_MKDTEMP */\n\t\tif (vim_tempdir != NULL)\n\t\t    break;\n\t    }\n\t}\n    }\n\n    if (vim_tempdir != NULL)\n    {\n\t/* There is no need to check if the file exists, because we own the\n\t * directory and nobody else creates a file in it. */\n\tsprintf((char *)itmp, \"%s%ld\", vim_tempdir, temp_count++);\n\treturn vim_strsave(itmp);\n    }\n\n    return NULL;\n\n#else /* TEMPDIRNAMES */\n\n# ifdef WIN3264\n    char\tszTempFile[_MAX_PATH + 1];\n    char\tbuf4[4];\n    char_u\t*retval;\n    char_u\t*p;\n\n    STRCPY(itmp, \"\");\n    if (GetTempPath(_MAX_PATH, szTempFile) == 0)\n    {\n\tszTempFile[0] = '.';\t/* GetTempPath() failed, use current dir */\n\tszTempFile[1] = NUL;\n    }\n    strcpy(buf4, \"VIM\");\n    buf4[2] = extra_char;   /* make it \"VIa\", \"VIb\", etc. */\n    if (GetTempFileName(szTempFile, buf4, 0, (LPSTR)itmp) == 0)\n\treturn NULL;\n    if (!keep)\n\t/* GetTempFileName() will create the file, we don't want that */\n\t(void)DeleteFile((LPSTR)itmp);\n\n    /* Backslashes in a temp file name cause problems when filtering with\n     * \"sh\".  NOTE: This also checks 'shellcmdflag' to help those people who\n     * didn't set 'shellslash'. */\n    retval = vim_strsave(itmp);\n    if (*p_shcf == '-' || p_ssl)\n\tfor (p = retval; *p; ++p)\n\t    if (*p == '\\\\')\n\t\t*p = '/';\n    return retval;\n\n# else /* WIN3264 */\n\n#  ifdef USE_TMPNAM\n    char_u\t*p;\n\n    /* tmpnam() will make its own name */\n    p = tmpnam((char *)itmp);\n    if (p == NULL || *p == NUL)\n\treturn NULL;\n#  else\n    char_u\t*p;\n\n#   ifdef VMS_TEMPNAM\n    /* mktemp() is not working on VMS.  It seems to be\n     * a do-nothing function. Therefore we use tempnam().\n     */\n    sprintf((char *)itmp, \"VIM%c\", extra_char);\n    p = (char_u *)tempnam(\"tmp:\", (char *)itmp);\n    if (p != NULL)\n    {\n\t/* VMS will use '.LIS' if we don't explicitly specify an extension,\n\t * and VIM will then be unable to find the file later */\n\tSTRCPY(itmp, p);\n\tSTRCAT(itmp, \".txt\");\n\tfree(p);\n    }\n    else\n\treturn NULL;\n#   else\n    STRCPY(itmp, TEMPNAME);\n    if ((p = vim_strchr(itmp, '?')) != NULL)\n\t*p = extra_char;\n    if (mktemp((char *)itmp) == NULL)\n\treturn NULL;\n#   endif\n#  endif\n\n    return vim_strsave(itmp);\n# endif /* WIN3264 */\n#endif /* TEMPDIRNAMES */\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Convert all backslashes in fname to forward slashes in-place, unless when\n * it looks like a URL.\n */\n    void\nforward_slash(char_u *fname)\n{\n    char_u\t*p;\n\n    if (path_with_url(fname))\n\treturn;\n    for (p = fname; *p != NUL; ++p)\n# ifdef  FEAT_MBYTE\n\t/* The Big5 encoding can have '\\' in the trail byte. */\n\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) > 1)\n\t    ++p;\n\telse\n# endif\n\tif (*p == '\\\\')\n\t    *p = '/';\n}\n#endif\n\n\n/*\n * Code for automatic commands.\n *\n * Only included when \"FEAT_AUTOCMD\" has been defined.\n */\n\n#if defined(FEAT_AUTOCMD) || defined(PROTO)\n\n/*\n * The autocommands are stored in a list for each event.\n * Autocommands for the same pattern, that are consecutive, are joined\n * together, to avoid having to match the pattern too often.\n * The result is an array of Autopat lists, which point to AutoCmd lists:\n *\n * first_autopat[0] --> Autopat.next  -->  Autopat.next -->  NULL\n *\t\t\tAutopat.cmds\t   Autopat.cmds\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t   AutoCmd.next\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t\tNULL\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *\n * first_autopat[1] --> Autopat.next  -->  NULL\n *\t\t\tAutopat.cmds\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\tAutoCmd.next\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *   etc.\n *\n *   The order of AutoCmds is important, this is the order in which they were\n *   defined and will have to be executed.\n */\ntypedef struct AutoCmd\n{\n    char_u\t    *cmd;\t\t/* The command to be executed (NULL\n\t\t\t\t\t   when command has been removed) */\n    char\t    nested;\t\t/* If autocommands nest here */\n    char\t    last;\t\t/* last command in list */\n#ifdef FEAT_EVAL\n    scid_T\t    scriptID;\t\t/* script ID where defined */\n#endif\n    struct AutoCmd  *next;\t\t/* Next AutoCmd in list */\n} AutoCmd;\n\ntypedef struct AutoPat\n{\n    char_u\t    *pat;\t\t/* pattern as typed (NULL when pattern\n\t\t\t\t\t   has been removed) */\n    regprog_T\t    *reg_prog;\t\t/* compiled regprog for pattern */\n    AutoCmd\t    *cmds;\t\t/* list of commands to do */\n    struct AutoPat  *next;\t\t/* next AutoPat in AutoPat list */\n    int\t\t    group;\t\t/* group ID */\n    int\t\t    patlen;\t\t/* strlen() of pat */\n    int\t\t    buflocal_nr;\t/* !=0 for buffer-local AutoPat */\n    char\t    allow_dirs;\t\t/* Pattern may match whole path */\n    char\t    last;\t\t/* last pattern for apply_autocmds() */\n} AutoPat;\n\nstatic struct event_name\n{\n    char\t*name;\t/* event name */\n    event_T\tevent;\t/* event number */\n} event_names[] =\n{\n    {\"BufAdd\",\t\tEVENT_BUFADD},\n    {\"BufCreate\",\tEVENT_BUFADD},\n    {\"BufDelete\",\tEVENT_BUFDELETE},\n    {\"BufEnter\",\tEVENT_BUFENTER},\n    {\"BufFilePost\",\tEVENT_BUFFILEPOST},\n    {\"BufFilePre\",\tEVENT_BUFFILEPRE},\n    {\"BufHidden\",\tEVENT_BUFHIDDEN},\n    {\"BufLeave\",\tEVENT_BUFLEAVE},\n    {\"BufNew\",\t\tEVENT_BUFNEW},\n    {\"BufNewFile\",\tEVENT_BUFNEWFILE},\n    {\"BufRead\",\t\tEVENT_BUFREADPOST},\n    {\"BufReadCmd\",\tEVENT_BUFREADCMD},\n    {\"BufReadPost\",\tEVENT_BUFREADPOST},\n    {\"BufReadPre\",\tEVENT_BUFREADPRE},\n    {\"BufUnload\",\tEVENT_BUFUNLOAD},\n    {\"BufWinEnter\",\tEVENT_BUFWINENTER},\n    {\"BufWinLeave\",\tEVENT_BUFWINLEAVE},\n    {\"BufWipeout\",\tEVENT_BUFWIPEOUT},\n    {\"BufWrite\",\tEVENT_BUFWRITEPRE},\n    {\"BufWritePost\",\tEVENT_BUFWRITEPOST},\n    {\"BufWritePre\",\tEVENT_BUFWRITEPRE},\n    {\"BufWriteCmd\",\tEVENT_BUFWRITECMD},\n    {\"CmdlineEnter\",\tEVENT_CMDLINEENTER},\n    {\"CmdlineLeave\",\tEVENT_CMDLINELEAVE},\n    {\"CmdwinEnter\",\tEVENT_CMDWINENTER},\n    {\"CmdwinLeave\",\tEVENT_CMDWINLEAVE},\n    {\"CmdUndefined\",\tEVENT_CMDUNDEFINED},\n    {\"ColorScheme\",\tEVENT_COLORSCHEME},\n    {\"CompleteDone\",\tEVENT_COMPLETEDONE},\n    {\"CursorHold\",\tEVENT_CURSORHOLD},\n    {\"CursorHoldI\",\tEVENT_CURSORHOLDI},\n    {\"CursorMoved\",\tEVENT_CURSORMOVED},\n    {\"CursorMovedI\",\tEVENT_CURSORMOVEDI},\n    {\"EncodingChanged\",\tEVENT_ENCODINGCHANGED},\n    {\"FileEncoding\",\tEVENT_ENCODINGCHANGED},\n    {\"FileAppendPost\",\tEVENT_FILEAPPENDPOST},\n    {\"FileAppendPre\",\tEVENT_FILEAPPENDPRE},\n    {\"FileAppendCmd\",\tEVENT_FILEAPPENDCMD},\n    {\"FileChangedShell\",EVENT_FILECHANGEDSHELL},\n    {\"FileChangedShellPost\",EVENT_FILECHANGEDSHELLPOST},\n    {\"FileChangedRO\",\tEVENT_FILECHANGEDRO},\n    {\"FileReadPost\",\tEVENT_FILEREADPOST},\n    {\"FileReadPre\",\tEVENT_FILEREADPRE},\n    {\"FileReadCmd\",\tEVENT_FILEREADCMD},\n    {\"FileType\",\tEVENT_FILETYPE},\n    {\"FileWritePost\",\tEVENT_FILEWRITEPOST},\n    {\"FileWritePre\",\tEVENT_FILEWRITEPRE},\n    {\"FileWriteCmd\",\tEVENT_FILEWRITECMD},\n    {\"FilterReadPost\",\tEVENT_FILTERREADPOST},\n    {\"FilterReadPre\",\tEVENT_FILTERREADPRE},\n    {\"FilterWritePost\",\tEVENT_FILTERWRITEPOST},\n    {\"FilterWritePre\",\tEVENT_FILTERWRITEPRE},\n    {\"FocusGained\",\tEVENT_FOCUSGAINED},\n    {\"FocusLost\",\tEVENT_FOCUSLOST},\n    {\"FuncUndefined\",\tEVENT_FUNCUNDEFINED},\n    {\"GUIEnter\",\tEVENT_GUIENTER},\n    {\"GUIFailed\",\tEVENT_GUIFAILED},\n    {\"InsertChange\",\tEVENT_INSERTCHANGE},\n    {\"InsertEnter\",\tEVENT_INSERTENTER},\n    {\"InsertLeave\",\tEVENT_INSERTLEAVE},\n    {\"InsertCharPre\",\tEVENT_INSERTCHARPRE},\n    {\"MenuPopup\",\tEVENT_MENUPOPUP},\n    {\"OptionSet\",\tEVENT_OPTIONSET},\n    {\"QuickFixCmdPost\",\tEVENT_QUICKFIXCMDPOST},\n    {\"QuickFixCmdPre\",\tEVENT_QUICKFIXCMDPRE},\n    {\"QuitPre\",\t\tEVENT_QUITPRE},\n    {\"RemoteReply\",\tEVENT_REMOTEREPLY},\n    {\"SessionLoadPost\",\tEVENT_SESSIONLOADPOST},\n    {\"ShellCmdPost\",\tEVENT_SHELLCMDPOST},\n    {\"ShellFilterPost\",\tEVENT_SHELLFILTERPOST},\n    {\"SourcePre\",\tEVENT_SOURCEPRE},\n    {\"SourceCmd\",\tEVENT_SOURCECMD},\n    {\"SpellFileMissing\",EVENT_SPELLFILEMISSING},\n    {\"StdinReadPost\",\tEVENT_STDINREADPOST},\n    {\"StdinReadPre\",\tEVENT_STDINREADPRE},\n    {\"SwapExists\",\tEVENT_SWAPEXISTS},\n    {\"Syntax\",\t\tEVENT_SYNTAX},\n    {\"TabNew\",\t\tEVENT_TABNEW},\n    {\"TabClosed\",\tEVENT_TABCLOSED},\n    {\"TabEnter\",\tEVENT_TABENTER},\n    {\"TabLeave\",\tEVENT_TABLEAVE},\n    {\"TermChanged\",\tEVENT_TERMCHANGED},\n    {\"TermResponse\",\tEVENT_TERMRESPONSE},\n    {\"TextChanged\",\tEVENT_TEXTCHANGED},\n    {\"TextChangedI\",\tEVENT_TEXTCHANGEDI},\n    {\"User\",\t\tEVENT_USER},\n    {\"VimEnter\",\tEVENT_VIMENTER},\n    {\"VimLeave\",\tEVENT_VIMLEAVE},\n    {\"VimLeavePre\",\tEVENT_VIMLEAVEPRE},\n    {\"WinNew\",\t\tEVENT_WINNEW},\n    {\"WinEnter\",\tEVENT_WINENTER},\n    {\"WinLeave\",\tEVENT_WINLEAVE},\n    {\"VimResized\",\tEVENT_VIMRESIZED},\n    {NULL,\t\t(event_T)0}\n};\n\nstatic AutoPat *first_autopat[NUM_EVENTS] =\n{\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\n/*\n * struct used to keep status while executing autocommands for an event.\n */\ntypedef struct AutoPatCmd\n{\n    AutoPat\t*curpat;\t/* next AutoPat to examine */\n    AutoCmd\t*nextcmd;\t/* next AutoCmd to execute */\n    int\t\tgroup;\t\t/* group being used */\n    char_u\t*fname;\t\t/* fname to match with */\n    char_u\t*sfname;\t/* sfname to match with */\n    char_u\t*tail;\t\t/* tail of fname */\n    event_T\tevent;\t\t/* current event */\n    int\t\targ_bufnr;\t/* initially equal to <abuf>, set to zero when\n\t\t\t\t   buf is deleted */\n    struct AutoPatCmd   *next;\t/* chain of active apc-s for auto-invalidation*/\n} AutoPatCmd;\n\nstatic AutoPatCmd *active_apc_list = NULL; /* stack of active autocommands */\n\n/*\n * augroups stores a list of autocmd group names.\n */\nstatic garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};\n#define AUGROUP_NAME(i) (((char_u **)augroups.ga_data)[i])\n/* use get_deleted_augroup() to get this */\nstatic char_u *deleted_augroup = NULL;\n\n/*\n * The ID of the current group.  Group 0 is the default one.\n */\nstatic int current_augroup = AUGROUP_DEFAULT;\n\nstatic int au_need_clean = FALSE;   /* need to delete marked patterns */\n\nstatic void show_autocmd(AutoPat *ap, event_T event);\nstatic void au_remove_pat(AutoPat *ap);\nstatic void au_remove_cmds(AutoPat *ap);\nstatic void au_cleanup(void);\nstatic int au_new_group(char_u *name);\nstatic void au_del_group(char_u *name);\nstatic event_T event_name2nr(char_u *start, char_u **end);\nstatic char_u *event_nr2name(event_T event);\nstatic char_u *find_end_event(char_u *arg, int have_group);\nstatic int event_ignored(event_T event);\nstatic int au_get_grouparg(char_u **argp);\nstatic int do_autocmd_event(event_T event, char_u *pat, int nested, char_u *cmd, int forceit, int group);\nstatic int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);\nstatic void auto_next_pat(AutoPatCmd *apc, int stop_at_last);\n#if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN)\nstatic int match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs);\n#endif\n\n\nstatic event_T\tlast_event;\nstatic int\tlast_group;\nstatic int\tautocmd_blocked = 0;\t/* block all autocmds */\n\n    static char_u *\nget_deleted_augroup(void)\n{\n    if (deleted_augroup == NULL)\n\tdeleted_augroup = (char_u *)_(\"--Deleted--\");\n    return deleted_augroup;\n}\n\n/*\n * Show the autocommands for one AutoPat.\n */\n    static void\nshow_autocmd(AutoPat *ap, event_T event)\n{\n    AutoCmd *ac;\n\n    /* Check for \"got_int\" (here and at various places below), which is set\n     * when \"q\" has been hit for the \"--more--\" prompt */\n    if (got_int)\n\treturn;\n    if (ap->pat == NULL)\t\t/* pattern has been removed */\n\treturn;\n\n    msg_putchar('\\n');\n    if (got_int)\n\treturn;\n    if (event != last_event || ap->group != last_group)\n    {\n\tif (ap->group != AUGROUP_DEFAULT)\n\t{\n\t    if (AUGROUP_NAME(ap->group) == NULL)\n\t\tmsg_puts_attr(get_deleted_augroup(), HL_ATTR(HLF_E));\n\t    else\n\t\tmsg_puts_attr(AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));\n\t    msg_puts((char_u *)\"  \");\n\t}\n\tmsg_puts_attr(event_nr2name(event), HL_ATTR(HLF_T));\n\tlast_event = event;\n\tlast_group = ap->group;\n\tmsg_putchar('\\n');\n\tif (got_int)\n\t    return;\n    }\n    msg_col = 4;\n    msg_outtrans(ap->pat);\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n    {\n\tif (ac->cmd != NULL)\t\t/* skip removed commands */\n\t{\n\t    if (msg_col >= 14)\n\t\tmsg_putchar('\\n');\n\t    msg_col = 14;\n\t    if (got_int)\n\t\treturn;\n\t    msg_outtrans(ac->cmd);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(ac->scriptID);\n#endif\n\t    if (got_int)\n\t\treturn;\n\t    if (ac->next != NULL)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    return;\n\t    }\n\t}\n    }\n}\n\n/*\n * Mark an autocommand pattern for deletion.\n */\n    static void\nau_remove_pat(AutoPat *ap)\n{\n    vim_free(ap->pat);\n    ap->pat = NULL;\n    ap->buflocal_nr = -1;\n    au_need_clean = TRUE;\n}\n\n/*\n * Mark all commands for a pattern for deletion.\n */\n    static void\nau_remove_cmds(AutoPat *ap)\n{\n    AutoCmd *ac;\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n    {\n\tvim_free(ac->cmd);\n\tac->cmd = NULL;\n    }\n    au_need_clean = TRUE;\n}\n\n/*\n * Cleanup autocommands and patterns that have been deleted.\n * This is only done when not executing autocommands.\n */\n    static void\nau_cleanup(void)\n{\n    AutoPat\t*ap, **prev_ap;\n    AutoCmd\t*ac, **prev_ac;\n    event_T\tevent;\n\n    if (autocmd_busy || !au_need_clean)\n\treturn;\n\n    /* loop over all events */\n    for (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n    {\n\t/* loop over all autocommand patterns */\n\tprev_ap = &(first_autopat[(int)event]);\n\tfor (ap = *prev_ap; ap != NULL; ap = *prev_ap)\n\t{\n\t    /* loop over all commands for this pattern */\n\t    prev_ac = &(ap->cmds);\n\t    for (ac = *prev_ac; ac != NULL; ac = *prev_ac)\n\t    {\n\t\t/* remove the command if the pattern is to be deleted or when\n\t\t * the command has been marked for deletion */\n\t\tif (ap->pat == NULL || ac->cmd == NULL)\n\t\t{\n\t\t    *prev_ac = ac->next;\n\t\t    vim_free(ac->cmd);\n\t\t    vim_free(ac);\n\t\t}\n\t\telse\n\t\t    prev_ac = &(ac->next);\n\t    }\n\n\t    /* remove the pattern if it has been marked for deletion */\n\t    if (ap->pat == NULL)\n\t    {\n\t\t*prev_ap = ap->next;\n\t\tvim_regfree(ap->reg_prog);\n\t\tvim_free(ap);\n\t    }\n\t    else\n\t\tprev_ap = &(ap->next);\n\t}\n    }\n\n    au_need_clean = FALSE;\n}\n\n/*\n * Called when buffer is freed, to remove/invalidate related buffer-local\n * autocmds.\n */\n    void\naubuflocal_remove(buf_T *buf)\n{\n    AutoPat\t*ap;\n    event_T\tevent;\n    AutoPatCmd\t*apc;\n\n    /* invalidate currently executing autocommands */\n    for (apc = active_apc_list; apc; apc = apc->next)\n\tif (buf->b_fnum == apc->arg_bufnr)\n\t    apc->arg_bufnr = 0;\n\n    /* invalidate buflocals looping through events */\n    for (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t/* loop over all autocommand patterns */\n\tfor (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\t    if (ap->buflocal_nr == buf->b_fnum)\n\t    {\n\t\tau_remove_pat(ap);\n\t\tif (p_verbose >= 6)\n\t\t{\n\t\t    verbose_enter();\n\t\t    smsg((char_u *)\n\t\t\t    _(\"auto-removing autocommand: %s <buffer=%d>\"),\n\t\t\t\t\t   event_nr2name(event), buf->b_fnum);\n\t\t    verbose_leave();\n\t\t}\n\t    }\n    au_cleanup();\n}\n\n/*\n * Add an autocmd group name.\n * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_new_group(char_u *name)\n{\n    int\t\ti;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t/* the group doesn't exist yet, add it */\n    {\n\t/* First try using a free entry. */\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t    if (AUGROUP_NAME(i) == NULL)\n\t\tbreak;\n\tif (i == augroups.ga_len && ga_grow(&augroups, 1) == FAIL)\n\t    return AUGROUP_ERROR;\n\n\tAUGROUP_NAME(i) = vim_strsave(name);\n\tif (AUGROUP_NAME(i) == NULL)\n\t    return AUGROUP_ERROR;\n\tif (i == augroups.ga_len)\n\t    ++augroups.ga_len;\n    }\n\n    return i;\n}\n\n    static void\nau_del_group(char_u *name)\n{\n    int\t    i;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t/* the group doesn't exist */\n\tEMSG2(_(\"E367: No such group: \\\"%s\\\"\"), name);\n    else if (i == current_augroup)\n\tEMSG(_(\"E936: Cannot delete the current group\"));\n    else\n    {\n\tevent_T\tevent;\n\tAutoPat\t*ap;\n\tint\tin_use = FALSE;\n\n\tfor (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t{\n\t    for (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\t\tif (ap->group == i && ap->pat != NULL)\n\t\t{\n\t\t    give_warning((char_u *)_(\"W19: Deleting augroup that is still in use\"), TRUE);\n\t\t    in_use = TRUE;\n\t\t    event = NUM_EVENTS;\n\t\t    break;\n\t\t}\n\t}\n\tvim_free(AUGROUP_NAME(i));\n\tif (in_use)\n\t{\n\t    AUGROUP_NAME(i) = get_deleted_augroup();\n\t}\n\telse\n\t    AUGROUP_NAME(i) = NULL;\n    }\n}\n\n/*\n * Find the ID of an autocmd group name.\n * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_find_group(char_u *name)\n{\n    int\t    i;\n\n    for (i = 0; i < augroups.ga_len; ++i)\n\tif (AUGROUP_NAME(i) != NULL && AUGROUP_NAME(i) != get_deleted_augroup()\n\t\t&& STRCMP(AUGROUP_NAME(i), name) == 0)\n\t    return i;\n    return AUGROUP_ERROR;\n}\n\n/*\n * Return TRUE if augroup \"name\" exists.\n */\n    int\nau_has_group(char_u *name)\n{\n    return au_find_group(name) != AUGROUP_ERROR;\n}\n\n/*\n * \":augroup {name}\".\n */\n    void\ndo_augroup(char_u *arg, int del_group)\n{\n    int\t    i;\n\n    if (del_group)\n    {\n\tif (*arg == NUL)\n\t    EMSG(_(e_argreq));\n\telse\n\t    au_del_group(arg);\n    }\n    else if (STRICMP(arg, \"end\") == 0)   /* \":aug end\": back to group 0 */\n\tcurrent_augroup = AUGROUP_DEFAULT;\n    else if (*arg)\t\t    /* \":aug xxx\": switch to group xxx */\n    {\n\ti = au_new_group(arg);\n\tif (i != AUGROUP_ERROR)\n\t    current_augroup = i;\n    }\n    else\t\t\t    /* \":aug\": list the group names */\n    {\n\tmsg_start();\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t{\n\t    if (AUGROUP_NAME(i) != NULL)\n\t    {\n\t\tmsg_puts(AUGROUP_NAME(i));\n\t\tmsg_puts((char_u *)\"  \");\n\t    }\n\t}\n\tmsg_clr_eos();\n\tmsg_end();\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_autocmds(void)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    for (current_augroup = -1; current_augroup < augroups.ga_len;\n\t\t\t\t\t\t\t    ++current_augroup)\n\tdo_autocmd((char_u *)\"\", TRUE);\n\n    for (i = 0; i < augroups.ga_len; ++i)\n    {\n\ts = ((char_u **)(augroups.ga_data))[i];\n\tif (s != get_deleted_augroup())\n\t    vim_free(s);\n    }\n    ga_clear(&augroups);\n}\n#endif\n\n/*\n * Return the event number for event name \"start\".\n * Return NUM_EVENTS if the event name was not found.\n * Return a pointer to the next event name in \"end\".\n */\n    static event_T\nevent_name2nr(char_u *start, char_u **end)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tlen;\n\n    /* the event name ends with end of line, '|', a blank or a comma */\n    for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)\n\t;\n    for (i = 0; event_names[i].name != NULL; ++i)\n    {\n\tlen = (int)STRLEN(event_names[i].name);\n\tif (len == p - start && STRNICMP(event_names[i].name, start, len) == 0)\n\t    break;\n    }\n    if (*p == ',')\n\t++p;\n    *end = p;\n    if (event_names[i].name == NULL)\n\treturn NUM_EVENTS;\n    return event_names[i].event;\n}\n\n/*\n * Return the name for event \"event\".\n */\n    static char_u *\nevent_nr2name(event_T event)\n{\n    int\t    i;\n\n    for (i = 0; event_names[i].name != NULL; ++i)\n\tif (event_names[i].event == event)\n\t    return (char_u *)event_names[i].name;\n    return (char_u *)\"Unknown\";\n}\n\n/*\n * Scan over the events.  \"*\" stands for all events.\n */\n    static char_u *\nfind_end_event(\n    char_u  *arg,\n    int\t    have_group)\t    /* TRUE when group name was found */\n{\n    char_u  *pat;\n    char_u  *p;\n\n    if (*arg == '*')\n    {\n\tif (arg[1] && !VIM_ISWHITE(arg[1]))\n\t{\n\t    EMSG2(_(\"E215: Illegal character after *: %s\"), arg);\n\t    return NULL;\n\t}\n\tpat = arg + 1;\n    }\n    else\n    {\n\tfor (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)\n\t{\n\t    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)\n\t    {\n\t\tif (have_group)\n\t\t    EMSG2(_(\"E216: No such event: %s\"), pat);\n\t\telse\n\t\t    EMSG2(_(\"E216: No such group or event: %s\"), pat);\n\t\treturn NULL;\n\t    }\n\t}\n    }\n    return pat;\n}\n\n/*\n * Return TRUE if \"event\" is included in 'eventignore'.\n */\n    static int\nevent_ignored(event_T event)\n{\n    char_u\t*p = p_ei;\n\n    while (*p != NUL)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t    return TRUE;\n\tif (event_name2nr(p, &p) == event)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Return OK when the contents of p_ei is valid, FAIL otherwise.\n */\n    int\ncheck_ei(void)\n{\n    char_u\t*p = p_ei;\n\n    while (*p)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t{\n\t    p += 3;\n\t    if (*p == ',')\n\t\t++p;\n\t}\n\telse if (event_name2nr(p, &p) == NUM_EVENTS)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n# if defined(FEAT_SYN_HL) || defined(PROTO)\n\n/*\n * Add \"what\" to 'eventignore' to skip loading syntax highlighting for every\n * buffer loaded into the window.  \"what\" must start with a comma.\n * Returns the old value of 'eventignore' in allocated memory.\n */\n    char_u *\nau_event_disable(char *what)\n{\n    char_u\t*new_ei;\n    char_u\t*save_ei;\n\n    save_ei = vim_strsave(p_ei);\n    if (save_ei != NULL)\n    {\n\tnew_ei = vim_strnsave(p_ei, (int)(STRLEN(p_ei) + STRLEN(what)));\n\tif (new_ei != NULL)\n\t{\n\t    if (*what == ',' && *p_ei == NUL)\n\t\tSTRCPY(new_ei, what + 1);\n\t    else\n\t\tSTRCAT(new_ei, what);\n\t    set_string_option_direct((char_u *)\"ei\", -1, new_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\t    vim_free(new_ei);\n\t}\n    }\n    return save_ei;\n}\n\n    void\nau_event_restore(char_u *old_ei)\n{\n    if (old_ei != NULL)\n    {\n\tset_string_option_direct((char_u *)\"ei\", -1, old_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\tvim_free(old_ei);\n    }\n}\n# endif  /* FEAT_SYN_HL */\n\n/*\n * do_autocmd() -- implements the :autocmd command.  Can be used in the\n *  following ways:\n *\n * :autocmd <event> <pat> <cmd>\t    Add <cmd> to the list of commands that\n *\t\t\t\t    will be automatically executed for <event>\n *\t\t\t\t    when editing a file matching <pat>, in\n *\t\t\t\t    the current group.\n * :autocmd <event> <pat>\t    Show the auto-commands associated with\n *\t\t\t\t    <event> and <pat>.\n * :autocmd <event>\t\t    Show the auto-commands associated with\n *\t\t\t\t    <event>.\n * :autocmd\t\t\t    Show all auto-commands.\n * :autocmd! <event> <pat> <cmd>    Remove all auto-commands associated with\n *\t\t\t\t    <event> and <pat>, and add the command\n *\t\t\t\t    <cmd>, for the current group.\n * :autocmd! <event> <pat>\t    Remove all auto-commands associated with\n *\t\t\t\t    <event> and <pat> for the current group.\n * :autocmd! <event>\t\t    Remove all auto-commands associated with\n *\t\t\t\t    <event> for the current group.\n * :autocmd!\t\t\t    Remove ALL auto-commands for the current\n *\t\t\t\t    group.\n *\n *  Multiple events and patterns may be given separated by commas.  Here are\n *  some examples:\n * :autocmd bufread,bufenter *.c,*.h\tset tw=0 smartindent noic\n * :autocmd bufleave\t     *\t\tset tw=79 nosmartindent ic infercase\n *\n * :autocmd * *.c\t\tshow all autocommands for *.c files.\n *\n * Mostly a {group} argument can optionally appear before <event>.\n */\n    void\ndo_autocmd(char_u *arg_in, int forceit)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*pat;\n    char_u\t*envpat = NULL;\n    char_u\t*cmd;\n    event_T\tevent;\n    int\t\tneed_free = FALSE;\n    int\t\tnested = FALSE;\n    int\t\tgroup;\n\n    if (*arg == '|')\n    {\n\targ = (char_u *)\"\";\n\tgroup = AUGROUP_ALL;\t/* no argument, use all groups */\n    }\n    else\n    {\n\t/*\n\t * Check for a legal group name.  If not, use AUGROUP_ALL.\n\t */\n\tgroup = au_get_grouparg(&arg);\n\tif (arg == NULL)\t    /* out of memory */\n\t    return;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    pat = find_end_event(arg, group != AUGROUP_ALL);\n    if (pat == NULL)\n\treturn;\n\n    pat = skipwhite(pat);\n    if (*pat == '|')\n    {\n\tpat = (char_u *)\"\";\n\tcmd = (char_u *)\"\";\n    }\n    else\n    {\n\t/*\n\t * Scan over the pattern.  Put a NUL at the end.\n\t */\n\tcmd = pat;\n\twhile (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\\\'))\n\t    cmd++;\n\tif (*cmd)\n\t    *cmd++ = NUL;\n\n\t/* Expand environment variables in the pattern.  Set 'shellslash', we want\n\t * forward slashes here. */\n\tif (vim_strchr(pat, '$') != NULL || vim_strchr(pat, '~') != NULL)\n\t{\n#ifdef BACKSLASH_IN_FILENAME\n\t    int\tp_ssl_save = p_ssl;\n\n\t    p_ssl = TRUE;\n#endif\n\t    envpat = expand_env_save(pat);\n#ifdef BACKSLASH_IN_FILENAME\n\t    p_ssl = p_ssl_save;\n#endif\n\t    if (envpat != NULL)\n\t\tpat = envpat;\n\t}\n\n\t/*\n\t * Check for \"nested\" flag.\n\t */\n\tcmd = skipwhite(cmd);\n\tif (*cmd != NUL && STRNCMP(cmd, \"nested\", 6) == 0 && VIM_ISWHITE(cmd[6]))\n\t{\n\t    nested = TRUE;\n\t    cmd = skipwhite(cmd + 6);\n\t}\n\n\t/*\n\t * Find the start of the commands.\n\t * Expand <sfile> in it.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    cmd = expand_sfile(cmd);\n\t    if (cmd == NULL)\t    /* some error */\n\t\treturn;\n\t    need_free = TRUE;\n\t}\n    }\n\n    /*\n     * Print header when showing autocommands.\n     */\n    if (!forceit && *cmd == NUL)\n    {\n\t/* Highlight title */\n\tMSG_PUTS_TITLE(_(\"\\n--- Auto-Commands ---\"));\n    }\n\n    /*\n     * Loop over the events.\n     */\n    last_event = (event_T)-1;\t\t/* for listing the event name */\n    last_group = AUGROUP_ERROR;\t\t/* for listing the group name */\n    if (*arg == '*' || *arg == NUL || *arg == '|')\n    {\n\tfor (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t    if (do_autocmd_event(event, pat,\n\t\t\t\t\t nested, cmd, forceit, group) == FAIL)\n\t\tbreak;\n    }\n    else\n    {\n\twhile (*arg && *arg != '|' && !VIM_ISWHITE(*arg))\n\t    if (do_autocmd_event(event_name2nr(arg, &arg), pat,\n\t\t\t\t\tnested,\tcmd, forceit, group) == FAIL)\n\t\tbreak;\n    }\n\n    if (need_free)\n\tvim_free(cmd);\n    vim_free(envpat);\n}\n\n/*\n * Find the group ID in a \":autocmd\" or \":doautocmd\" argument.\n * The \"argp\" argument is advanced to the following argument.\n *\n * Returns the group ID, AUGROUP_ERROR for error (out of memory).\n */\n    static int\nau_get_grouparg(char_u **argp)\n{\n    char_u\t*group_name;\n    char_u\t*p;\n    char_u\t*arg = *argp;\n    int\t\tgroup = AUGROUP_ALL;\n\n    for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)\n\t;\n    if (p > arg)\n    {\n\tgroup_name = vim_strnsave(arg, (int)(p - arg));\n\tif (group_name == NULL)\t\t/* out of memory */\n\t    return AUGROUP_ERROR;\n\tgroup = au_find_group(group_name);\n\tif (group == AUGROUP_ERROR)\n\t    group = AUGROUP_ALL;\t/* no match, use all groups */\n\telse\n\t    *argp = skipwhite(p);\t/* match, skip over group name */\n\tvim_free(group_name);\n    }\n    return group;\n}\n\n/*\n * do_autocmd() for one event.\n * If *pat == NUL do for all patterns.\n * If *cmd == NUL show entries.\n * If forceit == TRUE delete entries.\n * If group is not AUGROUP_ALL, only use this group.\n */\n    static int\ndo_autocmd_event(\n    event_T\tevent,\n    char_u\t*pat,\n    int\t\tnested,\n    char_u\t*cmd,\n    int\t\tforceit,\n    int\t\tgroup)\n{\n    AutoPat\t*ap;\n    AutoPat\t**prev_ap;\n    AutoCmd\t*ac;\n    AutoCmd\t**prev_ac;\n    int\t\tbrace_level;\n    char_u\t*endpat;\n    int\t\tfindgroup;\n    int\t\tallgroups;\n    int\t\tpatlen;\n    int\t\tis_buflocal;\n    int\t\tbuflocal_nr;\n    char_u\tbuflocal_pat[25];\t/* for \"<buffer=X>\" */\n\n    if (group == AUGROUP_ALL)\n\tfindgroup = current_augroup;\n    else\n\tfindgroup = group;\n    allgroups = (group == AUGROUP_ALL && !forceit && *cmd == NUL);\n\n    /*\n     * Show or delete all patterns for an event.\n     */\n    if (*pat == NUL)\n    {\n\tfor (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\t{\n\t    if (forceit)  /* delete the AutoPat, if it's in the current group */\n\t    {\n\t\tif (ap->group == findgroup)\n\t\t    au_remove_pat(ap);\n\t    }\n\t    else if (group == AUGROUP_ALL || ap->group == group)\n\t\tshow_autocmd(ap, event);\n\t}\n    }\n\n    /*\n     * Loop through all the specified patterns.\n     */\n    for ( ; *pat; pat = (*endpat == ',' ? endpat + 1 : endpat))\n    {\n\t/*\n\t * Find end of the pattern.\n\t * Watch out for a comma in braces, like \"*.\\{obj,o\\}\".\n\t */\n\tbrace_level = 0;\n\tfor (endpat = pat; *endpat && (*endpat != ',' || brace_level\n\t\t\t   || (endpat > pat && endpat[-1] == '\\\\')); ++endpat)\n\t{\n\t    if (*endpat == '{')\n\t\tbrace_level++;\n\t    else if (*endpat == '}')\n\t\tbrace_level--;\n\t}\n\tif (pat == endpat)\t\t/* ignore single comma */\n\t    continue;\n\tpatlen = (int)(endpat - pat);\n\n\t/*\n\t * detect special <buflocal[=X]> buffer-local patterns\n\t */\n\tis_buflocal = FALSE;\n\tbuflocal_nr = 0;\n\n\tif (patlen >= 8 && STRNCMP(pat, \"<buffer\", 7) == 0\n\t\t\t\t\t\t    && pat[patlen - 1] == '>')\n\t{\n\t    /* \"<buffer...>\": Error will be printed only for addition.\n\t     * printing and removing will proceed silently. */\n\t    is_buflocal = TRUE;\n\t    if (patlen == 8)\n\t\t/* \"<buffer>\" */\n\t\tbuflocal_nr = curbuf->b_fnum;\n\t    else if (patlen > 9 && pat[7] == '=')\n\t    {\n\t\tif (patlen == 13 && STRNICMP(pat, \"<buffer=abuf>\", 13) == 0)\n\t\t    /* \"<buffer=abuf>\" */\n\t\t    buflocal_nr = autocmd_bufnr;\n\t\telse if (skipdigits(pat + 8) == pat + patlen - 1)\n\t\t    /* \"<buffer=123>\" */\n\t\t    buflocal_nr = atoi((char *)pat + 8);\n\t    }\n\t}\n\n\tif (is_buflocal)\n\t{\n\t    /* normalize pat into standard \"<buffer>#N\" form */\n\t    sprintf((char *)buflocal_pat, \"<buffer=%d>\", buflocal_nr);\n\t    pat = buflocal_pat;\t\t\t/* can modify pat and patlen */\n\t    patlen = (int)STRLEN(buflocal_pat);\t/*   but not endpat */\n\t}\n\n\t/*\n\t * Find AutoPat entries with this pattern.\n\t */\n\tprev_ap = &first_autopat[(int)event];\n\twhile ((ap = *prev_ap) != NULL)\n\t{\n\t    if (ap->pat != NULL)\n\t    {\n\t\t/* Accept a pattern when:\n\t\t * - a group was specified and it's that group, or a group was\n\t\t *   not specified and it's the current group, or a group was\n\t\t *   not specified and we are listing\n\t\t * - the length of the pattern matches\n\t\t * - the pattern matches.\n\t\t * For <buffer[=X]>, this condition works because we normalize\n\t\t * all buffer-local patterns.\n\t\t */\n\t\tif ((allgroups || ap->group == findgroup)\n\t\t\t&& ap->patlen == patlen\n\t\t\t&& STRNCMP(pat, ap->pat, patlen) == 0)\n\t\t{\n\t\t    /*\n\t\t     * Remove existing autocommands.\n\t\t     * If adding any new autocmd's for this AutoPat, don't\n\t\t     * delete the pattern from the autopat list, append to\n\t\t     * this list.\n\t\t     */\n\t\t    if (forceit)\n\t\t    {\n\t\t\tif (*cmd != NUL && ap->next == NULL)\n\t\t\t{\n\t\t\t    au_remove_cmds(ap);\n\t\t\t    break;\n\t\t\t}\n\t\t\tau_remove_pat(ap);\n\t\t    }\n\n\t\t    /*\n\t\t     * Show autocmd's for this autopat, or buflocals <buffer=X>\n\t\t     */\n\t\t    else if (*cmd == NUL)\n\t\t\tshow_autocmd(ap, event);\n\n\t\t    /*\n\t\t     * Add autocmd to this autopat, if it's the last one.\n\t\t     */\n\t\t    else if (ap->next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    prev_ap = &ap->next;\n\t}\n\n\t/*\n\t * Add a new command.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    /*\n\t     * If the pattern we want to add a command to does appear at the\n\t     * end of the list (or not is not in the list at all), add the\n\t     * pattern at the end of the list.\n\t     */\n\t    if (ap == NULL)\n\t    {\n\t\t/* refuse to add buffer-local ap if buffer number is invalid */\n\t\tif (is_buflocal && (buflocal_nr == 0\n\t\t\t\t      || buflist_findnr(buflocal_nr) == NULL))\n\t\t{\n\t\t    EMSGN(_(\"E680: <buffer=%d>: invalid buffer number \"),\n\t\t\t\t\t\t\t\t buflocal_nr);\n\t\t    return FAIL;\n\t\t}\n\n\t\tap = (AutoPat *)alloc((unsigned)sizeof(AutoPat));\n\t\tif (ap == NULL)\n\t\t    return FAIL;\n\t\tap->pat = vim_strnsave(pat, patlen);\n\t\tap->patlen = patlen;\n\t\tif (ap->pat == NULL)\n\t\t{\n\t\t    vim_free(ap);\n\t\t    return FAIL;\n\t\t}\n\n\t\tif (is_buflocal)\n\t\t{\n\t\t    ap->buflocal_nr = buflocal_nr;\n\t\t    ap->reg_prog = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t*reg_pat;\n\n\t\t    ap->buflocal_nr = 0;\n\t\t    reg_pat = file_pat_to_reg_pat(pat, endpat,\n\t\t\t\t\t\t\t &ap->allow_dirs, TRUE);\n\t\t    if (reg_pat != NULL)\n\t\t\tap->reg_prog = vim_regcomp(reg_pat, RE_MAGIC);\n\t\t    vim_free(reg_pat);\n\t\t    if (reg_pat == NULL || ap->reg_prog == NULL)\n\t\t    {\n\t\t\tvim_free(ap->pat);\n\t\t\tvim_free(ap);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t\tap->cmds = NULL;\n\t\t*prev_ap = ap;\n\t\tap->next = NULL;\n\t\tif (group == AUGROUP_ALL)\n\t\t    ap->group = current_augroup;\n\t\telse\n\t\t    ap->group = group;\n\t    }\n\n\t    /*\n\t     * Add the autocmd at the end of the AutoCmd list.\n\t     */\n\t    prev_ac = &(ap->cmds);\n\t    while ((ac = *prev_ac) != NULL)\n\t\tprev_ac = &ac->next;\n\t    ac = (AutoCmd *)alloc((unsigned)sizeof(AutoCmd));\n\t    if (ac == NULL)\n\t\treturn FAIL;\n\t    ac->cmd = vim_strsave(cmd);\n#ifdef FEAT_EVAL\n\t    ac->scriptID = current_SID;\n#endif\n\t    if (ac->cmd == NULL)\n\t    {\n\t\tvim_free(ac);\n\t\treturn FAIL;\n\t    }\n\t    ac->next = NULL;\n\t    *prev_ac = ac;\n\t    ac->nested = nested;\n\t}\n    }\n\n    au_cleanup();\t/* may really delete removed patterns/commands now */\n    return OK;\n}\n\n/*\n * Implementation of \":doautocmd [group] event [fname]\".\n * Return OK for success, FAIL for failure;\n */\n    int\ndo_doautocmd(\n    char_u\t*arg,\n    int\t\tdo_msg,\t    /* give message for no matching autocmds? */\n    int\t\t*did_something)\n{\n    char_u\t*fname;\n    int\t\tnothing_done = TRUE;\n    int\t\tgroup;\n\n    if (did_something != NULL)\n\t*did_something = FALSE;\n\n    /*\n     * Check for a legal group name.  If not, use AUGROUP_ALL.\n     */\n    group = au_get_grouparg(&arg);\n    if (arg == NULL)\t    /* out of memory */\n\treturn FAIL;\n\n    if (*arg == '*')\n    {\n\tEMSG(_(\"E217: Can't execute autocommands for ALL events\"));\n\treturn FAIL;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    fname = find_end_event(arg, group != AUGROUP_ALL);\n    if (fname == NULL)\n\treturn FAIL;\n\n    fname = skipwhite(fname);\n\n    /*\n     * Loop over the events.\n     */\n    while (*arg && !ends_excmd(*arg) && !VIM_ISWHITE(*arg))\n\tif (apply_autocmds_group(event_name2nr(arg, &arg),\n\t\t\t\t      fname, NULL, TRUE, group, curbuf, NULL))\n\t    nothing_done = FALSE;\n\n    if (nothing_done && do_msg)\n\tMSG(_(\"No matching autocommands\"));\n    if (did_something != NULL)\n\t*did_something = !nothing_done;\n\n#ifdef FEAT_EVAL\n    return aborting() ? FAIL : OK;\n#else\n    return OK;\n#endif\n}\n\n/*\n * \":doautoall\": execute autocommands for each loaded buffer.\n */\n    void\nex_doautoall(exarg_T *eap)\n{\n    int\t\tretval;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    /*\n     * This is a bit tricky: For some commands curwin->w_buffer needs to be\n     * equal to curbuf, but for some buffers there may not be a window.\n     * So we change the buffer for the current window for a moment.  This\n     * gives problems when the autocommands make changes to the list of\n     * buffers or windows...\n     */\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_ml.ml_mfp != NULL)\n\t{\n\t    /* find a window for this buffer and save some values */\n\t    aucmd_prepbuf(&aco, buf);\n\t    set_bufref(&bufref, buf);\n\n\t    /* execute the autocommands for this buffer */\n\t    retval = do_doautocmd(arg, FALSE, &did_aucmd);\n\n\t    if (call_do_modelines && did_aucmd)\n\t    {\n\t\t/* Execute the modeline settings, but don't set window-local\n\t\t * options if we are using the current window for another\n\t\t * buffer. */\n\t\tdo_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);\n\t    }\n\n\t    /* restore the current window */\n\t    aucmd_restbuf(&aco);\n\n\t    /* stop if there is some error or buffer was deleted */\n\t    if (retval == FAIL || !bufref_valid(&bufref))\n\t\tbreak;\n\t}\n    }\n\n    check_cursor();\t    /* just in case lines got deleted */\n}\n\n/*\n * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise\n * return TRUE and advance *argp to after it.\n * Thus return TRUE when do_modelines() should be called.\n */\n    int\ncheck_nomodeline(char_u **argp)\n{\n    if (STRNCMP(*argp, \"<nomodeline>\", 12) == 0)\n    {\n\t*argp = skipwhite(*argp + 12);\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Prepare for executing autocommands for (hidden) buffer \"buf\".\n * Search for a visible window containing the current buffer.  If there isn't\n * one then use \"aucmd_win\".\n * Set \"curbuf\" and \"curwin\" to match \"buf\".\n * When FEAT_AUTOCMD is not defined another version is used, see below.\n */\n    void\naucmd_prepbuf(\n    aco_save_T\t*aco,\t\t/* structure to save values in */\n    buf_T\t*buf)\t\t/* new curbuf */\n{\n    win_T\t*win;\n    int\t\tsave_ea;\n#ifdef FEAT_AUTOCHDIR\n    int\t\tsave_acd;\n#endif\n\n    /* Find a window that is for the new buffer */\n    if (buf == curbuf)\t\t/* be quick when buf is curbuf */\n\twin = curwin;\n    else\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer == buf)\n\t\tbreak;\n\n    /* Allocate \"aucmd_win\" when needed.  If this fails (out of memory) fall\n     * back to using the current window. */\n    if (win == NULL && aucmd_win == NULL)\n    {\n\twin_alloc_aucmd_win();\n\tif (aucmd_win == NULL)\n\t    win = curwin;\n    }\n    if (win == NULL && aucmd_win_used)\n\t/* Strange recursive autocommand, fall back to using the current\n\t * window.  Expect a few side effects... */\n\twin = curwin;\n\n    aco->save_curwin = curwin;\n    aco->save_curbuf = curbuf;\n    if (win != NULL)\n    {\n\t/* There is a window for \"buf\" in the current tab page, make it the\n\t * curwin.  This is preferred, it has the least side effects (esp. if\n\t * \"buf\" is curbuf). */\n\taco->use_aucmd_win = FALSE;\n\tcurwin = win;\n    }\n    else\n    {\n\t/* There is no window for \"buf\", use \"aucmd_win\".  To minimize the side\n\t * effects, insert it in the current tab page.\n\t * Anything related to a window (e.g., setting folds) may have\n\t * unexpected results. */\n\taco->use_aucmd_win = TRUE;\n\taucmd_win_used = TRUE;\n\taucmd_win->w_buffer = buf;\n\taucmd_win->w_s = &buf->b_s;\n\t++buf->b_nwindows;\n\twin_init_empty(aucmd_win); /* set cursor and topline to safe values */\n\n\t/* Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n\t * win_enter_ext(). */\n\tvim_free(aucmd_win->w_localdir);\n\taucmd_win->w_localdir = NULL;\n\taco->globaldir = globaldir;\n\tglobaldir = NULL;\n\n\n\t/* Split the current window, put the aucmd_win in the upper half.\n\t * We don't want the BufEnter or WinEnter autocommands. */\n\tblock_autocmds();\n\tmake_snapshot(SNAP_AUCMD_IDX);\n\tsave_ea = p_ea;\n\tp_ea = FALSE;\n\n#ifdef FEAT_AUTOCHDIR\n\t/* Prevent chdir() call in win_enter_ext(), through do_autochdir(). */\n\tsave_acd = p_acd;\n\tp_acd = FALSE;\n#endif\n\n\t(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);\n\t(void)win_comp_pos();   /* recompute window positions */\n\tp_ea = save_ea;\n#ifdef FEAT_AUTOCHDIR\n\tp_acd = save_acd;\n#endif\n\tunblock_autocmds();\n\tcurwin = aucmd_win;\n    }\n    curbuf = buf;\n    aco->new_curwin = curwin;\n    set_bufref(&aco->new_curbuf, curbuf);\n}\n\n/*\n * Cleanup after executing autocommands for a (hidden) buffer.\n * Restore the window as it was (if possible).\n * When FEAT_AUTOCMD is not defined another version is used, see below.\n */\n    void\naucmd_restbuf(\n    aco_save_T\t*aco)\t\t/* structure holding saved values */\n{\n    int dummy;\n\n    if (aco->use_aucmd_win)\n    {\n\t--curbuf->b_nwindows;\n\t/* Find \"aucmd_win\", it can't be closed, but it may be in another tab\n\t * page. Do not trigger autocommands here. */\n\tblock_autocmds();\n\tif (curwin != aucmd_win)\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t*wp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\tif (wp == aucmd_win)\n\t\t{\n\t\t    if (tp != curtab)\n\t\t\tgoto_tabpage_tp(tp, TRUE, TRUE);\n\t\t    win_goto(aucmd_win);\n\t\t    goto win_found;\n\t\t}\n\t    }\n\t}\nwin_found:\n\n\t/* Remove the window and frame from the tree of frames. */\n\t(void)winframe_remove(curwin, &dummy, NULL);\n\twin_remove(curwin, NULL);\n\taucmd_win_used = FALSE;\n\tlast_status(FALSE);\t    /* may need to remove last status line */\n\n\tif (!valid_tabpage_win(curtab))\n\t    /* no valid window in current tabpage */\n\t    close_tabpage(curtab);\n\n\trestore_snapshot(SNAP_AUCMD_IDX, FALSE);\n\t(void)win_comp_pos();   /* recompute window positions */\n\tunblock_autocmds();\n\n\tif (win_valid(aco->save_curwin))\n\t    curwin = aco->save_curwin;\n\telse\n\t    /* Hmm, original window disappeared.  Just use the first one. */\n\t    curwin = firstwin;\n#ifdef FEAT_EVAL\n\tvars_clear(&aucmd_win->w_vars->dv_hashtab);  /* free all w: variables */\n\thash_init(&aucmd_win->w_vars->dv_hashtab);   /* re-use the hashtab */\n#endif\n\tcurbuf = curwin->w_buffer;\n\n\tvim_free(globaldir);\n\tglobaldir = aco->globaldir;\n\n\t/* the buffer contents may have changed */\n\tcheck_cursor();\n\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n\t}\n#if defined(FEAT_GUI)\n\t/* Hide the scrollbars from the aucmd_win and update. */\n\tgui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);\n\tgui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);\n\tgui_may_update_scrollbars();\n#endif\n    }\n    else\n    {\n\t/* restore curwin */\n\tif (win_valid(aco->save_curwin))\n\t{\n\t    /* Restore the buffer which was previously edited by curwin, if\n\t     * it was changed, we are still the same window and the buffer is\n\t     * valid. */\n\t    if (curwin == aco->new_curwin\n\t\t    && curbuf != aco->new_curbuf.br_buf\n\t\t    && bufref_valid(&aco->new_curbuf)\n\t\t    && aco->new_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t    {\n# if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n\t\tif (curwin->w_s == &curbuf->b_s)\n\t\t    curwin->w_s = &aco->new_curbuf.br_buf->b_s;\n# endif\n\t\t--curbuf->b_nwindows;\n\t\tcurbuf = aco->new_curbuf.br_buf;\n\t\tcurwin->w_buffer = curbuf;\n\t\t++curbuf->b_nwindows;\n\t    }\n\n\t    curwin = aco->save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t    /* In case the autocommand move the cursor to a position that that\n\t     * not exist in curbuf. */\n\t    check_cursor();\n\t}\n    }\n}\n\nstatic int\tautocmd_nested = FALSE;\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    int\napply_autocmds(\n    event_T\tevent,\n    char_u\t*fname,\t    /* NULL or empty means use actual file name */\n    char_u\t*fname_io,  /* fname to use for <afile> on cmdline */\n    int\t\tforce,\t    /* when TRUE, ignore autocmd_busy */\n    buf_T\t*buf)\t    /* buffer for <abuf> */\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n}\n\n/*\n * Like apply_autocmds(), but with extra \"eap\" argument.  This takes care of\n * setting v:filearg.\n */\n    static int\napply_autocmds_exarg(\n    event_T\tevent,\n    char_u\t*fname,\n    char_u\t*fname_io,\n    int\t\tforce,\n    buf_T\t*buf,\n    exarg_T\t*eap)\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t       AUGROUP_ALL, buf, eap);\n}\n\n/*\n * Like apply_autocmds(), but handles the caller's retval.  If the script\n * processing is being aborted or if retval is FAIL when inside a try\n * conditional, no autocommands are executed.  If otherwise the autocommands\n * cause the script to be aborted, retval is set to FAIL.\n */\n    int\napply_autocmds_retval(\n    event_T\tevent,\n    char_u\t*fname,\t    /* NULL or empty means use actual file name */\n    char_u\t*fname_io,  /* fname to use for <afile> on cmdline */\n    int\t\tforce,\t    /* when TRUE, ignore autocmd_busy */\n    buf_T\t*buf,\t    /* buffer for <abuf> */\n    int\t\t*retval)    /* pointer to caller's retval */\n{\n    int\t\tdid_cmd;\n\n#ifdef FEAT_EVAL\n    if (should_abort(*retval))\n\treturn FALSE;\n#endif\n\n    did_cmd = apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n    if (did_cmd\n#ifdef FEAT_EVAL\n\t    && aborting()\n#endif\n\t    )\n\t*retval = FAIL;\n    return did_cmd;\n}\n\n/*\n * Return TRUE when there is a CursorHold autocommand defined.\n */\n    int\nhas_cursorhold(void)\n{\n    return (first_autopat[(int)(get_real_state() == NORMAL_BUSY\n\t\t\t    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);\n}\n\n/*\n * Return TRUE if the CursorHold event can be triggered.\n */\n    int\ntrigger_cursorhold(void)\n{\n    int\t\tstate;\n\n    if (!did_cursorhold\n\t    && has_cursorhold()\n\t    && !Recording\n\t    && typebuf.tb_len == 0\n#ifdef FEAT_INS_EXPAND\n\t    && !ins_compl_active()\n#endif\n\t    )\n    {\n\tstate = get_real_state();\n\tif (state == NORMAL_BUSY || (state & INSERT) != 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE when there is a CursorMoved autocommand defined.\n */\n    int\nhas_cursormoved(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);\n}\n\n/*\n * Return TRUE when there is a CursorMovedI autocommand defined.\n */\n    int\nhas_cursormovedI(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChanged autocommand defined.\n */\n    int\nhas_textchanged(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChangedI autocommand defined.\n */\n    int\nhas_textchangedI(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is an InsertCharPre autocommand defined.\n */\n    int\nhas_insertcharpre(void)\n{\n    return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);\n}\n\n/*\n * Return TRUE when there is an CmdUndefined autocommand defined.\n */\n    int\nhas_cmdundefined(void)\n{\n    return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);\n}\n\n/*\n * Return TRUE when there is an FuncUndefined autocommand defined.\n */\n    int\nhas_funcundefined(void)\n{\n    return (first_autopat[(int)EVENT_FUNCUNDEFINED] != NULL);\n}\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    static int\napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t    /* NULL or empty means use actual file name */\n    char_u\t*fname_io,  /* fname to use for <afile> on cmdline, NULL means\n\t\t\t       use fname */\n    int\t\tforce,\t    /* when TRUE, ignore autocmd_busy */\n    int\t\tgroup,\t    /* group ID, or AUGROUP_ALL */\n    buf_T\t*buf,\t    /* buffer for <abuf> */\n    exarg_T\t*eap)\t    /* command arguments */\n{\n    char_u\t*sfname = NULL;\t/* short file name */\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_sourcing_name;\n    linenr_T\tsave_sourcing_lnum;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd\tpatcmd;\n    AutoPat\t*ap;\n#ifdef FEAT_EVAL\n    scid_T\tsave_current_SID;\n    void\t*save_funccalp;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\tEMSG(_(\"E218: autocommand nesting too deep\"));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_OPTIONSET)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; /* call FullName_save() later */\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t/* make a copy, so we can change it */\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t * ColorScheme or QuickFixCmd* */\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST)\n\t    fname = vim_strsave(fname);\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    /* out of memory */\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    /* remove version for correct match */\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    /* Don't redraw while doing auto commands. */\n    ++RedrawingDisabled;\n    save_sourcing_name = sourcing_name;\n    sourcing_name = NULL;\t/* don't free this one */\n    save_sourcing_lnum = sourcing_lnum;\n    sourcing_lnum = 0;\t\t/* no line number here */\n\n#ifdef FEAT_EVAL\n    save_current_SID = current_SID;\n\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); /* doesn't count for the caller itself */\n# endif\n\n    /* Don't use local function variables, if called from a function */\n    save_funccalp = save_funccal();\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n#ifdef FEAT_INS_EXPAND\n\tif (!ins_compl_active())\n#endif\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t/* see matching decrement below */\n\n    /* Remember that FileType was triggered.  Used for did_filetype(). */\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    /* Find first autocommand that matches */\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.nextcmd = NULL;\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    patcmd.next = NULL;\n    auto_next_pat(&patcmd, FALSE);\n\n    /* found one, start executing the autocommands */\n    if (patcmd.curpat != NULL)\n    {\n\t/* add to active_apc_list */\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t/* set v:cmdarg (only when there is a matching pattern) */\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t/* avoid gcc warning */\n#endif\n\tretval = TRUE;\n\t/* mark the last pattern, to avoid an endless loop when more patterns\n\t * are added when executing autocommands */\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\tcheck_lnums(TRUE);\t/* make sure cursor and topline are valid */\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t/* delete from active_apc_list */\n\tif (active_apc_list == &patcmd)\t    /* just in case */\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(sourcing_name);\n    sourcing_name = save_sourcing_name;\n    sourcing_lnum = save_sourcing_lnum;\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n#ifdef FEAT_EVAL\n    current_SID = save_current_SID;\n    restore_funccal(save_funccalp);\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t/* see matching increment above */\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n#ifdef FEAT_TITLE\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n#endif\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t/* may really delete removed patterns/commands now */\n\nBYPASS_AU:\n    /* When wiping out a buffer make sure all its buffer-local autocommands\n     * are deleted. */\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}\n\n# ifdef FEAT_EVAL\nstatic char_u\t*old_termresponse = NULL;\n# endif\n\n/*\n * Block triggering autocommands until unblock_autocmd() is called.\n * Can be used recursively, so long as it's symmetric.\n */\n    void\nblock_autocmds(void)\n{\n# ifdef FEAT_EVAL\n    /* Remember the value of v:termresponse. */\n    if (autocmd_blocked == 0)\n\told_termresponse = get_vim_var_str(VV_TERMRESPONSE);\n# endif\n    ++autocmd_blocked;\n}\n\n    void\nunblock_autocmds(void)\n{\n    --autocmd_blocked;\n\n# ifdef FEAT_EVAL\n    /* When v:termresponse was set while autocommands were blocked, trigger\n     * the autocommands now.  Esp. useful when executing a shell command\n     * during startup (vimdiff). */\n    if (autocmd_blocked == 0\n\t\t      && get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)\n\tapply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);\n# endif\n}\n\n    int\nis_autocmd_blocked(void)\n{\n    return autocmd_blocked != 0;\n}\n\n/*\n * Find next autocommand pattern that matches.\n */\n    static void\nauto_next_pat(\n    AutoPatCmd\t*apc,\n    int\t\tstop_at_last)\t    /* stop when 'last' flag is set */\n{\n    AutoPat\t*ap;\n    AutoCmd\t*cp;\n    char_u\t*name;\n    char\t*s;\n\n    vim_free(sourcing_name);\n    sourcing_name = NULL;\n\n    for (ap = apc->curpat; ap != NULL && !got_int; ap = ap->next)\n    {\n\tapc->curpat = NULL;\n\n\t/* Only use a pattern when it has not been removed, has commands and\n\t * the group matches. For buffer-local autocommands only check the\n\t * buffer number. */\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t\t&& (apc->group == AUGROUP_ALL || apc->group == ap->group))\n\t{\n\t    /* execution-condition */\n\t    if (ap->buflocal_nr == 0\n\t\t    ? (match_file_pat(NULL, &ap->reg_prog, apc->fname,\n\t\t\t\t      apc->sfname, apc->tail, ap->allow_dirs))\n\t\t    : ap->buflocal_nr == apc->arg_bufnr)\n\t    {\n\t\tname = event_nr2name(apc->event);\n\t\ts = _(\"%s Auto commands for \\\"%s\\\"\");\n\t\tsourcing_name = alloc((unsigned)(STRLEN(s)\n\t\t\t\t\t    + STRLEN(name) + ap->patlen + 1));\n\t\tif (sourcing_name != NULL)\n\t\t{\n\t\t    sprintf((char *)sourcing_name, s,\n\t\t\t\t\t       (char *)name, (char *)ap->pat);\n\t\t    if (p_verbose >= 8)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg((char_u *)_(\"Executing %s\"), sourcing_name);\n\t\t\tverbose_leave();\n\t\t    }\n\t\t}\n\n\t\tapc->curpat = ap;\n\t\tapc->nextcmd = ap->cmds;\n\t\t/* mark last command */\n\t\tfor (cp = ap->cmds; cp->next != NULL; cp = cp->next)\n\t\t    cp->last = FALSE;\n\t\tcp->last = TRUE;\n\t    }\n\t    line_breakcheck();\n\t    if (apc->curpat != NULL)\t    /* found a match */\n\t\tbreak;\n\t}\n\tif (stop_at_last && ap->last)\n\t    break;\n    }\n}\n\n/*\n * Get next autocommand command.\n * Called by do_cmdline() to get the next line for \":if\".\n * Returns allocated string, or NULL for end of autocommands.\n */\n    char_u *\ngetnextac(int c UNUSED, void *cookie, int indent UNUSED)\n{\n    AutoPatCmd\t    *acp = (AutoPatCmd *)cookie;\n    char_u\t    *retval;\n    AutoCmd\t    *ac;\n\n    /* Can be called again after returning the last line. */\n    if (acp->curpat == NULL)\n\treturn NULL;\n\n    /* repeat until we find an autocommand to execute */\n    for (;;)\n    {\n\t/* skip removed commands */\n\twhile (acp->nextcmd != NULL && acp->nextcmd->cmd == NULL)\n\t    if (acp->nextcmd->last)\n\t\tacp->nextcmd = NULL;\n\t    else\n\t\tacp->nextcmd = acp->nextcmd->next;\n\n\tif (acp->nextcmd != NULL)\n\t    break;\n\n\t/* at end of commands, find next pattern that matches */\n\tif (acp->curpat->last)\n\t    acp->curpat = NULL;\n\telse\n\t    acp->curpat = acp->curpat->next;\n\tif (acp->curpat != NULL)\n\t    auto_next_pat(acp, TRUE);\n\tif (acp->curpat == NULL)\n\t    return NULL;\n    }\n\n    ac = acp->nextcmd;\n\n    if (p_verbose >= 9)\n    {\n\tverbose_enter_scroll();\n\tsmsg((char_u *)_(\"autocommand %s\"), ac->cmd);\n\tmsg_puts((char_u *)\"\\n\");   /* don't overwrite this either */\n\tverbose_leave_scroll();\n    }\n    retval = vim_strsave(ac->cmd);\n    autocmd_nested = ac->nested;\n#ifdef FEAT_EVAL\n    current_SID = ac->scriptID;\n#endif\n    if (ac->last)\n\tacp->nextcmd = NULL;\n    else\n\tacp->nextcmd = ac->next;\n    return retval;\n}\n\n/*\n * Return TRUE if there is a matching autocommand for \"fname\".\n * To account for buffer-local autocommands, function needs to know\n * in which buffer the file will be opened.\n */\n    int\nhas_autocmd(event_T event, char_u *sfname, buf_T *buf)\n{\n    AutoPat\t*ap;\n    char_u\t*fname;\n    char_u\t*tail = gettail(sfname);\n    int\t\tretval = FALSE;\n\n    fname = FullName_save(sfname, FALSE);\n    if (fname == NULL)\n\treturn FALSE;\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    sfname = vim_strsave(sfname);\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n    for (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t      && (ap->buflocal_nr == 0\n\t\t? match_file_pat(NULL, &ap->reg_prog,\n\t\t\t\t\t  fname, sfname, tail, ap->allow_dirs)\n\t\t: buf != NULL && ap->buflocal_nr == buf->b_fnum\n\t   ))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\n    vim_free(fname);\n#ifdef BACKSLASH_IN_FILENAME\n    vim_free(sfname);\n#endif\n\n    return retval;\n}\n\n#if defined(FEAT_CMDL_COMPL) || defined(PROTO)\n/*\n * Function given to ExpandGeneric() to obtain the list of autocommand group\n * names.\n */\n    char_u *\nget_augroup_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx == augroups.ga_len)\t\t/* add \"END\" add the end */\n\treturn (char_u *)\"END\";\n    if (idx >= augroups.ga_len)\t\t/* end of list */\n\treturn NULL;\n    if (AUGROUP_NAME(idx) == NULL || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t/* skip deleted entries */\n\treturn (char_u *)\"\";\n    return AUGROUP_NAME(idx);\t\t/* return a name */\n}\n\nstatic int include_groups = FALSE;\n\n    char_u  *\nset_context_in_autocmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\tdoautocmd)\t/* TRUE for :doauto*, FALSE for :autocmd */\n{\n    char_u\t*p;\n    int\t\tgroup;\n\n    /* check for a group name, skip it if present */\n    include_groups = FALSE;\n    p = arg;\n    group = au_get_grouparg(&arg);\n    if (group == AUGROUP_ERROR)\n\treturn NULL;\n    /* If there only is a group name that's what we expand. */\n    if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))\n    {\n\targ = p;\n\tgroup = AUGROUP_ALL;\n    }\n\n    /* skip over event name */\n    for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)\n\tif (*p == ',')\n\t    arg = p + 1;\n    if (*p == NUL)\n    {\n\tif (group == AUGROUP_ALL)\n\t    include_groups = TRUE;\n\txp->xp_context = EXPAND_EVENTS;\t    /* expand event name */\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    /* skip over pattern */\n    arg = skipwhite(p);\n    while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\\\'))\n\targ++;\n    if (*arg)\n\treturn arg;\t\t\t    /* expand (next) command */\n\n    if (doautocmd)\n\txp->xp_context = EXPAND_FILES;\t    /* expand file names */\n    else\n\txp->xp_context = EXPAND_NOTHING;    /* pattern is not expanded */\n    return NULL;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of event names.\n */\n    char_u *\nget_event_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx < augroups.ga_len)\t\t/* First list group names, if wanted */\n    {\n\tif (!include_groups || AUGROUP_NAME(idx) == NULL\n\t\t\t\t || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t    return (char_u *)\"\";\t/* skip deleted entries */\n\treturn AUGROUP_NAME(idx);\t/* return a name */\n    }\n    return (char_u *)event_names[idx - augroups.ga_len].name;\n}\n\n#endif\t/* FEAT_CMDL_COMPL */\n\n/*\n * Return TRUE if autocmd is supported.\n */\n    int\nautocmd_supported(char_u *name)\n{\n    char_u *p;\n\n    return (event_name2nr(name, &p) != NUM_EVENTS);\n}\n\n/*\n * Return TRUE if an autocommand is defined for a group, event and\n * pattern:  The group can be omitted to accept any group. \"event\" and \"pattern\"\n * can be NULL to accept any event and pattern. \"pattern\" can be NULL to accept\n * any pattern. Buffer-local patterns <buffer> or <buffer=N> are accepted.\n * Used for:\n *\texists(\"#Group\") or\n *\texists(\"#Group#Event\") or\n *\texists(\"#Group#Event#pat\") or\n *\texists(\"#Event\") or\n *\texists(\"#Event#pat\")\n */\n    int\nau_exists(char_u *arg)\n{\n    char_u\t*arg_save;\n    char_u\t*pattern = NULL;\n    char_u\t*event_name;\n    char_u\t*p;\n    event_T\tevent;\n    AutoPat\t*ap;\n    buf_T\t*buflocal_buf = NULL;\n    int\t\tgroup;\n    int\t\tretval = FALSE;\n\n    /* Make a copy so that we can change the '#' chars to a NUL. */\n    arg_save = vim_strsave(arg);\n    if (arg_save == NULL)\n\treturn FALSE;\n    p = vim_strchr(arg_save, '#');\n    if (p != NULL)\n\t*p++ = NUL;\n\n    /* First, look for an autocmd group name */\n    group = au_find_group(arg_save);\n    if (group == AUGROUP_ERROR)\n    {\n\t/* Didn't match a group name, assume the first argument is an event. */\n\tgroup = AUGROUP_ALL;\n\tevent_name = arg_save;\n    }\n    else\n    {\n\tif (p == NULL)\n\t{\n\t    /* \"Group\": group name is present and it's recognized */\n\t    retval = TRUE;\n\t    goto theend;\n\t}\n\n\t/* Must be \"Group#Event\" or \"Group#Event#pat\". */\n\tevent_name = p;\n\tp = vim_strchr(event_name, '#');\n\tif (p != NULL)\n\t    *p++ = NUL;\t    /* \"Group#Event#pat\" */\n    }\n\n    pattern = p;\t    /* \"pattern\" is NULL when there is no pattern */\n\n    /* find the index (enum) for the event name */\n    event = event_name2nr(event_name, &p);\n\n    /* return FALSE if the event name is not recognized */\n    if (event == NUM_EVENTS)\n\tgoto theend;\n\n    /* Find the first autocommand for this event.\n     * If there isn't any, return FALSE;\n     * If there is one and no pattern given, return TRUE; */\n    ap = first_autopat[(int)event];\n    if (ap == NULL)\n\tgoto theend;\n\n    /* if pattern is \"<buffer>\", special handling is needed which uses curbuf */\n    /* for pattern \"<buffer=N>, fnamecmp() will work fine */\n    if (pattern != NULL && STRICMP(pattern, \"<buffer>\") == 0)\n\tbuflocal_buf = curbuf;\n\n    /* Check if there is an autocommand with the given pattern. */\n    for ( ; ap != NULL; ap = ap->next)\n\t/* only use a pattern when it has not been removed and has commands. */\n\t/* For buffer-local autocommands, fnamecmp() works fine. */\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t    && (group == AUGROUP_ALL || ap->group == group)\n\t    && (pattern == NULL\n\t\t|| (buflocal_buf == NULL\n\t\t    ? fnamecmp(ap->pat, pattern) == 0\n\t\t    : ap->buflocal_nr == buflocal_buf->b_fnum)))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\ntheend:\n    vim_free(arg_save);\n    return retval;\n}\n\n#else\t/* FEAT_AUTOCMD */\n\n/*\n * Prepare for executing commands for (hidden) buffer \"buf\".\n * This is the non-autocommand version, it simply saves \"curbuf\" and sets\n * \"curbuf\" and \"curwin\" to match \"buf\".\n */\n    void\naucmd_prepbuf(\n    aco_save_T\t*aco,\t\t/* structure to save values in */\n    buf_T\t*buf)\t\t/* new curbuf */\n{\n    aco->save_curbuf = curbuf;\n    --curbuf->b_nwindows;\n    curbuf = buf;\n    curwin->w_buffer = buf;\n    ++curbuf->b_nwindows;\n}\n\n/*\n * Restore after executing commands for a (hidden) buffer.\n * This is the non-autocommand version.\n */\n    void\naucmd_restbuf(\n    aco_save_T\t*aco)\t\t/* structure holding saved values */\n{\n    --curbuf->b_nwindows;\n    curbuf = aco->save_curbuf;\n    curwin->w_buffer = curbuf;\n    ++curbuf->b_nwindows;\n}\n\n#endif\t/* FEAT_AUTOCMD */\n\n\n#if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN) || defined(PROTO)\n/*\n * Try matching a filename with a \"pattern\" (\"prog\" is NULL), or use the\n * precompiled regprog \"prog\" (\"pattern\" is NULL).  That avoids calling\n * vim_regcomp() often.\n * Used for autocommands and 'wildignore'.\n * Returns TRUE if there is a match, FALSE otherwise.\n */\n    static int\nmatch_file_pat(\n    char_u\t*pattern,\t\t/* pattern to match with */\n    regprog_T\t**prog,\t\t\t/* pre-compiled regprog or NULL */\n    char_u\t*fname,\t\t\t/* full path of file name */\n    char_u\t*sfname,\t\t/* short file name or NULL */\n    char_u\t*tail,\t\t\t/* tail of path */\n    int\t\tallow_dirs)\t\t/* allow matching with dir */\n{\n    regmatch_T\tregmatch;\n    int\t\tresult = FALSE;\n\n    regmatch.rm_ic = p_fic; /* ignore case if 'fileignorecase' is set */\n    if (prog != NULL)\n\tregmatch.regprog = *prog;\n    else\n\tregmatch.regprog = vim_regcomp(pattern, RE_MAGIC);\n\n    /*\n     * Try for a match with the pattern with:\n     * 1. the full file name, when the pattern has a '/'.\n     * 2. the short file name, when the pattern has a '/'.\n     * 3. the tail of the file name, when the pattern has no '/'.\n     */\n    if (regmatch.regprog != NULL\n\t     && ((allow_dirs\n\t\t     && (vim_regexec(&regmatch, fname, (colnr_T)0)\n\t\t\t || (sfname != NULL\n\t\t\t     && vim_regexec(&regmatch, sfname, (colnr_T)0))))\n\t\t || (!allow_dirs && vim_regexec(&regmatch, tail, (colnr_T)0))))\n\tresult = TRUE;\n\n    if (prog != NULL)\n\t*prog = regmatch.regprog;\n    else\n\tvim_regfree(regmatch.regprog);\n    return result;\n}\n#endif\n\n#if defined(FEAT_WILDIGN) || defined(PROTO)\n/*\n * Return TRUE if a file matches with a pattern in \"list\".\n * \"list\" is a comma-separated list of patterns, like 'wildignore'.\n * \"sfname\" is the short file name or NULL, \"ffname\" the long file name.\n */\n    int\nmatch_file_list(char_u *list, char_u *sfname, char_u *ffname)\n{\n    char_u\tbuf[100];\n    char_u\t*tail;\n    char_u\t*regpat;\n    char\tallow_dirs;\n    int\t\tmatch;\n    char_u\t*p;\n\n    tail = gettail(sfname);\n\n    /* try all patterns in 'wildignore' */\n    p = list;\n    while (*p)\n    {\n\tcopy_option_part(&p, buf, 100, \",\");\n\tregpat = file_pat_to_reg_pat(buf, NULL, &allow_dirs, FALSE);\n\tif (regpat == NULL)\n\t    break;\n\tmatch = match_file_pat(regpat, NULL, ffname, sfname,\n\t\t\t\t\t\t       tail, (int)allow_dirs);\n\tvim_free(regpat);\n\tif (match)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Convert the given pattern \"pat\" which has shell style wildcards in it, into\n * a regular expression, and return the result in allocated memory.  If there\n * is a directory path separator to be matched, then TRUE is put in\n * allow_dirs, otherwise FALSE is put there -- webb.\n * Handle backslashes before special characters, like \"\\*\" and \"\\ \".\n *\n * Returns NULL when out of memory.\n */\n    char_u *\nfile_pat_to_reg_pat(\n    char_u\t*pat,\n    char_u\t*pat_end,\t/* first char after pattern or NULL */\n    char\t*allow_dirs,\t/* Result passed back out in here */\n    int\t\tno_bslash UNUSED) /* Don't use a backward slash as pathsep */\n{\n    int\t\tsize = 2; /* '^' at start, '$' at end */\n    char_u\t*endp;\n    char_u\t*reg_pat;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tnested = 0;\n    int\t\tadd_dollar = TRUE;\n\n    if (allow_dirs != NULL)\n\t*allow_dirs = FALSE;\n    if (pat_end == NULL)\n\tpat_end = pat + STRLEN(pat);\n\n    for (p = pat; p < pat_end; p++)\n    {\n\tswitch (*p)\n\t{\n\t    case '*':\n\t    case '.':\n\t    case ',':\n\t    case '{':\n\t    case '}':\n\t    case '~':\n\t\tsize += 2;\t/* extra backslash */\n\t\tbreak;\n#ifdef BACKSLASH_IN_FILENAME\n\t    case '\\\\':\n\t    case '/':\n\t\tsize += 4;\t/* could become \"[\\/]\" */\n\t\tbreak;\n#endif\n\t    default:\n\t\tsize++;\n# ifdef FEAT_MBYTE\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) > 1)\n\t\t{\n\t\t    ++p;\n\t\t    ++size;\n\t\t}\n# endif\n\t\tbreak;\n\t}\n    }\n    reg_pat = alloc(size + 1);\n    if (reg_pat == NULL)\n\treturn NULL;\n\n    i = 0;\n\n    if (pat[0] == '*')\n\twhile (pat[0] == '*' && pat < pat_end - 1)\n\t    pat++;\n    else\n\treg_pat[i++] = '^';\n    endp = pat_end - 1;\n    if (endp >= pat && *endp == '*')\n    {\n\twhile (endp - pat > 0 && *endp == '*')\n\t    endp--;\n\tadd_dollar = FALSE;\n    }\n    for (p = pat; *p && nested >= 0 && p <= endp; p++)\n    {\n\tswitch (*p)\n\t{\n\t    case '*':\n\t\treg_pat[i++] = '.';\n\t\treg_pat[i++] = '*';\n\t\twhile (p[1] == '*')\t/* \"**\" matches like \"*\" */\n\t\t    ++p;\n\t\tbreak;\n\t    case '.':\n\t    case '~':\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = *p;\n\t\tbreak;\n\t    case '?':\n\t\treg_pat[i++] = '.';\n\t\tbreak;\n\t    case '\\\\':\n\t\tif (p[1] == NUL)\n\t\t    break;\n#ifdef BACKSLASH_IN_FILENAME\n\t\tif (!no_bslash)\n\t\t{\n\t\t    /* translate:\n\t\t     * \"\\x\" to \"\\\\x\"  e.g., \"dir\\file\"\n\t\t     * \"\\*\" to \"\\\\.*\" e.g., \"dir\\*.c\"\n\t\t     * \"\\?\" to \"\\\\.\"  e.g., \"dir\\??.c\"\n\t\t     * \"\\+\" to \"\\+\"   e.g., \"fileX\\+.c\"\n\t\t     */\n\t\t    if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')\n\t\t\t    && p[1] != '+')\n\t\t    {\n\t\t\treg_pat[i++] = '[';\n\t\t\treg_pat[i++] = '\\\\';\n\t\t\treg_pat[i++] = '/';\n\t\t\treg_pat[i++] = ']';\n\t\t\tif (allow_dirs != NULL)\n\t\t\t    *allow_dirs = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n#endif\n\t\t/* Undo escaping from ExpandEscape():\n\t\t * foo\\?bar -> foo?bar\n\t\t * foo\\%bar -> foo%bar\n\t\t * foo\\,bar -> foo,bar\n\t\t * foo\\ bar -> foo bar\n\t\t * Don't unescape \\, * and others that are also special in a\n\t\t * regexp.\n\t\t * An escaped { must be unescaped since we use magic not\n\t\t * verymagic.  Use \"\\\\\\{n,m\\}\"\" to get \"\\{n,m}\".\n\t\t */\n\t\tif (*++p == '?'\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t&& no_bslash\n#endif\n\t\t\t)\n\t\t    reg_pat[i++] = '?';\n\t\telse\n\t\t    if (*p == ',' || *p == '%' || *p == '#'\n\t\t\t       || vim_isspace(*p) || *p == '{' || *p == '}')\n\t\t\treg_pat[i++] = *p;\n\t\t    else if (*p == '\\\\' && p[1] == '\\\\' && p[2] == '{')\n\t\t    {\n\t\t\treg_pat[i++] = '\\\\';\n\t\t\treg_pat[i++] = '{';\n\t\t\tp += 2;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (allow_dirs != NULL && vim_ispathsep(*p)\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t\t&& (!no_bslash || *p != '\\\\')\n#endif\n\t\t\t\t)\n\t\t\t    *allow_dirs = TRUE;\n\t\t\treg_pat[i++] = '\\\\';\n\t\t\treg_pat[i++] = *p;\n\t\t    }\n\t\tbreak;\n#ifdef BACKSLASH_IN_FILENAME\n\t    case '/':\n\t\treg_pat[i++] = '[';\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = '/';\n\t\treg_pat[i++] = ']';\n\t\tif (allow_dirs != NULL)\n\t\t    *allow_dirs = TRUE;\n\t\tbreak;\n#endif\n\t    case '{':\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = '(';\n\t\tnested++;\n\t\tbreak;\n\t    case '}':\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = ')';\n\t\t--nested;\n\t\tbreak;\n\t    case ',':\n\t\tif (nested)\n\t\t{\n\t\t    reg_pat[i++] = '\\\\';\n\t\t    reg_pat[i++] = '|';\n\t\t}\n\t\telse\n\t\t    reg_pat[i++] = ',';\n\t\tbreak;\n\t    default:\n# ifdef  FEAT_MBYTE\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) > 1)\n\t\t    reg_pat[i++] = *p++;\n\t\telse\n# endif\n\t\tif (allow_dirs != NULL && vim_ispathsep(*p))\n\t\t    *allow_dirs = TRUE;\n\t\treg_pat[i++] = *p;\n\t\tbreak;\n\t}\n    }\n    if (add_dollar)\n\treg_pat[i++] = '$';\n    reg_pat[i] = NUL;\n    if (nested != 0)\n    {\n\tif (nested < 0)\n\t    EMSG(_(\"E219: Missing {.\"));\n\telse\n\t    EMSG(_(\"E220: Missing }.\"));\n\tvim_free(reg_pat);\n\treg_pat = NULL;\n    }\n    return reg_pat;\n}\n\n#if defined(EINTR) || defined(PROTO)\n/*\n * Version of read() that retries when interrupted by EINTR (possibly\n * by a SIGWINCH).\n */\n    long\nread_eintr(int fd, void *buf, size_t bufsize)\n{\n    long ret;\n\n    for (;;)\n    {\n\tret = vim_read(fd, buf, bufsize);\n\tif (ret >= 0 || errno != EINTR)\n\t    break;\n    }\n    return ret;\n}\n\n/*\n * Version of write() that retries when interrupted by EINTR (possibly\n * by a SIGWINCH).\n */\n    long\nwrite_eintr(int fd, void *buf, size_t bufsize)\n{\n    long    ret = 0;\n    long    wlen;\n\n    /* Repeat the write() so long it didn't fail, other than being interrupted\n     * by a signal. */\n    while (ret < (long)bufsize)\n    {\n\twlen = vim_write(fd, (char *)buf + ret, bufsize - ret);\n\tif (wlen < 0)\n\t{\n\t    if (errno != EINTR)\n\t\tbreak;\n\t}\n\telse\n\t    ret += wlen;\n    }\n    return ret;\n}\n#endif\n", "\" Tests for the swap feature\n\n\" Tests for 'directory' option.\nfunc Test_swap_directory()\n  if !has(\"unix\")\n    return\n  endif\n  let content = ['start of testfile',\n\t      \\ 'line 2 Abcdefghij',\n\t      \\ 'line 3 Abcdefghij',\n\t      \\ 'end of testfile']\n  call writefile(content, 'Xtest1')\n\n  \"  '.', swap file in the same directory as file\n  set dir=.,~\n\n  \" Verify that the swap file doesn't exist in the current directory\n  call assert_equal([], glob(\".Xtest1*.swp\", 1, 1, 1))\n  edit Xtest1\n  let swfname = split(execute(\"swapname\"))[0]\n  call assert_equal([swfname], glob(swfname, 1, 1, 1))\n\n  \" './dir', swap file in a directory relative to the file\n  set dir=./Xtest2,.,~\n\n  call mkdir(\"Xtest2\")\n  edit Xtest1\n  call assert_equal([], glob(swfname, 1, 1, 1))\n  let swfname = \"Xtest2/Xtest1.swp\"\n  call assert_equal(swfname, split(execute(\"swapname\"))[0])\n  call assert_equal([swfname], glob(\"Xtest2/*\", 1, 1, 1))\n\n  \" 'dir', swap file in directory relative to the current dir\n  set dir=Xtest.je,~\n\n  call mkdir(\"Xtest.je\")\n  call writefile(content, 'Xtest2/Xtest3')\n  edit Xtest2/Xtest3\n  call assert_equal([\"Xtest2/Xtest3\"], glob(\"Xtest2/*\", 1, 1, 1))\n  let swfname = \"Xtest.je/Xtest3.swp\"\n  call assert_equal(swfname, split(execute(\"swapname\"))[0])\n  call assert_equal([swfname], glob(\"Xtest.je/*\", 1, 1, 1))\n\n  set dir&\n  call delete(\"Xtest1\")\n  call delete(\"Xtest2\", \"rf\")\n  call delete(\"Xtest.je\", \"rf\")\nendfunc\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\nmake_version(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't catenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n# else\nchar\t*longVersion = VIM_VERSION_LONG_DATE __DATE__ \" \" __TIME__ \")\";\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n#endif\n\nstatic void list_features(void);\nstatic void version_msg(char *s);\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n#ifdef FEAT_AUTOCMD\n\t\"+autocmd\",\n#else\n\t\"-autocmd\",\n#endif\n#ifdef FEAT_BEVAL\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n#ifdef FEAT_CURSORBIND\n\t\"+cursorbind\",\n#else\n\t\"-cursorbind\",\n#endif\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n#ifdef FEAT_FKMAP\n\t\"+farsi\",\n#else\n\t\"-farsi\",\n#endif\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n#ifdef FEAT_LISTCMDS\n\t\"+listcmds\",\n#else\n\t\"-listcmds\",\n#endif\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_SGR\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n# ifdef FEAT_MBYTE\n\t\"+multi_byte\",\n# else\n\t\"-multi_byte\",\n# endif\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n\t\"+packages\",\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n#ifdef FEAT_SCROLLBIND\n\t\"+scrollbind\",\n#else\n\t\"-scrollbind\",\n#endif\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n#ifdef FEAT_SUN_WORKSHOP\n\t\"+sun_workshop\",\n#else\n\t\"-sun_workshop\",\n#endif\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n#ifdef FEAT_TAG_OLDSTATIC\n\t\"+tag_old_static\",\n#else\n\t\"-tag_old_static\",\n#endif\n#ifdef FEAT_TAG_ANYWHITE\n\t\"+tag_any_white\",\n#else\n\t\"-tag_any_white\",\n#endif\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#else\t\t    /* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n#ifdef FEAT_USR_CMDS\n\t\"+user_commands\",\n#else\n\t\"-user_commands\",\n#endif\n\t\"+vertsplit\",\n#ifdef FEAT_VIRTUALEDIT\n\t\"+virtualedit\",\n#else\n\t\"-virtualedit\",\n#endif\n\t\"+visual\",\n#ifdef FEAT_VISUALEXTRA\n\t\"+visualextra\",\n#else\n\t\"-visualextra\",\n#endif\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n#ifdef FEAT_VREPLACE\n\t\"+vreplace\",\n#else\n\t\"-vreplace\",\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef WIN3264\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tnfeat = 0;\n    int\t\twidth = 0;\n\n    /* Find the length of the longest feature name, use that + 1 as the column\n     * width */\n    for (i = 0; features[i] != NULL; ++i)\n    {\n\tint l = (int)STRLEN(features[i]);\n\n\tif (l > width)\n\t    width = l;\n\t++nfeat;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; features[i] != NULL; ++i)\n\t{\n\t    version_msg(features[i]);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = nfeat / ncol + (nfeat % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < nfeat)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    msg_puts((char_u *)features[idx]);\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    MSG(longVersion);\n#ifdef WIN3264\n# ifdef FEAT_GUI_W32\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit GUI version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit GUI version\"));\n#  endif\n# ifdef FEAT_OLE\n    MSG_PUTS(_(\" with OLE support\"));\n# endif\n# else\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    MSG_PUTS(_(\"\\nmacOS version\"));\n# else\n    MSG_PUTS(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    MSG_PUTS(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tMSG_PUTS(\" - \");\n\tMSG_PUTS(compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tMSG_PUTS(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tMSG_PUTS(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    MSG_PUTS(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tMSG_PUTS(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    MSG_PUTS(s);\n\t    s = \", \";\n\t    MSG_PUTS(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(_(\"Modified by \"));\n    MSG_PUTS(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tMSG_PUTS(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    MSG_PUTS(_(\"by \"));\n\t    MSG_PUTS(compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    MSG_PUTS(\"@\");\n\t    MSG_PUTS(compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    MSG_PUTS(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    MSG_PUTS(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    MSG_PUTS(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    MSG_PUTS(_(\"\\nSmall version \"));\n#   else\n    MSG_PUTS(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    MSG_PUTS(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    MSG_PUTS(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     MSG_PUTS(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     MSG_PUTS(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    MSG_PUTS(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    MSG_PUTS(_(\"with X11-neXtaw GUI.\"));\n#    else\n    MSG_PUTS(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    MSG_PUTS(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    MSG_PUTS(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    MSG_PUTS(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    MSG_PUTS(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n */\n    static void\nversion_msg(char *s)\n{\n    int\t\tlen = (int)STRLEN(s);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n\tMSG_PUTS(s);\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n#endif\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["# Makefile for Vim on Unix and Unix-like systems\tvim:ts=8:sw=8:tw=78\n#\n# This Makefile is loosely based on the GNU Makefile conventions found in\n# standards.info.\n#\n# Compiling Vim, summary:\n#\n#\t3. make\n#\t5. make install\n#\n# Compiling Vim, details:\n#\n# Edit this file for adjusting to your system. You should not need to edit any\n# other file for machine specific things!\n# The name of this file MUST be Makefile (note the uppercase 'M').\n#\n# 1. Edit this Makefile  {{{1\n#\tThe defaults for Vim should work on most machines, but you may want to\n#\tuncomment some lines or make other changes below to tune it to your\n#\tsystem, compiler or preferences.  Uncommenting means that the '#' in\n#\tthe first column of a line is removed.\n#\t- If you want a version of Vim that is small and starts up quickly,\n#\t  you might want to disable the GUI, X11, Perl, Python and Tcl.\n#\t- Uncomment the line with --disable-gui if you have Motif, GTK and/or\n#\t  Athena but don't want to make gvim (the GUI version of Vim with nice\n#\t  menus and scrollbars, but makes Vim bigger and startup slower).\n#\t- Uncomment --disable-darwin if on Mac OS X but you want to compile a\n#\t  Unix version.\n#\t- Uncomment the line \"CONF_OPT_X = --without-x\" if you have X11 but\n#\t  want to disable using X11 libraries.\tThis speeds up starting Vim,\n#\t  but the window title will not be set and the X11 selection can not\n#\t  be used.\n#\t- Uncomment the line \"CONF_OPT_XSMP = --disable-xsmp\" if you have the\n#\t  X11 Session Management Protocol (XSMP) library (libSM) but do not\n#\t  want to use it.\n#\t  This can speedup Vim startup but Vim loses the ability to catch the\n#\t  user logging out from session-managers like GNOME and work\n#\t  could be lost.\n#\t- Uncomment one or more of these lines to include an interface;\n#\t  each makes Vim quite a bit bigger:\n#\t\t--enable-luainterp\tfor Lua interpreter\n#\t\t--enable-mzschemeinterp\tfor MzScheme interpreter\n#\t\t--enable-perlinterp\tfor Perl interpreter\n#\t\t--enable-python3interp\tfor Python3 interpreter\n#\t\t--enable-pythoninterp\tfor Python interpreter\n#\t\t--enable-rubyinterp\tfor Ruby interpreter\n#\t\t--enable-tclinterp\tfor Tcl interpreter\n#\t\t--enable-cscope\t\tfor Cscope interface\n#\t- Uncomment one of the lines with --with-features= to enable a set of\n#\t  features (but not the interfaces just mentioned).\n#\t- Uncomment the line with --disable-acl to disable ACL support even\n#\t  though your system supports it.\n#\t- Uncomment the line with --disable-gpm to disable gpm support\n#\t  even though you have gpm libraries and includes.\n#\t- Uncomment the line with --disable-sysmouse to disable sysmouse\n#\t  support even though you have /dev/sysmouse and includes.\n#\t- Uncomment one of the lines with CFLAGS and/or CC if you have\n#\t  something very special or want to tune the optimizer.\n#\t- Search for the name of your system to see if it needs anything\n#\t  special.\n#\t- A few versions of make use '.include \"file\"' instead of 'include\n#\t  file'.  Adjust the include line below if yours does.\n#\n# 2. Edit feature.h  {{{1\n#\tOnly if you do not agree with the default compile features, e.g.:\n#\t- you want Vim to be as vi compatible as it can be\n#\t- you want to use Emacs tags files\n#\t- you want right-to-left editing (Hebrew)\n#\t- you want 'langmap' support (Greek)\n#\t- you want to remove features to make Vim smaller\n#\n# 3. \"make\"  {{{1\n#\tWill first run ./configure with the options in this file. Then it will\n#\tstart make again on this Makefile to do the compiling. You can also do\n#\tthis in two steps with:\n#\t\tmake config\n#\t\tmake\n#\tThe configuration phase creates/overwrites auto/config.h and\n#\tauto/config.mk.\n#\tThe configure script is created with \"make autoconf\".  It can detect\n#\tdifferent features of your system and act accordingly.  However, it is\n#\tnot correct for all systems.  Check this:\n#\t- If you have X windows, but configure could not find it or reported\n#\t  another include/library directory then you wanted to use, you have\n#\t  to set CONF_OPT_X below.  You might also check the installation of\n#\t  xmkmf.\n#\t- If you have --enable-gui=motif and have Motif on your system, but\n#\t  configure reports \"checking for location of gui... <not found>\", you\n#\t  have to set GUI_INC_LOC and GUI_LIB_LOC below.\n#\tIf you changed something, do this to run configure again:\n#\t\tmake reconfig\n#\n#\t- If you do not trust the automatic configuration code, then inspect\n#\t  auto/config.h and auto/config.mk, before starting the actual build\n#\t  phase. If possible edit this Makefile, rather than auto/config.mk --\n#\t  especially look at the definition of VIMLOC below. Note that the\n#\t  configure phase overwrites auto/config.mk and auto/config.h again.\n#\t- If you get error messages, find out what is wrong and try to correct\n#\t  it in this Makefile. You may need to do \"make reconfig\" when you\n#\t  change anything that configure uses (e.g. switching from an old C\n#\t  compiler to an ANSI C compiler). Only when auto/configure does\n#\t  something wrong you may need to change one of the other files. If\n#\t  you find a clean way to fix the problem, consider sending a note to\n#\t  the author of autoconf (bug-gnu-utils@prep.ai.mit.edu) or Vim\n#\t  (Bram@vim.org). Don't bother to do that when you made a hack\n#\t  solution for a non-standard system.\n#\n# 4. \"make test\"  {{{1\n#\tThis is optional.  This will run Vim scripts on a number of test\n#\tfiles, and compare the produced output with the expected output.\n#\tIf all is well, you will get the \"ALL DONE\" message in the end.  If a\n#\ttest fails you get \"TEST FAILURE\".  See below (search for \"/^test\").\n#\n# 5. \"make install\"  {{{1\n#\tIf the new Vim seems to be working OK you can install it and the\n#\tdocumentation in the appropriate location. The default is\n#\t\"/usr/local\".  Change \"prefix\" below to change the location.\n#\t\"auto/pathdef.c\" will be compiled again after changing this to make\n#\tthe executable know where the help files are located.\n#\tNote that any existing executable is removed or overwritten.  If you\n#\twant to keep it you will have to make a backup copy first.\n#\tThe runtime files are in a different directory for each version.  You\n#\tmight want to delete an older version.\n#\tIf you don't want to install everything, there are other targets:\n#\t\tmake installvim\t\tonly installs Vim, not the tools\n#\t\tmake installvimbin\tonly installs the Vim executable\n#\t\tmake installruntime\tinstalls most of the runtime files\n#\t\tmake installrtbase\tonly installs the Vim help and\n#\t\t\t\t\t\t\truntime files\n#\t\tmake installlinks\tonly installs the Vim binary links\n#\t\tmake installmanlinks\tonly installs the Vim manpage links\n#\t\tmake installmacros\tonly installs the Vim macros\n#\t\tmake installpack\tonly installs the packages\n#\t\tmake installtutorbin\tonly installs the Vim tutor program\n#\t\tmake installtutor\tonly installs the Vim tutor files\n#\t\tmake installspell\tonly installs the spell files\n#\t\tmake installtools\tonly installs xxd\n#\tIf you install Vim, not to install for real but to prepare a package\n#\tor RPM, set DESTDIR to the root of the tree.\n#\n# 6. Use Vim until a new version comes out.  {{{1\n#\n# 7. \"make uninstall_runtime\"  {{{1\n#\tWill remove the runtime files for the current version.\tThis is safe\n#\tto use while another version is being used, only version-specific\n#\tfiles will be deleted.\n#\tTo remove the runtime files of another version:\n#\t\tmake uninstall_runtime VIMRTDIR=/vim54\n#\tIf you want to delete all installed files, use:\n#\t\tmake uninstall\n#\tNote that this will delete files that have the same name for any\n#\tversion, thus you might need to do a \"make install\" soon after this.\n#\tBe careful not to remove a version of Vim that is still being used!\n#\tTo find out which files and directories will be deleted, use:\n#\t\tmake -n uninstall\n# }}}\n#\n### This Makefile has been successfully tested on many systems. {{{\n### Only the ones that require special options are mentioned here.\n### Check the (*) column for remarks, listed below.\n### Later code changes may cause small problems, otherwise Vim is supposed to\n### compile and run without problems.\n\n#system:\t      configurations:\t\t     version (*) tested by:\n#-------------\t      ------------------------\t     -------  -  ----------\n#AIX 3.2.5\t      cc (not gcc)   -\t\t\t4.5  (M) Will Fiveash\n#AIX 4\t\t      cc\t     +X11 -GUI\t\t3.27 (4) Axel Kielhorn\n#AIX 4.1.4\t      cc\t     +X11 +GUI\t\t4.5  (5) Nico Bakker\n#AIX 4.2.1\t      cc\t\t\t\t5.2k (C) Will Fiveash\n#AIX 4.3.3.12\t      xic 3.6.6\t\t\t\t5.6  (5) David R. Favor\n#A/UX 3.1.1\t      gcc\t     +X11\t\t4.0  (6) Jim Jagielski\n#BeOS PR\t      mwcc DR3\t\t\t\t5.0n (T) Olaf Seibert\n#BSDI 2.1 (x86)       shlicc2 gcc-2.6.3 -X11 X11R6\t4.5  (1) Jos Backus\n#BSD/OS 3.0 (x86)     gcc gcc-2.7.2.1 -X11 X11R6\t4.6c (1) Jos Backus\n#CX/UX 6.2\t      cc\t     +X11 +GUI_Mofif\t5.4  (V) Kipp E. Howard\n#DG/UX 5.4*\t      gcc 2.5.8      GUI\t\t5.0e (H) Jonas Schlein\n#DG/UX 5.4R4.20       gcc 2.7.2      GUI\t\t5.0s (H) Rocky Olive\n#HP-UX (most)\t      c89 cc\t\t\t\t5.1  (2) Bram Moolenaar\n#HP-UX_9.04\t      cc\t     +X11 +Motif\t5.0  (2) Carton Lao\n#Irix 6.3 (O2)\t      cc\t     ?\t\t\t4.5  (L) Edouard Poor\n#Irix 6.4\t      cc\t     ?\t\t\t5.0m (S) Rick Sayre\n#Irix 6.5\t      cc\t     ?\t\t\t6.0  (S) David Harrison\n#Irix 64 bit\t\t\t\t\t\t4.5  (K) Jon Wright\n#Linux 2.0\t      gcc-2.7.2      Infomagic Motif\t4.3  (3) Ronald Rietman\n#Linux 2.0.31\t      gcc\t     +X11 +GUI Athena\t5.0w (U) Darren Hiebert\n#LynxOS 3.0.1\t      2.9-gnupro-98r2 +X11 +GUI Athena  5.7.1(O) Lorenz Hahn\n#LynxOS 3.1.0\t      2.9-gnupro-98r2 +X11 +GUI Athena  5.7.1(O) Lorenz Hahn\n#NEC UP4800 UNIX_SV 4.2MP  cc\t     +X11R6 Motif,Athena4.6b (Q) Lennart Schultz\n#NetBSD 1.0A\t      gcc-2.4.5      -X11 -GUI\t\t3.21 (X) Juergen Weigert\n#QNX 4.2\t      wcc386-10.6    -X11\t\t4.2  (D) G.F. Desrochers\n#QNX 4.23\t      Watcom\t     -X11\t\t4.2  (F) John Oleynick\n#SCO Unix v3.2.5      cc\t     +X11 Motif\t\t3.27 (C) M. Kuperblum\n#SCO Open Server 5    gcc 2.7.2.3    +X11 +GUI Motif\t5.3  (A) Glauber Ribeiro\n#SINIX-N 5.43 RM400 R4000   cc\t     +X11 +GUI\t\t5.0l (I) Martin Furter\n#SINIX-Z 5.42 i386    gcc 2.7.2.3    +X11 +GUI Motif\t5.1  (I) Joachim Fehn\n#SINIX-Y 5.43 RM600 R4000  gcc 2.7.2.3 +X11 +GUI Motif\t5.1  (I) Joachim Fehn\n#Reliant/SINIX 5.44   cc\t     +X11 +GUI\t\t5.5a (I) B. Pruemmer\n#SNI Targon31 TOS 4.1.11 gcc-2.4.5   +X11 -GUI\t\t4.6c (B) Paul Slootman\n#Solaris 2.4 (Sparc)  cc\t     +X11 +GUI\t\t3.29 (9) Glauber\n#Solaris 2.4/2.5      clcc\t     +X11 -GUI openwin\t3.20 (7) Robert Colon\n#Solaris 2.5 (sun4m)  cc (SC4.0)     +X11R6 +GUI (CDE)\t4.6b (E) Andrew Large\n#Solaris 2.5\t      cc\t     +X11 +GUI Athena\t4.2  (9) Sonia Heimann\n#Solaris 2.5\t      gcc 2.5.6      +X11 Motif\t\t5.0m (R) Ant. Colombo\n#Solaris 2.6\t      gcc 2.8.1      ncurses\t\t5.3  (G) Larry W. Virden\n#Solaris with -lthread\t\t\t\t\t5.5  (W) K. Nagano\n#Solaris\t      gcc\t\t\t\t     (b) Riccardo\n#SunOS 4.1.x\t\t\t     +X11 -GUI\t\t5.1b (J) Bram Moolenaar\n#SunOS 4.1.3_U1 (sun4c) gcc\t     +X11 +GUI Athena\t5.0w (J) Darren Hiebert\n#SUPER-UX 6.2 (NEC SX-4) cc\t     +X11R6 Motif,Athena4.6b (P) Lennart Schultz\n#Tandem/NSK\t\t\t\t\t\t     (c) Matthew Woehlke\n#Unisys 6035\t      cc\t     +X11 Motif\t\t5.3  (8) Glauber Ribeiro\n#ESIX V4.2\t      cc\t     +X11\t\t6.0  (a) Reinhard Wobst\n#Mac OS X 10.[23]     gcc\t     Carbon\t\t6.2  (x) Bram Moolenaar\n# }}}\n\n# (*)  Remarks: {{{\n#\n# (1)  Uncomment line below for shlicc2\n# (2)  HPUX with compile problems or wrong digraphs, uncomment line below\n# (3)  Infomagic Motif needs GUI_LIB_LOC and GUI_INC_LOC set, see below.\n#      And add \"-lXpm\" to MOTIF_LIBS2.\n# (4)  For cc the optimizer must be disabled (use CFLAGS= after running\n#      configure) (symptom: \":set termcap\" output looks weird).\n# (5)  Compiler may need extra argument, see below.\n# (6)  See below for a few lines to uncomment\n# (7)  See below for lines which enable the use of clcc\n# (8)  Needs some EXTRA_LIBS, search for Unisys below\n# (9)  Needs an extra compiler flag to compile gui_at_sb.c, see below.\n# (A)  May need EXTRA_LIBS, see below\n# (B)  Can't compile GUI because there is no waitpid()...  Disable GUI below.\n# (C)  Force the use of curses instead of termcap, see below.\n# (D)  Uncomment lines below for QNX\n# (E)  You might want to use termlib instead of termcap, see below.\n# (F)  See below for instructions.\n# (G)  Using ncurses version 4.2 has reported to cause a crash.  Use the\n#      Sun curses library instead.\n# (H)  See line for EXTRA_LIBS below.\n# (I)  SINIX-N 5.42 and 5.43 need some EXTRA_LIBS.  Also for Reliant-Unix.\n# (J)  If you get undefined symbols, see below for a solution.\n# (K)  See lines to uncomment below for machines with 64 bit pointers.\n# (L)  For Silicon Graphics O2 workstations remove \"-lnsl\" from auto/config.mk\n# (M)  gcc version cygnus-2.0.1 does NOT work (symptom: \"dl\" deletes two\n#      characters instead of one).\n# (N)  SCO with decmouse.\n# (O)  LynxOS needs EXTRA_LIBS, see below.\n# (P)  For SuperUX 6.2 on NEC SX-4 see a few lines below to uncomment.\n# (Q)  For UNIXSVR 4.2MP on NEC UP4800 see below for lines to uncomment.\n# (R)  For Solaris 2.5 (or 2.5.1) with gcc > 2.5.6, uncomment line below.\n# (S)  For Irix 6.x with MipsPro compiler, use -OPT:Olimit.  See line below.\n# (T)  See ../doc/os_beos.txt.\n# (U)  Must uncomment CONF_OPT_PYTHON option below to disable Python\n#      detection, since the configure script runs into an error when it\n#      detects Python (probably because of the bash shell).\n# (V)  See lines to uncomment below.\n# (X)  Need to use the .include \"auto/config.mk\" line below\n# (Y)  See line with c89 below\n# (Z)  See lines with cc or c89 below\n# (a)  See line with EXTRA_LIBS below.\n# (b)  When using gcc with the Solaris linker, make sure you don't use GNU\n#      strip, otherwise the binary may not run: \"Cannot find ELF\".\n# (c)  Add -lfloss to EXTRA_LIBS, see below.\n# (x)  When you get warnings for precompiled header files, run\n#      \"sudo fixPrecomps\".  Also see CONF_OPT_DARWIN below.\n# }}}\n\n\n#DO NOT CHANGE the next line, we need it for configure to find the compiler\n#instead of using the default from the \"make\" program.\n#Use a line further down to change the value for CC.\nCC=\n\n# Change and use these defines if configure cannot find your Motif stuff.\n# Unfortunately there is no \"standard\" location for Motif. {{{\n# These defines can contain a single directory (recommended) or a list of\n# directories (for when you are working with several systems). The LAST\n# directory that exists is used.\n# When changed, run \"make reconfig\" next!\n#GUI_INC_LOC = -I/usr/include/Motif2.0 -I/usr/include/Motif1.2\n#GUI_LIB_LOC = -L/usr/lib/Motif2.0 -L/usr/lib/Motif1.2\n### Use these two lines for Infomagic Motif (3)\n#GUI_INC_LOC = -I/usr/X11R6/include\n#GUI_LIB_LOC = -L/usr/X11R6/lib\n# }}}\n\n# Defaults used when auto/config.mk does not exist.\nsrcdir = .\nVIMNAME = vim\nEXNAME = ex\nVIEWNAME = view\n\n######################## auto/config.mk ######################## {{{1\n# At this position auto/config.mk is included. When starting from the\n# toplevel Makefile it is almost empty. After running auto/configure it\n# contains settings that have been discovered for your system. Settings below\n# this include override settings in auto/config.mk!\n\n# Note: If make fails because auto/config.mk does not exist (it is not\n# included in the repository), do:\n#    cp config.mk.dist auto/config.mk\n\n# (X) How to include auto/config.mk depends on the version of \"make\" you have,\n#     if the current choice doesn't work, try the other one.\n\ninclude auto/config.mk\n#.include \"auto/config.mk\"\nCClink = $(CC)\n\n#}}}\n\n# Include the configuration choices first, so we can override everything\n# below. As shipped, this file contains a target that causes to run\n# configure. Once configure was run, this file contains a list of\n# make variables with predefined values instead. Thus any second invocation\n# of make, will build Vim.\n\n# CONFIGURE - configure arguments {{{1\n# You can give a lot of options to configure.\n# Change this to your desire and do 'make config' afterwards\n\n# examples (can only use one!):\n#CONF_ARGS = --exec-prefix=/usr\n#CONF_ARGS = --with-vim-name=vim7 --with-ex-name=ex7 --with-view-name=view7\n#CONF_ARGS = --with-global-runtime=/etc/vim\n#CONF_ARGS = --with-local-dir=/usr/share\n#CONF_ARGS = --without-local-dir\n\n# Use this one if you distribute a modified version of Vim.\n#CONF_ARGS = --with-modified-by=\"John Doe\"\n\n# GUI - For creating Vim with GUI (gvim) (B)\n# Uncomment this line when you don't want to get the GUI version, although you\n# have GTK, Motif and/or Athena.  Also use --without-x if you don't want X11\n# at all.\n#CONF_OPT_GUI = --disable-gui\n\n# Uncomment one of these lines if you have that GUI but don't want to use it.\n# The automatic check will use another one that can be found.\n# Gnome is disabled by default, because it may cause trouble.\n#\n# When both GTK+ 2 and GTK+ 3 are possible then GTK+ 2 will be selected.\n# To use GTK+ 3 instead use --enable-gui=gtk3 (see below).\n#CONF_OPT_GUI = --disable-gtk2-check\n#CONF_OPT_GUI = --enable-gnome-check\n#CONF_OPT_GUI = --disable-gtk3-check\n#CONF_OPT_GUI = --disable-motif-check\n#CONF_OPT_GUI = --disable-athena-check\n#CONF_OPT_GUI = --disable-nextaw-check\n\n# Uncomment one of these lines to select a specific GUI to use.\n# When using \"yes\" or nothing, configure will use the first one found: GTK+,\n# Motif or Athena.\n#\n# GTK versions that are known not to work 100% are rejected.\n# Use \"--disable-gtktest\" to accept them anyway.\n# For GTK 1 use Vim 7.2.\n#\n# GNOME means GTK with Gnome support.  If using GTK and --enable-gnome-check\n# is used then GNOME will automatically be used if it is found.  If you have\n# GNOME, but do not want to use it (e.g., want a GTK-only version), then use\n# --enable-gui=gtk or leave out --enable-gnome-check.\n#\n# GNOME makes sense only for GTK+ 2.  Avoid use of --enable-gnome-check with\n# GTK+ 3 build, as the functionality of GNOME is already incooperated into\n# GTK+ 3.\n#\n# If the selected GUI isn't found, the GUI is disabled automatically\n#CONF_OPT_GUI = --enable-gui=gtk2\n#CONF_OPT_GUI = --enable-gui=gtk2 --disable-gtktest\n#CONF_OPT_GUI = --enable-gui=gnome2\n#CONF_OPT_GUI = --enable-gui=gnome2 --disable-gtktest\n#CONF_OPT_GUI = --enable-gui=gtk3\n#CONF_OPT_GUI = --enable-gui=gtk3 --disable-gtktest\n#CONF_OPT_GUI = --enable-gui=motif\n#CONF_OPT_GUI = --enable-gui=motif --with-motif-lib=\"-static -lXm -shared\"\n#CONF_OPT_GUI = --enable-gui=athena\n#CONF_OPT_GUI = --enable-gui=nextaw\n\n# Carbon GUI for Mac OS X\n#CONF_OPT_GUI = --enable-gui=carbon\n\n# Uncomment this line to run an individual test with gvim.\n#GUI_TESTARG = GUI_FLAG=-g \n\n# DARWIN - detecting Mac OS X\n# Uncomment this line when you want to compile a Unix version of Vim on\n# Darwin.  None of the Mac specific options or files will be used.\n#CONF_OPT_DARWIN = --disable-darwin\n\n# Select the architecture supported.  Default is to build for the current\n# platform.  Use \"both\" for a universal binary.  That probably doesn't work\n# when including Perl, Python, etc.\n#CONF_OPT_DARWIN = --with-mac-arch=i386\n#CONF_OPT_DARWIN = --with-mac-arch=ppc\n#CONF_OPT_DARWIN = --with-mac-arch=both\n\n# Uncomment the next line to fail if one of the requested language interfaces\n# cannot be configured.  Without this Vim will be build anyway, without\n# the failing interfaces.\n#CONF_OPT_FAIL = --enable-fail-if-missing\n\n# LUA\n# Uncomment one of these when you want to include the Lua interface.\n# First one is for static linking, second one for dynamic loading.\n# Use --with-luajit if you want to use LuaJIT instead of Lua.\n# Set PATH environment variable to find lua or luajit executable.\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n#CONF_OPT_LUA = --enable-luainterp\n#CONF_OPT_LUA = --enable-luainterp=dynamic\n#CONF_OPT_LUA = --enable-luainterp --with-luajit\n#CONF_OPT_LUA = --enable-luainterp=dynamic --with-luajit\n# Lua installation dir (when not set uses $LUA_PREFIX or defaults to /usr)\n#CONF_OPT_LUA_PREFIX = --with-lua-prefix=/usr/local\n\n# MZSCHEME\n# Uncomment this when you want to include the MzScheme interface.\n# NOTE: does not work well together with valgrind.\n#CONF_OPT_MZSCHEME = --enable-mzschemeinterp\n# PLT/mrscheme/drscheme Home dir; the PLTHOME environment variable also works\n#CONF_OPT_PLTHOME  = --with-plthome=/usr/local/plt\n#CONF_OPT_PLTHOME  = --with-plthome=/usr/local/drscheme\n#CONF_OPT_PLTHOME  = --with-plthome=/home/me/mz\n\n# PERL\n# Uncomment one of these when you want to include the Perl interface.\n# First one is for static linking, second one for dynamic loading.\n# The Perl option sometimes causes problems, because it adds extra flags\n#\n# to the command line.\tIf you see strange flags during compilation, check in\n# auto/config.mk where they come from.  If it's PERL_CFLAGS, try commenting\n# the next line.\n# When you get an error for a missing \"perl.exp\" file, try creating an empty\n# one: \"touch perl.exp\".\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n#CONF_OPT_PERL = --enable-perlinterp\n#CONF_OPT_PERL = --enable-perlinterp=dynamic\n\n# PYTHON\n# Uncomment lines here when you want to include the Python interface.\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n# NOTE: This may cause threading to be enabled, which has side effects (such\n# as using different libraries and debugging becomes more difficult).\n# For Python3 support make a symbolic link in /usr/local/bin:\n#\tln -s python3 python3.1\n# If both python2.x and python3.x are enabled then the linking will be via\n# dlopen(), dlsym(), dlclose(), i.e. pythonX.Y.so must be available\n# However, this may still cause problems, such as \"import termios\" failing.\n# Build two separate versions of Vim in that case.\n#CONF_OPT_PYTHON = --enable-pythoninterp\n#CONF_OPT_PYTHON = --enable-pythoninterp=dynamic\n#CONF_OPT_PYTHON3 = --enable-python3interp\n#CONF_OPT_PYTHON3 = --enable-python3interp=dynamic\n\n# RUBY\n# Uncomment this when you want to include the Ruby interface.\n# First one for static linking, second one for loading when used.\n# Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).\n# This requires at least \"normal\" features, \"tiny\" and \"small\" don't work.\n#CONF_OPT_RUBY = --enable-rubyinterp\n#CONF_OPT_RUBY = --enable-rubyinterp=dynamic\n#CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1\n\n# TCL\n# Uncomment this when you want to include the Tcl interface.\n# First one is for static linking, second one for dynamic loading.\n#CONF_OPT_TCL = --enable-tclinterp\n#CONF_OPT_TCL = --enable-tclinterp=dynamic\n#CONF_OPT_TCL = --enable-tclinterp --with-tclsh=tclsh8.4\n\n# CSCOPE\n# Uncomment this when you want to include the Cscope interface.\n#CONF_OPT_CSCOPE = --enable-cscope\n\n# WORKSHOP - Sun Visual Workshop interface.  Only works with Motif!\n#CONF_OPT_WORKSHOP = --enable-workshop\n\n# NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.\n# Motif version must have XPM libraries (see |workshop-xpm|).\n# Uncomment this when you do not want the netbeans interface.\n#CONF_OPT_NETBEANS = --disable-netbeans\n\n# CHANNEL - inter process communication. Same conditions as NetBeans.\n# Uncomment this when you do not want inter process communication.\n#CONF_OPT_CHANNEL = --disable-channel\n\n# TERMINAL - Terminal emulator support, :terminal command.  Requires the\n# channel feature. The default is enable for when using \"huge\" features.\n# Uncomment the first line when you want terminal emulator support for\n# not-huge builds.  Uncomment the second line when you don't want terminal\n# emulator support in the huge build.\n#CONF_OPT_TERMINAL = --enable-terminal\n#CONF_OPT_TERMINAL = --disable-terminal\n\n# MULTIBYTE - To edit multi-byte characters.\n# Uncomment this when you want to edit a multibyte language.\n# It's automatically enabled with normal features, GTK or IME support.\n# Note: Compile on a machine where setlocale() actually works, otherwise the\n# configure tests may fail.\n#CONF_OPT_MULTIBYTE = --enable-multibyte\n\n# NLS - National Language Support\n# Uncomment this when you do not want to support translated messages, even\n# though configure can find support for it.\n#CONF_OPT_NLS = --disable-nls\n\n# XIM - X Input Method.  Special character input support for X11 (Chinese,\n# Japanese, special symbols, etc).  Also needed for dead-key support.\n# When omitted it's automatically enabled for the X-windows GUI.\n# HANGUL - Input Hangul (Korean) language using internal routines.\n# Uncomment one of these when you want to input a multibyte language.\n#CONF_OPT_INPUT = --enable-xim\n#CONF_OPT_INPUT = --disable-xim\n#CONF_OPT_INPUT = --enable-hangulinput\n\n# FONTSET - X fontset support for output of languages with many characters.\n# Uncomment this when you want to output a multibyte language.\n#CONF_OPT_OUTPUT = --enable-fontset\n\n# ACL - Uncomment this when you do not want to include ACL support, even\n# though your system does support it.  E.g., when it's buggy.\n#CONF_OPT_ACL = --disable-acl\n\n# gpm - For mouse support on Linux console via gpm\n# Uncomment this when you do not want to include gpm support, even\n# though you have gpm libraries and includes.\n#CONF_OPT_GPM = --disable-gpm\n\n# sysmouse - For mouse support on FreeBSD and DragonFly console via sysmouse\n# Uncomment this when you do not want do include sysmouse support, even\n# though you have /dev/sysmouse and includes.\n#CONF_OPT_SYSMOUSE = --disable-sysmouse\n\n# FEATURES - For creating Vim with more or less features\n# Uncomment one of these lines when you want to include few to many features.\n# The default is \"huge\" for most systems.\n#CONF_OPT_FEAT = --with-features=tiny\n#CONF_OPT_FEAT = --with-features=small\n#CONF_OPT_FEAT = --with-features=normal\n#CONF_OPT_FEAT = --with-features=big\n#CONF_OPT_FEAT = --with-features=huge\n\n# COMPILED BY - For including a specific e-mail address for \":version\".\n#CONF_OPT_COMPBY = \"--with-compiledby=John Doe <JohnDoe@yahoo.com>\"\n\n# X WINDOWS DISABLE - For creating a plain Vim without any X11 related fancies\n# (otherwise Vim configure will try to include xterm titlebar access)\n# Also disable the GUI above, otherwise it will be included anyway.\n# When both GUI and X11 have been disabled this may save about 15% of the\n# code and make Vim startup quicker.\n#CONF_OPT_X = --without-x\n\n# X WINDOWS DIRECTORY - specify X directories\n# If configure can't find you X stuff, or if you have multiple X11 derivatives\n# installed, you may wish to specify which one to use.\n# Select nothing to let configure choose.\n# This here selects openwin (as found on sun).\n#XROOT = /usr/openwin\n#CONF_OPT_X = --x-include=$(XROOT)/include --x-libraries=$(XROOT)/lib\n\n# X11 Session Management Protocol support\n# Vim will try to use XSMP to catch the user logging out if there are unsaved\n# files.  Uncomment this line to disable that (it prevents vim trying to open\n# communications with the session manager).\n#CONF_OPT_XSMP = --disable-xsmp\n\n# You may wish to include xsmp but use exclude xsmp-interact if the logout\n# XSMP functionality does not work well with your session-manager (at time of\n# writing, this would be early GNOME-1 gnome-session: it 'freezes' other\n# applications after Vim has cancelled a logout (until Vim quits).  This\n# *might* be the Vim code, but is more likely a bug in early GNOME-1.\n# This disables the dialog that asks you if you want to save files or not.\n#CONF_OPT_XSMP = --disable-xsmp-interact\n\n# COMPILER - Name of the compiler {{{1\n# The default from configure will mostly be fine, no need to change this, just\n# an example. If a compiler is defined here, configure will use it rather than\n# probing for one. It is dangerous to change this after configure was run.\n# Make will use your choice then -- but beware: Many things may change with\n# another compiler.  It is wise to run 'make reconfig' to start all over\n# again.\n#CC = cc\n#CC = gcc\n#CC = clang\n\n# COMPILER FLAGS - change as you please. Either before running {{{1\n# configure or afterwards. For examples see below.\n# When using -g with some older versions of Linux you might get a\n# statically linked executable.\n# When not defined, configure will try to use -O2 -g for gcc and -O for cc.\n#CFLAGS = -g\n#CFLAGS = -O\n\n# Optimization limits - depends on the compiler.  Automatic check in configure\n# doesn't work very well, because many compilers only give a warning for\n# unrecognized arguments.\n#CFLAGS = -O -OPT:Olimit=2600\n#CFLAGS = -O -Olimit 2000\n#CFLAGS = -O -FOlimit,2000\n\n# Often used for GCC: mixed optimizing, lot of optimizing, debugging\n#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes\n#CFLAGS = -g -O2 -fno-strength-reduce -Wall -Wmissing-prototypes\n#CFLAGS = -g -Wall -Wmissing-prototypes\n#CFLAGS = -O6 -fno-strength-reduce -Wall -Wshadow -Wmissing-prototypes\n#CFLAGS = -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes\n#CFLAGS = -g -O2 '-DSTARTUPTIME=\"vimstartup\"' -fno-strength-reduce -Wall -Wmissing-prototypes\n\n# Use this with GCC to check for mistakes, unused arguments, etc.\n#CFLAGS = -g -Wall -Wextra -Wshadow -Wmissing-prototypes -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1\n# Add -Wpedantic to find // comments and other C99 constructs.\n# Better disable Perl and Python to avoid a lot of warnings.\n#CFLAGS = -g -Wall -Wextra -Wshadow -Wmissing-prototypes -Wpedantic -Wunreachable-code -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1\n#CFLAGS = -g -O2 -Wall -Wextra -Wmissing-prototypes -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -DU_DEBUG\n#PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers\n#MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter\n\n# EFENCE - Electric-Fence malloc debugging: catches memory accesses beyond\n# allocated memory (and makes every malloc()/free() very slow).\n# Electric Fence is free (search ftp sites).\n# You may want to set the EF_PROTECT_BELOW environment variable to check the\n# other side of allocated memory.\n# On FreeBSD you might need to enlarge the number of mmaps allowed.  Do this\n# as root: sysctl -w vm.max_proc_mmap=30000\n#EXTRA_LIBS = /usr/local/lib/libefence.a\n\n# Autoconf binary.\nAUTOCONF = autoconf\n\n# PURIFY - remove the # to use the \"purify\" program (hoi Nia++!)\n#PURIFY = purify\n\n# VALGRIND - remove the # to use valgrind for memory leaks and access errors.\n#\t     Used for the unittest targets.\n# VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=25 --log-file=valgrind.$@\n\n# NBDEBUG - debugging the netbeans interface.\n#EXTRA_DEFS = -DNBDEBUG\n\n# }}}\n\n# LINT - for running lint\n#  For standard Unix lint\nLINT = lint\nLINT_OPTIONS = -beprxzF\n#  For splint\n#  It doesn't work well, crashes on include files and non-ascii characters.\n#LINT = splint\n#LINT_OPTIONS = +unixlib -weak -macrovarprefixexclude -showfunc -linelen 9999\n\n# PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.\n# Might not work with GUI or Perl.\n# For unknown reasons adding \"-lc\" fixes a linking problem with some versions\n# of GCC.  That's probably a bug in the \"-pg\" implementation.\n# After running Vim see the profile result with: gprof vim gmon.out | vim -\n# Need to recompile everything after changing this: \"make clean\" \"make\".\n#PROFILE_CFLAGS = -pg -g -DWE_ARE_PROFILING\n#PROFILE_LIBS = -pg\n#PROFILE_LIBS = -pg -lc\n\n\n# TEST COVERAGE - Uncomment the two lines below the explanation to get code\n# coverage information. (provided by Yegappan Lakshmanan)\n# 1. make clean, run configure and build Vim as usual.\n# 2. Generate the baseline code coverage information:\n#\t$ lcov -c -i -b . -d objects -o objects/coverage_base.info\n# 3. Run \"make test\" to run the unit tests.  The code coverage information will\n#    be generated in the src/objects directory.\n# 4. Generate the code coverage information from the tests:\n#\t$ lcov -c -b . -d objects/ -o objects/coverage_test.info\n# 5. Combine the baseline and test code coverage data:\n#\t$ lcov -a objects/coverage_base.info -a objects/coverage_test.info -o objects/coverage_total.info\n# 6. Process the test coverage data and generate a report in html:\n#\t$ genhtml objects/coverage_total.info -o objects\n# 7. Open the objects/index.html file in a web browser to view the coverage\n#    information.\n#\n# PROFILE_CFLAGS=-g -O0 -fprofile-arcs -ftest-coverage\n# LDFLAGS=--coverage\n\n\n# Uncomment one of the next two lines to compile Vim with the\n# address sanitizer or with the undefined sanitizer.  Works with gcc and\n# clang.  May make Vim twice as slow.  Errors reported on stderr.\n# More at: https://code.google.com/p/address-sanitizer/\n#SANITIZER_CFLAGS = -g -O0 -fsanitize=address -fno-omit-frame-pointer\n#SANITIZER_CFLAGS = -g -O0 -fsanitize=undefined -fno-omit-frame-pointer\nSANITIZER_LIBS = $(SANITIZER_CFLAGS)\n\n# MEMORY LEAK DETECTION\n# Requires installing the ccmalloc library.\n# Configuration is in the .ccmalloc or ~/.ccmalloc file.\n# Doesn't work very well, since memory linked to from global variables\n# (in libraries) is also marked as leaked memory.\n#LEAK_CFLAGS = -DEXITFREE\n#LEAK_LIBS = -lccmalloc\n\n# Uncomment this line to have Vim call abort() when an internal error is\n# detected.  Useful when using a tool to find errors.\n#ABORT_CLFAGS = -DABORT_ON_INTERNAL_ERROR\n\n#####################################################\n###  Specific systems, check if yours is listed!  ### {{{\n#####################################################\n\n### Uncomment things here only if the values chosen by configure are wrong.\n### It's better to adjust configure.ac and \"make autoconf\", if you can!\n### Then send the required changes to configure.ac to the bugs list.\n\n### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries\n###\n#CC = shlicc2\n#CFLAGS = -O2 -g -m486 -Wall -Wshadow -Wmissing-prototypes -fno-builtin\n\n### (2) HP-UX with a non-ANSI cc, use the c89 ANSI compiler\n###\tThe first probably works on all systems\n###\tThe second should work a bit better on newer systems\n###\tThe third should work a bit better on HPUX 11.11\n###\tInformation provided by: Richard Allen <ra@rhi.hi.is>\n#CC = c89 -D_HPUX_SOURCE\n#CC = c89 -O +Onolimit +ESlit -D_HPUX_SOURCE\n#CC = c89 -O +Onolimit +ESlit +e -D_HPUX_SOURCE\n\n### (2) For HP-UX: Enable the use of a different set of digraphs.  Use this\n###\twhen the default (ISO) digraphs look completely wrong.\n###\tAfter changing this do \"touch digraph.c; make\".\n#EXTRA_DEFS = -DHPUX_DIGRAPHS\n\n### (2) For HP-UX: 9.04 cpp default macro definition table of 128000 bytes\n###\tis too small to compile many routines.\tIt produces too much defining\n###\tand no space errors.\n###\tUncomment the following to specify a larger macro definition table.\n#CFLAGS = -Wp,-H256000\n\n### (2) For HP-UX 10.20 using the HP cc, with X11R6 and Motif 1.2, with\n###\tlibraries in /usr/lib instead of /lib (avoiding transition links).\n###\tInformation provided by: David Green\n#XROOT = /usr\n#CONF_OPT_X = --x-include=$(XROOT)/include/X11R6 --x-libraries=$(XROOT)/lib/X11R6\n#GUI_INC_LOC = -I/usr/include/Motif1.2\n#GUI_LIB_LOC = -L/usr/lib/Motif1.2_R6\n\n### (5) AIX 4.1.4 with cc\n#CFLAGS = -O -qmaxmem=8192\n\n###     AIX with c89 (Walter Briscoe)\n#CC = c89\n#CPPFLAGS = -D_ALL_SOURCE\n\n###     AIX 4.3.3.12 with xic 3.6.6 (David R. Favor)\n#       needed to avoid a problem where strings.h gets included\n#CFLAGS = -qsrcmsg -O2 -qmaxmem=8192 -D__STR31__\n\n### (W) Solaris with multi-threaded libraries (-lthread):\n###\tIf suspending doesn't work properly, try using this line:\n#EXTRA_DEFS = -D_REENTRANT\n\n### (7) Solaris 2.4/2.5 with Centerline compiler\n#CC = clcc\n#X_LIBS_DIR = -L/usr/openwin/lib -R/usr/openwin/lib\n#CFLAGS = -O\n\n### (9) Solaris 2.x with cc (SunPro), using Athena.\n###\tOnly required for compiling gui_at_sb.c.\n###\tSymptom: \"identifier redeclared: vim_XawScrollbarSetThumb\"\n###\tUse one of the lines (either Full ANSI or no ANSI at all)\n#CFLAGS = $(CFLAGS) -Xc\n#CFLAGS = $(CFLAGS) -Xs\n\n### Solaris 2.3 with X11 and specific cc\n#CC=/opt/SUNWspro/bin/cc -O -Xa -v -R/usr/openwin/lib\n\n### Solaris with /usr/ucb/cc (it is rejected by autoconf as \"cc\")\n#CC\t    = /usr/ucb/cc\n#EXTRA_LIBS = -R/usr/ucblib\n\n### Solaris with Forte Developer and FEAT_SUN_WORKSHOP\n# The Xpm library is available from http://koala.ilog.fr/ftp/pub/xpm.\n#CC\t\t= cc\n#XPM_DIR\t\t= /usr/local/xpm/xpm-3.4k-solaris\n#XPM_LIB\t\t= -L$(XPM_DIR)/lib -R$(XPM_DIR)/lib -lXpm\n#XPM_IPATH\t= -I$(XPM_DIR)/include\n#EXTRA_LIBS\t= $(XPM_LIB)\n#EXTRA_IPATHS\t= $(XPM_IPATH)\n#EXTRA_DEFS\t= -xCC -DHAVE_X11_XPM_H\n\n### Solaris with workshop compilers: Vim is unstable when compiled with\n# \"-fast\".  Use this instead. (Shea Martin)\n#CFLAGS = -x02 -xtarget=ultra\n\n### (R) for Solaris 2.5 (or 2.5.1) with gcc > 2.5.6 you might need this:\n#LDFLAGS = -lw -ldl -lXmu\n#GUI_LIB_LOC = -L/usr/local/lib\n\n### (8) Unisys 6035 (Glauber Ribeiro)\n#EXTRA_LIBS = -lnsl -lsocket -lgen\n\n### When builtin functions cause problems with gcc (for Sun 4.1.x)\n#CFLAGS = -O2 -Wall -traditional -Wno-implicit\n\n### Apollo DOMAIN (with SYSTYPE = bsd4.3) (TESTED for version 3.0)\n#EXTRA_DEFS = -DDOMAIN\n#CFLAGS= -O -A systype,bsd4.3\n\n### Coherent 4.2.10 on Intel 386 platform\n#EXTRA_DEFS = -Dvoid=int\n#EXTRA_LIBS = -lterm -lsocket\n\n### SCO 3.2, with different library name for terminfo\n#EXTRA_LIBS = -ltinfo\n\n### UTS2 for Amdahl UTS 2.1.x\n#EXTRA_DEFS = -DUTS2\n#EXTRA_LIBS = -lsocket\n\n### UTS4 for Amdahl UTS 4.x\n#EXTRA_DEFS = -DUTS4 -Xa\n\n### USL for Unix Systems Laboratories (SYSV 4.2)\n#EXTRA_DEFS = -DUSL\n\n### (6)  A/UX 3.1.1 with gcc (Jim Jagielski)\n#CC= gcc -D_POSIX_SOURCE\n#CFLAGS= -O2\n#EXTRA_LIBS = -lposix -lbsd -ltermcap -lX11\n\n### (A)  Some versions of SCO Open Server 5 (Jan Christiaan van Winkel)\n###\t Also use the CONF_TERM_LIB below!\n#EXTRA_LIBS = -lgen\n\n### (D)  QNX (by G.F. Desrochers)\n#CFLAGS = -g -O -mf -4\n\n### (F)  QNX (by John Oleynick)\n# 1. If you don't have an X server: Comment out CONF_OPT_GUI and uncomment\n#    CONF_OPT_X = --without-x.\n# 2. make config\n# 3. edit auto/config.mk and remove -ldir and -ltermcap from LIBS.  It doesn't\n#\thave -ldir (does config find it somewhere?) and -ltermcap has at\n#\tleast one problem so I use termlib.o instead.  The problem with\n#\ttermcap is that it segfaults if you call it with the name of\n#\ta non-existent terminal type.\n# 4. edit auto/config.h and add #define USE_TMPNAM\n# 5. add termlib.o to OBJ\n# 6. make\n\n### (H)  for Data general DG/UX 5.4.2 and 5.4R3.10 (Jonas J. Schlein)\n#EXTRA_LIBS = -lgen\n\n### (I) SINIX-N 5.42 or 5.43 RM400 R4000 (also SINIX-Y and SINIX-Z)\n#EXTRA_LIBS = -lgen -lnsl\n###   For SINIX-Y this is needed for the right prototype of gettimeofday()\n#EXTRA_DEFS = -D_XPG_IV\n\n### (I) Reliant-Unix (aka SINIX) 5.44 with standard cc\n#\tUse both \"-F O3\" lines for optimization or the \"-g\" line for debugging\n#EXTRA_LIBS = -lgen -lsocket -lnsl -lSM -lICE\n#CFLAGS = -F O3 -DSINIXN\n#LDFLAGS = -F O3\n#CFLAGS = -g -DSINIXN\n\n### (P)  SCO 3.2.42, with different termcap names for some useful keys DJB\n#EXTRA_DEFS = -DSCOKEYS -DNETTERM_MOUSE -DDEC_MOUSE -DXTERM_MOUSE -DHAVE_GETTIMEOFDAY\n#EXTRA_LIBS = -lsocket -ltermcap -lmalloc -lc_s\n\n### (P)  SuperUX 6.2 on NEC SX-4 (Lennart Schultz)\n#GUI_INC_LOC = -I/usr/include\n#GUI_LIB_LOC = -L/usr/lib\n#EXTRA_LIBS = -lgen\n\n### (Q) UNIXSVR 4.2MP on NEC UP4800 (Lennart Schultz)\n#GUI_INC_LOC = -I/usr/necccs/include\n#GUI_LIB_LOC = -L/usr/necccs/lib/X11R6\n#XROOT = /usr/necccs\n#CONF_OPT_X = --x-include=$(XROOT)/include --x-libraries=$(XROOT)/lib/X11R6\n#EXTRA_LIBS = -lsocket -lgen\n\n### Irix 4.0 & 5.2 (Silicon Graphics Machines, __sgi will be defined)\n# Not needed for Irix 5.3, Ives Aerts reported\n#EXTRA_LIBS = -lmalloc -lc_s\n# Irix 4.0, when regexp and regcmp cannot be found when linking:\n#EXTRA_LIBS = -lmalloc -lc_s -lPW\n\n### (S) Irix 6.x (MipsPro compiler): Uses different Olimit flag:\n# Note:\tThis newer option style is used with the MipsPro compilers ONLY if\n#\tyou are compiling an \"n32\" or \"64\" ABI binary (use either a -n32\n#\tflag or a -64 flag for CFLAGS).  If you explicitly use a -o32 flag,\n#\tthen the CFLAGS option format will be the typical style (i.e.\n#\t-Olimit 3000).\n#CFLAGS = -OPT:Olimit=3000 -O\n\n### (S) Irix 6.5 with MipsPro C compiler.  Try this as a test to see new\n#\tcompiler features!  Beware, the optimization is EXTREMELY thorough\n#\tand takes quite a long time.\n# Note: See the note above.  Here, the -mips3 option automatically\n#\tenables either the \"n32\" or \"64\" ABI, depending on what machine you\n#\tare compiling on (n32 is explicitly enabled here, just to make sure).\n#CFLAGS = -OPT:Olimit=3500 -O -n32 -mips3 -IPA:aggr_cprop=ON -INLINE:dfe=ON:list=ON:must=screen_char,out_char,ui_write,out_flush\n#LDFLAGS= -OPT:Olimit=3500 -O -n32 -mips3 -IPA:aggr_cprop=ON -INLINE:dfe=ON:list=ON:must=screen_char,out_char,ui_write,out_flush\n\n### (K) for SGI Irix machines with 64 bit pointers (\"uname -s\" says IRIX64)\n###\tSuggested by Jon Wright <jon@gate.sinica.edu.tw>.\n###\tTested on R8000 IRIX6.1 Power Indigo2.\n###\tCheck /etc/compiler.defaults for your compiler settings.\n# either (for 64 bit pointers) uncomment the following line\n#GUI_LIB_LOC = -L/usr/lib64\n# then\n# 1) make config\n# 2) edit auto/config.mk and delete the -lelf entry in the LIBS line\n# 3) make\n#\n# or (for 32bit pointers) uncomment the following line\n#EXTRA_DEFS = -n32\n#GUI_LIB_LOC = -L/usr/lib32\n# then\n# 1) make config\n# 2) edit auto/config.mk, add -n32 to LDFLAGS\n# 3) make\n#\n#Alternatively: use -o32 instead of -n32.\n###\n\n### (C)  On SCO Unix v3.2.5 (and probably other versions) the termcap library,\n###\t which is found by configure, doesn't work correctly.  Symptom is the\n###\t error message \"Termcap entry too long\".  Uncomment the next line.\n###\t On AIX 4.2.1 (and other versions probably), libtermcap is reported\n###\t not to display properly.\n### after changing this, you need to do \"make reconfig\".\n#CONF_TERM_LIB = --with-tlib=curses\n\n### (E)  If you want to use termlib library instead of the automatically found\n###\t one.  After changing this, you need to do \"make reconfig\".\n#CONF_TERM_LIB = --with-tlib=termlib\n\n### (a)  ESIX V4.2 (Reinhard Wobst)\n#EXTRA_LIBS = -lnsl -lsocket -lgen -lXIM -lXmu -lXext\n\n### (c)  Tandem/NSK (Matthew Woehlke)\n#EXTRA_LIBS = -lfloss\n\n### If you want to use ncurses library instead of the automatically found one\n### after changing this, you need to do \"make reconfig\".\n#CONF_TERM_LIB = --with-tlib=ncurses\n\n### For GCC on MS-Windows, the \".exe\" suffix will be added.\n#EXEEXT = .exe\n#LNKEXT = .exe\n\n### (O)  For LynxOS 2.5.0, tested on PC.\n#EXTRA_LIBS = -lXext -lSM -lICE -lbsd\n###\t For LynxOS 3.0.1, tested on PPC\n#EXTRA_LIBS= -lXext -lSM -lICE -lnetinet -lXmu -liberty -lX11\n###\t For LynxOS 3.1.0, tested on PC\n#EXTRA_LIBS= -lXext -lSM -lICE -lnetinet -lXmu\n\n\n### (V)  For CX/UX 6.2\t(on Harris/Concurrent NightHawk 4800, 5800). Remove\n###\t -Qtarget if only in a 5800 environment.  (Kipp E. Howard)\n#CFLAGS = -O -Qtarget=m88110compat\n#EXTRA_LIBS = -lgen\n\n# The value of QUOTESED comes from auto/config.mk.\n# Uncomment the next line to use the default value.\n# QUOTESED = sed -e 's/[\\\\\"]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";$$/\";/'\n\n##################### end of system specific lines ################### }}}\n\n### Names of the programs and targets  {{{1\nVIMTARGET\t= $(VIMNAME)$(EXEEXT)\nEXTARGET\t= $(EXNAME)$(LNKEXT)\nVIEWTARGET\t= $(VIEWNAME)$(LNKEXT)\nGVIMNAME\t= g$(VIMNAME)\nGVIMTARGET\t= $(GVIMNAME)$(LNKEXT)\nGVIEWNAME\t= g$(VIEWNAME)\nGVIEWTARGET\t= $(GVIEWNAME)$(LNKEXT)\nRVIMNAME\t= r$(VIMNAME)\nRVIMTARGET\t= $(RVIMNAME)$(LNKEXT)\nRVIEWNAME\t= r$(VIEWNAME)\nRVIEWTARGET\t= $(RVIEWNAME)$(LNKEXT)\nRGVIMNAME\t= r$(GVIMNAME)\nRGVIMTARGET\t= $(RGVIMNAME)$(LNKEXT)\nRGVIEWNAME\t= r$(GVIEWNAME)\nRGVIEWTARGET\t= $(RGVIEWNAME)$(LNKEXT)\nVIMDIFFNAME\t= $(VIMNAME)diff\nGVIMDIFFNAME\t= g$(VIMDIFFNAME)\nVIMDIFFTARGET\t= $(VIMDIFFNAME)$(LNKEXT)\nGVIMDIFFTARGET\t= $(GVIMDIFFNAME)$(LNKEXT)\nEVIMNAME\t= e$(VIMNAME)\nEVIMTARGET\t= $(EVIMNAME)$(LNKEXT)\nEVIEWNAME\t= e$(VIEWNAME)\nEVIEWTARGET\t= $(EVIEWNAME)$(LNKEXT)\n\n### Names of the tools that are also made  {{{1\nTOOLS = xxd/xxd$(EXEEXT)\n\n### Installation directories.  The defaults come from configure. {{{1\n#\n### prefix\tthe top directory for the data (default \"/usr/local\")\n#\n# Uncomment the next line to install Vim in your home directory.\n#prefix = $(HOME)\n\n### exec_prefix\tis the top directory for the executable (default $(prefix))\n#\n# Uncomment the next line to install the Vim executable in \"/usr/machine/bin\"\n#exec_prefix = /usr/machine\n\n### BINDIR\tdir for the executable\t (default \"$(exec_prefix)/bin\")\n### MANDIR\tdir for the manual pages (default \"$(prefix)/man\")\n### DATADIR\tdir for the other files  (default \"$(prefix)/lib\" or\n#\t\t\t\t\t\t  \"$(prefix)/share\")\n# They may be different when using different architectures for the\n# executable and a common directory for the other files.\n#\n# Uncomment the next line to install Vim in \"/usr/bin\"\n#BINDIR   = /usr/bin\n# Uncomment the next line to install Vim manuals in \"/usr/share/man/man1\"\n#MANDIR   = /usr/share/man\n# Uncomment the next line to install Vim help files in \"/usr/share/vim\"\n#DATADIR  = /usr/share\n\n### DESTDIR\troot of the installation tree.  This is prepended to the other\n#\t\tdirectories.  This directory must exist.\n#DESTDIR  = ~/pkg/vim\n\n### Directory of the man pages\nMAN1DIR = /man1\n\n### Vim version (adjusted by a script)\nVIMMAJOR = 8\nVIMMINOR = 0\n\n### Location of Vim files (should not need to be changed, and  {{{1\n### some things might not work when they are changed!)\nVIMDIR = /vim\nVIMRTDIR = /vim$(VIMMAJOR)$(VIMMINOR)\nHELPSUBDIR = /doc\nCOLSUBDIR = /colors\nSYNSUBDIR = /syntax\nINDSUBDIR = /indent\nAUTOSUBDIR = /autoload\nPLUGSUBDIR = /plugin\nFTPLUGSUBDIR = /ftplugin\nLANGSUBDIR = /lang\nCOMPSUBDIR = /compiler\nKMAPSUBDIR = /keymap\nMACROSUBDIR = /macros\nPACKSUBDIR = /pack\nTOOLSSUBDIR = /tools\nTUTORSUBDIR = /tutor\nSPELLSUBDIR = /spell\nPRINTSUBDIR = /print\nPODIR = po\n\n### VIMLOC\tcommon root of the Vim files (all versions)\n### VIMRTLOC\tcommon root of the runtime Vim files (this version)\n### VIMRCLOC\tcompiled-in location for global [g]vimrc files (all versions)\n### VIMRUNTIMEDIR  compiled-in location for runtime files (optional)\n### HELPSUBLOC\tlocation for help files\n### COLSUBLOC\tlocation for colorscheme files\n### SYNSUBLOC\tlocation for syntax files\n### INDSUBLOC\tlocation for indent files\n### AUTOSUBLOC\tlocation for standard autoload files\n### PLUGSUBLOC\tlocation for standard plugin files\n### FTPLUGSUBLOC  location for ftplugin files\n### LANGSUBLOC\tlocation for language files\n### COMPSUBLOC\tlocation for compiler files\n### KMAPSUBLOC\tlocation for keymap files\n### MACROSUBLOC\tlocation for macro files\n### PACKSUBLOC\tlocation for packages\n### TOOLSSUBLOC\tlocation for tools files\n### TUTORSUBLOC\tlocation for tutor files\n### SPELLSUBLOC\tlocation for spell files\n### PRINTSUBLOC\tlocation for PostScript files (prolog, latin1, ..)\n### SCRIPTLOC\tlocation for script files (menu.vim, bugreport.vim, ..)\n### You can override these if you want to install them somewhere else.\n### Edit feature.h for compile-time settings.\nVIMLOC\t\t= $(DATADIR)$(VIMDIR)\nVIMRTLOC\t= $(DATADIR)$(VIMDIR)$(VIMRTDIR)\nVIMRCLOC\t= $(VIMLOC)\nHELPSUBLOC\t= $(VIMRTLOC)$(HELPSUBDIR)\nCOLSUBLOC\t= $(VIMRTLOC)$(COLSUBDIR)\nSYNSUBLOC\t= $(VIMRTLOC)$(SYNSUBDIR)\nINDSUBLOC\t= $(VIMRTLOC)$(INDSUBDIR)\nAUTOSUBLOC\t= $(VIMRTLOC)$(AUTOSUBDIR)\nPLUGSUBLOC\t= $(VIMRTLOC)$(PLUGSUBDIR)\nFTPLUGSUBLOC\t= $(VIMRTLOC)$(FTPLUGSUBDIR)\nLANGSUBLOC\t= $(VIMRTLOC)$(LANGSUBDIR)\nCOMPSUBLOC\t= $(VIMRTLOC)$(COMPSUBDIR)\nKMAPSUBLOC\t= $(VIMRTLOC)$(KMAPSUBDIR)\nMACROSUBLOC\t= $(VIMRTLOC)$(MACROSUBDIR)\nPACKSUBLOC\t= $(VIMRTLOC)$(PACKSUBDIR)\nTOOLSSUBLOC\t= $(VIMRTLOC)$(TOOLSSUBDIR)\nTUTORSUBLOC\t= $(VIMRTLOC)$(TUTORSUBDIR)\nSPELLSUBLOC\t= $(VIMRTLOC)$(SPELLSUBDIR)\nPRINTSUBLOC\t= $(VIMRTLOC)$(PRINTSUBDIR)\nSCRIPTLOC\t= $(VIMRTLOC)\n\n### Only set VIMRUNTIMEDIR when VIMRTLOC is set to a different location and\n### the runtime directory is not below it.\n#VIMRUNTIMEDIR = $(VIMRTLOC)\n\n### Name of the defaults/evim/mswin file target.\nVIM_DEFAULTS_FILE = $(DESTDIR)$(SCRIPTLOC)/defaults.vim\nEVIM_FILE\t= $(DESTDIR)$(SCRIPTLOC)/evim.vim\nMSWIN_FILE\t= $(DESTDIR)$(SCRIPTLOC)/mswin.vim\n\n### Name of the menu file target.\nSYS_MENU_FILE\t= $(DESTDIR)$(SCRIPTLOC)/menu.vim\nSYS_SYNMENU_FILE = $(DESTDIR)$(SCRIPTLOC)/synmenu.vim\nSYS_DELMENU_FILE = $(DESTDIR)$(SCRIPTLOC)/delmenu.vim\n\n### Name of the bugreport file target.\nSYS_BUGR_FILE\t= $(DESTDIR)$(SCRIPTLOC)/bugreport.vim\n\n### Name of the rgb.txt file target.\nSYS_RGB_FILE   = $(DESTDIR)$(SCRIPTLOC)/rgb.txt\n\n### Name of the file type detection file target.\nSYS_FILETYPE_FILE = $(DESTDIR)$(SCRIPTLOC)/filetype.vim\n\n### Name of the file type detection file target.\nSYS_FTOFF_FILE\t= $(DESTDIR)$(SCRIPTLOC)/ftoff.vim\n\n### Name of the file type detection script file target.\nSYS_SCRIPTS_FILE = $(DESTDIR)$(SCRIPTLOC)/scripts.vim\n\n### Name of the ftplugin-on file target.\nSYS_FTPLUGIN_FILE = $(DESTDIR)$(SCRIPTLOC)/ftplugin.vim\n\n### Name of the ftplugin-off file target.\nSYS_FTPLUGOF_FILE = $(DESTDIR)$(SCRIPTLOC)/ftplugof.vim\n\n### Name of the indent-on file target.\nSYS_INDENT_FILE = $(DESTDIR)$(SCRIPTLOC)/indent.vim\n\n### Name of the indent-off file target.\nSYS_INDOFF_FILE = $(DESTDIR)$(SCRIPTLOC)/indoff.vim\n\n### Name of the option window script file target.\nSYS_OPTWIN_FILE = $(DESTDIR)$(SCRIPTLOC)/optwin.vim\n\n# Program to install the program in the target directory.  Could also be \"mv\".\nINSTALL_PROG\t= cp\n\n# Program to install the data in the target directory.\tCannot be \"mv\"!\nINSTALL_DATA\t= cp\nINSTALL_DATA_R\t= cp -r\n\n### Program to run on installed binary.  Use the second one to disable strip.\n#STRIP = strip\n#STRIP = /bin/true\n\n### Permissions for binaries  {{{1\nBINMOD = 755\n\n### Permissions for man page\nMANMOD = 644\n\n### Permissions for help files\nHELPMOD = 644\n\n### Permissions for Perl and shell scripts\nSCRIPTMOD = 755\n\n### Permission for Vim script files (menu.vim, bugreport.vim, ..)\nVIMSCRIPTMOD = 644\n\n### Permissions for all directories that are created\nDIRMOD = 755\n\n### Permissions for all other files that are created\nFILEMOD = 644\n\n# Where to copy the man and help files from\nHELPSOURCE = ../runtime/doc\n\n# Where to copy the script files from (menu, bugreport)\nSCRIPTSOURCE = ../runtime\n\n# Where to copy the colorscheme files from\nCOLSOURCE = ../runtime/colors\n\n# Where to copy the syntax files from\nSYNSOURCE = ../runtime/syntax\n\n# Where to copy the indent files from\nINDSOURCE = ../runtime/indent\n\n# Where to copy the standard plugin files from\nAUTOSOURCE = ../runtime/autoload\n\n# Where to copy the standard plugin files from\nPLUGSOURCE = ../runtime/plugin\n\n# Where to copy the ftplugin files from\nFTPLUGSOURCE = ../runtime/ftplugin\n\n# Where to copy the macro files from\nMACROSOURCE = ../runtime/macros\n\n# Where to copy the package files from\nPACKSOURCE = ../runtime/pack\n\n# Where to copy the tools files from\nTOOLSSOURCE = ../runtime/tools\n\n# Where to copy the tutor files from\nTUTORSOURCE = ../runtime/tutor\n\n# Where to copy the spell files from\nSPELLSOURCE = ../runtime/spell\n\n# Where to look for language specific files\nLANGSOURCE = ../runtime/lang\n\n# Where to look for compiler files\nCOMPSOURCE = ../runtime/compiler\n\n# Where to look for keymap files\nKMAPSOURCE = ../runtime/keymap\n\n# Where to look for print resource files\nPRINTSOURCE = ../runtime/print\n\n# If you are using Linux, you might want to use this to make vim the\n# default vi editor, it will create a link from vi to Vim when doing\n# \"make install\".  An existing file will be overwritten!\n# When not using it, some make programs can't handle an undefined $(LINKIT).\n#LINKIT = ln -f -s $(DEST_BIN)/$(VIMTARGET) $(DESTDIR)/usr/bin/vi\nLINKIT = @echo >/dev/null\n\n###\n### GRAPHICAL USER INTERFACE (GUI).  {{{1\n### 'configure --enable-gui' can enable one of these for you if you did set\n### a corresponding CONF_OPT_GUI above and have X11.\n### Override configures choice by uncommenting all the following lines.\n### As they are, the GUI is disabled.  Replace \"NONE\" with \"ATHENA\" or \"MOTIF\"\n### for enabling the Athena or Motif GUI.\n#GUI_SRC\t= $(NONE_SRC)\n#GUI_OBJ\t= $(NONE_OBJ)\n#GUI_DEFS\t= $(NONE_DEFS)\n#GUI_IPATH\t= $(NONE_IPATH)\n#GUI_LIBS_DIR\t= $(NONE_LIBS_DIR)\n#GUI_LIBS1\t= $(NONE_LIBS1)\n#GUI_LIBS2\t= $(NONE_LIBS2)\n#GUI_INSTALL    = $(NONE_INSTALL)\n#GUI_TARGETS\t= $(NONE_TARGETS)\n#GUI_MAN_TARGETS= $(NONE_MAN_TARGETS)\n#GUI_TESTTARGET = $(NONE_TESTTARGET)\n#GUI_BUNDLE\t= $(NONE_BUNDLE)\n\n# Without a GUI install the normal way.\nNONE_INSTALL = install_normal\n\n### GTK GUI\nGTK_SRC\t\t= gui.c gui_gtk.c gui_gtk_x11.c gui_gtk_f.c \\\n\t\t\tgui_beval.c $(GRESOURCE_SRC)\nGTK_OBJ\t\t= objects/gui.o objects/gui_gtk.o objects/gui_gtk_x11.o \\\n\t\t\tobjects/gui_gtk_f.o \\\n\t\t\tobjects/gui_beval.o $(GRESOURCE_OBJ)\nGTK_DEFS\t= -DFEAT_GUI_GTK $(NARROW_PROTO)\nGTK_IPATH\t= $(GUI_INC_LOC)\nGTK_LIBS_DIR\t= $(GUI_LIB_LOC)\nGTK_LIBS1\t=\nGTK_LIBS2\t= $(GTK_LIBNAME)\nGTK_INSTALL     = install_normal install_gui_extra\nGTK_TARGETS\t= installglinks\nGTK_MAN_TARGETS = yes\nGTK_TESTTARGET  = gui\nGTK_BUNDLE\t=\n\n### Motif GUI\nMOTIF_SRC\t= gui.c gui_motif.c gui_x11.c gui_beval.c \\\n\t\t\tgui_xmdlg.c gui_xmebw.c\nMOTIF_OBJ\t= objects/gui.o objects/gui_motif.o objects/gui_x11.o \\\n\t\t\tobjects/gui_beval.o \\\n\t\t\tobjects/gui_xmdlg.o objects/gui_xmebw.o\nMOTIF_DEFS\t= -DFEAT_GUI_MOTIF $(NARROW_PROTO)\nMOTIF_IPATH\t= $(GUI_INC_LOC)\nMOTIF_LIBS_DIR\t= $(GUI_LIB_LOC)\nMOTIF_LIBS1\t=\nMOTIF_LIBS2\t= $(MOTIF_LIBNAME) -lXt\nMOTIF_INSTALL   = install_normal install_gui_extra\nMOTIF_TARGETS\t= installglinks\nMOTIF_MAN_TARGETS = yes\nMOTIF_TESTTARGET = gui\nMOTIF_BUNDLE\t=\n\n### Athena GUI\n### Use Xaw3d to make the menus look a little bit nicer\n#XAW_LIB = -lXaw3d\nXAW_LIB = -lXaw\n\n### When using Xaw3d, uncomment/comment the following lines to also get the\n### scrollbars from Xaw3d.\n#ATHENA_SRC\t= gui.c gui_athena.c gui_x11.c gui_beval.c gui_at_fs.c\n#ATHENA_OBJ\t= objects/gui.o objects/gui_athena.o objects/gui_x11.o \\\n#\t\t\tobjects/gui_beval.o objects/gui_at_fs.o\n#ATHENA_DEFS\t= -DFEAT_GUI_ATHENA $(NARROW_PROTO) \\\n#\t\t    -Dvim_scrollbarWidgetClass=scrollbarWidgetClass \\\n#\t\t    -Dvim_XawScrollbarSetThumb=XawScrollbarSetThumb\nATHENA_SRC\t= gui.c gui_athena.c gui_x11.c gui_beval.c \\\n\t\t\tgui_at_sb.c gui_at_fs.c\nATHENA_OBJ\t= objects/gui.o objects/gui_athena.o objects/gui_x11.o \\\n\t\t\tobjects/gui_beval.o \\\n\t\t\tobjects/gui_at_sb.o objects/gui_at_fs.o\nATHENA_DEFS\t= -DFEAT_GUI_ATHENA $(NARROW_PROTO)\n\nATHENA_IPATH\t= $(GUI_INC_LOC)\nATHENA_LIBS_DIR = $(GUI_LIB_LOC)\nATHENA_LIBS1\t= $(XAW_LIB)\nATHENA_LIBS2\t= -lXt\nATHENA_INSTALL  = install_normal install_gui_extra\nATHENA_TARGETS\t= installglinks\nATHENA_MAN_TARGETS = yes\nATHENA_TESTTARGET = gui\nATHENA_BUNDLE\t=\n\n### neXtaw GUI\nNEXTAW_LIB = -lneXtaw\n\nNEXTAW_SRC\t= gui.c gui_athena.c gui_x11.c gui_beval.c gui_at_fs.c\nNEXTAW_OBJ\t= objects/gui.o objects/gui_athena.o objects/gui_x11.o \\\n\t\t\tobjects/gui_beval.o objects/gui_at_fs.o\nNEXTAW_DEFS\t= -DFEAT_GUI_ATHENA -DFEAT_GUI_NEXTAW $(NARROW_PROTO)\n\nNEXTAW_IPATH\t= $(GUI_INC_LOC)\nNEXTAW_LIBS_DIR = $(GUI_LIB_LOC)\nNEXTAW_LIBS1\t= $(NEXTAW_LIB)\nNEXTAW_LIBS2\t= -lXt\nNEXTAW_INSTALL  =  install_normal install_gui_extra\nNEXTAW_TARGETS\t=  installglinks\nNEXTAW_MAN_TARGETS = yes\nNEXTAW_TESTTARGET = gui\nNEXTAW_BUNDLE\t=\n\n### (J)  Sun OpenWindows 3.2 (SunOS 4.1.x) or earlier that produce these ld\n#\t errors:  ld: Undefined symbol\n#\t\t      _get_wmShellWidgetClass\n#\t\t      _get_applicationShellWidgetClass\n# then you need to get patches 100512-02 and 100573-03 from Sun.  In the\n# meantime, uncomment the following GUI_X_LIBS definition as a workaround:\n#GUI_X_LIBS = -Bstatic -lXmu -Bdynamic -lXext\n# If you also get cos, sin etc. as undefined symbols, try uncommenting this\n# too:\n#EXTRA_LIBS = /usr/openwin/lib/libXmu.sa -lm\n\n# PHOTON GUI\nPHOTONGUI_SRC\t= gui.c gui_photon.c\nPHOTONGUI_OBJ\t= objects/gui.o objects/gui_photon.o\nPHOTONGUI_DEFS\t= -DFEAT_GUI_PHOTON\nPHOTONGUI_IPATH\t=\nPHOTONGUI_LIBS_DIR =\nPHOTONGUI_LIBS1\t= -lph -lphexlib\nPHOTONGUI_LIBS2\t=\nPHOTONGUI_INSTALL = install_normal install_gui_extra\nPHOTONGUI_TARGETS = installglinks\nPHOTONGUI_MAN_TARGETS = yes\nPHOTONGUI_TESTTARGET = gui\nPHOTONGUI_BUNDLE =\n\n# CARBON GUI\nCARBONGUI_SRC\t= gui.c gui_mac.c\nCARBONGUI_OBJ\t= objects/gui.o objects/gui_mac.o\nCARBONGUI_DEFS\t= -DFEAT_GUI_MAC -fno-common -fpascal-strings \\\n\t\t  -Wall -Wno-unknown-pragmas \\\n\t\t  -mdynamic-no-pic -pipe\nCARBONGUI_IPATH\t= -I. -Iproto\nCARBONGUI_LIBS_DIR =\nCARBONGUI_LIBS1\t= -framework Carbon\nCARBONGUI_LIBS2\t=\nCARBONGUI_INSTALL = install_macosx\nCARBONGUI_TARGETS =\nCARBONGUI_MAN_TARGETS =\nCARBONGUI_TESTTARGET = gui\nCARBONGUI_BUNDLE = gui_bundle\nAPPDIR = $(VIMNAME).app\nCARBONGUI_TESTARG = VIMPROG=../$(APPDIR)/Contents/MacOS/$(VIMTARGET)\n\n# All GUI files\nALL_GUI_SRC  = gui.c gui_gtk.c gui_gtk_f.c gui_motif.c gui_xmdlg.c gui_xmebw.c gui_athena.c gui_gtk_x11.c gui_x11.c gui_at_sb.c gui_at_fs.c\nALL_GUI_PRO  = gui.pro gui_gtk.pro gui_motif.pro gui_xmdlg.pro gui_athena.pro gui_gtk_x11.pro gui_x11.pro gui_w32.pro gui_photon.pro\n\n# }}}\n\nTERM_DEPS = \\\n\tlibvterm/include/vterm.h \\\n\tlibvterm/include/vterm_keycodes.h \\\n\tlibvterm/src/rect.h \\\n\tlibvterm/src/utf8.h \\\n\tlibvterm/src/vterm_internal.h\n\n### Command to create dependencies based on #include \"...\"\n### prototype headers are ignored due to -DPROTO, system\n### headers #include <...> are ignored if we use the -MM option, as\n### e.g. provided by gcc-cpp.\n### Include FEAT_GUI to get dependency on gui.h\n### Need to change \"-I /<path>\" to \"-isystem /<path>\" for GCC 3.x.\nCPP_DEPEND = $(CC) -I$(srcdir) -M$(CPP_MM) \\\n\t\t`echo \"$(DEPEND_CFLAGS)\" $(DEPEND_CFLAGS_FILTER)`\n\n# flags for cproto\n#     This is for cproto 3 patchlevel 8 or below\n#     __inline, __attribute__ and __extension__ are not recognized by cproto\n#     G_IMPLEMENT_INLINES is to avoid functions defined in glib/gutils.h.\n#NO_ATTR = -D__inline= -D__inline__= -DG_IMPLEMENT_INLINES \\\n#\t  -D\"__attribute__\\\\(x\\\\)=\" -D\"__asm__\\\\(x\\\\)=\" \\\n#\t  -D__extension__= -D__restrict=\"\" \\\n#\t  -D__gnuc_va_list=char -D__builtin_va_list=char\n\n#\n#     This is for cproto 3 patchlevel 9 or above (currently 4.6, 4.7g)\n#     __inline and __attribute__ are now recognized by cproto\n#     -D\"foo()=\" is not supported by all compilers so do not use it\nNO_ATTR=\n#\n# Use this for cproto 3 patchlevel 6 or below (use \"cproto -V\" to check):\n# PROTO_FLAGS = -f4 -d -E\"$(CPP)\" $(NO_ATTR)\n#\n# Use this for cproto 3 patchlevel 7 or above (use \"cproto -V\" to check):\nPROTO_FLAGS = -d -E\"$(CPP)\" $(NO_ATTR)\n\n\n################################################\n##   no changes required below this line      ##\n################################################\n\nSHELL = /bin/sh\n\n# We would normally use \"mkdir -p\" but it doesn't work properly everywhere.\n# Using AC_PROG_MKDIR_P in configure.ac has a problem with the \"auto\"\n# directory.  Always use the install-sh script, it's slower but reliable.\nMKDIR_P = $(SHELL) install-sh -c -d\n\n.SUFFIXES:\n.SUFFIXES: .c .o .pro\n\nPRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)\nPOST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)\n\nALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(ABORT_CLFAGS) $(POST_DEFS)\n\n# Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together\n# with \"-E\".\nOSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)\n\nLINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(TCL_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca\n\nLINT_EXTRA = -DHANGUL_INPUT -D\"__attribute__(x)=\"\n\nDEPEND_CFLAGS = -DPROTO -DDEPEND -DFEAT_GUI $(LINT_CFLAGS)\n\n# Note: MZSCHEME_LIBS must come before LIBS, because LIBS adds -lm which is\n# needed by racket.\nALL_LIB_DIRS = $(GUI_LIBS_DIR) $(X_LIBS_DIR)\nALL_LIBS = \\\n\t   $(GUI_LIBS1) \\\n\t   $(GUI_X_LIBS) \\\n\t   $(GUI_LIBS2) \\\n\t   $(X_PRE_LIBS) \\\n\t   $(X_LIBS) \\\n\t   $(X_EXTRA_LIBS) \\\n\t   $(MZSCHEME_LIBS) \\\n\t   $(LIBS) \\\n\t   $(EXTRA_LIBS) \\\n\t   $(LUA_LIBS) \\\n\t   $(PERL_LIBS) \\\n\t   $(PYTHON_LIBS) \\\n\t   $(PYTHON3_LIBS) \\\n\t   $(TCL_LIBS) \\\n\t   $(RUBY_LIBS) \\\n\t   $(PROFILE_LIBS) \\\n\t   $(SANITIZER_LIBS) \\\n\t   $(LEAK_LIBS)\n\n# abbreviations\nDEST_BIN = $(DESTDIR)$(BINDIR)\nDEST_VIM = $(DESTDIR)$(VIMLOC)\nDEST_RT = $(DESTDIR)$(VIMRTLOC)\nDEST_HELP = $(DESTDIR)$(HELPSUBLOC)\nDEST_COL = $(DESTDIR)$(COLSUBLOC)\nDEST_SYN = $(DESTDIR)$(SYNSUBLOC)\nDEST_IND = $(DESTDIR)$(INDSUBLOC)\nDEST_AUTO = $(DESTDIR)$(AUTOSUBLOC)\nDEST_PLUG = $(DESTDIR)$(PLUGSUBLOC)\nDEST_FTP = $(DESTDIR)$(FTPLUGSUBLOC)\nDEST_LANG = $(DESTDIR)$(LANGSUBLOC)\nDEST_COMP = $(DESTDIR)$(COMPSUBLOC)\nDEST_KMAP = $(DESTDIR)$(KMAPSUBLOC)\nDEST_MACRO = $(DESTDIR)$(MACROSUBLOC)\nDEST_PACK = $(DESTDIR)$(PACKSUBLOC)\nDEST_TOOLS = $(DESTDIR)$(TOOLSSUBLOC)\nDEST_TUTOR = $(DESTDIR)$(TUTORSUBLOC)\nDEST_SPELL = $(DESTDIR)$(SPELLSUBLOC)\nDEST_SCRIPT = $(DESTDIR)$(SCRIPTLOC)\nDEST_PRINT = $(DESTDIR)$(PRINTSUBLOC)\nDEST_MAN_TOP = $(DESTDIR)$(MANDIR)\n\n# We assume that the \".../man/xx/man1/\" directory is for latin1 manual pages.\n# Some systems use UTF-8, but these should find the \".../man/xx.UTF-8/man1/\"\n# directory first.\n# FreeBSD uses \".../man/xx.ISO8859-1/man1\" for latin1, use that one too.\nDEST_MAN = $(DEST_MAN_TOP)$(MAN1DIR)\nDEST_MAN_FR = $(DEST_MAN_TOP)/fr$(MAN1DIR)\nDEST_MAN_FR_I = $(DEST_MAN_TOP)/fr.ISO8859-1$(MAN1DIR)\nDEST_MAN_FR_U = $(DEST_MAN_TOP)/fr.UTF-8$(MAN1DIR)\nDEST_MAN_IT = $(DEST_MAN_TOP)/it$(MAN1DIR)\nDEST_MAN_IT_I = $(DEST_MAN_TOP)/it.ISO8859-1$(MAN1DIR)\nDEST_MAN_IT_U = $(DEST_MAN_TOP)/it.UTF-8$(MAN1DIR)\nDEST_MAN_JA_U = $(DEST_MAN_TOP)/ja$(MAN1DIR)\nDEST_MAN_PL = $(DEST_MAN_TOP)/pl$(MAN1DIR)\nDEST_MAN_PL_I = $(DEST_MAN_TOP)/pl.ISO8859-2$(MAN1DIR)\nDEST_MAN_PL_U = $(DEST_MAN_TOP)/pl.UTF-8$(MAN1DIR)\nDEST_MAN_RU = $(DEST_MAN_TOP)/ru.KOI8-R$(MAN1DIR)\nDEST_MAN_RU_U = $(DEST_MAN_TOP)/ru.UTF-8$(MAN1DIR)\n\n#\t     BASIC_SRC: files that are always used\n#\t       GUI_SRC: extra GUI files for current configuration\n#\t   ALL_GUI_SRC: all GUI files for Unix\n#\n#\t\t   SRC: files used for current configuration\n#\t      TAGS_SRC: source files used for make tags\n#\t     TAGS_INCL: include files used for make tags\n#\t       ALL_SRC: source files used for make depend and make lint\n\nTAGS_INCL = *.h\n\nBASIC_SRC = \\\n\tarabic.c \\\n\tblowfish.c \\\n\tbuffer.c \\\n\tcharset.c \\\n\tcrypt.c \\\n\tcrypt_zip.c \\\n\tdict.c \\\n\tdiff.c \\\n\tdigraph.c \\\n\tedit.c \\\n\teval.c \\\n\tevalfunc.c \\\n\tex_cmds.c \\\n\tex_cmds2.c \\\n\tex_docmd.c \\\n\tex_eval.c \\\n\tex_getln.c \\\n\tfarsi.c \\\n\tfileio.c \\\n\tfold.c \\\n\tgetchar.c \\\n\thardcopy.c \\\n\thashtab.c \\\n\tif_cscope.c \\\n\tif_xcmdsrv.c \\\n\tjson.c \\\n\tlist.c \\\n\tmain.c \\\n\tmark.c \\\n\tmemfile.c \\\n\tmemline.c \\\n\tmenu.c \\\n\tmessage.c \\\n\tmisc1.c \\\n\tmisc2.c \\\n\tmove.c \\\n\tmbyte.c \\\n\tnormal.c \\\n\tops.c \\\n\toption.c \\\n\tos_unix.c \\\n\tauto/pathdef.c \\\n\tpopupmnu.c \\\n\tpty.c \\\n\tquickfix.c \\\n\tregexp.c \\\n\tscreen.c \\\n\tsearch.c \\\n\tsha256.c \\\n\tspell.c \\\n\tspellfile.c \\\n\tsyntax.c \\\n\ttag.c \\\n\tterm.c \\\n\tterminal.c \\\n\tui.c \\\n\tundo.c \\\n\tuserfunc.c \\\n\tversion.c \\\n\twindow.c \\\n\t$(OS_EXTRA_SRC)\n\nSRC =\t$(BASIC_SRC) \\\n\t$(GUI_SRC) \\\n\t$(TERM_SRC) \\\n\t$(HANGULIN_SRC) \\\n\t$(LUA_SRC) \\\n\t$(MZSCHEME_SRC) \\\n\t$(PERL_SRC) \\\n\t$(PYTHON_SRC) $(PYTHON3_SRC) \\\n\t$(TCL_SRC) \\\n\t$(RUBY_SRC) \\\n\t$(WORKSHOP_SRC) \\\n\t$(WSDEBUG_SRC)\n\nTAGS_SRC = *.c *.cpp if_perl.xs\n\nEXTRA_SRC = hangulin.c if_lua.c if_mzsch.c auto/if_perl.c if_perlsfio.c \\\n\t    if_python.c if_python3.c if_tcl.c if_ruby.c \\\n\t    gui_beval.c workshop.c wsdebug.c integration.c \\\n\t    netbeans.c channel.c \\\n\t    $(GRESOURCE_SRC)\n\n# Unittest files\nJSON_TEST_SRC = json_test.c\nJSON_TEST_TARGET = json_test$(EXEEXT)\nKWORD_TEST_SRC = kword_test.c\nKWORD_TEST_TARGET = kword_test$(EXEEXT)\nMEMFILE_TEST_SRC = memfile_test.c\nMEMFILE_TEST_TARGET = memfile_test$(EXEEXT)\nMESSAGE_TEST_SRC = message_test.c\nMESSAGE_TEST_TARGET = message_test$(EXEEXT)\n\nUNITTEST_SRC = $(JSON_TEST_SRC) $(KWORD_TEST_SRC) $(MEMFILE_TEST_SRC) $(MESSAGE_TEST_SRC)\nUNITTEST_TARGETS = $(JSON_TEST_TARGET) $(KWORD_TEST_TARGET) $(MEMFILE_TEST_TARGET) $(MESSAGE_TEST_TARGET)\nRUN_UNITTESTS = run_json_test run_kword_test run_memfile_test run_message_test\n\n# All sources, also the ones that are not configured\nALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)\n\n# Which files to check with lint.  Select one of these three lines.  ALL_SRC\n# checks more, but may not work well for checking a GUI that wasn't configured.\n# The perl sources also don't work well with lint.\nLINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) \\\n\t   $(PYTHON_SRC) $(PYTHON3_SRC) $(TCL_SRC) \\\n\t   $(WORKSHOP_SRC) $(WSDEBUG_SRC) \\\n\t   $(NETBEANS_SRC) $(CHANNEL_SRC) $(TERM_SRC)\n#LINT_SRC = $(SRC)\n#LINT_SRC = $(ALL_SRC)\n#LINT_SRC = $(BASIC_SRC)\n\nOBJ_COMMON = \\\n\tobjects/arabic.o \\\n\tobjects/buffer.o \\\n\tobjects/blowfish.o \\\n\tobjects/crypt.o \\\n\tobjects/crypt_zip.o \\\n\tobjects/dict.o \\\n\tobjects/diff.o \\\n\tobjects/digraph.o \\\n\tobjects/edit.o \\\n\tobjects/eval.o \\\n\tobjects/evalfunc.o \\\n\tobjects/ex_cmds.o \\\n\tobjects/ex_cmds2.o \\\n\tobjects/ex_docmd.o \\\n\tobjects/ex_eval.o \\\n\tobjects/ex_getln.o \\\n\tobjects/farsi.o \\\n\tobjects/fileio.o \\\n\tobjects/fold.o \\\n\tobjects/getchar.o \\\n\tobjects/hardcopy.o \\\n\tobjects/hashtab.o \\\n\t$(HANGULIN_OBJ) \\\n\tobjects/if_cscope.o \\\n\tobjects/if_xcmdsrv.o \\\n\tobjects/list.o \\\n\tobjects/mark.o \\\n\tobjects/memline.o \\\n\tobjects/menu.o \\\n\tobjects/misc1.o \\\n\tobjects/misc2.o \\\n\tobjects/move.o \\\n\tobjects/mbyte.o \\\n\tobjects/normal.o \\\n\tobjects/ops.o \\\n\tobjects/option.o \\\n\tobjects/os_unix.o \\\n\tobjects/pathdef.o \\\n\tobjects/popupmnu.o \\\n\tobjects/pty.o \\\n\tobjects/quickfix.o \\\n\tobjects/regexp.o \\\n\tobjects/screen.o \\\n\tobjects/search.o \\\n\tobjects/sha256.o \\\n\tobjects/spell.o \\\n\tobjects/spellfile.o \\\n\tobjects/syntax.o \\\n\tobjects/tag.o \\\n\tobjects/term.o \\\n\tobjects/terminal.o \\\n\tobjects/ui.o \\\n\tobjects/undo.o \\\n\tobjects/userfunc.o \\\n\tobjects/version.o \\\n\tobjects/window.o \\\n\t$(GUI_OBJ) \\\n\t$(TERM_OBJ) \\\n\t$(LUA_OBJ) \\\n\t$(MZSCHEME_OBJ) \\\n\t$(PERL_OBJ) \\\n\t$(PYTHON_OBJ) \\\n\t$(PYTHON3_OBJ) \\\n\t$(TCL_OBJ) \\\n\t$(RUBY_OBJ) \\\n\t$(OS_EXTRA_OBJ) \\\n\t$(WORKSHOP_OBJ) \\\n\t$(NETBEANS_OBJ) \\\n\t$(CHANNEL_OBJ) \\\n\t$(WSDEBUG_OBJ)\n\n# The files included by tests are not in OBJ_COMMON.\nOBJ_MAIN = \\\n\tobjects/charset.o \\\n\tobjects/json.o \\\n\tobjects/main.o \\\n\tobjects/memfile.o \\\n\tobjects/message.o\n\nOBJ = $(OBJ_COMMON) $(OBJ_MAIN)\n\nOBJ_JSON_TEST = \\\n\tobjects/charset.o \\\n\tobjects/memfile.o \\\n\tobjects/message.o \\\n\tobjects/json_test.o\n\nJSON_TEST_OBJ = $(OBJ_COMMON) $(OBJ_JSON_TEST)\n\nOBJ_KWORD_TEST = \\\n\tobjects/json.o \\\n\tobjects/memfile.o \\\n\tobjects/message.o \\\n\tobjects/kword_test.o\n\nKWORD_TEST_OBJ = $(OBJ_COMMON) $(OBJ_KWORD_TEST)\n\nOBJ_MEMFILE_TEST = \\\n\tobjects/charset.o \\\n\tobjects/json.o \\\n\tobjects/message.o \\\n\tobjects/memfile_test.o\n\nMEMFILE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MEMFILE_TEST)\n\nOBJ_MESSAGE_TEST = \\\n\tobjects/charset.o \\\n\tobjects/json.o \\\n\tobjects/memfile.o \\\n\tobjects/message_test.o\n\nMESSAGE_TEST_OBJ = $(OBJ_COMMON) $(OBJ_MESSAGE_TEST)\n\nALL_OBJ = $(OBJ_COMMON) \\\n\t  $(OBJ_MAIN) \\\n\t  $(OBJ_JSON_TEST) \\\n\t  $(OBJ_KWORD_TEST) \\\n\t  $(OBJ_MEMFILE_TEST) \\\n\t  $(OBJ_MESSAGE_TEST)\n\n\nPRO_AUTO = \\\n\tarabic.pro \\\n\tblowfish.pro \\\n\tbuffer.pro \\\n\tcharset.pro \\\n\tcrypt.pro \\\n\tcrypt_zip.pro \\\n\tdict.pro \\\n\tdiff.pro \\\n\tdigraph.pro \\\n\tedit.pro \\\n\teval.pro \\\n\tevalfunc.pro \\\n\tex_cmds.pro \\\n\tex_cmds2.pro \\\n\tex_docmd.pro \\\n\tex_eval.pro \\\n\tex_getln.pro \\\n\tfarsi.pro \\\n\tfileio.pro \\\n\tfold.pro \\\n\tgetchar.pro \\\n\thardcopy.pro \\\n\thashtab.pro \\\n\thangulin.pro \\\n\tif_cscope.pro \\\n\tif_lua.pro \\\n\tif_mzsch.pro \\\n\tif_python.pro \\\n\tif_python3.pro \\\n\tif_ruby.pro \\\n\tif_xcmdsrv.pro \\\n\tjson.pro \\\n\tlist.pro \\\n\tmain.pro \\\n\tmark.pro \\\n\tmbyte.pro \\\n\tmemfile.pro \\\n\tmemline.pro \\\n\tmenu.pro \\\n\tmessage.pro \\\n\tmisc1.pro \\\n\tmisc2.pro \\\n\tmove.pro \\\n\tnormal.pro \\\n\tops.pro \\\n\toption.pro \\\n\tos_mac_conv.pro \\\n\tos_unix.pro \\\n\tpopupmnu.pro \\\n\tpty.pro \\\n\tquickfix.pro \\\n\tregexp.pro \\\n\tscreen.pro \\\n\tsearch.pro \\\n\tsha256.pro \\\n\tspell.pro \\\n\tspellfile.pro \\\n\tsyntax.pro \\\n\ttag.pro \\\n\tterm.pro \\\n\tterminal.pro \\\n\ttermlib.pro \\\n\tui.pro \\\n\tundo.pro \\\n\tuserfunc.pro \\\n\tversion.pro \\\n\twindow.pro \\\n\tgui_beval.pro \\\n\tworkshop.pro \\\n\tnetbeans.pro \\\n\tchannel.pro \\\n\t$(ALL_GUI_PRO) \\\n\t$(TCL_PRO)\n\n# Resources used for the Mac are in one directory.\nRSRC_DIR = os_mac_rsrc\n\nPRO_MANUAL = os_amiga.pro os_win32.pro \\\n\tos_mswin.pro winclip.pro os_beos.pro os_vms.pro $(PERL_PRO)\n\n# Default target is making the executable and tools\nall: $(VIMTARGET) $(TOOLS) languages $(GUI_BUNDLE)\n\ntools: $(TOOLS)\n\n# Run configure with all the setting from above.\n#\n# Note: auto/config.h doesn't depend on configure, because running configure\n# doesn't always update auto/config.h.  The timestamp isn't changed if the\n# file contents didn't change (to avoid recompiling everything).  Including a\n# dependency on auto/config.h would cause running configure each time when\n# auto/config.h isn't updated.  The dependency on auto/config.mk should make\n# sure configure is run when it's needed.\n#\n# Remove the config.cache every time, once in a while it causes problems that\n# are very hard to figure out.\n#\nconfig auto/config.mk: auto/configure config.mk.in config.h.in\n\t-rm -f auto/config.cache\n\tif test \"X$(MAKECMDGOALS)\" != \"Xclean\" \\\n\t\t-a \"X$(MAKECMDGOALS)\" != \"Xdistclean\" \\\n\t\t-a \"X$(MAKECMDGOALS)\" != \"Xautoconf\" \\\n\t\t-a \"X$(MAKECMDGOALS)\" != \"Xreconfig\"; then \\\n\t    GUI_INC_LOC=\"$(GUI_INC_LOC)\" GUI_LIB_LOC=\"$(GUI_LIB_LOC)\" \\\n\t\tCC=\"$(CC)\" CPPFLAGS=\"$(CPPFLAGS)\" CFLAGS=\"$(CFLAGS)\" \\\n\t\tLDFLAGS=\"$(LDFLAGS)\" $(CONF_SHELL) srcdir=\"$(srcdir)\" \\\n\t\t./configure $(CONF_OPT_GUI) $(CONF_OPT_X) $(CONF_OPT_XSMP) \\\n\t\t$(CONF_OPT_DARWIN) $(CONF_OPT_FAIL) \\\n\t\t$(CONF_OPT_PERL) $(CONF_OPT_PYTHON) $(CONF_OPT_PYTHON3) \\\n\t\t$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \\\n\t\t$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \\\n\t\t$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \\\n\t\t$(CONF_OPT_FEAT) $(CONF_TERM_LIB) \\\n\t\t$(CONF_OPT_COMPBY) $(CONF_OPT_ACL) $(CONF_OPT_NETBEANS) \\\n\t\t$(CONF_OPT_CHANNEL) $(CONF_OPT_TERMINAL) \\\n\t\t$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \\\n\t\t$(CONF_OPT_LUA) $(CONF_OPT_LUA_PREFIX) \\\n\t\t$(CONF_OPT_SYSMOUSE); \\\n\tfi\n\n# Use \"make reconfig\" to rerun configure without cached values.\n# When config.h changes, most things will be recompiled automatically.\n# Invoke $(MAKE) to run config with the empty auto/config.mk.\n# Invoke $(MAKE) to build all with the filled auto/config.mk.\nreconfig: scratch clean\n\t$(MAKE) -f Makefile config\n\t$(MAKE) -f Makefile all\n\n# Run autoconf to produce auto/configure.\n# Note:\n# - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of\n#   producing auto/configure.\n# - autoconf is not run automatically, because a patch usually changes both\n#   configure.ac and auto/configure but can't update the timestamps.  People\n#   who do not have (the correct version of) autoconf would run into trouble.\n#\n# Two tricks are required to make autoconf put its output in the \"auto\" dir:\n# - Temporarily move the ./configure script to ./configure.save.  Don't\n#   overwrite it, it's probably the result of an aborted autoconf.\n# - Use sed to change ./config.log to auto/config.log in the configure script.\n# Autoconf 2.5x (2.59 at least) produces a few more files that we need to take\n# care of:\n# - configure.lineno: has the line numbers replaced with $LINENO.  That\n#   improves patches a LOT, thus use it instead (until someone says it doesn't\n#   work on some system).\n# - autom4te.cache directory is created and not cleaned up.  Delete it.\n# - Uses \">config.log\" instead of \"./config.log\".\nautoconf:\n\tif test ! -f configure.save; then mv configure configure.save; fi\n\t$(AUTOCONF)\n\tsed -e 's+>config.log+>auto/config.log+' -e 's+\\./config.log+auto/config.log+' configure > auto/configure\n\tchmod 755 auto/configure\n\tmv -f configure.save configure\n\t-rm -rf autom4te.cache\n\t-rm -f auto/config.status auto/config.cache\n\n# Run vim script to generate the Ex command lookup table.\n# This only needs to be run when a command name has been added or changed.\n# If this fails because you don't have Vim yet, first build and install Vim\n# without changes.\ncmdidxs: ex_cmds.h\n\tvim -u NONE -i NONE -X -S create_cmdidxs.vim\n\n\n# The normal command to compile a .c file to its .o file.\n# Without or with ALL_CFLAGS.\nCCC_NF = $(CC) -c -I$(srcdir)\nCCC = $(CCC_NF) $(ALL_CFLAGS)\n\n\n# Link the target for normal use or debugging.\n# A shell script is used to try linking without unnecessary libraries.\n$(VIMTARGET): auto/config.mk objects $(OBJ) version.c version.h\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(VIMTARGET) $(OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\nxxd/xxd$(EXEEXT): xxd/xxd.c\n\tcd xxd; CC=\"$(CC)\" CFLAGS=\"$(CPPFLAGS) $(CFLAGS)\" LDFLAGS=\"$(LDFLAGS)\" \\\n\t\t$(MAKE) -f Makefile\n\n# Build the language specific files if they were unpacked.\n# Generate the converted .mo files separately, it's no problem if this fails.\nlanguages:\n\t@if test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t\tcd $(PODIR); \\\n\t\t  CC=\"$(CC)\" $(MAKE) prefix=$(DESTDIR)$(prefix); \\\n\tfi\n\t-@if test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t\tcd $(PODIR); \\\n\t\t  CC=\"$(CC)\" $(MAKE) prefix=$(DESTDIR)$(prefix) converted; \\\n\tfi\n\n# Update the *.po files for changes in the sources.  Only run manually.\nupdate-po:\n\tcd $(PODIR); CC=\"$(CC)\" $(MAKE) prefix=$(DESTDIR)$(prefix) update-po\n\n# Generate function prototypes.  This is not needed to compile vim, but if\n# you want to use it, cproto is out there on the net somewhere -- Webb\n#\n# When generating os_amiga.pro and os_win32.pro there will be a\n# few include files that can not be found, that's OK.\n\nproto: $(PRO_AUTO) $(PRO_MANUAL)\n\n# Filter out arguments that cproto doesn't support.\n# Don't pass \"-pthread\", \"-fwrapv\" and similar arguments to cproto, it sees\n# them as a list of individual flags.\n# The -E\"gcc -E\" argument must be separate to avoid problems with shell\n# quoting.\nCPROTO = cproto $(PROTO_FLAGS) -DPROTO \\\n\t `echo '$(LINT_CFLAGS)' | sed -e 's/ -[a-z-]\\+//g'`\n\n### Would be nice if this would work for \"normal\" make.\n### Currently it only works for (Free)BSD make.\n#$(PRO_AUTO): $$(*F).c\n#\t$(CPROTO) -DFEAT_GUI $(*F).c > $@\n\n# Always define FEAT_GUI.  This may generate a few warnings if it's also\n# defined in auto/config.h, you can ignore that.\n.c.pro:\n\t$(CPROTO) -DFEAT_GUI $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_amiga.pro: os_amiga.c\n\t$(CPROTO) -DAMIGA -UHAVE_CONFIG_H -DBPTR=char* $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_win32.pro: os_win32.c\n\t$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_mswin.pro: os_mswin.c\n\t$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nwinclip.pro: winclip.c\n\t$(CPROTO) -DWIN32 -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_beos.pro: os_beos.c\n\t$(CPROTO) -D__BEOS__ -UHAVE_CONFIG_H $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nos_vms.pro: os_vms.c\n# must use os_vms_conf.h for auto/config.h\n\tmv auto/config.h auto/config.h.save\n\tcp os_vms_conf.h auto/config.h\n\t$(CPROTO) -DVMS -UFEAT_GUI_ATHENA -UFEAT_GUI_NEXTAW -UFEAT_GUI_MOTIF -UFEAT_GUI_GTK $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\trm auto/config.h\n\tmv auto/config.h.save auto/config.h\n\n# if_perl.pro is special: Use the generated if_perl.c for input and remove\n# prototypes for local functions.\nif_perl.pro: auto/if_perl.c\n\t$(CPROTO) -DFEAT_GUI auto/if_perl.c | sed \"/_VI/d\" > proto/$@\n\ngui_gtk_gresources.pro: auto/gui_gtk_gresources.c\n\t$(CPROTO) -DFEAT_GUI $< > proto/$@\n\techo \"/* vim: set ft=c : */\" >> proto/$@\n\nnotags:\n\t-rm -f tags\n\n# Note: tags is made for the currently configured version, can't include both\n#\tMotif and Athena GUI\n# You can ignore error messages for missing files.\ntags TAGS: notags\n\t$(TAGPRG) $(TAGS_SRC) $(TAGS_INCL)\n\n# Make a highlight file for types.  Requires Exuberant ctags and awk\ntypes: types.vim\ntypes.vim: $(TAGS_SRC) $(TAGS_INCL)\n\tctags --c-kinds=gstu -o- $(TAGS_SRC) $(TAGS_INCL) |\\\n\t\tawk 'BEGIN{printf(\"syntax keyword Type\\t\")}\\\n\t\t\t{printf(\"%s \", $$1)}END{print \"\"}' > $@\n\techo \"syn keyword Constant OK FAIL TRUE FALSE MAYBE\" >> $@\n\n# TESTING\n#\n# Execute the test scripts and the unittests.\ntest check: scripttests unittests\n\n# Execute the test scripts.  Run these after compiling Vim, before installing.\n# This doesn't depend on $(VIMTARGET), because that won't work when configure\n# wasn't run yet.  Restart make to build it instead.\n#\n# This will produce a lot of garbage on your screen, including a few error\n# messages.  Don't worry about that.\n# If there is a real error, there will be a difference between \"testXX.out\" and\n# a \"testXX.ok\" file.\n# If everything is alright, the final message will be \"ALL DONE\".  If not you\n# get \"TEST FAILURE\".\n#\nscripttests:\n\t$(MAKE) -f Makefile $(VIMTARGET)\n\tif test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t\tcd $(PODIR); $(MAKE) -f Makefile check VIM=../$(VIMTARGET); \\\n\tfi\n\t-if test $(VIMTARGET) != vim -a ! -r vim; then \\\n\t\tln -s $(VIMTARGET) vim; \\\n\tfi\n\tcd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\n# Run the tests with the GUI.  Assumes vim/gvim was already built\ntestgui:\n\tcd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) GUI_FLAG=-g $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\nbenchmark:\n\tcd testdir; $(MAKE) -f Makefile benchmark VIMPROG=../$(VIMTARGET) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\nunittesttargets:\n\t$(MAKE) -f Makefile $(UNITTEST_TARGETS)\n\n# Execute the unittests one by one.\nunittest unittests: $(RUN_UNITTESTS)\n\nrun_json_test: $(JSON_TEST_TARGET)\n\t$(VALGRIND) ./$(JSON_TEST_TARGET) || exit 1; echo $* passed;\n\nrun_kword_test: $(KWORD_TEST_TARGET)\n\t$(VALGRIND) ./$(KWORD_TEST_TARGET) || exit 1; echo $* passed;\n\nrun_memfile_test: $(MEMFILE_TEST_TARGET)\n\t$(VALGRIND) ./$(MEMFILE_TEST_TARGET) || exit 1; echo $* passed;\n\nrun_message_test: $(MESSAGE_TEST_TARGET)\n\t$(VALGRIND) ./$(MESSAGE_TEST_TARGET) || exit 1; echo $* passed;\n\n# Run individual OLD style test.\n# These do not depend on the executable, compile it when needed.\ntest1 \\\n\ttest_changelist \\\n\ttest_close_count \\\n\ttest_erasebackword \\\n\ttest_eval \\\n\ttest_fixeol \\\n\ttest_insertcount \\\n\ttest_listchars \\\n\ttest_search_mbyte \\\n\ttest_wordcount \\\n\ttest3 test11 test14 test15 test17 \\\n\ttest29 test30 test36 test37 test39 \\\n\ttest42 test44 test48 test49 \\\n\ttest50 test52 test55 test59 \\\n\ttest64 test68 test69 \\\n\ttest70 test72 test73 \\\n\ttest85 test86 test87 test88 \\\n\ttest94 test95 test99 test108:\n\tcd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\n# Run individual NEW style test.\n# These do not depend on the executable, compile it when needed.\ntest_arglist \\\n\ttest_arabic \\\n\ttest_assert \\\n\ttest_assign \\\n\ttest_autochdir \\\n\ttest_autocmd \\\n\ttest_backspace_opt \\\n\ttest_breakindent \\\n\ttest_bufline \\\n\ttest_bufwintabinfo \\\n\ttest_cd \\\n\ttest_cdo \\\n\ttest_changedtick \\\n\ttest_channel \\\n\ttest_charsearch \\\n\ttest_charsearch_utf8 \\\n\ttest_cindent \\\n\ttest_clientserver \\\n\ttest_cmdline \\\n\ttest_command_count \\\n\ttest_comparators \\\n\ttest_crypt \\\n\ttest_cscope \\\n\ttest_cursor_func \\\n\ttest_curswant \\\n\ttest_delete \\\n\ttest_diffmode \\\n\ttest_digraph \\\n\ttest_display \\\n\ttest_edit \\\n\ttest_escaped_glob \\\n\ttest_ex_undo \\\n\ttest_ex_z \\\n\ttest_exec_while_if \\\n\ttest_execute_func \\\n\ttest_exists \\\n\ttest_exists_autocmd \\\n\ttest_expand \\\n\ttest_expand_dllpath \\\n\ttest_expr \\\n\ttest_expr_utf8 \\\n\ttest_farsi \\\n\ttest_feedkeys \\\n\ttest_file_perm \\\n\ttest_file_size \\\n\ttest_fileformat \\\n\ttest_filetype \\\n\ttest_filter_cmd \\\n\ttest_filter_map \\\n\ttest_findfile \\\n\ttest_float_func \\\n\ttest_fnameescape \\\n\ttest_fnamemodify \\\n\ttest_fold \\\n\ttest_functions \\\n\ttest_ga \\\n\ttest_getcwd \\\n\ttest_getvar \\\n\ttest_gf \\\n\ttest_glob2regpat \\\n\ttest_global \\\n\ttest_gn \\\n\ttest_goto \\\n\ttest_gui \\\n\ttest_gui_init \\\n\ttest_hardcopy \\\n\ttest_help \\\n\ttest_help_tagjump \\\n\ttest_hide \\\n\ttest_highlight \\\n\ttest_history \\\n\ttest_hlsearch \\\n\ttest_increment \\\n\ttest_increment_dbcs \\\n\ttest_ins_complete \\\n\ttest_job_fails \\\n\ttest_join \\\n\ttest_json \\\n\ttest_jumps \\\n\ttest_lambda \\\n\ttest_langmap \\\n\ttest_largefile \\\n\ttest_let \\\n\ttest_lineending \\\n\ttest_lispwords \\\n\ttest_listlbr \\\n\ttest_listlbr_utf8 \\\n\ttest_lua \\\n\ttest_makeencoding \\\n\ttest_man \\\n\ttest_maparg \\\n\ttest_mapping \\\n\ttest_marks \\\n\ttest_match \\\n\ttest_matchadd_conceal \\\n\ttest_matchadd_conceal_utf8 \\\n\ttest_menu \\\n\ttest_messages \\\n\ttest_mksession \\\n\ttest_mksession_utf8 \\\n\ttest_nested_function \\\n\ttest_netbeans \\\n\ttest_normal \\\n\ttest_number \\\n\ttest_options \\\n\ttest_packadd \\\n\ttest_partial \\\n\ttest_paste \\\n\ttest_perl \\\n\ttest_plus_arg_edit \\\n\ttest_popup \\\n\ttest_preview \\\n\ttest_profile \\\n\ttest_put \\\n\ttest_python2 \\\n\ttest_python3 \\\n\ttest_pyx2 \\\n\ttest_pyx3 \\\n\ttest_quickfix \\\n\ttest_quotestar \\\n\ttest_recover \\\n\ttest_regex_char_classes \\\n\ttest_regexp_latin \\\n\ttest_regexp_utf8 \\\n\ttest_registers \\\n\ttest_reltime \\\n\ttest_retab \\\n\ttest_ruby \\\n\ttest_scroll_opt \\\n\ttest_scrollbind \\\n\ttest_search \\\n\ttest_searchpos \\\n\ttest_set \\\n\ttest_sha256 \\\n\ttest_signs \\\n\ttest_smartindent \\\n\ttest_sort \\\n\ttest_source_utf8 \\\n\ttest_spell \\\n\ttest_startup \\\n\ttest_startup_utf8 \\\n\ttest_stat \\\n\ttest_statusline \\\n\ttest_substitute \\\n\ttest_swap \\\n\ttest_syn_attr \\\n\ttest_syntax \\\n\ttest_system \\\n\ttest_tabline \\\n\ttest_tabpage \\\n\ttest_tagcase \\\n\ttest_tagjump \\\n\ttest_taglist \\\n\ttest_tcl \\\n\ttest_terminal \\\n\ttest_terminal_fail \\\n\ttest_textobjects \\\n\ttest_timers \\\n\ttest_true_false \\\n\ttest_undo \\\n\ttest_unlet \\\n\ttest_usercommands \\\n\ttest_utf8 \\\n\ttest_utf8_comparisons \\\n\ttest_viminfo \\\n\ttest_vimscript \\\n\ttest_virtualedit \\\n\ttest_visual \\\n\ttest_winbar \\\n\ttest_winbuf_close \\\n\ttest_window_cmd \\\n\ttest_window_id \\\n\ttest_windows_home \\\n\ttest_writefile \\\n\ttest_alot_latin \\\n\ttest_alot_utf8 \\\n\ttest_alot:\n\tcd testdir; rm -f $@.res test.log messages; $(MAKE) -f Makefile $@.res VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\t@if test -f testdir/test.log; then \\\n\t\tcat testdir/test.log; \\\n\tfi\n\tcat testdir/messages\n\nnewtests:\n\tcd testdir; rm -f $@.res test.log messages; $(MAKE) -f Makefile newtestssilent VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)\n\t@if test -f testdir/test.log; then \\\n\t\tcat testdir/test.log; \\\n\tfi\n\tcat testdir/messages\n\ntestclean:\n\tcd testdir; $(MAKE) -f Makefile clean\n\tif test -d $(PODIR); then \\\n\t\tcd $(PODIR); $(MAKE) checkclean; \\\n\tfi\n\n# Unittests\n# It's build just like Vim to satisfy all dependencies.\n$(JSON_TEST_TARGET): auto/config.mk objects $(JSON_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(JSON_TEST_TARGET) $(JSON_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n$(KWORD_TEST_TARGET): auto/config.mk objects $(KWORD_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(KWORD_TEST_TARGET) $(KWORD_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n$(MEMFILE_TEST_TARGET): auto/config.mk objects $(MEMFILE_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(MEMFILE_TEST_TARGET) $(MEMFILE_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n$(MESSAGE_TEST_TARGET): auto/config.mk objects $(MESSAGE_TEST_OBJ)\n\t$(CCC) version.c -o objects/version.o\n\t@LINK=\"$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \\\n\t\t-o $(MESSAGE_TEST_TARGET) $(MESSAGE_TEST_OBJ) $(ALL_LIBS)\" \\\n\t\tMAKE=\"$(MAKE)\" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \\\n\t\tsh $(srcdir)/link.sh\n\n# install targets\n\ninstall: $(GUI_INSTALL)\n\ninstall_normal: installvim installtools $(INSTALL_LANGS) install-icons\n\ninstall_gui_extra: installgtutorbin\n\ninstallvim: installvimbin installtutorbin \\\n\t\tinstallruntime installlinks installmanlinks\n\n#\n# Avoid overwriting an existing executable, somebody might be running it and\n# overwriting it could cause it to crash.  Deleting it is OK, it won't be\n# really deleted until all running processes for it have exited.  It is\n# renamed first, in case the deleting doesn't work.\n#\n# If you want to keep an older version, rename it before running \"make\n# install\".\n#\ninstallvimbin: $(VIMTARGET) $(DESTDIR)$(exec_prefix) $(DEST_BIN)\n\t-if test -f $(DEST_BIN)/$(VIMTARGET); then \\\n\t  mv -f $(DEST_BIN)/$(VIMTARGET) $(DEST_BIN)/$(VIMNAME).rm; \\\n\t  rm -f $(DEST_BIN)/$(VIMNAME).rm; \\\n\tfi\n\t$(INSTALL_PROG) $(VIMTARGET) $(DEST_BIN)\n\t$(STRIP) $(DEST_BIN)/$(VIMTARGET)\n\tchmod $(BINMOD) $(DEST_BIN)/$(VIMTARGET)\n# may create a link to the new executable from /usr/bin/vi\n\t-$(LINKIT)\n\n# Long list of arguments for the shell script that installs the manual pages\n# for one language.\nINSTALLMANARGS = $(VIMLOC) $(SCRIPTLOC) $(VIMRCLOC) $(HELPSOURCE) $(MANMOD) \\\n\t\t$(VIMNAME) $(VIMDIFFNAME) $(EVIMNAME)\n\n# Install most of the runtime files\ninstallruntime: installrtbase installmacros installpack installtutor installspell\n\n# install the help files; first adjust the contents for the final location\ninstallrtbase: $(HELPSOURCE)/vim.1 $(DEST_VIM) $(DEST_RT) \\\n\t\t$(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) \\\n\t\t$(DEST_FTP) $(DEST_AUTO) $(DEST_AUTO)/xml $(DEST_PLUG) \\\n\t\t$(DEST_TUTOR) $(DEST_SPELL) $(DEST_COMP)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN) \"\" $(INSTALLMANARGS)\n# Generate the help tags with \":helptags\" to handle all languages.\n# Move the distributed tags file aside and restore it, to avoid it being\n# different from the repository.\n\tcd $(HELPSOURCE); if test -z \"$(CROSS_COMPILING)\" -a -f tags; then \\\n\t\tmv -f tags tags.dist; fi\n\t@echo generating help tags\n\t-@cd $(HELPSOURCE); if test -z \"$(CROSS_COMPILING)\"; then \\\n\t\t$(MAKE) VIMEXE=$(DEST_BIN)/$(VIMTARGET) vimtags; fi\n\tcd $(HELPSOURCE); \\\n\t\tfiles=`ls *.txt tags`; \\\n\t\tfiles=\"$$files `ls *.??x tags-?? 2>/dev/null || true`\"; \\\n\t\t$(INSTALL_DATA) $$files  $(DEST_HELP); \\\n\t\tcd $(DEST_HELP); \\\n\t\tchmod $(HELPMOD) $$files\n\t$(INSTALL_DATA)  $(HELPSOURCE)/*.pl $(DEST_HELP)\n\tchmod $(SCRIPTMOD) $(DEST_HELP)/*.pl\n\tcd $(HELPSOURCE); if test -f tags.dist; then mv -f tags.dist tags; fi\n# install the menu files\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/menu.vim $(SYS_MENU_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_MENU_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/synmenu.vim $(SYS_SYNMENU_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_SYNMENU_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/delmenu.vim $(SYS_DELMENU_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_DELMENU_FILE)\n# install the defaults/evim/mswin file\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/defaults.vim $(VIM_DEFAULTS_FILE)\n\tchmod $(VIMSCRIPTMOD) $(VIM_DEFAULTS_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/evim.vim $(EVIM_FILE)\n\tchmod $(VIMSCRIPTMOD) $(EVIM_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/mswin.vim $(MSWIN_FILE)\n\tchmod $(VIMSCRIPTMOD) $(MSWIN_FILE)\n# install the rgb.txt file\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(SYS_RGB_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_RGB_FILE)\n# install the bugreport file\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/bugreport.vim $(SYS_BUGR_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_BUGR_FILE)\n# install the example vimrc files\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/vimrc_example.vim $(DEST_SCRIPT)\n\tchmod $(VIMSCRIPTMOD) $(DEST_SCRIPT)/vimrc_example.vim\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/gvimrc_example.vim $(DEST_SCRIPT)\n\tchmod $(VIMSCRIPTMOD) $(DEST_SCRIPT)/gvimrc_example.vim\n# install the file type detection files\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/filetype.vim $(SYS_FILETYPE_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FILETYPE_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/ftoff.vim $(SYS_FTOFF_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FTOFF_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/scripts.vim $(SYS_SCRIPTS_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_SCRIPTS_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/ftplugin.vim $(SYS_FTPLUGIN_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FTPLUGIN_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/ftplugof.vim $(SYS_FTPLUGOF_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_FTPLUGOF_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/indent.vim $(SYS_INDENT_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_INDENT_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/indoff.vim $(SYS_INDOFF_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_INDOFF_FILE)\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/optwin.vim $(SYS_OPTWIN_FILE)\n\tchmod $(VIMSCRIPTMOD) $(SYS_OPTWIN_FILE)\n# install the print resource files\n\tcd $(PRINTSOURCE); $(INSTALL_DATA) *.ps $(DEST_PRINT)\n\tcd $(DEST_PRINT); chmod $(FILEMOD) *.ps\n# install the colorscheme files\n\tcd $(COLSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_COL)\n\tcd $(DEST_COL); chmod $(HELPMOD) *.vim README.txt\n# install the syntax files\n\tcd $(SYNSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_SYN)\n\tcd $(DEST_SYN); chmod $(HELPMOD) *.vim README.txt\n# install the indent files\n\tcd $(INDSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_IND)\n\tcd $(DEST_IND); chmod $(HELPMOD) *.vim README.txt\n# install the standard autoload files\n\tcd $(AUTOSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_AUTO)\n\tcd $(DEST_AUTO); chmod $(HELPMOD) *.vim README.txt\n\tcd $(AUTOSOURCE)/xml; $(INSTALL_DATA) *.vim $(DEST_AUTO)/xml\n\tcd $(DEST_AUTO)/xml; chmod $(HELPMOD) *.vim\n# install the standard plugin files\n\tcd $(PLUGSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_PLUG)\n\tcd $(DEST_PLUG); chmod $(HELPMOD) *.vim README.txt\n# install the ftplugin files\n\tcd $(FTPLUGSOURCE); $(INSTALL_DATA) *.vim README.txt logtalk.dict $(DEST_FTP)\n\tcd $(DEST_FTP); chmod $(HELPMOD) *.vim README.txt\n# install the compiler files\n\tcd $(COMPSOURCE); $(INSTALL_DATA) *.vim README.txt $(DEST_COMP)\n\tcd $(DEST_COMP); chmod $(HELPMOD) *.vim README.txt\n\ninstallmacros: $(DEST_VIM) $(DEST_RT) $(DEST_MACRO)\n\t$(INSTALL_DATA_R) $(MACROSOURCE)/* $(DEST_MACRO)\n\tchmod $(DIRMOD) `find $(DEST_MACRO) -type d -print`\n\tchmod $(FILEMOD) `find $(DEST_MACRO) -type f -print`\n\tchmod $(SCRIPTMOD) $(DEST_MACRO)/less.sh\n# When using CVS some CVS directories might have been copied.\n# Also delete AAPDIR and *.info files.\n\tcvs=`find $(DEST_MACRO) \\( -name CVS -o -name AAPDIR -o -name \"*.info\" \\) -print`; \\\n\t      if test -n \"$$cvs\"; then \\\n\t\t rm -rf $$cvs; \\\n\t      fi\n\ninstallpack: $(DEST_VIM) $(DEST_RT) $(DEST_PACK)\n\t$(INSTALL_DATA_R) $(PACKSOURCE)/* $(DEST_PACK)\n\tchmod $(DIRMOD) `find $(DEST_PACK) -type d -print`\n\tchmod $(FILEMOD) `find $(DEST_PACK) -type f -print`\n\n# install the tutor files\ninstalltutorbin: $(DEST_VIM)\n\t$(INSTALL_DATA) vimtutor $(DEST_BIN)/$(VIMNAME)tutor\n\tchmod $(SCRIPTMOD) $(DEST_BIN)/$(VIMNAME)tutor\n\ninstallgtutorbin: $(DEST_VIM)\n\t$(INSTALL_DATA) gvimtutor $(DEST_BIN)/$(GVIMNAME)tutor\n\tchmod $(SCRIPTMOD) $(DEST_BIN)/$(GVIMNAME)tutor\n\ninstalltutor: $(DEST_RT) $(DEST_TUTOR)\n\t-$(INSTALL_DATA) $(TUTORSOURCE)/README* $(TUTORSOURCE)/tutor* $(DEST_TUTOR)\n\t-rm -f $(DEST_TUTOR)/*.info\n\tchmod $(HELPMOD) $(DEST_TUTOR)/*\n\n# Install the spell files, if they exist.  This assumes at least the English\n# spell file is there.\ninstallspell: $(DEST_VIM) $(DEST_RT) $(DEST_SPELL)\n\tif test -f $(SPELLSOURCE)/en.latin1.spl; then \\\n\t  $(INSTALL_DATA) $(SPELLSOURCE)/*.spl $(SPELLSOURCE)/*.sug $(SPELLSOURCE)/*.vim $(DEST_SPELL); \\\n\t  chmod $(HELPMOD) $(DEST_SPELL)/*.spl $(DEST_SPELL)/*.sug $(DEST_SPELL)/*.vim; \\\n\tfi\n\n# install helper program xxd\ninstalltools: $(TOOLS) $(DESTDIR)$(exec_prefix) $(DEST_BIN) \\\n\t\t$(TOOLSSOURCE) $(DEST_VIM) $(DEST_RT) $(DEST_TOOLS) \\\n\t\t$(INSTALL_TOOL_LANGS)\n\tif test -f $(DEST_BIN)/xxd$(EXEEXT); then \\\n\t  mv -f $(DEST_BIN)/xxd$(EXEEXT) $(DEST_BIN)/xxd.rm; \\\n\t  rm -f $(DEST_BIN)/xxd.rm; \\\n\tfi\n\t$(INSTALL_PROG) xxd/xxd$(EXEEXT) $(DEST_BIN)\n\t$(STRIP) $(DEST_BIN)/xxd$(EXEEXT)\n\tchmod $(BINMOD) $(DEST_BIN)/xxd$(EXEEXT)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN) \"\" $(INSTALLMANARGS)\n\n# install the runtime tools\n\t$(INSTALL_DATA_R) $(TOOLSSOURCE)/* $(DEST_TOOLS)\n# When using CVS some CVS directories might have been copied.\n\tcvs=`find $(DEST_TOOLS) \\( -name CVS -o -name AAPDIR \\) -print`; \\\n\t      if test -n \"$$cvs\"; then \\\n\t\t rm -rf $$cvs; \\\n\t      fi\n\t-chmod $(FILEMOD) $(DEST_TOOLS)/*\n# replace the path in some tools\n\tperlpath=`./which.sh perl` && sed -e \"s+/usr/bin/perl+$$perlpath+\" $(TOOLSSOURCE)/efm_perl.pl >$(DEST_TOOLS)/efm_perl.pl\n\tawkpath=`./which.sh nawk` && sed -e \"s+/usr/bin/nawk+$$awkpath+\" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; if test -z \"$$awkpath\"; then \\\n\t\tawkpath=`./which.sh gawk` && sed -e \"s+/usr/bin/nawk+$$awkpath+\" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; if test -z \"$$awkpath\"; then \\\n\t\tawkpath=`./which.sh awk` && sed -e \"s+/usr/bin/nawk+$$awkpath+\" $(TOOLSSOURCE)/mve.awk >$(DEST_TOOLS)/mve.awk; fi; fi\n\t-chmod $(SCRIPTMOD) `grep -l \"^#!\" $(DEST_TOOLS)/*`\n\n# install the language specific files for tools, if they were unpacked\ninstall-tool-languages:\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR_I) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_FR_U) \"-fr.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT_I) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_IT_U) \"-it.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_JA_U) \"-ja.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL_I) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_PL_U) \"-pl.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_RU) \"-ru\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh xxd $(DEST_MAN_RU_U) \"-ru.UTF-8\" $(INSTALLMANARGS)\n\n# install the language specific files, if they were unpacked\ninstall-languages: languages $(DEST_LANG) $(DEST_KMAP)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_FR) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_FR_I) \"-fr\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_FR_U) \"-fr.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_IT) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_IT_I) \"-it\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_IT_U) \"-it.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_JA_U) \"-ja.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_PL) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_PL_I) \"-pl\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_PL_U) \"-pl.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_RU) \"-ru\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh install $(DEST_MAN_RU_U) \"-ru.UTF-8\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_JA_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU_U) $(INSTALLMLARGS)\n\tif test -n \"$(MAKEMO)\" -a -f $(PODIR)/Makefile; then \\\n\t   cd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) LOCALEDIR=$(DEST_LANG) \\\n\t   INSTALL_DATA=$(INSTALL_DATA) FILEMOD=$(FILEMOD) install; \\\n\tfi\n\tif test -d $(LANGSOURCE); then \\\n\t   $(INSTALL_DATA) $(LANGSOURCE)/README.txt $(LANGSOURCE)/*.vim $(DEST_LANG); \\\n\t   chmod $(FILEMOD) $(DEST_LANG)/README.txt $(DEST_LANG)/*.vim; \\\n\tfi\n\tif test -d $(KMAPSOURCE); then \\\n\t   $(INSTALL_DATA) $(KMAPSOURCE)/README.txt $(KMAPSOURCE)/*.vim $(DEST_KMAP); \\\n\t   chmod $(FILEMOD) $(DEST_KMAP)/README.txt $(DEST_KMAP)/*.vim; \\\n\tfi\n\n# Install the icons for KDE, if the directory exists and the icon doesn't.\n# Always when $(DESTDIR) is not empty.\nICON48PATH = $(DESTDIR)$(DATADIR)/icons/hicolor/48x48/apps\nICON32PATH = $(DESTDIR)$(DATADIR)/icons/locolor/32x32/apps\nICON16PATH = $(DESTDIR)$(DATADIR)/icons/locolor/16x16/apps\nICONTHEMEPATH = $(DATADIR)/icons/hicolor\nDESKTOPPATH = $(DESTDIR)$(DATADIR)/applications\nKDEPATH = $(HOME)/.kde/share/icons\ninstall-icons:\n\tif test -n \"$(DESTDIR)\"; then \\\n\t\t$(MKDIR_P) $(ICON48PATH) $(ICON32PATH) \\\n\t\t$(ICON16PATH) $(DESKTOPPATH); \\\n\tfi\n\n\tif test -d $(ICON48PATH) -a -w $(ICON48PATH) \\\n\t\t-a ! -f $(ICON48PATH)/gvim.png; then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim48x48.png $(ICON48PATH)/gvim.png; \\\n\t   if test -z \"$(DESTDIR)\" -a -x \"$(GTK_UPDATE_ICON_CACHE)\" \\\n\t\t   -a -w $(ICONTHEMEPATH) \\\n\t\t   -a -f $(ICONTHEMEPATH)/index.theme; then \\\n\t\t$(GTK_UPDATE_ICON_CACHE) -q $(ICONTHEMEPATH); \\\n\t   fi \\\n\tfi\n\tif test -d $(ICON32PATH) -a -w $(ICON32PATH) \\\n\t\t-a ! -f $(ICON32PATH)/gvim.png; then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim32x32.png $(ICON32PATH)/gvim.png; \\\n\tfi\n\tif test -d $(ICON16PATH) -a -w $(ICON16PATH) \\\n\t\t-a ! -f $(ICON16PATH)/gvim.png; then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim16x16.png $(ICON16PATH)/gvim.png; \\\n\tfi\n\tif test -d $(DESKTOPPATH) -a -w $(DESKTOPPATH); then \\\n\t   $(INSTALL_DATA) $(SCRIPTSOURCE)/vim.desktop \\\n\t\t$(SCRIPTSOURCE)/gvim.desktop \\\n\t\t$(DESKTOPPATH); \\\n\t   if test -z \"$(DESTDIR)\" -a -x \"$(UPDATE_DESKTOP_DATABASE)\"; then \\\n\t      $(UPDATE_DESKTOP_DATABASE) -q $(DESKTOPPATH); \\\n\t   fi \\\n\tfi\n\n$(HELPSOURCE)/vim.1 $(MACROSOURCE) $(TOOLSSOURCE):\n\t@echo Runtime files not found.\n\t@echo You need to unpack the runtime archive before running \"make install\".\n\ttest -f error\n\n$(DESTDIR)$(exec_prefix) $(DEST_BIN) \\\n\t\t$(DEST_VIM) $(DEST_RT) $(DEST_HELP) \\\n\t\t$(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND) $(DEST_FTP) \\\n\t\t$(DEST_LANG) $(DEST_KMAP) $(DEST_COMP) $(DEST_MACRO) \\\n\t\t$(DEST_PACK) $(DEST_TOOLS) $(DEST_TUTOR) $(DEST_SPELL) \\\n\t\t$(DEST_AUTO) $(DEST_AUTO)/xml $(DEST_PLUG):\n\t$(MKDIR_P) $@\n\t-chmod $(DIRMOD) $@\n\n# create links from various names to vim.  This is only done when the links\n# (or executables with the same name) don't exist yet.\ninstalllinks: $(GUI_TARGETS) \\\n\t\t\t$(DEST_BIN)/$(EXTARGET) \\\n\t\t\t$(DEST_BIN)/$(VIEWTARGET) \\\n\t\t\t$(DEST_BIN)/$(RVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(RVIEWTARGET) \\\n\t\t\t$(INSTALLVIMDIFF)\n\ninstallglinks: $(DEST_BIN)/$(GVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(GVIEWTARGET) \\\n\t\t\t$(DEST_BIN)/$(RGVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(RGVIEWTARGET) \\\n\t\t\t$(DEST_BIN)/$(EVIMTARGET) \\\n\t\t\t$(DEST_BIN)/$(EVIEWTARGET) \\\n\t\t\t$(INSTALLGVIMDIFF)\n\ninstallvimdiff: $(DEST_BIN)/$(VIMDIFFTARGET)\ninstallgvimdiff: $(DEST_BIN)/$(GVIMDIFFTARGET)\n\n$(DEST_BIN)/$(EXTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(EXTARGET)\n\n$(DEST_BIN)/$(VIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(VIEWTARGET)\n\n$(DEST_BIN)/$(GVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIMTARGET)\n\n$(DEST_BIN)/$(GVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIEWTARGET)\n\n$(DEST_BIN)/$(RVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RVIMTARGET)\n\n$(DEST_BIN)/$(RVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RVIEWTARGET)\n\n$(DEST_BIN)/$(RGVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RGVIMTARGET)\n\n$(DEST_BIN)/$(RGVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(RGVIEWTARGET)\n\n$(DEST_BIN)/$(VIMDIFFTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(VIMDIFFTARGET)\n\n$(DEST_BIN)/$(GVIMDIFFTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(GVIMDIFFTARGET)\n\n$(DEST_BIN)/$(EVIMTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(EVIMTARGET)\n\n$(DEST_BIN)/$(EVIEWTARGET):\n\tcd $(DEST_BIN); ln -s $(VIMTARGET) $(EVIEWTARGET)\n\n# Create links for the manual pages with various names to vim.\tThis is only\n# done when the links (or manpages with the same name) don't exist yet.\n\nINSTALLMLARGS = $(VIMNAME) $(VIMDIFFNAME) $(EVIMNAME) \\\n\t\t$(EXNAME) $(VIEWNAME) $(RVIMNAME) $(RVIEWNAME) \\\n\t\t$(GVIMNAME) $(GVIEWNAME) $(RGVIMNAME) $(RGVIEWNAME) \\\n\t\t$(GVIMDIFFNAME) $(EVIEWNAME)\n\ninstallmanlinks:\n\t-$(SHELL) ./installml.sh install \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN) $(INSTALLMLARGS)\n\nuninstall: uninstall_runtime\n\t-rm -f $(DEST_BIN)/$(VIMTARGET)\n\t-rm -f $(DEST_BIN)/vimtutor\n\t-rm -f $(DEST_BIN)/gvimtutor\n\t-rm -f $(DEST_BIN)/$(EXTARGET) $(DEST_BIN)/$(VIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(GVIMTARGET) $(DEST_BIN)/$(GVIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(RVIMTARGET) $(DEST_BIN)/$(RVIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(RGVIMTARGET) $(DEST_BIN)/$(RGVIEWTARGET)\n\t-rm -f $(DEST_BIN)/$(VIMDIFFTARGET) $(DEST_BIN)/$(GVIMDIFFTARGET)\n\t-rm -f $(DEST_BIN)/$(EVIMTARGET) $(DEST_BIN)/$(EVIEWTARGET)\n\t-rm -f $(DEST_BIN)/xxd$(EXEEXT)\n\n# Note: the \"rmdir\" will fail if any files were added after \"make install\"\nuninstall_runtime:\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR_I) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_FR_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT_I) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_IT_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_JA_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL_I) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_PL_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_RU) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installman.sh uninstall $(DEST_MAN_RU_U) \"\" $(INSTALLMANARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_FR_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_IT_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_JA_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_I) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_PL_U) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU) $(INSTALLMLARGS)\n\t-$(SHELL) ./installml.sh uninstall \"$(GUI_MAN_TARGETS)\" \\\n\t\t$(DEST_MAN_RU_U) $(INSTALLMLARGS)\n\t-rm -f $(DEST_MAN)/xxd.1\n\t-rm -f $(DEST_MAN_FR)/xxd.1 $(DEST_MAN_FR_I)/xxd.1 $(DEST_MAN_FR_U)/xxd.1\n\t-rm -f $(DEST_MAN_IT)/xxd.1 $(DEST_MAN_IT_I)/xxd.1 $(DEST_MAN_IT_U)/xxd.1\n\t-rm -f $(DEST_MAN_JA_U)/xxd.1\n\t-rm -f $(DEST_MAN_PL)/xxd.1 $(DEST_MAN_PL_I)/xxd.1 $(DEST_MAN_PL_U)/xxd.1\n\t-rm -f $(DEST_MAN_RU)/xxd.1 $(DEST_MAN_RU_U)/xxd.1\n\t-rm -f $(DEST_HELP)/*.txt $(DEST_HELP)/tags $(DEST_HELP)/*.pl\n\t-rm -f $(DEST_HELP)/*.??x $(DEST_HELP)/tags-??\n\t-rm -f $(SYS_RGB_FILE)\n\t-rm -f $(SYS_MENU_FILE) $(SYS_SYNMENU_FILE) $(SYS_DELMENU_FILE)\n\t-rm -f $(SYS_BUGR_FILE) $(VIM_DEFAULTS_FILE) $(EVIM_FILE) $(MSWIN_FILE)\n\t-rm -f $(DEST_SCRIPT)/gvimrc_example.vim $(DEST_SCRIPT)/vimrc_example.vim\n\t-rm -f $(SYS_FILETYPE_FILE) $(SYS_FTOFF_FILE) $(SYS_SCRIPTS_FILE)\n\t-rm -f $(SYS_INDOFF_FILE) $(SYS_INDENT_FILE)\n\t-rm -f $(SYS_FTPLUGOF_FILE) $(SYS_FTPLUGIN_FILE)\n\t-rm -f $(SYS_OPTWIN_FILE)\n\t-rm -f $(DEST_COL)/*.vim $(DEST_COL)/README.txt\n\t-rm -f $(DEST_SYN)/*.vim $(DEST_SYN)/README.txt\n\t-rm -f $(DEST_IND)/*.vim $(DEST_IND)/README.txt\n\t-rm -rf $(DEST_MACRO)\n\t-rm -rf $(DEST_PACK)\n\t-rm -rf $(DEST_TUTOR)\n\t-rm -rf $(DEST_SPELL)\n\t-rm -rf $(DEST_TOOLS)\n\t-rm -rf $(DEST_LANG)\n\t-rm -rf $(DEST_KMAP)\n\t-rm -rf $(DEST_COMP)\n\t-rm -f $(DEST_PRINT)/*.ps\n\t-rmdir $(DEST_HELP) $(DEST_PRINT) $(DEST_COL) $(DEST_SYN) $(DEST_IND)\n\t-rm -rf $(DEST_FTP)/*.vim $(DEST_FTP)/README.txt $(DEST_FTP)/logtalk.dict\n\t-rm -f $(DEST_AUTO)/*.vim $(DEST_AUTO)/README.txt $(DEST_AUTO)/xml/*.vim\n\t-rm -f $(DEST_PLUG)/*.vim $(DEST_PLUG)/README.txt\n\t-rmdir $(DEST_FTP) $(DEST_AUTO)/xml $(DEST_AUTO) $(DEST_PLUG) $(DEST_RT)\n#\tThis will fail when other Vim versions are installed, no worries.\n\t-rmdir $(DEST_VIM)\n\n# Clean up all the files that have been produced, except configure's.\n# We support common typing mistakes for Juergen! :-)\nclean celan: testclean\n\t-rm -f *.o core $(VIMTARGET).core $(VIMTARGET) vim xxd/*.o\n\t-rm -rf objects\n\t-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c auto/gui_gtk_gresources.c auto/gui_gtk_gresources.h\n\t-rm -f conftest* *~ auto/link.sed\n\t-rm -f testdir/opt_test.vim\n\t-rm -f $(UNITTEST_TARGETS)\n\t-rm -f runtime pixmaps\n\t-rm -rf $(APPDIR)\n\t-rm -rf mzscheme_base.c\n\tif test -d $(PODIR); then \\\n\t\tcd $(PODIR); $(MAKE) prefix=$(DESTDIR)$(prefix) clean; \\\n\tfi\n\n# Make a shadow directory for compilation on another system or with different\n# features.\nSHADOWDIR = shadow\n\nshadow:\truntime pixmaps\n\t$(MKDIR_P) $(SHADOWDIR)\n\tcd $(SHADOWDIR); ln -s ../*.[chm] ../*.in ../*.sh ../*.xs ../*.xbm ../gui_gtk_res.xml ../toolcheck ../proto ../libvterm ../vimtutor ../gvimtutor ../install-sh .\n\tmkdir $(SHADOWDIR)/auto\n\tcd $(SHADOWDIR)/auto; ln -s ../../auto/configure .\n\t$(MKDIR_P) $(SHADOWDIR)/po\n\tcd $(SHADOWDIR)/po; ln -s ../../po/*.po ../../po/*.mak ../../po/*.vim ../../po/Makefile .\n\tcd $(SHADOWDIR); rm -f auto/link.sed\n\tcp Makefile configure $(SHADOWDIR)\n\trm -f $(SHADOWDIR)/auto/config.mk $(SHADOWDIR)/config.mk.dist\n\tcp config.mk.dist $(SHADOWDIR)/auto/config.mk\n\tcp config.mk.dist $(SHADOWDIR)\n\t$(MKDIR_P) $(SHADOWDIR)/xxd\n\tcd $(SHADOWDIR)/xxd; ln -s ../../xxd/*.[ch] ../../xxd/Make* .\n\tif test -d $(RSRC_DIR); then \\\n\t\tcd $(SHADOWDIR); \\\n\t\tln -s ../infplist.xml .; \\\n\t\tln -s ../$(RSRC_DIR) ../os_mac.rsr.hqx ../dehqx.py .; \\\n\tfi\n\t$(MKDIR_P) $(SHADOWDIR)/testdir\n\tcd $(SHADOWDIR)/testdir; ln -s ../../testdir/Makefile \\\n\t\t\t\t ../../testdir/Make_all.mak \\\n\t\t\t\t ../../testdir/README.txt \\\n\t\t\t\t ../../testdir/*.in \\\n\t\t\t\t ../../testdir/*.vim \\\n\t\t\t\t ../../testdir/*.py \\\n\t\t\t\t ../../testdir/python* \\\n\t\t\t\t ../../testdir/pyxfile \\\n\t\t\t\t ../../testdir/sautest \\\n\t\t\t\t ../../testdir/samples \\\n\t\t\t\t ../../testdir/test83-tags? \\\n\t\t\t\t ../../testdir/*.ok .\n\n# Link needed for doing \"make install\" in a shadow directory.\nruntime:\n\t-ln -s ../runtime .\n\n# Link needed for doing \"make\" using GTK in a shadow directory.\npixmaps:\n\t-ln -s ../pixmaps .\n\n# Update the synmenu.vim file with the latest Syntax menu.\n# This is only needed when runtime/makemenu.vim was changed.\nmenu: ./vim ../runtime/makemenu.vim\n\t./vim -u ../runtime/makemenu.vim\n\n# Start configure from scratch\nscrub scratch:\n\t-rm -f auto/config.status auto/config.cache config.log auto/config.log\n\t-rm -f auto/config.h auto/link.log auto/link.sed auto/config.mk\n\ttouch auto/config.h\n\tcp config.mk.dist auto/config.mk\n\ndistclean: clean scratch\n\t-rm -f tags\n\ndist: distclean\n\t@echo\n\t@echo Making the distribution has to be done in the top directory\n\nmdepend:\n\t-@rm -f Makefile~\n\tcp Makefile Makefile~\n\tsed -e '/\\#\\#\\# Dependencies/q' < Makefile > tmp_make\n\t@for i in $(ALL_SRC) ; do \\\n\t  echo \"$$i\" ; \\\n\t  echo `echo \"$$i\" | sed -e 's/[^ ]*\\.c$$/objects\\/\\1.o/'`\": $$i\" `\\\n\t    $(CPP) $$i |\\\n\t    grep '^# .*\"\\./.*\\.h\"' |\\\n\t    sort -t'\"' -u +1 -2 |\\\n\t    sed -e 's/.*\"\\.\\/\\(.*\\)\".*/\\1/'\\\n\t    ` >> tmp_make ; \\\n\tdone\n\tmv tmp_make Makefile\n\ndepend:\n\t-@rm -f Makefile~\n\tcp Makefile Makefile~\n\tsed -e '/\\#\\#\\# Dependencies/q' < Makefile > tmp_make\n\t-for i in $(ALL_SRC); do echo $$i; \\\n\t\t$(CPP_DEPEND) $$i | \\\n\t\tsed -e 's+^\\([^ ]*\\.o\\)+objects/\\1+' >> tmp_make; done\n\tmv tmp_make Makefile\n\n# Run lint.  Clean up the *.ln files that are sometimes left behind.\nlint:\n\t$(LINT) $(LINT_OPTIONS) $(LINT_CFLAGS) $(LINT_EXTRA) $(LINT_SRC)\n\t-rm -f *.ln\n\n# Check dosinst.c with lint.\nlintinstall:\n\t$(LINT) $(LINT_OPTIONS) -DWIN32 -DUNIX_LINT dosinst.c\n\t-rm -f dosinst.ln\n\n###########################################################################\n\n.c.o:\n\t$(CCC) $<\n\nauto/if_perl.c: if_perl.xs\n\t$(PERL) -e 'unless ( $$] >= 5.005 ) { for (qw(na defgv errgv)) { print \"#define PL_$$_ $$_\\n\" }}' > $@\n\t$(PERL) $(PERL_XSUBPP) -prototypes -typemap \\\n\t    $(PERLLIB)/ExtUtils/typemap if_perl.xs >> $@\n\nauto/osdef.h: auto/config.h osdef.sh osdef1.h.in osdef2.h.in\n\tCC=\"$(CC) $(OSDEF_CFLAGS)\" srcdir=$(srcdir) sh $(srcdir)/osdef.sh\n\nauto/pathdef.c: Makefile auto/config.mk\n\t-@echo creating $@\n\t-@echo '/* pathdef.c */' > $@\n\t-@echo '/* This file is automatically created by Makefile' >> $@\n\t-@echo ' * DO NOT EDIT!  Change Makefile only. */' >> $@\n\t-@echo '#include \"vim.h\"' >> $@\n\t-@echo 'char_u *default_vim_dir = (char_u *)\"$(VIMRCLOC)\";' | $(QUOTESED) >> $@\n\t-@echo 'char_u *default_vimruntime_dir = (char_u *)\"$(VIMRUNTIMEDIR)\";' | $(QUOTESED) >> $@\n\t-@echo 'char_u *all_cflags = (char_u *)\"$(CC) -c -I$(srcdir) $(ALL_CFLAGS)\";' | $(QUOTESED) >>  $@\n\t-@echo 'char_u *all_lflags = (char_u *)\"$(CC) $(ALL_LIB_DIRS) $(LDFLAGS) -o $(VIMTARGET) $(ALL_LIBS) \";' | $(QUOTESED) >>  $@\n\t-@echo 'char_u *compiled_user = (char_u *)\"' | tr -d $(NL) >> $@\n\t-@if test -n \"$(COMPILEDBY)\"; then \\\n\t\techo \"$(COMPILEDBY)\" | tr -d $(NL) >> $@; \\\n\t\telse ((logname) 2>/dev/null || whoami) | tr -d $(NL) >> $@; fi\n\t-@echo '\";' >> $@\n\t-@echo 'char_u *compiled_sys = (char_u *)\"' | tr -d $(NL) >> $@\n\t-@if test -z \"$(COMPILEDBY)\"; then hostname | tr -d $(NL) >> $@; fi\n\t-@echo '\";' >> $@\n\t-@sh $(srcdir)/pathdef.sh\n\nGUI_GTK_RES_INPUTS = \\\n\t../pixmaps/stock_vim_build_tags.png \\\n\t../pixmaps/stock_vim_find_help.png \\\n\t../pixmaps/stock_vim_save_all.png \\\n\t../pixmaps/stock_vim_session_load.png \\\n\t../pixmaps/stock_vim_session_new.png \\\n\t../pixmaps/stock_vim_session_save.png \\\n\t../pixmaps/stock_vim_shell.png \\\n\t../pixmaps/stock_vim_window_maximize.png \\\n\t../pixmaps/stock_vim_window_maximize_width.png \\\n\t../pixmaps/stock_vim_window_minimize.png \\\n\t../pixmaps/stock_vim_window_minimize_width.png \\\n\t../pixmaps/stock_vim_window_split.png \\\n\t../pixmaps/stock_vim_window_split_vertical.png\n\nauto/gui_gtk_gresources.c: gui_gtk_res.xml $(GUI_GTK_RES_INPUTS)\n\t$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=../pixmaps --generate --c-name=gui_gtk --manual-register gui_gtk_res.xml\nauto/gui_gtk_gresources.h: gui_gtk_res.xml $(GUI_GTK_RES_INPUTS)\n\tif test -z \"$(GLIB_COMPILE_RESOURCES)\"; then touch $@; else \\\n\t\t$(GLIB_COMPILE_RESOURCES) --target=$@ --sourcedir=../pixmaps --generate --c-name=gui_gtk --manual-register gui_gtk_res.xml; \\\n\tfi\n\n# All the object files are put in the \"objects\" directory.  Since not all make\n# commands understand putting object files in another directory, it must be\n# specified for each file separately.\n\nobjects: objects/.dirstamp\n\nobjects/.dirstamp:\n\t$(MKDIR_P) objects\n\ttouch objects/.dirstamp\n\n# All object files depend on the objects directory, so that parallel make\n# works.  Can't depend on the directory itself, its timestamp changes all the\n# time.\n$(ALL_OBJ): objects/.dirstamp\n\nobjects/arabic.o: arabic.c\n\t$(CCC) -o $@ arabic.c\n\nobjects/blowfish.o: blowfish.c\n\t$(CCC) -o $@ blowfish.c\n\nobjects/buffer.o: buffer.c\n\t$(CCC) -o $@ buffer.c\n\nobjects/charset.o: charset.c\n\t$(CCC) -o $@ charset.c\n\nobjects/crypt.o: crypt.c\n\t$(CCC) -o $@ crypt.c\n\nobjects/crypt_zip.o: crypt_zip.c\n\t$(CCC) -o $@ crypt_zip.c\n\nobjects/dict.o: dict.c\n\t$(CCC) -o $@ dict.c\n\nobjects/diff.o: diff.c\n\t$(CCC) -o $@ diff.c\n\nobjects/digraph.o: digraph.c\n\t$(CCC) -o $@ digraph.c\n\nobjects/edit.o: edit.c\n\t$(CCC) -o $@ edit.c\n\nobjects/eval.o: eval.c\n\t$(CCC) -o $@ eval.c\n\nobjects/evalfunc.o: evalfunc.c\n\t$(CCC) -o $@ evalfunc.c\n\nobjects/ex_cmds.o: ex_cmds.c\n\t$(CCC) -o $@ ex_cmds.c\n\nobjects/ex_cmds2.o: ex_cmds2.c\n\t$(CCC) -o $@ ex_cmds2.c\n\nobjects/ex_docmd.o: ex_docmd.c\n\t$(CCC) -o $@ ex_docmd.c\n\nobjects/ex_eval.o: ex_eval.c\n\t$(CCC) -o $@ ex_eval.c\n\nobjects/ex_getln.o: ex_getln.c\n\t$(CCC) -o $@ ex_getln.c\n\nobjects/farsi.o: farsi.c\n\t$(CCC) -o $@ farsi.c\n\nobjects/fileio.o: fileio.c\n\t$(CCC) -o $@ fileio.c\n\nobjects/fold.o: fold.c\n\t$(CCC) -o $@ fold.c\n\nobjects/getchar.o: getchar.c\n\t$(CCC) -o $@ getchar.c\n\nobjects/hardcopy.o: hardcopy.c\n\t$(CCC) -o $@ hardcopy.c\n\nobjects/hashtab.o: hashtab.c\n\t$(CCC) -o $@ hashtab.c\n\nobjects/gui.o: gui.c\n\t$(CCC) -o $@ gui.c\n\nobjects/gui_at_fs.o: gui_at_fs.c\n\t$(CCC) -o $@ gui_at_fs.c\n\nobjects/gui_at_sb.o: gui_at_sb.c\n\t$(CCC) -o $@ gui_at_sb.c\n\nobjects/gui_athena.o: gui_athena.c\n\t$(CCC) -o $@ gui_athena.c\n\nobjects/gui_beval.o: gui_beval.c\n\t$(CCC) -o $@ gui_beval.c\n\nobjects/gui_gtk.o: gui_gtk.c\n\t$(CCC) -o $@ gui_gtk.c\n\nobjects/gui_gtk_f.o: gui_gtk_f.c\n\t$(CCC) -o $@ gui_gtk_f.c\n\nobjects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c\n\t$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/gui_gtk_gresources.c\n\nobjects/gui_gtk_x11.o: gui_gtk_x11.c\n\t$(CCC) -o $@ gui_gtk_x11.c\n\nobjects/gui_motif.o: gui_motif.c\n\t$(CCC) -o $@ gui_motif.c\n\nobjects/gui_xmdlg.o: gui_xmdlg.c\n\t$(CCC) -o $@ gui_xmdlg.c\n\nobjects/gui_xmebw.o: gui_xmebw.c\n\t$(CCC) -o $@ gui_xmebw.c\n\nobjects/gui_x11.o: gui_x11.c\n\t$(CCC) -o $@ gui_x11.c\n\nobjects/gui_photon.o: gui_photon.c\n\t$(CCC) -o $@ gui_photon.c\n\nobjects/gui_mac.o: gui_mac.c\n\t$(CCC) -o $@ gui_mac.c\n\nobjects/hangulin.o: hangulin.c\n\t$(CCC) -o $@ hangulin.c\n\nobjects/if_cscope.o: if_cscope.c\n\t$(CCC) -o $@ if_cscope.c\n\nobjects/if_xcmdsrv.o: if_xcmdsrv.c\n\t$(CCC) -o $@ if_xcmdsrv.c\n\nobjects/if_lua.o: if_lua.c\n\t$(CCC_NF) $(LUA_CFLAGS) $(ALL_CFLAGS) -o $@ if_lua.c\n\nobjects/if_mzsch.o: if_mzsch.c $(MZSCHEME_EXTRA)\n\t$(CCC) -o $@ $(MZSCHEME_CFLAGS_EXTRA) if_mzsch.c\n\nmzscheme_base.c:\n\t$(MZSCHEME_MZC) --c-mods mzscheme_base.c ++lib scheme/base\n\nobjects/if_perl.o: auto/if_perl.c\n\t$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ auto/if_perl.c\n\nobjects/if_perlsfio.o: if_perlsfio.c\n\t$(CCC_NF) $(PERL_CFLAGS) $(ALL_CFLAGS) -o $@ if_perlsfio.c\n\nobjects/py_getpath.o: $(PYTHON_CONFDIR)/getpath.c\n\t$(CCC_NF) $(PYTHON_CFLAGS) $(ALL_CFLAGS) -o $@ \\\n\t\t$(PYTHON_CONFDIR)/getpath.c \\\n\t\t-I$(PYTHON_CONFDIR) -DHAVE_CONFIG_H -DNO_MAIN \\\n\t\t$(PYTHON_GETPATH_CFLAGS)\n\nobjects/if_python.o: if_python.c if_py_both.h\n\t$(CCC_NF) $(PYTHON_CFLAGS) $(PYTHON_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python.c\n\nobjects/if_python3.o: if_python3.c if_py_both.h\n\t$(CCC_NF) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) $(ALL_CFLAGS) -o $@ if_python3.c\n\nobjects/if_ruby.o: if_ruby.c\n\t$(CCC_NF) $(RUBY_CFLAGS) $(ALL_CFLAGS) -o $@ if_ruby.c\n\nobjects/if_tcl.o: if_tcl.c\n\t$(CCC_NF) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ if_tcl.c\n\nobjects/integration.o: integration.c\n\t$(CCC) -o $@ integration.c\n\nobjects/json.o: json.c\n\t$(CCC) -o $@ json.c\n\nobjects/json_test.o: json_test.c\n\t$(CCC) -o $@ json_test.c\n\nobjects/kword_test.o: kword_test.c\n\t$(CCC) -o $@ kword_test.c\n\nobjects/list.o: list.c\n\t$(CCC) -o $@ list.c\n\nobjects/main.o: main.c\n\t$(CCC) -o $@ main.c\n\nobjects/mark.o: mark.c\n\t$(CCC) -o $@ mark.c\n\nobjects/memfile.o: memfile.c\n\t$(CCC) -o $@ memfile.c\n\nobjects/memfile_test.o: memfile_test.c\n\t$(CCC) -o $@ memfile_test.c\n\nobjects/memline.o: memline.c\n\t$(CCC) -o $@ memline.c\n\nobjects/menu.o: menu.c\n\t$(CCC) -o $@ menu.c\n\nobjects/message.o: message.c\n\t$(CCC) -o $@ message.c\n\nobjects/message_test.o: message_test.c\n\t$(CCC) -o $@ message_test.c\n\nobjects/misc1.o: misc1.c\n\t$(CCC) -o $@ misc1.c\n\nobjects/misc2.o: misc2.c\n\t$(CCC) -o $@ misc2.c\n\nobjects/move.o: move.c\n\t$(CCC) -o $@ move.c\n\nobjects/mbyte.o: mbyte.c\n\t$(CCC) -o $@ mbyte.c\n\nobjects/normal.o: normal.c\n\t$(CCC) -o $@ normal.c\n\nobjects/ops.o: ops.c\n\t$(CCC) -o $@ ops.c\n\nobjects/option.o: option.c\n\t$(CCC_NF) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) $(PYTHON3_CFLAGS) $(RUBY_CFLAGS) $(TCL_CFLAGS) $(ALL_CFLAGS) -o $@ option.c\n\nobjects/os_beos.o: os_beos.c\n\t$(CCC) -o $@ os_beos.c\n\nobjects/os_qnx.o: os_qnx.c\n\t$(CCC) -o $@ os_qnx.c\n\nobjects/os_macosx.o: os_macosx.m\n\t$(CCC) -o $@ os_macosx.m\n\nobjects/os_mac_conv.o: os_mac_conv.c\n\t$(CCC) -o $@ os_mac_conv.c\n\nobjects/os_unix.o: os_unix.c\n\t$(CCC) -o $@ os_unix.c\n\nobjects/os_mswin.o: os_mswin.c\n\t$(CCC) -o $@ os_mswin.c\n\nobjects/winclip.o: winclip.c\n\t$(CCC) -o $@ winclip.c\n\nobjects/pathdef.o: auto/pathdef.c\n\t$(CCC) -o $@ auto/pathdef.c\n\nobjects/popupmnu.o: popupmnu.c\n\t$(CCC) -o $@ popupmnu.c\n\nobjects/pty.o: pty.c\n\t$(CCC) -o $@ pty.c\n\nobjects/quickfix.o: quickfix.c\n\t$(CCC) -o $@ quickfix.c\n\nobjects/regexp.o: regexp.c regexp_nfa.c\n\t$(CCC) -o $@ regexp.c\n\nobjects/screen.o: screen.c\n\t$(CCC) -o $@ screen.c\n\nobjects/search.o: search.c\n\t$(CCC) -o $@ search.c\n\nobjects/sha256.o: sha256.c\n\t$(CCC) -o $@ sha256.c\n\nobjects/spell.o: spell.c\n\t$(CCC) -o $@ spell.c\n\nobjects/spellfile.o: spellfile.c\n\t$(CCC) -o $@ spellfile.c\n\nobjects/syntax.o: syntax.c\n\t$(CCC) -o $@ syntax.c\n\nobjects/tag.o: tag.c\n\t$(CCC) -o $@ tag.c\n\nobjects/term.o: term.c\n\t$(CCC) -o $@ term.c\n\nobjects/terminal.o: terminal.c $(TERM_DEPS)\n\t$(CCC) -o $@ terminal.c\n\nobjects/ui.o: ui.c\n\t$(CCC) -o $@ ui.c\n\nobjects/undo.o: undo.c\n\t$(CCC) -o $@ undo.c\n\nobjects/userfunc.o: userfunc.c\n\t$(CCC) -o $@ userfunc.c\n\nobjects/window.o: window.c\n\t$(CCC) -o $@ window.c\n\nobjects/workshop.o: workshop.c\n\t$(CCC) -o $@ workshop.c\n\nobjects/wsdebug.o: wsdebug.c\n\t$(CCC) -o $@ wsdebug.c\n\nobjects/netbeans.o: netbeans.c\n\t$(CCC) -o $@ netbeans.c\n\nobjects/channel.o: channel.c\n\t$(CCC) -o $@ channel.c\n\nMakefile:\n\t@echo The name of the makefile MUST be \"Makefile\" (with capital M)!!!!\n\nCCCTERM = $(CCC_NF) -Ilibvterm/include $(ALL_CFLAGS) -DINLINE=\"\" \\\n\t  -DVSNPRINTF=vim_vsnprintf \\\n\t  -DIS_COMBINING_FUNCTION=utf_iscomposing_uint \\\n\t  -DWCWIDTH_FUNCTION=utf_uint2cells\n\nobjects/term_encoding.o: libvterm/src/encoding.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/encoding.c\n\nobjects/term_keyboard.o: libvterm/src/keyboard.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/keyboard.c\n\nobjects/term_mouse.o: libvterm/src/mouse.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/mouse.c\n\nobjects/term_parser.o: libvterm/src/parser.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/parser.c\n\nobjects/term_pen.o: libvterm/src/pen.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/pen.c\n\nobjects/term_screen.o: libvterm/src/screen.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/screen.c\n\nobjects/term_state.o: libvterm/src/state.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/state.c\n\nobjects/term_unicode.o: libvterm/src/unicode.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/unicode.c\n\nobjects/term_vterm.o: libvterm/src/vterm.c $(TERM_DEPS)\n\t$(CCCTERM) -o $@ libvterm/src/vterm.c\n\n###############################################################################\n### MacOS X installation\n###\n### This installs a runnable Vim.app in $(prefix)\n\nREZ    = /Developer/Tools/Rez\nRESDIR = $(APPDIR)/Contents/Resources\nVERSION = $(VIMMAJOR).$(VIMMINOR)\n\n### Common flags\nM4FLAGSX = $(M4FLAGS) -DAPP_EXE=$(VIMNAME) -DAPP_NAME=$(VIMNAME) \\\n\t\t-DAPP_VER=$(VERSION)\n\ninstall_macosx: gui_bundle\n# Remove the link to the runtime dir, don't want to copy all of that.\n\t-rm $(RESDIR)/vim/runtime\n\t$(INSTALL_DATA_R) $(APPDIR) $(DESTDIR)$(prefix)\n# Generate the help tags file now, it won't work with \"make installruntime\".\n\t-@srcdir=`pwd`; cd $(HELPSOURCE); $(MAKE) VIMEXE=$$srcdir/$(VIMTARGET) vimtags\n# Install the runtime files.  Recursive!\n\t$(MKDIR_P) $(DESTDIR)$(prefix)/$(RESDIR)/vim/runtime\n\tsrcdir=`pwd`; $(MAKE) -f Makefile installruntime \\\n\t\tVIMEXE=$$srcdir/$(VIMTARGET) \\\n\t\tprefix=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR) \\\n\t\texec_prefix=$(DESTDIR)$(prefix)/$(APPDIR)/Contents \\\n\t\tBINDIR=$(DESTDIR)$(prefix)/$(APPDIR)/Contents/MacOS \\\n\t\tVIMLOC=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR) \\\n\t\tVIMRTLOC=$(DESTDIR)$(prefix)/$(RESDIR)$(VIMDIR)/runtime\n# Put the link back.\n\tln -s `pwd`/../runtime $(RESDIR)/vim\n# Copy rgb.txt, Mac doesn't always have X11\n\t$(INSTALL_DATA) $(SCRIPTSOURCE)/rgb.txt $(DESTDIR)$(prefix)/$(RESDIR)/vim/runtime\n# TODO: Create the vimtutor and/or gvimtutor application.\n\ngui_bundle: $(RESDIR) bundle-dir bundle-executable bundle-info bundle-resource \\\n\tbundle-language\n\n$(RESDIR):\n\t$(MKDIR_P) $@\n\nbundle-dir: $(APPDIR)/Contents $(VIMTARGET)\n# Make a link to the runtime directory, so that we can try out the executable\n# without installing it.\n\t$(MKDIR_P) $(RESDIR)/vim\n\t-ln -s `pwd`/../runtime $(RESDIR)/vim\n\nbundle-executable: $(VIMTARGET)\n\t$(MKDIR_P) $(APPDIR)/Contents/MacOS\n\tcp $(VIMTARGET) $(APPDIR)/Contents/MacOS/$(VIMTARGET)\n\nbundle-info:  bundle-dir\n\t@echo \"Creating PkgInfo\"\n\t@echo -n \"APPLVIM!\" > $(APPDIR)/Contents/PkgInfo\n\t@echo \"Creating Info.plist\"\n\tm4 $(M4FLAGSX) infplist.xml > $(APPDIR)/Contents/Info.plist\n\nbundle-resource: bundle-dir bundle-rsrc\n\tcp -f $(RSRC_DIR)/*.icns $(RESDIR)\n\n### Classic resources\n# Resource fork (in the form of a .rsrc file) for Classic Vim (Mac OS 9)\n# This file is also required for OS X Vim.\nbundle-rsrc: os_mac.rsr.hqx\n\t@echo \"Creating resource fork\"\n\tpython dehqx.py $<\n\trm -f gui_mac.rsrc\n\tmv gui_mac.rsrc.rsrcfork $(RESDIR)/$(VIMNAME).rsrc\n\n# po/Make_osx.pl says something about generating a Mac message file\n# for Ukrainian.  Would somebody using Mac OS X in Ukrainian\n# *really* be upset that Carbon Vim was not localised in\n# Ukrainian?\n#\n#bundle-language: bundle-dir po/Make_osx.pl\n#\tcd po && perl Make_osx.pl --outdir ../$(RESDIR) $(MULTILANG)\nbundle-language: bundle-dir\n\n$(APPDIR)/Contents:\n\t$(MKDIR_P) $(APPDIR)/Contents/MacOS\n\t$(MKDIR_P) $(RESDIR)/English.lproj\n\n\n###############################################################################\n### (automatically generated by 'make depend')\n### Dependencies:\nobjects/arabic.o: arabic.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/blowfish.o: blowfish.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/buffer.o: buffer.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/charset.o: charset.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/crypt.o: crypt.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/crypt_zip.o: crypt_zip.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/dict.o: dict.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/diff.o: diff.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/digraph.o: digraph.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/edit.o: edit.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/eval.o: eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/evalfunc.o: evalfunc.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/ex_cmds.o: ex_cmds.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/ex_cmds2.o: ex_cmds2.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/ex_docmd.o: ex_docmd.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h ex_cmdidxs.h\nobjects/ex_eval.o: ex_eval.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/ex_getln.o: ex_getln.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/farsi.o: farsi.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/fileio.o: fileio.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/fold.o: fold.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/getchar.o: getchar.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/hardcopy.o: hardcopy.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/hashtab.o: hashtab.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/if_cscope.o: if_cscope.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_cscope.h\nobjects/if_xcmdsrv.o: if_xcmdsrv.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/json.o: json.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/list.o: list.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/main.o: main.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/mark.o: mark.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/memfile.o: memfile.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/memline.o: memline.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/menu.o: menu.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/message.o: message.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/misc1.o: misc1.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/misc2.o: misc2.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/move.o: move.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/mbyte.o: mbyte.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/normal.o: normal.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/ops.o: ops.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/option.o: option.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/os_unix.o: os_unix.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h os_unixx.h\nobjects/pathdef.o: auto/pathdef.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/popupmnu.o: popupmnu.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/quickfix.o: quickfix.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/regexp.o: regexp.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h regexp_nfa.c\nobjects/screen.o: screen.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/search.o: search.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/sha256.o: sha256.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/spell.o: spell.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/spellfile.o: spellfile.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/syntax.o: syntax.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/tag.o: tag.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/term.o: term.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/terminal.o: terminal.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/ui.o: ui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/undo.o: undo.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/userfunc.o: userfunc.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/version.o: version.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/window.o: window.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/gui.o: gui.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/gui_gtk.o: gui_gtk.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h gui_gtk_f.h\nobjects/gui_gtk_f.o: gui_gtk_f.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_gtk_f.h\nobjects/gui_motif.o: gui_motif.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_xmebw.h ../pixmaps/alert.xpm \\\n ../pixmaps/error.xpm ../pixmaps/generic.xpm ../pixmaps/info.xpm \\\n ../pixmaps/quest.xpm gui_x11_pm.h ../pixmaps/tb_new.xpm \\\n ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm ../pixmaps/tb_save.xpm \\\n ../pixmaps/tb_print.xpm ../pixmaps/tb_cut.xpm ../pixmaps/tb_copy.xpm \\\n ../pixmaps/tb_paste.xpm ../pixmaps/tb_find.xpm \\\n ../pixmaps/tb_find_next.xpm ../pixmaps/tb_find_prev.xpm \\\n ../pixmaps/tb_find_help.xpm ../pixmaps/tb_exit.xpm \\\n ../pixmaps/tb_undo.xpm ../pixmaps/tb_redo.xpm ../pixmaps/tb_help.xpm \\\n ../pixmaps/tb_macro.xpm ../pixmaps/tb_make.xpm \\\n ../pixmaps/tb_save_all.xpm ../pixmaps/tb_jump.xpm \\\n ../pixmaps/tb_ctags.xpm ../pixmaps/tb_load_session.xpm \\\n ../pixmaps/tb_save_session.xpm ../pixmaps/tb_new_session.xpm \\\n ../pixmaps/tb_blank.xpm ../pixmaps/tb_maximize.xpm \\\n ../pixmaps/tb_split.xpm ../pixmaps/tb_minimize.xpm \\\n ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \\\n ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \\\n ../pixmaps/tb_minwidth.xpm\nobjects/gui_xmdlg.o: gui_xmdlg.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/gui_xmebw.o: gui_xmebw.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_xmebwp.h gui_xmebw.h\nobjects/gui_athena.o: gui_athena.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_at_sb.h gui_x11_pm.h \\\n ../pixmaps/tb_new.xpm ../pixmaps/tb_open.xpm ../pixmaps/tb_close.xpm \\\n ../pixmaps/tb_save.xpm ../pixmaps/tb_print.xpm ../pixmaps/tb_cut.xpm \\\n ../pixmaps/tb_copy.xpm ../pixmaps/tb_paste.xpm ../pixmaps/tb_find.xpm \\\n ../pixmaps/tb_find_next.xpm ../pixmaps/tb_find_prev.xpm \\\n ../pixmaps/tb_find_help.xpm ../pixmaps/tb_exit.xpm \\\n ../pixmaps/tb_undo.xpm ../pixmaps/tb_redo.xpm ../pixmaps/tb_help.xpm \\\n ../pixmaps/tb_macro.xpm ../pixmaps/tb_make.xpm \\\n ../pixmaps/tb_save_all.xpm ../pixmaps/tb_jump.xpm \\\n ../pixmaps/tb_ctags.xpm ../pixmaps/tb_load_session.xpm \\\n ../pixmaps/tb_save_session.xpm ../pixmaps/tb_new_session.xpm \\\n ../pixmaps/tb_blank.xpm ../pixmaps/tb_maximize.xpm \\\n ../pixmaps/tb_split.xpm ../pixmaps/tb_minimize.xpm \\\n ../pixmaps/tb_shell.xpm ../pixmaps/tb_replace.xpm \\\n ../pixmaps/tb_vsplit.xpm ../pixmaps/tb_maxwidth.xpm \\\n ../pixmaps/tb_minwidth.xpm\nobjects/gui_gtk_x11.o: gui_gtk_x11.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h auto/gui_gtk_gresources.h gui_gtk_f.h \\\n ../runtime/vim32x32.xpm ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm\nobjects/gui_x11.o: gui_x11.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h ../runtime/vim32x32.xpm \\\n ../runtime/vim16x16.xpm ../runtime/vim48x48.xpm\nobjects/gui_at_sb.o: gui_at_sb.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_at_sb.h\nobjects/gui_at_fs.o: gui_at_fs.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h gui_at_sb.h\nobjects/pty.o: pty.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \\\n keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \\\n proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h globals.h farsi.h \\\n arabic.h\nobjects/json_test.o: json_test.c main.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h json.c\nobjects/kword_test.o: kword_test.c main.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h charset.c\nobjects/memfile_test.o: memfile_test.c main.c vim.h auto/config.h feature.h \\\n os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \\\n structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \\\n ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h memfile.c\nobjects/message_test.o: message_test.c main.c vim.h auto/config.h feature.h \\\n os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \\\n structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \\\n ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h message.c\nobjects/hangulin.o: hangulin.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/if_lua.o: if_lua.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/if_mzsch.o: if_mzsch.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_mzsch.h\nobjects/if_perl.o: auto/if_perl.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/if_perlsfio.o: if_perlsfio.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/if_python.o: if_python.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_py_both.h\nobjects/if_python3.o: if_python3.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h if_py_both.h\nobjects/if_tcl.o: if_tcl.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/if_ruby.o: if_ruby.c auto/config.h vim.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h version.h\nobjects/gui_beval.o: gui_beval.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h\nobjects/workshop.o: workshop.c auto/config.h integration.h vim.h feature.h \\\n os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \\\n structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h \\\n ex_cmds.h spell.h proto.h globals.h farsi.h arabic.h version.h \\\n workshop.h\nobjects/wsdebug.o: wsdebug.c\nobjects/integration.o: integration.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h integration.h\nobjects/netbeans.o: netbeans.c vim.h auto/config.h feature.h os_unix.h \\\n auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \\\n regexp.h gui.h gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h \\\n proto.h globals.h farsi.h arabic.h version.h\nobjects/channel.o: channel.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \\\n ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \\\n gui_beval.h proto/gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \\\n globals.h farsi.h arabic.h\nobjects/gui_gtk_gresources.o: auto/gui_gtk_gresources.c\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * fileio.c: read from and write to a file\n */\n\n#include \"vim.h\"\n\n#if defined(__TANDEM) || defined(__MINT__)\n# include <limits.h>\t\t/* for SSIZE_MAX */\n#endif\n\n#if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)\n# include <utime.h>\t\t/* for struct utimbuf */\n#endif\n\n#define BUFSIZE\t\t8192\t/* size of normal write buffer */\n#define SMBUFSIZE\t256\t/* size of emergency write buffer */\n\n/* Is there any system that doesn't have access()? */\n#define USE_MCH_ACCESS\n\n#ifdef FEAT_MBYTE\nstatic char_u *next_fenc(char_u **pp);\n# ifdef FEAT_EVAL\nstatic char_u *readfile_charconvert(char_u *fname, char_u *fenc, int *fdp);\n# endif\n#endif\n#ifdef FEAT_VIMINFO\nstatic void check_marks_read(void);\n#endif\n#ifdef FEAT_CRYPT\nstatic char_u *check_for_cryptkey(char_u *cryptkey, char_u *ptr, long *sizep, off_T *filesizep, int newfile, char_u *fname, int *did_ask);\n#endif\n#ifdef UNIX\nstatic void set_file_time(char_u *fname, time_t atime, time_t mtime);\n#endif\nstatic int set_rw_fname(char_u *fname, char_u *sfname);\nstatic int msg_add_fileformat(int eol_type);\nstatic void msg_add_eol(void);\nstatic int check_mtime(buf_T *buf, stat_T *s);\nstatic int time_differs(long t1, long t2);\n#ifdef FEAT_AUTOCMD\nstatic int apply_autocmds_exarg(event_T event, char_u *fname, char_u *fname_io, int force, buf_T *buf, exarg_T *eap);\nstatic int au_find_group(char_u *name);\n\n# define AUGROUP_DEFAULT    -1\t    /* default autocmd group */\n# define AUGROUP_ERROR\t    -2\t    /* erroneous autocmd group */\n# define AUGROUP_ALL\t    -3\t    /* all autocmd groups */\n#endif\n\n#if defined(FEAT_CRYPT) || defined(FEAT_MBYTE)\n# define HAS_BW_FLAGS\n# define FIO_LATIN1\t0x01\t/* convert Latin1 */\n# define FIO_UTF8\t0x02\t/* convert UTF-8 */\n# define FIO_UCS2\t0x04\t/* convert UCS-2 */\n# define FIO_UCS4\t0x08\t/* convert UCS-4 */\n# define FIO_UTF16\t0x10\t/* convert UTF-16 */\n# ifdef WIN3264\n#  define FIO_CODEPAGE\t0x20\t/* convert MS-Windows codepage */\n#  define FIO_PUT_CP(x) (((x) & 0xffff) << 16)\t/* put codepage in top word */\n#  define FIO_GET_CP(x)\t(((x)>>16) & 0xffff)\t/* get codepage from top word */\n# endif\n# ifdef MACOS_CONVERT\n#  define FIO_MACROMAN\t0x20\t/* convert MacRoman */\n# endif\n# define FIO_ENDIAN_L\t0x80\t/* little endian */\n# define FIO_ENCRYPTED\t0x1000\t/* encrypt written bytes */\n# define FIO_NOCONVERT\t0x2000\t/* skip encoding conversion */\n# define FIO_UCSBOM\t0x4000\t/* check for BOM at start of file */\n# define FIO_ALL\t-1\t/* allow all formats */\n#endif\n\n/* When converting, a read() or write() may leave some bytes to be converted\n * for the next call.  The value is guessed... */\n#define CONV_RESTLEN 30\n\n/* We have to guess how much a sequence of bytes may expand when converting\n * with iconv() to be able to allocate a buffer. */\n#define ICONV_MULT 8\n\n/*\n * Structure to pass arguments from buf_write() to buf_write_bytes().\n */\nstruct bw_info\n{\n    int\t\tbw_fd;\t\t/* file descriptor */\n    char_u\t*bw_buf;\t/* buffer with data to be written */\n    int\t\tbw_len;\t\t/* length of data */\n#ifdef HAS_BW_FLAGS\n    int\t\tbw_flags;\t/* FIO_ flags */\n#endif\n#ifdef FEAT_CRYPT\n    buf_T\t*bw_buffer;\t/* buffer being written */\n#endif\n#ifdef FEAT_MBYTE\n    char_u\tbw_rest[CONV_RESTLEN]; /* not converted bytes */\n    int\t\tbw_restlen;\t/* nr of bytes in bw_rest[] */\n    int\t\tbw_first;\t/* first write call */\n    char_u\t*bw_conv_buf;\t/* buffer for writing converted chars */\n    int\t\tbw_conv_buflen; /* size of bw_conv_buf */\n    int\t\tbw_conv_error;\t/* set for conversion error */\n    linenr_T\tbw_conv_error_lnum;  /* first line with error or zero */\n    linenr_T\tbw_start_lnum;  /* line number at start of buffer */\n# ifdef USE_ICONV\n    iconv_t\tbw_iconv_fd;\t/* descriptor for iconv() or -1 */\n# endif\n#endif\n};\n\nstatic int  buf_write_bytes(struct bw_info *ip);\n\n#ifdef FEAT_MBYTE\nstatic linenr_T readfile_linenr(linenr_T linecnt, char_u *p, char_u *endp);\nstatic int ucs2bytes(unsigned c, char_u **pp, int flags);\nstatic int need_conversion(char_u *fenc);\nstatic int get_fio_flags(char_u *ptr);\nstatic char_u *check_for_bom(char_u *p, long size, int *lenp, int flags);\nstatic int make_bom(char_u *buf, char_u *name);\n# ifdef WIN3264\nstatic int get_win_fio_flags(char_u *ptr);\n# endif\n# ifdef MACOS_CONVERT\nstatic int get_mac_fio_flags(char_u *ptr);\n# endif\n#endif\nstatic int move_lines(buf_T *frombuf, buf_T *tobuf);\n#ifdef TEMPDIRNAMES\nstatic void vim_settempdir(char_u *tempdir);\n#endif\n#ifdef FEAT_AUTOCMD\nstatic char *e_auchangedbuf = N_(\"E812: Autocommands changed buffer or buffer name\");\n#endif\n\n#ifdef FEAT_AUTOCMD\n/*\n * Set by the apply_autocmds_group function if the given event is equal to\n * EVENT_FILETYPE. Used by the readfile function in order to determine if\n * EVENT_BUFREADPOST triggered the EVENT_FILETYPE.\n *\n * Relying on this value requires one to reset it prior calling\n * apply_autocmds_group.\n */\nstatic int au_did_filetype INIT(= FALSE);\n#endif\n\n    void\nfilemess(\n    buf_T\t*buf,\n    char_u\t*name,\n    char_u\t*s,\n    int\t\tattr)\n{\n    int\t\tmsg_scroll_save;\n\n    if (msg_silent != 0)\n\treturn;\n    msg_add_fname(buf, name);\t    /* put file name in IObuff with quotes */\n    /* If it's extremely long, truncate it. */\n    if (STRLEN(IObuff) > IOSIZE - 80)\n\tIObuff[IOSIZE - 80] = NUL;\n    STRCAT(IObuff, s);\n    /*\n     * For the first message may have to start a new line.\n     * For further ones overwrite the previous one, reset msg_scroll before\n     * calling filemess().\n     */\n    msg_scroll_save = msg_scroll;\n    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0)\n\tmsg_scroll = FALSE;\n    if (!msg_scroll)\t/* wait a bit when overwriting an error msg */\n\tcheck_for_delay(FALSE);\n    msg_start();\n    msg_scroll = msg_scroll_save;\n    msg_scrolled_ign = TRUE;\n    /* may truncate the message to avoid a hit-return prompt */\n    msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);\n    msg_clr_eos();\n    out_flush();\n    msg_scrolled_ign = FALSE;\n}\n\n/*\n * Read lines from file \"fname\" into the buffer after line \"from\".\n *\n * 1. We allocate blocks with lalloc, as big as possible.\n * 2. Each block is filled with characters from the file with a single read().\n * 3. The lines are inserted in the buffer with ml_append().\n *\n * (caller must check that fname != NULL, unless READ_STDIN is used)\n *\n * \"lines_to_skip\" is the number of lines that must be skipped\n * \"lines_to_read\" is the number of lines that are appended\n * When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.\n *\n * flags:\n * READ_NEW\tstarting to edit a new buffer\n * READ_FILTER\treading filter output\n * READ_STDIN\tread from stdin instead of a file\n * READ_BUFFER\tread from curbuf instead of a file (converting after reading\n *\t\tstdin)\n * READ_DUMMY\tread into a dummy buffer (to check if file contents changed)\n * READ_KEEP_UNDO  don't clear undo info or read it from a file\n * READ_FIFO\tread from fifo/socket instead of a file\n *\n * return FAIL for failure, NOTDONE for directory (failure), or OK\n */\n    int\nreadfile(\n    char_u\t*fname,\n    char_u\t*sfname,\n    linenr_T\tfrom,\n    linenr_T\tlines_to_skip,\n    linenr_T\tlines_to_read,\n    exarg_T\t*eap,\t\t\t/* can be NULL! */\n    int\t\tflags)\n{\n    int\t\tfd = 0;\n    int\t\tnewfile = (flags & READ_NEW);\n    int\t\tcheck_readonly;\n    int\t\tfiltering = (flags & READ_FILTER);\n    int\t\tread_stdin = (flags & READ_STDIN);\n    int\t\tread_buffer = (flags & READ_BUFFER);\n    int\t\tread_fifo = (flags & READ_FIFO);\n    int\t\tset_options = newfile || read_buffer\n\t\t\t\t\t   || (eap != NULL && eap->read_edit);\n    linenr_T\tread_buf_lnum = 1;\t/* next line to read from curbuf */\n    colnr_T\tread_buf_col = 0;\t/* next char to read from this line */\n    char_u\tc;\n    linenr_T\tlnum = from;\n    char_u\t*ptr = NULL;\t\t/* pointer into read buffer */\n    char_u\t*buffer = NULL;\t\t/* read buffer */\n    char_u\t*new_buffer = NULL;\t/* init to shut up gcc */\n    char_u\t*line_start = NULL;\t/* init to shut up gcc */\n    int\t\twasempty;\t\t/* buffer was empty before reading */\n    colnr_T\tlen;\n    long\tsize = 0;\n    char_u\t*p;\n    off_T\tfilesize = 0;\n    int\t\tskip_read = FALSE;\n#ifdef FEAT_CRYPT\n    char_u\t*cryptkey = NULL;\n    int\t\tdid_ask_for_key = FALSE;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n    context_sha256_T sha_ctx;\n    int\t\tread_undo_file = FALSE;\n#endif\n    int\t\tsplit = 0;\t\t/* number of split lines */\n#define UNKNOWN\t 0x0fffffff\t\t/* file size is unknown */\n    linenr_T\tlinecnt;\n    int\t\terror = FALSE;\t\t/* errors encountered */\n    int\t\tff_error = EOL_UNKNOWN; /* file format with errors */\n    long\tlinerest = 0;\t\t/* remaining chars in line */\n#ifdef UNIX\n    int\t\tperm = 0;\n    int\t\tswap_mode = -1;\t\t/* protection bits for swap file */\n#else\n    int\t\tperm;\n#endif\n    int\t\tfileformat = 0;\t\t/* end-of-line format */\n    int\t\tkeep_fileformat = FALSE;\n    stat_T\tst;\n    int\t\tfile_readonly;\n    linenr_T\tskip_count = 0;\n    linenr_T\tread_count = 0;\n    int\t\tmsg_save = msg_scroll;\n    linenr_T\tread_no_eol_lnum = 0;   /* non-zero lnum when last line of\n\t\t\t\t\t * last read was missing the eol */\n    int\t\ttry_mac;\n    int\t\ttry_dos;\n    int\t\ttry_unix;\n    int\t\tfile_rewind = FALSE;\n#ifdef FEAT_MBYTE\n    int\t\tcan_retry;\n    linenr_T\tconv_error = 0;\t\t/* line nr with conversion error */\n    linenr_T\tillegal_byte = 0;\t/* line nr with illegal byte */\n    int\t\tkeep_dest_enc = FALSE;\t/* don't retry when char doesn't fit\n\t\t\t\t\t   in destination encoding */\n    int\t\tbad_char_behavior = BAD_REPLACE;\n\t\t\t\t\t/* BAD_KEEP, BAD_DROP or character to\n\t\t\t\t\t * replace with */\n    char_u\t*tmpname = NULL;\t/* name of 'charconvert' output file */\n    int\t\tfio_flags = 0;\n    char_u\t*fenc;\t\t\t/* fileencoding to use */\n    int\t\tfenc_alloced;\t\t/* fenc_next is in allocated memory */\n    char_u\t*fenc_next = NULL;\t/* next item in 'fencs' or NULL */\n    int\t\tadvance_fenc = FALSE;\n    long\treal_size = 0;\n# ifdef USE_ICONV\n    iconv_t\ticonv_fd = (iconv_t)-1;\t/* descriptor for iconv() or -1 */\n#  ifdef FEAT_EVAL\n    int\t\tdid_iconv = FALSE;\t/* TRUE when iconv() failed and trying\n\t\t\t\t\t   'charconvert' next */\n#  endif\n# endif\n    int\t\tconverted = FALSE;\t/* TRUE if conversion done */\n    int\t\tnotconverted = FALSE;\t/* TRUE if conversion wanted but it\n\t\t\t\t\t   wasn't possible */\n    char_u\tconv_rest[CONV_RESTLEN];\n    int\t\tconv_restlen = 0;\t/* nr of bytes in conv_rest[] */\n#endif\n#ifdef FEAT_AUTOCMD\n    buf_T\t*old_curbuf;\n    char_u\t*old_b_ffname;\n    char_u\t*old_b_fname;\n    int\t\tusing_b_ffname;\n    int\t\tusing_b_fname;\n#endif\n\n#ifdef FEAT_AUTOCMD\n    au_did_filetype = FALSE; /* reset before triggering any autocommands */\n#endif\n\n    curbuf->b_no_eol_lnum = 0;\t/* in case it was set by the previous read */\n\n    /*\n     * If there is no file name yet, use the one for the read file.\n     * BF_NOTEDITED is set to reflect this.\n     * Don't do this for a read from a filter.\n     * Only do this when 'cpoptions' contains the 'f' flag.\n     */\n    if (curbuf->b_ffname == NULL\n\t    && !filtering\n\t    && fname != NULL\n\t    && vim_strchr(p_cpo, CPO_FNAMER) != NULL\n\t    && !(flags & READ_DUMMY))\n    {\n\tif (set_rw_fname(fname, sfname) == FAIL)\n\t    return FAIL;\n    }\n\n#ifdef FEAT_AUTOCMD\n    /* Remember the initial values of curbuf, curbuf->b_ffname and\n     * curbuf->b_fname to detect whether they are altered as a result of\n     * executing nasty autocommands.  Also check if \"fname\" and \"sfname\"\n     * point to one of these values. */\n    old_curbuf = curbuf;\n    old_b_ffname = curbuf->b_ffname;\n    old_b_fname = curbuf->b_fname;\n    using_b_ffname = (fname == curbuf->b_ffname)\n\t\t\t\t\t      || (sfname == curbuf->b_ffname);\n    using_b_fname = (fname == curbuf->b_fname) || (sfname == curbuf->b_fname);\n#endif\n\n    /* After reading a file the cursor line changes but we don't want to\n     * display the line. */\n    ex_no_reprint = TRUE;\n\n    /* don't display the file info for another buffer now */\n    need_fileinfo = FALSE;\n\n    /*\n     * For Unix: Use the short file name whenever possible.\n     * Avoids problems with networks and when directory names are changed.\n     * Don't do this for MS-DOS, a \"cd\" in a sub-shell may have moved us to\n     * another directory, which we don't detect.\n     */\n    if (sfname == NULL)\n\tsfname = fname;\n#if defined(UNIX)\n    fname = sfname;\n#endif\n\n#ifdef FEAT_AUTOCMD\n    /*\n     * The BufReadCmd and FileReadCmd events intercept the reading process by\n     * executing the associated commands instead.\n     */\n    if (!filtering && !read_stdin && !read_buffer)\n    {\n\tpos_T\t    pos;\n\n\tpos = curbuf->b_op_start;\n\n\t/* Set '[ mark to the line above where the lines go (line 1 if zero). */\n\tcurbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n\tcurbuf->b_op_start.col = 0;\n\n\tif (newfile)\n\t{\n\t    if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap))\n#ifdef FEAT_EVAL\n\t\treturn aborting() ? FAIL : OK;\n#else\n\t\treturn OK;\n#endif\n\t}\n\telse if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,\n\t\t\t\t\t\t\t    FALSE, NULL, eap))\n#ifdef FEAT_EVAL\n\t    return aborting() ? FAIL : OK;\n#else\n\t    return OK;\n#endif\n\n\tcurbuf->b_op_start = pos;\n    }\n#endif\n\n    if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0)\n\tmsg_scroll = FALSE;\t/* overwrite previous file message */\n    else\n\tmsg_scroll = TRUE;\t/* don't overwrite previous file message */\n\n    /*\n     * If the name ends in a path separator, we can't open it.  Check here,\n     * because reading the file may actually work, but then creating the swap\n     * file may destroy it!  Reported on MS-DOS and Win 95.\n     * If the name is too long we might crash further on, quit here.\n     */\n    if (fname != NULL && *fname != NUL)\n    {\n\tp = fname + STRLEN(fname);\n\tif (after_pathsep(fname, p) || STRLEN(fname) >= MAXPATHL)\n\t{\n\t    filemess(curbuf, fname, (char_u *)_(\"Illegal file name\"), 0);\n\t    msg_end();\n\t    msg_scroll = msg_save;\n\t    return FAIL;\n\t}\n    }\n\n    if (!read_stdin && !read_buffer && !read_fifo)\n    {\n#ifdef UNIX\n\t/*\n\t * On Unix it is possible to read a directory, so we have to\n\t * check for it before the mch_open().\n\t */\n\tperm = mch_getperm(fname);\n\tif (perm >= 0 && !S_ISREG(perm)\t\t    /* not a regular file ... */\n# ifdef S_ISFIFO\n\t\t      && !S_ISFIFO(perm)\t    /* ... or fifo */\n# endif\n# ifdef S_ISSOCK\n\t\t      && !S_ISSOCK(perm)\t    /* ... or socket */\n# endif\n# ifdef OPEN_CHR_FILES\n\t\t      && !(S_ISCHR(perm) && is_dev_fd_file(fname))\n\t\t\t/* ... or a character special file named /dev/fd/<n> */\n# endif\n\t\t\t\t\t\t)\n\t{\n\t    int retval = FAIL;\n\n\t    if (S_ISDIR(perm))\n\t    {\n\t\tfilemess(curbuf, fname, (char_u *)_(\"is a directory\"), 0);\n\t\tretval = NOTDONE;\n\t    }\n\t    else\n\t\tfilemess(curbuf, fname, (char_u *)_(\"is not a file\"), 0);\n\t    msg_end();\n\t    msg_scroll = msg_save;\n\t    return retval;\n\t}\n#endif\n#if defined(MSWIN)\n\t/*\n\t * MS-Windows allows opening a device, but we will probably get stuck\n\t * trying to read it.\n\t */\n\tif (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)\n\t{\n\t    filemess(curbuf, fname, (char_u *)_(\"is a device (disabled with 'opendevice' option)\"), 0);\n\t    msg_end();\n\t    msg_scroll = msg_save;\n\t    return FAIL;\n\t}\n#endif\n    }\n\n    /* Set default or forced 'fileformat' and 'binary'. */\n    set_file_options(set_options, eap);\n\n    /*\n     * When opening a new file we take the readonly flag from the file.\n     * Default is r/w, can be set to r/o below.\n     * Don't reset it when in readonly mode\n     * Only set/reset b_p_ro when BF_CHECK_RO is set.\n     */\n    check_readonly = (newfile && (curbuf->b_flags & BF_CHECK_RO));\n    if (check_readonly && !readonlymode)\n\tcurbuf->b_p_ro = FALSE;\n\n    if (newfile && !read_stdin && !read_buffer && !read_fifo)\n    {\n\t/* Remember time of file. */\n\tif (mch_stat((char *)fname, &st) >= 0)\n\t{\n\t    buf_store_time(curbuf, &st, fname);\n\t    curbuf->b_mtime_read = curbuf->b_mtime;\n#ifdef UNIX\n\t    /*\n\t     * Use the protection bits of the original file for the swap file.\n\t     * This makes it possible for others to read the name of the\n\t     * edited file from the swapfile, but only if they can read the\n\t     * edited file.\n\t     * Remove the \"write\" and \"execute\" bits for group and others\n\t     * (they must not write the swapfile).\n\t     * Add the \"read\" and \"write\" bits for the user, otherwise we may\n\t     * not be able to write to the file ourselves.\n\t     * Setting the bits is done below, after creating the swap file.\n\t     */\n\t    swap_mode = (st.st_mode & 0644) | 0600;\n#endif\n#ifdef FEAT_CW_EDITOR\n\t    /* Get the FSSpec on MacOS\n\t     * TODO: Update it properly when the buffer name changes\n\t     */\n\t    (void)GetFSSpecFromPath(curbuf->b_ffname, &curbuf->b_FSSpec);\n#endif\n#ifdef VMS\n\t    curbuf->b_fab_rfm = st.st_fab_rfm;\n\t    curbuf->b_fab_rat = st.st_fab_rat;\n\t    curbuf->b_fab_mrs = st.st_fab_mrs;\n#endif\n\t}\n\telse\n\t{\n\t    curbuf->b_mtime = 0;\n\t    curbuf->b_mtime_read = 0;\n\t    curbuf->b_orig_size = 0;\n\t    curbuf->b_orig_mode = 0;\n\t}\n\n\t/* Reset the \"new file\" flag.  It will be set again below when the\n\t * file doesn't exist. */\n\tcurbuf->b_flags &= ~(BF_NEW | BF_NEW_W);\n    }\n\n/*\n * for UNIX: check readonly with perm and mch_access()\n * for Amiga: check readonly by trying to open the file for writing\n */\n    file_readonly = FALSE;\n    if (read_stdin)\n    {\n#if defined(MSWIN)\n\t/* Force binary I/O on stdin to avoid CR-LF -> LF conversion. */\n\tsetmode(0, O_BINARY);\n#endif\n    }\n    else if (!read_buffer)\n    {\n#ifdef USE_MCH_ACCESS\n\tif (\n# ifdef UNIX\n\t    !(perm & 0222) ||\n# endif\n\t\t\t\tmch_access((char *)fname, W_OK))\n\t    file_readonly = TRUE;\n\tfd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n#else\n\tif (!newfile\n\t\t|| readonlymode\n\t\t|| (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0)\n\t{\n\t    file_readonly = TRUE;\n\t    /* try to open ro */\n\t    fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n\t}\n#endif\n    }\n\n    if (fd < 0)\t\t\t    /* cannot open at all */\n    {\n#ifndef UNIX\n\tint\tisdir_f;\n#endif\n\tmsg_scroll = msg_save;\n#ifndef UNIX\n\t/*\n\t * On Amiga we can't open a directory, check here.\n\t */\n\tisdir_f = (mch_isdir(fname));\n\tperm = mch_getperm(fname);  /* check if the file exists */\n\tif (isdir_f)\n\t{\n\t    filemess(curbuf, sfname, (char_u *)_(\"is a directory\"), 0);\n\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t}\n\telse\n#endif\n\t    if (newfile)\n\t    {\n\t\tif (perm < 0\n#ifdef ENOENT\n\t\t\t&& errno == ENOENT\n#endif\n\t\t   )\n\t\t{\n\t\t    /*\n\t\t     * Set the 'new-file' flag, so that when the file has\n\t\t     * been created by someone else, a \":w\" will complain.\n\t\t     */\n\t\t    curbuf->b_flags |= BF_NEW;\n\n\t\t    /* Create a swap file now, so that other Vims are warned\n\t\t     * that we are editing this file.  Don't do this for a\n\t\t     * \"nofile\" or \"nowrite\" buffer type. */\n#ifdef FEAT_QUICKFIX\n\t\t    if (!bt_dontwrite(curbuf))\n#endif\n\t\t    {\n\t\t\tcheck_need_swap(newfile);\n#ifdef FEAT_AUTOCMD\n\t\t\t/* SwapExists autocommand may mess things up */\n\t\t\tif (curbuf != old_curbuf\n\t\t\t\t|| (using_b_ffname\n\t\t\t\t\t&& (old_b_ffname != curbuf->b_ffname))\n\t\t\t\t|| (using_b_fname\n\t\t\t\t\t && (old_b_fname != curbuf->b_fname)))\n\t\t\t{\n\t\t\t    EMSG(_(e_auchangedbuf));\n\t\t\t    return FAIL;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    if (dir_of_file_exists(fname))\n\t\t\tfilemess(curbuf, sfname, (char_u *)_(\"[New File]\"), 0);\n\t\t    else\n\t\t\tfilemess(curbuf, sfname,\n\t\t\t\t\t   (char_u *)_(\"[New DIRECTORY]\"), 0);\n#ifdef FEAT_VIMINFO\n\t\t    /* Even though this is a new file, it might have been\n\t\t     * edited before and deleted.  Get the old marks. */\n\t\t    check_marks_read();\n#endif\n#ifdef FEAT_MBYTE\n\t\t    /* Set forced 'fileencoding'.  */\n\t\t    if (eap != NULL)\n\t\t\tset_forced_fenc(eap);\n#endif\n#ifdef FEAT_AUTOCMD\n\t\t    apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n#endif\n\t\t    /* remember the current fileformat */\n\t\t    save_file_ff(curbuf);\n\n#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)\n\t\t    if (aborting())   /* autocmds may abort script processing */\n\t\t\treturn FAIL;\n#endif\n\t\t    return OK;\t    /* a new file is not an error */\n\t\t}\n\t\telse\n\t\t{\n\t\t    filemess(curbuf, sfname, (char_u *)(\n# ifdef EFBIG\n\t\t\t    (errno == EFBIG) ? _(\"[File too big]\") :\n# endif\n# ifdef EOVERFLOW\n\t\t\t    (errno == EOVERFLOW) ? _(\"[File too big]\") :\n# endif\n\t\t\t\t\t\t_(\"[Permission Denied]\")), 0);\n\t\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t\t}\n\t    }\n\n\treturn FAIL;\n    }\n\n    /*\n     * Only set the 'ro' flag for readonly files the first time they are\n     * loaded.\tHelp files always get readonly mode\n     */\n    if ((check_readonly && file_readonly) || curbuf->b_help)\n\tcurbuf->b_p_ro = TRUE;\n\n    if (set_options)\n    {\n\t/* Don't change 'eol' if reading from buffer as it will already be\n\t * correctly set when reading stdin. */\n\tif (!read_buffer)\n\t{\n\t    curbuf->b_p_eol = TRUE;\n\t    curbuf->b_start_eol = TRUE;\n\t}\n#ifdef FEAT_MBYTE\n\tcurbuf->b_p_bomb = FALSE;\n\tcurbuf->b_start_bomb = FALSE;\n#endif\n    }\n\n    /* Create a swap file now, so that other Vims are warned that we are\n     * editing this file.\n     * Don't do this for a \"nofile\" or \"nowrite\" buffer type. */\n#ifdef FEAT_QUICKFIX\n    if (!bt_dontwrite(curbuf))\n#endif\n    {\n\tcheck_need_swap(newfile);\n#ifdef FEAT_AUTOCMD\n\tif (!read_stdin && (curbuf != old_curbuf\n\t\t|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n\t\t|| (using_b_fname && (old_b_fname != curbuf->b_fname))))\n\t{\n\t    EMSG(_(e_auchangedbuf));\n\t    if (!read_buffer)\n\t\tclose(fd);\n\t    return FAIL;\n\t}\n#endif\n#ifdef UNIX\n\t/* Set swap file protection bits after creating it. */\n\tif (swap_mode > 0 && curbuf->b_ml.ml_mfp != NULL\n\t\t\t  && curbuf->b_ml.ml_mfp->mf_fname != NULL)\n\t{\n\t    char_u *swap_fname = curbuf->b_ml.ml_mfp->mf_fname;\n\n\t    /*\n\t     * If the group-read bit is set but not the world-read bit, then\n\t     * the group must be equal to the group of the original file.  If\n\t     * we can't make that happen then reset the group-read bit.  This\n\t     * avoids making the swap file readable to more users when the\n\t     * primary group of the user is too permissive.\n\t     */\n\t    if ((swap_mode & 044) == 040)\n\t    {\n\t\tstat_T\tswap_st;\n\n\t\tif (mch_stat((char *)swap_fname, &swap_st) >= 0\n\t\t\t&& st.st_gid != swap_st.st_gid\n\t\t\t&& fchown(curbuf->b_ml.ml_mfp->mf_fd, -1, st.st_gid)\n\t\t\t\t\t\t\t\t\t == -1)\n\t\t    swap_mode &= 0600;\n\t    }\n\n\t    (void)mch_setperm(swap_fname, (long)swap_mode);\n\t}\n#endif\n    }\n\n#if defined(HAS_SWAP_EXISTS_ACTION)\n    /* If \"Quit\" selected at ATTENTION dialog, don't load the file */\n    if (swap_exists_action == SEA_QUIT)\n    {\n\tif (!read_buffer && !read_stdin)\n\t    close(fd);\n\treturn FAIL;\n    }\n#endif\n\n    ++no_wait_return;\t    /* don't wait for return yet */\n\n    /*\n     * Set '[ mark to the line above where the lines go (line 1 if zero).\n     */\n    curbuf->b_op_start.lnum = ((from == 0) ? 1 : from);\n    curbuf->b_op_start.col = 0;\n\n    try_mac = (vim_strchr(p_ffs, 'm') != NULL);\n    try_dos = (vim_strchr(p_ffs, 'd') != NULL);\n    try_unix = (vim_strchr(p_ffs, 'x') != NULL);\n\n#ifdef FEAT_AUTOCMD\n    if (!read_buffer)\n    {\n\tint\tm = msg_scroll;\n\tint\tn = msg_scrolled;\n\n\t/*\n\t * The file must be closed again, the autocommands may want to change\n\t * the file before reading it.\n\t */\n\tif (!read_stdin)\n\t    close(fd);\t\t/* ignore errors */\n\n\t/*\n\t * The output from the autocommands should not overwrite anything and\n\t * should not be overwritten: Set msg_scroll, restore its value if no\n\t * output was done.\n\t */\n\tmsg_scroll = TRUE;\n\tif (filtering)\n\t    apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (read_stdin)\n\t    apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (newfile)\n\t    apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse\n\t    apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,\n\t\t\t\t\t\t\t    FALSE, NULL, eap);\n\t/* autocommands may have changed it */\n\ttry_mac = (vim_strchr(p_ffs, 'm') != NULL);\n\ttry_dos = (vim_strchr(p_ffs, 'd') != NULL);\n\ttry_unix = (vim_strchr(p_ffs, 'x') != NULL);\n\n\tif (msg_scrolled == n)\n\t    msg_scroll = m;\n\n#ifdef FEAT_EVAL\n\tif (aborting())\t    /* autocmds may abort script processing */\n\t{\n\t    --no_wait_return;\n\t    msg_scroll = msg_save;\n\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t    return FAIL;\n\t}\n#endif\n\t/*\n\t * Don't allow the autocommands to change the current buffer.\n\t * Try to re-open the file.\n\t *\n\t * Don't allow the autocommands to change the buffer name either\n\t * (cd for example) if it invalidates fname or sfname.\n\t */\n\tif (!read_stdin && (curbuf != old_curbuf\n\t\t|| (using_b_ffname && (old_b_ffname != curbuf->b_ffname))\n\t\t|| (using_b_fname && (old_b_fname != curbuf->b_fname))\n\t\t|| (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) < 0))\n\t{\n\t    --no_wait_return;\n\t    msg_scroll = msg_save;\n\t    if (fd < 0)\n\t\tEMSG(_(\"E200: *ReadPre autocommands made the file unreadable\"));\n\t    else\n\t\tEMSG(_(\"E201: *ReadPre autocommands must not change current buffer\"));\n\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t    return FAIL;\n\t}\n    }\n#endif /* FEAT_AUTOCMD */\n\n    /* Autocommands may add lines to the file, need to check if it is empty */\n    wasempty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\n    if (!recoverymode && !filtering && !(flags & READ_DUMMY))\n    {\n\t/*\n\t * Show the user that we are busy reading the input.  Sometimes this\n\t * may take a while.  When reading from stdin another program may\n\t * still be running, don't move the cursor to the last line, unless\n\t * always using the GUI.\n\t */\n\tif (read_stdin)\n\t{\n#ifndef ALWAYS_USE_GUI\n\t    mch_msg(_(\"Vim: Reading from stdin...\\n\"));\n#endif\n#ifdef FEAT_GUI\n\t    /* Also write a message in the GUI window, if there is one. */\n\t    if (gui.in_use && !gui.dying && !gui.starting)\n\t    {\n\t\tp = (char_u *)_(\"Reading from stdin...\");\n\t\tgui_write(p, (int)STRLEN(p));\n\t    }\n#endif\n\t}\n\telse if (!read_buffer)\n\t    filemess(curbuf, sfname, (char_u *)\"\", 0);\n    }\n\n    msg_scroll = FALSE;\t\t\t/* overwrite the file message */\n\n    /*\n     * Set linecnt now, before the \"retry\" caused by a wrong guess for\n     * fileformat, and after the autocommands, which may change them.\n     */\n    linecnt = curbuf->b_ml.ml_line_count;\n\n#ifdef FEAT_MBYTE\n    /* \"++bad=\" argument. */\n    if (eap != NULL && eap->bad_char != 0)\n    {\n\tbad_char_behavior = eap->bad_char;\n\tif (set_options)\n\t    curbuf->b_bad_char = eap->bad_char;\n    }\n    else\n\tcurbuf->b_bad_char = 0;\n\n    /*\n     * Decide which 'encoding' to use or use first.\n     */\n    if (eap != NULL && eap->force_enc != 0)\n    {\n\tfenc = enc_canonize(eap->cmd + eap->force_enc);\n\tfenc_alloced = TRUE;\n\tkeep_dest_enc = TRUE;\n    }\n    else if (curbuf->b_p_bin)\n    {\n\tfenc = (char_u *)\"\";\t\t/* binary: don't convert */\n\tfenc_alloced = FALSE;\n    }\n    else if (curbuf->b_help)\n    {\n\tchar_u\t    firstline[80];\n\tint\t    fc;\n\n\t/* Help files are either utf-8 or latin1.  Try utf-8 first, if this\n\t * fails it must be latin1.\n\t * Always do this when 'encoding' is \"utf-8\".  Otherwise only do\n\t * this when needed to avoid [converted] remarks all the time.\n\t * It is needed when the first line contains non-ASCII characters.\n\t * That is only in *.??x files. */\n\tfenc = (char_u *)\"latin1\";\n\tc = enc_utf8;\n\tif (!c && !read_stdin)\n\t{\n\t    fc = fname[STRLEN(fname) - 1];\n\t    if (TOLOWER_ASC(fc) == 'x')\n\t    {\n\t\t/* Read the first line (and a bit more).  Immediately rewind to\n\t\t * the start of the file.  If the read() fails \"len\" is -1. */\n\t\tlen = read_eintr(fd, firstline, 80);\n\t\tvim_lseek(fd, (off_T)0L, SEEK_SET);\n\t\tfor (p = firstline; p < firstline + len; ++p)\n\t\t    if (*p >= 0x80)\n\t\t    {\n\t\t\tc = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\n\tif (c)\n\t{\n\t    fenc_next = fenc;\n\t    fenc = (char_u *)\"utf-8\";\n\n\t    /* When the file is utf-8 but a character doesn't fit in\n\t     * 'encoding' don't retry.  In help text editing utf-8 bytes\n\t     * doesn't make sense. */\n\t    if (!enc_utf8)\n\t\tkeep_dest_enc = TRUE;\n\t}\n\tfenc_alloced = FALSE;\n    }\n    else if (*p_fencs == NUL)\n    {\n\tfenc = curbuf->b_p_fenc;\t/* use format from buffer */\n\tfenc_alloced = FALSE;\n    }\n    else\n    {\n\tfenc_next = p_fencs;\t\t/* try items in 'fileencodings' */\n\tfenc = next_fenc(&fenc_next);\n\tfenc_alloced = TRUE;\n    }\n#endif\n\n    /*\n     * Jump back here to retry reading the file in different ways.\n     * Reasons to retry:\n     * - encoding conversion failed: try another one from \"fenc_next\"\n     * - BOM detected and fenc was set, need to setup conversion\n     * - \"fileformat\" check failed: try another\n     *\n     * Variables set for special retry actions:\n     * \"file_rewind\"\tRewind the file to start reading it again.\n     * \"advance_fenc\"\tAdvance \"fenc\" using \"fenc_next\".\n     * \"skip_read\"\tRe-use already read bytes (BOM detected).\n     * \"did_iconv\"\ticonv() conversion failed, try 'charconvert'.\n     * \"keep_fileformat\" Don't reset \"fileformat\".\n     *\n     * Other status indicators:\n     * \"tmpname\"\tWhen != NULL did conversion with 'charconvert'.\n     *\t\t\tOutput file has to be deleted afterwards.\n     * \"iconv_fd\"\tWhen != -1 did conversion with iconv().\n     */\nretry:\n\n    if (file_rewind)\n    {\n\tif (read_buffer)\n\t{\n\t    read_buf_lnum = 1;\n\t    read_buf_col = 0;\n\t}\n\telse if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0)\n\t{\n\t    /* Can't rewind the file, give up. */\n\t    error = TRUE;\n\t    goto failed;\n\t}\n\t/* Delete the previously read lines. */\n\twhile (lnum > from)\n\t    ml_delete(lnum--, FALSE);\n\tfile_rewind = FALSE;\n#ifdef FEAT_MBYTE\n\tif (set_options)\n\t{\n\t    curbuf->b_p_bomb = FALSE;\n\t    curbuf->b_start_bomb = FALSE;\n\t}\n\tconv_error = 0;\n#endif\n    }\n\n    /*\n     * When retrying with another \"fenc\" and the first time \"fileformat\"\n     * will be reset.\n     */\n    if (keep_fileformat)\n\tkeep_fileformat = FALSE;\n    else\n    {\n\tif (eap != NULL && eap->force_ff != 0)\n\t{\n\t    fileformat = get_fileformat_force(curbuf, eap);\n\t    try_unix = try_dos = try_mac = FALSE;\n\t}\n\telse if (curbuf->b_p_bin)\n\t    fileformat = EOL_UNIX;\t\t/* binary: use Unix format */\n\telse if (*p_ffs == NUL)\n\t    fileformat = get_fileformat(curbuf);/* use format from buffer */\n\telse\n\t    fileformat = EOL_UNKNOWN;\t\t/* detect from file */\n    }\n\n#ifdef FEAT_MBYTE\n# ifdef USE_ICONV\n    if (iconv_fd != (iconv_t)-1)\n    {\n\t/* aborted conversion with iconv(), close the descriptor */\n\ticonv_close(iconv_fd);\n\ticonv_fd = (iconv_t)-1;\n    }\n# endif\n\n    if (advance_fenc)\n    {\n\t/*\n\t * Try the next entry in 'fileencodings'.\n\t */\n\tadvance_fenc = FALSE;\n\n\tif (eap != NULL && eap->force_enc != 0)\n\t{\n\t    /* Conversion given with \"++cc=\" wasn't possible, read\n\t     * without conversion. */\n\t    notconverted = TRUE;\n\t    conv_error = 0;\n\t    if (fenc_alloced)\n\t\tvim_free(fenc);\n\t    fenc = (char_u *)\"\";\n\t    fenc_alloced = FALSE;\n\t}\n\telse\n\t{\n\t    if (fenc_alloced)\n\t\tvim_free(fenc);\n\t    if (fenc_next != NULL)\n\t    {\n\t\tfenc = next_fenc(&fenc_next);\n\t\tfenc_alloced = (fenc_next != NULL);\n\t    }\n\t    else\n\t    {\n\t\tfenc = (char_u *)\"\";\n\t\tfenc_alloced = FALSE;\n\t    }\n\t}\n\tif (tmpname != NULL)\n\t{\n\t    mch_remove(tmpname);\t\t/* delete converted file */\n\t    vim_free(tmpname);\n\t    tmpname = NULL;\n\t}\n    }\n\n    /*\n     * Conversion may be required when the encoding of the file is different\n     * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.\n     */\n    fio_flags = 0;\n    converted = need_conversion(fenc);\n    if (converted)\n    {\n\n\t/* \"ucs-bom\" means we need to check the first bytes of the file\n\t * for a BOM. */\n\tif (STRCMP(fenc, ENC_UCSBOM) == 0)\n\t    fio_flags = FIO_UCSBOM;\n\n\t/*\n\t * Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be\n\t * done.  This is handled below after read().  Prepare the\n\t * fio_flags to avoid having to parse the string each time.\n\t * Also check for Unicode to Latin1 conversion, because iconv()\n\t * appears not to handle this correctly.  This works just like\n\t * conversion to UTF-8 except how the resulting character is put in\n\t * the buffer.\n\t */\n\telse if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0)\n\t    fio_flags = get_fio_flags(fenc);\n\n# ifdef WIN3264\n\t/*\n\t * Conversion from an MS-Windows codepage to UTF-8 or another codepage\n\t * is handled with MultiByteToWideChar().\n\t */\n\tif (fio_flags == 0)\n\t    fio_flags = get_win_fio_flags(fenc);\n# endif\n\n# ifdef MACOS_CONVERT\n\t/* Conversion from Apple MacRoman to latin1 or UTF-8 */\n\tif (fio_flags == 0)\n\t    fio_flags = get_mac_fio_flags(fenc);\n# endif\n\n# ifdef USE_ICONV\n\t/*\n\t * Try using iconv() if we can't convert internally.\n\t */\n\tif (fio_flags == 0\n#  ifdef FEAT_EVAL\n\t\t&& !did_iconv\n#  endif\n\t\t)\n\t    iconv_fd = (iconv_t)my_iconv_open(\n\t\t\t\t  enc_utf8 ? (char_u *)\"utf-8\" : p_enc, fenc);\n# endif\n\n# ifdef FEAT_EVAL\n\t/*\n\t * Use the 'charconvert' expression when conversion is required\n\t * and we can't do it internally or with iconv().\n\t */\n\tif (fio_flags == 0 && !read_stdin && !read_buffer && *p_ccv != NUL\n\t\t\t\t\t\t    && !read_fifo\n#  ifdef USE_ICONV\n\t\t\t\t\t\t    && iconv_fd == (iconv_t)-1\n#  endif\n\t\t)\n\t{\n#  ifdef USE_ICONV\n\t    did_iconv = FALSE;\n#  endif\n\t    /* Skip conversion when it's already done (retry for wrong\n\t     * \"fileformat\"). */\n\t    if (tmpname == NULL)\n\t    {\n\t\ttmpname = readfile_charconvert(fname, fenc, &fd);\n\t\tif (tmpname == NULL)\n\t\t{\n\t\t    /* Conversion failed.  Try another one. */\n\t\t    advance_fenc = TRUE;\n\t\t    if (fd < 0)\n\t\t    {\n\t\t\t/* Re-opening the original file failed! */\n\t\t\tEMSG(_(\"E202: Conversion made file unreadable!\"));\n\t\t\terror = TRUE;\n\t\t\tgoto failed;\n\t\t    }\n\t\t    goto retry;\n\t\t}\n\t    }\n\t}\n\telse\n# endif\n\t{\n\t    if (fio_flags == 0\n# ifdef USE_ICONV\n\t\t    && iconv_fd == (iconv_t)-1\n# endif\n\t       )\n\t    {\n\t\t/* Conversion wanted but we can't.\n\t\t * Try the next conversion in 'fileencodings' */\n\t\tadvance_fenc = TRUE;\n\t\tgoto retry;\n\t    }\n\t}\n    }\n\n    /* Set \"can_retry\" when it's possible to rewind the file and try with\n     * another \"fenc\" value.  It's FALSE when no other \"fenc\" to try, reading\n     * stdin or fixed at a specific encoding. */\n    can_retry = (*fenc != NUL && !read_stdin && !read_fifo && !keep_dest_enc);\n#endif\n\n    if (!skip_read)\n    {\n\tlinerest = 0;\n\tfilesize = 0;\n\tskip_count = lines_to_skip;\n\tread_count = lines_to_read;\n#ifdef FEAT_MBYTE\n\tconv_restlen = 0;\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\tread_undo_file = (newfile && (flags & READ_KEEP_UNDO) == 0\n\t\t\t\t  && curbuf->b_ffname != NULL\n\t\t\t\t  && curbuf->b_p_udf\n\t\t\t\t  && !filtering\n\t\t\t\t  && !read_fifo\n\t\t\t\t  && !read_stdin\n\t\t\t\t  && !read_buffer);\n\tif (read_undo_file)\n\t    sha256_start(&sha_ctx);\n#endif\n#ifdef FEAT_CRYPT\n\tif (curbuf->b_cryptstate != NULL)\n\t{\n\t    /* Need to free the state, but keep the key, don't want to ask for\n\t     * it again. */\n\t    crypt_free_state(curbuf->b_cryptstate);\n\t    curbuf->b_cryptstate = NULL;\n\t}\n#endif\n    }\n\n    while (!error && !got_int)\n    {\n\t/*\n\t * We allocate as much space for the file as we can get, plus\n\t * space for the old line plus room for one terminating NUL.\n\t * The amount is limited by the fact that read() only can read\n\t * upto max_unsigned characters (and other things).\n\t */\n#if VIM_SIZEOF_INT <= 2\n\tif (linerest >= 0x7ff0)\n\t{\n\t    ++split;\n\t    *ptr = NL;\t\t    /* split line by inserting a NL */\n\t    size = 1;\n\t}\n\telse\n#endif\n\t{\n\t    if (!skip_read)\n\t    {\n#if VIM_SIZEOF_INT > 2\n# if defined(SSIZE_MAX) && (SSIZE_MAX < 0x10000L)\n\t\tsize = SSIZE_MAX;\t\t    /* use max I/O size, 52K */\n# else\n\t\tsize = 0x10000L;\t\t    /* use buffer >= 64K */\n# endif\n#else\n\t\tsize = 0x7ff0L - linerest;\t    /* limit buffer to 32K */\n#endif\n\n\t\tfor ( ; size >= 10; size = (long)((long_u)size >> 1))\n\t\t{\n\t\t    if ((new_buffer = lalloc((long_u)(size + linerest + 1),\n\t\t\t\t\t\t\t      FALSE)) != NULL)\n\t\t\tbreak;\n\t\t}\n\t\tif (new_buffer == NULL)\n\t\t{\n\t\t    do_outofmem_msg((long_u)(size * 2 + linerest + 1));\n\t\t    error = TRUE;\n\t\t    break;\n\t\t}\n\t\tif (linerest)\t/* copy characters from the previous buffer */\n\t\t    mch_memmove(new_buffer, ptr - linerest, (size_t)linerest);\n\t\tvim_free(buffer);\n\t\tbuffer = new_buffer;\n\t\tptr = buffer + linerest;\n\t\tline_start = buffer;\n\n#ifdef FEAT_MBYTE\n\t\t/* May need room to translate into.\n\t\t * For iconv() we don't really know the required space, use a\n\t\t * factor ICONV_MULT.\n\t\t * latin1 to utf-8: 1 byte becomes up to 2 bytes\n\t\t * utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes\n\t\t * become up to 4 bytes, size must be multiple of 2\n\t\t * ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be\n\t\t * multiple of 2\n\t\t * ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be\n\t\t * multiple of 4 */\n\t\treal_size = (int)size;\n# ifdef USE_ICONV\n\t\tif (iconv_fd != (iconv_t)-1)\n\t\t    size = size / ICONV_MULT;\n\t\telse\n# endif\n\t\t    if (fio_flags & FIO_LATIN1)\n\t\t    size = size / 2;\n\t\telse if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n\t\t    size = (size * 2 / 3) & ~1;\n\t\telse if (fio_flags & FIO_UCS4)\n\t\t    size = (size * 2 / 3) & ~3;\n\t\telse if (fio_flags == FIO_UCSBOM)\n\t\t    size = size / ICONV_MULT;\t/* worst case */\n# ifdef WIN3264\n\t\telse if (fio_flags & FIO_CODEPAGE)\n\t\t    size = size / ICONV_MULT;\t/* also worst case */\n# endif\n# ifdef MACOS_CONVERT\n\t\telse if (fio_flags & FIO_MACROMAN)\n\t\t    size = size / ICONV_MULT;\t/* also worst case */\n# endif\n#endif\n\n#ifdef FEAT_MBYTE\n\t\tif (conv_restlen > 0)\n\t\t{\n\t\t    /* Insert unconverted bytes from previous line. */\n\t\t    mch_memmove(ptr, conv_rest, conv_restlen);\n\t\t    ptr += conv_restlen;\n\t\t    size -= conv_restlen;\n\t\t}\n#endif\n\n\t\tif (read_buffer)\n\t\t{\n\t\t    /*\n\t\t     * Read bytes from curbuf.  Used for converting text read\n\t\t     * from stdin.\n\t\t     */\n\t\t    if (read_buf_lnum > from)\n\t\t\tsize = 0;\n\t\t    else\n\t\t    {\n\t\t\tint\tn, ni;\n\t\t\tlong\ttlen;\n\n\t\t\ttlen = 0;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    p = ml_get(read_buf_lnum) + read_buf_col;\n\t\t\t    n = (int)STRLEN(p);\n\t\t\t    if ((int)tlen + n + 1 > size)\n\t\t\t    {\n\t\t\t\t/* Filled up to \"size\", append partial line.\n\t\t\t\t * Change NL to NUL to reverse the effect done\n\t\t\t\t * below. */\n\t\t\t\tn = (int)(size - tlen);\n\t\t\t\tfor (ni = 0; ni < n; ++ni)\n\t\t\t\t{\n\t\t\t\t    if (p[ni] == NL)\n\t\t\t\t\tptr[tlen++] = NUL;\n\t\t\t\t    else\n\t\t\t\t\tptr[tlen++] = p[ni];\n\t\t\t\t}\n\t\t\t\tread_buf_col += n;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t/* Append whole line and new-line.  Change NL\n\t\t\t\t * to NUL to reverse the effect done below. */\n\t\t\t\tfor (ni = 0; ni < n; ++ni)\n\t\t\t\t{\n\t\t\t\t    if (p[ni] == NL)\n\t\t\t\t\tptr[tlen++] = NUL;\n\t\t\t\t    else\n\t\t\t\t\tptr[tlen++] = p[ni];\n\t\t\t\t}\n\t\t\t\tptr[tlen++] = NL;\n\t\t\t\tread_buf_col = 0;\n\t\t\t\tif (++read_buf_lnum > from)\n\t\t\t\t{\n\t\t\t\t    /* When the last line didn't have an\n\t\t\t\t     * end-of-line don't add it now either. */\n\t\t\t\t    if (!curbuf->b_p_eol)\n\t\t\t\t\t--tlen;\n\t\t\t\t    size = tlen;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Read bytes from the file.\n\t\t     */\n\t\t    size = read_eintr(fd, ptr, size);\n\t\t}\n\n#ifdef FEAT_CRYPT\n\t\t/*\n\t\t * At start of file: Check for magic number of encryption.\n\t\t */\n\t\tif (filesize == 0 && size > 0)\n\t\t    cryptkey = check_for_cryptkey(cryptkey, ptr, &size,\n\t\t\t\t\t\t  &filesize, newfile, sfname,\n\t\t\t\t\t\t  &did_ask_for_key);\n\t\t/*\n\t\t * Decrypt the read bytes.  This is done before checking for\n\t\t * EOF because the crypt layer may be buffering.\n\t\t */\n\t\tif (cryptkey != NULL && curbuf->b_cryptstate != NULL\n\t\t\t\t\t\t\t\t   && size > 0)\n\t\t{\n\t\t    if (crypt_works_inplace(curbuf->b_cryptstate))\n\t\t    {\n\t\t\tcrypt_decode_inplace(curbuf->b_cryptstate, ptr, size);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tchar_u\t*newptr = NULL;\n\t\t\tint\tdecrypted_size;\n\n\t\t\tdecrypted_size = crypt_decode_alloc(\n\t\t\t\t    curbuf->b_cryptstate, ptr, size, &newptr);\n\n\t\t\t/* If the crypt layer is buffering, not producing\n\t\t\t * anything yet, need to read more. */\n\t\t\tif (size > 0 && decrypted_size == 0)\n\t\t\t    continue;\n\n\t\t\tif (linerest == 0)\n\t\t\t{\n\t\t\t    /* Simple case: reuse returned buffer (may be\n\t\t\t     * NULL, checked later). */\n\t\t\t    new_buffer = newptr;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    long_u\tnew_size;\n\n\t\t\t    /* Need new buffer to add bytes carried over. */\n\t\t\t    new_size = (long_u)(decrypted_size + linerest + 1);\n\t\t\t    new_buffer = lalloc(new_size, FALSE);\n\t\t\t    if (new_buffer == NULL)\n\t\t\t    {\n\t\t\t\tdo_outofmem_msg(new_size);\n\t\t\t\terror = TRUE;\n\t\t\t\tbreak;\n\t\t\t    }\n\n\t\t\t    mch_memmove(new_buffer, buffer, linerest);\n\t\t\t    if (newptr != NULL)\n\t\t\t\tmch_memmove(new_buffer + linerest, newptr,\n\t\t\t\t\t\t\t      decrypted_size);\n\t\t\t}\n\n\t\t\tif (new_buffer != NULL)\n\t\t\t{\n\t\t\t    vim_free(buffer);\n\t\t\t    buffer = new_buffer;\n\t\t\t    new_buffer = NULL;\n\t\t\t    line_start = buffer;\n\t\t\t    ptr = buffer + linerest;\n\t\t\t}\n\t\t\tsize = decrypted_size;\n\t\t    }\n\t\t}\n#endif\n\n\t\tif (size <= 0)\n\t\t{\n\t\t    if (size < 0)\t\t    /* read error */\n\t\t\terror = TRUE;\n#ifdef FEAT_MBYTE\n\t\t    else if (conv_restlen > 0)\n\t\t    {\n\t\t\t/*\n\t\t\t * Reached end-of-file but some trailing bytes could\n\t\t\t * not be converted.  Truncated file?\n\t\t\t */\n\n\t\t\t/* When we did a conversion report an error. */\n\t\t\tif (fio_flags != 0\n# ifdef USE_ICONV\n\t\t\t\t|| iconv_fd != (iconv_t)-1\n# endif\n\t\t\t   )\n\t\t\t{\n\t\t\t    if (can_retry)\n\t\t\t\tgoto rewind_retry;\n\t\t\t    if (conv_error == 0)\n\t\t\t\tconv_error = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t\t\t- linecnt + 1;\n\t\t\t}\n\t\t\t/* Remember the first linenr with an illegal byte */\n\t\t\telse if (illegal_byte == 0)\n\t\t\t    illegal_byte = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t\t\t- linecnt + 1;\n\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t{\n\t\t\t    *(ptr - conv_restlen) = NUL;\n\t\t\t    conv_restlen = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    /* Replace the trailing bytes with the replacement\n\t\t\t     * character if we were converting; if we weren't,\n\t\t\t     * leave the UTF8 checking code to do it, as it\n\t\t\t     * works slightly differently. */\n\t\t\t    if (bad_char_behavior != BAD_KEEP && (fio_flags != 0\n# ifdef USE_ICONV\n\t\t\t\t    || iconv_fd != (iconv_t)-1\n# endif\n\t\t\t       ))\n\t\t\t    {\n\t\t\t\twhile (conv_restlen > 0)\n\t\t\t\t{\n\t\t\t\t    *(--ptr) = bad_char_behavior;\n\t\t\t\t    --conv_restlen;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    fio_flags = 0;\t/* don't convert this */\n# ifdef USE_ICONV\n\t\t\t    if (iconv_fd != (iconv_t)-1)\n\t\t\t    {\n\t\t\t\ticonv_close(iconv_fd);\n\t\t\t\ticonv_fd = (iconv_t)-1;\n\t\t\t    }\n# endif\n\t\t\t}\n\t\t    }\n#endif\n\t\t}\n\t    }\n\t    skip_read = FALSE;\n\n#ifdef FEAT_MBYTE\n\t    /*\n\t     * At start of file (or after crypt magic number): Check for BOM.\n\t     * Also check for a BOM for other Unicode encodings, but not after\n\t     * converting with 'charconvert' or when a BOM has already been\n\t     * found.\n\t     */\n\t    if ((filesize == 0\n# ifdef FEAT_CRYPT\n\t\t   || (cryptkey != NULL\n\t\t\t&& filesize == crypt_get_header_len(\n\t\t\t\t\t\t crypt_get_method_nr(curbuf)))\n# endif\n\t\t       )\n\t\t    && (fio_flags == FIO_UCSBOM\n\t\t\t|| (!curbuf->b_p_bomb\n\t\t\t    && tmpname == NULL\n\t\t\t    && (*fenc == 'u' || (*fenc == NUL && enc_utf8)))))\n\t    {\n\t\tchar_u\t*ccname;\n\t\tint\tblen;\n\n\t\t/* no BOM detection in a short file or in binary mode */\n\t\tif (size < 2 || curbuf->b_p_bin)\n\t\t    ccname = NULL;\n\t\telse\n\t\t    ccname = check_for_bom(ptr, size, &blen,\n\t\t      fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));\n\t\tif (ccname != NULL)\n\t\t{\n\t\t    /* Remove BOM from the text */\n\t\t    filesize += blen;\n\t\t    size -= blen;\n\t\t    mch_memmove(ptr, ptr + blen, (size_t)size);\n\t\t    if (set_options)\n\t\t    {\n\t\t\tcurbuf->b_p_bomb = TRUE;\n\t\t\tcurbuf->b_start_bomb = TRUE;\n\t\t    }\n\t\t}\n\n\t\tif (fio_flags == FIO_UCSBOM)\n\t\t{\n\t\t    if (ccname == NULL)\n\t\t    {\n\t\t\t/* No BOM detected: retry with next encoding. */\n\t\t\tadvance_fenc = TRUE;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/* BOM detected: set \"fenc\" and jump back */\n\t\t\tif (fenc_alloced)\n\t\t\t    vim_free(fenc);\n\t\t\tfenc = ccname;\n\t\t\tfenc_alloced = FALSE;\n\t\t    }\n\t\t    /* retry reading without getting new bytes or rewinding */\n\t\t    skip_read = TRUE;\n\t\t    goto retry;\n\t\t}\n\t    }\n\n\t    /* Include not converted bytes. */\n\t    ptr -= conv_restlen;\n\t    size += conv_restlen;\n\t    conv_restlen = 0;\n#endif\n\t    /*\n\t     * Break here for a read error or end-of-file.\n\t     */\n\t    if (size <= 0)\n\t\tbreak;\n\n#ifdef FEAT_MBYTE\n\n# ifdef USE_ICONV\n\t    if (iconv_fd != (iconv_t)-1)\n\t    {\n\t\t/*\n\t\t * Attempt conversion of the read bytes to 'encoding' using\n\t\t * iconv().\n\t\t */\n\t\tconst char\t*fromp;\n\t\tchar\t\t*top;\n\t\tsize_t\t\tfrom_size;\n\t\tsize_t\t\tto_size;\n\n\t\tfromp = (char *)ptr;\n\t\tfrom_size = size;\n\t\tptr += size;\n\t\ttop = (char *)ptr;\n\t\tto_size = real_size - size;\n\n\t\t/*\n\t\t * If there is conversion error or not enough room try using\n\t\t * another conversion.  Except for when there is no\n\t\t * alternative (help files).\n\t\t */\n\t\twhile ((iconv(iconv_fd, (void *)&fromp, &from_size,\n\t\t\t\t\t\t\t       &top, &to_size)\n\t\t\t    == (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n\t\t\t\t\t\t  || from_size > CONV_RESTLEN)\n\t\t{\n\t\t    if (can_retry)\n\t\t\tgoto rewind_retry;\n\t\t    if (conv_error == 0)\n\t\t\tconv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t  ptr, (char_u *)top);\n\n\t\t    /* Deal with a bad byte and continue with the next. */\n\t\t    ++fromp;\n\t\t    --from_size;\n\t\t    if (bad_char_behavior == BAD_KEEP)\n\t\t    {\n\t\t\t*top++ = *(fromp - 1);\n\t\t\t--to_size;\n\t\t    }\n\t\t    else if (bad_char_behavior != BAD_DROP)\n\t\t    {\n\t\t\t*top++ = bad_char_behavior;\n\t\t\t--to_size;\n\t\t    }\n\t\t}\n\n\t\tif (from_size > 0)\n\t\t{\n\t\t    /* Some remaining characters, keep them for the next\n\t\t     * round. */\n\t\t    mch_memmove(conv_rest, (char_u *)fromp, from_size);\n\t\t    conv_restlen = (int)from_size;\n\t\t}\n\n\t\t/* move the linerest to before the converted characters */\n\t\tline_start = ptr - linerest;\n\t\tmch_memmove(line_start, buffer, (size_t)linerest);\n\t\tsize = (long)((char_u *)top - ptr);\n\t    }\n# endif\n\n# ifdef WIN3264\n\t    if (fio_flags & FIO_CODEPAGE)\n\t    {\n\t\tchar_u\t*src, *dst;\n\t\tWCHAR\tucs2buf[3];\n\t\tint\tucs2len;\n\t\tint\tcodepage = FIO_GET_CP(fio_flags);\n\t\tint\tbytelen;\n\t\tint\tfound_bad;\n\t\tchar\treplstr[2];\n\n\t\t/*\n\t\t * Conversion from an MS-Windows codepage or UTF-8 to UTF-8 or\n\t\t * a codepage, using standard MS-Windows functions.  This\n\t\t * requires two steps:\n\t\t * 1. convert from 'fileencoding' to ucs-2\n\t\t * 2. convert from ucs-2 to 'encoding'\n\t\t *\n\t\t * Because there may be illegal bytes AND an incomplete byte\n\t\t * sequence at the end, we may have to do the conversion one\n\t\t * character at a time to get it right.\n\t\t */\n\n\t\t/* Replacement string for WideCharToMultiByte(). */\n\t\tif (bad_char_behavior > 0)\n\t\t    replstr[0] = bad_char_behavior;\n\t\telse\n\t\t    replstr[0] = '?';\n\t\treplstr[1] = NUL;\n\n\t\t/*\n\t\t * Move the bytes to the end of the buffer, so that we have\n\t\t * room to put the result at the start.\n\t\t */\n\t\tsrc = ptr + real_size - size;\n\t\tmch_memmove(src, ptr, size);\n\n\t\t/*\n\t\t * Do the conversion.\n\t\t */\n\t\tdst = ptr;\n\t\tsize = size;\n\t\twhile (size > 0)\n\t\t{\n\t\t    found_bad = FALSE;\n\n#  ifdef CP_UTF8\t/* VC 4.1 doesn't define CP_UTF8 */\n\t\t    if (codepage == CP_UTF8)\n\t\t    {\n\t\t\t/* Handle CP_UTF8 input ourselves to be able to handle\n\t\t\t * trailing bytes properly.\n\t\t\t * Get one UTF-8 character from src. */\n\t\t\tbytelen = (int)utf_ptr2len_len(src, size);\n\t\t\tif (bytelen > size)\n\t\t\t{\n\t\t\t    /* Only got some bytes of a character.  Normally\n\t\t\t     * it's put in \"conv_rest\", but if it's too long\n\t\t\t     * deal with it as if they were illegal bytes. */\n\t\t\t    if (bytelen <= CONV_RESTLEN)\n\t\t\t\tbreak;\n\n\t\t\t    /* weird overlong byte sequence */\n\t\t\t    bytelen = size;\n\t\t\t    found_bad = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int\t    u8c = utf_ptr2char(src);\n\n\t\t\t    if (u8c > 0xffff || (*src >= 0x80 && bytelen == 1))\n\t\t\t\tfound_bad = TRUE;\n\t\t\t    ucs2buf[0] = u8c;\n\t\t\t    ucs2len = 1;\n\t\t\t}\n\t\t    }\n\t\t    else\n#  endif\n\t\t    {\n\t\t\t/* We don't know how long the byte sequence is, try\n\t\t\t * from one to three bytes. */\n\t\t\tfor (bytelen = 1; bytelen <= size && bytelen <= 3;\n\t\t\t\t\t\t\t\t    ++bytelen)\n\t\t\t{\n\t\t\t    ucs2len = MultiByteToWideChar(codepage,\n\t\t\t\t\t\t\t MB_ERR_INVALID_CHARS,\n\t\t\t\t\t\t\t (LPCSTR)src, bytelen,\n\t\t\t\t\t\t\t\t   ucs2buf, 3);\n\t\t\t    if (ucs2len > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ucs2len == 0)\n\t\t\t{\n\t\t\t    /* If we have only one byte then it's probably an\n\t\t\t     * incomplete byte sequence.  Otherwise discard\n\t\t\t     * one byte as a bad character. */\n\t\t\t    if (size == 1)\n\t\t\t\tbreak;\n\t\t\t    found_bad = TRUE;\n\t\t\t    bytelen = 1;\n\t\t\t}\n\t\t    }\n\n\t\t    if (!found_bad)\n\t\t    {\n\t\t\tint\ti;\n\n\t\t\t/* Convert \"ucs2buf[ucs2len]\" to 'enc' in \"dst\". */\n\t\t\tif (enc_utf8)\n\t\t\t{\n\t\t\t    /* From UCS-2 to UTF-8.  Cannot fail. */\n\t\t\t    for (i = 0; i < ucs2len; ++i)\n\t\t\t\tdst += utf_char2bytes(ucs2buf[i], dst);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    BOOL\tbad = FALSE;\n\t\t\t    int\t\tdstlen;\n\n\t\t\t    /* From UCS-2 to \"enc_codepage\".  If the\n\t\t\t     * conversion uses the default character \"?\",\n\t\t\t     * the data doesn't fit in this encoding. */\n\t\t\t    dstlen = WideCharToMultiByte(enc_codepage, 0,\n\t\t\t\t    (LPCWSTR)ucs2buf, ucs2len,\n\t\t\t\t    (LPSTR)dst, (int)(src - dst),\n\t\t\t\t    replstr, &bad);\n\t\t\t    if (bad)\n\t\t\t\tfound_bad = TRUE;\n\t\t\t    else\n\t\t\t\tdst += dstlen;\n\t\t\t}\n\t\t    }\n\n\t\t    if (found_bad)\n\t\t    {\n\t\t\t/* Deal with bytes we can't convert. */\n\t\t\tif (can_retry)\n\t\t\t    goto rewind_retry;\n\t\t\tif (conv_error == 0)\n\t\t\t    conv_error = readfile_linenr(linecnt, ptr, dst);\n\t\t\tif (bad_char_behavior != BAD_DROP)\n\t\t\t{\n\t\t\t    if (bad_char_behavior == BAD_KEEP)\n\t\t\t    {\n\t\t\t\tmch_memmove(dst, src, bytelen);\n\t\t\t\tdst += bytelen;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\t*dst++ = bad_char_behavior;\n\t\t\t}\n\t\t    }\n\n\t\t    src += bytelen;\n\t\t    size -= bytelen;\n\t\t}\n\n\t\tif (size > 0)\n\t\t{\n\t\t    /* An incomplete byte sequence remaining. */\n\t\t    mch_memmove(conv_rest, src, size);\n\t\t    conv_restlen = size;\n\t\t}\n\n\t\t/* The new size is equal to how much \"dst\" was advanced. */\n\t\tsize = (long)(dst - ptr);\n\t    }\n\t    else\n# endif\n# ifdef MACOS_CONVERT\n\t    if (fio_flags & FIO_MACROMAN)\n\t    {\n\t\t/*\n\t\t * Conversion from Apple MacRoman char encoding to UTF-8 or\n\t\t * latin1.  This is in os_mac_conv.c.\n\t\t */\n\t\tif (macroman2enc(ptr, &size, real_size) == FAIL)\n\t\t    goto rewind_retry;\n\t    }\n\t    else\n# endif\n\t    if (fio_flags != 0)\n\t    {\n\t\tint\tu8c;\n\t\tchar_u\t*dest;\n\t\tchar_u\t*tail = NULL;\n\n\t\t/*\n\t\t * \"enc_utf8\" set: Convert Unicode or Latin1 to UTF-8.\n\t\t * \"enc_utf8\" not set: Convert Unicode to Latin1.\n\t\t * Go from end to start through the buffer, because the number\n\t\t * of bytes may increase.\n\t\t * \"dest\" points to after where the UTF-8 bytes go, \"p\" points\n\t\t * to after the next character to convert.\n\t\t */\n\t\tdest = ptr + real_size;\n\t\tif (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8)\n\t\t{\n\t\t    p = ptr + size;\n\t\t    if (fio_flags == FIO_UTF8)\n\t\t    {\n\t\t\t/* Check for a trailing incomplete UTF-8 sequence */\n\t\t\ttail = ptr + size - 1;\n\t\t\twhile (tail > ptr && (*tail & 0xc0) == 0x80)\n\t\t\t    --tail;\n\t\t\tif (tail + utf_byte2len(*tail) <= ptr + size)\n\t\t\t    tail = NULL;\n\t\t\telse\n\t\t\t    p = tail;\n\t\t    }\n\t\t}\n\t\telse if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n\t\t{\n\t\t    /* Check for a trailing byte */\n\t\t    p = ptr + (size & ~1);\n\t\t    if (size & 1)\n\t\t\ttail = p;\n\t\t    if ((fio_flags & FIO_UTF16) && p > ptr)\n\t\t    {\n\t\t\t/* Check for a trailing leading word */\n\t\t\tif (fio_flags & FIO_ENDIAN_L)\n\t\t\t{\n\t\t\t    u8c = (*--p << 8);\n\t\t\t    u8c += *--p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    u8c = *--p;\n\t\t\t    u8c += (*--p << 8);\n\t\t\t}\n\t\t\tif (u8c >= 0xd800 && u8c <= 0xdbff)\n\t\t\t    tail = p;\n\t\t\telse\n\t\t\t    p += 2;\n\t\t    }\n\t\t}\n\t\telse /*  FIO_UCS4 */\n\t\t{\n\t\t    /* Check for trailing 1, 2 or 3 bytes */\n\t\t    p = ptr + (size & ~3);\n\t\t    if (size & 3)\n\t\t\ttail = p;\n\t\t}\n\n\t\t/* If there is a trailing incomplete sequence move it to\n\t\t * conv_rest[]. */\n\t\tif (tail != NULL)\n\t\t{\n\t\t    conv_restlen = (int)((ptr + size) - tail);\n\t\t    mch_memmove(conv_rest, (char_u *)tail, conv_restlen);\n\t\t    size -= conv_restlen;\n\t\t}\n\n\n\t\twhile (p > ptr)\n\t\t{\n\t\t    if (fio_flags & FIO_LATIN1)\n\t\t\tu8c = *--p;\n\t\t    else if (fio_flags & (FIO_UCS2 | FIO_UTF16))\n\t\t    {\n\t\t\tif (fio_flags & FIO_ENDIAN_L)\n\t\t\t{\n\t\t\t    u8c = (*--p << 8);\n\t\t\t    u8c += *--p;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    u8c = *--p;\n\t\t\t    u8c += (*--p << 8);\n\t\t\t}\n\t\t\tif ((fio_flags & FIO_UTF16)\n\t\t\t\t\t    && u8c >= 0xdc00 && u8c <= 0xdfff)\n\t\t\t{\n\t\t\t    int u16c;\n\n\t\t\t    if (p == ptr)\n\t\t\t    {\n\t\t\t\t/* Missing leading word. */\n\t\t\t\tif (can_retry)\n\t\t\t\t    goto rewind_retry;\n\t\t\t\tif (conv_error == 0)\n\t\t\t\t    conv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t\t      ptr, p);\n\t\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t\t    continue;\n\t\t\t\tif (bad_char_behavior != BAD_KEEP)\n\t\t\t\t    u8c = bad_char_behavior;\n\t\t\t    }\n\n\t\t\t    /* found second word of double-word, get the first\n\t\t\t     * word and compute the resulting character */\n\t\t\t    if (fio_flags & FIO_ENDIAN_L)\n\t\t\t    {\n\t\t\t\tu16c = (*--p << 8);\n\t\t\t\tu16c += *--p;\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tu16c = *--p;\n\t\t\t\tu16c += (*--p << 8);\n\t\t\t    }\n\t\t\t    u8c = 0x10000 + ((u16c & 0x3ff) << 10)\n\t\t\t\t\t\t\t      + (u8c & 0x3ff);\n\n\t\t\t    /* Check if the word is indeed a leading word. */\n\t\t\t    if (u16c < 0xd800 || u16c > 0xdbff)\n\t\t\t    {\n\t\t\t\tif (can_retry)\n\t\t\t\t    goto rewind_retry;\n\t\t\t\tif (conv_error == 0)\n\t\t\t\t    conv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t\t      ptr, p);\n\t\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t\t    continue;\n\t\t\t\tif (bad_char_behavior != BAD_KEEP)\n\t\t\t\t    u8c = bad_char_behavior;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else if (fio_flags & FIO_UCS4)\n\t\t    {\n\t\t\tif (fio_flags & FIO_ENDIAN_L)\n\t\t\t{\n\t\t\t    u8c = (unsigned)*--p << 24;\n\t\t\t    u8c += (unsigned)*--p << 16;\n\t\t\t    u8c += (unsigned)*--p << 8;\n\t\t\t    u8c += *--p;\n\t\t\t}\n\t\t\telse\t/* big endian */\n\t\t\t{\n\t\t\t    u8c = *--p;\n\t\t\t    u8c += (unsigned)*--p << 8;\n\t\t\t    u8c += (unsigned)*--p << 16;\n\t\t\t    u8c += (unsigned)*--p << 24;\n\t\t\t}\n\t\t    }\n\t\t    else    /* UTF-8 */\n\t\t    {\n\t\t\tif (*--p < 0x80)\n\t\t\t    u8c = *p;\n\t\t\telse\n\t\t\t{\n\t\t\t    len = utf_head_off(ptr, p);\n\t\t\t    p -= len;\n\t\t\t    u8c = utf_ptr2char(p);\n\t\t\t    if (len == 0)\n\t\t\t    {\n\t\t\t\t/* Not a valid UTF-8 character, retry with\n\t\t\t\t * another fenc when possible, otherwise just\n\t\t\t\t * report the error. */\n\t\t\t\tif (can_retry)\n\t\t\t\t    goto rewind_retry;\n\t\t\t\tif (conv_error == 0)\n\t\t\t\t    conv_error = readfile_linenr(linecnt,\n\t\t\t\t\t\t\t\t      ptr, p);\n\t\t\t\tif (bad_char_behavior == BAD_DROP)\n\t\t\t\t    continue;\n\t\t\t\tif (bad_char_behavior != BAD_KEEP)\n\t\t\t\t    u8c = bad_char_behavior;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (enc_utf8)\t/* produce UTF-8 */\n\t\t    {\n\t\t\tdest -= utf_char2len(u8c);\n\t\t\t(void)utf_char2bytes(u8c, dest);\n\t\t    }\n\t\t    else\t\t/* produce Latin1 */\n\t\t    {\n\t\t\t--dest;\n\t\t\tif (u8c >= 0x100)\n\t\t\t{\n\t\t\t    /* character doesn't fit in latin1, retry with\n\t\t\t     * another fenc when possible, otherwise just\n\t\t\t     * report the error. */\n\t\t\t    if (can_retry)\n\t\t\t\tgoto rewind_retry;\n\t\t\t    if (conv_error == 0)\n\t\t\t\tconv_error = readfile_linenr(linecnt, ptr, p);\n\t\t\t    if (bad_char_behavior == BAD_DROP)\n\t\t\t\t++dest;\n\t\t\t    else if (bad_char_behavior == BAD_KEEP)\n\t\t\t\t*dest = u8c;\n\t\t\t    else if (eap != NULL && eap->bad_char != 0)\n\t\t\t\t*dest = bad_char_behavior;\n\t\t\t    else\n\t\t\t\t*dest = 0xBF;\n\t\t\t}\n\t\t\telse\n\t\t\t    *dest = u8c;\n\t\t    }\n\t\t}\n\n\t\t/* move the linerest to before the converted characters */\n\t\tline_start = dest - linerest;\n\t\tmch_memmove(line_start, buffer, (size_t)linerest);\n\t\tsize = (long)((ptr + real_size) - dest);\n\t\tptr = dest;\n\t    }\n\t    else if (enc_utf8 && !curbuf->b_p_bin)\n\t    {\n\t\tint  incomplete_tail = FALSE;\n\n\t\t/* Reading UTF-8: Check if the bytes are valid UTF-8. */\n\t\tfor (p = ptr; ; ++p)\n\t\t{\n\t\t    int\t todo = (int)((ptr + size) - p);\n\t\t    int\t l;\n\n\t\t    if (todo <= 0)\n\t\t\tbreak;\n\t\t    if (*p >= 0x80)\n\t\t    {\n\t\t\t/* A length of 1 means it's an illegal byte.  Accept\n\t\t\t * an incomplete character at the end though, the next\n\t\t\t * read() will get the next bytes, we'll check it\n\t\t\t * then. */\n\t\t\tl = utf_ptr2len_len(p, todo);\n\t\t\tif (l > todo && !incomplete_tail)\n\t\t\t{\n\t\t\t    /* Avoid retrying with a different encoding when\n\t\t\t     * a truncated file is more likely, or attempting\n\t\t\t     * to read the rest of an incomplete sequence when\n\t\t\t     * we have already done so. */\n\t\t\t    if (p > ptr || filesize > 0)\n\t\t\t\tincomplete_tail = TRUE;\n\t\t\t    /* Incomplete byte sequence, move it to conv_rest[]\n\t\t\t     * and try to read the rest of it, unless we've\n\t\t\t     * already done so. */\n\t\t\t    if (p > ptr)\n\t\t\t    {\n\t\t\t\tconv_restlen = todo;\n\t\t\t\tmch_memmove(conv_rest, p, conv_restlen);\n\t\t\t\tsize -= conv_restlen;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (l == 1 || l > todo)\n\t\t\t{\n\t\t\t    /* Illegal byte.  If we can try another encoding\n\t\t\t     * do that, unless at EOF where a truncated\n\t\t\t     * file is more likely than a conversion error. */\n\t\t\t    if (can_retry && !incomplete_tail)\n\t\t\t\tbreak;\n# ifdef USE_ICONV\n\t\t\t    /* When we did a conversion report an error. */\n\t\t\t    if (iconv_fd != (iconv_t)-1 && conv_error == 0)\n\t\t\t\tconv_error = readfile_linenr(linecnt, ptr, p);\n# endif\n\t\t\t    /* Remember the first linenr with an illegal byte */\n\t\t\t    if (conv_error == 0 && illegal_byte == 0)\n\t\t\t\tillegal_byte = readfile_linenr(linecnt, ptr, p);\n\n\t\t\t    /* Drop, keep or replace the bad byte. */\n\t\t\t    if (bad_char_behavior == BAD_DROP)\n\t\t\t    {\n\t\t\t\tmch_memmove(p, p + 1, todo - 1);\n\t\t\t\t--p;\n\t\t\t\t--size;\n\t\t\t    }\n\t\t\t    else if (bad_char_behavior != BAD_KEEP)\n\t\t\t\t*p = bad_char_behavior;\n\t\t\t}\n\t\t\telse\n\t\t\t    p += l - 1;\n\t\t    }\n\t\t}\n\t\tif (p < ptr + size && !incomplete_tail)\n\t\t{\n\t\t    /* Detected a UTF-8 error. */\nrewind_retry:\n\t\t    /* Retry reading with another conversion. */\n# if defined(FEAT_EVAL) && defined(USE_ICONV)\n\t\t    if (*p_ccv != NUL && iconv_fd != (iconv_t)-1)\n\t\t\t/* iconv() failed, try 'charconvert' */\n\t\t\tdid_iconv = TRUE;\n\t\t    else\n# endif\n\t\t\t/* use next item from 'fileencodings' */\n\t\t\tadvance_fenc = TRUE;\n\t\t    file_rewind = TRUE;\n\t\t    goto retry;\n\t\t}\n\t    }\n#endif\n\n\t    /* count the number of characters (after conversion!) */\n\t    filesize += size;\n\n\t    /*\n\t     * when reading the first part of a file: guess EOL type\n\t     */\n\t    if (fileformat == EOL_UNKNOWN)\n\t    {\n\t\t/* First try finding a NL, for Dos and Unix */\n\t\tif (try_dos || try_unix)\n\t\t{\n\t\t    /* Reset the carriage return counter. */\n\t\t    if (try_mac)\n\t\t\ttry_mac = 1;\n\n\t\t    for (p = ptr; p < ptr + size; ++p)\n\t\t    {\n\t\t\tif (*p == NL)\n\t\t\t{\n\t\t\t    if (!try_unix\n\t\t\t\t    || (try_dos && p > ptr && p[-1] == CAR))\n\t\t\t\tfileformat = EOL_DOS;\n\t\t\t    else\n\t\t\t\tfileformat = EOL_UNIX;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (*p == CAR && try_mac)\n\t\t\t    try_mac++;\n\t\t    }\n\n\t\t    /* Don't give in to EOL_UNIX if EOL_MAC is more likely */\n\t\t    if (fileformat == EOL_UNIX && try_mac)\n\t\t    {\n\t\t\t/* Need to reset the counters when retrying fenc. */\n\t\t\ttry_mac = 1;\n\t\t\ttry_unix = 1;\n\t\t\tfor (; p >= ptr && *p != CAR; p--)\n\t\t\t    ;\n\t\t\tif (p >= ptr)\n\t\t\t{\n\t\t\t    for (p = ptr; p < ptr + size; ++p)\n\t\t\t    {\n\t\t\t\tif (*p == NL)\n\t\t\t\t    try_unix++;\n\t\t\t\telse if (*p == CAR)\n\t\t\t\t    try_mac++;\n\t\t\t    }\n\t\t\t    if (try_mac > try_unix)\n\t\t\t\tfileformat = EOL_MAC;\n\t\t\t}\n\t\t    }\n\t\t    else if (fileformat == EOL_UNKNOWN && try_mac == 1)\n\t\t\t/* Looking for CR but found no end-of-line markers at\n\t\t\t * all: use the default format. */\n\t\t\tfileformat = default_fileformat();\n\t\t}\n\n\t\t/* No NL found: may use Mac format */\n\t\tif (fileformat == EOL_UNKNOWN && try_mac)\n\t\t    fileformat = EOL_MAC;\n\n\t\t/* Still nothing found?  Use first format in 'ffs' */\n\t\tif (fileformat == EOL_UNKNOWN)\n\t\t    fileformat = default_fileformat();\n\n\t\t/* if editing a new file: may set p_tx and p_ff */\n\t\tif (set_options)\n\t\t    set_fileformat(fileformat, OPT_LOCAL);\n\t    }\n\t}\n\n\t/*\n\t * This loop is executed once for every character read.\n\t * Keep it fast!\n\t */\n\tif (fileformat == EOL_MAC)\n\t{\n\t    --ptr;\n\t    while (++ptr, --size >= 0)\n\t    {\n\t\t/* catch most common case first */\n\t\tif ((c = *ptr) != NUL && c != CAR && c != NL)\n\t\t    continue;\n\t\tif (c == NUL)\n\t\t    *ptr = NL;\t/* NULs are replaced by newlines! */\n\t\telse if (c == NL)\n\t\t    *ptr = CAR;\t/* NLs are replaced by CRs! */\n\t\telse\n\t\t{\n\t\t    if (skip_count == 0)\n\t\t    {\n\t\t\t*ptr = NUL;\t    /* end of line */\n\t\t\tlen = (colnr_T) (ptr - line_start + 1);\n\t\t\tif (ml_append(lnum, line_start, len, newfile) == FAIL)\n\t\t\t{\n\t\t\t    error = TRUE;\n\t\t\t    break;\n\t\t\t}\n#ifdef FEAT_PERSISTENT_UNDO\n\t\t\tif (read_undo_file)\n\t\t\t    sha256_update(&sha_ctx, line_start, len);\n#endif\n\t\t\t++lnum;\n\t\t\tif (--read_count == 0)\n\t\t\t{\n\t\t\t    error = TRUE;\t/* break loop */\n\t\t\t    line_start = ptr;\t/* nothing left to write */\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t--skip_count;\n\t\t    line_start = ptr + 1;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    --ptr;\n\t    while (++ptr, --size >= 0)\n\t    {\n\t\tif ((c = *ptr) != NUL && c != NL)  /* catch most common case */\n\t\t    continue;\n\t\tif (c == NUL)\n\t\t    *ptr = NL;\t/* NULs are replaced by newlines! */\n\t\telse\n\t\t{\n\t\t    if (skip_count == 0)\n\t\t    {\n\t\t\t*ptr = NUL;\t\t/* end of line */\n\t\t\tlen = (colnr_T)(ptr - line_start + 1);\n\t\t\tif (fileformat == EOL_DOS)\n\t\t\t{\n\t\t\t    if (ptr > line_start && ptr[-1] == CAR)\n\t\t\t    {\n\t\t\t\t/* remove CR before NL */\n\t\t\t\tptr[-1] = NUL;\n\t\t\t\t--len;\n\t\t\t    }\n\t\t\t    /*\n\t\t\t     * Reading in Dos format, but no CR-LF found!\n\t\t\t     * When 'fileformats' includes \"unix\", delete all\n\t\t\t     * the lines read so far and start all over again.\n\t\t\t     * Otherwise give an error message later.\n\t\t\t     */\n\t\t\t    else if (ff_error != EOL_DOS)\n\t\t\t    {\n\t\t\t\tif (   try_unix\n\t\t\t\t    && !read_stdin\n\t\t\t\t    && (read_buffer\n\t\t\t\t\t|| vim_lseek(fd, (off_T)0L, SEEK_SET)\n\t\t\t\t\t\t\t\t\t  == 0))\n\t\t\t\t{\n\t\t\t\t    fileformat = EOL_UNIX;\n\t\t\t\t    if (set_options)\n\t\t\t\t\tset_fileformat(EOL_UNIX, OPT_LOCAL);\n\t\t\t\t    file_rewind = TRUE;\n\t\t\t\t    keep_fileformat = TRUE;\n\t\t\t\t    goto retry;\n\t\t\t\t}\n\t\t\t\tff_error = EOL_DOS;\n\t\t\t    }\n\t\t\t}\n\t\t\tif (ml_append(lnum, line_start, len, newfile) == FAIL)\n\t\t\t{\n\t\t\t    error = TRUE;\n\t\t\t    break;\n\t\t\t}\n#ifdef FEAT_PERSISTENT_UNDO\n\t\t\tif (read_undo_file)\n\t\t\t    sha256_update(&sha_ctx, line_start, len);\n#endif\n\t\t\t++lnum;\n\t\t\tif (--read_count == 0)\n\t\t\t{\n\t\t\t    error = TRUE;\t    /* break loop */\n\t\t\t    line_start = ptr;\t/* nothing left to write */\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t\t--skip_count;\n\t\t    line_start = ptr + 1;\n\t\t}\n\t    }\n\t}\n\tlinerest = (long)(ptr - line_start);\n\tui_breakcheck();\n    }\n\nfailed:\n    /* not an error, max. number of lines reached */\n    if (error && read_count == 0)\n\terror = FALSE;\n\n    /*\n     * If we get EOF in the middle of a line, note the fact and\n     * complete the line ourselves.\n     * In Dos format ignore a trailing CTRL-Z, unless 'binary' set.\n     */\n    if (!error\n\t    && !got_int\n\t    && linerest != 0\n\t    && !(!curbuf->b_p_bin\n\t\t&& fileformat == EOL_DOS\n\t\t&& *line_start == Ctrl_Z\n\t\t&& ptr == line_start + 1))\n    {\n\t/* remember for when writing */\n\tif (set_options)\n\t    curbuf->b_p_eol = FALSE;\n\t*ptr = NUL;\n\tlen = (colnr_T)(ptr - line_start + 1);\n\tif (ml_append(lnum, line_start, len, newfile) == FAIL)\n\t    error = TRUE;\n\telse\n\t{\n#ifdef FEAT_PERSISTENT_UNDO\n\t    if (read_undo_file)\n\t\tsha256_update(&sha_ctx, line_start, len);\n#endif\n\t    read_no_eol_lnum = ++lnum;\n\t}\n    }\n\n    if (set_options)\n\tsave_file_ff(curbuf);\t\t/* remember the current file format */\n\n#ifdef FEAT_CRYPT\n    if (curbuf->b_cryptstate != NULL)\n    {\n\tcrypt_free_state(curbuf->b_cryptstate);\n\tcurbuf->b_cryptstate = NULL;\n    }\n    if (cryptkey != NULL && cryptkey != curbuf->b_p_key)\n\tcrypt_free_key(cryptkey);\n    /* Don't set cryptkey to NULL, it's used below as a flag that\n     * encryption was used. */\n#endif\n\n#ifdef FEAT_MBYTE\n    /* If editing a new file: set 'fenc' for the current buffer.\n     * Also for \":read ++edit file\". */\n    if (set_options)\n\tset_string_option_direct((char_u *)\"fenc\", -1, fenc,\n\t\t\t\t\t\t       OPT_FREE|OPT_LOCAL, 0);\n    if (fenc_alloced)\n\tvim_free(fenc);\n# ifdef USE_ICONV\n    if (iconv_fd != (iconv_t)-1)\n    {\n\ticonv_close(iconv_fd);\n\ticonv_fd = (iconv_t)-1;\n    }\n# endif\n#endif\n\n    if (!read_buffer && !read_stdin)\n\tclose(fd);\t\t\t\t/* errors are ignored */\n#ifdef HAVE_FD_CLOEXEC\n    else\n    {\n\tint fdflags = fcntl(fd, F_GETFD);\n\tif (fdflags >= 0 && (fdflags & FD_CLOEXEC) == 0)\n\t    (void)fcntl(fd, F_SETFD, fdflags | FD_CLOEXEC);\n    }\n#endif\n    vim_free(buffer);\n\n#ifdef HAVE_DUP\n    if (read_stdin)\n    {\n\t/* Use stderr for stdin, makes shell commands work. */\n\tclose(0);\n\tignored = dup(2);\n    }\n#endif\n\n#ifdef FEAT_MBYTE\n    if (tmpname != NULL)\n    {\n\tmch_remove(tmpname);\t\t/* delete converted file */\n\tvim_free(tmpname);\n    }\n#endif\n    --no_wait_return;\t\t\t/* may wait for return now */\n\n    /*\n     * In recovery mode everything but autocommands is skipped.\n     */\n    if (!recoverymode)\n    {\n\t/* need to delete the last line, which comes from the empty buffer */\n\tif (newfile && wasempty && !(curbuf->b_ml.ml_flags & ML_EMPTY))\n\t{\n#ifdef FEAT_NETBEANS_INTG\n\t    netbeansFireChanges = 0;\n#endif\n\t    ml_delete(curbuf->b_ml.ml_line_count, FALSE);\n#ifdef FEAT_NETBEANS_INTG\n\t    netbeansFireChanges = 1;\n#endif\n\t    --linecnt;\n\t}\n\tlinecnt = curbuf->b_ml.ml_line_count - linecnt;\n\tif (filesize == 0)\n\t    linecnt = 0;\n\tif (newfile || read_buffer)\n\t{\n\t    redraw_curbuf_later(NOT_VALID);\n#ifdef FEAT_DIFF\n\t    /* After reading the text into the buffer the diff info needs to\n\t     * be updated. */\n\t    diff_invalidate(curbuf);\n#endif\n#ifdef FEAT_FOLDING\n\t    /* All folds in the window are invalid now.  Mark them for update\n\t     * before triggering autocommands. */\n\t    foldUpdateAll(curwin);\n#endif\n\t}\n\telse if (linecnt)\t\t/* appended at least one line */\n\t    appended_lines_mark(from, linecnt);\n\n#ifndef ALWAYS_USE_GUI\n\t/*\n\t * If we were reading from the same terminal as where messages go,\n\t * the screen will have been messed up.\n\t * Switch on raw mode now and clear the screen.\n\t */\n\tif (read_stdin)\n\t{\n\t    settmode(TMODE_RAW);\t/* set to raw mode */\n\t    starttermcap();\n\t    screenclear();\n\t}\n#endif\n\n\tif (got_int)\n\t{\n\t    if (!(flags & READ_DUMMY))\n\t    {\n\t\tfilemess(curbuf, sfname, (char_u *)_(e_interr), 0);\n\t\tif (newfile)\n\t\t    curbuf->b_p_ro = TRUE;\t/* must use \"w!\" now */\n\t    }\n\t    msg_scroll = msg_save;\n#ifdef FEAT_VIMINFO\n\t    check_marks_read();\n#endif\n\t    return OK;\t\t/* an interrupt isn't really an error */\n\t}\n\n\tif (!filtering && !(flags & READ_DUMMY))\n\t{\n\t    msg_add_fname(curbuf, sfname);   /* fname in IObuff with quotes */\n\t    c = FALSE;\n\n#ifdef UNIX\n# ifdef S_ISFIFO\n\t    if (S_ISFIFO(perm))\t\t\t    /* fifo or socket */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[fifo/socket]\"));\n\t\tc = TRUE;\n\t    }\n# else\n#  ifdef S_IFIFO\n\t    if ((perm & S_IFMT) == S_IFIFO)\t    /* fifo */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[fifo]\"));\n\t\tc = TRUE;\n\t    }\n#  endif\n#  ifdef S_IFSOCK\n\t    if ((perm & S_IFMT) == S_IFSOCK)\t    /* or socket */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[socket]\"));\n\t\tc = TRUE;\n\t    }\n#  endif\n# endif\n# ifdef OPEN_CHR_FILES\n\t    if (S_ISCHR(perm))\t\t\t    /* or character special */\n\t    {\n\t\tSTRCAT(IObuff, _(\"[character special]\"));\n\t\tc = TRUE;\n\t    }\n# endif\n#endif\n\t    if (curbuf->b_p_ro)\n\t    {\n\t\tSTRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));\n\t\tc = TRUE;\n\t    }\n\t    if (read_no_eol_lnum)\n\t    {\n\t\tmsg_add_eol();\n\t\tc = TRUE;\n\t    }\n\t    if (ff_error == EOL_DOS)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[CR missing]\"));\n\t\tc = TRUE;\n\t    }\n\t    if (split)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[long lines split]\"));\n\t\tc = TRUE;\n\t    }\n#ifdef FEAT_MBYTE\n\t    if (notconverted)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[NOT converted]\"));\n\t\tc = TRUE;\n\t    }\n\t    else if (converted)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[converted]\"));\n\t\tc = TRUE;\n\t    }\n#endif\n#ifdef FEAT_CRYPT\n\t    if (cryptkey != NULL)\n\t    {\n\t\tcrypt_append_msg(curbuf);\n\t\tc = TRUE;\n\t    }\n#endif\n#ifdef FEAT_MBYTE\n\t    if (conv_error != 0)\n\t    {\n\t\tsprintf((char *)IObuff + STRLEN(IObuff),\n\t\t       _(\"[CONVERSION ERROR in line %ld]\"), (long)conv_error);\n\t\tc = TRUE;\n\t    }\n\t    else if (illegal_byte > 0)\n\t    {\n\t\tsprintf((char *)IObuff + STRLEN(IObuff),\n\t\t\t _(\"[ILLEGAL BYTE in line %ld]\"), (long)illegal_byte);\n\t\tc = TRUE;\n\t    }\n\t    else\n#endif\n\t\tif (error)\n\t    {\n\t\tSTRCAT(IObuff, _(\"[READ ERRORS]\"));\n\t\tc = TRUE;\n\t    }\n\t    if (msg_add_fileformat(fileformat))\n\t\tc = TRUE;\n#ifdef FEAT_CRYPT\n\t    if (cryptkey != NULL)\n\t\tmsg_add_lines(c, (long)linecnt, filesize\n\t\t\t - crypt_get_header_len(crypt_get_method_nr(curbuf)));\n\t    else\n#endif\n\t\tmsg_add_lines(c, (long)linecnt, filesize);\n\n\t    vim_free(keep_msg);\n\t    keep_msg = NULL;\n\t    msg_scrolled_ign = TRUE;\n#ifdef ALWAYS_USE_GUI\n\t    /* Don't show the message when reading stdin, it would end up in a\n\t     * message box (which might be shown when exiting!) */\n\t    if (read_stdin || read_buffer)\n\t\tp = msg_may_trunc(FALSE, IObuff);\n\t    else\n#endif\n\t\tp = msg_trunc_attr(IObuff, FALSE, 0);\n\t    if (read_stdin || read_buffer || restart_edit != 0\n\t\t    || (msg_scrolled != 0 && !need_wait_return))\n\t\t/* Need to repeat the message after redrawing when:\n\t\t * - When reading from stdin (the screen will be cleared next).\n\t\t * - When restart_edit is set (otherwise there will be a delay\n\t\t *   before redrawing).\n\t\t * - When the screen was scrolled but there is no wait-return\n\t\t *   prompt. */\n\t\tset_keep_msg(p, 0);\n\t    msg_scrolled_ign = FALSE;\n\t}\n\n\t/* with errors writing the file requires \":w!\" */\n\tif (newfile && (error\n#ifdef FEAT_MBYTE\n\t\t    || conv_error != 0\n\t\t    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)\n#endif\n\t\t    ))\n\t    curbuf->b_p_ro = TRUE;\n\n\tu_clearline();\t    /* cannot use \"U\" command after adding lines */\n\n\t/*\n\t * In Ex mode: cursor at last new line.\n\t * Otherwise: cursor at first new line.\n\t */\n\tif (exmode_active)\n\t    curwin->w_cursor.lnum = from + linecnt;\n\telse\n\t    curwin->w_cursor.lnum = from + 1;\n\tcheck_cursor_lnum();\n\tbeginline(BL_WHITE | BL_FIX);\t    /* on first non-blank */\n\n\t/*\n\t * Set '[ and '] marks to the newly read lines.\n\t */\n\tcurbuf->b_op_start.lnum = from + 1;\n\tcurbuf->b_op_start.col = 0;\n\tcurbuf->b_op_end.lnum = from + linecnt;\n\tcurbuf->b_op_end.col = 0;\n\n#ifdef WIN32\n\t/*\n\t * Work around a weird problem: When a file has two links (only\n\t * possible on NTFS) and we write through one link, then stat() it\n\t * through the other link, the timestamp information may be wrong.\n\t * It's correct again after reading the file, thus reset the timestamp\n\t * here.\n\t */\n\tif (newfile && !read_stdin && !read_buffer\n\t\t\t\t\t && mch_stat((char *)fname, &st) >= 0)\n\t{\n\t    buf_store_time(curbuf, &st, fname);\n\t    curbuf->b_mtime_read = curbuf->b_mtime;\n\t}\n#endif\n    }\n    msg_scroll = msg_save;\n\n#ifdef FEAT_VIMINFO\n    /*\n     * Get the marks before executing autocommands, so they can be used there.\n     */\n    check_marks_read();\n#endif\n\n    /*\n     * We remember if the last line of the read didn't have\n     * an eol even when 'binary' is off, to support turning 'fixeol' off,\n     * or writing the read again with 'binary' on.  The latter is required\n     * for \":autocmd FileReadPost *.gz set bin|'[,']!gunzip\" to work.\n     */\n    curbuf->b_no_eol_lnum = read_no_eol_lnum;\n\n    /* When reloading a buffer put the cursor at the first line that is\n     * different. */\n    if (flags & READ_KEEP_UNDO)\n\tu_find_first_changed();\n\n#ifdef FEAT_PERSISTENT_UNDO\n    /*\n     * When opening a new file locate undo info and read it.\n     */\n    if (read_undo_file)\n    {\n\tchar_u\thash[UNDO_HASH_SIZE];\n\n\tsha256_finish(&sha_ctx, hash);\n\tu_read_undo(NULL, hash, fname);\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    if (!read_stdin && !read_fifo && (!read_buffer || sfname != NULL))\n    {\n\tint m = msg_scroll;\n\tint n = msg_scrolled;\n\n\t/* Save the fileformat now, otherwise the buffer will be considered\n\t * modified if the format/encoding was automatically detected. */\n\tif (set_options)\n\t    save_file_ff(curbuf);\n\n\t/*\n\t * The output from the autocommands should not overwrite anything and\n\t * should not be overwritten: Set msg_scroll, restore its value if no\n\t * output was done.\n\t */\n\tmsg_scroll = TRUE;\n\tif (filtering)\n\t    apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (newfile || (read_buffer && sfname != NULL))\n\t{\n\t    apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\t    if (!au_did_filetype && *curbuf->b_p_ft != NUL)\n\t\t/*\n\t\t * EVENT_FILETYPE was not triggered but the buffer already has a\n\t\t * filetype. Trigger EVENT_FILETYPE using the existing filetype.\n\t\t */\n\t\tapply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft, curbuf->b_fname,\n\t\t\tTRUE, curbuf);\n\t}\n\telse\n\t    apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,\n\t\t\t\t\t\t\t    FALSE, NULL, eap);\n\tif (msg_scrolled == n)\n\t    msg_scroll = m;\n# ifdef FEAT_EVAL\n\tif (aborting())\t    /* autocmds may abort script processing */\n\t    return FAIL;\n# endif\n    }\n#endif\n\n    if (recoverymode && error)\n\treturn FAIL;\n    return OK;\n}\n\n#if defined(OPEN_CHR_FILES) || defined(PROTO)\n/*\n * Returns TRUE if the file name argument is of the form \"/dev/fd/\\d\\+\",\n * which is the name of files used for process substitution output by\n * some shells on some operating systems, e.g., bash on SunOS.\n * Do not accept \"/dev/fd/[012]\", opening these may hang Vim.\n */\n    int\nis_dev_fd_file(char_u *fname)\n{\n    return (STRNCMP(fname, \"/dev/fd/\", 8) == 0\n\t    && VIM_ISDIGIT(fname[8])\n\t    && *skipdigits(fname + 9) == NUL\n\t    && (fname[9] != NUL\n\t\t|| (fname[8] != '0' && fname[8] != '1' && fname[8] != '2')));\n}\n#endif\n\n#ifdef FEAT_MBYTE\n\n/*\n * From the current line count and characters read after that, estimate the\n * line number where we are now.\n * Used for error messages that include a line number.\n */\n    static linenr_T\nreadfile_linenr(\n    linenr_T\tlinecnt,\t/* line count before reading more bytes */\n    char_u\t*p,\t\t/* start of more bytes read */\n    char_u\t*endp)\t\t/* end of more bytes read */\n{\n    char_u\t*s;\n    linenr_T\tlnum;\n\n    lnum = curbuf->b_ml.ml_line_count - linecnt + 1;\n    for (s = p; s < endp; ++s)\n\tif (*s == '\\n')\n\t    ++lnum;\n    return lnum;\n}\n#endif\n\n/*\n * Fill \"*eap\" to force the 'fileencoding', 'fileformat' and 'binary to be\n * equal to the buffer \"buf\".  Used for calling readfile().\n * Returns OK or FAIL.\n */\n    int\nprep_exarg(exarg_T *eap, buf_T *buf)\n{\n    eap->cmd = alloc((unsigned)(STRLEN(buf->b_p_ff)\n#ifdef FEAT_MBYTE\n\t\t+ STRLEN(buf->b_p_fenc)\n#endif\n\t\t\t\t\t\t + 15));\n    if (eap->cmd == NULL)\n\treturn FAIL;\n\n#ifdef FEAT_MBYTE\n    sprintf((char *)eap->cmd, \"e ++ff=%s ++enc=%s\", buf->b_p_ff, buf->b_p_fenc);\n    eap->force_enc = 14 + (int)STRLEN(buf->b_p_ff);\n    eap->bad_char = buf->b_bad_char;\n#else\n    sprintf((char *)eap->cmd, \"e ++ff=%s\", buf->b_p_ff);\n#endif\n    eap->force_ff = 7;\n\n    eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;\n    eap->read_edit = FALSE;\n    eap->forceit = FALSE;\n    return OK;\n}\n\n/*\n * Set default or forced 'fileformat' and 'binary'.\n */\n    void\nset_file_options(int set_options, exarg_T *eap)\n{\n    /* set default 'fileformat' */\n    if (set_options)\n    {\n\tif (eap != NULL && eap->force_ff != 0)\n\t    set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);\n\telse if (*p_ffs != NUL)\n\t    set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n\n    /* set or reset 'binary' */\n    if (eap != NULL && eap->force_bin != 0)\n    {\n\tint\toldval = curbuf->b_p_bin;\n\n\tcurbuf->b_p_bin = (eap->force_bin == FORCE_BIN);\n\tset_options_bin(oldval, curbuf->b_p_bin, OPT_LOCAL);\n    }\n}\n\n#if defined(FEAT_MBYTE) || defined(PROTO)\n/*\n * Set forced 'fileencoding'.\n */\n    void\nset_forced_fenc(exarg_T *eap)\n{\n    if (eap->force_enc != 0)\n    {\n\tchar_u *fenc = enc_canonize(eap->cmd + eap->force_enc);\n\n\tif (fenc != NULL)\n\t    set_string_option_direct((char_u *)\"fenc\", -1,\n\t\t\t\t fenc, OPT_FREE|OPT_LOCAL, 0);\n\tvim_free(fenc);\n    }\n}\n\n/*\n * Find next fileencoding to use from 'fileencodings'.\n * \"pp\" points to fenc_next.  It's advanced to the next item.\n * When there are no more items, an empty string is returned and *pp is set to\n * NULL.\n * When *pp is not set to NULL, the result is in allocated memory.\n */\n    static char_u *\nnext_fenc(char_u **pp)\n{\n    char_u\t*p;\n    char_u\t*r;\n\n    if (**pp == NUL)\n    {\n\t*pp = NULL;\n\treturn (char_u *)\"\";\n    }\n    p = vim_strchr(*pp, ',');\n    if (p == NULL)\n    {\n\tr = enc_canonize(*pp);\n\t*pp += STRLEN(*pp);\n    }\n    else\n    {\n\tr = vim_strnsave(*pp, (int)(p - *pp));\n\t*pp = p + 1;\n\tif (r != NULL)\n\t{\n\t    p = enc_canonize(r);\n\t    vim_free(r);\n\t    r = p;\n\t}\n    }\n    if (r == NULL)\t/* out of memory */\n    {\n\tr = (char_u *)\"\";\n\t*pp = NULL;\n    }\n    return r;\n}\n\n# ifdef FEAT_EVAL\n/*\n * Convert a file with the 'charconvert' expression.\n * This closes the file which is to be read, converts it and opens the\n * resulting file for reading.\n * Returns name of the resulting converted file (the caller should delete it\n * after reading it).\n * Returns NULL if the conversion failed (\"*fdp\" is not set) .\n */\n    static char_u *\nreadfile_charconvert(\n    char_u\t*fname,\t\t/* name of input file */\n    char_u\t*fenc,\t\t/* converted from */\n    int\t\t*fdp)\t\t/* in/out: file descriptor of file */\n{\n    char_u\t*tmpname;\n    char_u\t*errmsg = NULL;\n\n    tmpname = vim_tempname('r', FALSE);\n    if (tmpname == NULL)\n\terrmsg = (char_u *)_(\"Can't find temp file for conversion\");\n    else\n    {\n\tclose(*fdp);\t\t/* close the input file, ignore errors */\n\t*fdp = -1;\n\tif (eval_charconvert(fenc, enc_utf8 ? (char_u *)\"utf-8\" : p_enc,\n\t\t\t\t\t\t      fname, tmpname) == FAIL)\n\t    errmsg = (char_u *)_(\"Conversion with 'charconvert' failed\");\n\tif (errmsg == NULL && (*fdp = mch_open((char *)tmpname,\n\t\t\t\t\t\t  O_RDONLY | O_EXTRA, 0)) < 0)\n\t    errmsg = (char_u *)_(\"can't read output of 'charconvert'\");\n    }\n\n    if (errmsg != NULL)\n    {\n\t/* Don't use emsg(), it breaks mappings, the retry with\n\t * another type of conversion might still work. */\n\tMSG(errmsg);\n\tif (tmpname != NULL)\n\t{\n\t    mch_remove(tmpname);\t/* delete converted file */\n\t    vim_free(tmpname);\n\t    tmpname = NULL;\n\t}\n    }\n\n    /* If the input file is closed, open it (caller should check for error). */\n    if (*fdp < 0)\n\t*fdp = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);\n\n    return tmpname;\n}\n# endif\n\n#endif\n\n#ifdef FEAT_VIMINFO\n/*\n * Read marks for the current buffer from the viminfo file, when we support\n * buffer marks and the buffer has a name.\n */\n    static void\ncheck_marks_read(void)\n{\n    if (!curbuf->b_marks_read && get_viminfo_parameter('\\'') > 0\n\t\t\t\t\t\t  && curbuf->b_ffname != NULL)\n\tread_viminfo(NULL, VIF_WANT_MARKS);\n\n    /* Always set b_marks_read; needed when 'viminfo' is changed to include\n     * the ' parameter after opening a buffer. */\n    curbuf->b_marks_read = TRUE;\n}\n#endif\n\n#if defined(FEAT_CRYPT) || defined(PROTO)\n/*\n * Check for magic number used for encryption.  Applies to the current buffer.\n * If found, the magic number is removed from ptr[*sizep] and *sizep and\n * *filesizep are updated.\n * Return the (new) encryption key, NULL for no encryption.\n */\n    static char_u *\ncheck_for_cryptkey(\n    char_u\t*cryptkey,\t/* previous encryption key or NULL */\n    char_u\t*ptr,\t\t/* pointer to read bytes */\n    long\t*sizep,\t\t/* length of read bytes */\n    off_T\t*filesizep,\t/* nr of bytes used from file */\n    int\t\tnewfile,\t/* editing a new buffer */\n    char_u\t*fname,\t\t/* file name to display */\n    int\t\t*did_ask)\t/* flag: whether already asked for key */\n{\n    int method = crypt_method_nr_from_magic((char *)ptr, *sizep);\n    int b_p_ro = curbuf->b_p_ro;\n\n    if (method >= 0)\n    {\n\t/* Mark the buffer as read-only until the decryption has taken place.\n\t * Avoids accidentally overwriting the file with garbage. */\n\tcurbuf->b_p_ro = TRUE;\n\n\t/* Set the cryptmethod local to the buffer. */\n\tcrypt_set_cm_option(curbuf, method);\n\tif (cryptkey == NULL && !*did_ask)\n\t{\n\t    if (*curbuf->b_p_key)\n\t\tcryptkey = curbuf->b_p_key;\n\t    else\n\t    {\n\t\t/* When newfile is TRUE, store the typed key in the 'key'\n\t\t * option and don't free it.  bf needs hash of the key saved.\n\t\t * Don't ask for the key again when first time Enter was hit.\n\t\t * Happens when retrying to detect encoding. */\n\t\tsmsg((char_u *)_(need_key_msg), fname);\n\t\tmsg_scroll = TRUE;\n\t\tcrypt_check_method(method);\n\t\tcryptkey = crypt_get_key(newfile, FALSE);\n\t\t*did_ask = TRUE;\n\n\t\t/* check if empty key entered */\n\t\tif (cryptkey != NULL && *cryptkey == NUL)\n\t\t{\n\t\t    if (cryptkey != curbuf->b_p_key)\n\t\t\tvim_free(cryptkey);\n\t\t    cryptkey = NULL;\n\t\t}\n\t    }\n\t}\n\n\tif (cryptkey != NULL)\n\t{\n\t    int header_len;\n\n\t    curbuf->b_cryptstate = crypt_create_from_header(\n\t\t\t\t\t\t       method, cryptkey, ptr);\n\t    crypt_set_cm_option(curbuf, method);\n\n\t    /* Remove cryptmethod specific header from the text. */\n\t    header_len = crypt_get_header_len(method);\n\t    if (*sizep <= header_len)\n\t\t/* invalid header, buffer can't be encrypted */\n\t\treturn NULL;\n\t    *filesizep += header_len;\n\t    *sizep -= header_len;\n\t    mch_memmove(ptr, ptr + header_len, (size_t)*sizep);\n\n\t    /* Restore the read-only flag. */\n\t    curbuf->b_p_ro = b_p_ro;\n\t}\n    }\n    /* When starting to edit a new file which does not have encryption, clear\n     * the 'key' option, except when starting up (called with -x argument) */\n    else if (newfile && *curbuf->b_p_key != NUL && !starting)\n\tset_option_value((char_u *)\"key\", 0L, (char_u *)\"\", OPT_LOCAL);\n\n    return cryptkey;\n}\n#endif  /* FEAT_CRYPT */\n\n#ifdef UNIX\n    static void\nset_file_time(\n    char_u  *fname,\n    time_t  atime,\t    /* access time */\n    time_t  mtime)\t    /* modification time */\n{\n# if defined(HAVE_UTIME) && defined(HAVE_UTIME_H)\n    struct utimbuf  buf;\n\n    buf.actime\t= atime;\n    buf.modtime\t= mtime;\n    (void)utime((char *)fname, &buf);\n# else\n#  if defined(HAVE_UTIMES)\n    struct timeval  tvp[2];\n\n    tvp[0].tv_sec   = atime;\n    tvp[0].tv_usec  = 0;\n    tvp[1].tv_sec   = mtime;\n    tvp[1].tv_usec  = 0;\n#   ifdef NeXT\n    (void)utimes((char *)fname, tvp);\n#   else\n    (void)utimes((char *)fname, (const struct timeval *)&tvp);\n#   endif\n#  endif\n# endif\n}\n#endif /* UNIX */\n\n#if defined(VMS) && !defined(MIN)\n/* Older DECC compiler for VAX doesn't define MIN() */\n# define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n/*\n * Return TRUE if a file appears to be read-only from the file permissions.\n */\n    int\ncheck_file_readonly(\n    char_u\t*fname,\t\t/* full path to file */\n    int\t\tperm)\t\t/* known permissions on file */\n{\n#ifndef USE_MCH_ACCESS\n    int\t    fd = 0;\n#endif\n\n    return (\n#ifdef USE_MCH_ACCESS\n# ifdef UNIX\n\t(perm & 0222) == 0 ||\n# endif\n\tmch_access((char *)fname, W_OK)\n#else\n\t(fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0\n\t\t\t\t\t? TRUE : (close(fd), FALSE)\n#endif\n\t);\n}\n\n\n/*\n * buf_write() - write to file \"fname\" lines \"start\" through \"end\"\n *\n * We do our own buffering here because fwrite() is so slow.\n *\n * If \"forceit\" is true, we don't care for errors when attempting backups.\n * In case of an error everything possible is done to restore the original\n * file.  But when \"forceit\" is TRUE, we risk losing it.\n *\n * When \"reset_changed\" is TRUE and \"append\" == FALSE and \"start\" == 1 and\n * \"end\" == curbuf->b_ml.ml_line_count, reset curbuf->b_changed.\n *\n * This function must NOT use NameBuff (because it's called by autowrite()).\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nbuf_write(\n    buf_T\t    *buf,\n    char_u\t    *fname,\n    char_u\t    *sfname,\n    linenr_T\t    start,\n    linenr_T\t    end,\n    exarg_T\t    *eap,\t\t/* for forced 'ff' and 'fenc', can be\n\t\t\t\t\t   NULL! */\n    int\t\t    append,\t\t/* append to the file */\n    int\t\t    forceit,\n    int\t\t    reset_changed,\n    int\t\t    filtering)\n{\n    int\t\t    fd;\n    char_u\t    *backup = NULL;\n    int\t\t    backup_copy = FALSE; /* copy the original file? */\n    int\t\t    dobackup;\n    char_u\t    *ffname;\n    char_u\t    *wfname = NULL;\t/* name of file to write to */\n    char_u\t    *s;\n    char_u\t    *ptr;\n    char_u\t    c;\n    int\t\t    len;\n    linenr_T\t    lnum;\n    long\t    nchars;\n    char_u\t    *errmsg = NULL;\n    int\t\t    errmsg_allocated = FALSE;\n    char_u\t    *errnum = NULL;\n    char_u\t    *buffer;\n    char_u\t    smallbuf[SMBUFSIZE];\n    char_u\t    *backup_ext;\n    int\t\t    bufsize;\n    long\t    perm;\t\t    /* file permissions */\n    int\t\t    retval = OK;\n    int\t\t    newfile = FALSE;\t    /* TRUE if file doesn't exist yet */\n    int\t\t    msg_save = msg_scroll;\n    int\t\t    overwriting;\t    /* TRUE if writing over original */\n    int\t\t    no_eol = FALSE;\t    /* no end-of-line written */\n    int\t\t    device = FALSE;\t    /* writing to a device */\n    stat_T\t    st_old;\n    int\t\t    prev_got_int = got_int;\n    int\t\t    checking_conversion;\n    int\t\t    file_readonly = FALSE;  /* overwritten file is read-only */\n    static char\t    *err_readonly = \"is read-only (cannot override: \\\"W\\\" in 'cpoptions')\";\n#if defined(UNIX)\t\t\t    /*XXX fix me sometime? */\n    int\t\t    made_writable = FALSE;  /* 'w' bit has been set */\n#endif\n\t\t\t\t\t/* writing everything */\n    int\t\t    whole = (start == 1 && end == buf->b_ml.ml_line_count);\n#ifdef FEAT_AUTOCMD\n    linenr_T\t    old_line_count = buf->b_ml.ml_line_count;\n#endif\n    int\t\t    attr;\n    int\t\t    fileformat;\n    int\t\t    write_bin;\n    struct bw_info  write_info;\t\t/* info for buf_write_bytes() */\n#ifdef FEAT_MBYTE\n    int\t\t    converted = FALSE;\n    int\t\t    notconverted = FALSE;\n    char_u\t    *fenc;\t\t/* effective 'fileencoding' */\n    char_u\t    *fenc_tofree = NULL; /* allocated \"fenc\" */\n#endif\n#ifdef HAS_BW_FLAGS\n    int\t\t    wb_flags = 0;\n#endif\n#ifdef HAVE_ACL\n    vim_acl_T\t    acl = NULL;\t\t/* ACL copied from original file to\n\t\t\t\t\t   backup or new file */\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n    int\t\t    write_undo_file = FALSE;\n    context_sha256_T sha_ctx;\n#endif\n    unsigned int    bkc = get_bkc_value(buf);\n\n    if (fname == NULL || *fname == NUL)\t/* safety check */\n\treturn FAIL;\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\t/* This can happen during startup when there is a stray \"w\" in the\n\t * vimrc file. */\n\tEMSG(_(e_emptybuf));\n\treturn FAIL;\n    }\n\n    /*\n     * Disallow writing from .exrc and .vimrc in current directory for\n     * security reasons.\n     */\n    if (check_secure())\n\treturn FAIL;\n\n    /* Avoid a crash for a long name. */\n    if (STRLEN(fname) >= MAXPATHL)\n    {\n\tEMSG(_(e_longname));\n\treturn FAIL;\n    }\n\n#ifdef FEAT_MBYTE\n    /* must init bw_conv_buf and bw_iconv_fd before jumping to \"fail\" */\n    write_info.bw_conv_buf = NULL;\n    write_info.bw_conv_error = FALSE;\n    write_info.bw_conv_error_lnum = 0;\n    write_info.bw_restlen = 0;\n# ifdef USE_ICONV\n    write_info.bw_iconv_fd = (iconv_t)-1;\n# endif\n#endif\n#ifdef FEAT_CRYPT\n    write_info.bw_buffer = buf;\n#endif\n\n    /* After writing a file changedtick changes but we don't want to display\n     * the line. */\n    ex_no_reprint = TRUE;\n\n    /*\n     * If there is no file name yet, use the one for the written file.\n     * BF_NOTEDITED is set to reflect this (in case the write fails).\n     * Don't do this when the write is for a filter command.\n     * Don't do this when appending.\n     * Only do this when 'cpoptions' contains the 'F' flag.\n     */\n    if (buf->b_ffname == NULL\n\t    && reset_changed\n\t    && whole\n\t    && buf == curbuf\n#ifdef FEAT_QUICKFIX\n\t    && !bt_nofile(buf)\n#endif\n\t    && !filtering\n\t    && (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)\n\t    && vim_strchr(p_cpo, CPO_FNAMEW) != NULL)\n    {\n\tif (set_rw_fname(fname, sfname) == FAIL)\n\t    return FAIL;\n\tbuf = curbuf;\t    /* just in case autocmds made \"buf\" invalid */\n    }\n\n    if (sfname == NULL)\n\tsfname = fname;\n    /*\n     * For Unix: Use the short file name whenever possible.\n     * Avoids problems with networks and when directory names are changed.\n     * Don't do this for MS-DOS, a \"cd\" in a sub-shell may have moved us to\n     * another directory, which we don't detect\n     */\n    ffname = fname;\t\t\t    /* remember full fname */\n#ifdef UNIX\n    fname = sfname;\n#endif\n\n    if (buf->b_ffname != NULL && fnamecmp(ffname, buf->b_ffname) == 0)\n\toverwriting = TRUE;\n    else\n\toverwriting = FALSE;\n\n    if (exiting)\n\tsettmode(TMODE_COOK);\t    /* when exiting allow typeahead now */\n\n    ++no_wait_return;\t\t    /* don't wait for return yet */\n\n    /*\n     * Set '[ and '] marks to the lines to be written.\n     */\n    buf->b_op_start.lnum = start;\n    buf->b_op_start.col = 0;\n    buf->b_op_end.lnum = end;\n    buf->b_op_end.col = 0;\n\n#ifdef FEAT_AUTOCMD\n    {\n\taco_save_T\taco;\n\tint\t\tbuf_ffname = FALSE;\n\tint\t\tbuf_sfname = FALSE;\n\tint\t\tbuf_fname_f = FALSE;\n\tint\t\tbuf_fname_s = FALSE;\n\tint\t\tdid_cmd = FALSE;\n\tint\t\tnofile_err = FALSE;\n\tint\t\tempty_memline = (buf->b_ml.ml_mfp == NULL);\n\tbufref_T\tbufref;\n\n\t/*\n\t * Apply PRE autocommands.\n\t * Set curbuf to the buffer to be written.\n\t * Careful: The autocommands may call buf_write() recursively!\n\t */\n\tif (ffname == buf->b_ffname)\n\t    buf_ffname = TRUE;\n\tif (sfname == buf->b_sfname)\n\t    buf_sfname = TRUE;\n\tif (fname == buf->b_ffname)\n\t    buf_fname_f = TRUE;\n\tif (fname == buf->b_sfname)\n\t    buf_fname_s = TRUE;\n\n\t/* set curwin/curbuf to buf and save a few things */\n\taucmd_prepbuf(&aco, buf);\n\tset_bufref(&bufref, buf);\n\n\tif (append)\n\t{\n\t    if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,\n\t\t\t\t\t sfname, sfname, FALSE, curbuf, eap)))\n\t    {\n#ifdef FEAT_QUICKFIX\n\t\tif (overwriting && bt_nofile(curbuf))\n\t\t    nofile_err = TRUE;\n\t\telse\n#endif\n\t\t    apply_autocmds_exarg(EVENT_FILEAPPENDPRE,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    }\n\t}\n\telse if (filtering)\n\t{\n\t    apply_autocmds_exarg(EVENT_FILTERWRITEPRE,\n\t\t\t\t\t    NULL, sfname, FALSE, curbuf, eap);\n\t}\n\telse if (reset_changed && whole)\n\t{\n\t    int was_changed = curbufIsChanged();\n\n\t    did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    if (did_cmd)\n\t    {\n\t\tif (was_changed && !curbufIsChanged())\n\t\t{\n\t\t    /* Written everything correctly and BufWriteCmd has reset\n\t\t     * 'modified': Correct the undo information so that an\n\t\t     * undo now sets 'modified'. */\n\t\t    u_unchanged(curbuf);\n\t\t    u_update_save_nr(curbuf);\n\t\t}\n\t    }\n\t    else\n\t    {\n#ifdef FEAT_QUICKFIX\n\t\tif (overwriting && bt_nofile(curbuf))\n\t\t    nofile_err = TRUE;\n\t\telse\n#endif\n\t\t    apply_autocmds_exarg(EVENT_BUFWRITEPRE,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    }\n\t}\n\telse\n\t{\n\t    if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,\n\t\t\t\t\t sfname, sfname, FALSE, curbuf, eap)))\n\t    {\n#ifdef FEAT_QUICKFIX\n\t\tif (overwriting && bt_nofile(curbuf))\n\t\t    nofile_err = TRUE;\n\t\telse\n#endif\n\t\t    apply_autocmds_exarg(EVENT_FILEWRITEPRE,\n\t\t\t\t\t  sfname, sfname, FALSE, curbuf, eap);\n\t    }\n\t}\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\n\t/*\n\t * In three situations we return here and don't write the file:\n\t * 1. the autocommands deleted or unloaded the buffer.\n\t * 2. The autocommands abort script processing.\n\t * 3. If one of the \"Cmd\" autocommands was executed.\n\t */\n\tif (!bufref_valid(&bufref))\n\t    buf = NULL;\n\tif (buf == NULL || (buf->b_ml.ml_mfp == NULL && !empty_memline)\n\t\t\t\t       || did_cmd || nofile_err\n#ifdef FEAT_EVAL\n\t\t\t\t       || aborting()\n#endif\n\t\t\t\t       )\n\t{\n\t    --no_wait_return;\n\t    msg_scroll = msg_save;\n\t    if (nofile_err)\n\t\tEMSG(_(\"E676: No matching autocommands for acwrite buffer\"));\n\n\t    if (nofile_err\n#ifdef FEAT_EVAL\n\t\t    || aborting()\n#endif\n\t\t    )\n\t\t/* An aborting error, interrupt or exception in the\n\t\t * autocommands. */\n\t\treturn FAIL;\n\t    if (did_cmd)\n\t    {\n\t\tif (buf == NULL)\n\t\t    /* The buffer was deleted.  We assume it was written\n\t\t     * (can't retry anyway). */\n\t\t    return OK;\n\t\tif (overwriting)\n\t\t{\n\t\t    /* Assume the buffer was written, update the timestamp. */\n\t\t    ml_timestamp(buf);\n\t\t    if (append)\n\t\t\tbuf->b_flags &= ~BF_NEW;\n\t\t    else\n\t\t\tbuf->b_flags &= ~BF_WRITE_MASK;\n\t\t}\n\t\tif (reset_changed && buf->b_changed && !append\n\t\t\t&& (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL))\n\t\t    /* Buffer still changed, the autocommands didn't work\n\t\t     * properly. */\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n#ifdef FEAT_EVAL\n\t    if (!aborting())\n#endif\n\t\tEMSG(_(\"E203: Autocommands deleted or unloaded buffer to be written\"));\n\t    return FAIL;\n\t}\n\n\t/*\n\t * The autocommands may have changed the number of lines in the file.\n\t * When writing the whole file, adjust the end.\n\t * When writing part of the file, assume that the autocommands only\n\t * changed the number of lines that are to be written (tricky!).\n\t */\n\tif (buf->b_ml.ml_line_count != old_line_count)\n\t{\n\t    if (whole)\t\t\t\t\t\t/* write all */\n\t\tend = buf->b_ml.ml_line_count;\n\t    else if (buf->b_ml.ml_line_count > old_line_count)\t/* more lines */\n\t\tend += buf->b_ml.ml_line_count - old_line_count;\n\t    else\t\t\t\t\t\t/* less lines */\n\t    {\n\t\tend -= old_line_count - buf->b_ml.ml_line_count;\n\t\tif (end < start)\n\t\t{\n\t\t    --no_wait_return;\n\t\t    msg_scroll = msg_save;\n\t\t    EMSG(_(\"E204: Autocommand changed number of lines in unexpected way\"));\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * The autocommands may have changed the name of the buffer, which may\n\t * be kept in fname, ffname and sfname.\n\t */\n\tif (buf_ffname)\n\t    ffname = buf->b_ffname;\n\tif (buf_sfname)\n\t    sfname = buf->b_sfname;\n\tif (buf_fname_f)\n\t    fname = buf->b_ffname;\n\tif (buf_fname_s)\n\t    fname = buf->b_sfname;\n    }\n#endif\n\n#ifdef FEAT_NETBEANS_INTG\n    if (netbeans_active() && isNetbeansBuffer(buf))\n    {\n\tif (whole)\n\t{\n\t    /*\n\t     * b_changed can be 0 after an undo, but we still need to write\n\t     * the buffer to NetBeans.\n\t     */\n\t    if (buf->b_changed || isNetbeansModified(buf))\n\t    {\n\t\t--no_wait_return;\t\t/* may wait for return now */\n\t\tmsg_scroll = msg_save;\n\t\tnetbeans_save_buffer(buf);\t/* no error checking... */\n\t\treturn retval;\n\t    }\n\t    else\n\t    {\n\t\terrnum = (char_u *)\"E656: \";\n\t\terrmsg = (char_u *)_(\"NetBeans disallows writes of unmodified buffers\");\n\t\tbuffer = NULL;\n\t\tgoto fail;\n\t    }\n\t}\n\telse\n\t{\n\t    errnum = (char_u *)\"E657: \";\n\t    errmsg = (char_u *)_(\"Partial writes disallowed for NetBeans buffers\");\n\t    buffer = NULL;\n\t    goto fail;\n\t}\n    }\n#endif\n\n    if (shortmess(SHM_OVER) && !exiting)\n\tmsg_scroll = FALSE;\t    /* overwrite previous file message */\n    else\n\tmsg_scroll = TRUE;\t    /* don't overwrite previous file message */\n    if (!filtering)\n\tfilemess(buf,\n#ifndef UNIX\n\t\tsfname,\n#else\n\t\tfname,\n#endif\n\t\t    (char_u *)\"\", 0);\t/* show that we are busy */\n    msg_scroll = FALSE;\t\t    /* always overwrite the file message now */\n\n    buffer = alloc(BUFSIZE);\n    if (buffer == NULL)\t\t    /* can't allocate big buffer, use small\n\t\t\t\t     * one (to be able to write when out of\n\t\t\t\t     * memory) */\n    {\n\tbuffer = smallbuf;\n\tbufsize = SMBUFSIZE;\n    }\n    else\n\tbufsize = BUFSIZE;\n\n    /*\n     * Get information about original file (if there is one).\n     */\n#if defined(UNIX)\n    st_old.st_dev = 0;\n    st_old.st_ino = 0;\n    perm = -1;\n    if (mch_stat((char *)fname, &st_old) < 0)\n\tnewfile = TRUE;\n    else\n    {\n\tperm = st_old.st_mode;\n\tif (!S_ISREG(st_old.st_mode))\t\t/* not a file */\n\t{\n\t    if (S_ISDIR(st_old.st_mode))\n\t    {\n\t\terrnum = (char_u *)\"E502: \";\n\t\terrmsg = (char_u *)_(\"is a directory\");\n\t\tgoto fail;\n\t    }\n\t    if (mch_nodetype(fname) != NODE_WRITABLE)\n\t    {\n\t\terrnum = (char_u *)\"E503: \";\n\t\terrmsg = (char_u *)_(\"is not a file or writable device\");\n\t\tgoto fail;\n\t    }\n\t    /* It's a device of some kind (or a fifo) which we can write to\n\t     * but for which we can't make a backup. */\n\t    device = TRUE;\n\t    newfile = TRUE;\n\t    perm = -1;\n\t}\n    }\n#else /* !UNIX */\n    /*\n     * Check for a writable device name.\n     */\n    c = mch_nodetype(fname);\n    if (c == NODE_OTHER)\n    {\n\terrnum = (char_u *)\"E503: \";\n\terrmsg = (char_u *)_(\"is not a file or writable device\");\n\tgoto fail;\n    }\n    if (c == NODE_WRITABLE)\n    {\n# if defined(MSWIN)\n\t/* MS-Windows allows opening a device, but we will probably get stuck\n\t * trying to write to it.  */\n\tif (!p_odev)\n\t{\n\t    errnum = (char_u *)\"E796: \";\n\t    errmsg = (char_u *)_(\"writing to device disabled with 'opendevice' option\");\n\t    goto fail;\n\t}\n# endif\n\tdevice = TRUE;\n\tnewfile = TRUE;\n\tperm = -1;\n    }\n    else\n    {\n\tperm = mch_getperm(fname);\n\tif (perm < 0)\n\t    newfile = TRUE;\n\telse if (mch_isdir(fname))\n\t{\n\t    errnum = (char_u *)\"E502: \";\n\t    errmsg = (char_u *)_(\"is a directory\");\n\t    goto fail;\n\t}\n\tif (overwriting)\n\t    (void)mch_stat((char *)fname, &st_old);\n    }\n#endif /* !UNIX */\n\n    if (!device && !newfile)\n    {\n\t/*\n\t * Check if the file is really writable (when renaming the file to\n\t * make a backup we won't discover it later).\n\t */\n\tfile_readonly = check_file_readonly(fname, (int)perm);\n\n\tif (!forceit && file_readonly)\n\t{\n\t    if (vim_strchr(p_cpo, CPO_FWRITE) != NULL)\n\t    {\n\t\terrnum = (char_u *)\"E504: \";\n\t\terrmsg = (char_u *)_(err_readonly);\n\t    }\n\t    else\n\t    {\n\t\terrnum = (char_u *)\"E505: \";\n\t\terrmsg = (char_u *)_(\"is read-only (add ! to override)\");\n\t    }\n\t    goto fail;\n\t}\n\n\t/*\n\t * Check if the timestamp hasn't changed since reading the file.\n\t */\n\tif (overwriting)\n\t{\n\t    retval = check_mtime(buf, &st_old);\n\t    if (retval == FAIL)\n\t\tgoto fail;\n\t}\n    }\n\n#ifdef HAVE_ACL\n    /*\n     * For systems that support ACL: get the ACL from the original file.\n     */\n    if (!newfile)\n\tacl = mch_get_acl(fname);\n#endif\n\n    /*\n     * If 'backupskip' is not empty, don't make a backup for some files.\n     */\n    dobackup = (p_wb || p_bk || *p_pm != NUL);\n#ifdef FEAT_WILDIGN\n    if (dobackup && *p_bsk != NUL && match_file_list(p_bsk, sfname, ffname))\n\tdobackup = FALSE;\n#endif\n\n    /*\n     * Save the value of got_int and reset it.  We don't want a previous\n     * interruption cancel writing, only hitting CTRL-C while writing should\n     * abort it.\n     */\n    prev_got_int = got_int;\n    got_int = FALSE;\n\n    /* Mark the buffer as 'being saved' to prevent changed buffer warnings */\n    buf->b_saving = TRUE;\n\n    /*\n     * If we are not appending or filtering, the file exists, and the\n     * 'writebackup', 'backup' or 'patchmode' option is set, need a backup.\n     * When 'patchmode' is set also make a backup when appending.\n     *\n     * Do not make any backup, if 'writebackup' and 'backup' are both switched\n     * off.  This helps when editing large files on almost-full disks.\n     */\n    if (!(append && *p_pm == NUL) && !filtering && perm >= 0 && dobackup)\n    {\n#if defined(UNIX) || defined(WIN32)\n\tstat_T\t    st;\n#endif\n\n\tif ((bkc & BKC_YES) || append)\t/* \"yes\" */\n\t    backup_copy = TRUE;\n#if defined(UNIX) || defined(WIN32)\n\telse if ((bkc & BKC_AUTO))\t/* \"auto\" */\n\t{\n\t    int\t\ti;\n\n# ifdef UNIX\n\t    /*\n\t     * Don't rename the file when:\n\t     * - it's a hard link\n\t     * - it's a symbolic link\n\t     * - we don't have write permission in the directory\n\t     * - we can't set the owner/group of the new file\n\t     */\n\t    if (st_old.st_nlink > 1\n\t\t    || mch_lstat((char *)fname, &st) < 0\n\t\t    || st.st_dev != st_old.st_dev\n\t\t    || st.st_ino != st_old.st_ino\n#  ifndef HAVE_FCHOWN\n\t\t    || st.st_uid != st_old.st_uid\n\t\t    || st.st_gid != st_old.st_gid\n#  endif\n\t\t    )\n\t\tbackup_copy = TRUE;\n\t    else\n# else\n#  ifdef WIN32\n\t    /* On NTFS file systems hard links are possible. */\n\t    if (mch_is_linked(fname))\n\t\tbackup_copy = TRUE;\n\t    else\n#  endif\n# endif\n\t    {\n\t\t/*\n\t\t * Check if we can create a file and set the owner/group to\n\t\t * the ones from the original file.\n\t\t * First find a file name that doesn't exist yet (use some\n\t\t * arbitrary numbers).\n\t\t */\n\t\tSTRCPY(IObuff, fname);\n\t\tfor (i = 4913; ; i += 123)\n\t\t{\n\t\t    sprintf((char *)gettail(IObuff), \"%d\", i);\n\t\t    if (mch_lstat((char *)IObuff, &st) < 0)\n\t\t\tbreak;\n\t\t}\n\t\tfd = mch_open((char *)IObuff,\n\t\t\t\t    O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, perm);\n\t\tif (fd < 0)\t/* can't write in directory */\n\t\t    backup_copy = TRUE;\n\t\telse\n\t\t{\n# ifdef UNIX\n#  ifdef HAVE_FCHOWN\n\t\t    ignored = fchown(fd, st_old.st_uid, st_old.st_gid);\n#  endif\n\t\t    if (mch_stat((char *)IObuff, &st) < 0\n\t\t\t    || st.st_uid != st_old.st_uid\n\t\t\t    || st.st_gid != st_old.st_gid\n\t\t\t    || (long)st.st_mode != perm)\n\t\t\tbackup_copy = TRUE;\n# endif\n\t\t    /* Close the file before removing it, on MS-Windows we\n\t\t     * can't delete an open file. */\n\t\t    close(fd);\n\t\t    mch_remove(IObuff);\n# ifdef MSWIN\n\t\t    /* MS-Windows may trigger a virus scanner to open the\n\t\t     * file, we can't delete it then.  Keep trying for half a\n\t\t     * second. */\n\t\t    {\n\t\t\tint try;\n\n\t\t\tfor (try = 0; try < 10; ++try)\n\t\t\t{\n\t\t\t    if (mch_lstat((char *)IObuff, &st) < 0)\n\t\t\t\tbreak;\n\t\t\t    ui_delay(50L, TRUE);  /* wait 50 msec */\n\t\t\t    mch_remove(IObuff);\n\t\t\t}\n\t\t    }\n# endif\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * Break symlinks and/or hardlinks if we've been asked to.\n\t */\n\tif ((bkc & BKC_BREAKSYMLINK) || (bkc & BKC_BREAKHARDLINK))\n\t{\n# ifdef UNIX\n\t    int\tlstat_res;\n\n\t    lstat_res = mch_lstat((char *)fname, &st);\n\n\t    /* Symlinks. */\n\t    if ((bkc & BKC_BREAKSYMLINK)\n\t\t    && lstat_res == 0\n\t\t    && st.st_ino != st_old.st_ino)\n\t\tbackup_copy = FALSE;\n\n\t    /* Hardlinks. */\n\t    if ((bkc & BKC_BREAKHARDLINK)\n\t\t    && st_old.st_nlink > 1\n\t\t    && (lstat_res != 0 || st.st_ino == st_old.st_ino))\n\t\tbackup_copy = FALSE;\n# else\n#  if defined(WIN32)\n\t    /* Symlinks. */\n\t    if ((bkc & BKC_BREAKSYMLINK) && mch_is_symbolic_link(fname))\n\t\tbackup_copy = FALSE;\n\n\t    /* Hardlinks. */\n\t    if ((bkc & BKC_BREAKHARDLINK) && mch_is_hard_link(fname))\n\t\tbackup_copy = FALSE;\n#  endif\n# endif\n\t}\n\n#endif\n\n\t/* make sure we have a valid backup extension to use */\n\tif (*p_bex == NUL)\n\t    backup_ext = (char_u *)\".bak\";\n\telse\n\t    backup_ext = p_bex;\n\n\tif (backup_copy\n\t\t&& (fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0)) >= 0)\n\t{\n\t    int\t\tbfd;\n\t    char_u\t*copybuf, *wp;\n\t    int\t\tsome_error = FALSE;\n\t    stat_T\tst_new;\n\t    char_u\t*dirp;\n\t    char_u\t*rootname;\n#if defined(UNIX)\n\t    int\t\tdid_set_shortname;\n#endif\n\n\t    copybuf = alloc(BUFSIZE + 1);\n\t    if (copybuf == NULL)\n\t    {\n\t\tsome_error = TRUE;\t    /* out of memory */\n\t\tgoto nobackup;\n\t    }\n\n\t    /*\n\t     * Try to make the backup in each directory in the 'bdir' option.\n\t     *\n\t     * Unix semantics has it, that we may have a writable file,\n\t     * that cannot be recreated with a simple open(..., O_CREAT, ) e.g:\n\t     *  - the directory is not writable,\n\t     *  - the file may be a symbolic link,\n\t     *  - the file may belong to another user/group, etc.\n\t     *\n\t     * For these reasons, the existing writable file must be truncated\n\t     * and reused. Creation of a backup COPY will be attempted.\n\t     */\n\t    dirp = p_bdir;\n\t    while (*dirp)\n\t    {\n#ifdef UNIX\n\t\tst_new.st_ino = 0;\n\t\tst_new.st_dev = 0;\n\t\tst_new.st_gid = 0;\n#endif\n\n\t\t/*\n\t\t * Isolate one directory name, using an entry in 'bdir'.\n\t\t */\n\t\t(void)copy_option_part(&dirp, copybuf, BUFSIZE, \",\");\n\t\trootname = get_file_in_dir(fname, copybuf);\n\t\tif (rootname == NULL)\n\t\t{\n\t\t    some_error = TRUE;\t    /* out of memory */\n\t\t    goto nobackup;\n\t\t}\n\n#if defined(UNIX)\n\t\tdid_set_shortname = FALSE;\n#endif\n\n\t\t/*\n\t\t * May try twice if 'shortname' not set.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t    /*\n\t\t     * Make backup file name.\n\t\t     */\n\t\t    backup = buf_modname((buf->b_p_sn || buf->b_shortname),\n\t\t\t\t\t\t rootname, backup_ext, FALSE);\n\t\t    if (backup == NULL)\n\t\t    {\n\t\t\tvim_free(rootname);\n\t\t\tsome_error = TRUE;\t\t/* out of memory */\n\t\t\tgoto nobackup;\n\t\t    }\n\n\t\t    /*\n\t\t     * Check if backup file already exists.\n\t\t     */\n\t\t    if (mch_stat((char *)backup, &st_new) >= 0)\n\t\t    {\n#ifdef UNIX\n\t\t\t/*\n\t\t\t * Check if backup file is same as original file.\n\t\t\t * May happen when modname() gave the same file back.\n\t\t\t * E.g. silly link, or file name-length reached.\n\t\t\t * If we don't check here, we either ruin the file\n\t\t\t * when copying or erase it after writing. jw.\n\t\t\t */\n\t\t\tif (st_new.st_dev == st_old.st_dev\n\t\t\t\t\t    && st_new.st_ino == st_old.st_ino)\n\t\t\t{\n\t\t\t    vim_free(backup);\n\t\t\t    backup = NULL;\t/* no backup file to delete */\n\t\t\t    /*\n\t\t\t     * may try again with 'shortname' set\n\t\t\t     */\n\t\t\t    if (!(buf->b_shortname || buf->b_p_sn))\n\t\t\t    {\n\t\t\t\tbuf->b_shortname = TRUE;\n\t\t\t\tdid_set_shortname = TRUE;\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t\t/* setting shortname didn't help */\n\t\t\t    if (did_set_shortname)\n\t\t\t\tbuf->b_shortname = FALSE;\n\t\t\t    break;\n\t\t\t}\n#endif\n\n\t\t\t/*\n\t\t\t * If we are not going to keep the backup file, don't\n\t\t\t * delete an existing one, try to use another name.\n\t\t\t * Change one character, just before the extension.\n\t\t\t */\n\t\t\tif (!p_bk)\n\t\t\t{\n\t\t\t    wp = backup + STRLEN(backup) - 1\n\t\t\t\t\t\t\t - STRLEN(backup_ext);\n\t\t\t    if (wp < backup)\t/* empty file name ??? */\n\t\t\t\twp = backup;\n\t\t\t    *wp = 'z';\n\t\t\t    while (*wp > 'a'\n\t\t\t\t    && mch_stat((char *)backup, &st_new) >= 0)\n\t\t\t\t--*wp;\n\t\t\t    /* They all exist??? Must be something wrong. */\n\t\t\t    if (*wp == 'a')\n\t\t\t    {\n\t\t\t\tvim_free(backup);\n\t\t\t\tbackup = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tvim_free(rootname);\n\n\t\t/*\n\t\t * Try to create the backup file\n\t\t */\n\t\tif (backup != NULL)\n\t\t{\n\t\t    /* remove old backup, if present */\n\t\t    mch_remove(backup);\n\t\t    /* Open with O_EXCL to avoid the file being created while\n\t\t     * we were sleeping (symlink hacker attack?) */\n\t\t    bfd = mch_open((char *)backup,\n\t\t\t\tO_WRONLY|O_CREAT|O_EXTRA|O_EXCL|O_NOFOLLOW,\n\t\t\t\t\t\t\t\t perm & 0777);\n\t\t    if (bfd < 0)\n\t\t    {\n\t\t\tvim_free(backup);\n\t\t\tbackup = NULL;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/* set file protection same as original file, but\n\t\t\t * strip s-bit */\n\t\t\t(void)mch_setperm(backup, perm & 0777);\n\n#ifdef UNIX\n\t\t\t/*\n\t\t\t * Try to set the group of the backup same as the\n\t\t\t * original file. If this fails, set the protection\n\t\t\t * bits for the group same as the protection bits for\n\t\t\t * others.\n\t\t\t */\n\t\t\tif (st_new.st_gid != st_old.st_gid\n# ifdef HAVE_FCHOWN  /* sequent-ptx lacks fchown() */\n\t\t\t\t&& fchown(bfd, (uid_t)-1, st_old.st_gid) != 0\n# endif\n\t\t\t\t\t\t)\n\t\t\t    mch_setperm(backup,\n\t\t\t\t\t  (perm & 0707) | ((perm & 07) << 3));\n# if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n\t\t\tmch_copy_sec(fname, backup);\n# endif\n#endif\n\n\t\t\t/*\n\t\t\t * copy the file.\n\t\t\t */\n\t\t\twrite_info.bw_fd = bfd;\n\t\t\twrite_info.bw_buf = copybuf;\n#ifdef HAS_BW_FLAGS\n\t\t\twrite_info.bw_flags = FIO_NOCONVERT;\n#endif\n\t\t\twhile ((write_info.bw_len = read_eintr(fd, copybuf,\n\t\t\t\t\t\t\t\tBUFSIZE)) > 0)\n\t\t\t{\n\t\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t\t    {\n\t\t\t\terrmsg = (char_u *)_(\"E506: Can't write to backup file (add ! to override)\");\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    ui_breakcheck();\n\t\t\t    if (got_int)\n\t\t\t    {\n\t\t\t\terrmsg = (char_u *)_(e_interr);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (close(bfd) < 0 && errmsg == NULL)\n\t\t\t    errmsg = (char_u *)_(\"E507: Close error for backup file (add ! to override)\");\n\t\t\tif (write_info.bw_len < 0)\n\t\t\t    errmsg = (char_u *)_(\"E508: Can't read file for backup (add ! to override)\");\n#ifdef UNIX\n\t\t\tset_file_time(backup, st_old.st_atime, st_old.st_mtime);\n#endif\n#ifdef HAVE_ACL\n\t\t\tmch_set_acl(backup, acl);\n#endif\n#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n\t\t\tmch_copy_sec(fname, backup);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n    nobackup:\n\t    close(fd);\t\t/* ignore errors for closing read file */\n\t    vim_free(copybuf);\n\n\t    if (backup == NULL && errmsg == NULL)\n\t\terrmsg = (char_u *)_(\"E509: Cannot create backup file (add ! to override)\");\n\t    /* ignore errors when forceit is TRUE */\n\t    if ((some_error || errmsg != NULL) && !forceit)\n\t    {\n\t\tretval = FAIL;\n\t\tgoto fail;\n\t    }\n\t    errmsg = NULL;\n\t}\n\telse\n\t{\n\t    char_u\t*dirp;\n\t    char_u\t*p;\n\t    char_u\t*rootname;\n\n\t    /*\n\t     * Make a backup by renaming the original file.\n\t     */\n\t    /*\n\t     * If 'cpoptions' includes the \"W\" flag, we don't want to\n\t     * overwrite a read-only file.  But rename may be possible\n\t     * anyway, thus we need an extra check here.\n\t     */\n\t    if (file_readonly && vim_strchr(p_cpo, CPO_FWRITE) != NULL)\n\t    {\n\t\terrnum = (char_u *)\"E504: \";\n\t\terrmsg = (char_u *)_(err_readonly);\n\t\tgoto fail;\n\t    }\n\n\t    /*\n\t     *\n\t     * Form the backup file name - change path/fo.o.h to\n\t     * path/fo.o.h.bak Try all directories in 'backupdir', first one\n\t     * that works is used.\n\t     */\n\t    dirp = p_bdir;\n\t    while (*dirp)\n\t    {\n\t\t/*\n\t\t * Isolate one directory name and make the backup file name.\n\t\t */\n\t\t(void)copy_option_part(&dirp, IObuff, IOSIZE, \",\");\n\t\trootname = get_file_in_dir(fname, IObuff);\n\t\tif (rootname == NULL)\n\t\t    backup = NULL;\n\t\telse\n\t\t{\n\t\t    backup = buf_modname((buf->b_p_sn || buf->b_shortname),\n\t\t\t\t\t\t rootname, backup_ext, FALSE);\n\t\t    vim_free(rootname);\n\t\t}\n\n\t\tif (backup != NULL)\n\t\t{\n\t\t    /*\n\t\t     * If we are not going to keep the backup file, don't\n\t\t     * delete an existing one, try to use another name.\n\t\t     * Change one character, just before the extension.\n\t\t     */\n\t\t    if (!p_bk && mch_getperm(backup) >= 0)\n\t\t    {\n\t\t\tp = backup + STRLEN(backup) - 1 - STRLEN(backup_ext);\n\t\t\tif (p < backup)\t/* empty file name ??? */\n\t\t\t    p = backup;\n\t\t\t*p = 'z';\n\t\t\twhile (*p > 'a' && mch_getperm(backup) >= 0)\n\t\t\t    --*p;\n\t\t\t/* They all exist??? Must be something wrong! */\n\t\t\tif (*p == 'a')\n\t\t\t{\n\t\t\t    vim_free(backup);\n\t\t\t    backup = NULL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (backup != NULL)\n\t\t{\n\t\t    /*\n\t\t     * Delete any existing backup and move the current version\n\t\t     * to the backup.\tFor safety, we don't remove the backup\n\t\t     * until the write has finished successfully. And if the\n\t\t     * 'backup' option is set, leave it around.\n\t\t     */\n\t\t    /*\n\t\t     * If the renaming of the original file to the backup file\n\t\t     * works, quit here.\n\t\t     */\n\t\t    if (vim_rename(fname, backup) == 0)\n\t\t\tbreak;\n\n\t\t    vim_free(backup);   /* don't do the rename below */\n\t\t    backup = NULL;\n\t\t}\n\t    }\n\t    if (backup == NULL && !forceit)\n\t    {\n\t\terrmsg = (char_u *)_(\"E510: Can't make backup file (add ! to override)\");\n\t\tgoto fail;\n\t    }\n\t}\n    }\n\n#if defined(UNIX)\n    /* When using \":w!\" and the file was read-only: make it writable */\n    if (forceit && perm >= 0 && !(perm & 0200) && st_old.st_uid == getuid()\n\t\t\t\t     && vim_strchr(p_cpo, CPO_FWRITE) == NULL)\n    {\n\tperm |= 0200;\n\t(void)mch_setperm(fname, perm);\n\tmade_writable = TRUE;\n    }\n#endif\n\n    /* When using \":w!\" and writing to the current file, 'readonly' makes no\n     * sense, reset it, unless 'Z' appears in 'cpoptions'.  */\n    if (forceit && overwriting && vim_strchr(p_cpo, CPO_KEEPRO) == NULL)\n    {\n\tbuf->b_p_ro = FALSE;\n#ifdef FEAT_TITLE\n\tneed_maketitle = TRUE;\t    /* set window title later */\n#endif\n\tstatus_redraw_all();\t    /* redraw status lines later */\n    }\n\n    if (end > buf->b_ml.ml_line_count)\n\tend = buf->b_ml.ml_line_count;\n    if (buf->b_ml.ml_flags & ML_EMPTY)\n\tstart = end + 1;\n\n    /*\n     * If the original file is being overwritten, there is a small chance that\n     * we crash in the middle of writing. Therefore the file is preserved now.\n     * This makes all block numbers positive so that recovery does not need\n     * the original file.\n     * Don't do this if there is a backup file and we are exiting.\n     */\n    if (reset_changed && !newfile && overwriting\n\t\t\t\t\t      && !(exiting && backup != NULL))\n    {\n\tml_preserve(buf, FALSE);\n\tif (got_int)\n\t{\n\t    errmsg = (char_u *)_(e_interr);\n\t    goto restore_backup;\n\t}\n    }\n\n#ifdef VMS\n    vms_remove_version(fname); /* remove version */\n#endif\n    /* Default: write the file directly.  May write to a temp file for\n     * multi-byte conversion. */\n    wfname = fname;\n\n#ifdef FEAT_MBYTE\n    /* Check for forced 'fileencoding' from \"++opt=val\" argument. */\n    if (eap != NULL && eap->force_enc != 0)\n    {\n\tfenc = eap->cmd + eap->force_enc;\n\tfenc = enc_canonize(fenc);\n\tfenc_tofree = fenc;\n    }\n    else\n\tfenc = buf->b_p_fenc;\n\n    /*\n     * Check if the file needs to be converted.\n     */\n    converted = need_conversion(fenc);\n\n    /*\n     * Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or\n     * Latin1 to Unicode conversion.  This is handled in buf_write_bytes().\n     * Prepare the flags for it and allocate bw_conv_buf when needed.\n     */\n    if (converted && (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0))\n    {\n\twb_flags = get_fio_flags(fenc);\n\tif (wb_flags & (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8))\n\t{\n\t    /* Need to allocate a buffer to translate into. */\n\t    if (wb_flags & (FIO_UCS2 | FIO_UTF16 | FIO_UTF8))\n\t\twrite_info.bw_conv_buflen = bufsize * 2;\n\t    else /* FIO_UCS4 */\n\t\twrite_info.bw_conv_buflen = bufsize * 4;\n\t    write_info.bw_conv_buf\n\t\t\t   = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\t    if (write_info.bw_conv_buf == NULL)\n\t\tend = 0;\n\t}\n    }\n\n# ifdef WIN3264\n    if (converted && wb_flags == 0 && (wb_flags = get_win_fio_flags(fenc)) != 0)\n    {\n\t/* Convert UTF-8 -> UCS-2 and UCS-2 -> DBCS.  Worst-case * 4: */\n\twrite_info.bw_conv_buflen = bufsize * 4;\n\twrite_info.bw_conv_buf\n\t\t\t    = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\tif (write_info.bw_conv_buf == NULL)\n\t    end = 0;\n    }\n# endif\n\n# ifdef MACOS_CONVERT\n    if (converted && wb_flags == 0 && (wb_flags = get_mac_fio_flags(fenc)) != 0)\n    {\n\twrite_info.bw_conv_buflen = bufsize * 3;\n\twrite_info.bw_conv_buf\n\t\t\t    = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\tif (write_info.bw_conv_buf == NULL)\n\t    end = 0;\n    }\n# endif\n\n# if defined(FEAT_EVAL) || defined(USE_ICONV)\n    if (converted && wb_flags == 0)\n    {\n#  ifdef USE_ICONV\n\t/*\n\t * Use iconv() conversion when conversion is needed and it's not done\n\t * internally.\n\t */\n\twrite_info.bw_iconv_fd = (iconv_t)my_iconv_open(fenc,\n\t\t\t\t\tenc_utf8 ? (char_u *)\"utf-8\" : p_enc);\n\tif (write_info.bw_iconv_fd != (iconv_t)-1)\n\t{\n\t    /* We're going to use iconv(), allocate a buffer to convert in. */\n\t    write_info.bw_conv_buflen = bufsize * ICONV_MULT;\n\t    write_info.bw_conv_buf\n\t\t\t   = lalloc((long_u)write_info.bw_conv_buflen, TRUE);\n\t    if (write_info.bw_conv_buf == NULL)\n\t\tend = 0;\n\t    write_info.bw_first = TRUE;\n\t}\n#   ifdef FEAT_EVAL\n\telse\n#   endif\n#  endif\n\n#  ifdef FEAT_EVAL\n\t    /*\n\t     * When the file needs to be converted with 'charconvert' after\n\t     * writing, write to a temp file instead and let the conversion\n\t     * overwrite the original file.\n\t     */\n\t    if (*p_ccv != NUL)\n\t    {\n\t\twfname = vim_tempname('w', FALSE);\n\t\tif (wfname == NULL)\t/* Can't write without a tempfile! */\n\t\t{\n\t\t    errmsg = (char_u *)_(\"E214: Can't find temp file for writing\");\n\t\t    goto restore_backup;\n\t\t}\n\t    }\n#  endif\n    }\n# endif\n    if (converted && wb_flags == 0\n#  ifdef USE_ICONV\n\t    && write_info.bw_iconv_fd == (iconv_t)-1\n#  endif\n#  ifdef FEAT_EVAL\n\t    && wfname == fname\n#  endif\n\t    )\n    {\n\tif (!forceit)\n\t{\n\t    errmsg = (char_u *)_(\"E213: Cannot convert (add ! to write without conversion)\");\n\t    goto restore_backup;\n\t}\n\tnotconverted = TRUE;\n    }\n#endif\n\n    /*\n     * If conversion is taking place, we may first pretend to write and check\n     * for conversion errors.  Then loop again to write for real.\n     * When not doing conversion this writes for real right away.\n     */\n    for (checking_conversion = TRUE; ; checking_conversion = FALSE)\n    {\n\t/*\n\t * There is no need to check conversion when:\n\t * - there is no conversion\n\t * - we make a backup file, that can be restored in case of conversion\n\t *   failure.\n\t */\n#ifdef FEAT_MBYTE\n\tif (!converted || dobackup)\n#endif\n\t    checking_conversion = FALSE;\n\n\tif (checking_conversion)\n\t{\n\t    /* Make sure we don't write anything. */\n\t    fd = -1;\n\t    write_info.bw_fd = fd;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Open the file \"wfname\" for writing.\n\t     * We may try to open the file twice: If we can't write to the file\n\t     * and forceit is TRUE we delete the existing file and try to\n\t     * create a new one. If this still fails we may have lost the\n\t     * original file!  (this may happen when the user reached his\n\t     * quotum for number of files).\n\t     * Appending will fail if the file does not exist and forceit is\n\t     * FALSE.\n\t     */\n\t    while ((fd = mch_open((char *)wfname, O_WRONLY | O_EXTRA | (append\n\t\t\t\t? (forceit ? (O_APPEND | O_CREAT) : O_APPEND)\n\t\t\t\t: (O_CREAT | O_TRUNC))\n\t\t\t\t, perm < 0 ? 0666 : (perm & 0777))) < 0)\n\t    {\n\t\t/*\n\t\t * A forced write will try to create a new file if the old one\n\t\t * is still readonly. This may also happen when the directory\n\t\t * is read-only. In that case the mch_remove() will fail.\n\t\t */\n\t\tif (errmsg == NULL)\n\t\t{\n#ifdef UNIX\n\t\t    stat_T\tst;\n\n\t\t    /* Don't delete the file when it's a hard or symbolic link.\n\t\t     */\n\t\t    if ((!newfile && st_old.st_nlink > 1)\n\t\t\t    || (mch_lstat((char *)fname, &st) == 0\n\t\t\t\t&& (st.st_dev != st_old.st_dev\n\t\t\t\t    || st.st_ino != st_old.st_ino)))\n\t\t\terrmsg = (char_u *)_(\"E166: Can't open linked file for writing\");\n\t\t    else\n#endif\n\t\t    {\n\t\t\terrmsg = (char_u *)_(\"E212: Can't open file for writing\");\n\t\t\tif (forceit && vim_strchr(p_cpo, CPO_FWRITE) == NULL\n\t\t\t\t\t\t\t\t  && perm >= 0)\n\t\t\t{\n#ifdef UNIX\n\t\t\t    /* we write to the file, thus it should be marked\n\t\t\t       writable after all */\n\t\t\t    if (!(perm & 0200))\n\t\t\t\tmade_writable = TRUE;\n\t\t\t    perm |= 0200;\n\t\t\t    if (st_old.st_uid != getuid()\n\t\t\t\t\t\t  || st_old.st_gid != getgid())\n\t\t\t\tperm &= 0777;\n#endif\n\t\t\t    if (!append)  /* don't remove when appending */\n\t\t\t\tmch_remove(wfname);\n\t\t\t    continue;\n\t\t\t}\n\t\t    }\n\t\t}\n\nrestore_backup:\n\t\t{\n\t\t    stat_T\tst;\n\n\t\t    /*\n\t\t     * If we failed to open the file, we don't need a backup.\n\t\t     * Throw it away.  If we moved or removed the original file\n\t\t     * try to put the backup in its place.\n\t\t     */\n\t\t    if (backup != NULL && wfname == fname)\n\t\t    {\n\t\t\tif (backup_copy)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * There is a small chance that we removed the\n\t\t\t     * original, try to move the copy in its place.\n\t\t\t     * This may not work if the vim_rename() fails.\n\t\t\t     * In that case we leave the copy around.\n\t\t\t     */\n\t\t\t    /* If file does not exist, put the copy in its\n\t\t\t     * place */\n\t\t\t    if (mch_stat((char *)fname, &st) < 0)\n\t\t\t\tvim_rename(backup, fname);\n\t\t\t    /* if original file does exist throw away the copy\n\t\t\t     */\n\t\t\t    if (mch_stat((char *)fname, &st) >= 0)\n\t\t\t\tmch_remove(backup);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    /* try to put the original file back */\n\t\t\t    vim_rename(backup, fname);\n\t\t\t}\n\t\t    }\n\n\t\t    /* if original file no longer exists give an extra warning\n\t\t     */\n\t\t    if (!newfile && mch_stat((char *)fname, &st) < 0)\n\t\t\tend = 0;\n\t\t}\n\n#ifdef FEAT_MBYTE\n\t\tif (wfname != fname)\n\t\t    vim_free(wfname);\n#endif\n\t\tgoto fail;\n\t    }\n\t    write_info.bw_fd = fd;\n\n#if defined(WIN3264)\n\t    if (backup != NULL && overwriting && !append)\n\t    {\n\t\tif (backup_copy)\n\t\t    (void)mch_copy_file_attribute(wfname, backup);\n\t\telse\n\t\t    (void)mch_copy_file_attribute(backup, wfname);\n\t    }\n\n\t    if (!overwriting && !append)\n\t    {\n\t\tif (buf->b_ffname != NULL)\n\t\t    (void)mch_copy_file_attribute(buf->b_ffname, wfname);\n\t\t/* Should copy resource fork */\n\t    }\n#endif\n\n#ifdef FEAT_CRYPT\n\t    if (*buf->b_p_key != NUL && !filtering)\n\t    {\n\t\tchar_u\t\t*header;\n\t\tint\t\theader_len;\n\n\t\tbuf->b_cryptstate = crypt_create_for_writing(\n\t\t\t\t\t\t      crypt_get_method_nr(buf),\n\t\t\t\t\t   buf->b_p_key, &header, &header_len);\n\t\tif (buf->b_cryptstate == NULL || header == NULL)\n\t\t    end = 0;\n\t\telse\n\t\t{\n\t\t    /* Write magic number, so that Vim knows how this file is\n\t\t     * encrypted when reading it back. */\n\t\t    write_info.bw_buf = header;\n\t\t    write_info.bw_len = header_len;\n\t\t    write_info.bw_flags = FIO_NOCONVERT;\n\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t\tend = 0;\n\t\t    wb_flags |= FIO_ENCRYPTED;\n\t\t    vim_free(header);\n\t\t}\n\t    }\n#endif\n\t}\n\terrmsg = NULL;\n\n\twrite_info.bw_buf = buffer;\n\tnchars = 0;\n\n\t/* use \"++bin\", \"++nobin\" or 'binary' */\n\tif (eap != NULL && eap->force_bin != 0)\n\t    write_bin = (eap->force_bin == FORCE_BIN);\n\telse\n\t    write_bin = buf->b_p_bin;\n\n#ifdef FEAT_MBYTE\n\t/*\n\t * The BOM is written just after the encryption magic number.\n\t * Skip it when appending and the file already existed, the BOM only\n\t * makes sense at the start of the file.\n\t */\n\tif (buf->b_p_bomb && !write_bin && (!append || perm < 0))\n\t{\n\t    write_info.bw_len = make_bom(buffer, fenc);\n\t    if (write_info.bw_len > 0)\n\t    {\n\t\t/* don't convert, do encryption */\n\t\twrite_info.bw_flags = FIO_NOCONVERT | wb_flags;\n\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t    end = 0;\n\t\telse\n\t\t    nchars += write_info.bw_len;\n\t    }\n\t}\n\twrite_info.bw_start_lnum = start;\n#endif\n\n#ifdef FEAT_PERSISTENT_UNDO\n\twrite_undo_file = (buf->b_p_udf\n\t\t\t    && overwriting\n\t\t\t    && !append\n\t\t\t    && !filtering\n\t\t\t    && reset_changed\n\t\t\t    && !checking_conversion);\n\tif (write_undo_file)\n\t    /* Prepare for computing the hash value of the text. */\n\t    sha256_start(&sha_ctx);\n#endif\n\n\twrite_info.bw_len = bufsize;\n#ifdef HAS_BW_FLAGS\n\twrite_info.bw_flags = wb_flags;\n#endif\n\tfileformat = get_fileformat_force(buf, eap);\n\ts = buffer;\n\tlen = 0;\n\tfor (lnum = start; lnum <= end; ++lnum)\n\t{\n\t    /*\n\t     * The next while loop is done once for each character written.\n\t     * Keep it fast!\n\t     */\n\t    ptr = ml_get_buf(buf, lnum, FALSE) - 1;\n#ifdef FEAT_PERSISTENT_UNDO\n\t    if (write_undo_file)\n\t\tsha256_update(&sha_ctx, ptr + 1,\n\t\t\t\t\t      (UINT32_T)(STRLEN(ptr + 1) + 1));\n#endif\n\t    while ((c = *++ptr) != NUL)\n\t    {\n\t\tif (c == NL)\n\t\t    *s = NUL;\t\t/* replace newlines with NULs */\n\t\telse if (c == CAR && fileformat == EOL_MAC)\n\t\t    *s = NL;\t\t/* Mac: replace CRs with NLs */\n\t\telse\n\t\t    *s = c;\n\t\t++s;\n\t\tif (++len != bufsize)\n\t\t    continue;\n\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t{\n\t\t    end = 0;\t\t/* write error: break loop */\n\t\t    break;\n\t\t}\n\t\tnchars += bufsize;\n\t\ts = buffer;\n\t\tlen = 0;\n#ifdef FEAT_MBYTE\n\t\twrite_info.bw_start_lnum = lnum;\n#endif\n\t    }\n\t    /* write failed or last line has no EOL: stop here */\n\t    if (end == 0\n\t\t    || (lnum == end\n\t\t\t&& (write_bin || !buf->b_p_fixeol)\n\t\t\t&& (lnum == buf->b_no_eol_lnum\n\t\t\t    || (lnum == buf->b_ml.ml_line_count\n\t\t\t\t\t\t\t   && !buf->b_p_eol))))\n\t    {\n\t\t++lnum;\t\t\t/* written the line, count it */\n\t\tno_eol = TRUE;\n\t\tbreak;\n\t    }\n\t    if (fileformat == EOL_UNIX)\n\t\t*s++ = NL;\n\t    else\n\t    {\n\t\t*s++ = CAR;\t\t    /* EOL_MAC or EOL_DOS: write CR */\n\t\tif (fileformat == EOL_DOS)  /* write CR-NL */\n\t\t{\n\t\t    if (++len == bufsize)\n\t\t    {\n\t\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t\t{\n\t\t\t    end = 0;\t/* write error: break loop */\n\t\t\t    break;\n\t\t\t}\n\t\t\tnchars += bufsize;\n\t\t\ts = buffer;\n\t\t\tlen = 0;\n\t\t    }\n\t\t    *s++ = NL;\n\t\t}\n\t    }\n\t    if (++len == bufsize && end)\n\t    {\n\t\tif (buf_write_bytes(&write_info) == FAIL)\n\t\t{\n\t\t    end = 0;\t\t/* write error: break loop */\n\t\t    break;\n\t\t}\n\t\tnchars += bufsize;\n\t\ts = buffer;\n\t\tlen = 0;\n\n\t\tui_breakcheck();\n\t\tif (got_int)\n\t\t{\n\t\t    end = 0;\t\t/* Interrupted, break loop */\n\t\t    break;\n\t\t}\n\t    }\n#ifdef VMS\n\t    /*\n\t     * On VMS there is a problem: newlines get added when writing\n\t     * blocks at a time. Fix it by writing a line at a time.\n\t     * This is much slower!\n\t     * Explanation: VAX/DECC RTL insists that records in some RMS\n\t     * structures end with a newline (carriage return) character, and\n\t     * if they don't it adds one.\n\t     * With other RMS structures it works perfect without this fix.\n\t     */\n\t    if (buf->b_fab_rfm == FAB$C_VFC\n\t\t    || ((buf->b_fab_rat & (FAB$M_FTN | FAB$M_CR)) != 0))\n\t    {\n\t\tint b2write;\n\n\t\tbuf->b_fab_mrs = (buf->b_fab_mrs == 0\n\t\t\t? MIN(4096, bufsize)\n\t\t\t: MIN(buf->b_fab_mrs, bufsize));\n\n\t\tb2write = len;\n\t\twhile (b2write > 0)\n\t\t{\n\t\t    write_info.bw_len = MIN(b2write, buf->b_fab_mrs);\n\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t    {\n\t\t\tend = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    b2write -= MIN(b2write, buf->b_fab_mrs);\n\t\t}\n\t\twrite_info.bw_len = bufsize;\n\t\tnchars += len;\n\t\ts = buffer;\n\t\tlen = 0;\n\t    }\n#endif\n\t}\n\tif (len > 0 && end > 0)\n\t{\n\t    write_info.bw_len = len;\n\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\tend = 0;\t\t    /* write error */\n\t    nchars += len;\n\t}\n\n\t/* Stop when writing done or an error was encountered. */\n\tif (!checking_conversion || end == 0)\n\t    break;\n\n\t/* If no error happened until now, writing should be ok, so loop to\n\t * really write the buffer. */\n    }\n\n    /* If we started writing, finish writing. Also when an error was\n     * encountered. */\n    if (!checking_conversion)\n    {\n#if defined(UNIX) && defined(HAVE_FSYNC)\n\t/*\n\t * On many journalling file systems there is a bug that causes both the\n\t * original and the backup file to be lost when halting the system\n\t * right after writing the file.  That's because only the meta-data is\n\t * journalled.  Syncing the file slows down the system, but assures it\n\t * has been written to disk and we don't lose it.\n\t * For a device do try the fsync() but don't complain if it does not\n\t * work (could be a pipe).\n\t * If the 'fsync' option is FALSE, don't fsync().  Useful for laptops.\n\t */\n\tif (p_fs && fsync(fd) != 0 && !device)\n\t{\n\t    errmsg = (char_u *)_(\"E667: Fsync failed\");\n\t    end = 0;\n\t}\n#endif\n\n#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n\t/* Probably need to set the security context. */\n\tif (!backup_copy)\n\t    mch_copy_sec(backup, wfname);\n#endif\n\n#ifdef UNIX\n\t/* When creating a new file, set its owner/group to that of the\n\t * original file.  Get the new device and inode number. */\n\tif (backup != NULL && !backup_copy)\n\t{\n# ifdef HAVE_FCHOWN\n\t    stat_T\tst;\n\n\t    /* don't change the owner when it's already OK, some systems remove\n\t     * permission or ACL stuff */\n\t    if (mch_stat((char *)wfname, &st) < 0\n\t\t    || st.st_uid != st_old.st_uid\n\t\t    || st.st_gid != st_old.st_gid)\n\t    {\n\t\tignored = fchown(fd, st_old.st_uid, st_old.st_gid);\n\t\tif (perm >= 0)\t/* set permission again, may have changed */\n\t\t    (void)mch_setperm(wfname, perm);\n\t    }\n# endif\n\t    buf_setino(buf);\n\t}\n\telse if (!buf->b_dev_valid)\n\t    /* Set the inode when creating a new file. */\n\t    buf_setino(buf);\n#endif\n\n\tif (close(fd) != 0)\n\t{\n\t    errmsg = (char_u *)_(\"E512: Close failed\");\n\t    end = 0;\n\t}\n\n#ifdef UNIX\n\tif (made_writable)\n\t    perm &= ~0200;\t/* reset 'w' bit for security reasons */\n#endif\n\tif (perm >= 0)\t\t/* set perm. of new file same as old file */\n\t    (void)mch_setperm(wfname, perm);\n#ifdef HAVE_ACL\n\t/*\n\t * Probably need to set the ACL before changing the user (can't set the\n\t * ACL on a file the user doesn't own).\n\t * On Solaris, with ZFS and the aclmode property set to \"discard\" (the\n\t * default), chmod() discards all part of a file's ACL that don't\n\t * represent the mode of the file.  It's non-trivial for us to discover\n\t * whether we're in that situation, so we simply always re-set the ACL.\n\t */\n# ifndef HAVE_SOLARIS_ZFS_ACL\n\tif (!backup_copy)\n# endif\n\t    mch_set_acl(wfname, acl);\n#endif\n#ifdef FEAT_CRYPT\n\tif (buf->b_cryptstate != NULL)\n\t{\n\t    crypt_free_state(buf->b_cryptstate);\n\t    buf->b_cryptstate = NULL;\n\t}\n#endif\n\n#if defined(FEAT_MBYTE) && defined(FEAT_EVAL)\n\tif (wfname != fname)\n\t{\n\t    /*\n\t     * The file was written to a temp file, now it needs to be\n\t     * converted with 'charconvert' to (overwrite) the output file.\n\t     */\n\t    if (end != 0)\n\t    {\n\t\tif (eval_charconvert(enc_utf8 ? (char_u *)\"utf-8\" : p_enc,\n\t\t\t\t\t\t  fenc, wfname, fname) == FAIL)\n\t\t{\n\t\t    write_info.bw_conv_error = TRUE;\n\t\t    end = 0;\n\t\t}\n\t    }\n\t    mch_remove(wfname);\n\t    vim_free(wfname);\n\t}\n#endif\n    }\n\n    if (end == 0)\n    {\n\t/*\n\t * Error encountered.\n\t */\n\tif (errmsg == NULL)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (write_info.bw_conv_error)\n\t    {\n\t\tif (write_info.bw_conv_error_lnum == 0)\n\t\t    errmsg = (char_u *)_(\"E513: write error, conversion failed (make 'fenc' empty to override)\");\n\t\telse\n\t\t{\n\t\t    errmsg_allocated = TRUE;\n\t\t    errmsg = alloc(300);\n\t\t    vim_snprintf((char *)errmsg, 300, _(\"E513: write error, conversion failed in line %ld (make 'fenc' empty to override)\"),\n\t\t\t\t\t (long)write_info.bw_conv_error_lnum);\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tif (got_int)\n\t\t    errmsg = (char_u *)_(e_interr);\n\t\telse\n\t\t    errmsg = (char_u *)_(\"E514: write error (file system full?)\");\n\t}\n\n\t/*\n\t * If we have a backup file, try to put it in place of the new file,\n\t * because the new file is probably corrupt.  This avoids losing the\n\t * original file when trying to make a backup when writing the file a\n\t * second time.\n\t * When \"backup_copy\" is set we need to copy the backup over the new\n\t * file.  Otherwise rename the backup file.\n\t * If this is OK, don't give the extra warning message.\n\t */\n\tif (backup != NULL)\n\t{\n\t    if (backup_copy)\n\t    {\n\t\t/* This may take a while, if we were interrupted let the user\n\t\t * know we got the message. */\n\t\tif (got_int)\n\t\t{\n\t\t    MSG(_(e_interr));\n\t\t    out_flush();\n\t\t}\n\t\tif ((fd = mch_open((char *)backup, O_RDONLY | O_EXTRA, 0)) >= 0)\n\t\t{\n\t\t    if ((write_info.bw_fd = mch_open((char *)fname,\n\t\t\t\t    O_WRONLY | O_CREAT | O_TRUNC | O_EXTRA,\n\t\t\t\t\t\t\t   perm & 0777)) >= 0)\n\t\t    {\n\t\t\t/* copy the file. */\n\t\t\twrite_info.bw_buf = smallbuf;\n#ifdef HAS_BW_FLAGS\n\t\t\twrite_info.bw_flags = FIO_NOCONVERT;\n#endif\n\t\t\twhile ((write_info.bw_len = read_eintr(fd, smallbuf,\n\t\t\t\t\t\t      SMBUFSIZE)) > 0)\n\t\t\t    if (buf_write_bytes(&write_info) == FAIL)\n\t\t\t\tbreak;\n\n\t\t\tif (close(write_info.bw_fd) >= 0\n\t\t\t\t\t\t   && write_info.bw_len == 0)\n\t\t\t    end = 1;\t\t/* success */\n\t\t    }\n\t\t    close(fd);\t/* ignore errors for closing read file */\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (vim_rename(backup, fname) == 0)\n\t\t    end = 1;\n\t    }\n\t}\n\tgoto fail;\n    }\n\n    lnum -= start;\t    /* compute number of written lines */\n    --no_wait_return;\t    /* may wait for return now */\n\n#if !(defined(UNIX) || defined(VMS))\n    fname = sfname;\t    /* use shortname now, for the messages */\n#endif\n    if (!filtering)\n    {\n\tmsg_add_fname(buf, fname);\t/* put fname in IObuff with quotes */\n\tc = FALSE;\n#ifdef FEAT_MBYTE\n\tif (write_info.bw_conv_error)\n\t{\n\t    STRCAT(IObuff, _(\" CONVERSION ERROR\"));\n\t    c = TRUE;\n\t    if (write_info.bw_conv_error_lnum != 0)\n\t\tvim_snprintf_add((char *)IObuff, IOSIZE, _(\" in line %ld;\"),\n\t\t\t(long)write_info.bw_conv_error_lnum);\n\t}\n\telse if (notconverted)\n\t{\n\t    STRCAT(IObuff, _(\"[NOT converted]\"));\n\t    c = TRUE;\n\t}\n\telse if (converted)\n\t{\n\t    STRCAT(IObuff, _(\"[converted]\"));\n\t    c = TRUE;\n\t}\n#endif\n\tif (device)\n\t{\n\t    STRCAT(IObuff, _(\"[Device]\"));\n\t    c = TRUE;\n\t}\n\telse if (newfile)\n\t{\n\t    STRCAT(IObuff, shortmess(SHM_NEW) ? _(\"[New]\") : _(\"[New File]\"));\n\t    c = TRUE;\n\t}\n\tif (no_eol)\n\t{\n\t    msg_add_eol();\n\t    c = TRUE;\n\t}\n\t/* may add [unix/dos/mac] */\n\tif (msg_add_fileformat(fileformat))\n\t    c = TRUE;\n#ifdef FEAT_CRYPT\n\tif (wb_flags & FIO_ENCRYPTED)\n\t{\n\t    crypt_append_msg(buf);\n\t    c = TRUE;\n\t}\n#endif\n\tmsg_add_lines(c, (long)lnum, nchars);\t/* add line/char count */\n\tif (!shortmess(SHM_WRITE))\n\t{\n\t    if (append)\n\t\tSTRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [a]\") : _(\" appended\"));\n\t    else\n\t\tSTRCAT(IObuff, shortmess(SHM_WRI) ? _(\" [w]\") : _(\" written\"));\n\t}\n\n\tset_keep_msg(msg_trunc_attr(IObuff, FALSE, 0), 0);\n    }\n\n    /* When written everything correctly: reset 'modified'.  Unless not\n     * writing to the original file and '+' is not in 'cpoptions'. */\n    if (reset_changed && whole && !append\n#ifdef FEAT_MBYTE\n\t    && !write_info.bw_conv_error\n#endif\n\t    && (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)\n\t    )\n    {\n\tunchanged(buf, TRUE);\n#ifdef FEAT_AUTOCMD\n\t/* b:changedtick is always incremented in unchanged() but that\n\t * should not trigger a TextChanged event. */\n\tif (last_changedtick + 1 == CHANGEDTICK(buf)\n\t\t\t\t\t       && last_changedtick_buf == buf)\n\t    last_changedtick = CHANGEDTICK(buf);\n#endif\n\tu_unchanged(buf);\n\tu_update_save_nr(buf);\n    }\n\n    /*\n     * If written to the current file, update the timestamp of the swap file\n     * and reset the BF_WRITE_MASK flags. Also sets buf->b_mtime.\n     */\n    if (overwriting)\n    {\n\tml_timestamp(buf);\n\tif (append)\n\t    buf->b_flags &= ~BF_NEW;\n\telse\n\t    buf->b_flags &= ~BF_WRITE_MASK;\n    }\n\n    /*\n     * If we kept a backup until now, and we are in patch mode, then we make\n     * the backup file our 'original' file.\n     */\n    if (*p_pm && dobackup)\n    {\n\tchar *org = (char *)buf_modname((buf->b_p_sn || buf->b_shortname),\n\t\t\t\t\t\t\t  fname, p_pm, FALSE);\n\n\tif (backup != NULL)\n\t{\n\t    stat_T\tst;\n\n\t    /*\n\t     * If the original file does not exist yet\n\t     * the current backup file becomes the original file\n\t     */\n\t    if (org == NULL)\n\t\tEMSG(_(\"E205: Patchmode: can't save original file\"));\n\t    else if (mch_stat(org, &st) < 0)\n\t    {\n\t\tvim_rename(backup, (char_u *)org);\n\t\tvim_free(backup);\t    /* don't delete the file */\n\t\tbackup = NULL;\n#ifdef UNIX\n\t\tset_file_time((char_u *)org, st_old.st_atime, st_old.st_mtime);\n#endif\n\t    }\n\t}\n\t/*\n\t * If there is no backup file, remember that a (new) file was\n\t * created.\n\t */\n\telse\n\t{\n\t    int empty_fd;\n\n\t    if (org == NULL\n\t\t    || (empty_fd = mch_open(org,\n\t\t\t\t      O_CREAT | O_EXTRA | O_EXCL | O_NOFOLLOW,\n\t\t\t\t\tperm < 0 ? 0666 : (perm & 0777))) < 0)\n\t      EMSG(_(\"E206: patchmode: can't touch empty original file\"));\n\t    else\n\t      close(empty_fd);\n\t}\n\tif (org != NULL)\n\t{\n\t    mch_setperm((char_u *)org, mch_getperm(fname) & 0777);\n\t    vim_free(org);\n\t}\n    }\n\n    /*\n     * Remove the backup unless 'backup' option is set\n     */\n    if (!p_bk && backup != NULL && mch_remove(backup) != 0)\n\tEMSG(_(\"E207: Can't delete backup file\"));\n\n#ifdef FEAT_SUN_WORKSHOP\n    if (usingSunWorkShop)\n\tworkshop_file_saved((char *) ffname);\n#endif\n\n    goto nofail;\n\n    /*\n     * Finish up.  We get here either after failure or success.\n     */\nfail:\n    --no_wait_return;\t\t/* may wait for return now */\nnofail:\n\n    /* Done saving, we accept changed buffer warnings again */\n    buf->b_saving = FALSE;\n\n    vim_free(backup);\n    if (buffer != smallbuf)\n\tvim_free(buffer);\n#ifdef FEAT_MBYTE\n    vim_free(fenc_tofree);\n    vim_free(write_info.bw_conv_buf);\n# ifdef USE_ICONV\n    if (write_info.bw_iconv_fd != (iconv_t)-1)\n    {\n\ticonv_close(write_info.bw_iconv_fd);\n\twrite_info.bw_iconv_fd = (iconv_t)-1;\n    }\n# endif\n#endif\n#ifdef HAVE_ACL\n    mch_free_acl(acl);\n#endif\n\n    if (errmsg != NULL)\n    {\n\tint numlen = errnum != NULL ? (int)STRLEN(errnum) : 0;\n\n\tattr = HL_ATTR(HLF_E);\t/* set highlight for error messages */\n\tmsg_add_fname(buf,\n#ifndef UNIX\n\t\tsfname\n#else\n\t\tfname\n#endif\n\t\t     );\t\t/* put file name in IObuff with quotes */\n\tif (STRLEN(IObuff) + STRLEN(errmsg) + numlen >= IOSIZE)\n\t    IObuff[IOSIZE - STRLEN(errmsg) - numlen - 1] = NUL;\n\t/* If the error message has the form \"is ...\", put the error number in\n\t * front of the file name. */\n\tif (errnum != NULL)\n\t{\n\t    STRMOVE(IObuff + numlen, IObuff);\n\t    mch_memmove(IObuff, errnum, (size_t)numlen);\n\t}\n\tSTRCAT(IObuff, errmsg);\n\temsg(IObuff);\n\tif (errmsg_allocated)\n\t    vim_free(errmsg);\n\n\tretval = FAIL;\n\tif (end == 0)\n\t{\n\t    MSG_PUTS_ATTR(_(\"\\nWARNING: Original file may be lost or damaged\\n\"),\n\t\t    attr | MSG_HIST);\n\t    MSG_PUTS_ATTR(_(\"don't quit the editor until the file is successfully written!\"),\n\t\t    attr | MSG_HIST);\n\n\t    /* Update the timestamp to avoid an \"overwrite changed file\"\n\t     * prompt when writing again. */\n\t    if (mch_stat((char *)fname, &st_old) >= 0)\n\t    {\n\t\tbuf_store_time(buf, &st_old, fname);\n\t\tbuf->b_mtime_read = buf->b_mtime;\n\t    }\n\t}\n    }\n    msg_scroll = msg_save;\n\n#ifdef FEAT_PERSISTENT_UNDO\n    /*\n     * When writing the whole file and 'undofile' is set, also write the undo\n     * file.\n     */\n    if (retval == OK && write_undo_file)\n    {\n\tchar_u\t    hash[UNDO_HASH_SIZE];\n\n\tsha256_finish(&sha_ctx, hash);\n\tu_write_undo(NULL, FALSE, buf, hash);\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n#ifdef FEAT_EVAL\n    if (!should_abort(retval))\n#else\n    if (!got_int)\n#endif\n    {\n\taco_save_T\taco;\n\n\tcurbuf->b_no_eol_lnum = 0;  /* in case it was set by the previous read */\n\n\t/*\n\t * Apply POST autocommands.\n\t * Careful: The autocommands may call buf_write() recursively!\n\t */\n\taucmd_prepbuf(&aco, buf);\n\n\tif (append)\n\t    apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (filtering)\n\t    apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse if (reset_changed && whole)\n\t    apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\telse\n\t    apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,\n\t\t\t\t\t\t\t  FALSE, curbuf, eap);\n\n\t/* restore curwin/curbuf and a few other things */\n\taucmd_restbuf(&aco);\n\n#ifdef FEAT_EVAL\n\tif (aborting())\t    /* autocmds may abort script processing */\n\t    retval = FALSE;\n#endif\n    }\n#endif\n\n    got_int |= prev_got_int;\n\n    return retval;\n}\n\n/*\n * Set the name of the current buffer.  Use when the buffer doesn't have a\n * name and a \":r\" or \":w\" command with a file name is used.\n */\n    static int\nset_rw_fname(char_u *fname, char_u *sfname)\n{\n#ifdef FEAT_AUTOCMD\n    buf_T\t*buf = curbuf;\n\n    /* It's like the unnamed buffer is deleted.... */\n    if (curbuf->b_p_bl)\n\tapply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n    apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, FALSE, curbuf);\n# ifdef FEAT_EVAL\n    if (aborting())\t    /* autocmds may abort script processing */\n\treturn FAIL;\n# endif\n    if (curbuf != buf)\n    {\n\t/* We are in another buffer now, don't do the renaming. */\n\tEMSG(_(e_auchangedbuf));\n\treturn FAIL;\n    }\n#endif\n\n    if (setfname(curbuf, fname, sfname, FALSE) == OK)\n\tcurbuf->b_flags |= BF_NOTEDITED;\n\n#ifdef FEAT_AUTOCMD\n    /* ....and a new named one is created */\n    apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, curbuf);\n    if (curbuf->b_p_bl)\n\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n# ifdef FEAT_EVAL\n    if (aborting())\t    /* autocmds may abort script processing */\n\treturn FAIL;\n# endif\n\n    /* Do filetype detection now if 'filetype' is empty. */\n    if (*curbuf->b_p_ft == NUL)\n    {\n\tif (au_has_group((char_u *)\"filetypedetect\"))\n\t    (void)do_doautocmd((char_u *)\"filetypedetect BufRead\", FALSE, NULL);\n\tdo_modelines(0);\n    }\n#endif\n\n    return OK;\n}\n\n/*\n * Put file name into IObuff with quotes.\n */\n    void\nmsg_add_fname(buf_T *buf, char_u *fname)\n{\n    if (fname == NULL)\n\tfname = (char_u *)\"-stdin-\";\n    home_replace(buf, fname, IObuff + 1, IOSIZE - 4, TRUE);\n    IObuff[0] = '\"';\n    STRCAT(IObuff, \"\\\" \");\n}\n\n/*\n * Append message for text mode to IObuff.\n * Return TRUE if something appended.\n */\n    static int\nmsg_add_fileformat(int eol_type)\n{\n#ifndef USE_CRNL\n    if (eol_type == EOL_DOS)\n    {\n\tSTRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[dos]\") : _(\"[dos format]\"));\n\treturn TRUE;\n    }\n#endif\n#ifndef USE_CR\n    if (eol_type == EOL_MAC)\n    {\n\tSTRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[mac]\") : _(\"[mac format]\"));\n\treturn TRUE;\n    }\n#endif\n#if defined(USE_CRNL) || defined(USE_CR)\n    if (eol_type == EOL_UNIX)\n    {\n\tSTRCAT(IObuff, shortmess(SHM_TEXT) ? _(\"[unix]\") : _(\"[unix format]\"));\n\treturn TRUE;\n    }\n#endif\n    return FALSE;\n}\n\n/*\n * Append line and character count to IObuff.\n */\n    void\nmsg_add_lines(\n    int\t    insert_space,\n    long    lnum,\n    off_T   nchars)\n{\n    char_u  *p;\n\n    p = IObuff + STRLEN(IObuff);\n\n    if (insert_space)\n\t*p++ = ' ';\n    if (shortmess(SHM_LINES))\n\tvim_snprintf((char *)p, IOSIZE - (p - IObuff),\n\t\t\"%ldL, %lldC\", lnum, (varnumber_T)nchars);\n    else\n    {\n\tif (lnum == 1)\n\t    STRCPY(p, _(\"1 line, \"));\n\telse\n\t    sprintf((char *)p, _(\"%ld lines, \"), lnum);\n\tp += STRLEN(p);\n\tif (nchars == 1)\n\t    STRCPY(p, _(\"1 character\"));\n\telse\n\t    vim_snprintf((char *)p, IOSIZE - (p - IObuff),\n\t\t    _(\"%lld characters\"), (varnumber_T)nchars);\n    }\n}\n\n/*\n * Append message for missing line separator to IObuff.\n */\n    static void\nmsg_add_eol(void)\n{\n    STRCAT(IObuff, shortmess(SHM_LAST) ? _(\"[noeol]\") : _(\"[Incomplete last line]\"));\n}\n\n/*\n * Check modification time of file, before writing to it.\n * The size isn't checked, because using a tool like \"gzip\" takes care of\n * using the same timestamp but can't set the size.\n */\n    static int\ncheck_mtime(buf_T *buf, stat_T *st)\n{\n    if (buf->b_mtime_read != 0\n\t    && time_differs((long)st->st_mtime, buf->b_mtime_read))\n    {\n\tmsg_scroll = TRUE;\t    /* don't overwrite messages here */\n\tmsg_silent = 0;\t\t    /* must give this prompt */\n\t/* don't use emsg() here, don't want to flush the buffers */\n\tMSG_ATTR(_(\"WARNING: The file has been changed since reading it!!!\"),\n\t\t\t\t\t\t       HL_ATTR(HLF_E));\n\tif (ask_yesno((char_u *)_(\"Do you really want to write to it\"),\n\t\t\t\t\t\t\t\t TRUE) == 'n')\n\t    return FAIL;\n\tmsg_scroll = FALSE;\t    /* always overwrite the file message now */\n    }\n    return OK;\n}\n\n    static int\ntime_differs(long t1, long t2)\n{\n#if defined(__linux__) || defined(MSWIN)\n    /* On a FAT filesystem, esp. under Linux, there are only 5 bits to store\n     * the seconds.  Since the roundoff is done when flushing the inode, the\n     * time may change unexpectedly by one second!!! */\n    return (t1 - t2 > 1 || t2 - t1 > 1);\n#else\n    return (t1 != t2);\n#endif\n}\n\n/*\n * Call write() to write a number of bytes to the file.\n * Handles encryption and 'encoding' conversion.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    static int\nbuf_write_bytes(struct bw_info *ip)\n{\n    int\t\twlen;\n    char_u\t*buf = ip->bw_buf;\t/* data to write */\n    int\t\tlen = ip->bw_len;\t/* length of data */\n#ifdef HAS_BW_FLAGS\n    int\t\tflags = ip->bw_flags;\t/* extra flags */\n#endif\n\n#ifdef FEAT_MBYTE\n    /*\n     * Skip conversion when writing the crypt magic number or the BOM.\n     */\n    if (!(flags & FIO_NOCONVERT))\n    {\n\tchar_u\t\t*p;\n\tunsigned\tc;\n\tint\t\tn;\n\n\tif (flags & FIO_UTF8)\n\t{\n\t    /*\n\t     * Convert latin1 in the buffer to UTF-8 in the file.\n\t     */\n\t    p = ip->bw_conv_buf;\t/* translate to buffer */\n\t    for (wlen = 0; wlen < len; ++wlen)\n\t\tp += utf_char2bytes(buf[wlen], p);\n\t    buf = ip->bw_conv_buf;\n\t    len = (int)(p - ip->bw_conv_buf);\n\t}\n\telse if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1))\n\t{\n\t    /*\n\t     * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or\n\t     * Latin1 chars in the file.\n\t     */\n\t    if (flags & FIO_LATIN1)\n\t\tp = buf;\t/* translate in-place (can only get shorter) */\n\t    else\n\t\tp = ip->bw_conv_buf;\t/* translate to buffer */\n\t    for (wlen = 0; wlen < len; wlen += n)\n\t    {\n\t\tif (wlen == 0 && ip->bw_restlen != 0)\n\t\t{\n\t\t    int\t\tl;\n\n\t\t    /* Use remainder of previous call.  Append the start of\n\t\t     * buf[] to get a full sequence.  Might still be too\n\t\t     * short! */\n\t\t    l = CONV_RESTLEN - ip->bw_restlen;\n\t\t    if (l > len)\n\t\t\tl = len;\n\t\t    mch_memmove(ip->bw_rest + ip->bw_restlen, buf, (size_t)l);\n\t\t    n = utf_ptr2len_len(ip->bw_rest, ip->bw_restlen + l);\n\t\t    if (n > ip->bw_restlen + len)\n\t\t    {\n\t\t\t/* We have an incomplete byte sequence at the end to\n\t\t\t * be written.  We can't convert it without the\n\t\t\t * remaining bytes.  Keep them for the next call. */\n\t\t\tif (ip->bw_restlen + len > CONV_RESTLEN)\n\t\t\t    return FAIL;\n\t\t\tip->bw_restlen += len;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (n > 1)\n\t\t\tc = utf_ptr2char(ip->bw_rest);\n\t\t    else\n\t\t\tc = ip->bw_rest[0];\n\t\t    if (n >= ip->bw_restlen)\n\t\t    {\n\t\t\tn -= ip->bw_restlen;\n\t\t\tip->bw_restlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tip->bw_restlen -= n;\n\t\t\tmch_memmove(ip->bw_rest, ip->bw_rest + n,\n\t\t\t\t\t\t      (size_t)ip->bw_restlen);\n\t\t\tn = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    n = utf_ptr2len_len(buf + wlen, len - wlen);\n\t\t    if (n > len - wlen)\n\t\t    {\n\t\t\t/* We have an incomplete byte sequence at the end to\n\t\t\t * be written.  We can't convert it without the\n\t\t\t * remaining bytes.  Keep them for the next call. */\n\t\t\tif (len - wlen > CONV_RESTLEN)\n\t\t\t    return FAIL;\n\t\t\tip->bw_restlen = len - wlen;\n\t\t\tmch_memmove(ip->bw_rest, buf + wlen,\n\t\t\t\t\t\t      (size_t)ip->bw_restlen);\n\t\t\tbreak;\n\t\t    }\n\t\t    if (n > 1)\n\t\t\tc = utf_ptr2char(buf + wlen);\n\t\t    else\n\t\t\tc = buf[wlen];\n\t\t}\n\n\t\tif (ucs2bytes(c, &p, flags) && !ip->bw_conv_error)\n\t\t{\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    ip->bw_conv_error_lnum = ip->bw_start_lnum;\n\t\t}\n\t\tif (c == NL)\n\t\t    ++ip->bw_start_lnum;\n\t    }\n\t    if (flags & FIO_LATIN1)\n\t\tlen = (int)(p - buf);\n\t    else\n\t    {\n\t\tbuf = ip->bw_conv_buf;\n\t\tlen = (int)(p - ip->bw_conv_buf);\n\t    }\n\t}\n\n# ifdef WIN3264\n\telse if (flags & FIO_CODEPAGE)\n\t{\n\t    /*\n\t     * Convert UTF-8 or codepage to UCS-2 and then to MS-Windows\n\t     * codepage.\n\t     */\n\t    char_u\t*from;\n\t    size_t\tfromlen;\n\t    char_u\t*to;\n\t    int\t\tu8c;\n\t    BOOL\tbad = FALSE;\n\t    int\t\tneeded;\n\n\t    if (ip->bw_restlen > 0)\n\t    {\n\t\t/* Need to concatenate the remainder of the previous call and\n\t\t * the bytes of the current call.  Use the end of the\n\t\t * conversion buffer for this. */\n\t\tfromlen = len + ip->bw_restlen;\n\t\tfrom = ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n\t\tmch_memmove(from, ip->bw_rest, (size_t)ip->bw_restlen);\n\t\tmch_memmove(from + ip->bw_restlen, buf, (size_t)len);\n\t    }\n\t    else\n\t    {\n\t\tfrom = buf;\n\t\tfromlen = len;\n\t    }\n\n\t    to = ip->bw_conv_buf;\n\t    if (enc_utf8)\n\t    {\n\t\t/* Convert from UTF-8 to UCS-2, to the start of the buffer.\n\t\t * The buffer has been allocated to be big enough. */\n\t\twhile (fromlen > 0)\n\t\t{\n\t\t    n = (int)utf_ptr2len_len(from, (int)fromlen);\n\t\t    if (n > (int)fromlen)\t/* incomplete byte sequence */\n\t\t\tbreak;\n\t\t    u8c = utf_ptr2char(from);\n\t\t    *to++ = (u8c & 0xff);\n\t\t    *to++ = (u8c >> 8);\n\t\t    fromlen -= n;\n\t\t    from += n;\n\t\t}\n\n\t\t/* Copy remainder to ip->bw_rest[] to be used for the next\n\t\t * call. */\n\t\tif (fromlen > CONV_RESTLEN)\n\t\t{\n\t\t    /* weird overlong sequence */\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t\tmch_memmove(ip->bw_rest, from, fromlen);\n\t\tip->bw_restlen = (int)fromlen;\n\t    }\n\t    else\n\t    {\n\t\t/* Convert from enc_codepage to UCS-2, to the start of the\n\t\t * buffer.  The buffer has been allocated to be big enough. */\n\t\tip->bw_restlen = 0;\n\t\tneeded = MultiByteToWideChar(enc_codepage,\n\t\t\t     MB_ERR_INVALID_CHARS, (LPCSTR)from, (int)fromlen,\n\t\t\t\t\t\t\t\t     NULL, 0);\n\t\tif (needed == 0)\n\t\t{\n\t\t    /* When conversion fails there may be a trailing byte. */\n\t\t    needed = MultiByteToWideChar(enc_codepage,\n\t\t\t MB_ERR_INVALID_CHARS, (LPCSTR)from, (int)fromlen - 1,\n\t\t\t\t\t\t\t\t     NULL, 0);\n\t\t    if (needed == 0)\n\t\t    {\n\t\t\t/* Conversion doesn't work. */\n\t\t\tip->bw_conv_error = TRUE;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    /* Save the trailing byte for the next call. */\n\t\t    ip->bw_rest[0] = from[fromlen - 1];\n\t\t    ip->bw_restlen = 1;\n\t\t}\n\t\tneeded = MultiByteToWideChar(enc_codepage, MB_ERR_INVALID_CHARS,\n\t\t\t\t(LPCSTR)from, (int)(fromlen - ip->bw_restlen),\n\t\t\t\t\t\t\t  (LPWSTR)to, needed);\n\t\tif (needed == 0)\n\t\t{\n\t\t    /* Safety check: Conversion doesn't work. */\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t\tto += needed * 2;\n\t    }\n\n\t    fromlen = to - ip->bw_conv_buf;\n\t    buf = to;\n#  ifdef CP_UTF8\t/* VC 4.1 doesn't define CP_UTF8 */\n\t    if (FIO_GET_CP(flags) == CP_UTF8)\n\t    {\n\t\t/* Convert from UCS-2 to UTF-8, using the remainder of the\n\t\t * conversion buffer.  Fails when out of space. */\n\t\tfor (from = ip->bw_conv_buf; fromlen > 1; fromlen -= 2)\n\t\t{\n\t\t    u8c = *from++;\n\t\t    u8c += (*from++ << 8);\n\t\t    to += utf_char2bytes(u8c, to);\n\t\t    if (to + 6 >= ip->bw_conv_buf + ip->bw_conv_buflen)\n\t\t    {\n\t\t\tip->bw_conv_error = TRUE;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t\tlen = (int)(to - buf);\n\t    }\n\t    else\n#endif\n\t    {\n\t\t/* Convert from UCS-2 to the codepage, using the remainder of\n\t\t * the conversion buffer.  If the conversion uses the default\n\t\t * character \"0\", the data doesn't fit in this encoding, so\n\t\t * fail. */\n\t\tlen = WideCharToMultiByte(FIO_GET_CP(flags), 0,\n\t\t\t(LPCWSTR)ip->bw_conv_buf, (int)fromlen / sizeof(WCHAR),\n\t\t\t(LPSTR)to, (int)(ip->bw_conv_buflen - fromlen), 0,\n\t\t\t\t\t\t\t\t\t&bad);\n\t\tif (bad)\n\t\t{\n\t\t    ip->bw_conv_error = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n# endif\n\n# ifdef MACOS_CONVERT\n\telse if (flags & FIO_MACROMAN)\n\t{\n\t    /*\n\t     * Convert UTF-8 or latin1 to Apple MacRoman.\n\t     */\n\t    char_u\t*from;\n\t    size_t\tfromlen;\n\n\t    if (ip->bw_restlen > 0)\n\t    {\n\t\t/* Need to concatenate the remainder of the previous call and\n\t\t * the bytes of the current call.  Use the end of the\n\t\t * conversion buffer for this. */\n\t\tfromlen = len + ip->bw_restlen;\n\t\tfrom = ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n\t\tmch_memmove(from, ip->bw_rest, (size_t)ip->bw_restlen);\n\t\tmch_memmove(from + ip->bw_restlen, buf, (size_t)len);\n\t    }\n\t    else\n\t    {\n\t\tfrom = buf;\n\t\tfromlen = len;\n\t    }\n\n\t    if (enc2macroman(from, fromlen,\n\t\t\tip->bw_conv_buf, &len, ip->bw_conv_buflen,\n\t\t\tip->bw_rest, &ip->bw_restlen) == FAIL)\n\t    {\n\t\tip->bw_conv_error = TRUE;\n\t\treturn FAIL;\n\t    }\n\t    buf = ip->bw_conv_buf;\n\t}\n# endif\n\n# ifdef USE_ICONV\n\tif (ip->bw_iconv_fd != (iconv_t)-1)\n\t{\n\t    const char\t*from;\n\t    size_t\tfromlen;\n\t    char\t*to;\n\t    size_t\ttolen;\n\n\t    /* Convert with iconv(). */\n\t    if (ip->bw_restlen > 0)\n\t    {\n\t\tchar *fp;\n\n\t\t/* Need to concatenate the remainder of the previous call and\n\t\t * the bytes of the current call.  Use the end of the\n\t\t * conversion buffer for this. */\n\t\tfromlen = len + ip->bw_restlen;\n\t\tfp = (char *)ip->bw_conv_buf + ip->bw_conv_buflen - fromlen;\n\t\tmch_memmove(fp, ip->bw_rest, (size_t)ip->bw_restlen);\n\t\tmch_memmove(fp + ip->bw_restlen, buf, (size_t)len);\n\t\tfrom = fp;\n\t\ttolen = ip->bw_conv_buflen - fromlen;\n\t    }\n\t    else\n\t    {\n\t\tfrom = (const char *)buf;\n\t\tfromlen = len;\n\t\ttolen = ip->bw_conv_buflen;\n\t    }\n\t    to = (char *)ip->bw_conv_buf;\n\n\t    if (ip->bw_first)\n\t    {\n\t\tsize_t\tsave_len = tolen;\n\n\t\t/* output the initial shift state sequence */\n\t\t(void)iconv(ip->bw_iconv_fd, NULL, NULL, &to, &tolen);\n\n\t\t/* There is a bug in iconv() on Linux (which appears to be\n\t\t * wide-spread) which sets \"to\" to NULL and messes up \"tolen\".\n\t\t */\n\t\tif (to == NULL)\n\t\t{\n\t\t    to = (char *)ip->bw_conv_buf;\n\t\t    tolen = save_len;\n\t\t}\n\t\tip->bw_first = FALSE;\n\t    }\n\n\t    /*\n\t     * If iconv() has an error or there is not enough room, fail.\n\t     */\n\t    if ((iconv(ip->bw_iconv_fd, (void *)&from, &fromlen, &to, &tolen)\n\t\t\t== (size_t)-1 && ICONV_ERRNO != ICONV_EINVAL)\n\t\t\t\t\t\t    || fromlen > CONV_RESTLEN)\n\t    {\n\t\tip->bw_conv_error = TRUE;\n\t\treturn FAIL;\n\t    }\n\n\t    /* copy remainder to ip->bw_rest[] to be used for the next call. */\n\t    if (fromlen > 0)\n\t\tmch_memmove(ip->bw_rest, (void *)from, fromlen);\n\t    ip->bw_restlen = (int)fromlen;\n\n\t    buf = ip->bw_conv_buf;\n\t    len = (int)((char_u *)to - ip->bw_conv_buf);\n\t}\n# endif\n    }\n#endif /* FEAT_MBYTE */\n\n    if (ip->bw_fd < 0)\n\t/* Only checking conversion, which is OK if we get here. */\n\treturn OK;\n\n#ifdef FEAT_CRYPT\n    if (flags & FIO_ENCRYPTED)\n    {\n\t/* Encrypt the data. Do it in-place if possible, otherwise use an\n\t * allocated buffer. */\n\tif (crypt_works_inplace(ip->bw_buffer->b_cryptstate))\n\t{\n\t    crypt_encode_inplace(ip->bw_buffer->b_cryptstate, buf, len);\n\t}\n\telse\n\t{\n\t    char_u *outbuf;\n\n\t    len = crypt_encode_alloc(curbuf->b_cryptstate, buf, len, &outbuf);\n\t    if (len == 0)\n\t\treturn OK;  /* Crypt layer is buffering, will flush later. */\n\t    wlen = write_eintr(ip->bw_fd, outbuf, len);\n\t    vim_free(outbuf);\n\t    return (wlen < len) ? FAIL : OK;\n\t}\n    }\n#endif\n\n    wlen = write_eintr(ip->bw_fd, buf, len);\n    return (wlen < len) ? FAIL : OK;\n}\n\n#ifdef FEAT_MBYTE\n/*\n * Convert a Unicode character to bytes.\n * Return TRUE for an error, FALSE when it's OK.\n */\n    static int\nucs2bytes(\n    unsigned\tc,\t\t/* in: character */\n    char_u\t**pp,\t\t/* in/out: pointer to result */\n    int\t\tflags)\t\t/* FIO_ flags */\n{\n    char_u\t*p = *pp;\n    int\t\terror = FALSE;\n    int\t\tcc;\n\n\n    if (flags & FIO_UCS4)\n    {\n\tif (flags & FIO_ENDIAN_L)\n\t{\n\t    *p++ = c;\n\t    *p++ = (c >> 8);\n\t    *p++ = (c >> 16);\n\t    *p++ = (c >> 24);\n\t}\n\telse\n\t{\n\t    *p++ = (c >> 24);\n\t    *p++ = (c >> 16);\n\t    *p++ = (c >> 8);\n\t    *p++ = c;\n\t}\n    }\n    else if (flags & (FIO_UCS2 | FIO_UTF16))\n    {\n\tif (c >= 0x10000)\n\t{\n\t    if (flags & FIO_UTF16)\n\t    {\n\t\t/* Make two words, ten bits of the character in each.  First\n\t\t * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */\n\t\tc -= 0x10000;\n\t\tif (c >= 0x100000)\n\t\t    error = TRUE;\n\t\tcc = ((c >> 10) & 0x3ff) + 0xd800;\n\t\tif (flags & FIO_ENDIAN_L)\n\t\t{\n\t\t    *p++ = cc;\n\t\t    *p++ = ((unsigned)cc >> 8);\n\t\t}\n\t\telse\n\t\t{\n\t\t    *p++ = ((unsigned)cc >> 8);\n\t\t    *p++ = cc;\n\t\t}\n\t\tc = (c & 0x3ff) + 0xdc00;\n\t    }\n\t    else\n\t\terror = TRUE;\n\t}\n\tif (flags & FIO_ENDIAN_L)\n\t{\n\t    *p++ = c;\n\t    *p++ = (c >> 8);\n\t}\n\telse\n\t{\n\t    *p++ = (c >> 8);\n\t    *p++ = c;\n\t}\n    }\n    else    /* Latin1 */\n    {\n\tif (c >= 0x100)\n\t{\n\t    error = TRUE;\n\t    *p++ = 0xBF;\n\t}\n\telse\n\t    *p++ = c;\n    }\n\n    *pp = p;\n    return error;\n}\n\n/*\n * Return TRUE if file encoding \"fenc\" requires conversion from or to\n * 'encoding'.\n */\n    static int\nneed_conversion(char_u *fenc)\n{\n    int\t\tsame_encoding;\n    int\t\tenc_flags;\n    int\t\tfenc_flags;\n\n    if (*fenc == NUL || STRCMP(p_enc, fenc) == 0)\n    {\n\tsame_encoding = TRUE;\n\tfenc_flags = 0;\n    }\n    else\n    {\n\t/* Ignore difference between \"ansi\" and \"latin1\", \"ucs-4\" and\n\t * \"ucs-4be\", etc. */\n\tenc_flags = get_fio_flags(p_enc);\n\tfenc_flags = get_fio_flags(fenc);\n\tsame_encoding = (enc_flags != 0 && fenc_flags == enc_flags);\n    }\n    if (same_encoding)\n    {\n\t/* Specified encoding matches with 'encoding'.  This requires\n\t * conversion when 'encoding' is Unicode but not UTF-8. */\n\treturn enc_unicode != 0;\n    }\n\n    /* Encodings differ.  However, conversion is not needed when 'enc' is any\n     * Unicode encoding and the file is UTF-8. */\n    return !(enc_utf8 && fenc_flags == FIO_UTF8);\n}\n\n/*\n * Check \"ptr\" for a unicode encoding and return the FIO_ flags needed for the\n * internal conversion.\n * if \"ptr\" is an empty string, use 'encoding'.\n */\n    static int\nget_fio_flags(char_u *ptr)\n{\n    int\t\tprop;\n\n    if (*ptr == NUL)\n\tptr = p_enc;\n\n    prop = enc_canon_props(ptr);\n    if (prop & ENC_UNICODE)\n    {\n\tif (prop & ENC_2BYTE)\n\t{\n\t    if (prop & ENC_ENDIAN_L)\n\t\treturn FIO_UCS2 | FIO_ENDIAN_L;\n\t    return FIO_UCS2;\n\t}\n\tif (prop & ENC_4BYTE)\n\t{\n\t    if (prop & ENC_ENDIAN_L)\n\t\treturn FIO_UCS4 | FIO_ENDIAN_L;\n\t    return FIO_UCS4;\n\t}\n\tif (prop & ENC_2WORD)\n\t{\n\t    if (prop & ENC_ENDIAN_L)\n\t\treturn FIO_UTF16 | FIO_ENDIAN_L;\n\t    return FIO_UTF16;\n\t}\n\treturn FIO_UTF8;\n    }\n    if (prop & ENC_LATIN1)\n\treturn FIO_LATIN1;\n    /* must be ENC_DBCS, requires iconv() */\n    return 0;\n}\n\n#ifdef WIN3264\n/*\n * Check \"ptr\" for a MS-Windows codepage name and return the FIO_ flags needed\n * for the conversion MS-Windows can do for us.  Also accept \"utf-8\".\n * Used for conversion between 'encoding' and 'fileencoding'.\n */\n    static int\nget_win_fio_flags(char_u *ptr)\n{\n    int\t\tcp;\n\n    /* Cannot do this when 'encoding' is not utf-8 and not a codepage. */\n    if (!enc_utf8 && enc_codepage <= 0)\n\treturn 0;\n\n    cp = encname2codepage(ptr);\n    if (cp == 0)\n    {\n#  ifdef CP_UTF8\t/* VC 4.1 doesn't define CP_UTF8 */\n\tif (STRCMP(ptr, \"utf-8\") == 0)\n\t    cp = CP_UTF8;\n\telse\n#  endif\n\t    return 0;\n    }\n    return FIO_PUT_CP(cp) | FIO_CODEPAGE;\n}\n#endif\n\n#ifdef MACOS_CONVERT\n/*\n * Check \"ptr\" for a Carbon supported encoding and return the FIO_ flags\n * needed for the internal conversion to/from utf-8 or latin1.\n */\n    static int\nget_mac_fio_flags(char_u *ptr)\n{\n    if ((enc_utf8 || STRCMP(p_enc, \"latin1\") == 0)\n\t\t\t\t     && (enc_canon_props(ptr) & ENC_MACROMAN))\n\treturn FIO_MACROMAN;\n    return 0;\n}\n#endif\n\n/*\n * Check for a Unicode BOM (Byte Order Mark) at the start of p[size].\n * \"size\" must be at least 2.\n * Return the name of the encoding and set \"*lenp\" to the length.\n * Returns NULL when no BOM found.\n */\n    static char_u *\ncheck_for_bom(\n    char_u\t*p,\n    long\tsize,\n    int\t\t*lenp,\n    int\t\tflags)\n{\n    char\t*name = NULL;\n    int\t\tlen = 2;\n\n    if (p[0] == 0xef && p[1] == 0xbb && size >= 3 && p[2] == 0xbf\n\t    && (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0))\n    {\n\tname = \"utf-8\";\t\t/* EF BB BF */\n\tlen = 3;\n    }\n    else if (p[0] == 0xff && p[1] == 0xfe)\n    {\n\tif (size >= 4 && p[2] == 0 && p[3] == 0\n\t    && (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L)))\n\t{\n\t    name = \"ucs-4le\";\t/* FF FE 00 00 */\n\t    len = 4;\n\t}\n\telse if (flags == (FIO_UCS2 | FIO_ENDIAN_L))\n\t    name = \"ucs-2le\";\t/* FF FE */\n\telse if (flags == FIO_ALL || flags == (FIO_UTF16 | FIO_ENDIAN_L))\n\t    /* utf-16le is preferred, it also works for ucs-2le text */\n\t    name = \"utf-16le\";\t/* FF FE */\n    }\n    else if (p[0] == 0xfe && p[1] == 0xff\n\t    && (flags == FIO_ALL || flags == FIO_UCS2 || flags == FIO_UTF16))\n    {\n\t/* Default to utf-16, it works also for ucs-2 text. */\n\tif (flags == FIO_UCS2)\n\t    name = \"ucs-2\";\t/* FE FF */\n\telse\n\t    name = \"utf-16\";\t/* FE FF */\n    }\n    else if (size >= 4 && p[0] == 0 && p[1] == 0 && p[2] == 0xfe\n\t    && p[3] == 0xff && (flags == FIO_ALL || flags == FIO_UCS4))\n    {\n\tname = \"ucs-4\";\t\t/* 00 00 FE FF */\n\tlen = 4;\n    }\n\n    *lenp = len;\n    return (char_u *)name;\n}\n\n/*\n * Generate a BOM in \"buf[4]\" for encoding \"name\".\n * Return the length of the BOM (zero when no BOM).\n */\n    static int\nmake_bom(char_u *buf, char_u *name)\n{\n    int\t\tflags;\n    char_u\t*p;\n\n    flags = get_fio_flags(name);\n\n    /* Can't put a BOM in a non-Unicode file. */\n    if (flags == FIO_LATIN1 || flags == 0)\n\treturn 0;\n\n    if (flags == FIO_UTF8)\t/* UTF-8 */\n    {\n\tbuf[0] = 0xef;\n\tbuf[1] = 0xbb;\n\tbuf[2] = 0xbf;\n\treturn 3;\n    }\n    p = buf;\n    (void)ucs2bytes(0xfeff, &p, flags);\n    return (int)(p - buf);\n}\n#endif\n\n#if defined(FEAT_VIMINFO) || defined(FEAT_BROWSE) || \\\n    defined(FEAT_QUICKFIX) || defined(FEAT_AUTOCMD) || defined(PROTO)\n/*\n * Try to find a shortname by comparing the fullname with the current\n * directory.\n * Returns \"full_path\" or pointer into \"full_path\" if shortened.\n */\n    char_u *\nshorten_fname1(char_u *full_path)\n{\n    char_u\t*dirname;\n    char_u\t*p = full_path;\n\n    dirname = alloc(MAXPATHL);\n    if (dirname == NULL)\n\treturn full_path;\n    if (mch_dirname(dirname, MAXPATHL) == OK)\n    {\n\tp = shorten_fname(full_path, dirname);\n\tif (p == NULL || *p == NUL)\n\t    p = full_path;\n    }\n    vim_free(dirname);\n    return p;\n}\n#endif\n\n/*\n * Try to find a shortname by comparing the fullname with the current\n * directory.\n * Returns NULL if not shorter name possible, pointer into \"full_path\"\n * otherwise.\n */\n    char_u *\nshorten_fname(char_u *full_path, char_u *dir_name)\n{\n    int\t\tlen;\n    char_u\t*p;\n\n    if (full_path == NULL)\n\treturn NULL;\n    len = (int)STRLEN(dir_name);\n    if (fnamencmp(dir_name, full_path, len) == 0)\n    {\n\tp = full_path + len;\n#if defined(MSWIN)\n\t/*\n\t * MSWIN: when a file is in the root directory, dir_name will end in a\n\t * slash, since C: by itself does not define a specific dir. In this\n\t * case p may already be correct. <negri>\n\t */\n\tif (!((len > 2) && (*(p - 2) == ':')))\n#endif\n\t{\n\t    if (vim_ispathsep(*p))\n\t\t++p;\n#ifndef VMS   /* the path separator is always part of the path */\n\t    else\n\t\tp = NULL;\n#endif\n\t}\n    }\n#if defined(MSWIN)\n    /*\n     * When using a file in the current drive, remove the drive name:\n     * \"A:\\dir\\file\" -> \"\\dir\\file\".  This helps when moving a session file on\n     * a floppy from \"A:\\dir\" to \"B:\\dir\".\n     */\n    else if (len > 3\n\t    && TOUPPER_LOC(full_path[0]) == TOUPPER_LOC(dir_name[0])\n\t    && full_path[1] == ':'\n\t    && vim_ispathsep(full_path[2]))\n\tp = full_path + 2;\n#endif\n    else\n\tp = NULL;\n    return p;\n}\n\n/*\n * Shorten filenames for all buffers.\n * When \"force\" is TRUE: Use full path from now on for files currently being\n * edited, both for file name and swap file name.  Try to shorten the file\n * names a bit, if safe to do so.\n * When \"force\" is FALSE: Only try to shorten absolute file names.\n * For buffers that have buftype \"nofile\" or \"scratch\": never change the file\n * name.\n */\n    void\nshorten_fnames(int force)\n{\n    char_u\tdirname[MAXPATHL];\n    buf_T\t*buf;\n    char_u\t*p;\n\n    mch_dirname(dirname, MAXPATHL);\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_fname != NULL\n#ifdef FEAT_QUICKFIX\n\t\t&& !bt_nofile(buf)\n#endif\n\t\t&& !path_with_url(buf->b_fname)\n\t\t&& (force\n\t\t    || buf->b_sfname == NULL\n\t\t    || mch_isFullName(buf->b_sfname)))\n\t{\n\t    vim_free(buf->b_sfname);\n\t    buf->b_sfname = NULL;\n\t    p = shorten_fname(buf->b_ffname, dirname);\n\t    if (p != NULL)\n\t    {\n\t\tbuf->b_sfname = vim_strsave(p);\n\t\tbuf->b_fname = buf->b_sfname;\n\t    }\n\t    if (p == NULL || buf->b_fname == NULL)\n\t\tbuf->b_fname = buf->b_ffname;\n\t}\n\n\t/* Always make the swap file name a full path, a \"nofile\" buffer may\n\t * also have a swap file. */\n\tmf_fullname(buf->b_ml.ml_mfp);\n    }\n    status_redraw_all();\n    redraw_tabline = TRUE;\n}\n\n#if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \\\n\t|| defined(FEAT_GUI_MSWIN) \\\n\t|| defined(FEAT_GUI_MAC) \\\n\t|| defined(PROTO)\n/*\n * Shorten all filenames in \"fnames[count]\" by current directory.\n */\n    void\nshorten_filenames(char_u **fnames, int count)\n{\n    int\t\ti;\n    char_u\tdirname[MAXPATHL];\n    char_u\t*p;\n\n    if (fnames == NULL || count < 1)\n\treturn;\n    mch_dirname(dirname, sizeof(dirname));\n    for (i = 0; i < count; ++i)\n    {\n\tif ((p = shorten_fname(fnames[i], dirname)) != NULL)\n\t{\n\t    /* shorten_fname() returns pointer in given \"fnames[i]\".  If free\n\t     * \"fnames[i]\" first, \"p\" becomes invalid.  So we need to copy\n\t     * \"p\" first then free fnames[i]. */\n\t    p = vim_strsave(p);\n\t    vim_free(fnames[i]);\n\t    fnames[i] = p;\n\t}\n    }\n}\n#endif\n\n/*\n * add extension to file name - change path/fo.o.h to path/fo.o.h.ext or\n * fo_o_h.ext for MSDOS or when shortname option set.\n *\n * Assumed that fname is a valid name found in the filesystem we assure that\n * the return value is a different name and ends in 'ext'.\n * \"ext\" MUST be at most 4 characters long if it starts with a dot, 3\n * characters otherwise.\n * Space for the returned name is allocated, must be freed later.\n * Returns NULL when out of memory.\n */\n    char_u *\nmodname(\n    char_u *fname,\n    char_u *ext,\n    int\t    prepend_dot)\t/* may prepend a '.' to file name */\n{\n    return buf_modname((curbuf->b_p_sn || curbuf->b_shortname),\n\t\t\t\t\t\t     fname, ext, prepend_dot);\n}\n\n    char_u *\nbuf_modname(\n    int\t    shortname,\t\t/* use 8.3 file name */\n    char_u  *fname,\n    char_u  *ext,\n    int\t    prepend_dot)\t/* may prepend a '.' to file name */\n{\n    char_u\t*retval;\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*ptr;\n    int\t\tfnamelen, extlen;\n\n    extlen = (int)STRLEN(ext);\n\n    /*\n     * If there is no file name we must get the name of the current directory\n     * (we need the full path in case :cd is used).\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tretval = alloc((unsigned)(MAXPATHL + extlen + 3));\n\tif (retval == NULL)\n\t    return NULL;\n\tif (mch_dirname(retval, MAXPATHL) == FAIL ||\n\t\t\t\t     (fnamelen = (int)STRLEN(retval)) == 0)\n\t{\n\t    vim_free(retval);\n\t    return NULL;\n\t}\n\tif (!after_pathsep(retval, retval + fnamelen))\n\t{\n\t    retval[fnamelen++] = PATHSEP;\n\t    retval[fnamelen] = NUL;\n\t}\n\tprepend_dot = FALSE;\t    /* nothing to prepend a dot to */\n    }\n    else\n    {\n\tfnamelen = (int)STRLEN(fname);\n\tretval = alloc((unsigned)(fnamelen + extlen + 3));\n\tif (retval == NULL)\n\t    return NULL;\n\tSTRCPY(retval, fname);\n#ifdef VMS\n\tvms_remove_version(retval); /* we do not need versions here */\n#endif\n    }\n\n    /*\n     * search backwards until we hit a '/', '\\' or ':' replacing all '.'\n     * by '_' for MSDOS or when shortname option set and ext starts with a dot.\n     * Then truncate what is after the '/', '\\' or ':' to 8 characters for\n     * MSDOS and 26 characters for AMIGA, a lot more for UNIX.\n     */\n    for (ptr = retval + fnamelen; ptr > retval; MB_PTR_BACK(retval, ptr))\n    {\n\tif (*ext == '.'\n#ifdef USE_LONG_FNAME\n\t\t    && (!USE_LONG_FNAME || shortname)\n#else\n\t\t    && shortname\n#endif\n\t\t\t\t\t\t\t\t)\n\t    if (*ptr == '.')\t/* replace '.' by '_' */\n\t\t*ptr = '_';\n\tif (vim_ispathsep(*ptr))\n\t{\n\t    ++ptr;\n\t    break;\n\t}\n    }\n\n    /* the file name has at most BASENAMELEN characters. */\n    if (STRLEN(ptr) > (unsigned)BASENAMELEN)\n\tptr[BASENAMELEN] = '\\0';\n\n    s = ptr + STRLEN(ptr);\n\n    /*\n     * For 8.3 file names we may have to reduce the length.\n     */\n#ifdef USE_LONG_FNAME\n    if (!USE_LONG_FNAME || shortname)\n#else\n    if (shortname)\n#endif\n    {\n\t/*\n\t * If there is no file name, or the file name ends in '/', and the\n\t * extension starts with '.', put a '_' before the dot, because just\n\t * \".ext\" is invalid.\n\t */\n\tif (fname == NULL || *fname == NUL\n\t\t\t\t   || vim_ispathsep(fname[STRLEN(fname) - 1]))\n\t{\n\t    if (*ext == '.')\n\t\t*s++ = '_';\n\t}\n\t/*\n\t * If the extension starts with '.', truncate the base name at 8\n\t * characters\n\t */\n\telse if (*ext == '.')\n\t{\n\t    if ((size_t)(s - ptr) > (size_t)8)\n\t    {\n\t\ts = ptr + 8;\n\t\t*s = '\\0';\n\t    }\n\t}\n\t/*\n\t * If the extension doesn't start with '.', and the file name\n\t * doesn't have an extension yet, append a '.'\n\t */\n\telse if ((e = vim_strchr(ptr, '.')) == NULL)\n\t    *s++ = '.';\n\t/*\n\t * If the extension doesn't start with '.', and there already is an\n\t * extension, it may need to be truncated\n\t */\n\telse if ((int)STRLEN(e) + extlen > 4)\n\t    s = e + 4 - extlen;\n    }\n#if defined(USE_LONG_FNAME) || defined(WIN3264)\n    /*\n     * If there is no file name, and the extension starts with '.', put a\n     * '_' before the dot, because just \".ext\" may be invalid if it's on a\n     * FAT partition, and on HPFS it doesn't matter.\n     */\n    else if ((fname == NULL || *fname == NUL) && *ext == '.')\n\t*s++ = '_';\n#endif\n\n    /*\n     * Append the extension.\n     * ext can start with '.' and cannot exceed 3 more characters.\n     */\n    STRCPY(s, ext);\n\n    /*\n     * Prepend the dot.\n     */\n    if (prepend_dot && !shortname && *(e = gettail(retval)) != '.'\n#ifdef USE_LONG_FNAME\n\t    && USE_LONG_FNAME\n#endif\n\t\t\t\t)\n    {\n\tSTRMOVE(e + 1, e);\n\t*e = '.';\n    }\n\n    /*\n     * Check that, after appending the extension, the file name is really\n     * different.\n     */\n    if (fname != NULL && STRCMP(fname, retval) == 0)\n    {\n\t/* we search for a character that can be replaced by '_' */\n\twhile (--s >= ptr)\n\t{\n\t    if (*s != '_')\n\t    {\n\t\t*s = '_';\n\t\tbreak;\n\t    }\n\t}\n\tif (s < ptr)\t/* fname was \"________.<ext>\", how tricky! */\n\t    *ptr = 'v';\n    }\n    return retval;\n}\n\n/*\n * Like fgets(), but if the file line is too long, it is truncated and the\n * rest of the line is thrown away.  Returns TRUE for end-of-file.\n */\n    int\nvim_fgets(char_u *buf, int size, FILE *fp)\n{\n    char\t*eof;\n#define FGETS_SIZE 200\n    char\ttbuf[FGETS_SIZE];\n\n    buf[size - 2] = NUL;\n#ifdef USE_CR\n    eof = fgets_cr((char *)buf, size, fp);\n#else\n    eof = fgets((char *)buf, size, fp);\n#endif\n    if (buf[size - 2] != NUL && buf[size - 2] != '\\n')\n    {\n\tbuf[size - 1] = NUL;\t    /* Truncate the line */\n\n\t/* Now throw away the rest of the line: */\n\tdo\n\t{\n\t    tbuf[FGETS_SIZE - 2] = NUL;\n#ifdef USE_CR\n\t    ignoredp = fgets_cr((char *)tbuf, FGETS_SIZE, fp);\n#else\n\t    ignoredp = fgets((char *)tbuf, FGETS_SIZE, fp);\n#endif\n\t} while (tbuf[FGETS_SIZE - 2] != NUL && tbuf[FGETS_SIZE - 2] != '\\n');\n    }\n    return (eof == NULL);\n}\n\n#if defined(USE_CR) || defined(PROTO)\n/*\n * Like vim_fgets(), but accept any line terminator: CR, CR-LF or LF.\n * Returns TRUE for end-of-file.\n * Only used for the Mac, because it's much slower than vim_fgets().\n */\n    int\ntag_fgets(char_u *buf, int size, FILE *fp)\n{\n    int\t\ti = 0;\n    int\t\tc;\n    int\t\teof = FALSE;\n\n    for (;;)\n    {\n\tc = fgetc(fp);\n\tif (c == EOF)\n\t{\n\t    eof = TRUE;\n\t    break;\n\t}\n\tif (c == '\\r')\n\t{\n\t    /* Always store a NL for end-of-line. */\n\t    if (i < size - 1)\n\t\tbuf[i++] = '\\n';\n\t    c = fgetc(fp);\n\t    if (c != '\\n')\t/* Macintosh format: single CR. */\n\t\tungetc(c, fp);\n\t    break;\n\t}\n\tif (i < size - 1)\n\t    buf[i++] = c;\n\tif (c == '\\n')\n\t    break;\n    }\n    buf[i] = NUL;\n    return eof;\n}\n#endif\n\n/*\n * rename() only works if both files are on the same file system, this\n * function will (attempts to?) copy the file across if rename fails -- webb\n * Return -1 for failure, 0 for success.\n */\n    int\nvim_rename(char_u *from, char_u *to)\n{\n    int\t\tfd_in;\n    int\t\tfd_out;\n    int\t\tn;\n    char\t*errmsg = NULL;\n    char\t*buffer;\n#ifdef AMIGA\n    BPTR\tflock;\n#endif\n    stat_T\tst;\n    long\tperm;\n#ifdef HAVE_ACL\n    vim_acl_T\tacl;\t\t/* ACL from original file */\n#endif\n    int\t\tuse_tmp_file = FALSE;\n\n    /*\n     * When the names are identical, there is nothing to do.  When they refer\n     * to the same file (ignoring case and slash/backslash differences) but\n     * the file name differs we need to go through a temp file.\n     */\n    if (fnamecmp(from, to) == 0)\n    {\n\tif (p_fic && STRCMP(gettail(from), gettail(to)) != 0)\n\t    use_tmp_file = TRUE;\n\telse\n\t    return 0;\n    }\n\n    /*\n     * Fail if the \"from\" file doesn't exist.  Avoids that \"to\" is deleted.\n     */\n    if (mch_stat((char *)from, &st) < 0)\n\treturn -1;\n\n#ifdef UNIX\n    {\n\tstat_T\tst_to;\n\n\t/* It's possible for the source and destination to be the same file.\n\t * This happens when \"from\" and \"to\" differ in case and are on a FAT32\n\t * filesystem.  In that case go through a temp file name. */\n\tif (mch_stat((char *)to, &st_to) >= 0\n\t\t&& st.st_dev == st_to.st_dev\n\t\t&& st.st_ino == st_to.st_ino)\n\t    use_tmp_file = TRUE;\n    }\n#endif\n#ifdef WIN3264\n    {\n\tBY_HANDLE_FILE_INFORMATION info1, info2;\n\n\t/* It's possible for the source and destination to be the same file.\n\t * In that case go through a temp file name.  This makes rename(\"foo\",\n\t * \"./foo\") a no-op (in a complicated way). */\n\tif (win32_fileinfo(from, &info1) == FILEINFO_OK\n\t\t&& win32_fileinfo(to, &info2) == FILEINFO_OK\n\t\t&& info1.dwVolumeSerialNumber == info2.dwVolumeSerialNumber\n\t\t&& info1.nFileIndexHigh == info2.nFileIndexHigh\n\t\t&& info1.nFileIndexLow == info2.nFileIndexLow)\n\t    use_tmp_file = TRUE;\n    }\n#endif\n\n    if (use_tmp_file)\n    {\n\tchar\ttempname[MAXPATHL + 1];\n\n\t/*\n\t * Find a name that doesn't exist and is in the same directory.\n\t * Rename \"from\" to \"tempname\" and then rename \"tempname\" to \"to\".\n\t */\n\tif (STRLEN(from) >= MAXPATHL - 5)\n\t    return -1;\n\tSTRCPY(tempname, from);\n\tfor (n = 123; n < 99999; ++n)\n\t{\n\t    sprintf((char *)gettail((char_u *)tempname), \"%d\", n);\n\t    if (mch_stat(tempname, &st) < 0)\n\t    {\n\t\tif (mch_rename((char *)from, tempname) == 0)\n\t\t{\n\t\t    if (mch_rename(tempname, (char *)to) == 0)\n\t\t\treturn 0;\n\t\t    /* Strange, the second step failed.  Try moving the\n\t\t     * file back and return failure. */\n\t\t    mch_rename(tempname, (char *)from);\n\t\t    return -1;\n\t\t}\n\t\t/* If it fails for one temp name it will most likely fail\n\t\t * for any temp name, give up. */\n\t\treturn -1;\n\t    }\n\t}\n\treturn -1;\n    }\n\n    /*\n     * Delete the \"to\" file, this is required on some systems to make the\n     * mch_rename() work, on other systems it makes sure that we don't have\n     * two files when the mch_rename() fails.\n     */\n\n#ifdef AMIGA\n    /*\n     * With MSDOS-compatible filesystems (crossdos, messydos) it is possible\n     * that the name of the \"to\" file is the same as the \"from\" file, even\n     * though the names are different. To avoid the chance of accidentally\n     * deleting the \"from\" file (horror!) we lock it during the remove.\n     *\n     * When used for making a backup before writing the file: This should not\n     * happen with \":w\", because startscript() should detect this problem and\n     * set buf->b_shortname, causing modname() to return a correct \".bak\" file\n     * name.  This problem does exist with \":w filename\", but then the\n     * original file will be somewhere else so the backup isn't really\n     * important. If autoscripting is off the rename may fail.\n     */\n    flock = Lock((UBYTE *)from, (long)ACCESS_READ);\n#endif\n    mch_remove(to);\n#ifdef AMIGA\n    if (flock)\n\tUnLock(flock);\n#endif\n\n    /*\n     * First try a normal rename, return if it works.\n     */\n    if (mch_rename((char *)from, (char *)to) == 0)\n\treturn 0;\n\n    /*\n     * Rename() failed, try copying the file.\n     */\n    perm = mch_getperm(from);\n#ifdef HAVE_ACL\n    /* For systems that support ACL: get the ACL from the original file. */\n    acl = mch_get_acl(from);\n#endif\n    fd_in = mch_open((char *)from, O_RDONLY|O_EXTRA, 0);\n    if (fd_in == -1)\n    {\n#ifdef HAVE_ACL\n\tmch_free_acl(acl);\n#endif\n\treturn -1;\n    }\n\n    /* Create the new file with same permissions as the original. */\n    fd_out = mch_open((char *)to,\n\t\t       O_CREAT|O_EXCL|O_WRONLY|O_EXTRA|O_NOFOLLOW, (int)perm);\n    if (fd_out == -1)\n    {\n\tclose(fd_in);\n#ifdef HAVE_ACL\n\tmch_free_acl(acl);\n#endif\n\treturn -1;\n    }\n\n    buffer = (char *)alloc(BUFSIZE);\n    if (buffer == NULL)\n    {\n\tclose(fd_out);\n\tclose(fd_in);\n#ifdef HAVE_ACL\n\tmch_free_acl(acl);\n#endif\n\treturn -1;\n    }\n\n    while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)\n\tif (write_eintr(fd_out, buffer, n) != n)\n\t{\n\t    errmsg = _(\"E208: Error writing to \\\"%s\\\"\");\n\t    break;\n\t}\n\n    vim_free(buffer);\n    close(fd_in);\n    if (close(fd_out) < 0)\n\terrmsg = _(\"E209: Error closing \\\"%s\\\"\");\n    if (n < 0)\n    {\n\terrmsg = _(\"E210: Error reading \\\"%s\\\"\");\n\tto = from;\n    }\n#ifndef UNIX\t    /* for Unix mch_open() already set the permission */\n    mch_setperm(to, perm);\n#endif\n#ifdef HAVE_ACL\n    mch_set_acl(to, acl);\n    mch_free_acl(acl);\n#endif\n#if defined(HAVE_SELINUX) || defined(HAVE_SMACK)\n    mch_copy_sec(from, to);\n#endif\n    if (errmsg != NULL)\n    {\n\tEMSG2(errmsg, to);\n\treturn -1;\n    }\n    mch_remove(from);\n    return 0;\n}\n\nstatic int already_warned = FALSE;\n\n/*\n * Check if any not hidden buffer has been changed.\n * Postpone the check if there are characters in the stuff buffer, a global\n * command is being executed, a mapping is being executed or an autocommand is\n * busy.\n * Returns TRUE if some message was written (screen should be redrawn and\n * cursor positioned).\n */\n    int\ncheck_timestamps(\n    int\t\tfocus)\t\t/* called for GUI focus event */\n{\n    buf_T\t*buf;\n    int\t\tdidit = 0;\n    int\t\tn;\n\n    /* Don't check timestamps while system() or another low-level function may\n     * cause us to lose and gain focus. */\n    if (no_check_timestamps > 0)\n\treturn FALSE;\n\n    /* Avoid doing a check twice.  The OK/Reload dialog can cause a focus\n     * event and we would keep on checking if the file is steadily growing.\n     * Do check again after typing something. */\n    if (focus && did_check_timestamps)\n    {\n\tneed_check_timestamps = TRUE;\n\treturn FALSE;\n    }\n\n    if (!stuff_empty() || global_busy || !typebuf_typed()\n#ifdef FEAT_AUTOCMD\n\t\t\t|| autocmd_busy || curbuf_lock > 0 || allbuf_lock > 0\n#endif\n\t\t\t\t\t)\n\tneed_check_timestamps = TRUE;\t\t/* check later */\n    else\n    {\n\t++no_wait_return;\n\tdid_check_timestamps = TRUE;\n\talready_warned = FALSE;\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    /* Only check buffers in a window. */\n\t    if (buf->b_nwindows > 0)\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tn = buf_check_timestamp(buf, focus);\n\t\tif (didit < n)\n\t\t    didit = n;\n\t\tif (n > 0 && !bufref_valid(&bufref))\n\t\t{\n\t\t    /* Autocommands have removed the buffer, start at the\n\t\t     * first one again. */\n\t\t    buf = firstbuf;\n\t\t    continue;\n\t\t}\n\t    }\n\t}\n\t--no_wait_return;\n\tneed_check_timestamps = FALSE;\n\tif (need_wait_return && didit == 2)\n\t{\n\t    /* make sure msg isn't overwritten */\n\t    msg_puts((char_u *)\"\\n\");\n\t    out_flush();\n\t}\n    }\n    return didit;\n}\n\n/*\n * Move all the lines from buffer \"frombuf\" to buffer \"tobuf\".\n * Return OK or FAIL.  When FAIL \"tobuf\" is incomplete and/or \"frombuf\" is not\n * empty.\n */\n    static int\nmove_lines(buf_T *frombuf, buf_T *tobuf)\n{\n    buf_T\t*tbuf = curbuf;\n    int\t\tretval = OK;\n    linenr_T\tlnum;\n    char_u\t*p;\n\n    /* Copy the lines in \"frombuf\" to \"tobuf\". */\n    curbuf = tobuf;\n    for (lnum = 1; lnum <= frombuf->b_ml.ml_line_count; ++lnum)\n    {\n\tp = vim_strsave(ml_get_buf(frombuf, lnum, FALSE));\n\tif (p == NULL || ml_append(lnum - 1, p, 0, FALSE) == FAIL)\n\t{\n\t    vim_free(p);\n\t    retval = FAIL;\n\t    break;\n\t}\n\tvim_free(p);\n    }\n\n    /* Delete all the lines in \"frombuf\". */\n    if (retval != FAIL)\n    {\n\tcurbuf = frombuf;\n\tfor (lnum = curbuf->b_ml.ml_line_count; lnum > 0; --lnum)\n\t    if (ml_delete(lnum, FALSE) == FAIL)\n\t    {\n\t\t/* Oops!  We could try putting back the saved lines, but that\n\t\t * might fail again... */\n\t\tretval = FAIL;\n\t\tbreak;\n\t    }\n    }\n\n    curbuf = tbuf;\n    return retval;\n}\n\n/*\n * Check if buffer \"buf\" has been changed.\n * Also check if the file for a new buffer unexpectedly appeared.\n * return 1 if a changed buffer was found.\n * return 2 if a message has been displayed.\n * return 0 otherwise.\n */\n    int\nbuf_check_timestamp(\n    buf_T\t*buf,\n    int\t\tfocus UNUSED)\t/* called for GUI focus event */\n{\n    stat_T\tst;\n    int\t\tstat_res;\n    int\t\tretval = 0;\n    char_u\t*path;\n    char_u\t*tbuf;\n    char\t*mesg = NULL;\n    char\t*mesg2 = \"\";\n    int\t\thelpmesg = FALSE;\n    int\t\treload = FALSE;\n    char\t*reason;\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n    int\t\tcan_reload = FALSE;\n#endif\n    off_T\torig_size = buf->b_orig_size;\n    int\t\torig_mode = buf->b_orig_mode;\n#ifdef FEAT_GUI\n    int\t\tsave_mouse_correct = need_mouse_correct;\n#endif\n#ifdef FEAT_AUTOCMD\n    static int\tbusy = FALSE;\n    int\t\tn;\n    char_u\t*s;\n    bufref_T\tbufref;\n\n    set_bufref(&bufref, buf);\n#endif\n\n    /* If there is no file name, the buffer is not loaded, 'buftype' is\n     * set, we are in the middle of a save or being called recursively: ignore\n     * this buffer. */\n    if (buf->b_ffname == NULL\n\t    || buf->b_ml.ml_mfp == NULL\n\t    || *buf->b_p_bt != NUL\n\t    || buf->b_saving\n#ifdef FEAT_AUTOCMD\n\t    || busy\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t    || isNetbeansBuffer(buf)\n#endif\n#ifdef FEAT_TERMINAL\n\t    || buf->b_term != NULL\n#endif\n\t    )\n\treturn 0;\n\n    if (       !(buf->b_flags & BF_NOTEDITED)\n\t    && buf->b_mtime != 0\n\t    && ((stat_res = mch_stat((char *)buf->b_ffname, &st)) < 0\n\t\t|| time_differs((long)st.st_mtime, buf->b_mtime)\n\t\t|| st.st_size != buf->b_orig_size\n#ifdef HAVE_ST_MODE\n\t\t|| (int)st.st_mode != buf->b_orig_mode\n#else\n\t\t|| mch_getperm(buf->b_ffname) != buf->b_orig_mode\n#endif\n\t\t))\n    {\n\tretval = 1;\n\n\t/* set b_mtime to stop further warnings (e.g., when executing\n\t * FileChangedShell autocmd) */\n\tif (stat_res < 0)\n\t{\n\t    buf->b_mtime = 0;\n\t    buf->b_orig_size = 0;\n\t    buf->b_orig_mode = 0;\n\t}\n\telse\n\t    buf_store_time(buf, &st, buf->b_ffname);\n\n\t/* Don't do anything for a directory.  Might contain the file\n\t * explorer. */\n\tif (mch_isdir(buf->b_fname))\n\t    ;\n\n\t/*\n\t * If 'autoread' is set, the buffer has no changes and the file still\n\t * exists, reload the buffer.  Use the buffer-local option value if it\n\t * was set, the global option value otherwise.\n\t */\n\telse if ((buf->b_p_ar >= 0 ? buf->b_p_ar : p_ar)\n\t\t\t\t       && !bufIsChanged(buf) && stat_res >= 0)\n\t    reload = TRUE;\n\telse\n\t{\n\t    if (stat_res < 0)\n\t\treason = \"deleted\";\n\t    else if (bufIsChanged(buf))\n\t\treason = \"conflict\";\n\t    else if (orig_size != buf->b_orig_size || buf_contents_changed(buf))\n\t\treason = \"changed\";\n\t    else if (orig_mode != buf->b_orig_mode)\n\t\treason = \"mode\";\n\t    else\n\t\treason = \"time\";\n\n#ifdef FEAT_AUTOCMD\n\t    /*\n\t     * Only give the warning if there are no FileChangedShell\n\t     * autocommands.\n\t     * Avoid being called recursively by setting \"busy\".\n\t     */\n\t    busy = TRUE;\n# ifdef FEAT_EVAL\n\t    set_vim_var_string(VV_FCS_REASON, (char_u *)reason, -1);\n\t    set_vim_var_string(VV_FCS_CHOICE, (char_u *)\"\", -1);\n# endif\n\t    ++allbuf_lock;\n\t    n = apply_autocmds(EVENT_FILECHANGEDSHELL,\n\t\t\t\t      buf->b_fname, buf->b_fname, FALSE, buf);\n\t    --allbuf_lock;\n\t    busy = FALSE;\n\t    if (n)\n\t    {\n\t\tif (!bufref_valid(&bufref))\n\t\t    EMSG(_(\"E246: FileChangedShell autocommand deleted buffer\"));\n# ifdef FEAT_EVAL\n\t\ts = get_vim_var_str(VV_FCS_CHOICE);\n\t\tif (STRCMP(s, \"reload\") == 0 && *reason != 'd')\n\t\t    reload = TRUE;\n\t\telse if (STRCMP(s, \"ask\") == 0)\n\t\t    n = FALSE;\n\t\telse\n# endif\n\t\t    return 2;\n\t    }\n\t    if (!n)\n#endif\n\t    {\n\t\tif (*reason == 'd')\n\t\t    mesg = _(\"E211: File \\\"%s\\\" no longer available\");\n\t\telse\n\t\t{\n\t\t    helpmesg = TRUE;\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\t\t    can_reload = TRUE;\n#endif\n\t\t    /*\n\t\t     * Check if the file contents really changed to avoid\n\t\t     * giving a warning when only the timestamp was set (e.g.,\n\t\t     * checked out of CVS).  Always warn when the buffer was\n\t\t     * changed.\n\t\t     */\n\t\t    if (reason[2] == 'n')\n\t\t    {\n\t\t\tmesg = _(\"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");\n\t\t\tmesg2 = _(\"See \\\":help W12\\\" for more info.\");\n\t\t    }\n\t\t    else if (reason[1] == 'h')\n\t\t    {\n\t\t\tmesg = _(\"W11: Warning: File \\\"%s\\\" has changed since editing started\");\n\t\t\tmesg2 = _(\"See \\\":help W11\\\" for more info.\");\n\t\t    }\n\t\t    else if (*reason == 'm')\n\t\t    {\n\t\t\tmesg = _(\"W16: Warning: Mode of file \\\"%s\\\" has changed since editing started\");\n\t\t\tmesg2 = _(\"See \\\":help W16\\\" for more info.\");\n\t\t    }\n\t\t    else\n\t\t\t/* Only timestamp changed, store it to avoid a warning\n\t\t\t * in check_mtime() later. */\n\t\t\tbuf->b_mtime_read = buf->b_mtime;\n\t\t}\n\t    }\n\t}\n\n    }\n    else if ((buf->b_flags & BF_NEW) && !(buf->b_flags & BF_NEW_W)\n\t\t\t\t\t\t&& vim_fexists(buf->b_ffname))\n    {\n\tretval = 1;\n\tmesg = _(\"W13: Warning: File \\\"%s\\\" has been created after editing started\");\n\tbuf->b_flags |= BF_NEW_W;\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\tcan_reload = TRUE;\n#endif\n    }\n\n    if (mesg != NULL)\n    {\n\tpath = home_replace_save(buf, buf->b_fname);\n\tif (path != NULL)\n\t{\n\t    if (!helpmesg)\n\t\tmesg2 = \"\";\n\t    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)\n\t\t\t\t\t\t\t+ STRLEN(mesg2) + 2));\n\t    sprintf((char *)tbuf, mesg, path);\n#ifdef FEAT_EVAL\n\t    /* Set warningmsg here, before the unimportant and output-specific\n\t     * mesg2 has been appended. */\n\t    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);\n#endif\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\t    if (can_reload)\n\t    {\n\t\tif (*mesg2 != NUL)\n\t\t{\n\t\t    STRCAT(tbuf, \"\\n\");\n\t\t    STRCAT(tbuf, mesg2);\n\t\t}\n\t\tif (do_dialog(VIM_WARNING, (char_u *)_(\"Warning\"), tbuf,\n\t\t\t  (char_u *)_(\"&OK\\n&Load File\"), 1, NULL, TRUE) == 2)\n\t\t    reload = TRUE;\n\t    }\n\t    else\n#endif\n\t    if (State > NORMAL_BUSY || (State & CMDLINE) || already_warned)\n\t    {\n\t\tif (*mesg2 != NUL)\n\t\t{\n\t\t    STRCAT(tbuf, \"; \");\n\t\t    STRCAT(tbuf, mesg2);\n\t\t}\n\t\tEMSG(tbuf);\n\t\tretval = 2;\n\t    }\n\t    else\n\t    {\n# ifdef FEAT_AUTOCMD\n\t\tif (!autocmd_busy)\n# endif\n\t\t{\n\t\t    msg_start();\n\t\t    msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);\n\t\t    if (*mesg2 != NUL)\n\t\t\tmsg_puts_attr((char_u *)mesg2,\n\t\t\t\t\t\t   HL_ATTR(HLF_W) + MSG_HIST);\n\t\t    msg_clr_eos();\n\t\t    (void)msg_end();\n\t\t    if (emsg_silent == 0)\n\t\t    {\n\t\t\tout_flush();\n# ifdef FEAT_GUI\n\t\t\tif (!focus)\n# endif\n\t\t\t    /* give the user some time to think about it */\n\t\t\t    ui_delay(1000L, TRUE);\n\n\t\t\t/* don't redraw and erase the message */\n\t\t\tredraw_cmdline = FALSE;\n\t\t    }\n\t\t}\n\t\talready_warned = TRUE;\n\t    }\n\n\t    vim_free(path);\n\t    vim_free(tbuf);\n\t}\n    }\n\n    if (reload)\n    {\n\t/* Reload the buffer. */\n\tbuf_reload(buf, orig_mode);\n#ifdef FEAT_PERSISTENT_UNDO\n\tif (buf->b_p_udf && buf->b_ffname != NULL)\n\t{\n\t    char_u\t    hash[UNDO_HASH_SIZE];\n\t    buf_T\t    *save_curbuf = curbuf;\n\n\t    /* Any existing undo file is unusable, write it now. */\n\t    curbuf = buf;\n\t    u_compute_hash(hash);\n\t    u_write_undo(NULL, FALSE, buf, hash);\n\t    curbuf = save_curbuf;\n\t}\n#endif\n    }\n\n#ifdef FEAT_AUTOCMD\n    /* Trigger FileChangedShell when the file was changed in any way. */\n    if (bufref_valid(&bufref) && retval != 0)\n\t(void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST,\n\t\t\t\t      buf->b_fname, buf->b_fname, FALSE, buf);\n#endif\n#ifdef FEAT_GUI\n    /* restore this in case an autocommand has set it; it would break\n     * 'mousefocus' */\n    need_mouse_correct = save_mouse_correct;\n#endif\n\n    return retval;\n}\n\n/*\n * Reload a buffer that is already loaded.\n * Used when the file was changed outside of Vim.\n * \"orig_mode\" is buf->b_orig_mode before the need for reloading was detected.\n * buf->b_orig_mode may have been reset already.\n */\n    void\nbuf_reload(buf_T *buf, int orig_mode)\n{\n    exarg_T\tea;\n    pos_T\told_cursor;\n    linenr_T\told_topline;\n    int\t\told_ro = buf->b_p_ro;\n    buf_T\t*savebuf;\n    bufref_T\tbufref;\n    int\t\tsaved = OK;\n    aco_save_T\taco;\n    int\t\tflags = READ_NEW;\n\n    /* set curwin/curbuf for \"buf\" and save some things */\n    aucmd_prepbuf(&aco, buf);\n\n    /* We only want to read the text from the file, not reset the syntax\n     * highlighting, clear marks, diff status, etc.  Force the fileformat\n     * and encoding to be the same. */\n    if (prep_exarg(&ea, buf) == OK)\n    {\n\told_cursor = curwin->w_cursor;\n\told_topline = curwin->w_topline;\n\n\tif (p_ur < 0 || curbuf->b_ml.ml_line_count <= p_ur)\n\t{\n\t    /* Save all the text, so that the reload can be undone.\n\t     * Sync first so that this is a separate undo-able action. */\n\t    u_sync(FALSE);\n\t    saved = u_savecommon(0, curbuf->b_ml.ml_line_count + 1, 0, TRUE);\n\t    flags |= READ_KEEP_UNDO;\n\t}\n\n\t/*\n\t * To behave like when a new file is edited (matters for\n\t * BufReadPost autocommands) we first need to delete the current\n\t * buffer contents.  But if reading the file fails we should keep\n\t * the old contents.  Can't use memory only, the file might be\n\t * too big.  Use a hidden buffer to move the buffer contents to.\n\t */\n\tif (BUFEMPTY() || saved == FAIL)\n\t    savebuf = NULL;\n\telse\n\t{\n\t    /* Allocate a buffer without putting it in the buffer list. */\n\t    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n\t    set_bufref(&bufref, savebuf);\n\t    if (savebuf != NULL && buf == curbuf)\n\t    {\n\t\t/* Open the memline. */\n\t\tcurbuf = savebuf;\n\t\tcurwin->w_buffer = savebuf;\n\t\tsaved = ml_open(curbuf);\n\t\tcurbuf = buf;\n\t\tcurwin->w_buffer = buf;\n\t    }\n\t    if (savebuf == NULL || saved == FAIL || buf != curbuf\n\t\t\t\t      || move_lines(buf, savebuf) == FAIL)\n\t    {\n\t\tEMSG2(_(\"E462: Could not prepare for reloading \\\"%s\\\"\"),\n\t\t\t\t\t\t\t    buf->b_fname);\n\t\tsaved = FAIL;\n\t    }\n\t}\n\n\tif (saved == OK)\n\t{\n\t    curbuf->b_flags |= BF_CHECK_RO;\t/* check for RO again */\n#ifdef FEAT_AUTOCMD\n\t    keep_filetype = TRUE;\t\t/* don't detect 'filetype' */\n#endif\n\t    if (readfile(buf->b_ffname, buf->b_fname, (linenr_T)0,\n\t\t\t(linenr_T)0,\n\t\t\t(linenr_T)MAXLNUM, &ea, flags) != OK)\n\t    {\n#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)\n\t\tif (!aborting())\n#endif\n\t\t    EMSG2(_(\"E321: Could not reload \\\"%s\\\"\"), buf->b_fname);\n\t\tif (savebuf != NULL && bufref_valid(&bufref) && buf == curbuf)\n\t\t{\n\t\t    /* Put the text back from the save buffer.  First\n\t\t     * delete any lines that readfile() added. */\n\t\t    while (!BUFEMPTY())\n\t\t\tif (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)\n\t\t\t    break;\n\t\t    (void)move_lines(savebuf, buf);\n\t\t}\n\t    }\n\t    else if (buf == curbuf)  /* \"buf\" still valid */\n\t    {\n\t\t/* Mark the buffer as unmodified and free undo info. */\n\t\tunchanged(buf, TRUE);\n\t\tif ((flags & READ_KEEP_UNDO) == 0)\n\t\t{\n\t\t    u_blockfree(buf);\n\t\t    u_clearall(buf);\n\t\t}\n\t\telse\n\t\t{\n\t\t    /* Mark all undo states as changed. */\n\t\t    u_unchanged(curbuf);\n\t\t}\n\t    }\n\t}\n\tvim_free(ea.cmd);\n\n\tif (savebuf != NULL && bufref_valid(&bufref))\n\t    wipe_buffer(savebuf, FALSE);\n\n#ifdef FEAT_DIFF\n\t/* Invalidate diff info if necessary. */\n\tdiff_invalidate(curbuf);\n#endif\n\n\t/* Restore the topline and cursor position and check it (lines may\n\t * have been removed). */\n\tif (old_topline > curbuf->b_ml.ml_line_count)\n\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_topline = old_topline;\n\tcurwin->w_cursor = old_cursor;\n\tcheck_cursor();\n\tupdate_topline();\n#ifdef FEAT_AUTOCMD\n\tkeep_filetype = FALSE;\n#endif\n#ifdef FEAT_FOLDING\n\t{\n\t    win_T\t*wp;\n\t    tabpage_T\t*tp;\n\n\t    /* Update folds unless they are defined manually. */\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\tif (wp->w_buffer == curwin->w_buffer\n\t\t\t&& !foldmethodIsManual(wp))\n\t\t    foldUpdateAll(wp);\n\t}\n#endif\n\t/* If the mode didn't change and 'readonly' was set, keep the old\n\t * value; the user probably used the \":view\" command.  But don't\n\t * reset it, might have had a read error. */\n\tif (orig_mode == curbuf->b_orig_mode)\n\t    curbuf->b_p_ro |= old_ro;\n\n\t/* Modelines must override settings done by autocommands. */\n\tdo_modelines(0);\n    }\n\n    /* restore curwin/curbuf and a few other things */\n    aucmd_restbuf(&aco);\n    /* Careful: autocommands may have made \"buf\" invalid! */\n}\n\n    void\nbuf_store_time(buf_T *buf, stat_T *st, char_u *fname UNUSED)\n{\n    buf->b_mtime = (long)st->st_mtime;\n    buf->b_orig_size = st->st_size;\n#ifdef HAVE_ST_MODE\n    buf->b_orig_mode = (int)st->st_mode;\n#else\n    buf->b_orig_mode = mch_getperm(fname);\n#endif\n}\n\n/*\n * Adjust the line with missing eol, used for the next write.\n * Used for do_filter(), when the input lines for the filter are deleted.\n */\n    void\nwrite_lnum_adjust(linenr_T offset)\n{\n    if (curbuf->b_no_eol_lnum != 0)\t/* only if there is a missing eol */\n\tcurbuf->b_no_eol_lnum += offset;\n}\n\n#if defined(TEMPDIRNAMES) || defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Delete \"name\" and everything in it, recursively.\n * return 0 for succes, -1 if some file was not deleted.\n */\n    int\ndelete_recursive(char_u *name)\n{\n    int result = 0;\n    char_u\t**files;\n    int\t\tfile_count;\n    int\t\ti;\n    char_u\t*exp;\n\n    /* A symbolic link to a directory itself is deleted, not the directory it\n     * points to. */\n    if (\n# if defined(UNIX) || defined(WIN32)\n\t mch_isrealdir(name)\n# else\n\t mch_isdir(name)\n# endif\n\t    )\n    {\n\tvim_snprintf((char *)NameBuff, MAXPATHL, \"%s/*\", name);\n\texp = vim_strsave(NameBuff);\n\tif (exp == NULL)\n\t    return -1;\n\tif (gen_expand_wildcards(1, &exp, &file_count, &files,\n\t      EW_DIR|EW_FILE|EW_SILENT|EW_ALLLINKS|EW_DODOT|EW_EMPTYOK) == OK)\n\t{\n\t    for (i = 0; i < file_count; ++i)\n\t\tif (delete_recursive(files[i]) != 0)\n\t\t    result = -1;\n\t    FreeWild(file_count, files);\n\t}\n\telse\n\t    result = -1;\n\tvim_free(exp);\n\t(void)mch_rmdir(name);\n    }\n    else\n\tresult = mch_remove(name) == 0 ? 0 : -1;\n\n    return result;\n}\n#endif\n\n#if defined(TEMPDIRNAMES) || defined(PROTO)\nstatic long\ttemp_count = 0;\t\t/* Temp filename counter. */\n\n/*\n * Delete the temp directory and all files it contains.\n */\n    void\nvim_deltempdir(void)\n{\n    if (vim_tempdir != NULL)\n    {\n\t/* remove the trailing path separator */\n\tgettail(vim_tempdir)[-1] = NUL;\n\tdelete_recursive(vim_tempdir);\n\tvim_free(vim_tempdir);\n\tvim_tempdir = NULL;\n    }\n}\n\n/*\n * Directory \"tempdir\" was created.  Expand this name to a full path and put\n * it in \"vim_tempdir\".  This avoids that using \":cd\" would confuse us.\n * \"tempdir\" must be no longer than MAXPATHL.\n */\n    static void\nvim_settempdir(char_u *tempdir)\n{\n    char_u\t*buf;\n\n    buf = alloc((unsigned)MAXPATHL + 2);\n    if (buf != NULL)\n    {\n\tif (vim_FullName(tempdir, buf, MAXPATHL, FALSE) == FAIL)\n\t    STRCPY(buf, tempdir);\n\tadd_pathsep(buf);\n\tvim_tempdir = vim_strsave(buf);\n\tvim_free(buf);\n    }\n}\n#endif\n\n/*\n * vim_tempname(): Return a unique name that can be used for a temp file.\n *\n * The temp file is NOT guaranteed to be created.  If \"keep\" is FALSE it is\n * guaranteed to NOT be created.\n *\n * The returned pointer is to allocated memory.\n * The returned pointer is NULL if no valid name was found.\n */\n    char_u  *\nvim_tempname(\n    int\t    extra_char UNUSED,  /* char to use in the name instead of '?' */\n    int\t    keep UNUSED)\n{\n#ifdef USE_TMPNAM\n    char_u\titmp[L_tmpnam];\t/* use tmpnam() */\n#else\n    char_u\titmp[TEMPNAMELEN];\n#endif\n\n#ifdef TEMPDIRNAMES\n    static char\t*(tempdirs[]) = {TEMPDIRNAMES};\n    int\t\ti;\n# ifndef EEXIST\n    stat_T\tst;\n# endif\n\n    /*\n     * This will create a directory for private use by this instance of Vim.\n     * This is done once, and the same directory is used for all temp files.\n     * This method avoids security problems because of symlink attacks et al.\n     * It's also a bit faster, because we only need to check for an existing\n     * file when creating the directory and not for each temp file.\n     */\n    if (vim_tempdir == NULL)\n    {\n\t/*\n\t * Try the entries in TEMPDIRNAMES to create the temp directory.\n\t */\n\tfor (i = 0; i < (int)(sizeof(tempdirs) / sizeof(char *)); ++i)\n\t{\n# ifndef HAVE_MKDTEMP\n\t    size_t\titmplen;\n\t    long\tnr;\n\t    long\toff;\n# endif\n\n\t    /* Expand $TMP, leave room for \"/v1100000/999999999\".\n\t     * Skip the directory check if the expansion fails. */\n\t    expand_env((char_u *)tempdirs[i], itmp, TEMPNAMELEN - 20);\n\t    if (itmp[0] != '$' && mch_isdir(itmp))\n\t    {\n\t\t/* directory exists */\n\t\tadd_pathsep(itmp);\n\n# ifdef HAVE_MKDTEMP\n\t\t{\n#  if defined(UNIX) || defined(VMS)\n\t\t    /* Make sure the umask doesn't remove the executable bit.\n\t\t     * \"repl\" has been reported to use \"177\". */\n\t\t    mode_t\tumask_save = umask(077);\n#  endif\n\t\t    /* Leave room for filename */\n\t\t    STRCAT(itmp, \"vXXXXXX\");\n\t\t    if (mkdtemp((char *)itmp) != NULL)\n\t\t\tvim_settempdir(itmp);\n#  if defined(UNIX) || defined(VMS)\n\t\t    (void)umask(umask_save);\n#  endif\n\t\t}\n# else\n\t\t/* Get an arbitrary number of up to 6 digits.  When it's\n\t\t * unlikely that it already exists it will be faster,\n\t\t * otherwise it doesn't matter.  The use of mkdir() avoids any\n\t\t * security problems because of the predictable number. */\n\t\tnr = (mch_get_pid() + (long)time(NULL)) % 1000000L;\n\t\titmplen = STRLEN(itmp);\n\n\t\t/* Try up to 10000 different values until we find a name that\n\t\t * doesn't exist. */\n\t\tfor (off = 0; off < 10000L; ++off)\n\t\t{\n\t\t    int\t\tr;\n#  if defined(UNIX) || defined(VMS)\n\t\t    mode_t\tumask_save;\n#  endif\n\n\t\t    sprintf((char *)itmp + itmplen, \"v%ld\", nr + off);\n#  ifndef EEXIST\n\t\t    /* If mkdir() does not set errno to EEXIST, check for\n\t\t     * existing file here.  There is a race condition then,\n\t\t     * although it's fail-safe. */\n\t\t    if (mch_stat((char *)itmp, &st) >= 0)\n\t\t\tcontinue;\n#  endif\n#  if defined(UNIX) || defined(VMS)\n\t\t    /* Make sure the umask doesn't remove the executable bit.\n\t\t     * \"repl\" has been reported to use \"177\". */\n\t\t    umask_save = umask(077);\n#  endif\n\t\t    r = vim_mkdir(itmp, 0700);\n#  if defined(UNIX) || defined(VMS)\n\t\t    (void)umask(umask_save);\n#  endif\n\t\t    if (r == 0)\n\t\t    {\n\t\t\tvim_settempdir(itmp);\n\t\t\tbreak;\n\t\t    }\n#  ifdef EEXIST\n\t\t    /* If the mkdir() didn't fail because the file/dir exists,\n\t\t     * we probably can't create any dir here, try another\n\t\t     * place. */\n\t\t    if (errno != EEXIST)\n#  endif\n\t\t\tbreak;\n\t\t}\n# endif /* HAVE_MKDTEMP */\n\t\tif (vim_tempdir != NULL)\n\t\t    break;\n\t    }\n\t}\n    }\n\n    if (vim_tempdir != NULL)\n    {\n\t/* There is no need to check if the file exists, because we own the\n\t * directory and nobody else creates a file in it. */\n\tsprintf((char *)itmp, \"%s%ld\", vim_tempdir, temp_count++);\n\treturn vim_strsave(itmp);\n    }\n\n    return NULL;\n\n#else /* TEMPDIRNAMES */\n\n# ifdef WIN3264\n    char\tszTempFile[_MAX_PATH + 1];\n    char\tbuf4[4];\n    char_u\t*retval;\n    char_u\t*p;\n\n    STRCPY(itmp, \"\");\n    if (GetTempPath(_MAX_PATH, szTempFile) == 0)\n    {\n\tszTempFile[0] = '.';\t/* GetTempPath() failed, use current dir */\n\tszTempFile[1] = NUL;\n    }\n    strcpy(buf4, \"VIM\");\n    buf4[2] = extra_char;   /* make it \"VIa\", \"VIb\", etc. */\n    if (GetTempFileName(szTempFile, buf4, 0, (LPSTR)itmp) == 0)\n\treturn NULL;\n    if (!keep)\n\t/* GetTempFileName() will create the file, we don't want that */\n\t(void)DeleteFile((LPSTR)itmp);\n\n    /* Backslashes in a temp file name cause problems when filtering with\n     * \"sh\".  NOTE: This also checks 'shellcmdflag' to help those people who\n     * didn't set 'shellslash'. */\n    retval = vim_strsave(itmp);\n    if (*p_shcf == '-' || p_ssl)\n\tfor (p = retval; *p; ++p)\n\t    if (*p == '\\\\')\n\t\t*p = '/';\n    return retval;\n\n# else /* WIN3264 */\n\n#  ifdef USE_TMPNAM\n    char_u\t*p;\n\n    /* tmpnam() will make its own name */\n    p = tmpnam((char *)itmp);\n    if (p == NULL || *p == NUL)\n\treturn NULL;\n#  else\n    char_u\t*p;\n\n#   ifdef VMS_TEMPNAM\n    /* mktemp() is not working on VMS.  It seems to be\n     * a do-nothing function. Therefore we use tempnam().\n     */\n    sprintf((char *)itmp, \"VIM%c\", extra_char);\n    p = (char_u *)tempnam(\"tmp:\", (char *)itmp);\n    if (p != NULL)\n    {\n\t/* VMS will use '.LIS' if we don't explicitly specify an extension,\n\t * and VIM will then be unable to find the file later */\n\tSTRCPY(itmp, p);\n\tSTRCAT(itmp, \".txt\");\n\tfree(p);\n    }\n    else\n\treturn NULL;\n#   else\n    STRCPY(itmp, TEMPNAME);\n    if ((p = vim_strchr(itmp, '?')) != NULL)\n\t*p = extra_char;\n    if (mktemp((char *)itmp) == NULL)\n\treturn NULL;\n#   endif\n#  endif\n\n    return vim_strsave(itmp);\n# endif /* WIN3264 */\n#endif /* TEMPDIRNAMES */\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Convert all backslashes in fname to forward slashes in-place, unless when\n * it looks like a URL.\n */\n    void\nforward_slash(char_u *fname)\n{\n    char_u\t*p;\n\n    if (path_with_url(fname))\n\treturn;\n    for (p = fname; *p != NUL; ++p)\n# ifdef  FEAT_MBYTE\n\t/* The Big5 encoding can have '\\' in the trail byte. */\n\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) > 1)\n\t    ++p;\n\telse\n# endif\n\tif (*p == '\\\\')\n\t    *p = '/';\n}\n#endif\n\n\n/*\n * Code for automatic commands.\n *\n * Only included when \"FEAT_AUTOCMD\" has been defined.\n */\n\n#if defined(FEAT_AUTOCMD) || defined(PROTO)\n\n/*\n * The autocommands are stored in a list for each event.\n * Autocommands for the same pattern, that are consecutive, are joined\n * together, to avoid having to match the pattern too often.\n * The result is an array of Autopat lists, which point to AutoCmd lists:\n *\n * first_autopat[0] --> Autopat.next  -->  Autopat.next -->  NULL\n *\t\t\tAutopat.cmds\t   Autopat.cmds\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t   AutoCmd.next\n *\t\t\t    |\t\t\t |\n *\t\t\t    V\t\t\t V\n *\t\t\tAutoCmd.next\t\tNULL\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *\n * first_autopat[1] --> Autopat.next  -->  NULL\n *\t\t\tAutopat.cmds\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\tAutoCmd.next\n *\t\t\t    |\n *\t\t\t    V\n *\t\t\t   NULL\n *   etc.\n *\n *   The order of AutoCmds is important, this is the order in which they were\n *   defined and will have to be executed.\n */\ntypedef struct AutoCmd\n{\n    char_u\t    *cmd;\t\t/* The command to be executed (NULL\n\t\t\t\t\t   when command has been removed) */\n    char\t    nested;\t\t/* If autocommands nest here */\n    char\t    last;\t\t/* last command in list */\n#ifdef FEAT_EVAL\n    scid_T\t    scriptID;\t\t/* script ID where defined */\n#endif\n    struct AutoCmd  *next;\t\t/* Next AutoCmd in list */\n} AutoCmd;\n\ntypedef struct AutoPat\n{\n    char_u\t    *pat;\t\t/* pattern as typed (NULL when pattern\n\t\t\t\t\t   has been removed) */\n    regprog_T\t    *reg_prog;\t\t/* compiled regprog for pattern */\n    AutoCmd\t    *cmds;\t\t/* list of commands to do */\n    struct AutoPat  *next;\t\t/* next AutoPat in AutoPat list */\n    int\t\t    group;\t\t/* group ID */\n    int\t\t    patlen;\t\t/* strlen() of pat */\n    int\t\t    buflocal_nr;\t/* !=0 for buffer-local AutoPat */\n    char\t    allow_dirs;\t\t/* Pattern may match whole path */\n    char\t    last;\t\t/* last pattern for apply_autocmds() */\n} AutoPat;\n\nstatic struct event_name\n{\n    char\t*name;\t/* event name */\n    event_T\tevent;\t/* event number */\n} event_names[] =\n{\n    {\"BufAdd\",\t\tEVENT_BUFADD},\n    {\"BufCreate\",\tEVENT_BUFADD},\n    {\"BufDelete\",\tEVENT_BUFDELETE},\n    {\"BufEnter\",\tEVENT_BUFENTER},\n    {\"BufFilePost\",\tEVENT_BUFFILEPOST},\n    {\"BufFilePre\",\tEVENT_BUFFILEPRE},\n    {\"BufHidden\",\tEVENT_BUFHIDDEN},\n    {\"BufLeave\",\tEVENT_BUFLEAVE},\n    {\"BufNew\",\t\tEVENT_BUFNEW},\n    {\"BufNewFile\",\tEVENT_BUFNEWFILE},\n    {\"BufRead\",\t\tEVENT_BUFREADPOST},\n    {\"BufReadCmd\",\tEVENT_BUFREADCMD},\n    {\"BufReadPost\",\tEVENT_BUFREADPOST},\n    {\"BufReadPre\",\tEVENT_BUFREADPRE},\n    {\"BufUnload\",\tEVENT_BUFUNLOAD},\n    {\"BufWinEnter\",\tEVENT_BUFWINENTER},\n    {\"BufWinLeave\",\tEVENT_BUFWINLEAVE},\n    {\"BufWipeout\",\tEVENT_BUFWIPEOUT},\n    {\"BufWrite\",\tEVENT_BUFWRITEPRE},\n    {\"BufWritePost\",\tEVENT_BUFWRITEPOST},\n    {\"BufWritePre\",\tEVENT_BUFWRITEPRE},\n    {\"BufWriteCmd\",\tEVENT_BUFWRITECMD},\n    {\"CmdlineEnter\",\tEVENT_CMDLINEENTER},\n    {\"CmdlineLeave\",\tEVENT_CMDLINELEAVE},\n    {\"CmdwinEnter\",\tEVENT_CMDWINENTER},\n    {\"CmdwinLeave\",\tEVENT_CMDWINLEAVE},\n    {\"CmdUndefined\",\tEVENT_CMDUNDEFINED},\n    {\"ColorScheme\",\tEVENT_COLORSCHEME},\n    {\"CompleteDone\",\tEVENT_COMPLETEDONE},\n    {\"CursorHold\",\tEVENT_CURSORHOLD},\n    {\"CursorHoldI\",\tEVENT_CURSORHOLDI},\n    {\"CursorMoved\",\tEVENT_CURSORMOVED},\n    {\"CursorMovedI\",\tEVENT_CURSORMOVEDI},\n    {\"EncodingChanged\",\tEVENT_ENCODINGCHANGED},\n    {\"FileEncoding\",\tEVENT_ENCODINGCHANGED},\n    {\"FileAppendPost\",\tEVENT_FILEAPPENDPOST},\n    {\"FileAppendPre\",\tEVENT_FILEAPPENDPRE},\n    {\"FileAppendCmd\",\tEVENT_FILEAPPENDCMD},\n    {\"FileChangedShell\",EVENT_FILECHANGEDSHELL},\n    {\"FileChangedShellPost\",EVENT_FILECHANGEDSHELLPOST},\n    {\"FileChangedRO\",\tEVENT_FILECHANGEDRO},\n    {\"FileReadPost\",\tEVENT_FILEREADPOST},\n    {\"FileReadPre\",\tEVENT_FILEREADPRE},\n    {\"FileReadCmd\",\tEVENT_FILEREADCMD},\n    {\"FileType\",\tEVENT_FILETYPE},\n    {\"FileWritePost\",\tEVENT_FILEWRITEPOST},\n    {\"FileWritePre\",\tEVENT_FILEWRITEPRE},\n    {\"FileWriteCmd\",\tEVENT_FILEWRITECMD},\n    {\"FilterReadPost\",\tEVENT_FILTERREADPOST},\n    {\"FilterReadPre\",\tEVENT_FILTERREADPRE},\n    {\"FilterWritePost\",\tEVENT_FILTERWRITEPOST},\n    {\"FilterWritePre\",\tEVENT_FILTERWRITEPRE},\n    {\"FocusGained\",\tEVENT_FOCUSGAINED},\n    {\"FocusLost\",\tEVENT_FOCUSLOST},\n    {\"FuncUndefined\",\tEVENT_FUNCUNDEFINED},\n    {\"GUIEnter\",\tEVENT_GUIENTER},\n    {\"GUIFailed\",\tEVENT_GUIFAILED},\n    {\"InsertChange\",\tEVENT_INSERTCHANGE},\n    {\"InsertEnter\",\tEVENT_INSERTENTER},\n    {\"InsertLeave\",\tEVENT_INSERTLEAVE},\n    {\"InsertCharPre\",\tEVENT_INSERTCHARPRE},\n    {\"MenuPopup\",\tEVENT_MENUPOPUP},\n    {\"OptionSet\",\tEVENT_OPTIONSET},\n    {\"QuickFixCmdPost\",\tEVENT_QUICKFIXCMDPOST},\n    {\"QuickFixCmdPre\",\tEVENT_QUICKFIXCMDPRE},\n    {\"QuitPre\",\t\tEVENT_QUITPRE},\n    {\"RemoteReply\",\tEVENT_REMOTEREPLY},\n    {\"SessionLoadPost\",\tEVENT_SESSIONLOADPOST},\n    {\"ShellCmdPost\",\tEVENT_SHELLCMDPOST},\n    {\"ShellFilterPost\",\tEVENT_SHELLFILTERPOST},\n    {\"SourcePre\",\tEVENT_SOURCEPRE},\n    {\"SourceCmd\",\tEVENT_SOURCECMD},\n    {\"SpellFileMissing\",EVENT_SPELLFILEMISSING},\n    {\"StdinReadPost\",\tEVENT_STDINREADPOST},\n    {\"StdinReadPre\",\tEVENT_STDINREADPRE},\n    {\"SwapExists\",\tEVENT_SWAPEXISTS},\n    {\"Syntax\",\t\tEVENT_SYNTAX},\n    {\"TabNew\",\t\tEVENT_TABNEW},\n    {\"TabClosed\",\tEVENT_TABCLOSED},\n    {\"TabEnter\",\tEVENT_TABENTER},\n    {\"TabLeave\",\tEVENT_TABLEAVE},\n    {\"TermChanged\",\tEVENT_TERMCHANGED},\n    {\"TermResponse\",\tEVENT_TERMRESPONSE},\n    {\"TextChanged\",\tEVENT_TEXTCHANGED},\n    {\"TextChangedI\",\tEVENT_TEXTCHANGEDI},\n    {\"User\",\t\tEVENT_USER},\n    {\"VimEnter\",\tEVENT_VIMENTER},\n    {\"VimLeave\",\tEVENT_VIMLEAVE},\n    {\"VimLeavePre\",\tEVENT_VIMLEAVEPRE},\n    {\"WinNew\",\t\tEVENT_WINNEW},\n    {\"WinEnter\",\tEVENT_WINENTER},\n    {\"WinLeave\",\tEVENT_WINLEAVE},\n    {\"VimResized\",\tEVENT_VIMRESIZED},\n    {NULL,\t\t(event_T)0}\n};\n\nstatic AutoPat *first_autopat[NUM_EVENTS] =\n{\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL\n};\n\n/*\n * struct used to keep status while executing autocommands for an event.\n */\ntypedef struct AutoPatCmd\n{\n    AutoPat\t*curpat;\t/* next AutoPat to examine */\n    AutoCmd\t*nextcmd;\t/* next AutoCmd to execute */\n    int\t\tgroup;\t\t/* group being used */\n    char_u\t*fname;\t\t/* fname to match with */\n    char_u\t*sfname;\t/* sfname to match with */\n    char_u\t*tail;\t\t/* tail of fname */\n    event_T\tevent;\t\t/* current event */\n    int\t\targ_bufnr;\t/* initially equal to <abuf>, set to zero when\n\t\t\t\t   buf is deleted */\n    struct AutoPatCmd   *next;\t/* chain of active apc-s for auto-invalidation*/\n} AutoPatCmd;\n\nstatic AutoPatCmd *active_apc_list = NULL; /* stack of active autocommands */\n\n/*\n * augroups stores a list of autocmd group names.\n */\nstatic garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};\n#define AUGROUP_NAME(i) (((char_u **)augroups.ga_data)[i])\n/* use get_deleted_augroup() to get this */\nstatic char_u *deleted_augroup = NULL;\n\n/*\n * The ID of the current group.  Group 0 is the default one.\n */\nstatic int current_augroup = AUGROUP_DEFAULT;\n\nstatic int au_need_clean = FALSE;   /* need to delete marked patterns */\n\nstatic void show_autocmd(AutoPat *ap, event_T event);\nstatic void au_remove_pat(AutoPat *ap);\nstatic void au_remove_cmds(AutoPat *ap);\nstatic void au_cleanup(void);\nstatic int au_new_group(char_u *name);\nstatic void au_del_group(char_u *name);\nstatic event_T event_name2nr(char_u *start, char_u **end);\nstatic char_u *event_nr2name(event_T event);\nstatic char_u *find_end_event(char_u *arg, int have_group);\nstatic int event_ignored(event_T event);\nstatic int au_get_grouparg(char_u **argp);\nstatic int do_autocmd_event(event_T event, char_u *pat, int nested, char_u *cmd, int forceit, int group);\nstatic int apply_autocmds_group(event_T event, char_u *fname, char_u *fname_io, int force, int group, buf_T *buf, exarg_T *eap);\nstatic void auto_next_pat(AutoPatCmd *apc, int stop_at_last);\n#if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN)\nstatic int match_file_pat(char_u *pattern, regprog_T **prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs);\n#endif\n\n\nstatic event_T\tlast_event;\nstatic int\tlast_group;\nstatic int\tautocmd_blocked = 0;\t/* block all autocmds */\n\n    static char_u *\nget_deleted_augroup(void)\n{\n    if (deleted_augroup == NULL)\n\tdeleted_augroup = (char_u *)_(\"--Deleted--\");\n    return deleted_augroup;\n}\n\n/*\n * Show the autocommands for one AutoPat.\n */\n    static void\nshow_autocmd(AutoPat *ap, event_T event)\n{\n    AutoCmd *ac;\n\n    /* Check for \"got_int\" (here and at various places below), which is set\n     * when \"q\" has been hit for the \"--more--\" prompt */\n    if (got_int)\n\treturn;\n    if (ap->pat == NULL)\t\t/* pattern has been removed */\n\treturn;\n\n    msg_putchar('\\n');\n    if (got_int)\n\treturn;\n    if (event != last_event || ap->group != last_group)\n    {\n\tif (ap->group != AUGROUP_DEFAULT)\n\t{\n\t    if (AUGROUP_NAME(ap->group) == NULL)\n\t\tmsg_puts_attr(get_deleted_augroup(), HL_ATTR(HLF_E));\n\t    else\n\t\tmsg_puts_attr(AUGROUP_NAME(ap->group), HL_ATTR(HLF_T));\n\t    msg_puts((char_u *)\"  \");\n\t}\n\tmsg_puts_attr(event_nr2name(event), HL_ATTR(HLF_T));\n\tlast_event = event;\n\tlast_group = ap->group;\n\tmsg_putchar('\\n');\n\tif (got_int)\n\t    return;\n    }\n    msg_col = 4;\n    msg_outtrans(ap->pat);\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n    {\n\tif (ac->cmd != NULL)\t\t/* skip removed commands */\n\t{\n\t    if (msg_col >= 14)\n\t\tmsg_putchar('\\n');\n\t    msg_col = 14;\n\t    if (got_int)\n\t\treturn;\n\t    msg_outtrans(ac->cmd);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(ac->scriptID);\n#endif\n\t    if (got_int)\n\t\treturn;\n\t    if (ac->next != NULL)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tif (got_int)\n\t\t    return;\n\t    }\n\t}\n    }\n}\n\n/*\n * Mark an autocommand pattern for deletion.\n */\n    static void\nau_remove_pat(AutoPat *ap)\n{\n    vim_free(ap->pat);\n    ap->pat = NULL;\n    ap->buflocal_nr = -1;\n    au_need_clean = TRUE;\n}\n\n/*\n * Mark all commands for a pattern for deletion.\n */\n    static void\nau_remove_cmds(AutoPat *ap)\n{\n    AutoCmd *ac;\n\n    for (ac = ap->cmds; ac != NULL; ac = ac->next)\n    {\n\tvim_free(ac->cmd);\n\tac->cmd = NULL;\n    }\n    au_need_clean = TRUE;\n}\n\n/*\n * Cleanup autocommands and patterns that have been deleted.\n * This is only done when not executing autocommands.\n */\n    static void\nau_cleanup(void)\n{\n    AutoPat\t*ap, **prev_ap;\n    AutoCmd\t*ac, **prev_ac;\n    event_T\tevent;\n\n    if (autocmd_busy || !au_need_clean)\n\treturn;\n\n    /* loop over all events */\n    for (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n    {\n\t/* loop over all autocommand patterns */\n\tprev_ap = &(first_autopat[(int)event]);\n\tfor (ap = *prev_ap; ap != NULL; ap = *prev_ap)\n\t{\n\t    /* loop over all commands for this pattern */\n\t    prev_ac = &(ap->cmds);\n\t    for (ac = *prev_ac; ac != NULL; ac = *prev_ac)\n\t    {\n\t\t/* remove the command if the pattern is to be deleted or when\n\t\t * the command has been marked for deletion */\n\t\tif (ap->pat == NULL || ac->cmd == NULL)\n\t\t{\n\t\t    *prev_ac = ac->next;\n\t\t    vim_free(ac->cmd);\n\t\t    vim_free(ac);\n\t\t}\n\t\telse\n\t\t    prev_ac = &(ac->next);\n\t    }\n\n\t    /* remove the pattern if it has been marked for deletion */\n\t    if (ap->pat == NULL)\n\t    {\n\t\t*prev_ap = ap->next;\n\t\tvim_regfree(ap->reg_prog);\n\t\tvim_free(ap);\n\t    }\n\t    else\n\t\tprev_ap = &(ap->next);\n\t}\n    }\n\n    au_need_clean = FALSE;\n}\n\n/*\n * Called when buffer is freed, to remove/invalidate related buffer-local\n * autocmds.\n */\n    void\naubuflocal_remove(buf_T *buf)\n{\n    AutoPat\t*ap;\n    event_T\tevent;\n    AutoPatCmd\t*apc;\n\n    /* invalidate currently executing autocommands */\n    for (apc = active_apc_list; apc; apc = apc->next)\n\tif (buf->b_fnum == apc->arg_bufnr)\n\t    apc->arg_bufnr = 0;\n\n    /* invalidate buflocals looping through events */\n    for (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t/* loop over all autocommand patterns */\n\tfor (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\t    if (ap->buflocal_nr == buf->b_fnum)\n\t    {\n\t\tau_remove_pat(ap);\n\t\tif (p_verbose >= 6)\n\t\t{\n\t\t    verbose_enter();\n\t\t    smsg((char_u *)\n\t\t\t    _(\"auto-removing autocommand: %s <buffer=%d>\"),\n\t\t\t\t\t   event_nr2name(event), buf->b_fnum);\n\t\t    verbose_leave();\n\t\t}\n\t    }\n    au_cleanup();\n}\n\n/*\n * Add an autocmd group name.\n * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_new_group(char_u *name)\n{\n    int\t\ti;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t/* the group doesn't exist yet, add it */\n    {\n\t/* First try using a free entry. */\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t    if (AUGROUP_NAME(i) == NULL)\n\t\tbreak;\n\tif (i == augroups.ga_len && ga_grow(&augroups, 1) == FAIL)\n\t    return AUGROUP_ERROR;\n\n\tAUGROUP_NAME(i) = vim_strsave(name);\n\tif (AUGROUP_NAME(i) == NULL)\n\t    return AUGROUP_ERROR;\n\tif (i == augroups.ga_len)\n\t    ++augroups.ga_len;\n    }\n\n    return i;\n}\n\n    static void\nau_del_group(char_u *name)\n{\n    int\t    i;\n\n    i = au_find_group(name);\n    if (i == AUGROUP_ERROR)\t/* the group doesn't exist */\n\tEMSG2(_(\"E367: No such group: \\\"%s\\\"\"), name);\n    else if (i == current_augroup)\n\tEMSG(_(\"E936: Cannot delete the current group\"));\n    else\n    {\n\tevent_T\tevent;\n\tAutoPat\t*ap;\n\tint\tin_use = FALSE;\n\n\tfor (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t{\n\t    for (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\t\tif (ap->group == i && ap->pat != NULL)\n\t\t{\n\t\t    give_warning((char_u *)_(\"W19: Deleting augroup that is still in use\"), TRUE);\n\t\t    in_use = TRUE;\n\t\t    event = NUM_EVENTS;\n\t\t    break;\n\t\t}\n\t}\n\tvim_free(AUGROUP_NAME(i));\n\tif (in_use)\n\t{\n\t    AUGROUP_NAME(i) = get_deleted_augroup();\n\t}\n\telse\n\t    AUGROUP_NAME(i) = NULL;\n    }\n}\n\n/*\n * Find the ID of an autocmd group name.\n * Return it's ID.  Returns AUGROUP_ERROR (< 0) for error.\n */\n    static int\nau_find_group(char_u *name)\n{\n    int\t    i;\n\n    for (i = 0; i < augroups.ga_len; ++i)\n\tif (AUGROUP_NAME(i) != NULL && AUGROUP_NAME(i) != get_deleted_augroup()\n\t\t&& STRCMP(AUGROUP_NAME(i), name) == 0)\n\t    return i;\n    return AUGROUP_ERROR;\n}\n\n/*\n * Return TRUE if augroup \"name\" exists.\n */\n    int\nau_has_group(char_u *name)\n{\n    return au_find_group(name) != AUGROUP_ERROR;\n}\n\n/*\n * \":augroup {name}\".\n */\n    void\ndo_augroup(char_u *arg, int del_group)\n{\n    int\t    i;\n\n    if (del_group)\n    {\n\tif (*arg == NUL)\n\t    EMSG(_(e_argreq));\n\telse\n\t    au_del_group(arg);\n    }\n    else if (STRICMP(arg, \"end\") == 0)   /* \":aug end\": back to group 0 */\n\tcurrent_augroup = AUGROUP_DEFAULT;\n    else if (*arg)\t\t    /* \":aug xxx\": switch to group xxx */\n    {\n\ti = au_new_group(arg);\n\tif (i != AUGROUP_ERROR)\n\t    current_augroup = i;\n    }\n    else\t\t\t    /* \":aug\": list the group names */\n    {\n\tmsg_start();\n\tfor (i = 0; i < augroups.ga_len; ++i)\n\t{\n\t    if (AUGROUP_NAME(i) != NULL)\n\t    {\n\t\tmsg_puts(AUGROUP_NAME(i));\n\t\tmsg_puts((char_u *)\"  \");\n\t    }\n\t}\n\tmsg_clr_eos();\n\tmsg_end();\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_autocmds(void)\n{\n    int\t\ti;\n    char_u\t*s;\n\n    for (current_augroup = -1; current_augroup < augroups.ga_len;\n\t\t\t\t\t\t\t    ++current_augroup)\n\tdo_autocmd((char_u *)\"\", TRUE);\n\n    for (i = 0; i < augroups.ga_len; ++i)\n    {\n\ts = ((char_u **)(augroups.ga_data))[i];\n\tif (s != get_deleted_augroup())\n\t    vim_free(s);\n    }\n    ga_clear(&augroups);\n}\n#endif\n\n/*\n * Return the event number for event name \"start\".\n * Return NUM_EVENTS if the event name was not found.\n * Return a pointer to the next event name in \"end\".\n */\n    static event_T\nevent_name2nr(char_u *start, char_u **end)\n{\n    char_u\t*p;\n    int\t\ti;\n    int\t\tlen;\n\n    /* the event name ends with end of line, '|', a blank or a comma */\n    for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)\n\t;\n    for (i = 0; event_names[i].name != NULL; ++i)\n    {\n\tlen = (int)STRLEN(event_names[i].name);\n\tif (len == p - start && STRNICMP(event_names[i].name, start, len) == 0)\n\t    break;\n    }\n    if (*p == ',')\n\t++p;\n    *end = p;\n    if (event_names[i].name == NULL)\n\treturn NUM_EVENTS;\n    return event_names[i].event;\n}\n\n/*\n * Return the name for event \"event\".\n */\n    static char_u *\nevent_nr2name(event_T event)\n{\n    int\t    i;\n\n    for (i = 0; event_names[i].name != NULL; ++i)\n\tif (event_names[i].event == event)\n\t    return (char_u *)event_names[i].name;\n    return (char_u *)\"Unknown\";\n}\n\n/*\n * Scan over the events.  \"*\" stands for all events.\n */\n    static char_u *\nfind_end_event(\n    char_u  *arg,\n    int\t    have_group)\t    /* TRUE when group name was found */\n{\n    char_u  *pat;\n    char_u  *p;\n\n    if (*arg == '*')\n    {\n\tif (arg[1] && !VIM_ISWHITE(arg[1]))\n\t{\n\t    EMSG2(_(\"E215: Illegal character after *: %s\"), arg);\n\t    return NULL;\n\t}\n\tpat = arg + 1;\n    }\n    else\n    {\n\tfor (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)\n\t{\n\t    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)\n\t    {\n\t\tif (have_group)\n\t\t    EMSG2(_(\"E216: No such event: %s\"), pat);\n\t\telse\n\t\t    EMSG2(_(\"E216: No such group or event: %s\"), pat);\n\t\treturn NULL;\n\t    }\n\t}\n    }\n    return pat;\n}\n\n/*\n * Return TRUE if \"event\" is included in 'eventignore'.\n */\n    static int\nevent_ignored(event_T event)\n{\n    char_u\t*p = p_ei;\n\n    while (*p != NUL)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t    return TRUE;\n\tif (event_name2nr(p, &p) == event)\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Return OK when the contents of p_ei is valid, FAIL otherwise.\n */\n    int\ncheck_ei(void)\n{\n    char_u\t*p = p_ei;\n\n    while (*p)\n    {\n\tif (STRNICMP(p, \"all\", 3) == 0 && (p[3] == NUL || p[3] == ','))\n\t{\n\t    p += 3;\n\t    if (*p == ',')\n\t\t++p;\n\t}\n\telse if (event_name2nr(p, &p) == NUM_EVENTS)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n# if defined(FEAT_SYN_HL) || defined(PROTO)\n\n/*\n * Add \"what\" to 'eventignore' to skip loading syntax highlighting for every\n * buffer loaded into the window.  \"what\" must start with a comma.\n * Returns the old value of 'eventignore' in allocated memory.\n */\n    char_u *\nau_event_disable(char *what)\n{\n    char_u\t*new_ei;\n    char_u\t*save_ei;\n\n    save_ei = vim_strsave(p_ei);\n    if (save_ei != NULL)\n    {\n\tnew_ei = vim_strnsave(p_ei, (int)(STRLEN(p_ei) + STRLEN(what)));\n\tif (new_ei != NULL)\n\t{\n\t    if (*what == ',' && *p_ei == NUL)\n\t\tSTRCPY(new_ei, what + 1);\n\t    else\n\t\tSTRCAT(new_ei, what);\n\t    set_string_option_direct((char_u *)\"ei\", -1, new_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\t    vim_free(new_ei);\n\t}\n    }\n    return save_ei;\n}\n\n    void\nau_event_restore(char_u *old_ei)\n{\n    if (old_ei != NULL)\n    {\n\tset_string_option_direct((char_u *)\"ei\", -1, old_ei,\n\t\t\t\t\t\t\t  OPT_FREE, SID_NONE);\n\tvim_free(old_ei);\n    }\n}\n# endif  /* FEAT_SYN_HL */\n\n/*\n * do_autocmd() -- implements the :autocmd command.  Can be used in the\n *  following ways:\n *\n * :autocmd <event> <pat> <cmd>\t    Add <cmd> to the list of commands that\n *\t\t\t\t    will be automatically executed for <event>\n *\t\t\t\t    when editing a file matching <pat>, in\n *\t\t\t\t    the current group.\n * :autocmd <event> <pat>\t    Show the auto-commands associated with\n *\t\t\t\t    <event> and <pat>.\n * :autocmd <event>\t\t    Show the auto-commands associated with\n *\t\t\t\t    <event>.\n * :autocmd\t\t\t    Show all auto-commands.\n * :autocmd! <event> <pat> <cmd>    Remove all auto-commands associated with\n *\t\t\t\t    <event> and <pat>, and add the command\n *\t\t\t\t    <cmd>, for the current group.\n * :autocmd! <event> <pat>\t    Remove all auto-commands associated with\n *\t\t\t\t    <event> and <pat> for the current group.\n * :autocmd! <event>\t\t    Remove all auto-commands associated with\n *\t\t\t\t    <event> for the current group.\n * :autocmd!\t\t\t    Remove ALL auto-commands for the current\n *\t\t\t\t    group.\n *\n *  Multiple events and patterns may be given separated by commas.  Here are\n *  some examples:\n * :autocmd bufread,bufenter *.c,*.h\tset tw=0 smartindent noic\n * :autocmd bufleave\t     *\t\tset tw=79 nosmartindent ic infercase\n *\n * :autocmd * *.c\t\tshow all autocommands for *.c files.\n *\n * Mostly a {group} argument can optionally appear before <event>.\n */\n    void\ndo_autocmd(char_u *arg_in, int forceit)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*pat;\n    char_u\t*envpat = NULL;\n    char_u\t*cmd;\n    event_T\tevent;\n    int\t\tneed_free = FALSE;\n    int\t\tnested = FALSE;\n    int\t\tgroup;\n\n    if (*arg == '|')\n    {\n\targ = (char_u *)\"\";\n\tgroup = AUGROUP_ALL;\t/* no argument, use all groups */\n    }\n    else\n    {\n\t/*\n\t * Check for a legal group name.  If not, use AUGROUP_ALL.\n\t */\n\tgroup = au_get_grouparg(&arg);\n\tif (arg == NULL)\t    /* out of memory */\n\t    return;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    pat = find_end_event(arg, group != AUGROUP_ALL);\n    if (pat == NULL)\n\treturn;\n\n    pat = skipwhite(pat);\n    if (*pat == '|')\n    {\n\tpat = (char_u *)\"\";\n\tcmd = (char_u *)\"\";\n    }\n    else\n    {\n\t/*\n\t * Scan over the pattern.  Put a NUL at the end.\n\t */\n\tcmd = pat;\n\twhile (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\\\'))\n\t    cmd++;\n\tif (*cmd)\n\t    *cmd++ = NUL;\n\n\t/* Expand environment variables in the pattern.  Set 'shellslash', we want\n\t * forward slashes here. */\n\tif (vim_strchr(pat, '$') != NULL || vim_strchr(pat, '~') != NULL)\n\t{\n#ifdef BACKSLASH_IN_FILENAME\n\t    int\tp_ssl_save = p_ssl;\n\n\t    p_ssl = TRUE;\n#endif\n\t    envpat = expand_env_save(pat);\n#ifdef BACKSLASH_IN_FILENAME\n\t    p_ssl = p_ssl_save;\n#endif\n\t    if (envpat != NULL)\n\t\tpat = envpat;\n\t}\n\n\t/*\n\t * Check for \"nested\" flag.\n\t */\n\tcmd = skipwhite(cmd);\n\tif (*cmd != NUL && STRNCMP(cmd, \"nested\", 6) == 0 && VIM_ISWHITE(cmd[6]))\n\t{\n\t    nested = TRUE;\n\t    cmd = skipwhite(cmd + 6);\n\t}\n\n\t/*\n\t * Find the start of the commands.\n\t * Expand <sfile> in it.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    cmd = expand_sfile(cmd);\n\t    if (cmd == NULL)\t    /* some error */\n\t\treturn;\n\t    need_free = TRUE;\n\t}\n    }\n\n    /*\n     * Print header when showing autocommands.\n     */\n    if (!forceit && *cmd == NUL)\n    {\n\t/* Highlight title */\n\tMSG_PUTS_TITLE(_(\"\\n--- Auto-Commands ---\"));\n    }\n\n    /*\n     * Loop over the events.\n     */\n    last_event = (event_T)-1;\t\t/* for listing the event name */\n    last_group = AUGROUP_ERROR;\t\t/* for listing the group name */\n    if (*arg == '*' || *arg == NUL || *arg == '|')\n    {\n\tfor (event = (event_T)0; (int)event < (int)NUM_EVENTS;\n\t\t\t\t\t    event = (event_T)((int)event + 1))\n\t    if (do_autocmd_event(event, pat,\n\t\t\t\t\t nested, cmd, forceit, group) == FAIL)\n\t\tbreak;\n    }\n    else\n    {\n\twhile (*arg && *arg != '|' && !VIM_ISWHITE(*arg))\n\t    if (do_autocmd_event(event_name2nr(arg, &arg), pat,\n\t\t\t\t\tnested,\tcmd, forceit, group) == FAIL)\n\t\tbreak;\n    }\n\n    if (need_free)\n\tvim_free(cmd);\n    vim_free(envpat);\n}\n\n/*\n * Find the group ID in a \":autocmd\" or \":doautocmd\" argument.\n * The \"argp\" argument is advanced to the following argument.\n *\n * Returns the group ID, AUGROUP_ERROR for error (out of memory).\n */\n    static int\nau_get_grouparg(char_u **argp)\n{\n    char_u\t*group_name;\n    char_u\t*p;\n    char_u\t*arg = *argp;\n    int\t\tgroup = AUGROUP_ALL;\n\n    for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)\n\t;\n    if (p > arg)\n    {\n\tgroup_name = vim_strnsave(arg, (int)(p - arg));\n\tif (group_name == NULL)\t\t/* out of memory */\n\t    return AUGROUP_ERROR;\n\tgroup = au_find_group(group_name);\n\tif (group == AUGROUP_ERROR)\n\t    group = AUGROUP_ALL;\t/* no match, use all groups */\n\telse\n\t    *argp = skipwhite(p);\t/* match, skip over group name */\n\tvim_free(group_name);\n    }\n    return group;\n}\n\n/*\n * do_autocmd() for one event.\n * If *pat == NUL do for all patterns.\n * If *cmd == NUL show entries.\n * If forceit == TRUE delete entries.\n * If group is not AUGROUP_ALL, only use this group.\n */\n    static int\ndo_autocmd_event(\n    event_T\tevent,\n    char_u\t*pat,\n    int\t\tnested,\n    char_u\t*cmd,\n    int\t\tforceit,\n    int\t\tgroup)\n{\n    AutoPat\t*ap;\n    AutoPat\t**prev_ap;\n    AutoCmd\t*ac;\n    AutoCmd\t**prev_ac;\n    int\t\tbrace_level;\n    char_u\t*endpat;\n    int\t\tfindgroup;\n    int\t\tallgroups;\n    int\t\tpatlen;\n    int\t\tis_buflocal;\n    int\t\tbuflocal_nr;\n    char_u\tbuflocal_pat[25];\t/* for \"<buffer=X>\" */\n\n    if (group == AUGROUP_ALL)\n\tfindgroup = current_augroup;\n    else\n\tfindgroup = group;\n    allgroups = (group == AUGROUP_ALL && !forceit && *cmd == NUL);\n\n    /*\n     * Show or delete all patterns for an event.\n     */\n    if (*pat == NUL)\n    {\n\tfor (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\t{\n\t    if (forceit)  /* delete the AutoPat, if it's in the current group */\n\t    {\n\t\tif (ap->group == findgroup)\n\t\t    au_remove_pat(ap);\n\t    }\n\t    else if (group == AUGROUP_ALL || ap->group == group)\n\t\tshow_autocmd(ap, event);\n\t}\n    }\n\n    /*\n     * Loop through all the specified patterns.\n     */\n    for ( ; *pat; pat = (*endpat == ',' ? endpat + 1 : endpat))\n    {\n\t/*\n\t * Find end of the pattern.\n\t * Watch out for a comma in braces, like \"*.\\{obj,o\\}\".\n\t */\n\tbrace_level = 0;\n\tfor (endpat = pat; *endpat && (*endpat != ',' || brace_level\n\t\t\t   || (endpat > pat && endpat[-1] == '\\\\')); ++endpat)\n\t{\n\t    if (*endpat == '{')\n\t\tbrace_level++;\n\t    else if (*endpat == '}')\n\t\tbrace_level--;\n\t}\n\tif (pat == endpat)\t\t/* ignore single comma */\n\t    continue;\n\tpatlen = (int)(endpat - pat);\n\n\t/*\n\t * detect special <buflocal[=X]> buffer-local patterns\n\t */\n\tis_buflocal = FALSE;\n\tbuflocal_nr = 0;\n\n\tif (patlen >= 8 && STRNCMP(pat, \"<buffer\", 7) == 0\n\t\t\t\t\t\t    && pat[patlen - 1] == '>')\n\t{\n\t    /* \"<buffer...>\": Error will be printed only for addition.\n\t     * printing and removing will proceed silently. */\n\t    is_buflocal = TRUE;\n\t    if (patlen == 8)\n\t\t/* \"<buffer>\" */\n\t\tbuflocal_nr = curbuf->b_fnum;\n\t    else if (patlen > 9 && pat[7] == '=')\n\t    {\n\t\tif (patlen == 13 && STRNICMP(pat, \"<buffer=abuf>\", 13) == 0)\n\t\t    /* \"<buffer=abuf>\" */\n\t\t    buflocal_nr = autocmd_bufnr;\n\t\telse if (skipdigits(pat + 8) == pat + patlen - 1)\n\t\t    /* \"<buffer=123>\" */\n\t\t    buflocal_nr = atoi((char *)pat + 8);\n\t    }\n\t}\n\n\tif (is_buflocal)\n\t{\n\t    /* normalize pat into standard \"<buffer>#N\" form */\n\t    sprintf((char *)buflocal_pat, \"<buffer=%d>\", buflocal_nr);\n\t    pat = buflocal_pat;\t\t\t/* can modify pat and patlen */\n\t    patlen = (int)STRLEN(buflocal_pat);\t/*   but not endpat */\n\t}\n\n\t/*\n\t * Find AutoPat entries with this pattern.\n\t */\n\tprev_ap = &first_autopat[(int)event];\n\twhile ((ap = *prev_ap) != NULL)\n\t{\n\t    if (ap->pat != NULL)\n\t    {\n\t\t/* Accept a pattern when:\n\t\t * - a group was specified and it's that group, or a group was\n\t\t *   not specified and it's the current group, or a group was\n\t\t *   not specified and we are listing\n\t\t * - the length of the pattern matches\n\t\t * - the pattern matches.\n\t\t * For <buffer[=X]>, this condition works because we normalize\n\t\t * all buffer-local patterns.\n\t\t */\n\t\tif ((allgroups || ap->group == findgroup)\n\t\t\t&& ap->patlen == patlen\n\t\t\t&& STRNCMP(pat, ap->pat, patlen) == 0)\n\t\t{\n\t\t    /*\n\t\t     * Remove existing autocommands.\n\t\t     * If adding any new autocmd's for this AutoPat, don't\n\t\t     * delete the pattern from the autopat list, append to\n\t\t     * this list.\n\t\t     */\n\t\t    if (forceit)\n\t\t    {\n\t\t\tif (*cmd != NUL && ap->next == NULL)\n\t\t\t{\n\t\t\t    au_remove_cmds(ap);\n\t\t\t    break;\n\t\t\t}\n\t\t\tau_remove_pat(ap);\n\t\t    }\n\n\t\t    /*\n\t\t     * Show autocmd's for this autopat, or buflocals <buffer=X>\n\t\t     */\n\t\t    else if (*cmd == NUL)\n\t\t\tshow_autocmd(ap, event);\n\n\t\t    /*\n\t\t     * Add autocmd to this autopat, if it's the last one.\n\t\t     */\n\t\t    else if (ap->next == NULL)\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    prev_ap = &ap->next;\n\t}\n\n\t/*\n\t * Add a new command.\n\t */\n\tif (*cmd != NUL)\n\t{\n\t    /*\n\t     * If the pattern we want to add a command to does appear at the\n\t     * end of the list (or not is not in the list at all), add the\n\t     * pattern at the end of the list.\n\t     */\n\t    if (ap == NULL)\n\t    {\n\t\t/* refuse to add buffer-local ap if buffer number is invalid */\n\t\tif (is_buflocal && (buflocal_nr == 0\n\t\t\t\t      || buflist_findnr(buflocal_nr) == NULL))\n\t\t{\n\t\t    EMSGN(_(\"E680: <buffer=%d>: invalid buffer number \"),\n\t\t\t\t\t\t\t\t buflocal_nr);\n\t\t    return FAIL;\n\t\t}\n\n\t\tap = (AutoPat *)alloc((unsigned)sizeof(AutoPat));\n\t\tif (ap == NULL)\n\t\t    return FAIL;\n\t\tap->pat = vim_strnsave(pat, patlen);\n\t\tap->patlen = patlen;\n\t\tif (ap->pat == NULL)\n\t\t{\n\t\t    vim_free(ap);\n\t\t    return FAIL;\n\t\t}\n\n\t\tif (is_buflocal)\n\t\t{\n\t\t    ap->buflocal_nr = buflocal_nr;\n\t\t    ap->reg_prog = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u\t*reg_pat;\n\n\t\t    ap->buflocal_nr = 0;\n\t\t    reg_pat = file_pat_to_reg_pat(pat, endpat,\n\t\t\t\t\t\t\t &ap->allow_dirs, TRUE);\n\t\t    if (reg_pat != NULL)\n\t\t\tap->reg_prog = vim_regcomp(reg_pat, RE_MAGIC);\n\t\t    vim_free(reg_pat);\n\t\t    if (reg_pat == NULL || ap->reg_prog == NULL)\n\t\t    {\n\t\t\tvim_free(ap->pat);\n\t\t\tvim_free(ap);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t\tap->cmds = NULL;\n\t\t*prev_ap = ap;\n\t\tap->next = NULL;\n\t\tif (group == AUGROUP_ALL)\n\t\t    ap->group = current_augroup;\n\t\telse\n\t\t    ap->group = group;\n\t    }\n\n\t    /*\n\t     * Add the autocmd at the end of the AutoCmd list.\n\t     */\n\t    prev_ac = &(ap->cmds);\n\t    while ((ac = *prev_ac) != NULL)\n\t\tprev_ac = &ac->next;\n\t    ac = (AutoCmd *)alloc((unsigned)sizeof(AutoCmd));\n\t    if (ac == NULL)\n\t\treturn FAIL;\n\t    ac->cmd = vim_strsave(cmd);\n#ifdef FEAT_EVAL\n\t    ac->scriptID = current_SID;\n#endif\n\t    if (ac->cmd == NULL)\n\t    {\n\t\tvim_free(ac);\n\t\treturn FAIL;\n\t    }\n\t    ac->next = NULL;\n\t    *prev_ac = ac;\n\t    ac->nested = nested;\n\t}\n    }\n\n    au_cleanup();\t/* may really delete removed patterns/commands now */\n    return OK;\n}\n\n/*\n * Implementation of \":doautocmd [group] event [fname]\".\n * Return OK for success, FAIL for failure;\n */\n    int\ndo_doautocmd(\n    char_u\t*arg,\n    int\t\tdo_msg,\t    /* give message for no matching autocmds? */\n    int\t\t*did_something)\n{\n    char_u\t*fname;\n    int\t\tnothing_done = TRUE;\n    int\t\tgroup;\n\n    if (did_something != NULL)\n\t*did_something = FALSE;\n\n    /*\n     * Check for a legal group name.  If not, use AUGROUP_ALL.\n     */\n    group = au_get_grouparg(&arg);\n    if (arg == NULL)\t    /* out of memory */\n\treturn FAIL;\n\n    if (*arg == '*')\n    {\n\tEMSG(_(\"E217: Can't execute autocommands for ALL events\"));\n\treturn FAIL;\n    }\n\n    /*\n     * Scan over the events.\n     * If we find an illegal name, return here, don't do anything.\n     */\n    fname = find_end_event(arg, group != AUGROUP_ALL);\n    if (fname == NULL)\n\treturn FAIL;\n\n    fname = skipwhite(fname);\n\n    /*\n     * Loop over the events.\n     */\n    while (*arg && !ends_excmd(*arg) && !VIM_ISWHITE(*arg))\n\tif (apply_autocmds_group(event_name2nr(arg, &arg),\n\t\t\t\t      fname, NULL, TRUE, group, curbuf, NULL))\n\t    nothing_done = FALSE;\n\n    if (nothing_done && do_msg)\n\tMSG(_(\"No matching autocommands\"));\n    if (did_something != NULL)\n\t*did_something = !nothing_done;\n\n#ifdef FEAT_EVAL\n    return aborting() ? FAIL : OK;\n#else\n    return OK;\n#endif\n}\n\n/*\n * \":doautoall\": execute autocommands for each loaded buffer.\n */\n    void\nex_doautoall(exarg_T *eap)\n{\n    int\t\tretval;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    bufref_T\tbufref;\n    char_u\t*arg = eap->arg;\n    int\t\tcall_do_modelines = check_nomodeline(&arg);\n    int\t\tdid_aucmd;\n\n    /*\n     * This is a bit tricky: For some commands curwin->w_buffer needs to be\n     * equal to curbuf, but for some buffers there may not be a window.\n     * So we change the buffer for the current window for a moment.  This\n     * gives problems when the autocommands make changes to the list of\n     * buffers or windows...\n     */\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_ml.ml_mfp != NULL)\n\t{\n\t    /* find a window for this buffer and save some values */\n\t    aucmd_prepbuf(&aco, buf);\n\t    set_bufref(&bufref, buf);\n\n\t    /* execute the autocommands for this buffer */\n\t    retval = do_doautocmd(arg, FALSE, &did_aucmd);\n\n\t    if (call_do_modelines && did_aucmd)\n\t    {\n\t\t/* Execute the modeline settings, but don't set window-local\n\t\t * options if we are using the current window for another\n\t\t * buffer. */\n\t\tdo_modelines(curwin == aucmd_win ? OPT_NOWIN : 0);\n\t    }\n\n\t    /* restore the current window */\n\t    aucmd_restbuf(&aco);\n\n\t    /* stop if there is some error or buffer was deleted */\n\t    if (retval == FAIL || !bufref_valid(&bufref))\n\t\tbreak;\n\t}\n    }\n\n    check_cursor();\t    /* just in case lines got deleted */\n}\n\n/*\n * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise\n * return TRUE and advance *argp to after it.\n * Thus return TRUE when do_modelines() should be called.\n */\n    int\ncheck_nomodeline(char_u **argp)\n{\n    if (STRNCMP(*argp, \"<nomodeline>\", 12) == 0)\n    {\n\t*argp = skipwhite(*argp + 12);\n\treturn FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Prepare for executing autocommands for (hidden) buffer \"buf\".\n * Search for a visible window containing the current buffer.  If there isn't\n * one then use \"aucmd_win\".\n * Set \"curbuf\" and \"curwin\" to match \"buf\".\n * When FEAT_AUTOCMD is not defined another version is used, see below.\n */\n    void\naucmd_prepbuf(\n    aco_save_T\t*aco,\t\t/* structure to save values in */\n    buf_T\t*buf)\t\t/* new curbuf */\n{\n    win_T\t*win;\n    int\t\tsave_ea;\n#ifdef FEAT_AUTOCHDIR\n    int\t\tsave_acd;\n#endif\n\n    /* Find a window that is for the new buffer */\n    if (buf == curbuf)\t\t/* be quick when buf is curbuf */\n\twin = curwin;\n    else\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer == buf)\n\t\tbreak;\n\n    /* Allocate \"aucmd_win\" when needed.  If this fails (out of memory) fall\n     * back to using the current window. */\n    if (win == NULL && aucmd_win == NULL)\n    {\n\twin_alloc_aucmd_win();\n\tif (aucmd_win == NULL)\n\t    win = curwin;\n    }\n    if (win == NULL && aucmd_win_used)\n\t/* Strange recursive autocommand, fall back to using the current\n\t * window.  Expect a few side effects... */\n\twin = curwin;\n\n    aco->save_curwin = curwin;\n    aco->save_curbuf = curbuf;\n    if (win != NULL)\n    {\n\t/* There is a window for \"buf\" in the current tab page, make it the\n\t * curwin.  This is preferred, it has the least side effects (esp. if\n\t * \"buf\" is curbuf). */\n\taco->use_aucmd_win = FALSE;\n\tcurwin = win;\n    }\n    else\n    {\n\t/* There is no window for \"buf\", use \"aucmd_win\".  To minimize the side\n\t * effects, insert it in the current tab page.\n\t * Anything related to a window (e.g., setting folds) may have\n\t * unexpected results. */\n\taco->use_aucmd_win = TRUE;\n\taucmd_win_used = TRUE;\n\taucmd_win->w_buffer = buf;\n\taucmd_win->w_s = &buf->b_s;\n\t++buf->b_nwindows;\n\twin_init_empty(aucmd_win); /* set cursor and topline to safe values */\n\n\t/* Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n\t * win_enter_ext(). */\n\tvim_free(aucmd_win->w_localdir);\n\taucmd_win->w_localdir = NULL;\n\taco->globaldir = globaldir;\n\tglobaldir = NULL;\n\n\n\t/* Split the current window, put the aucmd_win in the upper half.\n\t * We don't want the BufEnter or WinEnter autocommands. */\n\tblock_autocmds();\n\tmake_snapshot(SNAP_AUCMD_IDX);\n\tsave_ea = p_ea;\n\tp_ea = FALSE;\n\n#ifdef FEAT_AUTOCHDIR\n\t/* Prevent chdir() call in win_enter_ext(), through do_autochdir(). */\n\tsave_acd = p_acd;\n\tp_acd = FALSE;\n#endif\n\n\t(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);\n\t(void)win_comp_pos();   /* recompute window positions */\n\tp_ea = save_ea;\n#ifdef FEAT_AUTOCHDIR\n\tp_acd = save_acd;\n#endif\n\tunblock_autocmds();\n\tcurwin = aucmd_win;\n    }\n    curbuf = buf;\n    aco->new_curwin = curwin;\n    set_bufref(&aco->new_curbuf, curbuf);\n}\n\n/*\n * Cleanup after executing autocommands for a (hidden) buffer.\n * Restore the window as it was (if possible).\n * When FEAT_AUTOCMD is not defined another version is used, see below.\n */\n    void\naucmd_restbuf(\n    aco_save_T\t*aco)\t\t/* structure holding saved values */\n{\n    int dummy;\n\n    if (aco->use_aucmd_win)\n    {\n\t--curbuf->b_nwindows;\n\t/* Find \"aucmd_win\", it can't be closed, but it may be in another tab\n\t * page. Do not trigger autocommands here. */\n\tblock_autocmds();\n\tif (curwin != aucmd_win)\n\t{\n\t    tabpage_T\t*tp;\n\t    win_T\t*wp;\n\n\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    {\n\t\tif (wp == aucmd_win)\n\t\t{\n\t\t    if (tp != curtab)\n\t\t\tgoto_tabpage_tp(tp, TRUE, TRUE);\n\t\t    win_goto(aucmd_win);\n\t\t    goto win_found;\n\t\t}\n\t    }\n\t}\nwin_found:\n\n\t/* Remove the window and frame from the tree of frames. */\n\t(void)winframe_remove(curwin, &dummy, NULL);\n\twin_remove(curwin, NULL);\n\taucmd_win_used = FALSE;\n\tlast_status(FALSE);\t    /* may need to remove last status line */\n\n\tif (!valid_tabpage_win(curtab))\n\t    /* no valid window in current tabpage */\n\t    close_tabpage(curtab);\n\n\trestore_snapshot(SNAP_AUCMD_IDX, FALSE);\n\t(void)win_comp_pos();   /* recompute window positions */\n\tunblock_autocmds();\n\n\tif (win_valid(aco->save_curwin))\n\t    curwin = aco->save_curwin;\n\telse\n\t    /* Hmm, original window disappeared.  Just use the first one. */\n\t    curwin = firstwin;\n#ifdef FEAT_EVAL\n\tvars_clear(&aucmd_win->w_vars->dv_hashtab);  /* free all w: variables */\n\thash_init(&aucmd_win->w_vars->dv_hashtab);   /* re-use the hashtab */\n#endif\n\tcurbuf = curwin->w_buffer;\n\n\tvim_free(globaldir);\n\tglobaldir = aco->globaldir;\n\n\t/* the buffer contents may have changed */\n\tcheck_cursor();\n\tif (curwin->w_topline > curbuf->b_ml.ml_line_count)\n\t{\n\t    curwin->w_topline = curbuf->b_ml.ml_line_count;\n#ifdef FEAT_DIFF\n\t    curwin->w_topfill = 0;\n#endif\n\t}\n#if defined(FEAT_GUI)\n\t/* Hide the scrollbars from the aucmd_win and update. */\n\tgui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_LEFT], FALSE);\n\tgui_mch_enable_scrollbar(&aucmd_win->w_scrollbars[SBAR_RIGHT], FALSE);\n\tgui_may_update_scrollbars();\n#endif\n    }\n    else\n    {\n\t/* restore curwin */\n\tif (win_valid(aco->save_curwin))\n\t{\n\t    /* Restore the buffer which was previously edited by curwin, if\n\t     * it was changed, we are still the same window and the buffer is\n\t     * valid. */\n\t    if (curwin == aco->new_curwin\n\t\t    && curbuf != aco->new_curbuf.br_buf\n\t\t    && bufref_valid(&aco->new_curbuf)\n\t\t    && aco->new_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t    {\n# if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n\t\tif (curwin->w_s == &curbuf->b_s)\n\t\t    curwin->w_s = &aco->new_curbuf.br_buf->b_s;\n# endif\n\t\t--curbuf->b_nwindows;\n\t\tcurbuf = aco->new_curbuf.br_buf;\n\t\tcurwin->w_buffer = curbuf;\n\t\t++curbuf->b_nwindows;\n\t    }\n\n\t    curwin = aco->save_curwin;\n\t    curbuf = curwin->w_buffer;\n\t    /* In case the autocommand move the cursor to a position that that\n\t     * not exist in curbuf. */\n\t    check_cursor();\n\t}\n    }\n}\n\nstatic int\tautocmd_nested = FALSE;\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    int\napply_autocmds(\n    event_T\tevent,\n    char_u\t*fname,\t    /* NULL or empty means use actual file name */\n    char_u\t*fname_io,  /* fname to use for <afile> on cmdline */\n    int\t\tforce,\t    /* when TRUE, ignore autocmd_busy */\n    buf_T\t*buf)\t    /* buffer for <abuf> */\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n}\n\n/*\n * Like apply_autocmds(), but with extra \"eap\" argument.  This takes care of\n * setting v:filearg.\n */\n    static int\napply_autocmds_exarg(\n    event_T\tevent,\n    char_u\t*fname,\n    char_u\t*fname_io,\n    int\t\tforce,\n    buf_T\t*buf,\n    exarg_T\t*eap)\n{\n    return apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t       AUGROUP_ALL, buf, eap);\n}\n\n/*\n * Like apply_autocmds(), but handles the caller's retval.  If the script\n * processing is being aborted or if retval is FAIL when inside a try\n * conditional, no autocommands are executed.  If otherwise the autocommands\n * cause the script to be aborted, retval is set to FAIL.\n */\n    int\napply_autocmds_retval(\n    event_T\tevent,\n    char_u\t*fname,\t    /* NULL or empty means use actual file name */\n    char_u\t*fname_io,  /* fname to use for <afile> on cmdline */\n    int\t\tforce,\t    /* when TRUE, ignore autocmd_busy */\n    buf_T\t*buf,\t    /* buffer for <abuf> */\n    int\t\t*retval)    /* pointer to caller's retval */\n{\n    int\t\tdid_cmd;\n\n#ifdef FEAT_EVAL\n    if (should_abort(*retval))\n\treturn FALSE;\n#endif\n\n    did_cmd = apply_autocmds_group(event, fname, fname_io, force,\n\t\t\t\t\t\t      AUGROUP_ALL, buf, NULL);\n    if (did_cmd\n#ifdef FEAT_EVAL\n\t    && aborting()\n#endif\n\t    )\n\t*retval = FAIL;\n    return did_cmd;\n}\n\n/*\n * Return TRUE when there is a CursorHold autocommand defined.\n */\n    int\nhas_cursorhold(void)\n{\n    return (first_autopat[(int)(get_real_state() == NORMAL_BUSY\n\t\t\t    ? EVENT_CURSORHOLD : EVENT_CURSORHOLDI)] != NULL);\n}\n\n/*\n * Return TRUE if the CursorHold event can be triggered.\n */\n    int\ntrigger_cursorhold(void)\n{\n    int\t\tstate;\n\n    if (!did_cursorhold\n\t    && has_cursorhold()\n\t    && !Recording\n\t    && typebuf.tb_len == 0\n#ifdef FEAT_INS_EXPAND\n\t    && !ins_compl_active()\n#endif\n\t    )\n    {\n\tstate = get_real_state();\n\tif (state == NORMAL_BUSY || (state & INSERT) != 0)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE when there is a CursorMoved autocommand defined.\n */\n    int\nhas_cursormoved(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVED] != NULL);\n}\n\n/*\n * Return TRUE when there is a CursorMovedI autocommand defined.\n */\n    int\nhas_cursormovedI(void)\n{\n    return (first_autopat[(int)EVENT_CURSORMOVEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChanged autocommand defined.\n */\n    int\nhas_textchanged(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGED] != NULL);\n}\n\n/*\n * Return TRUE when there is a TextChangedI autocommand defined.\n */\n    int\nhas_textchangedI(void)\n{\n    return (first_autopat[(int)EVENT_TEXTCHANGEDI] != NULL);\n}\n\n/*\n * Return TRUE when there is an InsertCharPre autocommand defined.\n */\n    int\nhas_insertcharpre(void)\n{\n    return (first_autopat[(int)EVENT_INSERTCHARPRE] != NULL);\n}\n\n/*\n * Return TRUE when there is an CmdUndefined autocommand defined.\n */\n    int\nhas_cmdundefined(void)\n{\n    return (first_autopat[(int)EVENT_CMDUNDEFINED] != NULL);\n}\n\n/*\n * Return TRUE when there is an FuncUndefined autocommand defined.\n */\n    int\nhas_funcundefined(void)\n{\n    return (first_autopat[(int)EVENT_FUNCUNDEFINED] != NULL);\n}\n\n/*\n * Execute autocommands for \"event\" and file name \"fname\".\n * Return TRUE if some commands were executed.\n */\n    static int\napply_autocmds_group(\n    event_T\tevent,\n    char_u\t*fname,\t    /* NULL or empty means use actual file name */\n    char_u\t*fname_io,  /* fname to use for <afile> on cmdline, NULL means\n\t\t\t       use fname */\n    int\t\tforce,\t    /* when TRUE, ignore autocmd_busy */\n    int\t\tgroup,\t    /* group ID, or AUGROUP_ALL */\n    buf_T\t*buf,\t    /* buffer for <abuf> */\n    exarg_T\t*eap)\t    /* command arguments */\n{\n    char_u\t*sfname = NULL;\t/* short file name */\n    char_u\t*tail;\n    int\t\tsave_changed;\n    buf_T\t*old_curbuf;\n    int\t\tretval = FALSE;\n    char_u\t*save_sourcing_name;\n    linenr_T\tsave_sourcing_lnum;\n    char_u\t*save_autocmd_fname;\n    int\t\tsave_autocmd_fname_full;\n    int\t\tsave_autocmd_bufnr;\n    char_u\t*save_autocmd_match;\n    int\t\tsave_autocmd_busy;\n    int\t\tsave_autocmd_nested;\n    static int\tnesting = 0;\n    AutoPatCmd\tpatcmd;\n    AutoPat\t*ap;\n#ifdef FEAT_EVAL\n    scid_T\tsave_current_SID;\n    void\t*save_funccalp;\n    char_u\t*save_cmdarg;\n    long\tsave_cmdbang;\n#endif\n    static int\tfilechangeshell_busy = FALSE;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n    int\t\tdid_save_redobuff = FALSE;\n    save_redo_T\tsave_redo;\n\n    /*\n     * Quickly return if there are no autocommands for this event or\n     * autocommands are blocked.\n     */\n    if (event == NUM_EVENTS || first_autopat[(int)event] == NULL\n\t    || autocmd_blocked > 0)\n\tgoto BYPASS_AU;\n\n    /*\n     * When autocommands are busy, new autocommands are only executed when\n     * explicitly enabled with the \"nested\" flag.\n     */\n    if (autocmd_busy && !(force || autocmd_nested))\n\tgoto BYPASS_AU;\n\n#ifdef FEAT_EVAL\n    /*\n     * Quickly return when immediately aborting on error, or when an interrupt\n     * occurred or an exception was thrown but not caught.\n     */\n    if (aborting())\n\tgoto BYPASS_AU;\n#endif\n\n    /*\n     * FileChangedShell never nests, because it can create an endless loop.\n     */\n    if (filechangeshell_busy && (event == EVENT_FILECHANGEDSHELL\n\t\t\t\t      || event == EVENT_FILECHANGEDSHELLPOST))\n\tgoto BYPASS_AU;\n\n    /*\n     * Ignore events in 'eventignore'.\n     */\n    if (event_ignored(event))\n\tgoto BYPASS_AU;\n\n    /*\n     * Allow nesting of autocommands, but restrict the depth, because it's\n     * possible to create an endless loop.\n     */\n    if (nesting == 10)\n    {\n\tEMSG(_(\"E218: autocommand nesting too deep\"));\n\tgoto BYPASS_AU;\n    }\n\n    /*\n     * Check if these autocommands are disabled.  Used when doing \":all\" or\n     * \":ball\".\n     */\n    if (       (autocmd_no_enter\n\t\t&& (event == EVENT_WINENTER || event == EVENT_BUFENTER))\n\t    || (autocmd_no_leave\n\t\t&& (event == EVENT_WINLEAVE || event == EVENT_BUFLEAVE)))\n\tgoto BYPASS_AU;\n\n    /*\n     * Save the autocmd_* variables and info about the current buffer.\n     */\n    save_autocmd_fname = autocmd_fname;\n    save_autocmd_fname_full = autocmd_fname_full;\n    save_autocmd_bufnr = autocmd_bufnr;\n    save_autocmd_match = autocmd_match;\n    save_autocmd_busy = autocmd_busy;\n    save_autocmd_nested = autocmd_nested;\n    save_changed = curbuf->b_changed;\n    old_curbuf = curbuf;\n\n    /*\n     * Set the file name to be used for <afile>.\n     * Make a copy to avoid that changing a buffer name or directory makes it\n     * invalid.\n     */\n    if (fname_io == NULL)\n    {\n\tif (event == EVENT_COLORSCHEME || event == EVENT_OPTIONSET)\n\t    autocmd_fname = NULL;\n\telse if (fname != NULL && !ends_excmd(*fname))\n\t    autocmd_fname = fname;\n\telse if (buf != NULL)\n\t    autocmd_fname = buf->b_ffname;\n\telse\n\t    autocmd_fname = NULL;\n    }\n    else\n\tautocmd_fname = fname_io;\n    if (autocmd_fname != NULL)\n\tautocmd_fname = vim_strsave(autocmd_fname);\n    autocmd_fname_full = FALSE; /* call FullName_save() later */\n\n    /*\n     * Set the buffer number to be used for <abuf>.\n     */\n    if (buf == NULL)\n\tautocmd_bufnr = 0;\n    else\n\tautocmd_bufnr = buf->b_fnum;\n\n    /*\n     * When the file name is NULL or empty, use the file name of buffer \"buf\".\n     * Always use the full path of the file name to match with, in case\n     * \"allow_dirs\" is set.\n     */\n    if (fname == NULL || *fname == NUL)\n    {\n\tif (buf == NULL)\n\t    fname = NULL;\n\telse\n\t{\n#ifdef FEAT_SYN_HL\n\t    if (event == EVENT_SYNTAX)\n\t\tfname = buf->b_p_syn;\n\t    else\n#endif\n\t\tif (event == EVENT_FILETYPE)\n\t\t    fname = buf->b_p_ft;\n\t\telse\n\t\t{\n\t\t    if (buf->b_sfname != NULL)\n\t\t\tsfname = vim_strsave(buf->b_sfname);\n\t\t    fname = buf->b_ffname;\n\t\t}\n\t}\n\tif (fname == NULL)\n\t    fname = (char_u *)\"\";\n\tfname = vim_strsave(fname);\t/* make a copy, so we can change it */\n    }\n    else\n    {\n\tsfname = vim_strsave(fname);\n\t/* Don't try expanding FileType, Syntax, FuncUndefined, WindowID,\n\t * ColorScheme or QuickFixCmd* */\n\tif (event == EVENT_FILETYPE\n\t\t|| event == EVENT_SYNTAX\n\t\t|| event == EVENT_FUNCUNDEFINED\n\t\t|| event == EVENT_REMOTEREPLY\n\t\t|| event == EVENT_SPELLFILEMISSING\n\t\t|| event == EVENT_QUICKFIXCMDPRE\n\t\t|| event == EVENT_COLORSCHEME\n\t\t|| event == EVENT_OPTIONSET\n\t\t|| event == EVENT_QUICKFIXCMDPOST)\n\t    fname = vim_strsave(fname);\n\telse\n\t    fname = FullName_save(fname, FALSE);\n    }\n    if (fname == NULL)\t    /* out of memory */\n    {\n\tvim_free(sfname);\n\tretval = FALSE;\n\tgoto BYPASS_AU;\n    }\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n#ifdef VMS\n    /* remove version for correct match */\n    if (sfname != NULL)\n\tvms_remove_version(sfname);\n    vms_remove_version(fname);\n#endif\n\n    /*\n     * Set the name to be used for <amatch>.\n     */\n    autocmd_match = fname;\n\n\n    /* Don't redraw while doing auto commands. */\n    ++RedrawingDisabled;\n    save_sourcing_name = sourcing_name;\n    sourcing_name = NULL;\t/* don't free this one */\n    save_sourcing_lnum = sourcing_lnum;\n    sourcing_lnum = 0;\t\t/* no line number here */\n\n#ifdef FEAT_EVAL\n    save_current_SID = current_SID;\n\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time); /* doesn't count for the caller itself */\n# endif\n\n    /* Don't use local function variables, if called from a function */\n    save_funccalp = save_funccal();\n#endif\n\n    /*\n     * When starting to execute autocommands, save the search patterns.\n     */\n    if (!autocmd_busy)\n    {\n\tsave_search_patterns();\n#ifdef FEAT_INS_EXPAND\n\tif (!ins_compl_active())\n#endif\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redobuff = TRUE;\n\t}\n\tdid_filetype = keep_filetype;\n    }\n\n    /*\n     * Note that we are applying autocmds.  Some commands need to know.\n     */\n    autocmd_busy = TRUE;\n    filechangeshell_busy = (event == EVENT_FILECHANGEDSHELL);\n    ++nesting;\t\t/* see matching decrement below */\n\n    /* Remember that FileType was triggered.  Used for did_filetype(). */\n    if (event == EVENT_FILETYPE)\n\tdid_filetype = TRUE;\n\n    tail = gettail(fname);\n\n    /* Find first autocommand that matches */\n    patcmd.curpat = first_autopat[(int)event];\n    patcmd.nextcmd = NULL;\n    patcmd.group = group;\n    patcmd.fname = fname;\n    patcmd.sfname = sfname;\n    patcmd.tail = tail;\n    patcmd.event = event;\n    patcmd.arg_bufnr = autocmd_bufnr;\n    patcmd.next = NULL;\n    auto_next_pat(&patcmd, FALSE);\n\n    /* found one, start executing the autocommands */\n    if (patcmd.curpat != NULL)\n    {\n\t/* add to active_apc_list */\n\tpatcmd.next = active_apc_list;\n\tactive_apc_list = &patcmd;\n\n#ifdef FEAT_EVAL\n\t/* set v:cmdarg (only when there is a matching pattern) */\n\tsave_cmdbang = (long)get_vim_var_nr(VV_CMDBANG);\n\tif (eap != NULL)\n\t{\n\t    save_cmdarg = set_cmdarg(eap, NULL);\n\t    set_vim_var_nr(VV_CMDBANG, (long)eap->forceit);\n\t}\n\telse\n\t    save_cmdarg = NULL;\t/* avoid gcc warning */\n#endif\n\tretval = TRUE;\n\t/* mark the last pattern, to avoid an endless loop when more patterns\n\t * are added when executing autocommands */\n\tfor (ap = patcmd.curpat; ap->next != NULL; ap = ap->next)\n\t    ap->last = FALSE;\n\tap->last = TRUE;\n\tcheck_lnums(TRUE);\t/* make sure cursor and topline are valid */\n\tdo_cmdline(NULL, getnextac, (void *)&patcmd,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n#ifdef FEAT_EVAL\n\tif (eap != NULL)\n\t{\n\t    (void)set_cmdarg(NULL, save_cmdarg);\n\t    set_vim_var_nr(VV_CMDBANG, save_cmdbang);\n\t}\n#endif\n\t/* delete from active_apc_list */\n\tif (active_apc_list == &patcmd)\t    /* just in case */\n\t    active_apc_list = patcmd.next;\n    }\n\n    --RedrawingDisabled;\n    autocmd_busy = save_autocmd_busy;\n    filechangeshell_busy = FALSE;\n    autocmd_nested = save_autocmd_nested;\n    vim_free(sourcing_name);\n    sourcing_name = save_sourcing_name;\n    sourcing_lnum = save_sourcing_lnum;\n    vim_free(autocmd_fname);\n    autocmd_fname = save_autocmd_fname;\n    autocmd_fname_full = save_autocmd_fname_full;\n    autocmd_bufnr = save_autocmd_bufnr;\n    autocmd_match = save_autocmd_match;\n#ifdef FEAT_EVAL\n    current_SID = save_current_SID;\n    restore_funccal(save_funccalp);\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n    vim_free(fname);\n    vim_free(sfname);\n    --nesting;\t\t/* see matching increment above */\n\n    /*\n     * When stopping to execute autocommands, restore the search patterns and\n     * the redo buffer.  Free any buffers in the au_pending_free_buf list and\n     * free any windows in the au_pending_free_win list.\n     */\n    if (!autocmd_busy)\n    {\n\trestore_search_patterns();\n\tif (did_save_redobuff)\n\t    restoreRedobuff(&save_redo);\n\tdid_filetype = FALSE;\n\twhile (au_pending_free_buf != NULL)\n\t{\n\t    buf_T *b = au_pending_free_buf->b_next;\n\t    vim_free(au_pending_free_buf);\n\t    au_pending_free_buf = b;\n\t}\n\twhile (au_pending_free_win != NULL)\n\t{\n\t    win_T *w = au_pending_free_win->w_next;\n\t    vim_free(au_pending_free_win);\n\t    au_pending_free_win = w;\n\t}\n    }\n\n    /*\n     * Some events don't set or reset the Changed flag.\n     * Check if still in the same buffer!\n     */\n    if (curbuf == old_curbuf\n\t    && (event == EVENT_BUFREADPOST\n\t\t|| event == EVENT_BUFWRITEPOST\n\t\t|| event == EVENT_FILEAPPENDPOST\n\t\t|| event == EVENT_VIMLEAVE\n\t\t|| event == EVENT_VIMLEAVEPRE))\n    {\n#ifdef FEAT_TITLE\n\tif (curbuf->b_changed != save_changed)\n\t    need_maketitle = TRUE;\n#endif\n\tcurbuf->b_changed = save_changed;\n    }\n\n    au_cleanup();\t/* may really delete removed patterns/commands now */\n\nBYPASS_AU:\n    /* When wiping out a buffer make sure all its buffer-local autocommands\n     * are deleted. */\n    if (event == EVENT_BUFWIPEOUT && buf != NULL)\n\taubuflocal_remove(buf);\n\n    if (retval == OK && event == EVENT_FILETYPE)\n\tau_did_filetype = TRUE;\n\n    return retval;\n}\n\n# ifdef FEAT_EVAL\nstatic char_u\t*old_termresponse = NULL;\n# endif\n\n/*\n * Block triggering autocommands until unblock_autocmd() is called.\n * Can be used recursively, so long as it's symmetric.\n */\n    void\nblock_autocmds(void)\n{\n# ifdef FEAT_EVAL\n    /* Remember the value of v:termresponse. */\n    if (autocmd_blocked == 0)\n\told_termresponse = get_vim_var_str(VV_TERMRESPONSE);\n# endif\n    ++autocmd_blocked;\n}\n\n    void\nunblock_autocmds(void)\n{\n    --autocmd_blocked;\n\n# ifdef FEAT_EVAL\n    /* When v:termresponse was set while autocommands were blocked, trigger\n     * the autocommands now.  Esp. useful when executing a shell command\n     * during startup (vimdiff). */\n    if (autocmd_blocked == 0\n\t\t      && get_vim_var_str(VV_TERMRESPONSE) != old_termresponse)\n\tapply_autocmds(EVENT_TERMRESPONSE, NULL, NULL, FALSE, curbuf);\n# endif\n}\n\n    int\nis_autocmd_blocked(void)\n{\n    return autocmd_blocked != 0;\n}\n\n/*\n * Find next autocommand pattern that matches.\n */\n    static void\nauto_next_pat(\n    AutoPatCmd\t*apc,\n    int\t\tstop_at_last)\t    /* stop when 'last' flag is set */\n{\n    AutoPat\t*ap;\n    AutoCmd\t*cp;\n    char_u\t*name;\n    char\t*s;\n\n    vim_free(sourcing_name);\n    sourcing_name = NULL;\n\n    for (ap = apc->curpat; ap != NULL && !got_int; ap = ap->next)\n    {\n\tapc->curpat = NULL;\n\n\t/* Only use a pattern when it has not been removed, has commands and\n\t * the group matches. For buffer-local autocommands only check the\n\t * buffer number. */\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t\t&& (apc->group == AUGROUP_ALL || apc->group == ap->group))\n\t{\n\t    /* execution-condition */\n\t    if (ap->buflocal_nr == 0\n\t\t    ? (match_file_pat(NULL, &ap->reg_prog, apc->fname,\n\t\t\t\t      apc->sfname, apc->tail, ap->allow_dirs))\n\t\t    : ap->buflocal_nr == apc->arg_bufnr)\n\t    {\n\t\tname = event_nr2name(apc->event);\n\t\ts = _(\"%s Auto commands for \\\"%s\\\"\");\n\t\tsourcing_name = alloc((unsigned)(STRLEN(s)\n\t\t\t\t\t    + STRLEN(name) + ap->patlen + 1));\n\t\tif (sourcing_name != NULL)\n\t\t{\n\t\t    sprintf((char *)sourcing_name, s,\n\t\t\t\t\t       (char *)name, (char *)ap->pat);\n\t\t    if (p_verbose >= 8)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg((char_u *)_(\"Executing %s\"), sourcing_name);\n\t\t\tverbose_leave();\n\t\t    }\n\t\t}\n\n\t\tapc->curpat = ap;\n\t\tapc->nextcmd = ap->cmds;\n\t\t/* mark last command */\n\t\tfor (cp = ap->cmds; cp->next != NULL; cp = cp->next)\n\t\t    cp->last = FALSE;\n\t\tcp->last = TRUE;\n\t    }\n\t    line_breakcheck();\n\t    if (apc->curpat != NULL)\t    /* found a match */\n\t\tbreak;\n\t}\n\tif (stop_at_last && ap->last)\n\t    break;\n    }\n}\n\n/*\n * Get next autocommand command.\n * Called by do_cmdline() to get the next line for \":if\".\n * Returns allocated string, or NULL for end of autocommands.\n */\n    char_u *\ngetnextac(int c UNUSED, void *cookie, int indent UNUSED)\n{\n    AutoPatCmd\t    *acp = (AutoPatCmd *)cookie;\n    char_u\t    *retval;\n    AutoCmd\t    *ac;\n\n    /* Can be called again after returning the last line. */\n    if (acp->curpat == NULL)\n\treturn NULL;\n\n    /* repeat until we find an autocommand to execute */\n    for (;;)\n    {\n\t/* skip removed commands */\n\twhile (acp->nextcmd != NULL && acp->nextcmd->cmd == NULL)\n\t    if (acp->nextcmd->last)\n\t\tacp->nextcmd = NULL;\n\t    else\n\t\tacp->nextcmd = acp->nextcmd->next;\n\n\tif (acp->nextcmd != NULL)\n\t    break;\n\n\t/* at end of commands, find next pattern that matches */\n\tif (acp->curpat->last)\n\t    acp->curpat = NULL;\n\telse\n\t    acp->curpat = acp->curpat->next;\n\tif (acp->curpat != NULL)\n\t    auto_next_pat(acp, TRUE);\n\tif (acp->curpat == NULL)\n\t    return NULL;\n    }\n\n    ac = acp->nextcmd;\n\n    if (p_verbose >= 9)\n    {\n\tverbose_enter_scroll();\n\tsmsg((char_u *)_(\"autocommand %s\"), ac->cmd);\n\tmsg_puts((char_u *)\"\\n\");   /* don't overwrite this either */\n\tverbose_leave_scroll();\n    }\n    retval = vim_strsave(ac->cmd);\n    autocmd_nested = ac->nested;\n#ifdef FEAT_EVAL\n    current_SID = ac->scriptID;\n#endif\n    if (ac->last)\n\tacp->nextcmd = NULL;\n    else\n\tacp->nextcmd = ac->next;\n    return retval;\n}\n\n/*\n * Return TRUE if there is a matching autocommand for \"fname\".\n * To account for buffer-local autocommands, function needs to know\n * in which buffer the file will be opened.\n */\n    int\nhas_autocmd(event_T event, char_u *sfname, buf_T *buf)\n{\n    AutoPat\t*ap;\n    char_u\t*fname;\n    char_u\t*tail = gettail(sfname);\n    int\t\tretval = FALSE;\n\n    fname = FullName_save(sfname, FALSE);\n    if (fname == NULL)\n\treturn FALSE;\n\n#ifdef BACKSLASH_IN_FILENAME\n    /*\n     * Replace all backslashes with forward slashes.  This makes the\n     * autocommand patterns portable between Unix and MS-DOS.\n     */\n    sfname = vim_strsave(sfname);\n    if (sfname != NULL)\n\tforward_slash(sfname);\n    forward_slash(fname);\n#endif\n\n    for (ap = first_autopat[(int)event]; ap != NULL; ap = ap->next)\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t      && (ap->buflocal_nr == 0\n\t\t? match_file_pat(NULL, &ap->reg_prog,\n\t\t\t\t\t  fname, sfname, tail, ap->allow_dirs)\n\t\t: buf != NULL && ap->buflocal_nr == buf->b_fnum\n\t   ))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\n    vim_free(fname);\n#ifdef BACKSLASH_IN_FILENAME\n    vim_free(sfname);\n#endif\n\n    return retval;\n}\n\n#if defined(FEAT_CMDL_COMPL) || defined(PROTO)\n/*\n * Function given to ExpandGeneric() to obtain the list of autocommand group\n * names.\n */\n    char_u *\nget_augroup_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx == augroups.ga_len)\t\t/* add \"END\" add the end */\n\treturn (char_u *)\"END\";\n    if (idx >= augroups.ga_len)\t\t/* end of list */\n\treturn NULL;\n    if (AUGROUP_NAME(idx) == NULL || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t/* skip deleted entries */\n\treturn (char_u *)\"\";\n    return AUGROUP_NAME(idx);\t\t/* return a name */\n}\n\nstatic int include_groups = FALSE;\n\n    char_u  *\nset_context_in_autocmd(\n    expand_T\t*xp,\n    char_u\t*arg,\n    int\t\tdoautocmd)\t/* TRUE for :doauto*, FALSE for :autocmd */\n{\n    char_u\t*p;\n    int\t\tgroup;\n\n    /* check for a group name, skip it if present */\n    include_groups = FALSE;\n    p = arg;\n    group = au_get_grouparg(&arg);\n    if (group == AUGROUP_ERROR)\n\treturn NULL;\n    /* If there only is a group name that's what we expand. */\n    if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))\n    {\n\targ = p;\n\tgroup = AUGROUP_ALL;\n    }\n\n    /* skip over event name */\n    for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)\n\tif (*p == ',')\n\t    arg = p + 1;\n    if (*p == NUL)\n    {\n\tif (group == AUGROUP_ALL)\n\t    include_groups = TRUE;\n\txp->xp_context = EXPAND_EVENTS;\t    /* expand event name */\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    /* skip over pattern */\n    arg = skipwhite(p);\n    while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\\\'))\n\targ++;\n    if (*arg)\n\treturn arg;\t\t\t    /* expand (next) command */\n\n    if (doautocmd)\n\txp->xp_context = EXPAND_FILES;\t    /* expand file names */\n    else\n\txp->xp_context = EXPAND_NOTHING;    /* pattern is not expanded */\n    return NULL;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of event names.\n */\n    char_u *\nget_event_name(expand_T *xp UNUSED, int idx)\n{\n    if (idx < augroups.ga_len)\t\t/* First list group names, if wanted */\n    {\n\tif (!include_groups || AUGROUP_NAME(idx) == NULL\n\t\t\t\t || AUGROUP_NAME(idx) == get_deleted_augroup())\n\t    return (char_u *)\"\";\t/* skip deleted entries */\n\treturn AUGROUP_NAME(idx);\t/* return a name */\n    }\n    return (char_u *)event_names[idx - augroups.ga_len].name;\n}\n\n#endif\t/* FEAT_CMDL_COMPL */\n\n/*\n * Return TRUE if autocmd is supported.\n */\n    int\nautocmd_supported(char_u *name)\n{\n    char_u *p;\n\n    return (event_name2nr(name, &p) != NUM_EVENTS);\n}\n\n/*\n * Return TRUE if an autocommand is defined for a group, event and\n * pattern:  The group can be omitted to accept any group. \"event\" and \"pattern\"\n * can be NULL to accept any event and pattern. \"pattern\" can be NULL to accept\n * any pattern. Buffer-local patterns <buffer> or <buffer=N> are accepted.\n * Used for:\n *\texists(\"#Group\") or\n *\texists(\"#Group#Event\") or\n *\texists(\"#Group#Event#pat\") or\n *\texists(\"#Event\") or\n *\texists(\"#Event#pat\")\n */\n    int\nau_exists(char_u *arg)\n{\n    char_u\t*arg_save;\n    char_u\t*pattern = NULL;\n    char_u\t*event_name;\n    char_u\t*p;\n    event_T\tevent;\n    AutoPat\t*ap;\n    buf_T\t*buflocal_buf = NULL;\n    int\t\tgroup;\n    int\t\tretval = FALSE;\n\n    /* Make a copy so that we can change the '#' chars to a NUL. */\n    arg_save = vim_strsave(arg);\n    if (arg_save == NULL)\n\treturn FALSE;\n    p = vim_strchr(arg_save, '#');\n    if (p != NULL)\n\t*p++ = NUL;\n\n    /* First, look for an autocmd group name */\n    group = au_find_group(arg_save);\n    if (group == AUGROUP_ERROR)\n    {\n\t/* Didn't match a group name, assume the first argument is an event. */\n\tgroup = AUGROUP_ALL;\n\tevent_name = arg_save;\n    }\n    else\n    {\n\tif (p == NULL)\n\t{\n\t    /* \"Group\": group name is present and it's recognized */\n\t    retval = TRUE;\n\t    goto theend;\n\t}\n\n\t/* Must be \"Group#Event\" or \"Group#Event#pat\". */\n\tevent_name = p;\n\tp = vim_strchr(event_name, '#');\n\tif (p != NULL)\n\t    *p++ = NUL;\t    /* \"Group#Event#pat\" */\n    }\n\n    pattern = p;\t    /* \"pattern\" is NULL when there is no pattern */\n\n    /* find the index (enum) for the event name */\n    event = event_name2nr(event_name, &p);\n\n    /* return FALSE if the event name is not recognized */\n    if (event == NUM_EVENTS)\n\tgoto theend;\n\n    /* Find the first autocommand for this event.\n     * If there isn't any, return FALSE;\n     * If there is one and no pattern given, return TRUE; */\n    ap = first_autopat[(int)event];\n    if (ap == NULL)\n\tgoto theend;\n\n    /* if pattern is \"<buffer>\", special handling is needed which uses curbuf */\n    /* for pattern \"<buffer=N>, fnamecmp() will work fine */\n    if (pattern != NULL && STRICMP(pattern, \"<buffer>\") == 0)\n\tbuflocal_buf = curbuf;\n\n    /* Check if there is an autocommand with the given pattern. */\n    for ( ; ap != NULL; ap = ap->next)\n\t/* only use a pattern when it has not been removed and has commands. */\n\t/* For buffer-local autocommands, fnamecmp() works fine. */\n\tif (ap->pat != NULL && ap->cmds != NULL\n\t    && (group == AUGROUP_ALL || ap->group == group)\n\t    && (pattern == NULL\n\t\t|| (buflocal_buf == NULL\n\t\t    ? fnamecmp(ap->pat, pattern) == 0\n\t\t    : ap->buflocal_nr == buflocal_buf->b_fnum)))\n\t{\n\t    retval = TRUE;\n\t    break;\n\t}\n\ntheend:\n    vim_free(arg_save);\n    return retval;\n}\n\n#else\t/* FEAT_AUTOCMD */\n\n/*\n * Prepare for executing commands for (hidden) buffer \"buf\".\n * This is the non-autocommand version, it simply saves \"curbuf\" and sets\n * \"curbuf\" and \"curwin\" to match \"buf\".\n */\n    void\naucmd_prepbuf(\n    aco_save_T\t*aco,\t\t/* structure to save values in */\n    buf_T\t*buf)\t\t/* new curbuf */\n{\n    aco->save_curbuf = curbuf;\n    --curbuf->b_nwindows;\n    curbuf = buf;\n    curwin->w_buffer = buf;\n    ++curbuf->b_nwindows;\n}\n\n/*\n * Restore after executing commands for a (hidden) buffer.\n * This is the non-autocommand version.\n */\n    void\naucmd_restbuf(\n    aco_save_T\t*aco)\t\t/* structure holding saved values */\n{\n    --curbuf->b_nwindows;\n    curbuf = aco->save_curbuf;\n    curwin->w_buffer = curbuf;\n    ++curbuf->b_nwindows;\n}\n\n#endif\t/* FEAT_AUTOCMD */\n\n\n#if defined(FEAT_AUTOCMD) || defined(FEAT_WILDIGN) || defined(PROTO)\n/*\n * Try matching a filename with a \"pattern\" (\"prog\" is NULL), or use the\n * precompiled regprog \"prog\" (\"pattern\" is NULL).  That avoids calling\n * vim_regcomp() often.\n * Used for autocommands and 'wildignore'.\n * Returns TRUE if there is a match, FALSE otherwise.\n */\n    static int\nmatch_file_pat(\n    char_u\t*pattern,\t\t/* pattern to match with */\n    regprog_T\t**prog,\t\t\t/* pre-compiled regprog or NULL */\n    char_u\t*fname,\t\t\t/* full path of file name */\n    char_u\t*sfname,\t\t/* short file name or NULL */\n    char_u\t*tail,\t\t\t/* tail of path */\n    int\t\tallow_dirs)\t\t/* allow matching with dir */\n{\n    regmatch_T\tregmatch;\n    int\t\tresult = FALSE;\n\n    regmatch.rm_ic = p_fic; /* ignore case if 'fileignorecase' is set */\n    if (prog != NULL)\n\tregmatch.regprog = *prog;\n    else\n\tregmatch.regprog = vim_regcomp(pattern, RE_MAGIC);\n\n    /*\n     * Try for a match with the pattern with:\n     * 1. the full file name, when the pattern has a '/'.\n     * 2. the short file name, when the pattern has a '/'.\n     * 3. the tail of the file name, when the pattern has no '/'.\n     */\n    if (regmatch.regprog != NULL\n\t     && ((allow_dirs\n\t\t     && (vim_regexec(&regmatch, fname, (colnr_T)0)\n\t\t\t || (sfname != NULL\n\t\t\t     && vim_regexec(&regmatch, sfname, (colnr_T)0))))\n\t\t || (!allow_dirs && vim_regexec(&regmatch, tail, (colnr_T)0))))\n\tresult = TRUE;\n\n    if (prog != NULL)\n\t*prog = regmatch.regprog;\n    else\n\tvim_regfree(regmatch.regprog);\n    return result;\n}\n#endif\n\n#if defined(FEAT_WILDIGN) || defined(PROTO)\n/*\n * Return TRUE if a file matches with a pattern in \"list\".\n * \"list\" is a comma-separated list of patterns, like 'wildignore'.\n * \"sfname\" is the short file name or NULL, \"ffname\" the long file name.\n */\n    int\nmatch_file_list(char_u *list, char_u *sfname, char_u *ffname)\n{\n    char_u\tbuf[100];\n    char_u\t*tail;\n    char_u\t*regpat;\n    char\tallow_dirs;\n    int\t\tmatch;\n    char_u\t*p;\n\n    tail = gettail(sfname);\n\n    /* try all patterns in 'wildignore' */\n    p = list;\n    while (*p)\n    {\n\tcopy_option_part(&p, buf, 100, \",\");\n\tregpat = file_pat_to_reg_pat(buf, NULL, &allow_dirs, FALSE);\n\tif (regpat == NULL)\n\t    break;\n\tmatch = match_file_pat(regpat, NULL, ffname, sfname,\n\t\t\t\t\t\t       tail, (int)allow_dirs);\n\tvim_free(regpat);\n\tif (match)\n\t    return TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Convert the given pattern \"pat\" which has shell style wildcards in it, into\n * a regular expression, and return the result in allocated memory.  If there\n * is a directory path separator to be matched, then TRUE is put in\n * allow_dirs, otherwise FALSE is put there -- webb.\n * Handle backslashes before special characters, like \"\\*\" and \"\\ \".\n *\n * Returns NULL when out of memory.\n */\n    char_u *\nfile_pat_to_reg_pat(\n    char_u\t*pat,\n    char_u\t*pat_end,\t/* first char after pattern or NULL */\n    char\t*allow_dirs,\t/* Result passed back out in here */\n    int\t\tno_bslash UNUSED) /* Don't use a backward slash as pathsep */\n{\n    int\t\tsize = 2; /* '^' at start, '$' at end */\n    char_u\t*endp;\n    char_u\t*reg_pat;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tnested = 0;\n    int\t\tadd_dollar = TRUE;\n\n    if (allow_dirs != NULL)\n\t*allow_dirs = FALSE;\n    if (pat_end == NULL)\n\tpat_end = pat + STRLEN(pat);\n\n    for (p = pat; p < pat_end; p++)\n    {\n\tswitch (*p)\n\t{\n\t    case '*':\n\t    case '.':\n\t    case ',':\n\t    case '{':\n\t    case '}':\n\t    case '~':\n\t\tsize += 2;\t/* extra backslash */\n\t\tbreak;\n#ifdef BACKSLASH_IN_FILENAME\n\t    case '\\\\':\n\t    case '/':\n\t\tsize += 4;\t/* could become \"[\\/]\" */\n\t\tbreak;\n#endif\n\t    default:\n\t\tsize++;\n# ifdef FEAT_MBYTE\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) > 1)\n\t\t{\n\t\t    ++p;\n\t\t    ++size;\n\t\t}\n# endif\n\t\tbreak;\n\t}\n    }\n    reg_pat = alloc(size + 1);\n    if (reg_pat == NULL)\n\treturn NULL;\n\n    i = 0;\n\n    if (pat[0] == '*')\n\twhile (pat[0] == '*' && pat < pat_end - 1)\n\t    pat++;\n    else\n\treg_pat[i++] = '^';\n    endp = pat_end - 1;\n    if (endp >= pat && *endp == '*')\n    {\n\twhile (endp - pat > 0 && *endp == '*')\n\t    endp--;\n\tadd_dollar = FALSE;\n    }\n    for (p = pat; *p && nested >= 0 && p <= endp; p++)\n    {\n\tswitch (*p)\n\t{\n\t    case '*':\n\t\treg_pat[i++] = '.';\n\t\treg_pat[i++] = '*';\n\t\twhile (p[1] == '*')\t/* \"**\" matches like \"*\" */\n\t\t    ++p;\n\t\tbreak;\n\t    case '.':\n\t    case '~':\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = *p;\n\t\tbreak;\n\t    case '?':\n\t\treg_pat[i++] = '.';\n\t\tbreak;\n\t    case '\\\\':\n\t\tif (p[1] == NUL)\n\t\t    break;\n#ifdef BACKSLASH_IN_FILENAME\n\t\tif (!no_bslash)\n\t\t{\n\t\t    /* translate:\n\t\t     * \"\\x\" to \"\\\\x\"  e.g., \"dir\\file\"\n\t\t     * \"\\*\" to \"\\\\.*\" e.g., \"dir\\*.c\"\n\t\t     * \"\\?\" to \"\\\\.\"  e.g., \"dir\\??.c\"\n\t\t     * \"\\+\" to \"\\+\"   e.g., \"fileX\\+.c\"\n\t\t     */\n\t\t    if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')\n\t\t\t    && p[1] != '+')\n\t\t    {\n\t\t\treg_pat[i++] = '[';\n\t\t\treg_pat[i++] = '\\\\';\n\t\t\treg_pat[i++] = '/';\n\t\t\treg_pat[i++] = ']';\n\t\t\tif (allow_dirs != NULL)\n\t\t\t    *allow_dirs = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n#endif\n\t\t/* Undo escaping from ExpandEscape():\n\t\t * foo\\?bar -> foo?bar\n\t\t * foo\\%bar -> foo%bar\n\t\t * foo\\,bar -> foo,bar\n\t\t * foo\\ bar -> foo bar\n\t\t * Don't unescape \\, * and others that are also special in a\n\t\t * regexp.\n\t\t * An escaped { must be unescaped since we use magic not\n\t\t * verymagic.  Use \"\\\\\\{n,m\\}\"\" to get \"\\{n,m}\".\n\t\t */\n\t\tif (*++p == '?'\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t&& no_bslash\n#endif\n\t\t\t)\n\t\t    reg_pat[i++] = '?';\n\t\telse\n\t\t    if (*p == ',' || *p == '%' || *p == '#'\n\t\t\t       || vim_isspace(*p) || *p == '{' || *p == '}')\n\t\t\treg_pat[i++] = *p;\n\t\t    else if (*p == '\\\\' && p[1] == '\\\\' && p[2] == '{')\n\t\t    {\n\t\t\treg_pat[i++] = '\\\\';\n\t\t\treg_pat[i++] = '{';\n\t\t\tp += 2;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (allow_dirs != NULL && vim_ispathsep(*p)\n#ifdef BACKSLASH_IN_FILENAME\n\t\t\t\t&& (!no_bslash || *p != '\\\\')\n#endif\n\t\t\t\t)\n\t\t\t    *allow_dirs = TRUE;\n\t\t\treg_pat[i++] = '\\\\';\n\t\t\treg_pat[i++] = *p;\n\t\t    }\n\t\tbreak;\n#ifdef BACKSLASH_IN_FILENAME\n\t    case '/':\n\t\treg_pat[i++] = '[';\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = '/';\n\t\treg_pat[i++] = ']';\n\t\tif (allow_dirs != NULL)\n\t\t    *allow_dirs = TRUE;\n\t\tbreak;\n#endif\n\t    case '{':\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = '(';\n\t\tnested++;\n\t\tbreak;\n\t    case '}':\n\t\treg_pat[i++] = '\\\\';\n\t\treg_pat[i++] = ')';\n\t\t--nested;\n\t\tbreak;\n\t    case ',':\n\t\tif (nested)\n\t\t{\n\t\t    reg_pat[i++] = '\\\\';\n\t\t    reg_pat[i++] = '|';\n\t\t}\n\t\telse\n\t\t    reg_pat[i++] = ',';\n\t\tbreak;\n\t    default:\n# ifdef  FEAT_MBYTE\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) > 1)\n\t\t    reg_pat[i++] = *p++;\n\t\telse\n# endif\n\t\tif (allow_dirs != NULL && vim_ispathsep(*p))\n\t\t    *allow_dirs = TRUE;\n\t\treg_pat[i++] = *p;\n\t\tbreak;\n\t}\n    }\n    if (add_dollar)\n\treg_pat[i++] = '$';\n    reg_pat[i] = NUL;\n    if (nested != 0)\n    {\n\tif (nested < 0)\n\t    EMSG(_(\"E219: Missing {.\"));\n\telse\n\t    EMSG(_(\"E220: Missing }.\"));\n\tvim_free(reg_pat);\n\treg_pat = NULL;\n    }\n    return reg_pat;\n}\n\n#if defined(EINTR) || defined(PROTO)\n/*\n * Version of read() that retries when interrupted by EINTR (possibly\n * by a SIGWINCH).\n */\n    long\nread_eintr(int fd, void *buf, size_t bufsize)\n{\n    long ret;\n\n    for (;;)\n    {\n\tret = vim_read(fd, buf, bufsize);\n\tif (ret >= 0 || errno != EINTR)\n\t    break;\n    }\n    return ret;\n}\n\n/*\n * Version of write() that retries when interrupted by EINTR (possibly\n * by a SIGWINCH).\n */\n    long\nwrite_eintr(int fd, void *buf, size_t bufsize)\n{\n    long    ret = 0;\n    long    wlen;\n\n    /* Repeat the write() so long it didn't fail, other than being interrupted\n     * by a signal. */\n    while (ret < (long)bufsize)\n    {\n\twlen = vim_write(fd, (char *)buf + ret, bufsize - ret);\n\tif (wlen < 0)\n\t{\n\t    if (errno != EINTR)\n\t\tbreak;\n\t}\n\telse\n\t    ret += wlen;\n    }\n    return ret;\n}\n#endif\n", "\" Tests for the swap feature\n\n\"\" Tests for 'directory' option.\n\"func Test_swap_directory()\n\"  if !has(\"unix\")\n\"    return\n\"  endif\n\"  let content = ['start of testfile',\n\"\t      \\ 'line 2 Abcdefghij',\n\"\t      \\ 'line 3 Abcdefghij',\n\"\t      \\ 'end of testfile']\n\"  call writefile(content, 'Xtest1')\n\"\n\"  \"  '.', swap file in the same directory as file\n\"  set dir=.,~\n\"\n\"  \" Verify that the swap file doesn't exist in the current directory\n\"  call assert_equal([], glob(\".Xtest1*.swp\", 1, 1, 1))\n\"  edit Xtest1\n\"  let swfname = split(execute(\"swapname\"))[0]\n\"  call assert_equal([swfname], glob(swfname, 1, 1, 1))\n\"\n\"  \" './dir', swap file in a directory relative to the file\n\"  set dir=./Xtest2,.,~\n\"\n\"  call mkdir(\"Xtest2\")\n\"  edit Xtest1\n\"  call assert_equal([], glob(swfname, 1, 1, 1))\n\"  let swfname = \"Xtest2/Xtest1.swp\"\n\"  call assert_equal(swfname, split(execute(\"swapname\"))[0])\n\"  call assert_equal([swfname], glob(\"Xtest2/*\", 1, 1, 1))\n\"\n\"  \" 'dir', swap file in directory relative to the current dir\n\"  set dir=Xtest.je,~\n\"\n\"  call mkdir(\"Xtest.je\")\n\"  call writefile(content, 'Xtest2/Xtest3')\n\"  edit Xtest2/Xtest3\n\"  call assert_equal([\"Xtest2/Xtest3\"], glob(\"Xtest2/*\", 1, 1, 1))\n\"  let swfname = \"Xtest.je/Xtest3.swp\"\n\"  call assert_equal(swfname, split(execute(\"swapname\"))[0])\n\"  call assert_equal([swfname], glob(\"Xtest.je/*\", 1, 1, 1))\n\"\n\"  set dir&\n\"  call delete(\"Xtest1\")\n\"  call delete(\"Xtest2\", \"rf\")\n\"  call delete(\"Xtest.je\", \"rf\")\n\"endfunc\n\nfunc Test_swap_group()\n  if !has(\"unix\")\n    return\n  endif\n  let groups = split(system('groups'))\n  if len(groups) <= 1\n    throw 'Skipped: need at least two groups, got ' . groups\n  endif\n\n  call delete('Xtest')\n  split Xtest\n  call setline(1, 'just some text')\n  wq\n  if system('ls -l Xtest') !~ ' ' . groups[0] . ' \\d'\n    throw 'Skipped: test file does not have the first group'\n  else\n    silent !chmod 640 Xtest\n    call system('chgrp ' . groups[1] . ' Xtest')\n    if system('ls -l Xtest') !~ ' ' . groups[1] . ' \\d'\n      throw 'Skipped: cannot set second group on test file'\n    else\n      split Xtest\n      let swapname = substitute(execute('swapname'), '[[:space:]]', '', 'g')\n      call assert_match('Xtest', swapname)\n      \" Group of swapfile must now match original file.\n      call assert_match(' ' . groups[1] . ' \\d', system('ls -l ' . swapname))\n\n      bwipe!\n    endif\n  endif\n\n  call delete('Xtest')\nendfunc\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n#ifdef AMIGA\n# include <time.h>\t/* for time() */\n#endif\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\nmake_version(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't catenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n    strcat(longVersion, \")\");\n}\n# else\nchar\t*longVersion = VIM_VERSION_LONG_DATE __DATE__ \" \" __TIME__ \")\";\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n#endif\n\nstatic void list_features(void);\nstatic void version_msg(char *s);\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t/* only for Amiga systems */\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n#ifdef FEAT_AUTOCMD\n\t\"+autocmd\",\n#else\n\t\"-autocmd\",\n#endif\n#ifdef FEAT_BEVAL\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n#ifdef FEAT_CMDL_COMPL\n\t\"+cmdline_compl\",\n#else\n\t\"-cmdline_compl\",\n#endif\n#ifdef FEAT_CMDHIST\n\t\"+cmdline_hist\",\n#else\n\t\"-cmdline_hist\",\n#endif\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n#ifdef FEAT_COMMENTS\n\t\"+comments\",\n#else\n\t\"-comments\",\n#endif\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n#ifdef FEAT_CURSORBIND\n\t\"+cursorbind\",\n#else\n\t\"-cursorbind\",\n#endif\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n#ifdef FEAT_FKMAP\n\t\"+farsi\",\n#else\n\t\"-farsi\",\n#endif\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    /* only interesting on Unix systems */\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n#ifdef FEAT_HANGULIN\n\t\"+hangul_input\",\n#else\n\t\"-hangul_input\",\n#endif\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n#ifdef FEAT_INS_EXPAND\n\t\"+insert_expand\",\n#else\n\t\"-insert_expand\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n#ifdef FEAT_LISTCMDS\n\t\"+listcmds\",\n#else\n\t\"-listcmds\",\n#endif\n#ifdef FEAT_LOCALMAP\n\t\"+localmap\",\n#else\n\t\"-localmap\",\n#endif\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n#ifdef FEAT_MODIFY_FNAME\n\t\"+modify_fname\",\n#else\n\t\"-modify_fname\",\n#endif\n#ifdef FEAT_MOUSE\n\t\"+mouse\",\n#  ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#  else\n\t\"-mouseshape\",\n#  endif\n# else\n\t\"-mouse\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_SGR\n\t\"+mouse_sgr\",\n# else\n\t\"-mouse_sgr\",\n# endif\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n# ifdef FEAT_MOUSE_XTERM\n\t\"+mouse_xterm\",\n# else\n\t\"-mouse_xterm\",\n# endif\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n# ifdef FEAT_MBYTE\n\t\"+multi_byte\",\n# else\n\t\"-multi_byte\",\n# endif\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n#ifdef FEAT_NUM64\n\t\"+num64\",\n#else\n\t\"-num64\",\n#endif\n#ifdef FEAT_GUI_W32\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n\t\"+packages\",\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n#ifdef FEAT_SCROLLBIND\n\t\"+scrollbind\",\n#else\n\t\"-scrollbind\",\n#endif\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n#ifdef FEAT_SUN_WORKSHOP\n\t\"+sun_workshop\",\n#else\n\t\"-sun_workshop\",\n#endif\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    /* only interesting on Unix systems */\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n#ifdef FEAT_TAG_OLDSTATIC\n\t\"+tag_old_static\",\n#else\n\t\"-tag_old_static\",\n#endif\n#ifdef FEAT_TAG_ANYWHITE\n\t\"+tag_any_white\",\n#else\n\t\"-tag_any_white\",\n#endif\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n/* only Unix can have terminfo instead of termcap */\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#else\t\t    /* unix always includes termcap support */\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n#ifdef FEAT_USR_CMDS\n\t\"+user_commands\",\n#else\n\t\"-user_commands\",\n#endif\n\t\"+vertsplit\",\n#ifdef FEAT_VIRTUALEDIT\n\t\"+virtualedit\",\n#else\n\t\"-virtualedit\",\n#endif\n\t\"+visual\",\n#ifdef FEAT_VISUALEXTRA\n\t\"+visualextra\",\n#else\n\t\"-visualextra\",\n#endif\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n#ifdef FEAT_VREPLACE\n\t\"+vreplace\",\n#else\n\t\"-vreplace\",\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef WIN3264\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    int\t\ti;\n    int\t\th = 0;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] > h)\n\t    h = included_patches[i];\n    return h;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\ti;\n\n    for (i = 0; included_patches[i] != 0; ++i)\n\tif (included_patches[i] == n)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tnfeat = 0;\n    int\t\twidth = 0;\n\n    /* Find the length of the longest feature name, use that + 1 as the column\n     * width */\n    for (i = 0; features[i] != NULL; ++i)\n    {\n\tint l = (int)STRLEN(features[i]);\n\n\tif (l > width)\n\t    width = l;\n\t++nfeat;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t/* Not enough screen columns - show one per line */\n\tfor (i = 0; features[i] != NULL; ++i)\n\t{\n\t    version_msg(features[i]);\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    /* The rightmost column doesn't need a separator.\n     * Sacrifice it to fit in one more column if possible. */\n    ncol = (int) (Columns + 1) / width;\n    nrow = nfeat / ncol + (nfeat % ncol ? 1 : 0);\n\n    /* i counts columns then rows.  idx counts rows then columns. */\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < nfeat)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    msg_puts((char_u *)features[idx]);\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0)\n\t\t    msg_putchar('\\n');\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    if (msg_col > 0)\n\t\tmsg_putchar('\\n');\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    MSG(longVersion);\n#ifdef WIN3264\n# ifdef FEAT_GUI_W32\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit GUI version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit GUI version\"));\n#  endif\n# ifdef FEAT_OLE\n    MSG_PUTS(_(\" with OLE support\"));\n# endif\n# else\n#  ifdef _WIN64\n    MSG_PUTS(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    MSG_PUTS(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    MSG_PUTS(_(\"\\nmacOS version\"));\n# else\n    MSG_PUTS(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n#endif\n\n#ifdef VMS\n    MSG_PUTS(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tMSG_PUTS(\" - \");\n\tMSG_PUTS(compiled_arch);\n    }\n# endif\n\n#endif\n\n    /* Print the list of patch numbers if there is at least one. */\n    /* Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\" */\n    if (included_patches[0] != 0)\n    {\n\tMSG_PUTS(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\t/* find last one */\n\tfor (i = 0; included_patches[i] != 0; ++i)\n\t    ;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tMSG_PUTS(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    MSG_PUTS(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    /* Print the list of extra patch descriptions if there is at least one. */\n    if (extra_patches[0] != NULL)\n    {\n\tMSG_PUTS(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    MSG_PUTS(s);\n\t    s = \", \";\n\t    MSG_PUTS(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    MSG_PUTS(\"\\n\");\n    MSG_PUTS(_(\"Modified by \"));\n    MSG_PUTS(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tMSG_PUTS(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    MSG_PUTS(_(\"by \"));\n\t    MSG_PUTS(compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    MSG_PUTS(\"@\");\n\t    MSG_PUTS(compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    MSG_PUTS(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    MSG_PUTS(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    MSG_PUTS(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    MSG_PUTS(_(\"\\nSmall version \"));\n#   else\n    MSG_PUTS(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    MSG_PUTS(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    MSG_PUTS(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     MSG_PUTS(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     MSG_PUTS(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    MSG_PUTS(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    MSG_PUTS(_(\"with X11-neXtaw GUI.\"));\n#    else\n    MSG_PUTS(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#     ifdef FEAT_GUI_PHOTON\n    MSG_PUTS(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    MSG_PUTS(_(\"with GUI.\"));\n#      else\n#\tif defined(TARGET_API_MAC_CARBON) && TARGET_API_MAC_CARBON\n    MSG_PUTS(_(\"with Carbon GUI.\"));\n#\telse\n#\t if defined(TARGET_API_MAC_OSX) && TARGET_API_MAC_OSX\n    MSG_PUTS(_(\"with Cocoa GUI.\"));\n#\t else\n#\t endif\n#\tendif\n#      endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n */\n    static void\nversion_msg(char *s)\n{\n    int\t\tlen = (int)STRLEN(s);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n\tMSG_PUTS(s);\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    void\nintro_message(\n    int\t\tcolon)\t\t/* TRUE for \":intro\" */\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    /* blanklines = screen height - # message lines */\n    blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);\n    if (!p_cp)\n\tblanklines += 4;  /* add 4 for not showing \"Vi compatible\" message */\n\n    /* Don't overwrite a statusline.  Depends on 'cmdheight'. */\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    /* Show the sponsor and register message one out of four times, the Uganda\n     * message two out of four times. */\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    /* start displaying the message lines after half of the blank lines */\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)(sizeof(lines) / sizeof(char *)); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    /* Make the wait-return message appear just below the text. */\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    /* Center the message horizontally. */\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    /* Check for 9.9x or 9.9xx, alpha/beta version */\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    /* Split up in parts to highlight <> items differently. */\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n#ifdef FEAT_MBYTE\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n#endif\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    /* Add the version number to the version line. */\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/Makefile", "src/fileio.c", "src/testdir/test_swap.vim", "src/version.c"], "buggy_code_start_loc": [2261, 719, 3, 763], "buggy_code_end_loc": [2261, 720, 48, 763], "fixing_code_start_loc": [2262, 719, 3, 764], "fixing_code_end_loc": [2263, 742, 82, 766], "type": "CWE-668", "message": "fileio.c in Vim prior to 8.0.1263 sets the group ownership of a .swp file to the editor's primary group (which may be different from the group ownership of the original file), which allows local users to obtain sensitive information by leveraging an applicable group membership, as demonstrated by /etc/shadow owned by root:shadow mode 0640, but /etc/.shadow.swp owned by root:users mode 0640, a different vulnerability than CVE-2017-1000382.", "other": {"cve": {"id": "CVE-2017-17087", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-01T08:29:00.670", "lastModified": "2022-02-20T05:58:55.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fileio.c in Vim prior to 8.0.1263 sets the group ownership of a .swp file to the editor's primary group (which may be different from the group ownership of the original file), which allows local users to obtain sensitive information by leveraging an applicable group membership, as demonstrated by /etc/shadow owned by root:shadow mode 0640, but /etc/.shadow.swp owned by root:users mode 0640, a different vulnerability than CVE-2017-1000382."}, {"lang": "es", "value": "fileio.c en Vim en versiones anteriores a la 8.0.1263 establece la propiedad de grupo de un archivo .swp en el grupo primario del editor (que puede ser diferente de la propiedad de grupo del archivo original), lo que permite a los usuarios locales obtener informaci\u00f3n sensible aprovechando una membres\u00eda de grupo aplicable, tal y como lo demuestra el hecho de que /etc/shadow es propiedad de root:shadow mode 0640, pero /etc/.shadow.swp es propiedad de root:users mode 0640. Esta es una vulnerabilidad diferente a CVE-2017-1000382."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.0.1263", "matchCriteriaId": "CF7D04AC-59B5-42A7-B95E-4F54D6ABDB16"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/11/27/2", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://security.cucumberlinux.com/security/details.php?id=166", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/5a73e0ca54c77e067c3b12ea6f35e3e8681e8cf8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/vim_dev/sRT9BtjLWMk/BRtSXNU4BwAJ", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/01/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4582-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/5a73e0ca54c77e067c3b12ea6f35e3e8681e8cf8"}}