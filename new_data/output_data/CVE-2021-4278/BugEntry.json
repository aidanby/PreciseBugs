{"buggy_code": ["\nv0.6.2\n------\n\n.clone() with Date support\n\n\nv0.6.1\n------\n\nNew: .dotPath.*(): a faster alternative to .path.*(), supporting only dot-separated path\n\n\nv0.6.0\n------\n\nBreaking change: .extend() 'deepFilter' option is gone 'deepFilter.whitelist' has moved to 'deep' and 'deepFilter.blacklist' has moved to 'immutables'\n\n\nv0.5.27\n-------\n\nFixed a vulnerability in .extend(), moved to ESLint, moved to Tea-Time builtin 'expect'\n\n\nv0.5.26\n-------\n\nNew: Browser lib!\n\n\nv0.5.25\n-------\n\ntree.path -- new operations: concat and insert\n\n\nv0.5.24\n-------\n\nIMPORTANT BUGFIX: clone was not working well with arrays\n\n\nv0.5.23\n-------\n\nclone interface\n\n\nv0.5.22\n-------\n\nTree.path.* now supports empty keys\n\n\nv0.5.21\n-------\n\ntree.path() now return undefined if the source object, well, is not an object (instead of throwing)\n\n\nv0.5.20\n-------\n\nBugfix: make require( 'tree-kit/lib/path.js' ) works as expected (was encapsulating everything in a 'path' sub-object)\n\n\nv0.5.19\n-------\n\nNew: tree.path.autoPush()\n\n\nv0.5.18\n-------\n\ntree.json was removed (get its own module: json-kit)\n\n\nv0.5.17\n-------\n\njson: parser run a bit faster\n\n\nv0.5.16\n-------\n\njson: parser run a bit faster\n\n\nv0.5.15\n-------\n\njson: parser is now working\n\n\nv0.5.14\n-------\n\njson.stringify() improvements\n\n\nv0.5.13\n-------\n\n\"use strict\" everywhere\n\n\nv0.5.12\n-------\n\nBechmark: ubench v0.2.x ; \"use strict\" everywhere\n\n\nv0.5.11\n-------\n\nubench benchmark\n\n\nv0.5.10\n-------\n\njson: some fixes\n\n\nv0.5.9\n------\n\njson.stringify() is now on par with native JSON.stringify()!\n\n\nv0.5.8\n------\n\njson utilities: wip\n\n\nv0.5.7\n------\n\nNew: tree.path.append() and tree.path.prepend()\n\n\nv0.5.6\n------\n\nNew feature: tree.path() now support the bracket syntax for arrays.\n\n\nv0.5.5\n------\n\nDocumentation: just added link to http://blog.soulserv.net/tag/tree-kit that points to tree-kit tutorials.\n\n\nv0.5.4\n------\n\npath: all methods return the targeted object like path.get() does.\n\n\nv0.5.3\n------\n\nNew path.*() method: path.define(), like set, but only if the targeted item does not exist\n\n\nv0.5.2\n------\n\nNew path.*() methods: path.inc() & path.dec(), that increment and decrement values\n\n\nv0.5.1\n------\n\npath.*():\n\t* tree.path.prototype can be used for inheritance, using Object.create( tree.path.prototype )\n\t* path.*() now supports path as array too (but it's still not done for array walking)\n\n\nv0.5.0\n------\n\npath.*(): pseudo-element notation use '#' instead of ':'\n\n\nv0.4.3 - v0.4.4\n---------------\n\npath.*() now support a semi-colon syntax for accessing arrays, featuring pseudo-element like :last and :next, etc.\n\n\nv0.4.2\n------\n\nNew: path submodule featuring path.get(), path.set() and path.delete(). It allows setting, getting deleting by a\n\tdot-separated path scheme.\n\n\nv0.4.1\n------\n\nclone() have now its own module/file: clone.js.\n\n\nv0.4.0\n------\n\nextend():\n\t* 'circular' & 'maxDepth' options finished, 'descriptor' option bugfix\n\nclone():\n\t* does not depend upon extend() anymore, it has been fully rewritten with optimization in mind\n\t* it does not use recursive function call but loops, which is super-efficient ;)\n\t* it now accepts a *circular* boolean argument, just like extend(), see the doc!\n\n\nv0.3.5\n------\n\nDoc: table of content.\n\n\nv0.3.4\n------\n\nNew method: clone(), providing the best object-cloning facility that this lib can offer.\n\n\nv0.3.3\n------\n\nextend()\n- 'nonEnum' option that copy non-enumerable properties as well (in conjunction with 'own')\n- 'descriptor' option that preserve property's descriptor\n\n", "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.treeKit = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2019 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Browser only get the essential of tree-kit, not the unfinished parts of it\n\nvar tree = {} ;\nmodule.exports = tree ;\n\n\ntree.extend = require( './extend.js' ) ;\ntree.clone = require( './clone.js' ) ;\ntree.path = require( './path.js' ) ;\n\n},{\"./clone.js\":2,\"./extend.js\":3,\"./path.js\":4}],2:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2019 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tStand-alone fork of extend.js, without options.\n*/\n\nfunction clone( originalObject , circular ) {\n\t// First create an empty object with\n\t// same prototype of our original source\n\n\tvar originalProto = Object.getPrototypeOf( originalObject ) ;\n\n\t// Opaque objects, like Date\n\tif ( clone.opaque.has( originalProto ) ) { return clone.opaque.get( originalProto )( originalObject ) ; }\n\n\tvar propertyIndex , descriptor , keys , current , nextSource , proto ,\n\t\tcopies = [ {\n\t\t\tsource: originalObject ,\n\t\t\ttarget: Array.isArray( originalObject ) ? [] : Object.create( originalProto )\n\t\t} ] ,\n\t\tcloneObject = copies[ 0 ].target ,\n\t\trefMap = new Map() ;\n\n\trefMap.set( originalObject , cloneObject ) ;\n\n\n\t// First in, first out\n\twhile ( ( current = copies.shift() ) ) {\n\t\tkeys = Object.getOwnPropertyNames( current.source ) ;\n\n\t\tfor ( propertyIndex = 0 ; propertyIndex < keys.length ; propertyIndex ++ ) {\n\t\t\t// Save the source's descriptor\n\t\t\tdescriptor = Object.getOwnPropertyDescriptor( current.source , keys[ propertyIndex ] ) ;\n\n\n\t\t\tif ( ! descriptor.value || typeof descriptor.value !== 'object' ) {\n\t\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tnextSource = descriptor.value ;\n\n\t\t\tif ( circular ) {\n\t\t\t\tif ( refMap.has( nextSource ) ) {\n\t\t\t\t\t// The source is already referenced, just assign reference\n\t\t\t\t\tdescriptor.value = refMap.get( nextSource ) ;\n\t\t\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproto = Object.getPrototypeOf( descriptor.value ) ;\n\n\t\t\t// Opaque objects, like Date, not recursivity for them\n\t\t\tif ( clone.opaque.has( proto ) ) {\n\t\t\t\tdescriptor.value = clone.opaque.get( proto )( descriptor.value ) ;\n\t\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tdescriptor.value = Array.isArray( nextSource ) ? [] : Object.create( proto ) ;\n\n\t\t\tif ( circular ) { refMap.set( nextSource , descriptor.value ) ; }\n\n\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\tcopies.push( { source: nextSource , target: descriptor.value } ) ;\n\t\t}\n\t}\n\n\treturn cloneObject ;\n}\n\nmodule.exports = clone ;\n\n\n\nclone.opaque = new Map() ;\nclone.opaque.set( Date.prototype , src => new Date( src ) ) ;\n\n\n},{}],3:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2019 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\t== Extend function ==\n*/\n\n/*\n\toptions:\n\t\t* own: only copy own properties that are enumerable\n\t\t* nonEnum: copy non-enumerable properties as well, works only with own:true\n\t\t* descriptor: preserve property's descriptor\n\t\t* deep: boolean/Array/Set, if true perform a deep (recursive) extend, if it is an Array/Set of prototypes, only deep-copy\n\t\t\tobjects of those prototypes\n\t\t\t(it is a replacement for deepFilter.whitelist which was removed in Tree Kit 0.6).\n\t\t* immutables: an Array/Set of immutable object's prototypes that are filtered out for deep-copy\n\t\t\t(it is a replacement for deepFilter.blacklist which was removed in Tree Kit 0.6).\n\t\t* maxDepth: used in conjunction with deep, when max depth is reached an exception is raised, default to 100 when\n\t\t\tthe 'circular' option is off, or default to null if 'circular' is on\n\t\t* circular: circular references reconnection\n\t\t* move: move properties to target (delete properties from the sources)\n\t\t* preserve: existing properties in the target object are not overwritten\n\t\t* nofunc: skip functions\n\t\t* deepFunc: in conjunction with 'deep', this will process sources functions like objects rather than\n\t\t\tcopying/referencing them directly into the source, thus, the result will not be a function, it forces 'deep'\n\t\t* proto: try to clone objects with the right prototype, using Object.create() or mutating it with Object.setPrototypeOf(),\n\t\t\tit forces option 'own'.\n\t\t* inherit: rather than mutating target prototype for source prototype like the 'proto' option does, here it is\n\t\t\tthe source itself that IS the prototype for the target. Force option 'own' and disable 'proto'.\n\t\t* skipRoot: the prototype of the target root object is NOT mutated only if this option is set.\n\t\t* flat: extend into the target top-level only, compose name with the path of the source, force 'deep',\n\t\t\tdisable 'unflat', 'proto', 'inherit'\n\t\t* unflat: assume sources are in the 'flat' format, expand all properties deeply into the target, disable 'flat'\n*/\nfunction extend( options , target , ... sources ) {\n\t//console.log( \"\\nextend():\\n\" , arguments ) ;\n\tvar i , source , newTarget = false , length = sources.length ;\n\n\tif ( ! length ) { return target ; }\n\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\n\tvar runtime = { depth: 0 , prefix: '' } ;\n\n\tif ( options.deep ) {\n\t\tif ( Array.isArray( options.deep ) ) { options.deep = new Set( options.deep ) ; }\n\t\telse if ( ! ( options.deep instanceof Set ) ) { options.deep = true ; }\n\t}\n\n\tif ( options.immutables ) {\n\t\tif ( Array.isArray( options.immutables ) ) { options.immutables = new Set( options.immutables ) ; }\n\t\telse if ( ! ( options.immutables instanceof Set ) ) { delete options.immutables ; }\n\t}\n\n\tif ( ! options.maxDepth && options.deep && ! options.circular ) { options.maxDepth = 100 ; }\n\n\tif ( options.deepFunc ) { options.deep = true ; }\n\n\t// 'flat' option force 'deep'\n\tif ( options.flat ) {\n\t\toptions.deep = true ;\n\t\toptions.proto = false ;\n\t\toptions.inherit = false ;\n\t\toptions.unflat = false ;\n\t\tif ( typeof options.flat !== 'string' ) { options.flat = '.' ; }\n\t}\n\n\tif ( options.unflat ) {\n\t\toptions.deep = false ;\n\t\toptions.proto = false ;\n\t\toptions.inherit = false ;\n\t\toptions.flat = false ;\n\t\tif ( typeof options.unflat !== 'string' ) { options.unflat = '.' ; }\n\t}\n\n\t// If the prototype is applied, only owned properties should be copied\n\tif ( options.inherit ) { options.own = true ; options.proto = false ; }\n\telse if ( options.proto ) { options.own = true ; }\n\n\tif ( ! target || ( typeof target !== 'object' && typeof target !== 'function' ) ) {\n\t\tnewTarget = true ;\n\t}\n\n\tif ( ! options.skipRoot && ( options.inherit || options.proto ) ) {\n\t\tfor ( i = length - 1 ; i >= 0 ; i -- ) {\n\t\t\tsource = sources[ i ] ;\n\t\t\tif ( source && ( typeof source === 'object' || typeof source === 'function' ) ) {\n\t\t\t\tif ( options.inherit ) {\n\t\t\t\t\tif ( newTarget ) { target = Object.create( source ) ; }\n\t\t\t\t\telse { Object.setPrototypeOf( target , source ) ; }\n\t\t\t\t}\n\t\t\t\telse if ( options.proto ) {\n\t\t\t\t\tif ( newTarget ) { target = Object.create( Object.getPrototypeOf( source ) ) ; }\n\t\t\t\t\telse { Object.setPrototypeOf( target , Object.getPrototypeOf( source ) ) ; }\n\t\t\t\t}\n\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t}\n\telse if ( newTarget ) {\n\t\ttarget = {} ;\n\t}\n\n\truntime.references = { sources: [] , targets: [] } ;\n\n\tfor ( i = 0 ; i < length ; i ++ ) {\n\t\tsource = sources[ i ] ;\n\t\tif ( ! source || ( typeof source !== 'object' && typeof source !== 'function' ) ) { continue ; }\n\t\textendOne( runtime , options , target , source ) ;\n\t}\n\n\treturn target ;\n}\n\nmodule.exports = extend ;\n\n\n\nfunction extendOne( runtime , options , target , source ) {\n\t//console.log( \"\\nextendOne():\\n\" , arguments ) ;\n\t//process.exit() ;\n\n\tvar j , jmax , sourceKeys , sourceKey , sourceValue , sourceValueProto ,\n\t\tvalue , sourceDescriptor , targetKey , targetPointer , path ,\n\t\tindexOfSource = -1 ;\n\n\t// Max depth check\n\tif ( options.maxDepth && runtime.depth > options.maxDepth ) {\n\t\tthrow new Error( '[tree] extend(): max depth reached(' + options.maxDepth + ')' ) ;\n\t}\n\n\n\tif ( options.circular ) {\n\t\truntime.references.sources.push( source ) ;\n\t\truntime.references.targets.push( target ) ;\n\t}\n\n\tif ( options.own ) {\n\t\tif ( options.nonEnum ) { sourceKeys = Object.getOwnPropertyNames( source ) ; }\n\t\telse { sourceKeys = Object.keys( source ) ; }\n\t}\n\telse { sourceKeys = source ; }\n\n\tfor ( sourceKey in sourceKeys ) {\n\t\tif ( options.own ) { sourceKey = sourceKeys[ sourceKey ] ; }\n\n\t\t// OMG, this DEPRECATED __proto__ shit is still alive and can be used to hack anything ><\n\t\tif ( sourceKey === '__proto__' ) { continue ; }\n\n\t\t// If descriptor is on, get it now\n\t\tif ( options.descriptor ) {\n\t\t\tsourceDescriptor = Object.getOwnPropertyDescriptor( source , sourceKey ) ;\n\t\t\tsourceValue = sourceDescriptor.value ;\n\t\t}\n\t\telse {\n\t\t\t// We have to trigger an eventual getter only once\n\t\t\tsourceValue = source[ sourceKey ] ;\n\t\t}\n\n\t\ttargetPointer = target ;\n\t\ttargetKey = runtime.prefix + sourceKey ;\n\n\t\t// Do not copy if property is a function and we don't want them\n\t\tif ( options.nofunc && typeof sourceValue === 'function' ) { continue ; }\n\n\t\t// 'unflat' mode computing\n\t\tif ( options.unflat && runtime.depth === 0 ) {\n\t\t\tpath = sourceKey.split( options.unflat ) ;\n\t\t\tjmax = path.length - 1 ;\n\n\t\t\tif ( jmax ) {\n\t\t\t\tfor ( j = 0 ; j < jmax ; j ++ ) {\n\t\t\t\t\tif ( ! targetPointer[ path[ j ] ] ||\n\t\t\t\t\t\t( typeof targetPointer[ path[ j ] ] !== 'object' &&\n\t\t\t\t\t\t\ttypeof targetPointer[ path[ j ] ] !== 'function' ) ) {\n\t\t\t\t\t\ttargetPointer[ path[ j ] ] = {} ;\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetPointer = targetPointer[ path[ j ] ] ;\n\t\t\t\t}\n\n\t\t\t\ttargetKey = runtime.prefix + path[ jmax ] ;\n\t\t\t}\n\t\t}\n\n\n\t\tif ( options.deep\t// eslint-disable-line no-constant-condition\n\t\t\t&& sourceValue\n\t\t\t&& ( typeof sourceValue === 'object' || ( options.deepFunc && typeof sourceValue === 'function' ) )\n\t\t\t&& ( ! options.descriptor || ! sourceDescriptor.get )\n\t\t\t// not a condition we just cache sourceValueProto now... ok it's trashy ><\n\t\t\t&& ( ( sourceValueProto = Object.getPrototypeOf( sourceValue ) ) || true )\n\t\t\t&& ( ! ( options.deep instanceof Set ) || options.deep.has( sourceValueProto ) )\n\t\t\t&& ( ! options.immutables || ! options.immutables.has( sourceValueProto ) )\n\t\t) {\n\t\t\tif ( options.circular ) {\n\t\t\t\tindexOfSource = runtime.references.sources.indexOf( sourceValue ) ;\n\t\t\t}\n\n\t\t\tif ( options.flat ) {\n\t\t\t\t// No circular references reconnection when in 'flat' mode\n\t\t\t\tif ( indexOfSource >= 0 ) { continue ; }\n\n\t\t\t\textendOne(\n\t\t\t\t\t{ depth: runtime.depth + 1 , prefix: runtime.prefix + sourceKey + options.flat , references: runtime.references } ,\n\t\t\t\t\toptions , targetPointer , sourceValue\n\t\t\t\t) ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( indexOfSource >= 0 ) {\n\t\t\t\t\t// Circular references reconnection...\n\t\t\t\t\tif ( options.descriptor ) {\n\t\t\t\t\t\tObject.defineProperty( targetPointer , targetKey , {\n\t\t\t\t\t\t\tvalue: runtime.references.targets[ indexOfSource ] ,\n\t\t\t\t\t\t\tenumerable: sourceDescriptor.enumerable ,\n\t\t\t\t\t\t\twritable: sourceDescriptor.writable ,\n\t\t\t\t\t\t\tconfigurable: sourceDescriptor.configurable\n\t\t\t\t\t\t} ) ;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttargetPointer[ targetKey ] = runtime.references.targets[ indexOfSource ] ;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetPointer[ targetKey ] || ! Object.prototype.hasOwnProperty.call( targetPointer , targetKey ) || ( typeof targetPointer[ targetKey ] !== 'object' && typeof targetPointer[ targetKey ] !== 'function' ) ) {\n\t\t\t\t\tif ( Array.isArray( sourceValue ) ) { value = [] ; }\n\t\t\t\t\telse if ( options.proto ) { value = Object.create( sourceValueProto ) ; }\t// jshint ignore:line\n\t\t\t\t\telse if ( options.inherit ) { value = Object.create( sourceValue ) ; }\n\t\t\t\t\telse { value = {} ; }\n\n\t\t\t\t\tif ( options.descriptor ) {\n\t\t\t\t\t\tObject.defineProperty( targetPointer , targetKey , {\n\t\t\t\t\t\t\tvalue: value ,\n\t\t\t\t\t\t\tenumerable: sourceDescriptor.enumerable ,\n\t\t\t\t\t\t\twritable: sourceDescriptor.writable ,\n\t\t\t\t\t\t\tconfigurable: sourceDescriptor.configurable\n\t\t\t\t\t\t} ) ;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttargetPointer[ targetKey ] = value ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( options.proto && Object.getPrototypeOf( targetPointer[ targetKey ] ) !== sourceValueProto ) {\n\t\t\t\t\tObject.setPrototypeOf( targetPointer[ targetKey ] , sourceValueProto ) ;\n\t\t\t\t}\n\t\t\t\telse if ( options.inherit && Object.getPrototypeOf( targetPointer[ targetKey ] ) !== sourceValue ) {\n\t\t\t\t\tObject.setPrototypeOf( targetPointer[ targetKey ] , sourceValue ) ;\n\t\t\t\t}\n\n\t\t\t\tif ( options.circular ) {\n\t\t\t\t\truntime.references.sources.push( sourceValue ) ;\n\t\t\t\t\truntime.references.targets.push( targetPointer[ targetKey ] ) ;\n\t\t\t\t}\n\n\t\t\t\t// Recursively extends sub-object\n\t\t\t\textendOne(\n\t\t\t\t\t{ depth: runtime.depth + 1 , prefix: '' , references: runtime.references } ,\n\t\t\t\t\toptions , targetPointer[ targetKey ] , sourceValue\n\t\t\t\t) ;\n\t\t\t}\n\t\t}\n\t\telse if ( options.preserve && targetPointer[ targetKey ] !== undefined ) {\n\t\t\t// Do not overwrite, and so do not delete source's properties that were not moved\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( ! options.inherit ) {\n\t\t\tif ( options.descriptor ) { Object.defineProperty( targetPointer , targetKey , sourceDescriptor ) ; }\n\t\t\telse { targetPointer[ targetKey ] = sourceValue ; }\n\t\t}\n\n\t\t// Delete owned property of the source object\n\t\tif ( options.move ) { delete source[ sourceKey ] ; }\n\t}\n}\n\n\n},{}],4:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2019 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nvar treePath = {} ;\nmodule.exports = treePath ;\n\n\n\ntreePath.op = function op( type , object , path , value ) {\n\tvar i , parts , last , pointer , key , isArray = false , pathArrayMode = false , isGenericSet , canBeEmpty = true ;\n\n\tif ( ! object || ( typeof object !== 'object' && typeof object !== 'function' ) ) {\n\t\treturn ;\n\t}\n\n\tif ( typeof path === 'string' ) {\n\t\t// Split the path into parts\n\t\tif ( path ) { parts = path.match( /([.#[\\]]|[^.#[\\]]+)/g ) ; }\n\t\telse { parts = [ '' ] ; }\n\n\t\tif ( parts[ 0 ] === '.' ) { parts.unshift( '' ) ; }\n\t\tif ( parts[ parts.length - 1 ] === '.' ) { parts.push( '' ) ; }\n\t}\n\telse if ( Array.isArray( path ) ) {\n\t\tparts = path ;\n\t\tpathArrayMode = true ;\n\t}\n\telse {\n\t\tthrow new TypeError( '[tree.path] .' + type + '(): the path argument should be a string or an array' ) ;\n\t}\n\n\tswitch ( type ) {\n\t\tcase 'get' :\n\t\tcase 'delete' :\n\t\t\tisGenericSet = false ;\n\t\t\tbreak ;\n\t\tcase 'set' :\n\t\tcase 'define' :\n\t\tcase 'inc' :\n\t\tcase 'dec' :\n\t\tcase 'append' :\n\t\tcase 'prepend' :\n\t\tcase 'concat' :\n\t\tcase 'insert' :\n\t\tcase 'autoPush' :\n\t\t\tisGenericSet = true ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tthrow new TypeError( \"[tree.path] .op(): wrong type of operation '\" + type + \"'\" ) ;\n\t}\n\n\t//console.log( parts ) ;\n\t// The pointer start at the object's root\n\tpointer = object ;\n\n\tlast = parts.length - 1 ;\n\n\tfor ( i = 0 ; i <= last ; i ++ ) {\n\t\tif ( pathArrayMode ) {\n\t\t\tif ( key === undefined ) {\n\t\t\t\tkey = parts[ i ] ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tif ( ! pointer[ key ] || ( typeof pointer[ key ] !== 'object' && typeof pointer[ key ] !== 'function' ) ) {\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer[ key ] = {} ;\n\t\t\t}\n\n\t\t\tpointer = pointer[ key ] ;\n\t\t\tkey = parts[ i ] ;\n\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( parts[ i ] === '.' ) {\n\t\t\tisArray = false ;\n\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( ! canBeEmpty ) {\n\t\t\t\t\tcanBeEmpty = true ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\n\t\t\t\tkey = '' ;\n\t\t\t}\n\n\t\t\tif ( ! pointer[ key ] || ( typeof pointer[ key ] !== 'object' && typeof pointer[ key ] !== 'function' ) ) {\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer[ key ] = {} ;\n\t\t\t}\n\n\t\t\tpointer = pointer[ key ] ;\n\t\t\tcanBeEmpty = true ;\n\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( parts[ i ] === '#' || parts[ i ] === '[' ) {\n\t\t\tisArray = true ;\n\t\t\tcanBeEmpty = false ;\n\n\t\t\tif ( key === undefined ) {\n\t\t\t\t// The root element cannot be altered, we are in trouble if an array is expected but we have only a regular object.\n\t\t\t\tif ( ! Array.isArray( pointer ) ) { return undefined ; }\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tif ( ! pointer[ key ] || ! Array.isArray( pointer[ key ] ) ) {\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer[ key ] = [] ;\n\t\t\t}\n\n\t\t\tpointer = pointer[ key ] ;\n\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( parts[ i ] === ']' ) {\n\t\t\t// Closing bracket: do nothing\n\t\t\tcanBeEmpty = false ;\n\t\t\tcontinue ;\n\t\t}\n\n\t\tcanBeEmpty = false ;\n\n\t\tif ( ! isArray ) { key = parts[ i ] ; continue ; }\n\n\t\tswitch ( parts[ i ] ) {\n\t\t\tcase 'length' :\n\t\t\t\tkey = parts[ i ] ;\n\t\t\t\tbreak ;\n\n\t\t\t// Pseudo-key\n\t\t\tcase 'first' :\n\t\t\t\tkey = 0 ;\n\t\t\t\tbreak ;\n\t\t\tcase 'last' :\n\t\t\t\tkey = pointer.length - 1 ;\n\t\t\t\tif ( key < 0 ) { key = 0 ; }\n\t\t\t\tbreak ;\n\t\t\tcase 'next' :\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tkey = pointer.length ;\n\t\t\t\tbreak ;\n\t\t\tcase 'insert' :\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer.unshift( undefined ) ;\n\t\t\t\tkey = 0 ;\n\t\t\t\tbreak ;\n\n\t\t\t// default = number\n\t\t\tdefault :\n\t\t\t\t// Convert the string key to a numerical index\n\t\t\t\tkey = parseInt( parts[ i ] , 10 ) ;\n\t\t}\n\t}\n\n\tswitch ( type ) {\n\t\tcase 'get' :\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'delete' :\n\t\t\tif ( isArray && typeof key === 'number' ) { pointer.splice( key , 1 ) ; }\n\t\t\telse { delete pointer[ key ] ; }\n\t\t\treturn ;\n\t\tcase 'set' :\n\t\t\tpointer[ key ] = value ;\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'define' :\n\t\t\t// define: set only if it doesn't exist\n\t\t\tif ( ! ( key in pointer ) ) { pointer[ key ] = value ; }\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'inc' :\n\t\t\tif ( typeof pointer[ key ] === 'number' ) { pointer[ key ] ++ ; }\n\t\t\telse if ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = 1 ; }\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'dec' :\n\t\t\tif ( typeof pointer[ key ] === 'number' ) { pointer[ key ] -- ; }\n\t\t\telse if ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = -1 ; }\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'append' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = [ value ] ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].push( value ) ; }\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'prepend' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = [ value ] ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].unshift( value ) ; }\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'concat' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = value ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) && Array.isArray( value ) ) {\n\t\t\t\tpointer[ key ] = pointer[ key ].concat( value ) ;\n\t\t\t}\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'insert' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = value ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) && Array.isArray( value ) ) {\n\t\t\t\tpointer[ key ] = value.concat( pointer[ key ] ) ;\n\t\t\t}\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'autoPush' :\n\t\t\tif ( pointer[ key ] === undefined ) { pointer[ key ] = value ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].push( value ) ; }\n\t\t\telse { pointer[ key ] = [ pointer[ key ] , value ] ; }\n\t\t\treturn pointer[ key ] ;\n\t}\n} ;\n\n\n\n// get, set and delete use the same op() function\ntreePath.get = treePath.op.bind( undefined , 'get' ) ;\ntreePath.delete = treePath.op.bind( undefined , 'delete' ) ;\ntreePath.set = treePath.op.bind( undefined , 'set' ) ;\ntreePath.define = treePath.op.bind( undefined , 'define' ) ;\ntreePath.inc = treePath.op.bind( undefined , 'inc' ) ;\ntreePath.dec = treePath.op.bind( undefined , 'dec' ) ;\ntreePath.append = treePath.op.bind( undefined , 'append' ) ;\ntreePath.prepend = treePath.op.bind( undefined , 'prepend' ) ;\ntreePath.concat = treePath.op.bind( undefined , 'concat' ) ;\ntreePath.insert = treePath.op.bind( undefined , 'insert' ) ;\ntreePath.autoPush = treePath.op.bind( undefined , 'autoPush' ) ;\n\n\n\n// Prototype used for object creation, so they can be created with Object.create( tree.path.prototype )\ntreePath.prototype = {\n\tget: function( path ) { return treePath.get( this , path ) ; } ,\n\tdelete: function( path ) { return treePath.delete( this , path ) ; } ,\n\tset: function( path , value ) { return treePath.set( this , path , value ) ; } ,\n\tdefine: function( path , value ) { return treePath.define( this , path , value ) ; } ,\n\tinc: function( path , value ) { return treePath.inc( this , path , value ) ; } ,\n\tdec: function( path , value ) { return treePath.dec( this , path , value ) ; } ,\n\tappend: function( path , value ) { return treePath.append( this , path , value ) ; } ,\n\tprepend: function( path , value ) { return treePath.prepend( this , path , value ) ; } ,\n\tconcat: function( path , value ) { return treePath.concat( this , path , value ) ; } ,\n\tinsert: function( path , value ) { return treePath.insert( this , path , value ) ; } ,\n\tautoPush: function( path , value ) { return treePath.autoPush( this , path , value ) ; }\n} ;\n\n\n\n// Upgrade an object so it can support get, set and delete at its root\ntreePath.upgrade = function upgrade( object ) {\n\tObject.defineProperties( object , {\n\t\tget: { value: treePath.op.bind( undefined , 'get' , object ) } ,\n\t\tdelete: { value: treePath.op.bind( undefined , 'delete' , object ) } ,\n\t\tset: { value: treePath.op.bind( undefined , 'set' , object ) } ,\n\t\tdefine: { value: treePath.op.bind( undefined , 'define' , object ) } ,\n\t\tinc: { value: treePath.op.bind( undefined , 'inc' , object ) } ,\n\t\tdec: { value: treePath.op.bind( undefined , 'dec' , object ) } ,\n\t\tappend: { value: treePath.op.bind( undefined , 'append' , object ) } ,\n\t\tprepend: { value: treePath.op.bind( undefined , 'prepend' , object ) } ,\n\t\tconcat: { value: treePath.op.bind( undefined , 'concat' , object ) } ,\n\t\tinsert: { value: treePath.op.bind( undefined , 'insert' , object ) } ,\n\t\tautoPush: { value: treePath.op.bind( undefined , 'autoPush' , object ) }\n\t} ) ;\n} ;\n\n\n},{}]},{},[1])(1)\n});\n", "(function(e){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=e()}else if(typeof define===\"function\"&&define.amd){define([],e)}else{var t;if(typeof window!==\"undefined\"){t=window}else if(typeof global!==\"undefined\"){t=global}else if(typeof self!==\"undefined\"){t=self}else{t=this}t.treeKit=e()}})(function(){var e,t,n;return function(){function e(t,n,r){function i(o,u){if(!n[o]){if(!t[o]){var s=\"function\"==typeof require&&require;if(!u&&s)return s(o,!0);if(f)return f(o,!0);var a=new Error(\"Cannot find module '\"+o+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var c=n[o]={exports:{}};t[o][0].call(c.exports,function(e){var n=t[o][1][e];return i(n||e)},c,c.exports,e,t,n,r)}return n[o].exports}for(var f=\"function\"==typeof require&&require,o=0;o<r.length;o++)i(r[o]);return i}return e}()({1:[function(e,t,n){\"use strict\";var r={};t.exports=r;r.extend=e(\"./extend.js\");r.clone=e(\"./clone.js\");r.path=e(\"./path.js\")},{\"./clone.js\":2,\"./extend.js\":3,\"./path.js\":4}],2:[function(e,t,n){\"use strict\";function r(e,t){var n=Object.getPrototypeOf(e);if(r.opaque.has(n)){return r.opaque.get(n)(e)}var i,f,o,u,s,a,c=[{source:e,target:Array.isArray(e)?[]:Object.create(n)}],p=c[0].target,d=new Map;d.set(e,p);while(u=c.shift()){o=Object.getOwnPropertyNames(u.source);for(i=0;i<o.length;i++){f=Object.getOwnPropertyDescriptor(u.source,o[i]);if(!f.value||typeof f.value!==\"object\"){Object.defineProperty(u.target,o[i],f);continue}s=f.value;if(t){if(d.has(s)){f.value=d.get(s);Object.defineProperty(u.target,o[i],f);continue}}a=Object.getPrototypeOf(f.value);if(r.opaque.has(a)){f.value=r.opaque.get(a)(f.value);Object.defineProperty(u.target,o[i],f);continue}f.value=Array.isArray(s)?[]:Object.create(a);if(t){d.set(s,f.value)}Object.defineProperty(u.target,o[i],f);c.push({source:s,target:f.value})}}return p}t.exports=r;r.opaque=new Map;r.opaque.set(Date.prototype,e=>new Date(e))},{}],3:[function(e,t,n){\"use strict\";function r(e,t,...n){var r,f,o=false,u=n.length;if(!u){return t}if(!e||typeof e!==\"object\"){e={}}var s={depth:0,prefix:\"\"};if(e.deep){if(Array.isArray(e.deep)){e.deep=new Set(e.deep)}else if(!(e.deep instanceof Set)){e.deep=true}}if(e.immutables){if(Array.isArray(e.immutables)){e.immutables=new Set(e.immutables)}else if(!(e.immutables instanceof Set)){delete e.immutables}}if(!e.maxDepth&&e.deep&&!e.circular){e.maxDepth=100}if(e.deepFunc){e.deep=true}if(e.flat){e.deep=true;e.proto=false;e.inherit=false;e.unflat=false;if(typeof e.flat!==\"string\"){e.flat=\".\"}}if(e.unflat){e.deep=false;e.proto=false;e.inherit=false;e.flat=false;if(typeof e.unflat!==\"string\"){e.unflat=\".\"}}if(e.inherit){e.own=true;e.proto=false}else if(e.proto){e.own=true}if(!t||typeof t!==\"object\"&&typeof t!==\"function\"){o=true}if(!e.skipRoot&&(e.inherit||e.proto)){for(r=u-1;r>=0;r--){f=n[r];if(f&&(typeof f===\"object\"||typeof f===\"function\")){if(e.inherit){if(o){t=Object.create(f)}else{Object.setPrototypeOf(t,f)}}else if(e.proto){if(o){t=Object.create(Object.getPrototypeOf(f))}else{Object.setPrototypeOf(t,Object.getPrototypeOf(f))}}break}}}else if(o){t={}}s.references={sources:[],targets:[]};for(r=0;r<u;r++){f=n[r];if(!f||typeof f!==\"object\"&&typeof f!==\"function\"){continue}i(s,e,t,f)}return t}t.exports=r;function i(e,t,n,r){var f,o,u,s,a,c,p,d,l,b,y,h=-1;if(t.maxDepth&&e.depth>t.maxDepth){throw new Error(\"[tree] extend(): max depth reached(\"+t.maxDepth+\")\")}if(t.circular){e.references.sources.push(r);e.references.targets.push(n)}if(t.own){if(t.nonEnum){u=Object.getOwnPropertyNames(r)}else{u=Object.keys(r)}}else{u=r}for(s in u){if(t.own){s=u[s]}if(s===\"__proto__\"){continue}if(t.descriptor){d=Object.getOwnPropertyDescriptor(r,s);a=d.value}else{a=r[s]}b=n;l=e.prefix+s;if(t.nofunc&&typeof a===\"function\"){continue}if(t.unflat&&e.depth===0){y=s.split(t.unflat);o=y.length-1;if(o){for(f=0;f<o;f++){if(!b[y[f]]||typeof b[y[f]]!==\"object\"&&typeof b[y[f]]!==\"function\"){b[y[f]]={}}b=b[y[f]]}l=e.prefix+y[o]}}if(t.deep&&a&&(typeof a===\"object\"||t.deepFunc&&typeof a===\"function\")&&(!t.descriptor||!d.get)&&((c=Object.getPrototypeOf(a))||true)&&(!(t.deep instanceof Set)||t.deep.has(c))&&(!t.immutables||!t.immutables.has(c))){if(t.circular){h=e.references.sources.indexOf(a)}if(t.flat){if(h>=0){continue}i({depth:e.depth+1,prefix:e.prefix+s+t.flat,references:e.references},t,b,a)}else{if(h>=0){if(t.descriptor){Object.defineProperty(b,l,{value:e.references.targets[h],enumerable:d.enumerable,writable:d.writable,configurable:d.configurable})}else{b[l]=e.references.targets[h]}continue}if(!b[l]||!Object.prototype.hasOwnProperty.call(b,l)||typeof b[l]!==\"object\"&&typeof b[l]!==\"function\"){if(Array.isArray(a)){p=[]}else if(t.proto){p=Object.create(c)}else if(t.inherit){p=Object.create(a)}else{p={}}if(t.descriptor){Object.defineProperty(b,l,{value:p,enumerable:d.enumerable,writable:d.writable,configurable:d.configurable})}else{b[l]=p}}else if(t.proto&&Object.getPrototypeOf(b[l])!==c){Object.setPrototypeOf(b[l],c)}else if(t.inherit&&Object.getPrototypeOf(b[l])!==a){Object.setPrototypeOf(b[l],a)}if(t.circular){e.references.sources.push(a);e.references.targets.push(b[l])}i({depth:e.depth+1,prefix:\"\",references:e.references},t,b[l],a)}}else if(t.preserve&&b[l]!==undefined){continue}else if(!t.inherit){if(t.descriptor){Object.defineProperty(b,l,d)}else{b[l]=a}}if(t.move){delete r[s]}}}},{}],4:[function(e,t,n){\"use strict\";var r={};t.exports=r;r.op=function e(t,n,r,i){var f,o,u,s,a,c=false,p=false,d,l=true;if(!n||typeof n!==\"object\"&&typeof n!==\"function\"){return}if(typeof r===\"string\"){if(r){o=r.match(/([.#[\\]]|[^.#[\\]]+)/g)}else{o=[\"\"]}if(o[0]===\".\"){o.unshift(\"\")}if(o[o.length-1]===\".\"){o.push(\"\")}}else if(Array.isArray(r)){o=r;p=true}else{throw new TypeError(\"[tree.path] .\"+t+\"(): the path argument should be a string or an array\")}switch(t){case\"get\":case\"delete\":d=false;break;case\"set\":case\"define\":case\"inc\":case\"dec\":case\"append\":case\"prepend\":case\"concat\":case\"insert\":case\"autoPush\":d=true;break;default:throw new TypeError(\"[tree.path] .op(): wrong type of operation '\"+t+\"'\")}s=n;u=o.length-1;for(f=0;f<=u;f++){if(p){if(a===undefined){a=o[f];continue}if(!s[a]||typeof s[a]!==\"object\"&&typeof s[a]!==\"function\"){if(!d){return undefined}s[a]={}}s=s[a];a=o[f];continue}else if(o[f]===\".\"){c=false;if(a===undefined){if(!l){l=true;continue}a=\"\"}if(!s[a]||typeof s[a]!==\"object\"&&typeof s[a]!==\"function\"){if(!d){return undefined}s[a]={}}s=s[a];l=true;continue}else if(o[f]===\"#\"||o[f]===\"[\"){c=true;l=false;if(a===undefined){if(!Array.isArray(s)){return undefined}continue}if(!s[a]||!Array.isArray(s[a])){if(!d){return undefined}s[a]=[]}s=s[a];continue}else if(o[f]===\"]\"){l=false;continue}l=false;if(!c){a=o[f];continue}switch(o[f]){case\"length\":a=o[f];break;case\"first\":a=0;break;case\"last\":a=s.length-1;if(a<0){a=0}break;case\"next\":if(!d){return undefined}a=s.length;break;case\"insert\":if(!d){return undefined}s.unshift(undefined);a=0;break;default:a=parseInt(o[f],10)}}switch(t){case\"get\":return s[a];case\"delete\":if(c&&typeof a===\"number\"){s.splice(a,1)}else{delete s[a]}return;case\"set\":s[a]=i;return s[a];case\"define\":if(!(a in s)){s[a]=i}return s[a];case\"inc\":if(typeof s[a]===\"number\"){s[a]++}else if(!s[a]||typeof s[a]!==\"object\"){s[a]=1}return s[a];case\"dec\":if(typeof s[a]===\"number\"){s[a]--}else if(!s[a]||typeof s[a]!==\"object\"){s[a]=-1}return s[a];case\"append\":if(!s[a]){s[a]=[i]}else if(Array.isArray(s[a])){s[a].push(i)}return s[a];case\"prepend\":if(!s[a]){s[a]=[i]}else if(Array.isArray(s[a])){s[a].unshift(i)}return s[a];case\"concat\":if(!s[a]){s[a]=i}else if(Array.isArray(s[a])&&Array.isArray(i)){s[a]=s[a].concat(i)}return s[a];case\"insert\":if(!s[a]){s[a]=i}else if(Array.isArray(s[a])&&Array.isArray(i)){s[a]=i.concat(s[a])}return s[a];case\"autoPush\":if(s[a]===undefined){s[a]=i}else if(Array.isArray(s[a])){s[a].push(i)}else{s[a]=[s[a],i]}return s[a]}};r.get=r.op.bind(undefined,\"get\");r.delete=r.op.bind(undefined,\"delete\");r.set=r.op.bind(undefined,\"set\");r.define=r.op.bind(undefined,\"define\");r.inc=r.op.bind(undefined,\"inc\");r.dec=r.op.bind(undefined,\"dec\");r.append=r.op.bind(undefined,\"append\");r.prepend=r.op.bind(undefined,\"prepend\");r.concat=r.op.bind(undefined,\"concat\");r.insert=r.op.bind(undefined,\"insert\");r.autoPush=r.op.bind(undefined,\"autoPush\");r.prototype={get:function(e){return r.get(this,e)},delete:function(e){return r.delete(this,e)},set:function(e,t){return r.set(this,e,t)},define:function(e,t){return r.define(this,e,t)},inc:function(e,t){return r.inc(this,e,t)},dec:function(e,t){return r.dec(this,e,t)},append:function(e,t){return r.append(this,e,t)},prepend:function(e,t){return r.prepend(this,e,t)},concat:function(e,t){return r.concat(this,e,t)},insert:function(e,t){return r.insert(this,e,t)},autoPush:function(e,t){return r.autoPush(this,e,t)}};r.upgrade=function e(t){Object.defineProperties(t,{get:{value:r.op.bind(undefined,\"get\",t)},delete:{value:r.op.bind(undefined,\"delete\",t)},set:{value:r.op.bind(undefined,\"set\",t)},define:{value:r.op.bind(undefined,\"define\",t)},inc:{value:r.op.bind(undefined,\"inc\",t)},dec:{value:r.op.bind(undefined,\"dec\",t)},append:{value:r.op.bind(undefined,\"append\",t)},prepend:{value:r.op.bind(undefined,\"prepend\",t)},concat:{value:r.op.bind(undefined,\"concat\",t)},insert:{value:r.op.bind(undefined,\"insert\",t)},autoPush:{value:r.op.bind(undefined,\"autoPush\",t)}})}},{}]},{},[1])(1)});", "{\n  \"name\": \"tree-kit\",\n  \"version\": \"0.6.2\",\n  \"description\": \"Tree utilities which provides a full-featured extend and object-cloning facility, and various tools to deal with nested object structures.\",\n  \"main\": \"lib/tree.js\",\n  \"directories\": {\n    \"test\": \"test\",\n    \"bench\": \"bench\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"browserify\": \"^16.2.3\",\n    \"uglify-es\": \"^3.3.9\"\n  },\n  \"scripts\": {\n    \"test\": \"tea-time -R dot\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/cronvel/tree-kit.git\"\n  },\n  \"keywords\": [\n    \"tree\",\n    \"extend\",\n    \"clone\",\n    \"prototype\",\n    \"inherit\",\n    \"deep\",\n    \"diff\",\n    \"mask\"\n  ],\n  \"author\": \"C\u00e9dric Ronvel\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cronvel/tree-kit/issues\"\n  },\n  \"config\": {\n    \"tea-time\": {\n      \"coverDir\": [\n        \"lib\"\n      ]\n    }\n  },\n  \"copyright\": {\n    \"title\": \"Tree Kit\",\n    \"years\": [\n      2014,\n      2021\n    ],\n    \"owner\": \"C\u00e9dric Ronvel\"\n  }\n}\n"], "fixing_code": ["\nv0.7.0\n------\n\nBREAKING CHANGE -- .path()/.dotPath(): drop the function's subtree support, fix prototype pollution\n\n\nv0.6.2\n------\n\n.clone() with Date support\n\n\nv0.6.1\n------\n\nNew: .dotPath.*(): a faster alternative to .path.*(), supporting only dot-separated path\n\n\nv0.6.0\n------\n\nBreaking change: .extend() 'deepFilter' option is gone 'deepFilter.whitelist' has moved to 'deep' and 'deepFilter.blacklist' has moved to 'immutables'\n\n\nv0.5.27\n-------\n\nFixed a vulnerability in .extend(), moved to ESLint, moved to Tea-Time builtin 'expect'\n\n\nv0.5.26\n-------\n\nNew: Browser lib!\n\n\nv0.5.25\n-------\n\ntree.path -- new operations: concat and insert\n\n\nv0.5.24\n-------\n\nIMPORTANT BUGFIX: clone was not working well with arrays\n\n\nv0.5.23\n-------\n\nclone interface\n\n\nv0.5.22\n-------\n\nTree.path.* now supports empty keys\n\n\nv0.5.21\n-------\n\ntree.path() now return undefined if the source object, well, is not an object (instead of throwing)\n\n\nv0.5.20\n-------\n\nBugfix: make require( 'tree-kit/lib/path.js' ) works as expected (was encapsulating everything in a 'path' sub-object)\n\n\nv0.5.19\n-------\n\nNew: tree.path.autoPush()\n\n\nv0.5.18\n-------\n\ntree.json was removed (get its own module: json-kit)\n\n\nv0.5.17\n-------\n\njson: parser run a bit faster\n\n\nv0.5.16\n-------\n\njson: parser run a bit faster\n\n\nv0.5.15\n-------\n\njson: parser is now working\n\n\nv0.5.14\n-------\n\njson.stringify() improvements\n\n\nv0.5.13\n-------\n\n\"use strict\" everywhere\n\n\nv0.5.12\n-------\n\nBechmark: ubench v0.2.x ; \"use strict\" everywhere\n\n\nv0.5.11\n-------\n\nubench benchmark\n\n\nv0.5.10\n-------\n\njson: some fixes\n\n\nv0.5.9\n------\n\njson.stringify() is now on par with native JSON.stringify()!\n\n\nv0.5.8\n------\n\njson utilities: wip\n\n\nv0.5.7\n------\n\nNew: tree.path.append() and tree.path.prepend()\n\n\nv0.5.6\n------\n\nNew feature: tree.path() now support the bracket syntax for arrays.\n\n\nv0.5.5\n------\n\nDocumentation: just added link to http://blog.soulserv.net/tag/tree-kit that points to tree-kit tutorials.\n\n\nv0.5.4\n------\n\npath: all methods return the targeted object like path.get() does.\n\n\nv0.5.3\n------\n\nNew path.*() method: path.define(), like set, but only if the targeted item does not exist\n\n\nv0.5.2\n------\n\nNew path.*() methods: path.inc() & path.dec(), that increment and decrement values\n\n\nv0.5.1\n------\n\npath.*():\n\t* tree.path.prototype can be used for inheritance, using Object.create( tree.path.prototype )\n\t* path.*() now supports path as array too (but it's still not done for array walking)\n\n\nv0.5.0\n------\n\npath.*(): pseudo-element notation use '#' instead of ':'\n\n\nv0.4.3 - v0.4.4\n---------------\n\npath.*() now support a semi-colon syntax for accessing arrays, featuring pseudo-element like :last and :next, etc.\n\n\nv0.4.2\n------\n\nNew: path submodule featuring path.get(), path.set() and path.delete(). It allows setting, getting deleting by a\n\tdot-separated path scheme.\n\n\nv0.4.1\n------\n\nclone() have now its own module/file: clone.js.\n\n\nv0.4.0\n------\n\nextend():\n\t* 'circular' & 'maxDepth' options finished, 'descriptor' option bugfix\n\nclone():\n\t* does not depend upon extend() anymore, it has been fully rewritten with optimization in mind\n\t* it does not use recursive function call but loops, which is super-efficient ;)\n\t* it now accepts a *circular* boolean argument, just like extend(), see the doc!\n\n\nv0.3.5\n------\n\nDoc: table of content.\n\n\nv0.3.4\n------\n\nNew method: clone(), providing the best object-cloning facility that this lib can offer.\n\n\nv0.3.3\n------\n\nextend()\n- 'nonEnum' option that copy non-enumerable properties as well (in conjunction with 'own')\n- 'descriptor' option that preserve property's descriptor\n\n", "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.treeKit = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n// Browser only get the essential of tree-kit, not the unfinished parts of it\n\nconst tree = {} ;\nmodule.exports = tree ;\n\n\n\ntree.extend = require( './extend.js' ) ;\ntree.clone = require( './clone.js' ) ;\ntree.path = require( './path.js' ) ;\ntree.dotPath = require( './dotPath.js' ) ;\n\n\n},{\"./clone.js\":2,\"./dotPath.js\":3,\"./extend.js\":4,\"./path.js\":5}],2:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\tStand-alone fork of extend.js, without options.\n*/\n\nfunction clone( originalObject , circular ) {\n\t// First create an empty object with\n\t// same prototype of our original source\n\n\tvar originalProto = Object.getPrototypeOf( originalObject ) ;\n\n\t// Opaque objects, like Date\n\tif ( clone.opaque.has( originalProto ) ) { return clone.opaque.get( originalProto )( originalObject ) ; }\n\n\tvar propertyIndex , descriptor , keys , current , nextSource , proto ,\n\t\tcopies = [ {\n\t\t\tsource: originalObject ,\n\t\t\ttarget: Array.isArray( originalObject ) ? [] : Object.create( originalProto )\n\t\t} ] ,\n\t\tcloneObject = copies[ 0 ].target ,\n\t\trefMap = new Map() ;\n\n\trefMap.set( originalObject , cloneObject ) ;\n\n\n\t// First in, first out\n\twhile ( ( current = copies.shift() ) ) {\n\t\tkeys = Object.getOwnPropertyNames( current.source ) ;\n\n\t\tfor ( propertyIndex = 0 ; propertyIndex < keys.length ; propertyIndex ++ ) {\n\t\t\t// Save the source's descriptor\n\t\t\tdescriptor = Object.getOwnPropertyDescriptor( current.source , keys[ propertyIndex ] ) ;\n\n\n\t\t\tif ( ! descriptor.value || typeof descriptor.value !== 'object' ) {\n\t\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tnextSource = descriptor.value ;\n\n\t\t\tif ( circular ) {\n\t\t\t\tif ( refMap.has( nextSource ) ) {\n\t\t\t\t\t// The source is already referenced, just assign reference\n\t\t\t\t\tdescriptor.value = refMap.get( nextSource ) ;\n\t\t\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproto = Object.getPrototypeOf( descriptor.value ) ;\n\n\t\t\t// Opaque objects, like Date, not recursivity for them\n\t\t\tif ( clone.opaque.has( proto ) ) {\n\t\t\t\tdescriptor.value = clone.opaque.get( proto )( descriptor.value ) ;\n\t\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tdescriptor.value = Array.isArray( nextSource ) ? [] : Object.create( proto ) ;\n\n\t\t\tif ( circular ) { refMap.set( nextSource , descriptor.value ) ; }\n\n\t\t\tObject.defineProperty( current.target , keys[ propertyIndex ] , descriptor ) ;\n\t\t\tcopies.push( { source: nextSource , target: descriptor.value } ) ;\n\t\t}\n\t}\n\n\treturn cloneObject ;\n}\n\nmodule.exports = clone ;\n\n\n\nclone.opaque = new Map() ;\nclone.opaque.set( Date.prototype , src => new Date( src ) ) ;\n\n\n},{}],3:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nconst dotPath = {} ;\nmodule.exports = dotPath ;\n\n\n\nconst EMPTY_PATH = [] ;\nconst PROTO_POLLUTION_MESSAGE = 'This would pollute prototype' ;\n\n\n\nfunction toPathArray( path ) {\n\tif ( Array.isArray( path ) ) { return path ; }\n\telse if ( ! path ) { return EMPTY_PATH ; }\n\telse if ( typeof path === 'string' ) { return path.split( '.' ) ; }\n\n\tthrow new TypeError( '[tree.dotPath]: the path argument should be a string or an array' ) ;\n}\n\n\n\n// Walk the tree using the path array.\nfunction walk( object , pathArray , maxOffset = 0 ) {\n\tvar i , iMax , key ,\n\t\tpointer = object ;\n\n\tfor ( i = 0 , iMax = pathArray.length + maxOffset ; i < iMax ; i ++ ) {\n\t\tkey = pathArray[ i ] ;\n\n\t\tif ( key === '__proto__' || typeof pointer === 'function' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\tif ( ! pointer || typeof pointer !== 'object' ) { return undefined ; }\n\n\t\tpointer = pointer[ key ] ;\n\t}\n\n\treturn pointer ;\n}\n\n\n\n// Walk the tree, create missing element: pave the path up to before the last part of the path.\n// Return that before-the-last element.\n// Object MUST be an object! no check are performed for the first step!\nfunction pave( object , pathArray ) {\n\tvar i , iMax , key ,\n\t\tpointer = object ;\n\n\tfor ( i = 0 , iMax = pathArray.length - 1 ; i < iMax ; i ++ ) {\n\t\tkey = pathArray[ i ] ;\n\n\t\tif ( key === '__proto__' || typeof pointer[ key ] === 'function' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\tif ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = {} ; }\n\n\t\tpointer = pointer[ key ] ;\n\t}\n\n\treturn pointer ;\n}\n\n\n\ndotPath.get = ( object , path ) => walk( object , toPathArray( path ) ) ;\n\n\n\ndotPath.set = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tpointer[ key ] = value ;\n\n\treturn value ;\n} ;\n\n\n\ndotPath.define = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( ! ( key in pointer ) ) { pointer[ key ] = value ; }\n\n\treturn value ;\n} ;\n\n\n\ndotPath.inc = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( typeof pointer[ key ] === 'number' ) { pointer[ key ] ++ ; }\n\telse if ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = 1 ; }\n\n\treturn value ;\n} ;\n\n\n\ndotPath.dec = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( typeof pointer[ key ] === 'number' ) { pointer[ key ] -- ; }\n\telse if ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = -1 ; }\n\n\treturn value ;\n} ;\n\n\n\ndotPath.concat = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( ! pointer[ key ] ) { pointer[ key ] = value ; }\n\telse if ( Array.isArray( pointer[ key ] ) && Array.isArray( value ) ) {\n\t\tpointer[ key ] = pointer[ key ].concat( value ) ;\n\t}\n\t//else ? do nothing???\n\n\treturn value ;\n} ;\n\n\n\ndotPath.insert = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( ! pointer[ key ] ) { pointer[ key ] = value ; }\n\telse if ( Array.isArray( pointer[ key ] ) && Array.isArray( value ) ) {\n\t\tpointer[ key ] = value.concat( pointer[ key ] ) ;\n\t}\n\t//else ? do nothing???\n\n\treturn value ;\n} ;\n\n\n\ndotPath.delete = ( object , path ) => {\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = walk( object , pathArray , -1 ) ;\n\n\tif ( ! pointer || typeof pointer !== 'object' ) { return false ; }\n\n\treturn delete pointer[ key ] ;\n} ;\n\n\n\ndotPath.autoPush = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( pointer[ key ] === undefined ) { pointer[ key ] = value ; }\n\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].push( value ) ; }\n\telse { pointer[ key ] = [ pointer[ key ] , value ] ; }\n\n\treturn pointer[ key ] ;\n} ;\n\n\n\ndotPath.append = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( ! pointer[ key ] ) { pointer[ key ] = [ value ] ; }\n\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].push( value ) ; }\n\t//else ? do nothing???\n\n\treturn pointer[ key ] ;\n} ;\n\n\n\ndotPath.prepend = ( object , path , value ) => {\n\tif ( ! object || typeof object !== 'object' ) {\n\t\t// Throw?\n\t\treturn undefined ;\n\t}\n\n\tvar pathArray = toPathArray( path ) ,\n\t\tkey = pathArray[ pathArray.length - 1 ] ;\n\n\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\n\tvar pointer = pave( object , pathArray ) ;\n\n\tif ( ! pointer[ key ] ) { pointer[ key ] = [ value ] ; }\n\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].unshift( value ) ; }\n\t//else ? do nothing???\n\n\treturn pointer[ key ] ;\n} ;\n\n\n},{}],4:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\n/*\n\t== Extend function ==\n*/\n\n/*\n\toptions:\n\t\t* own: only copy own properties that are enumerable\n\t\t* nonEnum: copy non-enumerable properties as well, works only with own:true\n\t\t* descriptor: preserve property's descriptor\n\t\t* deep: boolean/Array/Set, if true perform a deep (recursive) extend, if it is an Array/Set of prototypes, only deep-copy\n\t\t\tobjects of those prototypes\n\t\t\t(it is a replacement for deepFilter.whitelist which was removed in Tree Kit 0.6).\n\t\t* immutables: an Array/Set of immutable object's prototypes that are filtered out for deep-copy\n\t\t\t(it is a replacement for deepFilter.blacklist which was removed in Tree Kit 0.6).\n\t\t* maxDepth: used in conjunction with deep, when max depth is reached an exception is raised, default to 100 when\n\t\t\tthe 'circular' option is off, or default to null if 'circular' is on\n\t\t* circular: circular references reconnection\n\t\t* move: move properties to target (delete properties from the sources)\n\t\t* preserve: existing properties in the target object are not overwritten\n\t\t* nofunc: skip functions\n\t\t* deepFunc: in conjunction with 'deep', this will process sources functions like objects rather than\n\t\t\tcopying/referencing them directly into the source, thus, the result will not be a function, it forces 'deep'\n\t\t* proto: try to clone objects with the right prototype, using Object.create() or mutating it with Object.setPrototypeOf(),\n\t\t\tit forces option 'own'.\n\t\t* inherit: rather than mutating target prototype for source prototype like the 'proto' option does, here it is\n\t\t\tthe source itself that IS the prototype for the target. Force option 'own' and disable 'proto'.\n\t\t* skipRoot: the prototype of the target root object is NOT mutated only if this option is set.\n\t\t* flat: extend into the target top-level only, compose name with the path of the source, force 'deep',\n\t\t\tdisable 'unflat', 'proto', 'inherit'\n\t\t* unflat: assume sources are in the 'flat' format, expand all properties deeply into the target, disable 'flat'\n*/\nfunction extend( options , target , ... sources ) {\n\t//console.log( \"\\nextend():\\n\" , arguments ) ;\n\tvar i , source , newTarget = false , length = sources.length ;\n\n\tif ( ! length ) { return target ; }\n\n\tif ( ! options || typeof options !== 'object' ) { options = {} ; }\n\n\tvar runtime = { depth: 0 , prefix: '' } ;\n\n\tif ( options.deep ) {\n\t\tif ( Array.isArray( options.deep ) ) { options.deep = new Set( options.deep ) ; }\n\t\telse if ( ! ( options.deep instanceof Set ) ) { options.deep = true ; }\n\t}\n\n\tif ( options.immutables ) {\n\t\tif ( Array.isArray( options.immutables ) ) { options.immutables = new Set( options.immutables ) ; }\n\t\telse if ( ! ( options.immutables instanceof Set ) ) { delete options.immutables ; }\n\t}\n\n\tif ( ! options.maxDepth && options.deep && ! options.circular ) { options.maxDepth = 100 ; }\n\n\tif ( options.deepFunc ) { options.deep = true ; }\n\n\t// 'flat' option force 'deep'\n\tif ( options.flat ) {\n\t\toptions.deep = true ;\n\t\toptions.proto = false ;\n\t\toptions.inherit = false ;\n\t\toptions.unflat = false ;\n\t\tif ( typeof options.flat !== 'string' ) { options.flat = '.' ; }\n\t}\n\n\tif ( options.unflat ) {\n\t\toptions.deep = false ;\n\t\toptions.proto = false ;\n\t\toptions.inherit = false ;\n\t\toptions.flat = false ;\n\t\tif ( typeof options.unflat !== 'string' ) { options.unflat = '.' ; }\n\t}\n\n\t// If the prototype is applied, only owned properties should be copied\n\tif ( options.inherit ) { options.own = true ; options.proto = false ; }\n\telse if ( options.proto ) { options.own = true ; }\n\n\tif ( ! target || ( typeof target !== 'object' && typeof target !== 'function' ) ) {\n\t\tnewTarget = true ;\n\t}\n\n\tif ( ! options.skipRoot && ( options.inherit || options.proto ) ) {\n\t\tfor ( i = length - 1 ; i >= 0 ; i -- ) {\n\t\t\tsource = sources[ i ] ;\n\t\t\tif ( source && ( typeof source === 'object' || typeof source === 'function' ) ) {\n\t\t\t\tif ( options.inherit ) {\n\t\t\t\t\tif ( newTarget ) { target = Object.create( source ) ; }\n\t\t\t\t\telse { Object.setPrototypeOf( target , source ) ; }\n\t\t\t\t}\n\t\t\t\telse if ( options.proto ) {\n\t\t\t\t\tif ( newTarget ) { target = Object.create( Object.getPrototypeOf( source ) ) ; }\n\t\t\t\t\telse { Object.setPrototypeOf( target , Object.getPrototypeOf( source ) ) ; }\n\t\t\t\t}\n\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t}\n\telse if ( newTarget ) {\n\t\ttarget = {} ;\n\t}\n\n\truntime.references = { sources: [] , targets: [] } ;\n\n\tfor ( i = 0 ; i < length ; i ++ ) {\n\t\tsource = sources[ i ] ;\n\t\tif ( ! source || ( typeof source !== 'object' && typeof source !== 'function' ) ) { continue ; }\n\t\textendOne( runtime , options , target , source ) ;\n\t}\n\n\treturn target ;\n}\n\nmodule.exports = extend ;\n\n\n\nfunction extendOne( runtime , options , target , source ) {\n\t//console.log( \"\\nextendOne():\\n\" , arguments ) ;\n\t//process.exit() ;\n\n\tvar j , jmax , sourceKeys , sourceKey , sourceValue , sourceValueProto ,\n\t\tvalue , sourceDescriptor , targetKey , targetPointer , path ,\n\t\tindexOfSource = -1 ;\n\n\t// Max depth check\n\tif ( options.maxDepth && runtime.depth > options.maxDepth ) {\n\t\tthrow new Error( '[tree] extend(): max depth reached(' + options.maxDepth + ')' ) ;\n\t}\n\n\n\tif ( options.circular ) {\n\t\truntime.references.sources.push( source ) ;\n\t\truntime.references.targets.push( target ) ;\n\t}\n\n\tif ( options.own ) {\n\t\tif ( options.nonEnum ) { sourceKeys = Object.getOwnPropertyNames( source ) ; }\n\t\telse { sourceKeys = Object.keys( source ) ; }\n\t}\n\telse { sourceKeys = source ; }\n\n\tfor ( sourceKey in sourceKeys ) {\n\t\tif ( options.own ) { sourceKey = sourceKeys[ sourceKey ] ; }\n\n\t\t// OMG, this DEPRECATED __proto__ shit is still alive and can be used to hack anything ><\n\t\tif ( sourceKey === '__proto__' ) { continue ; }\n\n\t\t// If descriptor is on, get it now\n\t\tif ( options.descriptor ) {\n\t\t\tsourceDescriptor = Object.getOwnPropertyDescriptor( source , sourceKey ) ;\n\t\t\tsourceValue = sourceDescriptor.value ;\n\t\t}\n\t\telse {\n\t\t\t// We have to trigger an eventual getter only once\n\t\t\tsourceValue = source[ sourceKey ] ;\n\t\t}\n\n\t\ttargetPointer = target ;\n\t\ttargetKey = runtime.prefix + sourceKey ;\n\n\t\t// Do not copy if property is a function and we don't want them\n\t\tif ( options.nofunc && typeof sourceValue === 'function' ) { continue ; }\n\n\t\t// 'unflat' mode computing\n\t\tif ( options.unflat && runtime.depth === 0 ) {\n\t\t\tpath = sourceKey.split( options.unflat ) ;\n\t\t\tjmax = path.length - 1 ;\n\n\t\t\tif ( jmax ) {\n\t\t\t\tfor ( j = 0 ; j < jmax ; j ++ ) {\n\t\t\t\t\tif ( ! targetPointer[ path[ j ] ] ||\n\t\t\t\t\t\t( typeof targetPointer[ path[ j ] ] !== 'object' &&\n\t\t\t\t\t\t\ttypeof targetPointer[ path[ j ] ] !== 'function' ) ) {\n\t\t\t\t\t\ttargetPointer[ path[ j ] ] = {} ;\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetPointer = targetPointer[ path[ j ] ] ;\n\t\t\t\t}\n\n\t\t\t\ttargetKey = runtime.prefix + path[ jmax ] ;\n\t\t\t}\n\t\t}\n\n\n\t\tif ( options.deep\t// eslint-disable-line no-constant-condition\n\t\t\t&& sourceValue\n\t\t\t&& ( typeof sourceValue === 'object' || ( options.deepFunc && typeof sourceValue === 'function' ) )\n\t\t\t&& ( ! options.descriptor || ! sourceDescriptor.get )\n\t\t\t// not a condition we just cache sourceValueProto now... ok it's trashy ><\n\t\t\t&& ( ( sourceValueProto = Object.getPrototypeOf( sourceValue ) ) || true )\n\t\t\t&& ( ! ( options.deep instanceof Set ) || options.deep.has( sourceValueProto ) )\n\t\t\t&& ( ! options.immutables || ! options.immutables.has( sourceValueProto ) )\n\t\t) {\n\t\t\tif ( options.circular ) {\n\t\t\t\tindexOfSource = runtime.references.sources.indexOf( sourceValue ) ;\n\t\t\t}\n\n\t\t\tif ( options.flat ) {\n\t\t\t\t// No circular references reconnection when in 'flat' mode\n\t\t\t\tif ( indexOfSource >= 0 ) { continue ; }\n\n\t\t\t\textendOne(\n\t\t\t\t\t{ depth: runtime.depth + 1 , prefix: runtime.prefix + sourceKey + options.flat , references: runtime.references } ,\n\t\t\t\t\toptions , targetPointer , sourceValue\n\t\t\t\t) ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( indexOfSource >= 0 ) {\n\t\t\t\t\t// Circular references reconnection...\n\t\t\t\t\tif ( options.descriptor ) {\n\t\t\t\t\t\tObject.defineProperty( targetPointer , targetKey , {\n\t\t\t\t\t\t\tvalue: runtime.references.targets[ indexOfSource ] ,\n\t\t\t\t\t\t\tenumerable: sourceDescriptor.enumerable ,\n\t\t\t\t\t\t\twritable: sourceDescriptor.writable ,\n\t\t\t\t\t\t\tconfigurable: sourceDescriptor.configurable\n\t\t\t\t\t\t} ) ;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttargetPointer[ targetKey ] = runtime.references.targets[ indexOfSource ] ;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetPointer[ targetKey ] || ! Object.prototype.hasOwnProperty.call( targetPointer , targetKey ) || ( typeof targetPointer[ targetKey ] !== 'object' && typeof targetPointer[ targetKey ] !== 'function' ) ) {\n\t\t\t\t\tif ( Array.isArray( sourceValue ) ) { value = [] ; }\n\t\t\t\t\telse if ( options.proto ) { value = Object.create( sourceValueProto ) ; }\t// jshint ignore:line\n\t\t\t\t\telse if ( options.inherit ) { value = Object.create( sourceValue ) ; }\n\t\t\t\t\telse { value = {} ; }\n\n\t\t\t\t\tif ( options.descriptor ) {\n\t\t\t\t\t\tObject.defineProperty( targetPointer , targetKey , {\n\t\t\t\t\t\t\tvalue: value ,\n\t\t\t\t\t\t\tenumerable: sourceDescriptor.enumerable ,\n\t\t\t\t\t\t\twritable: sourceDescriptor.writable ,\n\t\t\t\t\t\t\tconfigurable: sourceDescriptor.configurable\n\t\t\t\t\t\t} ) ;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttargetPointer[ targetKey ] = value ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( options.proto && Object.getPrototypeOf( targetPointer[ targetKey ] ) !== sourceValueProto ) {\n\t\t\t\t\tObject.setPrototypeOf( targetPointer[ targetKey ] , sourceValueProto ) ;\n\t\t\t\t}\n\t\t\t\telse if ( options.inherit && Object.getPrototypeOf( targetPointer[ targetKey ] ) !== sourceValue ) {\n\t\t\t\t\tObject.setPrototypeOf( targetPointer[ targetKey ] , sourceValue ) ;\n\t\t\t\t}\n\n\t\t\t\tif ( options.circular ) {\n\t\t\t\t\truntime.references.sources.push( sourceValue ) ;\n\t\t\t\t\truntime.references.targets.push( targetPointer[ targetKey ] ) ;\n\t\t\t\t}\n\n\t\t\t\t// Recursively extends sub-object\n\t\t\t\textendOne(\n\t\t\t\t\t{ depth: runtime.depth + 1 , prefix: '' , references: runtime.references } ,\n\t\t\t\t\toptions , targetPointer[ targetKey ] , sourceValue\n\t\t\t\t) ;\n\t\t\t}\n\t\t}\n\t\telse if ( options.preserve && targetPointer[ targetKey ] !== undefined ) {\n\t\t\t// Do not overwrite, and so do not delete source's properties that were not moved\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( ! options.inherit ) {\n\t\t\tif ( options.descriptor ) { Object.defineProperty( targetPointer , targetKey , sourceDescriptor ) ; }\n\t\t\telse { targetPointer[ targetKey ] = sourceValue ; }\n\t\t}\n\n\t\t// Delete owned property of the source object\n\t\tif ( options.move ) { delete source[ sourceKey ] ; }\n\t}\n}\n\n\n},{}],5:[function(require,module,exports){\n/*\n\tTree Kit\n\n\tCopyright (c) 2014 - 2021 C\u00e9dric Ronvel\n\n\tThe MIT License (MIT)\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n*/\n\n\"use strict\" ;\n\n\n\nconst treePath = {} ;\nmodule.exports = treePath ;\n\n\n\nconst PROTO_POLLUTION_MESSAGE = 'This would pollute prototype' ;\n\n\n\ntreePath.op = function( type , object , path , value ) {\n\tvar i , parts , last , pointer , key , isArray = false , pathArrayMode = false , isGenericSet , canBeEmpty = true ;\n\n\tif ( ! object || typeof object !== 'object' ) { return ; }\n\n\tif ( typeof path === 'string' ) {\n\t\t// Split the path into parts\n\t\tif ( path ) { parts = path.match( /([.#[\\]]|[^.#[\\]]+)/g ) ; }\n\t\telse { parts = [ '' ] ; }\n\n\t\tif ( parts[ 0 ] === '.' ) { parts.unshift( '' ) ; }\n\t\tif ( parts[ parts.length - 1 ] === '.' ) { parts.push( '' ) ; }\n\t}\n\telse if ( Array.isArray( path ) ) {\n\t\tparts = path ;\n\t\tpathArrayMode = true ;\n\t}\n\telse {\n\t\tthrow new TypeError( '[tree.path] .' + type + '(): the path argument should be a string or an array' ) ;\n\t}\n\n\tswitch ( type ) {\n\t\tcase 'get' :\n\t\tcase 'delete' :\n\t\t\tisGenericSet = false ;\n\t\t\tbreak ;\n\t\tcase 'set' :\n\t\tcase 'define' :\n\t\tcase 'inc' :\n\t\tcase 'dec' :\n\t\tcase 'append' :\n\t\tcase 'prepend' :\n\t\tcase 'concat' :\n\t\tcase 'insert' :\n\t\tcase 'autoPush' :\n\t\t\tisGenericSet = true ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tthrow new TypeError( \"[tree.path] .op(): wrong type of operation '\" + type + \"'\" ) ;\n\t}\n\n\t//console.log( parts ) ;\n\t// The pointer start at the object's root\n\tpointer = object ;\n\n\tlast = parts.length - 1 ;\n\n\tfor ( i = 0 ; i <= last ; i ++ ) {\n\t\tif ( pathArrayMode ) {\n\t\t\tif ( key === undefined ) {\n\t\t\t\tkey = parts[ i ] ;\n\t\t\t\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tif ( typeof pointer[ key ] === 'function' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\t\tif ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) {\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer[ key ] = {} ;\n\t\t\t}\n\n\t\t\tpointer = pointer[ key ] ;\n\t\t\tkey = parts[ i ] ;\n\t\t\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( parts[ i ] === '.' ) {\n\t\t\tisArray = false ;\n\n\t\t\tif ( key === undefined ) {\n\t\t\t\tif ( ! canBeEmpty ) {\n\t\t\t\t\tcanBeEmpty = true ;\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\n\n\t\t\t\tkey = '' ;\n\t\t\t}\n\n\t\t\tif ( typeof pointer[ key ] === 'function' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\t\tif ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) {\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer[ key ] = {} ;\n\t\t\t}\n\n\t\t\tpointer = pointer[ key ] ;\n\t\t\tcanBeEmpty = true ;\n\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( parts[ i ] === '#' || parts[ i ] === '[' ) {\n\t\t\tisArray = true ;\n\t\t\tcanBeEmpty = false ;\n\n\t\t\tif ( key === undefined ) {\n\t\t\t\t// The root element cannot be altered, we are in trouble if an array is expected but we have only a regular object.\n\t\t\t\tif ( ! Array.isArray( pointer ) ) { return undefined ; }\n\t\t\t\tcontinue ;\n\t\t\t}\n\n\t\t\tif ( typeof pointer[ key ] === 'function' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\t\tif ( ! pointer[ key ] || ! Array.isArray( pointer[ key ] ) ) {\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer[ key ] = [] ;\n\t\t\t}\n\n\t\t\tpointer = pointer[ key ] ;\n\n\t\t\tcontinue ;\n\t\t}\n\t\telse if ( parts[ i ] === ']' ) {\n\t\t\t// Closing bracket: do nothing\n\t\t\tcanBeEmpty = false ;\n\t\t\tcontinue ;\n\t\t}\n\n\t\tcanBeEmpty = false ;\n\n\t\tif ( ! isArray ) {\n\t\t\tkey = parts[ i ] ;\n\t\t\tif ( key === '__proto__' ) { throw new Error( PROTO_POLLUTION_MESSAGE ) ; }\n\t\t\tcontinue ;\n\t\t}\n\n\t\tswitch ( parts[ i ] ) {\n\t\t\tcase 'length' :\n\t\t\t\tkey = 'length' ;\n\t\t\t\tbreak ;\n\n\t\t\t// Pseudo-key\n\t\t\tcase 'first' :\n\t\t\t\tkey = 0 ;\n\t\t\t\tbreak ;\n\t\t\tcase 'last' :\n\t\t\t\tkey = pointer.length - 1 ;\n\t\t\t\tif ( key < 0 ) { key = 0 ; }\n\t\t\t\tbreak ;\n\t\t\tcase 'next' :\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tkey = pointer.length ;\n\t\t\t\tbreak ;\n\t\t\tcase 'insert' :\n\t\t\t\tif ( ! isGenericSet ) { return undefined ; }\n\t\t\t\tpointer.unshift( undefined ) ;\n\t\t\t\tkey = 0 ;\n\t\t\t\tbreak ;\n\n\t\t\t// default = number\n\t\t\tdefault :\n\t\t\t\t// Convert the string key to a numerical index\n\t\t\t\tkey = parseInt( parts[ i ] , 10 ) ;\n\t\t}\n\t}\n\n\tswitch ( type ) {\n\t\tcase 'get' :\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'delete' :\n\t\t\tif ( isArray && typeof key === 'number' ) { pointer.splice( key , 1 ) ; }\n\t\t\telse { delete pointer[ key ] ; }\n\t\t\treturn ;\n\t\tcase 'set' :\n\t\t\tpointer[ key ] = value ;\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'define' :\n\t\t\t// define: set only if it doesn't exist\n\t\t\tif ( ! ( key in pointer ) ) { pointer[ key ] = value ; }\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'inc' :\n\t\t\tif ( typeof pointer[ key ] === 'number' ) { pointer[ key ] ++ ; }\n\t\t\telse if ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = 1 ; }\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'dec' :\n\t\t\tif ( typeof pointer[ key ] === 'number' ) { pointer[ key ] -- ; }\n\t\t\telse if ( ! pointer[ key ] || typeof pointer[ key ] !== 'object' ) { pointer[ key ] = -1 ; }\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'append' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = [ value ] ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].push( value ) ; }\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'prepend' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = [ value ] ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].unshift( value ) ; }\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'concat' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = value ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) && Array.isArray( value ) ) {\n\t\t\t\tpointer[ key ] = pointer[ key ].concat( value ) ;\n\t\t\t}\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'insert' :\n\t\t\tif ( ! pointer[ key ] ) { pointer[ key ] = value ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) && Array.isArray( value ) ) {\n\t\t\t\tpointer[ key ] = value.concat( pointer[ key ] ) ;\n\t\t\t}\n\t\t\t//else ? do nothing???\n\t\t\treturn pointer[ key ] ;\n\t\tcase 'autoPush' :\n\t\t\tif ( pointer[ key ] === undefined ) { pointer[ key ] = value ; }\n\t\t\telse if ( Array.isArray( pointer[ key ] ) ) { pointer[ key ].push( value ) ; }\n\t\t\telse { pointer[ key ] = [ pointer[ key ] , value ] ; }\n\t\t\treturn pointer[ key ] ;\n\t}\n} ;\n\n\n\n// get, set and delete use the same op() function\ntreePath.get = treePath.op.bind( undefined , 'get' ) ;\ntreePath.delete = treePath.op.bind( undefined , 'delete' ) ;\ntreePath.set = treePath.op.bind( undefined , 'set' ) ;\ntreePath.define = treePath.op.bind( undefined , 'define' ) ;\ntreePath.inc = treePath.op.bind( undefined , 'inc' ) ;\ntreePath.dec = treePath.op.bind( undefined , 'dec' ) ;\ntreePath.append = treePath.op.bind( undefined , 'append' ) ;\ntreePath.prepend = treePath.op.bind( undefined , 'prepend' ) ;\ntreePath.concat = treePath.op.bind( undefined , 'concat' ) ;\ntreePath.insert = treePath.op.bind( undefined , 'insert' ) ;\ntreePath.autoPush = treePath.op.bind( undefined , 'autoPush' ) ;\n\n\n\n// Prototype used for object creation, so they can be created with Object.create( tree.path.prototype )\ntreePath.prototype = {\n\tget: function( path ) { return treePath.get( this , path ) ; } ,\n\tdelete: function( path ) { return treePath.delete( this , path ) ; } ,\n\tset: function( path , value ) { return treePath.set( this , path , value ) ; } ,\n\tdefine: function( path , value ) { return treePath.define( this , path , value ) ; } ,\n\tinc: function( path , value ) { return treePath.inc( this , path , value ) ; } ,\n\tdec: function( path , value ) { return treePath.dec( this , path , value ) ; } ,\n\tappend: function( path , value ) { return treePath.append( this , path , value ) ; } ,\n\tprepend: function( path , value ) { return treePath.prepend( this , path , value ) ; } ,\n\tconcat: function( path , value ) { return treePath.concat( this , path , value ) ; } ,\n\tinsert: function( path , value ) { return treePath.insert( this , path , value ) ; } ,\n\tautoPush: function( path , value ) { return treePath.autoPush( this , path , value ) ; }\n} ;\n\n\n\n// Upgrade an object so it can support get, set and delete at its root\ntreePath.upgrade = function( object ) {\n\tObject.defineProperties( object , {\n\t\tget: { value: treePath.op.bind( undefined , 'get' , object ) } ,\n\t\tdelete: { value: treePath.op.bind( undefined , 'delete' , object ) } ,\n\t\tset: { value: treePath.op.bind( undefined , 'set' , object ) } ,\n\t\tdefine: { value: treePath.op.bind( undefined , 'define' , object ) } ,\n\t\tinc: { value: treePath.op.bind( undefined , 'inc' , object ) } ,\n\t\tdec: { value: treePath.op.bind( undefined , 'dec' , object ) } ,\n\t\tappend: { value: treePath.op.bind( undefined , 'append' , object ) } ,\n\t\tprepend: { value: treePath.op.bind( undefined , 'prepend' , object ) } ,\n\t\tconcat: { value: treePath.op.bind( undefined , 'concat' , object ) } ,\n\t\tinsert: { value: treePath.op.bind( undefined , 'insert' , object ) } ,\n\t\tautoPush: { value: treePath.op.bind( undefined , 'autoPush' , object ) }\n\t} ) ;\n} ;\n\n\n},{}]},{},[1])(1)\n});\n", "(function(e){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=e()}else if(typeof define===\"function\"&&define.amd){define([],e)}else{var t;if(typeof window!==\"undefined\"){t=window}else if(typeof global!==\"undefined\"){t=global}else if(typeof self!==\"undefined\"){t=self}else{t=this}t.treeKit=e()}})(function(){var e,t,r;return function(){function e(t,r,n){function i(f,u){if(!r[f]){if(!t[f]){var a=\"function\"==typeof require&&require;if(!u&&a)return a(f,!0);if(o)return o(f,!0);var s=new Error(\"Cannot find module '\"+f+\"'\");throw s.code=\"MODULE_NOT_FOUND\",s}var c=r[f]={exports:{}};t[f][0].call(c.exports,function(e){var r=t[f][1][e];return i(r||e)},c,c.exports,e,t,r,n)}return r[f].exports}for(var o=\"function\"==typeof require&&require,f=0;f<n.length;f++)i(n[f]);return i}return e}()({1:[function(e,t,r){\"use strict\";const n={};t.exports=n;n.extend=e(\"./extend.js\");n.clone=e(\"./clone.js\");n.path=e(\"./path.js\");n.dotPath=e(\"./dotPath.js\")},{\"./clone.js\":2,\"./dotPath.js\":3,\"./extend.js\":4,\"./path.js\":5}],2:[function(e,t,r){\"use strict\";function n(e,t){var r=Object.getPrototypeOf(e);if(n.opaque.has(r)){return n.opaque.get(r)(e)}var i,o,f,u,a,s,c=[{source:e,target:Array.isArray(e)?[]:Object.create(r)}],p=c[0].target,d=new Map;d.set(e,p);while(u=c.shift()){f=Object.getOwnPropertyNames(u.source);for(i=0;i<f.length;i++){o=Object.getOwnPropertyDescriptor(u.source,f[i]);if(!o.value||typeof o.value!==\"object\"){Object.defineProperty(u.target,f[i],o);continue}a=o.value;if(t){if(d.has(a)){o.value=d.get(a);Object.defineProperty(u.target,f[i],o);continue}}s=Object.getPrototypeOf(o.value);if(n.opaque.has(s)){o.value=n.opaque.get(s)(o.value);Object.defineProperty(u.target,f[i],o);continue}o.value=Array.isArray(a)?[]:Object.create(s);if(t){d.set(a,o.value)}Object.defineProperty(u.target,f[i],o);c.push({source:a,target:o.value})}}return p}t.exports=n;n.opaque=new Map;n.opaque.set(Date.prototype,e=>new Date(e))},{}],3:[function(e,t,r){\"use strict\";const n={};t.exports=n;const i=[];const o=\"This would pollute prototype\";function f(e){if(Array.isArray(e)){return e}else if(!e){return i}else if(typeof e===\"string\"){return e.split(\".\")}throw new TypeError(\"[tree.dotPath]: the path argument should be a string or an array\")}function u(e,t,r=0){var n,i,f,u=e;for(n=0,i=t.length+r;n<i;n++){f=t[n];if(f===\"__proto__\"||typeof u===\"function\"){throw new Error(o)}if(!u||typeof u!==\"object\"){return undefined}u=u[f]}return u}function a(e,t){var r,n,i,f=e;for(r=0,n=t.length-1;r<n;r++){i=t[r];if(i===\"__proto__\"||typeof f[i]===\"function\"){throw new Error(o)}if(!f[i]||typeof f[i]!==\"object\"){f[i]={}}f=f[i]}return f}n.get=((e,t)=>u(e,f(t)));n.set=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);u[i]=r;return r});n.define=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(!(i in u)){u[i]=r}return r});n.inc=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(typeof u[i]===\"number\"){u[i]++}else if(!u[i]||typeof u[i]!==\"object\"){u[i]=1}return r});n.dec=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(typeof u[i]===\"number\"){u[i]--}else if(!u[i]||typeof u[i]!==\"object\"){u[i]=-1}return r});n.concat=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(!u[i]){u[i]=r}else if(Array.isArray(u[i])&&Array.isArray(r)){u[i]=u[i].concat(r)}return r});n.insert=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(!u[i]){u[i]=r}else if(Array.isArray(u[i])&&Array.isArray(r)){u[i]=r.concat(u[i])}return r});n.delete=((e,t)=>{var r=f(t),n=r[r.length-1];if(n===\"__proto__\"){throw new Error(o)}var i=u(e,r,-1);if(!i||typeof i!==\"object\"){return false}return delete i[n]});n.autoPush=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(u[i]===undefined){u[i]=r}else if(Array.isArray(u[i])){u[i].push(r)}else{u[i]=[u[i],r]}return u[i]});n.append=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(!u[i]){u[i]=[r]}else if(Array.isArray(u[i])){u[i].push(r)}return u[i]});n.prepend=((e,t,r)=>{if(!e||typeof e!==\"object\"){return undefined}var n=f(t),i=n[n.length-1];if(i===\"__proto__\"){throw new Error(o)}var u=a(e,n);if(!u[i]){u[i]=[r]}else if(Array.isArray(u[i])){u[i].unshift(r)}return u[i]})},{}],4:[function(e,t,r){\"use strict\";function n(e,t,...r){var n,o,f=false,u=r.length;if(!u){return t}if(!e||typeof e!==\"object\"){e={}}var a={depth:0,prefix:\"\"};if(e.deep){if(Array.isArray(e.deep)){e.deep=new Set(e.deep)}else if(!(e.deep instanceof Set)){e.deep=true}}if(e.immutables){if(Array.isArray(e.immutables)){e.immutables=new Set(e.immutables)}else if(!(e.immutables instanceof Set)){delete e.immutables}}if(!e.maxDepth&&e.deep&&!e.circular){e.maxDepth=100}if(e.deepFunc){e.deep=true}if(e.flat){e.deep=true;e.proto=false;e.inherit=false;e.unflat=false;if(typeof e.flat!==\"string\"){e.flat=\".\"}}if(e.unflat){e.deep=false;e.proto=false;e.inherit=false;e.flat=false;if(typeof e.unflat!==\"string\"){e.unflat=\".\"}}if(e.inherit){e.own=true;e.proto=false}else if(e.proto){e.own=true}if(!t||typeof t!==\"object\"&&typeof t!==\"function\"){f=true}if(!e.skipRoot&&(e.inherit||e.proto)){for(n=u-1;n>=0;n--){o=r[n];if(o&&(typeof o===\"object\"||typeof o===\"function\")){if(e.inherit){if(f){t=Object.create(o)}else{Object.setPrototypeOf(t,o)}}else if(e.proto){if(f){t=Object.create(Object.getPrototypeOf(o))}else{Object.setPrototypeOf(t,Object.getPrototypeOf(o))}}break}}}else if(f){t={}}a.references={sources:[],targets:[]};for(n=0;n<u;n++){o=r[n];if(!o||typeof o!==\"object\"&&typeof o!==\"function\"){continue}i(a,e,t,o)}return t}t.exports=n;function i(e,t,r,n){var o,f,u,a,s,c,p,d,l,y,h,b=-1;if(t.maxDepth&&e.depth>t.maxDepth){throw new Error(\"[tree] extend(): max depth reached(\"+t.maxDepth+\")\")}if(t.circular){e.references.sources.push(n);e.references.targets.push(r)}if(t.own){if(t.nonEnum){u=Object.getOwnPropertyNames(n)}else{u=Object.keys(n)}}else{u=n}for(a in u){if(t.own){a=u[a]}if(a===\"__proto__\"){continue}if(t.descriptor){d=Object.getOwnPropertyDescriptor(n,a);s=d.value}else{s=n[a]}y=r;l=e.prefix+a;if(t.nofunc&&typeof s===\"function\"){continue}if(t.unflat&&e.depth===0){h=a.split(t.unflat);f=h.length-1;if(f){for(o=0;o<f;o++){if(!y[h[o]]||typeof y[h[o]]!==\"object\"&&typeof y[h[o]]!==\"function\"){y[h[o]]={}}y=y[h[o]]}l=e.prefix+h[f]}}if(t.deep&&s&&(typeof s===\"object\"||t.deepFunc&&typeof s===\"function\")&&(!t.descriptor||!d.get)&&((c=Object.getPrototypeOf(s))||true)&&(!(t.deep instanceof Set)||t.deep.has(c))&&(!t.immutables||!t.immutables.has(c))){if(t.circular){b=e.references.sources.indexOf(s)}if(t.flat){if(b>=0){continue}i({depth:e.depth+1,prefix:e.prefix+a+t.flat,references:e.references},t,y,s)}else{if(b>=0){if(t.descriptor){Object.defineProperty(y,l,{value:e.references.targets[b],enumerable:d.enumerable,writable:d.writable,configurable:d.configurable})}else{y[l]=e.references.targets[b]}continue}if(!y[l]||!Object.prototype.hasOwnProperty.call(y,l)||typeof y[l]!==\"object\"&&typeof y[l]!==\"function\"){if(Array.isArray(s)){p=[]}else if(t.proto){p=Object.create(c)}else if(t.inherit){p=Object.create(s)}else{p={}}if(t.descriptor){Object.defineProperty(y,l,{value:p,enumerable:d.enumerable,writable:d.writable,configurable:d.configurable})}else{y[l]=p}}else if(t.proto&&Object.getPrototypeOf(y[l])!==c){Object.setPrototypeOf(y[l],c)}else if(t.inherit&&Object.getPrototypeOf(y[l])!==s){Object.setPrototypeOf(y[l],s)}if(t.circular){e.references.sources.push(s);e.references.targets.push(y[l])}i({depth:e.depth+1,prefix:\"\",references:e.references},t,y[l],s)}}else if(t.preserve&&y[l]!==undefined){continue}else if(!t.inherit){if(t.descriptor){Object.defineProperty(y,l,d)}else{y[l]=s}}if(t.move){delete n[a]}}}},{}],5:[function(e,t,r){\"use strict\";const n={};t.exports=n;const i=\"This would pollute prototype\";n.op=function(e,t,r,n){var o,f,u,a,s,c=false,p=false,d,l=true;if(!t||typeof t!==\"object\"){return}if(typeof r===\"string\"){if(r){f=r.match(/([.#[\\]]|[^.#[\\]]+)/g)}else{f=[\"\"]}if(f[0]===\".\"){f.unshift(\"\")}if(f[f.length-1]===\".\"){f.push(\"\")}}else if(Array.isArray(r)){f=r;p=true}else{throw new TypeError(\"[tree.path] .\"+e+\"(): the path argument should be a string or an array\")}switch(e){case\"get\":case\"delete\":d=false;break;case\"set\":case\"define\":case\"inc\":case\"dec\":case\"append\":case\"prepend\":case\"concat\":case\"insert\":case\"autoPush\":d=true;break;default:throw new TypeError(\"[tree.path] .op(): wrong type of operation '\"+e+\"'\")}a=t;u=f.length-1;for(o=0;o<=u;o++){if(p){if(s===undefined){s=f[o];if(s===\"__proto__\"){throw new Error(i)}continue}if(typeof a[s]===\"function\"){throw new Error(i)}if(!a[s]||typeof a[s]!==\"object\"){if(!d){return undefined}a[s]={}}a=a[s];s=f[o];if(s===\"__proto__\"){throw new Error(i)}continue}else if(f[o]===\".\"){c=false;if(s===undefined){if(!l){l=true;continue}s=\"\"}if(typeof a[s]===\"function\"){throw new Error(i)}if(!a[s]||typeof a[s]!==\"object\"){if(!d){return undefined}a[s]={}}a=a[s];l=true;continue}else if(f[o]===\"#\"||f[o]===\"[\"){c=true;l=false;if(s===undefined){if(!Array.isArray(a)){return undefined}continue}if(typeof a[s]===\"function\"){throw new Error(i)}if(!a[s]||!Array.isArray(a[s])){if(!d){return undefined}a[s]=[]}a=a[s];continue}else if(f[o]===\"]\"){l=false;continue}l=false;if(!c){s=f[o];if(s===\"__proto__\"){throw new Error(i)}continue}switch(f[o]){case\"length\":s=\"length\";break;case\"first\":s=0;break;case\"last\":s=a.length-1;if(s<0){s=0}break;case\"next\":if(!d){return undefined}s=a.length;break;case\"insert\":if(!d){return undefined}a.unshift(undefined);s=0;break;default:s=parseInt(f[o],10)}}switch(e){case\"get\":return a[s];case\"delete\":if(c&&typeof s===\"number\"){a.splice(s,1)}else{delete a[s]}return;case\"set\":a[s]=n;return a[s];case\"define\":if(!(s in a)){a[s]=n}return a[s];case\"inc\":if(typeof a[s]===\"number\"){a[s]++}else if(!a[s]||typeof a[s]!==\"object\"){a[s]=1}return a[s];case\"dec\":if(typeof a[s]===\"number\"){a[s]--}else if(!a[s]||typeof a[s]!==\"object\"){a[s]=-1}return a[s];case\"append\":if(!a[s]){a[s]=[n]}else if(Array.isArray(a[s])){a[s].push(n)}return a[s];case\"prepend\":if(!a[s]){a[s]=[n]}else if(Array.isArray(a[s])){a[s].unshift(n)}return a[s];case\"concat\":if(!a[s]){a[s]=n}else if(Array.isArray(a[s])&&Array.isArray(n)){a[s]=a[s].concat(n)}return a[s];case\"insert\":if(!a[s]){a[s]=n}else if(Array.isArray(a[s])&&Array.isArray(n)){a[s]=n.concat(a[s])}return a[s];case\"autoPush\":if(a[s]===undefined){a[s]=n}else if(Array.isArray(a[s])){a[s].push(n)}else{a[s]=[a[s],n]}return a[s]}};n.get=n.op.bind(undefined,\"get\");n.delete=n.op.bind(undefined,\"delete\");n.set=n.op.bind(undefined,\"set\");n.define=n.op.bind(undefined,\"define\");n.inc=n.op.bind(undefined,\"inc\");n.dec=n.op.bind(undefined,\"dec\");n.append=n.op.bind(undefined,\"append\");n.prepend=n.op.bind(undefined,\"prepend\");n.concat=n.op.bind(undefined,\"concat\");n.insert=n.op.bind(undefined,\"insert\");n.autoPush=n.op.bind(undefined,\"autoPush\");n.prototype={get:function(e){return n.get(this,e)},delete:function(e){return n.delete(this,e)},set:function(e,t){return n.set(this,e,t)},define:function(e,t){return n.define(this,e,t)},inc:function(e,t){return n.inc(this,e,t)},dec:function(e,t){return n.dec(this,e,t)},append:function(e,t){return n.append(this,e,t)},prepend:function(e,t){return n.prepend(this,e,t)},concat:function(e,t){return n.concat(this,e,t)},insert:function(e,t){return n.insert(this,e,t)},autoPush:function(e,t){return n.autoPush(this,e,t)}};n.upgrade=function(e){Object.defineProperties(e,{get:{value:n.op.bind(undefined,\"get\",e)},delete:{value:n.op.bind(undefined,\"delete\",e)},set:{value:n.op.bind(undefined,\"set\",e)},define:{value:n.op.bind(undefined,\"define\",e)},inc:{value:n.op.bind(undefined,\"inc\",e)},dec:{value:n.op.bind(undefined,\"dec\",e)},append:{value:n.op.bind(undefined,\"append\",e)},prepend:{value:n.op.bind(undefined,\"prepend\",e)},concat:{value:n.op.bind(undefined,\"concat\",e)},insert:{value:n.op.bind(undefined,\"insert\",e)},autoPush:{value:n.op.bind(undefined,\"autoPush\",e)}})}},{}]},{},[1])(1)});", "{\n  \"name\": \"tree-kit\",\n  \"version\": \"0.7.0\",\n  \"description\": \"Tree utilities which provides a full-featured extend and object-cloning facility, and various tools to deal with nested object structures.\",\n  \"main\": \"lib/tree.js\",\n  \"directories\": {\n    \"test\": \"test\",\n    \"bench\": \"bench\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"browserify\": \"^16.2.3\",\n    \"uglify-es\": \"^3.3.9\"\n  },\n  \"scripts\": {\n    \"test\": \"tea-time -R dot\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/cronvel/tree-kit.git\"\n  },\n  \"keywords\": [\n    \"tree\",\n    \"extend\",\n    \"clone\",\n    \"prototype\",\n    \"inherit\",\n    \"deep\",\n    \"diff\",\n    \"mask\"\n  ],\n  \"author\": \"C\u00e9dric Ronvel\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cronvel/tree-kit/issues\"\n  },\n  \"config\": {\n    \"tea-time\": {\n      \"coverDir\": [\n        \"lib\"\n      ]\n    }\n  },\n  \"copyright\": {\n    \"title\": \"Tree Kit\",\n    \"years\": [\n      2014,\n      2021\n    ],\n    \"owner\": \"C\u00e9dric Ronvel\"\n  }\n}\n"], "filenames": ["CHANGELOG", "browser/tree-kit.js", "browser/tree-kit.min.js", "package.json"], "buggy_code_start_loc": [0, 5, 1, 3], "buggy_code_end_loc": [0, 731, 2, 4], "fixing_code_start_loc": [1, 5, 1, 3], "fixing_code_end_loc": [7, 1049, 2, 4], "type": "CWE-1321", "message": "A vulnerability classified as problematic has been found in cronvel tree-kit up to 0.6.x. This affects an unknown part. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). Upgrading to version 0.7.0 is able to address this issue. The name of the patch is a63f559c50d70e8cb2eaae670dec25d1dbc4afcd. It is recommended to upgrade the affected component. The identifier VDB-216765 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2021-4278", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-25T16:15:10.400", "lastModified": "2023-01-05T02:34:37.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in cronvel tree-kit up to 0.6.x. This affects an unknown part. The manipulation leads to improperly controlled modification of object prototype attributes ('prototype pollution'). Upgrading to version 0.7.0 is able to address this issue. The name of the patch is a63f559c50d70e8cb2eaae670dec25d1dbc4afcd. It is recommended to upgrade the affected component. The identifier VDB-216765 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tree_kit_project:tree_kit:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.7.0", "matchCriteriaId": "97CBC52E-DFF3-4525-9196-BEC3BF9F1147"}]}]}], "references": [{"url": "https://github.com/cronvel/tree-kit/commit/a63f559c50d70e8cb2eaae670dec25d1dbc4afcd", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cronvel/tree-kit/releases/tag/v0.7.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.216765", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216765", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cronvel/tree-kit/commit/a63f559c50d70e8cb2eaae670dec25d1dbc4afcd"}}