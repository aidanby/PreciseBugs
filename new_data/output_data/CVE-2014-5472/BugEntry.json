{"buggy_code": ["/*\n *  linux/fs/isofs/inode.c\n *\n *  (C) 1991  Linus Torvalds - minix filesystem\n *      1992, 1993, 1994  Eric Youngdale Modified for ISO 9660 filesystem.\n *      1994  Eberhard M\u00f6nkeberg - multi session handling.\n *      1995  Mark Dobie - allow mounting of some weird VideoCDs and PhotoCDs.\n *\t1997  Gordon Chaffee - Joliet CDs\n *\t1998  Eric Lammerts - ISO 9660 Level 3\n *\t2004  Paul Serice - Inode Support pushed out from 4GB to 128GB\n *\t2004  Paul Serice - NFS Export Operations\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/cdrom.h>\n#include <linux/parser.h>\n#include <linux/mpage.h>\n#include <linux/user_namespace.h>\n\n#include \"isofs.h\"\n#include \"zisofs.h\"\n\n#define BEQUIET\n\nstatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_hash(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int isofs_dentry_cmp(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\n#ifdef CONFIG_JOLIET\nstatic int isofs_hashi_ms(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_hash_ms(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_dentry_cmpi_ms(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int isofs_dentry_cmp_ms(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n#endif\n\nstatic void isofs_put_super(struct super_block *sb)\n{\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\treturn;\n}\n\nstatic int isofs_read_inode(struct inode *);\nstatic int isofs_statfs (struct dentry *, struct kstatfs *);\n\nstatic struct kmem_cache *isofs_inode_cachep;\n\nstatic struct inode *isofs_alloc_inode(struct super_block *sb)\n{\n\tstruct iso_inode_info *ei;\n\tei = kmem_cache_alloc(isofs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void isofs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(isofs_inode_cachep, ISOFS_I(inode));\n}\n\nstatic void isofs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, isofs_i_callback);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct iso_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tisofs_inode_cachep = kmem_cache_create(\"isofs_inode_cache\",\n\t\t\t\t\tsizeof(struct iso_inode_info),\n\t\t\t\t\t0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tinit_once);\n\tif (isofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(isofs_inode_cachep);\n}\n\nstatic int isofs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & MS_RDONLY))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nstatic const struct super_operations isofs_sops = {\n\t.alloc_inode\t= isofs_alloc_inode,\n\t.destroy_inode\t= isofs_destroy_inode,\n\t.put_super\t= isofs_put_super,\n\t.statfs\t\t= isofs_statfs,\n\t.remount_fs\t= isofs_remount,\n\t.show_options\t= generic_show_options,\n};\n\n\nstatic const struct dentry_operations isofs_dentry_ops[] = {\n\t{\n\t\t.d_hash\t\t= isofs_hash,\n\t\t.d_compare\t= isofs_dentry_cmp,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi,\n\t\t.d_compare\t= isofs_dentry_cmpi,\n\t},\n#ifdef CONFIG_JOLIET\n\t{\n\t\t.d_hash\t\t= isofs_hash_ms,\n\t\t.d_compare\t= isofs_dentry_cmp_ms,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi_ms,\n\t\t.d_compare\t= isofs_dentry_cmpi_ms,\n\t},\n#endif\n};\n\nstruct iso9660_options{\n\tunsigned int rock:1;\n\tunsigned int joliet:1;\n\tunsigned int cruft:1;\n\tunsigned int hide:1;\n\tunsigned int showassoc:1;\n\tunsigned int nocompress:1;\n\tunsigned int overriderockperm:1;\n\tunsigned int uid_set:1;\n\tunsigned int gid_set:1;\n\tunsigned int utf8:1;\n\tunsigned char map;\n\tunsigned char check;\n\tunsigned int blocksize;\n\tumode_t fmode;\n\tumode_t dmode;\n\tkgid_t gid;\n\tkuid_t uid;\n\tchar *iocharset;\n\t/* LVE */\n\ts32 session;\n\ts32 sbsector;\n};\n\n/*\n * Compute the hash for the isofs name corresponding to the dentry.\n */\nstatic int\nisofs_hash_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(name, len);\n\n\treturn 0;\n}\n\n/*\n * Compute the hash for the isofs name corresponding to the dentry.\n */\nstatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n/*\n * Compare of two isofs names.\n */\nstatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strnicmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nisofs_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(qstr, 0);\n}\n\nstatic int\nisofs_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 0);\n}\n\nstatic int\nisofs_dentry_cmp(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 0);\n}\n\nstatic int\nisofs_dentry_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 1);\n}\n\n#ifdef CONFIG_JOLIET\nstatic int\nisofs_hash_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(qstr, 1);\n}\n\nstatic int\nisofs_hashi_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 1);\n}\n\nstatic int\nisofs_dentry_cmp_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 0);\n}\n\nstatic int\nisofs_dentry_cmpi_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 1);\n}\n#endif\n\nenum {\n\tOpt_block, Opt_check_r, Opt_check_s, Opt_cruft, Opt_gid, Opt_ignore,\n\tOpt_iocharset, Opt_map_a, Opt_map_n, Opt_map_o, Opt_mode, Opt_nojoliet,\n\tOpt_norock, Opt_sb, Opt_session, Opt_uid, Opt_unhide, Opt_utf8, Opt_err,\n\tOpt_nocompress, Opt_hide, Opt_showassoc, Opt_dmode, Opt_overriderockperm,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t/* unset */\n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->utf8 = 0;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tpopt->utf8 = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_iocharset:\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n > 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/*\n * look if the driver can tell the multi session redirection value\n *\n * don't change this if you don't know what you do, please!\n * Multisession is legal only with XA disks.\n * A non-XA disk with more than one volume descriptor may do it right, but\n * usually is written in a nowhere standardized \"multi-partition\" manner.\n * Multisession uses absolute addressing (solely the first frame of the whole\n * track is #0), multi-partition uses relative addressing (each first frame of\n * each track is #0), and a track is not a session.\n *\n * A broken CDwriter software or drive firmware does not set new standards,\n * at least not if conflicting with the existing ones.\n *\n * emoenke@gwdg.de\n */\n#define WE_OBEY_THE_WRITTEN_STANDARDS 1\n\nstatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start=0;\n\tms_info.addr_format=CDROM_LBA;\n\tif(session >= 0 && session <= 99) {\n\t\tstruct cdrom_tocentry Te;\n\t\tTe.cdte_track=session;\n\t\tTe.cdte_format=CDROM_LBA;\n\t\ti = ioctl_by_bdev(bdev, CDROMREADTOCENTRY, (unsigned long) &Te);\n\t\tif (!i) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, Te.cdte_addr.lba,\n\t\t\t\tTe.cdte_ctrl&CDROM_DATA_TRACK);\n\t\t\tif ((Te.cdte_ctrl&CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn Te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long) &ms_info);\n\tif (session > 0)\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number\\n\");\n#if 0\n\tprintk(KERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",i);\n\tif (i==0) {\n\t\tprintk(KERN_DEBUG \"isofs.inode: XA disk: %s\\n\",ms_info.xa_flag?\"yes\":\"no\");\n\t\tprintk(KERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\", ms_info.addr.lba);\n\t}\n#endif\n\tif (i==0)\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n#endif\n\t\t\tvol_desc_start=ms_info.addr.lba;\n\treturn vol_desc_start;\n}\n\n/*\n * Check if root directory is empty (has less than 3 files).\n *\n * Used to detect broken CDs where ISO root directory is empty but Joliet root\n * directory is OK. If such CD has Rock Ridge extensions, they will be disabled\n * (and Joliet used instead) or else no files would be visible.\n */\nstatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}\n\n/*\n * Initialize the superblock and read the root inode.\n *\n * Note: a check_disk_change() has been done immediately prior\n * to this call, so we don't need to check again.\n */\nstatic int isofs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh = NULL, *pri_bh = NULL;\n\tstruct hs_primary_descriptor *h_pri = NULL;\n\tstruct iso_primary_descriptor *pri = NULL;\n\tstruct iso_supplementary_descriptor *sec = NULL;\n\tstruct iso_directory_record *rootp;\n\tstruct inode *inode;\n\tstruct iso9660_options opt;\n\tstruct isofs_sb_info *sbi;\n\tunsigned long first_data_zone;\n\tint joliet_level = 0;\n\tint iso_blknum, block;\n\tint orig_zonesize;\n\tint table, error = -EINVAL;\n\tunsigned int vol_desc_start;\n\n\tsave_mount_options(s, data);\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tif (!parse_options((char *)data, &opt))\n\t\tgoto out_freesbi;\n\n\t/*\n\t * First of all, get the hardware blocksize for this device.\n\t * If we don't know what it is, or the hardware blocksize is\n\t * larger than the blocksize the user specified, then use\n\t * that value.\n\t */\n\t/*\n\t * What if bugger tells us to go beyond page size?\n\t */\n\topt.blocksize = sb_min_blocksize(s, opt.blocksize);\n\n\tsbi->s_high_sierra = 0; /* default is iso9660 */\n\n\tvol_desc_start = (opt.sbsector != -1) ?\n\t\topt.sbsector : isofs_get_last_session(s,opt.session);\n\n\tfor (iso_blknum = vol_desc_start+16;\n\t\tiso_blknum < vol_desc_start+100; iso_blknum++) {\n\t\tstruct hs_volume_descriptor *hdp;\n\t\tstruct iso_volume_descriptor  *vdp;\n\n\t\tblock = iso_blknum << (ISOFS_BLOCK_BITS - s->s_blocksize_bits);\n\t\tif (!(bh = sb_bread(s, block)))\n\t\t\tgoto out_no_read;\n\n\t\tvdp = (struct iso_volume_descriptor *)bh->b_data;\n\t\thdp = (struct hs_volume_descriptor *)bh->b_data;\n\n\t\t/*\n\t\t * Due to the overlapping physical location of the descriptors,\n\t\t * ISO CDs can match hdp->id==HS_STANDARD_ID as well. To ensure\n\t\t * proper identification in this case, we first check for ISO.\n\t\t */\n\t\tif (strncmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) == 0) {\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_END)\n\t\t\t\tbreak;\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_PRIMARY) {\n\t\t\t\tif (pri == NULL) {\n\t\t\t\t\tpri = (struct iso_primary_descriptor *)vdp;\n\t\t\t\t\t/* Save the buffer in case we need it ... */\n\t\t\t\t\tpri_bh = bh;\n\t\t\t\t\tbh = NULL;\n\t\t\t\t}\n\t\t\t}\n#ifdef CONFIG_JOLIET\n\t\t\telse if (isonum_711(vdp->type) == ISO_VD_SUPPLEMENTARY) {\n\t\t\t\tsec = (struct iso_supplementary_descriptor *)vdp;\n\t\t\t\tif (sec->escape[0] == 0x25 && sec->escape[1] == 0x2f) {\n\t\t\t\t\tif (opt.joliet) {\n\t\t\t\t\t\tif (sec->escape[2] == 0x40)\n\t\t\t\t\t\t\tjoliet_level = 1;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x43)\n\t\t\t\t\t\t\tjoliet_level = 2;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x45)\n\t\t\t\t\t\t\tjoliet_level = 3;\n\n\t\t\t\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \"\n\t\t\t\t\t\t\t\"Microsoft Joliet Level %d\\n\",\n\t\t\t\t\t\t\tjoliet_level);\n\t\t\t\t\t}\n\t\t\t\t\tgoto root_found;\n\t\t\t\t} else {\n\t\t\t\t/* Unknown supplementary volume descriptor */\n\t\t\t\tsec = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tif (strncmp (hdp->id, HS_STANDARD_ID, sizeof hdp->id) == 0) {\n\t\t\t\tif (isonum_711(hdp->type) != ISO_VD_PRIMARY)\n\t\t\t\t\tgoto out_freebh;\n\n\t\t\t\tsbi->s_high_sierra = 1;\n\t\t\t\topt.rock = 0;\n\t\t\t\th_pri = (struct hs_primary_descriptor *)vdp;\n\t\t\t\tgoto root_found;\n\t\t\t}\n\t\t}\n\n\t\t/* Just skip any volume descriptors we don't recognize */\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t/*\n\t * If we fall through, either no volume descriptor was found,\n\t * or else we passed a primary descriptor looking for others.\n\t */\n\tif (!pri)\n\t\tgoto out_unknown_format;\n\tbrelse(bh);\n\tbh = pri_bh;\n\tpri_bh = NULL;\n\nroot_found:\n\n\tif (joliet_level && (pri == NULL || !opt.rock)) {\n\t\t/* This is the case of Joliet with the norock mount flag.\n\t\t * A disc with both Joliet and Rock Ridge is handled later\n\t\t */\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t}\n\n\tif(sbi->s_high_sierra){\n\t\trootp = (struct iso_directory_record *) h_pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(h_pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(h_pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(h_pri->volume_space_size);\n\t} else {\n\t\tif (!pri)\n\t\t\tgoto out_freebh;\n\t\trootp = (struct iso_directory_record *) pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(pri->volume_space_size);\n\t}\n\n\tsbi->s_ninodes = 0; /* No way to figure this out easily */\n\n\torig_zonesize = sbi->s_log_zone_size;\n\t/*\n\t * If the zone size is smaller than the hardware sector size,\n\t * this is a fatal error.  This would occur if the disc drive\n\t * had sectors that were 2048 bytes, but the filesystem had\n\t * blocks that were 512 bytes (which should only very rarely\n\t * happen.)\n\t */\n\tif (orig_zonesize < opt.blocksize)\n\t\tgoto out_bad_size;\n\n\t/* RDE: convert log zone size to bit shift */\n\tswitch (sbi->s_log_zone_size) {\n\tcase  512: sbi->s_log_zone_size =  9; break;\n\tcase 1024: sbi->s_log_zone_size = 10; break;\n\tcase 2048: sbi->s_log_zone_size = 11; break;\n\n\tdefault:\n\t\tgoto out_bad_zone_size;\n\t}\n\n\ts->s_magic = ISOFS_SUPER_MAGIC;\n\n\t/*\n\t * With multi-extent files, file size is only limited by the maximum\n\t * size of a file system, which is 8 TB.\n\t */\n\ts->s_maxbytes = 0x80000000000LL;\n\n\t/* Set this for reference. Its not currently used except on write\n\t   which we don't have .. */\n\n\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t  isonum_711(rootp->ext_attr_length);\n\tsbi->s_firstdatazone = first_data_zone;\n#ifndef BEQUIET\n\tprintk(KERN_DEBUG \"ISOFS: Max size:%ld   Log zone size:%ld\\n\",\n\t\tsbi->s_max_size, 1UL << sbi->s_log_zone_size);\n\tprintk(KERN_DEBUG \"ISOFS: First datazone:%ld\\n\", sbi->s_firstdatazone);\n\tif(sbi->s_high_sierra)\n\t\tprintk(KERN_DEBUG \"ISOFS: Disc in High Sierra format.\\n\");\n#endif\n\n\t/*\n\t * If the Joliet level is set, we _may_ decide to use the\n\t * secondary descriptor, but can't be sure until after we\n\t * read the root inode. But before reading the root inode\n\t * we may need to change the device blocksize, and would\n\t * rather release the old buffer first. So, we cache the\n\t * first_data_zone value from the secondary descriptor.\n\t */\n\tif (joliet_level) {\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t\trootp = (struct iso_directory_record *)\n\t\t\tpri->root_directory_record;\n\t\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t\tisonum_711(rootp->ext_attr_length);\n\t}\n\n\t/*\n\t * We're all done using the volume descriptor, and may need\n\t * to change the device blocksize, so release the buffer now.\n\t */\n\tbrelse(pri_bh);\n\tbrelse(bh);\n\n\t/*\n\t * Force the blocksize to 512 for 512 byte sectors.  The file\n\t * read primitives really get it wrong in a bad way if we don't\n\t * do this.\n\t *\n\t * Note - we should never be setting the blocksize to something\n\t * less than the hardware sector size for the device.  If we\n\t * do, we would end up having to read larger buffers and split\n\t * out portions to satisfy requests.\n\t *\n\t * Note2- the idea here is that we want to deal with the optimal\n\t * zonesize in the filesystem.  If we have it set to something less,\n\t * then we have horrible problems with trying to piece together\n\t * bits of adjacent blocks in order to properly read directory\n\t * entries.  By forcing the blocksize in this way, we ensure\n\t * that we will never be required to do this.\n\t */\n\tsb_set_blocksize(s, orig_zonesize);\n\n\tsbi->s_nls_iocharset = NULL;\n\n#ifdef CONFIG_JOLIET\n\tif (joliet_level && opt.utf8 == 0) {\n\t\tchar *p = opt.iocharset ? opt.iocharset : CONFIG_NLS_DEFAULT;\n\t\tsbi->s_nls_iocharset = load_nls(p);\n\t\tif (! sbi->s_nls_iocharset) {\n\t\t\t/* Fail only if explicit charset specified */\n\t\t\tif (opt.iocharset)\n\t\t\t\tgoto out_freesbi;\n\t\t\tsbi->s_nls_iocharset = load_nls_default();\n\t\t}\n\t}\n#endif\n\ts->s_op = &isofs_sops;\n\ts->s_export_op = &isofs_export_ops;\n\tsbi->s_mapping = opt.map;\n\tsbi->s_rock = (opt.rock ? 2 : 0);\n\tsbi->s_rock_offset = -1; /* initial offset, will guess until SP is found*/\n\tsbi->s_cruft = opt.cruft;\n\tsbi->s_hide = opt.hide;\n\tsbi->s_showassoc = opt.showassoc;\n\tsbi->s_uid = opt.uid;\n\tsbi->s_gid = opt.gid;\n\tsbi->s_uid_set = opt.uid_set;\n\tsbi->s_gid_set = opt.gid_set;\n\tsbi->s_utf8 = opt.utf8;\n\tsbi->s_nocompress = opt.nocompress;\n\tsbi->s_overriderockperm = opt.overriderockperm;\n\t/*\n\t * It would be incredibly stupid to allow people to mark every file\n\t * on the disk as suid, so we merely allow them to set the default\n\t * permissions.\n\t */\n\tif (opt.fmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_fmode = opt.fmode & 0777;\n\telse\n\t\tsbi->s_fmode = ISOFS_INVALID_MODE;\n\tif (opt.dmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_dmode = opt.dmode & 0777;\n\telse\n\t\tsbi->s_dmode = ISOFS_INVALID_MODE;\n\n\t/*\n\t * Read the root inode, which _may_ result in changing\n\t * the s_rock flag. Once we have the final s_rock value,\n\t * we then decide whether to use the Joliet descriptor.\n\t */\n\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\tif (IS_ERR(inode))\n\t\tgoto out_no_root;\n\n\t/*\n\t * Fix for broken CDs with Rock Ridge and empty ISO root directory but\n\t * correct Joliet root directory.\n\t */\n\tif (sbi->s_rock == 1 && joliet_level &&\n\t\t\t\trootdir_empty(s, sbi->s_firstdatazone)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"ISOFS: primary root directory is empty. \"\n\t\t\t\"Disabling Rock Ridge and switching to Joliet.\");\n\t\tsbi->s_rock = 0;\n\t}\n\n\t/*\n\t * If this disk has both Rock Ridge and Joliet on it, then we\n\t * want to use Rock Ridge by default.  This can be overridden\n\t * by using the norock mount option.  There is still one other\n\t * possibility that is not taken into account: a Rock Ridge\n\t * CD with Unicode names.  Until someone sees such a beast, it\n\t * will not be supported.\n\t */\n\tif (sbi->s_rock == 1) {\n\t\tjoliet_level = 0;\n\t} else if (joliet_level) {\n\t\tsbi->s_rock = 0;\n\t\tif (sbi->s_firstdatazone != first_data_zone) {\n\t\t\tsbi->s_firstdatazone = first_data_zone;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"ISOFS: changing to secondary root\\n\");\n\t\t\tiput(inode);\n\t\t\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\t\t\tif (IS_ERR(inode))\n\t\t\t\tgoto out_no_root;\n\t\t}\n\t}\n\n\tif (opt.check == 'u') {\n\t\t/* Only Joliet is case insensitive by default */\n\t\tif (joliet_level)\n\t\t\topt.check = 'r';\n\t\telse\n\t\t\topt.check = 's';\n\t}\n\tsbi->s_joliet_level = joliet_level;\n\n\t/* Make sure the root inode is a directory */\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"isofs_fill_super: root inode is not a directory. \"\n\t\t\t\"Corrupted media?\\n\");\n\t\tgoto out_iput;\n\t}\n\n\ttable = 0;\n\tif (joliet_level)\n\t\ttable += 2;\n\tif (opt.check == 'r')\n\t\ttable++;\n\n\ts->s_d_op = &isofs_dentry_ops[table];\n\n\t/* get the root dentry */\n\ts->s_root = d_make_root(inode);\n\tif (!(s->s_root)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_no_inode;\n\t}\n\n\tkfree(opt.iocharset);\n\n\treturn 0;\n\n\t/*\n\t * Display error messages and free resources.\n\t */\nout_iput:\n\tiput(inode);\n\tgoto out_no_inode;\nout_no_root:\n\terror = PTR_ERR(inode);\n\tif (error != -ENOMEM)\n\t\tprintk(KERN_WARNING \"%s: get root inode failed\\n\", __func__);\nout_no_inode:\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\tgoto out_freesbi;\nout_no_read:\n\tprintk(KERN_WARNING \"%s: bread failed, dev=%s, iso_blknum=%d, block=%d\\n\",\n\t\t__func__, s->s_id, iso_blknum, block);\n\tgoto out_freebh;\nout_bad_zone_size:\n\tprintk(KERN_WARNING \"ISOFS: Bad logical zone size %ld\\n\",\n\t\tsbi->s_log_zone_size);\n\tgoto out_freebh;\nout_bad_size:\n\tprintk(KERN_WARNING \"ISOFS: Logical zone size(%d) < hardware blocksize(%u)\\n\",\n\t\torig_zonesize, opt.blocksize);\n\tgoto out_freebh;\nout_unknown_format:\n\tif (!silent)\n\t\tprintk(KERN_WARNING \"ISOFS: Unable to identify CD-ROM format.\\n\");\n\nout_freebh:\n\tbrelse(bh);\n\tbrelse(pri_bh);\nout_freesbi:\n\tkfree(opt.iocharset);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn error;\n}\n\nstatic int isofs_statfs (struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = ISOFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (ISOFS_SB(sb)->s_nzones\n\t\t<< (ISOFS_SB(sb)->s_log_zone_size - sb->s_blocksize_bits));\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = ISOFS_SB(sb)->s_ninodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}\n\n/*\n * Get a set of blocks; filling in buffer_heads if already allocated\n * or getblk() if they are not.  Returns the number of blocks inserted\n * (-ve == error.)\n */\nint isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t/* If we are *way* beyond the end of the file, print a message.\n\t\t * Access beyond the end of the file up to the next page boundary\n\t\t * is normal, however because of the way the page cache works.\n\t\t * In this case, we just return 0 so that we can properly fill\n\t\t * the page with useless information without generating any\n\t\t * I/O errors.\n\t\t */\n\t\tif (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* On the last section, nextblk == 0, section size is likely to\n\t\t * exceed sect_size by a partial block, and access beyond the\n\t\t * end of the file will reach beyond the section size, too.\n\t\t */\n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t/* Next buffer head */\n\t\tb_off++;\t/* Next buffer offset */\n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}\n\n/*\n * Used by the standard interfaces.\n */\nstatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int isofs_bmap(struct inode *inode, sector_t block)\n{\n\tstruct buffer_head dummy;\n\tint error;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\terror = isofs_get_block(inode, block, &dummy, 0);\n\tif (!error)\n\t\treturn dummy.b_blocknr;\n\treturn 0;\n}\n\nstruct buffer_head *isofs_bread(struct inode *inode, sector_t block)\n{\n\tsector_t blknr = isofs_bmap(inode, block);\n\tif (!blknr)\n\t\treturn NULL;\n\treturn sb_bread(inode->i_sb, blknr);\n}\n\nstatic int isofs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, isofs_get_block);\n}\n\nstatic int isofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, isofs_get_block);\n}\n\nstatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}\n\nstatic const struct address_space_operations isofs_aops = {\n\t.readpage = isofs_readpage,\n\t.readpages = isofs_readpages,\n\t.bmap = _isofs_bmap\n};\n\nstatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t/* The first 16 blocks are reserved as the System Area.  Thus,\n\t * no inodes can appear in block 0.  We use this to flag that\n\t * this is the last section. */\n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}\n\nstatic int isofs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (tmpde == NULL) {\n\t\t\tprintk(KERN_INFO \"%s: out of memory\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t/* Assume it is a normal-format file unless told otherwise */\n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t/*\n\t\t\t\t\t * Set to 1.  We know there are 2, but\n\t\t\t\t\t * the find utility tries to optimize\n\t\t\t\t\t * if it is 2, and it screws up.  It is\n\t\t\t\t\t * easier to give 1 which tells find to\n\t\t\t\t\t * do it the hard way.\n\t\t\t\t\t */\n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Set default permissions: r-x for all.  The disc\n\t\t\t * could be shared with DOS machines so virtually\n\t\t\t * anything could be a valid executable.\n\t\t\t */\n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t/*\n\t * Some dipshit decided to store some other bit of information\n\t * in the high byte of the file length.  Truncate size in case\n\t * this CDROM was mounted with the cruft option.\n\t */\n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t/* I have no idea what file_unit_size is used for, so\n\t   we will flag it for now */\n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t/* I have no idea what other flag bits are used for, so\n\t   we will flag it for now */\n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\n\tinode->i_mtime.tv_sec =\n\tinode->i_atime.tv_sec =\n\tinode->i_ctime.tv_sec = iso_date(de->date, high_sierra);\n\tinode->i_mtime.tv_nsec =\n\tinode->i_atime.tv_nsec =\n\tinode->i_ctime.tv_nsec = 0;\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t/* Set the number of blocks for stat() - should be done before RR */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode);\n\t\t/* if we want uid/gid set, override the rock ridge setting */\n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t/* Now set final access rights if overriding rock ridge setting */\n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t/* Install the inode operations vector */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t/* XXX - parse_rock_ridge_inode() had already set i_rdev. */\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}\n\nstruct isofs_iget5_callback_data {\n\tunsigned long block;\n\tunsigned long offset;\n};\n\nstatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}\n\nstatic int isofs_iget5_set(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\ti->i_iget5_block = d->block;\n\ti->i_iget5_offset = d->offset;\n\treturn 0;\n}\n\n/* Store, in the inode's containing structure, the block and block\n * offset that point to the underlying meta-data for the inode.  The\n * code below is otherwise similar to the iget() code in\n * include/linux/fs.h */\nstruct inode *isofs_iget(struct super_block *sb,\n\t\t\t unsigned long block,\n\t\t\t unsigned long offset)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *isofs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\t/* We don't support read-write mounts */\n\tif (!(flags & MS_RDONLY))\n\t\treturn ERR_PTR(-EACCES);\n\treturn mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);\n}\n\nstatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"iso9660\");\nMODULE_ALIAS(\"iso9660\");\n\nstatic int __init init_iso9660_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out;\n#ifdef CONFIG_ZISOFS\n\terr = zisofs_init();\n\tif (err)\n\t\tgoto out1;\n#endif\n\terr = register_filesystem(&iso9660_fs_type);\n\tif (err)\n\t\tgoto out2;\n\treturn 0;\nout2:\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\nout1:\n#endif\n\tdestroy_inodecache();\nout:\n\treturn err;\n}\n\nstatic void __exit exit_iso9660_fs(void)\n{\n        unregister_filesystem(&iso9660_fs_type);\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\n#endif\n\tdestroy_inodecache();\n}\n\nmodule_init(init_iso9660_fs)\nmodule_exit(exit_iso9660_fs)\nMODULE_LICENSE(\"GPL\");\n", "#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/iso_fs.h>\n#include <asm/unaligned.h>\n\nenum isofs_file_format {\n\tisofs_file_normal = 0,\n\tisofs_file_sparse = 1,\n\tisofs_file_compressed = 2,\n};\n\t\n/*\n * iso fs inode data in memory\n */\nstruct iso_inode_info {\n\tunsigned long i_iget5_block;\n\tunsigned long i_iget5_offset;\n\tunsigned int i_first_extent;\n\tunsigned char i_file_format;\n\tunsigned char i_format_parm[3];\n\tunsigned long i_next_section_block;\n\tunsigned long i_next_section_offset;\n\toff_t i_section_size;\n\tstruct inode vfs_inode;\n};\n\n/*\n * iso9660 super-block data in memory\n */\nstruct isofs_sb_info {\n\tunsigned long s_ninodes;\n\tunsigned long s_nzones;\n\tunsigned long s_firstdatazone;\n\tunsigned long s_log_zone_size;\n\tunsigned long s_max_size;\n\t\n\tint           s_rock_offset; /* offset of SUSP fields within SU area */\n\tunsigned char s_joliet_level;\n\tunsigned char s_mapping;\n\tunsigned int  s_high_sierra:1;\n\tunsigned int  s_rock:2;\n\tunsigned int  s_utf8:1;\n\tunsigned int  s_cruft:1; /* Broken disks with high byte of length\n\t\t\t\t  * containing junk */\n\tunsigned int  s_nocompress:1;\n\tunsigned int  s_hide:1;\n\tunsigned int  s_showassoc:1;\n\tunsigned int  s_overriderockperm:1;\n\tunsigned int  s_uid_set:1;\n\tunsigned int  s_gid_set:1;\n\n\tumode_t s_fmode;\n\tumode_t s_dmode;\n\tkgid_t s_gid;\n\tkuid_t s_uid;\n\tstruct nls_table *s_nls_iocharset; /* Native language support table */\n};\n\n#define ISOFS_INVALID_MODE ((umode_t) -1)\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}\n\nstatic inline int isonum_711(char *p)\n{\n\treturn *(u8 *)p;\n}\nstatic inline int isonum_712(char *p)\n{\n\treturn *(s8 *)p;\n}\nstatic inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}\nstatic inline unsigned int isonum_722(char *p)\n{\n\treturn get_unaligned_be16(p);\n}\nstatic inline unsigned int isonum_723(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le16(p);\n}\nstatic inline unsigned int isonum_731(char *p)\n{\n\treturn get_unaligned_le32(p);\n}\nstatic inline unsigned int isonum_732(char *p)\n{\n\treturn get_unaligned_be32(p);\n}\nstatic inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}\nextern int iso_date(char *, int);\n\nstruct inode;\t\t/* To make gcc happy */\n\nextern int parse_rock_ridge_inode(struct iso_directory_record *, struct inode *);\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\n\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nextern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int flags);\nextern struct buffer_head *isofs_bread(struct inode *, sector_t);\nextern int isofs_get_blocks(struct inode *, sector_t, struct buffer_head **, unsigned long);\n\nextern struct inode *isofs_iget(struct super_block *sb,\n                                unsigned long block,\n                                unsigned long offset);\n\n/* Because the inode number is no longer relevant to finding the\n * underlying meta-data for an inode, we are free to choose a more\n * convenient 32-bit number as the inode number.  The inode numbering\n * scheme was recommended by Sergey Vlasov and Eric Lammerts. */\nstatic inline unsigned long isofs_get_ino(unsigned long block,\n\t\t\t\t\t  unsigned long offset,\n\t\t\t\t\t  unsigned long bufbits)\n{\n\treturn (block << (bufbits - 5)) | (offset >> 5);\n}\n\n/* Every directory can have many redundant directory entries scattered\n * throughout the directory tree.  First there is the directory entry\n * with the name of the directory stored in the parent directory.\n * Then, there is the \".\" directory entry stored in the directory\n * itself.  Finally, there are possibly many \"..\" directory entries\n * stored in all the subdirectories.\n *\n * In order for the NFS get_parent() method to work and for the\n * general consistency of the dcache, we need to make sure the\n * \"i_iget5_block\" and \"i_iget5_offset\" all point to exactly one of\n * the many redundant entries for each directory.  We normalize the\n * block and offset by always making them point to the \".\"  directory.\n *\n * Notice that we do not use the entry for the directory with the name\n * that is located in the parent directory.  Even though choosing this\n * first directory is more natural, it is much easier to find the \".\"\n * entry in the NFS get_parent() method because it is implicitly\n * encoded in the \"extent + ext_attr_length\" fields of _all_ the\n * redundant entries for the directory.  Thus, it can always be\n * reached regardless of which directory entry you have in hand.\n *\n * This works because the \".\" entry is simply the first directory\n * record when you start reading the file that holds all the directory\n * records, and this file starts at \"extent + ext_attr_length\" blocks.\n * Because the \".\" entry is always the first entry listed in the\n * directories file, the normalized \"offset\" value is always 0.\n *\n * You should pass the directory entry in \"de\".  On return, \"block\"\n * and \"offset\" will hold normalized values.  Only directories are\n * affected making it safe to call even for non-directory file\n * types. */\nstatic inline void\nisofs_normalize_block_and_offset(struct iso_directory_record* de,\n\t\t\t\t unsigned long *block,\n\t\t\t\t unsigned long *offset)\n{\n\t/* Only directories are normalized. */\n\tif (de->flags[0] & 2) {\n\t\t*offset = 0;\n\t\t*block = (unsigned long)isonum_733(de->extent)\n\t\t\t+ (unsigned long)isonum_711(de->ext_attr_length);\n\t}\n}\n\nextern const struct inode_operations isofs_dir_inode_operations;\nextern const struct file_operations isofs_dir_operations;\nextern const struct address_space_operations isofs_symlink_aops;\nextern const struct export_operations isofs_export_ops;\n", "/*\n *  linux/fs/isofs/rock.c\n *\n *  (C) 1992, 1993  Eric Youngdale\n *\n *  Rock Ridge Extensions to iso9660\n */\n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\n#include \"isofs.h\"\n#include \"rock.h\"\n\n/*\n * These functions are designed to read the system areas of a directory record\n * and extract relevant information.  There are different functions provided\n * depending upon what information we need at the time.  One function fills\n * out an inode structure, a second one extracts a filename, a third one\n * returns a symbolic link name, and a fourth one returns the extent number\n * for the file.\n */\n\n#define SIG(A,B) ((A) | ((B) << 8))\t/* isonum_721() */\n\nstruct rock_state {\n\tvoid *buffer;\n\tunsigned char *chr;\n\tint len;\n\tint cont_size;\n\tint cont_extent;\n\tint cont_offset;\n\tstruct inode *inode;\n};\n\n/*\n * This is a way of ensuring that we have something in the system\n * use fields that is compatible with Rock Ridge.  Return zero on success.\n */\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}\n\n/*\n * Returns 0 if the caller should continue scanning, 1 if the scan must end\n * and -ve on error.\n */\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}\n\n/*\n * We think there's a record of type `sig' at rs->chr.  Parse the signature\n * and make sure that there's really room for a record of that type.\n */\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n/*\n * return length of name field; 0: not found, -1: to be ignored\n */\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int regard_xa)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (regard_xa) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tISOFS_I(inode)->i_first_extent =\n\t\t\t    isonum_733(rr->u.CL.location);\n\t\t\treloc =\n\t\t\t    isofs_iget(inode->i_sb,\n\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n\t\t\t\t       0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}\n\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n{\n\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n\t}\n\treturn result;\n}\n\n/*\n * readpage() for symlinks: reads symlink contents into the page and either\n * makes it uptodate and returns 0 or returns error (-EIO)\n */\nstatic int rock_ridge_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = kmap(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t/*\n\t * If we go past the end of the buffer, there is some sort of error.\n\t */\n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* corrupted isofs */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t/* This tells is if there is a continuation record */\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t/* error exit from macro */\nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn -EIO;\n}\n\nconst struct address_space_operations isofs_symlink_aops = {\n\t.readpage = rock_ridge_symlink_readpage\n};\n"], "fixing_code": ["/*\n *  linux/fs/isofs/inode.c\n *\n *  (C) 1991  Linus Torvalds - minix filesystem\n *      1992, 1993, 1994  Eric Youngdale Modified for ISO 9660 filesystem.\n *      1994  Eberhard M\u00f6nkeberg - multi session handling.\n *      1995  Mark Dobie - allow mounting of some weird VideoCDs and PhotoCDs.\n *\t1997  Gordon Chaffee - Joliet CDs\n *\t1998  Eric Lammerts - ISO 9660 Level 3\n *\t2004  Paul Serice - Inode Support pushed out from 4GB to 128GB\n *\t2004  Paul Serice - NFS Export Operations\n */\n\n#include <linux/init.h>\n#include <linux/module.h>\n\n#include <linux/slab.h>\n#include <linux/nls.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/cdrom.h>\n#include <linux/parser.h>\n#include <linux/mpage.h>\n#include <linux/user_namespace.h>\n\n#include \"isofs.h\"\n#include \"zisofs.h\"\n\n#define BEQUIET\n\nstatic int isofs_hashi(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_hash(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_dentry_cmpi(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int isofs_dentry_cmp(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\n#ifdef CONFIG_JOLIET\nstatic int isofs_hashi_ms(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_hash_ms(const struct dentry *parent, struct qstr *qstr);\nstatic int isofs_dentry_cmpi_ms(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int isofs_dentry_cmp_ms(const struct dentry *parent,\n\t\tconst struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n#endif\n\nstatic void isofs_put_super(struct super_block *sb)\n{\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n\treturn;\n}\n\nstatic int isofs_read_inode(struct inode *, int relocated);\nstatic int isofs_statfs (struct dentry *, struct kstatfs *);\n\nstatic struct kmem_cache *isofs_inode_cachep;\n\nstatic struct inode *isofs_alloc_inode(struct super_block *sb)\n{\n\tstruct iso_inode_info *ei;\n\tei = kmem_cache_alloc(isofs_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void isofs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(isofs_inode_cachep, ISOFS_I(inode));\n}\n\nstatic void isofs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, isofs_i_callback);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct iso_inode_info *ei = foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int __init init_inodecache(void)\n{\n\tisofs_inode_cachep = kmem_cache_create(\"isofs_inode_cache\",\n\t\t\t\t\tsizeof(struct iso_inode_info),\n\t\t\t\t\t0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\tinit_once);\n\tif (isofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(isofs_inode_cachep);\n}\n\nstatic int isofs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tsync_filesystem(sb);\n\tif (!(*flags & MS_RDONLY))\n\t\treturn -EROFS;\n\treturn 0;\n}\n\nstatic const struct super_operations isofs_sops = {\n\t.alloc_inode\t= isofs_alloc_inode,\n\t.destroy_inode\t= isofs_destroy_inode,\n\t.put_super\t= isofs_put_super,\n\t.statfs\t\t= isofs_statfs,\n\t.remount_fs\t= isofs_remount,\n\t.show_options\t= generic_show_options,\n};\n\n\nstatic const struct dentry_operations isofs_dentry_ops[] = {\n\t{\n\t\t.d_hash\t\t= isofs_hash,\n\t\t.d_compare\t= isofs_dentry_cmp,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi,\n\t\t.d_compare\t= isofs_dentry_cmpi,\n\t},\n#ifdef CONFIG_JOLIET\n\t{\n\t\t.d_hash\t\t= isofs_hash_ms,\n\t\t.d_compare\t= isofs_dentry_cmp_ms,\n\t},\n\t{\n\t\t.d_hash\t\t= isofs_hashi_ms,\n\t\t.d_compare\t= isofs_dentry_cmpi_ms,\n\t},\n#endif\n};\n\nstruct iso9660_options{\n\tunsigned int rock:1;\n\tunsigned int joliet:1;\n\tunsigned int cruft:1;\n\tunsigned int hide:1;\n\tunsigned int showassoc:1;\n\tunsigned int nocompress:1;\n\tunsigned int overriderockperm:1;\n\tunsigned int uid_set:1;\n\tunsigned int gid_set:1;\n\tunsigned int utf8:1;\n\tunsigned char map;\n\tunsigned char check;\n\tunsigned int blocksize;\n\tumode_t fmode;\n\tumode_t dmode;\n\tkgid_t gid;\n\tkuid_t uid;\n\tchar *iocharset;\n\t/* LVE */\n\ts32 session;\n\ts32 sbsector;\n};\n\n/*\n * Compute the hash for the isofs name corresponding to the dentry.\n */\nstatic int\nisofs_hash_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\tqstr->hash = full_name_hash(name, len);\n\n\treturn 0;\n}\n\n/*\n * Compute the hash for the isofs name corresponding to the dentry.\n */\nstatic int\nisofs_hashi_common(struct qstr *qstr, int ms)\n{\n\tconst char *name;\n\tint len;\n\tchar c;\n\tunsigned long hash;\n\n\tlen = qstr->len;\n\tname = qstr->name;\n\tif (ms) {\n\t\twhile (len && name[len-1] == '.')\n\t\t\tlen--;\n\t}\n\n\thash = init_name_hash();\n\twhile (len--) {\n\t\tc = tolower(*name++);\n\t\thash = partial_name_hash(c, hash);\n\t}\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}\n\n/*\n * Compare of two isofs names.\n */\nstatic int isofs_dentry_cmp_common(\n\t\tunsigned int len, const char *str,\n\t\tconst struct qstr *name, int ms, int ci)\n{\n\tint alen, blen;\n\n\t/* A filename cannot end in '.' or we treat it like it has none */\n\talen = name->len;\n\tblen = len;\n\tif (ms) {\n\t\twhile (alen && name->name[alen-1] == '.')\n\t\t\talen--;\n\t\twhile (blen && str[blen-1] == '.')\n\t\t\tblen--;\n\t}\n\tif (alen == blen) {\n\t\tif (ci) {\n\t\t\tif (strnicmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (strncmp(name->name, str, alen) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int\nisofs_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(qstr, 0);\n}\n\nstatic int\nisofs_hashi(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 0);\n}\n\nstatic int\nisofs_dentry_cmp(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 0);\n}\n\nstatic int\nisofs_dentry_cmpi(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 0, 1);\n}\n\n#ifdef CONFIG_JOLIET\nstatic int\nisofs_hash_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hash_common(qstr, 1);\n}\n\nstatic int\nisofs_hashi_ms(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn isofs_hashi_common(qstr, 1);\n}\n\nstatic int\nisofs_dentry_cmp_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 0);\n}\n\nstatic int\nisofs_dentry_cmpi_ms(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn isofs_dentry_cmp_common(len, str, name, 1, 1);\n}\n#endif\n\nenum {\n\tOpt_block, Opt_check_r, Opt_check_s, Opt_cruft, Opt_gid, Opt_ignore,\n\tOpt_iocharset, Opt_map_a, Opt_map_n, Opt_map_o, Opt_mode, Opt_nojoliet,\n\tOpt_norock, Opt_sb, Opt_session, Opt_uid, Opt_unhide, Opt_utf8, Opt_err,\n\tOpt_nocompress, Opt_hide, Opt_showassoc, Opt_dmode, Opt_overriderockperm,\n};\n\nstatic const match_table_t tokens = {\n\t{Opt_norock, \"norock\"},\n\t{Opt_nojoliet, \"nojoliet\"},\n\t{Opt_unhide, \"unhide\"},\n\t{Opt_hide, \"hide\"},\n\t{Opt_showassoc, \"showassoc\"},\n\t{Opt_cruft, \"cruft\"},\n\t{Opt_utf8, \"utf8\"},\n\t{Opt_iocharset, \"iocharset=%s\"},\n\t{Opt_map_a, \"map=acorn\"},\n\t{Opt_map_a, \"map=a\"},\n\t{Opt_map_n, \"map=normal\"},\n\t{Opt_map_n, \"map=n\"},\n\t{Opt_map_o, \"map=off\"},\n\t{Opt_map_o, \"map=o\"},\n\t{Opt_session, \"session=%u\"},\n\t{Opt_sb, \"sbsector=%u\"},\n\t{Opt_check_r, \"check=relaxed\"},\n\t{Opt_check_r, \"check=r\"},\n\t{Opt_check_s, \"check=strict\"},\n\t{Opt_check_s, \"check=s\"},\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_mode, \"mode=%u\"},\n\t{Opt_dmode, \"dmode=%u\"},\n\t{Opt_overriderockperm, \"overriderockperm\"},\n\t{Opt_block, \"block=%u\"},\n\t{Opt_ignore, \"conv=binary\"},\n\t{Opt_ignore, \"conv=b\"},\n\t{Opt_ignore, \"conv=text\"},\n\t{Opt_ignore, \"conv=t\"},\n\t{Opt_ignore, \"conv=mtext\"},\n\t{Opt_ignore, \"conv=m\"},\n\t{Opt_ignore, \"conv=auto\"},\n\t{Opt_ignore, \"conv=a\"},\n\t{Opt_nocompress, \"nocompress\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct iso9660_options *popt)\n{\n\tchar *p;\n\tint option;\n\n\tpopt->map = 'n';\n\tpopt->rock = 1;\n\tpopt->joliet = 1;\n\tpopt->cruft = 0;\n\tpopt->hide = 0;\n\tpopt->showassoc = 0;\n\tpopt->check = 'u';\t\t/* unset */\n\tpopt->nocompress = 0;\n\tpopt->blocksize = 1024;\n\tpopt->fmode = popt->dmode = ISOFS_INVALID_MODE;\n\tpopt->uid_set = 0;\n\tpopt->gid_set = 0;\n\tpopt->gid = GLOBAL_ROOT_GID;\n\tpopt->uid = GLOBAL_ROOT_UID;\n\tpopt->iocharset = NULL;\n\tpopt->utf8 = 0;\n\tpopt->overriderockperm = 0;\n\tpopt->session=-1;\n\tpopt->sbsector=-1;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tunsigned n;\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_norock:\n\t\t\tpopt->rock = 0;\n\t\t\tbreak;\n\t\tcase Opt_nojoliet:\n\t\t\tpopt->joliet = 0;\n\t\t\tbreak;\n\t\tcase Opt_hide:\n\t\t\tpopt->hide = 1;\n\t\t\tbreak;\n\t\tcase Opt_unhide:\n\t\tcase Opt_showassoc:\n\t\t\tpopt->showassoc = 1;\n\t\t\tbreak;\n\t\tcase Opt_cruft:\n\t\t\tpopt->cruft = 1;\n\t\t\tbreak;\n\t\tcase Opt_utf8:\n\t\t\tpopt->utf8 = 1;\n\t\t\tbreak;\n#ifdef CONFIG_JOLIET\n\t\tcase Opt_iocharset:\n\t\t\tpopt->iocharset = match_strdup(&args[0]);\n\t\t\tbreak;\n#endif\n\t\tcase Opt_map_a:\n\t\t\tpopt->map = 'a';\n\t\t\tbreak;\n\t\tcase Opt_map_o:\n\t\t\tpopt->map = 'o';\n\t\t\tbreak;\n\t\tcase Opt_map_n:\n\t\t\tpopt->map = 'n';\n\t\t\tbreak;\n\t\tcase Opt_session:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n > 99)\n\t\t\t\treturn 0;\n\t\t\tpopt->session = n + 1;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->sbsector = option;\n\t\t\tbreak;\n\t\tcase Opt_check_r:\n\t\t\tpopt->check = 'r';\n\t\t\tbreak;\n\t\tcase Opt_check_s:\n\t\t\tpopt->check = 's';\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(popt->uid))\n\t\t\t\treturn 0;\n\t\t\tpopt->uid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(popt->gid))\n\t\t\t\treturn 0;\n\t\t\tpopt->gid_set = 1;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->fmode = option;\n\t\t\tbreak;\n\t\tcase Opt_dmode:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tpopt->dmode = option;\n\t\t\tbreak;\n\t\tcase Opt_overriderockperm:\n\t\t\tpopt->overriderockperm = 1;\n\t\t\tbreak;\n\t\tcase Opt_block:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tn = option;\n\t\t\tif (n != 512 && n != 1024 && n != 2048)\n\t\t\t\treturn 0;\n\t\t\tpopt->blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_nocompress:\n\t\t\tpopt->nocompress = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\n/*\n * look if the driver can tell the multi session redirection value\n *\n * don't change this if you don't know what you do, please!\n * Multisession is legal only with XA disks.\n * A non-XA disk with more than one volume descriptor may do it right, but\n * usually is written in a nowhere standardized \"multi-partition\" manner.\n * Multisession uses absolute addressing (solely the first frame of the whole\n * track is #0), multi-partition uses relative addressing (each first frame of\n * each track is #0), and a track is not a session.\n *\n * A broken CDwriter software or drive firmware does not set new standards,\n * at least not if conflicting with the existing ones.\n *\n * emoenke@gwdg.de\n */\n#define WE_OBEY_THE_WRITTEN_STANDARDS 1\n\nstatic unsigned int isofs_get_last_session(struct super_block *sb, s32 session)\n{\n\tstruct cdrom_multisession ms_info;\n\tunsigned int vol_desc_start;\n\tstruct block_device *bdev = sb->s_bdev;\n\tint i;\n\n\tvol_desc_start=0;\n\tms_info.addr_format=CDROM_LBA;\n\tif(session >= 0 && session <= 99) {\n\t\tstruct cdrom_tocentry Te;\n\t\tTe.cdte_track=session;\n\t\tTe.cdte_format=CDROM_LBA;\n\t\ti = ioctl_by_bdev(bdev, CDROMREADTOCENTRY, (unsigned long) &Te);\n\t\tif (!i) {\n\t\t\tprintk(KERN_DEBUG \"ISOFS: Session %d start %d type %d\\n\",\n\t\t\t\tsession, Te.cdte_addr.lba,\n\t\t\t\tTe.cdte_ctrl&CDROM_DATA_TRACK);\n\t\t\tif ((Te.cdte_ctrl&CDROM_DATA_TRACK) == 4)\n\t\t\t\treturn Te.cdte_addr.lba;\n\t\t}\n\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number or type of track\\n\");\n\t}\n\ti = ioctl_by_bdev(bdev, CDROMMULTISESSION, (unsigned long) &ms_info);\n\tif (session > 0)\n\t\tprintk(KERN_ERR \"ISOFS: Invalid session number\\n\");\n#if 0\n\tprintk(KERN_DEBUG \"isofs.inode: CDROMMULTISESSION: rc=%d\\n\",i);\n\tif (i==0) {\n\t\tprintk(KERN_DEBUG \"isofs.inode: XA disk: %s\\n\",ms_info.xa_flag?\"yes\":\"no\");\n\t\tprintk(KERN_DEBUG \"isofs.inode: vol_desc_start = %d\\n\", ms_info.addr.lba);\n\t}\n#endif\n\tif (i==0)\n#if WE_OBEY_THE_WRITTEN_STANDARDS\n\t\tif (ms_info.xa_flag) /* necessary for a valid ms_info.addr */\n#endif\n\t\t\tvol_desc_start=ms_info.addr.lba;\n\treturn vol_desc_start;\n}\n\n/*\n * Check if root directory is empty (has less than 3 files).\n *\n * Used to detect broken CDs where ISO root directory is empty but Joliet root\n * directory is OK. If such CD has Rock Ridge extensions, they will be disabled\n * (and Joliet used instead) or else no files would be visible.\n */\nstatic bool rootdir_empty(struct super_block *sb, unsigned long block)\n{\n\tint offset = 0, files = 0, de_len;\n\tstruct iso_directory_record *de;\n\tstruct buffer_head *bh;\n\n\tbh = sb_bread(sb, block);\n\tif (!bh)\n\t\treturn true;\n\twhile (files < 3) {\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\t\tif (de_len == 0)\n\t\t\tbreak;\n\t\tfiles++;\n\t\toffset += de_len;\n\t}\n\tbrelse(bh);\n\treturn files < 3;\n}\n\n/*\n * Initialize the superblock and read the root inode.\n *\n * Note: a check_disk_change() has been done immediately prior\n * to this call, so we don't need to check again.\n */\nstatic int isofs_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh = NULL, *pri_bh = NULL;\n\tstruct hs_primary_descriptor *h_pri = NULL;\n\tstruct iso_primary_descriptor *pri = NULL;\n\tstruct iso_supplementary_descriptor *sec = NULL;\n\tstruct iso_directory_record *rootp;\n\tstruct inode *inode;\n\tstruct iso9660_options opt;\n\tstruct isofs_sb_info *sbi;\n\tunsigned long first_data_zone;\n\tint joliet_level = 0;\n\tint iso_blknum, block;\n\tint orig_zonesize;\n\tint table, error = -EINVAL;\n\tunsigned int vol_desc_start;\n\n\tsave_mount_options(s, data);\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tif (!parse_options((char *)data, &opt))\n\t\tgoto out_freesbi;\n\n\t/*\n\t * First of all, get the hardware blocksize for this device.\n\t * If we don't know what it is, or the hardware blocksize is\n\t * larger than the blocksize the user specified, then use\n\t * that value.\n\t */\n\t/*\n\t * What if bugger tells us to go beyond page size?\n\t */\n\topt.blocksize = sb_min_blocksize(s, opt.blocksize);\n\n\tsbi->s_high_sierra = 0; /* default is iso9660 */\n\n\tvol_desc_start = (opt.sbsector != -1) ?\n\t\topt.sbsector : isofs_get_last_session(s,opt.session);\n\n\tfor (iso_blknum = vol_desc_start+16;\n\t\tiso_blknum < vol_desc_start+100; iso_blknum++) {\n\t\tstruct hs_volume_descriptor *hdp;\n\t\tstruct iso_volume_descriptor  *vdp;\n\n\t\tblock = iso_blknum << (ISOFS_BLOCK_BITS - s->s_blocksize_bits);\n\t\tif (!(bh = sb_bread(s, block)))\n\t\t\tgoto out_no_read;\n\n\t\tvdp = (struct iso_volume_descriptor *)bh->b_data;\n\t\thdp = (struct hs_volume_descriptor *)bh->b_data;\n\n\t\t/*\n\t\t * Due to the overlapping physical location of the descriptors,\n\t\t * ISO CDs can match hdp->id==HS_STANDARD_ID as well. To ensure\n\t\t * proper identification in this case, we first check for ISO.\n\t\t */\n\t\tif (strncmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) == 0) {\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_END)\n\t\t\t\tbreak;\n\t\t\tif (isonum_711(vdp->type) == ISO_VD_PRIMARY) {\n\t\t\t\tif (pri == NULL) {\n\t\t\t\t\tpri = (struct iso_primary_descriptor *)vdp;\n\t\t\t\t\t/* Save the buffer in case we need it ... */\n\t\t\t\t\tpri_bh = bh;\n\t\t\t\t\tbh = NULL;\n\t\t\t\t}\n\t\t\t}\n#ifdef CONFIG_JOLIET\n\t\t\telse if (isonum_711(vdp->type) == ISO_VD_SUPPLEMENTARY) {\n\t\t\t\tsec = (struct iso_supplementary_descriptor *)vdp;\n\t\t\t\tif (sec->escape[0] == 0x25 && sec->escape[1] == 0x2f) {\n\t\t\t\t\tif (opt.joliet) {\n\t\t\t\t\t\tif (sec->escape[2] == 0x40)\n\t\t\t\t\t\t\tjoliet_level = 1;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x43)\n\t\t\t\t\t\t\tjoliet_level = 2;\n\t\t\t\t\t\telse if (sec->escape[2] == 0x45)\n\t\t\t\t\t\t\tjoliet_level = 3;\n\n\t\t\t\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \"\n\t\t\t\t\t\t\t\"Microsoft Joliet Level %d\\n\",\n\t\t\t\t\t\t\tjoliet_level);\n\t\t\t\t\t}\n\t\t\t\t\tgoto root_found;\n\t\t\t\t} else {\n\t\t\t\t/* Unknown supplementary volume descriptor */\n\t\t\t\tsec = NULL;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tif (strncmp (hdp->id, HS_STANDARD_ID, sizeof hdp->id) == 0) {\n\t\t\t\tif (isonum_711(hdp->type) != ISO_VD_PRIMARY)\n\t\t\t\t\tgoto out_freebh;\n\n\t\t\t\tsbi->s_high_sierra = 1;\n\t\t\t\topt.rock = 0;\n\t\t\t\th_pri = (struct hs_primary_descriptor *)vdp;\n\t\t\t\tgoto root_found;\n\t\t\t}\n\t\t}\n\n\t\t/* Just skip any volume descriptors we don't recognize */\n\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\t}\n\t/*\n\t * If we fall through, either no volume descriptor was found,\n\t * or else we passed a primary descriptor looking for others.\n\t */\n\tif (!pri)\n\t\tgoto out_unknown_format;\n\tbrelse(bh);\n\tbh = pri_bh;\n\tpri_bh = NULL;\n\nroot_found:\n\n\tif (joliet_level && (pri == NULL || !opt.rock)) {\n\t\t/* This is the case of Joliet with the norock mount flag.\n\t\t * A disc with both Joliet and Rock Ridge is handled later\n\t\t */\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t}\n\n\tif(sbi->s_high_sierra){\n\t\trootp = (struct iso_directory_record *) h_pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(h_pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(h_pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(h_pri->volume_space_size);\n\t} else {\n\t\tif (!pri)\n\t\t\tgoto out_freebh;\n\t\trootp = (struct iso_directory_record *) pri->root_directory_record;\n\t\tsbi->s_nzones = isonum_733(pri->volume_space_size);\n\t\tsbi->s_log_zone_size = isonum_723(pri->logical_block_size);\n\t\tsbi->s_max_size = isonum_733(pri->volume_space_size);\n\t}\n\n\tsbi->s_ninodes = 0; /* No way to figure this out easily */\n\n\torig_zonesize = sbi->s_log_zone_size;\n\t/*\n\t * If the zone size is smaller than the hardware sector size,\n\t * this is a fatal error.  This would occur if the disc drive\n\t * had sectors that were 2048 bytes, but the filesystem had\n\t * blocks that were 512 bytes (which should only very rarely\n\t * happen.)\n\t */\n\tif (orig_zonesize < opt.blocksize)\n\t\tgoto out_bad_size;\n\n\t/* RDE: convert log zone size to bit shift */\n\tswitch (sbi->s_log_zone_size) {\n\tcase  512: sbi->s_log_zone_size =  9; break;\n\tcase 1024: sbi->s_log_zone_size = 10; break;\n\tcase 2048: sbi->s_log_zone_size = 11; break;\n\n\tdefault:\n\t\tgoto out_bad_zone_size;\n\t}\n\n\ts->s_magic = ISOFS_SUPER_MAGIC;\n\n\t/*\n\t * With multi-extent files, file size is only limited by the maximum\n\t * size of a file system, which is 8 TB.\n\t */\n\ts->s_maxbytes = 0x80000000000LL;\n\n\t/* Set this for reference. Its not currently used except on write\n\t   which we don't have .. */\n\n\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t  isonum_711(rootp->ext_attr_length);\n\tsbi->s_firstdatazone = first_data_zone;\n#ifndef BEQUIET\n\tprintk(KERN_DEBUG \"ISOFS: Max size:%ld   Log zone size:%ld\\n\",\n\t\tsbi->s_max_size, 1UL << sbi->s_log_zone_size);\n\tprintk(KERN_DEBUG \"ISOFS: First datazone:%ld\\n\", sbi->s_firstdatazone);\n\tif(sbi->s_high_sierra)\n\t\tprintk(KERN_DEBUG \"ISOFS: Disc in High Sierra format.\\n\");\n#endif\n\n\t/*\n\t * If the Joliet level is set, we _may_ decide to use the\n\t * secondary descriptor, but can't be sure until after we\n\t * read the root inode. But before reading the root inode\n\t * we may need to change the device blocksize, and would\n\t * rather release the old buffer first. So, we cache the\n\t * first_data_zone value from the secondary descriptor.\n\t */\n\tif (joliet_level) {\n\t\tpri = (struct iso_primary_descriptor *) sec;\n\t\trootp = (struct iso_directory_record *)\n\t\t\tpri->root_directory_record;\n\t\tfirst_data_zone = isonum_733(rootp->extent) +\n\t\t\t\tisonum_711(rootp->ext_attr_length);\n\t}\n\n\t/*\n\t * We're all done using the volume descriptor, and may need\n\t * to change the device blocksize, so release the buffer now.\n\t */\n\tbrelse(pri_bh);\n\tbrelse(bh);\n\n\t/*\n\t * Force the blocksize to 512 for 512 byte sectors.  The file\n\t * read primitives really get it wrong in a bad way if we don't\n\t * do this.\n\t *\n\t * Note - we should never be setting the blocksize to something\n\t * less than the hardware sector size for the device.  If we\n\t * do, we would end up having to read larger buffers and split\n\t * out portions to satisfy requests.\n\t *\n\t * Note2- the idea here is that we want to deal with the optimal\n\t * zonesize in the filesystem.  If we have it set to something less,\n\t * then we have horrible problems with trying to piece together\n\t * bits of adjacent blocks in order to properly read directory\n\t * entries.  By forcing the blocksize in this way, we ensure\n\t * that we will never be required to do this.\n\t */\n\tsb_set_blocksize(s, orig_zonesize);\n\n\tsbi->s_nls_iocharset = NULL;\n\n#ifdef CONFIG_JOLIET\n\tif (joliet_level && opt.utf8 == 0) {\n\t\tchar *p = opt.iocharset ? opt.iocharset : CONFIG_NLS_DEFAULT;\n\t\tsbi->s_nls_iocharset = load_nls(p);\n\t\tif (! sbi->s_nls_iocharset) {\n\t\t\t/* Fail only if explicit charset specified */\n\t\t\tif (opt.iocharset)\n\t\t\t\tgoto out_freesbi;\n\t\t\tsbi->s_nls_iocharset = load_nls_default();\n\t\t}\n\t}\n#endif\n\ts->s_op = &isofs_sops;\n\ts->s_export_op = &isofs_export_ops;\n\tsbi->s_mapping = opt.map;\n\tsbi->s_rock = (opt.rock ? 2 : 0);\n\tsbi->s_rock_offset = -1; /* initial offset, will guess until SP is found*/\n\tsbi->s_cruft = opt.cruft;\n\tsbi->s_hide = opt.hide;\n\tsbi->s_showassoc = opt.showassoc;\n\tsbi->s_uid = opt.uid;\n\tsbi->s_gid = opt.gid;\n\tsbi->s_uid_set = opt.uid_set;\n\tsbi->s_gid_set = opt.gid_set;\n\tsbi->s_utf8 = opt.utf8;\n\tsbi->s_nocompress = opt.nocompress;\n\tsbi->s_overriderockperm = opt.overriderockperm;\n\t/*\n\t * It would be incredibly stupid to allow people to mark every file\n\t * on the disk as suid, so we merely allow them to set the default\n\t * permissions.\n\t */\n\tif (opt.fmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_fmode = opt.fmode & 0777;\n\telse\n\t\tsbi->s_fmode = ISOFS_INVALID_MODE;\n\tif (opt.dmode != ISOFS_INVALID_MODE)\n\t\tsbi->s_dmode = opt.dmode & 0777;\n\telse\n\t\tsbi->s_dmode = ISOFS_INVALID_MODE;\n\n\t/*\n\t * Read the root inode, which _may_ result in changing\n\t * the s_rock flag. Once we have the final s_rock value,\n\t * we then decide whether to use the Joliet descriptor.\n\t */\n\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\tif (IS_ERR(inode))\n\t\tgoto out_no_root;\n\n\t/*\n\t * Fix for broken CDs with Rock Ridge and empty ISO root directory but\n\t * correct Joliet root directory.\n\t */\n\tif (sbi->s_rock == 1 && joliet_level &&\n\t\t\t\trootdir_empty(s, sbi->s_firstdatazone)) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"ISOFS: primary root directory is empty. \"\n\t\t\t\"Disabling Rock Ridge and switching to Joliet.\");\n\t\tsbi->s_rock = 0;\n\t}\n\n\t/*\n\t * If this disk has both Rock Ridge and Joliet on it, then we\n\t * want to use Rock Ridge by default.  This can be overridden\n\t * by using the norock mount option.  There is still one other\n\t * possibility that is not taken into account: a Rock Ridge\n\t * CD with Unicode names.  Until someone sees such a beast, it\n\t * will not be supported.\n\t */\n\tif (sbi->s_rock == 1) {\n\t\tjoliet_level = 0;\n\t} else if (joliet_level) {\n\t\tsbi->s_rock = 0;\n\t\tif (sbi->s_firstdatazone != first_data_zone) {\n\t\t\tsbi->s_firstdatazone = first_data_zone;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"ISOFS: changing to secondary root\\n\");\n\t\t\tiput(inode);\n\t\t\tinode = isofs_iget(s, sbi->s_firstdatazone, 0);\n\t\t\tif (IS_ERR(inode))\n\t\t\t\tgoto out_no_root;\n\t\t}\n\t}\n\n\tif (opt.check == 'u') {\n\t\t/* Only Joliet is case insensitive by default */\n\t\tif (joliet_level)\n\t\t\topt.check = 'r';\n\t\telse\n\t\t\topt.check = 's';\n\t}\n\tsbi->s_joliet_level = joliet_level;\n\n\t/* Make sure the root inode is a directory */\n\tif (!S_ISDIR(inode->i_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"isofs_fill_super: root inode is not a directory. \"\n\t\t\t\"Corrupted media?\\n\");\n\t\tgoto out_iput;\n\t}\n\n\ttable = 0;\n\tif (joliet_level)\n\t\ttable += 2;\n\tif (opt.check == 'r')\n\t\ttable++;\n\n\ts->s_d_op = &isofs_dentry_ops[table];\n\n\t/* get the root dentry */\n\ts->s_root = d_make_root(inode);\n\tif (!(s->s_root)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_no_inode;\n\t}\n\n\tkfree(opt.iocharset);\n\n\treturn 0;\n\n\t/*\n\t * Display error messages and free resources.\n\t */\nout_iput:\n\tiput(inode);\n\tgoto out_no_inode;\nout_no_root:\n\terror = PTR_ERR(inode);\n\tif (error != -ENOMEM)\n\t\tprintk(KERN_WARNING \"%s: get root inode failed\\n\", __func__);\nout_no_inode:\n#ifdef CONFIG_JOLIET\n\tunload_nls(sbi->s_nls_iocharset);\n#endif\n\tgoto out_freesbi;\nout_no_read:\n\tprintk(KERN_WARNING \"%s: bread failed, dev=%s, iso_blknum=%d, block=%d\\n\",\n\t\t__func__, s->s_id, iso_blknum, block);\n\tgoto out_freebh;\nout_bad_zone_size:\n\tprintk(KERN_WARNING \"ISOFS: Bad logical zone size %ld\\n\",\n\t\tsbi->s_log_zone_size);\n\tgoto out_freebh;\nout_bad_size:\n\tprintk(KERN_WARNING \"ISOFS: Logical zone size(%d) < hardware blocksize(%u)\\n\",\n\t\torig_zonesize, opt.blocksize);\n\tgoto out_freebh;\nout_unknown_format:\n\tif (!silent)\n\t\tprintk(KERN_WARNING \"ISOFS: Unable to identify CD-ROM format.\\n\");\n\nout_freebh:\n\tbrelse(bh);\n\tbrelse(pri_bh);\nout_freesbi:\n\tkfree(opt.iocharset);\n\tkfree(sbi);\n\ts->s_fs_info = NULL;\n\treturn error;\n}\n\nstatic int isofs_statfs (struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tbuf->f_type = ISOFS_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (ISOFS_SB(sb)->s_nzones\n\t\t<< (ISOFS_SB(sb)->s_log_zone_size - sb->s_blocksize_bits));\n\tbuf->f_bfree = 0;\n\tbuf->f_bavail = 0;\n\tbuf->f_files = ISOFS_SB(sb)->s_ninodes;\n\tbuf->f_ffree = 0;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}\n\n/*\n * Get a set of blocks; filling in buffer_heads if already allocated\n * or getblk() if they are not.  Returns the number of blocks inserted\n * (-ve == error.)\n */\nint isofs_get_blocks(struct inode *inode, sector_t iblock,\n\t\t     struct buffer_head **bh, unsigned long nblocks)\n{\n\tunsigned long b_off = iblock;\n\tunsigned offset, sect_size;\n\tunsigned int firstext;\n\tunsigned long nextblk, nextoff;\n\tint section, rv, error;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\terror = -EIO;\n\trv = 0;\n\tif (iblock != b_off) {\n\t\tprintk(KERN_DEBUG \"%s: block number too large\\n\", __func__);\n\t\tgoto abort;\n\t}\n\n\n\toffset = 0;\n\tfirstext = ei->i_first_extent;\n\tsect_size = ei->i_section_size >> ISOFS_BUFFER_BITS(inode);\n\tnextblk = ei->i_next_section_block;\n\tnextoff = ei->i_next_section_offset;\n\tsection = 0;\n\n\twhile (nblocks) {\n\t\t/* If we are *way* beyond the end of the file, print a message.\n\t\t * Access beyond the end of the file up to the next page boundary\n\t\t * is normal, however because of the way the page cache works.\n\t\t * In this case, we just return 0 so that we can properly fill\n\t\t * the page with useless information without generating any\n\t\t * I/O errors.\n\t\t */\n\t\tif (b_off > ((inode->i_size + PAGE_CACHE_SIZE - 1) >> ISOFS_BUFFER_BITS(inode))) {\n\t\t\tprintk(KERN_DEBUG \"%s: block >= EOF (%lu, %llu)\\n\",\n\t\t\t\t__func__, b_off,\n\t\t\t\t(unsigned long long)inode->i_size);\n\t\t\tgoto abort;\n\t\t}\n\n\t\t/* On the last section, nextblk == 0, section size is likely to\n\t\t * exceed sect_size by a partial block, and access beyond the\n\t\t * end of the file will reach beyond the section size, too.\n\t\t */\n\t\twhile (nextblk && (b_off >= (offset + sect_size))) {\n\t\t\tstruct inode *ninode;\n\n\t\t\toffset += sect_size;\n\t\t\tninode = isofs_iget(inode->i_sb, nextblk, nextoff);\n\t\t\tif (IS_ERR(ninode)) {\n\t\t\t\terror = PTR_ERR(ninode);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t\tfirstext  = ISOFS_I(ninode)->i_first_extent;\n\t\t\tsect_size = ISOFS_I(ninode)->i_section_size >> ISOFS_BUFFER_BITS(ninode);\n\t\t\tnextblk   = ISOFS_I(ninode)->i_next_section_block;\n\t\t\tnextoff   = ISOFS_I(ninode)->i_next_section_offset;\n\t\t\tiput(ninode);\n\n\t\t\tif (++section > 100) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: More than 100 file sections ?!?\"\n\t\t\t\t\t\" aborting...\\n\", __func__);\n\t\t\t\tprintk(KERN_DEBUG \"%s: block=%lu firstext=%u sect_size=%u \"\n\t\t\t\t\t\"nextblk=%lu nextoff=%lu\\n\", __func__,\n\t\t\t\t\tb_off, firstext, (unsigned) sect_size,\n\t\t\t\t\tnextblk, nextoff);\n\t\t\t\tgoto abort;\n\t\t\t}\n\t\t}\n\n\t\tif (*bh) {\n\t\t\tmap_bh(*bh, inode->i_sb, firstext + b_off - offset);\n\t\t} else {\n\t\t\t*bh = sb_getblk(inode->i_sb, firstext+b_off-offset);\n\t\t\tif (!*bh)\n\t\t\t\tgoto abort;\n\t\t}\n\t\tbh++;\t/* Next buffer head */\n\t\tb_off++;\t/* Next buffer offset */\n\t\tnblocks--;\n\t\trv++;\n\t}\n\n\terror = 0;\nabort:\n\treturn rv != 0 ? rv : error;\n}\n\n/*\n * Used by the standard interfaces.\n */\nstatic int isofs_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\tif (create) {\n\t\tprintk(KERN_DEBUG \"%s: Kernel tries to allocate a block\\n\", __func__);\n\t\treturn -EROFS;\n\t}\n\n\tret = isofs_get_blocks(inode, iblock, &bh_result, 1);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int isofs_bmap(struct inode *inode, sector_t block)\n{\n\tstruct buffer_head dummy;\n\tint error;\n\n\tdummy.b_state = 0;\n\tdummy.b_blocknr = -1000;\n\terror = isofs_get_block(inode, block, &dummy, 0);\n\tif (!error)\n\t\treturn dummy.b_blocknr;\n\treturn 0;\n}\n\nstruct buffer_head *isofs_bread(struct inode *inode, sector_t block)\n{\n\tsector_t blknr = isofs_bmap(inode, block);\n\tif (!blknr)\n\t\treturn NULL;\n\treturn sb_bread(inode->i_sb, blknr);\n}\n\nstatic int isofs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, isofs_get_block);\n}\n\nstatic int isofs_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, isofs_get_block);\n}\n\nstatic sector_t _isofs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,isofs_get_block);\n}\n\nstatic const struct address_space_operations isofs_aops = {\n\t.readpage = isofs_readpage,\n\t.readpages = isofs_readpages,\n\t.bmap = _isofs_bmap\n};\n\nstatic int isofs_read_level3_size(struct inode *inode)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tint high_sierra = ISOFS_SB(inode->i_sb)->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tunsigned long block, offset, block_saved, offset_saved;\n\tint i = 0;\n\tint more_entries = 0;\n\tstruct iso_directory_record *tmpde = NULL;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\n\tinode->i_size = 0;\n\n\t/* The first 16 blocks are reserved as the System Area.  Thus,\n\t * no inodes can appear in block 0.  We use this to flag that\n\t * this is the last section. */\n\tei->i_next_section_block = 0;\n\tei->i_next_section_offset = 0;\n\n\tblock = ei->i_iget5_block;\n\toffset = ei->i_iget5_offset;\n\n\tdo {\n\t\tstruct iso_directory_record *de;\n\t\tunsigned int de_len;\n\n\t\tif (!bh) {\n\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\tif (!bh)\n\t\t\t\tgoto out_noread;\n\t\t}\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\t\tde_len = *(unsigned char *) de;\n\n\t\tif (de_len == 0) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\t++block;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = block;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tif (!tmpde) {\n\t\t\t\ttmpde = kmalloc(256, GFP_KERNEL);\n\t\t\t\tif (!tmpde)\n\t\t\t\t\tgoto out_nomem;\n\t\t\t}\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = sb_bread(inode->i_sb, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\tgoto out_noread;\n\t\t\t\tmemcpy((void *)tmpde+slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tinode->i_size += isonum_733(de->size);\n\t\tif (i == 1) {\n\t\t\tei->i_next_section_block = block_saved;\n\t\t\tei->i_next_section_offset = offset_saved;\n\t\t}\n\n\t\tmore_entries = de->flags[-high_sierra] & 0x80;\n\n\t\ti++;\n\t\tif (i > 100)\n\t\t\tgoto out_toomany;\n\t} while (more_entries);\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn 0;\n\nout_nomem:\n\tif (bh)\n\t\tbrelse(bh);\n\treturn -ENOMEM;\n\nout_noread:\n\tprintk(KERN_INFO \"ISOFS: unable to read i-node block %lu\\n\", block);\n\tkfree(tmpde);\n\treturn -EIO;\n\nout_toomany:\n\tprintk(KERN_INFO \"%s: More than 100 file sections ?!?, aborting...\\n\"\n\t\t\"isofs_read_level3_size: inode=%lu\\n\",\n\t\t__func__, inode->i_ino);\n\tgoto out;\n}\n\nstatic int isofs_read_inode(struct inode *inode, int relocated)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tunsigned long block;\n\tint high_sierra = sbi->s_high_sierra;\n\tstruct buffer_head *bh = NULL;\n\tstruct iso_directory_record *de;\n\tstruct iso_directory_record *tmpde = NULL;\n\tunsigned int de_len;\n\tunsigned long offset;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tint ret = -EIO;\n\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_badread;\n\n\toffset = ei->i_iget5_offset;\n\n\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\tde_len = *(unsigned char *) de;\n\n\tif (offset + de_len > bufsize) {\n\t\tint frag1 = bufsize - offset;\n\n\t\ttmpde = kmalloc(de_len, GFP_KERNEL);\n\t\tif (tmpde == NULL) {\n\t\t\tprintk(KERN_INFO \"%s: out of memory\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tmemcpy(tmpde, bh->b_data + offset, frag1);\n\t\tbrelse(bh);\n\t\tbh = sb_bread(inode->i_sb, ++block);\n\t\tif (!bh)\n\t\t\tgoto out_badread;\n\t\tmemcpy((char *)tmpde+frag1, bh->b_data, de_len - frag1);\n\t\tde = tmpde;\n\t}\n\n\tinode->i_ino = isofs_get_ino(ei->i_iget5_block,\n\t\t\t\t\tei->i_iget5_offset,\n\t\t\t\t\tISOFS_BUFFER_BITS(inode));\n\n\t/* Assume it is a normal-format file unless told otherwise */\n\tei->i_file_format = isofs_file_normal;\n\n\tif (de->flags[-high_sierra] & 2) {\n\t\tif (sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\t\telse\n\t\t\tinode->i_mode = S_IFDIR | S_IRUGO | S_IXUGO;\n\t\tset_nlink(inode, 1);\t/*\n\t\t\t\t\t * Set to 1.  We know there are 2, but\n\t\t\t\t\t * the find utility tries to optimize\n\t\t\t\t\t * if it is 2, and it screws up.  It is\n\t\t\t\t\t * easier to give 1 which tells find to\n\t\t\t\t\t * do it the hard way.\n\t\t\t\t\t */\n\t} else {\n\t\tif (sbi->s_fmode != ISOFS_INVALID_MODE) {\n\t\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Set default permissions: r-x for all.  The disc\n\t\t\t * could be shared with DOS machines so virtually\n\t\t\t * anything could be a valid executable.\n\t\t\t */\n\t\t\tinode->i_mode = S_IFREG | S_IRUGO | S_IXUGO;\n\t\t}\n\t\tset_nlink(inode, 1);\n\t}\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\tinode->i_blocks = 0;\n\n\tei->i_format_parm[0] = 0;\n\tei->i_format_parm[1] = 0;\n\tei->i_format_parm[2] = 0;\n\n\tei->i_section_size = isonum_733(de->size);\n\tif (de->flags[-high_sierra] & 0x80) {\n\t\tret = isofs_read_level3_size(inode);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = -EIO;\n\t} else {\n\t\tei->i_next_section_block = 0;\n\t\tei->i_next_section_offset = 0;\n\t\tinode->i_size = isonum_733(de->size);\n\t}\n\n\t/*\n\t * Some dipshit decided to store some other bit of information\n\t * in the high byte of the file length.  Truncate size in case\n\t * this CDROM was mounted with the cruft option.\n\t */\n\n\tif (sbi->s_cruft)\n\t\tinode->i_size &= 0x00ffffff;\n\n\tif (de->interleave[0]) {\n\t\tprintk(KERN_DEBUG \"ISOFS: Interleaved files not (yet) supported.\\n\");\n\t\tinode->i_size = 0;\n\t}\n\n\t/* I have no idea what file_unit_size is used for, so\n\t   we will flag it for now */\n\tif (de->file_unit_size[0] != 0) {\n\t\tprintk(KERN_DEBUG \"ISOFS: File unit size != 0 for ISO file (%ld).\\n\",\n\t\t\tinode->i_ino);\n\t}\n\n\t/* I have no idea what other flag bits are used for, so\n\t   we will flag it for now */\n#ifdef DEBUG\n\tif((de->flags[-high_sierra] & ~2)!= 0){\n\t\tprintk(KERN_DEBUG \"ISOFS: Unusual flag settings for ISO file \"\n\t\t\t\t\"(%ld %x).\\n\",\n\t\t\tinode->i_ino, de->flags[-high_sierra]);\n\t}\n#endif\n\n\tinode->i_mtime.tv_sec =\n\tinode->i_atime.tv_sec =\n\tinode->i_ctime.tv_sec = iso_date(de->date, high_sierra);\n\tinode->i_mtime.tv_nsec =\n\tinode->i_atime.tv_nsec =\n\tinode->i_ctime.tv_nsec = 0;\n\n\tei->i_first_extent = (isonum_733(de->extent) +\n\t\t\tisonum_711(de->ext_attr_length));\n\n\t/* Set the number of blocks for stat() - should be done before RR */\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tif (!high_sierra) {\n\t\tparse_rock_ridge_inode(de, inode, relocated);\n\t\t/* if we want uid/gid set, override the rock ridge setting */\n\t\tif (sbi->s_uid_set)\n\t\t\tinode->i_uid = sbi->s_uid;\n\t\tif (sbi->s_gid_set)\n\t\t\tinode->i_gid = sbi->s_gid;\n\t}\n\t/* Now set final access rights if overriding rock ridge setting */\n\tif (S_ISDIR(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_dmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFDIR | sbi->s_dmode;\n\tif (S_ISREG(inode->i_mode) && sbi->s_overriderockperm &&\n\t    sbi->s_fmode != ISOFS_INVALID_MODE)\n\t\tinode->i_mode = S_IFREG | sbi->s_fmode;\n\n\t/* Install the inode operations vector */\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tswitch (ei->i_file_format) {\n#ifdef CONFIG_ZISOFS\n\t\tcase isofs_file_compressed:\n\t\t\tinode->i_data.a_ops = &zisofs_aops;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tinode->i_data.a_ops = &isofs_aops;\n\t\t\tbreak;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &isofs_dir_inode_operations;\n\t\tinode->i_fop = &isofs_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &page_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &isofs_symlink_aops;\n\t} else\n\t\t/* XXX - parse_rock_ridge_inode() had already set i_rdev. */\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\n\tret = 0;\nout:\n\tkfree(tmpde);\n\tif (bh)\n\t\tbrelse(bh);\n\treturn ret;\n\nout_badread:\n\tprintk(KERN_WARNING \"ISOFS: unable to read i-node block\\n\");\nfail:\n\tgoto out;\n}\n\nstruct isofs_iget5_callback_data {\n\tunsigned long block;\n\tunsigned long offset;\n};\n\nstatic int isofs_iget5_test(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\treturn (i->i_iget5_block == d->block)\n\t\t&& (i->i_iget5_offset == d->offset);\n}\n\nstatic int isofs_iget5_set(struct inode *ino, void *data)\n{\n\tstruct iso_inode_info *i = ISOFS_I(ino);\n\tstruct isofs_iget5_callback_data *d =\n\t\t(struct isofs_iget5_callback_data*)data;\n\ti->i_iget5_block = d->block;\n\ti->i_iget5_offset = d->offset;\n\treturn 0;\n}\n\n/* Store, in the inode's containing structure, the block and block\n * offset that point to the underlying meta-data for the inode.  The\n * code below is otherwise similar to the iget() code in\n * include/linux/fs.h */\nstruct inode *__isofs_iget(struct super_block *sb,\n\t\t\t   unsigned long block,\n\t\t\t   unsigned long offset,\n\t\t\t   int relocated)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode, relocated);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}\n\nstatic struct dentry *isofs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\t/* We don't support read-write mounts */\n\tif (!(flags & MS_RDONLY))\n\t\treturn ERR_PTR(-EACCES);\n\treturn mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);\n}\n\nstatic struct file_system_type iso9660_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"iso9660\",\n\t.mount\t\t= isofs_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\nMODULE_ALIAS_FS(\"iso9660\");\nMODULE_ALIAS(\"iso9660\");\n\nstatic int __init init_iso9660_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out;\n#ifdef CONFIG_ZISOFS\n\terr = zisofs_init();\n\tif (err)\n\t\tgoto out1;\n#endif\n\terr = register_filesystem(&iso9660_fs_type);\n\tif (err)\n\t\tgoto out2;\n\treturn 0;\nout2:\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\nout1:\n#endif\n\tdestroy_inodecache();\nout:\n\treturn err;\n}\n\nstatic void __exit exit_iso9660_fs(void)\n{\n        unregister_filesystem(&iso9660_fs_type);\n#ifdef CONFIG_ZISOFS\n\tzisofs_cleanup();\n#endif\n\tdestroy_inodecache();\n}\n\nmodule_init(init_iso9660_fs)\nmodule_exit(exit_iso9660_fs)\nMODULE_LICENSE(\"GPL\");\n", "#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/exportfs.h>\n#include <linux/iso_fs.h>\n#include <asm/unaligned.h>\n\nenum isofs_file_format {\n\tisofs_file_normal = 0,\n\tisofs_file_sparse = 1,\n\tisofs_file_compressed = 2,\n};\n\t\n/*\n * iso fs inode data in memory\n */\nstruct iso_inode_info {\n\tunsigned long i_iget5_block;\n\tunsigned long i_iget5_offset;\n\tunsigned int i_first_extent;\n\tunsigned char i_file_format;\n\tunsigned char i_format_parm[3];\n\tunsigned long i_next_section_block;\n\tunsigned long i_next_section_offset;\n\toff_t i_section_size;\n\tstruct inode vfs_inode;\n};\n\n/*\n * iso9660 super-block data in memory\n */\nstruct isofs_sb_info {\n\tunsigned long s_ninodes;\n\tunsigned long s_nzones;\n\tunsigned long s_firstdatazone;\n\tunsigned long s_log_zone_size;\n\tunsigned long s_max_size;\n\t\n\tint           s_rock_offset; /* offset of SUSP fields within SU area */\n\tunsigned char s_joliet_level;\n\tunsigned char s_mapping;\n\tunsigned int  s_high_sierra:1;\n\tunsigned int  s_rock:2;\n\tunsigned int  s_utf8:1;\n\tunsigned int  s_cruft:1; /* Broken disks with high byte of length\n\t\t\t\t  * containing junk */\n\tunsigned int  s_nocompress:1;\n\tunsigned int  s_hide:1;\n\tunsigned int  s_showassoc:1;\n\tunsigned int  s_overriderockperm:1;\n\tunsigned int  s_uid_set:1;\n\tunsigned int  s_gid_set:1;\n\n\tumode_t s_fmode;\n\tumode_t s_dmode;\n\tkgid_t s_gid;\n\tkuid_t s_uid;\n\tstruct nls_table *s_nls_iocharset; /* Native language support table */\n};\n\n#define ISOFS_INVALID_MODE ((umode_t) -1)\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}\n\nstatic inline int isonum_711(char *p)\n{\n\treturn *(u8 *)p;\n}\nstatic inline int isonum_712(char *p)\n{\n\treturn *(s8 *)p;\n}\nstatic inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}\nstatic inline unsigned int isonum_722(char *p)\n{\n\treturn get_unaligned_be16(p);\n}\nstatic inline unsigned int isonum_723(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le16(p);\n}\nstatic inline unsigned int isonum_731(char *p)\n{\n\treturn get_unaligned_le32(p);\n}\nstatic inline unsigned int isonum_732(char *p)\n{\n\treturn get_unaligned_be32(p);\n}\nstatic inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}\nextern int iso_date(char *, int);\n\nstruct inode;\t\t/* To make gcc happy */\n\nextern int parse_rock_ridge_inode(struct iso_directory_record *, struct inode *, int relocated);\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\n\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nextern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int flags);\nextern struct buffer_head *isofs_bread(struct inode *, sector_t);\nextern int isofs_get_blocks(struct inode *, sector_t, struct buffer_head **, unsigned long);\n\nstruct inode *__isofs_iget(struct super_block *sb,\n\t\t\t   unsigned long block,\n\t\t\t   unsigned long offset,\n\t\t\t   int relocated);\n\nstatic inline struct inode *isofs_iget(struct super_block *sb,\n\t\t\t\t       unsigned long block,\n\t\t\t\t       unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 0);\n}\n\nstatic inline struct inode *isofs_iget_reloc(struct super_block *sb,\n\t\t\t\t\t     unsigned long block,\n\t\t\t\t\t     unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 1);\n}\n\n/* Because the inode number is no longer relevant to finding the\n * underlying meta-data for an inode, we are free to choose a more\n * convenient 32-bit number as the inode number.  The inode numbering\n * scheme was recommended by Sergey Vlasov and Eric Lammerts. */\nstatic inline unsigned long isofs_get_ino(unsigned long block,\n\t\t\t\t\t  unsigned long offset,\n\t\t\t\t\t  unsigned long bufbits)\n{\n\treturn (block << (bufbits - 5)) | (offset >> 5);\n}\n\n/* Every directory can have many redundant directory entries scattered\n * throughout the directory tree.  First there is the directory entry\n * with the name of the directory stored in the parent directory.\n * Then, there is the \".\" directory entry stored in the directory\n * itself.  Finally, there are possibly many \"..\" directory entries\n * stored in all the subdirectories.\n *\n * In order for the NFS get_parent() method to work and for the\n * general consistency of the dcache, we need to make sure the\n * \"i_iget5_block\" and \"i_iget5_offset\" all point to exactly one of\n * the many redundant entries for each directory.  We normalize the\n * block and offset by always making them point to the \".\"  directory.\n *\n * Notice that we do not use the entry for the directory with the name\n * that is located in the parent directory.  Even though choosing this\n * first directory is more natural, it is much easier to find the \".\"\n * entry in the NFS get_parent() method because it is implicitly\n * encoded in the \"extent + ext_attr_length\" fields of _all_ the\n * redundant entries for the directory.  Thus, it can always be\n * reached regardless of which directory entry you have in hand.\n *\n * This works because the \".\" entry is simply the first directory\n * record when you start reading the file that holds all the directory\n * records, and this file starts at \"extent + ext_attr_length\" blocks.\n * Because the \".\" entry is always the first entry listed in the\n * directories file, the normalized \"offset\" value is always 0.\n *\n * You should pass the directory entry in \"de\".  On return, \"block\"\n * and \"offset\" will hold normalized values.  Only directories are\n * affected making it safe to call even for non-directory file\n * types. */\nstatic inline void\nisofs_normalize_block_and_offset(struct iso_directory_record* de,\n\t\t\t\t unsigned long *block,\n\t\t\t\t unsigned long *offset)\n{\n\t/* Only directories are normalized. */\n\tif (de->flags[0] & 2) {\n\t\t*offset = 0;\n\t\t*block = (unsigned long)isonum_733(de->extent)\n\t\t\t+ (unsigned long)isonum_711(de->ext_attr_length);\n\t}\n}\n\nextern const struct inode_operations isofs_dir_inode_operations;\nextern const struct file_operations isofs_dir_operations;\nextern const struct address_space_operations isofs_symlink_aops;\nextern const struct export_operations isofs_export_ops;\n", "/*\n *  linux/fs/isofs/rock.c\n *\n *  (C) 1992, 1993  Eric Youngdale\n *\n *  Rock Ridge Extensions to iso9660\n */\n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\n#include \"isofs.h\"\n#include \"rock.h\"\n\n/*\n * These functions are designed to read the system areas of a directory record\n * and extract relevant information.  There are different functions provided\n * depending upon what information we need at the time.  One function fills\n * out an inode structure, a second one extracts a filename, a third one\n * returns a symbolic link name, and a fourth one returns the extent number\n * for the file.\n */\n\n#define SIG(A,B) ((A) | ((B) << 8))\t/* isonum_721() */\n\nstruct rock_state {\n\tvoid *buffer;\n\tunsigned char *chr;\n\tint len;\n\tint cont_size;\n\tint cont_extent;\n\tint cont_offset;\n\tstruct inode *inode;\n};\n\n/*\n * This is a way of ensuring that we have something in the system\n * use fields that is compatible with Rock Ridge.  Return zero on success.\n */\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}\n\n/*\n * Returns 0 if the caller should continue scanning, 1 if the scan must end\n * and -ve on error.\n */\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}\n\n/*\n * We think there's a record of type `sig' at rs->chr.  Parse the signature\n * and make sure that there's really room for a record of that type.\n */\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n/*\n * return length of name field; 0: not found, -1: to be ignored\n */\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\n#define RR_REGARD_XA 1\n#define RR_RELOC_DE 2\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}\n\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}\n\n/*\n * readpage() for symlinks: reads symlink contents into the page and either\n * makes it uptodate and returns 0 or returns error (-EIO)\n */\nstatic int rock_ridge_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = kmap(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t/*\n\t * If we go past the end of the buffer, there is some sort of error.\n\t */\n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* corrupted isofs */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t/* This tells is if there is a continuation record */\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t/* error exit from macro */\nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn -EIO;\n}\n\nconst struct address_space_operations isofs_symlink_aops = {\n\t.readpage = rock_ridge_symlink_readpage\n};\n"], "filenames": ["fs/isofs/inode.c", "fs/isofs/isofs.h", "fs/isofs/rock.c"], "buggy_code_start_loc": [64, 110, 290], "buggy_code_end_loc": [1511, 124, 651], "fixing_code_start_loc": [64, 110, 291], "fixing_code_end_loc": [1512, 139, 668], "type": "CWE-20", "message": "The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel through 3.16.1 allows local users to cause a denial of service (unkillable mount process) via a crafted iso9660 image with a self-referential CL entry.", "other": {"cve": {"id": "CVE-2014-5472", "sourceIdentifier": "cve@mitre.org", "published": "2014-09-01T01:55:28.593", "lastModified": "2017-09-08T01:29:06.823", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel through 3.16.1 allows local users to cause a denial of service (unkillable mount process) via a crafted iso9660 image with a self-referential CL entry."}, {"lang": "es", "value": "La funci\u00f3n parse_rock_ridge_inode_internal en fs/isofs/rock.c en el kernel de Linux hasta 3.16.1 permite a usuarios locales causar una denegaci\u00f3n de servicio (un proceso de montaje imparable) a trav\u00e9s de un imagen iso9660 manipulado con una entrada CL de auto referencia."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.16.1", "matchCriteriaId": "8452407A-5074-4385-B9A1-9E49042CCAEB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.16.0:*:*:*:*:*:*:*", "matchCriteriaId": "3CFFCDFC-AE4F-47EE-B1DA-05A6865D1745"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=410dd3cf4c9b36f27ed4542ee18b1af5e68645a4", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00006.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-10/msg00007.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "cve@mitre.org"}, {"url": "http://marc.info/?l=bugtraq&m=142722450701342&w=2", "source": "cve@mitre.org"}, {"url": "http://marc.info/?l=bugtraq&m=142722544401658&w=2", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-1318.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0102.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0695.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0782.html", "source": "cve@mitre.org"}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0803.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2014/08/27/1", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/69428", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2354-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2355-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2356-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2357-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2358-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2359-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1134099", "source": "cve@mitre.org"}, {"url": "https://code.google.com/p/google-security-research/issues/detail?id=88", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/95556", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/410dd3cf4c9b36f27ed4542ee18b1af5e68645a4"}}