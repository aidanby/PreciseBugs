{"buggy_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t_ \"crypto/sha256\" // for `crypto.SHA256`\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/go-openapi/runtime\"\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/tuf\"\n\n\tctypes \"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\thashedrekord \"github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1\"\n\trekord \"github.com/sigstore/rekor/pkg/types/rekord/v0.0.1\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\tsignatureoptions \"github.com/sigstore/sigstore/pkg/signature/options\"\n)\n\nfunc isb64(data []byte) bool {\n\t_, err := base64.StdEncoding.DecodeString(string(data))\n\treturn err == nil\n}\n\n// nolint\nfunc VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n\tcertOidcIssuer, certChain, sigRef, blobRef, certGithubWorkflowTrigger, certGithubWorkflowSha,\n\tcertGithubWorkflowName,\n\tcertGithubWorkflowRepository,\n\tcertGithubWorkflowRef string, enforceSCT bool) error {\n\tvar verifier signature.Verifier\n\tvar cert *x509.Certificate\n\n\tif !options.OneOf(ko.KeyRef, ko.Sk, certRef) && !options.EnableExperimental() && ko.BundlePath == \"\" {\n\t\treturn &options.PubKeyParseError{}\n\t}\n\n\tsig, b64sig, err := signatures(sigRef, ko.BundlePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblobBytes, err := payloadBytes(blobRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Keys are optional!\n\tswitch {\n\tcase ko.KeyRef != \"\":\n\t\tverifier, err = sigs.PublicKeyFromKeyRef(ctx, ko.KeyRef)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading public key: %w\", err)\n\t\t}\n\t\tpkcs11Key, ok := verifier.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase ko.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(ko.Slot)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"opening piv token: %w\", err)\n\t\t}\n\t\tdefer sk.Close()\n\t\tverifier, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading public key from token: %w\", err)\n\t\t}\n\tcase certRef != \"\":\n\t\tcert, err = loadCertFromFileOrURL(certRef)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tco := &cosign.CheckOpts{\n\t\t\tCertEmail:                    certEmail,\n\t\t\tCertOidcIssuer:               certOidcIssuer,\n\t\t\tCertGithubWorkflowTrigger:    certGithubWorkflowTrigger,\n\t\t\tCertGithubWorkflowSha:        certGithubWorkflowSha,\n\t\t\tCertGithubWorkflowName:       certGithubWorkflowName,\n\t\t\tCertGithubWorkflowRepository: certGithubWorkflowRepository,\n\t\t\tCertGithubWorkflowRef:        certGithubWorkflowRef,\n\t\t\tEnforceSCT:                   enforceSCT,\n\t\t}\n\t\tif certChain == \"\" {\n\t\t\t// If no certChain is passed, the Fulcio root certificate will be used\n\t\t\tco.RootCerts, err = fulcio.GetRoots()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n\t\t\t}\n\t\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n\t\t\t}\n\t\t\tverifier, err = cosign.ValidateAndUnpackCert(cert, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// Verify certificate with chain\n\t\t\tchain, err := loadCertChainFromFileOrURL(certChain)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tverifier, err = cosign.ValidateAndUnpackCertWithChain(cert, chain, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase ko.BundlePath != \"\":\n\t\tb, err := cosign.FetchLocalSignedPayloadFromPath(ko.BundlePath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif b.Cert == \"\" {\n\t\t\treturn fmt.Errorf(\"bundle does not contain cert for verification, please provide public key\")\n\t\t}\n\t\t// cert can either be a cert or public key\n\t\tcertBytes := []byte(b.Cert)\n\t\tif isb64(certBytes) {\n\t\t\tcertBytes, _ = base64.StdEncoding.DecodeString(b.Cert)\n\t\t}\n\t\tcert, err = loadCertFromPEM(certBytes)\n\t\tif err != nil {\n\t\t\t// check if cert is actually a public key\n\t\t\tverifier, err = sigs.LoadPublicKeyRaw(certBytes, crypto.SHA256)\n\t\t} else {\n\t\t\tverifier, err = signature.LoadVerifier(cert.PublicKey, crypto.SHA256)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase options.EnableExperimental():\n\t\trClient, err := rekor.NewClient(ko.RekorURL)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tuuids, err := cosign.FindTLogEntriesByPayload(ctx, rClient, blobBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(uuids) == 0 {\n\t\t\treturn errors.New(\"could not find a tlog entry for provided blob\")\n\t\t}\n\t\treturn verifySigByUUID(ctx, ko, rClient, certEmail, certOidcIssuer, sig, b64sig, uuids, blobBytes, enforceSCT)\n\t}\n\n\t// Use the DSSE verifier if the payload is a DSSE with the In-Toto format.\n\tif isIntotoDSSE(blobBytes) {\n\t\tverifier = dsse.WrapVerifier(verifier)\n\t}\n\n\t// verify the signature\n\tif err := verifier.VerifySignature(bytes.NewReader([]byte(sig)), bytes.NewReader(blobBytes)); err != nil {\n\t\treturn err\n\t}\n\n\t// verify the rekor entry\n\tif err := verifyRekorEntry(ctx, ko, nil, verifier, cert, b64sig, blobBytes); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintln(os.Stderr, \"Verified OK\")\n\treturn nil\n}\n\nfunc verifySigByUUID(ctx context.Context, ko options.KeyOpts, rClient *client.Rekor, certEmail, certOidcIssuer, sig, b64sig string,\n\tuuids []string, blobBytes []byte, enforceSCT bool) error {\n\tvar validSigExists bool\n\tfor _, u := range uuids {\n\t\ttlogEntry, err := cosign.GetTlogEntry(ctx, rClient, u)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tcerts, err := extractCerts(tlogEntry)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tco := &cosign.CheckOpts{\n\t\t\tCertEmail:      certEmail,\n\t\t\tCertOidcIssuer: certOidcIssuer,\n\t\t\tEnforceSCT:     enforceSCT,\n\t\t}\n\n\t\tco.RootCerts, err = fulcio.GetRoots()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n\t\t}\n\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n\t\t}\n\n\t\tcert := certs[0]\n\t\tverifier, err := cosign.ValidateAndUnpackCert(cert, co)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\t// Use the DSSE verifier if the payload is a DSSE with the In-Toto format.\n\t\tif isIntotoDSSE(blobBytes) {\n\t\t\tverifier = dsse.WrapVerifier(verifier)\n\t\t}\n\t\t// verify the signature\n\t\tif err := verifier.VerifySignature(bytes.NewReader([]byte(sig)), bytes.NewReader(blobBytes)); err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// verify the rekor entry\n\t\tif err := verifyRekorEntry(ctx, ko, tlogEntry, verifier, cert, b64sig, blobBytes); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tvalidSigExists = true\n\t}\n\tif !validSigExists {\n\t\tfmt.Fprintln(os.Stderr, `WARNING: No valid entries were found in rekor to verify this blob.\n\nTransparency log support for blobs is experimental, and occasionally an entry isn't found even if one exists.\n\nWe recommend requesting the certificate/signature from the original signer of this blob and manually verifying with cosign verify-blob --cert [cert] --signature [signature].`)\n\t\treturn fmt.Errorf(\"could not find a valid tlog entry for provided blob, found %d invalid entries\", len(uuids))\n\t}\n\tfmt.Fprintln(os.Stderr, \"Verified OK\")\n\treturn nil\n}\n\n// signatures returns the raw signature and the base64 encoded signature\nfunc signatures(sigRef string, bundlePath string) (string, string, error) {\n\tvar targetSig []byte\n\tvar err error\n\tswitch {\n\tcase sigRef != \"\":\n\t\ttargetSig, err = blob.LoadFileOrURL(sigRef)\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t// ignore if file does not exist, it can be a base64 encoded string as well\n\t\t\t\treturn \"\", \"\", err\n\t\t\t}\n\t\t\ttargetSig = []byte(sigRef)\n\t\t}\n\tcase bundlePath != \"\":\n\t\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\ttargetSig = []byte(b.Base64Signature)\n\tdefault:\n\t\treturn \"\", \"\", fmt.Errorf(\"missing flag '--signature'\")\n\t}\n\n\tvar sig, b64sig string\n\tif isb64(targetSig) {\n\t\tb64sig = string(targetSig)\n\t\tsigBytes, _ := base64.StdEncoding.DecodeString(b64sig)\n\t\tsig = string(sigBytes)\n\t} else {\n\t\tsig = string(targetSig)\n\t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n\t}\n\treturn sig, b64sig, nil\n}\n\nfunc payloadBytes(blobRef string) ([]byte, error) {\n\tvar blobBytes []byte\n\tvar err error\n\tif blobRef == \"-\" {\n\t\tblobBytes, err = io.ReadAll(os.Stdin)\n\t} else {\n\t\tblobBytes, err = blob.LoadFileOrURL(blobRef)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blobBytes, nil\n}\n\nfunc verifyRekorEntry(ctx context.Context, ko options.KeyOpts, e *models.LogEntryAnon, pubKey signature.Verifier, cert *x509.Certificate, b64sig string, blobBytes []byte) error {\n\t// TODO: This can be moved below offline bundle verification when SIGSTORE_TRUST_REKOR_API_PUBLIC_KEY\n\t// is removed.\n\trekorClient, err := rekor.NewClient(ko.RekorURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If we have a bundle with a rekor entry, let's first try to verify offline\n\tif ko.BundlePath != \"\" {\n\t\tif err := verifyRekorBundle(ctx, ko.BundlePath, cert, rekorClient); err == nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"tlog entry verified offline\\n\")\n\t\t\treturn nil\n\t\t}\n\t}\n\tif !options.EnableExperimental() {\n\t\treturn nil\n\t}\n\n\t// Only fetch from rekor tlog if we don't already have the entry.\n\tif e == nil {\n\t\tvar pubBytes []byte\n\t\tif pubKey != nil {\n\t\t\tpubBytes, err = sigs.PublicKeyPem(pubKey, signatureoptions.WithContext(ctx))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif cert != nil {\n\t\t\tpubBytes, err = cryptoutils.MarshalCertificateToPEM(cert)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\te, err = cosign.FindTlogEntry(ctx, rekorClient, b64sig, blobBytes, pubBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := cosign.VerifyTLogEntry(ctx, rekorClient, e); err != nil {\n\t\treturn nil\n\t}\n\n\tuuid, err := cosign.ComputeLeafHash(e)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(os.Stderr, \"tlog entry verified with uuid: %s index: %d\\n\", hex.EncodeToString(uuid), *e.LogIndex)\n\tif cert == nil {\n\t\treturn nil\n\t}\n\t// if we have a cert, we should check expiry\n\treturn cosign.CheckExpiry(cert, time.Unix(*e.IntegratedTime, 0))\n}\n\nfunc verifyRekorBundle(ctx context.Context, bundlePath string, cert *x509.Certificate, rekorClient *client.Rekor) error {\n\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif b.Bundle == nil {\n\t\treturn fmt.Errorf(\"rekor entry is not available\")\n\t}\n\tpublicKeys, err := cosign.GetRekorPubs(ctx, rekorClient)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"retrieving rekor public key: %w\", err)\n\t}\n\n\tpubKey, ok := publicKeys[b.Bundle.Payload.LogID]\n\tif !ok {\n\t\treturn errors.New(\"rekor log public key not found for payload\")\n\t}\n\terr = cosign.VerifySET(b.Bundle.Payload, b.Bundle.SignedEntryTimestamp, pubKey.PubKey)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif pubKey.Status != tuf.Active {\n\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n\t}\n\n\tif cert == nil {\n\t\treturn nil\n\t}\n\tit := time.Unix(b.Bundle.Payload.IntegratedTime, 0)\n\treturn cosign.CheckExpiry(cert, it)\n}\n\nfunc extractCerts(e *models.LogEntryAnon) ([]*x509.Certificate, error) {\n\tb, err := base64.StdEncoding.DecodeString(e.Body.(string))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(b), runtime.JSONConsumer())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\teimpl, err := types.NewEntry(pe)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar publicKeyB64 []byte\n\tswitch e := eimpl.(type) {\n\tcase *rekord.V001Entry:\n\t\tpublicKeyB64, err = e.RekordObj.Signature.PublicKey.Content.MarshalText()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase *hashedrekord.V001Entry:\n\t\tpublicKeyB64, err = e.HashedRekordObj.Signature.PublicKey.Content.MarshalText()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, errors.New(\"unexpected tlog entry type\")\n\t}\n\n\tpublicKey, err := base64.StdEncoding.DecodeString(string(publicKeyB64))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcerts, err := cryptoutils.UnmarshalCertificatesFromPEM(publicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(certs) == 0 {\n\t\treturn nil, errors.New(\"no certs found in pem tlog\")\n\t}\n\n\treturn certs, err\n}\n\n// isIntotoDSSE checks whether a payload is a Dead Simple Signing Envelope with the In-Toto format.\nfunc isIntotoDSSE(blobBytes []byte) bool {\n\tDSSEenvelope := ssldsse.Envelope{}\n\tif err := json.Unmarshal(blobBytes, &DSSEenvelope); err != nil {\n\t\treturn false\n\t}\n\tif DSSEenvelope.PayloadType != ctypes.IntotoPayloadType {\n\t\treturn false\n\t}\n\n\treturn true\n}\n", "// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n)\n\nfunc TestSignaturesRef(t *testing.T) {\n\tsig := \"a==\"\n\tb64sig := \"YT09\"\n\ttests := []struct {\n\t\tdescription string\n\t\tsigRef      string\n\t\tshouldErr   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"raw sig\",\n\t\t\tsigRef:      sig,\n\t\t},\n\t\t{\n\t\t\tdescription: \"encoded sig\",\n\t\t\tsigRef:      b64sig,\n\t\t}, {\n\t\t\tdescription: \"empty ref\",\n\t\t\tshouldErr:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tgotSig, gotb64Sig, err := signatures(test.sigRef, \"\")\n\t\t\tif test.shouldErr && err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.shouldErr {\n\t\t\t\tt.Fatal(\"should have received an error\")\n\t\t\t}\n\t\t\tif gotSig != sig {\n\t\t\t\tt.Fatalf(\"unexpected signature, expected: %s got: %s\", sig, gotSig)\n\t\t\t}\n\t\t\tif gotb64Sig != b64sig {\n\t\t\t\tt.Fatalf(\"unexpected encoded signature, expected: %s got: %s\", b64sig, gotb64Sig)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSignaturesBundle(t *testing.T) {\n\ttd := t.TempDir()\n\tfp := filepath.Join(td, \"file\")\n\n\tsig := \"a==\"\n\tb64sig := \"YT09\"\n\n\t// save as a LocalSignedPayload to the file\n\tlsp := cosign.LocalSignedPayload{\n\t\tBase64Signature: b64sig,\n\t}\n\tcontents, err := json.Marshal(lsp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.WriteFile(fp, contents, 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgotSig, gotb64Sig, err := signatures(\"\", fp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif gotSig != sig {\n\t\tt.Fatalf(\"unexpected signature, expected: %s got: %s\", sig, gotSig)\n\t}\n\tif gotb64Sig != b64sig {\n\t\tt.Fatalf(\"unexpected encoded signature, expected: %s got: %s\", b64sig, gotb64Sig)\n\t}\n}\n\nfunc TestIsIntotoDSSEWithEnvelopes(t *testing.T) {\n\ttts := []struct {\n\t\tenvelope     dsse.Envelope\n\t\tisIntotoDSSE bool\n\t}{\n\t\t{\n\t\t\tenvelope: dsse.Envelope{\n\t\t\t\tPayloadType: \"application/vnd.in-toto+json\",\n\t\t\t\tPayload:     base64.StdEncoding.EncodeToString([]byte(\"This is a test\")),\n\t\t\t\tSignatures:  []dsse.Signature{},\n\t\t\t},\n\t\t\tisIntotoDSSE: true,\n\t\t},\n\t}\n\tfor _, tt := range tts {\n\t\tenvlopeBytes, _ := json.Marshal(tt.envelope)\n\t\tgot := isIntotoDSSE(envlopeBytes)\n\t\tif got != tt.isIntotoDSSE {\n\t\t\tt.Fatalf(\"unexpected envelope content\")\n\t\t}\n\t}\n}\n\nfunc TestIsIntotoDSSEWithBytes(t *testing.T) {\n\ttts := []struct {\n\t\tenvelope     []byte\n\t\tisIntotoDSSE bool\n\t}{\n\t\t{\n\t\t\tenvelope:     []byte(\"This is no valid\"),\n\t\t\tisIntotoDSSE: false,\n\t\t},\n\t\t{\n\t\t\tenvelope:     []byte(\"MEUCIQDBmE1ZRFjUVic1hzukesJlmMFG1JqWWhcthnhawTeBNQIga3J9/WKsNlSZaySnl8V360bc2S8dIln2/qo186EfjHA=\"),\n\t\t\tisIntotoDSSE: false,\n\t\t},\n\t}\n\tfor _, tt := range tts {\n\t\tenvlopeBytes, _ := json.Marshal(tt.envelope)\n\t\tgot := isIntotoDSSE(envlopeBytes)\n\t\tif got != tt.isIntotoDSSE {\n\t\t\tt.Fatalf(\"unexpected envelope content\")\n\t\t}\n\t}\n}\n", "// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage mock\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\n\t\"github.com/go-openapi/runtime\"\n\t\"github.com/transparency-dev/merkle/rfc6962\"\n\n\t\"github.com/sigstore/rekor/pkg/generated/client/entries\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n)\n\nvar (\n\tlea = models.LogEntryAnon{\n\t\tAttestation:    &models.LogEntryAnonAttestation{},\n\t\tBody:           base64.StdEncoding.EncodeToString([]byte(\"asdf\")),\n\t\tIntegratedTime: new(int64),\n\t\tLogID:          new(string),\n\t\tLogIndex:       new(int64),\n\t\tVerification: &models.LogEntryAnonVerification{\n\t\t\tInclusionProof: &models.InclusionProof{\n\t\t\t\tRootHash: new(string),\n\t\t\t\tTreeSize: new(int64),\n\t\t\t\tLogIndex: new(int64),\n\t\t\t},\n\t\t},\n\t}\n\tdata = models.LogEntry{\n\t\tuuid(lea): lea,\n\t}\n)\n\n// uuid generates the UUID for the given LogEntry.\n// This is effectively a reimplementation of\n// pkg/cosign/tlog.go -> verifyUUID / ComputeLeafHash, but separated\n// to avoid a circular dependency.\n// TODO?: Perhaps we should refactor the tlog libraries into a separate\n// package?\nfunc uuid(e models.LogEntryAnon) string {\n\tentryBytes, err := base64.StdEncoding.DecodeString(e.Body.(string))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn hex.EncodeToString(rfc6962.DefaultHasher.HashLeaf(entryBytes))\n}\n\n// EntriesClient is a client that implements entries.ClientService for Rekor\n// To use:\n// var mClient client.Rekor\n// mClient.entries = &EntriesClient{}\ntype EntriesClient struct {\n\tEntries models.LogEntry\n}\n\nfunc (m *EntriesClient) CreateLogEntry(params *entries.CreateLogEntryParams, opts ...entries.ClientOption) (*entries.CreateLogEntryCreated, error) {\n\treturn &entries.CreateLogEntryCreated{\n\t\tETag:     \"\",\n\t\tLocation: \"\",\n\t\tPayload:  data,\n\t}, nil\n}\n\nfunc (m *EntriesClient) GetLogEntryByIndex(params *entries.GetLogEntryByIndexParams, opts ...entries.ClientOption) (*entries.GetLogEntryByIndexOK, error) {\n\treturn &entries.GetLogEntryByIndexOK{\n\t\tPayload: data,\n\t}, nil\n}\n\nfunc (m *EntriesClient) GetLogEntryByUUID(params *entries.GetLogEntryByUUIDParams, opts ...entries.ClientOption) (*entries.GetLogEntryByUUIDOK, error) {\n\treturn &entries.GetLogEntryByUUIDOK{\n\t\tPayload: data,\n\t}, nil\n}\n\nfunc (m *EntriesClient) SearchLogQuery(params *entries.SearchLogQueryParams, opts ...entries.ClientOption) (*entries.SearchLogQueryOK, error) {\n\treturn &entries.SearchLogQueryOK{\n\t\tPayload: []models.LogEntry{data},\n\t}, nil\n}\n\n// TODO: Implement mock\nfunc (m *EntriesClient) SetTransport(transport runtime.ClientTransport) {\n}\n", "// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage rekor\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/payload\"\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n)\n\nfunc mustGetNewSigner(t *testing.T) signature.Signer {\n\tt.Helper()\n\tpriv, err := cosign.GeneratePrivateKey()\n\tif err != nil {\n\t\tt.Fatalf(\"cosign.GeneratePrivateKey() failed: %v\", err)\n\t}\n\ts, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"signature.LoadECDSASignerVerifier(key, crypto.SHA256) failed: %v\", err)\n\t}\n\treturn s\n}\n\nfunc TestSigner(t *testing.T) {\n\t// Need real cert and chain\n\tpayloadSigner := payload.NewSigner(mustGetNewSigner(t))\n\n\t// Mock out Rekor client\n\tvar mClient client.Rekor\n\tmClient.Entries = &mock.EntriesClient{}\n\n\ttestSigner := NewSigner(payloadSigner, &mClient)\n\n\ttestPayload := \"test payload\"\n\n\tociSig, pub, err := testSigner.Sign(context.Background(), strings.NewReader(testPayload))\n\tif err != nil {\n\t\tt.Fatalf(\"Sign() returned error: %v\", err)\n\t}\n\n\t// Verify that the wrapped signer was called.\n\tverifier, err := signature.LoadVerifier(pub, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"signature.LoadVerifier(pub) returned error: %v\", err)\n\t}\n\tb64Sig, err := ociSig.Base64Signature()\n\tif err != nil {\n\t\tt.Fatalf(\"ociSig.Base64Signature() returned error: %v\", err)\n\t}\n\tsig, err := base64.StdEncoding.DecodeString(b64Sig)\n\tif err != nil {\n\t\tt.Fatalf(\"base64.StdEncoding.DecodeString(b64Sig) returned error: %v\", err)\n\t}\n\tgotPayload, err := ociSig.Payload()\n\tif err != nil {\n\t\tt.Fatalf(\"ociSig.Payload() returned error: %v\", err)\n\t}\n\tif string(gotPayload) != testPayload {\n\t\tt.Errorf(\"ociSig.Payload() returned %q, wanted %q\", string(gotPayload), testPayload)\n\t}\n\tif err = verifier.VerifySignature(bytes.NewReader(sig), bytes.NewReader(gotPayload)); err != nil {\n\t\tt.Errorf(\"VerifySignature() returned error: %v\", err)\n\t}\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio/fulcioverifier/ctl\"\n\tcbundle \"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/sigstore/pkg/tuf\"\n\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/cosign/pkg/oci/layout\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n\tsigPayload \"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\n// Identity specifies an issuer/subject to verify a signature against.\n// Both IssuerRegExp/SubjectRegExp support regexp while Issuer/Subject are for\n// strict matching.\ntype Identity struct {\n\tIssuer        string\n\tSubject       string\n\tIssuerRegExp  string\n\tSubjectRegExp string\n}\n\n// CheckOpts are the options for checking signatures.\ntype CheckOpts struct {\n\t// RegistryClientOpts are the options for interacting with the container registry.\n\tRegistryClientOpts []ociremote.Option\n\n\t// Annotations optionally specifies image signature annotations to verify.\n\tAnnotations map[string]interface{}\n\n\t// ClaimVerifier, if provided, verifies claims present in the oci.Signature.\n\tClaimVerifier func(sig oci.Signature, imageDigest v1.Hash, annotations map[string]interface{}) error\n\n\t// RekorClient, if set, is used to use to verify signatures and public keys.\n\tRekorClient *client.Rekor\n\n\t// SigVerifier is used to verify signatures.\n\tSigVerifier signature.Verifier\n\t// PKOpts are the options provided to `SigVerifier.PublicKey()`.\n\tPKOpts []signature.PublicKeyOption\n\n\t// RootCerts are the root CA certs used to verify a signature's chained certificate.\n\tRootCerts *x509.CertPool\n\t// IntermediateCerts are the optional intermediate CA certs used to verify a certificate chain.\n\tIntermediateCerts *x509.CertPool\n\t// CertEmail is the email expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertEmail string\n\t// CertOidcIssuer is the OIDC issuer expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertOidcIssuer string\n\n\t// CertGithubWorkflowTrigger is the GitHub Workflow Trigger name expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowTrigger string\n\t// CertGithubWorkflowSha is the GitHub Workflow SHA expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowSha string\n\t// CertGithubWorkflowName is the GitHub Workflow Name expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowName string\n\t// CertGithubWorkflowRepository is the GitHub Workflow Repository  expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowRepository string\n\t// CertGithubWorkflowRef is the GitHub Workflow Ref expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowRef string\n\n\t// EnforceSCT requires that a certificate contain an embedded SCT during verification. An SCT is proof of inclusion in a\n\t// certificate transparency log.\n\tEnforceSCT bool\n\n\t// SignatureRef is the reference to the signature file\n\tSignatureRef string\n\n\t// Identities is an array of Identity (Subject, Issuer) matchers that have\n\t// to be met for the signature to ve valid.\n\t// Supercedes CertEmail / CertOidcIssuer\n\tIdentities []Identity\n}\n\nfunc getSignedEntity(signedImgRef name.Reference, regClientOpts []ociremote.Option) (oci.SignedEntity, v1.Hash, error) {\n\tse, err := ociremote.SignedEntity(signedImgRef, regClientOpts...)\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\t// Both of the SignedEntity types implement Digest()\n\th, err := se.(interface{ Digest() (v1.Hash, error) }).Digest()\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\treturn se, h, nil\n}\n\nfunc verifyOCISignature(ctx context.Context, verifier signature.Verifier, sig oci.Signature) error {\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsignature, err := base64.StdEncoding.DecodeString(b64sig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(payload), options.WithContext(ctx))\n}\n\n// For unit testing\ntype payloader interface {\n\tPayload() ([]byte, error)\n}\n\nfunc verifyOCIAttestation(_ context.Context, verifier signature.Verifier, att payloader) error {\n\tpayload, err := att.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tenv := ssldsse.Envelope{}\n\tif err := json.Unmarshal(payload, &env); err != nil {\n\t\treturn err\n\t}\n\n\tif env.PayloadType != types.IntotoPayloadType {\n\t\treturn NewVerificationError(\"invalid payloadType %s on envelope. Expected %s\", env.PayloadType, types.IntotoPayloadType)\n\t}\n\tdssev, err := ssldsse.NewEnvelopeVerifier(&dsse.VerifierAdapter{SignatureVerifier: verifier})\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = dssev.Verify(&env)\n\treturn err\n}\n\n// ValidateAndUnpackCert creates a Verifier from a certificate. Veries that the certificate\n// chains up to a trusted root. Optionally verifies the subject and issuer of the certificate.\nfunc ValidateAndUnpackCert(cert *x509.Certificate, co *CheckOpts) (signature.Verifier, error) {\n\tverifier, err := signature.LoadVerifier(cert.PublicKey, crypto.SHA256)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid certificate found on signature: %w\", err)\n\t}\n\n\t// Now verify the cert, then the signature.\n\tchains, err := TrustedCert(cert, co.RootCerts, co.IntermediateCerts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = CheckCertificatePolicy(cert, co)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontains, err := ctl.ContainsSCT(cert.Raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif co.EnforceSCT && !contains {\n\t\treturn nil, &VerificationError{\"certificate does not include required embedded SCT\"}\n\t}\n\tif contains {\n\t\t// handle if chains has more than one chain - grab first and print message\n\t\tif len(chains) > 1 {\n\t\t\tfmt.Fprintf(os.Stderr, \"**Info** Multiple valid certificate chains found. Selecting the first to verify the SCT.\\n\")\n\t\t}\n\t\tif err := ctl.VerifyEmbeddedSCT(context.Background(), chains[0]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn verifier, nil\n}\n\n// CheckCertificatePolicy checks that the certificate subject and issuer match\n// the expected values.\nfunc CheckCertificatePolicy(cert *x509.Certificate, co *CheckOpts) error {\n\tce := CertExtensions{Cert: cert}\n\tif co.CertEmail != \"\" {\n\t\temailVerified := false\n\t\tfor _, em := range cert.EmailAddresses {\n\t\t\tif co.CertEmail == em {\n\t\t\t\temailVerified = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !emailVerified {\n\t\t\treturn &VerificationError{\"expected email not found in certificate\"}\n\t\t}\n\t}\n\n\tif err := validateCertExtensions(ce, co); err != nil {\n\t\treturn err\n\t}\n\tissuer := ce.GetIssuer()\n\t// If there are identities given, go through them and if one of them\n\t// matches, call that good, otherwise, return an error.\n\tif len(co.Identities) > 0 {\n\t\tfor _, identity := range co.Identities {\n\t\t\tissuerMatches := false\n\t\t\tswitch {\n\t\t\t// Check the issuer first\n\t\t\tcase identity.IssuerRegExp != \"\":\n\t\t\t\tif regex, err := regexp.Compile(identity.IssuerRegExp); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"malformed issuer in identity: %s : %w\", identity.IssuerRegExp, err)\n\t\t\t\t} else if regex.MatchString(issuer) {\n\t\t\t\t\tissuerMatches = true\n\t\t\t\t}\n\t\t\tcase identity.Issuer != \"\":\n\t\t\t\tif identity.Issuer == issuer {\n\t\t\t\t\tissuerMatches = true\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// No issuer constraint on this identity, so checks out\n\t\t\t\tissuerMatches = true\n\t\t\t}\n\n\t\t\t// Then the subject\n\t\t\tsubjectMatches := false\n\t\t\tswitch {\n\t\t\tcase identity.SubjectRegExp != \"\":\n\t\t\t\tregex, err := regexp.Compile(identity.SubjectRegExp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"malformed subject in identity: %s : %w\", identity.SubjectRegExp, err)\n\t\t\t\t}\n\t\t\t\tfor _, san := range getSubjectAlternateNames(cert) {\n\t\t\t\t\tif regex.MatchString(san) {\n\t\t\t\t\t\tsubjectMatches = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase identity.Subject != \"\":\n\t\t\t\tfor _, san := range getSubjectAlternateNames(cert) {\n\t\t\t\t\tif san == identity.Subject {\n\t\t\t\t\t\tsubjectMatches = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// No subject constraint on this identity, so checks out\n\t\t\t\tsubjectMatches = true\n\t\t\t}\n\t\t\tif subjectMatches && issuerMatches {\n\t\t\t\t// If both issuer / subject match, return verifier\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn &VerificationError{\"none of the expected identities matched what was in the certificate\"}\n\t}\n\treturn nil\n}\n\nfunc validateCertExtensions(ce CertExtensions, co *CheckOpts) error {\n\tif co.CertOidcIssuer != \"\" {\n\t\tif ce.GetIssuer() != co.CertOidcIssuer {\n\t\t\treturn &VerificationError{\"expected oidc issuer not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowTrigger != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowTrigger() != co.CertGithubWorkflowTrigger {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Trigger not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowSha != \"\" {\n\t\tif ce.GetExtensionGithubWorkflowSha() != co.CertGithubWorkflowSha {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow SHA not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowName != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowName() != co.CertGithubWorkflowName {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Name not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowRepository != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowRepository() != co.CertGithubWorkflowRepository {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Repository not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowRef != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowRef() != co.CertGithubWorkflowRef {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Ref not found in certificate\"}\n\t\t}\n\t}\n\treturn nil\n}\n\n// getSubjectAlternateNames returns all of the following for a Certificate.\n// DNSNames\n// EmailAddresses\n// IPAddresses\n// URIs\nfunc getSubjectAlternateNames(cert *x509.Certificate) []string {\n\tsans := []string{}\n\tsans = append(sans, cert.DNSNames...)\n\tsans = append(sans, cert.EmailAddresses...)\n\tfor _, ip := range cert.IPAddresses {\n\t\tsans = append(sans, ip.String())\n\t}\n\tfor _, uri := range cert.URIs {\n\t\tsans = append(sans, uri.String())\n\t}\n\treturn sans\n}\n\n// ValidateAndUnpackCertWithChain creates a Verifier from a certificate. Verifies that the certificate\n// chains up to the provided root. Chain should start with the parent of the certificate and end with the root.\n// Optionally verifies the subject and issuer of the certificate.\nfunc ValidateAndUnpackCertWithChain(cert *x509.Certificate, chain []*x509.Certificate, co *CheckOpts) (signature.Verifier, error) {\n\tif len(chain) == 0 {\n\t\treturn nil, errors.New(\"no chain provided to validate certificate\")\n\t}\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(chain[len(chain)-1])\n\tco.RootCerts = rootPool\n\n\tsubPool := x509.NewCertPool()\n\tfor _, c := range chain[:len(chain)-1] {\n\t\tsubPool.AddCert(c)\n\t}\n\tco.IntermediateCerts = subPool\n\n\treturn ValidateAndUnpackCert(cert, co)\n}\n\nfunc tlogValidatePublicKey(ctx context.Context, rekorClient *client.Rekor, pub crypto.PublicKey, sig oci.Signature) error {\n\tpemBytes, err := cryptoutils.MarshalPublicKeyToPEM(pub)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = tlogValidateEntry(ctx, rekorClient, sig, pemBytes)\n\treturn err\n}\n\nfunc tlogValidateCertificate(ctx context.Context, rekorClient *client.Rekor, sig oci.Signature) error {\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpemBytes, err := cryptoutils.MarshalCertificateToPEM(cert)\n\tif err != nil {\n\t\treturn err\n\t}\n\te, err := tlogValidateEntry(ctx, rekorClient, sig, pemBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// if we have a cert, we should check expiry\n\treturn CheckExpiry(cert, time.Unix(*e.IntegratedTime, 0))\n}\n\nfunc tlogValidateEntry(ctx context.Context, client *client.Rekor, sig oci.Signature, pem []byte) (*models.LogEntryAnon, error) {\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\te, err := FindTlogEntry(ctx, client, b64sig, payload, pem)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn e, VerifyTLogEntry(ctx, client, e)\n}\n\ntype fakeOCISignatures struct {\n\toci.Signatures\n\tsignatures []oci.Signature\n}\n\nfunc (fos *fakeOCISignatures) Get() ([]oci.Signature, error) {\n\treturn fos.signatures, nil\n}\n\n// VerifyImageSignatures does all the main cosign checks in a loop, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyImageSignatures(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar sigs oci.Signatures\n\tsigRef := co.SignatureRef\n\tif sigRef == \"\" {\n\t\tsigs, err = se.Signatures()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t} else {\n\t\tsigs, err = loadSignatureFromFile(sigRef, signedImgRef, co)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\n// VerifyLocalImageSignatures verifies signatures from a saved, local image, without any network calls, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageSignatures(ctx context.Context, path string, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tsigs, err := se.Signatures()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\nfunc verifySignatures(ctx context.Context, sigs oci.Signatures, h v1.Hash, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := sigs.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\n\tfor _, sig := range sl {\n\t\tverified, err := VerifyImageSignature(ctx, sig, h, co)\n\t\tbundleVerified = bundleVerified || verified\n\t\tif err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedSignatures = append(checkedSignatures, sig)\n\t}\n\tif len(checkedSignatures) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"%w:\\n%s\", ErrNoMatchingSignatures, strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedSignatures, bundleVerified, nil\n}\n\n// VerifyImageSignature verifies a signature\nfunc VerifyImageSignature(ctx context.Context, sig oci.Signature, h v1.Hash, co *CheckOpts) (bundleVerified bool, err error) {\n\tverifier := co.SigVerifier\n\tif verifier == nil {\n\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\tcert, err := sig.Cert()\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t\tif cert == nil {\n\t\t\treturn bundleVerified, &VerificationError{\"no certificate found on signature\"}\n\t\t}\n\t\t// Create a certificate pool for intermediate CA certificates, excluding the root\n\t\tchain, err := sig.Chain()\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t\t// If the chain annotation is not present or there is only a root\n\t\tif chain == nil || len(chain) <= 1 {\n\t\t\tco.IntermediateCerts = nil\n\t\t} else if co.IntermediateCerts == nil {\n\t\t\t// If the intermediate certs have not been loaded in by TUF\n\t\t\tpool := x509.NewCertPool()\n\t\t\tfor _, cert := range chain[:len(chain)-1] {\n\t\t\t\tpool.AddCert(cert)\n\t\t\t}\n\t\t\tco.IntermediateCerts = pool\n\t\t}\n\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tif err := verifyOCISignature(ctx, verifier, sig); err != nil {\n\t\treturn bundleVerified, err\n\t}\n\n\t// We can't check annotations without claims, both require unmarshalling the payload.\n\tif co.ClaimVerifier != nil {\n\t\tif err := co.ClaimVerifier(sig, h, co.Annotations); err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tbundleVerified, err = VerifyBundle(ctx, sig, co.RekorClient)\n\tif err != nil && co.RekorClient == nil {\n\t\treturn false, fmt.Errorf(\"unable to verify bundle: %w\", err)\n\t}\n\n\tif !bundleVerified && co.RekorClient != nil {\n\t\tif co.SigVerifier != nil {\n\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn bundleVerified, err\n\t\t\t}\n\t\t\treturn bundleVerified, tlogValidatePublicKey(ctx, co.RekorClient, pub, sig)\n\t\t}\n\n\t\treturn bundleVerified, tlogValidateCertificate(ctx, co.RekorClient, sig)\n\t}\n\n\treturn bundleVerified, nil\n}\n\nfunc loadSignatureFromFile(sigRef string, signedImgRef name.Reference, co *CheckOpts) (oci.Signatures, error) {\n\tvar b64sig string\n\ttargetSig, err := blob.LoadFileOrURL(sigRef)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\ttargetSig = []byte(sigRef)\n\t}\n\n\t_, err = base64.StdEncoding.DecodeString(string(targetSig))\n\n\tif err == nil {\n\t\tb64sig = string(targetSig)\n\t} else {\n\t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n\t}\n\n\tdigest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpayload, err := (&sigPayload.Cosign{Image: digest}).MarshalJSON()\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsig, err := static.NewSignature(payload, b64sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fakeOCISignatures{\n\t\tsignatures: []oci.Signature{sig},\n\t}, nil\n}\n\n// VerifyAttestations does all the main cosign checks in a loop, returning the verified attestations.\n// If there were no valid attestations, we return an error.\nfunc VerifyImageAttestations(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\n// VerifyLocalImageAttestations verifies attestations from a saved, local image, without any network calls,\n// returning the verified attestations.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageAttestations(ctx context.Context, path string, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\nfunc verifyImageAttestations(ctx context.Context, atts oci.Signatures, h v1.Hash, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := atts.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\tfor _, att := range sl {\n\t\tif err := func(att oci.Signature) error {\n\t\t\tverifier := co.SigVerifier\n\t\t\tif verifier == nil {\n\t\t\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\t\t\tcert, err := att.Cert()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif cert == nil {\n\t\t\t\t\treturn &VerificationError{\"no certificate found on attestation\"}\n\t\t\t\t}\n\t\t\t\t// Create a certificate pool for intermediate CA certificates, excluding the root\n\t\t\t\tchain, err := att.Chain()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t// If the chain annotation is not present or there is only a root\n\t\t\t\tif chain == nil || len(chain) <= 1 {\n\t\t\t\t\tco.IntermediateCerts = nil\n\t\t\t\t} else if co.IntermediateCerts == nil {\n\t\t\t\t\t// If the intermediate certs have not been loaded in by TUF\n\t\t\t\t\tpool := x509.NewCertPool()\n\t\t\t\t\tfor _, cert := range chain[:len(chain)-1] {\n\t\t\t\t\t\tpool.AddCert(cert)\n\t\t\t\t\t}\n\t\t\t\t\tco.IntermediateCerts = pool\n\t\t\t\t}\n\t\t\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := verifyOCIAttestation(ctx, verifier, att); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// We can't check annotations without claims, both require unmarshalling the payload.\n\t\t\tif co.ClaimVerifier != nil {\n\t\t\t\tif err := co.ClaimVerifier(att, h, co.Annotations); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverified, err := VerifyBundle(ctx, att, co.RekorClient)\n\t\t\tif err != nil && co.RekorClient == nil {\n\t\t\t\treturn fmt.Errorf(\"unable to verify bundle: %w\", err)\n\t\t\t}\n\t\t\tbundleVerified = bundleVerified || verified\n\n\t\t\tif !verified && co.RekorClient != nil {\n\t\t\t\tif co.SigVerifier != nil {\n\t\t\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn tlogValidatePublicKey(ctx, co.RekorClient, pub, att)\n\t\t\t\t}\n\n\t\t\t\treturn tlogValidateCertificate(ctx, co.RekorClient, att)\n\t\t\t}\n\t\t\treturn nil\n\t\t}(att); err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedAttestations = append(checkedAttestations, att)\n\t}\n\tif len(checkedAttestations) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"%w:\\n%s\", ErrNoMatchingAttestations, strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedAttestations, bundleVerified, nil\n}\n\n// CheckExpiry confirms the time provided is within the valid period of the cert\nfunc CheckExpiry(cert *x509.Certificate, it time.Time) error {\n\tft := func(t time.Time) string {\n\t\treturn t.Format(time.RFC3339)\n\t}\n\tif cert.NotAfter.Before(it) {\n\t\treturn NewVerificationError(\"certificate expired before signatures were entered in log: %s is before %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\tif cert.NotBefore.After(it) {\n\t\treturn NewVerificationError(\"certificate was issued after signatures were entered in log: %s is after %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\treturn nil\n}\n\nfunc VerifyBundle(ctx context.Context, sig oci.Signature, rekorClient *client.Rekor) (bool, error) {\n\tbundle, err := sig.Bundle()\n\tif err != nil {\n\t\treturn false, err\n\t} else if bundle == nil {\n\t\treturn false, nil\n\t}\n\n\tif err := compareSigs(bundle.Payload.Body.(string), sig); err != nil {\n\t\treturn false, err\n\t}\n\n\tpublicKeys, err := GetRekorPubs(ctx, rekorClient)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"retrieving rekor public key: %w\", err)\n\t}\n\n\tpubKey, ok := publicKeys[bundle.Payload.LogID]\n\tif !ok {\n\t\treturn false, &VerificationError{\"rekor log public key not found for payload\"}\n\t}\n\terr = VerifySET(bundle.Payload, bundle.SignedEntryTimestamp, pubKey.PubKey)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif pubKey.Status != tuf.Active {\n\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n\t}\n\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif cert != nil {\n\t\t// Verify the cert against the integrated time.\n\t\t// Note that if the caller requires the certificate to be present, it has to ensure that itself.\n\t\tif err := CheckExpiry(cert, time.Unix(bundle.Payload.IntegratedTime, 0)); err != nil {\n\t\t\treturn false, fmt.Errorf(\"checking expiry on cert: %w\", err)\n\t\t}\n\t}\n\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"reading payload: %w\", err)\n\t}\n\tsignature, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"reading base64signature: %w\", err)\n\t}\n\n\talg, bundlehash, err := bundleHash(bundle.Payload.Body.(string), signature)\n\th := sha256.Sum256(payload)\n\tpayloadHash := hex.EncodeToString(h[:])\n\n\tif alg != \"sha256\" || bundlehash != payloadHash {\n\t\treturn false, fmt.Errorf(\"matching bundle to payload: %w\", err)\n\t}\n\treturn true, nil\n}\n\n// compare bundle signature to the signature we are verifying\nfunc compareSigs(bundleBody string, sig oci.Signature) error {\n\t// TODO(nsmith5): modify function signature to make it more clear _why_\n\t// we've returned nil (there are several reasons possible here).\n\tactualSig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"base64 signature: %w\", err)\n\t}\n\tif actualSig == \"\" {\n\t\t// NB: empty sig means this is an attestation\n\t\treturn nil\n\t}\n\tbundleSignature, err := bundleSig(bundleBody)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to extract signature from bundle: %w\", err)\n\t}\n\tif bundleSignature == \"\" {\n\t\treturn nil\n\t}\n\tif bundleSignature != actualSig {\n\t\treturn &VerificationError{\"signature in bundle does not match signature being verified\"}\n\t}\n\treturn nil\n}\n\nfunc bundleHash(bundleBody, signature string) (string, string, error) {\n\tvar toto models.Intoto\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar intotoObj models.IntotoV001Schema\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\t// The fact that there's no signature (or empty rather), implies\n\t// that this is an Attestation that we're verifying.\n\tif len(signature) == 0 {\n\t\terr = json.Unmarshal(bodyDecoded, &toto)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tspecMarshal, err := json.Marshal(toto.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &intotoObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\treturn *intotoObj.Content.Hash.Algorithm, *intotoObj.Content.Hash.Value, nil\n\t}\n\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &rekordObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\treturn *rekordObj.Data.Hash.Algorithm, *rekordObj.Data.Hash.Value, nil\n\t}\n\n\t// Try hashedRekordObj\n\terr = json.Unmarshal(bodyDecoded, &hrekord)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\terr = json.Unmarshal(specMarshal, &hrekordObj)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn *hrekordObj.Data.Hash.Algorithm, *hrekordObj.Data.Hash.Value, nil\n}\n\n// bundleSig extracts the signature from the rekor bundle body\nfunc bundleSig(bundleBody string) (string, error) {\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"decoding bundleBody: %w\", err)\n\t}\n\n\t// Try Rekord\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif err := json.Unmarshal(specMarshal, &rekordObj); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn rekordObj.Signature.Content.String(), nil\n\t}\n\n\t// Try hashedRekordObj\n\tif err := json.Unmarshal(bodyDecoded, &hrekord); err != nil {\n\t\treturn \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := json.Unmarshal(specMarshal, &hrekordObj); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hrekordObj.Signature.Content.String(), nil\n}\n\nfunc VerifySET(bundlePayload cbundle.RekorPayload, signature []byte, pub *ecdsa.PublicKey) error {\n\tcontents, err := json.Marshal(bundlePayload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"marshaling: %w\", err)\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(contents)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"canonicalizing: %w\", err)\n\t}\n\n\t// verify the SET against the public key\n\thash := sha256.Sum256(canonicalized)\n\tif !ecdsa.VerifyASN1(pub, hash[:], signature) {\n\t\treturn &VerificationError{\"unable to verify\"}\n\t}\n\treturn nil\n}\n\nfunc TrustedCert(cert *x509.Certificate, roots *x509.CertPool, intermediates *x509.CertPool) ([][]*x509.Certificate, error) {\n\tchains, err := cert.Verify(x509.VerifyOptions{\n\t\t// THIS IS IMPORTANT: WE DO NOT CHECK TIMES HERE\n\t\t// THE CERTIFICATE IS TREATED AS TRUSTED FOREVER\n\t\t// WE CHECK THAT THE SIGNATURES WERE CREATED DURING THIS WINDOW\n\t\tCurrentTime:   cert.NotBefore,\n\t\tRoots:         roots,\n\t\tIntermediates: intermediates,\n\t\tKeyUsages: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageCodeSigning,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn chains, nil\n}\n\nfunc correctAnnotations(wanted, have map[string]interface{}) bool {\n\tfor k, v := range wanted {\n\t\tif have[k] != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/google/certificate-transparency-go/testdata\"\n\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/cosign/test\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\trtypes \"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype mockVerifier struct {\n\tshouldErr bool\n}\n\nfunc (m *mockVerifier) PublicKey(opts ...signature.PublicKeyOption) (crypto.PublicKey, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockVerifier) VerifySignature(signature, message io.Reader, opts ...signature.VerifyOption) error {\n\tif m.shouldErr {\n\t\treturn errors.New(\"failure\")\n\t}\n\treturn nil\n}\n\nvar _ signature.Verifier = (*mockVerifier)(nil)\n\ntype mockAttestation struct {\n\tpayload interface{}\n}\n\nvar _ payloader = (*mockAttestation)(nil)\n\nfunc (m *mockAttestation) Annotations() (map[string]string, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockAttestation) Payload() ([]byte, error) {\n\treturn json.Marshal(m.payload)\n}\n\nfunc appendSlices(slices [][]byte) []byte {\n\tvar tmp []byte\n\tfor _, s := range slices {\n\t\ttmp = append(tmp, s...)\n\t}\n\treturn tmp\n}\n\nfunc Test_verifyOCIAttestation(t *testing.T) {\n\tstmt, err := json.Marshal(in_toto.ProvenanceStatement{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvalid := map[string]interface{}{\n\t\t\"payloadType\": types.IntotoPayloadType,\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\t// Should Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: valid}); err != nil {\n\t\tt.Errorf(\"verifyOCIAttestation() error = %v\", err)\n\t}\n\n\tinvalid := map[string]interface{}{\n\t\t\"payloadType\": \"not valid type\",\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\n\t// Should Not Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: invalid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{shouldErr: true}, &mockAttestation{payload: valid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n}\n\nfunc TestVerifyImageSignature(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload,\n\t\tbase64.StdEncoding.EncodeToString(signature),\n\t\tstatic.WithCertChain(pemLeaf, appendSlices([][]byte{pemSub, pemRoot})))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error while verifying signature, expected no error, got %v\", err)\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureMultipleSubs(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert1, subKey1, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tsubCert2, subKey2, _ := test.GenerateSubordinateCa(subCert1, subKey1)\n\tsubCert3, subKey3, _ := test.GenerateSubordinateCa(subCert2, subKey2)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert3, subKey3)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub1 := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert1.Raw})\n\tpemSub2 := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert2.Raw})\n\tpemSub3 := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert3.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload,\n\t\tbase64.StdEncoding.EncodeToString(signature), static.WithCertChain(pemLeaf, appendSlices([][]byte{pemSub3, pemSub2, pemSub1, pemRoot})))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error while verifying signature, expected no error, got %v\", err)\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc signEntry(ctx context.Context, t *testing.T, signer signature.Signer, entry bundle.RekorPayload) []byte {\n\tpayload, err := json.Marshal(entry)\n\tif err != nil {\n\t\tt.Fatalf(\"marshalling error: %v\", err)\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(payload)\n\tif err != nil {\n\t\tt.Fatalf(\"canonicalizing error: %v\", err)\n\t}\n\tsignature, err := signer.SignMessage(bytes.NewReader(canonicalized), options.WithContext(ctx))\n\tif err != nil {\n\t\tt.Fatalf(\"signing error: %v\", err)\n\t}\n\treturn signature\n}\n\nfunc CreateTestBundle(ctx context.Context, t *testing.T, rekor signature.Signer, leaf []byte) *bundle.RekorBundle {\n\t// generate log ID according to rekor public key\n\tpk, _ := rekor.PublicKey(nil)\n\tkeyID, _ := getLogID(pk)\n\tpyld := bundle.RekorPayload{\n\t\tBody:           base64.StdEncoding.EncodeToString(leaf),\n\t\tIntegratedTime: time.Now().Unix(),\n\t\tLogIndex:       693591,\n\t\tLogID:          keyID,\n\t}\n\t// Sign with root.\n\tsignature := signEntry(ctx, t, rekor, pyld)\n\tb := &bundle.RekorBundle{\n\t\tSignedEntryTimestamp: strfmt.Base64(signature),\n\t\tPayload:              pyld,\n\t}\n\treturn b\n}\n\nfunc TestVerifyImageSignatureWithNoChain(t *testing.T) {\n\tctx := context.Background()\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsv, _, err := signature.NewECDSASignerVerifier(elliptic.P256(), rand.Reader, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"creating signer: %v\", err)\n\t}\n\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\t// Create a fake bundle\n\tpe, _ := proposedEntry(base64.StdEncoding.EncodeToString(signature), payload, pemLeaf)\n\tentry, _ := rtypes.NewEntry(pe[0])\n\tleaf, _ := entry.Canonicalize(ctx)\n\trekorBundle := CreateTestBundle(ctx, t, sv, leaf)\n\n\topts := []static.Option{static.WithCertChain(pemLeaf, []byte{}), static.WithBundle(rekorBundle)}\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(signature), opts...)\n\n\t// TODO(asraa): Re-enable passing test when Rekor public keys can be set in CheckOpts,\n\t// instead of relying on the singleton TUF instance.\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err == nil {\n\t\tt.Fatalf(\"expected error due to custom Rekor public key\")\n\t}\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureWithOnlyRoot(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(signature), static.WithCertChain(pemLeaf, pemRoot))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error while verifying signature, expected no error, got %v\", err)\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureWithMissingSub(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(signature), static.WithCertChain(pemLeaf, pemRoot))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err == nil {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\tif !strings.Contains(err.Error(), \"certificate signed by unknown authority\") {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureWithExistingSub(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\totherSubCert, _, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tsubPool := x509.NewCertPool()\n\t// Load in different sub cert so the chain doesn't verify\n\trootPool.AddCert(otherSubCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload,\n\t\tbase64.StdEncoding.EncodeToString(signature),\n\t\tstatic.WithCertChain(pemLeaf, appendSlices([][]byte{pemSub, pemRoot})))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool, IntermediateCerts: subPool})\n\tif err == nil {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\tif !strings.Contains(err.Error(), \"certificate signed by unknown authority\") {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\n// This test ensures that image signature validation fails properly if we are\n// using a SigVerifier with Rekor.\n// See https://github.com/sigstore/cosign/issues/1816 for more details.\nfunc TestVerifyImageSignatureWithSigVerifierAndRekor(t *testing.T) {\n\tsv, privKey, err := signature.NewDefaultECDSASignerVerifier()\n\tif err != nil {\n\t\tt.Fatalf(\"error generating verifier: %v\", err)\n\t}\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsig, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(sig))\n\n\t// Add a fake rekor client - this makes it look like there's a matching\n\t// tlog entry for the signature during validation (even though it does not\n\t// match the underlying data / key)\n\tmClient := new(client.Rekor)\n\tmClient.Entries = &mock.EntriesClient{}\n\n\tif _, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{\n\t\tSigVerifier: sv,\n\t\tRekorClient: mClient,\n\t}); err == nil || !strings.Contains(err.Error(), \"verifying inclusion proof\") {\n\t\t// TODO(wlynch): This is a weak test, since this is really failing because\n\t\t// there is no inclusion proof for the Rekor entry rather than failing to\n\t\t// validate the Rekor public key itself. At the very least this ensures\n\t\t// that we're hitting tlog validation during signature checking,\n\t\t// but we should look into improving this once there is an in-memory\n\t\t// Rekor client that is capable of performing inclusion proof validation\n\t\t// in unit tests.\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccess(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n\terr = CheckCertificatePolicy(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"CheckCertificatePolicy expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccessAllowAllValues(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts: rootPool,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n\terr = CheckCertificatePolicy(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"CheckCertificatePolicy expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithSCT(t *testing.T) {\n\tchain, err := cryptoutils.UnmarshalCertificatesFromPEM([]byte(testdata.TestEmbeddedCertPEM + testdata.CACertPEM))\n\tif err != nil {\n\t\tt.Fatalf(\"error unmarshalling certificate chain: %v\", err)\n\t}\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(chain[1])\n\tco := &CheckOpts{\n\t\tRootCerts: rootPool,\n\t}\n\n\t// write SCT verification key to disk\n\ttmpPrivFile, err := os.CreateTemp(t.TempDir(), \"cosign_verify_sct_*.key\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp key file: %v\", err)\n\t}\n\tdefer tmpPrivFile.Close()\n\tif _, err := tmpPrivFile.Write([]byte(testdata.LogPublicKeyPEM)); err != nil {\n\t\tt.Fatalf(\"failed to write key file: %v\", err)\n\t}\n\tos.Setenv(\"SIGSTORE_CT_LOG_PUBLIC_KEY_FILE\", tmpPrivFile.Name())\n\tdefer os.Unsetenv(\"SIGSTORE_CT_LOG_PUBLIC_KEY_FILE\")\n\n\t_, err = ValidateAndUnpackCert(chain[0], co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n\n\t// validate again, explicitly setting enforce SCT\n\tco.EnforceSCT = true\n\t_, err = ValidateAndUnpackCert(chain[0], co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithoutRequiredSCT(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t\tEnforceSCT:     true,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"certificate does not include required embedded SCT\")\n}\n\nfunc TestValidateAndUnpackCertInvalidRoot(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\totherRoot, _, _ := test.GenerateRootCa()\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(otherRoot)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"certificate signed by unknown authority\")\n}\n\nfunc TestValidateAndUnpackCertInvalidOidcIssuer(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: \"other\",\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected oidc issuer not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected oidc issuer not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidEmail(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      \"other\",\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowTrigger(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowTrigger := \"myTrigger\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, githubWorkFlowTrigger, \"\", \"\", \"\", \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:                 rootPool,\n\t\tCertEmail:                 subject,\n\t\tCertGithubWorkflowTrigger: \"otherTrigger\",\n\t\tCertOidcIssuer:            oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Trigger not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Trigger not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowSHA(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowSha := \"mySHA\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", githubWorkFlowSha, \"\", \"\", \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:             rootPool,\n\t\tCertEmail:             subject,\n\t\tCertGithubWorkflowSha: \"otherSHA\",\n\t\tCertOidcIssuer:        oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow SHA not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow SHA not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowName(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowName := \"myName\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", \"\", githubWorkFlowName, \"\", \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:              rootPool,\n\t\tCertEmail:              subject,\n\t\tCertGithubWorkflowName: \"otherName\",\n\t\tCertOidcIssuer:         oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Name not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Name not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowRepository(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowRepository := \"myRepository\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", \"\", \"\", githubWorkFlowRepository, \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:                    rootPool,\n\t\tCertEmail:                    subject,\n\t\tCertGithubWorkflowRepository: \"otherRepository\",\n\t\tCertOidcIssuer:               oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Repository not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Repository not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowRef(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowRef := \"myRef\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", \"\", \"\", \"\", githubWorkFlowRef, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:             rootPool,\n\t\tCertEmail:             subject,\n\t\tCertGithubWorkflowRef: \"otherRef\",\n\t\tCertOidcIssuer:        oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Ref not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Ref not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertWithChainSuccess(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, subCert, subKey)\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{subCert, leafCert}, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithChainSuccessWithRoot(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{rootCert}, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithChainFailsWithoutChain(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{}, co)\n\tif err == nil || err.Error() != \"no chain provided to validate certificate\" {\n\t\tt.Errorf(\"expected error without chain, got %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithChainFailsWithInvalidChain(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\trootCertOther, _, _ := test.GenerateRootCa()\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{rootCertOther}, co)\n\tif err == nil || !strings.Contains(err.Error(), \"certificate signed by unknown authority\") {\n\t\tt.Errorf(\"expected error without valid chain, got %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithIdentities(t *testing.T) {\n\tu, err := url.Parse(\"http://url.example.com\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to parse url\", err)\n\t}\n\temailSubject := \"email@example.com\"\n\tdnsSubjects := []string{\"dnssubject.example.com\"}\n\tipSubjects := []net.IP{net.ParseIP(\"1.2.3.4\")}\n\turiSubjects := []*url.URL{u}\n\toidcIssuer := \"https://accounts.google.com\"\n\n\ttests := []struct {\n\t\tidentities       []Identity\n\t\twantErrSubstring string\n\t\tdnsNames         []string\n\t\temailAddresses   []string\n\t\tipAddresses      []net.IP\n\t\turis             []*url.URL\n\t}{\n\t\t{identities: nil /* No matches required, checks out */},\n\t\t{identities: []Identity{ // Strict match on both\n\t\t\t{Subject: emailSubject, Issuer: oidcIssuer}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // just issuer\n\t\t\t{Issuer: oidcIssuer}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // just subject\n\t\t\t{Subject: emailSubject}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // mis-match\n\t\t\t{Subject: \"wrongsubject\", Issuer: oidcIssuer},\n\t\t\t{Subject: emailSubject, Issuer: \"wrongissuer\"}},\n\t\t\temailAddresses:   []string{emailSubject},\n\t\t\twantErrSubstring: \"none of the expected identities matched\"},\n\t\t{identities: []Identity{ // one good identity, other does not match\n\t\t\t{Subject: \"wrongsubject\", Issuer: \"wrongissuer\"},\n\t\t\t{Subject: emailSubject, Issuer: oidcIssuer}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // illegal regex for subject\n\t\t\t{SubjectRegExp: \"****\", Issuer: oidcIssuer}},\n\t\t\temailAddresses:   []string{emailSubject},\n\t\t\twantErrSubstring: \"malformed subject in identity\"},\n\t\t{identities: []Identity{ // illegal regex for issuer\n\t\t\t{Subject: emailSubject, IssuerRegExp: \"****\"}},\n\t\t\twantErrSubstring: \"malformed issuer in identity\"},\n\t\t{identities: []Identity{ // regex matches\n\t\t\t{SubjectRegExp: \".*example.com\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\temailAddresses:   []string{emailSubject},\n\t\t\twantErrSubstring: \"\"},\n\t\t{identities: []Identity{ // regex matches dnsNames\n\t\t\t{SubjectRegExp: \".*ubject.example.com\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\tdnsNames:         dnsSubjects,\n\t\t\twantErrSubstring: \"\"},\n\t\t{identities: []Identity{ // regex matches ip\n\t\t\t{SubjectRegExp: \"1.2.3.*\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\tipAddresses:      ipSubjects,\n\t\t\twantErrSubstring: \"\"},\n\t\t{identities: []Identity{ // regex matches urls\n\t\t\t{SubjectRegExp: \".*url.examp.*\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\turis:             uriSubjects,\n\t\t\twantErrSubstring: \"\"},\n\t}\n\tfor _, tc := range tests {\n\t\trootCert, rootKey, _ := test.GenerateRootCa()\n\t\tleafCert, _, _ := test.GenerateLeafCertWithSubjectAlternateNames(tc.dnsNames, tc.emailAddresses, tc.ipAddresses, tc.uris, oidcIssuer, rootCert, rootKey)\n\n\t\trootPool := x509.NewCertPool()\n\t\trootPool.AddCert(rootCert)\n\n\t\tco := &CheckOpts{\n\t\t\tRootCerts:  rootPool,\n\t\t\tIdentities: tc.identities,\n\t\t}\n\t\t_, err := ValidateAndUnpackCert(leafCert, co)\n\t\tif err == nil && tc.wantErrSubstring != \"\" {\n\t\t\tt.Errorf(\"Expected error %s got none\", tc.wantErrSubstring)\n\t\t} else if err != nil {\n\t\t\tif tc.wantErrSubstring == \"\" {\n\t\t\t\tt.Errorf(\"Did not expect an error, got err = %v\", err)\n\t\t\t} else if !strings.Contains(err.Error(), tc.wantErrSubstring) {\n\t\t\t\tt.Errorf(\"Did not get the expected error %s, got err = %v\", tc.wantErrSubstring, err)\n\t\t\t}\n\t\t}\n\t\t// Test CheckCertificatePolicy\n\t\terr = CheckCertificatePolicy(leafCert, co)\n\t\tif err == nil && tc.wantErrSubstring != \"\" {\n\t\t\tt.Errorf(\"Expected error %s got none\", tc.wantErrSubstring)\n\t\t} else if err != nil {\n\t\t\tif tc.wantErrSubstring == \"\" {\n\t\t\t\tt.Errorf(\"Did not expect an error, got err = %v\", err)\n\t\t\t} else if !strings.Contains(err.Error(), tc.wantErrSubstring) {\n\t\t\t\tt.Errorf(\"Did not get the expected error %s, got err = %v\", tc.wantErrSubstring, err)\n\t\t\t}\n\t\t}\n\t}\n}\nfunc TestCompareSigs(t *testing.T) {\n\t// TODO(nsmith5): Add test cases for invalid signature, missing signature etc\n\ttests := []struct {\n\t\tdescription string\n\t\tb64sig      string\n\t\tbundleBody  string\n\t\tshouldErr   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"sigs match\",\n\t\t\tb64sig:      \"MEQCIDO3XHbLovPWK+bk8ItCig2cwlr/8MXbLvz3UFzxMGIMAiA1lqdM9IqqUvCUqzOjufTq3sKU3qSn7R5tPqPz0ddNwQ==\",\n\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n\t\t},\n\t\t{\n\t\t\tdescription: \"sigs don't match\",\n\t\t\tb64sig:      \"bm9wZQo=\",\n\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n\t\t\tshouldErr:   true,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tsig, err := static.NewSignature([]byte(\"payload\"), test.b64sig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create static signature: %v\", err)\n\t\t\t}\n\t\t\terr = compareSigs(test.bundleBody, sig)\n\t\t\tif err == nil && test.shouldErr {\n\t\t\t\tt.Fatal(\"test should have errored\")\n\t\t\t}\n\t\t\tif err != nil && !test.shouldErr {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTrustedCertSuccess(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, _, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tsubPool := x509.NewCertPool()\n\tsubPool.AddCert(subCert)\n\n\tchains, err := TrustedCert(leafCert, rootPool, subPool)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error verifying certificate, got %v\", err)\n\t}\n\tif len(chains) != 1 {\n\t\tt.Fatalf(\"unexpected number of chains found, expected 1, got %v\", len(chains))\n\t}\n\tif len(chains[0]) != 3 {\n\t\tt.Fatalf(\"unexpected number of certs in chain, expected 3, got %v\", len(chains[0]))\n\t}\n}\n\nfunc TestTrustedCertSuccessNoIntermediates(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\t_, err := TrustedCert(leafCert, rootPool, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error verifying certificate, got %v\", err)\n\t}\n}\n\n// Tests that verification succeeds if both a root and subordinate pool are\n// present, but a chain is built with only the leaf and root certificates.\nfunc TestTrustedCertSuccessChainFromRoot(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\tsubCert, _, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tsubPool := x509.NewCertPool()\n\tsubPool.AddCert(subCert)\n\n\t_, err := TrustedCert(leafCert, rootPool, subPool)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error verifying certificate, got %v\", err)\n\t}\n}\n", "// Copyright 2022 The Sigstore Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage test\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/asn1\"\n\t\"math/big\"\n\t\"net\"\n\t\"net/url\"\n\t\"time\"\n)\n\n/*\nTo use:\n\nrootCert, rootKey, _ := GenerateRootCa()\nsubCert, subKey, _ := GenerateSubordinateCa(rootCert, rootKey)\nleafCert, _, _ := GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\nroots := x509.NewCertPool()\nsubs := x509.NewCertPool()\nroots.AddCert(rootCert)\nsubs.AddCert(subCert)\nopts := x509.VerifyOptions{\n\tRoots:         roots,\n\tIntermediates: subs,\n\tKeyUsages: []x509.ExtKeyUsage{\n\t\tx509.ExtKeyUsageCodeSigning,\n\t},\n}\n_, err := leafCert.Verify(opts)\n*/\n\nfunc createCertificate(template *x509.Certificate, parent *x509.Certificate, pub interface{}, priv crypto.Signer) (*x509.Certificate, error) {\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, template, parent, pub, priv)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcert, err := x509.ParseCertificate(certBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn cert, nil\n}\n\nfunc GenerateRootCa() (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\trootTemplate := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   \"sigstore\",\n\t\t\tOrganization: []string{\"sigstore.dev\"},\n\t\t},\n\t\tNotBefore:             time.Now().Add(-5 * time.Minute),\n\t\tNotAfter:              time.Now().Add(5 * time.Hour),\n\t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(rootTemplate, rootTemplate, &priv.PublicKey, priv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateSubordinateCa(rootTemplate *x509.Certificate, rootPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tsubTemplate := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   \"sigstore-sub\",\n\t\t\tOrganization: []string{\"sigstore.dev\"},\n\t\t},\n\t\tNotBefore:             time.Now().Add(-2 * time.Minute),\n\t\tNotAfter:              time.Now().Add(2 * time.Hour),\n\t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(subTemplate, rootTemplate, &priv.PublicKey, rootPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateLeafCert(subject string, oidcIssuer string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: []string{subject},\n\t\tNotBefore:      time.Now().Add(-1 * time.Minute),\n\t\tNotAfter:       time.Now().Add(time.Hour),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t},\n\t\t},\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateLeafCertWithGitHubOIDs(subject string, oidcIssuer string, githubWorkflowTrigger, githubWorkflowSha, githubWorkflowName,\n\tgithubWorkflowRepository, githubWorkflowRef string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: []string{subject},\n\t\tNotBefore:      time.Now().Add(-1 * time.Minute),\n\t\tNotAfter:       time.Now().Add(time.Hour),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 2}, Value: []byte(githubWorkflowTrigger)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 3}, Value: []byte(githubWorkflowSha)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 4}, Value: []byte(githubWorkflowName)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 5}, Value: []byte(githubWorkflowRepository)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 6}, Value: []byte(githubWorkflowRef)}},\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateLeafCertWithSubjectAlternateNames(dnsNames []string, emailAddresses []string, ipAddresses []net.IP, uris []*url.URL, oidcIssuer string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: emailAddresses,\n\t\tDNSNames:       dnsNames,\n\t\tIPAddresses:    ipAddresses,\n\t\tURIs:           uris,\n\t\tNotBefore:      time.Now().Add(-1 * time.Minute),\n\t\tNotAfter:       time.Now().Add(time.Hour),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t}},\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n"], "fixing_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-openapi/runtime\"\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/tuf\"\n\n\tctypes \"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/pki\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/rekor/pkg/types/hashedrekord\"\n\thashedrekord_v001 \"github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1\"\n\t\"github.com/sigstore/rekor/pkg/types/intoto\"\n\tintoto_v001 \"github.com/sigstore/rekor/pkg/types/intoto/v0.0.1\"\n\t\"github.com/sigstore/rekor/pkg/types/rekord\"\n\trekord_v001 \"github.com/sigstore/rekor/pkg/types/rekord/v0.0.1\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\tsignatureoptions \"github.com/sigstore/sigstore/pkg/signature/options\"\n)\n\nfunc isb64(data []byte) bool {\n\t_, err := base64.StdEncoding.DecodeString(string(data))\n\treturn err == nil\n}\n\n// nolint\nfunc VerifyBlobCmd(ctx context.Context, ko options.KeyOpts, certRef, certEmail,\n\tcertOidcIssuer, certChain, sigRef, blobRef, certGithubWorkflowTrigger, certGithubWorkflowSha,\n\tcertGithubWorkflowName,\n\tcertGithubWorkflowRepository,\n\tcertGithubWorkflowRef string, enforceSCT bool) error {\n\tvar cert *x509.Certificate\n\n\tif !options.OneOf(ko.KeyRef, ko.Sk, certRef) && !options.EnableExperimental() && ko.BundlePath == \"\" {\n\t\treturn &options.PubKeyParseError{}\n\t}\n\n\tsig, err := signatures(sigRef, ko.BundlePath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tblobBytes, err := payloadBytes(blobRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tco := &cosign.CheckOpts{\n\t\tCertEmail:                    certEmail,\n\t\tCertOidcIssuer:               certOidcIssuer,\n\t\tCertGithubWorkflowTrigger:    certGithubWorkflowTrigger,\n\t\tCertGithubWorkflowSha:        certGithubWorkflowSha,\n\t\tCertGithubWorkflowName:       certGithubWorkflowName,\n\t\tCertGithubWorkflowRepository: certGithubWorkflowRepository,\n\t\tCertGithubWorkflowRef:        certGithubWorkflowRef,\n\t\tEnforceSCT:                   enforceSCT,\n\t}\n\tif options.EnableExperimental() {\n\t\tif ko.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(ko.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t}\n\tif certRef == \"\" || options.EnableExperimental() {\n\t\tco.RootCerts, err = fulcio.GetRoots()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n\t\t}\n\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n\t\t}\n\t}\n\n\t// Keys are optional!\n\tswitch {\n\tcase ko.KeyRef != \"\":\n\t\tco.SigVerifier, err = sigs.PublicKeyFromKeyRef(ctx, ko.KeyRef)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading public key: %w\", err)\n\t\t}\n\t\tpkcs11Key, ok := co.SigVerifier.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase ko.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(ko.Slot)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"opening piv token: %w\", err)\n\t\t}\n\t\tdefer sk.Close()\n\t\tco.SigVerifier, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading public key from token: %w\", err)\n\t\t}\n\tcase certRef != \"\":\n\t\tcert, err = loadCertFromFileOrURL(certRef)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif certChain == \"\" {\n\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// Verify certificate with chain\n\t\t\tchain, err := loadCertChainFromFileOrURL(certChain)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCertWithChain(cert, chain, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase ko.BundlePath != \"\":\n\t\tb, err := cosign.FetchLocalSignedPayloadFromPath(ko.BundlePath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif b.Cert == \"\" {\n\t\t\treturn fmt.Errorf(\"bundle does not contain cert for verification, please provide public key\")\n\t\t}\n\t\t// b.Cert can either be a certificate or public key\n\t\tcertBytes := []byte(b.Cert)\n\t\tif isb64(certBytes) {\n\t\t\tcertBytes, _ = base64.StdEncoding.DecodeString(b.Cert)\n\t\t}\n\t\tcert, err = loadCertFromPEM(certBytes)\n\t\tif err != nil {\n\t\t\t// check if cert is actually a public key\n\t\t\tco.SigVerifier, err = sigs.LoadPublicKeyRaw(certBytes, crypto.SHA256)\n\t\t} else {\n\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t// No certificate is provided: search by artifact sha in the TLOG.\n\tcase options.EnableExperimental():\n\t\tuuids, err := cosign.FindTLogEntriesByPayload(ctx, co.RekorClient, blobBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(uuids) == 0 {\n\t\t\treturn errors.New(\"could not find a tlog entry for provided blob\")\n\t\t}\n\n\t\t// Iterate through and try to find a matching Rekor entry.\n\t\t// This does not support intoto properly! c/f extractCerts and\n\t\t// the verifier.\n\t\tfor _, u := range uuids {\n\t\t\ttlogEntry, err := cosign.GetTlogEntry(ctx, co.RekorClient, u)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Note that this will error out if the TLOG entry was signed with a\n\t\t\t// raw public key. Again, using search on artifact sha is unreliable.\n\t\t\tcerts, err := extractCerts(tlogEntry)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcert := certs[0]\n\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif err := verifyBlob(ctx, co, blobBytes, sig, cert,\n\t\t\t\tko.BundlePath, tlogEntry); err == nil {\n\t\t\t\t// We found a succesful Rekor entry!\n\t\t\t\tfmt.Fprintln(os.Stderr, \"Verified OK\")\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\t// No successful Rekor entry found.\n\t\tfmt.Fprintln(os.Stderr, `WARNING: No valid entries were found in rekor to verify this blob.\n\nTransparency log support for blobs is experimental, and occasionally an entry isn't found even if one exists.\n\nWe recommend requesting the certificate/signature from the original signer of this blob and manually verifying with cosign verify-blob --cert [cert] --signature [signature].`)\n\t\treturn fmt.Errorf(\"could not find a valid tlog entry for provided blob, found %d invalid entries\", len(uuids))\n\n\t}\n\n\t// Performs all blob verification.\n\tif err := verifyBlob(ctx, co, blobBytes, sig, cert, ko.BundlePath, nil); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintln(os.Stderr, \"Verified OK\")\n\treturn nil\n}\n\n/* Verify Blob main entry point. This will perform the following:\n   1. Verifies the signature on the blob using the provided verifier.\n   2. Checks for transparency log entry presence:\n        a. Verifies the Rekor entry in the bundle, if provided. OR\n        b. If we don't have a Rekor entry retrieved via cert, do an online lookup (assuming\n           we are in experimental mode).\n        c. Uses the provided Rekor entry (may have been retrieved through Rekor SearchIndex) OR\n   3. If a certificate is provided, check it's expiration.\n*/\n// TODO: Make a version of this public. This could be VerifyBlobCmd, but we need to\n// clean up the args into CheckOpts or use KeyOpts here to resolve different KeyOpts.\nfunc verifyBlob(ctx context.Context, co *cosign.CheckOpts,\n\tblobBytes []byte, sig string, cert *x509.Certificate,\n\tbundlePath string, e *models.LogEntryAnon) error {\n\tif cert != nil {\n\t\t// This would have already be done in the main entrypoint, but do this for robustness.\n\t\tvar err error\n\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCert(cert, co)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"validating cert: %w\", err)\n\t\t}\n\t}\n\n\t// Use the DSSE verifier if the payload is a DSSE with the In-Toto format.\n\t// TODO: This verifier only supports verification of a single signer/signature on\n\t// the envelope. Either have the verifier validate that only one signature exists,\n\t// or use a multi-signature verifier.\n\tif isIntotoDSSE(blobBytes) {\n\t\tco.SigVerifier = dsse.WrapVerifier(co.SigVerifier)\n\t}\n\n\t// 1. Verify the signature.\n\tif err := co.SigVerifier.VerifySignature(strings.NewReader(sig), bytes.NewReader(blobBytes)); err != nil {\n\t\treturn err\n\t}\n\n\t// This is the signature creation time. Without a transparency log entry timestamp,\n\t// we can only use the current time as a bound.\n\tvar validityTime time.Time\n\t// 2. Checks for transparency log entry presence:\n\tswitch {\n\t// a. We have a local bundle.\n\tcase bundlePath != \"\":\n\t\tvar svBytes []byte\n\t\tvar err error\n\t\tif cert != nil {\n\t\t\tsvBytes, err = cryptoutils.MarshalCertificateToPEM(cert)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"marshalling cert: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tsvBytes, err = sigs.PublicKeyPem(co.SigVerifier, signatureoptions.WithContext(ctx))\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"marshalling pubkey: %w\", err)\n\t\t\t}\n\t\t}\n\t\tbundle, err := verifyRekorBundle(ctx, bundlePath, co.RekorClient, blobBytes, sig, svBytes)\n\t\tif err != nil {\n\t\t\t// Return when the provided bundle fails verification. (Do not fallback).\n\t\t\treturn err\n\t\t}\n\t\tvalidityTime = time.Unix(bundle.IntegratedTime, 0)\n\t\tfmt.Fprintf(os.Stderr, \"tlog entry verified offline\\n\")\n\t// b. We can make an online lookup to the transparency log since we don't have an entry.\n\tcase co.RekorClient != nil && e == nil:\n\t\tvar tlogFindErr error\n\t\tif cert == nil {\n\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\te, tlogFindErr = tlogFindPublicKey(ctx, co.RekorClient, blobBytes, sig, pub)\n\t\t} else {\n\t\t\te, tlogFindErr = tlogFindCertificate(ctx, co.RekorClient, blobBytes, sig, cert)\n\t\t}\n\t\tif tlogFindErr != nil {\n\t\t\t// TODO: Think about whether we should break here.\n\t\t\t// This is COSIGN_EXPERIMENTAL mode, but in the case where someone\n\t\t\t// provided a public key or still-valid cert,\n\t\t\t/// they don't need TLOG lookup for the timestamp.\n\t\t\tfmt.Fprintf(os.Stderr, \"could not find entry in tlog: %s\", tlogFindErr)\n\t\t\treturn tlogFindErr\n\t\t}\n\t\t// Fallthrough here to verify the TLOG entry and compute the integrated time.\n\t\tfallthrough\n\t// We are provided a log entry, possibly from above, or search.\n\tcase e != nil:\n\t\tif err := cosign.VerifyTLogEntry(ctx, co.RekorClient, e); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tuuid, err := cosign.ComputeLeafHash(e)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvalidityTime = time.Unix(*e.IntegratedTime, 0)\n\t\tfmt.Fprintf(os.Stderr, \"tlog entry verified with uuid: %s index: %d\\n\", hex.EncodeToString(uuid), *e.LogIndex)\n\t// If we do not have access to a bundle, a Rekor entry, or the access to lookup,\n\t// then we can only use the current time as the signature creation time to verify\n\t// the signature was created when the certificate was valid.\n\tdefault:\n\t\tvalidityTime = time.Now()\n\t}\n\n\t// 3. If a certificate is provided, check it's expiration.\n\tif cert == nil {\n\t\treturn nil\n\t}\n\n\treturn cosign.CheckExpiry(cert, validityTime)\n}\n\nfunc tlogFindPublicKey(ctx context.Context, rekorClient *client.Rekor,\n\tblobBytes []byte, sig string, pub crypto.PublicKey) (*models.LogEntryAnon, error) {\n\tpemBytes, err := cryptoutils.MarshalPublicKeyToPEM(pub)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tlogFindEntry(ctx, rekorClient, blobBytes, sig, pemBytes)\n}\n\nfunc tlogFindCertificate(ctx context.Context, rekorClient *client.Rekor,\n\tblobBytes []byte, sig string, cert *x509.Certificate) (*models.LogEntryAnon, error) {\n\tpemBytes, err := cryptoutils.MarshalCertificateToPEM(cert)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tlogFindEntry(ctx, rekorClient, blobBytes, sig, pemBytes)\n}\n\nfunc tlogFindEntry(ctx context.Context, client *client.Rekor,\n\tblobBytes []byte, sig string, pem []byte) (*models.LogEntryAnon, error) {\n\tb64sig := base64.StdEncoding.EncodeToString([]byte(sig))\n\treturn cosign.FindTlogEntry(ctx, client, b64sig, blobBytes, pem)\n}\n\n// signatures returns the raw signature\nfunc signatures(sigRef string, bundlePath string) (string, error) {\n\tvar targetSig []byte\n\tvar err error\n\tswitch {\n\tcase sigRef != \"\":\n\t\ttargetSig, err = blob.LoadFileOrURL(sigRef)\n\t\tif err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\t// ignore if file does not exist, it can be a base64 encoded string as well\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\ttargetSig = []byte(sigRef)\n\t\t}\n\tcase bundlePath != \"\":\n\t\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\ttargetSig = []byte(b.Base64Signature)\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"missing flag '--signature'\")\n\t}\n\n\tvar sig, b64sig string\n\tif isb64(targetSig) {\n\t\tb64sig = string(targetSig)\n\t\tsigBytes, _ := base64.StdEncoding.DecodeString(b64sig)\n\t\tsig = string(sigBytes)\n\t} else {\n\t\tsig = string(targetSig)\n\t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n\t}\n\treturn sig, nil\n}\n\nfunc payloadBytes(blobRef string) ([]byte, error) {\n\tvar blobBytes []byte\n\tvar err error\n\tif blobRef == \"-\" {\n\t\tblobBytes, err = io.ReadAll(os.Stdin)\n\t} else {\n\t\tblobBytes, err = blob.LoadFileOrURL(blobRef)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn blobBytes, nil\n}\n\n// TODO: RekorClient can be removed when SIGSTORE_TRUST_REKOR_API_PUBLIC_KEY\n// is removed.\nfunc verifyRekorBundle(ctx context.Context, bundlePath string, rekorClient *client.Rekor,\n\tblobBytes []byte, sig string, pubKeyBytes []byte) (*bundle.RekorPayload, error) {\n\tb, err := cosign.FetchLocalSignedPayloadFromPath(bundlePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif b.Bundle == nil {\n\t\treturn nil, fmt.Errorf(\"rekor entry could not be extracted from local bundle\")\n\t}\n\n\tif err := verifyBundleMatchesData(ctx, b.Bundle, blobBytes, pubKeyBytes, []byte(sig)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tpublicKeys, err := cosign.GetRekorPubs(ctx, rekorClient)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"retrieving rekor public key: %w\", err)\n\t}\n\n\tpubKey, ok := publicKeys[b.Bundle.Payload.LogID]\n\tif !ok {\n\t\treturn nil, errors.New(\"rekor log public key not found for payload\")\n\t}\n\terr = cosign.VerifySET(b.Bundle.Payload, b.Bundle.SignedEntryTimestamp, pubKey.PubKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif pubKey.Status != tuf.Active {\n\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n\t}\n\n\treturn &b.Bundle.Payload, nil\n}\n\nfunc verifyBundleMatchesData(ctx context.Context, bundle *bundle.RekorBundle, blobBytes, certBytes, sigBytes []byte) error {\n\teimpl, kind, apiVersion, err := unmarshalEntryImpl(bundle.Payload.Body.(string))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttargetImpl, err := reconstructCanonicalizedEntry(ctx, kind, apiVersion, blobBytes, certBytes, sigBytes)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"recontructing rekorEntry for bundle comparison: %w\", err)\n\t}\n\n\tswitch e := eimpl.(type) {\n\tcase *rekord_v001.V001Entry:\n\t\tt := targetImpl.(*rekord_v001.V001Entry)\n\t\tdata, err := e.RekordObj.Data.Content.MarshalText()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid rekord data: %w\", err)\n\t\t}\n\t\ttData, err := t.RekordObj.Data.Content.MarshalText()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid rekord data: %w\", err)\n\t\t}\n\t\tif !bytes.Equal(data, tData) {\n\t\t\treturn fmt.Errorf(\"rekord data does not match blob\")\n\t\t}\n\t\tif err := compareBase64Strings(e.RekordObj.Signature.Content.String(),\n\t\t\tt.RekordObj.Signature.Content.String()); err != nil {\n\t\t\treturn fmt.Errorf(\"rekord signature does not match bundle %s\", err)\n\t\t}\n\t\tif err := compareBase64Strings(e.RekordObj.Signature.PublicKey.Content.String(),\n\t\t\tt.RekordObj.Signature.PublicKey.Content.String()); err != nil {\n\t\t\treturn fmt.Errorf(\"rekord public key does not match bundle\")\n\t\t}\n\tcase *hashedrekord_v001.V001Entry:\n\t\tt := targetImpl.(*hashedrekord_v001.V001Entry)\n\t\tif *e.HashedRekordObj.Data.Hash.Value != *t.HashedRekordObj.Data.Hash.Value {\n\t\t\treturn fmt.Errorf(\"hashedRekord data does not match blob\")\n\t\t}\n\t\tif err := compareBase64Strings(e.HashedRekordObj.Signature.Content.String(),\n\t\t\tt.HashedRekordObj.Signature.Content.String()); err != nil {\n\t\t\treturn fmt.Errorf(\"hashedRekord signature does not match bundle %s\", err)\n\t\t}\n\t\tif err := compareBase64Strings(e.HashedRekordObj.Signature.PublicKey.Content.String(),\n\t\t\tt.HashedRekordObj.Signature.PublicKey.Content.String()); err != nil {\n\t\t\treturn fmt.Errorf(\"hashedRekord public key does not match bundle\")\n\t\t}\n\tcase *intoto_v001.V001Entry:\n\t\tt := targetImpl.(*intoto_v001.V001Entry)\n\t\tif *e.IntotoObj.Content.Hash.Value != *t.IntotoObj.Content.Hash.Value {\n\t\t\treturn fmt.Errorf(\"intoto content hash does not match attestation\")\n\t\t}\n\t\tif *e.IntotoObj.Content.PayloadHash.Value != *t.IntotoObj.Content.PayloadHash.Value {\n\t\t\treturn fmt.Errorf(\"intoto payload hash does not match attestation\")\n\t\t}\n\t\tif err := compareBase64Strings(e.IntotoObj.PublicKey.String(),\n\t\t\tt.IntotoObj.PublicKey.String()); err != nil {\n\t\t\treturn fmt.Errorf(\"intoto public key does not match bundle\")\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"unexpected tlog entry type\")\n\t}\n\treturn nil\n}\n\nfunc reconstructCanonicalizedEntry(ctx context.Context, kind, apiVersion string, blobBytes, certBytes, sigBytes []byte) (types.EntryImpl, error) {\n\tprops := types.ArtifactProperties{\n\t\tPublicKeyBytes: certBytes,\n\t\tPKIFormat:      string(pki.X509),\n\t}\n\tswitch kind {\n\tcase rekord.KIND:\n\t\tprops.ArtifactBytes = blobBytes\n\t\tprops.SignatureBytes = sigBytes\n\tcase hashedrekord.KIND:\n\t\tblobHash := sha256.Sum256(blobBytes)\n\t\tprops.ArtifactHash = strings.ToLower(hex.EncodeToString(blobHash[:]))\n\t\tprops.SignatureBytes = sigBytes\n\tcase intoto.KIND:\n\t\tprops.ArtifactBytes = blobBytes\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected entry kind: %s\", kind)\n\t}\n\tproposedEntry, err := types.NewProposedEntry(ctx, kind, apiVersion, props)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tentry, err := types.NewEntry(proposedEntry)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcan, err := entry.Canonicalize(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tproposedEntryCan, err := models.UnmarshalProposedEntry(bytes.NewReader(can), runtime.JSONConsumer())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn types.NewEntry(proposedEntryCan)\n}\n\n// unmarshalEntryImpl decodes the base64-encoded entry to a specific entry type (types.EntryImpl).\nfunc unmarshalEntryImpl(e string) (types.EntryImpl, string, string, error) {\n\tb, err := base64.StdEncoding.DecodeString(e)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", err\n\t}\n\n\tpe, err := models.UnmarshalProposedEntry(bytes.NewReader(b), runtime.JSONConsumer())\n\tif err != nil {\n\t\treturn nil, \"\", \"\", err\n\t}\n\n\tentry, err := types.NewEntry(pe)\n\tif err != nil {\n\t\treturn nil, \"\", \"\", err\n\t}\n\treturn entry, pe.Kind(), entry.APIVersion(), nil\n}\n\nfunc extractCerts(e *models.LogEntryAnon) ([]*x509.Certificate, error) {\n\teimpl, _, _, err := unmarshalEntryImpl(e.Body.(string))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar publicKeyB64 []byte\n\tswitch e := eimpl.(type) {\n\tcase *rekord_v001.V001Entry:\n\t\tpublicKeyB64, err = e.RekordObj.Signature.PublicKey.Content.MarshalText()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase *hashedrekord_v001.V001Entry:\n\t\tpublicKeyB64, err = e.HashedRekordObj.Signature.PublicKey.Content.MarshalText()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, errors.New(\"unexpected tlog entry type\")\n\t}\n\n\tpublicKey, err := base64.StdEncoding.DecodeString(string(publicKeyB64))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcerts, err := cryptoutils.UnmarshalCertificatesFromPEM(publicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(certs) == 0 {\n\t\treturn nil, errors.New(\"no certs found in pem tlog\")\n\t}\n\n\treturn certs, err\n}\n\n// isIntotoDSSE checks whether a payload is a Dead Simple Signing Envelope with the In-Toto format.\nfunc isIntotoDSSE(blobBytes []byte) bool {\n\tDSSEenvelope := ssldsse.Envelope{}\n\tif err := json.Unmarshal(blobBytes, &DSSEenvelope); err != nil {\n\t\treturn false\n\t}\n\tif DSSEenvelope.PayloadType != ctypes.IntotoPayloadType {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// TODO: Use this function to compare bundle signatures in OCI.\nfunc compareBase64Strings(got string, expected string) error {\n\tdecodeFirst, err := base64.StdEncoding.DecodeString(got)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"decoding base64 string %s\", got)\n\t}\n\tdecodeSecond, err := base64.StdEncoding.DecodeString(expected)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"decoding base64 string %s\", expected)\n\t}\n\tif !bytes.Equal(decodeFirst, decodeSecond) {\n\t\treturn fmt.Errorf(\"comparing base64 strings, expected %s, got %s\", expected, got)\n\t}\n\treturn nil\n}\n", "// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/go-openapi/swag\"\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\tctypes \"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/cosign/test\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/rekor/pkg/pki\"\n\t\"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/rekor/pkg/types/hashedrekord\"\n\thashedrekord_v001 \"github.com/sigstore/rekor/pkg/types/hashedrekord/v0.0.1\"\n\t\"github.com/sigstore/rekor/pkg/types/intoto\"\n\t\"github.com/sigstore/rekor/pkg/types/rekord\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\tsignatureoptions \"github.com/sigstore/sigstore/pkg/signature/options\"\n)\n\nfunc TestSignaturesRef(t *testing.T) {\n\tsig := \"a==\"\n\tb64sig := \"YT09\"\n\ttests := []struct {\n\t\tdescription string\n\t\tsigRef      string\n\t\tshouldErr   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"raw sig\",\n\t\t\tsigRef:      sig,\n\t\t},\n\t\t{\n\t\t\tdescription: \"encoded sig\",\n\t\t\tsigRef:      b64sig,\n\t\t}, {\n\t\t\tdescription: \"empty ref\",\n\t\t\tshouldErr:   true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tgotSig, err := signatures(test.sigRef, \"\")\n\t\t\tif test.shouldErr && err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.shouldErr {\n\t\t\t\tt.Fatal(\"should have received an error\")\n\t\t\t}\n\t\t\tif gotSig != sig {\n\t\t\t\tt.Fatalf(\"unexpected signature, expected: %s got: %s\", sig, gotSig)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSignaturesBundle(t *testing.T) {\n\ttd := t.TempDir()\n\tfp := filepath.Join(td, \"file\")\n\n\tsig := \"a==\"\n\tb64sig := \"YT09\"\n\n\t// save as a LocalSignedPayload to the file\n\tlsp := cosign.LocalSignedPayload{\n\t\tBase64Signature: b64sig,\n\t}\n\tcontents, err := json.Marshal(lsp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.WriteFile(fp, contents, 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgotSig, err := signatures(\"\", fp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif gotSig != sig {\n\t\tt.Fatalf(\"unexpected signature, expected: %s got: %s\", sig, gotSig)\n\t}\n}\n\nfunc TestIsIntotoDSSEWithEnvelopes(t *testing.T) {\n\ttts := []struct {\n\t\tenvelope     ssldsse.Envelope\n\t\tisIntotoDSSE bool\n\t}{\n\t\t{\n\t\t\tenvelope: ssldsse.Envelope{\n\t\t\t\tPayloadType: \"application/vnd.in-toto+json\",\n\t\t\t\tPayload:     base64.StdEncoding.EncodeToString([]byte(\"This is a test\")),\n\t\t\t\tSignatures:  []ssldsse.Signature{},\n\t\t\t},\n\t\t\tisIntotoDSSE: true,\n\t\t},\n\t}\n\tfor _, tt := range tts {\n\t\tenvlopeBytes, _ := json.Marshal(tt.envelope)\n\t\tgot := isIntotoDSSE(envlopeBytes)\n\t\tif got != tt.isIntotoDSSE {\n\t\t\tt.Fatalf(\"unexpected envelope content\")\n\t\t}\n\t}\n}\n\nfunc TestIsIntotoDSSEWithBytes(t *testing.T) {\n\ttts := []struct {\n\t\tenvelope     []byte\n\t\tisIntotoDSSE bool\n\t}{\n\t\t{\n\t\t\tenvelope:     []byte(\"This is no valid\"),\n\t\t\tisIntotoDSSE: false,\n\t\t},\n\t\t{\n\t\t\tenvelope:     []byte(\"MEUCIQDBmE1ZRFjUVic1hzukesJlmMFG1JqWWhcthnhawTeBNQIga3J9/WKsNlSZaySnl8V360bc2S8dIln2/qo186EfjHA=\"),\n\t\t\tisIntotoDSSE: false,\n\t\t},\n\t}\n\tfor _, tt := range tts {\n\t\tenvlopeBytes, _ := json.Marshal(tt.envelope)\n\t\tgot := isIntotoDSSE(envlopeBytes)\n\t\tif got != tt.isIntotoDSSE {\n\t\t\tt.Fatalf(\"unexpected envelope content\")\n\t\t}\n\t}\n}\n\n// Does not test identity options, only blob verification with different\n// options.\nfunc TestVerifyBlob(t *testing.T) {\n\tctx := context.Background()\n\ttd := t.TempDir()\n\n\tleafPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsigner, err := signature.LoadECDSASignerVerifier(leafPriv, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpubKeyBytes, err := sigs.PublicKeyPem(signer, signatureoptions.WithContext(ctx))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Generate expired and unexpired certificates\n\tidentity := \"hello@foo.com\"\n\tissuer := \"issuer\"\n\trootCert, rootPriv, _ := test.GenerateRootCa()\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tunexpiredLeafCert, _ := test.GenerateLeafCertWithExpiration(identity, issuer,\n\t\ttime.Now(), leafPriv, rootCert, rootPriv)\n\tunexpiredCertPem, _ := cryptoutils.MarshalCertificateToPEM(unexpiredLeafCert)\n\n\texpiredLeafCert, _ := test.GenerateLeafCertWithExpiration(identity, issuer,\n\t\ttime.Now().Add(-time.Hour), leafPriv, rootCert, rootPriv)\n\texpiredLeafPem, _ := cryptoutils.MarshalCertificateToPEM(expiredLeafCert)\n\n\t// Make rekor signer\n\trekorPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trekorSigner, err := signature.LoadECDSASignerVerifier(rekorPriv, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpemRekor, err := cryptoutils.MarshalPublicKeyToPEM(rekorSigner.Public())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmpRekorPubFile, err := os.CreateTemp(td, \"cosign_rekor_pub_*.key\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp rekor pub file: %v\", err)\n\t}\n\tdefer tmpRekorPubFile.Close()\n\tif _, err := tmpRekorPubFile.Write(pemRekor); err != nil {\n\t\tt.Fatalf(\"failed to write rekor pub file: %v\", err)\n\t}\n\tt.Setenv(\"SIGSTORE_REKOR_PUBLIC_KEY\", tmpRekorPubFile.Name())\n\n\tvar makeSignature = func(blob []byte) string {\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn string(sig)\n\t}\n\tblobBytes := []byte(\"foo\")\n\tblobSignature := makeSignature(blobBytes)\n\n\totherBytes := []byte(\"bar\")\n\totherSignature := makeSignature(otherBytes)\n\n\ttts := []struct {\n\t\tname        string\n\t\tblob        []byte\n\t\tsignature   string\n\t\tsigVerifier signature.Verifier\n\t\tcert        *x509.Certificate\n\t\tbundlePath  string\n\t\t// If online lookups to Rekor are enabled\n\t\texperimental bool\n\t\t// The rekor entry response when Rekor is enabled\n\t\trekorEntry *models.LogEntry\n\t\tshouldErr  bool\n\t}{\n\t\t{\n\t\t\tname:         \"valid signature with public key\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tshouldErr:    false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - experimental no rekor fail\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: true,\n\t\t\trekorEntry:   nil,\n\t\t\tshouldErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - experimental rekor entry success\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: true,\n\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tpubKeyBytes, true),\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - good bundle provided\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tpubKeyBytes, true),\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - bad bundle SET\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *signer, blobBytes, []byte(blobSignature),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - bad bundle cert mismatch\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - bad bundle signature mismatch\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(makeSignature(blobBytes)),\n\t\t\t\tpubKeyBytes, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with public key - bad bundle msg & signature mismatch\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, otherBytes, []byte(otherSignature),\n\t\t\t\tpubKeyBytes, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid signature with public key\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    otherSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tshouldErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid signature with public key - experimental\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    otherSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: true,\n\t\t\tshouldErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\texperimental: false,\n\t\t\tshouldErr:    false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate - bad bundle cert mismatch\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tpubKeyBytes, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate - bad bundle signature mismatch\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(makeSignature(blobBytes)),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate - bad bundle msg & signature mismatch\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, otherBytes, []byte(otherSignature),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"invalid signature with unexpired certificate\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    otherSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\texperimental: false,\n\t\t\tshouldErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate - experimental\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: true,\n\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: false,\n\t\t},\n\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate - experimental & rekor entry found\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\texperimental: true,\n\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tcert:         expiredLeafCert,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tshouldErr:    true,\n\t\t},\n\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - experimental good rekor lookup\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         expiredLeafCert,\n\t\t\texperimental: true,\n\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, true),\n\t\t\tshouldErr: false,\n\t\t},\n\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - experimental bad rekor integrated time\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tcert:         expiredLeafCert,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: true,\n\t\t\trekorEntry: makeRekorEntry(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, false),\n\t\t\tshouldErr: true,\n\t\t},\n\n\t\t{\n\t\t\tname:         \"valid signature with unexpired certificate - good bundle, nonexperimental\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tcert:         unexpiredLeafCert,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\tunexpiredCertPem, true),\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - good bundle, nonexperimental\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tcert:         expiredLeafCert,\n\t\t\tsigVerifier:  signer,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, true),\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - bundle with bad expiration\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         expiredLeafCert,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, false),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - bundle with bad SET\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         expiredLeafCert,\n\t\t\texperimental: false,\n\t\t\tbundlePath: makeLocalBundle(t, *signer, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - experimental good bundle\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         expiredLeafCert,\n\t\t\texperimental: true,\n\t\t\tbundlePath: makeLocalBundle(t, *rekorSigner, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, true),\n\t\t\tshouldErr: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"valid signature with expired certificate - experimental bad rekor entry\",\n\t\t\tblob:         blobBytes,\n\t\t\tsignature:    blobSignature,\n\t\t\tsigVerifier:  signer,\n\t\t\tcert:         expiredLeafCert,\n\t\t\texperimental: true,\n\t\t\t// This is the wrong signer for the SET!\n\t\t\trekorEntry: makeRekorEntry(t, *signer, blobBytes, []byte(blobSignature),\n\t\t\t\texpiredLeafPem, true),\n\t\t\tshouldErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tts {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttt := tt\n\t\t\tvar mClient client.Rekor\n\t\t\tmClient.Entries = &mock.EntriesClient{Entries: tt.rekorEntry}\n\t\t\tco := &cosign.CheckOpts{\n\t\t\t\tSigVerifier: tt.sigVerifier,\n\t\t\t\tRootCerts:   rootPool,\n\t\t\t}\n\t\t\t// if expermental is enabled, add RekorClient to co.\n\t\t\tif tt.experimental {\n\t\t\t\tco.RekorClient = &mClient\n\t\t\t}\n\n\t\t\terr := verifyBlob(ctx, co, tt.blob, tt.signature, tt.cert, tt.bundlePath, nil)\n\t\t\tif (err != nil) != tt.shouldErr {\n\t\t\t\tt.Fatalf(\"verifyBlob()= %s, expected shouldErr=%t \", err, tt.shouldErr)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc makeRekorEntry(t *testing.T, rekorSigner signature.ECDSASignerVerifier,\n\tpyld, sig, svBytes []byte, expiryValid bool) *models.LogEntry {\n\tctx := context.Background()\n\t// Calculate log ID, the digest of the Rekor public key\n\tlogID, err := getLogID(rekorSigner.Public())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thashedrekord := &hashedrekord_v001.V001Entry{}\n\th := sha256.Sum256(pyld)\n\tpe, err := hashedrekord.CreateFromArtifactProperties(ctx, types.ArtifactProperties{\n\t\tArtifactHash:   hex.EncodeToString(h[:]),\n\t\tSignatureBytes: sig,\n\t\tPublicKeyBytes: svBytes,\n\t\tPKIFormat:      \"x509\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tentry, err := types.NewEntry(pe)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tleaf, err := entry.Canonicalize(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tintegratedTime := time.Now()\n\tcerts, _ := cryptoutils.UnmarshalCertificatesFromPEM(svBytes)\n\tif certs != nil && len(certs) > 0 {\n\t\tif expiryValid {\n\t\t\tintegratedTime = certs[0].NotAfter.Add(-time.Second)\n\t\t} else {\n\t\t\tintegratedTime = certs[0].NotAfter.Add(time.Second)\n\t\t}\n\t}\n\te := models.LogEntryAnon{\n\t\tBody:           base64.StdEncoding.EncodeToString(leaf),\n\t\tIntegratedTime: swag.Int64(integratedTime.Unix()),\n\t\tLogIndex:       swag.Int64(0),\n\t\tLogID:          swag.String(logID),\n\t}\n\t// Marshal payload, sign, and set SET in Bundle\n\tjsonPayload, err := json.Marshal(e)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(jsonPayload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbundleSig, err := rekorSigner.SignMessage(bytes.NewReader(canonicalized))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tuuid, _ := cosign.ComputeLeafHash(&e)\n\n\te.Verification = &models.LogEntryAnonVerification{\n\t\tSignedEntryTimestamp: bundleSig,\n\t\tInclusionProof: &models.InclusionProof{\n\t\t\tLogIndex: swag.Int64(0),\n\t\t\tTreeSize: swag.Int64(1),\n\t\t\tRootHash: swag.String(hex.EncodeToString(uuid)),\n\t\t\tHashes:   []string{},\n\t\t},\n\t}\n\treturn &models.LogEntry{hex.EncodeToString(uuid): e}\n}\n\nfunc makeLocalBundle(t *testing.T, rekorSigner signature.ECDSASignerVerifier,\n\tpyld []byte, sig []byte, svBytes []byte, expiryValid bool) string {\n\ttd := t.TempDir()\n\n\t// Create bundle.\n\tentry := makeRekorEntry(t, rekorSigner, pyld, sig, svBytes, expiryValid)\n\tvar e models.LogEntryAnon\n\tfor _, v := range *entry {\n\t\te = v\n\t}\n\tb := cosign.LocalSignedPayload{\n\t\tBase64Signature: base64.StdEncoding.EncodeToString(sig),\n\t\tCert:            string(svBytes),\n\t\tBundle: &bundle.RekorBundle{\n\t\t\tPayload: bundle.RekorPayload{\n\t\t\t\tBody:           e.Body,\n\t\t\t\tIntegratedTime: *e.IntegratedTime,\n\t\t\t\tLogIndex:       *e.LogIndex,\n\t\t\t\tLogID:          *e.LogID,\n\t\t\t},\n\t\t\tSignedEntryTimestamp: e.Verification.SignedEntryTimestamp,\n\t\t},\n\t}\n\n\t// Write bundle to disk\n\tjsonBundle, err := json.Marshal(b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbundlePath := filepath.Join(td, \"bundle.sig\")\n\tif err := os.WriteFile(bundlePath, jsonBundle, 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn bundlePath\n}\n\nfunc TestVerifyBlobCmdWithBundle(t *testing.T) {\n\tkeyless := newKeylessStack(t)\n\n\tt.Run(\"Normal verification\", func(t *testing.T) {\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\n\t\t// Create blob\n\t\tblob := \"someblob\"\n\n\t\t// Sign blob with private key\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n\t\t\tidentity, /*certEmail*/\n\t\t\tissuer,   /*certOidcIssuer*/\n\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath, /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\tt.Run(\"Mismatched cert/sig\", func(t *testing.T) {\n\t\t// This test ensures that the signature and cert at the top level in the LocalSignedPayload must be identical to the ones in the RekorBundle.\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\t\t_, _, leafPemCert2, signer2 := keyless.genLeafCert(t, identity, issuer)\n\n\t\t// Create blob\n\t\tblob := \"someblob\"\n\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tsig2, err := signer2.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert2, sig2)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n\t\t\t\"\",       /*certEmail*/\n\t\t\t\"\",       /*certOidcIssuer*/\n\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath, /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expecting err due to mismatched signatures, got nil\")\n\t\t}\n\t})\n\tt.Run(\"Expired cert\", func(t *testing.T) {\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\n\t\t// Create blob\n\t\tblob := \"someblob\"\n\n\t\t// Sign blob with private key\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()-1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n\t\t\t\"\",       /*certEmail*/\n\t\t\t\"\",       /*certOidcIssuer*/\n\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath, /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected error due to expired cert, received nil\")\n\t\t}\n\t})\n\tt.Run(\"Attestation\", func(t *testing.T) {\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\n\t\tstmt := `{\"_type\":\"https://in-toto.io/Statement/v0.1\",\"predicateType\":\"customFoo\",\"subject\":[{\"name\":\"subject\",\"digest\":{\"sha256\":\"deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef\"}}],\"predicate\":{}}`\n\t\twrapped := dsse.WrapSigner(signer, ctypes.IntotoPayloadType)\n\t\tsignedPayload, err := wrapped.SignMessage(bytes.NewReader([]byte(stmt)), signatureoptions.WithContext(context.Background()))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// intoto sig = json-serialized dsse envelope\n\t\tsig := signedPayload\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, intoto.KIND, intoto.New().DefaultVersion(), signedPayload, leafPemCert, sig)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, string(signedPayload), \"attestation.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n\t\t\t\"\",       /*certEmail*/\n\t\t\t\"\",       /*certOidcIssuer*/\n\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath, /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t})\n\tt.Run(\"Invalid blob signature\", func(t *testing.T) {\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\n\t\t// Create blob\n\t\tblob := \"someblob\"\n\n\t\t// Sign blob with private key\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = []byte{'i', 'n', 'v', 'a', 'l', 'i', 'd'}\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",       /*certRef*/ // Cert is fetched from bundle\n\t\t\t\"\",       /*certEmail*/\n\t\t\t\"\",       /*certOidcIssuer*/\n\t\t\t\"\",       /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",       /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath, /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err == nil || !strings.Contains(err.Error(), \"unable to verify SET\") {\n\t\t\tt.Fatalf(\"expected error verifying SET, got %v\", err)\n\t\t}\n\t})\n\tt.Run(\"Mismatched certificate email\", func(t *testing.T) {\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\n\t\t// Create blob\n\t\tblob := \"someblob\"\n\n\t\t// Sign blob with private key\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",                    /*certRef*/ // Cert is fetched from bundle\n\t\t\t\"invalid@example.com\", /*certEmail*/\n\t\t\tissuer,                /*certOidcIssuer*/\n\t\t\t\"\",                    /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",                    /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath,              /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err == nil || !strings.Contains(err.Error(), \"expected email not found in certificate\") {\n\t\t\tt.Fatalf(\"expected error with mismatched identity, got %v\", err)\n\t\t}\n\t})\n\tt.Run(\"Mismatched certificate issuer\", func(t *testing.T) {\n\t\tidentity := \"hello@foo.com\"\n\t\tissuer := \"issuer\"\n\t\tleafCert, _, leafPemCert, signer := keyless.genLeafCert(t, identity, issuer)\n\n\t\t// Create blob\n\t\tblob := \"someblob\"\n\n\t\t// Sign blob with private key\n\t\tsig, err := signer.SignMessage(bytes.NewReader([]byte(blob)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Create bundle\n\t\tentry := genRekorEntry(t, hashedrekord.KIND, hashedrekord.New().DefaultVersion(), []byte(blob), leafPemCert, sig)\n\t\tb := createBundle(t, sig, leafPemCert, keyless.rekorLogID, leafCert.NotBefore.Unix()+1, entry)\n\t\tb.Bundle.SignedEntryTimestamp = keyless.rekorSignPayload(t, b.Bundle.Payload)\n\t\tbundlePath := writeBundleFile(t, keyless.td, b, \"bundle.json\")\n\t\tblobPath := writeBlobFile(t, keyless.td, blob, \"blob.txt\")\n\n\t\t// Verify command\n\t\terr = VerifyBlobCmd(context.Background(),\n\t\t\toptions.KeyOpts{BundlePath: bundlePath},\n\t\t\t\"\",        /*certRef*/ // Cert is fetched from bundle\n\t\t\tidentity,  /*certEmail*/\n\t\t\t\"invalid\", /*certOidcIssuer*/\n\t\t\t\"\",        /*certChain*/ // Chain is fetched from TUF/SIGSTORE_ROOT_FILE\n\t\t\t\"\",        /*sigRef*/    // Sig is fetched from bundle\n\t\t\tblobPath,  /*blobRef*/\n\t\t\t// GitHub identity flags start\n\t\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\t// GitHub identity flags end\n\t\t\tfalse /*enforceSCT*/)\n\t\tif err == nil || !strings.Contains(err.Error(), \"expected oidc issuer not found in certificate\") {\n\t\t\tt.Fatalf(\"expected error with mismatched issuer, got %v\", err)\n\t\t}\n\t})\n}\n\ntype keylessStack struct {\n\trootCert    *x509.Certificate\n\trootPriv    *ecdsa.PrivateKey\n\trootPemCert []byte\n\tsubCert     *x509.Certificate\n\tsubPriv     *ecdsa.PrivateKey\n\tsubPemCert  []byte\n\trekorSigner *signature.ECDSASignerVerifier\n\trekorLogID  string\n\ttd          string // temporary directory\n}\n\nfunc newKeylessStack(t *testing.T) *keylessStack {\n\tstack := &keylessStack{td: t.TempDir()}\n\tstack.rootCert, stack.rootPriv, _ = test.GenerateRootCa()\n\tstack.rootPemCert, _ = cryptoutils.MarshalCertificateToPEM(stack.rootCert)\n\tstack.subCert, stack.subPriv, _ = test.GenerateSubordinateCa(stack.rootCert, stack.rootPriv)\n\tstack.subPemCert, _ = cryptoutils.MarshalCertificateToPEM(stack.subCert)\n\n\tstack.genChainFile(t)\n\tstack.genRekor(t)\n\treturn stack\n}\n\nfunc (s *keylessStack) genLeafCert(t *testing.T, subject string, issuer string) (*x509.Certificate, *ecdsa.PrivateKey, []byte, *signature.ECDSASignerVerifier) {\n\tcert, priv, _ := test.GenerateLeafCert(subject, issuer, s.subCert, s.subPriv)\n\tpemCert, _ := cryptoutils.MarshalCertificateToPEM(cert)\n\tsigner, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn cert, priv, pemCert, signer\n}\n\nfunc (s *keylessStack) genChainFile(t *testing.T) {\n\tvar chain []byte\n\tchain = append(chain, s.subPemCert...)\n\tchain = append(chain, s.rootPemCert...)\n\ttmpChainFile, err := os.CreateTemp(s.td, \"cosign_fulcio_chain_*.cert\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp chain file: %v\", err)\n\t}\n\tdefer tmpChainFile.Close()\n\tif _, err := tmpChainFile.Write(chain); err != nil {\n\t\tt.Fatalf(\"failed to write chain file: %v\", err)\n\t}\n\t// Override for Fulcio root so it doesn't use TUF\n\tt.Setenv(\"SIGSTORE_ROOT_FILE\", tmpChainFile.Name())\n}\n\nfunc (s *keylessStack) genRekor(t *testing.T) {\n\t// Create Rekor private key and write to disk\n\trekorPriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts.rekorSigner, err = signature.LoadECDSASignerVerifier(rekorPriv, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trekorPub := s.rekorSigner.Public()\n\tpemRekor, err := cryptoutils.MarshalPublicKeyToPEM(rekorPub)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmpRekorPubFile, err := os.CreateTemp(s.td, \"cosign_rekor_pub_*.key\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp rekor pub file: %v\", err)\n\t}\n\tdefer tmpRekorPubFile.Close()\n\tif _, err := tmpRekorPubFile.Write(pemRekor); err != nil {\n\t\tt.Fatalf(\"failed to write rekor pub file: %v\", err)\n\t}\n\n\t// Calculate log ID, the digest of the Rekor public key\n\ts.rekorLogID, err = getLogID(rekorPub)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Override for Rekor public key so it doesn't use TUF\n\tt.Setenv(\"SIGSTORE_REKOR_PUBLIC_KEY\", tmpRekorPubFile.Name())\n}\nfunc (s *keylessStack) rekorSignPayload(t *testing.T, payload bundle.RekorPayload) []byte {\n\t// Marshal payload, sign, and return SET\n\tjsonPayload, err := json.Marshal(payload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(jsonPayload)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbundleSig, err := s.rekorSigner.SignMessage(bytes.NewReader(canonicalized))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn bundleSig\n}\n\n// getLogID calculates the digest of a PKIX-encoded public key\nfunc getLogID(pub crypto.PublicKey) (string, error) {\n\tpubBytes, err := x509.MarshalPKIXPublicKey(pub)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdigest := sha256.Sum256(pubBytes)\n\treturn hex.EncodeToString(digest[:]), nil\n}\n\nfunc genRekorEntry(t *testing.T, kind, version string, artifact []byte, cert []byte, sig []byte) string {\n\t// Generate the Rekor Entry\n\tentryImpl, err := createEntry(context.Background(), kind, version, artifact, cert, sig)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tentryBytes, err := entryImpl.Canonicalize(context.Background())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn base64.StdEncoding.EncodeToString(entryBytes)\n}\n\nfunc createBundle(t *testing.T, sig []byte, certPem []byte, logID string, integratedTime int64, rekorEntry string) *cosign.LocalSignedPayload {\n\t// Create bundle with:\n\t// * Blob signature\n\t// * Signing certificate\n\t// * Bundle with a payload and signature over the payload\n\tb := &cosign.LocalSignedPayload{\n\t\tBase64Signature: base64.StdEncoding.EncodeToString(sig),\n\t\tCert:            string(certPem),\n\t\tBundle: &bundle.RekorBundle{\n\t\t\tSignedEntryTimestamp: []byte{},\n\t\t\tPayload: bundle.RekorPayload{\n\t\t\t\tLogID:          logID,\n\t\t\t\tIntegratedTime: integratedTime,\n\t\t\t\tLogIndex:       1,\n\t\t\t\tBody:           rekorEntry,\n\t\t\t},\n\t\t},\n\t}\n\n\treturn b\n}\n\nfunc createEntry(ctx context.Context, kind, apiVersion string, blobBytes, certBytes, sigBytes []byte) (types.EntryImpl, error) {\n\tprops := types.ArtifactProperties{\n\t\tPublicKeyBytes: certBytes,\n\t\tPKIFormat:      string(pki.X509),\n\t}\n\tswitch kind {\n\tcase rekord.KIND:\n\t\tprops.ArtifactBytes = blobBytes\n\t\tprops.SignatureBytes = sigBytes\n\tcase hashedrekord.KIND:\n\t\tblobHash := sha256.Sum256(blobBytes)\n\t\tprops.ArtifactHash = strings.ToLower(hex.EncodeToString(blobHash[:]))\n\t\tprops.SignatureBytes = sigBytes\n\tcase intoto.KIND:\n\t\tprops.ArtifactBytes = blobBytes\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected entry kind: %s\", kind)\n\t}\n\tproposedEntry, err := types.NewProposedEntry(ctx, kind, apiVersion, props)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn types.NewEntry(proposedEntry)\n}\n\nfunc writeBundleFile(t *testing.T, td string, b *cosign.LocalSignedPayload, name string) string {\n\t// Write bundle to disk\n\tjsonBundle, err := json.Marshal(b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbundlePath := filepath.Join(td, name)\n\tif err := os.WriteFile(bundlePath, jsonBundle, 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn bundlePath\n}\n\nfunc writeBlobFile(t *testing.T, td string, blob string, name string) string {\n\t// Write blob to disk\n\tblobPath := filepath.Join(td, name)\n\tif err := os.WriteFile(blobPath, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn blobPath\n}\n", "// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage mock\n\nimport (\n\t\"errors\"\n\n\t\"github.com/go-openapi/runtime\"\n\n\t\"github.com/sigstore/rekor/pkg/generated/client/entries\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n)\n\n// EntriesClient is a client that implements entries.ClientService for Rekor\n// To use:\n// var mClient client.Rekor\n// mClient.Entries = &logEntry\ntype EntriesClient struct {\n\tEntries *models.LogEntry\n}\n\nfunc (m *EntriesClient) CreateLogEntry(params *entries.CreateLogEntryParams, opts ...entries.ClientOption) (*entries.CreateLogEntryCreated, error) {\n\tif m.Entries != nil {\n\t\treturn &entries.CreateLogEntryCreated{\n\t\t\tETag:     \"\",\n\t\t\tLocation: \"\",\n\t\t\tPayload:  *m.Entries,\n\t\t}, nil\n\t}\n\treturn nil, errors.New(\"entry not provided\")\n}\n\nfunc (m *EntriesClient) GetLogEntryByIndex(params *entries.GetLogEntryByIndexParams, opts ...entries.ClientOption) (*entries.GetLogEntryByIndexOK, error) {\n\tif m.Entries != nil {\n\t\treturn &entries.GetLogEntryByIndexOK{\n\t\t\tPayload: *m.Entries,\n\t\t}, nil\n\t}\n\treturn nil, errors.New(\"entry not provided\")\n}\n\nfunc (m *EntriesClient) GetLogEntryByUUID(params *entries.GetLogEntryByUUIDParams, opts ...entries.ClientOption) (*entries.GetLogEntryByUUIDOK, error) {\n\tif m.Entries != nil {\n\t\treturn &entries.GetLogEntryByUUIDOK{\n\t\t\tPayload: *m.Entries,\n\t\t}, nil\n\t}\n\treturn nil, errors.New(\"entry not provided\")\n}\n\nfunc (m *EntriesClient) SearchLogQuery(params *entries.SearchLogQueryParams, opts ...entries.ClientOption) (*entries.SearchLogQueryOK, error) {\n\tresp := []models.LogEntry{}\n\tif m.Entries != nil {\n\t\tresp = append(resp, *m.Entries)\n\t}\n\treturn &entries.SearchLogQueryOK{\n\t\tPayload: resp,\n\t}, nil\n}\n\n// TODO: Implement mock\nfunc (m *EntriesClient) SetTransport(transport runtime.ClientTransport) {\n}\n", "// Copyright 2022 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage rekor\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/go-openapi/swag\"\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/payload\"\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n)\n\nfunc mustGetNewSigner(t *testing.T) signature.Signer {\n\tt.Helper()\n\tpriv, err := cosign.GeneratePrivateKey()\n\tif err != nil {\n\t\tt.Fatalf(\"cosign.GeneratePrivateKey() failed: %v\", err)\n\t}\n\ts, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"signature.LoadECDSASignerVerifier(key, crypto.SHA256) failed: %v\", err)\n\t}\n\treturn s\n}\n\nfunc TestSigner(t *testing.T) {\n\t// Need real cert and chain\n\tpayloadSigner := payload.NewSigner(mustGetNewSigner(t))\n\n\t// Mock out Rekor client\n\tvar mClient client.Rekor\n\n\tmClient.Entries = &mock.EntriesClient{\n\t\tEntries: &models.LogEntry{\"123\": models.LogEntryAnon{\n\t\t\tLogIndex: swag.Int64(123),\n\t\t}},\n\t}\n\n\ttestSigner := NewSigner(payloadSigner, &mClient)\n\n\ttestPayload := \"test payload\"\n\n\tociSig, pub, err := testSigner.Sign(context.Background(), strings.NewReader(testPayload))\n\tif err != nil {\n\t\tt.Fatalf(\"Sign() returned error: %v\", err)\n\t}\n\n\t// Verify that the wrapped signer was called.\n\tverifier, err := signature.LoadVerifier(pub, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"signature.LoadVerifier(pub) returned error: %v\", err)\n\t}\n\tb64Sig, err := ociSig.Base64Signature()\n\tif err != nil {\n\t\tt.Fatalf(\"ociSig.Base64Signature() returned error: %v\", err)\n\t}\n\tsig, err := base64.StdEncoding.DecodeString(b64Sig)\n\tif err != nil {\n\t\tt.Fatalf(\"base64.StdEncoding.DecodeString(b64Sig) returned error: %v\", err)\n\t}\n\tgotPayload, err := ociSig.Payload()\n\tif err != nil {\n\t\tt.Fatalf(\"ociSig.Payload() returned error: %v\", err)\n\t}\n\tif string(gotPayload) != testPayload {\n\t\tt.Errorf(\"ociSig.Payload() returned %q, wanted %q\", string(gotPayload), testPayload)\n\t}\n\tif err = verifier.VerifySignature(bytes.NewReader(sig), bytes.NewReader(gotPayload)); err != nil {\n\t\tt.Errorf(\"VerifySignature() returned error: %v\", err)\n\t}\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio/fulcioverifier/ctl\"\n\tcbundle \"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/sigstore/pkg/tuf\"\n\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/cosign/pkg/oci/layout\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n\tsigPayload \"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\n// Identity specifies an issuer/subject to verify a signature against.\n// Both IssuerRegExp/SubjectRegExp support regexp while Issuer/Subject are for\n// strict matching.\ntype Identity struct {\n\tIssuer        string\n\tSubject       string\n\tIssuerRegExp  string\n\tSubjectRegExp string\n}\n\n// CheckOpts are the options for checking signatures.\ntype CheckOpts struct {\n\t// RegistryClientOpts are the options for interacting with the container registry.\n\tRegistryClientOpts []ociremote.Option\n\n\t// Annotations optionally specifies image signature annotations to verify.\n\tAnnotations map[string]interface{}\n\n\t// ClaimVerifier, if provided, verifies claims present in the oci.Signature.\n\tClaimVerifier func(sig oci.Signature, imageDigest v1.Hash, annotations map[string]interface{}) error\n\n\t// RekorClient, if set, is used to use to verify signatures and public keys.\n\tRekorClient *client.Rekor\n\n\t// SigVerifier is used to verify signatures.\n\tSigVerifier signature.Verifier\n\t// PKOpts are the options provided to `SigVerifier.PublicKey()`.\n\tPKOpts []signature.PublicKeyOption\n\n\t// RootCerts are the root CA certs used to verify a signature's chained certificate.\n\tRootCerts *x509.CertPool\n\t// IntermediateCerts are the optional intermediate CA certs used to verify a certificate chain.\n\tIntermediateCerts *x509.CertPool\n\t// CertEmail is the email expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertEmail string\n\t// CertOidcIssuer is the OIDC issuer expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertOidcIssuer string\n\n\t// CertGithubWorkflowTrigger is the GitHub Workflow Trigger name expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowTrigger string\n\t// CertGithubWorkflowSha is the GitHub Workflow SHA expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowSha string\n\t// CertGithubWorkflowName is the GitHub Workflow Name expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowName string\n\t// CertGithubWorkflowRepository is the GitHub Workflow Repository  expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowRepository string\n\t// CertGithubWorkflowRef is the GitHub Workflow Ref expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertGithubWorkflowRef string\n\n\t// EnforceSCT requires that a certificate contain an embedded SCT during verification. An SCT is proof of inclusion in a\n\t// certificate transparency log.\n\tEnforceSCT bool\n\n\t// SignatureRef is the reference to the signature file\n\tSignatureRef string\n\n\t// Identities is an array of Identity (Subject, Issuer) matchers that have\n\t// to be met for the signature to ve valid.\n\t// Supercedes CertEmail / CertOidcIssuer\n\tIdentities []Identity\n}\n\nfunc getSignedEntity(signedImgRef name.Reference, regClientOpts []ociremote.Option) (oci.SignedEntity, v1.Hash, error) {\n\tse, err := ociremote.SignedEntity(signedImgRef, regClientOpts...)\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\t// Both of the SignedEntity types implement Digest()\n\th, err := se.(interface{ Digest() (v1.Hash, error) }).Digest()\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\treturn se, h, nil\n}\n\nfunc verifyOCISignature(ctx context.Context, verifier signature.Verifier, sig oci.Signature) error {\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsignature, err := base64.StdEncoding.DecodeString(b64sig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(payload), options.WithContext(ctx))\n}\n\n// For unit testing\ntype payloader interface {\n\tPayload() ([]byte, error)\n}\n\nfunc verifyOCIAttestation(_ context.Context, verifier signature.Verifier, att payloader) error {\n\tpayload, err := att.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tenv := ssldsse.Envelope{}\n\tif err := json.Unmarshal(payload, &env); err != nil {\n\t\treturn err\n\t}\n\n\tif env.PayloadType != types.IntotoPayloadType {\n\t\treturn NewVerificationError(\"invalid payloadType %s on envelope. Expected %s\", env.PayloadType, types.IntotoPayloadType)\n\t}\n\tdssev, err := ssldsse.NewEnvelopeVerifier(&dsse.VerifierAdapter{SignatureVerifier: verifier})\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = dssev.Verify(&env)\n\treturn err\n}\n\n// ValidateAndUnpackCert creates a Verifier from a certificate. Veries that the certificate\n// chains up to a trusted root. Optionally verifies the subject and issuer of the certificate.\nfunc ValidateAndUnpackCert(cert *x509.Certificate, co *CheckOpts) (signature.Verifier, error) {\n\tverifier, err := signature.LoadVerifier(cert.PublicKey, crypto.SHA256)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid certificate found on signature: %w\", err)\n\t}\n\n\t// Now verify the cert, then the signature.\n\tchains, err := TrustedCert(cert, co.RootCerts, co.IntermediateCerts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = CheckCertificatePolicy(cert, co)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcontains, err := ctl.ContainsSCT(cert.Raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif co.EnforceSCT && !contains {\n\t\treturn nil, &VerificationError{\"certificate does not include required embedded SCT\"}\n\t}\n\tif contains {\n\t\t// handle if chains has more than one chain - grab first and print message\n\t\tif len(chains) > 1 {\n\t\t\tfmt.Fprintf(os.Stderr, \"**Info** Multiple valid certificate chains found. Selecting the first to verify the SCT.\\n\")\n\t\t}\n\t\tif err := ctl.VerifyEmbeddedSCT(context.Background(), chains[0]); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn verifier, nil\n}\n\n// CheckCertificatePolicy checks that the certificate subject and issuer match\n// the expected values.\nfunc CheckCertificatePolicy(cert *x509.Certificate, co *CheckOpts) error {\n\tce := CertExtensions{Cert: cert}\n\tif co.CertEmail != \"\" {\n\t\temailVerified := false\n\t\tfor _, em := range cert.EmailAddresses {\n\t\t\tif co.CertEmail == em {\n\t\t\t\temailVerified = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !emailVerified {\n\t\t\treturn &VerificationError{\"expected email not found in certificate\"}\n\t\t}\n\t}\n\n\tif err := validateCertExtensions(ce, co); err != nil {\n\t\treturn err\n\t}\n\tissuer := ce.GetIssuer()\n\t// If there are identities given, go through them and if one of them\n\t// matches, call that good, otherwise, return an error.\n\tif len(co.Identities) > 0 {\n\t\tfor _, identity := range co.Identities {\n\t\t\tissuerMatches := false\n\t\t\tswitch {\n\t\t\t// Check the issuer first\n\t\t\tcase identity.IssuerRegExp != \"\":\n\t\t\t\tif regex, err := regexp.Compile(identity.IssuerRegExp); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"malformed issuer in identity: %s : %w\", identity.IssuerRegExp, err)\n\t\t\t\t} else if regex.MatchString(issuer) {\n\t\t\t\t\tissuerMatches = true\n\t\t\t\t}\n\t\t\tcase identity.Issuer != \"\":\n\t\t\t\tif identity.Issuer == issuer {\n\t\t\t\t\tissuerMatches = true\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// No issuer constraint on this identity, so checks out\n\t\t\t\tissuerMatches = true\n\t\t\t}\n\n\t\t\t// Then the subject\n\t\t\tsubjectMatches := false\n\t\t\tswitch {\n\t\t\tcase identity.SubjectRegExp != \"\":\n\t\t\t\tregex, err := regexp.Compile(identity.SubjectRegExp)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"malformed subject in identity: %s : %w\", identity.SubjectRegExp, err)\n\t\t\t\t}\n\t\t\t\tfor _, san := range getSubjectAlternateNames(cert) {\n\t\t\t\t\tif regex.MatchString(san) {\n\t\t\t\t\t\tsubjectMatches = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase identity.Subject != \"\":\n\t\t\t\tfor _, san := range getSubjectAlternateNames(cert) {\n\t\t\t\t\tif san == identity.Subject {\n\t\t\t\t\t\tsubjectMatches = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// No subject constraint on this identity, so checks out\n\t\t\t\tsubjectMatches = true\n\t\t\t}\n\t\t\tif subjectMatches && issuerMatches {\n\t\t\t\t// If both issuer / subject match, return verifier\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn &VerificationError{\"none of the expected identities matched what was in the certificate\"}\n\t}\n\treturn nil\n}\n\nfunc validateCertExtensions(ce CertExtensions, co *CheckOpts) error {\n\tif co.CertOidcIssuer != \"\" {\n\t\tif ce.GetIssuer() != co.CertOidcIssuer {\n\t\t\treturn &VerificationError{\"expected oidc issuer not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowTrigger != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowTrigger() != co.CertGithubWorkflowTrigger {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Trigger not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowSha != \"\" {\n\t\tif ce.GetExtensionGithubWorkflowSha() != co.CertGithubWorkflowSha {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow SHA not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowName != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowName() != co.CertGithubWorkflowName {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Name not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowRepository != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowRepository() != co.CertGithubWorkflowRepository {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Repository not found in certificate\"}\n\t\t}\n\t}\n\n\tif co.CertGithubWorkflowRef != \"\" {\n\t\tif ce.GetCertExtensionGithubWorkflowRef() != co.CertGithubWorkflowRef {\n\t\t\treturn &VerificationError{\"expected GitHub Workflow Ref not found in certificate\"}\n\t\t}\n\t}\n\treturn nil\n}\n\n// getSubjectAlternateNames returns all of the following for a Certificate.\n// DNSNames\n// EmailAddresses\n// IPAddresses\n// URIs\nfunc getSubjectAlternateNames(cert *x509.Certificate) []string {\n\tsans := []string{}\n\tsans = append(sans, cert.DNSNames...)\n\tsans = append(sans, cert.EmailAddresses...)\n\tfor _, ip := range cert.IPAddresses {\n\t\tsans = append(sans, ip.String())\n\t}\n\tfor _, uri := range cert.URIs {\n\t\tsans = append(sans, uri.String())\n\t}\n\treturn sans\n}\n\n// ValidateAndUnpackCertWithChain creates a Verifier from a certificate. Verifies that the certificate\n// chains up to the provided root. Chain should start with the parent of the certificate and end with the root.\n// Optionally verifies the subject and issuer of the certificate.\nfunc ValidateAndUnpackCertWithChain(cert *x509.Certificate, chain []*x509.Certificate, co *CheckOpts) (signature.Verifier, error) {\n\tif len(chain) == 0 {\n\t\treturn nil, errors.New(\"no chain provided to validate certificate\")\n\t}\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(chain[len(chain)-1])\n\tco.RootCerts = rootPool\n\n\tsubPool := x509.NewCertPool()\n\tfor _, c := range chain[:len(chain)-1] {\n\t\tsubPool.AddCert(c)\n\t}\n\tco.IntermediateCerts = subPool\n\n\treturn ValidateAndUnpackCert(cert, co)\n}\n\nfunc tlogValidatePublicKey(ctx context.Context, rekorClient *client.Rekor, pub crypto.PublicKey, sig oci.Signature) error {\n\tpemBytes, err := cryptoutils.MarshalPublicKeyToPEM(pub)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = tlogValidateEntry(ctx, rekorClient, sig, pemBytes)\n\treturn err\n}\n\nfunc tlogValidateCertificate(ctx context.Context, rekorClient *client.Rekor, sig oci.Signature) error {\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpemBytes, err := cryptoutils.MarshalCertificateToPEM(cert)\n\tif err != nil {\n\t\treturn err\n\t}\n\te, err := tlogValidateEntry(ctx, rekorClient, sig, pemBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// if we have a cert, we should check expiry\n\treturn CheckExpiry(cert, time.Unix(*e.IntegratedTime, 0))\n}\n\nfunc tlogValidateEntry(ctx context.Context, client *client.Rekor, sig oci.Signature, pem []byte) (*models.LogEntryAnon, error) {\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\te, err := FindTlogEntry(ctx, client, b64sig, payload, pem)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn e, VerifyTLogEntry(ctx, client, e)\n}\n\ntype fakeOCISignatures struct {\n\toci.Signatures\n\tsignatures []oci.Signature\n}\n\nfunc (fos *fakeOCISignatures) Get() ([]oci.Signature, error) {\n\treturn fos.signatures, nil\n}\n\n// VerifyImageSignatures does all the main cosign checks in a loop, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyImageSignatures(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar sigs oci.Signatures\n\tsigRef := co.SignatureRef\n\tif sigRef == \"\" {\n\t\tsigs, err = se.Signatures()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t} else {\n\t\tsigs, err = loadSignatureFromFile(sigRef, signedImgRef, co)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\n// VerifyLocalImageSignatures verifies signatures from a saved, local image, without any network calls, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageSignatures(ctx context.Context, path string, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tsigs, err := se.Signatures()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\nfunc verifySignatures(ctx context.Context, sigs oci.Signatures, h v1.Hash, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := sigs.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\n\tfor _, sig := range sl {\n\t\tverified, err := VerifyImageSignature(ctx, sig, h, co)\n\t\tbundleVerified = bundleVerified || verified\n\t\tif err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedSignatures = append(checkedSignatures, sig)\n\t}\n\tif len(checkedSignatures) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"%w:\\n%s\", ErrNoMatchingSignatures, strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedSignatures, bundleVerified, nil\n}\n\n// VerifyImageSignature verifies a signature\nfunc VerifyImageSignature(ctx context.Context, sig oci.Signature, h v1.Hash, co *CheckOpts) (bundleVerified bool, err error) {\n\tverifier := co.SigVerifier\n\tif verifier == nil {\n\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\tcert, err := sig.Cert()\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t\tif cert == nil {\n\t\t\treturn bundleVerified, &VerificationError{\"no certificate found on signature\"}\n\t\t}\n\t\t// Create a certificate pool for intermediate CA certificates, excluding the root\n\t\tchain, err := sig.Chain()\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t\t// If the chain annotation is not present or there is only a root\n\t\tif chain == nil || len(chain) <= 1 {\n\t\t\tco.IntermediateCerts = nil\n\t\t} else if co.IntermediateCerts == nil {\n\t\t\t// If the intermediate certs have not been loaded in by TUF\n\t\t\tpool := x509.NewCertPool()\n\t\t\tfor _, cert := range chain[:len(chain)-1] {\n\t\t\t\tpool.AddCert(cert)\n\t\t\t}\n\t\t\tco.IntermediateCerts = pool\n\t\t}\n\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tif err := verifyOCISignature(ctx, verifier, sig); err != nil {\n\t\treturn bundleVerified, err\n\t}\n\n\t// We can't check annotations without claims, both require unmarshalling the payload.\n\tif co.ClaimVerifier != nil {\n\t\tif err := co.ClaimVerifier(sig, h, co.Annotations); err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tbundleVerified, err = VerifyBundle(ctx, sig, co.RekorClient)\n\tif err != nil && co.RekorClient == nil {\n\t\treturn false, fmt.Errorf(\"unable to verify bundle: %w\", err)\n\t}\n\n\tif !bundleVerified && co.RekorClient != nil {\n\t\tif co.SigVerifier != nil {\n\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn bundleVerified, err\n\t\t\t}\n\t\t\treturn bundleVerified, tlogValidatePublicKey(ctx, co.RekorClient, pub, sig)\n\t\t}\n\n\t\treturn bundleVerified, tlogValidateCertificate(ctx, co.RekorClient, sig)\n\t}\n\n\treturn bundleVerified, nil\n}\n\nfunc loadSignatureFromFile(sigRef string, signedImgRef name.Reference, co *CheckOpts) (oci.Signatures, error) {\n\tvar b64sig string\n\ttargetSig, err := blob.LoadFileOrURL(sigRef)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\ttargetSig = []byte(sigRef)\n\t}\n\n\t_, err = base64.StdEncoding.DecodeString(string(targetSig))\n\n\tif err == nil {\n\t\tb64sig = string(targetSig)\n\t} else {\n\t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n\t}\n\n\tdigest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpayload, err := (&sigPayload.Cosign{Image: digest}).MarshalJSON()\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsig, err := static.NewSignature(payload, b64sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fakeOCISignatures{\n\t\tsignatures: []oci.Signature{sig},\n\t}, nil\n}\n\n// VerifyAttestations does all the main cosign checks in a loop, returning the verified attestations.\n// If there were no valid attestations, we return an error.\nfunc VerifyImageAttestations(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\n// VerifyLocalImageAttestations verifies attestations from a saved, local image, without any network calls,\n// returning the verified attestations.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageAttestations(ctx context.Context, path string, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\nfunc verifyImageAttestations(ctx context.Context, atts oci.Signatures, h v1.Hash, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := atts.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\tfor _, att := range sl {\n\t\tif err := func(att oci.Signature) error {\n\t\t\tverifier := co.SigVerifier\n\t\t\tif verifier == nil {\n\t\t\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\t\t\tcert, err := att.Cert()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif cert == nil {\n\t\t\t\t\treturn &VerificationError{\"no certificate found on attestation\"}\n\t\t\t\t}\n\t\t\t\t// Create a certificate pool for intermediate CA certificates, excluding the root\n\t\t\t\tchain, err := att.Chain()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\t// If the chain annotation is not present or there is only a root\n\t\t\t\tif chain == nil || len(chain) <= 1 {\n\t\t\t\t\tco.IntermediateCerts = nil\n\t\t\t\t} else if co.IntermediateCerts == nil {\n\t\t\t\t\t// If the intermediate certs have not been loaded in by TUF\n\t\t\t\t\tpool := x509.NewCertPool()\n\t\t\t\t\tfor _, cert := range chain[:len(chain)-1] {\n\t\t\t\t\t\tpool.AddCert(cert)\n\t\t\t\t\t}\n\t\t\t\t\tco.IntermediateCerts = pool\n\t\t\t\t}\n\t\t\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := verifyOCIAttestation(ctx, verifier, att); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// We can't check annotations without claims, both require unmarshalling the payload.\n\t\t\tif co.ClaimVerifier != nil {\n\t\t\t\tif err := co.ClaimVerifier(att, h, co.Annotations); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverified, err := VerifyBundle(ctx, att, co.RekorClient)\n\t\t\tif err != nil && co.RekorClient == nil {\n\t\t\t\treturn fmt.Errorf(\"unable to verify bundle: %w\", err)\n\t\t\t}\n\t\t\tbundleVerified = bundleVerified || verified\n\n\t\t\tif !verified && co.RekorClient != nil {\n\t\t\t\tif co.SigVerifier != nil {\n\t\t\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn tlogValidatePublicKey(ctx, co.RekorClient, pub, att)\n\t\t\t\t}\n\n\t\t\t\treturn tlogValidateCertificate(ctx, co.RekorClient, att)\n\t\t\t}\n\t\t\treturn nil\n\t\t}(att); err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedAttestations = append(checkedAttestations, att)\n\t}\n\tif len(checkedAttestations) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"%w:\\n%s\", ErrNoMatchingAttestations, strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedAttestations, bundleVerified, nil\n}\n\n// CheckExpiry confirms the time provided is within the valid period of the cert\nfunc CheckExpiry(cert *x509.Certificate, it time.Time) error {\n\tft := func(t time.Time) string {\n\t\treturn t.Format(time.RFC3339)\n\t}\n\tif cert.NotAfter.Before(it) {\n\t\treturn NewVerificationError(\"certificate expired before signatures were entered in log: %s is before %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\tif cert.NotBefore.After(it) {\n\t\treturn NewVerificationError(\"certificate was issued after signatures were entered in log: %s is after %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\treturn nil\n}\n\nfunc VerifyBundle(ctx context.Context, sig oci.Signature, rekorClient *client.Rekor) (bool, error) {\n\tbundle, err := sig.Bundle()\n\tif err != nil {\n\t\treturn false, err\n\t} else if bundle == nil {\n\t\treturn false, nil\n\t}\n\n\tif err := compareSigs(bundle.Payload.Body.(string), sig); err != nil {\n\t\treturn false, err\n\t}\n\n\tpublicKeys, err := GetRekorPubs(ctx, rekorClient)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"retrieving rekor public key: %w\", err)\n\t}\n\n\tpubKey, ok := publicKeys[bundle.Payload.LogID]\n\tif !ok {\n\t\treturn false, &VerificationError{\"rekor log public key not found for payload\"}\n\t}\n\terr = VerifySET(bundle.Payload, bundle.SignedEntryTimestamp, pubKey.PubKey)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif pubKey.Status != tuf.Active {\n\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n\t}\n\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif cert != nil {\n\t\t// Verify the cert against the integrated time.\n\t\t// Note that if the caller requires the certificate to be present, it has to ensure that itself.\n\t\tif err := CheckExpiry(cert, time.Unix(bundle.Payload.IntegratedTime, 0)); err != nil {\n\t\t\treturn false, fmt.Errorf(\"checking expiry on cert: %w\", err)\n\t\t}\n\t}\n\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"reading payload: %w\", err)\n\t}\n\tsignature, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"reading base64signature: %w\", err)\n\t}\n\n\talg, bundlehash, err := bundleHash(bundle.Payload.Body.(string), signature)\n\th := sha256.Sum256(payload)\n\tpayloadHash := hex.EncodeToString(h[:])\n\n\tif alg != \"sha256\" || bundlehash != payloadHash {\n\t\treturn false, fmt.Errorf(\"matching bundle to payload: %w\", err)\n\t}\n\treturn true, nil\n}\n\n// compare bundle signature to the signature we are verifying\nfunc compareSigs(bundleBody string, sig oci.Signature) error {\n\t// TODO(nsmith5): modify function signature to make it more clear _why_\n\t// we've returned nil (there are several reasons possible here).\n\tactualSig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"base64 signature: %w\", err)\n\t}\n\tif actualSig == \"\" {\n\t\t// NB: empty sig means this is an attestation\n\t\treturn nil\n\t}\n\tbundleSignature, err := bundleSig(bundleBody)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to extract signature from bundle: %w\", err)\n\t}\n\tif bundleSignature == \"\" {\n\t\treturn nil\n\t}\n\tif bundleSignature != actualSig {\n\t\treturn &VerificationError{\"signature in bundle does not match signature being verified\"}\n\t}\n\treturn nil\n}\n\nfunc bundleHash(bundleBody, signature string) (string, string, error) {\n\tvar toto models.Intoto\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar intotoObj models.IntotoV001Schema\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\t// The fact that there's no signature (or empty rather), implies\n\t// that this is an Attestation that we're verifying.\n\tif len(signature) == 0 {\n\t\terr = json.Unmarshal(bodyDecoded, &toto)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tspecMarshal, err := json.Marshal(toto.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &intotoObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\treturn *intotoObj.Content.Hash.Algorithm, *intotoObj.Content.Hash.Value, nil\n\t}\n\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &rekordObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\treturn *rekordObj.Data.Hash.Algorithm, *rekordObj.Data.Hash.Value, nil\n\t}\n\n\t// Try hashedRekordObj\n\terr = json.Unmarshal(bodyDecoded, &hrekord)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\terr = json.Unmarshal(specMarshal, &hrekordObj)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn *hrekordObj.Data.Hash.Algorithm, *hrekordObj.Data.Hash.Value, nil\n}\n\n// bundleSig extracts the signature from the rekor bundle body\nfunc bundleSig(bundleBody string) (string, error) {\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"decoding bundleBody: %w\", err)\n\t}\n\n\t// Try Rekord\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif err := json.Unmarshal(specMarshal, &rekordObj); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn rekordObj.Signature.Content.String(), nil\n\t}\n\n\t// Try hashedRekordObj\n\tif err := json.Unmarshal(bodyDecoded, &hrekord); err != nil {\n\t\treturn \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := json.Unmarshal(specMarshal, &hrekordObj); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hrekordObj.Signature.Content.String(), nil\n}\n\nfunc VerifySET(bundlePayload cbundle.RekorPayload, signature []byte, pub *ecdsa.PublicKey) error {\n\tcontents, err := json.Marshal(bundlePayload)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"marshaling: %w\", err)\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(contents)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"canonicalizing: %w\", err)\n\t}\n\n\t// verify the SET against the public key\n\thash := sha256.Sum256(canonicalized)\n\tif !ecdsa.VerifyASN1(pub, hash[:], signature) {\n\t\treturn &VerificationError{\"unable to verify SET\"}\n\t}\n\treturn nil\n}\n\nfunc TrustedCert(cert *x509.Certificate, roots *x509.CertPool, intermediates *x509.CertPool) ([][]*x509.Certificate, error) {\n\tchains, err := cert.Verify(x509.VerifyOptions{\n\t\t// THIS IS IMPORTANT: WE DO NOT CHECK TIMES HERE\n\t\t// THE CERTIFICATE IS TREATED AS TRUSTED FOREVER\n\t\t// WE CHECK THAT THE SIGNATURES WERE CREATED DURING THIS WINDOW\n\t\tCurrentTime:   cert.NotBefore,\n\t\tRoots:         roots,\n\t\tIntermediates: intermediates,\n\t\tKeyUsages: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageCodeSigning,\n\t\t},\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn chains, nil\n}\n\nfunc correctAnnotations(wanted, have map[string]interface{}) bool {\n\tfor k, v := range wanted {\n\t\tif have[k] != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/go-openapi/strfmt\"\n\t\"github.com/google/certificate-transparency-go/testdata\"\n\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/internal/pkg/cosign/rekor/mock\"\n\t\"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/cosign/test\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\trtypes \"github.com/sigstore/rekor/pkg/types\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/transparency-dev/merkle/rfc6962\"\n)\n\ntype mockVerifier struct {\n\tshouldErr bool\n}\n\nfunc (m *mockVerifier) PublicKey(opts ...signature.PublicKeyOption) (crypto.PublicKey, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockVerifier) VerifySignature(signature, message io.Reader, opts ...signature.VerifyOption) error {\n\tif m.shouldErr {\n\t\treturn errors.New(\"failure\")\n\t}\n\treturn nil\n}\n\nvar _ signature.Verifier = (*mockVerifier)(nil)\n\ntype mockAttestation struct {\n\tpayload interface{}\n}\n\nvar _ payloader = (*mockAttestation)(nil)\n\nfunc (m *mockAttestation) Annotations() (map[string]string, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockAttestation) Payload() ([]byte, error) {\n\treturn json.Marshal(m.payload)\n}\n\nfunc appendSlices(slices [][]byte) []byte {\n\tvar tmp []byte\n\tfor _, s := range slices {\n\t\ttmp = append(tmp, s...)\n\t}\n\treturn tmp\n}\n\nfunc Test_verifyOCIAttestation(t *testing.T) {\n\tstmt, err := json.Marshal(in_toto.ProvenanceStatement{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvalid := map[string]interface{}{\n\t\t\"payloadType\": types.IntotoPayloadType,\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\t// Should Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: valid}); err != nil {\n\t\tt.Errorf(\"verifyOCIAttestation() error = %v\", err)\n\t}\n\n\tinvalid := map[string]interface{}{\n\t\t\"payloadType\": \"not valid type\",\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\n\t// Should Not Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: invalid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{shouldErr: true}, &mockAttestation{payload: valid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n}\n\nfunc TestVerifyImageSignature(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload,\n\t\tbase64.StdEncoding.EncodeToString(signature),\n\t\tstatic.WithCertChain(pemLeaf, appendSlices([][]byte{pemSub, pemRoot})))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error while verifying signature, expected no error, got %v\", err)\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureMultipleSubs(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert1, subKey1, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tsubCert2, subKey2, _ := test.GenerateSubordinateCa(subCert1, subKey1)\n\tsubCert3, subKey3, _ := test.GenerateSubordinateCa(subCert2, subKey2)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert3, subKey3)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub1 := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert1.Raw})\n\tpemSub2 := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert2.Raw})\n\tpemSub3 := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert3.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload,\n\t\tbase64.StdEncoding.EncodeToString(signature), static.WithCertChain(pemLeaf, appendSlices([][]byte{pemSub3, pemSub2, pemSub1, pemRoot})))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error while verifying signature, expected no error, got %v\", err)\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc signEntry(ctx context.Context, t *testing.T, signer signature.Signer, entry bundle.RekorPayload) []byte {\n\tpayload, err := json.Marshal(entry)\n\tif err != nil {\n\t\tt.Fatalf(\"marshalling error: %v\", err)\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(payload)\n\tif err != nil {\n\t\tt.Fatalf(\"canonicalizing error: %v\", err)\n\t}\n\tsignature, err := signer.SignMessage(bytes.NewReader(canonicalized), options.WithContext(ctx))\n\tif err != nil {\n\t\tt.Fatalf(\"signing error: %v\", err)\n\t}\n\treturn signature\n}\n\nfunc CreateTestBundle(ctx context.Context, t *testing.T, rekor signature.Signer, leaf []byte) *bundle.RekorBundle {\n\t// generate log ID according to rekor public key\n\tpk, _ := rekor.PublicKey(nil)\n\tkeyID, _ := getLogID(pk)\n\tpyld := bundle.RekorPayload{\n\t\tBody:           base64.StdEncoding.EncodeToString(leaf),\n\t\tIntegratedTime: time.Now().Unix(),\n\t\tLogIndex:       693591,\n\t\tLogID:          keyID,\n\t}\n\t// Sign with root.\n\tsignature := signEntry(ctx, t, rekor, pyld)\n\tb := &bundle.RekorBundle{\n\t\tSignedEntryTimestamp: strfmt.Base64(signature),\n\t\tPayload:              pyld,\n\t}\n\treturn b\n}\n\nfunc TestVerifyImageSignatureWithNoChain(t *testing.T) {\n\tctx := context.Background()\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsv, _, err := signature.NewECDSASignerVerifier(elliptic.P256(), rand.Reader, crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"creating signer: %v\", err)\n\t}\n\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\t// Create a fake bundle\n\tpe, _ := proposedEntry(base64.StdEncoding.EncodeToString(signature), payload, pemLeaf)\n\tentry, _ := rtypes.NewEntry(pe[0])\n\tleaf, _ := entry.Canonicalize(ctx)\n\trekorBundle := CreateTestBundle(ctx, t, sv, leaf)\n\n\topts := []static.Option{static.WithCertChain(pemLeaf, []byte{}), static.WithBundle(rekorBundle)}\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(signature), opts...)\n\n\t// TODO(asraa): Re-enable passing test when Rekor public keys can be set in CheckOpts,\n\t// instead of relying on the singleton TUF instance.\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err == nil {\n\t\tt.Fatalf(\"expected error due to custom Rekor public key\")\n\t}\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureWithOnlyRoot(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(signature), static.WithCertChain(pemLeaf, pemRoot))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error while verifying signature, expected no error, got %v\", err)\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureWithMissingSub(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(signature), static.WithCertChain(pemLeaf, pemRoot))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool})\n\tif err == nil {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\tif !strings.Contains(err.Error(), \"certificate signed by unknown authority\") {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nfunc TestVerifyImageSignatureWithExistingSub(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, privKey, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\tpemRoot := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: rootCert.Raw})\n\tpemSub := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: subCert.Raw})\n\tpemLeaf := pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: leafCert.Raw})\n\n\totherSubCert, _, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tsubPool := x509.NewCertPool()\n\t// Load in different sub cert so the chain doesn't verify\n\trootPool.AddCert(otherSubCert)\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsignature, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\n\tociSig, _ := static.NewSignature(payload,\n\t\tbase64.StdEncoding.EncodeToString(signature),\n\t\tstatic.WithCertChain(pemLeaf, appendSlices([][]byte{pemSub, pemRoot})))\n\tverified, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{RootCerts: rootPool, IntermediateCerts: subPool})\n\tif err == nil {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\tif !strings.Contains(err.Error(), \"certificate signed by unknown authority\") {\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n\t// TODO: Create fake bundle and test verification\n\tif verified == true {\n\t\tt.Fatalf(\"expected verified=false, got verified=true\")\n\t}\n}\n\nvar (\n\tlea = models.LogEntryAnon{\n\t\tAttestation:    &models.LogEntryAnonAttestation{},\n\t\tBody:           base64.StdEncoding.EncodeToString([]byte(\"asdf\")),\n\t\tIntegratedTime: new(int64),\n\t\tLogID:          new(string),\n\t\tLogIndex:       new(int64),\n\t\tVerification: &models.LogEntryAnonVerification{\n\t\t\tInclusionProof: &models.InclusionProof{\n\t\t\t\tRootHash: new(string),\n\t\t\t\tTreeSize: new(int64),\n\t\t\t\tLogIndex: new(int64),\n\t\t\t},\n\t\t},\n\t}\n\tdata = models.LogEntry{\n\t\tuuid(lea): lea,\n\t}\n)\n\n// uuid generates the UUID for the given LogEntry.\n// This is effectively a reimplementation of\n// pkg/cosign/tlog.go -> verifyUUID / ComputeLeafHash, but separated\n// to avoid a circular dependency.\n// TODO?: Perhaps we should refactor the tlog libraries into a separate\n// package?\nfunc uuid(e models.LogEntryAnon) string {\n\tentryBytes, err := base64.StdEncoding.DecodeString(e.Body.(string))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn hex.EncodeToString(rfc6962.DefaultHasher.HashLeaf(entryBytes))\n}\n\n// This test ensures that image signature validation fails properly if we are\n// using a SigVerifier with Rekor.\n// See https://github.com/sigstore/cosign/issues/1816 for more details.\nfunc TestVerifyImageSignatureWithSigVerifierAndRekor(t *testing.T) {\n\tsv, privKey, err := signature.NewDefaultECDSASignerVerifier()\n\tif err != nil {\n\t\tt.Fatalf(\"error generating verifier: %v\", err)\n\t}\n\n\tpayload := []byte{1, 2, 3, 4}\n\th := sha256.Sum256(payload)\n\tsig, _ := privKey.Sign(rand.Reader, h[:], crypto.SHA256)\n\tociSig, _ := static.NewSignature(payload, base64.StdEncoding.EncodeToString(sig))\n\n\t// Add a fake rekor client - this makes it look like there's a matching\n\t// tlog entry for the signature during validation (even though it does not\n\t// match the underlying data / key)\n\tmClient := new(client.Rekor)\n\tmClient.Entries = &mock.EntriesClient{\n\t\tEntries: &data,\n\t}\n\n\tif _, err := VerifyImageSignature(context.TODO(), ociSig, v1.Hash{}, &CheckOpts{\n\t\tSigVerifier: sv,\n\t\tRekorClient: mClient,\n\t}); err == nil || !strings.Contains(err.Error(), \"verifying inclusion proof\") {\n\t\t// TODO(wlynch): This is a weak test, since this is really failing because\n\t\t// there is no inclusion proof for the Rekor entry rather than failing to\n\t\t// validate the Rekor public key itself. At the very least this ensures\n\t\t// that we're hitting tlog validation during signature checking,\n\t\t// but we should look into improving this once there is an in-memory\n\t\t// Rekor client that is capable of performing inclusion proof validation\n\t\t// in unit tests.\n\t\tt.Fatal(\"expected error while verifying signature\")\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccess(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n\terr = CheckCertificatePolicy(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"CheckCertificatePolicy expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccessAllowAllValues(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts: rootPool,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n\terr = CheckCertificatePolicy(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"CheckCertificatePolicy expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithSCT(t *testing.T) {\n\tchain, err := cryptoutils.UnmarshalCertificatesFromPEM([]byte(testdata.TestEmbeddedCertPEM + testdata.CACertPEM))\n\tif err != nil {\n\t\tt.Fatalf(\"error unmarshalling certificate chain: %v\", err)\n\t}\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(chain[1])\n\tco := &CheckOpts{\n\t\tRootCerts: rootPool,\n\t}\n\n\t// write SCT verification key to disk\n\ttmpPrivFile, err := os.CreateTemp(t.TempDir(), \"cosign_verify_sct_*.key\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp key file: %v\", err)\n\t}\n\tdefer tmpPrivFile.Close()\n\tif _, err := tmpPrivFile.Write([]byte(testdata.LogPublicKeyPEM)); err != nil {\n\t\tt.Fatalf(\"failed to write key file: %v\", err)\n\t}\n\tos.Setenv(\"SIGSTORE_CT_LOG_PUBLIC_KEY_FILE\", tmpPrivFile.Name())\n\tdefer os.Unsetenv(\"SIGSTORE_CT_LOG_PUBLIC_KEY_FILE\")\n\n\t_, err = ValidateAndUnpackCert(chain[0], co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n\n\t// validate again, explicitly setting enforce SCT\n\tco.EnforceSCT = true\n\t_, err = ValidateAndUnpackCert(chain[0], co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithoutRequiredSCT(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t\tEnforceSCT:     true,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"certificate does not include required embedded SCT\")\n}\n\nfunc TestValidateAndUnpackCertInvalidRoot(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\totherRoot, _, _ := test.GenerateRootCa()\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(otherRoot)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"certificate signed by unknown authority\")\n}\n\nfunc TestValidateAndUnpackCertInvalidOidcIssuer(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: \"other\",\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected oidc issuer not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected oidc issuer not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidEmail(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      \"other\",\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowTrigger(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowTrigger := \"myTrigger\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, githubWorkFlowTrigger, \"\", \"\", \"\", \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:                 rootPool,\n\t\tCertEmail:                 subject,\n\t\tCertGithubWorkflowTrigger: \"otherTrigger\",\n\t\tCertOidcIssuer:            oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Trigger not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Trigger not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowSHA(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowSha := \"mySHA\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", githubWorkFlowSha, \"\", \"\", \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:             rootPool,\n\t\tCertEmail:             subject,\n\t\tCertGithubWorkflowSha: \"otherSHA\",\n\t\tCertOidcIssuer:        oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow SHA not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow SHA not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowName(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowName := \"myName\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", \"\", githubWorkFlowName, \"\", \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:              rootPool,\n\t\tCertEmail:              subject,\n\t\tCertGithubWorkflowName: \"otherName\",\n\t\tCertOidcIssuer:         oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Name not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Name not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowRepository(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowRepository := \"myRepository\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", \"\", \"\", githubWorkFlowRepository, \"\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:                    rootPool,\n\t\tCertEmail:                    subject,\n\t\tCertGithubWorkflowRepository: \"otherRepository\",\n\t\tCertOidcIssuer:               oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Repository not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Repository not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidGithubWorkflowRef(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\tgithubWorkFlowRef := \"myRef\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCertWithGitHubOIDs(subject, oidcIssuer, \"\", \"\", \"\", \"\", githubWorkFlowRef, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:             rootPool,\n\t\tCertEmail:             subject,\n\t\tCertGithubWorkflowRef: \"otherRef\",\n\t\tCertOidcIssuer:        oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Ref not found in certificate\")\n\terr = CheckCertificatePolicy(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected GitHub Workflow Ref not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertWithChainSuccess(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, subCert, subKey)\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{subCert, leafCert}, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithChainSuccessWithRoot(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{rootCert}, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithChainFailsWithoutChain(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{}, co)\n\tif err == nil || err.Error() != \"no chain provided to validate certificate\" {\n\t\tt.Errorf(\"expected error without chain, got %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithChainFailsWithInvalidChain(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\trootCertOther, _, _ := test.GenerateRootCa()\n\n\tco := &CheckOpts{\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCertWithChain(leafCert, []*x509.Certificate{rootCertOther}, co)\n\tif err == nil || !strings.Contains(err.Error(), \"certificate signed by unknown authority\") {\n\t\tt.Errorf(\"expected error without valid chain, got %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertWithIdentities(t *testing.T) {\n\tu, err := url.Parse(\"http://url.example.com\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to parse url\", err)\n\t}\n\temailSubject := \"email@example.com\"\n\tdnsSubjects := []string{\"dnssubject.example.com\"}\n\tipSubjects := []net.IP{net.ParseIP(\"1.2.3.4\")}\n\turiSubjects := []*url.URL{u}\n\toidcIssuer := \"https://accounts.google.com\"\n\n\ttests := []struct {\n\t\tidentities       []Identity\n\t\twantErrSubstring string\n\t\tdnsNames         []string\n\t\temailAddresses   []string\n\t\tipAddresses      []net.IP\n\t\turis             []*url.URL\n\t}{\n\t\t{identities: nil /* No matches required, checks out */},\n\t\t{identities: []Identity{ // Strict match on both\n\t\t\t{Subject: emailSubject, Issuer: oidcIssuer}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // just issuer\n\t\t\t{Issuer: oidcIssuer}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // just subject\n\t\t\t{Subject: emailSubject}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // mis-match\n\t\t\t{Subject: \"wrongsubject\", Issuer: oidcIssuer},\n\t\t\t{Subject: emailSubject, Issuer: \"wrongissuer\"}},\n\t\t\temailAddresses:   []string{emailSubject},\n\t\t\twantErrSubstring: \"none of the expected identities matched\"},\n\t\t{identities: []Identity{ // one good identity, other does not match\n\t\t\t{Subject: \"wrongsubject\", Issuer: \"wrongissuer\"},\n\t\t\t{Subject: emailSubject, Issuer: oidcIssuer}},\n\t\t\temailAddresses: []string{emailSubject}},\n\t\t{identities: []Identity{ // illegal regex for subject\n\t\t\t{SubjectRegExp: \"****\", Issuer: oidcIssuer}},\n\t\t\temailAddresses:   []string{emailSubject},\n\t\t\twantErrSubstring: \"malformed subject in identity\"},\n\t\t{identities: []Identity{ // illegal regex for issuer\n\t\t\t{Subject: emailSubject, IssuerRegExp: \"****\"}},\n\t\t\twantErrSubstring: \"malformed issuer in identity\"},\n\t\t{identities: []Identity{ // regex matches\n\t\t\t{SubjectRegExp: \".*example.com\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\temailAddresses:   []string{emailSubject},\n\t\t\twantErrSubstring: \"\"},\n\t\t{identities: []Identity{ // regex matches dnsNames\n\t\t\t{SubjectRegExp: \".*ubject.example.com\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\tdnsNames:         dnsSubjects,\n\t\t\twantErrSubstring: \"\"},\n\t\t{identities: []Identity{ // regex matches ip\n\t\t\t{SubjectRegExp: \"1.2.3.*\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\tipAddresses:      ipSubjects,\n\t\t\twantErrSubstring: \"\"},\n\t\t{identities: []Identity{ // regex matches urls\n\t\t\t{SubjectRegExp: \".*url.examp.*\", IssuerRegExp: \".*accounts.google.*\"}},\n\t\t\turis:             uriSubjects,\n\t\t\twantErrSubstring: \"\"},\n\t}\n\tfor _, tc := range tests {\n\t\trootCert, rootKey, _ := test.GenerateRootCa()\n\t\tleafCert, _, _ := test.GenerateLeafCertWithSubjectAlternateNames(tc.dnsNames, tc.emailAddresses, tc.ipAddresses, tc.uris, oidcIssuer, rootCert, rootKey)\n\n\t\trootPool := x509.NewCertPool()\n\t\trootPool.AddCert(rootCert)\n\n\t\tco := &CheckOpts{\n\t\t\tRootCerts:  rootPool,\n\t\t\tIdentities: tc.identities,\n\t\t}\n\t\t_, err := ValidateAndUnpackCert(leafCert, co)\n\t\tif err == nil && tc.wantErrSubstring != \"\" {\n\t\t\tt.Errorf(\"Expected error %s got none\", tc.wantErrSubstring)\n\t\t} else if err != nil {\n\t\t\tif tc.wantErrSubstring == \"\" {\n\t\t\t\tt.Errorf(\"Did not expect an error, got err = %v\", err)\n\t\t\t} else if !strings.Contains(err.Error(), tc.wantErrSubstring) {\n\t\t\t\tt.Errorf(\"Did not get the expected error %s, got err = %v\", tc.wantErrSubstring, err)\n\t\t\t}\n\t\t}\n\t\t// Test CheckCertificatePolicy\n\t\terr = CheckCertificatePolicy(leafCert, co)\n\t\tif err == nil && tc.wantErrSubstring != \"\" {\n\t\t\tt.Errorf(\"Expected error %s got none\", tc.wantErrSubstring)\n\t\t} else if err != nil {\n\t\t\tif tc.wantErrSubstring == \"\" {\n\t\t\t\tt.Errorf(\"Did not expect an error, got err = %v\", err)\n\t\t\t} else if !strings.Contains(err.Error(), tc.wantErrSubstring) {\n\t\t\t\tt.Errorf(\"Did not get the expected error %s, got err = %v\", tc.wantErrSubstring, err)\n\t\t\t}\n\t\t}\n\t}\n}\nfunc TestCompareSigs(t *testing.T) {\n\t// TODO(nsmith5): Add test cases for invalid signature, missing signature etc\n\ttests := []struct {\n\t\tdescription string\n\t\tb64sig      string\n\t\tbundleBody  string\n\t\tshouldErr   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"sigs match\",\n\t\t\tb64sig:      \"MEQCIDO3XHbLovPWK+bk8ItCig2cwlr/8MXbLvz3UFzxMGIMAiA1lqdM9IqqUvCUqzOjufTq3sKU3qSn7R5tPqPz0ddNwQ==\",\n\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n\t\t},\n\t\t{\n\t\t\tdescription: \"sigs don't match\",\n\t\t\tb64sig:      \"bm9wZQo=\",\n\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n\t\t\tshouldErr:   true,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tsig, err := static.NewSignature([]byte(\"payload\"), test.b64sig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create static signature: %v\", err)\n\t\t\t}\n\t\t\terr = compareSigs(test.bundleBody, sig)\n\t\t\tif err == nil && test.shouldErr {\n\t\t\t\tt.Fatal(\"test should have errored\")\n\t\t\t}\n\t\t\tif err != nil && !test.shouldErr {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTrustedCertSuccess(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tsubCert, subKey, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\tleafCert, _, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tsubPool := x509.NewCertPool()\n\tsubPool.AddCert(subCert)\n\n\tchains, err := TrustedCert(leafCert, rootPool, subPool)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error verifying certificate, got %v\", err)\n\t}\n\tif len(chains) != 1 {\n\t\tt.Fatalf(\"unexpected number of chains found, expected 1, got %v\", len(chains))\n\t}\n\tif len(chains[0]) != 3 {\n\t\tt.Fatalf(\"unexpected number of certs in chain, expected 3, got %v\", len(chains[0]))\n\t}\n}\n\nfunc TestTrustedCertSuccessNoIntermediates(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\t_, err := TrustedCert(leafCert, rootPool, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error verifying certificate, got %v\", err)\n\t}\n}\n\n// Tests that verification succeeds if both a root and subordinate pool are\n// present, but a chain is built with only the leaf and root certificates.\nfunc TestTrustedCertSuccessChainFromRoot(t *testing.T) {\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(\"subject\", \"oidc-issuer\", rootCert, rootKey)\n\tsubCert, _, _ := test.GenerateSubordinateCa(rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\tsubPool := x509.NewCertPool()\n\tsubPool.AddCert(subCert)\n\n\t_, err := TrustedCert(leafCert, rootPool, subPool)\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error verifying certificate, got %v\", err)\n\t}\n}\n", "// Copyright 2022 The Sigstore Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage test\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/asn1\"\n\t\"math/big\"\n\t\"net\"\n\t\"net/url\"\n\t\"time\"\n)\n\n/*\nTo use:\n\nrootCert, rootKey, _ := GenerateRootCa()\nsubCert, subKey, _ := GenerateSubordinateCa(rootCert, rootKey)\nleafCert, _, _ := GenerateLeafCert(\"subject\", \"oidc-issuer\", subCert, subKey)\n\nroots := x509.NewCertPool()\nsubs := x509.NewCertPool()\nroots.AddCert(rootCert)\nsubs.AddCert(subCert)\nopts := x509.VerifyOptions{\n\tRoots:         roots,\n\tIntermediates: subs,\n\tKeyUsages: []x509.ExtKeyUsage{\n\t\tx509.ExtKeyUsageCodeSigning,\n\t},\n}\n_, err := leafCert.Verify(opts)\n*/\n\nfunc createCertificate(template *x509.Certificate, parent *x509.Certificate, pub interface{}, priv crypto.Signer) (*x509.Certificate, error) {\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, template, parent, pub, priv)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcert, err := x509.ParseCertificate(certBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn cert, nil\n}\n\nfunc GenerateRootCa() (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\trootTemplate := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   \"sigstore\",\n\t\t\tOrganization: []string{\"sigstore.dev\"},\n\t\t},\n\t\tNotBefore:             time.Now().Add(-5 * time.Hour),\n\t\tNotAfter:              time.Now().Add(5 * time.Hour),\n\t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(rootTemplate, rootTemplate, &priv.PublicKey, priv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateSubordinateCa(rootTemplate *x509.Certificate, rootPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tsubTemplate := &x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t\tSubject: pkix.Name{\n\t\t\tCommonName:   \"sigstore-sub\",\n\t\t\tOrganization: []string{\"sigstore.dev\"},\n\t\t},\n\t\tNotBefore:             time.Now().Add(-2 * time.Minute),\n\t\tNotAfter:              time.Now().Add(2 * time.Hour),\n\t\tKeyUsage:              x509.KeyUsageCertSign | x509.KeyUsageCRLSign,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tBasicConstraintsValid: true,\n\t\tIsCA:                  true,\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(subTemplate, rootTemplate, &priv.PublicKey, rootPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateLeafCertWithExpiration(subject string, oidcIssuer string, expiration time.Time,\n\tpriv *ecdsa.PrivateKey,\n\tparentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: []string{subject},\n\t\tNotBefore:      expiration,\n\t\tNotAfter:       expiration.Add(10 * time.Minute),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t},\n\t\t},\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn cert, nil\n}\n\nfunc GenerateLeafCert(subject string, oidcIssuer string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: []string{subject},\n\t\tNotBefore:      time.Now().Add(-1 * time.Minute),\n\t\tNotAfter:       time.Now().Add(time.Hour),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t},\n\t\t},\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateLeafCertWithGitHubOIDs(subject string, oidcIssuer string, githubWorkflowTrigger, githubWorkflowSha, githubWorkflowName,\n\tgithubWorkflowRepository, githubWorkflowRef string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: []string{subject},\n\t\tNotBefore:      time.Now().Add(-1 * time.Minute),\n\t\tNotAfter:       time.Now().Add(time.Hour),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 2}, Value: []byte(githubWorkflowTrigger)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 3}, Value: []byte(githubWorkflowSha)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 4}, Value: []byte(githubWorkflowName)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 5}, Value: []byte(githubWorkflowRepository)},\n\t\t\t{Id: asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 6}, Value: []byte(githubWorkflowRef)}},\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n\nfunc GenerateLeafCertWithSubjectAlternateNames(dnsNames []string, emailAddresses []string, ipAddresses []net.IP, uris []*url.URL, oidcIssuer string, parentTemplate *x509.Certificate, parentPriv crypto.Signer) (*x509.Certificate, *ecdsa.PrivateKey, error) {\n\tcertTemplate := &x509.Certificate{\n\t\tSerialNumber:   big.NewInt(1),\n\t\tEmailAddresses: emailAddresses,\n\t\tDNSNames:       dnsNames,\n\t\tIPAddresses:    ipAddresses,\n\t\tURIs:           uris,\n\t\tNotBefore:      time.Now().Add(-1 * time.Minute),\n\t\tNotAfter:       time.Now().Add(time.Hour),\n\t\tKeyUsage:       x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:    []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},\n\t\tIsCA:           false,\n\t\tExtraExtensions: []pkix.Extension{{\n\t\t\t// OID for OIDC Issuer extension\n\t\t\tId:       asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1},\n\t\t\tCritical: false,\n\t\t\tValue:    []byte(oidcIssuer),\n\t\t}},\n\t}\n\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := createCertificate(certTemplate, parentTemplate, &priv.PublicKey, parentPriv)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, priv, nil\n}\n"], "filenames": ["cmd/cosign/cli/verify/verify_blob.go", "cmd/cosign/cli/verify/verify_blob_test.go", "internal/pkg/cosign/rekor/mock/mock_rekor_client.go", "internal/pkg/cosign/rekor/signer_test.go", "pkg/cosign/verify.go", "pkg/cosign/verify_test.go", "test/cert_utils.go"], "buggy_code_start_loc": [22, 17, 18, 24, 995, 25, 72], "buggy_code_end_loc": [465, 143, 93, 52, 996, 365, 119], "fixing_code_start_loc": [22, 18, 18, 25, 995, 26, 72], "fixing_code_end_loc": [658, 1117, 70, 59, 996, 404, 148], "type": "CWE-347", "message": "Cosign is a project under the sigstore organization which aims to make signatures invisible infrastructure. In versions prior to 1.12.0 a number of vulnerabilities have been found in cosign verify-blob, where Cosign would successfully verify an artifact when verification should have failed. First a cosign bundle can be crafted to successfully verify a blob even if the embedded rekorBundle does not reference the given signature. Second, when providing identity flags, the email and issuer of a certificate is not checked when verifying a Rekor bundle, and the GitHub Actions identity is never checked. Third, providing an invalid Rekor bundle without the experimental flag results in a successful verification. And fourth an invalid transparency log entry will result in immediate success for verification. Details and examples of these issues can be seen in the GHSA-8gw7-4j42-w388 advisory linked. Users are advised to upgrade to 1.12.0. There are no known workarounds for these issues.", "other": {"cve": {"id": "CVE-2022-36056", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-14T20:15:09.860", "lastModified": "2022-09-19T18:11:48.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cosign is a project under the sigstore organization which aims to make signatures invisible infrastructure. In versions prior to 1.12.0 a number of vulnerabilities have been found in cosign verify-blob, where Cosign would successfully verify an artifact when verification should have failed. First a cosign bundle can be crafted to successfully verify a blob even if the embedded rekorBundle does not reference the given signature. Second, when providing identity flags, the email and issuer of a certificate is not checked when verifying a Rekor bundle, and the GitHub Actions identity is never checked. Third, providing an invalid Rekor bundle without the experimental flag results in a successful verification. And fourth an invalid transparency log entry will result in immediate success for verification. Details and examples of these issues can be seen in the GHSA-8gw7-4j42-w388 advisory linked. Users are advised to upgrade to 1.12.0. There are no known workarounds for these issues."}, {"lang": "es", "value": "Cosign es un proyecto bajo la organizaci\u00f3n sigstore que presenta como objetivo hacer que la infraestructura de las firmas sea invisible. En versiones anteriores a 1.12.0, han sido encontradas una serie de vulnerabilidades en cosign verify-blob, donde Cosign verificaba con \u00e9xito un artefacto cuando la verificaci\u00f3n deber\u00eda haber fallado. En primer lugar, puede dise\u00f1arse un paquete de Cosign para que verifique correctamente un blob aunque el rekorBundle insertado no haga referencia a la firma en cuesti\u00f3n. En segundo lugar, cuando son proporcionados indicadores de identidad, el correo electr\u00f3nico y el emisor de un certificado no son comprobados cuando es verificado un paquete Rekor, y la identidad de las acciones de GitHub nunca es comprobada. En tercer lugar, si es proporcionada un paquete Rekor no v\u00e1lido sin el flag experimental, la verificaci\u00f3n es realizada con \u00e9xito. Y en cuarto lugar, una entrada de registro de transparencia no v\u00e1lida resultar\u00e1 en un \u00e9xito inmediato de la verificaci\u00f3n. Los detalles y ejemplos de estos problemas pueden verse en el aviso GHSA-8gw7-4j42-w388 enlazado. Es recomendado a usuarios actualizar a versi\u00f3n 1.12.0. No se presentan mitigaciones conocidas para estos problemas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sigstore:cosign:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.12.0", "matchCriteriaId": "B4975968-ACFD-4039-AD18-F2C53D2CF1DD"}]}]}], "references": [{"url": "https://github.com/sigstore/cosign/commit/80b79ed8b4d28ccbce3d279fd273606b5cddcc25", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sigstore/cosign/security/advisories/GHSA-8gw7-4j42-w388", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sigstore/cosign/commit/80b79ed8b4d28ccbce3d279fd273606b5cddcc25"}}