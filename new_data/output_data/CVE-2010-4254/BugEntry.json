{"buggy_code": ["/*\n * reflection.c: Routines for creating an image at runtime.\n * \n * Author:\n *   Paolo Molaro (lupus@ximian.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n *\n */\n#include <config.h>\n#include \"mono/utils/mono-digest.h\"\n#include \"mono/utils/mono-membar.h\"\n#include \"mono/metadata/reflection.h\"\n#include \"mono/metadata/tabledefs.h\"\n#include \"mono/metadata/metadata-internals.h\"\n#include <mono/metadata/profiler-private.h>\n#include \"mono/metadata/class-internals.h\"\n#include \"mono/metadata/gc-internal.h\"\n#include \"mono/metadata/tokentype.h\"\n#include \"mono/metadata/domain-internals.h\"\n#include \"mono/metadata/opcodes.h\"\n#include \"mono/metadata/assembly.h\"\n#include \"mono/metadata/object-internals.h\"\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/security-manager.h>\n#include <stdio.h>\n#include <glib.h>\n#include <errno.h>\n#include <time.h>\n#include <string.h>\n#include <ctype.h>\n#include \"image.h\"\n#include \"cil-coff.h\"\n#include \"mono-endian.h\"\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/utils/mono-string.h>\n#include <mono/utils/mono-error-internals.h>\n\n\n#if HAVE_SGEN_GC\nstatic void* reflection_info_desc = NULL;\n#define MOVING_GC_REGISTER(addr) do {\t\\\n\t\tif (!reflection_info_desc) {\t\\\n\t\t\tgsize bmap = 1;\t\t\\\n\t\t\treflection_info_desc = mono_gc_make_descr_from_bitmap (&bmap, 1);\t\\\n\t\t}\t\\\n\t\tmono_gc_register_root ((char*)(addr), sizeof (gpointer), reflection_info_desc); \\\n\t} while (0)\n#else\n#define MOVING_GC_REGISTER(addr)\n#endif\n\ntypedef struct {\n\tchar *p;\n\tchar *buf;\n\tchar *end;\n} SigBuffer;\n\n#define TEXT_OFFSET 512\n#define CLI_H_SIZE 136\n#define FILE_ALIGN 512\n#define VIRT_ALIGN 8192\n#define START_TEXT_RVA  0x00002000\n\ntypedef struct {\n\tMonoReflectionILGen *ilgen;\n\tMonoReflectionType *rtype;\n\tMonoArray *parameters;\n\tMonoArray *generic_params;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *pinfo;\n\tMonoArray *opt_types;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tguint32 call_conv;\n\tguint32 *table_idx; /* note: it's a pointer */\n\tMonoArray *code;\n\tMonoObject *type;\n\tMonoString *name;\n\tMonoBoolean init_locals;\n\tMonoBoolean skip_visibility;\n\tMonoArray *return_modreq;\n\tMonoArray *return_modopt;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n\tMonoMethod *mhandle;\n\tguint32 nrefs;\n\tgpointer *refs;\n\t/* for PInvoke */\n\tint charset, extra_flags, native_cc;\n\tMonoString *dll, *dllentry;\n} ReflectionMethodBuilder;\n\ntypedef struct {\n\tguint32 owner;\n\tMonoReflectionGenericParam *gparam;\n} GenericParamTableEntry;\n\nconst unsigned char table_sizes [MONO_TABLE_NUM] = {\n\tMONO_MODULE_SIZE,\n\tMONO_TYPEREF_SIZE,\n\tMONO_TYPEDEF_SIZE,\n\t0,\n\tMONO_FIELD_SIZE,\n\t0,\n\tMONO_METHOD_SIZE,\n\t0,\n\tMONO_PARAM_SIZE,\n\tMONO_INTERFACEIMPL_SIZE,\n\tMONO_MEMBERREF_SIZE,\t/* 0x0A */\n\tMONO_CONSTANT_SIZE,\n\tMONO_CUSTOM_ATTR_SIZE,\n\tMONO_FIELD_MARSHAL_SIZE,\n\tMONO_DECL_SECURITY_SIZE,\n\tMONO_CLASS_LAYOUT_SIZE,\n\tMONO_FIELD_LAYOUT_SIZE,\t/* 0x10 */\n\tMONO_STAND_ALONE_SIGNATURE_SIZE,\n\tMONO_EVENT_MAP_SIZE,\n\t0,\n\tMONO_EVENT_SIZE,\n\tMONO_PROPERTY_MAP_SIZE,\n\t0,\n\tMONO_PROPERTY_SIZE,\n\tMONO_METHOD_SEMA_SIZE,\n\tMONO_METHODIMPL_SIZE,\n\tMONO_MODULEREF_SIZE,\t/* 0x1A */\n\tMONO_TYPESPEC_SIZE,\n\tMONO_IMPLMAP_SIZE,\t\n\tMONO_FIELD_RVA_SIZE,\n\t0,\n\t0,\n\tMONO_ASSEMBLY_SIZE,\t/* 0x20 */\n\tMONO_ASSEMBLY_PROCESSOR_SIZE,\n\tMONO_ASSEMBLYOS_SIZE,\n\tMONO_ASSEMBLYREF_SIZE,\n\tMONO_ASSEMBLYREFPROC_SIZE,\n\tMONO_ASSEMBLYREFOS_SIZE,\n\tMONO_FILE_SIZE,\n\tMONO_EXP_TYPE_SIZE,\n\tMONO_MANIFEST_SIZE,\n\tMONO_NESTED_CLASS_SIZE,\n\n\tMONO_GENERICPARAM_SIZE,\t/* 0x2A */\n\tMONO_METHODSPEC_SIZE,\n\tMONO_GENPARCONSTRAINT_SIZE\n\n};\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32 mono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec);\nstatic guint32 mono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec);\nstatic guint32 mono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *cb);\nstatic guint32 mono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper);\nstatic void    ensure_runtime_vtable (MonoClass *klass);\nstatic gpointer resolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context);\nstatic guint32 mono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method);\nstatic guint32 encode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context);\nstatic gpointer register_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly);\nstatic void reflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb);\nstatic void reflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb);\n#endif\n\nstatic guint32 mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type);\nstatic guint32 mono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec);\nstatic void    mono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly);\nstatic guint32 encode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo);\nstatic guint32 encode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type);\nstatic char*   type_get_qualified_name (MonoType *type, MonoAssembly *ass);\nstatic void    encode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf);\nstatic void get_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types);\nstatic MonoObject *mono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob);\nstatic MonoReflectionType *mono_reflection_type_get_underlying_system_type (MonoReflectionType* t);\nstatic MonoType* mono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve);\nstatic MonoReflectionType* mono_reflection_type_resolve_user_types (MonoReflectionType *type);\nstatic gboolean is_sre_array (MonoClass *class);\nstatic gboolean is_sre_byref (MonoClass *class);\nstatic gboolean is_sre_pointer (MonoClass *class);\nstatic gboolean is_sre_method_builder (MonoClass *class);\nstatic gboolean is_sre_ctor_builder (MonoClass *class);\nstatic gboolean is_sr_mono_method (MonoClass *class);\nstatic gboolean is_sr_mono_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_generic_method (MonoClass *class);\nstatic gboolean is_sr_mono_generic_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_field (MonoClass *class);\nstatic gboolean is_sr_mono_property (MonoClass *class);\nstatic gboolean is_sre_method_on_tb_inst (MonoClass *class);\nstatic gboolean is_sre_ctor_on_tb_inst (MonoClass *class);\n\nstatic guint32 mono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method);\nstatic guint32 mono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m);\nstatic MonoMethod * inflate_method (MonoReflectionGenericClass *type, MonoObject *obj);\n\n#define RESOLVE_TYPE(type) do { type = (void*)mono_reflection_type_resolve_user_types ((MonoReflectionType*)type); } while (0)\n#define RESOLVE_ARRAY_TYPE_ELEMENT(array, index) do {\t\\\n\tMonoReflectionType *__type = mono_array_get (array, MonoReflectionType*, index);\t\\\n\t__type = mono_reflection_type_resolve_user_types (__type);\t\\\n\tmono_array_set (arr, MonoReflectionType*, index, __type);\t\\\n} while (0)\n\n#define mono_type_array_get_and_resolve(array, index) mono_reflection_type_get_handle ((MonoReflectionType*)mono_array_get (array, gpointer, index))\n\nvoid\nmono_reflection_init (void)\n{\n}\n\nstatic void\nsigbuffer_init (SigBuffer *buf, int size)\n{\n\tbuf->buf = g_malloc (size);\n\tbuf->p = buf->buf;\n\tbuf->end = buf->buf + size;\n}\n\nstatic void\nsigbuffer_make_room (SigBuffer *buf, int size)\n{\n\tif (buf->end - buf->p < size) {\n\t\tint new_size = buf->end - buf->buf + size + 32;\n\t\tchar *p = g_realloc (buf->buf, new_size);\n\t\tsize = buf->p - buf->buf;\n\t\tbuf->buf = p;\n\t\tbuf->p = p + size;\n\t\tbuf->end = buf->buf + new_size;\n\t}\n}\n\nstatic void\nsigbuffer_add_value (SigBuffer *buf, guint32 val)\n{\n\tsigbuffer_make_room (buf, 6);\n\tmono_metadata_encode_value (val, buf->p, &buf->p);\n}\n\nstatic void\nsigbuffer_add_byte (SigBuffer *buf, guint8 val)\n{\n\tsigbuffer_make_room (buf, 1);\n\tbuf->p [0] = val;\n\tbuf->p++;\n}\n\nstatic void\nsigbuffer_add_mem (SigBuffer *buf, char *p, guint32 size)\n{\n\tsigbuffer_make_room (buf, size);\n\tmemcpy (buf->p, p, size);\n\tbuf->p += size;\n}\n\nstatic void\nsigbuffer_free (SigBuffer *buf)\n{\n\tg_free (buf->buf);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/**\n * mp_g_alloc:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc (image, size);\n\telse\n\t\treturn g_malloc (size);\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/**\n * image_g_alloc0:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc0 (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc0 (image, size);\n\telse\n\t\treturn g_malloc0 (size);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic char*\nimage_strdup (MonoImage *image, const char *s)\n{\n\tif (image)\n\t\treturn mono_image_strdup (image, s);\n\telse\n\t\treturn g_strdup (s);\n}\n#endif\n\n#define image_g_new(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n#define image_g_new0(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc0 (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n\nstatic void\nalloc_table (MonoDynamicTable *table, guint nrows)\n{\n\ttable->rows = nrows;\n\tg_assert (table->columns);\n\tif (nrows + 1 >= table->alloc_rows) {\n\t\twhile (nrows + 1 >= table->alloc_rows) {\n\t\t\tif (table->alloc_rows == 0)\n\t\t\t\ttable->alloc_rows = 16;\n\t\t\telse\n\t\t\t\ttable->alloc_rows *= 2;\n\t\t}\n\n\t\ttable->values = g_renew (guint32, table->values, (table->alloc_rows) * table->columns);\n\t}\n}\n\nstatic void\nmake_room_in_stream (MonoDynamicStream *stream, int size)\n{\n\tif (size <= stream->alloc_size)\n\t\treturn;\n\t\n\twhile (stream->alloc_size <= size) {\n\t\tif (stream->alloc_size < 4096)\n\t\t\tstream->alloc_size = 4096;\n\t\telse\n\t\t\tstream->alloc_size *= 2;\n\t}\n\t\n\tstream->data = g_realloc (stream->data, stream->alloc_size);\n}\n\nstatic guint32\nstring_heap_insert (MonoDynamicStream *sh, const char *str)\n{\n\tguint32 idx;\n\tguint32 len;\n\tgpointer oldkey, oldval;\n\n\tif (g_hash_table_lookup_extended (sh->hash, str, &oldkey, &oldval))\n\t\treturn GPOINTER_TO_UINT (oldval);\n\n\tlen = strlen (str) + 1;\n\tidx = sh->index;\n\t\n\tmake_room_in_stream (sh, idx + len);\n\n\t/*\n\t * We strdup the string even if we already copy them in sh->data\n\t * so that the string pointers in the hash remain valid even if\n\t * we need to realloc sh->data. We may want to avoid that later.\n\t */\n\tg_hash_table_insert (sh->hash, g_strdup (str), GUINT_TO_POINTER (idx));\n\tmemcpy (sh->data + idx, str, len);\n\tsh->index += len;\n\treturn idx;\n}\n\nstatic guint32\nstring_heap_insert_mstring (MonoDynamicStream *sh, MonoString *str)\n{\n\tchar *name = mono_string_to_utf8 (str);\n\tguint32 idx;\n\tidx = string_heap_insert (sh, name);\n\tg_free (name);\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nstring_heap_init (MonoDynamicStream *sh)\n{\n\tsh->index = 0;\n\tsh->alloc_size = 4096;\n\tsh->data = g_malloc (4096);\n\tsh->hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\tstring_heap_insert (sh, \"\");\n}\n#endif\n\nstatic guint32\nmono_image_add_stream_data (MonoDynamicStream *stream, const char *data, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemcpy (stream->data + stream->index, data, len);\n\tidx = stream->index;\n\tstream->index += len;\n\t/* \n\t * align index? Not without adding an additional param that controls it since\n\t * we may store a blob value in pieces.\n\t */\n\treturn idx;\n}\n\nstatic guint32\nmono_image_add_stream_zero (MonoDynamicStream *stream, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemset (stream->data + stream->index, 0, len);\n\tidx = stream->index;\n\tstream->index += len;\n\treturn idx;\n}\n\nstatic void\nstream_data_align (MonoDynamicStream *stream)\n{\n\tchar buf [4] = {0};\n\tguint32 count = stream->index % 4;\n\n\t/* we assume the stream data will be aligned */\n\tif (count)\n\t\tmono_image_add_stream_data (stream, buf, 4 - count);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic int\nmono_blob_entry_hash (const char* str)\n{\n\tguint len, h;\n\tconst char *end;\n\tlen = mono_metadata_decode_blob_size (str, &str);\n\tif (len > 0) {\n\t\tend = str + len;\n\t\th = *str;\n\t\tfor (str += 1; str < end; str++)\n\t\t\th = (h << 5) - h + *str;\n\t\treturn h;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic gboolean\nmono_blob_entry_equal (const char *str1, const char *str2) {\n\tint len, len2;\n\tconst char *end1;\n\tconst char *end2;\n\tlen = mono_metadata_decode_blob_size (str1, &end1);\n\tlen2 = mono_metadata_decode_blob_size (str2, &end2);\n\tif (len != len2)\n\t\treturn 0;\n\treturn memcmp (end1, end2, len) == 0;\n}\n#endif\nstatic guint32\nadd_to_blob_cached (MonoDynamicImage *assembly, char *b1, int s1, char *b2, int s2)\n{\n\tguint32 idx;\n\tchar *copy;\n\tgpointer oldkey, oldval;\n\n\tcopy = g_malloc (s1+s2);\n\tmemcpy (copy, b1, s1);\n\tmemcpy (copy + s1, b2, s2);\n\tif (g_hash_table_lookup_extended (assembly->blob_cache, copy, &oldkey, &oldval)) {\n\t\tg_free (copy);\n\t\tidx = GPOINTER_TO_UINT (oldval);\n\t} else {\n\t\tidx = mono_image_add_stream_data (&assembly->blob, b1, s1);\n\t\tmono_image_add_stream_data (&assembly->blob, b2, s2);\n\t\tg_hash_table_insert (assembly->blob_cache, copy, GUINT_TO_POINTER (idx));\n\t}\n\treturn idx;\n}\n\nstatic guint32\nsigbuffer_add_to_blob_cached (MonoDynamicImage *assembly, SigBuffer *buf)\n{\n\tchar blob_size [8];\n\tchar *b = blob_size;\n\tguint32 size = buf->p - buf->buf;\n\t/* store length */\n\tg_assert (size <= (buf->end - buf->buf));\n\tmono_metadata_encode_value (size, b, &b);\n\treturn add_to_blob_cached (assembly, blob_size, b-blob_size, buf->buf, size);\n}\n\n/*\n * Copy len * nelem bytes from val to dest, swapping bytes to LE if necessary.\n * dest may be misaligned.\n */\nstatic void\nswap_with_size (char *dest, const char* val, int len, int nelem) {\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tint elem;\n\n\tfor (elem = 0; elem < nelem; ++elem) {\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\t*dest = *val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdest [0] = val [1];\n\t\t\tdest [1] = val [0];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdest [0] = val [3];\n\t\t\tdest [1] = val [2];\n\t\t\tdest [2] = val [1];\n\t\t\tdest [3] = val [0];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdest [0] = val [7];\n\t\t\tdest [1] = val [6];\n\t\t\tdest [2] = val [5];\n\t\t\tdest [3] = val [4];\n\t\t\tdest [4] = val [3];\n\t\t\tdest [5] = val [2];\n\t\t\tdest [6] = val [1];\n\t\t\tdest [7] = val [0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tdest += len;\n\t\tval += len;\n\t}\n#else\n\tmemcpy (dest, val, len * nelem);\n#endif\n}\n\nstatic guint32\nadd_mono_string_to_blob_cached (MonoDynamicImage *assembly, MonoString *str)\n{\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tguint32 idx = 0, len;\n\n\tlen = str->length * 2;\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\tg_free (swapped);\n\t}\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoClass *\ndefault_class_from_mono_type (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_OBJECT:\n\t\treturn mono_defaults.object_class;\n\tcase MONO_TYPE_VOID:\n\t\treturn mono_defaults.void_class;\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn mono_defaults.boolean_class;\n\tcase MONO_TYPE_CHAR:\n\t\treturn mono_defaults.char_class;\n\tcase MONO_TYPE_I1:\n\t\treturn mono_defaults.sbyte_class;\n\tcase MONO_TYPE_U1:\n\t\treturn mono_defaults.byte_class;\n\tcase MONO_TYPE_I2:\n\t\treturn mono_defaults.int16_class;\n\tcase MONO_TYPE_U2:\n\t\treturn mono_defaults.uint16_class;\n\tcase MONO_TYPE_I4:\n\t\treturn mono_defaults.int32_class;\n\tcase MONO_TYPE_U4:\n\t\treturn mono_defaults.uint32_class;\n\tcase MONO_TYPE_I:\n\t\treturn mono_defaults.int_class;\n\tcase MONO_TYPE_U:\n\t\treturn mono_defaults.uint_class;\n\tcase MONO_TYPE_I8:\n\t\treturn mono_defaults.int64_class;\n\tcase MONO_TYPE_U8:\n\t\treturn mono_defaults.uint64_class;\n\tcase MONO_TYPE_R4:\n\t\treturn mono_defaults.single_class;\n\tcase MONO_TYPE_R8:\n\t\treturn mono_defaults.double_class;\n\tcase MONO_TYPE_STRING:\n\t\treturn mono_defaults.string_class;\n\tdefault:\n\t\tg_warning (\"default_class_from_mono_type: implement me 0x%02x\\n\", type->type);\n\t\tg_assert_not_reached ();\n\t}\n\t\n\treturn NULL;\n}\n#endif\n\nstatic void\nencode_generic_class (MonoDynamicImage *assembly, MonoGenericClass *gclass, SigBuffer *buf)\n{\n\tint i;\n\tMonoGenericInst *class_inst;\n\tMonoClass *klass;\n\n\tg_assert (gclass);\n\n\tclass_inst = gclass->context.class_inst;\n\n\tsigbuffer_add_value (buf, MONO_TYPE_GENERICINST);\n\tklass = gclass->container_class;\n\tsigbuffer_add_value (buf, klass->byval_arg.type);\n\tsigbuffer_add_value (buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tsigbuffer_add_value (buf, class_inst->type_argc);\n\tfor (i = 0; i < class_inst->type_argc; ++i)\n\t\tencode_type (assembly, class_inst->type_argv [i], buf);\n\n}\n\nstatic void\nencode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tg_assert_not_reached ();\n\t\treturn;\n\t}\n\t\t\n\tif (type->byref)\n\t\tsigbuffer_add_value (buf, MONO_TYPE_BYREF);\n\n\tswitch (type->type){\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tbreak;\n\tcase MONO_TYPE_PTR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, type->data.type, buf);\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.klass->byval_arg, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\n\t\tif (k->generic_container) {\n\t\t\tMonoGenericClass *gclass = mono_metadata_lookup_generic_class (k, k->generic_container->context.class_inst, TRUE);\n\t\t\tencode_generic_class (assembly, gclass, buf);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure we use the correct type.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, k->byval_arg.type);\n\t\t\t/*\n\t\t\t * ensure only non-byref gets passed to mono_image_typedef_or_ref(),\n\t\t\t * otherwise two typerefs could point to the same type, leading to\n\t\t\t * verification errors.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, &k->byval_arg));\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_ARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.array->eklass->byval_arg, buf);\n\t\tsigbuffer_add_value (buf, type->data.array->rank);\n\t\tsigbuffer_add_value (buf, 0); /* FIXME: set to 0 for now */\n\t\tsigbuffer_add_value (buf, 0);\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_generic_class (assembly, type->data.generic_class, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tsigbuffer_add_value (buf, mono_type_get_generic_param_num (type));\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"need to encode type %x\", type->type);\n\t}\n}\n\nstatic void\nencode_reflection_type (MonoDynamicImage *assembly, MonoReflectionType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tsigbuffer_add_value (buf, MONO_TYPE_VOID);\n\t\treturn;\n\t}\n\n\tencode_type (assembly, mono_reflection_type_get_handle (type), buf);\n}\n\nstatic void\nencode_custom_modifiers (MonoDynamicImage *assembly, MonoArray *modreq, MonoArray *modopt, SigBuffer *buf)\n{\n\tint i;\n\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_REQD);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_OPT);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmethod_encode_signature (MonoDynamicImage *assembly, MonoMethodSignature *sig)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  sig->param_count;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tidx = sig->call_convention;\n\tif (sig->hasthis)\n\t\tidx |= 0x20; /* hasthis */\n\tif (sig->generic_param_count)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (sig->generic_param_count)\n\t\tsigbuffer_add_value (&buf, sig->generic_param_count);\n\tsigbuffer_add_value (&buf, nparams);\n\tencode_type (assembly, sig->ret, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tif (i == sig->sentinelpos)\n\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\t\tencode_type (assembly, sig->params [i], &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nmethod_builder_encode_signature (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\t/*\n\t * FIXME: reuse code from method_encode_signature().\n\t */\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  mb->parameters ? mono_array_length (mb->parameters): 0;\n\tguint32 ngparams = mb->generic_params ? mono_array_length (mb->generic_params): 0;\n\tguint32 notypes = mb->opt_types ? mono_array_length (mb->opt_types): 0;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t/* LAMESPEC: all the call conv spec is foobared */\n\tidx = mb->call_conv & 0x60; /* has-this, explicit-this */\n\tif (mb->call_conv & 2)\n\t\tidx |= 0x5; /* vararg */\n\tif (!(mb->attrs & METHOD_ATTRIBUTE_STATIC))\n\t\tidx |= 0x20; /* hasthis */\n\tif (ngparams)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (ngparams)\n\t\tsigbuffer_add_value (&buf, ngparams);\n\tsigbuffer_add_value (&buf, nparams + notypes);\n\tencode_custom_modifiers (assembly, mb->return_modreq, mb->return_modopt, &buf);\n\tencode_reflection_type (assembly, mb->rtype, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tMonoArray *modreq = NULL;\n\t\tMonoArray *modopt = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (mb->param_modreq && (i < mono_array_length (mb->param_modreq)))\n\t\t\tmodreq = mono_array_get (mb->param_modreq, MonoArray*, i);\n\t\tif (mb->param_modopt && (i < mono_array_length (mb->param_modopt)))\n\t\t\tmodopt = mono_array_get (mb->param_modopt, MonoArray*, i);\n\t\tencode_custom_modifiers (assembly, modreq, modopt, &buf);\n\t\tpt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tif (notypes)\n\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\tfor (i = 0; i < notypes; ++i) {\n\t\tMonoReflectionType *pt;\n\n\t\tpt = mono_array_get (mb->opt_types, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_locals (MonoDynamicImage *assembly, MonoReflectionILGen *ilgen)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 idx, sig_idx;\n\tguint nl = mono_array_length (ilgen->locals);\n\tSigBuffer buf;\n\tint i;\n\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, nl);\n\tfor (i = 0; i < nl; ++i) {\n\t\tMonoReflectionLocalBuilder *lb = mono_array_get (ilgen->locals, MonoReflectionLocalBuilder*, i);\n\t\t\n\t\tif (lb->is_pinned)\n\t\t\tsigbuffer_add_value (&buf, MONO_TYPE_PINNED);\n\t\t\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)lb->type, &buf);\n\t}\n\tsig_idx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\tif (assembly->standalonesig_cache == NULL)\n\t\tassembly->standalonesig_cache = g_hash_table_new (NULL, NULL);\n\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx)));\n\tif (idx)\n\t\treturn idx;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] = sig_idx;\n\n\tg_hash_table_insert (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx), GUINT_TO_POINTER (idx));\n\n\treturn idx;\n}\n\nstatic guint32\nmethod_count_clauses (MonoReflectionILGen *ilgen)\n{\n\tguint32 num_clauses = 0;\n\tint i;\n\n\tMonoILExceptionInfo *ex_info;\n\tfor (i = 0; i < mono_array_length (ilgen->ex_handlers); ++i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tif (ex_info->handlers)\n\t\t\tnum_clauses += mono_array_length (ex_info->handlers);\n\t\telse\n\t\t\tnum_clauses++;\n\t}\n\n\treturn num_clauses;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoExceptionClause*\nmethod_encode_clauses (MonoImage *image, MonoDynamicImage *assembly, MonoReflectionILGen *ilgen, guint32 num_clauses)\n{\n\tMonoExceptionClause *clauses;\n\tMonoExceptionClause *clause;\n\tMonoILExceptionInfo *ex_info;\n\tMonoILExceptionBlock *ex_block;\n\tguint32 finally_start;\n\tint i, j, clause_index;;\n\n\tclauses = image_g_new0 (image, MonoExceptionClause, num_clauses);\n\n\tclause_index = 0;\n\tfor (i = mono_array_length (ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tfinally_start = ex_info->start + ex_info->len;\n\t\tif (!ex_info->handlers)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\tclause = &(clauses [clause_index]);\n\n\t\t\tclause->flags = ex_block->type;\n\t\t\tclause->try_offset = ex_info->start;\n\n\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\tclause->try_len = finally_start - ex_info->start;\n\t\t\telse\n\t\t\t\tclause->try_len = ex_info->len;\n\t\t\tclause->handler_offset = ex_block->start;\n\t\t\tclause->handler_len = ex_block->len;\n\t\t\tif (ex_block->extype) {\n\t\t\t\tclause->data.catch_class = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype));\n\t\t\t} else {\n\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\tclause->data.filter_offset = ex_block->filter_offset;\n\t\t\t\telse\n\t\t\t\t\tclause->data.filter_offset = 0;\n\t\t\t}\n\t\t\tfinally_start = ex_block->start + ex_block->len;\n\n\t\t\tclause_index ++;\n\t\t}\n\t}\n\n\treturn clauses;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nstatic guint32\nmethod_encode_code (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\tchar flags = 0;\n\tguint32 idx;\n\tguint32 code_size;\n\tgint32 max_stack, i;\n\tgint32 num_locals = 0;\n\tgint32 num_exception = 0;\n\tgint maybe_small;\n\tguint32 fat_flags;\n\tchar fat_header [12];\n\tguint32 int_value;\n\tguint16 short_value;\n\tguint32 local_sig = 0;\n\tguint32 header_size = 12;\n\tMonoArray *code;\n\n\tif ((mb->attrs & (METHOD_ATTRIBUTE_PINVOKE_IMPL | METHOD_ATTRIBUTE_ABSTRACT)) ||\n\t\t\t(mb->iattrs & (METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL | METHOD_IMPL_ATTRIBUTE_RUNTIME)))\n\t\treturn 0;\n\n\t/*if (mb->name)\n\t\tg_print (\"Encode method %s\\n\", mono_string_to_utf8 (mb->name));*/\n\tif (mb->ilgen) {\n\t\tcode = mb->ilgen->code;\n\t\tcode_size = mb->ilgen->code_len;\n\t\tmax_stack = mb->ilgen->max_stack;\n\t\tnum_locals = mb->ilgen->locals ? mono_array_length (mb->ilgen->locals) : 0;\n\t\tif (mb->ilgen->ex_handlers)\n\t\t\tnum_exception = method_count_clauses (mb->ilgen);\n\t} else {\n\t\tcode = mb->code;\n\t\tif (code == NULL){\n\t\t\tchar *name = mono_string_to_utf8 (mb->name);\n\t\t\tchar *str = g_strdup_printf (\"Method %s does not have any IL associated\", name);\n\t\t\tMonoException *exception = mono_get_exception_argument (NULL, \"a method does not have any IL associated\");\n\t\t\tg_free (str);\n\t\t\tg_free (name);\n\t\t\tmono_raise_exception (exception);\n\t\t}\n\n\t\tcode_size = mono_array_length (code);\n\t\tmax_stack = 8; /* we probably need to run a verifier on the code... */\n\t}\n\n\tstream_data_align (&assembly->code);\n\n\t/* check for exceptions, maxstack, locals */\n\tmaybe_small = (max_stack <= 8) && (!num_locals) && (!num_exception);\n\tif (maybe_small) {\n\t\tif (code_size < 64 && !(code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x2;\n\t\t} else if (code_size < 32 && (code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x6; /* LAMESPEC: see metadata.c */\n\t\t} else {\n\t\t\tgoto fat_header;\n\t\t}\n\t\tidx = mono_image_add_stream_data (&assembly->code, &flags, 1);\n\t\t/* add to the fixup todo list */\n\t\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 1));\n\t\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\t\treturn assembly->text_rva + idx;\n\t} \nfat_header:\n\tif (num_locals)\n\t\tlocal_sig = MONO_TOKEN_SIGNATURE | encode_locals (assembly, mb->ilgen);\n\t/* \n\t * FIXME: need to set also the header size in fat_flags.\n\t * (and more sects and init locals flags)\n\t */\n\tfat_flags =  0x03;\n\tif (num_exception)\n\t\tfat_flags |= METHOD_HEADER_MORE_SECTS;\n\tif (mb->init_locals)\n\t\tfat_flags |= METHOD_HEADER_INIT_LOCALS;\n\tfat_header [0] = fat_flags;\n\tfat_header [1] = (header_size / 4 ) << 4;\n\tshort_value = GUINT16_TO_LE (max_stack);\n\tmemcpy (fat_header + 2, &short_value, 2);\n\tint_value = GUINT32_TO_LE (code_size);\n\tmemcpy (fat_header + 4, &int_value, 4);\n\tint_value = GUINT32_TO_LE (local_sig);\n\tmemcpy (fat_header + 8, &int_value, 4);\n\tidx = mono_image_add_stream_data (&assembly->code, fat_header, 12);\n\t/* add to the fixup todo list */\n\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 12));\n\t\n\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\tif (num_exception) {\n\t\tunsigned char sheader [4];\n\t\tMonoILExceptionInfo * ex_info;\n\t\tMonoILExceptionBlock * ex_block;\n\t\tint j;\n\n\t\tstream_data_align (&assembly->code);\n\t\t/* always use fat format for now */\n\t\tsheader [0] = METHOD_HEADER_SECTION_FAT_FORMAT | METHOD_HEADER_SECTION_EHTABLE;\n\t\tnum_exception *= 6 * sizeof (guint32);\n\t\tnum_exception += 4; /* include the size of the header */\n\t\tsheader [1] = num_exception & 0xff;\n\t\tsheader [2] = (num_exception >> 8) & 0xff;\n\t\tsheader [3] = (num_exception >> 16) & 0xff;\n\t\tmono_image_add_stream_data (&assembly->code, (char*)sheader, 4);\n\t\t/* fat header, so we are already aligned */\n\t\t/* reverse order */\n\t\tfor (i = mono_array_length (mb->ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\t\tex_info = (MonoILExceptionInfo *)mono_array_addr (mb->ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\t\tif (ex_info->handlers) {\n\t\t\t\tint finally_start = ex_info->start + ex_info->len;\n\t\t\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\t\t\tguint32 val;\n\t\t\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\t\t\t/* the flags */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->type);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* try offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_info->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* need fault, too, probably */\n\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\t\t\tval = GUINT32_TO_LE (finally_start - ex_info->start);\n\t\t\t\t\telse\n\t\t\t\t\t\tval = GUINT32_TO_LE (ex_info->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler len */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\tfinally_start = ex_block->start + ex_block->len;\n\t\t\t\t\tif (ex_block->extype) {\n\t\t\t\t\t\tval = mono_metadata_token_from_dor (mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\t\t\tval = ex_block->filter_offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tval = 0;\n\t\t\t\t\t}\n\t\t\t\t\tval = GUINT32_TO_LE (val);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/*g_print (\"out clause %d: from %d len=%d, handler at %d, %d, finally_start=%d, ex_info->start=%d, ex_info->len=%d, ex_block->type=%d, j=%d, i=%d\\n\", \n\t\t\t\t\t\t\tclause.flags, clause.try_offset, clause.try_len, clause.handler_offset, clause.handler_len, finally_start, ex_info->start, ex_info->len, ex_block->type, j, i);*/\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tg_error (\"No clauses for ex info block %d\", i);\n\t\t\t}\n\t\t}\n\t}\n\treturn assembly->text_rva + idx;\n}\n\nstatic guint32\nfind_index_in_table (MonoDynamicImage *assembly, int table_idx, int col, guint32 token)\n{\n\tint i;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [table_idx];\n\n\tg_assert (col < table->columns);\n\n\tvalues = table->values + table->columns;\n\tfor (i = 1; i <= table->rows; ++i) {\n\t\tif (values [col] == token)\n\t\t\treturn i;\n\t\tvalues += table->columns;\n\t}\n\treturn 0;\n}\n\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic MonoCustomAttrInfo*\nlookup_custom_attr (MonoImage *image, gpointer member)\n{\n\tMonoCustomAttrInfo* res;\n\n\tres = mono_image_property_lookup (image, member, MONO_PROP_DYNAMIC_CATTR);\n\n\tif (!res)\n\t\treturn NULL;\n\n\treturn g_memdup (res, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * res->num_attrs);\n}\n\nstatic gboolean\ncustom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)\n{\n\t/* FIXME: Need to do more checks */\n\tif (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {\n\t\tint visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\n\t\tif ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_builders (MonoImage *alloc_img, MonoImage *image, MonoArray *cattrs)\n{\n\tint i, index, count, not_visible;\n\tMonoCustomAttrInfo *ainfo;\n\tMonoReflectionCustomAttr *cattr;\n\n\tif (!cattrs)\n\t\treturn NULL;\n\t/* FIXME: check in assembly the Run flag is set */\n\n\tcount = mono_array_length (cattrs);\n\n\t/* Skip nonpublic attributes since MS.NET seems to do the same */\n\t/* FIXME: This needs to be done more globally */\n\tnot_visible = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (!custom_attr_visible (image, cattr))\n\t\t\tnot_visible ++;\n\t}\n\tcount -= not_visible;\n\n\tainfo = image_g_malloc0 (alloc_img, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * count);\n\n\tainfo->image = image;\n\tainfo->num_attrs = count;\n\tainfo->cached = alloc_img != NULL;\n\tindex = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (custom_attr_visible (image, cattr)) {\n\t\t\tunsigned char *saved = mono_image_alloc (image, mono_array_length (cattr->data));\n\t\t\tmemcpy (saved, mono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\t\tainfo->attrs [index].ctor = cattr->ctor->method;\n\t\t\tainfo->attrs [index].data = saved;\n\t\t\tainfo->attrs [index].data_size = mono_array_length (cattr->data);\n\t\t\tindex ++;\n\t\t}\n\t}\n\n\treturn ainfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic void\nmono_save_custom_attrs (MonoImage *image, void *obj, MonoArray *cattrs)\n{\n\tMonoCustomAttrInfo *ainfo, *tmp;\n\n\tif (!cattrs || !mono_array_length (cattrs))\n\t\treturn;\n\n\tainfo = mono_custom_attrs_from_builders (image, image, cattrs);\n\n\tmono_loader_lock ();\n\ttmp = mono_image_property_lookup (image, obj, MONO_PROP_DYNAMIC_CATTR);\n\tif (tmp)\n\t\tmono_custom_attrs_free (tmp);\n\tmono_image_property_insert (image, obj, MONO_PROP_DYNAMIC_CATTR, ainfo);\n\tmono_loader_unlock ();\n\n}\n#endif\n\nvoid\nmono_custom_attrs_free (MonoCustomAttrInfo *ainfo)\n{\n\tif (!ainfo->cached)\n\t\tg_free (ainfo);\n}\n\n/*\n * idx is the table index of the object\n * type is one of MONO_CUSTOM_ATTR_*\n */\nstatic void\nmono_image_add_cattrs (MonoDynamicImage *assembly, guint32 idx, guint32 type, MonoArray *cattrs)\n{\n\tMonoDynamicTable *table;\n\tMonoReflectionCustomAttr *cattr;\n\tguint32 *values;\n\tguint32 count, i, token;\n\tchar blob_size [6];\n\tchar *p = blob_size;\n\t\n\t/* it is legal to pass a NULL cattrs: we avoid to use the if in a lot of places */\n\tif (!cattrs)\n\t\treturn;\n\tcount = mono_array_length (cattrs);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_CUSTOM_ATTR_SIZE;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= type;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tvalues [MONO_CUSTOM_ATTR_PARENT] = idx;\n\t\ttoken = mono_image_create_token (assembly, (MonoObject*)cattr->ctor, FALSE, FALSE);\n\t\ttype = mono_metadata_token_index (token);\n\t\ttype <<= MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (mono_metadata_token_table (token)) {\n\t\tcase MONO_TABLE_METHOD:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_MEMBERREF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_warning (\"got wrong token in custom attr\");\n\t\t\tcontinue;\n\t\t}\n\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = type;\n\t\tp = blob_size;\n\t\tmono_metadata_encode_value (mono_array_length (cattr->data), p, &p);\n\t\tvalues [MONO_CUSTOM_ATTR_VALUE] = add_to_blob_cached (assembly, blob_size, p - blob_size,\n\t\t\tmono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\tvalues += MONO_CUSTOM_ATTR_SIZE;\n\t\t++table->next_idx;\n\t}\n}\n\nstatic void\nmono_image_add_decl_security (MonoDynamicImage *assembly, guint32 parent_token, MonoArray *permissions)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 count, i, idx;\n\tMonoReflectionPermissionSet *perm;\n\n\tif (!permissions)\n\t\treturn;\n\n\tcount = mono_array_length (permissions);\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\n\tfor (i = 0; i < mono_array_length (permissions); ++i) {\n\t\tperm = (MonoReflectionPermissionSet*)mono_array_addr (permissions, MonoReflectionPermissionSet, i);\n\n\t\tvalues = table->values + table->next_idx * MONO_DECL_SECURITY_SIZE;\n\n\t\tidx = mono_metadata_token_index (parent_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tswitch (mono_metadata_token_table (parent_token)) {\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_ASSEMBLY:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tvalues [MONO_DECL_SECURITY_ACTION] = perm->action;\n\t\tvalues [MONO_DECL_SECURITY_PARENT] = idx;\n\t\tvalues [MONO_DECL_SECURITY_PERMISSIONSET] = add_mono_string_to_blob_cached (assembly, perm->pset);\n\n\t\t++table->next_idx;\n\t}\n}\n\n/*\n * Fill in the MethodDef and ParamDef tables for a method.\n * This is used for both normal methods and constructors.\n */\nstatic void\nmono_image_basic_method (ReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint i, count;\n\n\t/* room in this table is already allocated */\n\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t*mb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->method_to_table_idx, mb->mhandle, GUINT_TO_POINTER ((*mb->table_idx)));\n\tvalues = table->values + *mb->table_idx * MONO_METHOD_SIZE;\n\tvalues [MONO_METHOD_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\tvalues [MONO_METHOD_FLAGS] = mb->attrs;\n\tvalues [MONO_METHOD_IMPLFLAGS] = mb->iattrs;\n\tvalues [MONO_METHOD_SIGNATURE] = method_builder_encode_signature (assembly, mb);\n\tvalues [MONO_METHOD_RVA] = method_encode_code (assembly, mb);\n\t\n\ttable = &assembly->tables [MONO_TABLE_PARAM];\n\tvalues [MONO_METHOD_PARAMLIST] = table->next_idx;\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_METHOD, *mb->table_idx), mb->permissions);\n\n\tif (mb->pinfo) {\n\t\tMonoDynamicTable *mtable;\n\t\tguint32 *mvalues;\n\t\t\n\t\tmtable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\tmvalues = mtable->values + mtable->next_idx * MONO_FIELD_MARSHAL_SIZE;\n\t\t\n\t\tcount = 0;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tif (mono_array_get (mb->pinfo, gpointer, i))\n\t\t\t\tcount++;\n\t\t}\n\t\ttable->rows += count;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_PARAM_SIZE;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (mb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tvalues [MONO_PARAM_FLAGS] = pb->attrs;\n\t\t\t\tvalues [MONO_PARAM_SEQUENCE] = i;\n\t\t\t\tif (pb->name != NULL) {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\t\t\t\t} else {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = 0;\n\t\t\t\t}\n\t\t\t\tvalues += MONO_PARAM_SIZE;\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tmtable->rows++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_PARENT] = (table->next_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_PARAMDEF;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t\tpb->table_idx = table->next_idx++;\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tguint32 field_type = 0;\n\t\t\t\t\tmtable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\t\t\t\tmtable->rows ++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_CONSTANT_SIZE;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_PARAM | (pb->table_idx << MONO_HASCONSTANT_BITS);\n\t\t\t\t\tmvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, pb->def_value, &field_type);\n\t\t\t\t\tmvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PADDING] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nreflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_reflection_type_resolve_user_types ((MonoReflectionType*)mb->rtype);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = mb->generic_params;\n\trmb->generic_container = mb->generic_container;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = mb->code;\n\trmb->type = mb->type;\n\trmb->name = mb->name;\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = mb->return_modreq;\n\trmb->return_modopt = mb->return_modopt;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n\n\tif (mb->dll) {\n\t\trmb->charset = mb->charset;\n\t\trmb->extra_flags = mb->extra_flags;\n\t\trmb->native_cc = mb->native_cc;\n\t\trmb->dllentry = mb->dllentry;\n\t\trmb->dll = mb->dll;\n\t}\n}\n\nstatic void\nreflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb)\n{\n\tconst char *name = mb->attrs & METHOD_ATTRIBUTE_STATIC ? \".cctor\": \".ctor\";\n\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_type_get_object (mono_domain_get (), &mono_defaults.void_class->byval_arg);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = mb->type;\n\trmb->name = mono_string_new (mono_domain_get (), name);\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\n\nstatic void\nreflection_methodbuilder_from_dynamic_method (ReflectionMethodBuilder *rmb, MonoReflectionDynamicMethod *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mb->rtype;\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = NULL;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = 0;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = (MonoObject *) mb->owner;\n\trmb->name = mb->name;\n\trmb->table_idx = NULL;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = mb->skip_visibility;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = NULL;\n\trmb->param_modopt = NULL;\n\trmb->permissions = NULL;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\t\n#endif\n\nstatic void\nmono_image_add_methodimpl (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)mb->type;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 tok;\n\n\tif (!mb->override_method)\n\t\treturn;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODIMPL];\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->rows * MONO_METHODIMPL_SIZE;\n\tvalues [MONO_METHODIMPL_CLASS] = tb->table_idx;\n\tvalues [MONO_METHODIMPL_BODY] = MONO_METHODDEFORREF_METHODDEF | (mb->table_idx << MONO_METHODDEFORREF_BITS);\n\n\ttok = mono_image_create_token (assembly, (MonoObject*)mb->override_method, FALSE, FALSE);\n\tswitch (mono_metadata_token_table (tok)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\tvalues [MONO_METHODIMPL_DECLARATION] = tok;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nmono_image_get_method_info (MonoReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tReflectionMethodBuilder rmb;\n\tint i;\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n\n\tif (mb->dll) { /* It's a P/Invoke method */\n\t\tguint32 moduleref;\n\t\t/* map CharSet values to on-disk values */\n\t\tint ncharset = (mb->charset ? (mb->charset - 1) * 2 : 0);\n\t\tint extra_flags = mb->extra_flags;\n\t\ttable = &assembly->tables [MONO_TABLE_IMPLMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_IMPLMAP_SIZE;\n\t\t\n\t\tvalues [MONO_IMPLMAP_FLAGS] = (mb->native_cc << 8) | ncharset | extra_flags;\n\t\tvalues [MONO_IMPLMAP_MEMBER] = (mb->table_idx << 1) | 1; /* memberforwarded: method */\n\t\tif (mb->dllentry)\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->dllentry);\n\t\telse\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\t\tmoduleref = string_heap_insert_mstring (&assembly->sheap, mb->dll);\n\t\tif (!(values [MONO_IMPLMAP_SCOPE] = find_index_in_table (assembly, MONO_TABLE_MODULEREF, MONO_MODULEREF_NAME, moduleref))) {\n\t\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\t\ttable->rows ++;\n\t\t\talloc_table (table, table->rows);\n\t\t\ttable->values [table->rows * MONO_MODULEREF_SIZE + MONO_MODULEREF_NAME] = moduleref;\n\t\t\tvalues [MONO_IMPLMAP_SCOPE] = table->rows;\n\t\t}\n\t}\n\n\tif (mb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (mb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (mb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_METHOD | (mb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (mb->generic_params, gpointer, i), owner, assembly);\n\t\t}\n\t}\n\n}\n\nstatic void\nmono_image_get_ctor_info (MonoDomain *domain, MonoReflectionCtorBuilder *mb, MonoDynamicImage *assembly)\n{\n\tReflectionMethodBuilder rmb;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n}\n#endif\n\nstatic char*\ntype_get_fully_qualified_name (MonoType *type)\n{\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\nstatic char*\ntype_get_qualified_name (MonoType *type, MonoAssembly *ass) {\n\tMonoClass *klass;\n\tMonoAssembly *ta;\n\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass) \n\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\tta = klass->image->assembly;\n\tif (ta->dynamic || (ta == ass)) {\n\t\tif (klass->generic_class || klass->generic_container)\n\t\t\t/* For generic type definitions, we want T, while REFLECTION returns T<K> */\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_FULL_NAME);\n\t\telse\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\t}\n\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*field_image is the image to which the eventual custom mods have been encoded against*/\nstatic guint32\nfieldref_encode_signature (MonoDynamicImage *assembly, MonoImage *field_image, MonoType *type)\n{\n\tSigBuffer buf;\n\tguint32 idx, i, token;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\t/* encode custom attributes before the type */\n\tif (type->num_mods) {\n\t\tfor (i = 0; i < type->num_mods; ++i) {\n\t\t\tif (field_image) {\n\t\t\t\tMonoClass *class = mono_class_get (field_image, type->modifiers [i].token);\n\t\t\t\tg_assert (class);\n\t\t\t\ttoken = mono_image_typedef_or_ref (assembly, &class->byval_arg);\n\t\t\t} else {\n\t\t\t\ttoken = type->modifiers [i].token;\n\t\t\t}\n\n\t\t\tif (type->modifiers [i].required)\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_REQD);\n\t\t\telse\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_OPT);\n\n\t\t\tsigbuffer_add_value (&buf, token);\n\t\t}\n\t}\n\tencode_type (assembly, type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nfield_encode_signature (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\tencode_custom_modifiers (assembly, fb->modreq, fb->modopt, &buf);\n\t/* encode custom attributes before the type */\n\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type) {\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tchar *p, *box_val;\n\tchar* buf;\n\tguint32 idx = 0, len = 0, dummy = 0;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\tguint32 fpa_double [2];\n\tguint32 *fpa_p;\n#endif\n#endif\n\t\n\tp = buf = g_malloc (64);\n\tif (!val) {\n\t\t*ret_type = MONO_TYPE_CLASS;\n\t\tlen = 4;\n\t\tbox_val = (char*)&dummy;\n\t} else {\n\t\tbox_val = ((char*)val) + sizeof (MonoObject);\n\t\t*ret_type = val->vtable->klass->byval_arg.type;\n\t}\nhandle_enum:\n\tswitch (*ret_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\tlen = 1;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tlen = 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tlen = 4;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tlen = 8;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tlen = 8;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tfpa_p = (guint32*)box_val;\n\t\tfpa_double [0] = fpa_p [1];\n\t\tfpa_double [1] = fpa_p [0];\n\t\tbox_val = (char*)fpa_double;\n#endif\n#endif\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (val->vtable->klass->enumtype) {\n\t\t\t*ret_type = mono_class_enum_basetype (val->vtable->klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else\n\t\t\tg_error (\"we can't encode valuetypes\");\n\tcase MONO_TYPE_CLASS:\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tMonoString *str = (MonoString*)val;\n\t\t/* there is no signature */\n\t\tlen = str->length * 2;\n\t\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t\t{\n\t\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\t\tg_free (swapped);\n\t\t}\n#else\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\n\t\tg_free (buf);\n\t\treturn idx;\n\t}\n\tcase MONO_TYPE_GENERICINST:\n\t\t*ret_type = val->vtable->klass->generic_class->container_class->byval_arg.type;\n\t\tgoto handle_enum;\n\tdefault:\n\t\tg_error (\"we don't encode constant type 0x%02x yet\", *ret_type);\n\t}\n\n\t/* there is no signature */\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tidx = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tswap_with_size (blob_size, box_val, len, 1);\n\tmono_image_add_stream_data (&assembly->blob, blob_size, len);\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, box_val, len);\n#endif\n\n\tg_free (buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo) {\n\tchar *str;\n\tSigBuffer buf;\n\tguint32 idx, len;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, minfo->type);\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tsigbuffer_add_value (&buf, minfo->count);\n\t\tbreak;\n\tcase MONO_NATIVE_LPARRAY:\n\t\tif (minfo->eltype || minfo->has_size) {\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\t\tif (minfo->has_size) {\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? minfo->param_num: 0);\n\t\t\t\tsigbuffer_add_value (&buf, minfo->count != -1? minfo->count: 0);\n\n\t\t\t\t/* LAMESPEC: ElemMult is undocumented */\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? 1: 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MONO_NATIVE_SAFEARRAY:\n\t\tif (minfo->eltype)\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\tbreak;\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->guid) {\n\t\t\tstr = mono_string_to_utf8 (minfo->guid);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\t/* native type name */\n\t\tsigbuffer_add_value (&buf, 0);\n\t\t/* custom marshaler type name */\n\t\tif (minfo->marshaltype || minfo->marshaltyperef) {\n\t\t\tif (minfo->marshaltyperef)\n\t\t\t\tstr = type_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\t\telse\n\t\t\t\tstr = mono_string_to_utf8 (minfo->marshaltype);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\t/* FIXME: Actually a bug, since this field is required.  Punting for now ... */\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tif (minfo->mcookie) {\n\t\t\tstr = mono_string_to_utf8 (minfo->mcookie);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_field_info (MonoReflectionFieldBuilder *fb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\t/* maybe this fixup should be done in the C# code */\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL)\n\t\tfb->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\tfb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->field_to_table_idx, fb->handle, GUINT_TO_POINTER (fb->table_idx));\n\tvalues = table->values + fb->table_idx * MONO_FIELD_SIZE;\n\tvalues [MONO_FIELD_NAME] = string_heap_insert_mstring (&assembly->sheap, fb->name);\n\tvalues [MONO_FIELD_FLAGS] = fb->attrs;\n\tvalues [MONO_FIELD_SIGNATURE] = field_encode_signature (assembly, fb);\n\n\tif (fb->offset != -1) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDLAYOUT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_LAYOUT_SIZE;\n\t\tvalues [MONO_FIELD_LAYOUT_FIELD] = fb->table_idx;\n\t\tvalues [MONO_FIELD_LAYOUT_OFFSET] = fb->offset;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL) {\n\t\tguint32 field_type = 0;\n\t\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CONSTANT_SIZE;\n\t\tvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_FIEDDEF | (fb->table_idx << MONO_HASCONSTANT_BITS);\n\t\tvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, fb->def_value, &field_type);\n\t\tvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\tvalues [MONO_CONSTANT_PADDING] = 0;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) {\n\t\tguint32 rva_idx;\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDRVA];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_RVA_SIZE;\n\t\tvalues [MONO_FIELD_RVA_FIELD] = fb->table_idx;\n\t\t/*\n\t\t * We store it in the code section because it's simpler for now.\n\t\t */\n\t\tif (fb->rva_data) {\n\t\t\tif (mono_array_length (fb->rva_data) >= 10)\n\t\t\t\tstream_data_align (&assembly->code);\n\t\t\trva_idx = mono_image_add_stream_data (&assembly->code, mono_array_addr (fb->rva_data, char, 0), mono_array_length (fb->rva_data));\n\t\t} else\n\t\t\trva_idx = mono_image_add_stream_zero (&assembly->code, mono_class_value_size (fb->handle->parent, NULL));\n\t\tvalues [MONO_FIELD_RVA_RVA] = rva_idx + assembly->text_rva;\n\t}\n\tif (fb->marshal_info) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\tvalues [MONO_FIELD_MARSHAL_PARENT] = (fb->table_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_FIELDSREF;\n\t\tvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, fb->marshal_info);\n\t}\n}\n\nstatic guint32\nproperty_encode_signature (MonoDynamicImage *assembly, MonoReflectionPropertyBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 nparams = 0;\n\tMonoReflectionMethodBuilder *mb = fb->get_method;\n\tMonoReflectionMethodBuilder *smb = fb->set_method;\n\tguint32 idx, i;\n\n\tif (mb && mb->parameters)\n\t\tnparams = mono_array_length (mb->parameters);\n\tif (!mb && smb && smb->parameters)\n\t\tnparams = mono_array_length (smb->parameters) - 1;\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_byte (&buf, 0x08);\n\tsigbuffer_add_value (&buf, nparams);\n\tif (mb) {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)mb->rtype, &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else if (smb && smb->parameters) {\n\t\t/* the property type is the last param */\n\t\tencode_reflection_type (assembly, mono_array_get (smb->parameters, MonoReflectionType*, nparams), &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (smb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_property_info (MonoReflectionPropertyBuilder *pb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * PROPERTYMAP (info already filled in _get_type_info ())\n\t * PROPERTY    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\tpb->table_idx = table->next_idx ++;\n\tvalues = table->values + pb->table_idx * MONO_PROPERTY_SIZE;\n\tvalues [MONO_PROPERTY_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\tvalues [MONO_PROPERTY_FLAGS] = pb->attrs;\n\tvalues [MONO_PROPERTY_TYPE] = property_encode_signature (assembly, pb);\n\n\t/* FIXME: we still don't handle 'other' methods */\n\tif (pb->get_method) num_methods ++;\n\tif (pb->set_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (pb->get_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_GETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->get_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n\tif (pb->set_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_SETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->set_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n}\n\nstatic void\nmono_image_get_event_info (MonoReflectionEventBuilder *eb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * EVENTMAP (info already filled in _get_type_info ())\n\t * EVENT    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\teb->table_idx = table->next_idx ++;\n\tvalues = table->values + eb->table_idx * MONO_EVENT_SIZE;\n\tvalues [MONO_EVENT_NAME] = string_heap_insert_mstring (&assembly->sheap, eb->name);\n\tvalues [MONO_EVENT_FLAGS] = eb->attrs;\n\tvalues [MONO_EVENT_TYPE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (eb->type));\n\n\t/*\n\t * FIXME: we still don't handle 'other' methods \n\t */\n\tif (eb->add_method) num_methods ++;\n\tif (eb->remove_method) num_methods ++;\n\tif (eb->raise_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (eb->add_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_ADD_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->add_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->remove_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_REMOVE_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->remove_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->raise_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_FIRE;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->raise_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n}\n\nstatic void\nencode_constraints (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 num_constraints, i;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAMCONSTRAINT];\n\tnum_constraints = gparam->iface_constraints ?\n\t\tmono_array_length (gparam->iface_constraints) : 0;\n\ttable->rows += num_constraints;\n\tif (gparam->base_type)\n\t\ttable->rows++;\n\talloc_table (table, table->rows);\n\n\tif (gparam->base_type) {\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (gparam->base_type));\n\t}\n\n\tfor (i = 0; i < num_constraints; i++) {\n\t\tMonoReflectionType *constraint = mono_array_get (\n\t\t\tgparam->iface_constraints, gpointer, i);\n\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (constraint));\n\t}\n}\n\nstatic void\nmono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tGenericParamTableEntry *entry;\n\n\t/*\n\t * The GenericParam table must be sorted according to the `owner' field.\n\t * We need to do this sorting prior to writing the GenericParamConstraint\n\t * table, since we have to use the final GenericParam table indices there\n\t * and they must also be sorted.\n\t */\n\n\tentry = g_new0 (GenericParamTableEntry, 1);\n\tentry->owner = owner;\n\t/* FIXME: track where gen_params should be freed and remove the GC root as well */\n\tMOVING_GC_REGISTER (&entry->gparam);\n\tentry->gparam = gparam;\n\n\tg_ptr_array_add (assembly->gen_params, entry);\n}\n\nstatic void\nwrite_generic_param_entry (MonoDynamicImage *assembly, GenericParamTableEntry *entry)\n{\n\tMonoDynamicTable *table;\n\tMonoGenericParam *param;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\ttable_idx = table->next_idx ++;\n\tvalues = table->values + table_idx * MONO_GENERICPARAM_SIZE;\n\n\tparam = mono_reflection_type_get_handle ((MonoReflectionType*)entry->gparam)->data.generic_param;\n\n\tvalues [MONO_GENERICPARAM_OWNER] = entry->owner;\n\tvalues [MONO_GENERICPARAM_FLAGS] = entry->gparam->attrs;\n\tvalues [MONO_GENERICPARAM_NUMBER] = mono_generic_param_num (param);\n\tvalues [MONO_GENERICPARAM_NAME] = string_heap_insert (&assembly->sheap, mono_generic_param_info (param)->name);\n\n\tmono_image_add_cattrs (assembly, table_idx, MONO_CUSTOM_ATTR_GENERICPAR, entry->gparam->cattrs);\n\n\tencode_constraints (entry->gparam, table_idx, assembly);\n}\n\nstatic guint32\nresolution_scope_from_image (MonoDynamicImage *assembly, MonoImage *image)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\tguint32 cols [MONO_ASSEMBLY_SIZE];\n\tconst char *pubkey;\n\tguint32 publen;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, image))))\n\t\treturn token;\n\n\tif (image->assembly->dynamic && (image->assembly == assembly->image.assembly)) {\n\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\ttoken = table->next_idx ++;\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + token * MONO_MODULEREF_SIZE;\n\t\tvalues [MONO_MODULEREF_NAME] = string_heap_insert (&assembly->sheap, image->module_name);\n\n\t\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\t\ttoken |= MONO_RESOLTION_SCOPE_MODULEREF;\n\t\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\n\t\treturn token;\n\t}\n\t\n\tif (image->assembly->dynamic)\n\t\t/* FIXME: */\n\t\tmemset (cols, 0, sizeof (cols));\n\telse {\n\t\t/* image->assembly->image is the manifest module */\n\t\timage = image->assembly->image;\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_ASSEMBLY], 0, cols, MONO_ASSEMBLY_SIZE);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLYREF];\n\ttoken = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + token * MONO_ASSEMBLYREF_SIZE;\n\tvalues [MONO_ASSEMBLYREF_NAME] = string_heap_insert (&assembly->sheap, image->assembly_name);\n\tvalues [MONO_ASSEMBLYREF_MAJOR_VERSION] = cols [MONO_ASSEMBLY_MAJOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_MINOR_VERSION] = cols [MONO_ASSEMBLY_MINOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_BUILD_NUMBER] = cols [MONO_ASSEMBLY_BUILD_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_REV_NUMBER] = cols [MONO_ASSEMBLY_REV_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_FLAGS] = 0;\n\tvalues [MONO_ASSEMBLYREF_CULTURE] = 0;\n\tvalues [MONO_ASSEMBLYREF_HASH_VALUE] = 0;\n\n\tif (strcmp (\"\", image->assembly->aname.culture)) {\n\t\tvalues [MONO_ASSEMBLYREF_CULTURE] = string_heap_insert (&assembly->sheap,\n\t\t\t\timage->assembly->aname.culture);\n\t}\n\n\tif ((pubkey = mono_image_get_public_key (image, &publen))) {\n\t\tguchar pubtoken [9];\n\t\tpubtoken [0] = 8;\n\t\tmono_digest_get_public_token (pubtoken + 1, (guchar*)pubkey, publen);\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = mono_image_add_stream_data (&assembly->blob, (char*)pubtoken, 9);\n\t} else {\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = 0;\n\t}\n\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\ttoken |= MONO_RESOLTION_SCOPE_ASSEMBLYREF;\n\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\ncreate_typespec (MonoDynamicImage *assembly, MonoType *type)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type))))\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\tswitch (type->type) {\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\t\tif (!k || !k->generic_container) {\n\t\t\tsigbuffer_free (&buf);\n\t\t\treturn 0;\n\t\t}\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsigbuffer_free (&buf);\n\t\treturn 0;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\nstatic guint32\nmono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, scope, enclosing;\n\tMonoClass *klass;\n\n\t/* if the type requires a typespec, we must try that first*/\n\tif (try_typespec && (token = create_typespec (assembly, type)))\n\t\treturn token;\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typeref, type));\n\tif (token)\n\t\treturn token;\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass)\n\t\tklass = mono_class_from_mono_type (type);\n\n\t/*\n\t * If it's in the same module and not a generic type parameter:\n\t */\n\tif ((klass->image == &assembly->image) && (type->type != MONO_TYPE_VAR) && \n\t\t\t(type->type != MONO_TYPE_MVAR)) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\t\ttoken = MONO_TYPEDEFORREF_TYPEDEF | (tb->table_idx << MONO_TYPEDEFORREF_BITS);\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\t\treturn token;\n\t}\n\n\tif (klass->nested_in) {\n\t\tenclosing = mono_image_typedef_or_ref_full (assembly, &klass->nested_in->byval_arg, FALSE);\n\t\t/* get the typeref idx of the enclosing type */\n\t\tenclosing >>= MONO_TYPEDEFORREF_BITS;\n\t\tscope = (enclosing << MONO_RESOLTION_SCOPE_BITS) | MONO_RESOLTION_SCOPE_TYPEREF;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t}\n\ttable = &assembly->tables [MONO_TABLE_TYPEREF];\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPEREF_SIZE;\n\t\tvalues [MONO_TYPEREF_SCOPE] = scope;\n\t\tvalues [MONO_TYPEREF_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\t\tvalues [MONO_TYPEREF_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\t}\n\ttoken = MONO_TYPEDEFORREF_TYPEREF | (table->next_idx << MONO_TYPEDEFORREF_BITS); /* typeref */\n\tg_hash_table_insert (assembly->typeref, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\treturn token;\n}\n\n/*\n * Despite the name, we handle also TypeSpec (with the above helper).\n */\nstatic guint32\nmono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)\n{\n\treturn mono_image_typedef_or_ref_full (assembly, type, TRUE);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * Insert a memberef row into the metadata: the token that point to the memberref\n * is returned. Caching is done in the caller (mono_image_get_methodref_token() or\n * mono_image_get_fieldref_token()).\n * The sig param is an index to an already built signature.\n */\nstatic guint32\nmono_image_get_memberref_token (MonoDynamicImage *assembly, MonoType *type, const char *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, pclass;\n\tguint32 parent;\n\n\tparent = mono_image_typedef_or_ref (assembly, type);\n\tswitch (parent & MONO_TYPEDEFORREF_MASK) {\n\tcase MONO_TYPEDEFORREF_TYPEREF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEREF;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPESPEC:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPEDEF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_warning (\"unknown typeref or def token 0x%08x for %s\", parent, name);\n\t\treturn 0;\n\t}\n\t/* extract the index */\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec)\n{\n\tguint32 token;\n\tMonoMethodSignature *sig;\n\t\n\tcreate_typespec = create_typespec && method->is_generic && method->klass->image != &assembly->image;\n\n\tif (create_typespec) {\n\t\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1)));\n\t\tif (token)\n\t\t\treturn token;\n\t} \n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token && !create_typespec)\n\t\treturn token;\n\n\tg_assert (!method->is_inflated);\n\tif (!token) {\n\t\t/*\n\t\t * A methodref signature can't contain an unmanaged calling convention.\n\t\t */\n\t\tsig = mono_metadata_signature_dup (mono_method_signature (method));\n\t\tif ((sig->call_convention != MONO_CALL_DEFAULT) && (sig->call_convention != MONO_CALL_VARARG))\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\ttoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg,\n\t\t\tmethod->name,  method_encode_signature (assembly, sig));\n\t\tg_free (sig);\n\t\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\t}\n\n\tif (create_typespec) {\n\t\tMonoDynamicTable *table = &assembly->tables [MONO_TABLE_METHODSPEC];\n\t\tg_assert (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF);\n\t\ttoken = (mono_metadata_token_index (token) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\n\t\tif (assembly->save) {\n\t\t\tguint32 *values;\n\n\t\t\talloc_table (table, table->rows + 1);\n\t\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\t\tvalues [MONO_METHODSPEC_METHOD] = token;\n\t\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_sig (assembly, &mono_method_get_generic_container (method)->context);\n\t\t}\n\n\t\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\t\ttable->next_idx ++;\n\t\t/*methodspec and memberef tokens are diferent, */\n\t\tg_hash_table_insert (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1), GUINT_TO_POINTER (token));\n\t\treturn token;\n\t}\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tname = mono_string_to_utf8 (method->name);\n\treflection_methodbuilder_from_method_builder (&rmb, method);\n\n\t/*\n\t * A methodref signature can't contain an unmanaged calling convention.\n\t * Since some flags are encoded as part of call_conv, we need to check against it.\n\t*/\n\tif ((rmb.call_conv & ~0x60) != MONO_CALL_DEFAULT && (rmb.call_conv & ~0x60) != MONO_CALL_VARARG)\n\t\trmb.call_conv = (rmb.call_conv & 0x60) | MONO_CALL_DEFAULT;\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\t\t\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_varargs_method_token (MonoDynamicImage *assembly, guint32 original,\n\t\t\t\t     const gchar *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = original;\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_definition_sig (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = mono_array_length (mb->generic_params);\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0xa);\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++) {\n\t\tsigbuffer_add_value (&buf, MONO_TYPE_MVAR);\n\t\tsigbuffer_add_value (&buf, i);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmono_image_get_methodspec_token_for_generic_method_definition (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0;\n\n\ttoken = GPOINTER_TO_UINT (mono_g_hash_table_lookup (assembly->methodspec, mb));\n\tif (token)\n\t\treturn token;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tmtoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_definition_sig (assembly, mb);\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\tmono_g_hash_table_insert (assembly->methodspec, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec)\n{\n\tguint32 token;\n\t\n\tif (mb->generic_params && create_methodspec) \n\t\treturn mono_image_get_methodspec_token_for_generic_method_definition (assembly, mb);\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\ttoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *mb)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n#endif\n\nstatic gboolean\nis_field_on_inst (MonoClassField *field)\n{\n\treturn (field->parent->generic_class && field->parent->generic_class->is_dynamic && ((MonoDynamicGenericClass*)field->parent->generic_class)->fields);\n}\n\n/*\n * If FIELD is a field of a MonoDynamicGenericClass, return its non-inflated type.\n */\nstatic MonoType*\nget_field_on_inst_generic_type (MonoClassField *field)\n{\n\tMonoDynamicGenericClass *dgclass;\n\tint field_index;\n\n\tg_assert (is_field_on_inst (field));\n\n\tdgclass = (MonoDynamicGenericClass*)field->parent->generic_class;\n\tfield_index = field - dgclass->fields;\n\n\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\treturn dgclass->field_generic_types [field_index];\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_fieldref_token (MonoDynamicImage *assembly, MonoReflectionField *f)\n{\n\tMonoType *type;\n\tguint32 token;\n\tMonoClassField *field;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\tg_assert (f->field->parent);\n\n\tfield = f->field;\n\tif (field->parent->generic_class && field->parent->generic_class->container_class && field->parent->generic_class->container_class->fields) {\n\t\tint index = field - field->parent->fields;\n\t\ttype = field->parent->generic_class->container_class->fields [index].type;\n\t} else {\n\t\tif (is_field_on_inst (f->field))\n\t\t\ttype = get_field_on_inst_generic_type (f->field);\n\t\telse\n\t\t\ttype = f->field->type;\n\t}\n\ttoken = mono_image_get_memberref_token (assembly, &f->field->parent->byval_arg, \n\t\t\t\t\t\t\t\t\t\t\tmono_field_get_name (f->field),  \n\t\t\t\t\t\t\t\t\t\t\tfieldref_encode_signature (assembly, field->parent->image, type));\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_field_on_inst_token (MonoDynamicImage *assembly, MonoReflectionFieldOnTypeBuilderInst *f)\n{\n\tguint32 token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionFieldBuilder *fb = f->fb;\n\tMonoType *type;\n\tchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)f->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tname = mono_string_to_utf8 (fb->name);\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, \n\t\t\t\t\t\t\t\t\t\t\tfield_encode_signature (assembly, fb));\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctor_on_inst_token (MonoDynamicImage *assembly, MonoReflectionCtorOnTypeBuilderInst *c, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionCtorBuilder *cb = c->cb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\t/* A ctor cannot be a generic method, so we can ignore create_methodspec */\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, c));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)c->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, cb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, c, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic MonoMethod*\nmono_reflection_method_on_tb_inst_get_handle (MonoReflectionMethodOnTypeBuilderInst *m)\n{\n\tMonoClass *klass;\n\tMonoGenericContext tmp_context;\n\tMonoType **type_argv;\n\tMonoGenericInst *ginst;\n\tMonoMethod *method, *inflated;\n\tint count, i;\n\n\tmethod = inflate_method (m->inst, (MonoObject*)m->mb);\n\n\tklass = method->klass;\n\n\tif (m->method_args == NULL)\n\t\treturn method;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_array_length (m->method_args);\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (m->method_args, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\treturn inflated;\n}\n\nstatic guint32\nmono_image_get_method_on_inst_token (MonoDynamicImage *assembly, MonoReflectionMethodOnTypeBuilderInst *m, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoReflectionMethodBuilder *mb = m->mb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\tif (m->method_args) {\n\t\tMonoMethod *inflated;\n\n\t\tinflated = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\tif (create_methodspec)\n\t\t\ttoken = mono_image_get_methodspec_token (assembly, inflated);\n\t\telse\n\t\t\ttoken = mono_image_get_inflated_method_token (assembly, inflated);\n\t\treturn token;\n\t}\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, m));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, m, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = context->method_inst->type_argc;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tsigbuffer_add_value (&buf, 0xa); /* FIXME FIXME FIXME */\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++)\n\t\tencode_type (assembly, context->method_inst->type_argv [i], &buf);\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmethod_encode_methodspec (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0, sig;\n\tMonoMethodInflated *imethod;\n\tMonoMethod *declaring;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\tdeclaring = imethod->declaring;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (declaring));\n\tmtoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg, declaring->name, sig);\n\n\tif (!mono_method_signature (declaring)->generic_param_count)\n\t\treturn mtoken;\n\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tsig = encode_generic_method_sig (assembly, mono_method_get_context (method));\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoMethodInflated *imethod;\n\tguint32 token;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\n\tif (mono_method_signature (imethod->declaring)->generic_param_count) {\n\t\ttoken = method_encode_methodspec (assembly, method);\n\t} else {\n\t\tguint32 sig = method_encode_signature (\n\t\t\tassembly, mono_method_signature (imethod->declaring));\n\t\ttoken = mono_image_get_memberref_token (\n\t\t\tassembly, &method->klass->byval_arg, method->name, sig);\n\t}\n\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m)\n{\n\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\tguint32 sig, token;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (imethod->declaring));\n\ttoken = mono_image_get_memberref_token (\n\t\tassembly, &m->klass->byval_arg, m->name, sig);\n\n\treturn token;\n}\n\nstatic guint32\ncreate_generic_typespec (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *type;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\tint count, i;\n\n\t/*\n\t * We're creating a TypeSpec for the TypeBuilder of a generic type declaration,\n\t * ie. what we'd normally use as the generic type in a TypeSpec signature.\n\t * Because of this, we must not insert it into the `typeref' hash table.\n\t */\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)tb);\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type));\n\tif (token)\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\n\tg_assert (tb->generic_params);\n\tklass = mono_class_from_mono_type (type);\n\n\tif (tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tsigbuffer_add_value (&buf, MONO_TYPE_GENERICINST);\n\tg_assert (klass->generic_container);\n\tsigbuffer_add_value (&buf, klass->byval_arg.type);\n\tsigbuffer_add_value (&buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tcount = mono_array_length (tb->generic_params);\n\tsigbuffer_add_value (&buf, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam;\n\n\t\tgparam = mono_array_get (tb->generic_params, MonoReflectionGenericParam *, i);\n\n\t\tencode_type (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)gparam), &buf);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\n/*\n * Return a copy of TYPE, adding the custom modifiers in MODREQ and MODOPT.\n */\nstatic MonoType*\nadd_custom_modifiers (MonoDynamicImage *assembly, MonoType *type, MonoArray *modreq, MonoArray *modopt)\n{\n\tint i, count, len, pos;\n\tMonoType *t;\n\n\tcount = 0;\n\tif (modreq)\n\t\tcount += mono_array_length (modreq);\n\tif (modopt)\n\t\tcount += mono_array_length (modopt);\n\n\tif (count == 0)\n\t\treturn mono_metadata_type_dup (NULL, type);\n\n\tlen = MONO_SIZEOF_TYPE + ((gint32)count) * sizeof (MonoCustomMod);\n\tt = g_malloc (len);\n\tmemcpy (t, type, MONO_SIZEOF_TYPE);\n\n\tt->num_mods = count;\n\tpos = 0;\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tt->modifiers [pos].required = 1;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tt->modifiers [pos].required = 0;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\n\treturn t;\n}\n\nstatic guint32\nmono_image_get_generic_field_token (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *custom = NULL;\n\tguint32 *values;\n\tguint32 token, pclass, parent, sig;\n\tgchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, fb));\n\tif (token)\n\t\treturn token;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (fb->typeb));\n\tname = mono_string_to_utf8 (fb->name);\n\n\t/* fb->type does not include the custom modifiers */\n\t/* FIXME: We should do this in one place when a fieldbuilder is created */\n\tif (fb->modreq || fb->modopt) {\n\t\tcustom = add_custom_modifiers (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type), fb->modreq, fb->modopt);\n\t\tsig = fieldref_encode_signature (assembly, NULL, custom);\n\t\tg_free (custom);\n\t} else {\n\t\tsig = fieldref_encode_signature (assembly, NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t}\n\n\tparent = create_generic_typespec (assembly, (MonoReflectionTypeBuilder *) fb->typeb);\n\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_TYPEDEFORREF_TYPESPEC);\n\t\n\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\tg_hash_table_insert (assembly->handleref, fb, GUINT_TO_POINTER(token));\n\tg_free (name);\n\treturn token;\n}\n\nstatic guint32\nmono_reflection_encode_sighelper (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tSigBuffer buf;\n\tguint32 nargs;\n\tguint32 size;\n\tguint32 i, idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\t/* FIXME: this means SignatureHelper.SignatureHelpType.HELPER_METHOD */\n\tg_assert (helper->type == 2);\n\n\tif (helper->arguments)\n\t\tnargs = mono_array_length (helper->arguments);\n\telse\n\t\tnargs = 0;\n\n\tsize = 10 + (nargs * 10);\n\t\n\tsigbuffer_init (&buf, 32);\n\n\t/* Encode calling convention */\n\t/* Change Any to Standard */\n\tif ((helper->call_conv & 0x03) == 0x03)\n\t\thelper->call_conv = 0x01;\n\t/* explicit_this implies has_this */\n\tif (helper->call_conv & 0x40)\n\t\thelper->call_conv &= 0x20;\n\n\tif (helper->call_conv == 0) { /* Unmanaged */\n\t\tidx = helper->unmanaged_call_conv - 1;\n\t} else {\n\t\t/* Managed */\n\t\tidx = helper->call_conv & 0x60; /* has_this + explicit_this */\n\t\tif (helper->call_conv & 0x02) /* varargs */\n\t\t\tidx += 0x05;\n\t}\n\n\tsigbuffer_add_byte (&buf, idx);\n\tsigbuffer_add_value (&buf, nargs);\n\tencode_reflection_type (assembly, helper->return_type, &buf);\n\tfor (i = 0; i < nargs; ++i) {\n\t\tMonoArray *modreqs = NULL;\n\t\tMonoArray *modopts = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (helper->modreqs && (i < mono_array_length (helper->modreqs)))\n\t\t\tmodreqs = mono_array_get (helper->modreqs, MonoArray*, i);\n\t\tif (helper->modopts && (i < mono_array_length (helper->modopts)))\n\t\t\tmodopts = mono_array_get (helper->modopts, MonoArray*, i);\n\n\t\tencode_custom_modifiers (assembly, modreqs, modopts, &buf);\n\t\tpt = mono_array_get (helper->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\treturn idx;\n}\n\nstatic guint32 \nmono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tguint32 idx;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] =\n\t\tmono_reflection_encode_sighelper (assembly, helper);\n\n\treturn idx;\n}\n\nstatic int\nreflection_cc_to_file (int call_conv) {\n\tswitch (call_conv & 0x3) {\n\tcase 0:\n\tcase 1: return MONO_CALL_DEFAULT;\n\tcase 2: return MONO_CALL_VARARG;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn 0;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\ntypedef struct {\n\tMonoType *parent;\n\tMonoMethodSignature *sig;\n\tchar *name;\n\tguint32 token;\n} ArrayMethod;\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_array_token (MonoDynamicImage *assembly, MonoReflectionArrayMethod *m)\n{\n\tguint32 nparams, i;\n\tGList *tmp;\n\tchar *name;\n\tMonoMethodSignature *sig;\n\tArrayMethod *am;\n\tMonoType *mtype;\n\n\tname = mono_string_to_utf8 (m->name);\n\tnparams = mono_array_length (m->parameters);\n\tsig = g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * nparams);\n\tsig->hasthis = 1;\n\tsig->sentinelpos = -1;\n\tsig->call_convention = reflection_cc_to_file (m->call_conv);\n\tsig->param_count = nparams;\n\tsig->ret = m->ret ? mono_reflection_type_get_handle (m->ret): &mono_defaults.void_class->byval_arg;\n\tmtype = mono_reflection_type_get_handle (m->parent);\n\tfor (i = 0; i < nparams; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (m->parameters, i);\n\n\tfor (tmp = assembly->array_methods; tmp; tmp = tmp->next) {\n\t\tam = tmp->data;\n\t\tif (strcmp (name, am->name) == 0 && \n\t\t\t\tmono_metadata_type_equal (am->parent, mtype) &&\n\t\t\t\tmono_metadata_signature_equal (am->sig, sig)) {\n\t\t\tg_free (name);\n\t\t\tg_free (sig);\n\t\t\tm->table_idx = am->token & 0xffffff;\n\t\t\treturn am->token;\n\t\t}\n\t}\n\tam = g_new0 (ArrayMethod, 1);\n\tam->name = name;\n\tam->sig = sig;\n\tam->parent = mtype;\n\tam->token = mono_image_get_memberref_token (assembly, am->parent, name,\n\t\tmethod_encode_signature (assembly, sig));\n\tassembly->array_methods = g_list_prepend (assembly->array_methods, am);\n\tm->table_idx = am->token & 0xffffff;\n\treturn am->token;\n}\n\n/*\n * Insert into the metadata tables all the info about the TypeBuilder tb.\n * Data in the tables is inserted in a predefined order, since some tables need to be sorted.\n */\nstatic void\nmono_image_get_type_info (MonoDomain *domain, MonoReflectionTypeBuilder *tb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint *values;\n\tint i, is_object = 0, is_system = 0;\n\tchar *n;\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\tvalues = table->values + tb->table_idx * MONO_TYPEDEF_SIZE;\n\tvalues [MONO_TYPEDEF_FLAGS] = tb->attrs;\n\tn = mono_string_to_utf8 (tb->name);\n\tif (strcmp (n, \"Object\") == 0)\n\t\tis_object++;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tn = mono_string_to_utf8 (tb->nspace);\n\tif (strcmp (n, \"System\") == 0)\n\t\tis_system++;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tif (tb->parent && !(is_system && is_object) && \n\t\t\t!(tb->attrs & TYPE_ATTRIBUTE_INTERFACE)) { /* interfaces don't have a parent */\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t} else {\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\t}\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = assembly->tables [MONO_TABLE_FIELD].next_idx;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = assembly->tables [MONO_TABLE_METHOD].next_idx;\n\n\t/*\n\t * if we have explicitlayout or sequentiallayouts, output data in the\n\t * ClassLayout table.\n\t */\n\tif (((tb->attrs & TYPE_ATTRIBUTE_LAYOUT_MASK) != TYPE_ATTRIBUTE_AUTO_LAYOUT) &&\n\t\t\t((tb->class_size > 0) || (tb->packing_size > 0))) {\n\t\ttable = &assembly->tables [MONO_TABLE_CLASSLAYOUT];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CLASS_LAYOUT_SIZE;\n\t\tvalues [MONO_CLASS_LAYOUT_PARENT] = tb->table_idx;\n\t\tvalues [MONO_CLASS_LAYOUT_CLASS_SIZE] = tb->class_size;\n\t\tvalues [MONO_CLASS_LAYOUT_PACKING_SIZE] = tb->packing_size;\n\t}\n\n\t/* handle interfaces */\n\tif (tb->interfaces) {\n\t\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\t\ti = table->rows;\n\t\ttable->rows += mono_array_length (tb->interfaces);\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + (i + 1) * MONO_INTERFACEIMPL_SIZE;\n\t\tfor (i = 0; i < mono_array_length (tb->interfaces); ++i) {\n\t\t\tMonoReflectionType* iface = (MonoReflectionType*) mono_array_get (tb->interfaces, gpointer, i);\n\t\t\tvalues [MONO_INTERFACEIMPL_CLASS] = tb->table_idx;\n\t\t\tvalues [MONO_INTERFACEIMPL_INTERFACE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (iface));\n\t\t\tvalues += MONO_INTERFACEIMPL_SIZE;\n\t\t}\n\t}\n\n\t/* handle fields */\n\tif (tb->fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += tb->num_fields;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_fields; ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (tb->fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\t/* handle constructors */\n\tif (tb->ctors) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (tb->ctors);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i)\n\t\t\tmono_image_get_ctor_info (domain,\n\t\t\t\tmono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i), assembly);\n\t}\n\n\t/* handle methods */\n\tif (tb->methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += tb->num_methods;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_methods; ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\n\t/* Do the same with properties etc.. */\n\tif (tb->events && mono_array_length (tb->events)) {\n\t\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\t\ttable->rows += mono_array_length (tb->events);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_EVENTMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_EVENT_MAP_SIZE;\n\t\tvalues [MONO_EVENT_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_EVENT_MAP_EVENTLIST] = assembly->tables [MONO_TABLE_EVENT].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i)\n\t\t\tmono_image_get_event_info (\n\t\t\t\tmono_array_get (tb->events, MonoReflectionEventBuilder*, i), assembly);\n\t}\n\tif (tb->properties && mono_array_length (tb->properties)) {\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\t\ttable->rows += mono_array_length (tb->properties);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTYMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_PROPERTY_MAP_SIZE;\n\t\tvalues [MONO_PROPERTY_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_PROPERTY_MAP_PROPERTY_LIST] = assembly->tables [MONO_TABLE_PROPERTY].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i)\n\t\t\tmono_image_get_property_info (\n\t\t\t\tmono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i), assembly);\n\t}\n\n\t/* handle generic parameters */\n\tif (tb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (tb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_TYPE | (tb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (tb->generic_params, MonoReflectionGenericParam*, i), owner, assembly);\n\t\t}\n\t}\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx), tb->permissions);\n\n\tif (tb->subtypes) {\n\t\tMonoDynamicTable *ntable;\n\t\t\n\t\tntable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\t\tntable->rows += mono_array_length (tb->subtypes);\n\t\talloc_table (ntable, ntable->rows);\n\t\tvalues = ntable->values + ntable->next_idx * MONO_NESTED_CLASS_SIZE;\n\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\n\t\t\tvalues [MONO_NESTED_CLASS_NESTED] = subtype->table_idx;\n\t\t\tvalues [MONO_NESTED_CLASS_ENCLOSING] = tb->table_idx;\n\t\t\t/*g_print (\"nesting %s (%d) in %s (%d) (rows %d/%d)\\n\",\n\t\t\t\tmono_string_to_utf8 (subtype->name), subtype->table_idx,\n\t\t\t\tmono_string_to_utf8 (tb->name), tb->table_idx,\n\t\t\t\tntable->next_idx, ntable->rows);*/\n\t\t\tvalues += MONO_NESTED_CLASS_SIZE;\n\t\t\tntable->next_idx++;\n\t\t}\n\t}\n}\n#endif\n\nstatic void\ncollect_types (GPtrArray *types, MonoReflectionTypeBuilder *type)\n{\n\tint i;\n\n\tg_ptr_array_add (types, type); /* FIXME: GC object added to unmanaged memory */\n\n\tif (!type->subtypes)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (type->subtypes); ++i) {\n\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (type->subtypes, MonoReflectionTypeBuilder*, i);\n\t\tcollect_types (types, subtype);\n\t}\n}\n\nstatic gint\ncompare_types_by_table_idx (MonoReflectionTypeBuilder **type1, MonoReflectionTypeBuilder **type2)\n{\n\tif ((*type1)->table_idx < (*type2)->table_idx)\n\t\treturn -1;\n\telse\n\t\tif ((*type1)->table_idx > (*type2)->table_idx)\n\t\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void\nparams_add_cattrs (MonoDynamicImage *assembly, MonoArray *pinfo) {\n\tint i;\n\n\tif (!pinfo)\n\t\treturn;\n\tfor (i = 0; i < mono_array_length (pinfo); ++i) {\n\t\tMonoReflectionParamBuilder *pb;\n\t\tpb = mono_array_get (pinfo, MonoReflectionParamBuilder *, i);\n\t\tif (!pb)\n\t\t\tcontinue;\n\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PARAMDEF, pb->cattrs);\n\t}\n}\n\nstatic void\ntype_add_cattrs (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb) {\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, tb->table_idx, MONO_CUSTOM_ATTR_TYPEDEF, tb->cattrs);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < tb->num_fields; ++i) {\n\t\t\tMonoReflectionFieldBuilder* fb;\n\t\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\tif (tb->events) {\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i) {\n\t\t\tMonoReflectionEventBuilder* eb;\n\t\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, eb->table_idx, MONO_CUSTOM_ATTR_EVENT, eb->cattrs);\n\t\t}\n\t}\n\tif (tb->properties) {\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i) {\n\t\t\tMonoReflectionPropertyBuilder* pb;\n\t\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PROPERTY, pb->cattrs);\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder* cb;\n\t\t\tcb = mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, cb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, cb->cattrs);\n\t\t\tparams_add_cattrs (assembly, cb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb;\n\t\t\tmb = mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmodule_add_cattrs (MonoDynamicImage *assembly, MonoReflectionModuleBuilder *moduleb)\n{\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, moduleb->table_idx, MONO_CUSTOM_ATTR_MODULE, moduleb->cattrs);\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb = mono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (moduleb->global_fields) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\t\n\tif (moduleb->types) {\n\t\tfor (i = 0; i < moduleb->num_types; ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmono_image_fill_file_table (MonoDomain *domain, MonoReflectionModule *module, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *dir, *path;\n\n\ttable = &assembly->tables [MONO_TABLE_FILE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_METADATA;\n\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, module->image->module_name);\n\tif (module->image->dynamic) {\n\t\t/* This depends on the fact that the main module is emitted last */\n\t\tdir = mono_string_to_utf8 (((MonoReflectionModuleBuilder*)module)->assemblyb->dir);\n\t\tpath = g_strdup_printf (\"%s%c%s\", dir, G_DIR_SEPARATOR, module->image->module_name);\n\t} else {\n\t\tdir = NULL;\n\t\tpath = g_strdup (module->image->name);\n\t}\n\tmono_sha1_get_digest_from_file (path, hash);\n\tg_free (dir);\n\tg_free (path);\n\tmono_metadata_encode_value (20, b, &b);\n\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\ttable->next_idx ++;\n}\n\nstatic void\nmono_image_fill_module_table (MonoDomain *domain, MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\tmb->table_idx = table->next_idx ++;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->module.name);\n\ti = mono_image_add_stream_data (&assembly->guid, mono_array_addr (mb->guid, char, 0), 16);\n\ti /= 16;\n\t++i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_GENERATION] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_MVID] = i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENC] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENCBASE] = 0;\n}\n\nstatic guint32\nmono_image_fill_export_table_from_class (MonoDomain *domain, MonoClass *klass,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 visib, res;\n\n\tvisib = klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\tif (! ((visib & TYPE_ATTRIBUTE_PUBLIC) || (visib & TYPE_ATTRIBUTE_NESTED_PUBLIC)))\n\t\treturn 0;\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = klass->flags;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = klass->type_token;\n\tif (klass->nested_in)\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (parent_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\telse\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (module_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_FILE;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = table->next_idx;\n\n\ttable->next_idx ++;\n\n\t/* Emit nested types */\n\tif (klass->ext && klass->ext->nested_classes) {\n\t\tGList *tmp;\n\n\t\tfor (tmp = klass->ext->nested_classes; tmp; tmp = tmp->next)\n\t\t\tmono_image_fill_export_table_from_class (domain, tmp->data, module_index, table->next_idx - 1, assembly);\n\t}\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table (MonoDomain *domain, MonoReflectionTypeBuilder *tb,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tguint32 idx, i;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tklass->type_token = mono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx);\n\n\tidx = mono_image_fill_export_table_from_class (domain, klass, module_index, \n\t\t\t\t\t\t\t\t\t\t\t\t   parent_index, assembly);\n\n\t/* \n\t * Emit nested types\n\t * We need to do this ourselves since klass->nested_classes is not set up.\n\t */\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\tmono_image_fill_export_table (domain, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i), module_index, idx, assembly);\n\t}\n}\n\nstatic void\nmono_image_fill_export_table_from_module (MonoDomain *domain, MonoReflectionModule *module,\n\tguint32 module_index, MonoDynamicImage *assembly)\n{\n\tMonoImage *image = module->image;\n\tMonoTableInfo  *t;\n\tguint32 i;\n\n\tt = &image->tables [MONO_TABLE_TYPEDEF];\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tMonoClass *klass = mono_class_get (image, mono_metadata_make_token (MONO_TABLE_TYPEDEF, i + 1));\n\n\t\tif (klass->flags & TYPE_ATTRIBUTE_PUBLIC)\n\t\t\tmono_image_fill_export_table_from_class (domain, klass, module_index, 0, assembly);\n\t}\n}\n\nstatic guint32\nadd_exported_type (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly, MonoClass *klass)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 scope, idx, res, impl;\n\tgboolean forwarder = TRUE;\n\n\tif (klass->nested_in) {\n\t\timpl = add_exported_type (assemblyb, assembly, klass->nested_in);\n\t\tforwarder = FALSE;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t\tg_assert ((scope & MONO_RESOLTION_SCOPE_MASK) == MONO_RESOLTION_SCOPE_ASSEMBLYREF);\n\t\tidx = scope >> MONO_RESOLTION_SCOPE_BITS;\n\t\timpl = (idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_ASSEMBLYREF;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = forwarder ? TYPE_ATTRIBUTE_FORWARDER : 0;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = 0;\n\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = impl;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = (table->next_idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\n\ttable->next_idx++;\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table_from_type_forwarders (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tint i;\n\n\tif (!assemblyb->type_forwarders)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (assemblyb->type_forwarders); ++i) {\n\t\tMonoReflectionType *t = mono_array_get (assemblyb->type_forwarders, MonoReflectionType *, i);\n\t\tMonoType *type;\n\t\tif (!t)\n\t\t\tcontinue;\n\n\t\ttype = mono_reflection_type_get_handle (t);\n\t\tg_assert (type);\n\n\t\tklass = mono_class_from_mono_type (type);\n\n\t\tadd_exported_type (assemblyb, assembly, klass);\n\t}\n}\n\n#define align_pointer(base,p)\\\n\tdo {\\\n\t\tguint32 __diff = (unsigned char*)(p)-(unsigned char*)(base);\\\n\t\tif (__diff & 3)\\\n\t\t\t(p) += 4 - (__diff & 3);\\\n\t} while (0)\n\nstatic int\ncompare_constants (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\treturn a_values [MONO_CONSTANT_PARENT] - b_values [MONO_CONSTANT_PARENT];\n}\n\nstatic int\ncompare_semantics (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\tint assoc = a_values [MONO_METHOD_SEMA_ASSOCIATION] - b_values [MONO_METHOD_SEMA_ASSOCIATION];\n\tif (assoc)\n\t\treturn assoc;\n\treturn a_values [MONO_METHOD_SEMA_SEMANTICS] - b_values [MONO_METHOD_SEMA_SEMANTICS];\n}\n\nstatic int\ncompare_custom_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_CUSTOM_ATTR_PARENT] - b_values [MONO_CUSTOM_ATTR_PARENT];\n}\n\nstatic int\ncompare_field_marshal (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_FIELD_MARSHAL_PARENT] - b_values [MONO_FIELD_MARSHAL_PARENT];\n}\n\nstatic int\ncompare_nested (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_NESTED_CLASS_NESTED] - b_values [MONO_NESTED_CLASS_NESTED];\n}\n\nstatic int\ncompare_genericparam (const void *a, const void *b)\n{\n\tconst GenericParamTableEntry **a_entry = (const GenericParamTableEntry **) a;\n\tconst GenericParamTableEntry **b_entry = (const GenericParamTableEntry **) b;\n\n\tif ((*b_entry)->owner == (*a_entry)->owner)\n\t\treturn \n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*a_entry)->gparam)) -\n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*b_entry)->gparam));\n\telse\n\t\treturn (*a_entry)->owner - (*b_entry)->owner;\n}\n\nstatic int\ncompare_declsecurity_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_DECL_SECURITY_PARENT] - b_values [MONO_DECL_SECURITY_PARENT];\n}\n\nstatic int\ncompare_interface_impl (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\tint klass = a_values [MONO_INTERFACEIMPL_CLASS] - b_values [MONO_INTERFACEIMPL_CLASS];\n\tif (klass)\n\t\treturn klass;\n\n\treturn a_values [MONO_INTERFACEIMPL_INTERFACE] - b_values [MONO_INTERFACEIMPL_INTERFACE];\n}\n\nstatic void\npad_heap (MonoDynamicStream *sh)\n{\n\tif (sh->index & 3) {\n\t\tint sz = 4 - (sh->index & 3);\n\t\tmemset (sh->data + sh->index, 0, sz);\n\t\tsh->index += sz;\n\t}\n}\n\nstruct StreamDesc {\n\tconst char *name;\n\tMonoDynamicStream *stream;\n};\n\n/*\n * build_compressed_metadata() fills in the blob of data that represents the \n * raw metadata as it will be saved in the PE file. The five streams are output \n * and the metadata tables are comnpressed from the guint32 array representation, \n * to the compressed on-disk format.\n */\nstatic void\nbuild_compressed_metadata (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\tguint64 valid_mask = 0;\n\tguint64 sorted_mask;\n\tguint32 heapt_size = 0;\n\tguint32 meta_size = 256; /* allow for header and other stuff */\n\tguint32 table_offset;\n\tguint32 ntables = 0;\n\tguint64 *int64val;\n\tguint32 *int32val;\n\tguint16 *int16val;\n\tMonoImage *meta;\n\tunsigned char *p;\n\tstruct StreamDesc stream_desc [5];\n\n\tqsort (assembly->gen_params->pdata, assembly->gen_params->len, sizeof (gpointer), compare_genericparam);\n\tfor (i = 0; i < assembly->gen_params->len; i++){\n\t\tGenericParamTableEntry *entry = g_ptr_array_index (assembly->gen_params, i);\n\t\twrite_generic_param_entry (assembly, entry);\n\t}\n\n\tstream_desc [0].name  = \"#~\";\n\tstream_desc [0].stream = &assembly->tstream;\n\tstream_desc [1].name  = \"#Strings\";\n\tstream_desc [1].stream = &assembly->sheap;\n\tstream_desc [2].name  = \"#US\";\n\tstream_desc [2].stream = &assembly->us;\n\tstream_desc [3].name  = \"#Blob\";\n\tstream_desc [3].stream = &assembly->blob;\n\tstream_desc [4].name  = \"#GUID\";\n\tstream_desc [4].stream = &assembly->guid;\n\t\n\t/* tables that are sorted */\n\tsorted_mask = ((guint64)1 << MONO_TABLE_CONSTANT) | ((guint64)1 << MONO_TABLE_FIELDMARSHAL)\n\t\t| ((guint64)1 << MONO_TABLE_METHODSEMANTICS) | ((guint64)1 << MONO_TABLE_CLASSLAYOUT)\n\t\t| ((guint64)1 << MONO_TABLE_FIELDLAYOUT) | ((guint64)1 << MONO_TABLE_FIELDRVA)\n\t\t| ((guint64)1 << MONO_TABLE_IMPLMAP) | ((guint64)1 << MONO_TABLE_NESTEDCLASS)\n\t\t| ((guint64)1 << MONO_TABLE_METHODIMPL) | ((guint64)1 << MONO_TABLE_CUSTOMATTRIBUTE)\n\t\t| ((guint64)1 << MONO_TABLE_DECLSECURITY) | ((guint64)1 << MONO_TABLE_GENERICPARAM)\n\t\t| ((guint64)1 << MONO_TABLE_INTERFACEIMPL);\n\t\n\t/* Compute table sizes */\n\t/* the MonoImage has already been created in mono_image_basic_init() */\n\tmeta = &assembly->image;\n\n\t/* sizes should be multiple of 4 */\n\tpad_heap (&assembly->blob);\n\tpad_heap (&assembly->guid);\n\tpad_heap (&assembly->sheap);\n\tpad_heap (&assembly->us);\n\n\t/* Setup the info used by compute_sizes () */\n\tmeta->idx_blob_wide = assembly->blob.index >= 65536 ? 1 : 0;\n\tmeta->idx_guid_wide = assembly->guid.index >= 65536 ? 1 : 0;\n\tmeta->idx_string_wide = assembly->sheap.index >= 65536 ? 1 : 0;\n\n\tmeta_size += assembly->blob.index;\n\tmeta_size += assembly->guid.index;\n\tmeta_size += assembly->sheap.index;\n\tmeta_size += assembly->us.index;\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i)\n\t\tmeta->tables [i].rows = assembly->tables [i].rows;\n\t\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\tvalid_mask |= (guint64)1 << i;\n\t\tntables ++;\n\t\tmeta->tables [i].row_size = mono_metadata_compute_size (\n\t\t\tmeta, i, &meta->tables [i].size_bitfield);\n\t\theapt_size += meta->tables [i].row_size * meta->tables [i].rows;\n\t}\n\theapt_size += 24; /* #~ header size */\n\theapt_size += ntables * 4;\n\t/* make multiple of 4 */\n\theapt_size += 3;\n\theapt_size &= ~3;\n\tmeta_size += heapt_size;\n\tmeta->raw_metadata = g_malloc0 (meta_size);\n\tp = (unsigned char*)meta->raw_metadata;\n\t/* the metadata signature */\n\t*p++ = 'B'; *p++ = 'S'; *p++ = 'J'; *p++ = 'B';\n\t/* version numbers and 4 bytes reserved */\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (meta->md_version_major);\n\t*int16val = GUINT16_TO_LE (meta->md_version_minor);\n\tp += 8;\n\t/* version string */\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE ((strlen (meta->version) + 3) & (~3)); /* needs to be multiple of 4 */\n\tp += 4;\n\tmemcpy (p, meta->version, strlen (meta->version));\n\tp += GUINT32_FROM_LE (*int32val);\n\talign_pointer (meta->raw_metadata, p);\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (0); /* flags must be 0 */\n\t*int16val = GUINT16_TO_LE (5); /* number of streams */\n\tp += 4;\n\n\t/*\n\t * write the stream info.\n\t */\n\ttable_offset = (p - (unsigned char*)meta->raw_metadata) + 5 * 8 + 40; /* room needed for stream headers */\n\ttable_offset += 3; table_offset &= ~3;\n\n\tassembly->tstream.index = heapt_size;\n\tfor (i = 0; i < 5; ++i) {\n\t\tint32val = (guint32*)p;\n\t\tstream_desc [i].stream->offset = table_offset;\n\t\t*int32val++ = GUINT32_TO_LE (table_offset);\n\t\t*int32val = GUINT32_TO_LE (stream_desc [i].stream->index);\n\t\ttable_offset += GUINT32_FROM_LE (*int32val);\n\t\ttable_offset += 3; table_offset &= ~3;\n\t\tp += 8;\n\t\tstrcpy ((char*)p, stream_desc [i].name);\n\t\tp += strlen (stream_desc [i].name) + 1;\n\t\talign_pointer (meta->raw_metadata, p);\n\t}\n\t/* \n\t * now copy the data, the table stream header and contents goes first.\n\t */\n\tg_assert ((p - (unsigned char*)meta->raw_metadata) < assembly->tstream.offset);\n\tp = (guchar*)meta->raw_metadata + assembly->tstream.offset;\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE (0); /* reserved */\n\tp += 4;\n\n\tif (mono_framework_version () > 1) {\n\t\t*p++ = 2; /* version */\n\t\t*p++ = 0;\n\t} else {\n\t\t*p++ = 1; /* version */\n\t\t*p++ = 0;\n\t}\n\n\tif (meta->idx_string_wide)\n\t\t*p |= 0x01;\n\tif (meta->idx_guid_wide)\n\t\t*p |= 0x02;\n\tif (meta->idx_blob_wide)\n\t\t*p |= 0x04;\n\t++p;\n\t*p++ = 1; /* reserved */\n\tint64val = (guint64*)p;\n\t*int64val++ = GUINT64_TO_LE (valid_mask);\n\t*int64val++ = GUINT64_TO_LE (valid_mask & sorted_mask); /* bitvector of sorted tables  */\n\tp += 16;\n\tint32val = (guint32*)p;\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\t*int32val++ = GUINT32_TO_LE (meta->tables [i].rows);\n\t}\n\tp = (unsigned char*)int32val;\n\n\t/* sort the tables that still need sorting */\n\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CONSTANT_SIZE, table->rows, sizeof (guint32) * MONO_CONSTANT_SIZE, compare_constants);\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_METHOD_SEMA_SIZE, table->rows, sizeof (guint32) * MONO_METHOD_SEMA_SIZE, compare_semantics);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CUSTOM_ATTR_SIZE, table->rows, sizeof (guint32) * MONO_CUSTOM_ATTR_SIZE, compare_custom_attrs);\n\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_FIELD_MARSHAL_SIZE, table->rows, sizeof (guint32) * MONO_FIELD_MARSHAL_SIZE, compare_field_marshal);\n\ttable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_NESTED_CLASS_SIZE, table->rows, sizeof (guint32) * MONO_NESTED_CLASS_SIZE, compare_nested);\n\t/* Section 21.11 DeclSecurity in Partition II doesn't specify this to be sorted by MS implementation requires it */\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_DECL_SECURITY_SIZE, table->rows, sizeof (guint32) * MONO_DECL_SECURITY_SIZE, compare_declsecurity_attrs);\n\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_INTERFACEIMPL_SIZE, table->rows, sizeof (guint32) * MONO_INTERFACEIMPL_SIZE, compare_interface_impl);\n\n\t/* compress the tables */\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tint row, col;\n\t\tguint32 *values;\n\t\tguint32 bitfield = meta->tables [i].size_bitfield;\n\t\tif (!meta->tables [i].rows)\n\t\t\tcontinue;\n\t\tif (assembly->tables [i].columns != mono_metadata_table_count (bitfield))\n\t\t\tg_error (\"col count mismatch in %d: %d %d\", i, assembly->tables [i].columns, mono_metadata_table_count (bitfield));\n\t\tmeta->tables [i].base = (char*)p;\n\t\tfor (row = 1; row <= meta->tables [i].rows; ++row) {\n\t\t\tvalues = assembly->tables [i].values + row * assembly->tables [i].columns;\n\t\t\tfor (col = 0; col < assembly->tables [i].columns; ++col) {\n\t\t\t\tswitch (mono_metadata_table_size (bitfield, col)) {\n\t\t\t\tcase 1:\n\t\t\t\t\t*p++ = values [col];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 16) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 24) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_assert ((p - (const unsigned char*)meta->tables [i].base) == (meta->tables [i].rows * meta->tables [i].row_size));\n\t}\n\t\n\tg_assert (assembly->guid.offset + assembly->guid.index < meta_size);\n\tmemcpy (meta->raw_metadata + assembly->sheap.offset, assembly->sheap.data, assembly->sheap.index);\n\tmemcpy (meta->raw_metadata + assembly->us.offset, assembly->us.data, assembly->us.index);\n\tmemcpy (meta->raw_metadata + assembly->blob.offset, assembly->blob.data, assembly->blob.index);\n\tmemcpy (meta->raw_metadata + assembly->guid.offset, assembly->guid.data, assembly->guid.index);\n\n\tassembly->meta_size = assembly->guid.offset + assembly->guid.index;\n}\n\n/*\n * Some tables in metadata need to be sorted according to some criteria, but\n * when methods and fields are first created with reflection, they may be assigned a token\n * that doesn't correspond to the final token they will get assigned after the sorting.\n * ILGenerator.cs keeps a fixup table that maps the position of tokens in the IL code stream\n * with the reflection objects that represent them. Once all the tables are set up, the \n * reflection objects will contains the correct table index. fixup_method() will fixup the\n * tokens for the method with ILGenerator @ilgen.\n */\nstatic void\nfixup_method (MonoReflectionILGen *ilgen, gpointer value, MonoDynamicImage *assembly)\n{\n\tguint32 code_idx = GPOINTER_TO_UINT (value);\n\tMonoReflectionILTokenInfo *iltoken;\n\tMonoReflectionFieldBuilder *field;\n\tMonoReflectionCtorBuilder *ctor;\n\tMonoReflectionMethodBuilder *method;\n\tMonoReflectionTypeBuilder *tb;\n\tMonoReflectionArrayMethod *am;\n\tguint32 i, idx = 0;\n\tunsigned char *target;\n\n\tfor (i = 0; i < ilgen->num_token_fixups; ++i) {\n\t\tiltoken = (MonoReflectionILTokenInfo *)mono_array_addr_with_size (ilgen->token_fixups, sizeof (MonoReflectionILTokenInfo), i);\n\t\ttarget = (guchar*)assembly->code.data + code_idx + iltoken->code_pos;\n\t\tswitch (target [3]) {\n\t\tcase MONO_TABLE_FIELD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tfield = (MonoReflectionFieldBuilder *)iltoken->member;\n\t\t\t\tidx = field->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->field_to_table_idx, f));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tmethod = (MonoReflectionMethodBuilder *)iltoken->member;\n\t\t\t\tidx = method->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tctor = (MonoReflectionCtorBuilder *)iltoken->member;\n\t\t\t\tidx = ctor->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") || \n\t\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tif (strcmp (iltoken->member->vtable->klass->name, \"TypeBuilder\"))\n\t\t\t\tg_assert_not_reached ();\n\t\t\ttb = (MonoReflectionTypeBuilder *)iltoken->member;\n\t\t\tidx = tb->table_idx;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoArrayMethod\")) {\n\t\t\t\tam = (MonoReflectionArrayMethod*)iltoken->member;\n\t\t\t\tidx = am->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (m->klass->generic_class || m->klass->generic_container);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tg_assert (is_field_on_inst (f));\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\") ||\n\t\t\t\t\t!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHODSPEC:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (mono_method_signature (m)->generic_param_count);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"got unexpected table 0x%02x in fixup\", target [3]);\n\t\t}\n\t\ttarget [0] = idx & 0xff;\n\t\ttarget [1] = (idx >> 8) & 0xff;\n\t\ttarget [2] = (idx >> 16) & 0xff;\n\t}\n}\n\n/*\n * fixup_cattrs:\n *\n *   The CUSTOM_ATTRIBUTE table might contain METHODDEF tokens whose final\n * value is not known when the table is emitted.\n */\nstatic void\nfixup_cattrs (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 type, i, idx, token;\n\tMonoObject *ctor;\n\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tvalues = table->values + ((i + 1) * MONO_CUSTOM_ATTR_SIZE);\n\n\t\ttype = values [MONO_CUSTOM_ATTR_TYPE];\n\t\tif ((type & MONO_CUSTOM_ATTR_TYPE_MASK) == MONO_CUSTOM_ATTR_TYPE_METHODDEF) {\n\t\t\tidx = type >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\t\ttoken = mono_metadata_make_token (MONO_TABLE_METHOD, idx);\n\t\t\tctor = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\t\t\tg_assert (ctor);\n\n\t\t\tif (!strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)ctor)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = (idx << MONO_CUSTOM_ATTR_TYPE_BITS) | MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nassembly_add_resource_manifest (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc, guint32 implementation)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_MANIFESTRESOURCE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_MANIFEST_SIZE;\n\tvalues [MONO_MANIFEST_OFFSET] = rsrc->offset;\n\tvalues [MONO_MANIFEST_FLAGS] = rsrc->attrs;\n\tvalues [MONO_MANIFEST_NAME] = string_heap_insert_mstring (&assembly->sheap, rsrc->name);\n\tvalues [MONO_MANIFEST_IMPLEMENTATION] = implementation;\n\ttable->next_idx++;\n}\n\nstatic void\nassembly_add_resource (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *name, *sname;\n\tguint32 idx, offset;\n\n\tif (rsrc->filename) {\n\t\tname = mono_string_to_utf8 (rsrc->filename);\n\t\tsname = g_path_get_basename (name);\n\t\n\t\ttable = &assembly->tables [MONO_TABLE_FILE];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\t\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_NO_METADATA;\n\t\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, sname);\n\t\tg_free (sname);\n\n\t\tmono_sha1_get_digest_from_file (name, hash);\n\t\tmono_metadata_encode_value (20, b, &b);\n\t\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\t\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\t\tg_free (name);\n\t\tidx = table->next_idx++;\n\t\trsrc->offset = 0;\n\t\tidx = MONO_IMPLEMENTATION_FILE | (idx << MONO_IMPLEMENTATION_BITS);\n\t} else {\n\t\tchar sizebuf [4];\n\t\tchar *data;\n\t\tguint len;\n\t\tif (rsrc->data) {\n\t\t\tdata = mono_array_addr (rsrc->data, char, 0);\n\t\t\tlen = mono_array_length (rsrc->data);\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t\toffset = len;\n\t\tsizebuf [0] = offset; sizebuf [1] = offset >> 8;\n\t\tsizebuf [2] = offset >> 16; sizebuf [3] = offset >> 24;\n\t\trsrc->offset = mono_image_add_stream_data (&assembly->resources, sizebuf, 4);\n\t\tmono_image_add_stream_data (&assembly->resources, data, len);\n\n\t\tif (!mb->is_main)\n\t\t\t/* \n\t\t\t * The entry should be emitted into the MANIFESTRESOURCE table of \n\t\t\t * the main module, but that needs to reference the FILE table\n\t\t\t * which isn't emitted yet.\n\t\t\t */\n\t\t\treturn;\n\t\telse\n\t\t\tidx = 0;\n\t}\n\n\tassembly_add_resource_manifest (mb, assembly, rsrc, idx);\n}\n\nstatic void\nset_version_from_string (MonoString *version, guint32 *values)\n{\n\tgchar *ver, *p, *str;\n\tguint32 i;\n\t\n\tvalues [MONO_ASSEMBLY_MAJOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_MINOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_REV_NUMBER] = 0;\n\tvalues [MONO_ASSEMBLY_BUILD_NUMBER] = 0;\n\tif (!version)\n\t\treturn;\n\tver = str = mono_string_to_utf8 (version);\n\tfor (i = 0; i < 4; ++i) {\n\t\tvalues [MONO_ASSEMBLY_MAJOR_VERSION + i] = strtol (ver, &p, 10);\n\t\tswitch (*p) {\n\t\tcase '.':\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\t/* handle Revision and Build */\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\tver = p;\n\t}\n\tg_free (str);\n}\n\nstatic guint32\nload_public_key (MonoArray *pkey, MonoDynamicImage *assembly) {\n\tgsize len;\n\tguint32 token = 0;\n\tchar blob_size [6];\n\tchar *b = blob_size;\n\n\tif (!pkey)\n\t\treturn token;\n\n\tlen = mono_array_length (pkey);\n\tmono_metadata_encode_value (len, b, &b);\n\ttoken = mono_image_add_stream_data (&assembly->blob, blob_size, b - blob_size);\n\tmono_image_add_stream_data (&assembly->blob, mono_array_addr (pkey, char, 0), len);\n\n\tassembly->public_key = g_malloc (len);\n\tmemcpy (assembly->public_key, mono_array_addr (pkey, char, 0), len);\n\tassembly->public_key_len = len;\n\n\t/* Special case: check for ECMA key (16 bytes) */\n\tif ((len == MONO_ECMA_KEY_LENGTH) && mono_is_ecma_key (mono_array_addr (pkey, char, 0), len)) {\n\t\t/* In this case we must reserve 128 bytes (1024 bits) for the signature */\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH;\n\t} else if (len >= MONO_PUBLIC_KEY_HEADER_LENGTH + MONO_MINIMUM_PUBLIC_KEY_LENGTH) {\n\t\t/* minimum key size (in 2.0) is 384 bits */\n\t\tassembly->strong_name_size = len - MONO_PUBLIC_KEY_HEADER_LENGTH;\n\t} else {\n\t\t/* FIXME - verifier */\n\t\tg_warning (\"Invalid public key length: %d bits (total: %d)\", (int)MONO_PUBLIC_KEY_BIT_SIZE (len), (int)len);\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH; /* to be safe */\n\t}\n\tassembly->strong_name = g_malloc0 (assembly->strong_name_size);\n\n\treturn token;\n}\n\nstatic void\nmono_image_emit_manifest (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tguint32 *values;\n\tint i;\n\tguint32 module_index;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\t/* Emit ASSEMBLY table */\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLY];\n\talloc_table (table, 1);\n\tvalues = table->values + MONO_ASSEMBLY_SIZE;\n\tvalues [MONO_ASSEMBLY_HASH_ALG] = assemblyb->algid? assemblyb->algid: ASSEMBLY_HASH_SHA1;\n\tvalues [MONO_ASSEMBLY_NAME] = string_heap_insert_mstring (&assembly->sheap, assemblyb->name);\n\tif (assemblyb->culture) {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert_mstring (&assembly->sheap, assemblyb->culture);\n\t} else {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert (&assembly->sheap, \"\");\n\t}\n\tvalues [MONO_ASSEMBLY_PUBLIC_KEY] = load_public_key (assemblyb->public_key, assembly);\n\tvalues [MONO_ASSEMBLY_FLAGS] = assemblyb->flags;\n\tset_version_from_string (assemblyb->version, values);\n\n\t/* Emit FILE + EXPORTED_TYPE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\tif (file_module != moduleb) {\n\t\t\tmono_image_fill_file_table (domain, (MonoReflectionModule*)file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->types) {\n\t\t\t\tfor (j = 0; j < file_module->num_types; ++j) {\n\t\t\t\t\tMonoReflectionTypeBuilder *tb = mono_array_get (file_module->types, MonoReflectionTypeBuilder*, j);\n\t\t\t\t\tmono_image_fill_export_table (domain, tb, module_index, 0, assembly);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (assemblyb->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (assemblyb->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *file_module = \n\t\t\t\tmono_array_get (assemblyb->loaded_modules, MonoReflectionModule*, i);\n\t\t\tmono_image_fill_file_table (domain, file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tmono_image_fill_export_table_from_module (domain, file_module, module_index, assembly);\n\t\t}\n\t}\n\tif (assemblyb->type_forwarders)\n\t\tmono_image_fill_export_table_from_type_forwarders (assemblyb, assembly);\n\n\t/* Emit MANIFESTRESOURCE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\t/* The table for the main module is emitted later */\n\t\tif (file_module != moduleb) {\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->resources) {\n\t\t\t\tint len = mono_array_length (file_module->resources);\n\t\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\t\tMonoReflectionResource* res = (MonoReflectionResource*)mono_array_addr (file_module->resources, MonoReflectionResource, j);\n\t\t\t\t\tassembly_add_resource_manifest (file_module, assembly, res, MONO_IMPLEMENTATION_FILE | (module_index << MONO_IMPLEMENTATION_BITS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\n/*\n * mono_image_build_metadata() will fill the info in all the needed metadata tables\n * for the modulebuilder @moduleb.\n * At the end of the process, method and field tokens are fixed up and the \n * on-disk compressed metadata representation is created.\n */\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tGPtrArray *types;\n\tguint32 *values;\n\tint i, j;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\tif (assembly->text_rva)\n\t\treturn;\n\n\tassembly->text_rva = START_TEXT_RVA;\n\n\tif (moduleb->is_main) {\n\t\tmono_image_emit_manifest (moduleb);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows = 1; /* .<Module> */\n\ttable->next_idx++;\n\talloc_table (table, table->rows);\n\t/*\n\t * Set the first entry.\n\t */\n\tvalues = table->values + table->columns;\n\tvalues [MONO_TYPEDEF_FLAGS] = 0;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, \"<Module>\") ;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, \"\") ;\n\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = 1;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = 1;\n\n\t/* \n\t * handle global methods \n\t * FIXME: test what to do when global methods are defined in multiple modules.\n\t */\n\tif (moduleb->global_methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (moduleb->global_methods);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\tif (moduleb->global_fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += mono_array_length (moduleb->global_fields);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\talloc_table (table, 1);\n\tmono_image_fill_module_table (domain, moduleb, assembly);\n\n\t/* Collect all types into a list sorted by their table_idx */\n\ttypes = g_ptr_array_new ();\n\n\tif (moduleb->types)\n\t\tfor (i = 0; i < moduleb->num_types; ++i) {\n\t\t\tMonoReflectionTypeBuilder *type = mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i);\n\t\t\tcollect_types (types, type);\n\t\t}\n\n\tg_ptr_array_sort (types, (GCompareFunc)compare_types_by_table_idx);\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows += types->len;\n\talloc_table (table, table->rows);\n\n\t/*\n\t * Emit type names + namespaces at one place inside the string heap,\n\t * so load_class_names () needs to touch fewer pages.\n\t */\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->nspace);\n\t}\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->name);\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tmono_image_get_type_info (domain, type, assembly);\n\t}\n\n\t/* \n\t * table->rows is already set above and in mono_image_fill_module_table.\n\t */\n\t/* add all the custom attributes at the end, once all the indexes are stable */\n\tmono_image_add_cattrs (assembly, 1, MONO_CUSTOM_ATTR_ASSEMBLY, assemblyb->cattrs);\n\n\t/* CAS assembly permissions */\n\tif (assemblyb->permissions_minimum)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_minimum);\n\tif (assemblyb->permissions_optional)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_optional);\n\tif (assemblyb->permissions_refused)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_refused);\n\n\tmodule_add_cattrs (assembly, moduleb);\n\n\t/* fixup tokens */\n\tmono_g_hash_table_foreach (assembly->token_fixups, (GHFunc)fixup_method, assembly);\n\n\t/* Create the MethodImpl table.  We do this after emitting all methods so we already know\n\t * the final tokens and don't need another fixup pass. */\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\tmoduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tif (type->methods) {\n\t\t\tfor (j = 0; j < type->num_methods; ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\t\ttype->methods, MonoReflectionMethodBuilder*, j);\n\n\t\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_ptr_array_free (types, TRUE);\n\n\tfixup_cattrs (assembly);\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit_save, so saving of dynamic assemblies is not supported.\");\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n\ntypedef struct {\n\tguint32 import_lookup_table;\n\tguint32 timestamp;\n\tguint32 forwarder;\n\tguint32 name_rva;\n\tguint32 import_address_table_rva;\n} MonoIDT;\n\ntypedef struct {\n\tguint32 name_rva;\n\tguint32 flags;\n} MonoILT;\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_insert_string:\n * @module: module builder object\n * @str: a string\n *\n * Insert @str into the user string stream of @module.\n */\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tMonoDynamicImage *assembly;\n\tguint32 idx;\n\tchar buf [16];\n\tchar *b = buf;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!module->dynamic_image)\n\t\tmono_image_module_basic_init (module);\n\n\tassembly = module->dynamic_image;\n\t\n\tif (assembly->save) {\n\t\tmono_metadata_encode_value (1 | (str->length * 2), b, &b);\n\t\tidx = mono_image_add_stream_data (&assembly->us, buf, b-buf);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tmono_image_add_stream_data (&assembly->us, swapped, str->length * 2);\n\t\tg_free (swapped);\n\t}\n#else\n\t\tmono_image_add_stream_data (&assembly->us, (const char*)mono_string_chars (str), str->length * 2);\n#endif\n\t\tmono_image_add_stream_data (&assembly->us, \"\", 1);\n\t} else {\n\t\tidx = assembly->us.index ++;\n\t}\n\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (MONO_TOKEN_STRING | idx), str);\n\n\treturn MONO_TOKEN_STRING | idx;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\tif (strcmp (klass->name, \"MonoMethod\") == 0) {\n\t\tMonoMethod *method = ((MonoReflectionMethod *)obj)->method;\n\t\tMonoMethodSignature *sig, *old;\n\t\tguint32 sig_token, parent;\n\t\tint nargs, i;\n\n\t\tg_assert (opt_param_types && (mono_method_signature (method)->sentinelpos >= 0));\n\n\t\tnargs = mono_array_length (opt_param_types);\n\t\told = mono_method_signature (method);\n\t\tsig = mono_metadata_signature_alloc ( &assembly->image, old->param_count + nargs);\n\n\t\tsig->hasthis = old->hasthis;\n\t\tsig->explicit_this = old->explicit_this;\n\t\tsig->call_convention = old->call_convention;\n\t\tsig->generic_param_count = old->generic_param_count;\n\t\tsig->param_count = old->param_count + nargs;\n\t\tsig->sentinelpos = old->param_count;\n\t\tsig->ret = old->ret;\n\n\t\tfor (i = 0; i < old->param_count; i++)\n\t\t\tsig->params [i] = old->params [i];\n\n\t\tfor (i = 0; i < nargs; i++) {\n\t\t\tMonoReflectionType *rt = mono_array_get (opt_param_types, MonoReflectionType *, i);\n\t\t\tsig->params [old->param_count + i] = mono_reflection_type_get_handle (rt);\n\t\t}\n\n\t\tparent = mono_image_typedef_or_ref (assembly, &method->klass->byval_arg);\n\t\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_MEMBERREF_PARENT_TYPEREF);\n\t\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\t\tparent <<= MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_TYPEREF;\n\n\t\tsig_token = method_encode_signature (assembly, sig);\n\t\ttoken = mono_image_get_varargs_method_token (assembly, parent, method->name, sig_token);\n\t} else if (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tReflectionMethodBuilder rmb;\n\t\tguint32 parent, sig;\n\t\tchar *name;\n\n\t\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\t\trmb.opt_types = opt_param_types;\n\n\t\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\t\tparent = mono_image_create_token (assembly, obj, TRUE, TRUE);\n\t\tg_assert (mono_metadata_token_table (parent) == MONO_TABLE_METHOD);\n\n\t\tparent = mono_metadata_token_index (parent) << MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_METHODDEF;\n\n\t\tname = mono_string_to_utf8 (rmb.name);\n\t\ttoken = mono_image_get_varargs_method_token (\n\t\t\tassembly, parent, name, sig);\n\t\tg_free (name);\n\t} else {\n\t\tg_error (\"requested method token for %s\\n\", klass->name);\n\t}\n\n\treturn token;\n}\n\n/*\n * mono_image_create_token:\n * @assembly: a dynamic assembly\n * @obj:\n * @register_token: Whenever to register the token in the assembly->tokens hash. \n *\n * Get a token to insert in the IL code stream for the given MemberInfo.\n * The metadata emission routines need to pass FALSE as REGISTER_TOKEN, since by that time, \n * the table_idx-es were recomputed, so registering the token would overwrite an existing \n * entry.\n */\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\t/* Check for user defined reflection objects */\n\t/* TypeDelegator is the only corlib type which doesn't look like a MonoReflectionType */\n\tif (klass->image != mono_defaults.corlib || (strcmp (klass->name, \"TypeDelegator\") == 0))\n\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported\")); \\\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params && !mb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_methodbuilder_token (assembly, mb, create_methodspec);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_ctorbuilder_token (assembly, mb);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)fb->typeb;\n\t\tif (tb->generic_params) {\n\t\t\ttoken = mono_image_get_generic_field_token (assembly, fb);\n\t\t} else {\n\t\t\ttoken = fb->table_idx | MONO_TOKEN_FIELD_DEF;\n\t\t}\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tMonoClass *mc = mono_class_from_mono_type (type);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref_full (assembly, type, mc->generic_container == NULL));\n\t} else if (strcmp (klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tif (create_methodspec)\n\t\t\t\ttoken = mono_image_get_methodspec_token (assembly, m->method);\n\t\t\telse\n\t\t\t\ttoken = mono_image_get_inflated_method_token (assembly, m->method);\n\t\t} else if ((m->method->klass->image == &assembly->image) &&\n\t\t\t !m->method->klass->generic_class) {\n\t\t\tstatic guint32 method_table_idx = 0xffffff;\n\t\t\tif (m->method->klass->wastypebuilder) {\n\t\t\t\t/* we use the same token as the one that was assigned\n\t\t\t\t * to the Methodbuilder.\n\t\t\t\t * FIXME: do the equivalent for Fields.\n\t\t\t\t */\n\t\t\t\ttoken = m->method->token;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Each token should have a unique index, but the indexes are\n\t\t\t\t * assigned by managed code, so we don't know about them. An\n\t\t\t\t * easy solution is to count backwards...\n\t\t\t\t */\n\t\t\t\tmethod_table_idx --;\n\t\t\t\ttoken = MONO_TOKEN_METHOD_DEF | method_table_idx;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = mono_image_get_methodref_token (assembly, m->method, create_methodspec);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, m->method->name);*/\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField *)obj;\n\t\tif ((f->field->parent->image == &assembly->image) && !is_field_on_inst (f->field)) {\n\t\t\tstatic guint32 field_table_idx = 0xffffff;\n\t\t\tfield_table_idx --;\n\t\t\ttoken = MONO_TOKEN_FIELD_DEF | field_table_idx;\n\t\t} else {\n\t\t\ttoken = mono_image_get_fieldref_token (assembly, f);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, f->field->name);*/\n\t} else if (strcmp (klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod *)obj;\n\t\ttoken = mono_image_get_array_token (assembly, m);\n\t} else if (strcmp (klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *s = (MonoReflectionSigHelper*)obj;\n\t\ttoken = MONO_TOKEN_SIGNATURE | mono_image_get_sighelper_token (assembly, s);\n\t} else if (strcmp (klass->name, \"EnumBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_field_on_inst_token (assembly, f);\n\t} else if (strcmp (klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_ctor_on_inst_token (assembly, c, create_methodspec);\n\t} else if (strcmp (klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_method_on_inst_token (assembly, m, create_methodspec);\n\t} else if (is_sre_array (klass) || is_sre_byref (klass) || is_sre_pointer (klass)) {\n\t\tMonoReflectionType *type = (MonoReflectionType *)obj;\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\t\tmono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (type)));\n\t} else {\n\t\tg_error (\"requested token for %s\\n\", klass->name);\n\t}\n\n\tif (register_token)\n\t\tmono_image_register_token (assembly, token, obj);\n\n\treturn token;\n}\n\n/*\n * mono_image_register_token:\n *\n *   Register the TOKEN->OBJ mapping in the mapping table in ASSEMBLY. This is required for\n * the Module.ResolveXXXToken () methods to work.\n */\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n\tMonoObject *prev = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tif (prev) {\n\t\t/* There could be multiple MethodInfo objects with the same token */\n\t\t//g_assert (prev == obj);\n\t} else {\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), obj);\n\t}\n}\n\nstatic MonoDynamicImage*\ncreate_dynamic_mono_image (MonoDynamicAssembly *assembly, char *assembly_name, char *module_name)\n{\n\tstatic const guchar entrycode [16] = {0xff, 0x25, 0};\n\tMonoDynamicImage *image;\n\tint i;\n\n\tconst char *version;\n\n\tif (!strcmp (mono_get_runtime_info ()->framework_version, \"2.1\"))\n\t\tversion = \"v2.0.50727\"; /* HACK: SL 2 enforces the .net 2 metadata version */\n\telse\n\t\tversion = mono_get_runtime_info ()->runtime_version;\n\n#if HAVE_BOEHM_GC\n\timage = GC_MALLOC (sizeof (MonoDynamicImage));\n#else\n\timage = g_new0 (MonoDynamicImage, 1);\n#endif\n\t\n\tmono_profiler_module_event (&image->image, MONO_PROFILE_START_LOAD);\n\t\n\t/*g_print (\"created image %p\\n\", image);*/\n\t/* keep in sync with image.c */\n\timage->image.name = assembly_name;\n\timage->image.assembly_name = image->image.name; /* they may be different */\n\timage->image.module_name = module_name;\n\timage->image.version = g_strdup (version);\n\timage->image.md_version_major = 1;\n\timage->image.md_version_minor = 1;\n\timage->image.dynamic = TRUE;\n\n\timage->image.references = g_new0 (MonoAssembly*, 1);\n\timage->image.references [0] = NULL;\n\n\tmono_image_init (&image->image);\n\n\timage->token_fixups = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->method_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->field_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->method_aux_hash = g_hash_table_new (NULL, NULL);\n\timage->handleref = g_hash_table_new (NULL, NULL);\n\timage->tokens = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->generic_def_objects = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->methodspec = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->typespec = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->typeref = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->blob_cache = g_hash_table_new ((GHashFunc)mono_blob_entry_hash, (GCompareFunc)mono_blob_entry_equal);\n\timage->gen_params = g_ptr_array_new ();\n\n\t/*g_print (\"string heap create for image %p (%s)\\n\", image, module_name);*/\n\tstring_heap_init (&image->sheap);\n\tmono_image_add_stream_data (&image->us, \"\", 1);\n\tadd_to_blob_cached (image, (char*) \"\", 1, NULL, 0);\n\t/* import tables... */\n\tmono_image_add_stream_data (&image->code, (char*)entrycode, sizeof (entrycode));\n\timage->iat_offset = mono_image_add_stream_zero (&image->code, 8); /* two IAT entries */\n\timage->idt_offset = mono_image_add_stream_zero (&image->code, 2 * sizeof (MonoIDT)); /* two IDT entries */\n\timage->imp_names_offset = mono_image_add_stream_zero (&image->code, 2); /* flags for name entry */\n\tmono_image_add_stream_data (&image->code, \"_CorExeMain\", 12);\n\tmono_image_add_stream_data (&image->code, \"mscoree.dll\", 12);\n\timage->ilt_offset = mono_image_add_stream_zero (&image->code, 8); /* two ILT entries */\n\tstream_data_align (&image->code);\n\n\timage->cli_header_offset = mono_image_add_stream_zero (&image->code, sizeof (MonoCLIHeader));\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i) {\n\t\timage->tables [i].next_idx = 1;\n\t\timage->tables [i].columns = table_sizes [i];\n\t}\n\n\timage->image.assembly = (MonoAssembly*)assembly;\n\timage->run = assembly->run;\n\timage->save = assembly->save;\n\timage->pe_kind = 0x1; /* ILOnly */\n\timage->machine = 0x14c; /* I386 */\n\t\n\tmono_profiler_module_loaded (&image->image, MONO_PROFILE_OK);\n\n\treturn image;\n}\n#endif\n\nstatic void\nfree_blob_cache_entry (gpointer key, gpointer val, gpointer user_data)\n{\n\tg_free (key);\n}\n\nvoid\nmono_dynamic_image_free (MonoDynamicImage *image)\n{\n\tMonoDynamicImage *di = image;\n\tGList *list;\n\tint i;\n\n\tif (di->methodspec)\n\t\tmono_g_hash_table_destroy (di->methodspec);\n\tif (di->typespec)\n\t\tg_hash_table_destroy (di->typespec);\n\tif (di->typeref)\n\t\tg_hash_table_destroy (di->typeref);\n\tif (di->handleref)\n\t\tg_hash_table_destroy (di->handleref);\n\tif (di->tokens)\n\t\tmono_g_hash_table_destroy (di->tokens);\n\tif (di->generic_def_objects)\n\t\tmono_g_hash_table_destroy (di->generic_def_objects);\n\tif (di->blob_cache) {\n\t\tg_hash_table_foreach (di->blob_cache, free_blob_cache_entry, NULL);\n\t\tg_hash_table_destroy (di->blob_cache);\n\t}\n\tif (di->standalonesig_cache)\n\t\tg_hash_table_destroy (di->standalonesig_cache);\n\tfor (list = di->array_methods; list; list = list->next) {\n\t\tArrayMethod *am = (ArrayMethod *)list->data;\n\t\tg_free (am->sig);\n\t\tg_free (am->name);\n\t\tg_free (am);\n\t}\n\tg_list_free (di->array_methods);\n\tif (di->gen_params) {\n\t\tfor (i = 0; i < di->gen_params->len; i++) {\n\t\t\tGenericParamTableEntry *entry = g_ptr_array_index (di->gen_params, i);\n\t\t\tif (entry->gparam->type.type) {\n\t\t\t\tMonoGenericParam *param = entry->gparam->type.type->data.generic_param;\n\t\t\t\tg_free ((char*)mono_generic_param_info (param)->name);\n\t\t\t\tg_free (param);\n\t\t\t}\n\t\t\tg_free (entry);\n\t\t}\n\t \tg_ptr_array_free (di->gen_params, TRUE);\n\t}\n\tif (di->token_fixups)\n\t\tmono_g_hash_table_destroy (di->token_fixups);\n\tif (di->method_to_table_idx)\n\t\tg_hash_table_destroy (di->method_to_table_idx);\n\tif (di->field_to_table_idx)\n\t\tg_hash_table_destroy (di->field_to_table_idx);\n\tif (di->method_aux_hash)\n\t\tg_hash_table_destroy (di->method_aux_hash);\n\tg_free (di->strong_name);\n\tg_free (di->win32_res);\n\tif (di->public_key)\n\t\tg_free (di->public_key);\n\n\t/*g_print (\"string heap destroy for image %p\\n\", di);*/\n\tmono_dynamic_stream_reset (&di->sheap);\n\tmono_dynamic_stream_reset (&di->code);\n\tmono_dynamic_stream_reset (&di->resources);\n\tmono_dynamic_stream_reset (&di->us);\n\tmono_dynamic_stream_reset (&di->blob);\n\tmono_dynamic_stream_reset (&di->tstream);\n\tmono_dynamic_stream_reset (&di->guid);\n\tfor (i = 0; i < MONO_TABLE_NUM; ++i) {\n\t\tg_free (di->tables [i].values);\n\t}\n}\t\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_basic_init:\n * @assembly: an assembly builder object\n *\n * Create the MonoImage that represents the assembly builder and setup some\n * of the helper hash table and the basic metadata streams.\n */\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tMonoDynamicAssembly *assembly;\n\tMonoDynamicImage *image;\n\tMonoDomain *domain = mono_object_domain (assemblyb);\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (assemblyb->dynamic_assembly)\n\t\treturn;\n\n#if HAVE_BOEHM_GC\n\tassembly = assemblyb->dynamic_assembly = GC_MALLOC (sizeof (MonoDynamicAssembly));\n#else\n\tassembly = assemblyb->dynamic_assembly = g_new0 (MonoDynamicAssembly, 1);\n#endif\n\n\tmono_profiler_assembly_event (&assembly->assembly, MONO_PROFILE_START_LOAD);\n\t\n\tassembly->assembly.ref_count = 1;\n\tassembly->assembly.dynamic = TRUE;\n\tassembly->assembly.corlib_internal = assemblyb->corlib_internal;\n\tassemblyb->assembly.assembly = (MonoAssembly*)assembly;\n\tassembly->assembly.basedir = mono_string_to_utf8 (assemblyb->dir);\n\tif (assemblyb->culture)\n\t\tassembly->assembly.aname.culture = mono_string_to_utf8 (assemblyb->culture);\n\telse\n\t\tassembly->assembly.aname.culture = g_strdup (\"\");\n\n        if (assemblyb->version) {\n\t\t\tchar *vstr = mono_string_to_utf8 (assemblyb->version);\n\t\t\tchar **version = g_strsplit (vstr, \".\", 4);\n\t\t\tchar **parts = version;\n\t\t\tassembly->assembly.aname.major = atoi (*parts++);\n\t\t\tassembly->assembly.aname.minor = atoi (*parts++);\n\t\t\tassembly->assembly.aname.build = *parts != NULL ? atoi (*parts++) : 0;\n\t\t\tassembly->assembly.aname.revision = *parts != NULL ? atoi (*parts) : 0;\n\n\t\t\tg_strfreev (version);\n\t\t\tg_free (vstr);\n        } else {\n\t\t\tassembly->assembly.aname.major = 0;\n\t\t\tassembly->assembly.aname.minor = 0;\n\t\t\tassembly->assembly.aname.build = 0;\n\t\t\tassembly->assembly.aname.revision = 0;\n        }\n\n\tassembly->run = assemblyb->access != 2;\n\tassembly->save = assemblyb->access != 1;\n\tassembly->domain = domain;\n\n\timage = create_dynamic_mono_image (assembly, mono_string_to_utf8 (assemblyb->name), g_strdup (\"RefEmit_YouForgotToDefineAModule\"));\n\timage->initial_image = TRUE;\n\tassembly->assembly.aname.name = image->image.name;\n\tassembly->assembly.image = &image->image;\n\tif (assemblyb->pktoken && assemblyb->pktoken->max_length) {\n\t\t/* -1 to correct for the trailing NULL byte */\n\t\tif (assemblyb->pktoken->max_length != MONO_PUBLIC_KEY_TOKEN_LENGTH - 1) {\n\t\t\tg_error (\"Public key token length invalid for assembly %s: %i\", assembly->assembly.aname.name, assemblyb->pktoken->max_length);\n\t\t}\n\t\tmemcpy (&assembly->assembly.aname.public_key_token, mono_array_addr (assemblyb->pktoken, guint8, 0), assemblyb->pktoken->max_length);\t\t\n\t}\n\n\tmono_domain_assemblies_lock (domain);\n\tdomain->domain_assemblies = g_slist_prepend (domain->domain_assemblies, assembly);\n\tmono_domain_assemblies_unlock (domain);\n\n\tregister_assembly (mono_object_domain (assemblyb), &assemblyb->assembly, &assembly->assembly);\n\t\n\tmono_profiler_assembly_loaded (&assembly->assembly, MONO_PROFILE_OK);\n\t\n\tmono_assembly_invoke_load_hook ((MonoAssembly*)assembly);\n}\n\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\nstatic int\ncalc_section_size (MonoDynamicImage *assembly)\n{\n\tint nsections = 0;\n\n\t/* alignment constraints */\n\tmono_image_add_stream_zero (&assembly->code, 4 - (assembly->code.index % 4));\n\tg_assert ((assembly->code.index % 4) == 0);\n\tassembly->meta_size += 3;\n\tassembly->meta_size &= ~3;\n\tmono_image_add_stream_zero (&assembly->resources, 4 - (assembly->resources.index % 4));\n\tg_assert ((assembly->resources.index % 4) == 0);\n\n\tassembly->sections [MONO_SECTION_TEXT].size = assembly->meta_size + assembly->code.index + assembly->resources.index + assembly->strong_name_size;\n\tassembly->sections [MONO_SECTION_TEXT].attrs = SECT_FLAGS_HAS_CODE | SECT_FLAGS_MEM_EXECUTE | SECT_FLAGS_MEM_READ;\n\tnsections++;\n\n\tif (assembly->win32_res) {\n\t\tguint32 res_size = (assembly->win32_res_size + 3) & ~3;\n\n\t\tassembly->sections [MONO_SECTION_RSRC].size = res_size;\n\t\tassembly->sections [MONO_SECTION_RSRC].attrs = SECT_FLAGS_HAS_INITIALIZED_DATA | SECT_FLAGS_MEM_READ;\n\t\tnsections++;\n\t}\n\n\tassembly->sections [MONO_SECTION_RELOC].size = 12;\n\tassembly->sections [MONO_SECTION_RELOC].attrs = SECT_FLAGS_MEM_READ | SECT_FLAGS_MEM_DISCARDABLE | SECT_FLAGS_HAS_INITIALIZED_DATA;\n\tnsections++;\n\n\treturn nsections;\n}\n\ntypedef struct {\n\tguint32 id;\n\tguint32 offset;\n\tGSList *children;\n\tMonoReflectionWin32Resource *win32_res; /* Only for leaf nodes */\n} ResTreeNode;\n\nstatic int\nresource_tree_compare_by_id (gconstpointer a, gconstpointer b)\n{\n\tResTreeNode *t1 = (ResTreeNode*)a;\n\tResTreeNode *t2 = (ResTreeNode*)b;\n\n\treturn t1->id - t2->id;\n}\n\n/*\n * resource_tree_create:\n *\n *  Organize the resources into a resource tree.\n */\nstatic ResTreeNode *\nresource_tree_create (MonoArray *win32_resources)\n{\n\tResTreeNode *tree, *res_node, *type_node, *lang_node;\n\tGSList *l;\n\tint i;\n\n\ttree = g_new0 (ResTreeNode, 1);\n\t\n\tfor (i = 0; i < mono_array_length (win32_resources); ++i) {\n\t\tMonoReflectionWin32Resource *win32_res =\n\t\t\t(MonoReflectionWin32Resource*)mono_array_addr (win32_resources, MonoReflectionWin32Resource, i);\n\n\t\t/* Create node */\n\n\t\t/* FIXME: BUG: this stores managed references in unmanaged memory */\n\t\tlang_node = g_new0 (ResTreeNode, 1);\n\t\tlang_node->id = win32_res->lang_id;\n\t\tlang_node->win32_res = win32_res;\n\n\t\t/* Create type node if neccesary */\n\t\ttype_node = NULL;\n\t\tfor (l = tree->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_type) {\n\t\t\t\ttype_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!type_node) {\n\t\t\ttype_node = g_new0 (ResTreeNode, 1);\n\t\t\ttype_node->id = win32_res->res_type;\n\n\t\t\t/* \n\t\t\t * The resource types have to be sorted otherwise\n\t\t\t * Windows Explorer can't display the version information.\n\t\t\t */\n\t\t\ttree->children = g_slist_insert_sorted (tree->children, \n\t\t\t\ttype_node, resource_tree_compare_by_id);\n\t\t}\n\n\t\t/* Create res node if neccesary */\n\t\tres_node = NULL;\n\t\tfor (l = type_node->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_id) {\n\t\t\t\tres_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!res_node) {\n\t\t\tres_node = g_new0 (ResTreeNode, 1);\n\t\t\tres_node->id = win32_res->res_id;\n\t\t\ttype_node->children = g_slist_append (type_node->children, res_node);\n\t\t}\n\n\t\tres_node->children = g_slist_append (res_node->children, lang_node);\n\t}\n\n\treturn tree;\n}\n\n/*\n * resource_tree_encode:\n * \n *   Encode the resource tree into the format used in the PE file.\n */\nstatic void\nresource_tree_encode (ResTreeNode *node, char *begin, char *p, char **endbuf)\n{\n\tchar *entries;\n\tMonoPEResourceDir dir;\n\tMonoPEResourceDirEntry dir_entry;\n\tMonoPEResourceDataEntry data_entry;\n\tGSList *l;\n\tguint32 res_id_entries;\n\n\t/*\n\t * For the format of the resource directory, see the article\n\t * \"An In-Depth Look into the Win32 Portable Executable File Format\" by\n\t * Matt Pietrek\n\t */\n\n\tmemset (&dir, 0, sizeof (dir));\n\tmemset (&dir_entry, 0, sizeof (dir_entry));\n\tmemset (&data_entry, 0, sizeof (data_entry));\n\n\tg_assert (sizeof (dir) == 16);\n\tg_assert (sizeof (dir_entry) == 8);\n\tg_assert (sizeof (data_entry) == 16);\n\n\tnode->offset = p - begin;\n\n\t/* IMAGE_RESOURCE_DIRECTORY */\n\tres_id_entries = g_slist_length (node->children);\n\tdir.res_id_entries = GUINT16_TO_LE (res_id_entries);\n\n\tmemcpy (p, &dir, sizeof (dir));\n\tp += sizeof (dir);\n\n\t/* Reserve space for entries */\n\tentries = p;\n\tp += sizeof (dir_entry) * res_id_entries;\n\n\t/* Write children */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tif (child->win32_res) {\n\t\t\tguint32 size;\n\n\t\t\tchild->offset = p - begin;\n\n\t\t\t/* IMAGE_RESOURCE_DATA_ENTRY */\n\t\t\tdata_entry.rde_data_offset = GUINT32_TO_LE (p - begin + sizeof (data_entry));\n\t\t\tsize = mono_array_length (child->win32_res->res_data);\n\t\t\tdata_entry.rde_size = GUINT32_TO_LE (size);\n\n\t\t\tmemcpy (p, &data_entry, sizeof (data_entry));\n\t\t\tp += sizeof (data_entry);\n\n\t\t\tmemcpy (p, mono_array_addr (child->win32_res->res_data, char, 0), size);\n\t\t\tp += size;\n\t\t} else {\n\t\t\tresource_tree_encode (child, begin, p, &p);\n\t\t}\n\t}\n\n\t/* IMAGE_RESOURCE_ENTRY */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tMONO_PE_RES_DIR_ENTRY_SET_NAME (dir_entry, FALSE, child->id);\n\t\tMONO_PE_RES_DIR_ENTRY_SET_DIR (dir_entry, !child->win32_res, child->offset);\n\n\t\tmemcpy (entries, &dir_entry, sizeof (dir_entry));\n\t\tentries += sizeof (dir_entry);\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nresource_tree_free (ResTreeNode * node)\n{\n\tGSList * list;\n\tfor (list = node->children; list; list = list->next)\n\t\tresource_tree_free ((ResTreeNode*)list->data);\n\tg_slist_free(node->children);\n\tg_free (node);\n}\n\nstatic void\nassembly_add_win32_resources (MonoDynamicImage *assembly, MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tchar *buf;\n\tchar *p;\n\tguint32 size, i;\n\tMonoReflectionWin32Resource *win32_res;\n\tResTreeNode *tree;\n\n\tif (!assemblyb->win32_resources)\n\t\treturn;\n\n\t/*\n\t * Resources are stored in a three level tree inside the PE file.\n\t * - level one contains a node for each type of resource\n\t * - level two contains a node for each resource\n\t * - level three contains a node for each instance of a resource for a\n\t *   specific language.\n\t */\n\n\ttree = resource_tree_create (assemblyb->win32_resources);\n\n\t/* Estimate the size of the encoded tree */\n\tsize = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->win32_resources); ++i) {\n\t\twin32_res = (MonoReflectionWin32Resource*)mono_array_addr (assemblyb->win32_resources, MonoReflectionWin32Resource, i);\n\t\tsize += mono_array_length (win32_res->res_data);\n\t}\n\t/* Directory structure */\n\tsize += mono_array_length (assemblyb->win32_resources) * 256;\n\tp = buf = g_malloc (size);\n\n\tresource_tree_encode (tree, p, p, &p);\n\n\tg_assert (p - buf <= size);\n\n\tassembly->win32_res = g_malloc (p - buf);\n\tassembly->win32_res_size = p - buf;\n\tmemcpy (assembly->win32_res, buf, p - buf);\n\n\tg_free (buf);\n\tresource_tree_free (tree);\n}\n\nstatic void\nfixup_resource_directory (char *res_section, char *p, guint32 rva)\n{\n\tMonoPEResourceDir *dir = (MonoPEResourceDir*)p;\n\tint i;\n\n\tp += sizeof (MonoPEResourceDir);\n\tfor (i = 0; i < GUINT16_FROM_LE (dir->res_named_entries) + GUINT16_FROM_LE (dir->res_id_entries); ++i) {\n\t\tMonoPEResourceDirEntry *dir_entry = (MonoPEResourceDirEntry*)p;\n\t\tchar *child = res_section + MONO_PE_RES_DIR_ENTRY_DIR_OFFSET (*dir_entry);\n\t\tif (MONO_PE_RES_DIR_ENTRY_IS_DIR (*dir_entry)) {\n\t\t\tfixup_resource_directory (res_section, child, rva);\n\t\t} else {\n\t\t\tMonoPEResourceDataEntry *data_entry = (MonoPEResourceDataEntry*)child;\n\t\t\tdata_entry->rde_data_offset = GUINT32_TO_LE (GUINT32_FROM_LE (data_entry->rde_data_offset) + rva);\n\t\t}\n\n\t\tp += sizeof (MonoPEResourceDirEntry);\n\t}\n}\n\nstatic void\nchecked_write_file (HANDLE f, gconstpointer buffer, guint32 numbytes)\n{\n\tguint32 dummy;\n\tif (!WriteFile (f, buffer, numbytes, &dummy, NULL))\n\t\tg_error (\"WriteFile returned %d\\n\", GetLastError ());\n}\n\n/*\n * mono_image_create_pefile:\n * @mb: a module builder object\n * \n * This function creates the PE-COFF header, the image sections, the CLI header  * etc. all the data is written in\n * assembly->pefile where it can be easily retrieved later in chunks.\n */\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tMonoMSDOSHeader *msdos;\n\tMonoDotNetHeader *header;\n\tMonoSectionTable *section;\n\tMonoCLIHeader *cli_header;\n\tguint32 size, image_size, virtual_base, text_offset;\n\tguint32 header_start, section_start, file_offset, virtual_offset;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDynamicStream pefile_stream = {0};\n\tMonoDynamicStream *pefile = &pefile_stream;\n\tint i, nsections;\n\tguint32 *rva, value;\n\tguchar *p;\n\tstatic const unsigned char msheader[] = {\n\t\t0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,\n\t\t0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,\n\t\t0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,  0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,\n\t\t0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72,  0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,\n\t\t0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e,  0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,\n\t\t0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tassemblyb = mb->assemblyb;\n\n\tmono_image_basic_init (assemblyb);\n\tassembly = mb->dynamic_image;\n\n\tassembly->pe_kind = assemblyb->pe_kind;\n\tassembly->machine = assemblyb->machine;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->pe_kind = assemblyb->pe_kind;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->machine = assemblyb->machine;\n\t\n\tmono_image_build_metadata (mb);\n\n\tif (mb->is_main && assemblyb->resources) {\n\t\tint len = mono_array_length (assemblyb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (assemblyb->resources, MonoReflectionResource, i));\n\t}\n\n\tif (mb->resources) {\n\t\tint len = mono_array_length (mb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (mb->resources, MonoReflectionResource, i));\n\t}\n\n\tbuild_compressed_metadata (assembly);\n\n\tif (mb->is_main)\n\t\tassembly_add_win32_resources (assembly, assemblyb);\n\n\tnsections = calc_section_size (assembly);\n\t\n\t/* The DOS header and stub */\n\tg_assert (sizeof (MonoMSDOSHeader) == sizeof (msheader));\n\tmono_image_add_stream_data (pefile, (char*)msheader, sizeof (msheader));\n\n\t/* the dotnet header */\n\theader_start = mono_image_add_stream_zero (pefile, sizeof (MonoDotNetHeader));\n\n\t/* the section tables */\n\tsection_start = mono_image_add_stream_zero (pefile, sizeof (MonoSectionTable) * nsections);\n\n\tfile_offset = section_start + sizeof (MonoSectionTable) * nsections;\n\tvirtual_offset = VIRT_ALIGN;\n\timage_size = 0;\n\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t/* align offsets */\n\t\tfile_offset += FILE_ALIGN - 1;\n\t\tfile_offset &= ~(FILE_ALIGN - 1);\n\t\tvirtual_offset += VIRT_ALIGN - 1;\n\t\tvirtual_offset &= ~(VIRT_ALIGN - 1);\n\n\t\tassembly->sections [i].offset = file_offset;\n\t\tassembly->sections [i].rva = virtual_offset;\n\n\t\tfile_offset += assembly->sections [i].size;\n\t\tvirtual_offset += assembly->sections [i].size;\n\t\timage_size += (assembly->sections [i].size + VIRT_ALIGN - 1) & ~(VIRT_ALIGN - 1);\n\t}\n\n\tfile_offset += FILE_ALIGN - 1;\n\tfile_offset &= ~(FILE_ALIGN - 1);\n\n\timage_size += section_start + sizeof (MonoSectionTable) * nsections;\n\n\t/* back-patch info */\n\tmsdos = (MonoMSDOSHeader*)pefile->data;\n\tmsdos->pe_offset = GUINT32_FROM_LE (sizeof (MonoMSDOSHeader));\n\n\theader = (MonoDotNetHeader*)(pefile->data + header_start);\n\theader->pesig [0] = 'P';\n\theader->pesig [1] = 'E';\n\t\n\theader->coff.coff_machine = GUINT16_FROM_LE (assemblyb->machine);\n\theader->coff.coff_sections = GUINT16_FROM_LE (nsections);\n\theader->coff.coff_time = GUINT32_FROM_LE (time (NULL));\n\theader->coff.coff_opt_header_size = GUINT16_FROM_LE (sizeof (MonoDotNetHeader) - sizeof (MonoCOFFHeader) - 4);\n\tif (assemblyb->pekind == 1) {\n\t\t/* it's a dll */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x210e);\n\t} else {\n\t\t/* it's an exe */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x010e);\n\t}\n\n\tvirtual_base = 0x400000; /* FIXME: 0x10000000 if a DLL */\n\n\theader->pe.pe_magic = GUINT16_FROM_LE (0x10B);\n\theader->pe.pe_major = 6;\n\theader->pe.pe_minor = 0;\n\tsize = assembly->sections [MONO_SECTION_TEXT].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_code_size = GUINT32_FROM_LE(size);\n\tsize = assembly->sections [MONO_SECTION_RSRC].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_data_size = GUINT32_FROM_LE(size);\n\tg_assert (START_TEXT_RVA == assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_code_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_data_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\t/* pe_rva_entry_point always at the beginning of the text section */\n\theader->pe.pe_rva_entry_point = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\n\theader->nt.pe_image_base = GUINT32_FROM_LE (virtual_base);\n\theader->nt.pe_section_align = GUINT32_FROM_LE (VIRT_ALIGN);\n\theader->nt.pe_file_alignment = GUINT32_FROM_LE (FILE_ALIGN);\n\theader->nt.pe_os_major = GUINT16_FROM_LE (4);\n\theader->nt.pe_os_minor = GUINT16_FROM_LE (0);\n\theader->nt.pe_subsys_major = GUINT16_FROM_LE (4);\n\tsize = section_start;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->nt.pe_header_size = GUINT32_FROM_LE (size);\n\tsize = image_size;\n\tsize += VIRT_ALIGN - 1;\n\tsize &= ~(VIRT_ALIGN - 1);\n\theader->nt.pe_image_size = GUINT32_FROM_LE (size);\n\n\t/*\n\t// Translate the PEFileKind value to the value expected by the Windows loader\n\t*/\n\t{\n\t\tshort kind;\n\n\t\t/*\n\t\t// PEFileKinds.Dll == 1\n\t\t// PEFileKinds.ConsoleApplication == 2\n\t\t// PEFileKinds.WindowApplication == 3\n\t\t//\n\t\t// need to get:\n\t\t//     IMAGE_SUBSYSTEM_WINDOWS_GUI 2 // Image runs in the Windows GUI subsystem.\n                //     IMAGE_SUBSYSTEM_WINDOWS_CUI 3 // Image runs in the Windows character subsystem.\n\t\t*/\n\t\tif (assemblyb->pekind == 3)\n\t\t\tkind = 2;\n\t\telse\n\t\t\tkind = 3;\n\t\t\n\t\theader->nt.pe_subsys_required = GUINT16_FROM_LE (kind);\n\t}    \n\theader->nt.pe_stack_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_stack_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_heap_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_heap_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_loader_flags = GUINT32_FROM_LE (0);\n\theader->nt.pe_data_dir_count = GUINT32_FROM_LE (16);\n\n\t/* fill data directory entries */\n\n\theader->datadir.pe_resource_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].size);\n\theader->datadir.pe_resource_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\n\theader->datadir.pe_reloc_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].size);\n\theader->datadir.pe_reloc_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].rva);\n\n\theader->datadir.pe_cli_header.size = GUINT32_FROM_LE (72);\n\theader->datadir.pe_cli_header.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->cli_header_offset);\n\theader->datadir.pe_iat.size = GUINT32_FROM_LE (8);\n\theader->datadir.pe_iat.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\t/* patch entrypoint name */\n\tif (assemblyb->pekind == 1)\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorDllMain\", 12);\n\telse\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorExeMain\", 12);\n\t/* patch imported function RVA name */\n\trva = (guint32*)(assembly->code.data + assembly->iat_offset);\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset);\n\n\t/* the import table */\n\theader->datadir.pe_import_table.size = GUINT32_FROM_LE (79); /* FIXME: magic number? */\n\theader->datadir.pe_import_table.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->idt_offset);\n\t/* patch imported dll RVA name and other entries in the dir */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, name_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset + 14); /* 14 is hint+strlen+1 of func name */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_address_table_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_lookup_table));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->ilt_offset);\n\n\tp = (guchar*)(assembly->code.data + assembly->ilt_offset);\n\tvalue = (assembly->text_rva + assembly->imp_names_offset);\n\t*p++ = (value) & 0xff;\n\t*p++ = (value >> 8) & (0xff);\n\t*p++ = (value >> 16) & (0xff);\n\t*p++ = (value >> 24) & (0xff);\n\n\t/* the CLI header info */\n\tcli_header = (MonoCLIHeader*)(assembly->code.data + assembly->cli_header_offset);\n\tcli_header->ch_size = GUINT32_FROM_LE (72);\n\tcli_header->ch_runtime_major = GUINT16_FROM_LE (2);\n\tif (mono_framework_version () > 1)\n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (5);\n\telse \n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (0);\n\tcli_header->ch_flags = GUINT32_FROM_LE (assemblyb->pe_kind);\n\tif (assemblyb->entry_point) {\n\t\tguint32 table_idx = 0;\n\t\tif (!strcmp (assemblyb->entry_point->object.vtable->klass->name, \"MethodBuilder\")) {\n\t\t\tMonoReflectionMethodBuilder *methodb = (MonoReflectionMethodBuilder*)assemblyb->entry_point;\n\t\t\ttable_idx = methodb->table_idx;\n\t\t} else {\n\t\t\ttable_idx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, assemblyb->entry_point->method));\n\t\t}\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (table_idx | MONO_TOKEN_METHOD_DEF);\n\t} else {\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (0);\n\t}\n\t/* The embedded managed resources */\n\ttext_offset = assembly->text_rva + assembly->code.index;\n\tcli_header->ch_resources.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_resources.size = GUINT32_FROM_LE (assembly->resources.index);\n\ttext_offset += assembly->resources.index;\n\tcli_header->ch_metadata.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_metadata.size = GUINT32_FROM_LE (assembly->meta_size);\n\ttext_offset += assembly->meta_size;\n\tif (assembly->strong_name_size) {\n\t\tcli_header->ch_strong_name.rva = GUINT32_FROM_LE (text_offset);\n\t\tcli_header->ch_strong_name.size = GUINT32_FROM_LE (assembly->strong_name_size);\n\t\ttext_offset += assembly->strong_name_size;\n\t}\n\n\t/* write the section tables and section content */\n\tsection = (MonoSectionTable*)(pefile->data + section_start);\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tstatic const char section_names [][7] = {\n\t\t\t\".text\", \".rsrc\", \".reloc\"\n\t\t};\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\tstrcpy (section->st_name, section_names [i]);\n\t\t/*g_print (\"output section %s (%d), size: %d\\n\", section->st_name, i, assembly->sections [i].size);*/\n\t\tsection->st_virtual_address = GUINT32_FROM_LE (assembly->sections [i].rva);\n\t\tsection->st_virtual_size = GUINT32_FROM_LE (assembly->sections [i].size);\n\t\tsection->st_raw_data_size = GUINT32_FROM_LE (GUINT32_TO_LE (section->st_virtual_size) + (FILE_ALIGN - 1));\n\t\tsection->st_raw_data_size &= GUINT32_FROM_LE (~(FILE_ALIGN - 1));\n\t\tsection->st_raw_data_ptr = GUINT32_FROM_LE (assembly->sections [i].offset);\n\t\tsection->st_flags = GUINT32_FROM_LE (assembly->sections [i].attrs);\n\t\tsection ++;\n\t}\n\t\n\tchecked_write_file (file, pefile->data, pefile->index);\n\t\n\tmono_dynamic_stream_reset (pefile);\n\t\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t\n\t\tif (SetFilePointer (file, assembly->sections [i].offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\t\t\n\t\tswitch (i) {\n\t\tcase MONO_SECTION_TEXT:\n\t\t\t/* patch entry point */\n\t\t\tp = (guchar*)(assembly->code.data + 2);\n\t\t\tvalue = (virtual_base + assembly->text_rva + assembly->iat_offset);\n\t\t\t*p++ = (value) & 0xff;\n\t\t\t*p++ = (value >> 8) & 0xff;\n\t\t\t*p++ = (value >> 16) & 0xff;\n\t\t\t*p++ = (value >> 24) & 0xff;\n\t\t\n\t\t\tchecked_write_file (file, assembly->code.data, assembly->code.index);\n\t\t\tchecked_write_file (file, assembly->resources.data, assembly->resources.index);\n\t\t\tchecked_write_file (file, assembly->image.raw_metadata, assembly->meta_size);\n\t\t\tchecked_write_file (file, assembly->strong_name, assembly->strong_name_size);\n\t\t\t\t\n\n\t\t\tg_free (assembly->image.raw_metadata);\n\t\t\tbreak;\n\t\tcase MONO_SECTION_RELOC: {\n\t\t\tstruct {\n\t\t\t\tguint32 page_rva;\n\t\t\t\tguint32 block_size;\n\t\t\t\tguint16 type_and_offset;\n\t\t\t\tguint16 term;\n\t\t\t} reloc;\n\t\t\t\n\t\t\tg_assert (sizeof (reloc) == 12);\n\t\t\t\n\t\t\treloc.page_rva = GUINT32_FROM_LE (assembly->text_rva);\n\t\t\treloc.block_size = GUINT32_FROM_LE (12);\n\t\t\t\n\t\t\t/* \n\t\t\t * the entrypoint is always at the start of the text section \n\t\t\t * 3 is IMAGE_REL_BASED_HIGHLOW\n\t\t\t * 2 is patch_size_rva - text_rva\n\t\t\t */\n\t\t\treloc.type_and_offset = GUINT16_FROM_LE ((3 << 12) + (2));\n\t\t\treloc.term = 0;\n\t\t\t\n\t\t\tchecked_write_file (file, &reloc, sizeof (reloc));\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_SECTION_RSRC:\n\t\t\tif (assembly->win32_res) {\n\n\t\t\t\t/* Fixup the offsets in the IMAGE_RESOURCE_DATA_ENTRY structures */\n\t\t\t\tfixup_resource_directory (assembly->win32_res, assembly->win32_res, assembly->sections [i].rva);\n\t\t\t\tchecked_write_file (file, assembly->win32_res, assembly->win32_res_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\t\n\t/* check that the file is properly padded */\n\tif (SetFilePointer (file, file_offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\tif (! SetEndOfFile (file))\n\t\tg_error (\"SetEndOfFile returned %d\\n\", GetLastError ());\n\t\n\tmono_dynamic_stream_reset (&assembly->code);\n\tmono_dynamic_stream_reset (&assembly->us);\n\tmono_dynamic_stream_reset (&assembly->blob);\n\tmono_dynamic_stream_reset (&assembly->guid);\n\tmono_dynamic_stream_reset (&assembly->sheap);\n\n\tg_hash_table_foreach (assembly->blob_cache, (GHFunc)g_free, NULL);\n\tg_hash_table_destroy (assembly->blob_cache);\n\tassembly->blob_cache = NULL;\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tg_assert_not_reached ();\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tchar *name;\n\tMonoImage *image;\n\tMonoImageOpenStatus status;\n\tMonoDynamicAssembly *assembly;\n\tguint32 module_count;\n\tMonoImage **new_modules;\n\tgboolean *new_modules_loaded;\n\t\n\tname = mono_string_to_utf8 (fileName);\n\n\timage = mono_image_open (name, &status);\n\tif (!image) {\n\t\tMonoException *exc;\n\t\tif (status == MONO_IMAGE_ERROR_ERRNO)\n\t\t\texc = mono_get_exception_file_not_found (fileName);\n\t\telse\n\t\t\texc = mono_get_exception_bad_image_format (name);\n\t\tg_free (name);\n\t\tmono_raise_exception (exc);\n\t}\n\n\tg_free (name);\n\n\tassembly = ab->dynamic_assembly;\n\timage->assembly = (MonoAssembly*)assembly;\n\n\tmodule_count = image->assembly->image->module_count;\n\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\tnew_modules_loaded = g_new0 (gboolean, module_count + 1);\n\n\tif (image->assembly->image->modules)\n\t\tmemcpy (new_modules, image->assembly->image->modules, module_count * sizeof (MonoImage *));\n\tif (image->assembly->image->modules_loaded)\n\t\tmemcpy (new_modules_loaded, image->assembly->image->modules_loaded, module_count * sizeof (gboolean));\n\tnew_modules [module_count] = image;\n\tnew_modules_loaded [module_count] = TRUE;\n\tmono_image_addref (image);\n\n\tg_free (image->assembly->image->modules);\n\timage->assembly->image->modules = new_modules;\n\timage->assembly->image->modules_loaded = new_modules_loaded;\n\timage->assembly->image->module_count ++;\n\n\tmono_assembly_load_references (image, &status);\n\tif (status) {\n\t\tmono_image_close (image);\n\t\tmono_raise_exception (mono_get_exception_file_not_found (fileName));\n\t}\n\n\treturn mono_module_get_object (mono_domain_get (), image);\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/*\n * We need to return always the same object for MethodInfo, FieldInfo etc..\n * but we need to consider the reflected type.\n * type uses a different hash, since it uses custom hash/equal functions.\n */\n\ntypedef struct {\n\tgpointer item;\n\tMonoClass *refclass;\n} ReflectedEntry;\n\nstatic gboolean\nreflected_equal (gconstpointer a, gconstpointer b) {\n\tconst ReflectedEntry *ea = a;\n\tconst ReflectedEntry *eb = b;\n\n\treturn (ea->item == eb->item) && (ea->refclass == eb->refclass);\n}\n\nstatic guint\nreflected_hash (gconstpointer a) {\n\tconst ReflectedEntry *ea = a;\n\treturn mono_aligned_addr_hash (ea->item);\n}\n\n#define CHECK_OBJECT(t,p,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n\t\tReflectedEntry e; \t\\\n\t\te.item = (p);\t\\\n\t\te.refclass = (k);\t\\\n\t\tmono_domain_lock (domain);\t\\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n\t\tif ((_obj = mono_g_hash_table_lookup (domain->refobject_hash, &e))) {\t\\\n\t\t\tmono_domain_unlock (domain);\t\\\n\t\t\treturn _obj;\t\\\n\t\t}\t\\\n        mono_domain_unlock (domain); \\\n\t} while (0)\n\n#ifdef HAVE_BOEHM_GC\n/* ReflectedEntry doesn't need to be GC tracked */\n#define ALLOC_REFENTRY g_new0 (ReflectedEntry, 1)\n#define FREE_REFENTRY(entry) g_free ((entry))\n#define REFENTRY_REQUIRES_CLEANUP\n#else\n#define ALLOC_REFENTRY mono_mempool_alloc (domain->mp, sizeof (ReflectedEntry))\n/* FIXME: */\n#define FREE_REFENTRY(entry)\n#endif\n\n#define CACHE_OBJECT(t,p,o,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n        ReflectedEntry pe; \\\n        pe.item = (p); \\\n        pe.refclass = (k); \\\n        mono_domain_lock (domain); \\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n        _obj = mono_g_hash_table_lookup (domain->refobject_hash, &pe); \\\n        if (!_obj) { \\\n\t\t    ReflectedEntry *e = ALLOC_REFENTRY; \t\\\n\t\t    e->item = (p);\t\\\n\t\t    e->refclass = (k);\t\\\n\t\t    mono_g_hash_table_insert (domain->refobject_hash, e,o);\t\\\n            _obj = o; \\\n        } \\\n\t\tmono_domain_unlock (domain);\t\\\n        return _obj; \\\n\t} while (0)\n\nstatic void\nclear_cached_object (MonoDomain *domain, gpointer o, MonoClass *klass)\n{\n\tmono_domain_lock (domain);\n\tif (domain->refobject_hash) {\n        ReflectedEntry pe;\n\t\tgpointer orig_pe, orig_value;\n\n\t\tpe.item = o;\n\t\tpe.refclass = klass;\n\t\tif (mono_g_hash_table_lookup_extended (domain->refobject_hash, &pe, &orig_pe, &orig_value)) {\n\t\t\tmono_g_hash_table_remove (domain->refobject_hash, &pe);\n\t\t\tFREE_REFENTRY (orig_pe);\n\t\t}\n\t}\n\tmono_domain_unlock (domain);\n}\n\n#ifdef REFENTRY_REQUIRES_CLEANUP\nstatic void\ncleanup_refobject_hash (gpointer key, gpointer value, gpointer user_data)\n{\n\tFREE_REFENTRY (key);\n}\n#endif\n\nvoid\nmono_reflection_cleanup_domain (MonoDomain *domain)\n{\n\tif (domain->refobject_hash) {\n/*let's avoid scanning the whole hashtable if not needed*/\n#ifdef REFENTRY_REQUIRES_CLEANUP\n\t\tmono_g_hash_table_foreach (domain->refobject_hash, cleanup_refobject_hash, NULL);\n#endif\n\t\tmono_g_hash_table_destroy (domain->refobject_hash);\n\t\tdomain->refobject_hash = NULL;\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic gpointer\nregister_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly)\n{\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\nstatic gpointer\nregister_module (MonoDomain *domain, MonoReflectionModuleBuilder *res, MonoDynamicImage *module)\n{\n\tCACHE_OBJECT (MonoReflectionModuleBuilder *, module, res, NULL);\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\tMonoReflectionAssemblyBuilder *ab = moduleb->assemblyb;\n\tif (!image) {\n\t\tMonoError error;\n\t\tint module_count;\n\t\tMonoImage **new_modules;\n\t\tMonoImage *ass;\n\t\tchar *name, *fqname;\n\t\t/*\n\t\t * FIXME: we already created an image in mono_image_basic_init (), but\n\t\t * we don't know which module it belongs to, since that is only \n\t\t * determined at assembly save time.\n\t\t */\n\t\t/*image = (MonoDynamicImage*)ab->dynamic_assembly->assembly.image; */\n\t\tname = mono_string_to_utf8 (ab->name);\n\t\tfqname = mono_string_to_utf8_checked (moduleb->module.fqname, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tg_free (name);\n\t\t\tmono_error_raise_exception (&error);\n\t\t}\n\t\timage = create_dynamic_mono_image (ab->dynamic_assembly, name, fqname);\n\n\t\tmoduleb->module.image = &image->image;\n\t\tmoduleb->dynamic_image = image;\n\t\tregister_module (mono_object_domain (moduleb), moduleb, image);\n\n\t\t/* register the module with the assembly */\n\t\tass = ab->dynamic_assembly->assembly.image;\n\t\tmodule_count = ass->module_count;\n\t\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\n\t\tif (ass->modules)\n\t\t\tmemcpy (new_modules, ass->modules, module_count * sizeof (MonoImage *));\n\t\tnew_modules [module_count] = &image->image;\n\t\tmono_image_addref (&image->image);\n\n\t\tg_free (ass->modules);\n\t\tass->modules = new_modules;\n\t\tass->module_count ++;\n\t}\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\n\tg_assert (type->type);\n\timage->wrappers_type = mono_class_from_mono_type (type->type);\n}\n\n#endif\n\n/*\n * mono_assembly_get_object:\n * @domain: an app domain\n * @assembly: an assembly\n *\n * Return an System.Reflection.Assembly object representing the MonoAssembly @assembly.\n */\nMonoReflectionAssembly*\nmono_assembly_get_object (MonoDomain *domain, MonoAssembly *assembly)\n{\n\tstatic MonoClass *System_Reflection_Assembly;\n\tMonoReflectionAssembly *res;\n\t\n\tCHECK_OBJECT (MonoReflectionAssembly *, assembly, NULL);\n\tif (!System_Reflection_Assembly)\n\t\tSystem_Reflection_Assembly = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Assembly\");\n\tres = (MonoReflectionAssembly *)mono_object_new (domain, System_Reflection_Assembly);\n\tres->assembly = assembly;\n\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\n\n\nMonoReflectionModule*   \nmono_module_get_object   (MonoDomain *domain, MonoImage *image)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tchar* basename;\n\t\n\tCHECK_OBJECT (MonoReflectionModule *, image, NULL);\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\tres->image = image;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, image->name));\n\tbasename = g_path_get_basename (image->name);\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, basename));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, image->module_name));\n\t\n\tg_free (basename);\n\n\tif (image->assembly->image == image) {\n\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULE, 1);\n\t} else {\n\t\tint i;\n\t\tres->token = 0;\n\t\tif (image->assembly->image->modules) {\n\t\t\tfor (i = 0; i < image->assembly->image->module_count; i++) {\n\t\t\t\tif (image->assembly->image->modules [i] == image)\n\t\t\t\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULEREF, i + 1);\n\t\t\t}\n\t\t\tg_assert (res->token);\n\t\t}\n\t}\n\n\tCACHE_OBJECT (MonoReflectionModule *, image, res, NULL);\n}\n\nMonoReflectionModule*   \nmono_module_file_get_object (MonoDomain *domain, MonoImage *image, int table_index)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tMonoTableInfo *table;\n\tguint32 cols [MONO_FILE_SIZE];\n\tconst char *name;\n\tguint32 i, name_idx;\n\tconst char *val;\n\t\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tg_assert (table_index < table->rows);\n\tmono_metadata_decode_row (table, table_index, cols, MONO_FILE_SIZE);\n\n\tres->image = NULL;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\tname = mono_metadata_string_heap (image, cols [MONO_FILE_NAME]);\n\n\t/* Check whenever the row has a corresponding row in the moduleref table */\n\ttable = &image->tables [MONO_TABLE_MODULEREF];\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tname_idx = mono_metadata_decode_row_col (table, i, MONO_MODULEREF_NAME);\n\t\tval = mono_metadata_string_heap (image, name_idx);\n\t\tif (strcmp (val, name) == 0)\n\t\t\tres->image = image->modules [i];\n\t}\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, name));\n\tres->is_resource = cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA;\n\tres->token = mono_metadata_make_token (MONO_TABLE_FILE, table_index + 1);\n\n\treturn res;\n}\n\nstatic gboolean\nmymono_metadata_type_equal (MonoType *t1, MonoType *t2)\n{\n\tif ((t1->type != t2->type) ||\n\t    (t1->byref != t2->byref))\n\t\treturn FALSE;\n\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TRUE;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn t1->data.klass == t2->data.klass;\n\tcase MONO_TYPE_PTR:\n\t\treturn mymono_metadata_type_equal (t1->data.type, t2->data.type);\n\tcase MONO_TYPE_ARRAY:\n\t\tif (t1->data.array->rank != t2->data.array->rank)\n\t\t\treturn FALSE;\n\t\treturn t1->data.array->eklass == t2->data.array->eklass;\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *i1 = t1->data.generic_class->context.class_inst;\n\t\tMonoGenericInst *i2 = t2->data.generic_class->context.class_inst;\n\t\tif (i1->type_argc != i2->type_argc)\n\t\t\treturn FALSE;\n\t\tif (!mono_metadata_type_equal (&t1->data.generic_class->container_class->byval_arg,\n\t\t\t\t\t       &t2->data.generic_class->container_class->byval_arg))\n\t\t\treturn FALSE;\n\t\t/* FIXME: we should probably just compare the instance pointers directly.  */\n\t\tfor (i = 0; i < i1->type_argc; ++i) {\n\t\t\tif (!mono_metadata_type_equal (i1->type_argv [i], i2->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn t1->data.generic_param == t2->data.generic_param;\n\tdefault:\n\t\tg_error (\"implement type compare for %0x!\", t1->type);\n\t\treturn FALSE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic guint\nmymono_metadata_type_hash (MonoType *t1)\n{\n\tguint hash;\n\n\thash = t1->type;\n\n\thash |= t1->byref << 6; /* do not collide with t1->type values */\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\t/* check if the distribution is good enough */\n\t\treturn ((hash << 5) - hash) ^ g_str_hash (t1->data.klass->name);\n\tcase MONO_TYPE_PTR:\n\t\treturn ((hash << 5) - hash) ^ mymono_metadata_type_hash (t1->data.type);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *inst = t1->data.generic_class->context.class_inst;\n\t\thash += g_str_hash (t1->data.generic_class->container_class->name);\n\t\thash *= 13;\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\thash += mymono_metadata_type_hash (inst->type_argv [i]);\n\t\t\thash *= 13;\n\t\t}\n\t\treturn hash;\n\t}\n\t}\n\treturn hash;\n}\n\nstatic MonoReflectionGenericClass*\nmono_generic_class_get_object (MonoDomain *domain, MonoType *geninst)\n{\n\tstatic MonoClass *System_Reflection_MonoGenericClass;\n\tMonoReflectionGenericClass *res;\n\tMonoClass *klass, *gklass;\n\tMonoGenericInst *ginst;\n\tMonoArray *type_args;\n\tint i;\n\n\tif (!System_Reflection_MonoGenericClass) {\n\t\tSystem_Reflection_MonoGenericClass = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"MonoGenericClass\");\n\t\tg_assert (System_Reflection_MonoGenericClass);\n\t}\n\n\tklass = mono_class_from_mono_type (geninst);\n\tgklass = klass->generic_class->container_class;\n\n\tmono_class_init (klass);\n\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionGenericClass *) mono_gc_alloc_pinned_obj (mono_class_vtable (domain, System_Reflection_MonoGenericClass), mono_class_instance_size (System_Reflection_MonoGenericClass));\n#else\n\tres = (MonoReflectionGenericClass *) mono_object_new (domain, System_Reflection_MonoGenericClass);\n#endif\n\n\tres->type.type = geninst;\n\tg_assert (gklass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)gklass->reflection_info)->vtable->klass->name, \"TypeBuilder\"));\n\tMONO_OBJECT_SETREF (res, generic_type, gklass->reflection_info);\n\n\tginst = klass->generic_class->context.class_inst;\n\ttype_args = mono_array_new (domain, mono_defaults.systemtype_class, ginst->type_argc);\n\tfor (i = 0; i < ginst->type_argc; ++i)\n\t\tmono_array_setref (type_args, i, mono_type_get_object (domain, ginst->type_argv [i]));\n\tMONO_OBJECT_SETREF (res, type_arguments, type_args);\n\n\treturn res;\n}\n\nstatic gboolean\nverify_safe_for_managed_space (MonoType *type)\n{\n\tswitch (type->type) {\n#ifdef DEBUG_HARDER\n\tcase MONO_TYPE_ARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.array->eklass->byval_arg);\n\tcase MONO_TYPE_PTR:\n\t\treturn verify_safe_for_managed_space (type->data.type);\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.klass->byval_arg);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoGenericInst *inst = type->data.generic_class->inst;\n\t\tint i;\n\t\tif (!inst->is_open)\n\t\t\tbreak;\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tif (!verify_safe_for_managed_space (inst->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\tbreak;\n\t}\n#endif\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn TRUE;\n\t}\n\treturn TRUE;\n}\n\n/*\n * mono_type_get_object:\n * @domain: an app domain\n * @type: a type\n *\n * Return an System.MonoType object representing the type @type.\n */\nMonoReflectionType*\nmono_type_get_object (MonoDomain *domain, MonoType *type)\n{\n\tMonoReflectionType *res;\n\tMonoClass *klass = mono_class_from_mono_type (type);\n\n\t/*we must avoid using @type as it might have come\n\t * from a mono_metadata_type_dup and the caller\n\t * expects that is can be freed.\n\t * Using the right type from \n\t */\n\ttype = klass->byval_arg.byref == type->byref ? &klass->byval_arg : &klass->this_arg;\n\n\t/* void is very common */\n\tif (type->type == MONO_TYPE_VOID && domain->typeof_void)\n\t\treturn (MonoReflectionType*)domain->typeof_void;\n\n\t/*\n\t * If the vtable of the given class was already created, we can use\n\t * the MonoType from there and avoid all locking and hash table lookups.\n\t * \n\t * We cannot do this for TypeBuilders as mono_reflection_create_runtime_class expects\n\t * that the resulting object is different.   \n\t */\n\tif (type == &klass->byval_arg && !klass->image->dynamic) {\n\t\tMonoVTable *vtable = mono_class_try_get_vtable (domain, klass);\n\t\tif (vtable && vtable->type)\n\t\t\treturn vtable->type;\n\t}\n\n\tmono_loader_lock (); /*FIXME mono_class_init and mono_class_vtable acquire it*/\n\tmono_domain_lock (domain);\n\tif (!domain->type_hash)\n\t\tdomain->type_hash = mono_g_hash_table_new_type ((GHashFunc)mymono_metadata_type_hash, \n\t\t\t\t(GCompareFunc)mymono_metadata_type_equal, MONO_HASH_VALUE_GC);\n\tif ((res = mono_g_hash_table_lookup (domain->type_hash, type))) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* Create a MonoGenericClass object for instantiations of not finished TypeBuilders */\n\tif ((type->type == MONO_TYPE_GENERICINST) && type->data.generic_class->is_dynamic && !type->data.generic_class->container_class->wastypebuilder) {\n\t\tres = (MonoReflectionType *)mono_generic_class_get_object (domain, type);\n\t\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tif (!verify_safe_for_managed_space (type)) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"This type cannot be propagated to managed space\"));\n\t}\n\n\tif (klass->reflection_info && !klass->wastypebuilder) {\n\t\tgboolean is_type_done = TRUE;\n\t\t/* Generic parameters have reflection_info set but they are not finished together with their enclosing type.\n\t\t * We must ensure that once a type is finished we don't return a GenericTypeParameterBuilder.\n\t\t * We can't simply close the types as this will interfere with other parts of the generics machinery.\n\t\t*/\n\t\tif (klass->byval_arg.type == MONO_TYPE_MVAR || klass->byval_arg.type == MONO_TYPE_VAR) {\n\t\t\tMonoGenericParam *gparam = klass->byval_arg.data.generic_param;\n\n\t\t\tif (gparam->owner && gparam->owner->is_method) {\n\t\t\t\tMonoMethod *method = gparam->owner->owner.method;\n\t\t\t\tif (method && mono_class_get_generic_type_definition (method->klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t} else if (gparam->owner && !gparam->owner->is_method) {\n\t\t\t\tMonoClass *klass = gparam->owner->owner.klass;\n\t\t\t\tif (klass && mono_class_get_generic_type_definition (klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t}\n\t\t} \n\n\t\t/* g_assert_not_reached (); */\n\t\t/* should this be considered an error condition? */\n\t\tif (is_type_done && !type->byref) {\n\t\t\tmono_domain_unlock (domain);\n\t\t\tmono_loader_unlock ();\n\t\t\treturn klass->reflection_info;\n\t\t}\n\t}\n\t// FIXME: Get rid of this, do it in the icalls for Type\n\tmono_class_init (klass);\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionType *)mono_gc_alloc_pinned_obj (mono_class_vtable (domain, mono_defaults.monotype_class), mono_class_instance_size (mono_defaults.monotype_class));\n#else\n\tres = (MonoReflectionType *)mono_object_new (domain, mono_defaults.monotype_class);\n#endif\n\tres->type = type;\n\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\n\tif (type->type == MONO_TYPE_VOID)\n\t\tdomain->typeof_void = (MonoObject*)res;\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\treturn res;\n}\n\n/*\n * mono_method_get_object:\n * @domain: an app domain\n * @method: a method\n * @refclass: the reflected type (can be NULL)\n *\n * Return an System.Reflection.MonoMethod object representing the method @method.\n */\nMonoReflectionMethod*\nmono_method_get_object (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\t/*\n\t * We use the same C representation for methods and constructors, but the type \n\t * name in C# is different.\n\t */\n\tstatic MonoClass *System_Reflection_MonoMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoCMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericCMethod = NULL;\n\tMonoClass *klass;\n\tMonoReflectionMethod *ret;\n\n\tif (method->is_inflated) {\n\t\tMonoReflectionGenericMethod *gret;\n\n\t\trefclass = method->klass;\n\t\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\t\tif ((*method->name == '.') && (!strcmp (method->name, \".ctor\") || !strcmp (method->name, \".cctor\"))) {\n\t\t\tif (!System_Reflection_MonoGenericCMethod)\n\t\t\t\tSystem_Reflection_MonoGenericCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericCMethod\");\n\t\t\tklass = System_Reflection_MonoGenericCMethod;\n\t\t} else {\n\t\t\tif (!System_Reflection_MonoGenericMethod)\n\t\t\t\tSystem_Reflection_MonoGenericMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericMethod\");\n\t\t\tklass = System_Reflection_MonoGenericMethod;\n\t\t}\n\t\tgret = (MonoReflectionGenericMethod*)mono_object_new (domain, klass);\n\t\tgret->method.method = method;\n\t\tMONO_OBJECT_SETREF (gret, method.name, mono_string_new (domain, method->name));\n\t\tMONO_OBJECT_SETREF (gret, method.reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\t\tCACHE_OBJECT (MonoReflectionMethod *, method, (MonoReflectionMethod*)gret, refclass);\n\t}\n\n\tif (!refclass)\n\t\trefclass = method->klass;\n\n\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\tif (*method->name == '.' && (strcmp (method->name, \".ctor\") == 0 || strcmp (method->name, \".cctor\") == 0)) {\n\t\tif (!System_Reflection_MonoCMethod)\n\t\t\tSystem_Reflection_MonoCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoCMethod\");\n\t\tklass = System_Reflection_MonoCMethod;\n\t}\n\telse {\n\t\tif (!System_Reflection_MonoMethod)\n\t\t\tSystem_Reflection_MonoMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoMethod\");\n\t\tklass = System_Reflection_MonoMethod;\n\t}\n\tret = (MonoReflectionMethod*)mono_object_new (domain, klass);\n\tret->method = method;\n\tMONO_OBJECT_SETREF (ret, reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\tCACHE_OBJECT (MonoReflectionMethod *, method, ret, refclass);\n}\n\n/*\n * mono_method_clear_object:\n *\n *   Clear the cached reflection objects for the dynamic method METHOD.\n */\nvoid\nmono_method_clear_object (MonoDomain *domain, MonoMethod *method)\n{\n\tMonoClass *klass;\n\tg_assert (method->dynamic);\n\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, method, klass);\n\t\tklass = klass->parent;\n\t}\n\t/* Added by mono_param_get_objects () */\n\tclear_cached_object (domain, &(method->signature), NULL);\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, &(method->signature), klass);\n\t\tklass = klass->parent;\n\t}\n}\n\n/*\n * mono_field_get_object:\n * @domain: an app domain\n * @klass: a type\n * @field: a field\n *\n * Return an System.Reflection.MonoField object representing the field @field\n * in class @klass.\n */\nMonoReflectionField*\nmono_field_get_object (MonoDomain *domain, MonoClass *klass, MonoClassField *field)\n{\n\tMonoReflectionField *res;\n\tstatic MonoClass *monofield_klass;\n\n\tCHECK_OBJECT (MonoReflectionField *, field, klass);\n\tif (!monofield_klass)\n\t\tmonofield_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoField\");\n\tres = (MonoReflectionField *)mono_object_new (domain, monofield_klass);\n\tres->klass = klass;\n\tres->field = field;\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, mono_field_get_name (field)));\n\tif (is_field_on_inst (field))\n\t\tres->attrs = get_field_on_inst_generic_type (field)->attrs;\n\telse\n\t\tres->attrs = field->type->attrs;\n\tMONO_OBJECT_SETREF (res, type, mono_type_get_object (domain, field->type));\n\tCACHE_OBJECT (MonoReflectionField *, field, res, klass);\n}\n\n/*\n * mono_property_get_object:\n * @domain: an app domain\n * @klass: a type\n * @property: a property\n *\n * Return an System.Reflection.MonoProperty object representing the property @property\n * in class @klass.\n */\nMonoReflectionProperty*\nmono_property_get_object (MonoDomain *domain, MonoClass *klass, MonoProperty *property)\n{\n\tMonoReflectionProperty *res;\n\tstatic MonoClass *monoproperty_klass;\n\n\tCHECK_OBJECT (MonoReflectionProperty *, property, klass);\n\tif (!monoproperty_klass)\n\t\tmonoproperty_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoProperty\");\n\tres = (MonoReflectionProperty *)mono_object_new (domain, monoproperty_klass);\n\tres->klass = klass;\n\tres->property = property;\n\tCACHE_OBJECT (MonoReflectionProperty *, property, res, klass);\n}\n\n/*\n * mono_event_get_object:\n * @domain: an app domain\n * @klass: a type\n * @event: a event\n *\n * Return an System.Reflection.MonoEvent object representing the event @event\n * in class @klass.\n */\nMonoReflectionEvent*\nmono_event_get_object (MonoDomain *domain, MonoClass *klass, MonoEvent *event)\n{\n\tMonoReflectionEvent *res;\n\tMonoReflectionMonoEvent *mono_event;\n\tstatic MonoClass *monoevent_klass;\n\n\tCHECK_OBJECT (MonoReflectionEvent *, event, klass);\n\tif (!monoevent_klass)\n\t\tmonoevent_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoEvent\");\n\tmono_event = (MonoReflectionMonoEvent *)mono_object_new (domain, monoevent_klass);\n\tmono_event->klass = klass;\n\tmono_event->event = event;\n\tres = (MonoReflectionEvent*)mono_event;\n\tCACHE_OBJECT (MonoReflectionEvent *, event, res, klass);\n}\n\n/**\n * mono_get_reflection_missing_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.Reflection.Missing.Value singleton object\n * (of type System.Reflection.Missing).\n *\n * Used as the value for ParameterInfo.DefaultValue when Optional\n * is present\n */\nstatic MonoObject *\nmono_get_reflection_missing_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *missing_value_field = NULL;\n\t\n\tif (!missing_value_field) {\n\t\tMonoClass *missing_klass;\n\t\tmissing_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"Missing\");\n\t\tmono_class_init (missing_klass);\n\t\tmissing_value_field = mono_class_get_field_from_name (missing_klass, \"Value\");\n\t\tg_assert (missing_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, missing_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic MonoObject*\nget_dbnull (MonoDomain *domain, MonoObject **dbnull)\n{\n\tif (!*dbnull)\n\t\t*dbnull = mono_get_dbnull_object (domain);\n\treturn *dbnull;\n}\n\nstatic MonoObject*\nget_reflection_missing (MonoDomain *domain, MonoObject **reflection_missing)\n{\n\tif (!*reflection_missing)\n\t\t*reflection_missing = mono_get_reflection_missing_object (domain);\n\treturn *reflection_missing;\n}\n\n/*\n * mono_param_get_objects:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.ParameterInfo array object representing the parameters\n * in the method @method.\n */\nMonoArray*\nmono_param_get_objects_internal (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\tstatic MonoClass *System_Reflection_ParameterInfo;\n\tstatic MonoClass *System_Reflection_ParameterInfo_array;\n\tMonoArray *res = NULL;\n\tMonoReflectionMethod *member = NULL;\n\tMonoReflectionParameter *param = NULL;\n\tchar **names, **blobs = NULL;\n\tguint32 *types = NULL;\n\tMonoType *type = NULL;\n\tMonoObject *dbnull = NULL;\n\tMonoObject *missing = NULL;\n\tMonoMarshalSpec **mspecs;\n\tMonoMethodSignature *sig;\n\tMonoVTable *pinfo_vtable;\n\tint i;\n\n\tif (!System_Reflection_ParameterInfo_array) {\n\t\tMonoClass *klass;\n\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ParameterInfo\");\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo = klass; \n\t\n\t\tklass = mono_array_class_get (klass, 1);\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo_array = klass;\n\t}\n\t\n\tif (!mono_method_signature (method)->param_count)\n\t\treturn mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), 0);\n\n\t/* Note: the cache is based on the address of the signature into the method\n\t * since we already cache MethodInfos with the method as keys.\n\t */\n\tCHECK_OBJECT (MonoArray*, &(method->signature), refclass);\n\n\tsig = mono_method_signature (method);\n\tmember = mono_method_get_object (domain, method, refclass);\n\tnames = g_new (char *, sig->param_count);\n\tmono_method_get_param_names (method, (const char **) names);\n\n\tmspecs = g_new (MonoMarshalSpec*, sig->param_count + 1);\n\tmono_method_get_marshal_info (method, mspecs);\n\n\tres = mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), sig->param_count);\n\tpinfo_vtable = mono_class_vtable (domain, System_Reflection_ParameterInfo);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tparam = (MonoReflectionParameter *)mono_object_new_specific (pinfo_vtable);\n\t\tMONO_OBJECT_SETREF (param, ClassImpl, mono_type_get_object (domain, sig->params [i]));\n\t\tMONO_OBJECT_SETREF (param, MemberImpl, (MonoObject*)member);\n\t\tMONO_OBJECT_SETREF (param, NameImpl, mono_string_new (domain, names [i]));\n\t\tparam->PositionImpl = i;\n\t\tparam->AttrsImpl = sig->params [i]->attrs;\n\n\t\tif (!(param->AttrsImpl & PARAM_ATTRIBUTE_HAS_DEFAULT)) {\n\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\telse\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t} else {\n\n\t\t\tif (!blobs) {\n\t\t\t\tblobs = g_new0 (char *, sig->param_count);\n\t\t\t\ttypes = g_new0 (guint32, sig->param_count);\n\t\t\t\tget_default_param_value_blobs (method, blobs, types); \n\t\t\t}\n\n\t\t\t/* Build MonoType for the type from the Constant Table */\n\t\t\tif (!type)\n\t\t\t\ttype = g_new0 (MonoType, 1);\n\t\t\ttype->type = types [i];\n\t\t\ttype->data.klass = NULL;\n\t\t\tif (types [i] == MONO_TYPE_CLASS)\n\t\t\t\ttype->data.klass = mono_defaults.object_class;\n\t\t\telse if ((sig->params [i]->type == MONO_TYPE_VALUETYPE) && sig->params [i]->data.klass->enumtype) {\n\t\t\t\t/* For enums, types [i] contains the base type */\n\n\t\t\t\t\ttype->type = MONO_TYPE_VALUETYPE;\n\t\t\t\t\ttype->data.klass = mono_class_from_mono_type (sig->params [i]);\n\t\t\t} else\n\t\t\t\ttype->data.klass = mono_class_from_mono_type (type);\n\n\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, mono_get_object_from_blob (domain, type, blobs [i]));\n\n\t\t\t/* Type in the Constant table is MONO_TYPE_CLASS for nulls */\n\t\t\tif (types [i] != MONO_TYPE_CLASS && !param->DefaultValueImpl) {\n\t\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\t\telse\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif (mspecs [i + 1])\n\t\t\tMONO_OBJECT_SETREF (param, MarshalAsImpl, (MonoObject*)mono_reflection_marshal_from_marshal_spec (domain, method->klass, mspecs [i + 1]));\n\t\t\n\t\tmono_array_setref (res, i, param);\n\t}\n\tg_free (names);\n\tg_free (blobs);\n\tg_free (types);\n\tg_free (type);\n\n\tfor (i = mono_method_signature (method)->param_count; i >= 0; i--)\n\t\tif (mspecs [i])\n\t\t\tmono_metadata_free_marshal_spec (mspecs [i]);\n\tg_free (mspecs);\n\t\n\tCACHE_OBJECT (MonoArray *, &(method->signature), res, refclass);\n}\n\nMonoArray*\nmono_param_get_objects (MonoDomain *domain, MonoMethod *method)\n{\n\treturn mono_param_get_objects_internal (domain, method, NULL);\n}\n\n/*\n * mono_method_body_get_object:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.MethodBody object representing the method @method.\n */\nMonoReflectionMethodBody*\nmono_method_body_get_object (MonoDomain *domain, MonoMethod *method)\n{\n\tstatic MonoClass *System_Reflection_MethodBody = NULL;\n\tstatic MonoClass *System_Reflection_LocalVariableInfo = NULL;\n\tstatic MonoClass *System_Reflection_ExceptionHandlingClause = NULL;\n\tMonoReflectionMethodBody *ret;\n\tMonoMethodNormal *mn;\n\tMonoMethodHeader *header;\n\tMonoImage *image;\n\tguint32 method_rva, local_var_sig_token;\n    char *ptr;\n\tunsigned char format, flags;\n\tint i;\n\n\tif (!System_Reflection_MethodBody)\n\t\tSystem_Reflection_MethodBody = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MethodBody\");\n\tif (!System_Reflection_LocalVariableInfo)\n\t\tSystem_Reflection_LocalVariableInfo = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"LocalVariableInfo\");\n\tif (!System_Reflection_ExceptionHandlingClause)\n\t\tSystem_Reflection_ExceptionHandlingClause = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ExceptionHandlingClause\");\n\n\tCHECK_OBJECT (MonoReflectionMethodBody *, method, NULL);\n\n\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t(method->flags & METHOD_ATTRIBUTE_ABSTRACT) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME))\n\t\treturn NULL;\n\n\tmn = (MonoMethodNormal *)method;\n\timage = method->klass->image;\n\theader = mono_method_get_header (method);\n\n\tif (!image->dynamic) {\n\t\t/* Obtain local vars signature token */\n\t\tmethod_rva = mono_metadata_decode_row_col (&image->tables [MONO_TABLE_METHOD], mono_metadata_token_index (method->token) - 1, MONO_METHOD_RVA);\n\t\tptr = mono_image_rva_map (image, method_rva);\n\t\tflags = *(const unsigned char *) ptr;\n\t\tformat = flags & METHOD_HEADER_FORMAT_MASK;\n\t\tswitch (format){\n\t\tcase METHOD_HEADER_TINY_FORMAT:\n\t\t\tlocal_var_sig_token = 0;\n\t\t\tbreak;\n\t\tcase METHOD_HEADER_FAT_FORMAT:\n\t\t\tptr += 2;\n\t\t\tptr += 2;\n\t\t\tptr += 4;\n\t\t\tlocal_var_sig_token = read32 (ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else\n\t\tlocal_var_sig_token = 0; //FIXME\n\n\tret = (MonoReflectionMethodBody*)mono_object_new (domain, System_Reflection_MethodBody);\n\n\tret->init_locals = header->init_locals;\n\tret->max_stack = header->max_stack;\n\tret->local_var_sig_token = local_var_sig_token;\n\tMONO_OBJECT_SETREF (ret, il, mono_array_new_cached (domain, mono_defaults.byte_class, header->code_size));\n\tmemcpy (mono_array_addr (ret->il, guint8, 0), header->code, header->code_size);\n\n\t/* Locals */\n\tMONO_OBJECT_SETREF (ret, locals, mono_array_new_cached (domain, System_Reflection_LocalVariableInfo, header->num_locals));\n\tfor (i = 0; i < header->num_locals; ++i) {\n\t\tMonoReflectionLocalVariableInfo *info = (MonoReflectionLocalVariableInfo*)mono_object_new (domain, System_Reflection_LocalVariableInfo);\n\t\tMONO_OBJECT_SETREF (info, local_type, mono_type_get_object (domain, header->locals [i]));\n\t\tinfo->is_pinned = header->locals [i]->pinned;\n\t\tinfo->local_index = i;\n\t\tmono_array_setref (ret->locals, i, info);\n\t}\n\n\t/* Exceptions */\n\tMONO_OBJECT_SETREF (ret, clauses, mono_array_new_cached (domain, System_Reflection_ExceptionHandlingClause, header->num_clauses));\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tMonoReflectionExceptionHandlingClause *info = (MonoReflectionExceptionHandlingClause*)mono_object_new (domain, System_Reflection_ExceptionHandlingClause);\n\t\tMonoExceptionClause *clause = &header->clauses [i];\n\n\t\tinfo->flags = clause->flags;\n\t\tinfo->try_offset = clause->try_offset;\n\t\tinfo->try_length = clause->try_len;\n\t\tinfo->handler_offset = clause->handler_offset;\n\t\tinfo->handler_length = clause->handler_len;\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tinfo->filter_offset = clause->data.filter_offset;\n\t\telse if (clause->data.catch_class)\n\t\t\tMONO_OBJECT_SETREF (info, catch_type, mono_type_get_object (mono_domain_get (), &clause->data.catch_class->byval_arg));\n\n\t\tmono_array_setref (ret->clauses, i, info);\n\t}\n\n\tCACHE_OBJECT (MonoReflectionMethodBody *, method, ret, NULL);\n\treturn ret;\n}\n\n/**\n * mono_get_dbnull_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.DBNull.Value singleton object\n *\n * Used as the value for ParameterInfo.DefaultValue \n */\nMonoObject *\nmono_get_dbnull_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *dbnull_value_field = NULL;\n\t\n\tif (!dbnull_value_field) {\n\t\tMonoClass *dbnull_klass;\n\t\tdbnull_klass = mono_class_from_name (mono_defaults.corlib, \"System\", \"DBNull\");\n\t\tmono_class_init (dbnull_klass);\n\t\tdbnull_value_field = mono_class_get_field_from_name (dbnull_klass, \"Value\");\n\t\tg_assert (dbnull_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, dbnull_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic void\nget_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types)\n{\n\tguint32 param_index, i, lastp, crow = 0;\n\tguint32 param_cols [MONO_PARAM_SIZE], const_cols [MONO_CONSTANT_SIZE];\n\tgint32 idx;\n\n\tMonoClass *klass = method->klass;\n\tMonoImage *image = klass->image;\n\tMonoMethodSignature *methodsig = mono_method_signature (method);\n\n\tMonoTableInfo *constt;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\n\tif (!methodsig->param_count)\n\t\treturn;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *aux;\n\t\tif (method->is_inflated)\n\t\t\tmethod = ((MonoMethodInflated*)method)->declaring;\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (aux && aux->param_defaults) {\n\t\t\tmemcpy (blobs, &(aux->param_defaults [1]), methodsig->param_count * sizeof (char*));\n\t\t\tmemcpy (types, &(aux->param_default_types [1]), methodsig->param_count * sizeof (guint32));\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tconstt = &image->tables [MONO_TABLE_CONSTANT];\n\n\tidx = mono_method_get_index (method) - 1;\n\tg_assert (idx != -1);\n\n\tparam_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\tif (idx + 1 < methodt->rows)\n\t\tlastp = mono_metadata_decode_row_col (methodt, idx + 1, MONO_METHOD_PARAMLIST);\n\telse\n\t\tlastp = paramt->rows + 1;\n\n\tfor (i = param_index; i < lastp; ++i) {\n\t\tguint32 paramseq;\n\n\t\tmono_metadata_decode_row (paramt, i - 1, param_cols, MONO_PARAM_SIZE);\n\t\tparamseq = param_cols [MONO_PARAM_SEQUENCE];\n\n\t\tif (!(param_cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_DEFAULT))\n\t\t\tcontinue;\n\n\t\tcrow = mono_metadata_get_constant_index (image, MONO_TOKEN_PARAM_DEF | i, crow + 1);\n\t\tif (!crow) {\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tmono_metadata_decode_row (constt, crow - 1, const_cols, MONO_CONSTANT_SIZE);\n\t\tblobs [paramseq - 1] = (gpointer) mono_metadata_blob_heap (image, const_cols [MONO_CONSTANT_VALUE]);\n\t\ttypes [paramseq - 1] = const_cols [MONO_CONSTANT_TYPE];\n\t}\n\n\treturn;\n}\n\nstatic MonoObject *\nmono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob)\n{\n\tvoid *retval;\n\tMonoClass *klass;\n\tMonoObject *object;\n\tMonoType *basetype = type;\n\n\tif (!blob)\n\t\treturn NULL;\n\t\n\tklass = mono_class_from_mono_type (type);\n\tif (klass->valuetype) {\n\t\tobject = mono_object_new (domain, klass);\n\t\tretval = ((gchar *) object + sizeof (MonoObject));\n\t\tif (klass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (klass);\n\t} else {\n\t\tretval = &object;\n\t}\n\t\t\t\n\tif (!mono_get_constant_value_from_blob (domain, basetype->type,  blob, retval))\n\t\treturn object;\n\telse\n\t\treturn NULL;\n}\n\nstatic int\nassembly_name_to_aname (MonoAssemblyName *assembly, char *p) {\n\tint found_sep;\n\tchar *s;\n\n\tmemset (assembly, 0, sizeof (MonoAssemblyName));\n\tassembly->name = p;\n\tassembly->culture = \"\";\n\tmemset (assembly->public_key_token, 0, MONO_PUBLIC_KEY_TOKEN_LENGTH);\n\n\twhile (*p && (isalnum (*p) || *p == '.' || *p == '-' || *p == '_' || *p == '$' || *p == '@'))\n\t\tp++;\n\tfound_sep = 0;\n\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t*p++ = 0;\n\t\tfound_sep = 1;\n\t\tcontinue;\n\t}\n\t/* failed */\n\tif (!found_sep)\n\t\treturn 1;\n\twhile (*p) {\n\t\tif (*p == 'V' && g_ascii_strncasecmp (p, \"Version=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tassembly->major = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->minor = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->build = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->revision = strtoul (p, &s, 10);\n\t\t\tif (s == p)\n\t\t\t\treturn 1;\n\t\t\tp = s;\n\t\t} else if (*p == 'C' && g_ascii_strncasecmp (p, \"Culture=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tif (g_ascii_strncasecmp (p, \"neutral\", 7) == 0) {\n\t\t\t\tassembly->culture = \"\";\n\t\t\t\tp += 7;\n\t\t\t} else {\n\t\t\t\tassembly->culture = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (*p == 'P' && g_ascii_strncasecmp (p, \"PublicKeyToken=\", 15) == 0) {\n\t\t\tp += 15;\n\t\t\tif (strncmp (p, \"null\", 4) == 0) {\n\t\t\t\tp += 4;\n\t\t\t} else {\n\t\t\t\tint len;\n\t\t\t\tgchar *start = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tlen = (p - start + 1);\n\t\t\t\tif (len > MONO_PUBLIC_KEY_TOKEN_LENGTH)\n\t\t\t\t\tlen = MONO_PUBLIC_KEY_TOKEN_LENGTH;\n\t\t\t\tg_strlcpy ((char*)assembly->public_key_token, start, len);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (*p && *p != ',')\n\t\t\t\tp++;\n\t\t}\n\t\tfound_sep = 0;\n\t\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t\t*p++ = 0;\n\t\t\tfound_sep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* failed */\n\t\tif (!found_sep)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * mono_reflection_parse_type:\n * @name: type name\n *\n * Parse a type name as accepted by the GetType () method and output the info\n * extracted in the info structure.\n * the name param will be mangled, so, make a copy before passing it to this function.\n * The fields in info will be valid until the memory pointed to by name is valid.\n *\n * See also mono_type_get_name () below.\n *\n * Returns: 0 on parse error.\n */\nstatic int\n_mono_reflection_parse_type (char *name, char **endptr, gboolean is_recursed,\n\t\t\t     MonoTypeNameParse *info)\n{\n\tchar *start, *p, *w, *temp, *last_point, *startn;\n\tint in_modifiers = 0;\n\tint isbyref = 0, rank, arity = 0, i;\n\n\tstart = p = w = name;\n\n\t//FIXME could we just zero the whole struct? memset (&info, 0, sizeof (MonoTypeNameParse))\n\tmemset (&info->assembly, 0, sizeof (MonoAssemblyName));\n\tinfo->name = info->name_space = NULL;\n\tinfo->nested = NULL;\n\tinfo->modifiers = NULL;\n\tinfo->type_arguments = NULL;\n\n\t/* last_point separates the namespace from the name */\n\tlast_point = NULL;\n\t/* Skips spaces */\n\twhile (*p == ' ') p++, start++, w++, name++;\n\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '+':\n\t\t\t*p = 0; /* NULL terminate the name */\n\t\t\tstartn = p + 1;\n\t\t\tinfo->nested = g_list_append (info->nested, startn);\n\t\t\t/* we have parsed the nesting namespace + name */\n\t\t\tif (info->name)\n\t\t\t\tbreak;\n\t\t\tif (last_point) {\n\t\t\t\tinfo->name_space = start;\n\t\t\t\t*last_point = 0;\n\t\t\t\tinfo->name = last_point + 1;\n\t\t\t} else {\n\t\t\t\tinfo->name_space = (char *)\"\";\n\t\t\t\tinfo->name = start;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tlast_point = p;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t++p;\n\t\t\tbreak;\n\t\tcase '&':\n\t\tcase '*':\n\t\tcase '[':\n\t\tcase ',':\n\t\tcase ']':\n\t\t\tin_modifiers = 1;\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\t++p;\n\t\t\ti = strtol (p, &temp, 10);\n\t\t\tarity += i;\n\t\t\tif (p == temp)\n\t\t\t\treturn 0;\n\t\t\tp = temp-1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (in_modifiers)\n\t\t\tbreak;\n\t\t// *w++ = *p++;\n\t\tp++;\n\t}\n\t\n\tif (!info->name) {\n\t\tif (last_point) {\n\t\t\tinfo->name_space = start;\n\t\t\t*last_point = 0;\n\t\t\tinfo->name = last_point + 1;\n\t\t} else {\n\t\t\tinfo->name_space = (char *)\"\";\n\t\t\tinfo->name = start;\n\t\t}\n\t}\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '&':\n\t\t\tif (isbyref) /* only one level allowed by the spec */\n\t\t\t\treturn 0;\n\t\t\tisbyref = 1;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (0));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-1));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tif (arity != 0) {\n\t\t\t\t*p++ = 0;\n\t\t\t\tinfo->type_arguments = g_ptr_array_new ();\n\t\t\t\tfor (i = 0; i < arity; i++) {\n\t\t\t\t\tMonoTypeNameParse *subinfo = g_new0 (MonoTypeNameParse, 1);\n\t\t\t\t\tgboolean fqname = FALSE;\n\n\t\t\t\t\tg_ptr_array_add (info->type_arguments, subinfo);\n\n\t\t\t\t\tif (*p == '[') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tfqname = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!_mono_reflection_parse_type (p, &p, TRUE, subinfo))\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t/*MS is lenient on [] delimited parameters that aren't fqn - and F# uses them.*/\n\t\t\t\t\tif (fqname && (*p != ']')) {\n\t\t\t\t\t\tchar *aname;\n\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t*p++ = 0;\n\n\t\t\t\t\t\taname = p;\n\t\t\t\t\t\twhile (*p && (*p != ']'))\n\t\t\t\t\t\t\tp++;\n\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t\twhile (*aname) {\n\t\t\t\t\t\t\tif (g_ascii_isspace (*aname)) {\n\t\t\t\t\t\t\t\t++aname;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!*aname ||\n\t\t\t\t\t\t    !assembly_name_to_aname (&subinfo->assembly, aname))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if (fqname && (*p == ']')) {\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < arity) {\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t*p++ = 0;\n\t\t\t\t}\n\n\t\t\t\tarity = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trank = 1;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == ',')\n\t\t\t\t\trank++;\n\t\t\t\telse if (*p == '*') /* '*' means unknown lower bound */\n\t\t\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-2));\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (*p++ != ']')\n\t\t\t\treturn 0;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (rank));\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\treturn 0;\n\t\tcase ',':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (g_ascii_isspace (*p)) {\n\t\t\t\t\t++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*p)\n\t\t\t\treturn 0; /* missing assembly name */\n\t\t\tif (!assembly_name_to_aname (&info->assembly, p))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (info->assembly.name)\n\t\t\tbreak;\n\t}\n\t// *w = 0; /* terminate class name */\n end:\n\tif (!info->name || !*info->name)\n\t\treturn 0;\n\tif (endptr)\n\t\t*endptr = p;\n\t/* add other consistency checks */\n\treturn 1;\n}\n\nint\nmono_reflection_parse_type (char *name, MonoTypeNameParse *info)\n{\n\treturn _mono_reflection_parse_type (name, NULL, FALSE, info);\n}\n\nstatic MonoType*\n_mono_reflection_get_type_from_info (MonoTypeNameParse *info, MonoImage *image, gboolean ignorecase)\n{\n\tgboolean type_resolve = FALSE;\n\tMonoType *type;\n\tMonoImage *rootimage = image;\n\n\tif (info->assembly.name) {\n\t\tMonoAssembly *assembly = mono_assembly_loaded (&info->assembly);\n\t\tif (!assembly && image && image->assembly && mono_assembly_names_equal (&info->assembly, &image->assembly->aname))\n\t\t\t/* \n\t\t\t * This could happen in the AOT compiler case when the search hook is not\n\t\t\t * installed.\n\t\t\t */\n\t\t\tassembly = image->assembly;\n\t\tif (!assembly) {\n\t\t\t/* then we must load the assembly ourselve - see #60439 */\n\t\t\tassembly = mono_assembly_load (&info->assembly, NULL, NULL);\n\t\t\tif (!assembly)\n\t\t\t\treturn NULL;\n\t\t}\n\t\timage = assembly->image;\n\t} else if (!image) {\n\t\timage = mono_defaults.corlib;\n\t}\n\n\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\tif (type == NULL && !info->assembly.name && image != mono_defaults.corlib) {\n\t\timage = mono_defaults.corlib;\n\t\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\t}\n\n\treturn type;\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoClass *klass;\n\tGList *mod;\n\tint modval;\n\tgboolean bounded = FALSE;\n\t\n\tif (!image)\n\t\timage = mono_defaults.corlib;\n\n\tif (ignorecase)\n\t\tklass = mono_class_from_name_case (image, info->name_space, info->name);\n\telse\n\t\tklass = mono_class_from_name (image, info->name_space, info->name);\n\tif (!klass)\n\t\treturn NULL;\n\tfor (mod = info->nested; mod; mod = mod->next) {\n\t\tgpointer iter = NULL;\n\t\tMonoClass *parent;\n\n\t\tparent = klass;\n\t\tmono_class_init (parent);\n\n\t\twhile ((klass = mono_class_get_nested_types (parent, &iter))) {\n\t\t\tif (ignorecase) {\n\t\t\t\tif (mono_utf8_strcasecmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (strcmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!klass)\n\t\t\tbreak;\n\t}\n\tif (!klass)\n\t\treturn NULL;\n\tmono_class_init (klass);\n\n\tif (info->type_arguments) {\n\t\tMonoType **type_args = g_new0 (MonoType *, info->type_arguments->len);\n\t\tMonoReflectionType *the_type;\n\t\tMonoType *instance;\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\ttype_args [i] = _mono_reflection_get_type_from_info (subinfo, rootimage, ignorecase);\n\t\t\tif (!type_args [i]) {\n\t\t\t\tg_free (type_args);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tthe_type = mono_type_get_object (mono_domain_get (), &klass->byval_arg);\n\n\t\tinstance = mono_reflection_bind_generic_parameters (\n\t\t\tthe_type, info->type_arguments->len, type_args);\n\n\t\tg_free (type_args);\n\t\tif (!instance)\n\t\t\treturn NULL;\n\n\t\tklass = mono_class_from_mono_type (instance);\n\t}\n\n\tfor (mod = info->modifiers; mod; mod = mod->next) {\n\t\tmodval = GPOINTER_TO_UINT (mod->data);\n\t\tif (!modval) { /* byref: must be last modifier */\n\t\t\treturn &klass->this_arg;\n\t\t} else if (modval == -1) {\n\t\t\tklass = mono_ptr_class_get (&klass->byval_arg);\n\t\t} else if (modval == -2) {\n\t\t\tbounded = TRUE;\n\t\t} else { /* array rank */\n\t\t\tklass = mono_bounded_array_class_get (klass, modval, bounded);\n\t\t}\n\t\tmono_class_init (klass);\n\t}\n\n\treturn &klass->byval_arg;\n}\n\n/*\n * mono_reflection_get_type:\n * @image: a metadata context\n * @info: type description structure\n * @ignorecase: flag for case-insensitive string compares\n * @type_resolve: whenever type resolve was already tried\n *\n * Build a MonoType from the type description in @info.\n * \n */\n\nMonoType*\nmono_reflection_get_type (MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve) {\n\treturn mono_reflection_get_type_with_rootimage(image, image, info, ignorecase, type_resolve);\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal_dynamic (MonoImage *rootimage, MonoAssembly *assembly, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoReflectionAssemblyBuilder *abuilder;\n\tMonoType *type;\n\tint i;\n\n\tg_assert (assembly->dynamic);\n\tabuilder = (MonoReflectionAssemblyBuilder*)mono_assembly_get_object (((MonoDynamicAssembly*)assembly)->domain, assembly);\n\n\t/* Enumerate all modules */\n\n\ttype = NULL;\n\tif (abuilder->modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->modules); ++i) {\n\t\t\tMonoReflectionModuleBuilder *mb = mono_array_get (abuilder->modules, MonoReflectionModuleBuilder*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, &mb->dynamic_image->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type && abuilder->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *mod = mono_array_get (abuilder->loaded_modules, MonoReflectionModule*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, mod->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn type;\n}\n\t\nMonoType*\nmono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve)\n{\n\tMonoType *type;\n\tMonoReflectionAssembly *assembly;\n\tGString *fullName;\n\tGList *mod;\n\n\tif (image && image->dynamic)\n\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, image->assembly, info, ignorecase);\n\telse\n\t\ttype = mono_reflection_get_type_internal (rootimage, image, info, ignorecase);\n\tif (type)\n\t\treturn type;\n\tif (!mono_domain_has_type_resolve (mono_domain_get ()))\n\t\treturn NULL;\n\n\tif (type_resolve) {\n\t\tif (*type_resolve) \n\t\t\treturn NULL;\n\t\telse\n\t\t\t*type_resolve = TRUE;\n\t}\n\t\n\t/* Reconstruct the type name */\n\tfullName = g_string_new (\"\");\n\tif (info->name_space && (info->name_space [0] != '\\0'))\n\t\tg_string_printf (fullName, \"%s.%s\", info->name_space, info->name);\n\telse\n\t\tg_string_printf (fullName, \"%s\", info->name);\n\tfor (mod = info->nested; mod; mod = mod->next)\n\t\tg_string_append_printf (fullName, \"+%s\", (char*)mod->data);\n\n\tassembly = mono_domain_try_type_resolve ( mono_domain_get (), fullName->str, NULL);\n\tif (assembly) {\n\t\tif (assembly->assembly->dynamic)\n\t\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, assembly->assembly, info, ignorecase);\n\t\telse\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, assembly->assembly->image, \n\t\t\t\t\t\t\t\t\t\t\t\t\t  info, ignorecase);\n\t}\n\tg_string_free (fullName, TRUE);\n\treturn type;\n}\n\nvoid\nmono_reflection_free_type_info (MonoTypeNameParse *info)\n{\n\tg_list_free (info->modifiers);\n\tg_list_free (info->nested);\n\n\tif (info->type_arguments) {\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\tmono_reflection_free_type_info (subinfo);\n\t\t\t/*We free the subinfo since it is allocated by _mono_reflection_parse_type*/\n\t\t\tg_free (subinfo);\n\t\t}\n\n\t\tg_ptr_array_free (info->type_arguments, TRUE);\n\t}\n}\n\n/*\n * mono_reflection_type_from_name:\n * @name: type name.\n * @image: a metadata context (can be NULL).\n *\n * Retrieves a MonoType from its @name. If the name is not fully qualified,\n * it defaults to get the type from @image or, if @image is NULL or loading\n * from it fails, uses corlib.\n * \n */\nMonoType*\nmono_reflection_type_from_name (char *name, MonoImage *image)\n{\n\tMonoType *type = NULL;\n\tMonoTypeNameParse info;\n\tchar *tmp;\n\n\t/* Make a copy since parse_type modifies its argument */\n\ttmp = g_strdup (name);\n\t\n\t/*g_print (\"requested type %s\\n\", str);*/\n\tif (mono_reflection_parse_type (tmp, &info)) {\n\t\ttype = _mono_reflection_get_type_from_info (&info, image, FALSE);\n\t}\n\n\tg_free (tmp);\n\tmono_reflection_free_type_info (&info);\n\treturn type;\n}\n\n/*\n * mono_reflection_get_token:\n *\n *   Return the metadata token of OBJ which should be an object\n * representing a metadata element.\n */\nguint32\nmono_reflection_get_token (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\n\t\t/* Call mono_image_create_token so the object gets added to the tokens hash table */\n\t\ttoken = mono_image_create_token (((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image, obj, FALSE, TRUE);\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_class_from_mono_type (type)->type_token;\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tMonoMethodInflated *inflated = (MonoMethodInflated *) m->method;\n\t\t\treturn inflated->declaring->token;\n\t\t} else {\n\t\t\ttoken = m->method->token;\n\t\t}\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField*)obj;\n\n\t\tif (is_field_on_inst (f->field)) {\n\t\t\tMonoDynamicGenericClass *dgclass = (MonoDynamicGenericClass*)f->field->parent->generic_class;\n\t\t\tint field_index = f->field - dgclass->fields;\n\t\t\tMonoObject *obj;\n\n\t\t\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\t\t\tobj = dgclass->field_objects [field_index];\n\t\t\treturn mono_reflection_get_token (obj);\n\t\t}\n\t\ttoken = mono_class_get_field_token (f->field);\n\t} else if (strcmp (klass->name, \"MonoProperty\") == 0) {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty*)obj;\n\n\t\ttoken = mono_class_get_property_token (p->property);\n\t} else if (strcmp (klass->name, \"MonoEvent\") == 0) {\n\t\tMonoReflectionMonoEvent *p = (MonoReflectionMonoEvent*)obj;\n\n\t\ttoken = mono_class_get_event_token (p->event);\n\t} else if (strcmp (klass->name, \"ParameterInfo\") == 0) {\n\t\tMonoReflectionParameter *p = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (p->MemberImpl);\n\t\tg_assert (mono_class_is_reflection_method_or_constructor (member_class));\n\n\t\ttoken = mono_method_get_param_token (((MonoReflectionMethod*)p->MemberImpl)->method, p->PositionImpl);\n\t} else if (strcmp (klass->name, \"Module\") == 0) {\n\t\tMonoReflectionModule *m = (MonoReflectionModule*)obj;\n\n\t\ttoken = m->token;\n\t} else if (strcmp (klass->name, \"Assembly\") == 0) {\n\t\ttoken = mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1);\n\t} else {\n\t\tgchar *msg = g_strdup_printf (\"MetadataToken is not supported for type '%s.%s'\", klass->name_space, klass->name);\n\t\tMonoException *ex = mono_get_exception_not_implemented (msg);\n\t\tg_free (msg);\n\t\tmono_raise_exception (ex);\n\t}\n\n\treturn token;\n}\n\nstatic void*\nload_cattr_value (MonoImage *image, MonoType *t, const char *p, const char **end)\n{\n\tint slen, type = t->type;\n\tMonoClass *tklass = t->data.klass;\n\nhandle_enum:\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN: {\n\t\tMonoBoolean *bval = g_malloc (sizeof (MonoBoolean));\n\t\t*bval = *p;\n\t\t*end = p + 1;\n\t\treturn bval;\n\t}\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2: {\n\t\tguint16 *val = g_malloc (sizeof (guint16));\n\t\t*val = read16 (p);\n\t\t*end = p + 2;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 4\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4: {\n\t\tguint32 *val = g_malloc (sizeof (guint32));\n\t\t*val = read32 (p);\n\t\t*end = p + 4;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 8\n\tcase MONO_TYPE_U: /* error out instead? this should probably not happen */\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8: {\n\t\tguint64 *val = g_malloc (sizeof (guint64));\n\t\t*val = read64 (p);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_R8: {\n\t\tdouble *val = g_malloc (sizeof (double));\n\t\treadr8 (p, val);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (t->data.klass->enumtype) {\n\t\t\ttype = mono_class_enum_basetype (t->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"generic valutype %s not handled in custom attr value decoding\", t->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING:\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t*end = p + slen;\n\t\treturn mono_string_new_len (mono_domain_get (), p, slen);\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *n;\n\t\tMonoType *t;\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\nhandle_type:\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\tn = g_memdup (p, slen + 1);\n\t\tn [slen] = 0;\n\t\tt = mono_reflection_type_from_name (n, image);\n\t\tif (!t)\n\t\t\tg_warning (\"Cannot load type '%s'\", n);\n\t\tg_free (n);\n\t\t*end = p + slen;\n\t\tif (t)\n\t\t\treturn mono_type_get_object (mono_domain_get (), t);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tchar subt = *p++;\n\t\tMonoObject *obj;\n\t\tMonoClass *subc = NULL;\n\t\tvoid *val;\n\n\t\tif (subt == 0x50) {\n\t\t\tgoto handle_type;\n\t\t} else if (subt == 0x0E) {\n\t\t\ttype = MONO_TYPE_STRING;\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x1D) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tint etype = *p;\n\t\t\tp ++;\n\n\t\t\tif (etype == 0x51)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\tetype = MONO_TYPE_OBJECT;\n\t\t\ttype = MONO_TYPE_SZARRAY;\n\t\t\tsimple_type.type = etype;\n\t\t\ttklass = mono_class_from_mono_type (&simple_type);\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x55) {\n\t\t\tchar *n;\n\t\t\tMonoType *t;\n\t\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t\tn = g_memdup (p, slen + 1);\n\t\t\tn [slen] = 0;\n\t\t\tt = mono_reflection_type_from_name (n, image);\n\t\t\tif (!t)\n\t\t\t\tg_error (\"Cannot load type '%s'\", n);\n\t\t\tg_free (n);\n\t\t\tp += slen;\n\t\t\tsubc = mono_class_from_mono_type (t);\n\t\t} else if (subt >= MONO_TYPE_BOOLEAN && subt <= MONO_TYPE_R8) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tsimple_type.type = subt;\n\t\t\tsubc = mono_class_from_mono_type (&simple_type);\n\t\t} else {\n\t\t\tg_error (\"Unknown type 0x%02x for object type encoding in custom attr\", subt);\n\t\t}\n\t\tval = load_cattr_value (image, &subc->byval_arg, p, end);\n\t\tobj = mono_object_new (mono_domain_get (), subc);\n\t\tmemcpy ((char*)obj + sizeof (MonoObject), val, mono_class_value_size (subc, NULL));\n\t\tg_free (val);\n\t\treturn obj;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tMonoArray *arr;\n\t\tguint32 i, alen, basetype;\n\t\talen = read32 (p);\n\t\tp += 4;\n\t\tif (alen == 0xffffffff) {\n\t\t\t*end = p;\n\t\t\treturn NULL;\n\t\t}\n\t\tarr = mono_array_new (mono_domain_get(), tklass, alen);\n\t\tbasetype = tklass->byval_arg.type;\n\t\tif (basetype == MONO_TYPE_VALUETYPE && tklass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (tklass)->type;\n\t\tswitch (basetype)\n\t\t{\n\t\t\tcase MONO_TYPE_U1:\n\t\t\tcase MONO_TYPE_I1:\n\t\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoBoolean val = *p++;\n\t\t\t\t\tmono_array_set (arr, MonoBoolean, i, val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CHAR:\n\t\t\tcase MONO_TYPE_U2:\n\t\t\tcase MONO_TYPE_I2:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint16 val = read16 (p);\n\t\t\t\t\tmono_array_set (arr, guint16, i, val);\n\t\t\t\t\tp += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R4:\n\t\t\tcase MONO_TYPE_U4:\n\t\t\tcase MONO_TYPE_I4:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint32 val = read32 (p);\n\t\t\t\t\tmono_array_set (arr, guint32, i, val);\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tdouble val;\n\t\t\t\t\treadr8 (p, &val);\n\t\t\t\t\tmono_array_set (arr, double, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_U8:\n\t\t\tcase MONO_TYPE_I8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint64 val = read64 (p);\n\t\t\t\t\tmono_array_set (arr, guint64, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoObject *item = load_cattr_value (image, &tklass->byval_arg, p, &p);\n\t\t\t\t\tmono_array_setref (arr, i, item);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_error (\"Type 0x%02x not handled in custom attr array decoding\", basetype);\n\t\t}\n\t\t*end=p;\n\t\treturn arr;\n\t}\n\tdefault:\n\t\tg_error (\"Type 0x%02x not handled in custom attr value decoding\", type);\n\t}\n\treturn NULL;\n}\n\nstatic MonoObject*\ncreate_cattr_typed_arg (MonoType *t, MonoObject *val)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *params [2], *unboxed;\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeTypedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\t\n\tparams [0] = mono_type_get_object (mono_domain_get (), t);\n\tparams [1] = val;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic MonoObject*\ncreate_cattr_named_arg (void *minfo, MonoObject *typedarg)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *unboxed, *params [2];\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeNamedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\n\tparams [0] = minfo;\n\tparams [1] = typedarg;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic gboolean\ntype_is_reference (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_VALUETYPE:\n\t\treturn FALSE;\n\tdefault:\n\t\treturn TRUE;\n\t}\n}\n\nstatic void\nfree_param_data (MonoMethodSignature *sig, void **params) {\n\tint i;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (!type_is_reference (sig->params [i]))\n\t\t\tg_free (params [i]);\n\t}\n}\n\n/*\n * Find the field index in the metadata FieldDef table.\n */\nstatic guint32\nfind_field_index (MonoClass *klass, MonoClassField *field) {\n\tint i;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tif (field == &klass->fields [i])\n\t\t\treturn klass->field.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the property index in the metadata Property table.\n */\nstatic guint32\nfind_property_index (MonoClass *klass, MonoProperty *property) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tif (property == &klass->ext->properties [i])\n\t\t\treturn klass->ext->property.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the event index in the metadata Event table.\n */\nstatic guint32\nfind_event_index (MonoClass *klass, MonoEvent *event) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\tif (event == &klass->ext->events [i])\n\t\t\treturn klass->ext->event.first + 1 + i;\n\t}\n\treturn 0;\n}\n\nstatic MonoObject*\ncreate_custom_attr (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tMonoObject *attr;\n\tvoid *params_buf [32];\n\tvoid **params;\n\tMonoMethodSignature *sig;\n\n\tmono_class_init (method->klass);\n\n\tif (len == 0) {\n\t\tattr = mono_object_new (mono_domain_get (), method->klass);\n\t\tmono_runtime_invoke (method, attr, NULL, NULL);\n\t\treturn attr;\n\t}\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn NULL;\n\n\t/*g_print (\"got attr %s\\n\", method->klass->name);*/\n\n\tsig = mono_method_signature (method);\n\tif (sig->param_count < 32)\n\t\tparams = params_buf;\n\telse\n\t\t/* Allocate using GC so it gets GC tracking */\n\t\tparams = mono_gc_alloc_fixed (sig->param_count * sizeof (void*), NULL);\n\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tparams [i] = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t}\n\n\tnamed = p;\n\tattr = mono_object_new (mono_domain_get (), method->klass);\n\tmono_runtime_invoke (method, attr, params, NULL);\n\tfree_param_data (method->signature, params);\n\tnum_named = read16 (named);\n\tnamed += 2;\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (mono_object_class (attr), name);\n\t\t\tvoid *val = load_cattr_value (image, field->type, named, &named);\n\t\t\tmono_field_set_value (attr, field, val);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoProperty *prop;\n\t\t\tvoid *pparams [1];\n\t\t\tMonoType *prop_type;\n\n\t\t\tprop = mono_class_get_property_from_name (mono_object_class (attr), name);\n\t\t\t/* can we have more that 1 arg in a custom attr named property? */\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\t\t\tpparams [0] = load_cattr_value (image, prop_type, named, &named);\n\t\t\tmono_property_set_value (prop, attr, pparams, NULL);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (pparams [0]);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\tif (params != params_buf)\n\t\tmono_gc_free_fixed (params);\n\n\treturn attr;\n}\n\t\n/*\n * mono_reflection_create_custom_attr_data_args:\n *\n *   Create an array of typed and named arguments from the cattr blob given by DATA.\n * TYPED_ARGS and NAMED_ARGS will contain the objects representing the arguments,\n * NAMED_ARG_INFO will contain information about the named arguments.\n */\nvoid\nmono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArray **typed_args, MonoArray **named_args, CattrNamedArg **named_arg_info)\n{\n\tMonoArray *typedargs, *namedargs;\n\tMonoClass *attrklass;\n\tMonoDomain *domain;\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tCattrNamedArg *arginfo = NULL;\n\n\tmono_class_init (method->klass);\n\n\t*typed_args = NULL;\n\t*named_args = NULL;\n\t*named_arg_info = NULL;\n\t\n\tdomain = mono_domain_get ();\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn;\n\n\ttypedargs = mono_array_new (domain, mono_get_object_class (), mono_method_signature (method)->param_count);\n\t\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj;\n\t\tvoid *val;\n\n\t\tval = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t\tobj = type_is_reference (mono_method_signature (method)->params [i]) ? \n\t\t\tval : mono_value_box (domain, mono_class_from_mono_type (mono_method_signature (method)->params [i]), val);\n\t\tmono_array_setref (typedargs, i, obj);\n\n\t\tif (!type_is_reference (mono_method_signature (method)->params [i]))\n\t\t\tg_free (val);\n\t}\n\n\tnamed = p;\n\tnum_named = read16 (named);\n\tnamedargs = mono_array_new (domain, mono_get_object_class (), num_named);\n\tnamed += 2;\n\tattrklass = method->klass;\n\n\targinfo = g_new0 (CattrNamedArg, num_named);\n\t*named_arg_info = arginfo;\n\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\targinfo [j].type = field->type;\n\t\t\targinfo [j].field = field;\n\n\t\t\tval = load_cattr_value (image, field->type, named, &named);\n\t\t\tobj = type_is_reference (field->type) ? val : mono_value_box (domain, mono_class_from_mono_type (field->type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoType *prop_type;\n\t\t\tMonoProperty *prop = mono_class_get_property_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\n\t\t\targinfo [j].type = prop_type;\n\t\t\targinfo [j].prop = prop;\n\n\t\t\tval = load_cattr_value (image, prop_type, named, &named);\n\t\t\tobj = type_is_reference (prop_type) ? val : mono_value_box (domain, mono_class_from_mono_type (prop_type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (val);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\t*typed_args = typedargs;\n\t*named_args = namedargs;\n}\n\nstatic MonoObject*\ncreate_custom_attr_data (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tMonoArray *typedargs, *namedargs;\n\tstatic MonoMethod *ctor;\n\tMonoDomain *domain;\n\tMonoObject *attr;\n\tvoid *params [3];\n\tCattrNamedArg *arginfo;\n\tint i;\n\n\tmono_class_init (method->klass);\n\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (mono_defaults.customattribute_data_class, \".ctor\", 3);\n\n\tdomain = mono_domain_get ();\n\tif (len == 0) {\n\t\t/* This is for Attributes with no parameters */\n\t\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\t\tparams [0] = mono_method_get_object (domain, method, NULL);\n\t\tparams [1] = params [2] = NULL;\n\t\tmono_runtime_invoke (method, attr, params, NULL);\n\t\treturn attr;\n\t}\n\n\tmono_reflection_create_custom_attr_data_args (image, method, data, len, &typedargs, &namedargs, &arginfo);\n\tif (!typedargs || !namedargs)\n\t\treturn NULL;\n\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj = mono_array_get (typedargs, MonoObject*, i);\n\t\tMonoObject *typedarg;\n\n\t\ttypedarg = create_cattr_typed_arg (mono_method_signature (method)->params [i], obj);\n\t\tmono_array_setref (typedargs, i, typedarg);\n\t}\n\n\tfor (i = 0; i < mono_array_length (namedargs); ++i) {\n\t\tMonoObject *obj = mono_array_get (namedargs, MonoObject*, i);\n\t\tMonoObject *typedarg, *namedarg, *minfo;\n\n\t\tif (arginfo [i].prop)\n\t\t\tminfo = (MonoObject*)mono_property_get_object (domain, NULL, arginfo [i].prop);\n\t\telse\n\t\t\tminfo = (MonoObject*)mono_field_get_object (domain, NULL, arginfo [i].field);\n\n\t\ttypedarg = create_cattr_typed_arg (arginfo [i].type, obj);\n\t\tnamedarg = create_cattr_named_arg (minfo, typedarg);\n\n\t\tmono_array_setref (namedargs, i, namedarg);\n\t}\n\n\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\tparams [0] = mono_method_get_object (domain, method, NULL);\n\tparams [1] = typedargs;\n\tparams [2] = namedargs;\n\tmono_runtime_invoke (ctor, attr, params, NULL);\n\treturn attr;\n}\n\nMonoArray*\nmono_custom_attrs_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (!cinfo->attrs [i].ctor)\n\t\t\t/* The cattr type is not finished yet */\n\t\t\t/* We should include the type name but cinfo doesn't contain it */\n\t\t\tmono_raise_exception (mono_get_exception_type_load (NULL, NULL));\n\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_construct_by_type (MonoCustomAttrInfo *cinfo, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i, n;\n\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass))\n\t\t\tn ++;\n\t}\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, n);\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass)) {\n\t\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\t\tmono_array_setref (result, n, attr);\n\t\t\tn ++;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_data_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\t\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tattr = create_custom_attr_data (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\n/**\n * mono_custom_attrs_from_index:\n *\n * Returns: NULL if no attributes are found or if a loading error occurs.\n */\nMonoCustomAttrInfo*\nmono_custom_attrs_from_index (MonoImage *image, guint32 idx)\n{\n\tguint32 mtoken, i, len;\n\tguint32 cols [MONO_CUSTOM_ATTR_SIZE];\n\tMonoTableInfo *ca;\n\tMonoCustomAttrInfo *ainfo;\n\tGList *tmp, *list = NULL;\n\tconst char *data;\n\n\tca = &image->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\ti = mono_metadata_custom_attrs_from_index (image, idx);\n\tif (!i)\n\t\treturn NULL;\n\ti --;\n\twhile (i < ca->rows) {\n\t\tif (mono_metadata_decode_row_col (ca, i, MONO_CUSTOM_ATTR_PARENT) != idx)\n\t\t\tbreak;\n\t\tlist = g_list_prepend (list, GUINT_TO_POINTER (i));\n\t\t++i;\n\t}\n\tlen = g_list_length (list);\n\tif (!len)\n\t\treturn NULL;\n\tainfo = g_malloc0 (MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * len);\n\tainfo->num_attrs = len;\n\tainfo->image = image;\n\tfor (i = 0, tmp = list; i < len; ++i, tmp = tmp->next) {\n\t\tmono_metadata_decode_row (ca, GPOINTER_TO_UINT (tmp->data), cols, MONO_CUSTOM_ATTR_SIZE);\n\t\tmtoken = cols [MONO_CUSTOM_ATTR_TYPE] >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (cols [MONO_CUSTOM_ATTR_TYPE] & MONO_CUSTOM_ATTR_TYPE_MASK) {\n\t\tcase MONO_CUSTOM_ATTR_TYPE_METHODDEF:\n\t\t\tmtoken |= MONO_TOKEN_METHOD_DEF;\n\t\t\tbreak;\n\t\tcase MONO_CUSTOM_ATTR_TYPE_MEMBERREF:\n\t\t\tmtoken |= MONO_TOKEN_MEMBER_REF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"Unknown table for custom attr type %08x\", cols [MONO_CUSTOM_ATTR_TYPE]);\n\t\t\tbreak;\n\t\t}\n\t\tainfo->attrs [i].ctor = mono_get_method (image, mtoken, NULL);\n\t\tif (!ainfo->attrs [i].ctor) {\n\t\t\tg_warning (\"Can't find custom attr constructor image: %s mtoken: 0x%08x\", image->name, mtoken);\n\t\t\tg_list_free (list);\n\t\t\tg_free (ainfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tdata = mono_metadata_blob_heap (image, cols [MONO_CUSTOM_ATTR_VALUE]);\n\t\tainfo->attrs [i].data_size = mono_metadata_decode_value (data, &data);\n\t\tainfo->attrs [i].data = (guchar*)data;\n\t}\n\tg_list_free (list);\n\n\treturn ainfo;\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_method (MonoMethod *method)\n{\n\tguint32 idx;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t\n\tif (method->dynamic || method->klass->image->dynamic)\n\t\treturn lookup_custom_attr (method->klass->image, method);\n\n\tif (!method->token)\n\t\t/* Synthetic methods */\n\t\treturn NULL;\n\n\tidx = mono_method_get_index (method);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_METHODDEF;\n\treturn mono_custom_attrs_from_index (method->klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_class (MonoClass *klass)\n{\n\tguint32 idx;\n\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\tif (klass->image->dynamic)\n\t\treturn lookup_custom_attr (klass->image, klass);\n\n\tif (klass->byval_arg.type == MONO_TYPE_VAR || klass->byval_arg.type == MONO_TYPE_MVAR) {\n\t\tidx = mono_metadata_token_index (klass->sizes.generic_param_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_GENERICPAR;\n\t} else {\n\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_TYPEDEF;\n\t}\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx;\n\t\n\tif (assembly->image->dynamic)\n\t\treturn lookup_custom_attr (assembly->image, assembly);\n\tidx = 1; /* there is only one assembly */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_ASSEMBLY;\n\treturn mono_custom_attrs_from_index (assembly->image, idx);\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_module (MonoImage *image)\n{\n\tguint32 idx;\n\t\n\tif (image->dynamic)\n\t\treturn lookup_custom_attr (image, image);\n\tidx = 1; /* there is only one module */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_MODULE;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_property (MonoClass *klass, MonoProperty *property)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tproperty = mono_metadata_get_corresponding_property_from_generic_type_definition (property);\n\t\treturn lookup_custom_attr (klass->image, property);\n\t}\n\tidx = find_property_index (klass, property);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PROPERTY;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_event (MonoClass *klass, MonoEvent *event)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tevent = mono_metadata_get_corresponding_event_from_generic_type_definition (event);\n\t\treturn lookup_custom_attr (klass->image, event);\n\t}\n\tidx = find_event_index (klass, event);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_EVENT;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_field (MonoClass *klass, MonoClassField *field)\n{\n\tguint32 idx;\n\tif (klass->image->dynamic) {\n\t\tfield = mono_metadata_get_corresponding_field_from_generic_type_definition (field);\n\t\treturn lookup_custom_attr (klass->image, field);\n\t}\n\tidx = find_field_index (klass, field);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_FIELDDEF;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_param (MonoMethod *method, guint32 param)\n{\n\tMonoTableInfo *ca;\n\tguint32 i, idx, method_index;\n\tguint32 param_list, param_last, param_pos, found;\n\tMonoImage *image;\n\tMonoReflectionMethodAux *aux;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoCustomAttrInfo *res, *ainfo;\n\t\tint size;\n\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!aux || !aux->param_cattr)\n\t\t\treturn NULL;\n\n\t\t/* Need to copy since it will be freed later */\n\t\tainfo = aux->param_cattr [param];\n\t\tif (!ainfo)\n\t\t\treturn NULL;\n\t\tsize = MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * ainfo->num_attrs;\n\t\tres = g_malloc0 (size);\n\t\tmemcpy (res, ainfo, size);\n\t\treturn res;\n\t}\n\n\timage = method->klass->image;\n\tmethod_index = mono_method_get_index (method);\n\tca = &image->tables [MONO_TABLE_METHOD];\n\n\tparam_list = mono_metadata_decode_row_col (ca, method_index - 1, MONO_METHOD_PARAMLIST);\n\tif (method_index == ca->rows) {\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t\tparam_last = ca->rows + 1;\n\t} else {\n\t\tparam_last = mono_metadata_decode_row_col (ca, method_index, MONO_METHOD_PARAMLIST);\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t}\n\tfound = FALSE;\n\tfor (i = param_list; i < param_last; ++i) {\n\t\tparam_pos = mono_metadata_decode_row_col (ca, i - 1, MONO_PARAM_SEQUENCE);\n\t\tif (param_pos == param) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\tidx = i;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PARAMDEF;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\ngboolean\nmono_custom_attrs_has_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i;\n\tMonoClass *klass;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass) || (MONO_CLASS_IS_INTERFACE (attr_klass) && mono_class_is_assignable_from (attr_klass, klass)))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nMonoObject*\nmono_custom_attrs_get_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i, attr_index;\n\tMonoClass *klass;\n\tMonoArray *attrs;\n\n\tattr_index = -1;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass)) {\n\t\t\tattr_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr_index == -1)\n\t\treturn NULL;\n\n\tattrs = mono_custom_attrs_construct (ainfo);\n\tif (attrs)\n\t\treturn mono_array_get (attrs, MonoObject*, attr_index);\n\telse\n\t\treturn NULL;\n}\n\n/*\n * mono_reflection_get_custom_attrs_info:\n * @obj: a reflection object handle\n *\n * Return the custom attribute info for attributes defined for the\n * reflection handle @obj. The objects.\n *\n * FIXME this function leaks like a sieve for SRE objects.\n */\nMonoCustomAttrInfo*\nmono_reflection_get_custom_attrs_info (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tMonoCustomAttrInfo *cinfo = NULL;\n\t\n\tklass = obj->vtable->klass;\n\tif (klass == mono_defaults.monotype_class) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tklass = mono_class_from_mono_type (type);\n\t\tcinfo = mono_custom_attrs_from_class (klass);\n\t} else if (strcmp (\"Assembly\", klass->name) == 0) {\n\t\tMonoReflectionAssembly *rassembly = (MonoReflectionAssembly*)obj;\n\t\tcinfo = mono_custom_attrs_from_assembly (rassembly->assembly);\n\t} else if (strcmp (\"Module\", klass->name) == 0) {\n\t\tMonoReflectionModule *module = (MonoReflectionModule*)obj;\n\t\tcinfo = mono_custom_attrs_from_module (module->image);\n\t} else if (strcmp (\"MonoProperty\", klass->name) == 0) {\n\t\tMonoReflectionProperty *rprop = (MonoReflectionProperty*)obj;\n\t\tcinfo = mono_custom_attrs_from_property (rprop->property->parent, rprop->property);\n\t} else if (strcmp (\"MonoEvent\", klass->name) == 0) {\n\t\tMonoReflectionMonoEvent *revent = (MonoReflectionMonoEvent*)obj;\n\t\tcinfo = mono_custom_attrs_from_event (revent->event->parent, revent->event);\n\t} else if (strcmp (\"MonoField\", klass->name) == 0) {\n\t\tMonoReflectionField *rfield = (MonoReflectionField*)obj;\n\t\tcinfo = mono_custom_attrs_from_field (rfield->field->parent, rfield->field);\n\t} else if ((strcmp (\"MonoMethod\", klass->name) == 0) || (strcmp (\"MonoCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if ((strcmp (\"MonoGenericMethod\", klass->name) == 0) || (strcmp (\"MonoGenericCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if (strcmp (\"ParameterInfo\", klass->name) == 0) {\n\t\tMonoReflectionParameter *param = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (param->MemberImpl);\n\t\tif (mono_class_is_reflection_method_or_constructor (member_class)) {\n\t\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)param->MemberImpl;\n\t\t\tcinfo = mono_custom_attrs_from_param (rmethod->method, param->PositionImpl + 1);\n\t\t} else if (is_sr_mono_property (member_class)) {\n\t\t\tMonoReflectionProperty *prop = (MonoReflectionProperty *)param->MemberImpl;\n\t\t\tMonoMethod *method;\n\t\t\tif (!(method = prop->property->get))\n\t\t\t\tmethod = prop->property->set;\n\t\t\tg_assert (method);\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_method_on_tb_inst (member_class)) {/*XXX This is a workaround for Compiler Context*/\n\t\t\tMonoMethod *method = mono_reflection_method_on_tb_inst_get_handle ((MonoReflectionMethodOnTypeBuilderInst*)param->MemberImpl);\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_ctor_on_tb_inst (member_class)) { /*XX This is a workaround for Compiler Context*/\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)param->MemberImpl;\n\t\t\tMonoMethod *method = NULL;\n\t\t\tif (is_sre_ctor_builder (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionCtorBuilder *)c->cb)->mhandle;\n\t\t\telse if (is_sr_mono_cmethod (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionMethod *)c->cb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"mono_reflection_get_custom_attrs_info:: can't handle a CTBI with base_method of type %s\", mono_type_get_full_name (member_class));\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else {\n\t\t\tchar *type_name = mono_type_get_full_name (member_class);\n\t\t\tchar *msg = g_strdup_printf (\"Custom attributes on a ParamInfo with member %s are not supported\", type_name);\n\t\t\tMonoException *ex = mono_get_exception_not_supported  (msg);\n\t\t\tg_free (type_name);\n\t\t\tg_free (msg);\n\t\t\tmono_raise_exception (ex);\n\t\t}\n\t} else if (strcmp (\"AssemblyBuilder\", klass->name) == 0) {\n\t\tMonoReflectionAssemblyBuilder *assemblyb = (MonoReflectionAssemblyBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, assemblyb->assembly.assembly->image, assemblyb->cattrs);\n\t} else if (strcmp (\"TypeBuilder\", klass->name) == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &tb->module->dynamic_image->image, tb->cattrs);\n\t} else if (strcmp (\"ModuleBuilder\", klass->name) == 0) {\n\t\tMonoReflectionModuleBuilder *mb = (MonoReflectionModuleBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &mb->dynamic_image->image, mb->cattrs);\n\t} else if (strcmp (\"ConstructorBuilder\", klass->name) == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, cb->mhandle->klass->image, cb->cattrs);\n\t} else if (strcmp (\"MethodBuilder\", klass->name) == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, mb->mhandle->klass->image, mb->cattrs);\n\t} else if (strcmp (\"FieldBuilder\", klass->name) == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image->image, fb->cattrs);\n\t} else if (strcmp (\"MonoGenericClass\", klass->name) == 0) {\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)obj;\n\t\tcinfo = mono_reflection_get_custom_attrs_info ((MonoObject*)gclass->generic_type);\n\t} else { /* handle other types here... */\n\t\tg_error (\"get custom attrs not yet supported for %s\", klass->name);\n\t}\n\n\treturn cinfo;\n}\n\n/*\n * mono_reflection_get_custom_attrs_by_type:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. If @attr_klass is non-NULL, only custom attributes \n * of that type are returned. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_by_type (MonoObject *obj, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tif (attr_klass)\n\t\t\tresult = mono_custom_attrs_construct_by_type (cinfo, attr_klass);\n\t\telse\n\t\t\tresult = mono_custom_attrs_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else {\n\t\tif (mono_loader_get_last_error ())\n\t\t\treturn NULL;\n\t\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, 0);\n\t}\n\n\treturn result;\n}\n\n/*\n * mono_reflection_get_custom_attrs:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs (MonoObject *obj)\n{\n\treturn mono_reflection_get_custom_attrs_by_type (obj, NULL);\n}\n\n/*\n * mono_reflection_get_custom_attrs_data:\n * @obj: a reflection obj handle\n *\n * Returns an array of System.Reflection.CustomAttributeData,\n * which include information about attributes reflected on\n * types loaded using the Reflection Only methods\n */\nMonoArray*\nmono_reflection_get_custom_attrs_data (MonoObject *obj)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tresult = mono_custom_attrs_data_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else\n\t\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, 0);\n\n\treturn result;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_get_underlying_system_type (MonoReflectionType* t)\n{\n        MonoMethod *method_get_underlying_system_type;\n\n        method_get_underlying_system_type = mono_object_get_virtual_method ((MonoObject *) t,\n                                                                            mono_class_get_method_from_name (mono_object_class (t),\n                                                                                                             \"get_UnderlyingSystemType\",\n                                                                                                             0));\n        return (MonoReflectionType *) mono_runtime_invoke (method_get_underlying_system_type, t, NULL, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic gboolean\nis_corlib_type (MonoClass *class)\n{\n\treturn class->image == mono_defaults.corlib;\n}\n\nstatic gboolean\nis_usertype (MonoReflectionType *ref)\n{\n\tMonoClass *class = mono_object_class (ref);\n\treturn class->image != mono_defaults.corlib || strcmp (\"TypeDelegator\", class->name) == 0;\n}\n\n#define check_corlib_type_cached(_class, _namespace, _name) do { \\\n\tstatic MonoClass *cached_class; \\\n\tif (cached_class) \\\n\t\treturn cached_class == _class; \\\n\tif (is_corlib_type (_class) && !strcmp (_name, _class->name) && !strcmp (_namespace, _class->name_space)) { \\\n\t\tcached_class = _class; \\\n\t\treturn TRUE; \\\n\t} \\\n\treturn FALSE; \\\n} while (0) \\\n\nstatic gboolean\nis_sre_array (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ArrayType\");\n}\n\nstatic gboolean\nis_sre_byref (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ByRefType\");\n}\n\nstatic gboolean\nis_sre_pointer (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"PointerType\");\n}\n\nstatic gboolean\nis_sre_generic_instance (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericClass\");\n}\n\nstatic gboolean\nis_sre_method_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodBuilder\");\n}\n\nstatic gboolean\nis_sre_ctor_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorBuilder\");\n}\n\nstatic gboolean\nis_sr_mono_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoMethod\");\n}\n\nstatic gboolean\nis_sr_mono_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_property (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoProperty\");\n}\n\nstatic gboolean\nis_sre_method_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodOnTypeBuilderInst\");\n}\n\nstatic gboolean\nis_sre_ctor_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorOnTypeBuilderInst\");\n}\n\ngboolean\nmono_class_is_reflection_method_or_constructor (MonoClass *class)\n{\n\treturn is_sr_mono_method (class) || is_sr_mono_cmethod (class) || is_sr_mono_generic_method (class) || is_sr_mono_generic_cmethod (class);\n}\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tMonoClass *class;\n\tif (!ref)\n\t\treturn NULL;\n\tif (ref->type)\n\t\treturn ref->type;\n\n\tif (is_usertype (ref)) {\n\t\tref = mono_reflection_type_get_underlying_system_type (ref);\n\t\tg_assert (!is_usertype (ref)); /*FIXME fail better*/\n\t\tif (ref->type)\n\t\t\treturn ref->type;\n\t}\n\n\tclass = mono_object_class (ref);\n\n\tif (is_sre_array (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionArrayType *sre_array = (MonoReflectionArrayType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_array->element_type);\n\t\tg_assert (base);\n\t\tif (sre_array->rank == 0) //single dimentional array\n\t\t\tres = &mono_array_class_get (mono_class_from_mono_type (base), 1)->byval_arg;\n\t\telse\n\t\t\tres = &mono_bounded_array_class_get (mono_class_from_mono_type (base), sre_array->rank, TRUE)->byval_arg;\n\t\tsre_array->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_byref (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_byref = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_byref->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_class_from_mono_type (base)->this_arg;\n\t\tsre_byref->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_pointer (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_pointer = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_pointer->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_ptr_class_get (base)->byval_arg;\n\t\tsre_pointer->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_generic_instance (class)) {\n\t\tMonoType *res, **types;\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)ref;\n\t\tint i, count;\n\n\t\tcount = mono_array_length (gclass->type_arguments);\n\t\ttypes = g_new0 (MonoType*, count);\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tMonoReflectionType *t = mono_array_get (gclass->type_arguments, gpointer, i);\n\t\t\ttypes [i] = mono_reflection_type_get_handle (t);\n\t\t}\n\n\t\tres = mono_reflection_bind_generic_parameters ((MonoReflectionType*)gclass->generic_type, count, types);\n\t\tg_free (types);\n\t\tg_assert (res);\n\t\tgclass->type.type = res;\n\t\treturn res;\n\t}\n\n\tg_error (\"Cannot handle corlib user type %s\", mono_type_full_name (&mono_object_class(ref)->byval_arg));\n\treturn NULL;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_resolve_user_types (MonoReflectionType *type)\n{\n\tif (!type || type->type)\n\t\treturn type;\n\n\tif (is_usertype (type)) {\n\t\ttype = mono_reflection_type_get_underlying_system_type (type);\n\t\tif (is_usertype (type))\n\t\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported22\"));\n\t}\n\n\treturn type;\n}\n\nvoid\nmono_reflection_create_unmanaged_type (MonoReflectionType *type)\n{\n\tmono_reflection_type_get_handle (type);\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nparameters_to_signature (MonoImage *image, MonoArray *parameters) {\n\tMonoMethodSignature *sig;\n\tint count, i;\n\n\tcount = parameters? mono_array_length (parameters): 0;\n\n\tsig = image_g_malloc0 (image, MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * count);\n\tsig->param_count = count;\n\tsig->sentinelpos = -1; /* FIXME */\n\tfor (i = 0; i < count; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (parameters, i);\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nctor_builder_to_signature (MonoImage *image, MonoReflectionCtorBuilder *ctor) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, ctor->parameters);\n\tsig->hasthis = ctor->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = &mono_defaults.void_class->byval_arg;\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nmethod_builder_to_signature (MonoImage *image, MonoReflectionMethodBuilder *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle ((MonoReflectionType*)method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = method->generic_params ? mono_array_length (method->generic_params) : 0;\n\treturn sig;\n}\n\nstatic MonoMethodSignature*\ndynamic_method_to_signature (MonoReflectionDynamicMethod *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (NULL, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle (method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = 0;\n\treturn sig;\n}\n\nstatic void\nget_prop_name_and_type (MonoObject *prop, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (prop);\n\tif (strcmp (klass->name, \"PropertyBuilder\") == 0) {\n\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *)prop;\n\t\t*name = mono_string_to_utf8 (pb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)pb->type);\n\t} else {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty *)prop;\n\t\t*name = g_strdup (p->property->name);\n\t\tif (p->property->get)\n\t\t\t*type = mono_method_signature (p->property->get)->ret;\n\t\telse\n\t\t\t*type = mono_method_signature (p->property->set)->params [mono_method_signature (p->property->set)->param_count - 1];\n\t}\n}\n\nstatic void\nget_field_name_and_type (MonoObject *field, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (field);\n\tif (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)field;\n\t\t*name = mono_string_to_utf8 (fb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t} else {\n\t\tMonoReflectionField *f = (MonoReflectionField *)field;\n\t\t*name = g_strdup (mono_field_get_name (f->field));\n\t\t*type = f->field->type;\n\t}\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/*\n * Encode a value in a custom attribute stream of bytes.\n * The value to encode is either supplied as an object in argument val\n * (valuetypes are boxed), or as a pointer to the data in the\n * argument argval.\n * @type represents the type of the value\n * @buffer is the start of the buffer\n * @p the current position in the buffer\n * @buflen contains the size of the buffer and is used to return the new buffer size\n * if this needs to be realloced.\n * @retbuffer and @retp return the start and the position of the buffer\n */\nstatic void\nencode_cattr_value (MonoAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, MonoObject *arg, char *argval)\n{\n\tMonoTypeEnum simple_type;\n\t\n\tif ((p-buffer) + 10 >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\tif (!argval)\n\t\targval = ((char*)arg + sizeof (MonoObject));\n\tsimple_type = type->type;\nhandle_enum:\n\tswitch (simple_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\t*p++ = *argval;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tswap_with_size (p, argval, 2, 1);\n\t\tp += 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tswap_with_size (p, argval, 4, 1);\n\t\tp += 4;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n#if defined(ARM_FPU_FPA) && G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tp [0] = argval [4];\n\t\tp [1] = argval [5];\n\t\tp [2] = argval [6];\n\t\tp [3] = argval [7];\n\t\tp [4] = argval [0];\n\t\tp [5] = argval [1];\n\t\tp [6] = argval [2];\n\t\tp [7] = argval [3];\n#else\n\t\tswap_with_size (p, argval, 8, 1);\n#endif\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tswap_with_size (p, argval, 8, 1);\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (type->data.klass->enumtype) {\n\t\t\tsimple_type = mono_class_enum_basetype (type->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_warning (\"generic valutype %s not handled in custom attr value decoding\", type->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\tstr = mono_string_to_utf8 ((MonoString*)arg);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\nhandle_type:\n\t\tstr = type_get_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)arg), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tint len, i;\n\t\tMonoClass *eclass, *arg_eclass;\n\n\t\tif (!arg) {\n\t\t\t*p++ = 0xff; *p++ = 0xff; *p++ = 0xff; *p++ = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tlen = mono_array_length ((MonoArray*)arg);\n\t\t*p++ = len & 0xff;\n\t\t*p++ = (len >> 8) & 0xff;\n\t\t*p++ = (len >> 16) & 0xff;\n\t\t*p++ = (len >> 24) & 0xff;\n\t\t*retp = p;\n\t\t*retbuffer = buffer;\n\t\teclass = type->data.klass;\n\t\targ_eclass = mono_object_class (arg)->element_class;\n\n\t\tif (!eclass) {\n\t\t\t/* Happens when we are called from the MONO_TYPE_OBJECT case below */\n\t\t\teclass = mono_defaults.object_class;\n\t\t}\n\t\tif (eclass == mono_defaults.object_class && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (arg_eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &arg_eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else if (eclass->valuetype && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, mono_array_get ((MonoArray*)arg, MonoObject*, i), NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tMonoClass *klass;\n\t\tchar *str;\n\t\tguint32 slen;\n\n\t\t/*\n\t\t * The parameter type is 'object' but the type of the actual\n\t\t * argument is not. So we have to add type information to the blob\n\t\t * too. This is completely undocumented in the spec.\n\t\t */\n\n\t\tif (arg == NULL) {\n\t\t\t*p++ = MONO_TYPE_STRING;\t// It's same hack as MS uses\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tklass = mono_object_class (arg);\n\n\t\tif (mono_object_isinst (arg, mono_defaults.systemtype_class)) {\n\t\t\t*p++ = 0x50;\n\t\t\tgoto handle_type;\n\t\t} else if (klass->enumtype) {\n\t\t\t*p++ = 0x55;\n\t\t} else if (klass == mono_defaults.string_class) {\n\t\t\tsimple_type = MONO_TYPE_STRING;\n\t\t\t*p++ = 0x0E;\n\t\t\tgoto handle_enum;\n\t\t} else if (klass->rank == 1) {\n\t\t\t*p++ = 0x1D;\n\t\t\tif (klass->element_class->byval_arg.type == MONO_TYPE_OBJECT)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\t*p++ = 0x51;\n\t\t\telse\n\t\t\t\t*p++ = klass->element_class->byval_arg.type;\n\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &klass->byval_arg, arg, NULL);\n\t\t\tbreak;\n\t\t} else if (klass->byval_arg.type >= MONO_TYPE_BOOLEAN && klass->byval_arg.type <= MONO_TYPE_R8) {\n\t\t\t*p++ = simple_type = klass->byval_arg.type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"unhandled type in custom attr\");\n\t\t}\n\t\tstr = type_get_qualified_name (mono_class_get_type(klass), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tsimple_type = mono_class_enum_basetype (klass)->type;\n\t\tgoto handle_enum;\n\t}\n\tdefault:\n\t\tg_error (\"type 0x%02x not yet supported in custom attr encoder\", simple_type);\n\t}\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\nstatic void\nencode_field_or_prop_type (MonoType *type, char *p, char **retp)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tint slen = strlen (str);\n\n\t\t*p++ = 0x55;\n\t\t/*\n\t\t * This seems to be optional...\n\t\t * *p++ = 0x80;\n\t\t */\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_OBJECT) {\n\t\t*p++ = 0x51;\n\t} else if (type->type == MONO_TYPE_CLASS) {\n\t\t/* it should be a type: encode_cattr_value () has the check */\n\t\t*p++ = 0x50;\n\t} else {\n\t\tmono_metadata_encode_value (type->type, p, &p);\n\t\tif (type->type == MONO_TYPE_SZARRAY)\n\t\t\t/* See the examples in Partition VI, Annex B */\n\t\t\tencode_field_or_prop_type (&type->data.klass->byval_arg, p, &p);\n\t}\n\n\t*retp = p;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nencode_named_val (MonoReflectionAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, char *name, MonoObject *value)\n{\n\tint len;\n\t/* Preallocate a large enough buffer */\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_SZARRAY && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (&type->data.klass->byval_arg, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else {\n\t\tlen = 0;\n\t}\n\tlen += strlen (name);\n\n\tif ((p-buffer) + 20 + len >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\t*buflen += len;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\n\tencode_field_or_prop_type (type, p, &p);\n\n\tlen = strlen (name);\n\tmono_metadata_encode_value (len, p, &p);\n\tmemcpy (p, name, len);\n\tp += len;\n\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, buflen, type, value, NULL);\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\n/*\n * mono_reflection_get_custom_attrs_blob:\n * @ctor: custom attribute constructor\n * @ctorArgs: arguments o the constructor\n * @properties:\n * @propValues:\n * @fields:\n * @fieldValues:\n * \n * Creates the blob of data that needs to be saved in the metadata and that represents\n * the custom attributed described by @ctor, @ctorArgs etc.\n * Returns: a Byte array representing the blob of data.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tMonoArray *result;\n\tMonoMethodSignature *sig;\n\tMonoObject *arg;\n\tchar *buffer, *p;\n\tguint32 buflen, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t/* sig is freed later so allocate it in the heap */\n\t\tsig = ctor_builder_to_signature (NULL, (MonoReflectionCtorBuilder*)ctor);\n\t} else {\n\t\tsig = mono_method_signature (((MonoReflectionMethod*)ctor)->method);\n\t}\n\n\tg_assert (mono_array_length (ctorArgs) == sig->param_count);\n\tbuflen = 256;\n\tp = buffer = g_malloc (buflen);\n\t/* write the prolog */\n\t*p++ = 1;\n\t*p++ = 0;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\targ = mono_array_get (ctorArgs, MonoObject*, i);\n\t\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, &buflen, sig->params [i], arg, NULL);\n\t}\n\ti = 0;\n\tif (properties)\n\t\ti += mono_array_length (properties);\n\tif (fields)\n\t\ti += mono_array_length (fields);\n\t*p++ = i & 0xff;\n\t*p++ = (i >> 8) & 0xff;\n\tif (properties) {\n\t\tMonoObject *prop;\n\t\tfor (i = 0; i < mono_array_length (properties); ++i) {\n\t\t\tMonoType *ptype;\n\t\t\tchar *pname;\n\n\t\t\tprop = mono_array_get (properties, gpointer, i);\n\t\t\tget_prop_name_and_type (prop, &pname, &ptype);\n\t\t\t*p++ = 0x54; /* PROPERTY signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ptype, pname, (MonoObject*)mono_array_get (propValues, gpointer, i));\n\t\t\tg_free (pname);\n\t\t}\n\t}\n\n\tif (fields) {\n\t\tMonoObject *field;\n\t\tfor (i = 0; i < mono_array_length (fields); ++i) {\n\t\t\tMonoType *ftype;\n\t\t\tchar *fname;\n\n\t\t\tfield = mono_array_get (fields, gpointer, i);\n\t\t\tget_field_name_and_type (field, &fname, &ftype);\n\t\t\t*p++ = 0x53; /* FIELD signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ftype, fname, (MonoObject*)mono_array_get (fieldValues, gpointer, i));\n\t\t\tg_free (fname);\n\t\t}\n\t}\n\n\tg_assert (p - buffer <= buflen);\n\tbuflen = p - buffer;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tp = mono_array_addr (result, char, 0);\n\tmemcpy (p, buffer, buflen);\n\tg_free (buffer);\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\"))\n\t\tg_free (sig);\n\treturn result;\n}\n\n/*\n * mono_reflection_setup_internal_class:\n * @tb: a TypeBuilder object\n *\n * Creates a MonoClass that represents the TypeBuilder.\n * This is a trick that lets us simplify a lot of reflection code\n * (and will allow us to support Build and Run assemblies easier).\n */\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass, *parent;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tRESOLVE_TYPE (tb->parent);\n\n\tmono_loader_lock ();\n\n\tif (tb->parent) {\n\t\t/* check so we can compile corlib correctly */\n\t\tif (strcmp (mono_object_class (tb->parent)->name, \"TypeBuilder\") == 0) {\n\t\t\t/* mono_class_setup_mono_type () guaranteess type->data.klass is valid */\n\t\t\tparent = mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent)->data.klass;\n\t\t} else {\n\t\t\tparent = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t\t}\n\t} else {\n\t\tparent = NULL;\n\t}\n\t\n\t/* the type has already being created: it means we just have to change the parent */\n\tif (tb->type.type) {\n\t\tklass = mono_class_from_mono_type (tb->type.type);\n\t\tklass->parent = NULL;\n\t\t/* fool mono_class_setup_parent */\n\t\tklass->supertypes = NULL;\n\t\tmono_class_setup_parent (klass, parent);\n\t\tmono_class_setup_mono_type (klass);\n\t\tmono_loader_unlock ();\n\t\treturn;\n\t}\n\n\tklass = mono_image_alloc0 (&tb->module->dynamic_image->image, sizeof (MonoClass));\n\n\tklass->image = &tb->module->dynamic_image->image;\n\n\tklass->inited = 1; /* we lie to the runtime */\n\tklass->name = mono_string_to_utf8_image (klass->image, tb->name, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->name_space = mono_string_to_utf8_image (klass->image, tb->nspace, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->type_token = MONO_TOKEN_TYPE_DEF | tb->table_idx;\n\tklass->flags = tb->attrs;\n\t\n\tmono_profiler_class_event (klass, MONO_PROFILE_START_LOAD);\n\n\tklass->element_class = klass;\n\n\tMOVING_GC_REGISTER (&klass->reflection_info);\n\tklass->reflection_info = tb;\n\n\t/* Put into cache so mono_class_get () will find it */\n\tmono_image_add_to_name_cache (klass->image, klass->name_space, klass->name, tb->table_idx);\n\n\tmono_g_hash_table_insert (tb->module->dynamic_image->tokens,\n\t\tGUINT_TO_POINTER (MONO_TOKEN_TYPE_DEF | tb->table_idx), tb);\n\n\tif (parent != NULL) {\n\t\tmono_class_setup_parent (klass, parent);\n\t} else if (strcmp (klass->name, \"Object\") == 0 && strcmp (klass->name_space, \"System\") == 0) {\n\t\tconst char *old_n = klass->name;\n\t\t/* trick to get relative numbering right when compiling corlib */\n\t\tklass->name = \"BuildingObject\";\n\t\tmono_class_setup_parent (klass, mono_defaults.object_class);\n\t\tklass->name = old_n;\n\t}\n\n\tif ((!strcmp (klass->name, \"ValueType\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Object\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Enum\") && !strcmp (klass->name_space, \"System\"))) {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->size_inited = 1;\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\n\tmono_class_setup_mono_type (klass);\n\n\tmono_class_setup_supertypes (klass);\n\n\t/*\n\t * FIXME: handle interfaces.\n\t */\n\n\ttb->type.type = &klass->byval_arg;\n\n\tif (tb->nesting_type) {\n\t\tg_assert (tb->nesting_type->type);\n\t\tklass->nested_in = mono_class_from_mono_type (mono_reflection_type_get_handle (tb->nesting_type));\n\t}\n\n\t/*g_print (\"setup %s as %s (%p)\\n\", klass->name, ((MonoObject*)tb)->vtable->klass->name, tb);*/\n\n\tmono_profiler_class_loaded (klass, MONO_PROFILE_OK);\n\t\n\tmono_loader_unlock ();\n\treturn;\n\nfailure:\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n}\n\n/*\n * mono_reflection_setup_generic_class:\n * @tb: a TypeBuilder object\n *\n * Setup the generic class before adding the first generic parameter.\n */\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n}\n\n/*\n * mono_reflection_create_generic_class:\n * @tb: a TypeBuilder object\n *\n * Creates the generic class after all generic parameters have been added.\n */\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tcount = tb->generic_params ? mono_array_length (tb->generic_params) : 0;\n\n\tif (klass->generic_container || (count == 0))\n\t\treturn;\n\n\tg_assert (tb->generic_container && (tb->generic_container->owner.klass == klass));\n\n\tklass->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\n\tklass->generic_container->owner.klass = klass;\n\tklass->generic_container->type_argc = count;\n\tklass->generic_container->type_params = mono_image_alloc0 (klass->image, sizeof (MonoGenericParamFull) * count);\n\n\tklass->is_generic = 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam = mono_array_get (tb->generic_params, gpointer, i);\n\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gparam)->data.generic_param;\n\t\tklass->generic_container->type_params [i] = *param;\n\t\t/*Make sure we are a diferent type instance */\n\t\tklass->generic_container->type_params [i].param.owner = klass->generic_container;\n\t\tklass->generic_container->type_params [i].info.pklass = NULL;\n\t\tklass->generic_container->type_params [i].info.flags = gparam->attrs;\n\n\t\tg_assert (klass->generic_container->type_params [i].param.owner);\n\t}\n\n\tklass->generic_container->context.class_inst = mono_get_shared_generic_inst (klass->generic_container);\n}\n\n/*\n * mono_reflection_create_internal_class:\n * @tb: a TypeBuilder object\n *\n * Actually create the MonoClass that is associated with the TypeBuilder.\n */\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tmono_loader_lock ();\n\tif (klass->enumtype && mono_class_enum_basetype (klass) == NULL) {\n\t\tMonoReflectionFieldBuilder *fb;\n\t\tMonoClass *ec;\n\t\tMonoType *enum_basetype;\n\n\t\tg_assert (tb->fields != NULL);\n\t\tg_assert (mono_array_length (tb->fields) >= 1);\n\n\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, 0);\n\n\t\tif (!mono_type_is_valid_enum_basetype (mono_reflection_type_get_handle ((MonoReflectionType*)fb->type))) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn;\n\t\t}\n\n\t\tenum_basetype = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\t\tif (!klass->element_class)\n\t\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\n\t\t/*\n\t\t * get the element_class from the current corlib.\n\t\t */\n\t\tec = default_class_from_mono_type (enum_basetype);\n\t\tklass->instance_size = ec->instance_size;\n\t\tklass->size_inited = 1;\n\t\t/* \n\t\t * this is almost safe to do with enums and it's needed to be able\n\t\t * to create objects of the enum type (for use in SetConstant).\n\t\t */\n\t\t/* FIXME: Does this mean enums can't have method overrides ? */\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\tmono_loader_unlock ();\n}\n\nstatic MonoMarshalSpec*\nmono_marshal_spec_from_builder (MonoImage *image, MonoAssembly *assembly,\n\t\t\t\t\t\t\t\tMonoReflectionMarshal *minfo)\n{\n\tMonoMarshalSpec *res;\n\n\tres = image_g_new0 (image, MonoMarshalSpec, 1);\n\tres->native = minfo->type;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tres->data.array_data.elem_type = minfo->eltype;\n\t\tif (minfo->has_size) {\n\t\t\tres->data.array_data.param_num = minfo->param_num;\n\t\t\tres->data.array_data.num_elem = minfo->count;\n\t\t\tres->data.array_data.elem_mult = minfo->param_num == -1 ? 0 : 1;\n\t\t}\n\t\telse {\n\t\t\tres->data.array_data.param_num = -1;\n\t\t\tres->data.array_data.num_elem = -1;\n\t\t\tres->data.array_data.elem_mult = -1;\n\t\t}\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tres->data.array_data.num_elem = minfo->count;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->marshaltyperef)\n\t\t\tres->data.custom_data.custom_name =\n\t\t\t\ttype_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\tif (minfo->mcookie)\n\t\t\tres->data.custom_data.cookie = mono_string_to_utf8 (minfo->mcookie);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nMonoReflectionMarshal*\nmono_reflection_marshal_from_marshal_spec (MonoDomain *domain, MonoClass *klass,\n\t\t\t\t\t\t\t\t\t\t   MonoMarshalSpec *spec)\n{\n\tstatic MonoClass *System_Reflection_Emit_UnmanagedMarshalClass;\n\tMonoReflectionMarshal *minfo;\n\tMonoType *mtype;\n\n\tif (!System_Reflection_Emit_UnmanagedMarshalClass) {\n\t\tSystem_Reflection_Emit_UnmanagedMarshalClass = mono_class_from_name (\n\t\t   mono_defaults.corlib, \"System.Reflection.Emit\", \"UnmanagedMarshal\");\n\t\tg_assert (System_Reflection_Emit_UnmanagedMarshalClass);\n\t}\n\n\tminfo = (MonoReflectionMarshal*)mono_object_new (domain, System_Reflection_Emit_UnmanagedMarshalClass);\n\tminfo->type = spec->native;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tminfo->eltype = spec->data.array_data.elem_type;\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tminfo->param_num = spec->data.array_data.param_num;\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (spec->data.custom_data.custom_name) {\n\t\t\tmtype = mono_reflection_type_from_name (spec->data.custom_data.custom_name, klass->image);\n\t\t\tif (mtype)\n\t\t\t\tMONO_OBJECT_SETREF (minfo, marshaltyperef, mono_type_get_object (domain, mtype));\n\n\t\t\tMONO_OBJECT_SETREF (minfo, marshaltype, mono_string_new (domain, spec->data.custom_data.custom_name));\n\t\t}\n\t\tif (spec->data.custom_data.cookie)\n\t\t\tMONO_OBJECT_SETREF (minfo, mcookie, mono_string_new (domain, spec->data.custom_data.cookie));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn minfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoMethod*\nreflection_methodbuilder_to_mono_method (MonoClass *klass,\n\t\t\t\t\t ReflectionMethodBuilder *rmb,\n\t\t\t\t\t MonoMethodSignature *sig)\n{\n\tMonoError error;\n\tMonoMethod *m;\n\tMonoMethodNormal *pm;\n\tMonoMarshalSpec **specs;\n\tMonoReflectionMethodAux *method_aux;\n\tMonoImage *image;\n\tgboolean dynamic;\n\tint i;\n\n\tmono_error_init (&error);\n\t/*\n\t * Methods created using a MethodBuilder should have their memory allocated\n\t * inside the image mempool, while dynamic methods should have their memory\n\t * malloc'd.\n\t */\n\tdynamic = rmb->refs != NULL;\n\timage = dynamic ? NULL : klass->image;\n\n\tif (!dynamic)\n\t\tg_assert (!klass->generic_class);\n\n\tmono_loader_lock ();\n\n\tif ((rmb->attrs & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(rmb->iattrs & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodPInvoke, 1);\n\telse if (rmb->refs)\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodWrapper, 1);\n\telse\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodNormal, 1);\n\n\tpm = (MonoMethodNormal*)m;\n\n\tm->dynamic = dynamic;\n\tm->slot = -1;\n\tm->flags = rmb->attrs;\n\tm->iflags = rmb->iattrs;\n\tm->name = mono_string_to_utf8_image (image, rmb->name, &error);\n\tg_assert (mono_error_ok (&error));\n\tm->klass = klass;\n\tm->signature = sig;\n\tm->skip_visibility = rmb->skip_visibility;\n\tif (rmb->table_idx)\n\t\tm->token = MONO_TOKEN_METHOD_DEF | (*rmb->table_idx);\n\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (klass == mono_defaults.string_class && !strcmp (m->name, \".ctor\"))\n\t\t\tm->string_ctor = 1;\n\n\t\tm->signature->pinvoke = 1;\n\t} else if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tm->signature->pinvoke = 1;\n\n\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\n\t\tmethod_aux->dllentry = rmb->dllentry ? mono_string_to_utf8_image (image, rmb->dllentry, &error) : image_strdup (image, m->name);\n\t\tg_assert (mono_error_ok (&error));\n\t\tmethod_aux->dll = mono_string_to_utf8_image (image, rmb->dll, &error);\n\t\tg_assert (mono_error_ok (&error));\n\t\t\n\t\t((MonoMethodPInvoke*)m)->piflags = (rmb->native_cc << 8) | (rmb->charset ? (rmb->charset - 1) * 2 : 0) | rmb->extra_flags;\n\n\t\tif (klass->image->dynamic)\n\t\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\t\tmono_loader_unlock ();\n\n\t\treturn m;\n\t} else if (!(m->flags & METHOD_ATTRIBUTE_ABSTRACT) &&\n\t\t\t   !(m->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME)) {\n\t\tMonoMethodHeader *header;\n\t\tguint32 code_size;\n\t\tgint32 max_stack, i;\n\t\tgint32 num_locals = 0;\n\t\tgint32 num_clauses = 0;\n\t\tguint8 *code;\n\n\t\tif (rmb->ilgen) {\n\t\t\tcode = mono_array_addr (rmb->ilgen->code, guint8, 0);\n\t\t\tcode_size = rmb->ilgen->code_len;\n\t\t\tmax_stack = rmb->ilgen->max_stack;\n\t\t\tnum_locals = rmb->ilgen->locals ? mono_array_length (rmb->ilgen->locals) : 0;\n\t\t\tif (rmb->ilgen->ex_handlers)\n\t\t\t\tnum_clauses = method_count_clauses (rmb->ilgen);\n\t\t} else {\n\t\t\tif (rmb->code) {\n\t\t\t\tcode = mono_array_addr (rmb->code, guint8, 0);\n\t\t\t\tcode_size = mono_array_length (rmb->code);\n\t\t\t\t/* we probably need to run a verifier on the code... */\n\t\t\t\tmax_stack = 8; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode = NULL;\n\t\t\t\tcode_size = 0;\n\t\t\t\tmax_stack = 8;\n\t\t\t}\n\t\t}\n\n\t\theader = image_g_malloc0 (image, MONO_SIZEOF_METHOD_HEADER + num_locals * sizeof (MonoType*));\n\t\theader->code_size = code_size;\n\t\theader->code = image_g_malloc (image, code_size);\n\t\tmemcpy ((char*)header->code, code, code_size);\n\t\theader->max_stack = max_stack;\n\t\theader->init_locals = rmb->init_locals;\n\t\theader->num_locals = num_locals;\n\n\t\tfor (i = 0; i < num_locals; ++i) {\n\t\t\tMonoReflectionLocalBuilder *lb = \n\t\t\t\tmono_array_get (rmb->ilgen->locals, MonoReflectionLocalBuilder*, i);\n\n\t\t\theader->locals [i] = image_g_new0 (image, MonoType, 1);\n\t\t\tmemcpy (header->locals [i], mono_reflection_type_get_handle ((MonoReflectionType*)lb->type), MONO_SIZEOF_TYPE);\n\t\t}\n\n\t\theader->num_clauses = num_clauses;\n\t\tif (num_clauses) {\n\t\t\theader->clauses = method_encode_clauses (image, (MonoDynamicImage*)klass->image,\n\t\t\t\t rmb->ilgen, num_clauses);\n\t\t}\n\n\t\tpm->header = header;\n\t}\n\n\tif (rmb->generic_params) {\n\t\tint count = mono_array_length (rmb->generic_params);\n\t\tMonoGenericContainer *container;\n\n\t\tcontainer = rmb->generic_container;\n\t\tif (container) {\n\t\t\tm->is_generic = TRUE;\n\t\t\tmono_method_set_generic_container (m, container);\n\t\t}\n\t\tcontainer->type_argc = count;\n\t\tcontainer->type_params = image_g_new0 (image, MonoGenericParamFull, count);\n\t\tcontainer->owner.method = m;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tMonoReflectionGenericParam *gp =\n\t\t\t\tmono_array_get (rmb->generic_params, MonoReflectionGenericParam*, i);\n\t\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gp)->data.generic_param;\n\t\t\tcontainer->type_params [i] = *param;\n\t\t}\n\n\t\tif (klass->generic_container) {\n\t\t\tcontainer->parent = klass->generic_container;\n\t\t\tcontainer->context.class_inst = klass->generic_container->context.class_inst;\n\t\t}\n\t\tcontainer->context.method_inst = mono_get_shared_generic_inst (container);\n\t}\n\n\tif (rmb->refs) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)m;\n\t\tint i;\n\t\tvoid **data;\n\n\t\tm->wrapper_type = MONO_WRAPPER_DYNAMIC_METHOD;\n\n\t\tmw->method_data = data = image_g_new (image, gpointer, rmb->nrefs + 1);\n\t\tdata [0] = GUINT_TO_POINTER (rmb->nrefs);\n\t\tfor (i = 0; i < rmb->nrefs; ++i)\n\t\t\tdata [i + 1] = rmb->refs [i];\n\t}\n\n\tmethod_aux = NULL;\n\n\t/* Parameter info */\n\tif (rmb->pinfo) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_names = image_g_new0 (image, char *, mono_method_signature (m)->param_count + 1);\n\t\tfor (i = 0; i <= m->signature->param_count; ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif ((i > 0) && (pb->attrs)) {\n\t\t\t\t\t/* Make a copy since it might point to a shared type structure */\n\t\t\t\t\tm->signature->params [i - 1] = mono_metadata_type_dup (klass->image, m->signature->params [i - 1]);\n\t\t\t\t\tm->signature->params [i - 1]->attrs = pb->attrs;\n\t\t\t\t}\n\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tMonoDynamicImage *assembly;\n\t\t\t\t\tguint32 idx, def_type, len;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tconst char *p2;\n\n\t\t\t\t\tif (!method_aux->param_defaults) {\n\t\t\t\t\t\tmethod_aux->param_defaults = image_g_new0 (image, guint8*, m->signature->param_count + 1);\n\t\t\t\t\t\tmethod_aux->param_default_types = image_g_new0 (image, guint32, m->signature->param_count + 1);\n\t\t\t\t\t}\n\t\t\t\t\tassembly = (MonoDynamicImage*)klass->image;\n\t\t\t\t\tidx = encode_constant (assembly, pb->def_value, &def_type);\n\t\t\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\t\t\tp = assembly->blob.data + idx;\n\t\t\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\t\t\tlen += p2 - p;\n\t\t\t\t\tmethod_aux->param_defaults [i] = image_g_malloc (image, len);\n\t\t\t\t\tmethod_aux->param_default_types [i] = def_type;\n\t\t\t\t\tmemcpy ((gpointer)method_aux->param_defaults [i], p, len);\n\t\t\t\t}\n\n\t\t\t\tif (pb->name) {\n\t\t\t\t\tmethod_aux->param_names [i] = mono_string_to_utf8_image (image, pb->name, &error);\n\t\t\t\t\tg_assert (mono_error_ok (&error));\n\t\t\t\t}\n\t\t\t\tif (pb->cattrs) {\n\t\t\t\t\tif (!method_aux->param_cattr)\n\t\t\t\t\t\tmethod_aux->param_cattr = image_g_new0 (image, MonoCustomAttrInfo*, m->signature->param_count + 1);\n\t\t\t\t\tmethod_aux->param_cattr [i] = mono_custom_attrs_from_builders (image, klass->image, pb->cattrs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Parameter marshalling */\n\tspecs = NULL;\n\tif (rmb->pinfo)\t\t\n\t\tfor (i = 0; i < mono_array_length (rmb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tif (specs == NULL)\n\t\t\t\t\t\tspecs = image_g_new0 (image, MonoMarshalSpec*, sig->param_count + 1);\n\t\t\t\t\tspecs [pb->position] = \n\t\t\t\t\t\tmono_marshal_spec_from_builder (image, klass->image->assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (specs != NULL) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_marshall = specs;\n\t}\n\n\tif (klass->image->dynamic && method_aux)\n\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\tmono_loader_unlock ();\n\n\treturn m;\n}\t\n\nstatic MonoMethod*\nctorbuilder_to_mono_method (MonoClass *klass, MonoReflectionCtorBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = ctor_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\n\treturn mb->mhandle;\n}\n\nstatic MonoMethod*\nmethodbuilder_to_mono_method (MonoClass *klass, MonoReflectionMethodBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = method_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\treturn mb->mhandle;\n}\n\nstatic MonoClassField*\nfieldbuilder_to_mono_class_field (MonoClass *klass, MonoReflectionFieldBuilder* fb)\n{\n\tMonoClassField *field;\n\tMonoType *custom;\n\n\tfield = g_new0 (MonoClassField, 1);\n\n\tfield->name = mono_string_to_utf8 (fb->name);\n\tif (fb->attrs || fb->modreq || fb->modopt) {\n\t\tfield->type = mono_metadata_type_dup (NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\tfield->type->attrs = fb->attrs;\n\n\t\tg_assert (klass->image->dynamic);\n\t\tcustom = add_custom_modifiers ((MonoDynamicImage*)klass->image, field->type, fb->modreq, fb->modopt);\n\t\tg_free (field->type);\n\t\tfield->type = custom;\n\t} else {\n\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t}\n\tif (fb->offset != -1)\n\t\tfield->offset = fb->offset;\n\tfield->parent = klass;\n\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t// FIXME: Can't store fb->def_value/RVA, is it needed for field_on_insts ?\n\n\treturn field;\n}\n#endif\n\nMonoType*\nmono_reflection_bind_generic_parameters (MonoReflectionType *type, int type_argc, MonoType **types)\n{\n\tMonoClass *klass;\n\tMonoReflectionTypeBuilder *tb = NULL;\n\tgboolean is_dynamic = FALSE;\n\tMonoDomain *domain;\n\tMonoClass *geninst;\n\n\tmono_loader_lock ();\n\n\tdomain = mono_object_domain (type);\n\n\tif (!strcmp (((MonoObject *) type)->vtable->klass->name, \"TypeBuilder\")) {\n\t\ttb = (MonoReflectionTypeBuilder *) type;\n\n\t\tis_dynamic = TRUE;\n\t} else if (!strcmp (((MonoObject *) type)->vtable->klass->name, \"MonoGenericClass\")) {\n\t\tMonoReflectionGenericClass *rgi = (MonoReflectionGenericClass *) type;\n\n\t\ttb = rgi->generic_type;\n\t\tis_dynamic = TRUE;\n\t}\n\n\t/* FIXME: fix the CreateGenericParameters protocol to avoid the two stage setup of TypeBuilders */\n\tif (tb && tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (type));\n\tif (!klass->generic_container) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (klass->wastypebuilder) {\n\t\ttb = (MonoReflectionTypeBuilder *) klass->reflection_info;\n\n\t\tis_dynamic = TRUE;\n\t}\n\n\tmono_loader_unlock ();\n\n\tgeninst = mono_class_bind_generic_parameters (klass, type_argc, types, is_dynamic);\n\n\treturn &geninst->byval_arg;\n}\n\nMonoClass*\nmono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic)\n{\n\tMonoGenericClass *gclass;\n\tMonoGenericInst *inst;\n\n\tg_assert (klass->generic_container);\n\n\tinst = mono_metadata_get_generic_inst (type_argc, types);\n\tgclass = mono_metadata_lookup_generic_class (klass, inst, is_dynamic);\n\n\treturn mono_generic_class_get_class (gclass);\n}\n\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic MonoMethod *\ninflate_mono_method (MonoClass *klass, MonoMethod *method, MonoObject *obj)\n{\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext *context;\n\tint i;\n\n\t/*\n\t * With generic code sharing the klass might not be inflated.\n\t * This can happen because classes inflated with their own\n\t * type arguments are \"normalized\" to the uninflated class.\n\t */\n\tif (!klass->generic_class)\n\t\treturn method;\n\n\tcontext = mono_class_get_context (klass);\n\n\tif (klass->method.count) {\n\t\t/* Find the already created inflated method */\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tg_assert (klass->methods [i]->is_inflated);\n\t\t\tif (((MonoMethodInflated*)klass->methods [i])->declaring == method)\n\t\t\t\tbreak;\n\t\t}\n\t\tg_assert (i < klass->method.count);\n\t\timethod = (MonoMethodInflated*)klass->methods [i];\n\t} else {\n\t\timethod = (MonoMethodInflated *) mono_class_inflate_generic_method_full (method, klass, context);\n\t}\n\n\tif (method->is_generic && method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, obj);\n\t\tmono_loader_unlock ();\n\t}\n\treturn (MonoMethod *) imethod;\n}\n\nstatic MonoMethod *\ninflate_method (MonoReflectionGenericClass *type, MonoObject *obj)\n{\n\tMonoMethod *method;\n\tMonoClass *gklass;\n\n\tgklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type->generic_type));\n\n\tif (!strcmp (obj->vtable->klass->name, \"MethodBuilder\"))\n\t\tif (((MonoReflectionMethodBuilder*)obj)->mhandle)\n\t\t\tmethod = ((MonoReflectionMethodBuilder*)obj)->mhandle;\n\t\telse\n\t\t\tmethod = methodbuilder_to_mono_method (gklass, (MonoReflectionMethodBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"ConstructorBuilder\"))\n\t\tmethod = ctorbuilder_to_mono_method (gklass, (MonoReflectionCtorBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"MonoMethod\") || !strcmp (obj->vtable->klass->name, \"MonoCMethod\"))\n\t\tmethod = ((MonoReflectionMethod *) obj)->method;\n\telse {\n\t\tmethod = NULL; /* prevent compiler warning */\n\t\tg_error (\"can't handle type %s\", obj->vtable->klass->name);\n\t}\n\n\treturn inflate_mono_method (mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type)), method, obj);\n}\n\n/*TODO avoid saving custom attrs for generic classes as it's enough to have them on the generic type definition.*/\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoClass *klass, *gklass;\n\tMonoType *gtype;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tgtype = mono_reflection_type_get_handle ((MonoReflectionType*)type);\n\tklass = mono_class_from_mono_type (gtype);\n\tg_assert (gtype->type == MONO_TYPE_GENERICINST);\n\tgclass = gtype->data.generic_class;\n\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tif (dgclass->initialized)\n\t\treturn;\n\n\tgklass = gclass->container_class;\n\tmono_class_init (gklass);\n\n\tdgclass->count_methods = methods ? mono_array_length (methods) : 0;\n\tdgclass->count_ctors = ctors ? mono_array_length (ctors) : 0;\n\tdgclass->count_fields = fields ? mono_array_length (fields) : 0;\n\tdgclass->count_properties = properties ? mono_array_length (properties) : 0;\n\tdgclass->count_events = events ? mono_array_length (events) : 0;\n\n\tdgclass->methods = g_new0 (MonoMethod *, dgclass->count_methods);\n\tdgclass->ctors = g_new0 (MonoMethod *, dgclass->count_ctors);\n\tdgclass->fields = g_new0 (MonoClassField, dgclass->count_fields);\n\tdgclass->properties = g_new0 (MonoProperty, dgclass->count_properties);\n\tdgclass->events = g_new0 (MonoEvent, dgclass->count_events);\n\tdgclass->field_objects = g_new0 (MonoObject*, dgclass->count_fields);\n\tdgclass->field_generic_types = g_new0 (MonoType*, dgclass->count_fields);\n\n\tfor (i = 0; i < dgclass->count_methods; i++) {\n\t\tMonoObject *obj = mono_array_get (methods, gpointer, i);\n\n\t\tdgclass->methods [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_ctors; i++) {\n\t\tMonoObject *obj = mono_array_get (ctors, gpointer, i);\n\n\t\tdgclass->ctors [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_fields; i++) {\n\t\tMonoObject *obj = mono_array_get (fields, gpointer, i);\n\t\tMonoClassField *field, *inflated_field = NULL;\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"FieldBuilder\"))\n\t\t\tinflated_field = field = fieldbuilder_to_mono_class_field (klass, (MonoReflectionFieldBuilder *) obj);\n\t\telse if (!strcmp (obj->vtable->klass->name, \"MonoField\"))\n\t\t\tfield = ((MonoReflectionField *) obj)->field;\n\t\telse {\n\t\t\tfield = NULL; /* prevent compiler warning */\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tdgclass->fields [i] = *field;\n\t\tdgclass->fields [i].parent = klass;\n\t\tdgclass->fields [i].type = mono_class_inflate_generic_type (\n\t\t\tfield->type, mono_generic_class_get_context ((MonoGenericClass *) dgclass));\n\t\tdgclass->field_generic_types [i] = field->type;\n\t\tMOVING_GC_REGISTER (&dgclass->field_objects [i]);\n\t\tdgclass->field_objects [i] = obj;\n\n\t\tif (inflated_field) {\n\t\t\tg_free (inflated_field);\n\t\t} else {\n\t\t\tdgclass->fields [i].name = g_strdup (dgclass->fields [i].name);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dgclass->count_properties; i++) {\n\t\tMonoObject *obj = mono_array_get (properties, gpointer, i);\n\t\tMonoProperty *property = &dgclass->properties [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"PropertyBuilder\")) {\n\t\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *) obj;\n\n\t\t\tproperty->parent = klass;\n\t\t\tproperty->attrs = pb->attrs;\n\t\t\tproperty->name = mono_string_to_utf8 (pb->name);\n\t\t\tif (pb->get_method)\n\t\t\t\tproperty->get = inflate_method (type, (MonoObject *) pb->get_method);\n\t\t\tif (pb->set_method)\n\t\t\t\tproperty->set = inflate_method (type, (MonoObject *) pb->set_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoProperty\")) {\n\t\t\t*property = *((MonoReflectionProperty *) obj)->property;\n\t\t\tproperty->name = g_strdup (property->name);\n\n\t\t\tif (property->get)\n\t\t\t\tproperty->get = inflate_mono_method (klass, property->get, NULL);\n\t\t\tif (property->set)\n\t\t\t\tproperty->set = inflate_mono_method (klass, property->set, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tfor (i = 0; i < dgclass->count_events; i++) {\n\t\tMonoObject *obj = mono_array_get (events, gpointer, i);\n\t\tMonoEvent *event = &dgclass->events [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"EventBuilder\")) {\n\t\t\tMonoReflectionEventBuilder *eb = (MonoReflectionEventBuilder *) obj;\n\n\t\t\tevent->parent = klass;\n\t\t\tevent->attrs = eb->attrs;\n\t\t\tevent->name = mono_string_to_utf8 (eb->name);\n\t\t\tif (eb->add_method)\n\t\t\t\tevent->add = inflate_method (type, (MonoObject *) eb->add_method);\n\t\t\tif (eb->remove_method)\n\t\t\t\tevent->remove = inflate_method (type, (MonoObject *) eb->remove_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoEvent\")) {\n\t\t\t*event = *((MonoReflectionMonoEvent *) obj)->event;\n\t\t\tevent->name = g_strdup (event->name);\n\n\t\t\tif (event->add)\n\t\t\t\tevent->add = inflate_mono_method (klass, event->add, NULL);\n\t\t\tif (event->remove)\n\t\t\t\tevent->remove = inflate_mono_method (klass, event->remove, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tdgclass->initialized = TRUE;\n}\n\nstatic void\nensure_generic_class_runtime_vtable (MonoClass *klass)\n{\n\tMonoClass *gklass = klass->generic_class->container_class;\n\tint i;\n\n\tif (klass->wastypebuilder)\n\t\treturn;\n\n\tensure_runtime_vtable (gklass);\n\n\tklass->method.count = gklass->method.count;\n\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * (klass->method.count + 1));\n\n\tfor (i = 0; i < klass->method.count; i++) {\n\t\tklass->methods [i] = mono_class_inflate_generic_method_full (\n\t\t\tgklass->methods [i], klass, mono_class_get_context (klass));\n\t}\n\n\tklass->interface_count = gklass->interface_count;\n\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\tMonoType *iface_type = mono_class_inflate_generic_type (&gklass->interfaces [i]->byval_arg, mono_class_get_context (klass));\n\t\tklass->interfaces [i] = mono_class_from_mono_type (iface_type);\n\t\tmono_metadata_free_type (iface_type);\n\n\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t}\n\tklass->interfaces_inited = 1;\n\n\t/*We can only finish with this klass once it's parent has as well*/\n\tif (gklass->wastypebuilder)\n\t\tklass->wastypebuilder = TRUE;\n\treturn;\n}\n\nstatic void\nensure_runtime_vtable (MonoClass *klass)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tint i, num, j;\n\n\tif (!klass->image->dynamic || (!tb && !klass->generic_class) || klass->wastypebuilder)\n\t\treturn;\n\tif (klass->parent)\n\t\tensure_runtime_vtable (klass->parent);\n\n\tif (tb) {\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tnum += tb->num_methods;\n\t\tklass->method.count = num;\n\t\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * num);\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [i] = ctorbuilder_to_mono_method (klass, mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i));\n\t\tnum = tb->num_methods;\n\t\tj = i;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [j++] = methodbuilder_to_mono_method (klass, mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i));\n\t\n\t\tif (tb->interfaces) {\n\t\t\tklass->interface_count = mono_array_length (tb->interfaces);\n\t\t\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\t\t\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\t\t\tMonoType *iface = mono_type_array_get_and_resolve (tb->interfaces, i);\n\t\t\t\tklass->interfaces [i] = mono_class_from_mono_type (iface);\n\t\t\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t\t\t}\n\t\t\tklass->interfaces_inited = 1;\n\t\t}\n\t} else if (klass->generic_class){\n\t\tensure_generic_class_runtime_vtable (klass);\n\t}\n\n\tif (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tfor (i = 0; i < klass->method.count; ++i)\n\t\t\tklass->methods [i]->slot = i;\n\t\t\n\t\tmono_class_setup_interface_offsets (klass);\n\t\tmono_class_setup_interface_id (klass);\n\t}\n\n\t/*\n\t * The generic vtable is needed even if image->run is not set since some\n\t * runtime code like ves_icall_Type_GetMethodsByName depends on \n\t * method->slot being defined.\n\t */\n\n\t/* \n\t * tb->methods could not be freed since it is used for determining \n\t * overrides during dynamic vtable construction.\n\t */\n}\n\nstatic MonoMethod*\nmono_reflection_method_get_handle (MonoObject *method)\n{\n\tMonoClass *class = mono_object_class (method);\n\tif (is_sr_mono_method (class) || is_sr_mono_generic_method (class)) {\n\t\tMonoReflectionMethod *sr_method = (MonoReflectionMethod*)method;\n\t\treturn sr_method->method;\n\t}\n\tif (is_sre_method_builder (class)) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)method;\n\t\treturn mb->mhandle;\n\t}\n\tif (is_sre_method_on_tb_inst (class)) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)method;\n\t\tMonoMethod *result;\n\t\t/*FIXME move this to a proper method and unify with resolve_object*/\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tMonoMethod *mono_method;\n\n\t\t\tif (is_sre_method_builder (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethodBuilder *)m->mb)->mhandle;\n \t\t\telse if (is_sr_mono_method (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethod *)m->mb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"resolve_object:: can't handle a MTBI with base_method of type %s\", mono_type_get_full_name (mono_object_class (m->mb)));\n\n\t\t\tresult = inflate_mono_method (inflated_klass, mono_method, (MonoObject*)m->mb);\n\t\t}\n\t\treturn result;\n\t}\n\n\tg_error (\"Can't handle methods of type %s:%s\", class->name_space, class->name);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\tMonoReflectionTypeBuilder *tb;\n\tint i, onum;\n\n\t*overrides = NULL;\n\t*num_overrides = 0;\n\n\tg_assert (klass->image->dynamic);\n\n\tif (!klass->reflection_info)\n\t\treturn;\n\n\tg_assert (strcmp (((MonoObject*)klass->reflection_info)->vtable->klass->name, \"TypeBuilder\") == 0);\n\n\ttb = (MonoReflectionTypeBuilder*)klass->reflection_info;\n\n\tonum = 0;\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method)\n\t\t\t\tonum ++;\n\t\t}\n\t}\n\n\tif (onum) {\n\t\t*overrides = g_new0 (MonoMethod*, onum * 2);\n\n\t\tonum = 0;\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method) {\n\t\t\t\t(*overrides) [onum * 2] = mono_reflection_method_get_handle ((MonoObject *)mb->override_method);\n\t\t\t\t(*overrides) [onum * 2 + 1] = mb->mhandle;\n\n\t\t\t\tg_assert (mb->mhandle);\n\n\t\t\t\tonum ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*num_overrides = onum;\n}\n\nstatic void\ntypebuilder_setup_fields (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionFieldBuilder *fb;\n\tMonoClassField *field;\n\tMonoImage *image = klass->image;\n\tconst char *p, *p2;\n\tint i;\n\tguint32 len, idx, real_size = 0;\n\n\tklass->field.count = tb->num_fields;\n\tklass->field.first = 0;\n\n\tmono_error_init (error);\n\n\tif (tb->class_size) {\n\t\tg_assert ((tb->packing_size & 0xfffffff0) == 0);\n\t\tklass->packing_size = tb->packing_size;\n\t\treal_size = klass->instance_size + tb->class_size;\n\t}\n\n\tif (!klass->field.count) {\n\t\tklass->instance_size = MAX (klass->instance_size, real_size);\n\t\treturn;\n\t}\n\t\n\tklass->fields = image_g_new0 (image, MonoClassField, klass->field.count);\n\tmono_class_alloc_ext (klass);\n\tklass->ext->field_def_values = image_g_new0 (image, MonoFieldDefaultValue, klass->field.count);\n\t/*\n\tThis is, guess what, a hack.\n\tThe issue is that the runtime doesn't know how to setup the fields of a typebuider and crash.\n\tOn the static path no field class is resolved, only types are built. This is the right thing to do\n\tbut we suck.\n\tSetting size_inited is harmless because we're doing the same job as mono_class_setup_fields anyway.\n\t*/\n\tklass->size_inited = 1;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tfb = mono_array_get (tb->fields, gpointer, i);\n\t\tfield = &klass->fields [i];\n\t\tfield->name = mono_string_to_utf8_image (image, fb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (fb->attrs) {\n\t\t\tfield->type = mono_metadata_type_dup (klass->image, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\t\tfield->type->attrs = fb->attrs;\n\t\t} else {\n\t\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\t}\n\t\tif ((fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) && fb->rva_data)\n\t\t\tklass->ext->field_def_values [i].data = mono_array_addr (fb->rva_data, char, 0);\n\t\tif (fb->offset != -1)\n\t\t\tfield->offset = fb->offset;\n\t\tfield->parent = klass;\n\t\tfb->handle = field;\n\t\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t\tif (fb->def_value) {\n\t\t\tMonoDynamicImage *assembly = (MonoDynamicImage*)klass->image;\n\t\t\tfield->type->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\t\t\tidx = encode_constant (assembly, fb->def_value, &klass->ext->field_def_values [i].def_type);\n\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\tp = assembly->blob.data + idx;\n\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\tlen += p2 - p;\n\t\t\tklass->ext->field_def_values [i].data = mono_image_alloc (image, len);\n\t\t\tmemcpy ((gpointer)klass->ext->field_def_values [i].data, p, len);\n\t\t}\n\t}\n\n\tklass->instance_size = MAX (klass->instance_size, real_size);\n\tmono_class_layout_fields (klass);\n}\n\nstatic void\ntypebuilder_setup_properties (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionPropertyBuilder *pb;\n\tMonoImage *image = klass->image;\n\tMonoProperty *properties;\n\tint i;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->property.count = tb->properties ? mono_array_length (tb->properties) : 0;\n\tklass->ext->property.first = 0;\n\n\tproperties = image_g_new0 (image, MonoProperty, klass->ext->property.count);\n\tklass->ext->properties = properties;\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\tproperties [i].parent = klass;\n\t\tproperties [i].attrs = pb->attrs;\n\t\tproperties [i].name = mono_string_to_utf8_image (image, pb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (pb->get_method)\n\t\t\tproperties [i].get = pb->get_method->mhandle;\n\t\tif (pb->set_method)\n\t\t\tproperties [i].set = pb->set_method->mhandle;\n\n\t\tmono_save_custom_attrs (klass->image, &properties [i], pb->cattrs);\n\t}\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tMonoEvent *event = g_new0 (MonoEvent, 1);\n\tMonoClass *klass;\n\tint j;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tevent->parent = klass;\n\tevent->attrs = eb->attrs;\n\tevent->name = mono_string_to_utf8 (eb->name);\n\tif (eb->add_method)\n\t\tevent->add = eb->add_method->mhandle;\n\tif (eb->remove_method)\n\t\tevent->remove = eb->remove_method->mhandle;\n\tif (eb->raise_method)\n\t\tevent->raise = eb->raise_method->mhandle;\n\n\tif (eb->other_methods) {\n\t\tevent->other = g_new0 (MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\tevent->other [j] = mb->mhandle;\n\t\t}\n\t}\n\n\treturn mono_event_get_object (mono_object_domain (tb), klass, event);\n}\n\nstatic void\ntypebuilder_setup_events (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionEventBuilder *eb;\n\tMonoImage *image = klass->image;\n\tMonoEvent *events;\n\tint i, j;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->event.count = tb->events ? mono_array_length (tb->events) : 0;\n\tklass->ext->event.first = 0;\n\n\tevents = image_g_new0 (image, MonoEvent, klass->ext->event.count);\n\tklass->ext->events = events;\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\tevents [i].parent = klass;\n\t\tevents [i].attrs = eb->attrs;\n\t\tevents [i].name = mono_string_to_utf8_image (image, eb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (eb->add_method)\n\t\t\tevents [i].add = eb->add_method->mhandle;\n\t\tif (eb->remove_method)\n\t\t\tevents [i].remove = eb->remove_method->mhandle;\n\t\tif (eb->raise_method)\n\t\t\tevents [i].raise = eb->raise_method->mhandle;\n\n\t\tif (eb->other_methods) {\n\t\t\tevents [i].other = image_g_new0 (image, MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\t\tevents [i].other [j] = mb->mhandle;\n\t\t\t}\n\t\t}\n\t\tmono_save_custom_attrs (klass->image, &events [i], eb->cattrs);\n\t}\n}\n\nstatic gboolean\nremove_instantiations_of (gpointer key,\n\t\t\t\t\t\t  gpointer value,\n\t\t\t\t\t\t  gpointer user_data)\n{\n\tMonoType *type = (MonoType*)key;\n\tMonoClass *klass = (MonoClass*)user_data;\n\n\tif ((type->type == MONO_TYPE_GENERICINST) && (type->data.generic_class->container_class == klass))\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\nstatic void\ncheck_array_for_usertypes (MonoArray *arr)\n{\n\tint i;\n\n\tif (!arr)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (arr); ++i)\n\t\tRESOLVE_ARRAY_TYPE_ELEMENT (arr, i);\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass;\n\tMonoDomain* domain;\n\tMonoReflectionType* res;\n\tint i, j;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (tb);\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\t/*\n\t * Check for user defined Type subclasses.\n\t */\n\tRESOLVE_TYPE (tb->parent);\n\tcheck_array_for_usertypes (tb->interfaces);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < mono_array_length (tb->fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (tb->fields, gpointer, i);\n\t\t\tif (fb) {\n\t\t\t\tRESOLVE_TYPE (fb->type);\n\t\t\t\tcheck_array_for_usertypes (fb->modreq);\n\t\t\t\tcheck_array_for_usertypes (fb->modopt);\n\t\t\t\tif (fb->marshal_info && fb->marshal_info->marshaltyperef)\n\t\t\t\t\tRESOLVE_TYPE (fb->marshal_info->marshaltyperef);\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->methods) {\n\t\tfor (i = 0; i < mono_array_length (tb->methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (tb->methods, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tRESOLVE_TYPE (mb->rtype);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modreq);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modopt);\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder *mb = mono_array_get (tb->ctors, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tmono_save_custom_attrs (klass->image, klass, tb->cattrs);\n\n\t/* \n\t * we need to lock the domain because the lock will be taken inside\n\t * So, we need to keep the locking order correct.\n\t */\n\tmono_loader_lock ();\n\tmono_domain_lock (domain);\n\tif (klass->wastypebuilder) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t}\n\t/*\n\t * Fields to set in klass:\n\t * the various flags: delegate/unicode/contextbound etc.\n\t */\n\tklass->flags = tb->attrs;\n\tklass->has_cctor = 1;\n\tklass->has_finalize = 1;\n\n#if 0\n\tif (!((MonoDynamicImage*)klass->image)->run) {\n\t\tif (klass->generic_container) {\n\t\t\t/* FIXME: The code below can't handle generic classes */\n\t\t\tklass->wastypebuilder = TRUE;\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_domain_unlock (domain);\n\t\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t\t}\n\t}\n#endif\n\n\t/* enums are done right away */\n\tif (!klass->enumtype)\n\t\tensure_runtime_vtable (klass);\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtb = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tklass->ext->nested_classes = g_list_prepend_image (klass->image, klass->ext->nested_classes, mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)subtb)));\n\t\t}\n\t}\n\n\tklass->nested_classes_inited = TRUE;\n\n\t/* fields and object layout */\n\tif (klass->parent) {\n\t\tif (!klass->parent->size_inited)\n\t\t\tmono_class_init (klass->parent);\n\t\tklass->instance_size = klass->parent->instance_size;\n\t\tklass->sizes.class_size = 0;\n\t\tklass->min_align = klass->parent->min_align;\n\t\t/* if the type has no fields we won't call the field_setup\n\t\t * routine which sets up klass->has_references.\n\t\t */\n\t\tklass->has_references |= klass->parent->has_references;\n\t} else {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->min_align = 1;\n\t}\n\n\t/* FIXME: handle packing_size and instance_size */\n\ttypebuilder_setup_fields (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\ttypebuilder_setup_properties (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\ttypebuilder_setup_events (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\tklass->wastypebuilder = TRUE;\n\n\t/* \n\t * If we are a generic TypeBuilder, there might be instantiations in the type cache\n\t * which have type System.Reflection.MonoGenericClass, but after the type is created, \n\t * we want to return normal System.MonoType objects, so clear these out from the cache.\n\t */\n\tif (domain->type_hash && klass->generic_container)\n\t\tmono_g_hash_table_foreach_remove (domain->type_hash, remove_instantiations_of, klass);\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\n\tif (klass->enumtype && !mono_class_is_valid_enum (klass)) {\n\t\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\tmono_raise_exception (mono_get_exception_type_load (tb->name, NULL));\n\t}\n\n\tres = mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\tg_assert (res != (MonoReflectionType*)tb);\n\n\treturn res;\n\nfailure:\n\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\tklass->wastypebuilder = TRUE;\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tMonoGenericParamFull *param;\n\tMonoImage *image;\n\tMonoClass *pklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tparam = g_new0 (MonoGenericParamFull, 1);\n\n\tif (gparam->mbuilder) {\n\t\tif (!gparam->mbuilder->generic_container) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)gparam->mbuilder->type;\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\t\tgparam->mbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->mbuilder->generic_container->is_method = TRUE;\n\t\t\t/* \n\t\t\t * Cannot set owner.method, since the MonoMethod is not created yet.\n\t\t\t * Set the image field instead, so type_in_image () works.\n\t\t\t */\n\t\t\tgparam->mbuilder->generic_container->image = klass->image;\n\t\t}\n\t\tparam->param.owner = gparam->mbuilder->generic_container;\n\t} else if (gparam->tbuilder) {\n\t\tif (!gparam->tbuilder->generic_container) {\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)gparam->tbuilder));\n\t\t\tgparam->tbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->tbuilder->generic_container->owner.klass = klass;\n\t\t}\n\t\tparam->param.owner = gparam->tbuilder->generic_container;\n\t}\n\n\tparam->info.name = mono_string_to_utf8 (gparam->name);\n\tparam->param.num = gparam->index;\n\n\timage = &gparam->tbuilder->module->dynamic_image->image;\n\tpklass = mono_class_from_generic_parameter ((MonoGenericParam *) param, image, gparam->mbuilder != NULL);\n\n\tgparam->type.type = &pklass->byval_arg;\n\n\tMOVING_GC_REGISTER (&pklass->reflection_info);\n\tpklass->reflection_info = gparam; /* FIXME: GC pin gparam */\n\tmono_image_lock (image);\n\timage->reflection_info_unregister_classes = g_slist_prepend (image->reflection_info_unregister_classes, pklass);\n\tmono_image_unlock (image);\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tMonoReflectionModuleBuilder *module = sig->module;\n\tMonoDynamicImage *assembly = module != NULL ? module->dynamic_image : NULL;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, na);\n\tif (assembly != NULL){\n\t\tfor (i = 0; i < na; ++i) {\n\t\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, type, &buf);\n\t\t}\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tMonoDynamicImage *assembly = sig->module->dynamic_image;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x06);\n\tfor (i = 0; i < na; ++i) {\n\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, type, &buf);\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tGSList *l;\n\tint i;\n\n\tsig = dynamic_method_to_signature (mb);\n\n\treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n\n\t/*\n\t * Resolve references.\n\t */\n\t/* \n\t * Every second entry in the refs array is reserved for storing handle_class,\n\t * which is needed by the ldtoken implementation in the JIT.\n\t */\n\trmb.nrefs = mb->nrefs;\n\trmb.refs = g_new0 (gpointer, mb->nrefs + 1);\n\tfor (i = 0; i < mb->nrefs; i += 2) {\n\t\tMonoClass *handle_class;\n\t\tgpointer ref;\n\t\tMonoObject *obj = mono_array_get (mb->refs, MonoObject*, i);\n\n\t\tif (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t\t/*\n\t\t\t * The referenced DynamicMethod should already be created by the managed\n\t\t\t * code, except in the case of circular references. In that case, we store\n\t\t\t * method in the refs array, and fix it up later when the referenced \n\t\t\t * DynamicMethod is created.\n\t\t\t */\n\t\t\tif (method->mhandle) {\n\t\t\t\tref = method->mhandle;\n\t\t\t} else {\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tref = method;\n\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tmethod->referenced_by = g_slist_append (method->referenced_by, mb);\n\t\t\t}\n\t\t\thandle_class = mono_defaults.methodhandle_class;\n\t\t} else {\n\t\t\tMonoException *ex = NULL;\n\t\t\tref = resolve_object (mb->module->image, obj, &handle_class, NULL);\n\t\t\tif (!ref)\n\t\t\t\tex = mono_get_exception_type_load (NULL, NULL);\n\t\t\telse if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\t\t\tex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);\n\n\t\t\tif (ex) {\n\t\t\t\tg_free (rmb.refs);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trmb.refs [i] = ref; /* FIXME: GC object stored in unmanaged memory (change also resolve_object() signature) */\n\t\trmb.refs [i + 1] = handle_class;\n\t}\t\t\n\n\tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\n\t/* Fix up refs entries pointing at us */\n\tfor (l = mb->referenced_by; l; l = l->next) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data;\n\t\tMonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle;\n\t\tgpointer *data;\n\t\t\n\t\tg_assert (method->mhandle);\n\n\t\tdata = (gpointer*)wrapper->method_data;\n\t\tfor (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) {\n\t\t\tif ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class))\n\t\t\t\tdata [i + 1] = mb->mhandle;\n\t\t}\n\t}\n\tg_slist_free (mb->referenced_by);\n\n\tg_free (rmb.refs);\n\n\t/* ilgen is no longer needed */\n\tmb->ilgen = NULL;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\nvoid\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);\n}\n\n/**\n * \n * mono_reflection_is_valid_dynamic_token:\n * \n * Returns TRUE if token is valid.\n * \n */\ngboolean\nmono_reflection_is_valid_dynamic_token (MonoDynamicImage *image, guint32 token)\n{\n\treturn mono_g_hash_table_lookup (image->tokens, GUINT_TO_POINTER (token)) != NULL;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/**\n * mono_reflection_lookup_dynamic_token:\n *\n * Finish the Builder object pointed to by TOKEN and return the corresponding\n * runtime structure. If HANDLE_CLASS is not NULL, it is set to the class required by \n * mono_ldtoken. If valid_token is TRUE, assert if it is not found in the token->object\n * mapping table.\n *\n * LOCKING: Take the loader lock\n */\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tMonoDynamicImage *assembly = (MonoDynamicImage*)image;\n\tMonoObject *obj;\n\tMonoClass *klass;\n\n\tmono_loader_lock ();\n\tobj = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tmono_loader_unlock ();\n\tif (!obj) {\n\t\tif (valid_token)\n\t\t\tg_error (\"Could not find required dynamic token 0x%08x\", token);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tif (!handle_class)\n\t\thandle_class = &klass;\n\treturn resolve_object (image, obj, handle_class, context);\n}\n\n/*\n * ensure_complete_type:\n *\n *   Ensure that KLASS is completed if it is a dynamic type, or references\n * dynamic types.\n */\nstatic void\nensure_complete_type (MonoClass *klass)\n{\n\tif (klass->image->dynamic && !klass->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\n\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t// Asserting here could break a lot of code\n\t\t//g_assert (klass->wastypebuilder);\n\t}\n\n\tif (klass->generic_class) {\n\t\tMonoGenericInst *inst = klass->generic_class->context.class_inst;\n\t\tint i;\n\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\tensure_complete_type (mono_class_from_mono_type (inst->type_argv [i]));\n\t\t}\n\t}\n}\n\nstatic gpointer\nresolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tgpointer result = NULL;\n\n\tif (strcmp (obj->vtable->klass->name, \"String\") == 0) {\n\t\tresult = mono_string_intern ((MonoString*)obj);\n\t\t*handle_class = mono_defaults.string_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (type, context);\n\t\t\tresult = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\t\t} else {\n\t\t\tresult = mono_class_from_mono_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericMethod\") == 0) {\n\t\tresult = ((MonoReflectionMethod*)obj)->method;\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tresult = mb->mhandle;\n\t\tif (!result) {\n\t\t\t/* Type is not yet created */\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t\t/*\n\t\t\t * Hopefully this has been filled in by calling CreateType() on the\n\t\t\t * TypeBuilder.\n\t\t\t */\n\t\t\t/*\n\t\t\t * TODO: This won't work if the application finishes another \n\t\t\t * TypeBuilder instance instead of this one.\n\t\t\t */\n\t\t\tresult = mb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\n\t\tresult = cb->mhandle;\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)cb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = cb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoField\") == 0) {\n\t\tMonoClassField *field = ((MonoReflectionField*)obj)->field;\n\n\t\tensure_complete_type (field->parent);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (&field->parent->byval_arg, context);\n\t\t\tMonoClass *class = mono_class_from_mono_type (inflated);\n\t\t\tMonoClassField *inflated_field;\n\t\t\tgpointer iter = NULL;\n\t\t\tmono_metadata_free_type (inflated);\n\t\t\twhile ((inflated_field = mono_class_get_fields (class, &iter))) {\n\t\t\t\tif (!strcmp (field->name, inflated_field->name))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg_assert (inflated_field && !strcmp (field->name, inflated_field->name));\n\t\t\tresult = inflated_field;\n\t\t} else {\n\t\t\tresult = field;\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tresult = fb->handle;\n\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)fb->typeb;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = fb->handle;\n\t\t}\n\n\t\tif (fb->handle && fb->handle->parent->generic_container) {\n\t\t\tMonoClass *klass = fb->handle->parent;\n\t\t\tMonoType *type = mono_class_inflate_generic_type (&klass->byval_arg, context);\n\t\t\tMonoClass *inflated = mono_class_from_mono_type (type);\n\n\t\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (fb->handle));\n\t\t\tg_assert (result);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)tb); \n\t\tMonoClass *klass;\n\n\t\tklass = type->data.klass;\n\t\tif (klass->wastypebuilder) {\n\t\t\t/* Already created */\n\t\t\tresult = klass;\n\t\t}\n\t\telse {\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = type->data.klass;\n\t\t\tg_assert (result);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *helper = (MonoReflectionSigHelper*)obj;\n\t\tMonoMethodSignature *sig;\n\t\tint nargs, i;\n\n\t\tif (helper->arguments)\n\t\t\tnargs = mono_array_length (helper->arguments);\n\t\telse\n\t\t\tnargs = 0;\n\n\t\tsig = mono_metadata_signature_alloc (image, nargs);\n\t\tsig->explicit_this = helper->call_conv & 64 ? 1 : 0;\n\t\tsig->hasthis = helper->call_conv & 32 ? 1 : 0;\n\n\t\tif (helper->unmanaged_call_conv) { /* unmanaged */\n\t\t\tsig->call_convention = helper->unmanaged_call_conv - 1;\n\t\t\tsig->pinvoke = TRUE;\n\t\t} else if (helper->call_conv & 0x02) {\n\t\t\tsig->call_convention = MONO_CALL_VARARG;\n\t\t} else {\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\t}\n\n\t\tsig->param_count = nargs;\n\t\t/* TODO: Copy type ? */\n\t\tsig->ret = helper->return_type->type;\n\t\tfor (i = 0; i < nargs; ++i)\n\t\t\tsig->params [i] = mono_type_array_get_and_resolve (helper->arguments, i);\n\n\t\tresult = sig;\n\t\t*handle_class = NULL;\n\t} else if (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t/* Already created by the managed code */\n\t\tg_assert (method->mhandle);\n\t\tresult = method->mhandle;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\tMonoClass *inflated;\n\t\tMonoType *type;\n\n\t\ttype = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)f->inst), context);\n\t\tinflated = mono_class_from_mono_type (type);\n\n\t\tg_assert (f->fb->handle);\n\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (f->fb->handle));\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)c->inst), context);\n\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\tg_assert (c->cb->mhandle);\n\t\tresult = inflate_mono_method (inflated_klass, c->cb->mhandle, (MonoObject*)c->cb);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)m->inst), context);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tg_assert (m->mb->mhandle);\n\t\t\tresult = inflate_mono_method (inflated_klass, m->mb->mhandle, (MonoObject*)m->mb);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod*)obj;\n\t\tMonoType *mtype;\n\t\tMonoClass *klass;\n\t\tMonoMethod *method;\n\t\tgpointer iter;\n\t\tchar *name;\n\n\t\tmtype = mono_reflection_type_get_handle (m->parent);\n\t\tklass = mono_class_from_mono_type (mtype);\n\n\t\t/* Find the method */\n\n\t\tname = mono_string_to_utf8 (m->name);\n\t\titer = NULL;\n\t\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\t\tif (!strcmp (method->name, name))\n\t\t\t\tbreak;\n\t\t}\n\t\tg_free (name);\n\n\t\t// FIXME:\n\t\tg_assert (method);\n\t\t// FIXME: Check parameters/return value etc. match\n\n\t\tresult = method;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (is_sre_array (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_byref (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_pointer (mono_object_get_class(obj))) {\n\t\tMonoReflectionType *ref_type = (MonoReflectionType *)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle (ref_type);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else {\n\t\tg_print (\"%s\\n\", obj->vtable->klass->name);\n\t\tg_assert_not_reached ();\n\t}\n\treturn result;\n}\n\n#else /* DISABLE_REFLECTION_EMIT */\n\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit, so System.Reflection.Emit is not supported.\");\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tg_assert_not_reached ();\n}\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n}\n\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\t*overrides = NULL;\n\t*num_overrides = 0;\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tg_assert_not_reached ();\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n}\n\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\treturn NULL;\n}\n\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tif (!ref)\n\t\treturn NULL;\n\treturn ref->type;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/* SECURITY_ACTION_* are defined in mono/metadata/tabledefs.h */\nconst static guint32 declsec_flags_map[] = {\n\t0x00000000,\t\t\t\t\t/* empty */\n\tMONO_DECLSEC_FLAG_REQUEST,\t\t\t/* SECURITY_ACTION_REQUEST\t\t\t(x01) */\n\tMONO_DECLSEC_FLAG_DEMAND,\t\t\t/* SECURITY_ACTION_DEMAND\t\t\t(x02) */\n\tMONO_DECLSEC_FLAG_ASSERT,\t\t\t/* SECURITY_ACTION_ASSERT\t\t\t(x03) */\n\tMONO_DECLSEC_FLAG_DENY,\t\t\t\t/* SECURITY_ACTION_DENY\t\t\t\t(x04) */\n\tMONO_DECLSEC_FLAG_PERMITONLY,\t\t\t/* SECURITY_ACTION_PERMITONLY\t\t\t(x05) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND,\t\t\t/* SECURITY_ACTION_LINKDEMAND\t\t\t(x06) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND,\t\t/* SECURITY_ACTION_INHERITANCEDEMAND\t\t(x07) */\n\tMONO_DECLSEC_FLAG_REQUEST_MINIMUM,\t\t/* SECURITY_ACTION_REQUEST_MINIMUM\t\t(x08) */\n\tMONO_DECLSEC_FLAG_REQUEST_OPTIONAL,\t\t/* SECURITY_ACTION_REQUEST_OPTIONAL\t\t(x09) */\n\tMONO_DECLSEC_FLAG_REQUEST_REFUSE,\t\t/* SECURITY_ACTION_REQUEST_REFUSE\t\t(x0A) */\n\tMONO_DECLSEC_FLAG_PREJIT_GRANT,\t\t\t/* SECURITY_ACTION_PREJIT_GRANT\t\t\t(x0B) */\n\tMONO_DECLSEC_FLAG_PREJIT_DENY,\t\t\t/* SECURITY_ACTION_PREJIT_DENY\t\t\t(x0C) */\n\tMONO_DECLSEC_FLAG_NONCAS_DEMAND,\t\t/* SECURITY_ACTION_NONCAS_DEMAND\t\t(x0D) */\n\tMONO_DECLSEC_FLAG_NONCAS_LINKDEMAND,\t\t/* SECURITY_ACTION_NONCAS_LINKDEMAND\t\t(x0E) */\n\tMONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND,\t/* SECURITY_ACTION_NONCAS_INHERITANCEDEMAND\t(x0F) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND_CHOICE,\t\t/* SECURITY_ACTION_LINKDEMAND_CHOICE\t\t(x10) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE,\t/* SECURITY_ACTION_INHERITANCEDEMAND_CHOICE\t(x11) */\n\tMONO_DECLSEC_FLAG_DEMAND_CHOICE,\t\t/* SECURITY_ACTION_DEMAND_CHOICE\t\t(x12) */\n};\n\n/*\n * Returns flags that includes all available security action associated to the handle.\n * @token: metadata token (either for a class or a method)\n * @image: image where resides the metadata.\n */\nstatic guint32\nmono_declsec_get_flags (MonoImage *image, guint32 token)\n{\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_DECLSECURITY];\n\tguint32 result = 0;\n\tguint32 action;\n\tint i;\n\n\t/* HasSecurity can be present for other, not specially encoded, attributes,\n\t   e.g. SuppressUnmanagedCodeSecurityAttribute */\n\tif (index < 0)\n\t\treturn 0;\n\n\tfor (i = index; i < t->rows; i++) {\n\t\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\tbreak;\n\n\t\taction = cols [MONO_DECL_SECURITY_ACTION];\n\t\tif ((action >= MONO_DECLSEC_ACTION_MIN) && (action <= MONO_DECLSEC_ACTION_MAX)) {\n\t\t\tresult |= declsec_flags_map [action];\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified method.\n *\n * @method: The method for which we want the declarative security flags.\n * Return the declarative security flags for the method (only).\n *\n * Note: To keep MonoMethod size down we do not cache the declarative security flags\n *       (except for the stack modifiers which are kept in the MonoJitInfo structure)\n */\nguint32\nmono_declsec_flags_from_method (MonoMethod *method)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\t/* FIXME: No cache (for the moment) */\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn mono_declsec_get_flags (method->klass->image, idx);\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified class.\n *\n * @klass: The class for which we want the declarative security flags.\n * Return the declarative security flags for the class.\n *\n * Note: We cache the flags inside the MonoClass structure as this will get \n *       called very often (at least for each method).\n */\nguint32\nmono_declsec_flags_from_class (MonoClass *klass)\n{\n\tif (klass->flags & TYPE_ATTRIBUTE_HAS_SECURITY) {\n\t\tif (!klass->ext || !klass->ext->declsec_flags) {\n\t\t\tguint32 idx;\n\n\t\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tmono_loader_lock ();\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tmono_loader_unlock ();\n\t\t\t/* we cache the flags on classes */\n\t\t\tklass->ext->declsec_flags = mono_declsec_get_flags (klass->image, idx);\n\t\t}\n\t\treturn klass->ext->declsec_flags;\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified assembly.\n *\n * @assembly: The assembly for which we want the declarative security flags.\n * Return the declarative security flags for the assembly.\n */\nguint32\nmono_declsec_flags_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\treturn mono_declsec_get_flags (assembly->image, idx);\n}\n\n\n/*\n * Fill actions for the specific index (which may either be an encoded class token or\n * an encoded method token) from the metadata image.\n * Returns TRUE if some actions requiring code generation are present, FALSE otherwise.\n */\nstatic MonoBoolean\nfill_actions_from_index (MonoImage *image, guint32 token, MonoDeclSecurityActions* actions,\n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tMonoBoolean result = FALSE;\n\tMonoTableInfo *t;\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tint i;\n\n\tt  = &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\treturn result;\n\n\t\t/* if present only replace (class) permissions with method permissions */\n\t\t/* if empty accept either class or method permissions */\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == id_std) {\n\t\t\tif (!actions->demand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demand.blob = (char*) (blob + 2);\n\t\t\t\tactions->demand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_noncas) {\n\t\t\tif (!actions->noncasdemand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->noncasdemand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->noncasdemand.blob = (char*) (blob + 2);\n\t\t\t\tactions->noncasdemand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_choice) {\n\t\t\tif (!actions->demandchoice.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demandchoice.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demandchoice.blob = (char*) (blob + 2);\n\t\t\t\tactions->demandchoice.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic MonoBoolean\nmono_declsec_get_class_demands_params (MonoClass *klass, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\treturn fill_actions_from_index (klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\nstatic MonoBoolean\nmono_declsec_get_method_demands_params (MonoMethod *method, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_method_get_index (method);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\treturn fill_actions_from_index (method->klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\n/*\n * Collect all actions (that requires to generate code in mini) assigned for\n * the specified method.\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_demands (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\tguint32 mask = MONO_DECLSEC_FLAG_DEMAND | MONO_DECLSEC_FLAG_NONCAS_DEMAND | \n\t\tMONO_DECLSEC_FLAG_DEMAND_CHOICE;\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult = mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & mask) {\n\t\tif (!result) {\n\t\t\tmono_class_init (method->klass);\n\t\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\t\t}\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* The boolean return value is used as a shortcut in case nothing needs to\n\t   be generated (e.g. LinkDemand[Choice] and InheritanceDemand[Choice]) */\n\treturn result;\n}\n\n\n/*\n * Collect all Link actions: LinkDemand, NonCasLinkDemand and LinkDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_linkdemands (MonoMethod *method, MonoDeclSecurityActions* klass, MonoDeclSecurityActions *cmethod)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* results are independant - zeroize both */\n\tmemset (cmethod, 0, sizeof (MonoDeclSecurityActions));\n\tmemset (klass, 0, sizeof (MonoDeclSecurityActions));\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult = mono_declsec_get_method_demands_params (method, cmethod, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & (MONO_DECLSEC_FLAG_LINKDEMAND | MONO_DECLSEC_FLAG_NONCAS_LINKDEMAND | MONO_DECLSEC_FLAG_LINKDEMAND_CHOICE)) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, klass, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * @klass\tThe inherited class - this is the class that provides the security check (attributes)\n * @demans\t\n * return TRUE if inheritance demands (any kind) are present, FALSE otherwise.\n * \n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_class (MonoClass *klass, MonoDeclSecurityActions* demands)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (klass);\n\tif (flags & (MONO_DECLSEC_FLAG_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE)) {\n\t\tmono_class_init (klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult |= mono_declsec_get_class_demands_params (klass, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_method (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\treturn mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\treturn FALSE;\n}\n\n\nstatic MonoBoolean\nget_declsec_action (MonoImage *image, guint32 token, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tMonoTableInfo *t;\n\tint i;\n\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tif (index == -1)\n\t\treturn FALSE;\n\n\tt =  &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\t/* shortcut - index are ordered */\n\t\tif (token != cols [MONO_DECL_SECURITY_PARENT])\n\t\t\treturn FALSE;\n\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == action) {\n\t\t\tconst char *metadata = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\tentry->blob = (char*) (metadata + 2);\n\t\t\tentry->size = mono_metadata_decode_blob_size (metadata, &metadata);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_method_action (MonoMethod *method, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn get_declsec_action (method->klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_class_action (MonoClass *klass, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\t/* use cache */\n\tguint32 flags = mono_declsec_flags_from_class (klass);\n\tif (declsec_flags_map [action] & flags) {\n\t\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\treturn get_declsec_action (klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_assembly_action (MonoAssembly *assembly, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\n\treturn get_declsec_action (assembly->image, idx, action, entry);\n}\n\ngboolean\nmono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass)\n{\n\tMonoObject *res, *exc;\n\tvoid *params [1];\n\tstatic MonoClass *System_Reflection_Emit_TypeBuilder = NULL;\n\tstatic MonoMethod *method = NULL;\n\n\tif (!System_Reflection_Emit_TypeBuilder) {\n\t\tSystem_Reflection_Emit_TypeBuilder = mono_class_from_name (mono_defaults.corlib, \"System.Reflection.Emit\", \"TypeBuilder\");\n\t\tg_assert (System_Reflection_Emit_TypeBuilder);\n\t}\n\tif (method == NULL) {\n\t\tmethod = mono_class_get_method_from_name (System_Reflection_Emit_TypeBuilder, \"IsAssignableTo\", 1);\n\t\tg_assert (method);\n\t}\n\n\t/* \n\t * The result of mono_type_get_object () might be a System.MonoType but we\n\t * need a TypeBuilder so use klass->reflection_info.\n\t */\n\tg_assert (klass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)(klass->reflection_info))->vtable->klass->name, \"TypeBuilder\"));\n\n\tparams [0] = mono_type_get_object (mono_domain_get (), &oklass->byval_arg);\n\n\tres = mono_runtime_invoke (method, (MonoObject*)(klass->reflection_info), params, &exc);\n\tif (exc)\n\t\treturn FALSE;\n\telse\n\t\treturn *(MonoBoolean*)mono_object_unbox (res);\n}\n", "#ifndef __MONO_METADATA_VERIFY_INTERNAL_H__\n#define __MONO_METADATA_VERIFY_INTERNAL_H__\n\n#include <mono/metadata/metadata.h>\n\nG_BEGIN_DECLS\n\ntypedef enum {\n\tMONO_VERIFIER_MODE_OFF,\n\tMONO_VERIFIER_MODE_VALID,\n\tMONO_VERIFIER_MODE_VERIFIABLE,\n\tMONO_VERIFIER_MODE_STRICT\n} MiniVerifierMode;\n\nvoid mono_verifier_set_mode (MiniVerifierMode mode) MONO_INTERNAL;\nvoid mono_verifier_enable_verify_all (void) MONO_INTERNAL;\n\ngboolean mono_verifier_is_enabled_for_image (MonoImage *image) MONO_INTERNAL;\ngboolean mono_verifier_is_enabled_for_method (MonoMethod *method) MONO_INTERNAL;\ngboolean mono_verifier_is_enabled_for_class (MonoClass *klass) MONO_INTERNAL;\n\ngboolean mono_verifier_is_method_full_trust (MonoMethod *method) MONO_INTERNAL;\ngboolean mono_verifier_is_class_full_trust (MonoClass *klass) MONO_INTERNAL;\ngboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *class) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_class (MonoClass *klass) MONO_INTERNAL;\n\nGSList* mono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_pe_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_cli_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_table_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_full_table_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_field_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_method_header (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_method_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_memberref_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_standalone_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_typespec_signature (MonoImage *image, guint32 offset, guint32 token, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_methodspec_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_string_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_is_sig_compatible (MonoImage *image, MonoMethod *method, MonoMethodSignature *signature) MONO_INTERNAL;\n\nG_END_DECLS\n\n#endif  /* __MONO_METADATA_VERIFY_INTERNAL_H__ */\n\n", "/*\n * verify.c: \n *\n * Author:\n *\tMono Project (http://www.mono-project.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n */\n#include <config.h>\n\n#include <mono/metadata/object-internals.h>\n#include <mono/metadata/verify.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/metadata/opcodes.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/mono-endian.h>\n#include <mono/metadata/metadata.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/security-manager.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/mono-basic-block.h>\n#include <mono/utils/monobitset.h>\n#include <string.h>\n#include <signal.h>\n#include <ctype.h>\n\nstatic MiniVerifierMode verifier_mode = MONO_VERIFIER_MODE_OFF;\nstatic gboolean verify_all = FALSE;\n\n/*\n * Set the desired level of checks for the verfier.\n * \n */\nvoid\nmono_verifier_set_mode (MiniVerifierMode mode)\n{\n\tverifier_mode = mode;\n}\n\nvoid\nmono_verifier_enable_verify_all ()\n{\n\tverify_all = TRUE;\n}\n\n#ifndef DISABLE_VERIFIER\n/*\n * Pull the list of opcodes\n */\n#define OPDEF(a,b,c,d,e,f,g,h,i,j) \\\n\ta = i,\n\nenum {\n#include \"mono/cil/opcode.def\"\n\tLAST = 0xff\n};\n#undef OPDEF\n\n#ifdef MONO_VERIFIER_DEBUG\n#define VERIFIER_DEBUG(code) do { code } while (0)\n#else\n#define VERIFIER_DEBUG(code)\n#endif\n\n//////////////////////////////////////////////////////////////////\n#define IS_STRICT_MODE(ctx) (((ctx)->level & MONO_VERIFY_NON_STRICT) == 0)\n#define IS_FAIL_FAST_MODE(ctx) (((ctx)->level & MONO_VERIFY_FAIL_FAST) == MONO_VERIFY_FAIL_FAST)\n#define IS_SKIP_VISIBILITY(ctx) (((ctx)->level & MONO_VERIFY_SKIP_VISIBILITY) == MONO_VERIFY_SKIP_VISIBILITY)\n#define IS_REPORT_ALL_ERRORS(ctx) (((ctx)->level & MONO_VERIFY_REPORT_ALL_ERRORS) == MONO_VERIFY_REPORT_ALL_ERRORS)\n#define CLEAR_PREFIX(ctx, prefix) do { (ctx)->prefix_set &= ~(prefix); } while (0)\n#define ADD_VERIFY_INFO(__ctx, __msg, __status, __exception)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->info.status = __status;\t\\\n\t\tvinfo->info.message = ( __msg );\t\\\n\t\tvinfo->exception_type = (__exception);\t\\\n\t\t(__ctx)->list = g_slist_prepend ((__ctx)->list, vinfo);\t\\\n\t} while (0)\n\n//TODO support MONO_VERIFY_REPORT_ALL_ERRORS\n#define ADD_VERIFY_ERROR(__ctx, __msg)\t\\\n\tdo {\t\\\n\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_ERROR, MONO_EXCEPTION_INVALID_PROGRAM); \\\n\t\t(__ctx)->valid = 0; \\\n\t} while (0)\n\n#define CODE_NOT_VERIFIABLE(__ctx, __msg) \\\n\tdo {\t\\\n\t\tif ((__ctx)->verifiable || IS_REPORT_ALL_ERRORS (__ctx)) { \\\n\t\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_NOT_VERIFIABLE, MONO_EXCEPTION_UNVERIFIABLE_IL); \\\n\t\t\t(__ctx)->verifiable = 0; \\\n\t\t\tif (IS_FAIL_FAST_MODE (__ctx)) \\\n\t\t\t\t(__ctx)->valid = 0; \\\n\t\t} \\\n\t} while (0)\n\n#define ADD_VERIFY_ERROR2(__ctx, __msg, __exception)\t\\\n\tdo {\t\\\n\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_ERROR, __exception); \\\n\t\t(__ctx)->valid = 0; \\\n\t} while (0)\n\n#define CODE_NOT_VERIFIABLE2(__ctx, __msg, __exception) \\\n\tdo {\t\\\n\t\tif ((__ctx)->verifiable || IS_REPORT_ALL_ERRORS (__ctx)) { \\\n\t\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_NOT_VERIFIABLE, __exception); \\\n\t\t\t(__ctx)->verifiable = 0; \\\n\t\t\tif (IS_FAIL_FAST_MODE (__ctx)) \\\n\t\t\t\t(__ctx)->valid = 0; \\\n\t\t} \\\n\t} while (0)\n\n#define CHECK_ADD4_OVERFLOW_UN(a, b) ((guint32)(0xFFFFFFFFU) - (guint32)(b) < (guint32)(a))\n#define CHECK_ADD8_OVERFLOW_UN(a, b) ((guint64)(0xFFFFFFFFFFFFFFFFUL) - (guint64)(b) < (guint64)(a))\n\n#if SIZEOF_VOID_P == 4\n#define CHECK_ADDP_OVERFLOW_UN(a,b) CHECK_ADD4_OVERFLOW_UN(a, b)\n#else\n#define CHECK_ADDP_OVERFLOW_UN(a,b) CHECK_ADD8_OVERFLOW_UN(a, b)\n#endif\n\n#define ADDP_IS_GREATER_OR_OVF(a, b, c) (((a) + (b) > (c)) || CHECK_ADDP_OVERFLOW_UN (a, b))\n#define ADD_IS_GREATER_OR_OVF(a, b, c) (((a) + (b) > (c)) || CHECK_ADD4_OVERFLOW_UN (a, b))\n\n/*Flags to be used with ILCodeDesc::flags */\nenum {\n\t/*Instruction has not been processed.*/\n\tIL_CODE_FLAG_NOT_PROCESSED  = 0,\n\t/*Instruction was decoded by mono_method_verify loop.*/\n\tIL_CODE_FLAG_SEEN = 1,\n\t/*Instruction was target of a branch or is at a protected block boundary.*/\n\tIL_CODE_FLAG_WAS_TARGET = 2,\n\t/*Used by stack_init to avoid double initialize each entry.*/\n\tIL_CODE_FLAG_STACK_INITED = 4,\n\t/*Used by merge_stacks to decide if it should just copy the eval stack.*/\n\tIL_CODE_STACK_MERGED = 8,\n\t/*This instruction is part of the delegate construction sequence, it cannot be target of a branch.*/\n\tIL_CODE_DELEGATE_SEQUENCE = 0x10,\n\t/*This is a delegate created from a ldftn to a non final virtual method*/\n\tIL_CODE_LDFTN_DELEGATE_NONFINAL_VIRTUAL = 0x20,\n\t/*This is a call to a non final virtual method*/\n\tIL_CODE_CALL_NONFINAL_VIRTUAL = 0x40,\n};\n\ntypedef enum {\n\tRESULT_VALID,\n\tRESULT_UNVERIFIABLE,\n\tRESULT_INVALID\n} verify_result_t;\n\ntypedef struct {\n\tMonoType *type;\n\tint stype;\n\tMonoMethod *method;\n} ILStackDesc;\n\n\ntypedef struct {\n\tILStackDesc *stack;\n\tguint16 size;\n\tguint16 flags;\n} ILCodeDesc;\n\ntypedef struct {\n\tint max_args;\n\tint max_stack;\n\tint verifiable;\n\tint valid;\n\tint level;\n\n\tint code_size;\n\tILCodeDesc *code;\n\tILCodeDesc eval;\n\n\tMonoType **params;\n\tGSList *list;\n\t/*Allocated fnptr MonoType that should be freed by us.*/\n\tGSList *funptrs;\n\t/*Type dup'ed exception types from catch blocks.*/\n\tGSList *exception_types;\n\n\tint num_locals;\n\tMonoType **locals;\n\n\t/*TODO get rid of target here, need_merge in mono_method_verify and hoist the merging code in the branching code*/\n\tint target;\n\n\tguint32 ip_offset;\n\tMonoMethodSignature *signature;\n\tMonoMethodHeader *header;\n\n\tMonoGenericContext *generic_context;\n\tMonoImage *image;\n\tMonoMethod *method;\n\n\t/*This flag helps solving a corner case of delegate verification in that you cannot have a \"starg 0\" \n\t *on a method that creates a delegate for a non-final virtual method using ldftn*/\n\tgboolean has_this_store;\n\n\t/*This flag is used to control if the contructor of the parent class has been called.\n\t *If the this pointer is pushed on the eval stack and it's a reference type constructor and\n\t * super_ctor_called is false, the uninitialized flag is set on the pushed value.\n\t * \n\t * Poping an uninitialized this ptr from the eval stack is an unverifiable operation unless\n\t * the safe variant is used. Only a few opcodes can use it : dup, pop, ldfld, stfld and call to a constructor.\n\t */\n\tgboolean super_ctor_called;\n\n\tguint32 prefix_set;\n\tgboolean has_flags;\n\tMonoType *constrained_type;\n} VerifyContext;\n\nstatic void\nmerge_stacks (VerifyContext *ctx, ILCodeDesc *from, ILCodeDesc *to, gboolean start, gboolean external);\n\nstatic int\nget_stack_type (MonoType *type);\n\nstatic gboolean\nmono_delegate_signature_equal (MonoMethodSignature *delegate_sig, MonoMethodSignature *method_sig, gboolean is_static_ldftn);\n\nstatic gboolean\nmono_class_is_valid_generic_instantiation (VerifyContext *ctx, MonoClass *klass);\n\nstatic gboolean\nmono_method_is_valid_generic_instantiation (VerifyContext *ctx, MonoMethod *method);\n//////////////////////////////////////////////////////////////////\n\n\n\nenum {\n\tTYPE_INV = 0, /* leave at 0. */\n\tTYPE_I4  = 1,\n\tTYPE_I8  = 2,\n\tTYPE_NATIVE_INT = 3,\n\tTYPE_R8  = 4,\n\t/* Used by operator tables to resolve pointer types (managed & unmanaged) and by unmanaged pointer types*/\n\tTYPE_PTR  = 5,\n\t/* value types and classes */\n\tTYPE_COMPLEX = 6,\n\t/* Number of types, used to define the size of the tables*/\n\tTYPE_MAX = 6,\n\n\t/* Used by tables to signal that a result is not verifiable*/\n\tNON_VERIFIABLE_RESULT = 0x80,\n\n\t/*Mask used to extract just the type, excluding flags */\n\tTYPE_MASK = 0x0F,\n\n\t/* The stack type is a managed pointer, unmask the value to res */\n\tPOINTER_MASK = 0x100,\n\t\n\t/*Stack type with the pointer mask*/\n\tRAW_TYPE_MASK = 0x10F,\n\n\t/* Controlled Mutability Manager Pointer */\n\tCMMP_MASK = 0x200,\n\n\t/* The stack type is a null literal*/\n\tNULL_LITERAL_MASK = 0x400,\n\t\n\t/**Used by ldarg.0 and family to let delegate verification happens.*/\n\tTHIS_POINTER_MASK = 0x800,\n\n\t/**Signals that this is a boxed value type*/\n\tBOXED_MASK = 0x1000,\n\n\t/*This is an unitialized this ref*/\n\tUNINIT_THIS_MASK = 0x2000,\n};\n\nstatic const char* const\ntype_names [TYPE_MAX + 1] = {\n\t\"Invalid\",\n\t\"Int32\",\n\t\"Int64\",\n\t\"Native Int\",\n\t\"Float64\",\n\t\"Native Pointer\",\n\t\"Complex\"\t\n};\n\nenum {\n\tPREFIX_UNALIGNED = 1,\n\tPREFIX_VOLATILE  = 2,\n\tPREFIX_TAIL      = 4,\n\tPREFIX_CONSTRAINED = 8,\n\tPREFIX_READONLY = 16\n};\n//////////////////////////////////////////////////////////////////\n\n\n/*Token validation macros and functions */\n#define IS_MEMBER_REF(token) (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF)\n#define IS_METHOD_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n#define IS_METHOD_SPEC(token) (mono_metadata_token_table (token) == MONO_TABLE_METHODSPEC)\n#define IS_FIELD_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_FIELD)\n\n#define IS_TYPE_REF(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPEREF)\n#define IS_TYPE_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPEDEF)\n#define IS_TYPE_SPEC(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPESPEC)\n#define IS_METHOD_DEF_OR_REF_OR_SPEC(token) (IS_METHOD_DEF (token) || IS_MEMBER_REF (token) || IS_METHOD_SPEC (token))\n#define IS_TYPE_DEF_OR_REF_OR_SPEC(token) (IS_TYPE_DEF (token) || IS_TYPE_REF (token) || IS_TYPE_SPEC (token))\n#define IS_FIELD_DEF_OR_REF(token) (IS_FIELD_DEF (token) || IS_MEMBER_REF (token))\n\n/*\n * Verify if @token refers to a valid row on int's table.\n */\nstatic gboolean\ntoken_bounds_check (MonoImage *image, guint32 token)\n{\n\tif (image->dynamic)\n\t\treturn mono_reflection_is_valid_dynamic_token ((MonoDynamicImage*)image, token);\n\treturn image->tables [mono_metadata_token_table (token)].rows >= mono_metadata_token_index (token);\n}\n\nstatic MonoType *\nmono_type_create_fnptr_from_mono_method (VerifyContext *ctx, MonoMethod *method)\n{\n\tMonoType *res = g_new0 (MonoType, 1);\n\t//FIXME use mono_method_get_signature_full\n\tres->data.method = mono_method_signature (method);\n\tres->type = MONO_TYPE_FNPTR;\n\tctx->funptrs = g_slist_prepend (ctx->funptrs, res);\n\treturn res;\n}\n\n/*\n * mono_type_is_enum_type:\n * \n * Returns TRUE if @type is an enum type. \n */\nstatic gboolean\nmono_type_is_enum_type (MonoType *type)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype)\n\t\treturn TRUE;\n\tif (type->type == MONO_TYPE_GENERICINST && type->data.generic_class->container_class->enumtype)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n/*\n * mono_type_is_value_type:\n * \n * Returns TRUE if @type is named after @namespace.@name.\n * \n */\nstatic gboolean\nmono_type_is_value_type (MonoType *type, const char *namespace, const char *name)\n{\n\treturn type->type == MONO_TYPE_VALUETYPE &&\n\t\t!strcmp (namespace, type->data.klass->name_space) &&\n\t\t!strcmp (name, type->data.klass->name);\n}\n\n/*\n * Returns TURE if @type is VAR or MVAR\n */\nstatic gboolean\nmono_type_is_generic_argument (MonoType *type)\n{\n\treturn type->type == MONO_TYPE_VAR || type->type == MONO_TYPE_MVAR;\n}\n\n/*\n * mono_type_get_underlying_type_any:\n * \n * This functions is just like mono_type_get_underlying_type but it doesn't care if the type is byref.\n * \n * Returns the underlying type of @type regardless if it is byref or not.\n */\nstatic MonoType*\nmono_type_get_underlying_type_any (MonoType *type)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype)\n\t\treturn mono_class_enum_basetype (type->data.klass);\n\tif (type->type == MONO_TYPE_GENERICINST && type->data.generic_class->container_class->enumtype)\n\t\treturn mono_class_enum_basetype (type->data.generic_class->container_class);\n\treturn type;\n}\n\nstatic const char*\nmono_type_get_stack_name (MonoType *type)\n{\n\treturn type_names [get_stack_type (type) & TYPE_MASK];\n}\n\n#define CTOR_REQUIRED_FLAGS (METHOD_ATTRIBUTE_SPECIAL_NAME | METHOD_ATTRIBUTE_RT_SPECIAL_NAME)\n#define CTOR_INVALID_FLAGS (METHOD_ATTRIBUTE_STATIC)\n\nstatic gboolean\nmono_method_is_constructor (MonoMethod *method) \n{\n\treturn ((method->flags & CTOR_REQUIRED_FLAGS) == CTOR_REQUIRED_FLAGS &&\n\t\t\t!(method->flags & CTOR_INVALID_FLAGS) &&\n\t\t\t!strcmp (\".ctor\", method->name));\n}\n\nstatic gboolean\nmono_class_has_default_constructor (MonoClass *klass)\n{\n\tMonoMethod *method;\n\tint i;\n\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tmethod = klass->methods [i];\n\t\tif (mono_method_is_constructor (method) &&\n\t\t\tmono_method_signature (method) &&\n\t\t\tmono_method_signature (method)->param_count == 0 &&\n\t\t\t(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nmono_class_interface_implements_interface (MonoClass *candidate, MonoClass *iface)\n{\n\tMonoError error;\n\tint i;\n\tdo {\n\t\tif (candidate == iface)\n\t\t\treturn TRUE;\n\t\tmono_class_setup_interfaces (candidate, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < candidate->interface_count; ++i) {\n\t\t\tif (candidate->interfaces [i] == iface || mono_class_interface_implements_interface (candidate->interfaces [i], iface))\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tcandidate = candidate->parent;\n\t} while (candidate);\n\treturn FALSE;\n}\n\n/*\n * Verify if @type is valid for the given @ctx verification context.\n * this function checks for VAR and MVAR types that are invalid under the current verifier,\n */\nstatic gboolean\nmono_type_is_valid_type_in_context (MonoType *type, MonoGenericContext *context)\n{\n\tint i;\n\tMonoGenericInst *inst;\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tif (!context)\n\t\t\treturn FALSE;\n\t\tinst = type->type == MONO_TYPE_VAR ? context->class_inst : context->method_inst;\n\t\tif (!inst || mono_type_get_generic_param_num (type) >= inst->type_argc)\n\t\t\treturn FALSE;\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn mono_type_is_valid_type_in_context (&type->data.klass->byval_arg, context);\n\tcase MONO_TYPE_ARRAY:\n\t\treturn mono_type_is_valid_type_in_context (&type->data.array->eklass->byval_arg, context);\n\tcase MONO_TYPE_PTR:\n\t\treturn mono_type_is_valid_type_in_context (type->data.type, context);\n\tcase MONO_TYPE_GENERICINST:\n\t\tinst = type->data.generic_class->context.class_inst;\n\t\tif (!inst->is_open)\n\t\t\tbreak;\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tif (!mono_type_is_valid_type_in_context (inst->type_argv [i], context))\n\t\t\t\treturn FALSE;\n\t\tbreak;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *klass = type->data.klass;\n\t\t/*\n\t\t * It's possible to encode generic'sh types in such a way that they disguise themselves as class or valuetype.\n\t\t * Fixing the type decoding is really tricky since under some cases this behavior is needed, for example, to\n\t\t * have a 'class' type pointing to a 'genericinst' class.\n\t\t *\n\t\t * For the runtime these non canonical (weird) encodings work fine, they worst they can cause is some\n\t\t * reflection oddities which are harmless  - to security at least.\n\t\t */\n\t\tif (klass->byval_arg.type != type->type)\n\t\t\treturn mono_type_is_valid_type_in_context (&klass->byval_arg, context);\n\t\tbreak;\n\t}\n\t}\n\treturn TRUE;\n}\n\n/*This function returns NULL if the type is not instantiatable*/\nstatic MonoType*\nverifier_inflate_type (VerifyContext *ctx, MonoType *type, MonoGenericContext *context)\n{\n\tMonoError error;\n\tMonoType *result;\n\n\tresult = mono_class_inflate_generic_type_checked (type, context, &error);\n\tif (!mono_error_ok (&error)) {\n\t\tmono_error_cleanup (&error);\n\t\treturn NULL;\n\t}\n\treturn result;\n}\n/*\n * Test if @candidate is a subtype of @target using the minimal possible information\n * TODO move the code for non finished TypeBuilders to here.\n */\nstatic gboolean\nmono_class_is_constraint_compatible (MonoClass *candidate, MonoClass *target)\n{\n\tif (candidate == target)\n\t\treturn TRUE;\n\tif (target == mono_defaults.object_class)\n\t\t\treturn TRUE;\n\n\t//setup_supertypes don't mono_class_init anything\n\tmono_class_setup_supertypes (candidate);\n\tmono_class_setup_supertypes (target);\n\n\tif (mono_class_has_parent (candidate, target))\n\t\treturn TRUE;\n\n\t//if target is not a supertype it must be an interface\n\tif (!MONO_CLASS_IS_INTERFACE (target))\n\t\t\treturn FALSE;\n\n\tif (candidate->image->dynamic && !candidate->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = candidate->reflection_info;\n\t\tint j;\n\t\tif (tb->interfaces) {\n\t\t\tfor (j = mono_array_length (tb->interfaces) - 1; j >= 0; --j) {\n\t\t\t\tMonoReflectionType *iface = mono_array_get (tb->interfaces, MonoReflectionType*, j);\n\t\t\t\tMonoClass *ifaceClass = mono_class_from_mono_type (iface->type);\n\t\t\t\tif (mono_class_is_constraint_compatible (ifaceClass, target)) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn mono_class_interface_implements_interface (candidate, target);\n}\n\nstatic gboolean\nis_valid_generic_instantiation (MonoGenericContainer *gc, MonoGenericContext *context, MonoGenericInst *ginst)\n{\n\tMonoError error;\n\tint i;\n\n\tif (ginst->type_argc != gc->type_argc)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < gc->type_argc; ++i) {\n\t\tMonoGenericParamInfo *param_info = mono_generic_container_get_param_info (gc, i);\n\t\tMonoClass *paramClass;\n\t\tMonoClass **constraints;\n\n\t\tif (!param_info->constraints && !(param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK))\n\t\t\tcontinue;\n\t\tif (mono_type_is_generic_argument (ginst->type_argv [i]))\n\t\t\tcontinue; //it's not our job to validate type variables\n\n\t\tparamClass = mono_class_from_mono_type (ginst->type_argv [i]);\n\n\t\tif (paramClass->exception_type != MONO_EXCEPTION_NONE)\n\t\t\treturn FALSE;\n\n\t\t/*it's not safe to call mono_class_init from here*/\n\t\tif (paramClass->generic_class && !paramClass->inited) {\n\t\t\tif (!mono_class_is_valid_generic_instantiation (NULL, paramClass))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_VALUE_TYPE_CONSTRAINT) && (!paramClass->valuetype || mono_class_is_nullable (paramClass)))\n\t\t\treturn FALSE;\n\n\t\tif ((param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT) && paramClass->valuetype)\n\t\t\treturn FALSE;\n\n\t\tif ((param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_CONSTRUCTOR_CONSTRAINT) && !paramClass->valuetype && !mono_class_has_default_constructor (paramClass))\n\t\t\treturn FALSE;\n\n\t\tif (!param_info->constraints)\n\t\t\tcontinue;\n\n\t\tfor (constraints = param_info->constraints; *constraints; ++constraints) {\n\t\t\tMonoClass *ctr = *constraints;\n\t\t\tMonoType *inflated;\n\n\t\t\tinflated = mono_class_inflate_generic_type_checked (&ctr->byval_arg, context, &error);\n\t\t\tif (!mono_error_ok (&error)) {\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tctr = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\n\t\t\tif (!mono_class_is_constraint_compatible (paramClass, ctr))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * Return true if @candidate is constraint compatible with @target.\n * \n * This means that @candidate constraints are a super set of @target constaints\n */\nstatic gboolean\nmono_generic_param_is_constraint_compatible (VerifyContext *ctx, MonoGenericParam *target, MonoGenericParam *candidate, MonoClass *candidate_param_class, MonoGenericContext *context)\n{\n\tMonoGenericParamInfo *tinfo = mono_generic_param_info (target);\n\tMonoGenericParamInfo *cinfo = mono_generic_param_info (candidate);\n\n\tint tmask = tinfo->flags & GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK;\n\tint cmask = cinfo->flags & GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK;\n\tif ((tmask & cmask) != tmask)\n\t\treturn FALSE;\n\n\tif (tinfo->constraints) {\n\t\tMonoClass **target_class, **candidate_class;\n\t\tfor (target_class = tinfo->constraints; *target_class; ++target_class) {\n\t\t\tMonoClass *tc;\n\t\t\tMonoType *inflated = verifier_inflate_type (ctx, &(*target_class)->byval_arg, context);\n\t\t\tif (!inflated)\n\t\t\t\treturn FALSE;\n\t\t\ttc = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\n\t\t\t/*\n\t\t\t * A constraint from @target might inflate into @candidate itself and in that case we don't need\n\t\t\t * check it's constraints since it satisfy the constraint by itself.\n\t\t\t */\n\t\t\tif (mono_metadata_type_equal (&tc->byval_arg, &candidate_param_class->byval_arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!cinfo->constraints)\n\t\t\t\treturn FALSE;\n\n\t\t\tfor (candidate_class = cinfo->constraints; *candidate_class; ++candidate_class) {\n\t\t\t\tMonoClass *cc;\n\t\t\t\tinflated = verifier_inflate_type (ctx, &(*candidate_class)->byval_arg, ctx->generic_context);\n\t\t\t\tif (!inflated)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tcc = mono_class_from_mono_type (inflated);\n\t\t\t\tmono_metadata_free_type (inflated);\n\n\t\t\t\tif (mono_class_is_assignable_from (tc, cc))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*candidate_class)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nstatic MonoGenericParam*\nverifier_get_generic_param_from_type (VerifyContext *ctx, MonoType *type)\n{\n\tMonoGenericContainer *gc;\n\tMonoMethod *method = ctx->method;\n\tint num;\n\n\tnum = mono_type_get_generic_param_num (type);\n\n\tif (type->type == MONO_TYPE_VAR) {\n\t\tMonoClass *gtd = method->klass;\n\t\tif (gtd->generic_class)\n\t\t\tgtd = gtd->generic_class->container_class;\n\t\tgc = gtd->generic_container;\n\t} else { //MVAR\n\t\tMonoMethod *gmd = method;\n\t\tif (method->is_inflated)\n\t\t\tgmd = ((MonoMethodInflated*)method)->declaring;\n\t\tgc = mono_method_get_generic_container (gmd);\n\t}\n\tif (!gc)\n\t\treturn FALSE;\n\treturn mono_generic_container_get_param (gc, num);\n}\n\n\n\n/*\n * Verify if @type is valid for the given @ctx verification context.\n * this function checks for VAR and MVAR types that are invalid under the current verifier,\n * This means that it either \n */\nstatic gboolean\nis_valid_type_in_context (VerifyContext *ctx, MonoType *type)\n{\n\treturn mono_type_is_valid_type_in_context (type, ctx->generic_context);\n}\n\nstatic gboolean\nis_valid_generic_instantiation_in_context (VerifyContext *ctx, MonoGenericInst *ginst)\n{\n\tint i;\n\tfor (i = 0; i < ginst->type_argc; ++i) {\n\t\tMonoType *type = ginst->type_argv [i];\n\t\tif (!is_valid_type_in_context (ctx, type))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\ngeneric_arguments_respect_constraints (VerifyContext *ctx, MonoGenericContainer *gc, MonoGenericContext *context, MonoGenericInst *ginst)\n{\n\tint i;\n\tfor (i = 0; i < ginst->type_argc; ++i) {\n\t\tMonoType *type = ginst->type_argv [i];\n\t\tMonoGenericParam *target = mono_generic_container_get_param (gc, i);\n\t\tMonoGenericParam *candidate;\n\t\tMonoClass *candidate_class;\n\n\t\tif (!mono_type_is_generic_argument (type))\n\t\t\tcontinue;\n\n\t\tif (!is_valid_type_in_context (ctx, type))\n\t\t\treturn FALSE;\n\n\t\tcandidate = verifier_get_generic_param_from_type (ctx, type);\n\t\tcandidate_class = mono_class_from_mono_type (type);\n\n\t\tif (!mono_generic_param_is_constraint_compatible (ctx, target, candidate, candidate_class, context))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nmono_method_repect_method_constraints (VerifyContext *ctx, MonoMethod *method)\n{\n\tMonoMethodInflated *gmethod = (MonoMethodInflated *)method;\n\tMonoGenericInst *ginst = gmethod->context.method_inst;\n\tMonoGenericContainer *gc = mono_method_get_generic_container (gmethod->declaring);\n\treturn !gc || generic_arguments_respect_constraints (ctx, gc, &gmethod->context, ginst);\n}\n\nstatic gboolean\nmono_class_repect_method_constraints (VerifyContext *ctx, MonoClass *klass)\n{\n\tMonoGenericClass *gklass = klass->generic_class;\n\tMonoGenericInst *ginst = gklass->context.class_inst;\n\tMonoGenericContainer *gc = gklass->container_class->generic_container;\n\treturn !gc || generic_arguments_respect_constraints (ctx, gc, &gklass->context, ginst);\n}\n\nstatic gboolean\nmono_method_is_valid_generic_instantiation (VerifyContext *ctx, MonoMethod *method)\n{\n\tMonoMethodInflated *gmethod = (MonoMethodInflated *)method;\n\tMonoGenericInst *ginst = gmethod->context.method_inst;\n\tMonoGenericContainer *gc = mono_method_get_generic_container (gmethod->declaring);\n\tif (!gc) /*non-generic inflated method - it's part of a generic type  */\n\t\treturn TRUE;\n\tif (ctx && !is_valid_generic_instantiation_in_context (ctx, ginst))\n\t\treturn FALSE;\n\treturn is_valid_generic_instantiation (gc, &gmethod->context, ginst);\n\n}\n\nstatic gboolean\nmono_class_is_valid_generic_instantiation (VerifyContext *ctx, MonoClass *klass)\n{\n\tMonoGenericClass *gklass = klass->generic_class;\n\tMonoGenericInst *ginst = gklass->context.class_inst;\n\tMonoGenericContainer *gc = gklass->container_class->generic_container;\n\tif (ctx && !is_valid_generic_instantiation_in_context (ctx, ginst))\n\t\treturn FALSE;\n\treturn is_valid_generic_instantiation (gc, &gklass->context, ginst);\n}\n\nstatic gboolean\nmono_type_is_valid_in_context (VerifyContext *ctx, MonoType *type)\n{\n\tMonoClass *klass;\n\n\tif (type == NULL) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid null type at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn FALSE;\n\t}\n\n\tif (!is_valid_type_in_context (ctx, type)) {\n\t\tchar *str = mono_type_full_name (type);\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic type (%s%s) (argument out of range or %s is not generic) at 0x%04x\",\n\t\t\ttype->type == MONO_TYPE_VAR ? \"!\" : \"!!\",\n\t\t\tstr,\n\t\t\ttype->type == MONO_TYPE_VAR ? \"class\" : \"method\",\n\t\t\tctx->ip_offset),\n\t\t\tMONO_EXCEPTION_BAD_IMAGE);\t\t\n\t\tg_free (str);\n\t\treturn FALSE;\n\t}\n\n\tklass = mono_class_from_mono_type (type);\n\tmono_class_init (klass);\n\tif (mono_loader_get_last_error () || klass->exception_type != MONO_EXCEPTION_NONE) {\n\t\tif (klass->generic_class && !mono_class_is_valid_generic_instantiation (NULL, klass))\n\t\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic instantiation of type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\telse\n\t\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Could not load type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\tif (klass->generic_class && klass->generic_class->container_class->exception_type != MONO_EXCEPTION_NONE) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Could not load type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\tif (!klass->generic_class)\n\t\treturn TRUE;\n\n\tif (!mono_class_is_valid_generic_instantiation (ctx, klass)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic type instantiation of type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\tif (!mono_class_repect_method_constraints (ctx, klass)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic type instantiation of type %s.%s (generic args don't respect target's constraints) at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic verify_result_t\nmono_method_is_valid_in_context (VerifyContext *ctx, MonoMethod *method)\n{\n\tif (!mono_type_is_valid_in_context (ctx, &method->klass->byval_arg))\n\t\treturn RESULT_INVALID;\n\n\tif (!method->is_inflated)\n\t\treturn RESULT_VALID;\n\n\tif (!mono_method_is_valid_generic_instantiation (ctx, method)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic method instantiation of method %s.%s::%s at 0x%04x\", method->klass->name_space, method->klass->name, method->name, ctx->ip_offset), MONO_EXCEPTION_UNVERIFIABLE_IL);\n\t\treturn RESULT_INVALID;\n\t}\n\n\tif (!mono_method_repect_method_constraints (ctx, method)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid generic method instantiation of method %s.%s::%s (generic args don't respect target's constraints) at 0x%04x\", method->klass->name_space, method->klass->name, method->name, ctx->ip_offset));\n\t\treturn RESULT_UNVERIFIABLE;\n\t}\n\treturn RESULT_VALID;\n}\n\n\t\nstatic MonoClassField*\nverifier_load_field (VerifyContext *ctx, int token, MonoClass **out_klass, const char *opcode) {\n\tMonoClassField *field;\n\tMonoClass *klass = NULL;\n\n\tif (!IS_FIELD_DEF_OR_REF (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid field token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tfield = mono_field_from_token (ctx->image, token, &klass, ctx->generic_context);\n\tif (!field || !field->parent || !klass) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Cannot load field from token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tif (!mono_type_is_valid_in_context (ctx, &klass->byval_arg))\n\t\treturn NULL;\n\n\t*out_klass = klass;\n\treturn field;\n}\n\nstatic MonoMethod*\nverifier_load_method (VerifyContext *ctx, int token, const char *opcode) {\n\tMonoMethod* method;\n\t\n\tif (!IS_METHOD_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid method token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tmethod = mono_get_method_full (ctx->image, token, NULL, ctx->generic_context);\n\n\tif (!method) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Cannot load method from token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\t\n\tif (mono_method_is_valid_in_context (ctx, method) == RESULT_INVALID)\n\t\treturn NULL;\n\n\treturn method;\n}\n\nstatic MonoType*\nverifier_load_type (VerifyContext *ctx, int token, const char *opcode) {\n\tMonoType* type;\n\t\n\tif (!IS_TYPE_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid type token 0x%08x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\ttype = mono_type_get_full (ctx->image, token, ctx->generic_context);\n\n\tif (!type) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Cannot load type from token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tif (!mono_type_is_valid_in_context (ctx, type))\n\t\treturn NULL;\n\n\treturn type;\n}\n\n\n/* stack_slot_get_type:\n * \n * Returns the stack type of @value. This value includes POINTER_MASK.\n * \n * Use this function to checks that account for a managed pointer.\n */\nstatic gint32\nstack_slot_get_type (ILStackDesc *value)\n{\n\treturn value->stype & RAW_TYPE_MASK;\n}\n\n/* stack_slot_get_underlying_type:\n * \n * Returns the stack type of @value. This value does not include POINTER_MASK.\n * \n * Use this function is cases where the fact that the value could be a managed pointer is\n * irrelevant. For example, field load doesn't care about this fact of type on stack.\n */\nstatic gint32\nstack_slot_get_underlying_type (ILStackDesc *value)\n{\n\treturn value->stype & TYPE_MASK;\n}\n\n/* stack_slot_is_managed_pointer:\n * \n * Returns TRUE is @value is a managed pointer.\n */\nstatic gboolean\nstack_slot_is_managed_pointer (ILStackDesc *value)\n{\n\treturn (value->stype & POINTER_MASK) == POINTER_MASK;\n}\n\n/* stack_slot_is_managed_mutability_pointer:\n * \n * Returns TRUE is @value is a managed mutability pointer.\n */\nstatic G_GNUC_UNUSED gboolean\nstack_slot_is_managed_mutability_pointer (ILStackDesc *value)\n{\n\treturn (value->stype & CMMP_MASK) == CMMP_MASK;\n}\n\n/* stack_slot_is_null_literal:\n * \n * Returns TRUE is @value is the null literal.\n */\nstatic gboolean\nstack_slot_is_null_literal (ILStackDesc *value)\n{\n\treturn (value->stype & NULL_LITERAL_MASK) == NULL_LITERAL_MASK;\n}\n\n\n/* stack_slot_is_this_pointer:\n * \n * Returns TRUE is @value is the this literal\n */\nstatic gboolean\nstack_slot_is_this_pointer (ILStackDesc *value)\n{\n\treturn (value->stype & THIS_POINTER_MASK) == THIS_POINTER_MASK;\n}\n\n/* stack_slot_is_boxed_value:\n * \n * Returns TRUE is @value is a boxed value\n */\nstatic gboolean\nstack_slot_is_boxed_value (ILStackDesc *value)\n{\n\treturn (value->stype & BOXED_MASK) == BOXED_MASK;\n}\n\nstatic const char *\nstack_slot_get_name (ILStackDesc *value)\n{\n\treturn type_names [value->stype & TYPE_MASK];\n}\n\n#define APPEND_WITH_PREDICATE(PRED,NAME) do {\\\n\tif (PRED (value)) { \\\n\t\tif (!first) \\\n\t\t\tg_string_append (str, \", \"); \\\n\t\tg_string_append (str, NAME); \\\n\t\tfirst = FALSE; \\\n\t} } while (0)\n\nstatic char*\nstack_slot_stack_type_full_name (ILStackDesc *value)\n{\n\tGString *str = g_string_new (\"\");\n\tchar *result;\n\tgboolean has_pred = FALSE, first = TRUE;\n\n\tif ((value->stype & TYPE_MASK) != value->stype) {\n\t\tg_string_append(str, \"[\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_this_pointer, \"this\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_boxed_value, \"boxed\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_null_literal, \"null\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_managed_mutability_pointer, \"cmmp\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_managed_pointer, \"mp\");\n\t\thas_pred = TRUE;\n\t}\n\n\tif (mono_type_is_generic_argument (value->type) && !stack_slot_is_boxed_value (value)) {\n\t\tif (!has_pred)\n\t\t\tg_string_append(str, \"[\");\n\t\tif (!first)\n\t\t\tg_string_append (str, \", \");\n\t\tg_string_append (str, \"unboxed\");\n\t\thas_pred = TRUE;\n\t}\n\n\tif (has_pred)\n\t\tg_string_append(str, \"] \");\n\n\tg_string_append (str, stack_slot_get_name (value));\n\tresult = str->str;\n\tg_string_free (str, FALSE);\n\treturn result;\n}\n\nstatic char*\nstack_slot_full_name (ILStackDesc *value)\n{\n\tchar *type_name = mono_type_full_name (value->type);\n\tchar *stack_name = stack_slot_stack_type_full_name (value);\n\tchar *res = g_strdup_printf (\"%s (%s)\", type_name, stack_name);\n\tg_free (type_name);\n\tg_free (stack_name);\n\treturn res;\n}\n\n//////////////////////////////////////////////////////////////////\nvoid\nmono_free_verify_list (GSList *list)\n{\n\tMonoVerifyInfoExtended *info;\n\tGSList *tmp;\n\n\tfor (tmp = list; tmp; tmp = tmp->next) {\n\t\tinfo = tmp->data;\n\t\tg_free (info->info.message);\n\t\tg_free (info);\n\t}\n\tg_slist_free (list);\n}\n\n#define ADD_ERROR(list,msg)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->info.status = MONO_VERIFY_ERROR;\t\\\n\t\tvinfo->info.message = (msg);\t\\\n\t\t(list) = g_slist_prepend ((list), vinfo);\t\\\n\t} while (0)\n\n#define ADD_WARN(list,code,msg)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->info.status = (code);\t\\\n\t\tvinfo->info.message = (msg);\t\\\n\t\t(list) = g_slist_prepend ((list), vinfo);\t\\\n\t} while (0)\n\nstatic const char\nvalid_cultures[][9] = {\n\t\"ar-SA\", \"ar-IQ\", \"ar-EG\", \"ar-LY\",\n\t\"ar-DZ\", \"ar-MA\", \"ar-TN\", \"ar-OM\",\n\t\"ar-YE\", \"ar-SY\", \"ar-JO\", \"ar-LB\",\n\t\"ar-KW\", \"ar-AE\", \"ar-BH\", \"ar-QA\",\n\t\"bg-BG\", \"ca-ES\", \"zh-TW\", \"zh-CN\",\n\t\"zh-HK\", \"zh-SG\", \"zh-MO\", \"cs-CZ\",\n\t\"da-DK\", \"de-DE\", \"de-CH\", \"de-AT\",\n\t\"de-LU\", \"de-LI\", \"el-GR\", \"en-US\",\n\t\"en-GB\", \"en-AU\", \"en-CA\", \"en-NZ\",\n\t\"en-IE\", \"en-ZA\", \"en-JM\", \"en-CB\",\n\t\"en-BZ\", \"en-TT\", \"en-ZW\", \"en-PH\",\n\t\"es-ES-Ts\", \"es-MX\", \"es-ES-Is\", \"es-GT\",\n\t\"es-CR\", \"es-PA\", \"es-DO\", \"es-VE\",\n\t\"es-CO\", \"es-PE\", \"es-AR\", \"es-EC\",\n\t\"es-CL\", \"es-UY\", \"es-PY\", \"es-BO\",\n\t\"es-SV\", \"es-HN\", \"es-NI\", \"es-PR\",\n\t\"Fi-FI\", \"fr-FR\", \"fr-BE\", \"fr-CA\",\n\t\"Fr-CH\", \"fr-LU\", \"fr-MC\", \"he-IL\",\n\t\"hu-HU\", \"is-IS\", \"it-IT\", \"it-CH\",\n\t\"Ja-JP\", \"ko-KR\", \"nl-NL\", \"nl-BE\",\n\t\"nb-NO\", \"nn-NO\", \"pl-PL\", \"pt-BR\",\n\t\"pt-PT\", \"ro-RO\", \"ru-RU\", \"hr-HR\",\n\t\"Lt-sr-SP\", \"Cy-sr-SP\", \"sk-SK\", \"sq-AL\",\n\t\"sv-SE\", \"sv-FI\", \"th-TH\", \"tr-TR\",\n\t\"ur-PK\", \"id-ID\", \"uk-UA\", \"be-BY\",\n\t\"sl-SI\", \"et-EE\", \"lv-LV\", \"lt-LT\",\n\t\"fa-IR\", \"vi-VN\", \"hy-AM\", \"Lt-az-AZ\",\n\t\"Cy-az-AZ\",\n\t\"eu-ES\", \"mk-MK\", \"af-ZA\",\n\t\"ka-GE\", \"fo-FO\", \"hi-IN\", \"ms-MY\",\n\t\"ms-BN\", \"kk-KZ\", \"ky-KZ\", \"sw-KE\",\n\t\"Lt-uz-UZ\", \"Cy-uz-UZ\", \"tt-TA\", \"pa-IN\",\n\t\"gu-IN\", \"ta-IN\", \"te-IN\", \"kn-IN\",\n\t\"mr-IN\", \"sa-IN\", \"mn-MN\", \"gl-ES\",\n\t\"kok-IN\", \"syr-SY\", \"div-MV\"\n};\n\nstatic int\nis_valid_culture (const char *cname)\n{\n\tint i;\n\tint found;\n\n\tfound = *cname == 0;\n\tfor (i = 0; i < G_N_ELEMENTS (valid_cultures); ++i) {\n\t\tif (g_ascii_strcasecmp (valid_cultures [i], cname)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\nstatic int\nis_valid_assembly_flags (guint32 flags) {\n\t/* Metadata: 22.1.2 */\n\tflags &= ~(0x8000 | 0x4000); /* ignore reserved bits 0x0030? */\n\treturn ((flags == 1) || (flags == 0));\n}\n\nstatic int\nis_valid_blob (MonoImage *image, guint32 blob_index, int notnull)\n{\n\tguint32 size;\n\tconst char *p, *blob_end;\n\n\tif (blob_index >= image->heap_blob.size)\n\t\treturn 0;\n\tp = mono_metadata_blob_heap (image, blob_index);\n\tsize = mono_metadata_decode_blob_size (p, &blob_end);\n\tif (blob_index + size + (blob_end-p) > image->heap_blob.size)\n\t\treturn 0;\n\tif (notnull && !size)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic const char*\nis_valid_string (MonoImage *image, guint32 str_index, int notnull)\n{\n\tconst char *p, *blob_end, *res;\n\n\tif (str_index >= image->heap_strings.size)\n\t\treturn NULL;\n\tres = p = mono_metadata_string_heap (image, str_index);\n\tblob_end = mono_metadata_string_heap (image, image->heap_strings.size - 1);\n\tif (notnull && !*p)\n\t\treturn 0;\n\t/* \n\t * FIXME: should check it's a valid utf8 string, too.\n\t */\n\twhile (p <= blob_end) {\n\t\tif (!*p)\n\t\t\treturn res;\n\t\t++p;\n\t}\n\treturn *p? NULL: res;\n}\n\nstatic int\nis_valid_cls_ident (const char *p)\n{\n\t/*\n\t * FIXME: we need the full unicode glib support for this.\n\t * Check: http://www.unicode.org/unicode/reports/tr15/Identifier.java\n\t * We do the lame thing for now.\n\t */\n\tif (!isalpha (*p))\n\t\treturn 0;\n\t++p;\n\twhile (*p) {\n\t\tif (!isalnum (*p) && *p != '_')\n\t\t\treturn 0;\n\t\t++p;\n\t}\n\treturn 1;\n}\n\nstatic int\nis_valid_filename (const char *p)\n{\n\tif (!*p)\n\t\treturn 0;\n\treturn strpbrk (p, \"\\\\//:\")? 0: 1;\n}\n\nstatic GSList*\nverify_assembly_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_ASSEMBLY];\n\tguint32 cols [MONO_ASSEMBLY_SIZE];\n\tconst char *p;\n\n\tif (level & MONO_VERIFY_ERROR) {\n\t\tif (t->rows > 1)\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly table may only have 0 or 1 rows\"));\n\t\tmono_metadata_decode_row (t, 0, cols, MONO_ASSEMBLY_SIZE);\n\n\t\tswitch (cols [MONO_ASSEMBLY_HASH_ALG]) {\n\t\tcase ASSEMBLY_HASH_NONE:\n\t\tcase ASSEMBLY_HASH_MD5:\n\t\tcase ASSEMBLY_HASH_SHA1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tADD_ERROR (list, g_strdup_printf (\"Hash algorithm 0x%x unknown\", cols [MONO_ASSEMBLY_HASH_ALG]));\n\t\t}\n\n\t\tif (!is_valid_assembly_flags (cols [MONO_ASSEMBLY_FLAGS]))\n\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid flags in assembly: 0x%x\", cols [MONO_ASSEMBLY_FLAGS]));\n\n\t\tif (!is_valid_blob (image, cols [MONO_ASSEMBLY_PUBLIC_KEY], FALSE))\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly public key is an invalid index\"));\n\n\t\tif (!(p = is_valid_string (image, cols [MONO_ASSEMBLY_NAME], TRUE))) {\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly name is invalid\"));\n\t\t} else {\n\t\t\tif (strpbrk (p, \":\\\\/.\"))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Assembly name `%s' contains invalid chars\", p));\n\t\t}\n\n\t\tif (!(p = is_valid_string (image, cols [MONO_ASSEMBLY_CULTURE], FALSE))) {\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly culture is an invalid index\"));\n\t\t} else {\n\t\t\tif (!is_valid_culture (p))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Assembly culture `%s' is invalid\", p));\n\t\t}\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_assemblyref_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_ASSEMBLYREF];\n\tguint32 cols [MONO_ASSEMBLYREF_SIZE];\n\tconst char *p;\n\tint i;\n\n\tif (level & MONO_VERIFY_ERROR) {\n\t\tfor (i = 0; i < t->rows; ++i) {\n\t\t\tmono_metadata_decode_row (t, i, cols, MONO_ASSEMBLYREF_SIZE);\n\t\t\tif (!is_valid_assembly_flags (cols [MONO_ASSEMBLYREF_FLAGS]))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid flags in assemblyref row %d: 0x%x\", i + 1, cols [MONO_ASSEMBLY_FLAGS]));\n\n\t\t\tif (!is_valid_blob (image, cols [MONO_ASSEMBLYREF_PUBLIC_KEY], FALSE))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef public key in row %d is an invalid index\", i + 1));\n\n\t\t\tif (!(p = is_valid_string (image, cols [MONO_ASSEMBLYREF_CULTURE], FALSE))) {\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef culture in row %d is invalid\", i + 1));\n\t\t\t} else {\n\t\t\t\tif (!is_valid_culture (p))\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef culture `%s' in row %d is invalid\", p, i + 1));\n\t\t\t}\n\n\t\t\tif (cols [MONO_ASSEMBLYREF_HASH_VALUE] && !is_valid_blob (image, cols [MONO_ASSEMBLYREF_HASH_VALUE], TRUE))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef hash value in row %d is invalid or not null and empty\", i + 1));\n\t\t}\n\t}\n\tif (level & MONO_VERIFY_WARNING) {\n\t\t/* check for duplicated rows */\n\t\tfor (i = 0; i < t->rows; ++i) {\n\t\t}\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_class_layout_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_CLASSLAYOUT];\n\tMonoTableInfo *tdef = &image->tables [MONO_TABLE_TYPEDEF];\n\tguint32 cols [MONO_CLASS_LAYOUT_SIZE];\n\tguint32 value, i;\n\n\tif (level & MONO_VERIFY_ERROR) {\n\t\tfor (i = 0; i < t->rows; ++i) {\n\t\t\tmono_metadata_decode_row (t, i, cols, MONO_CLASS_LAYOUT_SIZE);\n\n\t\t\tif (cols [MONO_CLASS_LAYOUT_PARENT] > tdef->rows || !cols [MONO_CLASS_LAYOUT_PARENT]) {\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent in class layout is invalid in row %d\", i + 1));\n\t\t\t} else {\n\t\t\t\tvalue = mono_metadata_decode_row_col (tdef, cols [MONO_CLASS_LAYOUT_PARENT] - 1, MONO_TYPEDEF_FLAGS);\n\t\t\t\tif (value & TYPE_ATTRIBUTE_INTERFACE)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent in class layout row %d is an interface\", i + 1));\n\t\t\t\tif (value & TYPE_ATTRIBUTE_AUTO_LAYOUT)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent in class layout row %d is AutoLayout\", i + 1));\n\t\t\t\tif (value & TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT) {\n\t\t\t\t\tswitch (cols [MONO_CLASS_LAYOUT_PACKING_SIZE]) {\n\t\t\t\t\tcase 0: case 1: case 2: case 4: case 8: case 16:\n\t\t\t\t\tcase 32: case 64: case 128: break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Packing size %d in class layout row %d is invalid\", cols [MONO_CLASS_LAYOUT_PACKING_SIZE], i + 1));\n\t\t\t\t\t}\n\t\t\t\t} else if (value & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT) {\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: LAMESPEC: it claims it must be 0 (it's 1, instead).\n\t\t\t\t\tif (cols [MONO_CLASS_LAYOUT_PACKING_SIZE])\n\t\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Packing size %d in class layout row %d is invalid with explicit layout\", cols [MONO_CLASS_LAYOUT_PACKING_SIZE], i + 1));\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * FIXME: we need to check that if class size != 0, \n\t\t\t\t * it needs to be greater than the class calculated size.\n\t\t\t\t * If parent is a valuetype it also needs to be smaller than\n\t\t\t\t * 1 MByte (0x100000 bytes).\n\t\t\t\t * To do both these checks we need to load the referenced \n\t\t\t\t * assemblies, though (the spec claims we didn't have to, bah).\n\t\t\t\t */\n\t\t\t\t/* \n\t\t\t\t * We need to check that the parent types have the same layout \n\t\t\t\t * type as well.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\n\treturn list;\n}\n\nstatic GSList*\nverify_constant_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_CONSTANT];\n\tguint32 cols [MONO_CONSTANT_SIZE];\n\tguint32 value, i;\n\tGHashTable *dups = g_hash_table_new (NULL, NULL);\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_CONSTANT_SIZE);\n\n\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\tif (g_hash_table_lookup (dups, GUINT_TO_POINTER (cols [MONO_CONSTANT_PARENT])))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent 0x%08x is duplicated in Constant row %d\", cols [MONO_CONSTANT_PARENT], i + 1));\n\t\tg_hash_table_insert (dups, GUINT_TO_POINTER (cols [MONO_CONSTANT_PARENT]),\n\t\t\t\tGUINT_TO_POINTER (cols [MONO_CONSTANT_PARENT]));\n\n\t\tswitch (cols [MONO_CONSTANT_TYPE]) {\n\t\tcase MONO_TYPE_U1: /* LAMESPEC: it says I1...*/\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_U8:\n\t\t\tif (level & MONO_VERIFY_CLS)\n\t\t\t\tADD_WARN (list, MONO_VERIFY_CLS, g_strdup_printf (\"Type 0x%x not CLS compliant in Constant row %d\", cols [MONO_CONSTANT_TYPE], i + 1));\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_CLASS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type 0x%x is invalid in Constant row %d\", cols [MONO_CONSTANT_TYPE], i + 1));\n\t\t}\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tvalue = cols [MONO_CONSTANT_PARENT] >> MONO_HASCONSTANT_BITS;\n\t\t\tswitch (cols [MONO_CONSTANT_PARENT] & MONO_HASCONSTANT_MASK) {\n\t\t\tcase MONO_HASCONSTANT_FIEDDEF:\n\t\t\t\tif (value > image->tables [MONO_TABLE_FIELD].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent (field) is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_HASCONSTANT_PARAM:\n\t\t\t\tif (value > image->tables [MONO_TABLE_PARAM].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent (param) is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_HASCONSTANT_PROPERTY:\n\t\t\t\tif (value > image->tables [MONO_TABLE_PROPERTY].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent (property) is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (level & MONO_VERIFY_CLS) {\n\t\t\t/* \n\t\t\t * FIXME: verify types is consistent with the enum type\n\t\t\t * is parent is an enum.\n\t\t\t */\n\t\t}\n\t}\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_event_map_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_EVENTMAP];\n\tguint32 cols [MONO_EVENT_MAP_SIZE];\n\tguint32 i, last_event;\n\tGHashTable *dups = g_hash_table_new (NULL, NULL);\n\n\tlast_event = 0;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_EVENT_MAP_SIZE);\n\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\tif (g_hash_table_lookup (dups, GUINT_TO_POINTER (cols [MONO_EVENT_MAP_PARENT])))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent 0x%08x is duplicated in Event Map row %d\", cols [MONO_EVENT_MAP_PARENT], i + 1));\n\t\tg_hash_table_insert (dups, GUINT_TO_POINTER (cols [MONO_EVENT_MAP_PARENT]),\n\t\t\t\tGUINT_TO_POINTER (cols [MONO_EVENT_MAP_PARENT]));\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif (cols [MONO_EVENT_MAP_PARENT] > image->tables [MONO_TABLE_TYPEDEF].rows)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent 0x%08x is invalid in Event Map row %d\", cols [MONO_EVENT_MAP_PARENT], i + 1));\n\t\t\tif (cols [MONO_EVENT_MAP_EVENTLIST] > image->tables [MONO_TABLE_EVENT].rows)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"EventList 0x%08x is invalid in Event Map row %d\", cols [MONO_EVENT_MAP_EVENTLIST], i + 1));\n\n\t\t\tif (cols [MONO_EVENT_MAP_EVENTLIST] <= last_event)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"EventList overlap in Event Map row %d\", i + 1));\n\t\t\tlast_event = cols [MONO_EVENT_MAP_EVENTLIST];\n\t\t}\n\t}\n\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_event_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_EVENT];\n\tguint32 cols [MONO_EVENT_SIZE];\n\tconst char *p;\n\tguint32 value, i;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_EVENT_SIZE);\n\n\t\tif (cols [MONO_EVENT_FLAGS] & ~(EVENT_SPECIALNAME|EVENT_RTSPECIALNAME)) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Flags 0x%04x invalid in Event row %d\", cols [MONO_EVENT_FLAGS], i + 1));\n\t\t}\n\t\tif (!(p = is_valid_string (image, cols [MONO_EVENT_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in Event row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_CLS) {\n\t\t\t\tif (!is_valid_cls_ident (p))\n\t\t\t\t\tADD_WARN (list, MONO_VERIFY_CLS, g_strdup_printf (\"Invalid CLS name '%s` in Event row %d\", p, i + 1));\n\t\t\t}\n\t\t}\n\n\t\tif (level & MONO_VERIFY_ERROR && cols [MONO_EVENT_TYPE]) {\n\t\t\tvalue = cols [MONO_EVENT_TYPE] >> MONO_TYPEDEFORREF_BITS;\n\t\t\tswitch (cols [MONO_EVENT_TYPE] & MONO_TYPEDEFORREF_MASK) {\n\t\t\tcase MONO_TYPEDEFORREF_TYPEDEF:\n\t\t\t\tif (!value || value > image->tables [MONO_TABLE_TYPEDEF].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPEDEFORREF_TYPEREF:\n\t\t\t\tif (!value || value > image->tables [MONO_TABLE_TYPEREF].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPEDEFORREF_TYPESPEC:\n\t\t\t\tif (!value || value > image->tables [MONO_TABLE_TYPESPEC].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * FIXME: check that there is 1 add and remove row in methodsemantics\n\t\t * and 0 or 1 raise and 0 or more other (maybe it's better to check for \n\t\t * these while checking methodsemantics).\n\t\t * check for duplicated names for the same type [ERROR]\n\t\t * check for CLS duplicate names for the same type [CLS]\n\t\t */\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_field_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_FIELD];\n\tguint32 cols [MONO_FIELD_SIZE];\n\tconst char *p;\n\tguint32 i, flags;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_FIELD_SIZE);\n\t\t/*\n\t\t * Check this field has only one owner and that the owner is not \n\t\t * an interface (done in verify_typedef_table() )\n\t\t */\n\t\tflags = cols [MONO_FIELD_FLAGS];\n\t\tswitch (flags & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) {\n\t\tcase FIELD_ATTRIBUTE_COMPILER_CONTROLLED:\n\t\tcase FIELD_ATTRIBUTE_PRIVATE:\n\t\tcase FIELD_ATTRIBUTE_FAM_AND_ASSEM:\n\t\tcase FIELD_ATTRIBUTE_ASSEMBLY:\n\t\tcase FIELD_ATTRIBUTE_FAMILY:\n\t\tcase FIELD_ATTRIBUTE_FAM_OR_ASSEM:\n\t\tcase FIELD_ATTRIBUTE_PUBLIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid access mask in Field row %d\", i + 1));\n\t\t\tbreak;\n\t\t}\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif ((flags & FIELD_ATTRIBUTE_LITERAL) && (flags & FIELD_ATTRIBUTE_INIT_ONLY))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Literal and InitOnly cannot be both set in Field row %d\", i + 1));\n\t\t\tif ((flags & FIELD_ATTRIBUTE_LITERAL) && !(flags & FIELD_ATTRIBUTE_STATIC))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Literal needs also Static set in Field row %d\", i + 1));\n\t\t\tif ((flags & FIELD_ATTRIBUTE_RT_SPECIAL_NAME) && !(flags & FIELD_ATTRIBUTE_SPECIAL_NAME))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"RTSpecialName needs also SpecialName set in Field row %d\", i + 1));\n\t\t\t/*\n\t\t\t * FIXME: check there is only one owner in the respective table.\n\t\t\t * if (flags & FIELD_ATTRIBUTE_HAS_FIELD_MARSHAL)\n\t\t\t * if (flags & FIELD_ATTRIBUTE_HAS_DEFAULT)\n\t\t\t * if (flags & FIELD_ATTRIBUTE_HAS_FIELD_RVA)\n\t\t\t */\n\t\t}\n\t\tif (!(p = is_valid_string (image, cols [MONO_FIELD_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in Field row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_CLS) {\n\t\t\t\tif (!is_valid_cls_ident (p))\n\t\t\t\t\tADD_WARN (list, MONO_VERIFY_CLS, g_strdup_printf (\"Invalid CLS name '%s` in Field row %d\", p, i + 1));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * check signature.\n\t\t * if owner is module needs to be static, access mask needs to be compilercontrolled,\n\t\t * public or private (not allowed in cls mode).\n\t\t * if owner is an enum ...\n\t\t */\n\n\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_file_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_FILE];\n\tguint32 cols [MONO_FILE_SIZE];\n\tconst char *p;\n\tguint32 i;\n\tGHashTable *dups = g_hash_table_new (g_str_hash, g_str_equal);\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_FILE_SIZE);\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif (cols [MONO_FILE_FLAGS] != FILE_CONTAINS_METADATA && cols [MONO_FILE_FLAGS] != FILE_CONTAINS_NO_METADATA)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid flags in File row %d\", i + 1));\n\t\t\tif (!is_valid_blob (image, cols [MONO_FILE_HASH_VALUE], TRUE))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"File hash value in row %d is invalid or not null and empty\", i + 1));\n\t\t}\n\t\tif (!(p = is_valid_string (image, cols [MONO_FILE_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in File row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\t\tif (!is_valid_filename (p))\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name '%s` in File row %d\", p, i + 1));\n\t\t\t\telse if (g_hash_table_lookup (dups, p)) {\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Duplicate name '%s` in File row %d\", p, i + 1));\n\t\t\t\t}\n\t\t\t\tg_hash_table_insert (dups, (gpointer)p, (gpointer)p);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * FIXME: I don't understand what this means:\n\t\t * If this module contains a row in the Assembly table (that is, if this module \"holds the manifest\") \n\t\t * then there shall not be any row in the File table for this module - i.e., no self-reference  [ERROR]\n\t\t */\n\n\t}\n\tif (level & MONO_VERIFY_WARNING) {\n\t\tif (!t->rows && image->tables [MONO_TABLE_EXPORTEDTYPE].rows)\n\t\t\tADD_WARN (list, MONO_VERIFY_WARNING, g_strdup (\"ExportedType table should be empty if File table is empty\"));\n\t}\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_moduleref_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_MODULEREF];\n\tMonoTableInfo *tfile = &image->tables [MONO_TABLE_FILE];\n\tguint32 cols [MONO_MODULEREF_SIZE];\n\tconst char *p, *pf;\n\tguint32 found, i, j, value;\n\tGHashTable *dups = g_hash_table_new (g_str_hash, g_str_equal);\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_MODULEREF_SIZE);\n\t\tif (!(p = is_valid_string (image, cols [MONO_MODULEREF_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in ModuleRef row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\t\tif (!is_valid_filename (p))\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name '%s` in ModuleRef row %d\", p, i + 1));\n\t\t\t\telse if (g_hash_table_lookup (dups, p)) {\n\t\t\t\t\tADD_WARN (list, MONO_VERIFY_WARNING, g_strdup_printf (\"Duplicate name '%s` in ModuleRef row %d\", p, i + 1));\n\t\t\t\t\tg_hash_table_insert (dups, (gpointer)p, (gpointer)p);\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tfor (j = 0; j < tfile->rows; ++j) {\n\t\t\t\t\t\tvalue = mono_metadata_decode_row_col (tfile, j, MONO_FILE_NAME);\n\t\t\t\t\t\tif ((pf = is_valid_string (image, value, TRUE)))\n\t\t\t\t\t\t\tif (strcmp (p, pf) == 0) {\n\t\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found)\n\t\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Name '%s` in ModuleRef row %d doesn't have a match in File table\", p, i + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_standalonesig_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_STANDALONESIG];\n\tguint32 cols [MONO_STAND_ALONE_SIGNATURE_SIZE];\n\tconst char *p;\n\tguint32 i;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_STAND_ALONE_SIGNATURE_SIZE);\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif (!is_valid_blob (image, cols [MONO_STAND_ALONE_SIGNATURE], TRUE)) {\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Signature is invalid in StandAloneSig row %d\", i + 1));\n\t\t\t} else {\n\t\t\t\tp = mono_metadata_blob_heap (image, cols [MONO_STAND_ALONE_SIGNATURE]);\n\t\t\t\t/* FIXME: check it's a valid locals or method sig.*/\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\nGSList*\nmono_image_verify_tables (MonoImage *image, int level)\n{\n\tGSList *error_list = NULL;\n\n\terror_list = verify_assembly_table (image, error_list, level);\n\t/* \n\t * AssemblyOS, AssemblyProcessor, AssemblyRefOs and\n\t * AssemblyRefProcessor should be ignored, \n\t * though we may want to emit a warning, since it should not \n\t * be present in a PE file.\n\t */\n\terror_list = verify_assemblyref_table (image, error_list, level);\n\terror_list = verify_class_layout_table (image, error_list, level);\n\terror_list = verify_constant_table (image, error_list, level);\n\t/*\n\t * cutom attribute, declsecurity \n\t */\n\terror_list = verify_event_map_table (image, error_list, level);\n\terror_list = verify_event_table (image, error_list, level);\n\terror_list = verify_field_table (image, error_list, level);\n\terror_list = verify_file_table (image, error_list, level);\n\terror_list = verify_moduleref_table (image, error_list, level);\n\terror_list = verify_standalonesig_table (image, error_list, level);\n\n\treturn g_slist_reverse (error_list);\n}\n\n#define ADD_INVALID(list,msg)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->status = MONO_VERIFY_ERROR;\t\\\n\t\tvinfo->message = (msg);\t\\\n\t\t(list) = g_slist_prepend ((list), vinfo);\t\\\n\t\t/*G_BREAKPOINT ();*/\t\\\n\t\tgoto invalid_cil;\t\\\n\t} while (0)\n\n#define CHECK_STACK_UNDERFLOW(num)\t\\\n\tdo {\t\\\n\t\tif (cur_stack < (num))\t\\\n\t\t\tADD_INVALID (list, g_strdup_printf (\"Stack underflow at 0x%04x (%d items instead of %d)\", ip_offset, cur_stack, (num)));\t\\\n\t} while (0)\n\n#define CHECK_STACK_OVERFLOW()\t\\\n\tdo {\t\\\n\t\tif (cur_stack >= max_stack)\t\\\n\t\t\tADD_INVALID (list, g_strdup_printf (\"Maxstack exceeded at 0x%04x\", ip_offset));\t\\\n\t} while (0)\n\n\nstatic int\nin_any_block (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_CLAUSE (clause, offset))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * in_any_exception_block:\n * \n * Returns TRUE is @offset is part of any exception clause (filter, handler, catch, finally or fault).\n */\nstatic gboolean\nin_any_exception_block (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn TRUE;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/*\n * is_valid_branch_instruction:\n *\n * Verify if it's valid to perform a branch from @offset to @target.\n * This should be used with br and brtrue/false.\n * It returns 0 if valid, 1 for unverifiable and 2 for invalid.\n * The major diferent from other similiar functions is that branching into a\n * finally/fault block is invalid instead of just unverifiable.  \n */\nstatic int\nis_valid_branch_instruction (MonoMethodHeader *header, guint offset, guint target)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\t/*branching into a finally block is invalid*/\n\t\tif ((clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY || clause->flags == MONO_EXCEPTION_CLAUSE_FAULT) &&\n\t\t\t!MONO_OFFSET_IN_HANDLER (clause, offset) &&\n\t\t\tMONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 2;\n\n\t\tif (clause->try_offset != target && (MONO_OFFSET_IN_CLAUSE (clause, offset) ^ MONO_OFFSET_IN_CLAUSE (clause, target)))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset) ^ MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset) ^ MONO_OFFSET_IN_FILTER (clause, target))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * is_valid_cmp_branch_instruction:\n * \n * Verify if it's valid to perform a branch from @offset to @target.\n * This should be used with binary comparison branching instruction, like beq, bge and similars.\n * It returns 0 if valid, 1 for unverifiable and 2 for invalid.\n * \n * The major diferences from other similar functions are that most errors lead to invalid\n * code and only branching out of finally, filter or fault clauses is unverifiable. \n */\nstatic int\nis_valid_cmp_branch_instruction (MonoMethodHeader *header, guint offset, guint target)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\t/*branching out of a handler or finally*/\n\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_NONE &&\n\t\t\tMONO_OFFSET_IN_HANDLER (clause, offset) &&\n\t\t\t!MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 1;\n\n\t\tif (clause->try_offset != target && (MONO_OFFSET_IN_CLAUSE (clause, offset) ^ MONO_OFFSET_IN_CLAUSE (clause, target)))\n\t\t\treturn 2;\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset) ^ MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 2;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset) ^ MONO_OFFSET_IN_FILTER (clause, target))\n\t\t\treturn 2;\n\t}\n\treturn 0;\n}\n\n/*\n * A leave can't escape a finally block \n */\nstatic int\nis_correct_leave (MonoMethodHeader *header, guint offset, guint target)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY && MONO_OFFSET_IN_HANDLER (clause, offset) && !MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 0;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * A rethrow can't happen outside of a catch handler.\n */\nstatic int\nis_correct_rethrow (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * An endfinally can't happen outside of a finally/fault handler.\n */\nstatic int\nis_correct_endfinally (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset) && (clause->flags == MONO_EXCEPTION_CLAUSE_FAULT || clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n/*\n * An endfilter can only happens inside a filter clause.\n * In non-strict mode filter is allowed inside the handler clause too\n */\nstatic MonoExceptionClause *\nis_correct_endfilter (VerifyContext *ctx, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < ctx->header->num_clauses; ++i) {\n\t\tclause = &ctx->header->clauses [i];\n\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tcontinue;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn clause;\n\t\tif (!IS_STRICT_MODE (ctx) && MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn clause;\n\t}\n\treturn NULL;\n}\n\n\n/*\n * Non-strict endfilter can happens inside a try block or any handler block\n */\nstatic int\nis_unverifiable_endfilter (VerifyContext *ctx, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < ctx->header->num_clauses; ++i) {\n\t\tclause = &ctx->header->clauses [i];\n\t\tif (MONO_OFFSET_IN_CLAUSE (clause, offset))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic gboolean\nis_valid_bool_arg (ILStackDesc *arg)\n{\n\tif (stack_slot_is_managed_pointer (arg) || stack_slot_is_boxed_value (arg) || stack_slot_is_null_literal (arg))\n\t\treturn TRUE;\n\n\n\tswitch (stack_slot_get_underlying_type (arg)) {\n\tcase TYPE_I4:\n\tcase TYPE_I8:\n\tcase TYPE_NATIVE_INT:\n\tcase TYPE_PTR:\n\t\treturn TRUE;\n\tcase TYPE_COMPLEX:\n\t\tg_assert (arg->type);\n\t\tswitch (arg->type->type) {\n\t\tcase MONO_TYPE_CLASS:\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_OBJECT:\n\t\tcase MONO_TYPE_SZARRAY:\n\t\tcase MONO_TYPE_ARRAY:\n\t\tcase MONO_TYPE_FNPTR:\n\t\tcase MONO_TYPE_PTR:\n\t\t\treturn TRUE;\n\t\tcase MONO_TYPE_GENERICINST:\n\t\t\t/*We need to check if the container class\n\t\t\t * of the generic type is a valuetype, iow:\n\t\t\t * is it a \"class Foo<T>\" or a \"struct Foo<T>\"?\n\t\t\t */\n\t\t\treturn !arg->type->data.generic_class->container_class->valuetype;\n\t\t}\n\tdefault:\n\t\treturn FALSE;\n\t}\n}\n\n\n/*Type manipulation helper*/\n\n/*Returns the byref version of the supplied MonoType*/\nstatic MonoType*\nmono_type_get_type_byref (MonoType *type)\n{\n\tif (type->byref)\n\t\treturn type;\n\treturn &mono_class_from_mono_type (type)->this_arg;\n}\n\n\n/*Returns the byval version of the supplied MonoType*/\nstatic MonoType*\nmono_type_get_type_byval (MonoType *type)\n{\n\tif (!type->byref)\n\t\treturn type;\n\treturn &mono_class_from_mono_type (type)->byval_arg;\n}\n\nstatic MonoType*\nmono_type_from_stack_slot (ILStackDesc *slot)\n{\n\tif (stack_slot_is_managed_pointer (slot))\n\t\treturn mono_type_get_type_byref (slot->type);\n\treturn slot->type;\n}\n\n/*Stack manipulation code*/\n\nstatic void\nstack_init (VerifyContext *ctx, ILCodeDesc *state) \n{\n\tif (state->flags & IL_CODE_FLAG_STACK_INITED)\n\t\treturn;\n\tstate->size = 0;\n\tstate->flags |= IL_CODE_FLAG_STACK_INITED;\n\tif (!state->stack)\n\t\tstate->stack = g_new0 (ILStackDesc, ctx->max_stack);\n}\n\nstatic void\nstack_copy (ILCodeDesc *to, ILCodeDesc *from)\n{\n\tto->size = from->size;\n\tmemcpy (to->stack, from->stack, sizeof (ILStackDesc) * from->size);\n}\n\nstatic void\ncopy_stack_value (ILStackDesc *to, ILStackDesc *from)\n{\n\tto->stype = from->stype;\n\tto->type = from->type;\n\tto->method = from->method;\n}\n\nstatic int\ncheck_underflow (VerifyContext *ctx, int size)\n{\n\tif (ctx->eval.size < size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack underflow, required %d, but have %d at 0x%04x\", size, ctx->eval.size, ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\ncheck_overflow (VerifyContext *ctx)\n{\n\tif (ctx->eval.size >= ctx->max_stack) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have stack-depth %d at 0x%04x\", ctx->eval.size + 1, ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*This reject out PTR, FNPTR and TYPEDBYREF*/\nstatic gboolean\ncheck_unmanaged_pointer (VerifyContext *ctx, ILStackDesc *value)\n{\n\tif (stack_slot_get_type (value) == TYPE_PTR) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Unmanaged pointer is not a verifiable type at 0x%04x\", ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*TODO verify if MONO_TYPE_TYPEDBYREF is not allowed here as well.*/\nstatic gboolean\ncheck_unverifiable_type (VerifyContext *ctx, MonoType *type)\n{\n\tif (type->type == MONO_TYPE_PTR || type->type == MONO_TYPE_FNPTR) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Unmanaged pointer is not a verifiable type at 0x%04x\", ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic ILStackDesc *\nstack_push (VerifyContext *ctx)\n{\n\tg_assert (ctx->eval.size < ctx->max_stack);\n\treturn & ctx->eval.stack [ctx->eval.size++];\n}\n\nstatic ILStackDesc *\nstack_push_val (VerifyContext *ctx, int stype, MonoType *type)\n{\n\tILStackDesc *top = stack_push (ctx);\n\ttop->stype = stype;\n\ttop->type = type;\n\treturn top;\n}\n\nstatic ILStackDesc *\nstack_pop (VerifyContext *ctx)\n{\n\tILStackDesc *ret;\n\tg_assert (ctx->eval.size > 0);\t\n\tret = ctx->eval.stack + --ctx->eval.size;\n\tif ((ret->stype & UNINIT_THIS_MASK) == UNINIT_THIS_MASK)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Found use of uninitialized 'this ptr' ref at 0x%04x\", ctx->ip_offset));\n\treturn ret;\n}\n\n/* This function allows to safely pop an unititialized this ptr from\n * the eval stack without marking the method as unverifiable. \n */\nstatic ILStackDesc *\nstack_pop_safe (VerifyContext *ctx)\n{\n\tg_assert (ctx->eval.size > 0);\n\treturn ctx->eval.stack + --ctx->eval.size;\n}\n\nstatic ILStackDesc *\nstack_push_stack_val (VerifyContext *ctx, ILStackDesc *value)\n{\n\tILStackDesc *top = stack_push (ctx);\n\tcopy_stack_value (top, value);\n\treturn top;\n}\n\n/* Returns the MonoType associated with the token, or NULL if it is invalid.\n * \n * A boxable type can be either a reference or value type, but cannot be a byref type or an unmanaged pointer   \n * */\nstatic MonoType*\nget_boxable_mono_type (VerifyContext* ctx, int token, const char *opcode)\n{\n\tMonoType *type;\n\tMonoClass *class;\n\n\tif (!(type = verifier_load_type (ctx, token, opcode)))\n\t\treturn NULL;\n\n\tif (type->byref && type->type != MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of byref type for %s at 0x%04x\", opcode, ctx->ip_offset));\n\t\treturn NULL;\n\t}\n\n\tif (type->type == MONO_TYPE_VOID) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of void type for %s at 0x%04x\", opcode, ctx->ip_offset));\n\t\treturn NULL;\n\t}\n\n\tif (type->type == MONO_TYPE_TYPEDBYREF)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid use of typedbyref for %s at 0x%04x\", opcode, ctx->ip_offset));\n\n\tif (!(class = mono_class_from_mono_type (type)))\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not retrieve type token for %s at 0x%04x\", opcode, ctx->ip_offset));\n\n\tif (class->generic_container && type->type != MONO_TYPE_GENERICINST)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use the generic type definition in a boxable type position for %s at 0x%04x\", opcode, ctx->ip_offset));\t\n\n\tcheck_unverifiable_type (ctx, type);\n\treturn type;\n}\n\n\n/*operation result tables */\n\nstatic const unsigned char bin_op_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_R8, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char add_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_R8, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char sub_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_R8, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_NATIVE_INT | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char int_bin_op_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char shift_op_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_I8, TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char cmp_br_op [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char cmp_br_eq_op [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_I4 | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_I4 | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_I4, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4},\n};\n\nstatic const unsigned char add_ovf_un_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char sub_ovf_un_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_NATIVE_INT | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char bin_ovf_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\n#ifdef MONO_VERIFIER_DEBUG\n\n/*debug helpers */\nstatic void\ndump_stack_value (ILStackDesc *value)\n{\n\tprintf (\"[(%x)(%x)\", value->type->type, value->stype);\n\n\tif (stack_slot_is_this_pointer (value))\n\t\tprintf (\"[this] \");\n\n\tif (stack_slot_is_boxed_value (value))\n\t\tprintf (\"[boxed] \");\n\n\tif (stack_slot_is_null_literal (value))\n\t\tprintf (\"[null] \");\n\n\tif (stack_slot_is_managed_mutability_pointer (value))\n\t\tprintf (\"Controled Mutability MP: \");\n\n\tif (stack_slot_is_managed_pointer (value))\n\t\tprintf (\"Managed Pointer to: \");\n\n\tswitch (stack_slot_get_underlying_type (value)) {\n\t\tcase TYPE_INV:\n\t\t\tprintf (\"invalid type]\"); \n\t\t\treturn;\n\t\tcase TYPE_I4:\n\t\t\tprintf (\"int32]\"); \n\t\t\treturn;\n\t\tcase TYPE_I8:\n\t\t\tprintf (\"int64]\"); \n\t\t\treturn;\n\t\tcase TYPE_NATIVE_INT:\n\t\t\tprintf (\"native int]\"); \n\t\t\treturn;\n\t\tcase TYPE_R8:\n\t\t\tprintf (\"float64]\"); \n\t\t\treturn;\n\t\tcase TYPE_PTR:\n\t\t\tprintf (\"unmanaged pointer]\"); \n\t\t\treturn;\n\t\tcase TYPE_COMPLEX:\n\t\t\tswitch (value->type->type) {\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\t\tprintf (\"complex] (%s)\", value->type->data.klass->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\tprintf (\"complex] (string)\");\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\t\tprintf (\"complex] (object)\");\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_SZARRAY:\n\t\t\t\tprintf (\"complex] (%s [])\", value->type->data.klass->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_ARRAY:\n\t\t\t\tprintf (\"complex] (%s [%d %d %d])\",\n\t\t\t\t\tvalue->type->data.array->eklass->name,\n\t\t\t\t\tvalue->type->data.array->rank,\n\t\t\t\t\tvalue->type->data.array->numsizes,\n\t\t\t\t\tvalue->type->data.array->numlobounds);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_GENERICINST:\n\t\t\t\tprintf (\"complex] (inst of %s )\", value->type->data.generic_class->container_class->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_VAR:\n\t\t\t\tprintf (\"complex] (type generic param !%d - %s) \", value->type->data.generic_param->num, mono_generic_param_info (value->type->data.generic_param)->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_MVAR:\n\t\t\t\tprintf (\"complex] (method generic param !!%d - %s) \", value->type->data.generic_param->num, mono_generic_param_info (value->type->data.generic_param)->name);\n\t\t\t\treturn;\n\t\t\tdefault: {\n\t\t\t\t//should be a boxed value \n\t\t\t\tchar * name = mono_type_full_name (value->type);\n\t\t\t\tprintf (\"complex] %s\", name);\n\t\t\t\tg_free (name);\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tprintf (\"unknown stack %x type]\\n\", value->stype);\n\t\t\tg_assert_not_reached ();\n\t}\n}\n\nstatic void\ndump_stack_state (ILCodeDesc *state) \n{\n\tint i;\n\n\tprintf (\"(%d) \", state->size);\n\tfor (i = 0; i < state->size; ++i)\n\t\tdump_stack_value (state->stack + i);\n\tprintf (\"\\n\");\n}\n#endif\n\n/*Returns TRUE if candidate array type can be assigned to target.\n *Both parameters MUST be of type MONO_TYPE_ARRAY (target->type == MONO_TYPE_ARRAY)\n */\nstatic gboolean\nis_array_type_compatible (MonoType *target, MonoType *candidate)\n{\n\tMonoArrayType *left = target->data.array;\n\tMonoArrayType *right = candidate->data.array;\n\n\tg_assert (target->type == MONO_TYPE_ARRAY);\n\tg_assert (candidate->type == MONO_TYPE_ARRAY);\n\n\tif (left->rank != right->rank)\n\t\treturn FALSE;\n\n\treturn mono_class_is_assignable_from (left->eklass, right->eklass);\n}\n\nstatic int\nget_stack_type (MonoType *type)\n{\n\tint mask = 0;\n\tint type_kind = type->type;\n\tif (type->byref)\n\t\tmask = POINTER_MASK;\n\t/*TODO handle CMMP_MASK */\n\nhandle_enum:\n\tswitch (type_kind) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\treturn TYPE_I4 | mask;\n\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\treturn TYPE_NATIVE_INT | mask;\n\n\t/* FIXME: the spec says that you cannot have a pointer to method pointer, do we need to check this here? */ \n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TYPE_PTR | mask;\n\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\t\treturn TYPE_COMPLEX | mask;\n\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\treturn TYPE_I8 | mask;\n\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\t\treturn TYPE_R8 | mask;\n\n\tcase MONO_TYPE_GENERICINST:\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (mono_type_is_enum_type (type)) {\n\t\t\ttype = mono_type_get_underlying_type_any (type);\n\t\t\tif (!type)\n\t\t\t\treturn FALSE;\n\t\t\ttype_kind = type->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\treturn TYPE_COMPLEX | mask;\n\t\t}\n\n\tdefault:\n\t\treturn TYPE_INV;\n\t}\n}\n\n/* convert MonoType to ILStackDesc format (stype) */\nstatic gboolean\nset_stack_value (VerifyContext *ctx, ILStackDesc *stack, MonoType *type, int take_addr)\n{\n\tint mask = 0;\n\tint type_kind = type->type;\n\n\tif (type->byref || take_addr)\n\t\tmask = POINTER_MASK;\n\t/* TODO handle CMMP_MASK */\n\nhandle_enum:\n\tstack->type = type;\n\n\tswitch (type_kind) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\tstack->stype = TYPE_I4 | mask;\n\t\tbreak;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\tstack->stype = TYPE_NATIVE_INT | mask;\n\t\tbreak;\n\n\t/*FIXME: Do we need to check if it's a pointer to the method pointer? The spec says it' illegal to have that.*/\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tstack->stype = TYPE_PTR | mask;\n\t\tbreak;\n\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR: \n\t\tstack->stype = TYPE_COMPLEX | mask;\n\t\tbreak;\n\t\t\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\tstack->stype = TYPE_I8 | mask;\n\t\tbreak;\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\t\tstack->stype = TYPE_R8 | mask;\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (mono_type_is_enum_type (type)) {\n\t\t\tMonoType *utype = mono_type_get_underlying_type_any (type);\n\t\t\tif (!utype) {\n\t\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not resolve underlying type of %x at %d\", type->type, ctx->ip_offset));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\ttype = utype;\n\t\t\ttype_kind = type->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tstack->stype = TYPE_COMPLEX | mask;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tVERIFIER_DEBUG ( printf (\"unknown type 0x%02x in eval stack type\\n\", type->type); );\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Illegal value set on stack 0x%02x at %d\", type->type, ctx->ip_offset));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/* \n * init_stack_with_value_at_exception_boundary:\n * \n * Initialize the stack and push a given type.\n * The instruction is marked as been on the exception boundary.\n */\nstatic void\ninit_stack_with_value_at_exception_boundary (VerifyContext *ctx, ILCodeDesc *code, MonoClass *klass)\n{\n\tMonoError error;\n\tMonoType *type = mono_class_inflate_generic_type_checked (&klass->byval_arg, ctx->generic_context, &error);\n\n\tif (!mono_error_ok (&error)) {\n\t\tchar *name = mono_type_get_full_name (klass);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid class %s used for exception\", name));\n\t\tg_free (name);\n\t\tmono_error_cleanup (&error);\n\t\treturn;\n\t}\n\n\tif (!ctx->max_stack) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack overflow at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tstack_init (ctx, code);\n\tset_stack_value (ctx, code->stack, type, FALSE);\n\tctx->exception_types = g_slist_prepend (ctx->exception_types, type);\n\tcode->size = 1;\n\tcode->flags |= IL_CODE_FLAG_WAS_TARGET;\n\tif (mono_type_is_generic_argument (type))\n\t\tcode->stack->stype |= BOXED_MASK;\n}\n\n/*Verify if type 'candidate' can be stored in type 'target'.\n * \n * If strict, check for the underlying type and not the verification stack types\n */\nstatic gboolean\nverify_type_compatibility_full (VerifyContext *ctx, MonoType *target, MonoType *candidate, gboolean strict)\n{\n#define IS_ONE_OF3(T, A, B, C) (T == A || T == B || T == C)\n#define IS_ONE_OF2(T, A, B) (T == A || T == B)\n\n\tMonoType *original_candidate = candidate;\n\tVERIFIER_DEBUG ( printf (\"checking type compatibility %s x %s strict %d\\n\", mono_type_full_name (target), mono_type_full_name (candidate), strict); );\n\n \t/*only one is byref */\n\tif (candidate->byref ^ target->byref) {\n\t\t/* converting from native int to byref*/\n\t\tif (get_stack_type (candidate) == TYPE_NATIVE_INT && target->byref) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"using byref native int at 0x%04x\", ctx->ip_offset));\n\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\tstrict |= target->byref;\n\t/*From now on we don't care about byref anymore, so it's ok to discard it here*/\n\tcandidate = mono_type_get_underlying_type_any (candidate);\n\nhandle_enum:\n\tswitch (target->type) {\n\tcase MONO_TYPE_VOID:\n\t\treturn candidate->type == MONO_TYPE_VOID;\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\t\tif (strict)\n\t\t\treturn IS_ONE_OF3 (candidate->type, MONO_TYPE_I1, MONO_TYPE_U1, MONO_TYPE_BOOLEAN);\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\t\tif (strict)\n\t\t\treturn IS_ONE_OF3 (candidate->type, MONO_TYPE_I2, MONO_TYPE_U2, MONO_TYPE_CHAR);\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4: {\n\t\tgboolean is_native_int = IS_ONE_OF2 (candidate->type, MONO_TYPE_I, MONO_TYPE_U);\n\t\tgboolean is_int4 = IS_ONE_OF2 (candidate->type, MONO_TYPE_I4, MONO_TYPE_U4);\n\t\tif (strict)\n\t\t\treturn is_native_int || is_int4;\n\t\treturn is_native_int || get_stack_type (candidate) == TYPE_I4;\n\t}\n\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\treturn IS_ONE_OF2 (candidate->type, MONO_TYPE_I8, MONO_TYPE_U8);\n\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\t\tif (strict)\n\t\t\treturn candidate->type == target->type;\n\t\treturn IS_ONE_OF2 (candidate->type, MONO_TYPE_R4, MONO_TYPE_R8);\n\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U: {\n\t\tgboolean is_native_int = IS_ONE_OF2 (candidate->type, MONO_TYPE_I, MONO_TYPE_U);\n\t\tgboolean is_int4 = IS_ONE_OF2 (candidate->type, MONO_TYPE_I4, MONO_TYPE_U4);\n\t\tif (strict)\n\t\t\treturn is_native_int || is_int4;\n\t\treturn is_native_int || get_stack_type (candidate) == TYPE_I4;\n\t}\n\n\tcase MONO_TYPE_PTR:\n\t\tif (candidate->type != MONO_TYPE_PTR)\n\t\t\treturn FALSE;\n\t\t/* check the underlying type */\n\t\treturn verify_type_compatibility_full (ctx, target->data.type, candidate->data.type, TRUE);\n\n\tcase MONO_TYPE_FNPTR: {\n\t\tMonoMethodSignature *left, *right;\n\t\tif (candidate->type != MONO_TYPE_FNPTR)\n\t\t\treturn FALSE;\n\n\t\tleft = mono_type_get_signature (target);\n\t\tright = mono_type_get_signature (candidate);\n\t\treturn mono_metadata_signature_equal (left, right) && left->call_convention == right->call_convention;\n\t}\n\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoClass *target_klass;\n\t\tMonoClass *candidate_klass;\n\t\tif (mono_type_is_enum_type (target)) {\n\t\t\ttarget = mono_type_get_underlying_type_any (target);\n\t\t\tif (!target)\n\t\t\t\treturn FALSE;\n\t\t\tgoto handle_enum;\n\t\t}\n\t\t/*\n\t\t * VAR / MVAR compatibility must be checked by verify_stack_type_compatibility\n\t\t * to take boxing status into account.\n\t\t */\n\t\tif (mono_type_is_generic_argument (original_candidate))\n\t\t\treturn FALSE;\n\n\t\ttarget_klass = mono_class_from_mono_type (target);\n\t\tcandidate_klass = mono_class_from_mono_type (candidate);\n\t\tif (mono_class_is_nullable (target_klass)) {\n\t\t\tif (!mono_class_is_nullable (candidate_klass))\n\t\t\t\treturn FALSE;\n\t\t\treturn target_klass == candidate_klass;\n\t\t}\n\t\t\n\t\treturn mono_class_is_assignable_from (target_klass, candidate_klass);\n\t}\n\n\tcase MONO_TYPE_STRING:\n\t\treturn candidate->type == MONO_TYPE_STRING;\n\n\tcase MONO_TYPE_CLASS:\n\t\t/*\n\t\t * VAR / MVAR compatibility must be checked by verify_stack_type_compatibility\n\t\t * to take boxing status into account.\n\t\t */\n\t\tif (mono_type_is_generic_argument (original_candidate))\n\t\t\treturn FALSE;\n\n\t\tif (candidate->type == MONO_TYPE_VALUETYPE)\n\t\t\treturn FALSE;\n\n\t\t/* If candidate is an enum it should return true for System.Enum and supertypes.\n\t\t * That's why here we use the original type and not the underlying type.\n\t\t */ \n\t\treturn mono_class_is_assignable_from (target->data.klass, mono_class_from_mono_type (original_candidate));\n\n\tcase MONO_TYPE_OBJECT:\n\t\treturn MONO_TYPE_IS_REFERENCE (candidate);\n\n\tcase MONO_TYPE_SZARRAY: {\n\t\tMonoClass *left;\n\t\tMonoClass *right;\n\t\tif (candidate->type != MONO_TYPE_SZARRAY)\n\t\t\treturn FALSE;\n\n\t\tleft = mono_class_from_mono_type (target)->element_class;\n\t\tright = mono_class_from_mono_type (candidate)->element_class;\n\t\treturn mono_class_is_assignable_from (left, right);\n\t}\n\n\tcase MONO_TYPE_ARRAY:\n\t\tif (candidate->type != MONO_TYPE_ARRAY)\n\t\t\treturn FALSE;\n\t\treturn is_array_type_compatible (target, candidate);\n\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn candidate->type == MONO_TYPE_TYPEDBYREF;\n\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *target_klass;\n\t\tMonoClass *candidate_klass;\n\n\t\tif (candidate->type == MONO_TYPE_CLASS)\n\t\t\treturn FALSE;\n\n\t\ttarget_klass = mono_class_from_mono_type (target);\n\t\tcandidate_klass = mono_class_from_mono_type (candidate);\n\t\tif (target_klass == candidate_klass)\n\t\t\treturn TRUE;\n\t\tif (mono_type_is_enum_type (target)) {\n\t\t\ttarget = mono_type_get_underlying_type_any (target);\n\t\t\tif (!target)\n\t\t\t\treturn FALSE;\n\t\t\tgoto handle_enum;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tcase MONO_TYPE_VAR:\n\t\tif (candidate->type != MONO_TYPE_VAR)\n\t\t\treturn FALSE;\n\t\treturn mono_type_get_generic_param_num (candidate) == mono_type_get_generic_param_num (target);\n\n\tcase MONO_TYPE_MVAR:\n\t\tif (candidate->type != MONO_TYPE_MVAR)\n\t\t\treturn FALSE;\n\t\treturn mono_type_get_generic_param_num (candidate) == mono_type_get_generic_param_num (target);\n\n\tdefault:\n\t\tVERIFIER_DEBUG ( printf (\"unknown store type %d\\n\", target->type); );\n\t\tg_assert_not_reached ();\n\t\treturn FALSE;\n\t}\n\treturn 1;\n#undef IS_ONE_OF3\n#undef IS_ONE_OF2\n}\n\nstatic gboolean\nverify_type_compatibility (VerifyContext *ctx, MonoType *target, MonoType *candidate)\n{\n\treturn verify_type_compatibility_full (ctx, target, candidate, FALSE);\n}\n\n/*\n * Returns the generic param bound to the context been verified.\n * \n */\nstatic MonoGenericParam*\nget_generic_param (VerifyContext *ctx, MonoType *param) \n{\n\tguint16 param_num = mono_type_get_generic_param_num (param);\n\tif (param->type == MONO_TYPE_VAR) {\n\t\tif (!ctx->generic_context->class_inst || ctx->generic_context->class_inst->type_argc <= param_num) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid generic type argument %d\", param_num));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ctx->generic_context->class_inst->type_argv [param_num]->data.generic_param;\n\t}\n\t\n\t/*param must be a MVAR */\n\tif (!ctx->generic_context->method_inst || ctx->generic_context->method_inst->type_argc <= param_num) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid generic method argument %d\", param_num));\n\t\treturn NULL;\n\t}\n\treturn ctx->generic_context->method_inst->type_argv [param_num]->data.generic_param;\n\t\n}\n\nstatic gboolean\nrecursive_boxed_constraint_type_check (VerifyContext *ctx, MonoType *type, MonoClass *constraint_class, int recursion_level)\n{\n\tMonoType *constraint_type = &constraint_class->byval_arg;\n\tif (recursion_level <= 0)\n\t\treturn FALSE;\n\n\tif (verify_type_compatibility_full (ctx, type, mono_type_get_type_byval (constraint_type), FALSE))\n\t\treturn TRUE;\n\n\tif (mono_type_is_generic_argument (constraint_type)) {\n\t\tMonoGenericParam *param = get_generic_param (ctx, constraint_type);\n\t\tMonoClass **class;\n\t\tif (!param)\n\t\t\treturn FALSE;\n\t\tfor (class = mono_generic_param_info (param)->constraints; class && *class; ++class) {\n\t\t\tif (recursive_boxed_constraint_type_check (ctx, type, *class, recursion_level - 1))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * is_compatible_boxed_valuetype:\n * \n * Returns TRUE if @candidate / @stack is a valid boxed valuetype. \n * \n * @type The source type. It it tested to be of the proper type.    \n * @candidate type of the boxed valuetype.\n * @stack stack slot of the boxed valuetype, separate from @candidade since one could be changed before calling this function\n * @strict if TRUE candidate must be boxed compatible to the target type\n * \n */\nstatic gboolean\nis_compatible_boxed_valuetype (VerifyContext *ctx, MonoType *type, MonoType *candidate, ILStackDesc *stack, gboolean strict)\n{\n\tif (!stack_slot_is_boxed_value (stack))\n\t\treturn FALSE;\n\tif (type->byref || candidate->byref)\n\t\treturn FALSE;\n\n\tif (mono_type_is_generic_argument (candidate)) {\n\t\tMonoGenericParam *param = get_generic_param (ctx, candidate);\n\t\tMonoClass **class;\n\t\tif (!param)\n\t\t\treturn FALSE;\n\n\t\tfor (class = mono_generic_param_info (param)->constraints; class && *class; ++class) {\n\t\t\t/*256 should be enough since there can't be more than 255 generic arguments.*/\n\t\t\tif (recursive_boxed_constraint_type_check (ctx, type, *class, 256))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\tif (mono_type_is_generic_argument (type))\n\t\treturn FALSE;\n\n\tif (!strict)\n\t\treturn TRUE;\n\n\treturn MONO_TYPE_IS_REFERENCE (type) && mono_class_is_assignable_from (mono_class_from_mono_type (type), mono_class_from_mono_type (candidate));\n}\n\nstatic int\nverify_stack_type_compatibility_full (VerifyContext *ctx, MonoType *type, ILStackDesc *stack, gboolean drop_byref, gboolean valuetype_must_be_boxed)\n{\n\tMonoType *candidate = mono_type_from_stack_slot (stack);\n\tif (MONO_TYPE_IS_REFERENCE (type) && !type->byref && stack_slot_is_null_literal (stack))\n\t\treturn TRUE;\n\n\tif (is_compatible_boxed_valuetype (ctx, type, candidate, stack, TRUE))\n\t\treturn TRUE;\n\n\tif (valuetype_must_be_boxed && !stack_slot_is_boxed_value (stack) && !MONO_TYPE_IS_REFERENCE (candidate))\n\t\treturn FALSE;\n\n\tif (!valuetype_must_be_boxed && stack_slot_is_boxed_value (stack))\n\t\treturn FALSE;\n\n\tif (drop_byref)\n\t\treturn verify_type_compatibility_full (ctx, type, mono_type_get_type_byval (candidate), FALSE);\n\n\treturn verify_type_compatibility_full (ctx, type, candidate, FALSE);\n}\n\nstatic int\nverify_stack_type_compatibility (VerifyContext *ctx, MonoType *type, ILStackDesc *stack)\n{\n\treturn verify_stack_type_compatibility_full (ctx, type, stack, FALSE, FALSE);\n}\n\nstatic gboolean\nmono_delegate_type_equal (MonoType *target, MonoType *candidate)\n{\n\tif (candidate->byref ^ target->byref)\n\t\treturn FALSE;\n\n\tswitch (target->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn candidate->type == target->type;\n\n\tcase MONO_TYPE_PTR:\n\t\treturn mono_delegate_type_equal (target->data.type, candidate->data.type);\n\n\tcase MONO_TYPE_FNPTR:\n\t\tif (candidate->type != MONO_TYPE_FNPTR)\n\t\t\treturn FALSE;\n\t\treturn mono_delegate_signature_equal (mono_type_get_signature (target), mono_type_get_signature (candidate), FALSE);\n\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoClass *target_klass;\n\t\tMonoClass *candidate_klass;\n\t\ttarget_klass = mono_class_from_mono_type (target);\n\t\tcandidate_klass = mono_class_from_mono_type (candidate);\n\t\t/*FIXME handle nullables and enum*/\n\t\treturn mono_class_is_assignable_from (target_klass, candidate_klass);\n\t}\n\tcase MONO_TYPE_OBJECT:\n\t\treturn MONO_TYPE_IS_REFERENCE (candidate);\n\n\tcase MONO_TYPE_CLASS:\n\t\treturn mono_class_is_assignable_from(target->data.klass, mono_class_from_mono_type (candidate));\n\n\tcase MONO_TYPE_SZARRAY:\n\t\tif (candidate->type != MONO_TYPE_SZARRAY)\n\t\t\treturn FALSE;\n\t\treturn mono_class_is_assignable_from (mono_class_from_mono_type (target)->element_class, mono_class_from_mono_type (candidate)->element_class);\n\n\tcase MONO_TYPE_ARRAY:\n\t\tif (candidate->type != MONO_TYPE_ARRAY)\n\t\t\treturn FALSE;\n\t\treturn is_array_type_compatible (target, candidate);\n\n\tcase MONO_TYPE_VALUETYPE:\n\t\t/*FIXME handle nullables and enum*/\n\t\treturn mono_class_from_mono_type (candidate) == mono_class_from_mono_type (target);\n\n\tcase MONO_TYPE_VAR:\n\t\treturn candidate->type == MONO_TYPE_VAR && mono_type_get_generic_param_num (target) == mono_type_get_generic_param_num (candidate);\n\t\treturn FALSE;\n\n\tcase MONO_TYPE_MVAR:\n\t\treturn candidate->type == MONO_TYPE_MVAR && mono_type_get_generic_param_num (target) == mono_type_get_generic_param_num (candidate);\n\t\treturn FALSE;\n\n\tdefault:\n\t\tVERIFIER_DEBUG ( printf (\"Unknown type %d. Implement me!\\n\", target->type); );\n\t\tg_assert_not_reached ();\n\t\treturn FALSE;\n\t}\n}\n\nstatic gboolean\nmono_delegate_param_equal (MonoType *delegate, MonoType *method)\n{\n\tif (mono_metadata_type_equal_full (delegate, method, TRUE))\n\t\treturn TRUE;\n\n\treturn mono_delegate_type_equal (method, delegate);\n}\n\nstatic gboolean\nmono_delegate_ret_equal (MonoType *delegate, MonoType *method)\n{\n\tif (mono_metadata_type_equal_full (delegate, method, TRUE))\n\t\treturn TRUE;\n\n\treturn mono_delegate_type_equal (delegate, method);\n}\n\n/*\n * mono_delegate_signature_equal:\n * \n * Compare two signatures in the way expected by delegates.\n * \n * This function only exists due to the fact that it should ignore the 'has_this' part of the signature.\n *\n * FIXME can this function be eliminated and proper metadata functionality be used?\n */\nstatic gboolean\nmono_delegate_signature_equal (MonoMethodSignature *delegate_sig, MonoMethodSignature *method_sig, gboolean is_static_ldftn)\n{\n\tint i;\n\tint method_offset = is_static_ldftn ? 1 : 0;\n\n\tif (delegate_sig->param_count + method_offset != method_sig->param_count) \n\t\treturn FALSE;\n\n\tif (delegate_sig->call_convention != method_sig->call_convention)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < delegate_sig->param_count; i++) { \n\t\tMonoType *p1 = delegate_sig->params [i];\n\t\tMonoType *p2 = method_sig->params [i + method_offset];\n\n\t\tif (!mono_delegate_param_equal (p1, p2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!mono_delegate_ret_equal (delegate_sig->ret, method_sig->ret))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/* \n * verify_ldftn_delegate:\n * \n * Verify properties of ldftn based delegates.\n */\nstatic void\nverify_ldftn_delegate (VerifyContext *ctx, MonoClass *delegate, ILStackDesc *value, ILStackDesc *funptr)\n{\n\tMonoMethod *method = funptr->method;\n\n\t/*ldftn non-final virtuals only allowed if method is not static,\n\t * the object is a this arg (comes from a ldarg.0), and there is no starg.0.\n\t * This rules doesn't apply if the object on stack is a boxed valuetype.\n\t */\n\tif ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) && !(method->flags & METHOD_ATTRIBUTE_FINAL) && !(method->klass->flags & TYPE_ATTRIBUTE_SEALED) && !stack_slot_is_boxed_value (value)) {\n\t\t/*A stdarg 0 must not happen, we fail here only in fail fast mode to avoid double error reports*/\n\t\tif (IS_FAIL_FAST_MODE (ctx) && ctx->has_this_store)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid ldftn with virtual function in method with stdarg 0 at  0x%04x\", ctx->ip_offset));\n\n\t\t/*current method must not be static*/\n\t\tif (ctx->method->flags & METHOD_ATTRIBUTE_STATIC)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid ldftn with virtual function at 0x%04x\", ctx->ip_offset));\n\n\t\t/*value is the this pointer, loaded using ldarg.0 */\n\t\tif (!stack_slot_is_this_pointer (value))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid object argument, it is not the this pointer, to ldftn with virtual method at  0x%04x\", ctx->ip_offset));\n\n\t\tctx->code [ctx->ip_offset].flags |= IL_CODE_LDFTN_DELEGATE_NONFINAL_VIRTUAL;\n\t}\n}\n\n/*\n * verify_delegate_compatibility:\n * \n * Verify delegate creation sequence.\n * \n */\nstatic void\nverify_delegate_compatibility (VerifyContext *ctx, MonoClass *delegate, ILStackDesc *value, ILStackDesc *funptr)\n{\n#define IS_VALID_OPCODE(offset, opcode) (ip [ip_offset - offset] == opcode && (ctx->code [ip_offset - offset].flags & IL_CODE_FLAG_SEEN))\n#define IS_LOAD_FUN_PTR(kind) (IS_VALID_OPCODE (6, CEE_PREFIX1) && ip [ip_offset - 5] == kind)\n\n\tMonoMethod *invoke, *method;\n\tconst guint8 *ip = ctx->header->code;\n\tguint32 ip_offset = ctx->ip_offset;\n\tgboolean is_static_ldftn = FALSE, is_first_arg_bound = FALSE;\n\t\n\tif (stack_slot_get_type (funptr) != TYPE_PTR || !funptr->method) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid function pointer parameter for delegate constructor at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\t\n\tinvoke = mono_get_delegate_invoke (delegate);\n\tmethod = funptr->method;\n\n\tif (!method || !mono_method_signature (method)) {\n\t\tchar *name = mono_type_get_full_name (delegate);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid method on stack to create delegate %s construction at 0x%04x\", name, ctx->ip_offset));\n\t\tg_free (name);\n\t\treturn;\n\t}\n\n\tif (!invoke || !mono_method_signature (invoke)) {\n\t\tchar *name = mono_type_get_full_name (delegate);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Delegate type %s with bad Invoke method at 0x%04x\", name, ctx->ip_offset));\n\t\tg_free (name);\n\t\treturn;\n\t}\n\n\tis_static_ldftn = (ip_offset > 5 && IS_LOAD_FUN_PTR (CEE_LDFTN)) && method->flags & METHOD_ATTRIBUTE_STATIC;\n\n\tif (is_static_ldftn)\n\t\tis_first_arg_bound = mono_method_signature (invoke)->param_count + 1 ==  mono_method_signature (method)->param_count;\n\n\tif (!mono_delegate_signature_equal (mono_method_signature (invoke), mono_method_signature (method), is_first_arg_bound)) {\n\t\tchar *fun_sig = mono_signature_get_desc (mono_method_signature (method), FALSE);\n\t\tchar *invoke_sig = mono_signature_get_desc (mono_method_signature (invoke), FALSE);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Function pointer signature '%s' doesn't match delegate's signature '%s' at 0x%04x\", fun_sig, invoke_sig, ctx->ip_offset));\n\t\tg_free (fun_sig);\n\t\tg_free (invoke_sig);\n\t}\n\n\t/* \n\t * Delegate code sequences:\n\t * [-6] ldftn token\n\t * newobj ...\n\t * \n\t * \n\t * [-7] dup\n\t * [-6] ldvirtftn token\n\t * newobj ...\n\t * \n\t * ldftn sequence:*/\n\tif (ip_offset > 5 && IS_LOAD_FUN_PTR (CEE_LDFTN)) {\n\t\tverify_ldftn_delegate (ctx, delegate, value, funptr);\n\t} else if (ip_offset > 6 && IS_VALID_OPCODE (7, CEE_DUP) && IS_LOAD_FUN_PTR (CEE_LDVIRTFTN)) {\n\t\tctx->code [ip_offset - 6].flags |= IL_CODE_DELEGATE_SEQUENCE;\t\n\t}else {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid code sequence for delegate creation at 0x%04x\", ctx->ip_offset));\n\t}\n\tctx->code [ip_offset].flags |= IL_CODE_DELEGATE_SEQUENCE;\n\n\t//general tests\n\tif (is_first_arg_bound) {\n\t\tif (mono_method_signature (method)->param_count == 0 || !verify_stack_type_compatibility_full (ctx, mono_method_signature (method)->params [0], value, FALSE, TRUE))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"This object not compatible with function pointer for delegate creation at 0x%04x\", ctx->ip_offset));\n\t} else {\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (!stack_slot_is_null_literal (value) && !is_first_arg_bound)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Non-null this args used with static function for delegate creation at 0x%04x\", ctx->ip_offset));\n\t\t} else {\n\t\t\tif (!verify_stack_type_compatibility_full (ctx, &method->klass->byval_arg, value, FALSE, TRUE) && !stack_slot_is_null_literal (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"This object not compatible with function pointer for delegate creation at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t}\n\n\tif (stack_slot_get_type (value) != TYPE_COMPLEX)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid first parameter for delegate creation at 0x%04x\", ctx->ip_offset));\n\n#undef IS_VALID_OPCODE\n#undef IS_LOAD_FUN_PTR\n}\n\n/* implement the opcode checks*/\nstatic void\npush_arg (VerifyContext *ctx, unsigned int arg, int take_addr) \n{\n\tILStackDesc *top;\n\n\tif (arg >= ctx->max_args) {\n\t\tif (take_addr) \n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have argument %d\", arg + 1));\n\t\telse {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Method doesn't have argument %d\", arg + 1));\n\t\t\tif (check_overflow (ctx)) //FIXME: what sane value could we ever push?\n\t\t\t\tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t}\n\t} else if (check_overflow (ctx)) {\n\t\t/*We must let the value be pushed, otherwise we would get an underflow error*/\n\t\tcheck_unverifiable_type (ctx, ctx->params [arg]);\n\t\tif (ctx->params [arg]->byref && take_addr)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"ByRef of ByRef at 0x%04x\", ctx->ip_offset));\n\t\ttop = stack_push (ctx);\n\t\tif (!set_stack_value (ctx, top, ctx->params [arg], take_addr))\n\t\t\treturn;\n\n\t\tif (arg == 0 && !(ctx->method->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\t\tif (take_addr)\n\t\t\t\tctx->has_this_store = TRUE;\n\t\t\telse\n\t\t\t\ttop->stype |= THIS_POINTER_MASK;\n\t\t\tif (mono_method_is_constructor (ctx->method) && !ctx->super_ctor_called && !ctx->method->klass->valuetype)\n\t\t\t\ttop->stype |= UNINIT_THIS_MASK;\n\t\t}\n\t} \n}\n\nstatic void\npush_local (VerifyContext *ctx, guint32 arg, int take_addr) \n{\n\tif (arg >= ctx->num_locals) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have local %d\", arg + 1));\n\t} else if (check_overflow (ctx)) {\n\t\t/*We must let the value be pushed, otherwise we would get an underflow error*/\n\t\tcheck_unverifiable_type (ctx, ctx->locals [arg]);\n\t\tif (ctx->locals [arg]->byref && take_addr)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"ByRef of ByRef at 0x%04x\", ctx->ip_offset));\n\n\t\tset_stack_value (ctx, stack_push (ctx), ctx->locals [arg], take_addr);\n\t} \n}\n\nstatic void\nstore_arg (VerifyContext *ctx, guint32 arg)\n{\n\tILStackDesc *value;\n\n\tif (arg >= ctx->max_args) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Method doesn't have argument %d at 0x%04x\", arg + 1, ctx->ip_offset));\n\t\tif (check_underflow (ctx, 1))\n\t\t\tstack_pop (ctx);\n\t\treturn;\n\t}\n\n\tif (check_underflow (ctx, 1)) {\n\t\tvalue = stack_pop (ctx);\n\t\tif (!verify_stack_type_compatibility (ctx, ctx->params [arg], value)) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type %s in argument store at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\t\t}\n\t}\n\tif (arg == 0 && !(ctx->method->flags & METHOD_ATTRIBUTE_STATIC))\n\t\tctx->has_this_store = 1;\n}\n\nstatic void\nstore_local (VerifyContext *ctx, guint32 arg)\n{\n\tILStackDesc *value;\n\tif (arg >= ctx->num_locals) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have local var %d at 0x%04x\", arg + 1, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\t/*TODO verify definite assigment */\t\t\n\tif (check_underflow (ctx, 1)) {\n\t\tvalue = stack_pop(ctx);\n\t\tif (!verify_stack_type_compatibility (ctx, ctx->locals [arg], value)) {\n\t\t\tchar *expected = mono_type_full_name (ctx->locals [arg]);\n\t\t\tchar *found = stack_slot_full_name (value);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type '%s' on stack cannot be stored to local %d with type '%s' at 0x%04x\",\n\t\t\t\t\tfound,\n\t\t\t\t\targ,\n\t\t\t\t\texpected,\n\t\t\t\t\tctx->ip_offset));\n\t\t\tg_free (expected);\n\t\t\tg_free (found);\t\n\t\t}\n\t}\n}\n\n/*FIXME add and sub needs special care here*/\nstatic void\ndo_binop (VerifyContext *ctx, unsigned int opcode, const unsigned char table [TYPE_MAX][TYPE_MAX])\n{\n\tILStackDesc *a, *b, *top;\n\tint idxa, idxb, complexMerge = 0;\n\tunsigned char res;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\tb = stack_pop (ctx);\n\ta = stack_pop (ctx);\n\n\tidxa = stack_slot_get_underlying_type (a);\n\tif (stack_slot_is_managed_pointer (a)) {\n\t\tidxa = TYPE_PTR;\n\t\tcomplexMerge = 1;\n\t}\n\n\tidxb = stack_slot_get_underlying_type (b);\n\tif (stack_slot_is_managed_pointer (b)) {\n\t\tidxb = TYPE_PTR;\n\t\tcomplexMerge = 2;\n\t}\n\n\t--idxa;\n\t--idxb;\n\tres = table [idxa][idxb];\n\n\tVERIFIER_DEBUG ( printf (\"binop res %d\\n\", res); );\n\tVERIFIER_DEBUG ( printf (\"idxa %d idxb %d\\n\", idxa, idxb); );\n\n\ttop = stack_push (ctx);\n\tif (res == TYPE_INV) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Binary instruction applyed to ill formed stack (%s x %s)\", stack_slot_get_name (a), stack_slot_get_name (b)));\n\t\tcopy_stack_value (top, a);\n\t\treturn;\n\t}\n\n \tif (res & NON_VERIFIABLE_RESULT) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Binary instruction is not verifiable (%s x %s)\", stack_slot_get_name (a), stack_slot_get_name (b)));\n\n\t\tres = res & ~NON_VERIFIABLE_RESULT;\n \t}\n\n \tif (complexMerge && res == TYPE_PTR) {\n \t\tif (complexMerge == 1) \n \t\t\tcopy_stack_value (top, a);\n \t\telse if (complexMerge == 2)\n \t\t\tcopy_stack_value (top, b);\n\t\t/*\n\t\t * There is no need to merge the type of two pointers.\n\t\t * The only valid operation is subtraction, that returns a native\n\t\t *  int as result and can be used with any 2 pointer kinds.\n\t\t * This is valid acording to Patition III 1.1.4\n\t\t */\n \t} else\n \t\ttop->stype = res;\n \t\n}\n\n\nstatic void\ndo_boolean_branch_op (VerifyContext *ctx, int delta)\n{\n\tint target = ctx->ip_offset + delta;\n\tILStackDesc *top;\n\n\tVERIFIER_DEBUG ( printf (\"boolean branch offset %d delta %d target %d\\n\", ctx->ip_offset, delta, target); );\n \n\tif (target < 0 || target >= ctx->code_size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Boolean branch target out of code at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tswitch (is_valid_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\tcase 1:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\tcase 2:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tctx->target = target;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\tif (!is_valid_bool_arg (top))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Argument type %s not valid for brtrue/brfalse at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\n\tcheck_unmanaged_pointer (ctx, top);\n}\n\nstatic gboolean\nstack_slot_is_complex_type_not_reference_type (ILStackDesc *slot)\n{\n\treturn stack_slot_get_type (slot) == TYPE_COMPLEX && !MONO_TYPE_IS_REFERENCE (slot->type) && !stack_slot_is_boxed_value (slot);\n}\n\nstatic void\ndo_branch_op (VerifyContext *ctx, signed int delta, const unsigned char table [TYPE_MAX][TYPE_MAX])\n{\n\tILStackDesc *a, *b;\n\tint idxa, idxb;\n\tunsigned char res;\n\tint target = ctx->ip_offset + delta;\n\n\tVERIFIER_DEBUG ( printf (\"branch offset %d delta %d target %d\\n\", ctx->ip_offset, delta, target); );\n \n\tif (target < 0 || target >= ctx->code_size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target out of code at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tswitch (is_valid_cmp_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\tcase 1: /*FIXME use constants and not magic numbers.*/\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\tcase 2:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tctx->target = target;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tb = stack_pop (ctx);\n\ta = stack_pop (ctx);\n\n\tidxa = stack_slot_get_underlying_type (a);\n\tif (stack_slot_is_managed_pointer (a))\n\t\tidxa = TYPE_PTR;\n\n\tidxb = stack_slot_get_underlying_type (b);\n\tif (stack_slot_is_managed_pointer (b))\n\t\tidxb = TYPE_PTR;\n\n\tif (stack_slot_is_complex_type_not_reference_type (a) || stack_slot_is_complex_type_not_reference_type (b)) {\n\t\tres = TYPE_INV;\n\t} else {\n\t\t--idxa;\n\t\t--idxb;\n\t\tres = table [idxa][idxb];\n\t}\n\n\tVERIFIER_DEBUG ( printf (\"branch res %d\\n\", res); );\n\tVERIFIER_DEBUG ( printf (\"idxa %d idxb %d\\n\", idxa, idxb); );\n\n\tif (res == TYPE_INV) {\n\t\tCODE_NOT_VERIFIABLE (ctx,\n\t\t\tg_strdup_printf (\"Compare and Branch instruction applyed to ill formed stack (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset));\n\t} else if (res & NON_VERIFIABLE_RESULT) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Compare and Branch instruction is not verifiable (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset)); \n \t\tres = res & ~NON_VERIFIABLE_RESULT;\n \t}\n}\n\nstatic void\ndo_cmp_op (VerifyContext *ctx, const unsigned char table [TYPE_MAX][TYPE_MAX], guint32 opcode)\n{\n\tILStackDesc *a, *b;\n\tint idxa, idxb;\n\tunsigned char res;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\tb = stack_pop (ctx);\n\ta = stack_pop (ctx);\n\n\tif (opcode == CEE_CGT_UN) {\n\t\tif (stack_slot_get_type (a) == TYPE_COMPLEX && stack_slot_get_type (b) == TYPE_COMPLEX) {\n\t\t\tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tidxa = stack_slot_get_underlying_type (a);\n\tif (stack_slot_is_managed_pointer (a))\n\t\tidxa = TYPE_PTR;\n\n\tidxb = stack_slot_get_underlying_type (b);\n\tif (stack_slot_is_managed_pointer (b)) \n\t\tidxb = TYPE_PTR;\n\n\tif (stack_slot_is_complex_type_not_reference_type (a) || stack_slot_is_complex_type_not_reference_type (b)) {\n\t\tres = TYPE_INV;\n\t} else {\n\t\t--idxa;\n\t\t--idxb;\n\t\tres = table [idxa][idxb];\n\t}\n\n\tif(res == TYPE_INV) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf(\"Compare instruction applyed to ill formed stack (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset));\n\t} else if (res & NON_VERIFIABLE_RESULT) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Compare instruction is not verifiable (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset)); \n \t\tres = res & ~NON_VERIFIABLE_RESULT;\n \t}\n \tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n}\n\nstatic void\ndo_ret (VerifyContext *ctx)\n{\n\tMonoType *ret = ctx->signature->ret;\n\tVERIFIER_DEBUG ( printf (\"checking ret\\n\"); );\n\tif (ret->type != MONO_TYPE_VOID) {\n\t\tILStackDesc *top;\n\t\tif (!check_underflow (ctx, 1))\n\t\t\treturn;\n\n\t\ttop = stack_pop(ctx);\n\n\t\tif (!verify_stack_type_compatibility (ctx, ctx->signature->ret, top)) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible return value on stack with method signature ret at 0x%04x\", ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\n\t\tif (ret->byref || ret->type == MONO_TYPE_TYPEDBYREF || mono_type_is_value_type (ret, \"System\", \"ArgIterator\") || mono_type_is_value_type (ret, \"System\", \"RuntimeArgumentHandle\"))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Method returns byref, TypedReference, ArgIterator or RuntimeArgumentHandle at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tif (ctx->eval.size > 0) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Stack not empty (%d) after ret at 0x%04x\", ctx->eval.size, ctx->ip_offset));\n\t} \n\tif (in_any_block (ctx->header, ctx->ip_offset))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"ret cannot escape exception blocks at 0x%04x\", ctx->ip_offset));\n}\n\n/*\n * FIXME we need to fix the case of a non-virtual instance method defined in the parent but call using a token pointing to a subclass.\n * \tThis is illegal but mono_get_method_full decoded it.\n * TODO handle calling .ctor outside one or calling the .ctor for other class but super  \n */\nstatic void\ndo_invoke_method (VerifyContext *ctx, int method_token, gboolean virtual)\n{\n\tint param_count, i;\n\tMonoMethodSignature *sig;\n\tILStackDesc *value;\n\tMonoMethod *method;\n\tgboolean virt_check_this = FALSE;\n\tgboolean constrained = ctx->prefix_set & PREFIX_CONSTRAINED;\n\n\tif (!(method = verifier_load_method (ctx, method_token, virtual ? \"callvirt\" : \"call\")))\n\t\treturn;\n\n\tif (virtual) {\n\t\tCLEAR_PREFIX (ctx, PREFIX_CONSTRAINED);\n\n\t\tif (method->klass->valuetype) // && !constrained ???\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use callvirtual with valuetype method at 0x%04x\", ctx->ip_offset));\n\n\t\tif ((method->flags & METHOD_ATTRIBUTE_STATIC))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use callvirtual with static method at 0x%04x\", ctx->ip_offset));\n\n\t} else {\n\t\tif (method->flags & METHOD_ATTRIBUTE_ABSTRACT) \n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use call with an abstract method at 0x%04x\", ctx->ip_offset));\n\t\t\n\t\tif ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) && !(method->flags & METHOD_ATTRIBUTE_FINAL) && !(method->klass->flags & TYPE_ATTRIBUTE_SEALED)) {\n\t\t\tvirt_check_this = TRUE;\n\t\t\tctx->code [ctx->ip_offset].flags |= IL_CODE_CALL_NONFINAL_VIRTUAL;\n\t\t}\n\t}\n\n\tif (!(sig = mono_method_get_signature_full (method, ctx->image, method_token, ctx->generic_context)))\n\t\tsig = mono_method_get_signature (method, ctx->image, method_token);\n\n\tif (!sig) {\n\t\tchar *name = mono_type_get_full_name (method->klass);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not resolve signature of %s:%s at 0x%04x\", name, method->name, ctx->ip_offset));\n\t\tg_free (name);\n\t\treturn;\n\t}\n\n\tparam_count = sig->param_count + sig->hasthis;\n\tif (!check_underflow (ctx, param_count))\n\t\treturn;\n\n\tfor (i = sig->param_count - 1; i >= 0; --i) {\n\t\tVERIFIER_DEBUG ( printf (\"verifying argument %d\\n\", i); );\n\t\tvalue = stack_pop (ctx);\n\t\tif (!verify_stack_type_compatibility (ctx, sig->params[i], value)) {\n\t\t\tchar *stack_name = stack_slot_full_name (value);\n\t\t\tchar *sig_name = mono_type_full_name (sig->params [i]);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible parameter with function signature: Calling method with signature (%s) but for argument %d there is a (%s) on stack at 0x%04x\", sig_name, i, stack_name, ctx->ip_offset));\n\t\t\tg_free (stack_name);\n\t\t\tg_free (sig_name);\n\t\t}\n\n\t\tif (stack_slot_is_managed_mutability_pointer (value))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer as argument of %s at 0x%04x\", virtual ? \"callvirt\" : \"call\",  ctx->ip_offset));\n\n\t\tif ((ctx->prefix_set & PREFIX_TAIL) && stack_slot_is_managed_pointer (value)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Cannot  pass a byref argument to a tail %s at 0x%04x\", virtual ? \"callvirt\" : \"call\",  ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sig->hasthis) {\n\t\tMonoType *type = &method->klass->byval_arg;\n\t\tILStackDesc copy;\n\n\t\tif (mono_method_is_constructor (method) && !method->klass->valuetype) {\n\t\t\tif (!mono_method_is_constructor (ctx->method))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a constructor outside one at 0x%04x\", ctx->ip_offset));\n\t\t\tif (method->klass != ctx->method->klass->parent && method->klass != ctx->method->klass)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a constructor to a type diferent that this or super at 0x%04x\", ctx->ip_offset));\n\n\t\t\tctx->super_ctor_called = TRUE;\n\t\t\tvalue = stack_pop_safe (ctx);\n\t\t\tif ((value->stype & THIS_POINTER_MASK) != THIS_POINTER_MASK)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid 'this ptr' argument for constructor at 0x%04x\", ctx->ip_offset));\n\t\t} else {\n\t\t\tvalue = stack_pop (ctx);\n\t\t}\n\t\t\t\n\t\tcopy_stack_value (&copy, value);\n\t\t//TODO we should extract this to a 'drop_byref_argument' and use everywhere\n\t\t//Other parts of the code suffer from the same issue of \n\t\tcopy.type = mono_type_get_type_byval (copy.type);\n\t\tcopy.stype &= ~POINTER_MASK;\n\n\t\tif (virt_check_this && !stack_slot_is_this_pointer (value) && !(method->klass->valuetype || stack_slot_is_boxed_value (value)))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a non-final virtual method from an objet diferent thant the this pointer at 0x%04x\", ctx->ip_offset));\n\n\t\tif (constrained && virtual) {\n\t\t\tif (!stack_slot_is_managed_pointer (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Object is not a managed pointer for a constrained call at 0x%04x\", ctx->ip_offset));\n\t\t\tif (!mono_metadata_type_equal_full (mono_type_get_type_byval (value->type), ctx->constrained_type, TRUE))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Object not compatible with constrained type at 0x%04x\", ctx->ip_offset));\n\t\t\tcopy.stype |= BOXED_MASK;\n\t\t} else {\n\t\t\tif (stack_slot_is_managed_pointer (value) && !mono_class_from_mono_type (value->type)->valuetype)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a reference type using a managed pointer to the this arg at 0x%04x\", ctx->ip_offset));\n\t\n\t\t\tif (!virtual && mono_class_from_mono_type (value->type)->valuetype && !method->klass->valuetype && !stack_slot_is_boxed_value (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a valuetype baseclass at 0x%04x\", ctx->ip_offset));\n\t\n\t\t\tif (virtual && mono_class_from_mono_type (value->type)->valuetype && !stack_slot_is_boxed_value (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a valuetype with callvirt at 0x%04x\", ctx->ip_offset));\n\t\n\t\t\tif (method->klass->valuetype && (stack_slot_is_boxed_value (value) || !stack_slot_is_managed_pointer (value)))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a boxed or literal valuetype to call a valuetype method at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t\tif (!verify_stack_type_compatibility (ctx, type, &copy)) {\n\t\t\tchar *expected = mono_type_full_name (type);\n\t\t\tchar *effective = stack_slot_full_name (&copy);\n\t\t\tchar *method_name = mono_method_full_name (method, TRUE);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible this argument on stack with method signature expected '%s' but got '%s' for a call to '%s' at 0x%04x\",\n\t\t\t\t\texpected, effective, method_name, ctx->ip_offset));\n\t\t\tg_free (method_name);\n\t\t\tg_free (effective);\n\t\t\tg_free (expected);\n\t\t}\n\n\t\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_method_full (ctx->method, method, mono_class_from_mono_type (value->type))) {\n\t\t\tchar *name = mono_method_full_name (method, TRUE);\n\t\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Method %s is not accessible at 0x%04x\", name, ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\t\t\tg_free (name);\n\t\t}\n\n\t} else if (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_method_full (ctx->method, method, NULL)) {\n\t\tchar *name = mono_method_full_name (method, TRUE);\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Method %s is not accessible at 0x%04x\", name, ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\t\tg_free (name);\n\t}\n\n\tif (sig->ret->type != MONO_TYPE_VOID) {\n\t\tif (check_overflow (ctx)) {\n\t\t\tvalue = stack_push (ctx);\n\t\t\tset_stack_value (ctx, value, sig->ret, FALSE);\n\t\t\tif ((ctx->prefix_set & PREFIX_READONLY) && method->klass->rank && !strcmp (method->name, \"Address\")) {\n\t\t\t\tctx->prefix_set &= ~PREFIX_READONLY;\n\t\t\t\tvalue->stype |= CMMP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctx->prefix_set & PREFIX_TAIL)) {\n\t\tif (!mono_delegate_ret_equal (mono_method_signature (ctx->method)->ret, sig->ret))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Tail call with incompatible return type at 0x%04x\", ctx->ip_offset));\n\t\tif (ctx->header->code [ctx->ip_offset + 5] != CEE_RET)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Tail call not followed by ret at 0x%04x\", ctx->ip_offset));\n\t}\n\n}\n\nstatic void\ndo_push_static_field (VerifyContext *ctx, int token, gboolean take_addr)\n{\n\tMonoClassField *field;\n\tMonoClass *klass;\n\tif (!check_overflow (ctx))\n\t\treturn;\n\tif (!take_addr)\n\t\tCLEAR_PREFIX (ctx, PREFIX_VOLATILE);\n\n\tif (!(field = verifier_load_field (ctx, token, &klass, take_addr ? \"ldsflda\" : \"ldsfld\")))\n\t\treturn;\n\n\tif (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC)) { \n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Cannot load non static field at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\t/*taking the address of initonly field only works from the static constructor */\n\tif (take_addr && (field->type->attrs & FIELD_ATTRIBUTE_INIT_ONLY) &&\n\t\t!(field->parent == ctx->method->klass && (ctx->method->flags & (METHOD_ATTRIBUTE_SPECIAL_NAME | METHOD_ATTRIBUTE_STATIC)) && !strcmp (\".cctor\", ctx->method->name)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot take the address of a init-only field at 0x%04x\", ctx->ip_offset));\n\n\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, NULL))\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\n\tset_stack_value (ctx, stack_push (ctx), field->type, take_addr);\n}\n\nstatic void\ndo_store_static_field (VerifyContext *ctx, int token) {\n\tMonoClassField *field;\n\tMonoClass *klass;\n\tILStackDesc *value;\n\tCLEAR_PREFIX (ctx, PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\tif (!(field = verifier_load_field (ctx, token, &klass, \"stsfld\")))\n\t\treturn;\n\n\tif (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC)) { \n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Cannot store non static field at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (field->type->type == MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Typedbyref field is an unverfiable type in store static field at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, NULL))\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\n\tif (!verify_stack_type_compatibility (ctx, field->type, value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type %s in static field store at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\t\n}\n\nstatic gboolean\ncheck_is_valid_type_for_field_ops (VerifyContext *ctx, int token, ILStackDesc *obj, MonoClassField **ret_field, const char *opcode)\n{\n\tMonoClassField *field;\n\tMonoClass *klass;\n\tgboolean is_pointer;\n\n\t/*must be a reference type, a managed pointer, an unamanaged pointer, or a valuetype*/\n\tif (!(field = verifier_load_field (ctx, token, &klass, opcode)))\n\t\treturn FALSE;\n\n\t*ret_field = field;\n\t//the value on stack is going to be used as a pointer\n\tis_pointer = stack_slot_get_type (obj) == TYPE_PTR || (stack_slot_get_type (obj) == TYPE_NATIVE_INT && !get_stack_type (&field->parent->byval_arg));\n\n\tif (field->type->type == MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Typedbyref field is an unverfiable type at 0x%04x\", ctx->ip_offset));\n\t\treturn FALSE;\n\t}\n\tg_assert (obj->type);\n\n\t/*The value on the stack must be a subclass of the defining type of the field*/ \n\t/* we need to check if we can load the field from the stack value*/\n\tif (is_pointer) {\n\t\tif (stack_slot_get_underlying_type (obj) == TYPE_NATIVE_INT)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Native int is not a verifiable type to reference a field at 0x%04x\", ctx->ip_offset));\n\n\t\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, NULL))\n\t\t\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\t} else {\n\t\tif (!field->parent->valuetype && stack_slot_is_managed_pointer (obj))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type at stack is a managed pointer to a reference type and is not compatible to reference the field at 0x%04x\", ctx->ip_offset));\n\n\t\t/*a value type can be loaded from a value or a managed pointer, but not a boxed object*/\n\t\tif (field->parent->valuetype && stack_slot_is_boxed_value (obj))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type at stack is a boxed valuetype and is not compatible to reference the field at 0x%04x\", ctx->ip_offset));\n\n\t\tif (!stack_slot_is_null_literal (obj) && !verify_stack_type_compatibility_full (ctx, &field->parent->byval_arg, obj, TRUE, FALSE)) {\n\t\t\tchar *found = stack_slot_full_name (obj);\n\t\t\tchar *expected = mono_type_full_name (&field->parent->byval_arg);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Expected type '%s' but found '%s' referencing the 'this' argument at 0x%04x\", expected, found, ctx->ip_offset));\n\t\t\tg_free (found);\n\t\t\tg_free (expected);\n\t\t}\n\n\t\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, mono_class_from_mono_type (obj->type)))\n\t\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\t} \n\n\tcheck_unmanaged_pointer (ctx, obj);\n\treturn TRUE;\n}\n\nstatic void\ndo_push_field (VerifyContext *ctx, int token, gboolean take_addr)\n{\n\tILStackDesc *obj;\n\tMonoClassField *field;\n\n\tif (!take_addr)\n\t\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\tobj = stack_pop_safe (ctx);\n\n\tif (!check_is_valid_type_for_field_ops (ctx, token, obj, &field, take_addr ? \"ldflda\" : \"ldfld\"))\n\t\treturn;\n\n\tif (take_addr && field->parent->valuetype && !stack_slot_is_managed_pointer (obj))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot take the address of a temporary value-type at 0x%04x\", ctx->ip_offset));\n\n\tif (take_addr && (field->type->attrs & FIELD_ATTRIBUTE_INIT_ONLY) &&\n\t\t!(field->parent == ctx->method->klass && mono_method_is_constructor (ctx->method)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot take the address of a init-only field at 0x%04x\", ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), field->type, take_addr);\n}\n\nstatic void\ndo_store_field (VerifyContext *ctx, int token)\n{\n\tILStackDesc *value, *obj;\n\tMonoClassField *field;\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\tobj = stack_pop_safe (ctx);\n\n\tif (!check_is_valid_type_for_field_ops (ctx, token, obj, &field, \"stfld\"))\n\t\treturn;\n\n\tif (!verify_stack_type_compatibility (ctx, field->type, value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type %s in field store at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\t\n}\n\n/*TODO proper handle for Nullable<T>*/\nstatic void\ndo_box_value (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"box\");\n\tMonoClass *klass;\t\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\t/*box is a nop for reference types*/\n\n\tif (stack_slot_get_underlying_type (value) == TYPE_COMPLEX && MONO_TYPE_IS_REFERENCE (value->type) && MONO_TYPE_IS_REFERENCE (type)) {\n\t\tstack_push_stack_val (ctx, value)->stype |= BOXED_MASK;\n\t\treturn;\n\t}\n\n\n\tif (!verify_stack_type_compatibility (ctx, type, value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for boxing operation at 0x%04x\", ctx->ip_offset));\n\n\tklass = mono_class_from_mono_type (type);\n\tif (mono_class_is_nullable (klass))\n\t\ttype = &mono_class_get_nullable_param (klass)->byval_arg;\n\tstack_push_val (ctx, TYPE_COMPLEX | BOXED_MASK, type);\n}\n\nstatic void\ndo_unbox_value (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"unbox\");\n\n\tif (!type)\n\t\treturn;\n \n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!mono_class_from_mono_type (type)->valuetype)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid reference type for unbox at 0x%04x\", ctx->ip_offset));\n\n\tvalue = stack_pop (ctx);\n\n\t/*Value should be: a boxed valuetype or a reference type*/\n\tif (!(stack_slot_get_type (value) == TYPE_COMPLEX &&\n\t\t(stack_slot_is_boxed_value (value) || !mono_class_from_mono_type (value->type)->valuetype)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type %s at stack for unbox operation at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\n\tset_stack_value (ctx, value = stack_push (ctx), mono_type_get_type_byref (type), FALSE);\n\tvalue->stype |= CMMP_MASK;\n}\n\nstatic void\ndo_unbox_any (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"unbox.any\");\n\n\tif (!type)\n\t\treturn;\n \n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\t/*Value should be: a boxed valuetype or a reference type*/\n\tif (!(stack_slot_get_type (value) == TYPE_COMPLEX &&\n\t\t(stack_slot_is_boxed_value (value) || !mono_class_from_mono_type (value->type)->valuetype)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type %s at stack for unbox.any operation at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n \n\tset_stack_value (ctx, stack_push (ctx), type, FALSE);\n}\n\nstatic void\ndo_unary_math_op (VerifyContext *ctx, int op)\n{\n\tILStackDesc *value;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\tvalue = stack_pop (ctx);\n\tswitch (stack_slot_get_type (value)) {\n\tcase TYPE_I4:\n\tcase TYPE_I8:\n\tcase TYPE_NATIVE_INT:\n\t\tbreak;\n\tcase TYPE_R8:\n\t\tif (op == CEE_NEG)\n\t\t\tbreak;\n\tcase TYPE_COMPLEX: /*only enums are ok*/\n\t\tif (mono_type_is_enum_type (value->type))\n\t\t\tbreak;\n\tdefault:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for unary not at 0x%04x\", ctx->ip_offset));\n\t}\n\tstack_push_stack_val (ctx, value);\n}\n\nstatic void\ndo_conversion (VerifyContext *ctx, int kind) \n{\n\tILStackDesc *value;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\tvalue = stack_pop (ctx);\n\n\tswitch (stack_slot_get_type (value)) {\n\tcase TYPE_I4:\n\tcase TYPE_I8:\n\tcase TYPE_NATIVE_INT:\n\tcase TYPE_R8:\n\t\tbreak;\n\tdefault:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type (%s) at stack for conversion operation. Numeric type expected at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\t}\n\n\tswitch (kind) {\n\tcase TYPE_I4:\n\t\tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\tbreak;\n\tcase TYPE_I8:\n\t\tstack_push_val (ctx,TYPE_I8, &mono_defaults.int64_class->byval_arg);\n\t\tbreak;\n\tcase TYPE_R8:\n\t\tstack_push_val (ctx, TYPE_R8, &mono_defaults.double_class->byval_arg);\n\t\tbreak;\n\tcase TYPE_NATIVE_INT:\n\t\tstack_push_val (ctx, TYPE_NATIVE_INT, &mono_defaults.int_class->byval_arg);\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"unknown type %02x in conversion\", kind);\n\n\t}\n}\n\nstatic void\ndo_load_token (VerifyContext *ctx, int token) \n{\n\tgpointer handle;\n\tMonoClass *handle_class;\n\tif (!check_overflow (ctx))\n\t\treturn;\n\n\tswitch (token & 0xff000000) {\n\tcase MONO_TOKEN_TYPE_DEF:\n\tcase MONO_TOKEN_TYPE_REF:\n\tcase MONO_TOKEN_TYPE_SPEC:\n\tcase MONO_TOKEN_FIELD_DEF:\n\tcase MONO_TOKEN_METHOD_DEF:\n\tcase MONO_TOKEN_METHOD_SPEC:\n\tcase MONO_TOKEN_MEMBER_REF:\n\t\tif (!token_bounds_check (ctx->image, token)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Table index out of range 0x%x for token %x for ldtoken at 0x%04x\", mono_metadata_token_index (token), token, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid table 0x%x for token 0x%x for ldtoken at 0x%04x\", mono_metadata_token_table (token), token, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\thandle = mono_ldtoken (ctx->image, token, &handle_class, ctx->generic_context);\n\tif (!handle) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid token 0x%x for ldtoken at 0x%04x\", token, ctx->ip_offset));\n\t\treturn;\n\t}\n\tif (handle_class == mono_defaults.typehandle_class) {\n\t\tmono_type_is_valid_in_context (ctx, (MonoType*)handle);\n\t} else if (handle_class == mono_defaults.methodhandle_class) {\n\t\tmono_method_is_valid_in_context (ctx, (MonoMethod*)handle);\t\t\n\t} else if (handle_class == mono_defaults.fieldhandle_class) {\n\t\tmono_type_is_valid_in_context (ctx, &((MonoClassField*)handle)->parent->byval_arg);\t\t\t\t\n\t} else {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid ldtoken type %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t}\n\tstack_push_val (ctx, TYPE_COMPLEX, mono_class_get_type (handle_class));\n}\n\nstatic void\ndo_ldobj_value (VerifyContext *ctx, int token) \n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"ldobj\");\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\tif (!stack_slot_is_managed_pointer (value) \n\t\t\t&& stack_slot_get_type (value) != TYPE_NATIVE_INT\n\t\t\t&& !(stack_slot_get_type (value) == TYPE_PTR && value->type->type != MONO_TYPE_FNPTR)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid argument %s to ldobj at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (stack_slot_get_type (value) == TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Using native pointer to ldobj at 0x%04x\", ctx->ip_offset));\n\n\t/*We have a byval on the stack, but the comparison must be strict. */\n\tif (!verify_type_compatibility_full (ctx, type, mono_type_get_type_byval (value->type), TRUE))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for ldojb operation at 0x%04x\", ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), type, FALSE);\n}\n\nstatic void\ndo_stobj (VerifyContext *ctx, int token) \n{\n\tILStackDesc *dest, *src;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"stobj\");\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tsrc = stack_pop (ctx);\n\tdest = stack_pop (ctx);\n\n\tif (stack_slot_is_managed_mutability_pointer (dest))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with stobj at 0x%04x\", ctx->ip_offset));\n\n\tif (!stack_slot_is_managed_pointer (dest)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid destination of stobj operation at 0x%04x\", ctx->ip_offset));\n\n\tif (stack_slot_is_boxed_value (src) && !MONO_TYPE_IS_REFERENCE (src->type) && !MONO_TYPE_IS_REFERENCE (type))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use stobj with a boxed source value that is not a reference type at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_stack_type_compatibility (ctx, type, src))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Token and source types of stobj don't match at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_type_compatibility (ctx, mono_type_get_type_byval (dest->type), type))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Destination and token types of stobj don't match at 0x%04x\", ctx->ip_offset));\n}\n\nstatic void\ndo_cpobj (VerifyContext *ctx, int token)\n{\n\tILStackDesc *dest, *src;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"cpobj\");\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tsrc = stack_pop (ctx);\n\tdest = stack_pop (ctx);\n\n\tif (!stack_slot_is_managed_pointer (src)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid source of cpobj operation at 0x%04x\", ctx->ip_offset));\n\n\tif (!stack_slot_is_managed_pointer (dest)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid destination of cpobj operation at 0x%04x\", ctx->ip_offset));\n\n\tif (stack_slot_is_managed_mutability_pointer (dest))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with cpobj at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_type_compatibility (ctx, type, mono_type_get_type_byval (src->type)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Token and source types of cpobj don't match at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_type_compatibility (ctx, mono_type_get_type_byval (dest->type), type))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Destination and token types of cpobj don't match at 0x%04x\", ctx->ip_offset));\n}\n\nstatic void\ndo_initobj (VerifyContext *ctx, int token)\n{\n\tILStackDesc *obj;\n\tMonoType *stack, *type = get_boxable_mono_type (ctx, token, \"initobj\");\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tobj = stack_pop (ctx);\n\n\tif (!stack_slot_is_managed_pointer (obj)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid object address for initobj at 0x%04x\", ctx->ip_offset));\n\n\tif (stack_slot_is_managed_mutability_pointer (obj))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with initobj at 0x%04x\", ctx->ip_offset));\n\n\tstack = mono_type_get_type_byval (obj->type);\n\tif (MONO_TYPE_IS_REFERENCE (stack)) {\n\t\tif (!verify_type_compatibility (ctx, stack, type)) \n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type token of initobj not compatible with value on stack at 0x%04x\", ctx->ip_offset));\n\t\telse if (IS_STRICT_MODE (ctx) && !mono_metadata_type_equal (type, stack)) \n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type token of initobj not compatible with value on stack at 0x%04x\", ctx->ip_offset));\n\t} else if (!verify_type_compatibility (ctx, stack, type)) {\n\t\tchar *expected_name = mono_type_full_name (type);\n\t\tchar *stack_name = mono_type_full_name (stack);\n\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Initobj %s not compatible with value on stack %s at 0x%04x\", expected_name, stack_name, ctx->ip_offset));\n\t\tg_free (expected_name);\n\t\tg_free (stack_name);\n\t}\n}\n\nstatic void\ndo_newobj (VerifyContext *ctx, int token) \n{\n\tILStackDesc *value;\n\tint i;\n\tMonoMethodSignature *sig;\n\tMonoMethod *method;\n\tgboolean is_delegate = FALSE;\n\n\tif (!(method = verifier_load_method (ctx, token, \"newobj\")))\n\t\treturn;\n\n\tif (!mono_method_is_constructor (method)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method from token 0x%08x not a constructor at 0x%04x\", token, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (method->klass->flags & (TYPE_ATTRIBUTE_ABSTRACT | TYPE_ATTRIBUTE_INTERFACE))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Trying to instantiate an abstract or interface type at 0x%04x\", ctx->ip_offset));\n\n\tif (!mono_method_can_access_method_full (ctx->method, method, NULL)) {\n\t\tchar *from = mono_method_full_name (ctx->method, TRUE);\n\t\tchar *to = mono_method_full_name (method, TRUE);\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Constructor %s not visible from %s at 0x%04x\", to, from, ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\t\tg_free (from);\n\t\tg_free (to);\n\t}\n\n\t//FIXME use mono_method_get_signature_full\n\tsig = mono_method_signature (method);\n\tif (!sig) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid constructor signature to newobj at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (!check_underflow (ctx, sig->param_count))\n\t\treturn;\n\n\tis_delegate = method->klass->parent == mono_defaults.multicastdelegate_class;\n\n\tif (is_delegate) {\n\t\tILStackDesc *funptr;\n\t\t//first arg is object, second arg is fun ptr\n\t\tif (sig->param_count != 2) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid delegate constructor at 0x%04x\", ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t\tfunptr = stack_pop (ctx);\n\t\tvalue = stack_pop (ctx);\n\t\tverify_delegate_compatibility (ctx, method->klass, value, funptr);\n\t} else {\n\t\tfor (i = sig->param_count - 1; i >= 0; --i) {\n\t\t\tVERIFIER_DEBUG ( printf (\"verifying constructor argument %d\\n\", i); );\n\t\t\tvalue = stack_pop (ctx);\n\t\t\tif (!verify_stack_type_compatibility (ctx, sig->params [i], value)) {\n\t\t\t\tchar *stack_name = stack_slot_full_name (value);\n\t\t\t\tchar *sig_name = mono_type_full_name (sig->params [i]);\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible parameter value with constructor signature: %s X %s at 0x%04x\", sig_name, stack_name, ctx->ip_offset));\n\t\t\t\tg_free (stack_name);\n\t\t\t\tg_free (sig_name);\n\t\t\t}\n\n\t\t\tif (stack_slot_is_managed_mutability_pointer (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer as argument of newobj at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t}\n\n\tif (check_overflow (ctx))\n\t\tset_stack_value (ctx, stack_push (ctx),  &method->klass->byval_arg, FALSE);\n}\n\nstatic void\ndo_cast (VerifyContext *ctx, int token, const char *opcode) {\n\tILStackDesc *value;\n\tMonoType *type;\n\tgboolean is_boxed;\n\tgboolean do_box;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!(type = verifier_load_type (ctx, token, opcode)))\n\t\treturn;\n\n\tif (type->byref) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid %s type at 0x%04x\", opcode, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tvalue = stack_pop (ctx);\n\tis_boxed = stack_slot_is_boxed_value (value);\n\n\tif (stack_slot_is_managed_pointer (value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value for %s at 0x%04x\", opcode, ctx->ip_offset));\n\telse if (!MONO_TYPE_IS_REFERENCE  (value->type) && !is_boxed) {\n\t\tchar *name = stack_slot_full_name (value);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Expected a reference type on stack for %s but found %s at 0x%04x\", opcode, name, ctx->ip_offset));\n\t\tg_free (name);\n\t}\n\n\tswitch (value->type->type) {\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_TYPEDBYREF: \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value for %s at 0x%04x\", opcode, ctx->ip_offset));\n\t}\n\n\tdo_box = is_boxed || mono_type_is_generic_argument(type) || mono_class_from_mono_type (type)->valuetype;\n\tstack_push_val (ctx, TYPE_COMPLEX | (do_box ? BOXED_MASK : 0), type);\n}\n\nstatic MonoType *\nmono_type_from_opcode (int opcode) {\n\tswitch (opcode) {\n\tcase CEE_LDIND_I1:\n\tcase CEE_LDIND_U1:\n\tcase CEE_STIND_I1:\n\tcase CEE_LDELEM_I1:\n\tcase CEE_LDELEM_U1:\n\tcase CEE_STELEM_I1:\n\t\treturn &mono_defaults.sbyte_class->byval_arg;\n\n\tcase CEE_LDIND_I2:\n\tcase CEE_LDIND_U2:\n\tcase CEE_STIND_I2:\n\tcase CEE_LDELEM_I2:\n\tcase CEE_LDELEM_U2:\n\tcase CEE_STELEM_I2:\n\t\treturn &mono_defaults.int16_class->byval_arg;\n\n\tcase CEE_LDIND_I4:\n\tcase CEE_LDIND_U4:\n\tcase CEE_STIND_I4:\n\tcase CEE_LDELEM_I4:\n\tcase CEE_LDELEM_U4:\n\tcase CEE_STELEM_I4:\n\t\treturn &mono_defaults.int32_class->byval_arg;\n\n\tcase CEE_LDIND_I8:\n\tcase CEE_STIND_I8:\n\tcase CEE_LDELEM_I8:\n\tcase CEE_STELEM_I8:\n\t\treturn &mono_defaults.int64_class->byval_arg;\n\n\tcase CEE_LDIND_R4:\n\tcase CEE_STIND_R4:\n\tcase CEE_LDELEM_R4:\n\tcase CEE_STELEM_R4:\n\t\treturn &mono_defaults.single_class->byval_arg;\n\n\tcase CEE_LDIND_R8:\n\tcase CEE_STIND_R8:\n\tcase CEE_LDELEM_R8:\n\tcase CEE_STELEM_R8:\n\t\treturn &mono_defaults.double_class->byval_arg;\n\n\tcase CEE_LDIND_I:\n\tcase CEE_STIND_I:\n\tcase CEE_LDELEM_I:\n\tcase CEE_STELEM_I:\n\t\treturn &mono_defaults.int_class->byval_arg;\n\n\tcase CEE_LDIND_REF:\n\tcase CEE_STIND_REF:\n\tcase CEE_LDELEM_REF:\n\tcase CEE_STELEM_REF:\n\t\treturn &mono_defaults.object_class->byval_arg;\n\n\tdefault:\n\t\tg_error (\"unknown opcode %02x in mono_type_from_opcode \", opcode);\n\t\treturn NULL;\n\t}\n}\n\nstatic void\ndo_load_indirect (VerifyContext *ctx, int opcode)\n{\n\tILStackDesc *value;\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\t\n\tvalue = stack_pop (ctx);\n\tif (!stack_slot_is_managed_pointer (value)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Load indirect not using a manager pointer at 0x%04x\", ctx->ip_offset));\n\t\tset_stack_value (ctx, stack_push (ctx), mono_type_from_opcode (opcode), FALSE);\n\t\treturn;\n\t}\n\n\tif (opcode == CEE_LDIND_REF) {\n\t\tif (stack_slot_get_underlying_type (value) != TYPE_COMPLEX || mono_class_from_mono_type (value->type)->valuetype)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for ldind_ref expected object byref operation at 0x%04x\", ctx->ip_offset));\n\t\tset_stack_value (ctx, stack_push (ctx), mono_type_get_type_byval (value->type), FALSE);\n\t} else {\n\t\tif (!verify_type_compatibility_full (ctx, mono_type_from_opcode (opcode), mono_type_get_type_byval (value->type), TRUE))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for ldind 0x%x operation at 0x%04x\", opcode, ctx->ip_offset));\n\t\tset_stack_value (ctx, stack_push (ctx), mono_type_from_opcode (opcode), FALSE);\n\t}\n}\n\nstatic void\ndo_store_indirect (VerifyContext *ctx, int opcode)\n{\n\tILStackDesc *addr, *val;\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tval = stack_pop (ctx);\n\taddr = stack_pop (ctx);\t\n\n\tcheck_unmanaged_pointer (ctx, addr);\n\n\tif (!stack_slot_is_managed_pointer (addr) && stack_slot_get_type (addr) != TYPE_PTR) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid non-pointer argument to stind at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (stack_slot_is_managed_mutability_pointer (addr)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with stind at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (!verify_type_compatibility_full (ctx, mono_type_from_opcode (opcode), mono_type_get_type_byval (addr->type), TRUE))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid addr type at stack for stind 0x%x operation at 0x%04x\", opcode, ctx->ip_offset));\n\n\tif (!verify_stack_type_compatibility (ctx, mono_type_from_opcode (opcode), val))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value type at stack for stind 0x%x operation at 0x%04x\", opcode, ctx->ip_offset));\n}\n\nstatic void\ndo_newarr (VerifyContext *ctx, int token) \n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"newarr\");\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\tif (stack_slot_get_type (value) != TYPE_I4 && stack_slot_get_type (value) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Array size type on stack (%s) is not a verifiable type at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), mono_class_get_type (mono_array_class_get (mono_class_from_mono_type (type), 1)), FALSE);\n}\n\n/*FIXME handle arrays that are not 0-indexed*/\nstatic void\ndo_ldlen (VerifyContext *ctx)\n{\n\tILStackDesc *value;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\tif (stack_slot_get_type (value) != TYPE_COMPLEX || value->type->type != MONO_TYPE_SZARRAY)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type for ldlen at 0x%04x\", ctx->ip_offset));\n\n\tstack_push_val (ctx, TYPE_NATIVE_INT, &mono_defaults.int_class->byval_arg);\t\n}\n\n/*FIXME handle arrays that are not 0-indexed*/\n/*FIXME handle readonly prefix and CMMP*/\nstatic void\ndo_ldelema (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *index, *array, *res;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"ldelema\");\n\tgboolean valid; \n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tindex = stack_pop (ctx);\n\tarray = stack_pop (ctx);\n\n\tif (stack_slot_get_type (index) != TYPE_I4 && stack_slot_get_type (index) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Index type(%s) for ldelema is not an int or a native int at 0x%04x\", stack_slot_get_name (index), ctx->ip_offset));\n\n\tif (!stack_slot_is_null_literal (array)) {\n\t\tif (stack_slot_get_type (array) != TYPE_COMPLEX || array->type->type != MONO_TYPE_SZARRAY)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type(%s) for ldelema at 0x%04x\", stack_slot_get_name (array), ctx->ip_offset));\n\t\telse {\n\t\t\tif (get_stack_type (type) == TYPE_I4 || get_stack_type (type) == TYPE_NATIVE_INT) {\n\t\t\t\t\tvalid = verify_type_compatibility_full (ctx, type, &array->type->data.klass->byval_arg, TRUE);\n\t\t\t} else {\n\t\t\t\tvalid = mono_metadata_type_equal (type, &array->type->data.klass->byval_arg);\n\t\t\t}\n\t\t\tif (!valid)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for ldelema at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t}\n\n\tres = stack_push (ctx);\n\tset_stack_value (ctx, res, type, TRUE);\n\tif (ctx->prefix_set & PREFIX_READONLY) {\n\t\tctx->prefix_set &= ~PREFIX_READONLY;\n\t\tres->stype |= CMMP_MASK;\n\t}\n}\n\n/*\n * FIXME handle arrays that are not 0-indexed\n * FIXME handle readonly prefix and CMMP\n */\nstatic void\ndo_ldelem (VerifyContext *ctx, int opcode, int token)\n{\n#define IS_ONE_OF2(T, A, B) (T == A || T == B)\n\tILStackDesc *index, *array;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tif (opcode == CEE_LDELEM) {\n\t\tif (!(type = verifier_load_type (ctx, token, \"ldelem.any\"))) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Type (0x%08x) not found at 0x%04x\", token, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\ttype = mono_type_from_opcode (opcode);\n\t}\n\n\tindex = stack_pop (ctx);\n\tarray = stack_pop (ctx);\n\n\tif (stack_slot_get_type (index) != TYPE_I4 && stack_slot_get_type (index) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Index type(%s) for ldelem.X is not an int or a native int at 0x%04x\", stack_slot_get_name (index), ctx->ip_offset));\n\n\tif (!stack_slot_is_null_literal (array)) {\n\t\tif (stack_slot_get_type (array) != TYPE_COMPLEX || array->type->type != MONO_TYPE_SZARRAY)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type(%s) for ldelem.X at 0x%04x\", stack_slot_get_name (array), ctx->ip_offset));\n\t\telse {\n\t\t\tif (opcode == CEE_LDELEM_REF) {\n\t\t\t\tif (array->type->data.klass->valuetype)\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type is not a reference type for ldelem.ref 0x%04x\", ctx->ip_offset));\n\t\t\t\ttype = &array->type->data.klass->byval_arg;\n\t\t\t} else {\n\t\t\t\tMonoType *candidate = &array->type->data.klass->byval_arg;\n\t\t\t\tif (IS_STRICT_MODE (ctx)) {\n\t\t\t\t\tMonoType *underlying_type = mono_type_get_underlying_type_any (type);\n\t\t\t\t\tMonoType *underlying_candidate = mono_type_get_underlying_type_any (candidate);\n\t\t\t\t\tif ((IS_ONE_OF2 (underlying_type->type, MONO_TYPE_I4, MONO_TYPE_U4) && IS_ONE_OF2 (underlying_candidate->type, MONO_TYPE_I, MONO_TYPE_U)) ||\n\t\t\t\t\t\t(IS_ONE_OF2 (underlying_candidate->type, MONO_TYPE_I4, MONO_TYPE_U4) && IS_ONE_OF2 (underlying_type->type, MONO_TYPE_I, MONO_TYPE_U)))\n\t\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for ldelem.X at 0x%04x\", ctx->ip_offset));\n\t\t\t\t}\n\t\t\t\tif (!verify_type_compatibility_full (ctx, type, candidate, TRUE))\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for ldelem.X at 0x%04x\", ctx->ip_offset));\n\t\t\t}\n\t\t}\n\t}\n\n\tset_stack_value (ctx, stack_push (ctx), type, FALSE);\n#undef IS_ONE_OF2\n}\n\n/*\n * FIXME handle arrays that are not 0-indexed\n */\nstatic void\ndo_stelem (VerifyContext *ctx, int opcode, int token)\n{\n\tILStackDesc *index, *array, *value;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 3))\n\t\treturn;\n\n\tif (opcode == CEE_STELEM) {\n\t\tif (!(type = verifier_load_type (ctx, token, \"stelem.any\"))) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Type (0x%08x) not found at 0x%04x\", token, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\ttype = mono_type_from_opcode (opcode);\n\t}\n\t\n\tvalue = stack_pop (ctx);\n\tindex = stack_pop (ctx);\n\tarray = stack_pop (ctx);\n\n\tif (stack_slot_get_type (index) != TYPE_I4 && stack_slot_get_type (index) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Index type(%s) for stdelem.X is not an int or a native int at 0x%04x\", stack_slot_get_name (index), ctx->ip_offset));\n\n\tif (!stack_slot_is_null_literal (array)) {\n\t\tif (stack_slot_get_type (array) != TYPE_COMPLEX || array->type->type != MONO_TYPE_SZARRAY) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type(%s) for stelem.X at 0x%04x\", stack_slot_get_name (array), ctx->ip_offset));\n\t\t} else {\n\t\t\tif (opcode == CEE_STELEM_REF) {\n\t\t\t\tif (array->type->data.klass->valuetype)\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type is not a reference type for stelem.ref 0x%04x\", ctx->ip_offset));\n\t\t\t} else if (!verify_type_compatibility_full (ctx, &array->type->data.klass->byval_arg, type, TRUE)) {\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for stdelem.X at 0x%04x\", ctx->ip_offset));\n\t\t\t}\n\t\t}\n\t}\n\tif (opcode == CEE_STELEM_REF) {\n\t\tif (!stack_slot_is_boxed_value (value) && mono_class_from_mono_type (value->type)->valuetype)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value is not a reference type for stelem.ref 0x%04x\", ctx->ip_offset));\n\t} else if (opcode != CEE_STELEM_REF) {\n\t\tif (!verify_stack_type_compatibility (ctx, type, value))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value on stack for stdelem.X at 0x%04x\", ctx->ip_offset));\n\n\t\tif (stack_slot_is_boxed_value (value) && !MONO_TYPE_IS_REFERENCE (value->type) && !MONO_TYPE_IS_REFERENCE (type))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use stobj with a boxed source value that is not a reference type at 0x%04x\", ctx->ip_offset));\n\n\t}\n}\n\nstatic void\ndo_throw (VerifyContext *ctx)\n{\n\tILStackDesc *exception;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\texception = stack_pop (ctx);\n\n\tif (!stack_slot_is_null_literal (exception) && !(stack_slot_get_type (exception) == TYPE_COMPLEX && !mono_class_from_mono_type (exception->type)->valuetype))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type on stack for throw, expected reference type at 0x%04x\", ctx->ip_offset));\n\n\tif (mono_type_is_generic_argument (exception->type) && !stack_slot_is_boxed_value (exception)) {\n\t\tchar *name = mono_type_full_name (exception->type);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type on stack for throw, expected reference type but found unboxed %s  at 0x%04x \", name, ctx->ip_offset));\n\t\tg_free (name);\n\t}\n\t/*The stack is left empty after a throw*/\n\tctx->eval.size = 0;\n}\n\n\nstatic void\ndo_endfilter (VerifyContext *ctx)\n{\n\tMonoExceptionClause *clause;\n\n\tif (IS_STRICT_MODE (ctx)) {\n\t\tif (ctx->eval.size != 1)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Stack size must have one item for endfilter at 0x%04x\", ctx->ip_offset));\n\n\t\tif (ctx->eval.size >= 1 && stack_slot_get_type (stack_pop (ctx)) != TYPE_I4)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Stack item type is not an int32 for endfilter at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tif ((clause = is_correct_endfilter (ctx, ctx->ip_offset))) {\n\t\tif (IS_STRICT_MODE (ctx)) {\n\t\t\tif (ctx->ip_offset != clause->handler_offset - 2)\n\t\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"endfilter is not the last instruction of the filter clause at 0x%04x\", ctx->ip_offset));\t\t\t\n\t\t} else {\n\t\t\tif ((ctx->ip_offset != clause->handler_offset - 2) && !MONO_OFFSET_IN_HANDLER (clause, ctx->ip_offset))\n\t\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"endfilter is not the last instruction of the filter clause at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t} else {\n\t\tif (IS_STRICT_MODE (ctx) && !is_unverifiable_endfilter (ctx, ctx->ip_offset))\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"endfilter outside filter clause at 0x%04x\", ctx->ip_offset));\n\t\telse\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"endfilter outside filter clause at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tctx->eval.size = 0;\n}\n\nstatic void\ndo_leave (VerifyContext *ctx, int delta)\n{\n\tint target = ((gint32)ctx->ip_offset) + delta;\n\tif (target >= ctx->code_size || target < 0)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target out of code at 0x%04x\", ctx->ip_offset));\n\n\tif (!is_correct_leave (ctx->header, ctx->ip_offset, target))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Leave not allowed in finally block at 0x%04x\", ctx->ip_offset));\n\tctx->eval.size = 0;\n\tctx->target = target;\n}\n\n/* \n * do_static_branch:\n * \n * Verify br and br.s opcodes.\n */\nstatic void\ndo_static_branch (VerifyContext *ctx, int delta)\n{\n\tint target = ctx->ip_offset + delta;\n\tif (target < 0 || target >= ctx->code_size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"branch target out of code at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tswitch (is_valid_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\tcase 1:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\tcase 2:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\t}\n\n\tctx->target = target;\n}\n\nstatic void\ndo_switch (VerifyContext *ctx, int count, const unsigned char *data)\n{\n\tint i, base = ctx->ip_offset + 5 + count * 4;\n\tILStackDesc *value;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\tif (stack_slot_get_type (value) != TYPE_I4 && stack_slot_get_type (value) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid argument to switch at 0x%04x\", ctx->ip_offset));\n\n\tfor (i = 0; i < count; ++i) {\n\t\tint target = base + read32 (data + i * 4);\n\n\t\tif (target < 0 || target >= ctx->code_size) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Switch target %x out of code at 0x%04x\", i, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (is_valid_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\t\tcase 1:\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Switch target %x escapes out of exception block at 0x%04x\", i, ctx->ip_offset));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Switch target %x escapes out of exception block at 0x%04x\", i, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t\tmerge_stacks (ctx, &ctx->eval, &ctx->code [target], FALSE, TRUE);\n\t}\n}\n\nstatic void\ndo_load_function_ptr (VerifyContext *ctx, guint32 token, gboolean virtual)\n{\n\tILStackDesc *top;\n\tMonoMethod *method;\n\n\tif (virtual && !check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!virtual && !check_overflow (ctx))\n\t\treturn;\n\n\tif (!IS_METHOD_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid token %x for ldftn  at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\n\tif (!(method = verifier_load_method (ctx, token, virtual ? \"ldvirtfrn\" : \"ldftn\")))\n\t\treturn;\n\n\tif (mono_method_is_constructor (method))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use ldftn with a constructor at 0x%04x\", ctx->ip_offset));\n\n\tif (virtual) {\n\t\tILStackDesc *top = stack_pop (ctx);\n\t\n\t\tif (stack_slot_get_type (top) != TYPE_COMPLEX || top->type->type == MONO_TYPE_VALUETYPE)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid argument to ldvirtftn at 0x%04x\", ctx->ip_offset));\n\t\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use ldvirtftn with a constructor at 0x%04x\", ctx->ip_offset));\n\n\t\tif (!verify_stack_type_compatibility (ctx, &method->klass->byval_arg, top))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Unexpected object for ldvirtftn at 0x%04x\", ctx->ip_offset));\n\t}\n\t\n\tif (!mono_method_can_access_method_full (ctx->method, method, NULL))\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Loaded method is not visible for ldftn/ldvirtftn at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\n\ttop = stack_push_val(ctx, TYPE_PTR, mono_type_create_fnptr_from_mono_method (ctx, method));\n\ttop->method = method;\n}\n\nstatic void\ndo_sizeof (VerifyContext *ctx, int token)\n{\n\tMonoType *type;\n\n\tif (!IS_TYPE_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid type token %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\t\n\tif (!(type = verifier_load_type (ctx, token, \"sizeof\")))\n\t\treturn;\n\n\tif (type->byref && type->type != MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of byref type at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (type->type == MONO_TYPE_VOID) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of void type at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (check_overflow (ctx))\n\t\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.uint32_class->byval_arg, FALSE);\n}\n\n/* Stack top can be of any type, the runtime doesn't care and treat everything as an int. */\nstatic void\ndo_localloc (VerifyContext *ctx)\n{\n\tILStackDesc *top;\n\t\n\tif (ctx->eval.size != 1) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack must have only size item in localloc at 0x%04x\", ctx->ip_offset));\n\t\treturn;\t\t\n\t}\n\n\tif (in_any_exception_block (ctx->header, ctx->ip_offset)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack must have only size item in localloc at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\t/*TODO verify top type*/\n\ttop = stack_pop (ctx);\n\n\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.int_class->byval_arg, FALSE);\n\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Instruction localloc in never verifiable at 0x%04x\", ctx->ip_offset));\n}\n\nstatic void\ndo_ldstr (VerifyContext *ctx, guint32 token)\n{\n\tGSList *error = NULL;\n\tif (mono_metadata_token_code (token) != MONO_TOKEN_STRING) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid string token %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\n\tif (!ctx->image->dynamic && !mono_verifier_verify_string_signature (ctx->image, mono_metadata_token_index (token), &error)) {\n\t\tif (error)\n\t\t\tctx->list = g_slist_concat (ctx->list, error);\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid string index %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\n\tif (check_overflow (ctx))\n\t\tstack_push_val (ctx, TYPE_COMPLEX,  &mono_defaults.string_class->byval_arg);\n}\n\nstatic void\ndo_refanyval (VerifyContext *ctx, int token)\n{\n\tILStackDesc *top;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!(type = get_boxable_mono_type (ctx, token, \"refanyval\")))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (top->stype != TYPE_PTR || top->type->type != MONO_TYPE_TYPEDBYREF)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Expected a typedref as argument for refanyval, but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), type, TRUE);\n}\n\nstatic void\ndo_refanytype (VerifyContext *ctx)\n{\n\tILStackDesc *top;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (top->stype != TYPE_PTR || top->type->type != MONO_TYPE_TYPEDBYREF)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Expected a typedref as argument for refanytype, but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.typehandle_class->byval_arg, FALSE);\n\n}\n\nstatic void\ndo_mkrefany (VerifyContext *ctx, int token)\n{\n\tILStackDesc *top;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!(type = get_boxable_mono_type (ctx, token, \"refanyval\")))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (stack_slot_is_managed_mutability_pointer (top))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with mkrefany at 0x%04x\", ctx->ip_offset));\n\n\tif (!stack_slot_is_managed_pointer (top)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Expected a managed pointer for mkrefany, but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\t}else {\n\t\tMonoType *stack_type = mono_type_get_type_byval (top->type);\n\t\tif (MONO_TYPE_IS_REFERENCE (type) && !mono_metadata_type_equal (type, stack_type))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type not compatible for mkrefany at 0x%04x\", ctx->ip_offset));\n\t\t\t\n\t\tif (!MONO_TYPE_IS_REFERENCE (type) && !verify_type_compatibility_full (ctx, type, stack_type, TRUE))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type not compatible for mkrefany at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.typed_reference_class->byval_arg, FALSE);\n}\n\nstatic void\ndo_ckfinite (VerifyContext *ctx)\n{\n\tILStackDesc *top;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (stack_slot_get_underlying_type (top) != TYPE_R8)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Expected float32 or float64 on stack for ckfinit but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\t\n\tstack_push_stack_val (ctx, top);\n}\n/*\n * merge_stacks:\n * Merge the stacks and perform compat checks. The merge check if types of @from are mergeable with type of @to \n * \n * @from holds new values for a given control path\n * @to holds the current values of a given control path\n * \n * TODO we can eliminate the from argument as all callers pass &ctx->eval\n */\nstatic void\nmerge_stacks (VerifyContext *ctx, ILCodeDesc *from, ILCodeDesc *to, gboolean start, gboolean external) \n{\n\tMonoError error;\n\tint i, j, k;\n\tstack_init (ctx, to);\n\n\tif (start) {\n\t\tif (to->flags == IL_CODE_FLAG_NOT_PROCESSED) \n\t\t\tfrom->size = 0;\n\t\telse\n\t\t\tstack_copy (&ctx->eval, to);\n\t\tgoto end_verify;\n\t} else if (!(to->flags & IL_CODE_STACK_MERGED)) {\n\t\tstack_copy (to, &ctx->eval);\n\t\tgoto end_verify;\n\t}\n\tVERIFIER_DEBUG ( printf (\"performing stack merge %d x %d\\n\", from->size, to->size); );\n\n\tif (from->size != to->size) {\n\t\tVERIFIER_DEBUG ( printf (\"different stack sizes %d x %d at 0x%04x\\n\", from->size, to->size, ctx->ip_offset); );\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not merge stacks, different sizes (%d x %d) at 0x%04x\", from->size, to->size, ctx->ip_offset)); \n\t\tgoto end_verify;\n\t}\n\n\t//FIXME we need to preserve CMMP attributes\n\t//FIXME we must take null literals into consideration.\n\tfor (i = 0; i < from->size; ++i) {\n\t\tILStackDesc *new_slot = from->stack + i;\n\t\tILStackDesc *old_slot = to->stack + i;\n\t\tMonoType *new_type = mono_type_from_stack_slot (new_slot);\n\t\tMonoType *old_type = mono_type_from_stack_slot (old_slot);\n\t\tMonoClass *old_class = mono_class_from_mono_type (old_type);\n\t\tMonoClass *new_class = mono_class_from_mono_type (new_type);\n\t\tMonoClass *match_class = NULL;\n\n\t\t// S := T then U = S (new value is compatible with current value, keep current)\n\t\tif (verify_stack_type_compatibility (ctx, old_type, new_slot)) {\n\t\t\tcopy_stack_value (new_slot, old_slot);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// T := S then U = T (old value is compatible with current value, use new)\n\t\tif (verify_stack_type_compatibility (ctx, new_type, old_slot)) {\n\t\t\tcopy_stack_value (old_slot, new_slot);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mono_type_is_generic_argument (old_type) || mono_type_is_generic_argument (new_type)) {\n\t\t\tchar *old_name = stack_slot_full_name (old_slot); \n\t\t\tchar *new_name = stack_slot_full_name (new_slot);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Could not merge stack at depth %d, types not compatible: %s X %s at 0x%04x\", i, old_name, new_name, ctx->ip_offset));\n\t\t\tg_free (old_name);\n\t\t\tg_free (new_name);\n\t\t\tgoto end_verify;\t\t\t\n\t\t} \n\n\t\t//both are reference types, use closest common super type\n\t\tif (!mono_class_from_mono_type (old_type)->valuetype \n\t\t\t&& !mono_class_from_mono_type (new_type)->valuetype\n\t\t\t&& !stack_slot_is_managed_pointer (old_slot)\n\t\t\t&& !stack_slot_is_managed_pointer (new_slot)) {\n\t\t\t\n\t\t\tfor (j = MIN (old_class->idepth, new_class->idepth) - 1; j > 0; --j) {\n\t\t\t\tif (mono_metadata_type_equal (&old_class->supertypes [j]->byval_arg, &new_class->supertypes [j]->byval_arg)) {\n\t\t\t\t\tmatch_class = old_class->supertypes [j];\n\t\t\t\t\tgoto match_found;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmono_class_setup_interfaces (old_class, &error);\n\t\t\tif (!mono_error_ok (&error)) {\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot merge stacks due to a TypeLoadException %s at 0x%04x\", mono_error_get_message (&error), ctx->ip_offset));\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\tgoto end_verify;\n\t\t\t}\n\t\t\tfor (j = 0; j < old_class->interface_count; ++j) {\n\t\t\t\tfor (k = 0; k < new_class->interface_count; ++k) {\n\t\t\t\t\tif (mono_metadata_type_equal (&old_class->interfaces [j]->byval_arg, &new_class->interfaces [k]->byval_arg)) {\n\t\t\t\t\t\tmatch_class = old_class->interfaces [j];\n\t\t\t\t\t\tgoto match_found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//No decent super type found, use object\n\t\t\tmatch_class = mono_defaults.object_class;\n\t\t\tgoto match_found;\n\t\t} else if (is_compatible_boxed_valuetype (ctx,old_type, new_type, new_slot, FALSE) || is_compatible_boxed_valuetype (ctx, new_type, old_type, old_slot, FALSE)) {\n\t\t\tmatch_class = mono_defaults.object_class;\n\t\t\tgoto match_found;\n\t\t}\n\n\t\t{\n\t\tchar *old_name = stack_slot_full_name (old_slot); \n\t\tchar *new_name = stack_slot_full_name (new_slot);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Could not merge stack at depth %d, types not compatible: %s X %s at 0x%04x\", i, old_name, new_name, ctx->ip_offset)); \n\t\tg_free (old_name);\n\t\tg_free (new_name);\n\t\t}\n\t\tset_stack_value (ctx, old_slot, &new_class->byval_arg, stack_slot_is_managed_pointer (old_slot));\n\t\tgoto end_verify;\n\nmatch_found:\n\t\tg_assert (match_class);\n\t\tset_stack_value (ctx, old_slot, &match_class->byval_arg, stack_slot_is_managed_pointer (old_slot));\n\t\tset_stack_value (ctx, new_slot, &match_class->byval_arg, stack_slot_is_managed_pointer (old_slot));\n\t\tcontinue;\n\t}\n\nend_verify:\n\tif (external)\n\t\tto->flags |= IL_CODE_FLAG_WAS_TARGET;\n\tto->flags |= IL_CODE_STACK_MERGED;\n}\n\n#define HANDLER_START(clause) ((clause)->flags == MONO_EXCEPTION_CLAUSE_FILTER ? (clause)->data.filter_offset : clause->handler_offset)\n#define IS_CATCH_OR_FILTER(clause) ((clause)->flags == MONO_EXCEPTION_CLAUSE_FILTER || (clause)->flags == MONO_EXCEPTION_CLAUSE_NONE)\n\n/*\n * is_clause_in_range :\n * \n * Returns TRUE if either the protected block or the handler of @clause is in the @start - @end range.  \n */\nstatic gboolean\nis_clause_in_range (MonoExceptionClause *clause, guint32 start, guint32 end)\n{\n\tif (clause->try_offset >= start && clause->try_offset < end)\n\t\treturn TRUE;\n\tif (HANDLER_START (clause) >= start && HANDLER_START (clause) < end)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n/*\n * is_clause_inside_range :\n * \n * Returns TRUE if @clause lies completely inside the @start - @end range.  \n */\nstatic gboolean\nis_clause_inside_range (MonoExceptionClause *clause, guint32 start, guint32 end)\n{\n\tif (clause->try_offset < start || (clause->try_offset + clause->try_len) > end)\n\t\treturn FALSE;\n\tif (HANDLER_START (clause) < start || (clause->handler_offset + clause->handler_len) > end)\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\n/*\n * is_clause_nested :\n * \n * Returns TRUE if @nested is nested in @clause.   \n */\nstatic gboolean\nis_clause_nested (MonoExceptionClause *clause, MonoExceptionClause *nested)\n{\n\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER && is_clause_inside_range (nested, clause->data.filter_offset, clause->handler_offset))\n\t\treturn TRUE;\n\treturn is_clause_inside_range (nested, clause->try_offset, clause->try_offset + clause->try_len) ||\n\tis_clause_inside_range (nested, clause->handler_offset, clause->handler_offset + clause->handler_len);\n}\n\n/* Test the relationship between 2 exception clauses. Follow  P.1 12.4.2.7 of ECMA\n * the each pair of exception must have the following properties:\n *  - one is fully nested on another (the outer must not be a filter clause) (the nested one must come earlier)\n *  - completely disjoin (none of the 3 regions of each entry overlap with the other 3)\n *  - mutual protection (protected block is EXACT the same, handlers are disjoin and all handler are catch or all handler are filter)\n */\nstatic void\nverify_clause_relationship (VerifyContext *ctx, MonoExceptionClause *clause, MonoExceptionClause *to_test)\n{\n\t/*clause is nested*/\n\tif (to_test->flags == MONO_EXCEPTION_CLAUSE_FILTER && is_clause_inside_range (clause, to_test->data.filter_offset, to_test->handler_offset)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception clause inside filter\"));\n\t\treturn;\n\t}\n\n\t/*wrong nesting order.*/\n\tif (is_clause_nested (clause, to_test)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Nested exception clause appears after enclosing clause\"));\n\t\treturn;\n\t}\n\n\t/*mutual protection*/\n\tif (clause->try_offset == to_test->try_offset && clause->try_len == to_test->try_len) {\n\t\t/*handlers are not disjoint*/\n\t\tif (is_clause_in_range (to_test, HANDLER_START (clause), clause->handler_offset + clause->handler_len)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception handlers overlap\"));\n\t\t\treturn;\n\t\t}\n\t\t/* handlers are not catch or filter */\n\t\tif (!IS_CATCH_OR_FILTER (clause) || !IS_CATCH_OR_FILTER (to_test)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception clauses with shared protected block are neither catch or filter\"));\n\t\t\treturn;\n\t\t}\n\t\t/*OK*/\n\t\treturn;\n\t}\n\n\t/*not completelly disjoint*/\n\tif ((is_clause_in_range (to_test, clause->try_offset, clause->try_offset + clause->try_len) ||\n\t\tis_clause_in_range (to_test, HANDLER_START (clause), clause->handler_offset + clause->handler_len)) && !is_clause_nested (to_test, clause))\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception clauses overlap\"));\n}\n\n#define code_bounds_check(size) \\\n\tif (ADDP_IS_GREATER_OR_OVF (ip, size, end)) {\\\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Code overrun starting with 0x%x at 0x%04x\", *ip, ctx.ip_offset)); \\\n\t\tbreak; \\\n\t} \\\n\nstatic gboolean\nmono_opcode_is_prefix (int op)\n{\n\tswitch (op) {\n\tcase MONO_CEE_UNALIGNED_:\n\tcase MONO_CEE_VOLATILE_:\n\tcase MONO_CEE_TAIL_:\n\tcase MONO_CEE_CONSTRAINED_:\n\tcase MONO_CEE_READONLY_:\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/*\n * FIXME: need to distinguish between valid and verifiable.\n * Need to keep track of types on the stack.\n * Verify types for opcodes.\n */\nGSList*\nmono_method_verify (MonoMethod *method, int level)\n{\n\tMonoError error;\n\tconst unsigned char *ip, *code_start;\n\tconst unsigned char *end;\n\tMonoSimpleBasicBlock *bb = NULL, *original_bb = NULL;\n\n\tint i, n, need_merge = 0, start = 0;\n\tguint token, ip_offset = 0, prefix = 0;\n\tMonoGenericContext *generic_context = NULL;\n\tMonoImage *image;\n\tVerifyContext ctx;\n\tGSList *tmp;\n\tVERIFIER_DEBUG ( printf (\"Verify IL for method %s %s %s\\n\",  method->klass->name_space,  method->klass->name, method->name); );\n\n\tif (method->iflags & (METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL | METHOD_IMPL_ATTRIBUTE_RUNTIME) ||\n\t\t\t(method->flags & (METHOD_ATTRIBUTE_PINVOKE_IMPL | METHOD_ATTRIBUTE_ABSTRACT))) {\n\t\treturn NULL;\n\t}\n\n\tmemset (&ctx, 0, sizeof (VerifyContext));\n\n\t//FIXME use mono_method_get_signature_full\n\tctx.signature = mono_method_signature (method);\n\tif (!ctx.signature) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Could not decode method signature\"));\n\t\treturn ctx.list;\n\t}\n\tctx.header = mono_method_get_header (method);\n\tif (!ctx.header) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Could not decode method header\"));\n\t\treturn ctx.list;\n\t}\n\tctx.method = method;\n\tcode_start = ip = ctx.header->code;\n\tend = ip + ctx.header->code_size;\n\tctx.image = image = method->klass->image;\n\n\n\tctx.max_args = ctx.signature->param_count + ctx.signature->hasthis;\n\tctx.max_stack = ctx.header->max_stack;\n\tctx.verifiable = ctx.valid = 1;\n\tctx.level = level;\n\n\tctx.code = g_new (ILCodeDesc, ctx.header->code_size);\n\tctx.code_size = ctx.header->code_size;\n\n\tmemset(ctx.code, 0, sizeof (ILCodeDesc) * ctx.header->code_size);\n\n\n\tctx.num_locals = ctx.header->num_locals;\n\tctx.locals = g_memdup (ctx.header->locals, sizeof (MonoType*) * ctx.header->num_locals);\n\n\tif (ctx.num_locals > 0 && !ctx.header->init_locals)\n\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Method with locals variable but without init locals set\"));\n\n\tctx.params = g_new (MonoType*, ctx.max_args);\n\tif (ctx.signature->hasthis)\n\t\tctx.params [0] = method->klass->valuetype ? &method->klass->this_arg : &method->klass->byval_arg;\n\tmemcpy (ctx.params + ctx.signature->hasthis, ctx.signature->params, sizeof (MonoType *) * ctx.signature->param_count);\n\n\tif (ctx.signature->is_inflated)\n\t\tctx.generic_context = generic_context = mono_method_get_context (method);\n\n\tif (!generic_context && (method->klass->generic_container || method->is_generic)) {\n\t\tif (method->is_generic)\n\t\t\tctx.generic_context = generic_context = &(mono_method_get_generic_container (method)->context);\n\t\telse\n\t\t\tctx.generic_context = generic_context = &method->klass->generic_container->context;\n\t}\n\n\tfor (i = 0; i < ctx.num_locals; ++i) {\n\t\tMonoType *uninflated = ctx.locals [i];\n\t\tctx.locals [i] = mono_class_inflate_generic_type_checked (ctx.locals [i], ctx.generic_context, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tchar *name = mono_type_full_name (ctx.locals [i] ? ctx.locals [i] : uninflated);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid local %d of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tmono_error_cleanup (&error);\n\t\t\t/* we must not free (in cleanup) what was not yet allocated (but only copied) */\n\t\t\tctx.num_locals = i;\n\t\t\tctx.max_args = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (i = 0; i < ctx.max_args; ++i) {\n\t\tMonoType *uninflated = ctx.params [i];\n\t\tctx.params [i] = mono_class_inflate_generic_type_checked (ctx.params [i], ctx.generic_context, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tchar *name = mono_type_full_name (ctx.params [i] ? ctx.params [i] : uninflated);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid parameter %d of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tmono_error_cleanup (&error);\n\t\t\t/* we must not free (in cleanup) what was not yet allocated (but only copied) */\n\t\t\tctx.max_args = i;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tstack_init (&ctx, &ctx.eval);\n\n\tfor (i = 0; i < ctx.num_locals; ++i) {\n\t\tif (!mono_type_is_valid_in_context (&ctx, ctx.locals [i]))\n\t\t\tbreak;\n\t\tif (get_stack_type (ctx.locals [i]) == TYPE_INV) {\n\t\t\tchar *name = mono_type_full_name (ctx.locals [i]);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid local %i of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\n\tfor (i = 0; i < ctx.max_args; ++i) {\n\t\tif (!mono_type_is_valid_in_context (&ctx, ctx.params [i]))\n\t\t\tbreak;\n\n\t\tif (get_stack_type (ctx.params [i]) == TYPE_INV) {\n\t\t\tchar *name = mono_type_full_name (ctx.params [i]);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid parameter %i of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx.valid)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ctx.header->num_clauses && ctx.valid; ++i) {\n\t\tMonoExceptionClause *clause = ctx.header->clauses + i;\n\t\tVERIFIER_DEBUG (printf (\"clause try %x len %x filter at %x handler at %x len %x\\n\", clause->try_offset, clause->try_len, clause->data.filter_offset, clause->handler_offset, clause->handler_len); );\n\n\t\tif (clause->try_offset > ctx.code_size || ADD_IS_GREATER_OR_OVF (clause->try_offset, clause->try_len, ctx.code_size))\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"try clause out of bounds at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->try_len <= 0)\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"try clause len <= 0 at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->handler_offset > ctx.code_size || ADD_IS_GREATER_OR_OVF (clause->handler_offset, clause->handler_len, ctx.code_size))\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"handler clause out of bounds at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->handler_len <= 0)\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"handler clause len <= 0 at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->try_offset < clause->handler_offset && ADD_IS_GREATER_OR_OVF (clause->try_offset, clause->try_len, HANDLER_START (clause)))\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"try block (at 0x%04x) includes handler block (at 0x%04x)\", clause->try_offset, clause->handler_offset));\n\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\tif (clause->data.filter_offset > ctx.code_size)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"filter clause out of bounds at 0x%04x\", clause->try_offset));\n\n\t\t\tif (clause->data.filter_offset >= clause->handler_offset)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"filter clause must come before the handler clause at 0x%04x\", clause->data.filter_offset));\n\t\t}\n\n\t\tfor (n = i + 1; n < ctx.header->num_clauses && ctx.valid; ++n)\n\t\t\tverify_clause_relationship (&ctx, clause, ctx.header->clauses + n);\n\n\t\tif (!ctx.valid)\n\t\t\tbreak;\n\n\t\tctx.code [clause->try_offset].flags |= IL_CODE_FLAG_WAS_TARGET;\n\t\tif (clause->try_offset + clause->try_len < ctx.code_size)\n\t\t\tctx.code [clause->try_offset + clause->try_len].flags |= IL_CODE_FLAG_WAS_TARGET;\n\t\tif (clause->handler_offset + clause->handler_len < ctx.code_size)\n\t\t\tctx.code [clause->handler_offset + clause->handler_len].flags |= IL_CODE_FLAG_WAS_TARGET;\n\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_NONE) {\n\t\t\tif (!clause->data.catch_class) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Catch clause %d with invalid type\", i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t\tinit_stack_with_value_at_exception_boundary (&ctx, ctx.code + clause->handler_offset, clause->data.catch_class);\n\t\t}\n\t\telse if (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\tinit_stack_with_value_at_exception_boundary (&ctx, ctx.code + clause->data.filter_offset, mono_defaults.exception_class);\n\t\t\tinit_stack_with_value_at_exception_boundary (&ctx, ctx.code + clause->handler_offset, mono_defaults.exception_class);\t\n\t\t}\n\t}\n\n\toriginal_bb = bb = mono_basic_block_split (method, &error);\n\tif (!mono_error_ok (&error)) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid branch target: %s\", mono_error_get_message (&error)));\n\t\tmono_error_cleanup (&error);\n\t\tgoto cleanup;\n\t}\n\tg_assert (bb);\n\n\twhile (ip < end && ctx.valid) {\n\t\tint op_size;\n\t\tip_offset = ip - code_start;\n\t\t{\n\t\t\tconst unsigned char *ip_copy = ip;\n\t\t\tint op;\n\n\t\t\tif (ip_offset > bb->end) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or EH block at [0x%04x] targets middle instruction at 0x%04x\", bb->end, ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (ip_offset == bb->end)\n\t\t\t\tbb = bb->next;\n\t\n\t\t\top_size = mono_opcode_value_and_size (&ip_copy, end, &op);\n\t\t\tif (op_size == -1) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction %x at 0x%04x\", *ip, ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (ADD_IS_GREATER_OR_OVF (ip_offset, op_size, bb->end)) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or EH block targets middle of instruction at 0x%04x\", ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/*Last Instruction*/\n\t\t\tif (ip_offset + op_size == bb->end && mono_opcode_is_prefix (op)) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or EH block targets between prefix '%s' and instruction at 0x%04x\", mono_opcode_name (op), ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tctx.ip_offset = ip_offset = ip - code_start;\n\n\t\t/*We need to check against fallthrou in and out of protected blocks.\n\t\t * For fallout we check the once a protected block ends, if the start flag is not set.\n\t\t * Likewise for fallthru in, we check if ip is the start of a protected block and start is not set\n\t\t * TODO convert these checks to be done using flags and not this loop\n\t\t */\n\t\tfor (i = 0; i < ctx.header->num_clauses && ctx.valid; ++i) {\n\t\t\tMonoExceptionClause *clause = ctx.header->clauses + i;\n\n\t\t\tif ((clause->try_offset + clause->try_len == ip_offset) && start == 0) {\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"fallthru off try block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif ((clause->handler_offset + clause->handler_len == ip_offset) && start == 0) {\n\t\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"fallout of handler block at 0x%04x\", ip_offset));\n\t\t\t\telse\n\t\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"fallout of handler block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER && clause->handler_offset == ip_offset && start == 0) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"fallout of filter block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (clause->handler_offset == ip_offset && start == 0) {\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"fallthru handler block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (clause->try_offset == ip_offset && ctx.eval.size > 0 && start == 0) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Try to enter try block with a non-empty stack at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*This must be done after fallthru detection otherwise it won't happen.*/\n\t\tif (bb->dead) {\n\t\t\t/*FIXME remove this once we move all bad branch checking code to use BB only*/\n\t\t\tctx.code [ip_offset].flags |= IL_CODE_FLAG_SEEN;\n\t\t\tip += op_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx.valid)\n\t\t\tbreak;\n\n\t\tif (need_merge) {\n\t\t\tVERIFIER_DEBUG ( printf (\"extra merge needed! 0x%04x \\n\", ctx.target); );\n\t\t\tmerge_stacks (&ctx, &ctx.eval, &ctx.code [ctx.target], FALSE, TRUE);\n\t\t\tneed_merge = 0;\t\n\t\t}\n\t\tmerge_stacks (&ctx, &ctx.eval, &ctx.code[ip_offset], start, FALSE);\n\t\tstart = 0;\n\n\t\t/*TODO we can fast detect a forward branch or exception block targeting code after prefix, we should fail fast*/\n#ifdef MONO_VERIFIER_DEBUG\n\t\t{\n\t\t\tchar *discode;\n\t\t\tdiscode = mono_disasm_code_one (NULL, method, ip, NULL);\n\t\t\tdiscode [strlen (discode) - 1] = 0; /* no \\n */\n\t\t\tg_print (\"[%d] %-29s (%d)\\n\",  ip_offset, discode, ctx.eval.size);\n\t\t\tg_free (discode);\n\t\t}\n\t\tdump_stack_state (&ctx.code [ip_offset]);\n\t\tdump_stack_state (&ctx.eval);\n#endif\n\n\t\tswitch (*ip) {\n\t\tcase CEE_NOP:\n\t\tcase CEE_BREAK:\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDARG_0:\n\t\tcase CEE_LDARG_1:\n\t\tcase CEE_LDARG_2:\n\t\tcase CEE_LDARG_3:\n\t\t\tpush_arg (&ctx, *ip - CEE_LDARG_0, FALSE);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDARG_S:\n\t\tcase CEE_LDARGA_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tpush_arg (&ctx, ip [1],  *ip == CEE_LDARGA_S);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_ADD_OVF_UN:\n\t\t\tdo_binop (&ctx, *ip, add_ovf_un_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_SUB_OVF_UN:\n\t\t\tdo_binop (&ctx, *ip, sub_ovf_un_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_ADD_OVF:\n\t\tcase CEE_SUB_OVF:\n\t\tcase CEE_MUL_OVF:\n\t\tcase CEE_MUL_OVF_UN:\n\t\t\tdo_binop (&ctx, *ip, bin_ovf_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_ADD:\n\t\t\tdo_binop (&ctx, *ip, add_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_SUB:\n\t\t\tdo_binop (&ctx, *ip, sub_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_MUL:\n\t\tcase CEE_DIV:\n\t\tcase CEE_REM:\n\t\t\tdo_binop (&ctx, *ip, bin_op_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_AND:\n\t\tcase CEE_DIV_UN:\n\t\tcase CEE_OR:\n\t\tcase CEE_REM_UN:\n\t\tcase CEE_XOR:\n\t\t\tdo_binop (&ctx, *ip, int_bin_op_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_SHL:\n\t\tcase CEE_SHR:\n\t\tcase CEE_SHR_UN:\n\t\t\tdo_binop (&ctx, *ip, shift_op_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_POP:\n\t\t\tif (!check_underflow (&ctx, 1))\n\t\t\t\tbreak;\n\t\t\tstack_pop_safe (&ctx);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_RET:\n\t\t\tdo_ret (&ctx);\n\t\t\t++ip;\n\t\t\tstart = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_LDLOC_0:\n\t\tcase CEE_LDLOC_1:\n\t\tcase CEE_LDLOC_2:\n\t\tcase CEE_LDLOC_3:\n\t\t\t/*TODO support definite assignment verification? */\n\t\t\tpush_local (&ctx, *ip - CEE_LDLOC_0, FALSE);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_STLOC_0:\n\t\tcase CEE_STLOC_1:\n\t\tcase CEE_STLOC_2:\n\t\tcase CEE_STLOC_3:\n\t\t\tstore_local (&ctx, *ip - CEE_STLOC_0);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_STLOC_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tstore_local (&ctx, ip [1]);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_STARG_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tstore_arg (&ctx, ip [1]);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I4_M1:\n\t\tcase CEE_LDC_I4_0:\n\t\tcase CEE_LDC_I4_1:\n\t\tcase CEE_LDC_I4_2:\n\t\tcase CEE_LDC_I4_3:\n\t\tcase CEE_LDC_I4_4:\n\t\tcase CEE_LDC_I4_5:\n\t\tcase CEE_LDC_I4_6:\n\t\tcase CEE_LDC_I4_7:\n\t\tcase CEE_LDC_I4_8:\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I4_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I4:\n\t\t\tcode_bounds_check (5);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx,TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I8:\n\t\t\tcode_bounds_check (9);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx,TYPE_I8, &mono_defaults.int64_class->byval_arg);\n\t\t\tip += 9;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_R4:\n\t\t\tcode_bounds_check (5);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_R8, &mono_defaults.double_class->byval_arg);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_R8:\n\t\t\tcode_bounds_check (9);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_R8, &mono_defaults.double_class->byval_arg);\n\t\t\tip += 9;\n\t\t\tbreak;\n\n\t\tcase CEE_LDNULL:\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_COMPLEX | NULL_LITERAL_MASK, &mono_defaults.object_class->byval_arg);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_BEQ_S:\n\t\tcase CEE_BNE_UN_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_branch_op (&ctx, (signed char)ip [1] + 2, cmp_br_eq_op);\n\t\t\tip += 2;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BGE_S:\n\t\tcase CEE_BGT_S:\n\t\tcase CEE_BLE_S:\n\t\tcase CEE_BLT_S:\n\t\tcase CEE_BGE_UN_S:\n\t\tcase CEE_BGT_UN_S:\n\t\tcase CEE_BLE_UN_S:\n\t\tcase CEE_BLT_UN_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_branch_op (&ctx, (signed char)ip [1] + 2, cmp_br_op);\n\t\t\tip += 2;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BEQ:\n\t\tcase CEE_BNE_UN:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_branch_op (&ctx, (gint32)read32 (ip + 1) + 5, cmp_br_eq_op);\n\t\t\tip += 5;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BGE:\n\t\tcase CEE_BGT:\n\t\tcase CEE_BLE:\n\t\tcase CEE_BLT:\n\t\tcase CEE_BGE_UN:\n\t\tcase CEE_BGT_UN:\n\t\tcase CEE_BLE_UN:\n\t\tcase CEE_BLT_UN:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_branch_op (&ctx, (gint32)read32 (ip + 1) + 5, cmp_br_op);\n\t\t\tip += 5;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_LDLOC_S:\n\t\tcase CEE_LDLOCA_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tpush_local (&ctx, ip[1], *ip == CEE_LDLOCA_S);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_UNUSED99:\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Use of the `unused' opcode\"));\n\t\t\t++ip;\n\t\t\tbreak; \n\n\t\tcase CEE_DUP: {\n\t\t\tILStackDesc * top;\n\t\t\tif (!check_underflow (&ctx, 1))\n\t\t\t\tbreak;\n\t\t\tif (!check_overflow (&ctx))\n\t\t\t\tbreak;\n\t\t\ttop = stack_pop_safe (&ctx);\n\t\t\tcopy_stack_value (stack_push (&ctx), top); \n\t\t\tcopy_stack_value (stack_push (&ctx), top);\n\t\t\t++ip;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CEE_JMP:\n\t\t\tcode_bounds_check (5);\n\t\t\tif (ctx.eval.size)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Eval stack must be empty in jmp at 0x%04x\", ip_offset));\n\t\t\ttoken = read32 (ip + 1);\n\t\t\tif (in_any_block (ctx.header, ip_offset))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"jmp cannot escape exception blocks at 0x%04x\", ip_offset));\n\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Intruction jmp is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\t/*\n\t\t\t * FIXME: check signature, retval, arguments etc.\n\t\t\t */\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\tcase CEE_CALL:\n\t\tcase CEE_CALLVIRT:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_invoke_method (&ctx, read32 (ip + 1), *ip == CEE_CALLVIRT);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CALLI:\n\t\t\tcode_bounds_check (5);\n\t\t\ttoken = read32 (ip + 1);\n\t\t\t/*\n\t\t\t * FIXME: check signature, retval, arguments etc.\n\t\t\t * FIXME: check requirements for tail call\n\t\t\t */\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Intruction calli is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\tcase CEE_BR_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_static_branch (&ctx, (signed char)ip [1] + 2);\n\t\t\tneed_merge = 1;\n\t\t\tip += 2;\n\t\t\tstart = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BRFALSE_S:\n\t\tcase CEE_BRTRUE_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_boolean_branch_op (&ctx, (signed char)ip [1] + 2);\n\t\t\tip += 2;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BR:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_static_branch (&ctx, (gint32)read32 (ip + 1) + 5);\n\t\t\tneed_merge = 1;\n\t\t\tip += 5;\n\t\t\tstart = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BRFALSE:\n\t\tcase CEE_BRTRUE:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_boolean_branch_op (&ctx, (gint32)read32 (ip + 1) + 5);\n\t\t\tip += 5;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_SWITCH: {\n\t\t\tguint32 entries;\n\t\t\tcode_bounds_check (5);\n\t\t\tentries = read32 (ip + 1);\n\n\t\t\tif (entries > 0xFFFFFFFFU / sizeof (guint32))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Too many switch entries %x at 0x%04x\", entries, ctx.ip_offset));\n\n\t\t\tip += 5;\n\t\t\tcode_bounds_check (sizeof (guint32) * entries);\n\t\t\t\n\t\t\tdo_switch (&ctx, entries, ip);\n\t\t\tip += sizeof (guint32) * entries;\n\t\t\tbreak;\n\t\t}\n\t\tcase CEE_LDIND_I1:\n\t\tcase CEE_LDIND_U1:\n\t\tcase CEE_LDIND_I2:\n\t\tcase CEE_LDIND_U2:\n\t\tcase CEE_LDIND_I4:\n\t\tcase CEE_LDIND_U4:\n\t\tcase CEE_LDIND_I8:\n\t\tcase CEE_LDIND_I:\n\t\tcase CEE_LDIND_R4:\n\t\tcase CEE_LDIND_R8:\n\t\tcase CEE_LDIND_REF:\n\t\t\tdo_load_indirect (&ctx, *ip);\n\t\t\t++ip;\n\t\t\tbreak;\n\t\t\t\n\t\tcase CEE_STIND_REF:\n\t\tcase CEE_STIND_I1:\n\t\tcase CEE_STIND_I2:\n\t\tcase CEE_STIND_I4:\n\t\tcase CEE_STIND_I8:\n\t\tcase CEE_STIND_R4:\n\t\tcase CEE_STIND_R8:\n\t\tcase CEE_STIND_I:\n\t\t\tdo_store_indirect (&ctx, *ip);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_NOT:\n\t\tcase CEE_NEG:\n\t\t\tdo_unary_math_op (&ctx, *ip);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_I1:\n\t\tcase CEE_CONV_I2:\n\t\tcase CEE_CONV_I4:\n\t\tcase CEE_CONV_U1:\n\t\tcase CEE_CONV_U2:\n\t\tcase CEE_CONV_U4:\n\t\t\tdo_conversion (&ctx, TYPE_I4);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_I8:\n\t\tcase CEE_CONV_U8:\n\t\t\tdo_conversion (&ctx, TYPE_I8);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_R4:\n\t\tcase CEE_CONV_R8:\n\t\tcase CEE_CONV_R_UN:\n\t\t\tdo_conversion (&ctx, TYPE_R8);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_I:\n\t\tcase CEE_CONV_U:\n\t\t\tdo_conversion (&ctx, TYPE_NATIVE_INT);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CPOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_cpobj (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldobj_value (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDSTR:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldstr (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_NEWOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_newobj (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CASTCLASS:\n\t\tcase CEE_ISINST:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_cast (&ctx, read32 (ip + 1), *ip == CEE_CASTCLASS ? \"castclass\" : \"isinst\");\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_UNUSED58:\n\t\tcase CEE_UNUSED1:\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Use of the `unused' opcode\"));\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_UNBOX:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_unbox_value (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_THROW:\n\t\t\tdo_throw (&ctx);\n\t\t\tstart = 1;\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDFLD:\n\t\tcase CEE_LDFLDA:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_push_field (&ctx, read32 (ip + 1), *ip == CEE_LDFLDA);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDSFLD:\n\t\tcase CEE_LDSFLDA:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_push_static_field (&ctx, read32 (ip + 1), *ip == CEE_LDSFLDA);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STFLD:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_store_field (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STSFLD:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_store_static_field (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_stobj (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I1_UN:\n\t\tcase CEE_CONV_OVF_I2_UN:\n\t\tcase CEE_CONV_OVF_I4_UN:\n\t\tcase CEE_CONV_OVF_U1_UN:\n\t\tcase CEE_CONV_OVF_U2_UN:\n\t\tcase CEE_CONV_OVF_U4_UN:\n\t\t\tdo_conversion (&ctx, TYPE_I4);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_OVF_I8_UN:\n\t\tcase CEE_CONV_OVF_U8_UN:\n\t\t\tdo_conversion (&ctx, TYPE_I8);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_OVF_I_UN:\n\t\tcase CEE_CONV_OVF_U_UN:\n\t\t\tdo_conversion (&ctx, TYPE_NATIVE_INT);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_BOX:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_box_value (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_NEWARR:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_newarr (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDLEN:\n\t\t\tdo_ldlen (&ctx);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDELEMA:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldelema (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDELEM_I1:\n\t\tcase CEE_LDELEM_U1:\n\t\tcase CEE_LDELEM_I2:\n\t\tcase CEE_LDELEM_U2:\n\t\tcase CEE_LDELEM_I4:\n\t\tcase CEE_LDELEM_U4:\n\t\tcase CEE_LDELEM_I8:\n\t\tcase CEE_LDELEM_I:\n\t\tcase CEE_LDELEM_R4:\n\t\tcase CEE_LDELEM_R8:\n\t\tcase CEE_LDELEM_REF:\n\t\t\tdo_ldelem (&ctx, *ip, 0);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_STELEM_I:\n\t\tcase CEE_STELEM_I1:\n\t\tcase CEE_STELEM_I2:\n\t\tcase CEE_STELEM_I4:\n\t\tcase CEE_STELEM_I8:\n\t\tcase CEE_STELEM_R4:\n\t\tcase CEE_STELEM_R8:\n\t\tcase CEE_STELEM_REF:\n\t\t\tdo_stelem (&ctx, *ip, 0);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDELEM:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldelem (&ctx, *ip, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STELEM:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_stelem (&ctx, *ip, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\t\t\n\t\tcase CEE_UNBOX_ANY:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_unbox_any (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I1:\n\t\tcase CEE_CONV_OVF_U1:\n\t\tcase CEE_CONV_OVF_I2:\n\t\tcase CEE_CONV_OVF_U2:\n\t\tcase CEE_CONV_OVF_I4:\n\t\tcase CEE_CONV_OVF_U4:\n\t\t\tdo_conversion (&ctx, TYPE_I4);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I8:\n\t\tcase CEE_CONV_OVF_U8:\n\t\t\tdo_conversion (&ctx, TYPE_I8);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I:\n\t\tcase CEE_CONV_OVF_U:\n\t\t\tdo_conversion (&ctx, TYPE_NATIVE_INT);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_REFANYVAL:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_refanyval (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CKFINITE:\n\t\t\tdo_ckfinite (&ctx);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_MKREFANY:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_mkrefany (&ctx,  read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDTOKEN:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_load_token (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_ENDFINALLY:\n\t\t\tif (!is_correct_endfinally (ctx.header, ip_offset))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"endfinally must be used inside a finally/fault handler at 0x%04x\", ctx.ip_offset));\n\t\t\tctx.eval.size = 0;\n\t\t\tstart = 1;\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LEAVE:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_leave (&ctx, read32 (ip + 1) + 5);\n\t\t\tip += 5;\n\t\t\tstart = 1;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_LEAVE_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_leave (&ctx, (signed char)ip [1] + 2);\n\t\t\tip += 2;\n\t\t\tstart = 1;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_PREFIX1:\n\t\t\tcode_bounds_check (2);\n\t\t\t++ip;\n\t\t\tswitch (*ip) {\n\t\t\tcase CEE_STLOC:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tstore_local (&ctx, read16 (ip + 1));\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CEQ:\n\t\t\t\tdo_cmp_op (&ctx, cmp_br_eq_op, *ip);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CGT:\n\t\t\tcase CEE_CGT_UN:\n\t\t\tcase CEE_CLT:\n\t\t\tcase CEE_CLT_UN:\n\t\t\t\tdo_cmp_op (&ctx, cmp_br_op, *ip);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_STARG:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tstore_arg (&ctx, read16 (ip + 1) );\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\n\t\t\tcase CEE_ARGLIST:\n\t\t\t\tif (!check_overflow (&ctx))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ctx.signature->call_convention != MONO_CALL_VARARG)\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Cannot use arglist on method without VARGARG calling convention at 0x%04x\", ctx.ip_offset));\n\t\t\t\tset_stack_value (&ctx, stack_push (&ctx), &mono_defaults.argumenthandle_class->byval_arg, FALSE);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\n\t\t\tcase CEE_LDFTN:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_load_function_ptr (&ctx, read32 (ip + 1), FALSE);\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LDVIRTFTN:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_load_function_ptr (&ctx, read32 (ip + 1), TRUE);\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LDARG:\n\t\t\tcase CEE_LDARGA:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tpush_arg (&ctx, read16 (ip + 1),  *ip == CEE_LDARGA);\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LDLOC:\n\t\t\tcase CEE_LDLOCA:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tpush_local (&ctx, read16 (ip + 1), *ip == CEE_LDLOCA);\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LOCALLOC:\n\t\t\t\tdo_localloc (&ctx);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_UNUSED56:\n\t\t\tcase CEE_UNUSED57:\n\t\t\tcase CEE_UNUSED70:\n\t\t\tcase CEE_UNUSED:\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Use of the `unused' opcode\"));\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\t\tcase CEE_ENDFILTER:\n\t\t\t\tdo_endfilter (&ctx);\n\t\t\t\tstart = 1;\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\t\tcase CEE_UNALIGNED_:\n\t\t\t\tcode_bounds_check (2);\n\t\t\t\tprefix |= PREFIX_UNALIGNED;\n\t\t\t\tip += 2;\n\t\t\t\tbreak;\n\t\t\tcase CEE_VOLATILE_:\n\t\t\t\tprefix |= PREFIX_VOLATILE;\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\t\tcase CEE_TAIL_:\n\t\t\t\tprefix |= PREFIX_TAIL;\n\t\t\t\t++ip;\n\t\t\t\tif (ip < end && (*ip != CEE_CALL && *ip != CEE_CALLI && *ip != CEE_CALLVIRT))\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"tail prefix must be used only with call opcodes at 0x%04x\", ip_offset));\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_INITOBJ:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_initobj (&ctx, read32 (ip + 1));\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CONSTRAINED_:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tctx.constrained_type = get_boxable_mono_type (&ctx, read32 (ip + 1), \"constrained.\");\n\t\t\t\tprefix |= PREFIX_CONSTRAINED;\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\t\n\t\t\tcase CEE_READONLY_:\n\t\t\t\tprefix |= PREFIX_READONLY;\n\t\t\t\tip++;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CPBLK:\n\t\t\t\tCLEAR_PREFIX (&ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\t\t\t\tif (!check_underflow (&ctx, 3))\n\t\t\t\t\tbreak;\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Instruction cpblk is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\t\tip++;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase CEE_INITBLK:\n\t\t\t\tCLEAR_PREFIX (&ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\t\t\t\tif (!check_underflow (&ctx, 3))\n\t\t\t\t\tbreak;\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Instruction initblk is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\t\tip++;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase CEE_NO_:\n\t\t\t\tip += 2;\n\t\t\t\tbreak;\n\t\t\tcase CEE_RETHROW:\n\t\t\t\tif (!is_correct_rethrow (ctx.header, ip_offset))\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"rethrow must be used inside a catch handler at 0x%04x\", ctx.ip_offset));\n\t\t\t\tctx.eval.size = 0;\n\t\t\t\tstart = 1;\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_SIZEOF:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_sizeof (&ctx, read32 (ip + 1));\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_REFANYTYPE:\n\t\t\t\tdo_refanytype (&ctx);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction FE %x at 0x%04x\", *ip, ctx.ip_offset));\n\t\t\t\t++ip;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction %x at 0x%04x\", *ip, ctx.ip_offset));\n\t\t\t++ip;\n\t\t}\n\n\t\t/*TODO we can fast detect a forward branch or exception block targeting code after prefix, we should fail fast*/\n\t\tif (prefix) {\n\t\t\tif (!ctx.prefix_set) //first prefix\n\t\t\t\tctx.code [ctx.ip_offset].flags |= IL_CODE_FLAG_SEEN;\n\t\t\tctx.prefix_set |= prefix;\n\t\t\tctx.has_flags = TRUE;\n\t\t\tprefix = 0;\n\t\t} else {\n\t\t\tif (!ctx.has_flags)\n\t\t\t\tctx.code [ctx.ip_offset].flags |= IL_CODE_FLAG_SEEN;\n\n\t\t\tif (ctx.prefix_set & PREFIX_CONSTRAINED)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after constrained prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tif (ctx.prefix_set & PREFIX_READONLY)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after readonly prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tif (ctx.prefix_set & PREFIX_VOLATILE)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after volatile prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tif (ctx.prefix_set & PREFIX_UNALIGNED)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after unaligned prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tctx.prefix_set = prefix = 0;\n\t\t\tctx.has_flags = FALSE;\n\t\t}\n\t}\n\t/*\n\t * if ip != end we overflowed: mark as error.\n\t */\n\tif ((ip != end || !start) && ctx.verifiable && !ctx.list) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Run ahead of method code at 0x%04x\", ip_offset));\n\t}\n\n\t/*We should guard against the last decoded opcode, otherwise we might add errors that doesn't make sense.*/\n\tfor (i = 0; i < ctx.code_size && i < ip_offset; ++i) {\n\t\tif (ctx.code [i].flags & IL_CODE_FLAG_WAS_TARGET) {\n\t\t\tif (!(ctx.code [i].flags & IL_CODE_FLAG_SEEN))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or exception block target middle of intruction at 0x%04x\", i));\n\n\t\t\tif (ctx.code [i].flags & IL_CODE_DELEGATE_SEQUENCE)\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Branch to delegate code sequence at 0x%04x\", i));\n\t\t}\n\t\tif ((ctx.code [i].flags & IL_CODE_LDFTN_DELEGATE_NONFINAL_VIRTUAL) && ctx.has_this_store)\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Invalid ldftn with virtual function in method with stdarg 0 at  0x%04x\", i));\n\n\t\tif ((ctx.code [i].flags & IL_CODE_CALL_NONFINAL_VIRTUAL) && ctx.has_this_store)\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Invalid call to a non-final virtual function in method with stdarg.0 or ldarga.0 at  0x%04x\", i));\n\t}\n\n\tif (mono_method_is_constructor (ctx.method) && !ctx.super_ctor_called && !ctx.method->klass->valuetype && ctx.method->klass != mono_defaults.object_class)\n\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Constructor not calling super\\n\"));\n\ncleanup:\n\tif (ctx.code) {\n\t\tfor (i = 0; i < ctx.header->code_size; ++i) {\n\t\t\tif (ctx.code [i].stack)\n\t\t\t\tg_free (ctx.code [i].stack);\n\t\t}\n\t}\n\n\tfor (tmp = ctx.funptrs; tmp; tmp = tmp->next)\n\t\tg_free (tmp->data);\n\tg_slist_free (ctx.funptrs);\n\n\tfor (tmp = ctx.exception_types; tmp; tmp = tmp->next)\n\t\tmono_metadata_free_type (tmp->data);\n\tg_slist_free (ctx.exception_types);\n\n\tfor (i = 0; i < ctx.num_locals; ++i) {\n\t\tif (ctx.locals [i])\n\t\t\tmono_metadata_free_type (ctx.locals [i]);\n\t}\n\tfor (i = 0; i < ctx.max_args; ++i) {\n\t\tif (ctx.params [i])\n\t\t\tmono_metadata_free_type (ctx.params [i]);\n\t}\n\n\tif (ctx.eval.stack)\n\t\tg_free (ctx.eval.stack);\n\tif (ctx.code)\n\t\tg_free (ctx.code);\n\tg_free (ctx.locals);\n\tg_free (ctx.params);\n\tmono_basic_block_free (original_bb);\n\n\treturn ctx.list;\n}\n\nchar*\nmono_verify_corlib ()\n{\n\t/* This is a public API function so cannot be removed */\n\treturn NULL;\n}\n\n/*\n * Returns true if @method needs to be verified.\n * \n */\ngboolean\nmono_verifier_is_enabled_for_method (MonoMethod *method)\n{\n\treturn mono_verifier_is_enabled_for_class (method->klass) && method->wrapper_type == MONO_WRAPPER_NONE;\n}\n\n/*\n * Returns true if @klass need to be verified.\n * \n */\ngboolean\nmono_verifier_is_enabled_for_class (MonoClass *klass)\n{\n\treturn verify_all || (verifier_mode > MONO_VERIFIER_MODE_OFF && !klass->image->assembly->in_gac && klass->image != mono_defaults.corlib);\n}\n\ngboolean\nmono_verifier_is_enabled_for_image (MonoImage *image)\n{\n\treturn verify_all || verifier_mode > MONO_VERIFIER_MODE_OFF;\n}\n\ngboolean\nmono_verifier_is_method_full_trust (MonoMethod *method)\n{\n\treturn mono_verifier_is_class_full_trust (method->klass);\n}\n\n/*\n * Returns if @klass is under full trust or not.\n * \n * TODO This code doesn't take CAS into account.\n * \n * Under verify_all all user code must be verifiable if no security option was set \n * \n */\ngboolean\nmono_verifier_is_class_full_trust (MonoClass *klass)\n{\n\t/* under CoreCLR code is trusted if it is part of the \"platform\" otherwise all code inside the GAC is trusted */\n\tgboolean trusted_location = (mono_security_get_mode () != MONO_SECURITY_MODE_CORE_CLR) ? \n\t\tklass->image->assembly->in_gac : mono_security_core_clr_is_platform_image (klass->image);\n\n\tif (verify_all && verifier_mode == MONO_VERIFIER_MODE_OFF)\n\t\treturn trusted_location || klass->image == mono_defaults.corlib;\n\treturn verifier_mode < MONO_VERIFIER_MODE_VERIFIABLE || trusted_location || klass->image == mono_defaults.corlib;\n}\n\nGSList*\nmono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility)\n{\n\treturn mono_method_verify (method, \n\t\t\t(verifier_mode != MONO_VERIFIER_MODE_STRICT ? MONO_VERIFY_NON_STRICT: 0)\n\t\t\t| (!mono_verifier_is_method_full_trust (method) ? MONO_VERIFY_FAIL_FAST : 0)\n\t\t\t| (skip_visibility ? MONO_VERIFY_SKIP_VISIBILITY : 0));\n}\n\nstatic int\nget_field_end (MonoClassField *field)\n{\n\tint align;\n\tint size = mono_type_size (field->type, &align);\n\tif (size == 0)\n\t\tsize = 4; /*FIXME Is this a safe bet?*/\n\treturn size + field->offset;\n}\n\nstatic gboolean\nverify_class_for_overlapping_reference_fields (MonoClass *class)\n{\n\tint i = 0, j;\n\tgpointer iter = NULL;\n\tMonoClassField *field;\n\tgboolean is_fulltrust = mono_verifier_is_class_full_trust (class);\n\t/*We can't skip types with !has_references since this is calculated after we have run.*/\n\tif (!((class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT))\n\t\treturn TRUE;\n\n\n\t/*We must check for stuff overlapping reference fields.\n\t  The outer loop uses mono_class_get_fields to ensure that MonoClass:fields get inited.\n\t*/\n\twhile ((field = mono_class_get_fields (class, &iter))) {\n\t\tint fieldEnd = get_field_end (field);\n\t\tgboolean is_valuetype = !MONO_TYPE_IS_REFERENCE (field->type);\n\t\t++i;\n\n\t\tif (mono_field_is_deleted (field) || (field->type->attrs & FIELD_ATTRIBUTE_STATIC))\n\t\t\tcontinue;\n\n\t\tfor (j = i; j < class->field.count; ++j) {\n\t\t\tMonoClassField *other = &class->fields [j];\n\t\t\tint otherEnd = get_field_end (other);\n\t\t\tif (mono_field_is_deleted (other) || (is_valuetype && !MONO_TYPE_IS_REFERENCE (other->type)) || (other->type->attrs & FIELD_ATTRIBUTE_STATIC))\n\t\t\t\tcontinue;\n\n\t\t\tif (!is_valuetype && MONO_TYPE_IS_REFERENCE (other->type) && field->offset == other->offset && is_fulltrust)\n\t\t\t\tcontinue;\n\n\t\t\tif ((otherEnd > field->offset && otherEnd <= fieldEnd) || (other->offset >= field->offset && other->offset < fieldEnd))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nstatic guint\nfield_hash (gconstpointer key)\n{\n\tconst MonoClassField *field = key;\n\treturn g_str_hash (field->name) ^ mono_metadata_type_hash (field->type); /**/\n}\n\nstatic gboolean\nfield_equals (gconstpointer _a, gconstpointer _b)\n{\n\tconst MonoClassField *a = _a;\n\tconst MonoClassField *b = _b;\n\treturn !strcmp (a->name, b->name) && mono_metadata_type_equal (a->type, b->type);\n}\n\n\nstatic gboolean\nverify_class_fields (MonoClass *class)\n{\n\tgpointer iter = NULL;\n\tMonoClassField *field;\n\tMonoGenericContext *context = mono_class_get_context (class);\n\tGHashTable *unique_fields = g_hash_table_new_full (&field_hash, &field_equals, NULL, NULL);\n\tif (class->generic_container)\n\t\tcontext = &class->generic_container->context;\n\n\twhile ((field = mono_class_get_fields (class, &iter)) != NULL) {\n\t\tif (!mono_type_is_valid_type_in_context (field->type, context)) {\n\t\t\tg_hash_table_destroy (unique_fields);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (g_hash_table_lookup (unique_fields, field)) {\n\t\t\tg_hash_table_destroy (unique_fields);\n\t\t\treturn FALSE;\n\t\t}\n\t\tg_hash_table_insert (unique_fields, field, field);\n\t}\n\tg_hash_table_destroy (unique_fields);\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_interfaces (MonoClass *class)\n{\n\tint i;\n\tfor (i = 0; i < class->interface_count; ++i) {\n\t\tMonoClass *iface = class->interfaces [i];\n\t\tif (!(iface->flags & TYPE_ATTRIBUTE_INTERFACE))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_valuetype_layout_with_target (MonoClass *class, MonoClass *target_class)\n{\n\tint type;\n\tgpointer iter = NULL;\n\tMonoClassField *field;\n\tMonoClass *field_class;\n\n\tif (!class->valuetype)\n\t\treturn TRUE;\n\n\ttype = class->byval_arg.type;\n\t/*primitive type fields are not properly decoded*/\n\tif ((type >= MONO_TYPE_BOOLEAN && type <= MONO_TYPE_R8) || (type >= MONO_TYPE_I && type <= MONO_TYPE_U))\n\t\treturn TRUE;\n\n\twhile ((field = mono_class_get_fields (class, &iter)) != NULL) {\n\t\tif (!field->type)\n\t\t\treturn FALSE;\n\n\t\tif (field->type->attrs & (FIELD_ATTRIBUTE_STATIC | FIELD_ATTRIBUTE_HAS_FIELD_RVA))\n\t\t\tcontinue;\n\n\t\tfield_class = mono_class_get_generic_type_definition (mono_class_from_mono_type (field->type));\n\n\t\tif (field_class == target_class || class == field_class || !verify_valuetype_layout_with_target (field_class, target_class))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_valuetype_layout (MonoClass *class)\n{\n\tgboolean res;\n\tres = verify_valuetype_layout_with_target (class, class);\n\treturn res;\n}\n\nstatic gboolean\nrecursive_mark_constraint_args (MonoBitSet *used_args, MonoGenericContainer *gc, MonoType *type)\n{\n\tint idx;\n\tMonoClass **constraints;\n\tMonoGenericParamInfo *param_info;\n\n\tg_assert (mono_type_is_generic_argument (type));\n\n\tidx = mono_type_get_generic_param_num (type);\n\tif (mono_bitset_test_fast (used_args, idx))\n\t\treturn FALSE;\n\n\tmono_bitset_set_fast (used_args, idx);\n\tparam_info = mono_generic_container_get_param_info (gc, idx);\n\n\tif (!param_info->constraints)\n\t\treturn TRUE;\n\n\tfor (constraints = param_info->constraints; *constraints; ++constraints) {\n\t\tMonoClass *ctr = *constraints;\n\t\tMonoType *constraint_type = &ctr->byval_arg;\n\n\t\tif (mono_type_is_generic_argument (constraint_type) && !recursive_mark_constraint_args (used_args, gc, constraint_type))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_generic_parameters (MonoClass *class)\n{\n\tint i;\n\tMonoGenericContainer *gc = class->generic_container;\n\tMonoBitSet *used_args = mono_bitset_new (gc->type_argc, 0);\n\n\tfor (i = 0; i < gc->type_argc; ++i) {\n\t\tMonoGenericParamInfo *param_info = mono_generic_container_get_param_info (gc, i);\n\t\tMonoClass **constraints;\n\n\t\tif (!param_info->constraints)\n\t\t\tcontinue;\n\n\t\tmono_bitset_clear_all (used_args);\n\t\tmono_bitset_set_fast (used_args, i);\n\n\t\tfor (constraints = param_info->constraints; *constraints; ++constraints) {\n\t\t\tMonoClass *ctr = *constraints;\n\t\t\tMonoType *constraint_type = &ctr->byval_arg;\n\n\t\t\tif (!mono_type_is_valid_type_in_context (constraint_type, &gc->context))\n\t\t\t\tgoto fail;\n\n\t\t\tif (mono_type_is_generic_argument (constraint_type) && !recursive_mark_constraint_args (used_args, gc, constraint_type))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tmono_bitset_free (used_args);\n\treturn TRUE;\n\nfail:\n\tmono_bitset_free (used_args);\n\treturn FALSE;\n}\n\n/*\n * Check if the class is verifiable.\n * \n * Right now there are no conditions that make a class a valid but not verifiable. Both overlapping reference\n * field and invalid generic instantiation are fatal errors.\n * \n * This method must be safe to be called from mono_class_init and all code must be carefull about that.\n * \n */\ngboolean\nmono_verifier_verify_class (MonoClass *class)\n{\n\t/*Neither <Module>, object or ifaces have parent.*/\n\tif (!class->parent &&\n\t\tclass != mono_defaults.object_class && \n\t\t!MONO_CLASS_IS_INTERFACE (class) &&\n\t\t(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/\n\t\treturn FALSE;\n\tif (class->parent && MONO_CLASS_IS_INTERFACE (class->parent))\n\t\treturn FALSE;\n\tif (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)\n\t\treturn FALSE;\n\tif (class->generic_container && !verify_generic_parameters (class))\n\t\treturn FALSE;\n\tif (!verify_class_for_overlapping_reference_fields (class))\n\t\treturn FALSE;\n\tif (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))\n\t\treturn FALSE;\n\tif (class->generic_class == NULL && !verify_class_fields (class))\n\t\treturn FALSE;\n\tif (class->valuetype && !verify_valuetype_layout (class))\n\t\treturn FALSE;\n\tif (!verify_interfaces (class))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n{\n\treturn mono_class_is_valid_generic_instantiation (NULL, class);\n}\n\n#else\n\ngboolean\nmono_verifier_verify_class (MonoClass *class)\n{\n\t/* The verifier was disabled at compile time */\n\treturn TRUE;\n}\n\nGSList*\nmono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;\n}\n\ngboolean\nmono_verifier_is_class_full_trust (MonoClass *klass)\n{\n\t/* The verifier was disabled at compile time */\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_is_method_full_trust (MonoMethod *method)\n{\n\t/* The verifier was disabled at compile time */\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_is_enabled_for_image (MonoImage *image)\n{\n\t/* The verifier was disabled at compile time */\n\treturn FALSE;\n}\n\ngboolean\nmono_verifier_is_enabled_for_class (MonoClass *klass)\n{\n\t/* The verifier was disabled at compile time */\n\treturn FALSE;\n}\n\ngboolean\nmono_verifier_is_enabled_for_method (MonoMethod *method)\n{\n\t/* The verifier was disabled at compile time */\n\treturn FALSE;\n}\n\nGSList*\nmono_method_verify (MonoMethod *method, int level)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;\n}\n\nvoid\nmono_free_verify_list (GSList *list)\n{\n\t/* The verifier was disabled at compile time */\n\t/* will always be null if verifier is disabled */\n}\n\nGSList*\nmono_image_verify_tables (MonoImage *image, int level)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;\n}\t\n\ngboolean\nmono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n{\n\treturn TRUE;\n}\n\n\n#endif\n"], "fixing_code": ["/*\n * reflection.c: Routines for creating an image at runtime.\n * \n * Author:\n *   Paolo Molaro (lupus@ximian.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n *\n */\n#include <config.h>\n#include \"mono/utils/mono-digest.h\"\n#include \"mono/utils/mono-membar.h\"\n#include \"mono/metadata/reflection.h\"\n#include \"mono/metadata/tabledefs.h\"\n#include \"mono/metadata/metadata-internals.h\"\n#include <mono/metadata/profiler-private.h>\n#include \"mono/metadata/class-internals.h\"\n#include \"mono/metadata/gc-internal.h\"\n#include \"mono/metadata/tokentype.h\"\n#include \"mono/metadata/domain-internals.h\"\n#include \"mono/metadata/opcodes.h\"\n#include \"mono/metadata/assembly.h\"\n#include \"mono/metadata/object-internals.h\"\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/security-manager.h>\n#include <stdio.h>\n#include <glib.h>\n#include <errno.h>\n#include <time.h>\n#include <string.h>\n#include <ctype.h>\n#include \"image.h\"\n#include \"cil-coff.h\"\n#include \"mono-endian.h\"\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/utils/mono-string.h>\n#include <mono/utils/mono-error-internals.h>\n\n\n#if HAVE_SGEN_GC\nstatic void* reflection_info_desc = NULL;\n#define MOVING_GC_REGISTER(addr) do {\t\\\n\t\tif (!reflection_info_desc) {\t\\\n\t\t\tgsize bmap = 1;\t\t\\\n\t\t\treflection_info_desc = mono_gc_make_descr_from_bitmap (&bmap, 1);\t\\\n\t\t}\t\\\n\t\tmono_gc_register_root ((char*)(addr), sizeof (gpointer), reflection_info_desc); \\\n\t} while (0)\n#else\n#define MOVING_GC_REGISTER(addr)\n#endif\n\ntypedef struct {\n\tchar *p;\n\tchar *buf;\n\tchar *end;\n} SigBuffer;\n\n#define TEXT_OFFSET 512\n#define CLI_H_SIZE 136\n#define FILE_ALIGN 512\n#define VIRT_ALIGN 8192\n#define START_TEXT_RVA  0x00002000\n\ntypedef struct {\n\tMonoReflectionILGen *ilgen;\n\tMonoReflectionType *rtype;\n\tMonoArray *parameters;\n\tMonoArray *generic_params;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *pinfo;\n\tMonoArray *opt_types;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tguint32 call_conv;\n\tguint32 *table_idx; /* note: it's a pointer */\n\tMonoArray *code;\n\tMonoObject *type;\n\tMonoString *name;\n\tMonoBoolean init_locals;\n\tMonoBoolean skip_visibility;\n\tMonoArray *return_modreq;\n\tMonoArray *return_modopt;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n\tMonoMethod *mhandle;\n\tguint32 nrefs;\n\tgpointer *refs;\n\t/* for PInvoke */\n\tint charset, extra_flags, native_cc;\n\tMonoString *dll, *dllentry;\n} ReflectionMethodBuilder;\n\ntypedef struct {\n\tguint32 owner;\n\tMonoReflectionGenericParam *gparam;\n} GenericParamTableEntry;\n\nconst unsigned char table_sizes [MONO_TABLE_NUM] = {\n\tMONO_MODULE_SIZE,\n\tMONO_TYPEREF_SIZE,\n\tMONO_TYPEDEF_SIZE,\n\t0,\n\tMONO_FIELD_SIZE,\n\t0,\n\tMONO_METHOD_SIZE,\n\t0,\n\tMONO_PARAM_SIZE,\n\tMONO_INTERFACEIMPL_SIZE,\n\tMONO_MEMBERREF_SIZE,\t/* 0x0A */\n\tMONO_CONSTANT_SIZE,\n\tMONO_CUSTOM_ATTR_SIZE,\n\tMONO_FIELD_MARSHAL_SIZE,\n\tMONO_DECL_SECURITY_SIZE,\n\tMONO_CLASS_LAYOUT_SIZE,\n\tMONO_FIELD_LAYOUT_SIZE,\t/* 0x10 */\n\tMONO_STAND_ALONE_SIGNATURE_SIZE,\n\tMONO_EVENT_MAP_SIZE,\n\t0,\n\tMONO_EVENT_SIZE,\n\tMONO_PROPERTY_MAP_SIZE,\n\t0,\n\tMONO_PROPERTY_SIZE,\n\tMONO_METHOD_SEMA_SIZE,\n\tMONO_METHODIMPL_SIZE,\n\tMONO_MODULEREF_SIZE,\t/* 0x1A */\n\tMONO_TYPESPEC_SIZE,\n\tMONO_IMPLMAP_SIZE,\t\n\tMONO_FIELD_RVA_SIZE,\n\t0,\n\t0,\n\tMONO_ASSEMBLY_SIZE,\t/* 0x20 */\n\tMONO_ASSEMBLY_PROCESSOR_SIZE,\n\tMONO_ASSEMBLYOS_SIZE,\n\tMONO_ASSEMBLYREF_SIZE,\n\tMONO_ASSEMBLYREFPROC_SIZE,\n\tMONO_ASSEMBLYREFOS_SIZE,\n\tMONO_FILE_SIZE,\n\tMONO_EXP_TYPE_SIZE,\n\tMONO_MANIFEST_SIZE,\n\tMONO_NESTED_CLASS_SIZE,\n\n\tMONO_GENERICPARAM_SIZE,\t/* 0x2A */\n\tMONO_METHODSPEC_SIZE,\n\tMONO_GENPARCONSTRAINT_SIZE\n\n};\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32 mono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec);\nstatic guint32 mono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec);\nstatic guint32 mono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *cb);\nstatic guint32 mono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper);\nstatic void    ensure_runtime_vtable (MonoClass *klass);\nstatic gpointer resolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context);\nstatic guint32 mono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method);\nstatic guint32 encode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context);\nstatic gpointer register_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly);\nstatic void reflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb);\nstatic void reflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb);\n#endif\n\nstatic guint32 mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type);\nstatic guint32 mono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec);\nstatic void    mono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly);\nstatic guint32 encode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo);\nstatic guint32 encode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type);\nstatic char*   type_get_qualified_name (MonoType *type, MonoAssembly *ass);\nstatic void    encode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf);\nstatic void get_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types);\nstatic MonoObject *mono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob);\nstatic MonoReflectionType *mono_reflection_type_get_underlying_system_type (MonoReflectionType* t);\nstatic MonoType* mono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve);\nstatic MonoReflectionType* mono_reflection_type_resolve_user_types (MonoReflectionType *type);\nstatic gboolean is_sre_array (MonoClass *class);\nstatic gboolean is_sre_byref (MonoClass *class);\nstatic gboolean is_sre_pointer (MonoClass *class);\nstatic gboolean is_sre_method_builder (MonoClass *class);\nstatic gboolean is_sre_ctor_builder (MonoClass *class);\nstatic gboolean is_sr_mono_method (MonoClass *class);\nstatic gboolean is_sr_mono_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_generic_method (MonoClass *class);\nstatic gboolean is_sr_mono_generic_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_field (MonoClass *class);\nstatic gboolean is_sr_mono_property (MonoClass *class);\nstatic gboolean is_sre_method_on_tb_inst (MonoClass *class);\nstatic gboolean is_sre_ctor_on_tb_inst (MonoClass *class);\n\nstatic guint32 mono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method);\nstatic guint32 mono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m);\nstatic MonoMethod * inflate_method (MonoReflectionGenericClass *type, MonoObject *obj);\n\n#define RESOLVE_TYPE(type) do { type = (void*)mono_reflection_type_resolve_user_types ((MonoReflectionType*)type); } while (0)\n#define RESOLVE_ARRAY_TYPE_ELEMENT(array, index) do {\t\\\n\tMonoReflectionType *__type = mono_array_get (array, MonoReflectionType*, index);\t\\\n\t__type = mono_reflection_type_resolve_user_types (__type);\t\\\n\tmono_array_set (arr, MonoReflectionType*, index, __type);\t\\\n} while (0)\n\n#define mono_type_array_get_and_resolve(array, index) mono_reflection_type_get_handle ((MonoReflectionType*)mono_array_get (array, gpointer, index))\n\nvoid\nmono_reflection_init (void)\n{\n}\n\nstatic void\nsigbuffer_init (SigBuffer *buf, int size)\n{\n\tbuf->buf = g_malloc (size);\n\tbuf->p = buf->buf;\n\tbuf->end = buf->buf + size;\n}\n\nstatic void\nsigbuffer_make_room (SigBuffer *buf, int size)\n{\n\tif (buf->end - buf->p < size) {\n\t\tint new_size = buf->end - buf->buf + size + 32;\n\t\tchar *p = g_realloc (buf->buf, new_size);\n\t\tsize = buf->p - buf->buf;\n\t\tbuf->buf = p;\n\t\tbuf->p = p + size;\n\t\tbuf->end = buf->buf + new_size;\n\t}\n}\n\nstatic void\nsigbuffer_add_value (SigBuffer *buf, guint32 val)\n{\n\tsigbuffer_make_room (buf, 6);\n\tmono_metadata_encode_value (val, buf->p, &buf->p);\n}\n\nstatic void\nsigbuffer_add_byte (SigBuffer *buf, guint8 val)\n{\n\tsigbuffer_make_room (buf, 1);\n\tbuf->p [0] = val;\n\tbuf->p++;\n}\n\nstatic void\nsigbuffer_add_mem (SigBuffer *buf, char *p, guint32 size)\n{\n\tsigbuffer_make_room (buf, size);\n\tmemcpy (buf->p, p, size);\n\tbuf->p += size;\n}\n\nstatic void\nsigbuffer_free (SigBuffer *buf)\n{\n\tg_free (buf->buf);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/**\n * mp_g_alloc:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc (image, size);\n\telse\n\t\treturn g_malloc (size);\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/**\n * image_g_alloc0:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc0 (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc0 (image, size);\n\telse\n\t\treturn g_malloc0 (size);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic char*\nimage_strdup (MonoImage *image, const char *s)\n{\n\tif (image)\n\t\treturn mono_image_strdup (image, s);\n\telse\n\t\treturn g_strdup (s);\n}\n#endif\n\n#define image_g_new(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n#define image_g_new0(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc0 (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n\nstatic void\nalloc_table (MonoDynamicTable *table, guint nrows)\n{\n\ttable->rows = nrows;\n\tg_assert (table->columns);\n\tif (nrows + 1 >= table->alloc_rows) {\n\t\twhile (nrows + 1 >= table->alloc_rows) {\n\t\t\tif (table->alloc_rows == 0)\n\t\t\t\ttable->alloc_rows = 16;\n\t\t\telse\n\t\t\t\ttable->alloc_rows *= 2;\n\t\t}\n\n\t\ttable->values = g_renew (guint32, table->values, (table->alloc_rows) * table->columns);\n\t}\n}\n\nstatic void\nmake_room_in_stream (MonoDynamicStream *stream, int size)\n{\n\tif (size <= stream->alloc_size)\n\t\treturn;\n\t\n\twhile (stream->alloc_size <= size) {\n\t\tif (stream->alloc_size < 4096)\n\t\t\tstream->alloc_size = 4096;\n\t\telse\n\t\t\tstream->alloc_size *= 2;\n\t}\n\t\n\tstream->data = g_realloc (stream->data, stream->alloc_size);\n}\n\nstatic guint32\nstring_heap_insert (MonoDynamicStream *sh, const char *str)\n{\n\tguint32 idx;\n\tguint32 len;\n\tgpointer oldkey, oldval;\n\n\tif (g_hash_table_lookup_extended (sh->hash, str, &oldkey, &oldval))\n\t\treturn GPOINTER_TO_UINT (oldval);\n\n\tlen = strlen (str) + 1;\n\tidx = sh->index;\n\t\n\tmake_room_in_stream (sh, idx + len);\n\n\t/*\n\t * We strdup the string even if we already copy them in sh->data\n\t * so that the string pointers in the hash remain valid even if\n\t * we need to realloc sh->data. We may want to avoid that later.\n\t */\n\tg_hash_table_insert (sh->hash, g_strdup (str), GUINT_TO_POINTER (idx));\n\tmemcpy (sh->data + idx, str, len);\n\tsh->index += len;\n\treturn idx;\n}\n\nstatic guint32\nstring_heap_insert_mstring (MonoDynamicStream *sh, MonoString *str)\n{\n\tchar *name = mono_string_to_utf8 (str);\n\tguint32 idx;\n\tidx = string_heap_insert (sh, name);\n\tg_free (name);\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nstring_heap_init (MonoDynamicStream *sh)\n{\n\tsh->index = 0;\n\tsh->alloc_size = 4096;\n\tsh->data = g_malloc (4096);\n\tsh->hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\tstring_heap_insert (sh, \"\");\n}\n#endif\n\nstatic guint32\nmono_image_add_stream_data (MonoDynamicStream *stream, const char *data, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemcpy (stream->data + stream->index, data, len);\n\tidx = stream->index;\n\tstream->index += len;\n\t/* \n\t * align index? Not without adding an additional param that controls it since\n\t * we may store a blob value in pieces.\n\t */\n\treturn idx;\n}\n\nstatic guint32\nmono_image_add_stream_zero (MonoDynamicStream *stream, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemset (stream->data + stream->index, 0, len);\n\tidx = stream->index;\n\tstream->index += len;\n\treturn idx;\n}\n\nstatic void\nstream_data_align (MonoDynamicStream *stream)\n{\n\tchar buf [4] = {0};\n\tguint32 count = stream->index % 4;\n\n\t/* we assume the stream data will be aligned */\n\tif (count)\n\t\tmono_image_add_stream_data (stream, buf, 4 - count);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic int\nmono_blob_entry_hash (const char* str)\n{\n\tguint len, h;\n\tconst char *end;\n\tlen = mono_metadata_decode_blob_size (str, &str);\n\tif (len > 0) {\n\t\tend = str + len;\n\t\th = *str;\n\t\tfor (str += 1; str < end; str++)\n\t\t\th = (h << 5) - h + *str;\n\t\treturn h;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic gboolean\nmono_blob_entry_equal (const char *str1, const char *str2) {\n\tint len, len2;\n\tconst char *end1;\n\tconst char *end2;\n\tlen = mono_metadata_decode_blob_size (str1, &end1);\n\tlen2 = mono_metadata_decode_blob_size (str2, &end2);\n\tif (len != len2)\n\t\treturn 0;\n\treturn memcmp (end1, end2, len) == 0;\n}\n#endif\nstatic guint32\nadd_to_blob_cached (MonoDynamicImage *assembly, char *b1, int s1, char *b2, int s2)\n{\n\tguint32 idx;\n\tchar *copy;\n\tgpointer oldkey, oldval;\n\n\tcopy = g_malloc (s1+s2);\n\tmemcpy (copy, b1, s1);\n\tmemcpy (copy + s1, b2, s2);\n\tif (g_hash_table_lookup_extended (assembly->blob_cache, copy, &oldkey, &oldval)) {\n\t\tg_free (copy);\n\t\tidx = GPOINTER_TO_UINT (oldval);\n\t} else {\n\t\tidx = mono_image_add_stream_data (&assembly->blob, b1, s1);\n\t\tmono_image_add_stream_data (&assembly->blob, b2, s2);\n\t\tg_hash_table_insert (assembly->blob_cache, copy, GUINT_TO_POINTER (idx));\n\t}\n\treturn idx;\n}\n\nstatic guint32\nsigbuffer_add_to_blob_cached (MonoDynamicImage *assembly, SigBuffer *buf)\n{\n\tchar blob_size [8];\n\tchar *b = blob_size;\n\tguint32 size = buf->p - buf->buf;\n\t/* store length */\n\tg_assert (size <= (buf->end - buf->buf));\n\tmono_metadata_encode_value (size, b, &b);\n\treturn add_to_blob_cached (assembly, blob_size, b-blob_size, buf->buf, size);\n}\n\n/*\n * Copy len * nelem bytes from val to dest, swapping bytes to LE if necessary.\n * dest may be misaligned.\n */\nstatic void\nswap_with_size (char *dest, const char* val, int len, int nelem) {\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tint elem;\n\n\tfor (elem = 0; elem < nelem; ++elem) {\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\t*dest = *val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdest [0] = val [1];\n\t\t\tdest [1] = val [0];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdest [0] = val [3];\n\t\t\tdest [1] = val [2];\n\t\t\tdest [2] = val [1];\n\t\t\tdest [3] = val [0];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdest [0] = val [7];\n\t\t\tdest [1] = val [6];\n\t\t\tdest [2] = val [5];\n\t\t\tdest [3] = val [4];\n\t\t\tdest [4] = val [3];\n\t\t\tdest [5] = val [2];\n\t\t\tdest [6] = val [1];\n\t\t\tdest [7] = val [0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tdest += len;\n\t\tval += len;\n\t}\n#else\n\tmemcpy (dest, val, len * nelem);\n#endif\n}\n\nstatic guint32\nadd_mono_string_to_blob_cached (MonoDynamicImage *assembly, MonoString *str)\n{\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tguint32 idx = 0, len;\n\n\tlen = str->length * 2;\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\tg_free (swapped);\n\t}\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoClass *\ndefault_class_from_mono_type (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_OBJECT:\n\t\treturn mono_defaults.object_class;\n\tcase MONO_TYPE_VOID:\n\t\treturn mono_defaults.void_class;\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn mono_defaults.boolean_class;\n\tcase MONO_TYPE_CHAR:\n\t\treturn mono_defaults.char_class;\n\tcase MONO_TYPE_I1:\n\t\treturn mono_defaults.sbyte_class;\n\tcase MONO_TYPE_U1:\n\t\treturn mono_defaults.byte_class;\n\tcase MONO_TYPE_I2:\n\t\treturn mono_defaults.int16_class;\n\tcase MONO_TYPE_U2:\n\t\treturn mono_defaults.uint16_class;\n\tcase MONO_TYPE_I4:\n\t\treturn mono_defaults.int32_class;\n\tcase MONO_TYPE_U4:\n\t\treturn mono_defaults.uint32_class;\n\tcase MONO_TYPE_I:\n\t\treturn mono_defaults.int_class;\n\tcase MONO_TYPE_U:\n\t\treturn mono_defaults.uint_class;\n\tcase MONO_TYPE_I8:\n\t\treturn mono_defaults.int64_class;\n\tcase MONO_TYPE_U8:\n\t\treturn mono_defaults.uint64_class;\n\tcase MONO_TYPE_R4:\n\t\treturn mono_defaults.single_class;\n\tcase MONO_TYPE_R8:\n\t\treturn mono_defaults.double_class;\n\tcase MONO_TYPE_STRING:\n\t\treturn mono_defaults.string_class;\n\tdefault:\n\t\tg_warning (\"default_class_from_mono_type: implement me 0x%02x\\n\", type->type);\n\t\tg_assert_not_reached ();\n\t}\n\t\n\treturn NULL;\n}\n#endif\n\nstatic void\nencode_generic_class (MonoDynamicImage *assembly, MonoGenericClass *gclass, SigBuffer *buf)\n{\n\tint i;\n\tMonoGenericInst *class_inst;\n\tMonoClass *klass;\n\n\tg_assert (gclass);\n\n\tclass_inst = gclass->context.class_inst;\n\n\tsigbuffer_add_value (buf, MONO_TYPE_GENERICINST);\n\tklass = gclass->container_class;\n\tsigbuffer_add_value (buf, klass->byval_arg.type);\n\tsigbuffer_add_value (buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tsigbuffer_add_value (buf, class_inst->type_argc);\n\tfor (i = 0; i < class_inst->type_argc; ++i)\n\t\tencode_type (assembly, class_inst->type_argv [i], buf);\n\n}\n\nstatic void\nencode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tg_assert_not_reached ();\n\t\treturn;\n\t}\n\t\t\n\tif (type->byref)\n\t\tsigbuffer_add_value (buf, MONO_TYPE_BYREF);\n\n\tswitch (type->type){\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tbreak;\n\tcase MONO_TYPE_PTR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, type->data.type, buf);\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.klass->byval_arg, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\n\t\tif (k->generic_container) {\n\t\t\tMonoGenericClass *gclass = mono_metadata_lookup_generic_class (k, k->generic_container->context.class_inst, TRUE);\n\t\t\tencode_generic_class (assembly, gclass, buf);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure we use the correct type.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, k->byval_arg.type);\n\t\t\t/*\n\t\t\t * ensure only non-byref gets passed to mono_image_typedef_or_ref(),\n\t\t\t * otherwise two typerefs could point to the same type, leading to\n\t\t\t * verification errors.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, &k->byval_arg));\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_ARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.array->eklass->byval_arg, buf);\n\t\tsigbuffer_add_value (buf, type->data.array->rank);\n\t\tsigbuffer_add_value (buf, 0); /* FIXME: set to 0 for now */\n\t\tsigbuffer_add_value (buf, 0);\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_generic_class (assembly, type->data.generic_class, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tsigbuffer_add_value (buf, mono_type_get_generic_param_num (type));\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"need to encode type %x\", type->type);\n\t}\n}\n\nstatic void\nencode_reflection_type (MonoDynamicImage *assembly, MonoReflectionType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tsigbuffer_add_value (buf, MONO_TYPE_VOID);\n\t\treturn;\n\t}\n\n\tencode_type (assembly, mono_reflection_type_get_handle (type), buf);\n}\n\nstatic void\nencode_custom_modifiers (MonoDynamicImage *assembly, MonoArray *modreq, MonoArray *modopt, SigBuffer *buf)\n{\n\tint i;\n\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_REQD);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_OPT);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmethod_encode_signature (MonoDynamicImage *assembly, MonoMethodSignature *sig)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  sig->param_count;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tidx = sig->call_convention;\n\tif (sig->hasthis)\n\t\tidx |= 0x20; /* hasthis */\n\tif (sig->generic_param_count)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (sig->generic_param_count)\n\t\tsigbuffer_add_value (&buf, sig->generic_param_count);\n\tsigbuffer_add_value (&buf, nparams);\n\tencode_type (assembly, sig->ret, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tif (i == sig->sentinelpos)\n\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\t\tencode_type (assembly, sig->params [i], &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nmethod_builder_encode_signature (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\t/*\n\t * FIXME: reuse code from method_encode_signature().\n\t */\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  mb->parameters ? mono_array_length (mb->parameters): 0;\n\tguint32 ngparams = mb->generic_params ? mono_array_length (mb->generic_params): 0;\n\tguint32 notypes = mb->opt_types ? mono_array_length (mb->opt_types): 0;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t/* LAMESPEC: all the call conv spec is foobared */\n\tidx = mb->call_conv & 0x60; /* has-this, explicit-this */\n\tif (mb->call_conv & 2)\n\t\tidx |= 0x5; /* vararg */\n\tif (!(mb->attrs & METHOD_ATTRIBUTE_STATIC))\n\t\tidx |= 0x20; /* hasthis */\n\tif (ngparams)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (ngparams)\n\t\tsigbuffer_add_value (&buf, ngparams);\n\tsigbuffer_add_value (&buf, nparams + notypes);\n\tencode_custom_modifiers (assembly, mb->return_modreq, mb->return_modopt, &buf);\n\tencode_reflection_type (assembly, mb->rtype, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tMonoArray *modreq = NULL;\n\t\tMonoArray *modopt = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (mb->param_modreq && (i < mono_array_length (mb->param_modreq)))\n\t\t\tmodreq = mono_array_get (mb->param_modreq, MonoArray*, i);\n\t\tif (mb->param_modopt && (i < mono_array_length (mb->param_modopt)))\n\t\t\tmodopt = mono_array_get (mb->param_modopt, MonoArray*, i);\n\t\tencode_custom_modifiers (assembly, modreq, modopt, &buf);\n\t\tpt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tif (notypes)\n\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\tfor (i = 0; i < notypes; ++i) {\n\t\tMonoReflectionType *pt;\n\n\t\tpt = mono_array_get (mb->opt_types, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_locals (MonoDynamicImage *assembly, MonoReflectionILGen *ilgen)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 idx, sig_idx;\n\tguint nl = mono_array_length (ilgen->locals);\n\tSigBuffer buf;\n\tint i;\n\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, nl);\n\tfor (i = 0; i < nl; ++i) {\n\t\tMonoReflectionLocalBuilder *lb = mono_array_get (ilgen->locals, MonoReflectionLocalBuilder*, i);\n\t\t\n\t\tif (lb->is_pinned)\n\t\t\tsigbuffer_add_value (&buf, MONO_TYPE_PINNED);\n\t\t\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)lb->type, &buf);\n\t}\n\tsig_idx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\tif (assembly->standalonesig_cache == NULL)\n\t\tassembly->standalonesig_cache = g_hash_table_new (NULL, NULL);\n\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx)));\n\tif (idx)\n\t\treturn idx;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] = sig_idx;\n\n\tg_hash_table_insert (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx), GUINT_TO_POINTER (idx));\n\n\treturn idx;\n}\n\nstatic guint32\nmethod_count_clauses (MonoReflectionILGen *ilgen)\n{\n\tguint32 num_clauses = 0;\n\tint i;\n\n\tMonoILExceptionInfo *ex_info;\n\tfor (i = 0; i < mono_array_length (ilgen->ex_handlers); ++i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tif (ex_info->handlers)\n\t\t\tnum_clauses += mono_array_length (ex_info->handlers);\n\t\telse\n\t\t\tnum_clauses++;\n\t}\n\n\treturn num_clauses;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoExceptionClause*\nmethod_encode_clauses (MonoImage *image, MonoDynamicImage *assembly, MonoReflectionILGen *ilgen, guint32 num_clauses)\n{\n\tMonoExceptionClause *clauses;\n\tMonoExceptionClause *clause;\n\tMonoILExceptionInfo *ex_info;\n\tMonoILExceptionBlock *ex_block;\n\tguint32 finally_start;\n\tint i, j, clause_index;;\n\n\tclauses = image_g_new0 (image, MonoExceptionClause, num_clauses);\n\n\tclause_index = 0;\n\tfor (i = mono_array_length (ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tfinally_start = ex_info->start + ex_info->len;\n\t\tif (!ex_info->handlers)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\tclause = &(clauses [clause_index]);\n\n\t\t\tclause->flags = ex_block->type;\n\t\t\tclause->try_offset = ex_info->start;\n\n\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\tclause->try_len = finally_start - ex_info->start;\n\t\t\telse\n\t\t\t\tclause->try_len = ex_info->len;\n\t\t\tclause->handler_offset = ex_block->start;\n\t\t\tclause->handler_len = ex_block->len;\n\t\t\tif (ex_block->extype) {\n\t\t\t\tclause->data.catch_class = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype));\n\t\t\t} else {\n\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\tclause->data.filter_offset = ex_block->filter_offset;\n\t\t\t\telse\n\t\t\t\t\tclause->data.filter_offset = 0;\n\t\t\t}\n\t\t\tfinally_start = ex_block->start + ex_block->len;\n\n\t\t\tclause_index ++;\n\t\t}\n\t}\n\n\treturn clauses;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nstatic guint32\nmethod_encode_code (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\tchar flags = 0;\n\tguint32 idx;\n\tguint32 code_size;\n\tgint32 max_stack, i;\n\tgint32 num_locals = 0;\n\tgint32 num_exception = 0;\n\tgint maybe_small;\n\tguint32 fat_flags;\n\tchar fat_header [12];\n\tguint32 int_value;\n\tguint16 short_value;\n\tguint32 local_sig = 0;\n\tguint32 header_size = 12;\n\tMonoArray *code;\n\n\tif ((mb->attrs & (METHOD_ATTRIBUTE_PINVOKE_IMPL | METHOD_ATTRIBUTE_ABSTRACT)) ||\n\t\t\t(mb->iattrs & (METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL | METHOD_IMPL_ATTRIBUTE_RUNTIME)))\n\t\treturn 0;\n\n\t/*if (mb->name)\n\t\tg_print (\"Encode method %s\\n\", mono_string_to_utf8 (mb->name));*/\n\tif (mb->ilgen) {\n\t\tcode = mb->ilgen->code;\n\t\tcode_size = mb->ilgen->code_len;\n\t\tmax_stack = mb->ilgen->max_stack;\n\t\tnum_locals = mb->ilgen->locals ? mono_array_length (mb->ilgen->locals) : 0;\n\t\tif (mb->ilgen->ex_handlers)\n\t\t\tnum_exception = method_count_clauses (mb->ilgen);\n\t} else {\n\t\tcode = mb->code;\n\t\tif (code == NULL){\n\t\t\tchar *name = mono_string_to_utf8 (mb->name);\n\t\t\tchar *str = g_strdup_printf (\"Method %s does not have any IL associated\", name);\n\t\t\tMonoException *exception = mono_get_exception_argument (NULL, \"a method does not have any IL associated\");\n\t\t\tg_free (str);\n\t\t\tg_free (name);\n\t\t\tmono_raise_exception (exception);\n\t\t}\n\n\t\tcode_size = mono_array_length (code);\n\t\tmax_stack = 8; /* we probably need to run a verifier on the code... */\n\t}\n\n\tstream_data_align (&assembly->code);\n\n\t/* check for exceptions, maxstack, locals */\n\tmaybe_small = (max_stack <= 8) && (!num_locals) && (!num_exception);\n\tif (maybe_small) {\n\t\tif (code_size < 64 && !(code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x2;\n\t\t} else if (code_size < 32 && (code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x6; /* LAMESPEC: see metadata.c */\n\t\t} else {\n\t\t\tgoto fat_header;\n\t\t}\n\t\tidx = mono_image_add_stream_data (&assembly->code, &flags, 1);\n\t\t/* add to the fixup todo list */\n\t\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 1));\n\t\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\t\treturn assembly->text_rva + idx;\n\t} \nfat_header:\n\tif (num_locals)\n\t\tlocal_sig = MONO_TOKEN_SIGNATURE | encode_locals (assembly, mb->ilgen);\n\t/* \n\t * FIXME: need to set also the header size in fat_flags.\n\t * (and more sects and init locals flags)\n\t */\n\tfat_flags =  0x03;\n\tif (num_exception)\n\t\tfat_flags |= METHOD_HEADER_MORE_SECTS;\n\tif (mb->init_locals)\n\t\tfat_flags |= METHOD_HEADER_INIT_LOCALS;\n\tfat_header [0] = fat_flags;\n\tfat_header [1] = (header_size / 4 ) << 4;\n\tshort_value = GUINT16_TO_LE (max_stack);\n\tmemcpy (fat_header + 2, &short_value, 2);\n\tint_value = GUINT32_TO_LE (code_size);\n\tmemcpy (fat_header + 4, &int_value, 4);\n\tint_value = GUINT32_TO_LE (local_sig);\n\tmemcpy (fat_header + 8, &int_value, 4);\n\tidx = mono_image_add_stream_data (&assembly->code, fat_header, 12);\n\t/* add to the fixup todo list */\n\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 12));\n\t\n\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\tif (num_exception) {\n\t\tunsigned char sheader [4];\n\t\tMonoILExceptionInfo * ex_info;\n\t\tMonoILExceptionBlock * ex_block;\n\t\tint j;\n\n\t\tstream_data_align (&assembly->code);\n\t\t/* always use fat format for now */\n\t\tsheader [0] = METHOD_HEADER_SECTION_FAT_FORMAT | METHOD_HEADER_SECTION_EHTABLE;\n\t\tnum_exception *= 6 * sizeof (guint32);\n\t\tnum_exception += 4; /* include the size of the header */\n\t\tsheader [1] = num_exception & 0xff;\n\t\tsheader [2] = (num_exception >> 8) & 0xff;\n\t\tsheader [3] = (num_exception >> 16) & 0xff;\n\t\tmono_image_add_stream_data (&assembly->code, (char*)sheader, 4);\n\t\t/* fat header, so we are already aligned */\n\t\t/* reverse order */\n\t\tfor (i = mono_array_length (mb->ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\t\tex_info = (MonoILExceptionInfo *)mono_array_addr (mb->ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\t\tif (ex_info->handlers) {\n\t\t\t\tint finally_start = ex_info->start + ex_info->len;\n\t\t\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\t\t\tguint32 val;\n\t\t\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\t\t\t/* the flags */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->type);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* try offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_info->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* need fault, too, probably */\n\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\t\t\tval = GUINT32_TO_LE (finally_start - ex_info->start);\n\t\t\t\t\telse\n\t\t\t\t\t\tval = GUINT32_TO_LE (ex_info->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler len */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\tfinally_start = ex_block->start + ex_block->len;\n\t\t\t\t\tif (ex_block->extype) {\n\t\t\t\t\t\tval = mono_metadata_token_from_dor (mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\t\t\tval = ex_block->filter_offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tval = 0;\n\t\t\t\t\t}\n\t\t\t\t\tval = GUINT32_TO_LE (val);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/*g_print (\"out clause %d: from %d len=%d, handler at %d, %d, finally_start=%d, ex_info->start=%d, ex_info->len=%d, ex_block->type=%d, j=%d, i=%d\\n\", \n\t\t\t\t\t\t\tclause.flags, clause.try_offset, clause.try_len, clause.handler_offset, clause.handler_len, finally_start, ex_info->start, ex_info->len, ex_block->type, j, i);*/\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tg_error (\"No clauses for ex info block %d\", i);\n\t\t\t}\n\t\t}\n\t}\n\treturn assembly->text_rva + idx;\n}\n\nstatic guint32\nfind_index_in_table (MonoDynamicImage *assembly, int table_idx, int col, guint32 token)\n{\n\tint i;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [table_idx];\n\n\tg_assert (col < table->columns);\n\n\tvalues = table->values + table->columns;\n\tfor (i = 1; i <= table->rows; ++i) {\n\t\tif (values [col] == token)\n\t\t\treturn i;\n\t\tvalues += table->columns;\n\t}\n\treturn 0;\n}\n\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic MonoCustomAttrInfo*\nlookup_custom_attr (MonoImage *image, gpointer member)\n{\n\tMonoCustomAttrInfo* res;\n\n\tres = mono_image_property_lookup (image, member, MONO_PROP_DYNAMIC_CATTR);\n\n\tif (!res)\n\t\treturn NULL;\n\n\treturn g_memdup (res, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * res->num_attrs);\n}\n\nstatic gboolean\ncustom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)\n{\n\t/* FIXME: Need to do more checks */\n\tif (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {\n\t\tint visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\n\t\tif ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_builders (MonoImage *alloc_img, MonoImage *image, MonoArray *cattrs)\n{\n\tint i, index, count, not_visible;\n\tMonoCustomAttrInfo *ainfo;\n\tMonoReflectionCustomAttr *cattr;\n\n\tif (!cattrs)\n\t\treturn NULL;\n\t/* FIXME: check in assembly the Run flag is set */\n\n\tcount = mono_array_length (cattrs);\n\n\t/* Skip nonpublic attributes since MS.NET seems to do the same */\n\t/* FIXME: This needs to be done more globally */\n\tnot_visible = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (!custom_attr_visible (image, cattr))\n\t\t\tnot_visible ++;\n\t}\n\tcount -= not_visible;\n\n\tainfo = image_g_malloc0 (alloc_img, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * count);\n\n\tainfo->image = image;\n\tainfo->num_attrs = count;\n\tainfo->cached = alloc_img != NULL;\n\tindex = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (custom_attr_visible (image, cattr)) {\n\t\t\tunsigned char *saved = mono_image_alloc (image, mono_array_length (cattr->data));\n\t\t\tmemcpy (saved, mono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\t\tainfo->attrs [index].ctor = cattr->ctor->method;\n\t\t\tainfo->attrs [index].data = saved;\n\t\t\tainfo->attrs [index].data_size = mono_array_length (cattr->data);\n\t\t\tindex ++;\n\t\t}\n\t}\n\n\treturn ainfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic void\nmono_save_custom_attrs (MonoImage *image, void *obj, MonoArray *cattrs)\n{\n\tMonoCustomAttrInfo *ainfo, *tmp;\n\n\tif (!cattrs || !mono_array_length (cattrs))\n\t\treturn;\n\n\tainfo = mono_custom_attrs_from_builders (image, image, cattrs);\n\n\tmono_loader_lock ();\n\ttmp = mono_image_property_lookup (image, obj, MONO_PROP_DYNAMIC_CATTR);\n\tif (tmp)\n\t\tmono_custom_attrs_free (tmp);\n\tmono_image_property_insert (image, obj, MONO_PROP_DYNAMIC_CATTR, ainfo);\n\tmono_loader_unlock ();\n\n}\n#endif\n\nvoid\nmono_custom_attrs_free (MonoCustomAttrInfo *ainfo)\n{\n\tif (!ainfo->cached)\n\t\tg_free (ainfo);\n}\n\n/*\n * idx is the table index of the object\n * type is one of MONO_CUSTOM_ATTR_*\n */\nstatic void\nmono_image_add_cattrs (MonoDynamicImage *assembly, guint32 idx, guint32 type, MonoArray *cattrs)\n{\n\tMonoDynamicTable *table;\n\tMonoReflectionCustomAttr *cattr;\n\tguint32 *values;\n\tguint32 count, i, token;\n\tchar blob_size [6];\n\tchar *p = blob_size;\n\t\n\t/* it is legal to pass a NULL cattrs: we avoid to use the if in a lot of places */\n\tif (!cattrs)\n\t\treturn;\n\tcount = mono_array_length (cattrs);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_CUSTOM_ATTR_SIZE;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= type;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tvalues [MONO_CUSTOM_ATTR_PARENT] = idx;\n\t\ttoken = mono_image_create_token (assembly, (MonoObject*)cattr->ctor, FALSE, FALSE);\n\t\ttype = mono_metadata_token_index (token);\n\t\ttype <<= MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (mono_metadata_token_table (token)) {\n\t\tcase MONO_TABLE_METHOD:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_MEMBERREF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_warning (\"got wrong token in custom attr\");\n\t\t\tcontinue;\n\t\t}\n\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = type;\n\t\tp = blob_size;\n\t\tmono_metadata_encode_value (mono_array_length (cattr->data), p, &p);\n\t\tvalues [MONO_CUSTOM_ATTR_VALUE] = add_to_blob_cached (assembly, blob_size, p - blob_size,\n\t\t\tmono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\tvalues += MONO_CUSTOM_ATTR_SIZE;\n\t\t++table->next_idx;\n\t}\n}\n\nstatic void\nmono_image_add_decl_security (MonoDynamicImage *assembly, guint32 parent_token, MonoArray *permissions)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 count, i, idx;\n\tMonoReflectionPermissionSet *perm;\n\n\tif (!permissions)\n\t\treturn;\n\n\tcount = mono_array_length (permissions);\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\n\tfor (i = 0; i < mono_array_length (permissions); ++i) {\n\t\tperm = (MonoReflectionPermissionSet*)mono_array_addr (permissions, MonoReflectionPermissionSet, i);\n\n\t\tvalues = table->values + table->next_idx * MONO_DECL_SECURITY_SIZE;\n\n\t\tidx = mono_metadata_token_index (parent_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tswitch (mono_metadata_token_table (parent_token)) {\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_ASSEMBLY:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tvalues [MONO_DECL_SECURITY_ACTION] = perm->action;\n\t\tvalues [MONO_DECL_SECURITY_PARENT] = idx;\n\t\tvalues [MONO_DECL_SECURITY_PERMISSIONSET] = add_mono_string_to_blob_cached (assembly, perm->pset);\n\n\t\t++table->next_idx;\n\t}\n}\n\n/*\n * Fill in the MethodDef and ParamDef tables for a method.\n * This is used for both normal methods and constructors.\n */\nstatic void\nmono_image_basic_method (ReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint i, count;\n\n\t/* room in this table is already allocated */\n\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t*mb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->method_to_table_idx, mb->mhandle, GUINT_TO_POINTER ((*mb->table_idx)));\n\tvalues = table->values + *mb->table_idx * MONO_METHOD_SIZE;\n\tvalues [MONO_METHOD_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\tvalues [MONO_METHOD_FLAGS] = mb->attrs;\n\tvalues [MONO_METHOD_IMPLFLAGS] = mb->iattrs;\n\tvalues [MONO_METHOD_SIGNATURE] = method_builder_encode_signature (assembly, mb);\n\tvalues [MONO_METHOD_RVA] = method_encode_code (assembly, mb);\n\t\n\ttable = &assembly->tables [MONO_TABLE_PARAM];\n\tvalues [MONO_METHOD_PARAMLIST] = table->next_idx;\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_METHOD, *mb->table_idx), mb->permissions);\n\n\tif (mb->pinfo) {\n\t\tMonoDynamicTable *mtable;\n\t\tguint32 *mvalues;\n\t\t\n\t\tmtable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\tmvalues = mtable->values + mtable->next_idx * MONO_FIELD_MARSHAL_SIZE;\n\t\t\n\t\tcount = 0;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tif (mono_array_get (mb->pinfo, gpointer, i))\n\t\t\t\tcount++;\n\t\t}\n\t\ttable->rows += count;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_PARAM_SIZE;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (mb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tvalues [MONO_PARAM_FLAGS] = pb->attrs;\n\t\t\t\tvalues [MONO_PARAM_SEQUENCE] = i;\n\t\t\t\tif (pb->name != NULL) {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\t\t\t\t} else {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = 0;\n\t\t\t\t}\n\t\t\t\tvalues += MONO_PARAM_SIZE;\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tmtable->rows++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_PARENT] = (table->next_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_PARAMDEF;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t\tpb->table_idx = table->next_idx++;\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tguint32 field_type = 0;\n\t\t\t\t\tmtable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\t\t\t\tmtable->rows ++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_CONSTANT_SIZE;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_PARAM | (pb->table_idx << MONO_HASCONSTANT_BITS);\n\t\t\t\t\tmvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, pb->def_value, &field_type);\n\t\t\t\t\tmvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PADDING] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nreflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_reflection_type_resolve_user_types ((MonoReflectionType*)mb->rtype);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = mb->generic_params;\n\trmb->generic_container = mb->generic_container;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = mb->code;\n\trmb->type = mb->type;\n\trmb->name = mb->name;\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = mb->return_modreq;\n\trmb->return_modopt = mb->return_modopt;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n\n\tif (mb->dll) {\n\t\trmb->charset = mb->charset;\n\t\trmb->extra_flags = mb->extra_flags;\n\t\trmb->native_cc = mb->native_cc;\n\t\trmb->dllentry = mb->dllentry;\n\t\trmb->dll = mb->dll;\n\t}\n}\n\nstatic void\nreflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb)\n{\n\tconst char *name = mb->attrs & METHOD_ATTRIBUTE_STATIC ? \".cctor\": \".ctor\";\n\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_type_get_object (mono_domain_get (), &mono_defaults.void_class->byval_arg);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = mb->type;\n\trmb->name = mono_string_new (mono_domain_get (), name);\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\n\nstatic void\nreflection_methodbuilder_from_dynamic_method (ReflectionMethodBuilder *rmb, MonoReflectionDynamicMethod *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mb->rtype;\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = NULL;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = 0;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = (MonoObject *) mb->owner;\n\trmb->name = mb->name;\n\trmb->table_idx = NULL;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = mb->skip_visibility;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = NULL;\n\trmb->param_modopt = NULL;\n\trmb->permissions = NULL;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\t\n#endif\n\nstatic void\nmono_image_add_methodimpl (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)mb->type;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 tok;\n\n\tif (!mb->override_method)\n\t\treturn;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODIMPL];\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->rows * MONO_METHODIMPL_SIZE;\n\tvalues [MONO_METHODIMPL_CLASS] = tb->table_idx;\n\tvalues [MONO_METHODIMPL_BODY] = MONO_METHODDEFORREF_METHODDEF | (mb->table_idx << MONO_METHODDEFORREF_BITS);\n\n\ttok = mono_image_create_token (assembly, (MonoObject*)mb->override_method, FALSE, FALSE);\n\tswitch (mono_metadata_token_table (tok)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\tvalues [MONO_METHODIMPL_DECLARATION] = tok;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nmono_image_get_method_info (MonoReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tReflectionMethodBuilder rmb;\n\tint i;\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n\n\tif (mb->dll) { /* It's a P/Invoke method */\n\t\tguint32 moduleref;\n\t\t/* map CharSet values to on-disk values */\n\t\tint ncharset = (mb->charset ? (mb->charset - 1) * 2 : 0);\n\t\tint extra_flags = mb->extra_flags;\n\t\ttable = &assembly->tables [MONO_TABLE_IMPLMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_IMPLMAP_SIZE;\n\t\t\n\t\tvalues [MONO_IMPLMAP_FLAGS] = (mb->native_cc << 8) | ncharset | extra_flags;\n\t\tvalues [MONO_IMPLMAP_MEMBER] = (mb->table_idx << 1) | 1; /* memberforwarded: method */\n\t\tif (mb->dllentry)\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->dllentry);\n\t\telse\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\t\tmoduleref = string_heap_insert_mstring (&assembly->sheap, mb->dll);\n\t\tif (!(values [MONO_IMPLMAP_SCOPE] = find_index_in_table (assembly, MONO_TABLE_MODULEREF, MONO_MODULEREF_NAME, moduleref))) {\n\t\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\t\ttable->rows ++;\n\t\t\talloc_table (table, table->rows);\n\t\t\ttable->values [table->rows * MONO_MODULEREF_SIZE + MONO_MODULEREF_NAME] = moduleref;\n\t\t\tvalues [MONO_IMPLMAP_SCOPE] = table->rows;\n\t\t}\n\t}\n\n\tif (mb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (mb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (mb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_METHOD | (mb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (mb->generic_params, gpointer, i), owner, assembly);\n\t\t}\n\t}\n\n}\n\nstatic void\nmono_image_get_ctor_info (MonoDomain *domain, MonoReflectionCtorBuilder *mb, MonoDynamicImage *assembly)\n{\n\tReflectionMethodBuilder rmb;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n}\n#endif\n\nstatic char*\ntype_get_fully_qualified_name (MonoType *type)\n{\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\nstatic char*\ntype_get_qualified_name (MonoType *type, MonoAssembly *ass) {\n\tMonoClass *klass;\n\tMonoAssembly *ta;\n\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass) \n\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\tta = klass->image->assembly;\n\tif (ta->dynamic || (ta == ass)) {\n\t\tif (klass->generic_class || klass->generic_container)\n\t\t\t/* For generic type definitions, we want T, while REFLECTION returns T<K> */\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_FULL_NAME);\n\t\telse\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\t}\n\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*field_image is the image to which the eventual custom mods have been encoded against*/\nstatic guint32\nfieldref_encode_signature (MonoDynamicImage *assembly, MonoImage *field_image, MonoType *type)\n{\n\tSigBuffer buf;\n\tguint32 idx, i, token;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\t/* encode custom attributes before the type */\n\tif (type->num_mods) {\n\t\tfor (i = 0; i < type->num_mods; ++i) {\n\t\t\tif (field_image) {\n\t\t\t\tMonoClass *class = mono_class_get (field_image, type->modifiers [i].token);\n\t\t\t\tg_assert (class);\n\t\t\t\ttoken = mono_image_typedef_or_ref (assembly, &class->byval_arg);\n\t\t\t} else {\n\t\t\t\ttoken = type->modifiers [i].token;\n\t\t\t}\n\n\t\t\tif (type->modifiers [i].required)\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_REQD);\n\t\t\telse\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_OPT);\n\n\t\t\tsigbuffer_add_value (&buf, token);\n\t\t}\n\t}\n\tencode_type (assembly, type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nfield_encode_signature (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\tencode_custom_modifiers (assembly, fb->modreq, fb->modopt, &buf);\n\t/* encode custom attributes before the type */\n\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type) {\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tchar *p, *box_val;\n\tchar* buf;\n\tguint32 idx = 0, len = 0, dummy = 0;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\tguint32 fpa_double [2];\n\tguint32 *fpa_p;\n#endif\n#endif\n\t\n\tp = buf = g_malloc (64);\n\tif (!val) {\n\t\t*ret_type = MONO_TYPE_CLASS;\n\t\tlen = 4;\n\t\tbox_val = (char*)&dummy;\n\t} else {\n\t\tbox_val = ((char*)val) + sizeof (MonoObject);\n\t\t*ret_type = val->vtable->klass->byval_arg.type;\n\t}\nhandle_enum:\n\tswitch (*ret_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\tlen = 1;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tlen = 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tlen = 4;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tlen = 8;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tlen = 8;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tfpa_p = (guint32*)box_val;\n\t\tfpa_double [0] = fpa_p [1];\n\t\tfpa_double [1] = fpa_p [0];\n\t\tbox_val = (char*)fpa_double;\n#endif\n#endif\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (val->vtable->klass->enumtype) {\n\t\t\t*ret_type = mono_class_enum_basetype (val->vtable->klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else\n\t\t\tg_error (\"we can't encode valuetypes\");\n\tcase MONO_TYPE_CLASS:\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tMonoString *str = (MonoString*)val;\n\t\t/* there is no signature */\n\t\tlen = str->length * 2;\n\t\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t\t{\n\t\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\t\tg_free (swapped);\n\t\t}\n#else\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\n\t\tg_free (buf);\n\t\treturn idx;\n\t}\n\tcase MONO_TYPE_GENERICINST:\n\t\t*ret_type = val->vtable->klass->generic_class->container_class->byval_arg.type;\n\t\tgoto handle_enum;\n\tdefault:\n\t\tg_error (\"we don't encode constant type 0x%02x yet\", *ret_type);\n\t}\n\n\t/* there is no signature */\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tidx = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tswap_with_size (blob_size, box_val, len, 1);\n\tmono_image_add_stream_data (&assembly->blob, blob_size, len);\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, box_val, len);\n#endif\n\n\tg_free (buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo) {\n\tchar *str;\n\tSigBuffer buf;\n\tguint32 idx, len;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, minfo->type);\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tsigbuffer_add_value (&buf, minfo->count);\n\t\tbreak;\n\tcase MONO_NATIVE_LPARRAY:\n\t\tif (minfo->eltype || minfo->has_size) {\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\t\tif (minfo->has_size) {\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? minfo->param_num: 0);\n\t\t\t\tsigbuffer_add_value (&buf, minfo->count != -1? minfo->count: 0);\n\n\t\t\t\t/* LAMESPEC: ElemMult is undocumented */\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? 1: 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MONO_NATIVE_SAFEARRAY:\n\t\tif (minfo->eltype)\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\tbreak;\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->guid) {\n\t\t\tstr = mono_string_to_utf8 (minfo->guid);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\t/* native type name */\n\t\tsigbuffer_add_value (&buf, 0);\n\t\t/* custom marshaler type name */\n\t\tif (minfo->marshaltype || minfo->marshaltyperef) {\n\t\t\tif (minfo->marshaltyperef)\n\t\t\t\tstr = type_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\t\telse\n\t\t\t\tstr = mono_string_to_utf8 (minfo->marshaltype);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\t/* FIXME: Actually a bug, since this field is required.  Punting for now ... */\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tif (minfo->mcookie) {\n\t\t\tstr = mono_string_to_utf8 (minfo->mcookie);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_field_info (MonoReflectionFieldBuilder *fb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\t/* maybe this fixup should be done in the C# code */\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL)\n\t\tfb->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\tfb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->field_to_table_idx, fb->handle, GUINT_TO_POINTER (fb->table_idx));\n\tvalues = table->values + fb->table_idx * MONO_FIELD_SIZE;\n\tvalues [MONO_FIELD_NAME] = string_heap_insert_mstring (&assembly->sheap, fb->name);\n\tvalues [MONO_FIELD_FLAGS] = fb->attrs;\n\tvalues [MONO_FIELD_SIGNATURE] = field_encode_signature (assembly, fb);\n\n\tif (fb->offset != -1) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDLAYOUT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_LAYOUT_SIZE;\n\t\tvalues [MONO_FIELD_LAYOUT_FIELD] = fb->table_idx;\n\t\tvalues [MONO_FIELD_LAYOUT_OFFSET] = fb->offset;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL) {\n\t\tguint32 field_type = 0;\n\t\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CONSTANT_SIZE;\n\t\tvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_FIEDDEF | (fb->table_idx << MONO_HASCONSTANT_BITS);\n\t\tvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, fb->def_value, &field_type);\n\t\tvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\tvalues [MONO_CONSTANT_PADDING] = 0;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) {\n\t\tguint32 rva_idx;\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDRVA];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_RVA_SIZE;\n\t\tvalues [MONO_FIELD_RVA_FIELD] = fb->table_idx;\n\t\t/*\n\t\t * We store it in the code section because it's simpler for now.\n\t\t */\n\t\tif (fb->rva_data) {\n\t\t\tif (mono_array_length (fb->rva_data) >= 10)\n\t\t\t\tstream_data_align (&assembly->code);\n\t\t\trva_idx = mono_image_add_stream_data (&assembly->code, mono_array_addr (fb->rva_data, char, 0), mono_array_length (fb->rva_data));\n\t\t} else\n\t\t\trva_idx = mono_image_add_stream_zero (&assembly->code, mono_class_value_size (fb->handle->parent, NULL));\n\t\tvalues [MONO_FIELD_RVA_RVA] = rva_idx + assembly->text_rva;\n\t}\n\tif (fb->marshal_info) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\tvalues [MONO_FIELD_MARSHAL_PARENT] = (fb->table_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_FIELDSREF;\n\t\tvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, fb->marshal_info);\n\t}\n}\n\nstatic guint32\nproperty_encode_signature (MonoDynamicImage *assembly, MonoReflectionPropertyBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 nparams = 0;\n\tMonoReflectionMethodBuilder *mb = fb->get_method;\n\tMonoReflectionMethodBuilder *smb = fb->set_method;\n\tguint32 idx, i;\n\n\tif (mb && mb->parameters)\n\t\tnparams = mono_array_length (mb->parameters);\n\tif (!mb && smb && smb->parameters)\n\t\tnparams = mono_array_length (smb->parameters) - 1;\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_byte (&buf, 0x08);\n\tsigbuffer_add_value (&buf, nparams);\n\tif (mb) {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)mb->rtype, &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else if (smb && smb->parameters) {\n\t\t/* the property type is the last param */\n\t\tencode_reflection_type (assembly, mono_array_get (smb->parameters, MonoReflectionType*, nparams), &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (smb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_property_info (MonoReflectionPropertyBuilder *pb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * PROPERTYMAP (info already filled in _get_type_info ())\n\t * PROPERTY    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\tpb->table_idx = table->next_idx ++;\n\tvalues = table->values + pb->table_idx * MONO_PROPERTY_SIZE;\n\tvalues [MONO_PROPERTY_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\tvalues [MONO_PROPERTY_FLAGS] = pb->attrs;\n\tvalues [MONO_PROPERTY_TYPE] = property_encode_signature (assembly, pb);\n\n\t/* FIXME: we still don't handle 'other' methods */\n\tif (pb->get_method) num_methods ++;\n\tif (pb->set_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (pb->get_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_GETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->get_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n\tif (pb->set_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_SETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->set_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n}\n\nstatic void\nmono_image_get_event_info (MonoReflectionEventBuilder *eb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * EVENTMAP (info already filled in _get_type_info ())\n\t * EVENT    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\teb->table_idx = table->next_idx ++;\n\tvalues = table->values + eb->table_idx * MONO_EVENT_SIZE;\n\tvalues [MONO_EVENT_NAME] = string_heap_insert_mstring (&assembly->sheap, eb->name);\n\tvalues [MONO_EVENT_FLAGS] = eb->attrs;\n\tvalues [MONO_EVENT_TYPE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (eb->type));\n\n\t/*\n\t * FIXME: we still don't handle 'other' methods \n\t */\n\tif (eb->add_method) num_methods ++;\n\tif (eb->remove_method) num_methods ++;\n\tif (eb->raise_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (eb->add_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_ADD_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->add_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->remove_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_REMOVE_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->remove_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->raise_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_FIRE;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->raise_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n}\n\nstatic void\nencode_constraints (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 num_constraints, i;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAMCONSTRAINT];\n\tnum_constraints = gparam->iface_constraints ?\n\t\tmono_array_length (gparam->iface_constraints) : 0;\n\ttable->rows += num_constraints;\n\tif (gparam->base_type)\n\t\ttable->rows++;\n\talloc_table (table, table->rows);\n\n\tif (gparam->base_type) {\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (gparam->base_type));\n\t}\n\n\tfor (i = 0; i < num_constraints; i++) {\n\t\tMonoReflectionType *constraint = mono_array_get (\n\t\t\tgparam->iface_constraints, gpointer, i);\n\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (constraint));\n\t}\n}\n\nstatic void\nmono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tGenericParamTableEntry *entry;\n\n\t/*\n\t * The GenericParam table must be sorted according to the `owner' field.\n\t * We need to do this sorting prior to writing the GenericParamConstraint\n\t * table, since we have to use the final GenericParam table indices there\n\t * and they must also be sorted.\n\t */\n\n\tentry = g_new0 (GenericParamTableEntry, 1);\n\tentry->owner = owner;\n\t/* FIXME: track where gen_params should be freed and remove the GC root as well */\n\tMOVING_GC_REGISTER (&entry->gparam);\n\tentry->gparam = gparam;\n\n\tg_ptr_array_add (assembly->gen_params, entry);\n}\n\nstatic void\nwrite_generic_param_entry (MonoDynamicImage *assembly, GenericParamTableEntry *entry)\n{\n\tMonoDynamicTable *table;\n\tMonoGenericParam *param;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\ttable_idx = table->next_idx ++;\n\tvalues = table->values + table_idx * MONO_GENERICPARAM_SIZE;\n\n\tparam = mono_reflection_type_get_handle ((MonoReflectionType*)entry->gparam)->data.generic_param;\n\n\tvalues [MONO_GENERICPARAM_OWNER] = entry->owner;\n\tvalues [MONO_GENERICPARAM_FLAGS] = entry->gparam->attrs;\n\tvalues [MONO_GENERICPARAM_NUMBER] = mono_generic_param_num (param);\n\tvalues [MONO_GENERICPARAM_NAME] = string_heap_insert (&assembly->sheap, mono_generic_param_info (param)->name);\n\n\tmono_image_add_cattrs (assembly, table_idx, MONO_CUSTOM_ATTR_GENERICPAR, entry->gparam->cattrs);\n\n\tencode_constraints (entry->gparam, table_idx, assembly);\n}\n\nstatic guint32\nresolution_scope_from_image (MonoDynamicImage *assembly, MonoImage *image)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\tguint32 cols [MONO_ASSEMBLY_SIZE];\n\tconst char *pubkey;\n\tguint32 publen;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, image))))\n\t\treturn token;\n\n\tif (image->assembly->dynamic && (image->assembly == assembly->image.assembly)) {\n\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\ttoken = table->next_idx ++;\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + token * MONO_MODULEREF_SIZE;\n\t\tvalues [MONO_MODULEREF_NAME] = string_heap_insert (&assembly->sheap, image->module_name);\n\n\t\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\t\ttoken |= MONO_RESOLTION_SCOPE_MODULEREF;\n\t\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\n\t\treturn token;\n\t}\n\t\n\tif (image->assembly->dynamic)\n\t\t/* FIXME: */\n\t\tmemset (cols, 0, sizeof (cols));\n\telse {\n\t\t/* image->assembly->image is the manifest module */\n\t\timage = image->assembly->image;\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_ASSEMBLY], 0, cols, MONO_ASSEMBLY_SIZE);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLYREF];\n\ttoken = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + token * MONO_ASSEMBLYREF_SIZE;\n\tvalues [MONO_ASSEMBLYREF_NAME] = string_heap_insert (&assembly->sheap, image->assembly_name);\n\tvalues [MONO_ASSEMBLYREF_MAJOR_VERSION] = cols [MONO_ASSEMBLY_MAJOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_MINOR_VERSION] = cols [MONO_ASSEMBLY_MINOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_BUILD_NUMBER] = cols [MONO_ASSEMBLY_BUILD_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_REV_NUMBER] = cols [MONO_ASSEMBLY_REV_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_FLAGS] = 0;\n\tvalues [MONO_ASSEMBLYREF_CULTURE] = 0;\n\tvalues [MONO_ASSEMBLYREF_HASH_VALUE] = 0;\n\n\tif (strcmp (\"\", image->assembly->aname.culture)) {\n\t\tvalues [MONO_ASSEMBLYREF_CULTURE] = string_heap_insert (&assembly->sheap,\n\t\t\t\timage->assembly->aname.culture);\n\t}\n\n\tif ((pubkey = mono_image_get_public_key (image, &publen))) {\n\t\tguchar pubtoken [9];\n\t\tpubtoken [0] = 8;\n\t\tmono_digest_get_public_token (pubtoken + 1, (guchar*)pubkey, publen);\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = mono_image_add_stream_data (&assembly->blob, (char*)pubtoken, 9);\n\t} else {\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = 0;\n\t}\n\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\ttoken |= MONO_RESOLTION_SCOPE_ASSEMBLYREF;\n\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\ncreate_typespec (MonoDynamicImage *assembly, MonoType *type)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type))))\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\tswitch (type->type) {\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\t\tif (!k || !k->generic_container) {\n\t\t\tsigbuffer_free (&buf);\n\t\t\treturn 0;\n\t\t}\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsigbuffer_free (&buf);\n\t\treturn 0;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\nstatic guint32\nmono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, scope, enclosing;\n\tMonoClass *klass;\n\n\t/* if the type requires a typespec, we must try that first*/\n\tif (try_typespec && (token = create_typespec (assembly, type)))\n\t\treturn token;\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typeref, type));\n\tif (token)\n\t\treturn token;\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass)\n\t\tklass = mono_class_from_mono_type (type);\n\n\t/*\n\t * If it's in the same module and not a generic type parameter:\n\t */\n\tif ((klass->image == &assembly->image) && (type->type != MONO_TYPE_VAR) && \n\t\t\t(type->type != MONO_TYPE_MVAR)) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\t\ttoken = MONO_TYPEDEFORREF_TYPEDEF | (tb->table_idx << MONO_TYPEDEFORREF_BITS);\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\t\treturn token;\n\t}\n\n\tif (klass->nested_in) {\n\t\tenclosing = mono_image_typedef_or_ref_full (assembly, &klass->nested_in->byval_arg, FALSE);\n\t\t/* get the typeref idx of the enclosing type */\n\t\tenclosing >>= MONO_TYPEDEFORREF_BITS;\n\t\tscope = (enclosing << MONO_RESOLTION_SCOPE_BITS) | MONO_RESOLTION_SCOPE_TYPEREF;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t}\n\ttable = &assembly->tables [MONO_TABLE_TYPEREF];\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPEREF_SIZE;\n\t\tvalues [MONO_TYPEREF_SCOPE] = scope;\n\t\tvalues [MONO_TYPEREF_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\t\tvalues [MONO_TYPEREF_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\t}\n\ttoken = MONO_TYPEDEFORREF_TYPEREF | (table->next_idx << MONO_TYPEDEFORREF_BITS); /* typeref */\n\tg_hash_table_insert (assembly->typeref, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\treturn token;\n}\n\n/*\n * Despite the name, we handle also TypeSpec (with the above helper).\n */\nstatic guint32\nmono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)\n{\n\treturn mono_image_typedef_or_ref_full (assembly, type, TRUE);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * Insert a memberef row into the metadata: the token that point to the memberref\n * is returned. Caching is done in the caller (mono_image_get_methodref_token() or\n * mono_image_get_fieldref_token()).\n * The sig param is an index to an already built signature.\n */\nstatic guint32\nmono_image_get_memberref_token (MonoDynamicImage *assembly, MonoType *type, const char *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, pclass;\n\tguint32 parent;\n\n\tparent = mono_image_typedef_or_ref (assembly, type);\n\tswitch (parent & MONO_TYPEDEFORREF_MASK) {\n\tcase MONO_TYPEDEFORREF_TYPEREF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEREF;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPESPEC:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPEDEF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_warning (\"unknown typeref or def token 0x%08x for %s\", parent, name);\n\t\treturn 0;\n\t}\n\t/* extract the index */\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec)\n{\n\tguint32 token;\n\tMonoMethodSignature *sig;\n\t\n\tcreate_typespec = create_typespec && method->is_generic && method->klass->image != &assembly->image;\n\n\tif (create_typespec) {\n\t\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1)));\n\t\tif (token)\n\t\t\treturn token;\n\t} \n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token && !create_typespec)\n\t\treturn token;\n\n\tg_assert (!method->is_inflated);\n\tif (!token) {\n\t\t/*\n\t\t * A methodref signature can't contain an unmanaged calling convention.\n\t\t */\n\t\tsig = mono_metadata_signature_dup (mono_method_signature (method));\n\t\tif ((sig->call_convention != MONO_CALL_DEFAULT) && (sig->call_convention != MONO_CALL_VARARG))\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\ttoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg,\n\t\t\tmethod->name,  method_encode_signature (assembly, sig));\n\t\tg_free (sig);\n\t\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\t}\n\n\tif (create_typespec) {\n\t\tMonoDynamicTable *table = &assembly->tables [MONO_TABLE_METHODSPEC];\n\t\tg_assert (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF);\n\t\ttoken = (mono_metadata_token_index (token) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\n\t\tif (assembly->save) {\n\t\t\tguint32 *values;\n\n\t\t\talloc_table (table, table->rows + 1);\n\t\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\t\tvalues [MONO_METHODSPEC_METHOD] = token;\n\t\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_sig (assembly, &mono_method_get_generic_container (method)->context);\n\t\t}\n\n\t\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\t\ttable->next_idx ++;\n\t\t/*methodspec and memberef tokens are diferent, */\n\t\tg_hash_table_insert (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1), GUINT_TO_POINTER (token));\n\t\treturn token;\n\t}\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tname = mono_string_to_utf8 (method->name);\n\treflection_methodbuilder_from_method_builder (&rmb, method);\n\n\t/*\n\t * A methodref signature can't contain an unmanaged calling convention.\n\t * Since some flags are encoded as part of call_conv, we need to check against it.\n\t*/\n\tif ((rmb.call_conv & ~0x60) != MONO_CALL_DEFAULT && (rmb.call_conv & ~0x60) != MONO_CALL_VARARG)\n\t\trmb.call_conv = (rmb.call_conv & 0x60) | MONO_CALL_DEFAULT;\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\t\t\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_varargs_method_token (MonoDynamicImage *assembly, guint32 original,\n\t\t\t\t     const gchar *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = original;\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_definition_sig (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = mono_array_length (mb->generic_params);\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0xa);\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++) {\n\t\tsigbuffer_add_value (&buf, MONO_TYPE_MVAR);\n\t\tsigbuffer_add_value (&buf, i);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmono_image_get_methodspec_token_for_generic_method_definition (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0;\n\n\ttoken = GPOINTER_TO_UINT (mono_g_hash_table_lookup (assembly->methodspec, mb));\n\tif (token)\n\t\treturn token;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tmtoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_definition_sig (assembly, mb);\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\tmono_g_hash_table_insert (assembly->methodspec, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec)\n{\n\tguint32 token;\n\t\n\tif (mb->generic_params && create_methodspec) \n\t\treturn mono_image_get_methodspec_token_for_generic_method_definition (assembly, mb);\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\ttoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *mb)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n#endif\n\nstatic gboolean\nis_field_on_inst (MonoClassField *field)\n{\n\treturn (field->parent->generic_class && field->parent->generic_class->is_dynamic && ((MonoDynamicGenericClass*)field->parent->generic_class)->fields);\n}\n\n/*\n * If FIELD is a field of a MonoDynamicGenericClass, return its non-inflated type.\n */\nstatic MonoType*\nget_field_on_inst_generic_type (MonoClassField *field)\n{\n\tMonoDynamicGenericClass *dgclass;\n\tint field_index;\n\n\tg_assert (is_field_on_inst (field));\n\n\tdgclass = (MonoDynamicGenericClass*)field->parent->generic_class;\n\tfield_index = field - dgclass->fields;\n\n\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\treturn dgclass->field_generic_types [field_index];\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_fieldref_token (MonoDynamicImage *assembly, MonoReflectionField *f)\n{\n\tMonoType *type;\n\tguint32 token;\n\tMonoClassField *field;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\tg_assert (f->field->parent);\n\n\tfield = f->field;\n\tif (field->parent->generic_class && field->parent->generic_class->container_class && field->parent->generic_class->container_class->fields) {\n\t\tint index = field - field->parent->fields;\n\t\ttype = field->parent->generic_class->container_class->fields [index].type;\n\t} else {\n\t\tif (is_field_on_inst (f->field))\n\t\t\ttype = get_field_on_inst_generic_type (f->field);\n\t\telse\n\t\t\ttype = f->field->type;\n\t}\n\ttoken = mono_image_get_memberref_token (assembly, &f->field->parent->byval_arg, \n\t\t\t\t\t\t\t\t\t\t\tmono_field_get_name (f->field),  \n\t\t\t\t\t\t\t\t\t\t\tfieldref_encode_signature (assembly, field->parent->image, type));\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_field_on_inst_token (MonoDynamicImage *assembly, MonoReflectionFieldOnTypeBuilderInst *f)\n{\n\tguint32 token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionFieldBuilder *fb = f->fb;\n\tMonoType *type;\n\tchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)f->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tname = mono_string_to_utf8 (fb->name);\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, \n\t\t\t\t\t\t\t\t\t\t\tfield_encode_signature (assembly, fb));\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctor_on_inst_token (MonoDynamicImage *assembly, MonoReflectionCtorOnTypeBuilderInst *c, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionCtorBuilder *cb = c->cb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\t/* A ctor cannot be a generic method, so we can ignore create_methodspec */\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, c));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)c->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, cb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, c, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic MonoMethod*\nmono_reflection_method_on_tb_inst_get_handle (MonoReflectionMethodOnTypeBuilderInst *m)\n{\n\tMonoClass *klass;\n\tMonoGenericContext tmp_context;\n\tMonoType **type_argv;\n\tMonoGenericInst *ginst;\n\tMonoMethod *method, *inflated;\n\tint count, i;\n\n\tmethod = inflate_method (m->inst, (MonoObject*)m->mb);\n\n\tklass = method->klass;\n\n\tif (m->method_args == NULL)\n\t\treturn method;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_array_length (m->method_args);\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (m->method_args, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\treturn inflated;\n}\n\nstatic guint32\nmono_image_get_method_on_inst_token (MonoDynamicImage *assembly, MonoReflectionMethodOnTypeBuilderInst *m, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoReflectionMethodBuilder *mb = m->mb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\tif (m->method_args) {\n\t\tMonoMethod *inflated;\n\n\t\tinflated = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\tif (create_methodspec)\n\t\t\ttoken = mono_image_get_methodspec_token (assembly, inflated);\n\t\telse\n\t\t\ttoken = mono_image_get_inflated_method_token (assembly, inflated);\n\t\treturn token;\n\t}\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, m));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, m, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = context->method_inst->type_argc;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tsigbuffer_add_value (&buf, 0xa); /* FIXME FIXME FIXME */\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++)\n\t\tencode_type (assembly, context->method_inst->type_argv [i], &buf);\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmethod_encode_methodspec (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0, sig;\n\tMonoMethodInflated *imethod;\n\tMonoMethod *declaring;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\tdeclaring = imethod->declaring;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (declaring));\n\tmtoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg, declaring->name, sig);\n\n\tif (!mono_method_signature (declaring)->generic_param_count)\n\t\treturn mtoken;\n\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tsig = encode_generic_method_sig (assembly, mono_method_get_context (method));\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoMethodInflated *imethod;\n\tguint32 token;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\n\tif (mono_method_signature (imethod->declaring)->generic_param_count) {\n\t\ttoken = method_encode_methodspec (assembly, method);\n\t} else {\n\t\tguint32 sig = method_encode_signature (\n\t\t\tassembly, mono_method_signature (imethod->declaring));\n\t\ttoken = mono_image_get_memberref_token (\n\t\t\tassembly, &method->klass->byval_arg, method->name, sig);\n\t}\n\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m)\n{\n\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\tguint32 sig, token;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (imethod->declaring));\n\ttoken = mono_image_get_memberref_token (\n\t\tassembly, &m->klass->byval_arg, m->name, sig);\n\n\treturn token;\n}\n\nstatic guint32\ncreate_generic_typespec (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *type;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\tint count, i;\n\n\t/*\n\t * We're creating a TypeSpec for the TypeBuilder of a generic type declaration,\n\t * ie. what we'd normally use as the generic type in a TypeSpec signature.\n\t * Because of this, we must not insert it into the `typeref' hash table.\n\t */\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)tb);\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type));\n\tif (token)\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\n\tg_assert (tb->generic_params);\n\tklass = mono_class_from_mono_type (type);\n\n\tif (tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tsigbuffer_add_value (&buf, MONO_TYPE_GENERICINST);\n\tg_assert (klass->generic_container);\n\tsigbuffer_add_value (&buf, klass->byval_arg.type);\n\tsigbuffer_add_value (&buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tcount = mono_array_length (tb->generic_params);\n\tsigbuffer_add_value (&buf, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam;\n\n\t\tgparam = mono_array_get (tb->generic_params, MonoReflectionGenericParam *, i);\n\n\t\tencode_type (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)gparam), &buf);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\n/*\n * Return a copy of TYPE, adding the custom modifiers in MODREQ and MODOPT.\n */\nstatic MonoType*\nadd_custom_modifiers (MonoDynamicImage *assembly, MonoType *type, MonoArray *modreq, MonoArray *modopt)\n{\n\tint i, count, len, pos;\n\tMonoType *t;\n\n\tcount = 0;\n\tif (modreq)\n\t\tcount += mono_array_length (modreq);\n\tif (modopt)\n\t\tcount += mono_array_length (modopt);\n\n\tif (count == 0)\n\t\treturn mono_metadata_type_dup (NULL, type);\n\n\tlen = MONO_SIZEOF_TYPE + ((gint32)count) * sizeof (MonoCustomMod);\n\tt = g_malloc (len);\n\tmemcpy (t, type, MONO_SIZEOF_TYPE);\n\n\tt->num_mods = count;\n\tpos = 0;\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tt->modifiers [pos].required = 1;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tt->modifiers [pos].required = 0;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\n\treturn t;\n}\n\nstatic guint32\nmono_image_get_generic_field_token (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *custom = NULL;\n\tguint32 *values;\n\tguint32 token, pclass, parent, sig;\n\tgchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, fb));\n\tif (token)\n\t\treturn token;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (fb->typeb));\n\tname = mono_string_to_utf8 (fb->name);\n\n\t/* fb->type does not include the custom modifiers */\n\t/* FIXME: We should do this in one place when a fieldbuilder is created */\n\tif (fb->modreq || fb->modopt) {\n\t\tcustom = add_custom_modifiers (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type), fb->modreq, fb->modopt);\n\t\tsig = fieldref_encode_signature (assembly, NULL, custom);\n\t\tg_free (custom);\n\t} else {\n\t\tsig = fieldref_encode_signature (assembly, NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t}\n\n\tparent = create_generic_typespec (assembly, (MonoReflectionTypeBuilder *) fb->typeb);\n\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_TYPEDEFORREF_TYPESPEC);\n\t\n\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\tg_hash_table_insert (assembly->handleref, fb, GUINT_TO_POINTER(token));\n\tg_free (name);\n\treturn token;\n}\n\nstatic guint32\nmono_reflection_encode_sighelper (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tSigBuffer buf;\n\tguint32 nargs;\n\tguint32 size;\n\tguint32 i, idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\t/* FIXME: this means SignatureHelper.SignatureHelpType.HELPER_METHOD */\n\tg_assert (helper->type == 2);\n\n\tif (helper->arguments)\n\t\tnargs = mono_array_length (helper->arguments);\n\telse\n\t\tnargs = 0;\n\n\tsize = 10 + (nargs * 10);\n\t\n\tsigbuffer_init (&buf, 32);\n\n\t/* Encode calling convention */\n\t/* Change Any to Standard */\n\tif ((helper->call_conv & 0x03) == 0x03)\n\t\thelper->call_conv = 0x01;\n\t/* explicit_this implies has_this */\n\tif (helper->call_conv & 0x40)\n\t\thelper->call_conv &= 0x20;\n\n\tif (helper->call_conv == 0) { /* Unmanaged */\n\t\tidx = helper->unmanaged_call_conv - 1;\n\t} else {\n\t\t/* Managed */\n\t\tidx = helper->call_conv & 0x60; /* has_this + explicit_this */\n\t\tif (helper->call_conv & 0x02) /* varargs */\n\t\t\tidx += 0x05;\n\t}\n\n\tsigbuffer_add_byte (&buf, idx);\n\tsigbuffer_add_value (&buf, nargs);\n\tencode_reflection_type (assembly, helper->return_type, &buf);\n\tfor (i = 0; i < nargs; ++i) {\n\t\tMonoArray *modreqs = NULL;\n\t\tMonoArray *modopts = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (helper->modreqs && (i < mono_array_length (helper->modreqs)))\n\t\t\tmodreqs = mono_array_get (helper->modreqs, MonoArray*, i);\n\t\tif (helper->modopts && (i < mono_array_length (helper->modopts)))\n\t\t\tmodopts = mono_array_get (helper->modopts, MonoArray*, i);\n\n\t\tencode_custom_modifiers (assembly, modreqs, modopts, &buf);\n\t\tpt = mono_array_get (helper->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\treturn idx;\n}\n\nstatic guint32 \nmono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tguint32 idx;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] =\n\t\tmono_reflection_encode_sighelper (assembly, helper);\n\n\treturn idx;\n}\n\nstatic int\nreflection_cc_to_file (int call_conv) {\n\tswitch (call_conv & 0x3) {\n\tcase 0:\n\tcase 1: return MONO_CALL_DEFAULT;\n\tcase 2: return MONO_CALL_VARARG;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn 0;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\ntypedef struct {\n\tMonoType *parent;\n\tMonoMethodSignature *sig;\n\tchar *name;\n\tguint32 token;\n} ArrayMethod;\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_array_token (MonoDynamicImage *assembly, MonoReflectionArrayMethod *m)\n{\n\tguint32 nparams, i;\n\tGList *tmp;\n\tchar *name;\n\tMonoMethodSignature *sig;\n\tArrayMethod *am;\n\tMonoType *mtype;\n\n\tname = mono_string_to_utf8 (m->name);\n\tnparams = mono_array_length (m->parameters);\n\tsig = g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * nparams);\n\tsig->hasthis = 1;\n\tsig->sentinelpos = -1;\n\tsig->call_convention = reflection_cc_to_file (m->call_conv);\n\tsig->param_count = nparams;\n\tsig->ret = m->ret ? mono_reflection_type_get_handle (m->ret): &mono_defaults.void_class->byval_arg;\n\tmtype = mono_reflection_type_get_handle (m->parent);\n\tfor (i = 0; i < nparams; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (m->parameters, i);\n\n\tfor (tmp = assembly->array_methods; tmp; tmp = tmp->next) {\n\t\tam = tmp->data;\n\t\tif (strcmp (name, am->name) == 0 && \n\t\t\t\tmono_metadata_type_equal (am->parent, mtype) &&\n\t\t\t\tmono_metadata_signature_equal (am->sig, sig)) {\n\t\t\tg_free (name);\n\t\t\tg_free (sig);\n\t\t\tm->table_idx = am->token & 0xffffff;\n\t\t\treturn am->token;\n\t\t}\n\t}\n\tam = g_new0 (ArrayMethod, 1);\n\tam->name = name;\n\tam->sig = sig;\n\tam->parent = mtype;\n\tam->token = mono_image_get_memberref_token (assembly, am->parent, name,\n\t\tmethod_encode_signature (assembly, sig));\n\tassembly->array_methods = g_list_prepend (assembly->array_methods, am);\n\tm->table_idx = am->token & 0xffffff;\n\treturn am->token;\n}\n\n/*\n * Insert into the metadata tables all the info about the TypeBuilder tb.\n * Data in the tables is inserted in a predefined order, since some tables need to be sorted.\n */\nstatic void\nmono_image_get_type_info (MonoDomain *domain, MonoReflectionTypeBuilder *tb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint *values;\n\tint i, is_object = 0, is_system = 0;\n\tchar *n;\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\tvalues = table->values + tb->table_idx * MONO_TYPEDEF_SIZE;\n\tvalues [MONO_TYPEDEF_FLAGS] = tb->attrs;\n\tn = mono_string_to_utf8 (tb->name);\n\tif (strcmp (n, \"Object\") == 0)\n\t\tis_object++;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tn = mono_string_to_utf8 (tb->nspace);\n\tif (strcmp (n, \"System\") == 0)\n\t\tis_system++;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tif (tb->parent && !(is_system && is_object) && \n\t\t\t!(tb->attrs & TYPE_ATTRIBUTE_INTERFACE)) { /* interfaces don't have a parent */\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t} else {\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\t}\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = assembly->tables [MONO_TABLE_FIELD].next_idx;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = assembly->tables [MONO_TABLE_METHOD].next_idx;\n\n\t/*\n\t * if we have explicitlayout or sequentiallayouts, output data in the\n\t * ClassLayout table.\n\t */\n\tif (((tb->attrs & TYPE_ATTRIBUTE_LAYOUT_MASK) != TYPE_ATTRIBUTE_AUTO_LAYOUT) &&\n\t\t\t((tb->class_size > 0) || (tb->packing_size > 0))) {\n\t\ttable = &assembly->tables [MONO_TABLE_CLASSLAYOUT];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CLASS_LAYOUT_SIZE;\n\t\tvalues [MONO_CLASS_LAYOUT_PARENT] = tb->table_idx;\n\t\tvalues [MONO_CLASS_LAYOUT_CLASS_SIZE] = tb->class_size;\n\t\tvalues [MONO_CLASS_LAYOUT_PACKING_SIZE] = tb->packing_size;\n\t}\n\n\t/* handle interfaces */\n\tif (tb->interfaces) {\n\t\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\t\ti = table->rows;\n\t\ttable->rows += mono_array_length (tb->interfaces);\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + (i + 1) * MONO_INTERFACEIMPL_SIZE;\n\t\tfor (i = 0; i < mono_array_length (tb->interfaces); ++i) {\n\t\t\tMonoReflectionType* iface = (MonoReflectionType*) mono_array_get (tb->interfaces, gpointer, i);\n\t\t\tvalues [MONO_INTERFACEIMPL_CLASS] = tb->table_idx;\n\t\t\tvalues [MONO_INTERFACEIMPL_INTERFACE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (iface));\n\t\t\tvalues += MONO_INTERFACEIMPL_SIZE;\n\t\t}\n\t}\n\n\t/* handle fields */\n\tif (tb->fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += tb->num_fields;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_fields; ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (tb->fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\t/* handle constructors */\n\tif (tb->ctors) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (tb->ctors);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i)\n\t\t\tmono_image_get_ctor_info (domain,\n\t\t\t\tmono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i), assembly);\n\t}\n\n\t/* handle methods */\n\tif (tb->methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += tb->num_methods;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_methods; ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\n\t/* Do the same with properties etc.. */\n\tif (tb->events && mono_array_length (tb->events)) {\n\t\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\t\ttable->rows += mono_array_length (tb->events);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_EVENTMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_EVENT_MAP_SIZE;\n\t\tvalues [MONO_EVENT_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_EVENT_MAP_EVENTLIST] = assembly->tables [MONO_TABLE_EVENT].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i)\n\t\t\tmono_image_get_event_info (\n\t\t\t\tmono_array_get (tb->events, MonoReflectionEventBuilder*, i), assembly);\n\t}\n\tif (tb->properties && mono_array_length (tb->properties)) {\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\t\ttable->rows += mono_array_length (tb->properties);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTYMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_PROPERTY_MAP_SIZE;\n\t\tvalues [MONO_PROPERTY_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_PROPERTY_MAP_PROPERTY_LIST] = assembly->tables [MONO_TABLE_PROPERTY].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i)\n\t\t\tmono_image_get_property_info (\n\t\t\t\tmono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i), assembly);\n\t}\n\n\t/* handle generic parameters */\n\tif (tb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (tb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_TYPE | (tb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (tb->generic_params, MonoReflectionGenericParam*, i), owner, assembly);\n\t\t}\n\t}\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx), tb->permissions);\n\n\tif (tb->subtypes) {\n\t\tMonoDynamicTable *ntable;\n\t\t\n\t\tntable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\t\tntable->rows += mono_array_length (tb->subtypes);\n\t\talloc_table (ntable, ntable->rows);\n\t\tvalues = ntable->values + ntable->next_idx * MONO_NESTED_CLASS_SIZE;\n\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\n\t\t\tvalues [MONO_NESTED_CLASS_NESTED] = subtype->table_idx;\n\t\t\tvalues [MONO_NESTED_CLASS_ENCLOSING] = tb->table_idx;\n\t\t\t/*g_print (\"nesting %s (%d) in %s (%d) (rows %d/%d)\\n\",\n\t\t\t\tmono_string_to_utf8 (subtype->name), subtype->table_idx,\n\t\t\t\tmono_string_to_utf8 (tb->name), tb->table_idx,\n\t\t\t\tntable->next_idx, ntable->rows);*/\n\t\t\tvalues += MONO_NESTED_CLASS_SIZE;\n\t\t\tntable->next_idx++;\n\t\t}\n\t}\n}\n#endif\n\nstatic void\ncollect_types (GPtrArray *types, MonoReflectionTypeBuilder *type)\n{\n\tint i;\n\n\tg_ptr_array_add (types, type); /* FIXME: GC object added to unmanaged memory */\n\n\tif (!type->subtypes)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (type->subtypes); ++i) {\n\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (type->subtypes, MonoReflectionTypeBuilder*, i);\n\t\tcollect_types (types, subtype);\n\t}\n}\n\nstatic gint\ncompare_types_by_table_idx (MonoReflectionTypeBuilder **type1, MonoReflectionTypeBuilder **type2)\n{\n\tif ((*type1)->table_idx < (*type2)->table_idx)\n\t\treturn -1;\n\telse\n\t\tif ((*type1)->table_idx > (*type2)->table_idx)\n\t\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void\nparams_add_cattrs (MonoDynamicImage *assembly, MonoArray *pinfo) {\n\tint i;\n\n\tif (!pinfo)\n\t\treturn;\n\tfor (i = 0; i < mono_array_length (pinfo); ++i) {\n\t\tMonoReflectionParamBuilder *pb;\n\t\tpb = mono_array_get (pinfo, MonoReflectionParamBuilder *, i);\n\t\tif (!pb)\n\t\t\tcontinue;\n\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PARAMDEF, pb->cattrs);\n\t}\n}\n\nstatic void\ntype_add_cattrs (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb) {\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, tb->table_idx, MONO_CUSTOM_ATTR_TYPEDEF, tb->cattrs);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < tb->num_fields; ++i) {\n\t\t\tMonoReflectionFieldBuilder* fb;\n\t\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\tif (tb->events) {\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i) {\n\t\t\tMonoReflectionEventBuilder* eb;\n\t\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, eb->table_idx, MONO_CUSTOM_ATTR_EVENT, eb->cattrs);\n\t\t}\n\t}\n\tif (tb->properties) {\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i) {\n\t\t\tMonoReflectionPropertyBuilder* pb;\n\t\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PROPERTY, pb->cattrs);\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder* cb;\n\t\t\tcb = mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, cb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, cb->cattrs);\n\t\t\tparams_add_cattrs (assembly, cb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb;\n\t\t\tmb = mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmodule_add_cattrs (MonoDynamicImage *assembly, MonoReflectionModuleBuilder *moduleb)\n{\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, moduleb->table_idx, MONO_CUSTOM_ATTR_MODULE, moduleb->cattrs);\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb = mono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (moduleb->global_fields) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\t\n\tif (moduleb->types) {\n\t\tfor (i = 0; i < moduleb->num_types; ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmono_image_fill_file_table (MonoDomain *domain, MonoReflectionModule *module, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *dir, *path;\n\n\ttable = &assembly->tables [MONO_TABLE_FILE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_METADATA;\n\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, module->image->module_name);\n\tif (module->image->dynamic) {\n\t\t/* This depends on the fact that the main module is emitted last */\n\t\tdir = mono_string_to_utf8 (((MonoReflectionModuleBuilder*)module)->assemblyb->dir);\n\t\tpath = g_strdup_printf (\"%s%c%s\", dir, G_DIR_SEPARATOR, module->image->module_name);\n\t} else {\n\t\tdir = NULL;\n\t\tpath = g_strdup (module->image->name);\n\t}\n\tmono_sha1_get_digest_from_file (path, hash);\n\tg_free (dir);\n\tg_free (path);\n\tmono_metadata_encode_value (20, b, &b);\n\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\ttable->next_idx ++;\n}\n\nstatic void\nmono_image_fill_module_table (MonoDomain *domain, MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\tmb->table_idx = table->next_idx ++;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->module.name);\n\ti = mono_image_add_stream_data (&assembly->guid, mono_array_addr (mb->guid, char, 0), 16);\n\ti /= 16;\n\t++i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_GENERATION] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_MVID] = i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENC] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENCBASE] = 0;\n}\n\nstatic guint32\nmono_image_fill_export_table_from_class (MonoDomain *domain, MonoClass *klass,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 visib, res;\n\n\tvisib = klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\tif (! ((visib & TYPE_ATTRIBUTE_PUBLIC) || (visib & TYPE_ATTRIBUTE_NESTED_PUBLIC)))\n\t\treturn 0;\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = klass->flags;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = klass->type_token;\n\tif (klass->nested_in)\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (parent_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\telse\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (module_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_FILE;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = table->next_idx;\n\n\ttable->next_idx ++;\n\n\t/* Emit nested types */\n\tif (klass->ext && klass->ext->nested_classes) {\n\t\tGList *tmp;\n\n\t\tfor (tmp = klass->ext->nested_classes; tmp; tmp = tmp->next)\n\t\t\tmono_image_fill_export_table_from_class (domain, tmp->data, module_index, table->next_idx - 1, assembly);\n\t}\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table (MonoDomain *domain, MonoReflectionTypeBuilder *tb,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tguint32 idx, i;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tklass->type_token = mono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx);\n\n\tidx = mono_image_fill_export_table_from_class (domain, klass, module_index, \n\t\t\t\t\t\t\t\t\t\t\t\t   parent_index, assembly);\n\n\t/* \n\t * Emit nested types\n\t * We need to do this ourselves since klass->nested_classes is not set up.\n\t */\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\tmono_image_fill_export_table (domain, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i), module_index, idx, assembly);\n\t}\n}\n\nstatic void\nmono_image_fill_export_table_from_module (MonoDomain *domain, MonoReflectionModule *module,\n\tguint32 module_index, MonoDynamicImage *assembly)\n{\n\tMonoImage *image = module->image;\n\tMonoTableInfo  *t;\n\tguint32 i;\n\n\tt = &image->tables [MONO_TABLE_TYPEDEF];\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tMonoClass *klass = mono_class_get (image, mono_metadata_make_token (MONO_TABLE_TYPEDEF, i + 1));\n\n\t\tif (klass->flags & TYPE_ATTRIBUTE_PUBLIC)\n\t\t\tmono_image_fill_export_table_from_class (domain, klass, module_index, 0, assembly);\n\t}\n}\n\nstatic guint32\nadd_exported_type (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly, MonoClass *klass)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 scope, idx, res, impl;\n\tgboolean forwarder = TRUE;\n\n\tif (klass->nested_in) {\n\t\timpl = add_exported_type (assemblyb, assembly, klass->nested_in);\n\t\tforwarder = FALSE;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t\tg_assert ((scope & MONO_RESOLTION_SCOPE_MASK) == MONO_RESOLTION_SCOPE_ASSEMBLYREF);\n\t\tidx = scope >> MONO_RESOLTION_SCOPE_BITS;\n\t\timpl = (idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_ASSEMBLYREF;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = forwarder ? TYPE_ATTRIBUTE_FORWARDER : 0;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = 0;\n\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = impl;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = (table->next_idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\n\ttable->next_idx++;\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table_from_type_forwarders (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tint i;\n\n\tif (!assemblyb->type_forwarders)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (assemblyb->type_forwarders); ++i) {\n\t\tMonoReflectionType *t = mono_array_get (assemblyb->type_forwarders, MonoReflectionType *, i);\n\t\tMonoType *type;\n\t\tif (!t)\n\t\t\tcontinue;\n\n\t\ttype = mono_reflection_type_get_handle (t);\n\t\tg_assert (type);\n\n\t\tklass = mono_class_from_mono_type (type);\n\n\t\tadd_exported_type (assemblyb, assembly, klass);\n\t}\n}\n\n#define align_pointer(base,p)\\\n\tdo {\\\n\t\tguint32 __diff = (unsigned char*)(p)-(unsigned char*)(base);\\\n\t\tif (__diff & 3)\\\n\t\t\t(p) += 4 - (__diff & 3);\\\n\t} while (0)\n\nstatic int\ncompare_constants (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\treturn a_values [MONO_CONSTANT_PARENT] - b_values [MONO_CONSTANT_PARENT];\n}\n\nstatic int\ncompare_semantics (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\tint assoc = a_values [MONO_METHOD_SEMA_ASSOCIATION] - b_values [MONO_METHOD_SEMA_ASSOCIATION];\n\tif (assoc)\n\t\treturn assoc;\n\treturn a_values [MONO_METHOD_SEMA_SEMANTICS] - b_values [MONO_METHOD_SEMA_SEMANTICS];\n}\n\nstatic int\ncompare_custom_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_CUSTOM_ATTR_PARENT] - b_values [MONO_CUSTOM_ATTR_PARENT];\n}\n\nstatic int\ncompare_field_marshal (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_FIELD_MARSHAL_PARENT] - b_values [MONO_FIELD_MARSHAL_PARENT];\n}\n\nstatic int\ncompare_nested (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_NESTED_CLASS_NESTED] - b_values [MONO_NESTED_CLASS_NESTED];\n}\n\nstatic int\ncompare_genericparam (const void *a, const void *b)\n{\n\tconst GenericParamTableEntry **a_entry = (const GenericParamTableEntry **) a;\n\tconst GenericParamTableEntry **b_entry = (const GenericParamTableEntry **) b;\n\n\tif ((*b_entry)->owner == (*a_entry)->owner)\n\t\treturn \n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*a_entry)->gparam)) -\n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*b_entry)->gparam));\n\telse\n\t\treturn (*a_entry)->owner - (*b_entry)->owner;\n}\n\nstatic int\ncompare_declsecurity_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_DECL_SECURITY_PARENT] - b_values [MONO_DECL_SECURITY_PARENT];\n}\n\nstatic int\ncompare_interface_impl (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\tint klass = a_values [MONO_INTERFACEIMPL_CLASS] - b_values [MONO_INTERFACEIMPL_CLASS];\n\tif (klass)\n\t\treturn klass;\n\n\treturn a_values [MONO_INTERFACEIMPL_INTERFACE] - b_values [MONO_INTERFACEIMPL_INTERFACE];\n}\n\nstatic void\npad_heap (MonoDynamicStream *sh)\n{\n\tif (sh->index & 3) {\n\t\tint sz = 4 - (sh->index & 3);\n\t\tmemset (sh->data + sh->index, 0, sz);\n\t\tsh->index += sz;\n\t}\n}\n\nstruct StreamDesc {\n\tconst char *name;\n\tMonoDynamicStream *stream;\n};\n\n/*\n * build_compressed_metadata() fills in the blob of data that represents the \n * raw metadata as it will be saved in the PE file. The five streams are output \n * and the metadata tables are comnpressed from the guint32 array representation, \n * to the compressed on-disk format.\n */\nstatic void\nbuild_compressed_metadata (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\tguint64 valid_mask = 0;\n\tguint64 sorted_mask;\n\tguint32 heapt_size = 0;\n\tguint32 meta_size = 256; /* allow for header and other stuff */\n\tguint32 table_offset;\n\tguint32 ntables = 0;\n\tguint64 *int64val;\n\tguint32 *int32val;\n\tguint16 *int16val;\n\tMonoImage *meta;\n\tunsigned char *p;\n\tstruct StreamDesc stream_desc [5];\n\n\tqsort (assembly->gen_params->pdata, assembly->gen_params->len, sizeof (gpointer), compare_genericparam);\n\tfor (i = 0; i < assembly->gen_params->len; i++){\n\t\tGenericParamTableEntry *entry = g_ptr_array_index (assembly->gen_params, i);\n\t\twrite_generic_param_entry (assembly, entry);\n\t}\n\n\tstream_desc [0].name  = \"#~\";\n\tstream_desc [0].stream = &assembly->tstream;\n\tstream_desc [1].name  = \"#Strings\";\n\tstream_desc [1].stream = &assembly->sheap;\n\tstream_desc [2].name  = \"#US\";\n\tstream_desc [2].stream = &assembly->us;\n\tstream_desc [3].name  = \"#Blob\";\n\tstream_desc [3].stream = &assembly->blob;\n\tstream_desc [4].name  = \"#GUID\";\n\tstream_desc [4].stream = &assembly->guid;\n\t\n\t/* tables that are sorted */\n\tsorted_mask = ((guint64)1 << MONO_TABLE_CONSTANT) | ((guint64)1 << MONO_TABLE_FIELDMARSHAL)\n\t\t| ((guint64)1 << MONO_TABLE_METHODSEMANTICS) | ((guint64)1 << MONO_TABLE_CLASSLAYOUT)\n\t\t| ((guint64)1 << MONO_TABLE_FIELDLAYOUT) | ((guint64)1 << MONO_TABLE_FIELDRVA)\n\t\t| ((guint64)1 << MONO_TABLE_IMPLMAP) | ((guint64)1 << MONO_TABLE_NESTEDCLASS)\n\t\t| ((guint64)1 << MONO_TABLE_METHODIMPL) | ((guint64)1 << MONO_TABLE_CUSTOMATTRIBUTE)\n\t\t| ((guint64)1 << MONO_TABLE_DECLSECURITY) | ((guint64)1 << MONO_TABLE_GENERICPARAM)\n\t\t| ((guint64)1 << MONO_TABLE_INTERFACEIMPL);\n\t\n\t/* Compute table sizes */\n\t/* the MonoImage has already been created in mono_image_basic_init() */\n\tmeta = &assembly->image;\n\n\t/* sizes should be multiple of 4 */\n\tpad_heap (&assembly->blob);\n\tpad_heap (&assembly->guid);\n\tpad_heap (&assembly->sheap);\n\tpad_heap (&assembly->us);\n\n\t/* Setup the info used by compute_sizes () */\n\tmeta->idx_blob_wide = assembly->blob.index >= 65536 ? 1 : 0;\n\tmeta->idx_guid_wide = assembly->guid.index >= 65536 ? 1 : 0;\n\tmeta->idx_string_wide = assembly->sheap.index >= 65536 ? 1 : 0;\n\n\tmeta_size += assembly->blob.index;\n\tmeta_size += assembly->guid.index;\n\tmeta_size += assembly->sheap.index;\n\tmeta_size += assembly->us.index;\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i)\n\t\tmeta->tables [i].rows = assembly->tables [i].rows;\n\t\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\tvalid_mask |= (guint64)1 << i;\n\t\tntables ++;\n\t\tmeta->tables [i].row_size = mono_metadata_compute_size (\n\t\t\tmeta, i, &meta->tables [i].size_bitfield);\n\t\theapt_size += meta->tables [i].row_size * meta->tables [i].rows;\n\t}\n\theapt_size += 24; /* #~ header size */\n\theapt_size += ntables * 4;\n\t/* make multiple of 4 */\n\theapt_size += 3;\n\theapt_size &= ~3;\n\tmeta_size += heapt_size;\n\tmeta->raw_metadata = g_malloc0 (meta_size);\n\tp = (unsigned char*)meta->raw_metadata;\n\t/* the metadata signature */\n\t*p++ = 'B'; *p++ = 'S'; *p++ = 'J'; *p++ = 'B';\n\t/* version numbers and 4 bytes reserved */\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (meta->md_version_major);\n\t*int16val = GUINT16_TO_LE (meta->md_version_minor);\n\tp += 8;\n\t/* version string */\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE ((strlen (meta->version) + 3) & (~3)); /* needs to be multiple of 4 */\n\tp += 4;\n\tmemcpy (p, meta->version, strlen (meta->version));\n\tp += GUINT32_FROM_LE (*int32val);\n\talign_pointer (meta->raw_metadata, p);\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (0); /* flags must be 0 */\n\t*int16val = GUINT16_TO_LE (5); /* number of streams */\n\tp += 4;\n\n\t/*\n\t * write the stream info.\n\t */\n\ttable_offset = (p - (unsigned char*)meta->raw_metadata) + 5 * 8 + 40; /* room needed for stream headers */\n\ttable_offset += 3; table_offset &= ~3;\n\n\tassembly->tstream.index = heapt_size;\n\tfor (i = 0; i < 5; ++i) {\n\t\tint32val = (guint32*)p;\n\t\tstream_desc [i].stream->offset = table_offset;\n\t\t*int32val++ = GUINT32_TO_LE (table_offset);\n\t\t*int32val = GUINT32_TO_LE (stream_desc [i].stream->index);\n\t\ttable_offset += GUINT32_FROM_LE (*int32val);\n\t\ttable_offset += 3; table_offset &= ~3;\n\t\tp += 8;\n\t\tstrcpy ((char*)p, stream_desc [i].name);\n\t\tp += strlen (stream_desc [i].name) + 1;\n\t\talign_pointer (meta->raw_metadata, p);\n\t}\n\t/* \n\t * now copy the data, the table stream header and contents goes first.\n\t */\n\tg_assert ((p - (unsigned char*)meta->raw_metadata) < assembly->tstream.offset);\n\tp = (guchar*)meta->raw_metadata + assembly->tstream.offset;\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE (0); /* reserved */\n\tp += 4;\n\n\tif (mono_framework_version () > 1) {\n\t\t*p++ = 2; /* version */\n\t\t*p++ = 0;\n\t} else {\n\t\t*p++ = 1; /* version */\n\t\t*p++ = 0;\n\t}\n\n\tif (meta->idx_string_wide)\n\t\t*p |= 0x01;\n\tif (meta->idx_guid_wide)\n\t\t*p |= 0x02;\n\tif (meta->idx_blob_wide)\n\t\t*p |= 0x04;\n\t++p;\n\t*p++ = 1; /* reserved */\n\tint64val = (guint64*)p;\n\t*int64val++ = GUINT64_TO_LE (valid_mask);\n\t*int64val++ = GUINT64_TO_LE (valid_mask & sorted_mask); /* bitvector of sorted tables  */\n\tp += 16;\n\tint32val = (guint32*)p;\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\t*int32val++ = GUINT32_TO_LE (meta->tables [i].rows);\n\t}\n\tp = (unsigned char*)int32val;\n\n\t/* sort the tables that still need sorting */\n\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CONSTANT_SIZE, table->rows, sizeof (guint32) * MONO_CONSTANT_SIZE, compare_constants);\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_METHOD_SEMA_SIZE, table->rows, sizeof (guint32) * MONO_METHOD_SEMA_SIZE, compare_semantics);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CUSTOM_ATTR_SIZE, table->rows, sizeof (guint32) * MONO_CUSTOM_ATTR_SIZE, compare_custom_attrs);\n\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_FIELD_MARSHAL_SIZE, table->rows, sizeof (guint32) * MONO_FIELD_MARSHAL_SIZE, compare_field_marshal);\n\ttable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_NESTED_CLASS_SIZE, table->rows, sizeof (guint32) * MONO_NESTED_CLASS_SIZE, compare_nested);\n\t/* Section 21.11 DeclSecurity in Partition II doesn't specify this to be sorted by MS implementation requires it */\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_DECL_SECURITY_SIZE, table->rows, sizeof (guint32) * MONO_DECL_SECURITY_SIZE, compare_declsecurity_attrs);\n\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_INTERFACEIMPL_SIZE, table->rows, sizeof (guint32) * MONO_INTERFACEIMPL_SIZE, compare_interface_impl);\n\n\t/* compress the tables */\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tint row, col;\n\t\tguint32 *values;\n\t\tguint32 bitfield = meta->tables [i].size_bitfield;\n\t\tif (!meta->tables [i].rows)\n\t\t\tcontinue;\n\t\tif (assembly->tables [i].columns != mono_metadata_table_count (bitfield))\n\t\t\tg_error (\"col count mismatch in %d: %d %d\", i, assembly->tables [i].columns, mono_metadata_table_count (bitfield));\n\t\tmeta->tables [i].base = (char*)p;\n\t\tfor (row = 1; row <= meta->tables [i].rows; ++row) {\n\t\t\tvalues = assembly->tables [i].values + row * assembly->tables [i].columns;\n\t\t\tfor (col = 0; col < assembly->tables [i].columns; ++col) {\n\t\t\t\tswitch (mono_metadata_table_size (bitfield, col)) {\n\t\t\t\tcase 1:\n\t\t\t\t\t*p++ = values [col];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 16) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 24) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_assert ((p - (const unsigned char*)meta->tables [i].base) == (meta->tables [i].rows * meta->tables [i].row_size));\n\t}\n\t\n\tg_assert (assembly->guid.offset + assembly->guid.index < meta_size);\n\tmemcpy (meta->raw_metadata + assembly->sheap.offset, assembly->sheap.data, assembly->sheap.index);\n\tmemcpy (meta->raw_metadata + assembly->us.offset, assembly->us.data, assembly->us.index);\n\tmemcpy (meta->raw_metadata + assembly->blob.offset, assembly->blob.data, assembly->blob.index);\n\tmemcpy (meta->raw_metadata + assembly->guid.offset, assembly->guid.data, assembly->guid.index);\n\n\tassembly->meta_size = assembly->guid.offset + assembly->guid.index;\n}\n\n/*\n * Some tables in metadata need to be sorted according to some criteria, but\n * when methods and fields are first created with reflection, they may be assigned a token\n * that doesn't correspond to the final token they will get assigned after the sorting.\n * ILGenerator.cs keeps a fixup table that maps the position of tokens in the IL code stream\n * with the reflection objects that represent them. Once all the tables are set up, the \n * reflection objects will contains the correct table index. fixup_method() will fixup the\n * tokens for the method with ILGenerator @ilgen.\n */\nstatic void\nfixup_method (MonoReflectionILGen *ilgen, gpointer value, MonoDynamicImage *assembly)\n{\n\tguint32 code_idx = GPOINTER_TO_UINT (value);\n\tMonoReflectionILTokenInfo *iltoken;\n\tMonoReflectionFieldBuilder *field;\n\tMonoReflectionCtorBuilder *ctor;\n\tMonoReflectionMethodBuilder *method;\n\tMonoReflectionTypeBuilder *tb;\n\tMonoReflectionArrayMethod *am;\n\tguint32 i, idx = 0;\n\tunsigned char *target;\n\n\tfor (i = 0; i < ilgen->num_token_fixups; ++i) {\n\t\tiltoken = (MonoReflectionILTokenInfo *)mono_array_addr_with_size (ilgen->token_fixups, sizeof (MonoReflectionILTokenInfo), i);\n\t\ttarget = (guchar*)assembly->code.data + code_idx + iltoken->code_pos;\n\t\tswitch (target [3]) {\n\t\tcase MONO_TABLE_FIELD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tfield = (MonoReflectionFieldBuilder *)iltoken->member;\n\t\t\t\tidx = field->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->field_to_table_idx, f));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tmethod = (MonoReflectionMethodBuilder *)iltoken->member;\n\t\t\t\tidx = method->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tctor = (MonoReflectionCtorBuilder *)iltoken->member;\n\t\t\t\tidx = ctor->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") || \n\t\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tif (strcmp (iltoken->member->vtable->klass->name, \"TypeBuilder\"))\n\t\t\t\tg_assert_not_reached ();\n\t\t\ttb = (MonoReflectionTypeBuilder *)iltoken->member;\n\t\t\tidx = tb->table_idx;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoArrayMethod\")) {\n\t\t\t\tam = (MonoReflectionArrayMethod*)iltoken->member;\n\t\t\t\tidx = am->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (m->klass->generic_class || m->klass->generic_container);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tg_assert (is_field_on_inst (f));\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\") ||\n\t\t\t\t\t!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHODSPEC:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (mono_method_signature (m)->generic_param_count);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"got unexpected table 0x%02x in fixup\", target [3]);\n\t\t}\n\t\ttarget [0] = idx & 0xff;\n\t\ttarget [1] = (idx >> 8) & 0xff;\n\t\ttarget [2] = (idx >> 16) & 0xff;\n\t}\n}\n\n/*\n * fixup_cattrs:\n *\n *   The CUSTOM_ATTRIBUTE table might contain METHODDEF tokens whose final\n * value is not known when the table is emitted.\n */\nstatic void\nfixup_cattrs (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 type, i, idx, token;\n\tMonoObject *ctor;\n\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tvalues = table->values + ((i + 1) * MONO_CUSTOM_ATTR_SIZE);\n\n\t\ttype = values [MONO_CUSTOM_ATTR_TYPE];\n\t\tif ((type & MONO_CUSTOM_ATTR_TYPE_MASK) == MONO_CUSTOM_ATTR_TYPE_METHODDEF) {\n\t\t\tidx = type >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\t\ttoken = mono_metadata_make_token (MONO_TABLE_METHOD, idx);\n\t\t\tctor = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\t\t\tg_assert (ctor);\n\n\t\t\tif (!strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)ctor)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = (idx << MONO_CUSTOM_ATTR_TYPE_BITS) | MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nassembly_add_resource_manifest (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc, guint32 implementation)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_MANIFESTRESOURCE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_MANIFEST_SIZE;\n\tvalues [MONO_MANIFEST_OFFSET] = rsrc->offset;\n\tvalues [MONO_MANIFEST_FLAGS] = rsrc->attrs;\n\tvalues [MONO_MANIFEST_NAME] = string_heap_insert_mstring (&assembly->sheap, rsrc->name);\n\tvalues [MONO_MANIFEST_IMPLEMENTATION] = implementation;\n\ttable->next_idx++;\n}\n\nstatic void\nassembly_add_resource (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *name, *sname;\n\tguint32 idx, offset;\n\n\tif (rsrc->filename) {\n\t\tname = mono_string_to_utf8 (rsrc->filename);\n\t\tsname = g_path_get_basename (name);\n\t\n\t\ttable = &assembly->tables [MONO_TABLE_FILE];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\t\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_NO_METADATA;\n\t\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, sname);\n\t\tg_free (sname);\n\n\t\tmono_sha1_get_digest_from_file (name, hash);\n\t\tmono_metadata_encode_value (20, b, &b);\n\t\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\t\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\t\tg_free (name);\n\t\tidx = table->next_idx++;\n\t\trsrc->offset = 0;\n\t\tidx = MONO_IMPLEMENTATION_FILE | (idx << MONO_IMPLEMENTATION_BITS);\n\t} else {\n\t\tchar sizebuf [4];\n\t\tchar *data;\n\t\tguint len;\n\t\tif (rsrc->data) {\n\t\t\tdata = mono_array_addr (rsrc->data, char, 0);\n\t\t\tlen = mono_array_length (rsrc->data);\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t\toffset = len;\n\t\tsizebuf [0] = offset; sizebuf [1] = offset >> 8;\n\t\tsizebuf [2] = offset >> 16; sizebuf [3] = offset >> 24;\n\t\trsrc->offset = mono_image_add_stream_data (&assembly->resources, sizebuf, 4);\n\t\tmono_image_add_stream_data (&assembly->resources, data, len);\n\n\t\tif (!mb->is_main)\n\t\t\t/* \n\t\t\t * The entry should be emitted into the MANIFESTRESOURCE table of \n\t\t\t * the main module, but that needs to reference the FILE table\n\t\t\t * which isn't emitted yet.\n\t\t\t */\n\t\t\treturn;\n\t\telse\n\t\t\tidx = 0;\n\t}\n\n\tassembly_add_resource_manifest (mb, assembly, rsrc, idx);\n}\n\nstatic void\nset_version_from_string (MonoString *version, guint32 *values)\n{\n\tgchar *ver, *p, *str;\n\tguint32 i;\n\t\n\tvalues [MONO_ASSEMBLY_MAJOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_MINOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_REV_NUMBER] = 0;\n\tvalues [MONO_ASSEMBLY_BUILD_NUMBER] = 0;\n\tif (!version)\n\t\treturn;\n\tver = str = mono_string_to_utf8 (version);\n\tfor (i = 0; i < 4; ++i) {\n\t\tvalues [MONO_ASSEMBLY_MAJOR_VERSION + i] = strtol (ver, &p, 10);\n\t\tswitch (*p) {\n\t\tcase '.':\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\t/* handle Revision and Build */\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\tver = p;\n\t}\n\tg_free (str);\n}\n\nstatic guint32\nload_public_key (MonoArray *pkey, MonoDynamicImage *assembly) {\n\tgsize len;\n\tguint32 token = 0;\n\tchar blob_size [6];\n\tchar *b = blob_size;\n\n\tif (!pkey)\n\t\treturn token;\n\n\tlen = mono_array_length (pkey);\n\tmono_metadata_encode_value (len, b, &b);\n\ttoken = mono_image_add_stream_data (&assembly->blob, blob_size, b - blob_size);\n\tmono_image_add_stream_data (&assembly->blob, mono_array_addr (pkey, char, 0), len);\n\n\tassembly->public_key = g_malloc (len);\n\tmemcpy (assembly->public_key, mono_array_addr (pkey, char, 0), len);\n\tassembly->public_key_len = len;\n\n\t/* Special case: check for ECMA key (16 bytes) */\n\tif ((len == MONO_ECMA_KEY_LENGTH) && mono_is_ecma_key (mono_array_addr (pkey, char, 0), len)) {\n\t\t/* In this case we must reserve 128 bytes (1024 bits) for the signature */\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH;\n\t} else if (len >= MONO_PUBLIC_KEY_HEADER_LENGTH + MONO_MINIMUM_PUBLIC_KEY_LENGTH) {\n\t\t/* minimum key size (in 2.0) is 384 bits */\n\t\tassembly->strong_name_size = len - MONO_PUBLIC_KEY_HEADER_LENGTH;\n\t} else {\n\t\t/* FIXME - verifier */\n\t\tg_warning (\"Invalid public key length: %d bits (total: %d)\", (int)MONO_PUBLIC_KEY_BIT_SIZE (len), (int)len);\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH; /* to be safe */\n\t}\n\tassembly->strong_name = g_malloc0 (assembly->strong_name_size);\n\n\treturn token;\n}\n\nstatic void\nmono_image_emit_manifest (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tguint32 *values;\n\tint i;\n\tguint32 module_index;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\t/* Emit ASSEMBLY table */\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLY];\n\talloc_table (table, 1);\n\tvalues = table->values + MONO_ASSEMBLY_SIZE;\n\tvalues [MONO_ASSEMBLY_HASH_ALG] = assemblyb->algid? assemblyb->algid: ASSEMBLY_HASH_SHA1;\n\tvalues [MONO_ASSEMBLY_NAME] = string_heap_insert_mstring (&assembly->sheap, assemblyb->name);\n\tif (assemblyb->culture) {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert_mstring (&assembly->sheap, assemblyb->culture);\n\t} else {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert (&assembly->sheap, \"\");\n\t}\n\tvalues [MONO_ASSEMBLY_PUBLIC_KEY] = load_public_key (assemblyb->public_key, assembly);\n\tvalues [MONO_ASSEMBLY_FLAGS] = assemblyb->flags;\n\tset_version_from_string (assemblyb->version, values);\n\n\t/* Emit FILE + EXPORTED_TYPE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\tif (file_module != moduleb) {\n\t\t\tmono_image_fill_file_table (domain, (MonoReflectionModule*)file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->types) {\n\t\t\t\tfor (j = 0; j < file_module->num_types; ++j) {\n\t\t\t\t\tMonoReflectionTypeBuilder *tb = mono_array_get (file_module->types, MonoReflectionTypeBuilder*, j);\n\t\t\t\t\tmono_image_fill_export_table (domain, tb, module_index, 0, assembly);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (assemblyb->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (assemblyb->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *file_module = \n\t\t\t\tmono_array_get (assemblyb->loaded_modules, MonoReflectionModule*, i);\n\t\t\tmono_image_fill_file_table (domain, file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tmono_image_fill_export_table_from_module (domain, file_module, module_index, assembly);\n\t\t}\n\t}\n\tif (assemblyb->type_forwarders)\n\t\tmono_image_fill_export_table_from_type_forwarders (assemblyb, assembly);\n\n\t/* Emit MANIFESTRESOURCE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\t/* The table for the main module is emitted later */\n\t\tif (file_module != moduleb) {\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->resources) {\n\t\t\t\tint len = mono_array_length (file_module->resources);\n\t\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\t\tMonoReflectionResource* res = (MonoReflectionResource*)mono_array_addr (file_module->resources, MonoReflectionResource, j);\n\t\t\t\t\tassembly_add_resource_manifest (file_module, assembly, res, MONO_IMPLEMENTATION_FILE | (module_index << MONO_IMPLEMENTATION_BITS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\n/*\n * mono_image_build_metadata() will fill the info in all the needed metadata tables\n * for the modulebuilder @moduleb.\n * At the end of the process, method and field tokens are fixed up and the \n * on-disk compressed metadata representation is created.\n */\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tGPtrArray *types;\n\tguint32 *values;\n\tint i, j;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\tif (assembly->text_rva)\n\t\treturn;\n\n\tassembly->text_rva = START_TEXT_RVA;\n\n\tif (moduleb->is_main) {\n\t\tmono_image_emit_manifest (moduleb);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows = 1; /* .<Module> */\n\ttable->next_idx++;\n\talloc_table (table, table->rows);\n\t/*\n\t * Set the first entry.\n\t */\n\tvalues = table->values + table->columns;\n\tvalues [MONO_TYPEDEF_FLAGS] = 0;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, \"<Module>\") ;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, \"\") ;\n\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = 1;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = 1;\n\n\t/* \n\t * handle global methods \n\t * FIXME: test what to do when global methods are defined in multiple modules.\n\t */\n\tif (moduleb->global_methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (moduleb->global_methods);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\tif (moduleb->global_fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += mono_array_length (moduleb->global_fields);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\talloc_table (table, 1);\n\tmono_image_fill_module_table (domain, moduleb, assembly);\n\n\t/* Collect all types into a list sorted by their table_idx */\n\ttypes = g_ptr_array_new ();\n\n\tif (moduleb->types)\n\t\tfor (i = 0; i < moduleb->num_types; ++i) {\n\t\t\tMonoReflectionTypeBuilder *type = mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i);\n\t\t\tcollect_types (types, type);\n\t\t}\n\n\tg_ptr_array_sort (types, (GCompareFunc)compare_types_by_table_idx);\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows += types->len;\n\talloc_table (table, table->rows);\n\n\t/*\n\t * Emit type names + namespaces at one place inside the string heap,\n\t * so load_class_names () needs to touch fewer pages.\n\t */\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->nspace);\n\t}\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->name);\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tmono_image_get_type_info (domain, type, assembly);\n\t}\n\n\t/* \n\t * table->rows is already set above and in mono_image_fill_module_table.\n\t */\n\t/* add all the custom attributes at the end, once all the indexes are stable */\n\tmono_image_add_cattrs (assembly, 1, MONO_CUSTOM_ATTR_ASSEMBLY, assemblyb->cattrs);\n\n\t/* CAS assembly permissions */\n\tif (assemblyb->permissions_minimum)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_minimum);\n\tif (assemblyb->permissions_optional)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_optional);\n\tif (assemblyb->permissions_refused)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_refused);\n\n\tmodule_add_cattrs (assembly, moduleb);\n\n\t/* fixup tokens */\n\tmono_g_hash_table_foreach (assembly->token_fixups, (GHFunc)fixup_method, assembly);\n\n\t/* Create the MethodImpl table.  We do this after emitting all methods so we already know\n\t * the final tokens and don't need another fixup pass. */\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\tmoduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tif (type->methods) {\n\t\t\tfor (j = 0; j < type->num_methods; ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\t\ttype->methods, MonoReflectionMethodBuilder*, j);\n\n\t\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_ptr_array_free (types, TRUE);\n\n\tfixup_cattrs (assembly);\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit_save, so saving of dynamic assemblies is not supported.\");\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n\ntypedef struct {\n\tguint32 import_lookup_table;\n\tguint32 timestamp;\n\tguint32 forwarder;\n\tguint32 name_rva;\n\tguint32 import_address_table_rva;\n} MonoIDT;\n\ntypedef struct {\n\tguint32 name_rva;\n\tguint32 flags;\n} MonoILT;\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_insert_string:\n * @module: module builder object\n * @str: a string\n *\n * Insert @str into the user string stream of @module.\n */\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tMonoDynamicImage *assembly;\n\tguint32 idx;\n\tchar buf [16];\n\tchar *b = buf;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!module->dynamic_image)\n\t\tmono_image_module_basic_init (module);\n\n\tassembly = module->dynamic_image;\n\t\n\tif (assembly->save) {\n\t\tmono_metadata_encode_value (1 | (str->length * 2), b, &b);\n\t\tidx = mono_image_add_stream_data (&assembly->us, buf, b-buf);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tmono_image_add_stream_data (&assembly->us, swapped, str->length * 2);\n\t\tg_free (swapped);\n\t}\n#else\n\t\tmono_image_add_stream_data (&assembly->us, (const char*)mono_string_chars (str), str->length * 2);\n#endif\n\t\tmono_image_add_stream_data (&assembly->us, \"\", 1);\n\t} else {\n\t\tidx = assembly->us.index ++;\n\t}\n\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (MONO_TOKEN_STRING | idx), str);\n\n\treturn MONO_TOKEN_STRING | idx;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\tif (strcmp (klass->name, \"MonoMethod\") == 0) {\n\t\tMonoMethod *method = ((MonoReflectionMethod *)obj)->method;\n\t\tMonoMethodSignature *sig, *old;\n\t\tguint32 sig_token, parent;\n\t\tint nargs, i;\n\n\t\tg_assert (opt_param_types && (mono_method_signature (method)->sentinelpos >= 0));\n\n\t\tnargs = mono_array_length (opt_param_types);\n\t\told = mono_method_signature (method);\n\t\tsig = mono_metadata_signature_alloc ( &assembly->image, old->param_count + nargs);\n\n\t\tsig->hasthis = old->hasthis;\n\t\tsig->explicit_this = old->explicit_this;\n\t\tsig->call_convention = old->call_convention;\n\t\tsig->generic_param_count = old->generic_param_count;\n\t\tsig->param_count = old->param_count + nargs;\n\t\tsig->sentinelpos = old->param_count;\n\t\tsig->ret = old->ret;\n\n\t\tfor (i = 0; i < old->param_count; i++)\n\t\t\tsig->params [i] = old->params [i];\n\n\t\tfor (i = 0; i < nargs; i++) {\n\t\t\tMonoReflectionType *rt = mono_array_get (opt_param_types, MonoReflectionType *, i);\n\t\t\tsig->params [old->param_count + i] = mono_reflection_type_get_handle (rt);\n\t\t}\n\n\t\tparent = mono_image_typedef_or_ref (assembly, &method->klass->byval_arg);\n\t\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_MEMBERREF_PARENT_TYPEREF);\n\t\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\t\tparent <<= MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_TYPEREF;\n\n\t\tsig_token = method_encode_signature (assembly, sig);\n\t\ttoken = mono_image_get_varargs_method_token (assembly, parent, method->name, sig_token);\n\t} else if (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tReflectionMethodBuilder rmb;\n\t\tguint32 parent, sig;\n\t\tchar *name;\n\n\t\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\t\trmb.opt_types = opt_param_types;\n\n\t\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\t\tparent = mono_image_create_token (assembly, obj, TRUE, TRUE);\n\t\tg_assert (mono_metadata_token_table (parent) == MONO_TABLE_METHOD);\n\n\t\tparent = mono_metadata_token_index (parent) << MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_METHODDEF;\n\n\t\tname = mono_string_to_utf8 (rmb.name);\n\t\ttoken = mono_image_get_varargs_method_token (\n\t\t\tassembly, parent, name, sig);\n\t\tg_free (name);\n\t} else {\n\t\tg_error (\"requested method token for %s\\n\", klass->name);\n\t}\n\n\treturn token;\n}\n\n/*\n * mono_image_create_token:\n * @assembly: a dynamic assembly\n * @obj:\n * @register_token: Whenever to register the token in the assembly->tokens hash. \n *\n * Get a token to insert in the IL code stream for the given MemberInfo.\n * The metadata emission routines need to pass FALSE as REGISTER_TOKEN, since by that time, \n * the table_idx-es were recomputed, so registering the token would overwrite an existing \n * entry.\n */\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\t/* Check for user defined reflection objects */\n\t/* TypeDelegator is the only corlib type which doesn't look like a MonoReflectionType */\n\tif (klass->image != mono_defaults.corlib || (strcmp (klass->name, \"TypeDelegator\") == 0))\n\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported\")); \\\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params && !mb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_methodbuilder_token (assembly, mb, create_methodspec);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_ctorbuilder_token (assembly, mb);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)fb->typeb;\n\t\tif (tb->generic_params) {\n\t\t\ttoken = mono_image_get_generic_field_token (assembly, fb);\n\t\t} else {\n\t\t\ttoken = fb->table_idx | MONO_TOKEN_FIELD_DEF;\n\t\t}\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tMonoClass *mc = mono_class_from_mono_type (type);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref_full (assembly, type, mc->generic_container == NULL));\n\t} else if (strcmp (klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tif (create_methodspec)\n\t\t\t\ttoken = mono_image_get_methodspec_token (assembly, m->method);\n\t\t\telse\n\t\t\t\ttoken = mono_image_get_inflated_method_token (assembly, m->method);\n\t\t} else if ((m->method->klass->image == &assembly->image) &&\n\t\t\t !m->method->klass->generic_class) {\n\t\t\tstatic guint32 method_table_idx = 0xffffff;\n\t\t\tif (m->method->klass->wastypebuilder) {\n\t\t\t\t/* we use the same token as the one that was assigned\n\t\t\t\t * to the Methodbuilder.\n\t\t\t\t * FIXME: do the equivalent for Fields.\n\t\t\t\t */\n\t\t\t\ttoken = m->method->token;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Each token should have a unique index, but the indexes are\n\t\t\t\t * assigned by managed code, so we don't know about them. An\n\t\t\t\t * easy solution is to count backwards...\n\t\t\t\t */\n\t\t\t\tmethod_table_idx --;\n\t\t\t\ttoken = MONO_TOKEN_METHOD_DEF | method_table_idx;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = mono_image_get_methodref_token (assembly, m->method, create_methodspec);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, m->method->name);*/\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField *)obj;\n\t\tif ((f->field->parent->image == &assembly->image) && !is_field_on_inst (f->field)) {\n\t\t\tstatic guint32 field_table_idx = 0xffffff;\n\t\t\tfield_table_idx --;\n\t\t\ttoken = MONO_TOKEN_FIELD_DEF | field_table_idx;\n\t\t} else {\n\t\t\ttoken = mono_image_get_fieldref_token (assembly, f);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, f->field->name);*/\n\t} else if (strcmp (klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod *)obj;\n\t\ttoken = mono_image_get_array_token (assembly, m);\n\t} else if (strcmp (klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *s = (MonoReflectionSigHelper*)obj;\n\t\ttoken = MONO_TOKEN_SIGNATURE | mono_image_get_sighelper_token (assembly, s);\n\t} else if (strcmp (klass->name, \"EnumBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_field_on_inst_token (assembly, f);\n\t} else if (strcmp (klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_ctor_on_inst_token (assembly, c, create_methodspec);\n\t} else if (strcmp (klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_method_on_inst_token (assembly, m, create_methodspec);\n\t} else if (is_sre_array (klass) || is_sre_byref (klass) || is_sre_pointer (klass)) {\n\t\tMonoReflectionType *type = (MonoReflectionType *)obj;\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\t\tmono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (type)));\n\t} else {\n\t\tg_error (\"requested token for %s\\n\", klass->name);\n\t}\n\n\tif (register_token)\n\t\tmono_image_register_token (assembly, token, obj);\n\n\treturn token;\n}\n\n/*\n * mono_image_register_token:\n *\n *   Register the TOKEN->OBJ mapping in the mapping table in ASSEMBLY. This is required for\n * the Module.ResolveXXXToken () methods to work.\n */\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n\tMonoObject *prev = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tif (prev) {\n\t\t/* There could be multiple MethodInfo objects with the same token */\n\t\t//g_assert (prev == obj);\n\t} else {\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), obj);\n\t}\n}\n\nstatic MonoDynamicImage*\ncreate_dynamic_mono_image (MonoDynamicAssembly *assembly, char *assembly_name, char *module_name)\n{\n\tstatic const guchar entrycode [16] = {0xff, 0x25, 0};\n\tMonoDynamicImage *image;\n\tint i;\n\n\tconst char *version;\n\n\tif (!strcmp (mono_get_runtime_info ()->framework_version, \"2.1\"))\n\t\tversion = \"v2.0.50727\"; /* HACK: SL 2 enforces the .net 2 metadata version */\n\telse\n\t\tversion = mono_get_runtime_info ()->runtime_version;\n\n#if HAVE_BOEHM_GC\n\timage = GC_MALLOC (sizeof (MonoDynamicImage));\n#else\n\timage = g_new0 (MonoDynamicImage, 1);\n#endif\n\t\n\tmono_profiler_module_event (&image->image, MONO_PROFILE_START_LOAD);\n\t\n\t/*g_print (\"created image %p\\n\", image);*/\n\t/* keep in sync with image.c */\n\timage->image.name = assembly_name;\n\timage->image.assembly_name = image->image.name; /* they may be different */\n\timage->image.module_name = module_name;\n\timage->image.version = g_strdup (version);\n\timage->image.md_version_major = 1;\n\timage->image.md_version_minor = 1;\n\timage->image.dynamic = TRUE;\n\n\timage->image.references = g_new0 (MonoAssembly*, 1);\n\timage->image.references [0] = NULL;\n\n\tmono_image_init (&image->image);\n\n\timage->token_fixups = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->method_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->field_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->method_aux_hash = g_hash_table_new (NULL, NULL);\n\timage->handleref = g_hash_table_new (NULL, NULL);\n\timage->tokens = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->generic_def_objects = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->methodspec = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->typespec = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->typeref = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->blob_cache = g_hash_table_new ((GHashFunc)mono_blob_entry_hash, (GCompareFunc)mono_blob_entry_equal);\n\timage->gen_params = g_ptr_array_new ();\n\n\t/*g_print (\"string heap create for image %p (%s)\\n\", image, module_name);*/\n\tstring_heap_init (&image->sheap);\n\tmono_image_add_stream_data (&image->us, \"\", 1);\n\tadd_to_blob_cached (image, (char*) \"\", 1, NULL, 0);\n\t/* import tables... */\n\tmono_image_add_stream_data (&image->code, (char*)entrycode, sizeof (entrycode));\n\timage->iat_offset = mono_image_add_stream_zero (&image->code, 8); /* two IAT entries */\n\timage->idt_offset = mono_image_add_stream_zero (&image->code, 2 * sizeof (MonoIDT)); /* two IDT entries */\n\timage->imp_names_offset = mono_image_add_stream_zero (&image->code, 2); /* flags for name entry */\n\tmono_image_add_stream_data (&image->code, \"_CorExeMain\", 12);\n\tmono_image_add_stream_data (&image->code, \"mscoree.dll\", 12);\n\timage->ilt_offset = mono_image_add_stream_zero (&image->code, 8); /* two ILT entries */\n\tstream_data_align (&image->code);\n\n\timage->cli_header_offset = mono_image_add_stream_zero (&image->code, sizeof (MonoCLIHeader));\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i) {\n\t\timage->tables [i].next_idx = 1;\n\t\timage->tables [i].columns = table_sizes [i];\n\t}\n\n\timage->image.assembly = (MonoAssembly*)assembly;\n\timage->run = assembly->run;\n\timage->save = assembly->save;\n\timage->pe_kind = 0x1; /* ILOnly */\n\timage->machine = 0x14c; /* I386 */\n\t\n\tmono_profiler_module_loaded (&image->image, MONO_PROFILE_OK);\n\n\treturn image;\n}\n#endif\n\nstatic void\nfree_blob_cache_entry (gpointer key, gpointer val, gpointer user_data)\n{\n\tg_free (key);\n}\n\nvoid\nmono_dynamic_image_free (MonoDynamicImage *image)\n{\n\tMonoDynamicImage *di = image;\n\tGList *list;\n\tint i;\n\n\tif (di->methodspec)\n\t\tmono_g_hash_table_destroy (di->methodspec);\n\tif (di->typespec)\n\t\tg_hash_table_destroy (di->typespec);\n\tif (di->typeref)\n\t\tg_hash_table_destroy (di->typeref);\n\tif (di->handleref)\n\t\tg_hash_table_destroy (di->handleref);\n\tif (di->tokens)\n\t\tmono_g_hash_table_destroy (di->tokens);\n\tif (di->generic_def_objects)\n\t\tmono_g_hash_table_destroy (di->generic_def_objects);\n\tif (di->blob_cache) {\n\t\tg_hash_table_foreach (di->blob_cache, free_blob_cache_entry, NULL);\n\t\tg_hash_table_destroy (di->blob_cache);\n\t}\n\tif (di->standalonesig_cache)\n\t\tg_hash_table_destroy (di->standalonesig_cache);\n\tfor (list = di->array_methods; list; list = list->next) {\n\t\tArrayMethod *am = (ArrayMethod *)list->data;\n\t\tg_free (am->sig);\n\t\tg_free (am->name);\n\t\tg_free (am);\n\t}\n\tg_list_free (di->array_methods);\n\tif (di->gen_params) {\n\t\tfor (i = 0; i < di->gen_params->len; i++) {\n\t\t\tGenericParamTableEntry *entry = g_ptr_array_index (di->gen_params, i);\n\t\t\tif (entry->gparam->type.type) {\n\t\t\t\tMonoGenericParam *param = entry->gparam->type.type->data.generic_param;\n\t\t\t\tg_free ((char*)mono_generic_param_info (param)->name);\n\t\t\t\tg_free (param);\n\t\t\t}\n\t\t\tg_free (entry);\n\t\t}\n\t \tg_ptr_array_free (di->gen_params, TRUE);\n\t}\n\tif (di->token_fixups)\n\t\tmono_g_hash_table_destroy (di->token_fixups);\n\tif (di->method_to_table_idx)\n\t\tg_hash_table_destroy (di->method_to_table_idx);\n\tif (di->field_to_table_idx)\n\t\tg_hash_table_destroy (di->field_to_table_idx);\n\tif (di->method_aux_hash)\n\t\tg_hash_table_destroy (di->method_aux_hash);\n\tg_free (di->strong_name);\n\tg_free (di->win32_res);\n\tif (di->public_key)\n\t\tg_free (di->public_key);\n\n\t/*g_print (\"string heap destroy for image %p\\n\", di);*/\n\tmono_dynamic_stream_reset (&di->sheap);\n\tmono_dynamic_stream_reset (&di->code);\n\tmono_dynamic_stream_reset (&di->resources);\n\tmono_dynamic_stream_reset (&di->us);\n\tmono_dynamic_stream_reset (&di->blob);\n\tmono_dynamic_stream_reset (&di->tstream);\n\tmono_dynamic_stream_reset (&di->guid);\n\tfor (i = 0; i < MONO_TABLE_NUM; ++i) {\n\t\tg_free (di->tables [i].values);\n\t}\n}\t\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_basic_init:\n * @assembly: an assembly builder object\n *\n * Create the MonoImage that represents the assembly builder and setup some\n * of the helper hash table and the basic metadata streams.\n */\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tMonoDynamicAssembly *assembly;\n\tMonoDynamicImage *image;\n\tMonoDomain *domain = mono_object_domain (assemblyb);\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (assemblyb->dynamic_assembly)\n\t\treturn;\n\n#if HAVE_BOEHM_GC\n\tassembly = assemblyb->dynamic_assembly = GC_MALLOC (sizeof (MonoDynamicAssembly));\n#else\n\tassembly = assemblyb->dynamic_assembly = g_new0 (MonoDynamicAssembly, 1);\n#endif\n\n\tmono_profiler_assembly_event (&assembly->assembly, MONO_PROFILE_START_LOAD);\n\t\n\tassembly->assembly.ref_count = 1;\n\tassembly->assembly.dynamic = TRUE;\n\tassembly->assembly.corlib_internal = assemblyb->corlib_internal;\n\tassemblyb->assembly.assembly = (MonoAssembly*)assembly;\n\tassembly->assembly.basedir = mono_string_to_utf8 (assemblyb->dir);\n\tif (assemblyb->culture)\n\t\tassembly->assembly.aname.culture = mono_string_to_utf8 (assemblyb->culture);\n\telse\n\t\tassembly->assembly.aname.culture = g_strdup (\"\");\n\n        if (assemblyb->version) {\n\t\t\tchar *vstr = mono_string_to_utf8 (assemblyb->version);\n\t\t\tchar **version = g_strsplit (vstr, \".\", 4);\n\t\t\tchar **parts = version;\n\t\t\tassembly->assembly.aname.major = atoi (*parts++);\n\t\t\tassembly->assembly.aname.minor = atoi (*parts++);\n\t\t\tassembly->assembly.aname.build = *parts != NULL ? atoi (*parts++) : 0;\n\t\t\tassembly->assembly.aname.revision = *parts != NULL ? atoi (*parts) : 0;\n\n\t\t\tg_strfreev (version);\n\t\t\tg_free (vstr);\n        } else {\n\t\t\tassembly->assembly.aname.major = 0;\n\t\t\tassembly->assembly.aname.minor = 0;\n\t\t\tassembly->assembly.aname.build = 0;\n\t\t\tassembly->assembly.aname.revision = 0;\n        }\n\n\tassembly->run = assemblyb->access != 2;\n\tassembly->save = assemblyb->access != 1;\n\tassembly->domain = domain;\n\n\timage = create_dynamic_mono_image (assembly, mono_string_to_utf8 (assemblyb->name), g_strdup (\"RefEmit_YouForgotToDefineAModule\"));\n\timage->initial_image = TRUE;\n\tassembly->assembly.aname.name = image->image.name;\n\tassembly->assembly.image = &image->image;\n\tif (assemblyb->pktoken && assemblyb->pktoken->max_length) {\n\t\t/* -1 to correct for the trailing NULL byte */\n\t\tif (assemblyb->pktoken->max_length != MONO_PUBLIC_KEY_TOKEN_LENGTH - 1) {\n\t\t\tg_error (\"Public key token length invalid for assembly %s: %i\", assembly->assembly.aname.name, assemblyb->pktoken->max_length);\n\t\t}\n\t\tmemcpy (&assembly->assembly.aname.public_key_token, mono_array_addr (assemblyb->pktoken, guint8, 0), assemblyb->pktoken->max_length);\t\t\n\t}\n\n\tmono_domain_assemblies_lock (domain);\n\tdomain->domain_assemblies = g_slist_prepend (domain->domain_assemblies, assembly);\n\tmono_domain_assemblies_unlock (domain);\n\n\tregister_assembly (mono_object_domain (assemblyb), &assemblyb->assembly, &assembly->assembly);\n\t\n\tmono_profiler_assembly_loaded (&assembly->assembly, MONO_PROFILE_OK);\n\t\n\tmono_assembly_invoke_load_hook ((MonoAssembly*)assembly);\n}\n\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\nstatic int\ncalc_section_size (MonoDynamicImage *assembly)\n{\n\tint nsections = 0;\n\n\t/* alignment constraints */\n\tmono_image_add_stream_zero (&assembly->code, 4 - (assembly->code.index % 4));\n\tg_assert ((assembly->code.index % 4) == 0);\n\tassembly->meta_size += 3;\n\tassembly->meta_size &= ~3;\n\tmono_image_add_stream_zero (&assembly->resources, 4 - (assembly->resources.index % 4));\n\tg_assert ((assembly->resources.index % 4) == 0);\n\n\tassembly->sections [MONO_SECTION_TEXT].size = assembly->meta_size + assembly->code.index + assembly->resources.index + assembly->strong_name_size;\n\tassembly->sections [MONO_SECTION_TEXT].attrs = SECT_FLAGS_HAS_CODE | SECT_FLAGS_MEM_EXECUTE | SECT_FLAGS_MEM_READ;\n\tnsections++;\n\n\tif (assembly->win32_res) {\n\t\tguint32 res_size = (assembly->win32_res_size + 3) & ~3;\n\n\t\tassembly->sections [MONO_SECTION_RSRC].size = res_size;\n\t\tassembly->sections [MONO_SECTION_RSRC].attrs = SECT_FLAGS_HAS_INITIALIZED_DATA | SECT_FLAGS_MEM_READ;\n\t\tnsections++;\n\t}\n\n\tassembly->sections [MONO_SECTION_RELOC].size = 12;\n\tassembly->sections [MONO_SECTION_RELOC].attrs = SECT_FLAGS_MEM_READ | SECT_FLAGS_MEM_DISCARDABLE | SECT_FLAGS_HAS_INITIALIZED_DATA;\n\tnsections++;\n\n\treturn nsections;\n}\n\ntypedef struct {\n\tguint32 id;\n\tguint32 offset;\n\tGSList *children;\n\tMonoReflectionWin32Resource *win32_res; /* Only for leaf nodes */\n} ResTreeNode;\n\nstatic int\nresource_tree_compare_by_id (gconstpointer a, gconstpointer b)\n{\n\tResTreeNode *t1 = (ResTreeNode*)a;\n\tResTreeNode *t2 = (ResTreeNode*)b;\n\n\treturn t1->id - t2->id;\n}\n\n/*\n * resource_tree_create:\n *\n *  Organize the resources into a resource tree.\n */\nstatic ResTreeNode *\nresource_tree_create (MonoArray *win32_resources)\n{\n\tResTreeNode *tree, *res_node, *type_node, *lang_node;\n\tGSList *l;\n\tint i;\n\n\ttree = g_new0 (ResTreeNode, 1);\n\t\n\tfor (i = 0; i < mono_array_length (win32_resources); ++i) {\n\t\tMonoReflectionWin32Resource *win32_res =\n\t\t\t(MonoReflectionWin32Resource*)mono_array_addr (win32_resources, MonoReflectionWin32Resource, i);\n\n\t\t/* Create node */\n\n\t\t/* FIXME: BUG: this stores managed references in unmanaged memory */\n\t\tlang_node = g_new0 (ResTreeNode, 1);\n\t\tlang_node->id = win32_res->lang_id;\n\t\tlang_node->win32_res = win32_res;\n\n\t\t/* Create type node if neccesary */\n\t\ttype_node = NULL;\n\t\tfor (l = tree->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_type) {\n\t\t\t\ttype_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!type_node) {\n\t\t\ttype_node = g_new0 (ResTreeNode, 1);\n\t\t\ttype_node->id = win32_res->res_type;\n\n\t\t\t/* \n\t\t\t * The resource types have to be sorted otherwise\n\t\t\t * Windows Explorer can't display the version information.\n\t\t\t */\n\t\t\ttree->children = g_slist_insert_sorted (tree->children, \n\t\t\t\ttype_node, resource_tree_compare_by_id);\n\t\t}\n\n\t\t/* Create res node if neccesary */\n\t\tres_node = NULL;\n\t\tfor (l = type_node->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_id) {\n\t\t\t\tres_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!res_node) {\n\t\t\tres_node = g_new0 (ResTreeNode, 1);\n\t\t\tres_node->id = win32_res->res_id;\n\t\t\ttype_node->children = g_slist_append (type_node->children, res_node);\n\t\t}\n\n\t\tres_node->children = g_slist_append (res_node->children, lang_node);\n\t}\n\n\treturn tree;\n}\n\n/*\n * resource_tree_encode:\n * \n *   Encode the resource tree into the format used in the PE file.\n */\nstatic void\nresource_tree_encode (ResTreeNode *node, char *begin, char *p, char **endbuf)\n{\n\tchar *entries;\n\tMonoPEResourceDir dir;\n\tMonoPEResourceDirEntry dir_entry;\n\tMonoPEResourceDataEntry data_entry;\n\tGSList *l;\n\tguint32 res_id_entries;\n\n\t/*\n\t * For the format of the resource directory, see the article\n\t * \"An In-Depth Look into the Win32 Portable Executable File Format\" by\n\t * Matt Pietrek\n\t */\n\n\tmemset (&dir, 0, sizeof (dir));\n\tmemset (&dir_entry, 0, sizeof (dir_entry));\n\tmemset (&data_entry, 0, sizeof (data_entry));\n\n\tg_assert (sizeof (dir) == 16);\n\tg_assert (sizeof (dir_entry) == 8);\n\tg_assert (sizeof (data_entry) == 16);\n\n\tnode->offset = p - begin;\n\n\t/* IMAGE_RESOURCE_DIRECTORY */\n\tres_id_entries = g_slist_length (node->children);\n\tdir.res_id_entries = GUINT16_TO_LE (res_id_entries);\n\n\tmemcpy (p, &dir, sizeof (dir));\n\tp += sizeof (dir);\n\n\t/* Reserve space for entries */\n\tentries = p;\n\tp += sizeof (dir_entry) * res_id_entries;\n\n\t/* Write children */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tif (child->win32_res) {\n\t\t\tguint32 size;\n\n\t\t\tchild->offset = p - begin;\n\n\t\t\t/* IMAGE_RESOURCE_DATA_ENTRY */\n\t\t\tdata_entry.rde_data_offset = GUINT32_TO_LE (p - begin + sizeof (data_entry));\n\t\t\tsize = mono_array_length (child->win32_res->res_data);\n\t\t\tdata_entry.rde_size = GUINT32_TO_LE (size);\n\n\t\t\tmemcpy (p, &data_entry, sizeof (data_entry));\n\t\t\tp += sizeof (data_entry);\n\n\t\t\tmemcpy (p, mono_array_addr (child->win32_res->res_data, char, 0), size);\n\t\t\tp += size;\n\t\t} else {\n\t\t\tresource_tree_encode (child, begin, p, &p);\n\t\t}\n\t}\n\n\t/* IMAGE_RESOURCE_ENTRY */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tMONO_PE_RES_DIR_ENTRY_SET_NAME (dir_entry, FALSE, child->id);\n\t\tMONO_PE_RES_DIR_ENTRY_SET_DIR (dir_entry, !child->win32_res, child->offset);\n\n\t\tmemcpy (entries, &dir_entry, sizeof (dir_entry));\n\t\tentries += sizeof (dir_entry);\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nresource_tree_free (ResTreeNode * node)\n{\n\tGSList * list;\n\tfor (list = node->children; list; list = list->next)\n\t\tresource_tree_free ((ResTreeNode*)list->data);\n\tg_slist_free(node->children);\n\tg_free (node);\n}\n\nstatic void\nassembly_add_win32_resources (MonoDynamicImage *assembly, MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tchar *buf;\n\tchar *p;\n\tguint32 size, i;\n\tMonoReflectionWin32Resource *win32_res;\n\tResTreeNode *tree;\n\n\tif (!assemblyb->win32_resources)\n\t\treturn;\n\n\t/*\n\t * Resources are stored in a three level tree inside the PE file.\n\t * - level one contains a node for each type of resource\n\t * - level two contains a node for each resource\n\t * - level three contains a node for each instance of a resource for a\n\t *   specific language.\n\t */\n\n\ttree = resource_tree_create (assemblyb->win32_resources);\n\n\t/* Estimate the size of the encoded tree */\n\tsize = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->win32_resources); ++i) {\n\t\twin32_res = (MonoReflectionWin32Resource*)mono_array_addr (assemblyb->win32_resources, MonoReflectionWin32Resource, i);\n\t\tsize += mono_array_length (win32_res->res_data);\n\t}\n\t/* Directory structure */\n\tsize += mono_array_length (assemblyb->win32_resources) * 256;\n\tp = buf = g_malloc (size);\n\n\tresource_tree_encode (tree, p, p, &p);\n\n\tg_assert (p - buf <= size);\n\n\tassembly->win32_res = g_malloc (p - buf);\n\tassembly->win32_res_size = p - buf;\n\tmemcpy (assembly->win32_res, buf, p - buf);\n\n\tg_free (buf);\n\tresource_tree_free (tree);\n}\n\nstatic void\nfixup_resource_directory (char *res_section, char *p, guint32 rva)\n{\n\tMonoPEResourceDir *dir = (MonoPEResourceDir*)p;\n\tint i;\n\n\tp += sizeof (MonoPEResourceDir);\n\tfor (i = 0; i < GUINT16_FROM_LE (dir->res_named_entries) + GUINT16_FROM_LE (dir->res_id_entries); ++i) {\n\t\tMonoPEResourceDirEntry *dir_entry = (MonoPEResourceDirEntry*)p;\n\t\tchar *child = res_section + MONO_PE_RES_DIR_ENTRY_DIR_OFFSET (*dir_entry);\n\t\tif (MONO_PE_RES_DIR_ENTRY_IS_DIR (*dir_entry)) {\n\t\t\tfixup_resource_directory (res_section, child, rva);\n\t\t} else {\n\t\t\tMonoPEResourceDataEntry *data_entry = (MonoPEResourceDataEntry*)child;\n\t\t\tdata_entry->rde_data_offset = GUINT32_TO_LE (GUINT32_FROM_LE (data_entry->rde_data_offset) + rva);\n\t\t}\n\n\t\tp += sizeof (MonoPEResourceDirEntry);\n\t}\n}\n\nstatic void\nchecked_write_file (HANDLE f, gconstpointer buffer, guint32 numbytes)\n{\n\tguint32 dummy;\n\tif (!WriteFile (f, buffer, numbytes, &dummy, NULL))\n\t\tg_error (\"WriteFile returned %d\\n\", GetLastError ());\n}\n\n/*\n * mono_image_create_pefile:\n * @mb: a module builder object\n * \n * This function creates the PE-COFF header, the image sections, the CLI header  * etc. all the data is written in\n * assembly->pefile where it can be easily retrieved later in chunks.\n */\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tMonoMSDOSHeader *msdos;\n\tMonoDotNetHeader *header;\n\tMonoSectionTable *section;\n\tMonoCLIHeader *cli_header;\n\tguint32 size, image_size, virtual_base, text_offset;\n\tguint32 header_start, section_start, file_offset, virtual_offset;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDynamicStream pefile_stream = {0};\n\tMonoDynamicStream *pefile = &pefile_stream;\n\tint i, nsections;\n\tguint32 *rva, value;\n\tguchar *p;\n\tstatic const unsigned char msheader[] = {\n\t\t0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,\n\t\t0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,\n\t\t0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,  0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,\n\t\t0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72,  0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,\n\t\t0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e,  0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,\n\t\t0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tassemblyb = mb->assemblyb;\n\n\tmono_image_basic_init (assemblyb);\n\tassembly = mb->dynamic_image;\n\n\tassembly->pe_kind = assemblyb->pe_kind;\n\tassembly->machine = assemblyb->machine;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->pe_kind = assemblyb->pe_kind;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->machine = assemblyb->machine;\n\t\n\tmono_image_build_metadata (mb);\n\n\tif (mb->is_main && assemblyb->resources) {\n\t\tint len = mono_array_length (assemblyb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (assemblyb->resources, MonoReflectionResource, i));\n\t}\n\n\tif (mb->resources) {\n\t\tint len = mono_array_length (mb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (mb->resources, MonoReflectionResource, i));\n\t}\n\n\tbuild_compressed_metadata (assembly);\n\n\tif (mb->is_main)\n\t\tassembly_add_win32_resources (assembly, assemblyb);\n\n\tnsections = calc_section_size (assembly);\n\t\n\t/* The DOS header and stub */\n\tg_assert (sizeof (MonoMSDOSHeader) == sizeof (msheader));\n\tmono_image_add_stream_data (pefile, (char*)msheader, sizeof (msheader));\n\n\t/* the dotnet header */\n\theader_start = mono_image_add_stream_zero (pefile, sizeof (MonoDotNetHeader));\n\n\t/* the section tables */\n\tsection_start = mono_image_add_stream_zero (pefile, sizeof (MonoSectionTable) * nsections);\n\n\tfile_offset = section_start + sizeof (MonoSectionTable) * nsections;\n\tvirtual_offset = VIRT_ALIGN;\n\timage_size = 0;\n\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t/* align offsets */\n\t\tfile_offset += FILE_ALIGN - 1;\n\t\tfile_offset &= ~(FILE_ALIGN - 1);\n\t\tvirtual_offset += VIRT_ALIGN - 1;\n\t\tvirtual_offset &= ~(VIRT_ALIGN - 1);\n\n\t\tassembly->sections [i].offset = file_offset;\n\t\tassembly->sections [i].rva = virtual_offset;\n\n\t\tfile_offset += assembly->sections [i].size;\n\t\tvirtual_offset += assembly->sections [i].size;\n\t\timage_size += (assembly->sections [i].size + VIRT_ALIGN - 1) & ~(VIRT_ALIGN - 1);\n\t}\n\n\tfile_offset += FILE_ALIGN - 1;\n\tfile_offset &= ~(FILE_ALIGN - 1);\n\n\timage_size += section_start + sizeof (MonoSectionTable) * nsections;\n\n\t/* back-patch info */\n\tmsdos = (MonoMSDOSHeader*)pefile->data;\n\tmsdos->pe_offset = GUINT32_FROM_LE (sizeof (MonoMSDOSHeader));\n\n\theader = (MonoDotNetHeader*)(pefile->data + header_start);\n\theader->pesig [0] = 'P';\n\theader->pesig [1] = 'E';\n\t\n\theader->coff.coff_machine = GUINT16_FROM_LE (assemblyb->machine);\n\theader->coff.coff_sections = GUINT16_FROM_LE (nsections);\n\theader->coff.coff_time = GUINT32_FROM_LE (time (NULL));\n\theader->coff.coff_opt_header_size = GUINT16_FROM_LE (sizeof (MonoDotNetHeader) - sizeof (MonoCOFFHeader) - 4);\n\tif (assemblyb->pekind == 1) {\n\t\t/* it's a dll */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x210e);\n\t} else {\n\t\t/* it's an exe */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x010e);\n\t}\n\n\tvirtual_base = 0x400000; /* FIXME: 0x10000000 if a DLL */\n\n\theader->pe.pe_magic = GUINT16_FROM_LE (0x10B);\n\theader->pe.pe_major = 6;\n\theader->pe.pe_minor = 0;\n\tsize = assembly->sections [MONO_SECTION_TEXT].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_code_size = GUINT32_FROM_LE(size);\n\tsize = assembly->sections [MONO_SECTION_RSRC].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_data_size = GUINT32_FROM_LE(size);\n\tg_assert (START_TEXT_RVA == assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_code_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_data_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\t/* pe_rva_entry_point always at the beginning of the text section */\n\theader->pe.pe_rva_entry_point = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\n\theader->nt.pe_image_base = GUINT32_FROM_LE (virtual_base);\n\theader->nt.pe_section_align = GUINT32_FROM_LE (VIRT_ALIGN);\n\theader->nt.pe_file_alignment = GUINT32_FROM_LE (FILE_ALIGN);\n\theader->nt.pe_os_major = GUINT16_FROM_LE (4);\n\theader->nt.pe_os_minor = GUINT16_FROM_LE (0);\n\theader->nt.pe_subsys_major = GUINT16_FROM_LE (4);\n\tsize = section_start;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->nt.pe_header_size = GUINT32_FROM_LE (size);\n\tsize = image_size;\n\tsize += VIRT_ALIGN - 1;\n\tsize &= ~(VIRT_ALIGN - 1);\n\theader->nt.pe_image_size = GUINT32_FROM_LE (size);\n\n\t/*\n\t// Translate the PEFileKind value to the value expected by the Windows loader\n\t*/\n\t{\n\t\tshort kind;\n\n\t\t/*\n\t\t// PEFileKinds.Dll == 1\n\t\t// PEFileKinds.ConsoleApplication == 2\n\t\t// PEFileKinds.WindowApplication == 3\n\t\t//\n\t\t// need to get:\n\t\t//     IMAGE_SUBSYSTEM_WINDOWS_GUI 2 // Image runs in the Windows GUI subsystem.\n                //     IMAGE_SUBSYSTEM_WINDOWS_CUI 3 // Image runs in the Windows character subsystem.\n\t\t*/\n\t\tif (assemblyb->pekind == 3)\n\t\t\tkind = 2;\n\t\telse\n\t\t\tkind = 3;\n\t\t\n\t\theader->nt.pe_subsys_required = GUINT16_FROM_LE (kind);\n\t}    \n\theader->nt.pe_stack_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_stack_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_heap_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_heap_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_loader_flags = GUINT32_FROM_LE (0);\n\theader->nt.pe_data_dir_count = GUINT32_FROM_LE (16);\n\n\t/* fill data directory entries */\n\n\theader->datadir.pe_resource_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].size);\n\theader->datadir.pe_resource_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\n\theader->datadir.pe_reloc_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].size);\n\theader->datadir.pe_reloc_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].rva);\n\n\theader->datadir.pe_cli_header.size = GUINT32_FROM_LE (72);\n\theader->datadir.pe_cli_header.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->cli_header_offset);\n\theader->datadir.pe_iat.size = GUINT32_FROM_LE (8);\n\theader->datadir.pe_iat.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\t/* patch entrypoint name */\n\tif (assemblyb->pekind == 1)\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorDllMain\", 12);\n\telse\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorExeMain\", 12);\n\t/* patch imported function RVA name */\n\trva = (guint32*)(assembly->code.data + assembly->iat_offset);\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset);\n\n\t/* the import table */\n\theader->datadir.pe_import_table.size = GUINT32_FROM_LE (79); /* FIXME: magic number? */\n\theader->datadir.pe_import_table.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->idt_offset);\n\t/* patch imported dll RVA name and other entries in the dir */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, name_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset + 14); /* 14 is hint+strlen+1 of func name */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_address_table_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_lookup_table));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->ilt_offset);\n\n\tp = (guchar*)(assembly->code.data + assembly->ilt_offset);\n\tvalue = (assembly->text_rva + assembly->imp_names_offset);\n\t*p++ = (value) & 0xff;\n\t*p++ = (value >> 8) & (0xff);\n\t*p++ = (value >> 16) & (0xff);\n\t*p++ = (value >> 24) & (0xff);\n\n\t/* the CLI header info */\n\tcli_header = (MonoCLIHeader*)(assembly->code.data + assembly->cli_header_offset);\n\tcli_header->ch_size = GUINT32_FROM_LE (72);\n\tcli_header->ch_runtime_major = GUINT16_FROM_LE (2);\n\tif (mono_framework_version () > 1)\n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (5);\n\telse \n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (0);\n\tcli_header->ch_flags = GUINT32_FROM_LE (assemblyb->pe_kind);\n\tif (assemblyb->entry_point) {\n\t\tguint32 table_idx = 0;\n\t\tif (!strcmp (assemblyb->entry_point->object.vtable->klass->name, \"MethodBuilder\")) {\n\t\t\tMonoReflectionMethodBuilder *methodb = (MonoReflectionMethodBuilder*)assemblyb->entry_point;\n\t\t\ttable_idx = methodb->table_idx;\n\t\t} else {\n\t\t\ttable_idx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, assemblyb->entry_point->method));\n\t\t}\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (table_idx | MONO_TOKEN_METHOD_DEF);\n\t} else {\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (0);\n\t}\n\t/* The embedded managed resources */\n\ttext_offset = assembly->text_rva + assembly->code.index;\n\tcli_header->ch_resources.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_resources.size = GUINT32_FROM_LE (assembly->resources.index);\n\ttext_offset += assembly->resources.index;\n\tcli_header->ch_metadata.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_metadata.size = GUINT32_FROM_LE (assembly->meta_size);\n\ttext_offset += assembly->meta_size;\n\tif (assembly->strong_name_size) {\n\t\tcli_header->ch_strong_name.rva = GUINT32_FROM_LE (text_offset);\n\t\tcli_header->ch_strong_name.size = GUINT32_FROM_LE (assembly->strong_name_size);\n\t\ttext_offset += assembly->strong_name_size;\n\t}\n\n\t/* write the section tables and section content */\n\tsection = (MonoSectionTable*)(pefile->data + section_start);\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tstatic const char section_names [][7] = {\n\t\t\t\".text\", \".rsrc\", \".reloc\"\n\t\t};\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\tstrcpy (section->st_name, section_names [i]);\n\t\t/*g_print (\"output section %s (%d), size: %d\\n\", section->st_name, i, assembly->sections [i].size);*/\n\t\tsection->st_virtual_address = GUINT32_FROM_LE (assembly->sections [i].rva);\n\t\tsection->st_virtual_size = GUINT32_FROM_LE (assembly->sections [i].size);\n\t\tsection->st_raw_data_size = GUINT32_FROM_LE (GUINT32_TO_LE (section->st_virtual_size) + (FILE_ALIGN - 1));\n\t\tsection->st_raw_data_size &= GUINT32_FROM_LE (~(FILE_ALIGN - 1));\n\t\tsection->st_raw_data_ptr = GUINT32_FROM_LE (assembly->sections [i].offset);\n\t\tsection->st_flags = GUINT32_FROM_LE (assembly->sections [i].attrs);\n\t\tsection ++;\n\t}\n\t\n\tchecked_write_file (file, pefile->data, pefile->index);\n\t\n\tmono_dynamic_stream_reset (pefile);\n\t\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t\n\t\tif (SetFilePointer (file, assembly->sections [i].offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\t\t\n\t\tswitch (i) {\n\t\tcase MONO_SECTION_TEXT:\n\t\t\t/* patch entry point */\n\t\t\tp = (guchar*)(assembly->code.data + 2);\n\t\t\tvalue = (virtual_base + assembly->text_rva + assembly->iat_offset);\n\t\t\t*p++ = (value) & 0xff;\n\t\t\t*p++ = (value >> 8) & 0xff;\n\t\t\t*p++ = (value >> 16) & 0xff;\n\t\t\t*p++ = (value >> 24) & 0xff;\n\t\t\n\t\t\tchecked_write_file (file, assembly->code.data, assembly->code.index);\n\t\t\tchecked_write_file (file, assembly->resources.data, assembly->resources.index);\n\t\t\tchecked_write_file (file, assembly->image.raw_metadata, assembly->meta_size);\n\t\t\tchecked_write_file (file, assembly->strong_name, assembly->strong_name_size);\n\t\t\t\t\n\n\t\t\tg_free (assembly->image.raw_metadata);\n\t\t\tbreak;\n\t\tcase MONO_SECTION_RELOC: {\n\t\t\tstruct {\n\t\t\t\tguint32 page_rva;\n\t\t\t\tguint32 block_size;\n\t\t\t\tguint16 type_and_offset;\n\t\t\t\tguint16 term;\n\t\t\t} reloc;\n\t\t\t\n\t\t\tg_assert (sizeof (reloc) == 12);\n\t\t\t\n\t\t\treloc.page_rva = GUINT32_FROM_LE (assembly->text_rva);\n\t\t\treloc.block_size = GUINT32_FROM_LE (12);\n\t\t\t\n\t\t\t/* \n\t\t\t * the entrypoint is always at the start of the text section \n\t\t\t * 3 is IMAGE_REL_BASED_HIGHLOW\n\t\t\t * 2 is patch_size_rva - text_rva\n\t\t\t */\n\t\t\treloc.type_and_offset = GUINT16_FROM_LE ((3 << 12) + (2));\n\t\t\treloc.term = 0;\n\t\t\t\n\t\t\tchecked_write_file (file, &reloc, sizeof (reloc));\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_SECTION_RSRC:\n\t\t\tif (assembly->win32_res) {\n\n\t\t\t\t/* Fixup the offsets in the IMAGE_RESOURCE_DATA_ENTRY structures */\n\t\t\t\tfixup_resource_directory (assembly->win32_res, assembly->win32_res, assembly->sections [i].rva);\n\t\t\t\tchecked_write_file (file, assembly->win32_res, assembly->win32_res_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\t\n\t/* check that the file is properly padded */\n\tif (SetFilePointer (file, file_offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\tif (! SetEndOfFile (file))\n\t\tg_error (\"SetEndOfFile returned %d\\n\", GetLastError ());\n\t\n\tmono_dynamic_stream_reset (&assembly->code);\n\tmono_dynamic_stream_reset (&assembly->us);\n\tmono_dynamic_stream_reset (&assembly->blob);\n\tmono_dynamic_stream_reset (&assembly->guid);\n\tmono_dynamic_stream_reset (&assembly->sheap);\n\n\tg_hash_table_foreach (assembly->blob_cache, (GHFunc)g_free, NULL);\n\tg_hash_table_destroy (assembly->blob_cache);\n\tassembly->blob_cache = NULL;\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tg_assert_not_reached ();\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tchar *name;\n\tMonoImage *image;\n\tMonoImageOpenStatus status;\n\tMonoDynamicAssembly *assembly;\n\tguint32 module_count;\n\tMonoImage **new_modules;\n\tgboolean *new_modules_loaded;\n\t\n\tname = mono_string_to_utf8 (fileName);\n\n\timage = mono_image_open (name, &status);\n\tif (!image) {\n\t\tMonoException *exc;\n\t\tif (status == MONO_IMAGE_ERROR_ERRNO)\n\t\t\texc = mono_get_exception_file_not_found (fileName);\n\t\telse\n\t\t\texc = mono_get_exception_bad_image_format (name);\n\t\tg_free (name);\n\t\tmono_raise_exception (exc);\n\t}\n\n\tg_free (name);\n\n\tassembly = ab->dynamic_assembly;\n\timage->assembly = (MonoAssembly*)assembly;\n\n\tmodule_count = image->assembly->image->module_count;\n\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\tnew_modules_loaded = g_new0 (gboolean, module_count + 1);\n\n\tif (image->assembly->image->modules)\n\t\tmemcpy (new_modules, image->assembly->image->modules, module_count * sizeof (MonoImage *));\n\tif (image->assembly->image->modules_loaded)\n\t\tmemcpy (new_modules_loaded, image->assembly->image->modules_loaded, module_count * sizeof (gboolean));\n\tnew_modules [module_count] = image;\n\tnew_modules_loaded [module_count] = TRUE;\n\tmono_image_addref (image);\n\n\tg_free (image->assembly->image->modules);\n\timage->assembly->image->modules = new_modules;\n\timage->assembly->image->modules_loaded = new_modules_loaded;\n\timage->assembly->image->module_count ++;\n\n\tmono_assembly_load_references (image, &status);\n\tif (status) {\n\t\tmono_image_close (image);\n\t\tmono_raise_exception (mono_get_exception_file_not_found (fileName));\n\t}\n\n\treturn mono_module_get_object (mono_domain_get (), image);\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/*\n * We need to return always the same object for MethodInfo, FieldInfo etc..\n * but we need to consider the reflected type.\n * type uses a different hash, since it uses custom hash/equal functions.\n */\n\ntypedef struct {\n\tgpointer item;\n\tMonoClass *refclass;\n} ReflectedEntry;\n\nstatic gboolean\nreflected_equal (gconstpointer a, gconstpointer b) {\n\tconst ReflectedEntry *ea = a;\n\tconst ReflectedEntry *eb = b;\n\n\treturn (ea->item == eb->item) && (ea->refclass == eb->refclass);\n}\n\nstatic guint\nreflected_hash (gconstpointer a) {\n\tconst ReflectedEntry *ea = a;\n\treturn mono_aligned_addr_hash (ea->item);\n}\n\n#define CHECK_OBJECT(t,p,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n\t\tReflectedEntry e; \t\\\n\t\te.item = (p);\t\\\n\t\te.refclass = (k);\t\\\n\t\tmono_domain_lock (domain);\t\\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n\t\tif ((_obj = mono_g_hash_table_lookup (domain->refobject_hash, &e))) {\t\\\n\t\t\tmono_domain_unlock (domain);\t\\\n\t\t\treturn _obj;\t\\\n\t\t}\t\\\n        mono_domain_unlock (domain); \\\n\t} while (0)\n\n#ifdef HAVE_BOEHM_GC\n/* ReflectedEntry doesn't need to be GC tracked */\n#define ALLOC_REFENTRY g_new0 (ReflectedEntry, 1)\n#define FREE_REFENTRY(entry) g_free ((entry))\n#define REFENTRY_REQUIRES_CLEANUP\n#else\n#define ALLOC_REFENTRY mono_mempool_alloc (domain->mp, sizeof (ReflectedEntry))\n/* FIXME: */\n#define FREE_REFENTRY(entry)\n#endif\n\n#define CACHE_OBJECT(t,p,o,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n        ReflectedEntry pe; \\\n        pe.item = (p); \\\n        pe.refclass = (k); \\\n        mono_domain_lock (domain); \\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n        _obj = mono_g_hash_table_lookup (domain->refobject_hash, &pe); \\\n        if (!_obj) { \\\n\t\t    ReflectedEntry *e = ALLOC_REFENTRY; \t\\\n\t\t    e->item = (p);\t\\\n\t\t    e->refclass = (k);\t\\\n\t\t    mono_g_hash_table_insert (domain->refobject_hash, e,o);\t\\\n            _obj = o; \\\n        } \\\n\t\tmono_domain_unlock (domain);\t\\\n        return _obj; \\\n\t} while (0)\n\nstatic void\nclear_cached_object (MonoDomain *domain, gpointer o, MonoClass *klass)\n{\n\tmono_domain_lock (domain);\n\tif (domain->refobject_hash) {\n        ReflectedEntry pe;\n\t\tgpointer orig_pe, orig_value;\n\n\t\tpe.item = o;\n\t\tpe.refclass = klass;\n\t\tif (mono_g_hash_table_lookup_extended (domain->refobject_hash, &pe, &orig_pe, &orig_value)) {\n\t\t\tmono_g_hash_table_remove (domain->refobject_hash, &pe);\n\t\t\tFREE_REFENTRY (orig_pe);\n\t\t}\n\t}\n\tmono_domain_unlock (domain);\n}\n\n#ifdef REFENTRY_REQUIRES_CLEANUP\nstatic void\ncleanup_refobject_hash (gpointer key, gpointer value, gpointer user_data)\n{\n\tFREE_REFENTRY (key);\n}\n#endif\n\nvoid\nmono_reflection_cleanup_domain (MonoDomain *domain)\n{\n\tif (domain->refobject_hash) {\n/*let's avoid scanning the whole hashtable if not needed*/\n#ifdef REFENTRY_REQUIRES_CLEANUP\n\t\tmono_g_hash_table_foreach (domain->refobject_hash, cleanup_refobject_hash, NULL);\n#endif\n\t\tmono_g_hash_table_destroy (domain->refobject_hash);\n\t\tdomain->refobject_hash = NULL;\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic gpointer\nregister_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly)\n{\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\nstatic gpointer\nregister_module (MonoDomain *domain, MonoReflectionModuleBuilder *res, MonoDynamicImage *module)\n{\n\tCACHE_OBJECT (MonoReflectionModuleBuilder *, module, res, NULL);\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\tMonoReflectionAssemblyBuilder *ab = moduleb->assemblyb;\n\tif (!image) {\n\t\tMonoError error;\n\t\tint module_count;\n\t\tMonoImage **new_modules;\n\t\tMonoImage *ass;\n\t\tchar *name, *fqname;\n\t\t/*\n\t\t * FIXME: we already created an image in mono_image_basic_init (), but\n\t\t * we don't know which module it belongs to, since that is only \n\t\t * determined at assembly save time.\n\t\t */\n\t\t/*image = (MonoDynamicImage*)ab->dynamic_assembly->assembly.image; */\n\t\tname = mono_string_to_utf8 (ab->name);\n\t\tfqname = mono_string_to_utf8_checked (moduleb->module.fqname, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tg_free (name);\n\t\t\tmono_error_raise_exception (&error);\n\t\t}\n\t\timage = create_dynamic_mono_image (ab->dynamic_assembly, name, fqname);\n\n\t\tmoduleb->module.image = &image->image;\n\t\tmoduleb->dynamic_image = image;\n\t\tregister_module (mono_object_domain (moduleb), moduleb, image);\n\n\t\t/* register the module with the assembly */\n\t\tass = ab->dynamic_assembly->assembly.image;\n\t\tmodule_count = ass->module_count;\n\t\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\n\t\tif (ass->modules)\n\t\t\tmemcpy (new_modules, ass->modules, module_count * sizeof (MonoImage *));\n\t\tnew_modules [module_count] = &image->image;\n\t\tmono_image_addref (&image->image);\n\n\t\tg_free (ass->modules);\n\t\tass->modules = new_modules;\n\t\tass->module_count ++;\n\t}\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\n\tg_assert (type->type);\n\timage->wrappers_type = mono_class_from_mono_type (type->type);\n}\n\n#endif\n\n/*\n * mono_assembly_get_object:\n * @domain: an app domain\n * @assembly: an assembly\n *\n * Return an System.Reflection.Assembly object representing the MonoAssembly @assembly.\n */\nMonoReflectionAssembly*\nmono_assembly_get_object (MonoDomain *domain, MonoAssembly *assembly)\n{\n\tstatic MonoClass *System_Reflection_Assembly;\n\tMonoReflectionAssembly *res;\n\t\n\tCHECK_OBJECT (MonoReflectionAssembly *, assembly, NULL);\n\tif (!System_Reflection_Assembly)\n\t\tSystem_Reflection_Assembly = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Assembly\");\n\tres = (MonoReflectionAssembly *)mono_object_new (domain, System_Reflection_Assembly);\n\tres->assembly = assembly;\n\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\n\n\nMonoReflectionModule*   \nmono_module_get_object   (MonoDomain *domain, MonoImage *image)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tchar* basename;\n\t\n\tCHECK_OBJECT (MonoReflectionModule *, image, NULL);\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\tres->image = image;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, image->name));\n\tbasename = g_path_get_basename (image->name);\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, basename));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, image->module_name));\n\t\n\tg_free (basename);\n\n\tif (image->assembly->image == image) {\n\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULE, 1);\n\t} else {\n\t\tint i;\n\t\tres->token = 0;\n\t\tif (image->assembly->image->modules) {\n\t\t\tfor (i = 0; i < image->assembly->image->module_count; i++) {\n\t\t\t\tif (image->assembly->image->modules [i] == image)\n\t\t\t\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULEREF, i + 1);\n\t\t\t}\n\t\t\tg_assert (res->token);\n\t\t}\n\t}\n\n\tCACHE_OBJECT (MonoReflectionModule *, image, res, NULL);\n}\n\nMonoReflectionModule*   \nmono_module_file_get_object (MonoDomain *domain, MonoImage *image, int table_index)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tMonoTableInfo *table;\n\tguint32 cols [MONO_FILE_SIZE];\n\tconst char *name;\n\tguint32 i, name_idx;\n\tconst char *val;\n\t\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tg_assert (table_index < table->rows);\n\tmono_metadata_decode_row (table, table_index, cols, MONO_FILE_SIZE);\n\n\tres->image = NULL;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\tname = mono_metadata_string_heap (image, cols [MONO_FILE_NAME]);\n\n\t/* Check whenever the row has a corresponding row in the moduleref table */\n\ttable = &image->tables [MONO_TABLE_MODULEREF];\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tname_idx = mono_metadata_decode_row_col (table, i, MONO_MODULEREF_NAME);\n\t\tval = mono_metadata_string_heap (image, name_idx);\n\t\tif (strcmp (val, name) == 0)\n\t\t\tres->image = image->modules [i];\n\t}\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, name));\n\tres->is_resource = cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA;\n\tres->token = mono_metadata_make_token (MONO_TABLE_FILE, table_index + 1);\n\n\treturn res;\n}\n\nstatic gboolean\nmymono_metadata_type_equal (MonoType *t1, MonoType *t2)\n{\n\tif ((t1->type != t2->type) ||\n\t    (t1->byref != t2->byref))\n\t\treturn FALSE;\n\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TRUE;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn t1->data.klass == t2->data.klass;\n\tcase MONO_TYPE_PTR:\n\t\treturn mymono_metadata_type_equal (t1->data.type, t2->data.type);\n\tcase MONO_TYPE_ARRAY:\n\t\tif (t1->data.array->rank != t2->data.array->rank)\n\t\t\treturn FALSE;\n\t\treturn t1->data.array->eklass == t2->data.array->eklass;\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *i1 = t1->data.generic_class->context.class_inst;\n\t\tMonoGenericInst *i2 = t2->data.generic_class->context.class_inst;\n\t\tif (i1->type_argc != i2->type_argc)\n\t\t\treturn FALSE;\n\t\tif (!mono_metadata_type_equal (&t1->data.generic_class->container_class->byval_arg,\n\t\t\t\t\t       &t2->data.generic_class->container_class->byval_arg))\n\t\t\treturn FALSE;\n\t\t/* FIXME: we should probably just compare the instance pointers directly.  */\n\t\tfor (i = 0; i < i1->type_argc; ++i) {\n\t\t\tif (!mono_metadata_type_equal (i1->type_argv [i], i2->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn t1->data.generic_param == t2->data.generic_param;\n\tdefault:\n\t\tg_error (\"implement type compare for %0x!\", t1->type);\n\t\treturn FALSE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic guint\nmymono_metadata_type_hash (MonoType *t1)\n{\n\tguint hash;\n\n\thash = t1->type;\n\n\thash |= t1->byref << 6; /* do not collide with t1->type values */\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\t/* check if the distribution is good enough */\n\t\treturn ((hash << 5) - hash) ^ g_str_hash (t1->data.klass->name);\n\tcase MONO_TYPE_PTR:\n\t\treturn ((hash << 5) - hash) ^ mymono_metadata_type_hash (t1->data.type);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *inst = t1->data.generic_class->context.class_inst;\n\t\thash += g_str_hash (t1->data.generic_class->container_class->name);\n\t\thash *= 13;\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\thash += mymono_metadata_type_hash (inst->type_argv [i]);\n\t\t\thash *= 13;\n\t\t}\n\t\treturn hash;\n\t}\n\t}\n\treturn hash;\n}\n\nstatic MonoReflectionGenericClass*\nmono_generic_class_get_object (MonoDomain *domain, MonoType *geninst)\n{\n\tstatic MonoClass *System_Reflection_MonoGenericClass;\n\tMonoReflectionGenericClass *res;\n\tMonoClass *klass, *gklass;\n\tMonoGenericInst *ginst;\n\tMonoArray *type_args;\n\tint i;\n\n\tif (!System_Reflection_MonoGenericClass) {\n\t\tSystem_Reflection_MonoGenericClass = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"MonoGenericClass\");\n\t\tg_assert (System_Reflection_MonoGenericClass);\n\t}\n\n\tklass = mono_class_from_mono_type (geninst);\n\tgklass = klass->generic_class->container_class;\n\n\tmono_class_init (klass);\n\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionGenericClass *) mono_gc_alloc_pinned_obj (mono_class_vtable (domain, System_Reflection_MonoGenericClass), mono_class_instance_size (System_Reflection_MonoGenericClass));\n#else\n\tres = (MonoReflectionGenericClass *) mono_object_new (domain, System_Reflection_MonoGenericClass);\n#endif\n\n\tres->type.type = geninst;\n\tg_assert (gklass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)gklass->reflection_info)->vtable->klass->name, \"TypeBuilder\"));\n\tMONO_OBJECT_SETREF (res, generic_type, gklass->reflection_info);\n\n\tginst = klass->generic_class->context.class_inst;\n\ttype_args = mono_array_new (domain, mono_defaults.systemtype_class, ginst->type_argc);\n\tfor (i = 0; i < ginst->type_argc; ++i)\n\t\tmono_array_setref (type_args, i, mono_type_get_object (domain, ginst->type_argv [i]));\n\tMONO_OBJECT_SETREF (res, type_arguments, type_args);\n\n\treturn res;\n}\n\nstatic gboolean\nverify_safe_for_managed_space (MonoType *type)\n{\n\tswitch (type->type) {\n#ifdef DEBUG_HARDER\n\tcase MONO_TYPE_ARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.array->eklass->byval_arg);\n\tcase MONO_TYPE_PTR:\n\t\treturn verify_safe_for_managed_space (type->data.type);\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.klass->byval_arg);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoGenericInst *inst = type->data.generic_class->inst;\n\t\tint i;\n\t\tif (!inst->is_open)\n\t\t\tbreak;\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tif (!verify_safe_for_managed_space (inst->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\tbreak;\n\t}\n#endif\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn TRUE;\n\t}\n\treturn TRUE;\n}\n\n/*\n * mono_type_get_object:\n * @domain: an app domain\n * @type: a type\n *\n * Return an System.MonoType object representing the type @type.\n */\nMonoReflectionType*\nmono_type_get_object (MonoDomain *domain, MonoType *type)\n{\n\tMonoReflectionType *res;\n\tMonoClass *klass = mono_class_from_mono_type (type);\n\n\t/*we must avoid using @type as it might have come\n\t * from a mono_metadata_type_dup and the caller\n\t * expects that is can be freed.\n\t * Using the right type from \n\t */\n\ttype = klass->byval_arg.byref == type->byref ? &klass->byval_arg : &klass->this_arg;\n\n\t/* void is very common */\n\tif (type->type == MONO_TYPE_VOID && domain->typeof_void)\n\t\treturn (MonoReflectionType*)domain->typeof_void;\n\n\t/*\n\t * If the vtable of the given class was already created, we can use\n\t * the MonoType from there and avoid all locking and hash table lookups.\n\t * \n\t * We cannot do this for TypeBuilders as mono_reflection_create_runtime_class expects\n\t * that the resulting object is different.   \n\t */\n\tif (type == &klass->byval_arg && !klass->image->dynamic) {\n\t\tMonoVTable *vtable = mono_class_try_get_vtable (domain, klass);\n\t\tif (vtable && vtable->type)\n\t\t\treturn vtable->type;\n\t}\n\n\tmono_loader_lock (); /*FIXME mono_class_init and mono_class_vtable acquire it*/\n\tmono_domain_lock (domain);\n\tif (!domain->type_hash)\n\t\tdomain->type_hash = mono_g_hash_table_new_type ((GHashFunc)mymono_metadata_type_hash, \n\t\t\t\t(GCompareFunc)mymono_metadata_type_equal, MONO_HASH_VALUE_GC);\n\tif ((res = mono_g_hash_table_lookup (domain->type_hash, type))) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* Create a MonoGenericClass object for instantiations of not finished TypeBuilders */\n\tif ((type->type == MONO_TYPE_GENERICINST) && type->data.generic_class->is_dynamic && !type->data.generic_class->container_class->wastypebuilder) {\n\t\tres = (MonoReflectionType *)mono_generic_class_get_object (domain, type);\n\t\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tif (!verify_safe_for_managed_space (type)) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"This type cannot be propagated to managed space\"));\n\t}\n\n\tif (klass->reflection_info && !klass->wastypebuilder) {\n\t\tgboolean is_type_done = TRUE;\n\t\t/* Generic parameters have reflection_info set but they are not finished together with their enclosing type.\n\t\t * We must ensure that once a type is finished we don't return a GenericTypeParameterBuilder.\n\t\t * We can't simply close the types as this will interfere with other parts of the generics machinery.\n\t\t*/\n\t\tif (klass->byval_arg.type == MONO_TYPE_MVAR || klass->byval_arg.type == MONO_TYPE_VAR) {\n\t\t\tMonoGenericParam *gparam = klass->byval_arg.data.generic_param;\n\n\t\t\tif (gparam->owner && gparam->owner->is_method) {\n\t\t\t\tMonoMethod *method = gparam->owner->owner.method;\n\t\t\t\tif (method && mono_class_get_generic_type_definition (method->klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t} else if (gparam->owner && !gparam->owner->is_method) {\n\t\t\t\tMonoClass *klass = gparam->owner->owner.klass;\n\t\t\t\tif (klass && mono_class_get_generic_type_definition (klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t}\n\t\t} \n\n\t\t/* g_assert_not_reached (); */\n\t\t/* should this be considered an error condition? */\n\t\tif (is_type_done && !type->byref) {\n\t\t\tmono_domain_unlock (domain);\n\t\t\tmono_loader_unlock ();\n\t\t\treturn klass->reflection_info;\n\t\t}\n\t}\n\t// FIXME: Get rid of this, do it in the icalls for Type\n\tmono_class_init (klass);\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionType *)mono_gc_alloc_pinned_obj (mono_class_vtable (domain, mono_defaults.monotype_class), mono_class_instance_size (mono_defaults.monotype_class));\n#else\n\tres = (MonoReflectionType *)mono_object_new (domain, mono_defaults.monotype_class);\n#endif\n\tres->type = type;\n\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\n\tif (type->type == MONO_TYPE_VOID)\n\t\tdomain->typeof_void = (MonoObject*)res;\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\treturn res;\n}\n\n/*\n * mono_method_get_object:\n * @domain: an app domain\n * @method: a method\n * @refclass: the reflected type (can be NULL)\n *\n * Return an System.Reflection.MonoMethod object representing the method @method.\n */\nMonoReflectionMethod*\nmono_method_get_object (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\t/*\n\t * We use the same C representation for methods and constructors, but the type \n\t * name in C# is different.\n\t */\n\tstatic MonoClass *System_Reflection_MonoMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoCMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericCMethod = NULL;\n\tMonoClass *klass;\n\tMonoReflectionMethod *ret;\n\n\tif (method->is_inflated) {\n\t\tMonoReflectionGenericMethod *gret;\n\n\t\trefclass = method->klass;\n\t\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\t\tif ((*method->name == '.') && (!strcmp (method->name, \".ctor\") || !strcmp (method->name, \".cctor\"))) {\n\t\t\tif (!System_Reflection_MonoGenericCMethod)\n\t\t\t\tSystem_Reflection_MonoGenericCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericCMethod\");\n\t\t\tklass = System_Reflection_MonoGenericCMethod;\n\t\t} else {\n\t\t\tif (!System_Reflection_MonoGenericMethod)\n\t\t\t\tSystem_Reflection_MonoGenericMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericMethod\");\n\t\t\tklass = System_Reflection_MonoGenericMethod;\n\t\t}\n\t\tgret = (MonoReflectionGenericMethod*)mono_object_new (domain, klass);\n\t\tgret->method.method = method;\n\t\tMONO_OBJECT_SETREF (gret, method.name, mono_string_new (domain, method->name));\n\t\tMONO_OBJECT_SETREF (gret, method.reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\t\tCACHE_OBJECT (MonoReflectionMethod *, method, (MonoReflectionMethod*)gret, refclass);\n\t}\n\n\tif (!refclass)\n\t\trefclass = method->klass;\n\n\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\tif (*method->name == '.' && (strcmp (method->name, \".ctor\") == 0 || strcmp (method->name, \".cctor\") == 0)) {\n\t\tif (!System_Reflection_MonoCMethod)\n\t\t\tSystem_Reflection_MonoCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoCMethod\");\n\t\tklass = System_Reflection_MonoCMethod;\n\t}\n\telse {\n\t\tif (!System_Reflection_MonoMethod)\n\t\t\tSystem_Reflection_MonoMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoMethod\");\n\t\tklass = System_Reflection_MonoMethod;\n\t}\n\tret = (MonoReflectionMethod*)mono_object_new (domain, klass);\n\tret->method = method;\n\tMONO_OBJECT_SETREF (ret, reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\tCACHE_OBJECT (MonoReflectionMethod *, method, ret, refclass);\n}\n\n/*\n * mono_method_clear_object:\n *\n *   Clear the cached reflection objects for the dynamic method METHOD.\n */\nvoid\nmono_method_clear_object (MonoDomain *domain, MonoMethod *method)\n{\n\tMonoClass *klass;\n\tg_assert (method->dynamic);\n\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, method, klass);\n\t\tklass = klass->parent;\n\t}\n\t/* Added by mono_param_get_objects () */\n\tclear_cached_object (domain, &(method->signature), NULL);\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, &(method->signature), klass);\n\t\tklass = klass->parent;\n\t}\n}\n\n/*\n * mono_field_get_object:\n * @domain: an app domain\n * @klass: a type\n * @field: a field\n *\n * Return an System.Reflection.MonoField object representing the field @field\n * in class @klass.\n */\nMonoReflectionField*\nmono_field_get_object (MonoDomain *domain, MonoClass *klass, MonoClassField *field)\n{\n\tMonoReflectionField *res;\n\tstatic MonoClass *monofield_klass;\n\n\tCHECK_OBJECT (MonoReflectionField *, field, klass);\n\tif (!monofield_klass)\n\t\tmonofield_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoField\");\n\tres = (MonoReflectionField *)mono_object_new (domain, monofield_klass);\n\tres->klass = klass;\n\tres->field = field;\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, mono_field_get_name (field)));\n\tif (is_field_on_inst (field))\n\t\tres->attrs = get_field_on_inst_generic_type (field)->attrs;\n\telse\n\t\tres->attrs = field->type->attrs;\n\tMONO_OBJECT_SETREF (res, type, mono_type_get_object (domain, field->type));\n\tCACHE_OBJECT (MonoReflectionField *, field, res, klass);\n}\n\n/*\n * mono_property_get_object:\n * @domain: an app domain\n * @klass: a type\n * @property: a property\n *\n * Return an System.Reflection.MonoProperty object representing the property @property\n * in class @klass.\n */\nMonoReflectionProperty*\nmono_property_get_object (MonoDomain *domain, MonoClass *klass, MonoProperty *property)\n{\n\tMonoReflectionProperty *res;\n\tstatic MonoClass *monoproperty_klass;\n\n\tCHECK_OBJECT (MonoReflectionProperty *, property, klass);\n\tif (!monoproperty_klass)\n\t\tmonoproperty_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoProperty\");\n\tres = (MonoReflectionProperty *)mono_object_new (domain, monoproperty_klass);\n\tres->klass = klass;\n\tres->property = property;\n\tCACHE_OBJECT (MonoReflectionProperty *, property, res, klass);\n}\n\n/*\n * mono_event_get_object:\n * @domain: an app domain\n * @klass: a type\n * @event: a event\n *\n * Return an System.Reflection.MonoEvent object representing the event @event\n * in class @klass.\n */\nMonoReflectionEvent*\nmono_event_get_object (MonoDomain *domain, MonoClass *klass, MonoEvent *event)\n{\n\tMonoReflectionEvent *res;\n\tMonoReflectionMonoEvent *mono_event;\n\tstatic MonoClass *monoevent_klass;\n\n\tCHECK_OBJECT (MonoReflectionEvent *, event, klass);\n\tif (!monoevent_klass)\n\t\tmonoevent_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoEvent\");\n\tmono_event = (MonoReflectionMonoEvent *)mono_object_new (domain, monoevent_klass);\n\tmono_event->klass = klass;\n\tmono_event->event = event;\n\tres = (MonoReflectionEvent*)mono_event;\n\tCACHE_OBJECT (MonoReflectionEvent *, event, res, klass);\n}\n\n/**\n * mono_get_reflection_missing_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.Reflection.Missing.Value singleton object\n * (of type System.Reflection.Missing).\n *\n * Used as the value for ParameterInfo.DefaultValue when Optional\n * is present\n */\nstatic MonoObject *\nmono_get_reflection_missing_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *missing_value_field = NULL;\n\t\n\tif (!missing_value_field) {\n\t\tMonoClass *missing_klass;\n\t\tmissing_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"Missing\");\n\t\tmono_class_init (missing_klass);\n\t\tmissing_value_field = mono_class_get_field_from_name (missing_klass, \"Value\");\n\t\tg_assert (missing_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, missing_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic MonoObject*\nget_dbnull (MonoDomain *domain, MonoObject **dbnull)\n{\n\tif (!*dbnull)\n\t\t*dbnull = mono_get_dbnull_object (domain);\n\treturn *dbnull;\n}\n\nstatic MonoObject*\nget_reflection_missing (MonoDomain *domain, MonoObject **reflection_missing)\n{\n\tif (!*reflection_missing)\n\t\t*reflection_missing = mono_get_reflection_missing_object (domain);\n\treturn *reflection_missing;\n}\n\n/*\n * mono_param_get_objects:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.ParameterInfo array object representing the parameters\n * in the method @method.\n */\nMonoArray*\nmono_param_get_objects_internal (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\tstatic MonoClass *System_Reflection_ParameterInfo;\n\tstatic MonoClass *System_Reflection_ParameterInfo_array;\n\tMonoArray *res = NULL;\n\tMonoReflectionMethod *member = NULL;\n\tMonoReflectionParameter *param = NULL;\n\tchar **names, **blobs = NULL;\n\tguint32 *types = NULL;\n\tMonoType *type = NULL;\n\tMonoObject *dbnull = NULL;\n\tMonoObject *missing = NULL;\n\tMonoMarshalSpec **mspecs;\n\tMonoMethodSignature *sig;\n\tMonoVTable *pinfo_vtable;\n\tint i;\n\n\tif (!System_Reflection_ParameterInfo_array) {\n\t\tMonoClass *klass;\n\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ParameterInfo\");\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo = klass; \n\t\n\t\tklass = mono_array_class_get (klass, 1);\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo_array = klass;\n\t}\n\t\n\tif (!mono_method_signature (method)->param_count)\n\t\treturn mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), 0);\n\n\t/* Note: the cache is based on the address of the signature into the method\n\t * since we already cache MethodInfos with the method as keys.\n\t */\n\tCHECK_OBJECT (MonoArray*, &(method->signature), refclass);\n\n\tsig = mono_method_signature (method);\n\tmember = mono_method_get_object (domain, method, refclass);\n\tnames = g_new (char *, sig->param_count);\n\tmono_method_get_param_names (method, (const char **) names);\n\n\tmspecs = g_new (MonoMarshalSpec*, sig->param_count + 1);\n\tmono_method_get_marshal_info (method, mspecs);\n\n\tres = mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), sig->param_count);\n\tpinfo_vtable = mono_class_vtable (domain, System_Reflection_ParameterInfo);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tparam = (MonoReflectionParameter *)mono_object_new_specific (pinfo_vtable);\n\t\tMONO_OBJECT_SETREF (param, ClassImpl, mono_type_get_object (domain, sig->params [i]));\n\t\tMONO_OBJECT_SETREF (param, MemberImpl, (MonoObject*)member);\n\t\tMONO_OBJECT_SETREF (param, NameImpl, mono_string_new (domain, names [i]));\n\t\tparam->PositionImpl = i;\n\t\tparam->AttrsImpl = sig->params [i]->attrs;\n\n\t\tif (!(param->AttrsImpl & PARAM_ATTRIBUTE_HAS_DEFAULT)) {\n\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\telse\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t} else {\n\n\t\t\tif (!blobs) {\n\t\t\t\tblobs = g_new0 (char *, sig->param_count);\n\t\t\t\ttypes = g_new0 (guint32, sig->param_count);\n\t\t\t\tget_default_param_value_blobs (method, blobs, types); \n\t\t\t}\n\n\t\t\t/* Build MonoType for the type from the Constant Table */\n\t\t\tif (!type)\n\t\t\t\ttype = g_new0 (MonoType, 1);\n\t\t\ttype->type = types [i];\n\t\t\ttype->data.klass = NULL;\n\t\t\tif (types [i] == MONO_TYPE_CLASS)\n\t\t\t\ttype->data.klass = mono_defaults.object_class;\n\t\t\telse if ((sig->params [i]->type == MONO_TYPE_VALUETYPE) && sig->params [i]->data.klass->enumtype) {\n\t\t\t\t/* For enums, types [i] contains the base type */\n\n\t\t\t\t\ttype->type = MONO_TYPE_VALUETYPE;\n\t\t\t\t\ttype->data.klass = mono_class_from_mono_type (sig->params [i]);\n\t\t\t} else\n\t\t\t\ttype->data.klass = mono_class_from_mono_type (type);\n\n\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, mono_get_object_from_blob (domain, type, blobs [i]));\n\n\t\t\t/* Type in the Constant table is MONO_TYPE_CLASS for nulls */\n\t\t\tif (types [i] != MONO_TYPE_CLASS && !param->DefaultValueImpl) {\n\t\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\t\telse\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif (mspecs [i + 1])\n\t\t\tMONO_OBJECT_SETREF (param, MarshalAsImpl, (MonoObject*)mono_reflection_marshal_from_marshal_spec (domain, method->klass, mspecs [i + 1]));\n\t\t\n\t\tmono_array_setref (res, i, param);\n\t}\n\tg_free (names);\n\tg_free (blobs);\n\tg_free (types);\n\tg_free (type);\n\n\tfor (i = mono_method_signature (method)->param_count; i >= 0; i--)\n\t\tif (mspecs [i])\n\t\t\tmono_metadata_free_marshal_spec (mspecs [i]);\n\tg_free (mspecs);\n\t\n\tCACHE_OBJECT (MonoArray *, &(method->signature), res, refclass);\n}\n\nMonoArray*\nmono_param_get_objects (MonoDomain *domain, MonoMethod *method)\n{\n\treturn mono_param_get_objects_internal (domain, method, NULL);\n}\n\n/*\n * mono_method_body_get_object:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.MethodBody object representing the method @method.\n */\nMonoReflectionMethodBody*\nmono_method_body_get_object (MonoDomain *domain, MonoMethod *method)\n{\n\tstatic MonoClass *System_Reflection_MethodBody = NULL;\n\tstatic MonoClass *System_Reflection_LocalVariableInfo = NULL;\n\tstatic MonoClass *System_Reflection_ExceptionHandlingClause = NULL;\n\tMonoReflectionMethodBody *ret;\n\tMonoMethodNormal *mn;\n\tMonoMethodHeader *header;\n\tMonoImage *image;\n\tguint32 method_rva, local_var_sig_token;\n    char *ptr;\n\tunsigned char format, flags;\n\tint i;\n\n\tif (!System_Reflection_MethodBody)\n\t\tSystem_Reflection_MethodBody = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MethodBody\");\n\tif (!System_Reflection_LocalVariableInfo)\n\t\tSystem_Reflection_LocalVariableInfo = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"LocalVariableInfo\");\n\tif (!System_Reflection_ExceptionHandlingClause)\n\t\tSystem_Reflection_ExceptionHandlingClause = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ExceptionHandlingClause\");\n\n\tCHECK_OBJECT (MonoReflectionMethodBody *, method, NULL);\n\n\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t(method->flags & METHOD_ATTRIBUTE_ABSTRACT) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME))\n\t\treturn NULL;\n\n\tmn = (MonoMethodNormal *)method;\n\timage = method->klass->image;\n\theader = mono_method_get_header (method);\n\n\tif (!image->dynamic) {\n\t\t/* Obtain local vars signature token */\n\t\tmethod_rva = mono_metadata_decode_row_col (&image->tables [MONO_TABLE_METHOD], mono_metadata_token_index (method->token) - 1, MONO_METHOD_RVA);\n\t\tptr = mono_image_rva_map (image, method_rva);\n\t\tflags = *(const unsigned char *) ptr;\n\t\tformat = flags & METHOD_HEADER_FORMAT_MASK;\n\t\tswitch (format){\n\t\tcase METHOD_HEADER_TINY_FORMAT:\n\t\t\tlocal_var_sig_token = 0;\n\t\t\tbreak;\n\t\tcase METHOD_HEADER_FAT_FORMAT:\n\t\t\tptr += 2;\n\t\t\tptr += 2;\n\t\t\tptr += 4;\n\t\t\tlocal_var_sig_token = read32 (ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else\n\t\tlocal_var_sig_token = 0; //FIXME\n\n\tret = (MonoReflectionMethodBody*)mono_object_new (domain, System_Reflection_MethodBody);\n\n\tret->init_locals = header->init_locals;\n\tret->max_stack = header->max_stack;\n\tret->local_var_sig_token = local_var_sig_token;\n\tMONO_OBJECT_SETREF (ret, il, mono_array_new_cached (domain, mono_defaults.byte_class, header->code_size));\n\tmemcpy (mono_array_addr (ret->il, guint8, 0), header->code, header->code_size);\n\n\t/* Locals */\n\tMONO_OBJECT_SETREF (ret, locals, mono_array_new_cached (domain, System_Reflection_LocalVariableInfo, header->num_locals));\n\tfor (i = 0; i < header->num_locals; ++i) {\n\t\tMonoReflectionLocalVariableInfo *info = (MonoReflectionLocalVariableInfo*)mono_object_new (domain, System_Reflection_LocalVariableInfo);\n\t\tMONO_OBJECT_SETREF (info, local_type, mono_type_get_object (domain, header->locals [i]));\n\t\tinfo->is_pinned = header->locals [i]->pinned;\n\t\tinfo->local_index = i;\n\t\tmono_array_setref (ret->locals, i, info);\n\t}\n\n\t/* Exceptions */\n\tMONO_OBJECT_SETREF (ret, clauses, mono_array_new_cached (domain, System_Reflection_ExceptionHandlingClause, header->num_clauses));\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tMonoReflectionExceptionHandlingClause *info = (MonoReflectionExceptionHandlingClause*)mono_object_new (domain, System_Reflection_ExceptionHandlingClause);\n\t\tMonoExceptionClause *clause = &header->clauses [i];\n\n\t\tinfo->flags = clause->flags;\n\t\tinfo->try_offset = clause->try_offset;\n\t\tinfo->try_length = clause->try_len;\n\t\tinfo->handler_offset = clause->handler_offset;\n\t\tinfo->handler_length = clause->handler_len;\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tinfo->filter_offset = clause->data.filter_offset;\n\t\telse if (clause->data.catch_class)\n\t\t\tMONO_OBJECT_SETREF (info, catch_type, mono_type_get_object (mono_domain_get (), &clause->data.catch_class->byval_arg));\n\n\t\tmono_array_setref (ret->clauses, i, info);\n\t}\n\n\tCACHE_OBJECT (MonoReflectionMethodBody *, method, ret, NULL);\n\treturn ret;\n}\n\n/**\n * mono_get_dbnull_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.DBNull.Value singleton object\n *\n * Used as the value for ParameterInfo.DefaultValue \n */\nMonoObject *\nmono_get_dbnull_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *dbnull_value_field = NULL;\n\t\n\tif (!dbnull_value_field) {\n\t\tMonoClass *dbnull_klass;\n\t\tdbnull_klass = mono_class_from_name (mono_defaults.corlib, \"System\", \"DBNull\");\n\t\tmono_class_init (dbnull_klass);\n\t\tdbnull_value_field = mono_class_get_field_from_name (dbnull_klass, \"Value\");\n\t\tg_assert (dbnull_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, dbnull_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic void\nget_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types)\n{\n\tguint32 param_index, i, lastp, crow = 0;\n\tguint32 param_cols [MONO_PARAM_SIZE], const_cols [MONO_CONSTANT_SIZE];\n\tgint32 idx;\n\n\tMonoClass *klass = method->klass;\n\tMonoImage *image = klass->image;\n\tMonoMethodSignature *methodsig = mono_method_signature (method);\n\n\tMonoTableInfo *constt;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\n\tif (!methodsig->param_count)\n\t\treturn;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *aux;\n\t\tif (method->is_inflated)\n\t\t\tmethod = ((MonoMethodInflated*)method)->declaring;\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (aux && aux->param_defaults) {\n\t\t\tmemcpy (blobs, &(aux->param_defaults [1]), methodsig->param_count * sizeof (char*));\n\t\t\tmemcpy (types, &(aux->param_default_types [1]), methodsig->param_count * sizeof (guint32));\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tconstt = &image->tables [MONO_TABLE_CONSTANT];\n\n\tidx = mono_method_get_index (method) - 1;\n\tg_assert (idx != -1);\n\n\tparam_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\tif (idx + 1 < methodt->rows)\n\t\tlastp = mono_metadata_decode_row_col (methodt, idx + 1, MONO_METHOD_PARAMLIST);\n\telse\n\t\tlastp = paramt->rows + 1;\n\n\tfor (i = param_index; i < lastp; ++i) {\n\t\tguint32 paramseq;\n\n\t\tmono_metadata_decode_row (paramt, i - 1, param_cols, MONO_PARAM_SIZE);\n\t\tparamseq = param_cols [MONO_PARAM_SEQUENCE];\n\n\t\tif (!(param_cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_DEFAULT))\n\t\t\tcontinue;\n\n\t\tcrow = mono_metadata_get_constant_index (image, MONO_TOKEN_PARAM_DEF | i, crow + 1);\n\t\tif (!crow) {\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tmono_metadata_decode_row (constt, crow - 1, const_cols, MONO_CONSTANT_SIZE);\n\t\tblobs [paramseq - 1] = (gpointer) mono_metadata_blob_heap (image, const_cols [MONO_CONSTANT_VALUE]);\n\t\ttypes [paramseq - 1] = const_cols [MONO_CONSTANT_TYPE];\n\t}\n\n\treturn;\n}\n\nstatic MonoObject *\nmono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob)\n{\n\tvoid *retval;\n\tMonoClass *klass;\n\tMonoObject *object;\n\tMonoType *basetype = type;\n\n\tif (!blob)\n\t\treturn NULL;\n\t\n\tklass = mono_class_from_mono_type (type);\n\tif (klass->valuetype) {\n\t\tobject = mono_object_new (domain, klass);\n\t\tretval = ((gchar *) object + sizeof (MonoObject));\n\t\tif (klass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (klass);\n\t} else {\n\t\tretval = &object;\n\t}\n\t\t\t\n\tif (!mono_get_constant_value_from_blob (domain, basetype->type,  blob, retval))\n\t\treturn object;\n\telse\n\t\treturn NULL;\n}\n\nstatic int\nassembly_name_to_aname (MonoAssemblyName *assembly, char *p) {\n\tint found_sep;\n\tchar *s;\n\n\tmemset (assembly, 0, sizeof (MonoAssemblyName));\n\tassembly->name = p;\n\tassembly->culture = \"\";\n\tmemset (assembly->public_key_token, 0, MONO_PUBLIC_KEY_TOKEN_LENGTH);\n\n\twhile (*p && (isalnum (*p) || *p == '.' || *p == '-' || *p == '_' || *p == '$' || *p == '@'))\n\t\tp++;\n\tfound_sep = 0;\n\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t*p++ = 0;\n\t\tfound_sep = 1;\n\t\tcontinue;\n\t}\n\t/* failed */\n\tif (!found_sep)\n\t\treturn 1;\n\twhile (*p) {\n\t\tif (*p == 'V' && g_ascii_strncasecmp (p, \"Version=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tassembly->major = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->minor = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->build = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->revision = strtoul (p, &s, 10);\n\t\t\tif (s == p)\n\t\t\t\treturn 1;\n\t\t\tp = s;\n\t\t} else if (*p == 'C' && g_ascii_strncasecmp (p, \"Culture=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tif (g_ascii_strncasecmp (p, \"neutral\", 7) == 0) {\n\t\t\t\tassembly->culture = \"\";\n\t\t\t\tp += 7;\n\t\t\t} else {\n\t\t\t\tassembly->culture = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (*p == 'P' && g_ascii_strncasecmp (p, \"PublicKeyToken=\", 15) == 0) {\n\t\t\tp += 15;\n\t\t\tif (strncmp (p, \"null\", 4) == 0) {\n\t\t\t\tp += 4;\n\t\t\t} else {\n\t\t\t\tint len;\n\t\t\t\tgchar *start = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tlen = (p - start + 1);\n\t\t\t\tif (len > MONO_PUBLIC_KEY_TOKEN_LENGTH)\n\t\t\t\t\tlen = MONO_PUBLIC_KEY_TOKEN_LENGTH;\n\t\t\t\tg_strlcpy ((char*)assembly->public_key_token, start, len);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (*p && *p != ',')\n\t\t\t\tp++;\n\t\t}\n\t\tfound_sep = 0;\n\t\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t\t*p++ = 0;\n\t\t\tfound_sep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* failed */\n\t\tif (!found_sep)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * mono_reflection_parse_type:\n * @name: type name\n *\n * Parse a type name as accepted by the GetType () method and output the info\n * extracted in the info structure.\n * the name param will be mangled, so, make a copy before passing it to this function.\n * The fields in info will be valid until the memory pointed to by name is valid.\n *\n * See also mono_type_get_name () below.\n *\n * Returns: 0 on parse error.\n */\nstatic int\n_mono_reflection_parse_type (char *name, char **endptr, gboolean is_recursed,\n\t\t\t     MonoTypeNameParse *info)\n{\n\tchar *start, *p, *w, *temp, *last_point, *startn;\n\tint in_modifiers = 0;\n\tint isbyref = 0, rank, arity = 0, i;\n\n\tstart = p = w = name;\n\n\t//FIXME could we just zero the whole struct? memset (&info, 0, sizeof (MonoTypeNameParse))\n\tmemset (&info->assembly, 0, sizeof (MonoAssemblyName));\n\tinfo->name = info->name_space = NULL;\n\tinfo->nested = NULL;\n\tinfo->modifiers = NULL;\n\tinfo->type_arguments = NULL;\n\n\t/* last_point separates the namespace from the name */\n\tlast_point = NULL;\n\t/* Skips spaces */\n\twhile (*p == ' ') p++, start++, w++, name++;\n\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '+':\n\t\t\t*p = 0; /* NULL terminate the name */\n\t\t\tstartn = p + 1;\n\t\t\tinfo->nested = g_list_append (info->nested, startn);\n\t\t\t/* we have parsed the nesting namespace + name */\n\t\t\tif (info->name)\n\t\t\t\tbreak;\n\t\t\tif (last_point) {\n\t\t\t\tinfo->name_space = start;\n\t\t\t\t*last_point = 0;\n\t\t\t\tinfo->name = last_point + 1;\n\t\t\t} else {\n\t\t\t\tinfo->name_space = (char *)\"\";\n\t\t\t\tinfo->name = start;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tlast_point = p;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t++p;\n\t\t\tbreak;\n\t\tcase '&':\n\t\tcase '*':\n\t\tcase '[':\n\t\tcase ',':\n\t\tcase ']':\n\t\t\tin_modifiers = 1;\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\t++p;\n\t\t\ti = strtol (p, &temp, 10);\n\t\t\tarity += i;\n\t\t\tif (p == temp)\n\t\t\t\treturn 0;\n\t\t\tp = temp-1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (in_modifiers)\n\t\t\tbreak;\n\t\t// *w++ = *p++;\n\t\tp++;\n\t}\n\t\n\tif (!info->name) {\n\t\tif (last_point) {\n\t\t\tinfo->name_space = start;\n\t\t\t*last_point = 0;\n\t\t\tinfo->name = last_point + 1;\n\t\t} else {\n\t\t\tinfo->name_space = (char *)\"\";\n\t\t\tinfo->name = start;\n\t\t}\n\t}\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '&':\n\t\t\tif (isbyref) /* only one level allowed by the spec */\n\t\t\t\treturn 0;\n\t\t\tisbyref = 1;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (0));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-1));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tif (arity != 0) {\n\t\t\t\t*p++ = 0;\n\t\t\t\tinfo->type_arguments = g_ptr_array_new ();\n\t\t\t\tfor (i = 0; i < arity; i++) {\n\t\t\t\t\tMonoTypeNameParse *subinfo = g_new0 (MonoTypeNameParse, 1);\n\t\t\t\t\tgboolean fqname = FALSE;\n\n\t\t\t\t\tg_ptr_array_add (info->type_arguments, subinfo);\n\n\t\t\t\t\tif (*p == '[') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tfqname = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!_mono_reflection_parse_type (p, &p, TRUE, subinfo))\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t/*MS is lenient on [] delimited parameters that aren't fqn - and F# uses them.*/\n\t\t\t\t\tif (fqname && (*p != ']')) {\n\t\t\t\t\t\tchar *aname;\n\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t*p++ = 0;\n\n\t\t\t\t\t\taname = p;\n\t\t\t\t\t\twhile (*p && (*p != ']'))\n\t\t\t\t\t\t\tp++;\n\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t\twhile (*aname) {\n\t\t\t\t\t\t\tif (g_ascii_isspace (*aname)) {\n\t\t\t\t\t\t\t\t++aname;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!*aname ||\n\t\t\t\t\t\t    !assembly_name_to_aname (&subinfo->assembly, aname))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if (fqname && (*p == ']')) {\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < arity) {\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t*p++ = 0;\n\t\t\t\t}\n\n\t\t\t\tarity = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trank = 1;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == ',')\n\t\t\t\t\trank++;\n\t\t\t\telse if (*p == '*') /* '*' means unknown lower bound */\n\t\t\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-2));\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (*p++ != ']')\n\t\t\t\treturn 0;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (rank));\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\treturn 0;\n\t\tcase ',':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (g_ascii_isspace (*p)) {\n\t\t\t\t\t++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*p)\n\t\t\t\treturn 0; /* missing assembly name */\n\t\t\tif (!assembly_name_to_aname (&info->assembly, p))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (info->assembly.name)\n\t\t\tbreak;\n\t}\n\t// *w = 0; /* terminate class name */\n end:\n\tif (!info->name || !*info->name)\n\t\treturn 0;\n\tif (endptr)\n\t\t*endptr = p;\n\t/* add other consistency checks */\n\treturn 1;\n}\n\nint\nmono_reflection_parse_type (char *name, MonoTypeNameParse *info)\n{\n\treturn _mono_reflection_parse_type (name, NULL, FALSE, info);\n}\n\nstatic MonoType*\n_mono_reflection_get_type_from_info (MonoTypeNameParse *info, MonoImage *image, gboolean ignorecase)\n{\n\tgboolean type_resolve = FALSE;\n\tMonoType *type;\n\tMonoImage *rootimage = image;\n\n\tif (info->assembly.name) {\n\t\tMonoAssembly *assembly = mono_assembly_loaded (&info->assembly);\n\t\tif (!assembly && image && image->assembly && mono_assembly_names_equal (&info->assembly, &image->assembly->aname))\n\t\t\t/* \n\t\t\t * This could happen in the AOT compiler case when the search hook is not\n\t\t\t * installed.\n\t\t\t */\n\t\t\tassembly = image->assembly;\n\t\tif (!assembly) {\n\t\t\t/* then we must load the assembly ourselve - see #60439 */\n\t\t\tassembly = mono_assembly_load (&info->assembly, NULL, NULL);\n\t\t\tif (!assembly)\n\t\t\t\treturn NULL;\n\t\t}\n\t\timage = assembly->image;\n\t} else if (!image) {\n\t\timage = mono_defaults.corlib;\n\t}\n\n\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\tif (type == NULL && !info->assembly.name && image != mono_defaults.corlib) {\n\t\timage = mono_defaults.corlib;\n\t\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\t}\n\n\treturn type;\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoClass *klass;\n\tGList *mod;\n\tint modval;\n\tgboolean bounded = FALSE;\n\t\n\tif (!image)\n\t\timage = mono_defaults.corlib;\n\n\tif (ignorecase)\n\t\tklass = mono_class_from_name_case (image, info->name_space, info->name);\n\telse\n\t\tklass = mono_class_from_name (image, info->name_space, info->name);\n\tif (!klass)\n\t\treturn NULL;\n\tfor (mod = info->nested; mod; mod = mod->next) {\n\t\tgpointer iter = NULL;\n\t\tMonoClass *parent;\n\n\t\tparent = klass;\n\t\tmono_class_init (parent);\n\n\t\twhile ((klass = mono_class_get_nested_types (parent, &iter))) {\n\t\t\tif (ignorecase) {\n\t\t\t\tif (mono_utf8_strcasecmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (strcmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!klass)\n\t\t\tbreak;\n\t}\n\tif (!klass)\n\t\treturn NULL;\n\tmono_class_init (klass);\n\n\tif (info->type_arguments) {\n\t\tMonoType **type_args = g_new0 (MonoType *, info->type_arguments->len);\n\t\tMonoReflectionType *the_type;\n\t\tMonoType *instance;\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\ttype_args [i] = _mono_reflection_get_type_from_info (subinfo, rootimage, ignorecase);\n\t\t\tif (!type_args [i]) {\n\t\t\t\tg_free (type_args);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tthe_type = mono_type_get_object (mono_domain_get (), &klass->byval_arg);\n\n\t\tinstance = mono_reflection_bind_generic_parameters (\n\t\t\tthe_type, info->type_arguments->len, type_args);\n\n\t\tg_free (type_args);\n\t\tif (!instance)\n\t\t\treturn NULL;\n\n\t\tklass = mono_class_from_mono_type (instance);\n\t}\n\n\tfor (mod = info->modifiers; mod; mod = mod->next) {\n\t\tmodval = GPOINTER_TO_UINT (mod->data);\n\t\tif (!modval) { /* byref: must be last modifier */\n\t\t\treturn &klass->this_arg;\n\t\t} else if (modval == -1) {\n\t\t\tklass = mono_ptr_class_get (&klass->byval_arg);\n\t\t} else if (modval == -2) {\n\t\t\tbounded = TRUE;\n\t\t} else { /* array rank */\n\t\t\tklass = mono_bounded_array_class_get (klass, modval, bounded);\n\t\t}\n\t\tmono_class_init (klass);\n\t}\n\n\treturn &klass->byval_arg;\n}\n\n/*\n * mono_reflection_get_type:\n * @image: a metadata context\n * @info: type description structure\n * @ignorecase: flag for case-insensitive string compares\n * @type_resolve: whenever type resolve was already tried\n *\n * Build a MonoType from the type description in @info.\n * \n */\n\nMonoType*\nmono_reflection_get_type (MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve) {\n\treturn mono_reflection_get_type_with_rootimage(image, image, info, ignorecase, type_resolve);\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal_dynamic (MonoImage *rootimage, MonoAssembly *assembly, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoReflectionAssemblyBuilder *abuilder;\n\tMonoType *type;\n\tint i;\n\n\tg_assert (assembly->dynamic);\n\tabuilder = (MonoReflectionAssemblyBuilder*)mono_assembly_get_object (((MonoDynamicAssembly*)assembly)->domain, assembly);\n\n\t/* Enumerate all modules */\n\n\ttype = NULL;\n\tif (abuilder->modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->modules); ++i) {\n\t\t\tMonoReflectionModuleBuilder *mb = mono_array_get (abuilder->modules, MonoReflectionModuleBuilder*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, &mb->dynamic_image->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type && abuilder->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *mod = mono_array_get (abuilder->loaded_modules, MonoReflectionModule*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, mod->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn type;\n}\n\t\nMonoType*\nmono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve)\n{\n\tMonoType *type;\n\tMonoReflectionAssembly *assembly;\n\tGString *fullName;\n\tGList *mod;\n\n\tif (image && image->dynamic)\n\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, image->assembly, info, ignorecase);\n\telse\n\t\ttype = mono_reflection_get_type_internal (rootimage, image, info, ignorecase);\n\tif (type)\n\t\treturn type;\n\tif (!mono_domain_has_type_resolve (mono_domain_get ()))\n\t\treturn NULL;\n\n\tif (type_resolve) {\n\t\tif (*type_resolve) \n\t\t\treturn NULL;\n\t\telse\n\t\t\t*type_resolve = TRUE;\n\t}\n\t\n\t/* Reconstruct the type name */\n\tfullName = g_string_new (\"\");\n\tif (info->name_space && (info->name_space [0] != '\\0'))\n\t\tg_string_printf (fullName, \"%s.%s\", info->name_space, info->name);\n\telse\n\t\tg_string_printf (fullName, \"%s\", info->name);\n\tfor (mod = info->nested; mod; mod = mod->next)\n\t\tg_string_append_printf (fullName, \"+%s\", (char*)mod->data);\n\n\tassembly = mono_domain_try_type_resolve ( mono_domain_get (), fullName->str, NULL);\n\tif (assembly) {\n\t\tif (assembly->assembly->dynamic)\n\t\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, assembly->assembly, info, ignorecase);\n\t\telse\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, assembly->assembly->image, \n\t\t\t\t\t\t\t\t\t\t\t\t\t  info, ignorecase);\n\t}\n\tg_string_free (fullName, TRUE);\n\treturn type;\n}\n\nvoid\nmono_reflection_free_type_info (MonoTypeNameParse *info)\n{\n\tg_list_free (info->modifiers);\n\tg_list_free (info->nested);\n\n\tif (info->type_arguments) {\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\tmono_reflection_free_type_info (subinfo);\n\t\t\t/*We free the subinfo since it is allocated by _mono_reflection_parse_type*/\n\t\t\tg_free (subinfo);\n\t\t}\n\n\t\tg_ptr_array_free (info->type_arguments, TRUE);\n\t}\n}\n\n/*\n * mono_reflection_type_from_name:\n * @name: type name.\n * @image: a metadata context (can be NULL).\n *\n * Retrieves a MonoType from its @name. If the name is not fully qualified,\n * it defaults to get the type from @image or, if @image is NULL or loading\n * from it fails, uses corlib.\n * \n */\nMonoType*\nmono_reflection_type_from_name (char *name, MonoImage *image)\n{\n\tMonoType *type = NULL;\n\tMonoTypeNameParse info;\n\tchar *tmp;\n\n\t/* Make a copy since parse_type modifies its argument */\n\ttmp = g_strdup (name);\n\t\n\t/*g_print (\"requested type %s\\n\", str);*/\n\tif (mono_reflection_parse_type (tmp, &info)) {\n\t\ttype = _mono_reflection_get_type_from_info (&info, image, FALSE);\n\t}\n\n\tg_free (tmp);\n\tmono_reflection_free_type_info (&info);\n\treturn type;\n}\n\n/*\n * mono_reflection_get_token:\n *\n *   Return the metadata token of OBJ which should be an object\n * representing a metadata element.\n */\nguint32\nmono_reflection_get_token (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\n\t\t/* Call mono_image_create_token so the object gets added to the tokens hash table */\n\t\ttoken = mono_image_create_token (((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image, obj, FALSE, TRUE);\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_class_from_mono_type (type)->type_token;\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tMonoMethodInflated *inflated = (MonoMethodInflated *) m->method;\n\t\t\treturn inflated->declaring->token;\n\t\t} else {\n\t\t\ttoken = m->method->token;\n\t\t}\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField*)obj;\n\n\t\tif (is_field_on_inst (f->field)) {\n\t\t\tMonoDynamicGenericClass *dgclass = (MonoDynamicGenericClass*)f->field->parent->generic_class;\n\t\t\tint field_index = f->field - dgclass->fields;\n\t\t\tMonoObject *obj;\n\n\t\t\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\t\t\tobj = dgclass->field_objects [field_index];\n\t\t\treturn mono_reflection_get_token (obj);\n\t\t}\n\t\ttoken = mono_class_get_field_token (f->field);\n\t} else if (strcmp (klass->name, \"MonoProperty\") == 0) {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty*)obj;\n\n\t\ttoken = mono_class_get_property_token (p->property);\n\t} else if (strcmp (klass->name, \"MonoEvent\") == 0) {\n\t\tMonoReflectionMonoEvent *p = (MonoReflectionMonoEvent*)obj;\n\n\t\ttoken = mono_class_get_event_token (p->event);\n\t} else if (strcmp (klass->name, \"ParameterInfo\") == 0) {\n\t\tMonoReflectionParameter *p = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (p->MemberImpl);\n\t\tg_assert (mono_class_is_reflection_method_or_constructor (member_class));\n\n\t\ttoken = mono_method_get_param_token (((MonoReflectionMethod*)p->MemberImpl)->method, p->PositionImpl);\n\t} else if (strcmp (klass->name, \"Module\") == 0) {\n\t\tMonoReflectionModule *m = (MonoReflectionModule*)obj;\n\n\t\ttoken = m->token;\n\t} else if (strcmp (klass->name, \"Assembly\") == 0) {\n\t\ttoken = mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1);\n\t} else {\n\t\tgchar *msg = g_strdup_printf (\"MetadataToken is not supported for type '%s.%s'\", klass->name_space, klass->name);\n\t\tMonoException *ex = mono_get_exception_not_implemented (msg);\n\t\tg_free (msg);\n\t\tmono_raise_exception (ex);\n\t}\n\n\treturn token;\n}\n\nstatic void*\nload_cattr_value (MonoImage *image, MonoType *t, const char *p, const char **end)\n{\n\tint slen, type = t->type;\n\tMonoClass *tklass = t->data.klass;\n\nhandle_enum:\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN: {\n\t\tMonoBoolean *bval = g_malloc (sizeof (MonoBoolean));\n\t\t*bval = *p;\n\t\t*end = p + 1;\n\t\treturn bval;\n\t}\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2: {\n\t\tguint16 *val = g_malloc (sizeof (guint16));\n\t\t*val = read16 (p);\n\t\t*end = p + 2;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 4\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4: {\n\t\tguint32 *val = g_malloc (sizeof (guint32));\n\t\t*val = read32 (p);\n\t\t*end = p + 4;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 8\n\tcase MONO_TYPE_U: /* error out instead? this should probably not happen */\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8: {\n\t\tguint64 *val = g_malloc (sizeof (guint64));\n\t\t*val = read64 (p);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_R8: {\n\t\tdouble *val = g_malloc (sizeof (double));\n\t\treadr8 (p, val);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (t->data.klass->enumtype) {\n\t\t\ttype = mono_class_enum_basetype (t->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"generic valutype %s not handled in custom attr value decoding\", t->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING:\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t*end = p + slen;\n\t\treturn mono_string_new_len (mono_domain_get (), p, slen);\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *n;\n\t\tMonoType *t;\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\nhandle_type:\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\tn = g_memdup (p, slen + 1);\n\t\tn [slen] = 0;\n\t\tt = mono_reflection_type_from_name (n, image);\n\t\tif (!t)\n\t\t\tg_warning (\"Cannot load type '%s'\", n);\n\t\tg_free (n);\n\t\t*end = p + slen;\n\t\tif (t)\n\t\t\treturn mono_type_get_object (mono_domain_get (), t);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tchar subt = *p++;\n\t\tMonoObject *obj;\n\t\tMonoClass *subc = NULL;\n\t\tvoid *val;\n\n\t\tif (subt == 0x50) {\n\t\t\tgoto handle_type;\n\t\t} else if (subt == 0x0E) {\n\t\t\ttype = MONO_TYPE_STRING;\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x1D) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tint etype = *p;\n\t\t\tp ++;\n\n\t\t\tif (etype == 0x51)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\tetype = MONO_TYPE_OBJECT;\n\t\t\ttype = MONO_TYPE_SZARRAY;\n\t\t\tsimple_type.type = etype;\n\t\t\ttklass = mono_class_from_mono_type (&simple_type);\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x55) {\n\t\t\tchar *n;\n\t\t\tMonoType *t;\n\t\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t\tn = g_memdup (p, slen + 1);\n\t\t\tn [slen] = 0;\n\t\t\tt = mono_reflection_type_from_name (n, image);\n\t\t\tif (!t)\n\t\t\t\tg_error (\"Cannot load type '%s'\", n);\n\t\t\tg_free (n);\n\t\t\tp += slen;\n\t\t\tsubc = mono_class_from_mono_type (t);\n\t\t} else if (subt >= MONO_TYPE_BOOLEAN && subt <= MONO_TYPE_R8) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tsimple_type.type = subt;\n\t\t\tsubc = mono_class_from_mono_type (&simple_type);\n\t\t} else {\n\t\t\tg_error (\"Unknown type 0x%02x for object type encoding in custom attr\", subt);\n\t\t}\n\t\tval = load_cattr_value (image, &subc->byval_arg, p, end);\n\t\tobj = mono_object_new (mono_domain_get (), subc);\n\t\tmemcpy ((char*)obj + sizeof (MonoObject), val, mono_class_value_size (subc, NULL));\n\t\tg_free (val);\n\t\treturn obj;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tMonoArray *arr;\n\t\tguint32 i, alen, basetype;\n\t\talen = read32 (p);\n\t\tp += 4;\n\t\tif (alen == 0xffffffff) {\n\t\t\t*end = p;\n\t\t\treturn NULL;\n\t\t}\n\t\tarr = mono_array_new (mono_domain_get(), tklass, alen);\n\t\tbasetype = tklass->byval_arg.type;\n\t\tif (basetype == MONO_TYPE_VALUETYPE && tklass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (tklass)->type;\n\t\tswitch (basetype)\n\t\t{\n\t\t\tcase MONO_TYPE_U1:\n\t\t\tcase MONO_TYPE_I1:\n\t\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoBoolean val = *p++;\n\t\t\t\t\tmono_array_set (arr, MonoBoolean, i, val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CHAR:\n\t\t\tcase MONO_TYPE_U2:\n\t\t\tcase MONO_TYPE_I2:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint16 val = read16 (p);\n\t\t\t\t\tmono_array_set (arr, guint16, i, val);\n\t\t\t\t\tp += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R4:\n\t\t\tcase MONO_TYPE_U4:\n\t\t\tcase MONO_TYPE_I4:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint32 val = read32 (p);\n\t\t\t\t\tmono_array_set (arr, guint32, i, val);\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tdouble val;\n\t\t\t\t\treadr8 (p, &val);\n\t\t\t\t\tmono_array_set (arr, double, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_U8:\n\t\t\tcase MONO_TYPE_I8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint64 val = read64 (p);\n\t\t\t\t\tmono_array_set (arr, guint64, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoObject *item = load_cattr_value (image, &tklass->byval_arg, p, &p);\n\t\t\t\t\tmono_array_setref (arr, i, item);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_error (\"Type 0x%02x not handled in custom attr array decoding\", basetype);\n\t\t}\n\t\t*end=p;\n\t\treturn arr;\n\t}\n\tdefault:\n\t\tg_error (\"Type 0x%02x not handled in custom attr value decoding\", type);\n\t}\n\treturn NULL;\n}\n\nstatic MonoObject*\ncreate_cattr_typed_arg (MonoType *t, MonoObject *val)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *params [2], *unboxed;\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeTypedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\t\n\tparams [0] = mono_type_get_object (mono_domain_get (), t);\n\tparams [1] = val;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic MonoObject*\ncreate_cattr_named_arg (void *minfo, MonoObject *typedarg)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *unboxed, *params [2];\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeNamedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\n\tparams [0] = minfo;\n\tparams [1] = typedarg;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic gboolean\ntype_is_reference (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_VALUETYPE:\n\t\treturn FALSE;\n\tdefault:\n\t\treturn TRUE;\n\t}\n}\n\nstatic void\nfree_param_data (MonoMethodSignature *sig, void **params) {\n\tint i;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (!type_is_reference (sig->params [i]))\n\t\t\tg_free (params [i]);\n\t}\n}\n\n/*\n * Find the field index in the metadata FieldDef table.\n */\nstatic guint32\nfind_field_index (MonoClass *klass, MonoClassField *field) {\n\tint i;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tif (field == &klass->fields [i])\n\t\t\treturn klass->field.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the property index in the metadata Property table.\n */\nstatic guint32\nfind_property_index (MonoClass *klass, MonoProperty *property) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tif (property == &klass->ext->properties [i])\n\t\t\treturn klass->ext->property.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the event index in the metadata Event table.\n */\nstatic guint32\nfind_event_index (MonoClass *klass, MonoEvent *event) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\tif (event == &klass->ext->events [i])\n\t\t\treturn klass->ext->event.first + 1 + i;\n\t}\n\treturn 0;\n}\n\nstatic MonoObject*\ncreate_custom_attr (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tMonoObject *attr;\n\tvoid *params_buf [32];\n\tvoid **params;\n\tMonoMethodSignature *sig;\n\n\tmono_class_init (method->klass);\n\n\tif (len == 0) {\n\t\tattr = mono_object_new (mono_domain_get (), method->klass);\n\t\tmono_runtime_invoke (method, attr, NULL, NULL);\n\t\treturn attr;\n\t}\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn NULL;\n\n\t/*g_print (\"got attr %s\\n\", method->klass->name);*/\n\n\tsig = mono_method_signature (method);\n\tif (sig->param_count < 32)\n\t\tparams = params_buf;\n\telse\n\t\t/* Allocate using GC so it gets GC tracking */\n\t\tparams = mono_gc_alloc_fixed (sig->param_count * sizeof (void*), NULL);\n\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tparams [i] = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t}\n\n\tnamed = p;\n\tattr = mono_object_new (mono_domain_get (), method->klass);\n\tmono_runtime_invoke (method, attr, params, NULL);\n\tfree_param_data (method->signature, params);\n\tnum_named = read16 (named);\n\tnamed += 2;\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (mono_object_class (attr), name);\n\t\t\tvoid *val = load_cattr_value (image, field->type, named, &named);\n\t\t\tmono_field_set_value (attr, field, val);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoProperty *prop;\n\t\t\tvoid *pparams [1];\n\t\t\tMonoType *prop_type;\n\n\t\t\tprop = mono_class_get_property_from_name (mono_object_class (attr), name);\n\t\t\t/* can we have more that 1 arg in a custom attr named property? */\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\t\t\tpparams [0] = load_cattr_value (image, prop_type, named, &named);\n\t\t\tmono_property_set_value (prop, attr, pparams, NULL);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (pparams [0]);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\tif (params != params_buf)\n\t\tmono_gc_free_fixed (params);\n\n\treturn attr;\n}\n\t\n/*\n * mono_reflection_create_custom_attr_data_args:\n *\n *   Create an array of typed and named arguments from the cattr blob given by DATA.\n * TYPED_ARGS and NAMED_ARGS will contain the objects representing the arguments,\n * NAMED_ARG_INFO will contain information about the named arguments.\n */\nvoid\nmono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArray **typed_args, MonoArray **named_args, CattrNamedArg **named_arg_info)\n{\n\tMonoArray *typedargs, *namedargs;\n\tMonoClass *attrklass;\n\tMonoDomain *domain;\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tCattrNamedArg *arginfo = NULL;\n\n\tmono_class_init (method->klass);\n\n\t*typed_args = NULL;\n\t*named_args = NULL;\n\t*named_arg_info = NULL;\n\t\n\tdomain = mono_domain_get ();\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn;\n\n\ttypedargs = mono_array_new (domain, mono_get_object_class (), mono_method_signature (method)->param_count);\n\t\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj;\n\t\tvoid *val;\n\n\t\tval = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t\tobj = type_is_reference (mono_method_signature (method)->params [i]) ? \n\t\t\tval : mono_value_box (domain, mono_class_from_mono_type (mono_method_signature (method)->params [i]), val);\n\t\tmono_array_setref (typedargs, i, obj);\n\n\t\tif (!type_is_reference (mono_method_signature (method)->params [i]))\n\t\t\tg_free (val);\n\t}\n\n\tnamed = p;\n\tnum_named = read16 (named);\n\tnamedargs = mono_array_new (domain, mono_get_object_class (), num_named);\n\tnamed += 2;\n\tattrklass = method->klass;\n\n\targinfo = g_new0 (CattrNamedArg, num_named);\n\t*named_arg_info = arginfo;\n\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\targinfo [j].type = field->type;\n\t\t\targinfo [j].field = field;\n\n\t\t\tval = load_cattr_value (image, field->type, named, &named);\n\t\t\tobj = type_is_reference (field->type) ? val : mono_value_box (domain, mono_class_from_mono_type (field->type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoType *prop_type;\n\t\t\tMonoProperty *prop = mono_class_get_property_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\n\t\t\targinfo [j].type = prop_type;\n\t\t\targinfo [j].prop = prop;\n\n\t\t\tval = load_cattr_value (image, prop_type, named, &named);\n\t\t\tobj = type_is_reference (prop_type) ? val : mono_value_box (domain, mono_class_from_mono_type (prop_type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (val);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\t*typed_args = typedargs;\n\t*named_args = namedargs;\n}\n\nstatic MonoObject*\ncreate_custom_attr_data (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tMonoArray *typedargs, *namedargs;\n\tstatic MonoMethod *ctor;\n\tMonoDomain *domain;\n\tMonoObject *attr;\n\tvoid *params [3];\n\tCattrNamedArg *arginfo;\n\tint i;\n\n\tmono_class_init (method->klass);\n\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (mono_defaults.customattribute_data_class, \".ctor\", 3);\n\n\tdomain = mono_domain_get ();\n\tif (len == 0) {\n\t\t/* This is for Attributes with no parameters */\n\t\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\t\tparams [0] = mono_method_get_object (domain, method, NULL);\n\t\tparams [1] = params [2] = NULL;\n\t\tmono_runtime_invoke (method, attr, params, NULL);\n\t\treturn attr;\n\t}\n\n\tmono_reflection_create_custom_attr_data_args (image, method, data, len, &typedargs, &namedargs, &arginfo);\n\tif (!typedargs || !namedargs)\n\t\treturn NULL;\n\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj = mono_array_get (typedargs, MonoObject*, i);\n\t\tMonoObject *typedarg;\n\n\t\ttypedarg = create_cattr_typed_arg (mono_method_signature (method)->params [i], obj);\n\t\tmono_array_setref (typedargs, i, typedarg);\n\t}\n\n\tfor (i = 0; i < mono_array_length (namedargs); ++i) {\n\t\tMonoObject *obj = mono_array_get (namedargs, MonoObject*, i);\n\t\tMonoObject *typedarg, *namedarg, *minfo;\n\n\t\tif (arginfo [i].prop)\n\t\t\tminfo = (MonoObject*)mono_property_get_object (domain, NULL, arginfo [i].prop);\n\t\telse\n\t\t\tminfo = (MonoObject*)mono_field_get_object (domain, NULL, arginfo [i].field);\n\n\t\ttypedarg = create_cattr_typed_arg (arginfo [i].type, obj);\n\t\tnamedarg = create_cattr_named_arg (minfo, typedarg);\n\n\t\tmono_array_setref (namedargs, i, namedarg);\n\t}\n\n\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\tparams [0] = mono_method_get_object (domain, method, NULL);\n\tparams [1] = typedargs;\n\tparams [2] = namedargs;\n\tmono_runtime_invoke (ctor, attr, params, NULL);\n\treturn attr;\n}\n\nMonoArray*\nmono_custom_attrs_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (!cinfo->attrs [i].ctor)\n\t\t\t/* The cattr type is not finished yet */\n\t\t\t/* We should include the type name but cinfo doesn't contain it */\n\t\t\tmono_raise_exception (mono_get_exception_type_load (NULL, NULL));\n\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_construct_by_type (MonoCustomAttrInfo *cinfo, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i, n;\n\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass))\n\t\t\tn ++;\n\t}\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, n);\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass)) {\n\t\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\t\tmono_array_setref (result, n, attr);\n\t\t\tn ++;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_data_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\t\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tattr = create_custom_attr_data (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\n/**\n * mono_custom_attrs_from_index:\n *\n * Returns: NULL if no attributes are found or if a loading error occurs.\n */\nMonoCustomAttrInfo*\nmono_custom_attrs_from_index (MonoImage *image, guint32 idx)\n{\n\tguint32 mtoken, i, len;\n\tguint32 cols [MONO_CUSTOM_ATTR_SIZE];\n\tMonoTableInfo *ca;\n\tMonoCustomAttrInfo *ainfo;\n\tGList *tmp, *list = NULL;\n\tconst char *data;\n\n\tca = &image->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\ti = mono_metadata_custom_attrs_from_index (image, idx);\n\tif (!i)\n\t\treturn NULL;\n\ti --;\n\twhile (i < ca->rows) {\n\t\tif (mono_metadata_decode_row_col (ca, i, MONO_CUSTOM_ATTR_PARENT) != idx)\n\t\t\tbreak;\n\t\tlist = g_list_prepend (list, GUINT_TO_POINTER (i));\n\t\t++i;\n\t}\n\tlen = g_list_length (list);\n\tif (!len)\n\t\treturn NULL;\n\tainfo = g_malloc0 (MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * len);\n\tainfo->num_attrs = len;\n\tainfo->image = image;\n\tfor (i = 0, tmp = list; i < len; ++i, tmp = tmp->next) {\n\t\tmono_metadata_decode_row (ca, GPOINTER_TO_UINT (tmp->data), cols, MONO_CUSTOM_ATTR_SIZE);\n\t\tmtoken = cols [MONO_CUSTOM_ATTR_TYPE] >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (cols [MONO_CUSTOM_ATTR_TYPE] & MONO_CUSTOM_ATTR_TYPE_MASK) {\n\t\tcase MONO_CUSTOM_ATTR_TYPE_METHODDEF:\n\t\t\tmtoken |= MONO_TOKEN_METHOD_DEF;\n\t\t\tbreak;\n\t\tcase MONO_CUSTOM_ATTR_TYPE_MEMBERREF:\n\t\t\tmtoken |= MONO_TOKEN_MEMBER_REF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"Unknown table for custom attr type %08x\", cols [MONO_CUSTOM_ATTR_TYPE]);\n\t\t\tbreak;\n\t\t}\n\t\tainfo->attrs [i].ctor = mono_get_method (image, mtoken, NULL);\n\t\tif (!ainfo->attrs [i].ctor) {\n\t\t\tg_warning (\"Can't find custom attr constructor image: %s mtoken: 0x%08x\", image->name, mtoken);\n\t\t\tg_list_free (list);\n\t\t\tg_free (ainfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tdata = mono_metadata_blob_heap (image, cols [MONO_CUSTOM_ATTR_VALUE]);\n\t\tainfo->attrs [i].data_size = mono_metadata_decode_value (data, &data);\n\t\tainfo->attrs [i].data = (guchar*)data;\n\t}\n\tg_list_free (list);\n\n\treturn ainfo;\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_method (MonoMethod *method)\n{\n\tguint32 idx;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t\n\tif (method->dynamic || method->klass->image->dynamic)\n\t\treturn lookup_custom_attr (method->klass->image, method);\n\n\tif (!method->token)\n\t\t/* Synthetic methods */\n\t\treturn NULL;\n\n\tidx = mono_method_get_index (method);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_METHODDEF;\n\treturn mono_custom_attrs_from_index (method->klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_class (MonoClass *klass)\n{\n\tguint32 idx;\n\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\tif (klass->image->dynamic)\n\t\treturn lookup_custom_attr (klass->image, klass);\n\n\tif (klass->byval_arg.type == MONO_TYPE_VAR || klass->byval_arg.type == MONO_TYPE_MVAR) {\n\t\tidx = mono_metadata_token_index (klass->sizes.generic_param_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_GENERICPAR;\n\t} else {\n\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_TYPEDEF;\n\t}\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx;\n\t\n\tif (assembly->image->dynamic)\n\t\treturn lookup_custom_attr (assembly->image, assembly);\n\tidx = 1; /* there is only one assembly */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_ASSEMBLY;\n\treturn mono_custom_attrs_from_index (assembly->image, idx);\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_module (MonoImage *image)\n{\n\tguint32 idx;\n\t\n\tif (image->dynamic)\n\t\treturn lookup_custom_attr (image, image);\n\tidx = 1; /* there is only one module */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_MODULE;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_property (MonoClass *klass, MonoProperty *property)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tproperty = mono_metadata_get_corresponding_property_from_generic_type_definition (property);\n\t\treturn lookup_custom_attr (klass->image, property);\n\t}\n\tidx = find_property_index (klass, property);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PROPERTY;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_event (MonoClass *klass, MonoEvent *event)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tevent = mono_metadata_get_corresponding_event_from_generic_type_definition (event);\n\t\treturn lookup_custom_attr (klass->image, event);\n\t}\n\tidx = find_event_index (klass, event);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_EVENT;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_field (MonoClass *klass, MonoClassField *field)\n{\n\tguint32 idx;\n\tif (klass->image->dynamic) {\n\t\tfield = mono_metadata_get_corresponding_field_from_generic_type_definition (field);\n\t\treturn lookup_custom_attr (klass->image, field);\n\t}\n\tidx = find_field_index (klass, field);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_FIELDDEF;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_param (MonoMethod *method, guint32 param)\n{\n\tMonoTableInfo *ca;\n\tguint32 i, idx, method_index;\n\tguint32 param_list, param_last, param_pos, found;\n\tMonoImage *image;\n\tMonoReflectionMethodAux *aux;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoCustomAttrInfo *res, *ainfo;\n\t\tint size;\n\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!aux || !aux->param_cattr)\n\t\t\treturn NULL;\n\n\t\t/* Need to copy since it will be freed later */\n\t\tainfo = aux->param_cattr [param];\n\t\tif (!ainfo)\n\t\t\treturn NULL;\n\t\tsize = MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * ainfo->num_attrs;\n\t\tres = g_malloc0 (size);\n\t\tmemcpy (res, ainfo, size);\n\t\treturn res;\n\t}\n\n\timage = method->klass->image;\n\tmethod_index = mono_method_get_index (method);\n\tca = &image->tables [MONO_TABLE_METHOD];\n\n\tparam_list = mono_metadata_decode_row_col (ca, method_index - 1, MONO_METHOD_PARAMLIST);\n\tif (method_index == ca->rows) {\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t\tparam_last = ca->rows + 1;\n\t} else {\n\t\tparam_last = mono_metadata_decode_row_col (ca, method_index, MONO_METHOD_PARAMLIST);\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t}\n\tfound = FALSE;\n\tfor (i = param_list; i < param_last; ++i) {\n\t\tparam_pos = mono_metadata_decode_row_col (ca, i - 1, MONO_PARAM_SEQUENCE);\n\t\tif (param_pos == param) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\tidx = i;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PARAMDEF;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\ngboolean\nmono_custom_attrs_has_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i;\n\tMonoClass *klass;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass) || (MONO_CLASS_IS_INTERFACE (attr_klass) && mono_class_is_assignable_from (attr_klass, klass)))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nMonoObject*\nmono_custom_attrs_get_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i, attr_index;\n\tMonoClass *klass;\n\tMonoArray *attrs;\n\n\tattr_index = -1;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass)) {\n\t\t\tattr_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr_index == -1)\n\t\treturn NULL;\n\n\tattrs = mono_custom_attrs_construct (ainfo);\n\tif (attrs)\n\t\treturn mono_array_get (attrs, MonoObject*, attr_index);\n\telse\n\t\treturn NULL;\n}\n\n/*\n * mono_reflection_get_custom_attrs_info:\n * @obj: a reflection object handle\n *\n * Return the custom attribute info for attributes defined for the\n * reflection handle @obj. The objects.\n *\n * FIXME this function leaks like a sieve for SRE objects.\n */\nMonoCustomAttrInfo*\nmono_reflection_get_custom_attrs_info (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tMonoCustomAttrInfo *cinfo = NULL;\n\t\n\tklass = obj->vtable->klass;\n\tif (klass == mono_defaults.monotype_class) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tklass = mono_class_from_mono_type (type);\n\t\tcinfo = mono_custom_attrs_from_class (klass);\n\t} else if (strcmp (\"Assembly\", klass->name) == 0) {\n\t\tMonoReflectionAssembly *rassembly = (MonoReflectionAssembly*)obj;\n\t\tcinfo = mono_custom_attrs_from_assembly (rassembly->assembly);\n\t} else if (strcmp (\"Module\", klass->name) == 0) {\n\t\tMonoReflectionModule *module = (MonoReflectionModule*)obj;\n\t\tcinfo = mono_custom_attrs_from_module (module->image);\n\t} else if (strcmp (\"MonoProperty\", klass->name) == 0) {\n\t\tMonoReflectionProperty *rprop = (MonoReflectionProperty*)obj;\n\t\tcinfo = mono_custom_attrs_from_property (rprop->property->parent, rprop->property);\n\t} else if (strcmp (\"MonoEvent\", klass->name) == 0) {\n\t\tMonoReflectionMonoEvent *revent = (MonoReflectionMonoEvent*)obj;\n\t\tcinfo = mono_custom_attrs_from_event (revent->event->parent, revent->event);\n\t} else if (strcmp (\"MonoField\", klass->name) == 0) {\n\t\tMonoReflectionField *rfield = (MonoReflectionField*)obj;\n\t\tcinfo = mono_custom_attrs_from_field (rfield->field->parent, rfield->field);\n\t} else if ((strcmp (\"MonoMethod\", klass->name) == 0) || (strcmp (\"MonoCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if ((strcmp (\"MonoGenericMethod\", klass->name) == 0) || (strcmp (\"MonoGenericCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if (strcmp (\"ParameterInfo\", klass->name) == 0) {\n\t\tMonoReflectionParameter *param = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (param->MemberImpl);\n\t\tif (mono_class_is_reflection_method_or_constructor (member_class)) {\n\t\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)param->MemberImpl;\n\t\t\tcinfo = mono_custom_attrs_from_param (rmethod->method, param->PositionImpl + 1);\n\t\t} else if (is_sr_mono_property (member_class)) {\n\t\t\tMonoReflectionProperty *prop = (MonoReflectionProperty *)param->MemberImpl;\n\t\t\tMonoMethod *method;\n\t\t\tif (!(method = prop->property->get))\n\t\t\t\tmethod = prop->property->set;\n\t\t\tg_assert (method);\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_method_on_tb_inst (member_class)) {/*XXX This is a workaround for Compiler Context*/\n\t\t\tMonoMethod *method = mono_reflection_method_on_tb_inst_get_handle ((MonoReflectionMethodOnTypeBuilderInst*)param->MemberImpl);\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_ctor_on_tb_inst (member_class)) { /*XX This is a workaround for Compiler Context*/\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)param->MemberImpl;\n\t\t\tMonoMethod *method = NULL;\n\t\t\tif (is_sre_ctor_builder (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionCtorBuilder *)c->cb)->mhandle;\n\t\t\telse if (is_sr_mono_cmethod (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionMethod *)c->cb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"mono_reflection_get_custom_attrs_info:: can't handle a CTBI with base_method of type %s\", mono_type_get_full_name (member_class));\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else {\n\t\t\tchar *type_name = mono_type_get_full_name (member_class);\n\t\t\tchar *msg = g_strdup_printf (\"Custom attributes on a ParamInfo with member %s are not supported\", type_name);\n\t\t\tMonoException *ex = mono_get_exception_not_supported  (msg);\n\t\t\tg_free (type_name);\n\t\t\tg_free (msg);\n\t\t\tmono_raise_exception (ex);\n\t\t}\n\t} else if (strcmp (\"AssemblyBuilder\", klass->name) == 0) {\n\t\tMonoReflectionAssemblyBuilder *assemblyb = (MonoReflectionAssemblyBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, assemblyb->assembly.assembly->image, assemblyb->cattrs);\n\t} else if (strcmp (\"TypeBuilder\", klass->name) == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &tb->module->dynamic_image->image, tb->cattrs);\n\t} else if (strcmp (\"ModuleBuilder\", klass->name) == 0) {\n\t\tMonoReflectionModuleBuilder *mb = (MonoReflectionModuleBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &mb->dynamic_image->image, mb->cattrs);\n\t} else if (strcmp (\"ConstructorBuilder\", klass->name) == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, cb->mhandle->klass->image, cb->cattrs);\n\t} else if (strcmp (\"MethodBuilder\", klass->name) == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, mb->mhandle->klass->image, mb->cattrs);\n\t} else if (strcmp (\"FieldBuilder\", klass->name) == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image->image, fb->cattrs);\n\t} else if (strcmp (\"MonoGenericClass\", klass->name) == 0) {\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)obj;\n\t\tcinfo = mono_reflection_get_custom_attrs_info ((MonoObject*)gclass->generic_type);\n\t} else { /* handle other types here... */\n\t\tg_error (\"get custom attrs not yet supported for %s\", klass->name);\n\t}\n\n\treturn cinfo;\n}\n\n/*\n * mono_reflection_get_custom_attrs_by_type:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. If @attr_klass is non-NULL, only custom attributes \n * of that type are returned. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_by_type (MonoObject *obj, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tif (attr_klass)\n\t\t\tresult = mono_custom_attrs_construct_by_type (cinfo, attr_klass);\n\t\telse\n\t\t\tresult = mono_custom_attrs_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else {\n\t\tif (mono_loader_get_last_error ())\n\t\t\treturn NULL;\n\t\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, 0);\n\t}\n\n\treturn result;\n}\n\n/*\n * mono_reflection_get_custom_attrs:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs (MonoObject *obj)\n{\n\treturn mono_reflection_get_custom_attrs_by_type (obj, NULL);\n}\n\n/*\n * mono_reflection_get_custom_attrs_data:\n * @obj: a reflection obj handle\n *\n * Returns an array of System.Reflection.CustomAttributeData,\n * which include information about attributes reflected on\n * types loaded using the Reflection Only methods\n */\nMonoArray*\nmono_reflection_get_custom_attrs_data (MonoObject *obj)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tresult = mono_custom_attrs_data_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else\n\t\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, 0);\n\n\treturn result;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_get_underlying_system_type (MonoReflectionType* t)\n{\n        MonoMethod *method_get_underlying_system_type;\n\n        method_get_underlying_system_type = mono_object_get_virtual_method ((MonoObject *) t,\n                                                                            mono_class_get_method_from_name (mono_object_class (t),\n                                                                                                             \"get_UnderlyingSystemType\",\n                                                                                                             0));\n        return (MonoReflectionType *) mono_runtime_invoke (method_get_underlying_system_type, t, NULL, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic gboolean\nis_corlib_type (MonoClass *class)\n{\n\treturn class->image == mono_defaults.corlib;\n}\n\nstatic gboolean\nis_usertype (MonoReflectionType *ref)\n{\n\tMonoClass *class = mono_object_class (ref);\n\treturn class->image != mono_defaults.corlib || strcmp (\"TypeDelegator\", class->name) == 0;\n}\n\n#define check_corlib_type_cached(_class, _namespace, _name) do { \\\n\tstatic MonoClass *cached_class; \\\n\tif (cached_class) \\\n\t\treturn cached_class == _class; \\\n\tif (is_corlib_type (_class) && !strcmp (_name, _class->name) && !strcmp (_namespace, _class->name_space)) { \\\n\t\tcached_class = _class; \\\n\t\treturn TRUE; \\\n\t} \\\n\treturn FALSE; \\\n} while (0) \\\n\nstatic gboolean\nis_sre_array (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ArrayType\");\n}\n\nstatic gboolean\nis_sre_byref (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ByRefType\");\n}\n\nstatic gboolean\nis_sre_pointer (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"PointerType\");\n}\n\nstatic gboolean\nis_sre_generic_instance (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericClass\");\n}\n\nstatic gboolean\nis_sre_method_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodBuilder\");\n}\n\nstatic gboolean\nis_sre_ctor_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorBuilder\");\n}\n\nstatic gboolean\nis_sr_mono_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoMethod\");\n}\n\nstatic gboolean\nis_sr_mono_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_property (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoProperty\");\n}\n\nstatic gboolean\nis_sre_method_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodOnTypeBuilderInst\");\n}\n\nstatic gboolean\nis_sre_ctor_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorOnTypeBuilderInst\");\n}\n\ngboolean\nmono_class_is_reflection_method_or_constructor (MonoClass *class)\n{\n\treturn is_sr_mono_method (class) || is_sr_mono_cmethod (class) || is_sr_mono_generic_method (class) || is_sr_mono_generic_cmethod (class);\n}\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tMonoClass *class;\n\tif (!ref)\n\t\treturn NULL;\n\tif (ref->type)\n\t\treturn ref->type;\n\n\tif (is_usertype (ref)) {\n\t\tref = mono_reflection_type_get_underlying_system_type (ref);\n\t\tg_assert (!is_usertype (ref)); /*FIXME fail better*/\n\t\tif (ref->type)\n\t\t\treturn ref->type;\n\t}\n\n\tclass = mono_object_class (ref);\n\n\tif (is_sre_array (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionArrayType *sre_array = (MonoReflectionArrayType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_array->element_type);\n\t\tg_assert (base);\n\t\tif (sre_array->rank == 0) //single dimentional array\n\t\t\tres = &mono_array_class_get (mono_class_from_mono_type (base), 1)->byval_arg;\n\t\telse\n\t\t\tres = &mono_bounded_array_class_get (mono_class_from_mono_type (base), sre_array->rank, TRUE)->byval_arg;\n\t\tsre_array->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_byref (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_byref = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_byref->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_class_from_mono_type (base)->this_arg;\n\t\tsre_byref->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_pointer (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_pointer = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_pointer->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_ptr_class_get (base)->byval_arg;\n\t\tsre_pointer->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_generic_instance (class)) {\n\t\tMonoType *res, **types;\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)ref;\n\t\tint i, count;\n\n\t\tcount = mono_array_length (gclass->type_arguments);\n\t\ttypes = g_new0 (MonoType*, count);\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tMonoReflectionType *t = mono_array_get (gclass->type_arguments, gpointer, i);\n\t\t\ttypes [i] = mono_reflection_type_get_handle (t);\n\t\t}\n\n\t\tres = mono_reflection_bind_generic_parameters ((MonoReflectionType*)gclass->generic_type, count, types);\n\t\tg_free (types);\n\t\tg_assert (res);\n\t\tgclass->type.type = res;\n\t\treturn res;\n\t}\n\n\tg_error (\"Cannot handle corlib user type %s\", mono_type_full_name (&mono_object_class(ref)->byval_arg));\n\treturn NULL;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_resolve_user_types (MonoReflectionType *type)\n{\n\tif (!type || type->type)\n\t\treturn type;\n\n\tif (is_usertype (type)) {\n\t\ttype = mono_reflection_type_get_underlying_system_type (type);\n\t\tif (is_usertype (type))\n\t\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported22\"));\n\t}\n\n\treturn type;\n}\n\nvoid\nmono_reflection_create_unmanaged_type (MonoReflectionType *type)\n{\n\tmono_reflection_type_get_handle (type);\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nparameters_to_signature (MonoImage *image, MonoArray *parameters) {\n\tMonoMethodSignature *sig;\n\tint count, i;\n\n\tcount = parameters? mono_array_length (parameters): 0;\n\n\tsig = image_g_malloc0 (image, MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * count);\n\tsig->param_count = count;\n\tsig->sentinelpos = -1; /* FIXME */\n\tfor (i = 0; i < count; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (parameters, i);\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nctor_builder_to_signature (MonoImage *image, MonoReflectionCtorBuilder *ctor) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, ctor->parameters);\n\tsig->hasthis = ctor->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = &mono_defaults.void_class->byval_arg;\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nmethod_builder_to_signature (MonoImage *image, MonoReflectionMethodBuilder *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle ((MonoReflectionType*)method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = method->generic_params ? mono_array_length (method->generic_params) : 0;\n\treturn sig;\n}\n\nstatic MonoMethodSignature*\ndynamic_method_to_signature (MonoReflectionDynamicMethod *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (NULL, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle (method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = 0;\n\treturn sig;\n}\n\nstatic void\nget_prop_name_and_type (MonoObject *prop, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (prop);\n\tif (strcmp (klass->name, \"PropertyBuilder\") == 0) {\n\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *)prop;\n\t\t*name = mono_string_to_utf8 (pb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)pb->type);\n\t} else {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty *)prop;\n\t\t*name = g_strdup (p->property->name);\n\t\tif (p->property->get)\n\t\t\t*type = mono_method_signature (p->property->get)->ret;\n\t\telse\n\t\t\t*type = mono_method_signature (p->property->set)->params [mono_method_signature (p->property->set)->param_count - 1];\n\t}\n}\n\nstatic void\nget_field_name_and_type (MonoObject *field, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (field);\n\tif (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)field;\n\t\t*name = mono_string_to_utf8 (fb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t} else {\n\t\tMonoReflectionField *f = (MonoReflectionField *)field;\n\t\t*name = g_strdup (mono_field_get_name (f->field));\n\t\t*type = f->field->type;\n\t}\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/*\n * Encode a value in a custom attribute stream of bytes.\n * The value to encode is either supplied as an object in argument val\n * (valuetypes are boxed), or as a pointer to the data in the\n * argument argval.\n * @type represents the type of the value\n * @buffer is the start of the buffer\n * @p the current position in the buffer\n * @buflen contains the size of the buffer and is used to return the new buffer size\n * if this needs to be realloced.\n * @retbuffer and @retp return the start and the position of the buffer\n */\nstatic void\nencode_cattr_value (MonoAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, MonoObject *arg, char *argval)\n{\n\tMonoTypeEnum simple_type;\n\t\n\tif ((p-buffer) + 10 >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\tif (!argval)\n\t\targval = ((char*)arg + sizeof (MonoObject));\n\tsimple_type = type->type;\nhandle_enum:\n\tswitch (simple_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\t*p++ = *argval;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tswap_with_size (p, argval, 2, 1);\n\t\tp += 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tswap_with_size (p, argval, 4, 1);\n\t\tp += 4;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n#if defined(ARM_FPU_FPA) && G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tp [0] = argval [4];\n\t\tp [1] = argval [5];\n\t\tp [2] = argval [6];\n\t\tp [3] = argval [7];\n\t\tp [4] = argval [0];\n\t\tp [5] = argval [1];\n\t\tp [6] = argval [2];\n\t\tp [7] = argval [3];\n#else\n\t\tswap_with_size (p, argval, 8, 1);\n#endif\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tswap_with_size (p, argval, 8, 1);\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (type->data.klass->enumtype) {\n\t\t\tsimple_type = mono_class_enum_basetype (type->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_warning (\"generic valutype %s not handled in custom attr value decoding\", type->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\tstr = mono_string_to_utf8 ((MonoString*)arg);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\nhandle_type:\n\t\tstr = type_get_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)arg), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tint len, i;\n\t\tMonoClass *eclass, *arg_eclass;\n\n\t\tif (!arg) {\n\t\t\t*p++ = 0xff; *p++ = 0xff; *p++ = 0xff; *p++ = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tlen = mono_array_length ((MonoArray*)arg);\n\t\t*p++ = len & 0xff;\n\t\t*p++ = (len >> 8) & 0xff;\n\t\t*p++ = (len >> 16) & 0xff;\n\t\t*p++ = (len >> 24) & 0xff;\n\t\t*retp = p;\n\t\t*retbuffer = buffer;\n\t\teclass = type->data.klass;\n\t\targ_eclass = mono_object_class (arg)->element_class;\n\n\t\tif (!eclass) {\n\t\t\t/* Happens when we are called from the MONO_TYPE_OBJECT case below */\n\t\t\teclass = mono_defaults.object_class;\n\t\t}\n\t\tif (eclass == mono_defaults.object_class && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (arg_eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &arg_eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else if (eclass->valuetype && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, mono_array_get ((MonoArray*)arg, MonoObject*, i), NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tMonoClass *klass;\n\t\tchar *str;\n\t\tguint32 slen;\n\n\t\t/*\n\t\t * The parameter type is 'object' but the type of the actual\n\t\t * argument is not. So we have to add type information to the blob\n\t\t * too. This is completely undocumented in the spec.\n\t\t */\n\n\t\tif (arg == NULL) {\n\t\t\t*p++ = MONO_TYPE_STRING;\t// It's same hack as MS uses\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tklass = mono_object_class (arg);\n\n\t\tif (mono_object_isinst (arg, mono_defaults.systemtype_class)) {\n\t\t\t*p++ = 0x50;\n\t\t\tgoto handle_type;\n\t\t} else if (klass->enumtype) {\n\t\t\t*p++ = 0x55;\n\t\t} else if (klass == mono_defaults.string_class) {\n\t\t\tsimple_type = MONO_TYPE_STRING;\n\t\t\t*p++ = 0x0E;\n\t\t\tgoto handle_enum;\n\t\t} else if (klass->rank == 1) {\n\t\t\t*p++ = 0x1D;\n\t\t\tif (klass->element_class->byval_arg.type == MONO_TYPE_OBJECT)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\t*p++ = 0x51;\n\t\t\telse\n\t\t\t\t*p++ = klass->element_class->byval_arg.type;\n\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &klass->byval_arg, arg, NULL);\n\t\t\tbreak;\n\t\t} else if (klass->byval_arg.type >= MONO_TYPE_BOOLEAN && klass->byval_arg.type <= MONO_TYPE_R8) {\n\t\t\t*p++ = simple_type = klass->byval_arg.type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"unhandled type in custom attr\");\n\t\t}\n\t\tstr = type_get_qualified_name (mono_class_get_type(klass), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tsimple_type = mono_class_enum_basetype (klass)->type;\n\t\tgoto handle_enum;\n\t}\n\tdefault:\n\t\tg_error (\"type 0x%02x not yet supported in custom attr encoder\", simple_type);\n\t}\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\nstatic void\nencode_field_or_prop_type (MonoType *type, char *p, char **retp)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tint slen = strlen (str);\n\n\t\t*p++ = 0x55;\n\t\t/*\n\t\t * This seems to be optional...\n\t\t * *p++ = 0x80;\n\t\t */\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_OBJECT) {\n\t\t*p++ = 0x51;\n\t} else if (type->type == MONO_TYPE_CLASS) {\n\t\t/* it should be a type: encode_cattr_value () has the check */\n\t\t*p++ = 0x50;\n\t} else {\n\t\tmono_metadata_encode_value (type->type, p, &p);\n\t\tif (type->type == MONO_TYPE_SZARRAY)\n\t\t\t/* See the examples in Partition VI, Annex B */\n\t\t\tencode_field_or_prop_type (&type->data.klass->byval_arg, p, &p);\n\t}\n\n\t*retp = p;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nencode_named_val (MonoReflectionAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, char *name, MonoObject *value)\n{\n\tint len;\n\t/* Preallocate a large enough buffer */\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_SZARRAY && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (&type->data.klass->byval_arg, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else {\n\t\tlen = 0;\n\t}\n\tlen += strlen (name);\n\n\tif ((p-buffer) + 20 + len >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\t*buflen += len;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\n\tencode_field_or_prop_type (type, p, &p);\n\n\tlen = strlen (name);\n\tmono_metadata_encode_value (len, p, &p);\n\tmemcpy (p, name, len);\n\tp += len;\n\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, buflen, type, value, NULL);\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\n/*\n * mono_reflection_get_custom_attrs_blob:\n * @ctor: custom attribute constructor\n * @ctorArgs: arguments o the constructor\n * @properties:\n * @propValues:\n * @fields:\n * @fieldValues:\n * \n * Creates the blob of data that needs to be saved in the metadata and that represents\n * the custom attributed described by @ctor, @ctorArgs etc.\n * Returns: a Byte array representing the blob of data.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tMonoArray *result;\n\tMonoMethodSignature *sig;\n\tMonoObject *arg;\n\tchar *buffer, *p;\n\tguint32 buflen, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t/* sig is freed later so allocate it in the heap */\n\t\tsig = ctor_builder_to_signature (NULL, (MonoReflectionCtorBuilder*)ctor);\n\t} else {\n\t\tsig = mono_method_signature (((MonoReflectionMethod*)ctor)->method);\n\t}\n\n\tg_assert (mono_array_length (ctorArgs) == sig->param_count);\n\tbuflen = 256;\n\tp = buffer = g_malloc (buflen);\n\t/* write the prolog */\n\t*p++ = 1;\n\t*p++ = 0;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\targ = mono_array_get (ctorArgs, MonoObject*, i);\n\t\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, &buflen, sig->params [i], arg, NULL);\n\t}\n\ti = 0;\n\tif (properties)\n\t\ti += mono_array_length (properties);\n\tif (fields)\n\t\ti += mono_array_length (fields);\n\t*p++ = i & 0xff;\n\t*p++ = (i >> 8) & 0xff;\n\tif (properties) {\n\t\tMonoObject *prop;\n\t\tfor (i = 0; i < mono_array_length (properties); ++i) {\n\t\t\tMonoType *ptype;\n\t\t\tchar *pname;\n\n\t\t\tprop = mono_array_get (properties, gpointer, i);\n\t\t\tget_prop_name_and_type (prop, &pname, &ptype);\n\t\t\t*p++ = 0x54; /* PROPERTY signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ptype, pname, (MonoObject*)mono_array_get (propValues, gpointer, i));\n\t\t\tg_free (pname);\n\t\t}\n\t}\n\n\tif (fields) {\n\t\tMonoObject *field;\n\t\tfor (i = 0; i < mono_array_length (fields); ++i) {\n\t\t\tMonoType *ftype;\n\t\t\tchar *fname;\n\n\t\t\tfield = mono_array_get (fields, gpointer, i);\n\t\t\tget_field_name_and_type (field, &fname, &ftype);\n\t\t\t*p++ = 0x53; /* FIELD signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ftype, fname, (MonoObject*)mono_array_get (fieldValues, gpointer, i));\n\t\t\tg_free (fname);\n\t\t}\n\t}\n\n\tg_assert (p - buffer <= buflen);\n\tbuflen = p - buffer;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tp = mono_array_addr (result, char, 0);\n\tmemcpy (p, buffer, buflen);\n\tg_free (buffer);\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\"))\n\t\tg_free (sig);\n\treturn result;\n}\n\n/*\n * mono_reflection_setup_internal_class:\n * @tb: a TypeBuilder object\n *\n * Creates a MonoClass that represents the TypeBuilder.\n * This is a trick that lets us simplify a lot of reflection code\n * (and will allow us to support Build and Run assemblies easier).\n */\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass, *parent;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tRESOLVE_TYPE (tb->parent);\n\n\tmono_loader_lock ();\n\n\tif (tb->parent) {\n\t\t/* check so we can compile corlib correctly */\n\t\tif (strcmp (mono_object_class (tb->parent)->name, \"TypeBuilder\") == 0) {\n\t\t\t/* mono_class_setup_mono_type () guaranteess type->data.klass is valid */\n\t\t\tparent = mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent)->data.klass;\n\t\t} else {\n\t\t\tparent = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t\t}\n\t} else {\n\t\tparent = NULL;\n\t}\n\t\n\t/* the type has already being created: it means we just have to change the parent */\n\tif (tb->type.type) {\n\t\tklass = mono_class_from_mono_type (tb->type.type);\n\t\tklass->parent = NULL;\n\t\t/* fool mono_class_setup_parent */\n\t\tklass->supertypes = NULL;\n\t\tmono_class_setup_parent (klass, parent);\n\t\tmono_class_setup_mono_type (klass);\n\t\tmono_loader_unlock ();\n\t\treturn;\n\t}\n\n\tklass = mono_image_alloc0 (&tb->module->dynamic_image->image, sizeof (MonoClass));\n\n\tklass->image = &tb->module->dynamic_image->image;\n\n\tklass->inited = 1; /* we lie to the runtime */\n\tklass->name = mono_string_to_utf8_image (klass->image, tb->name, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->name_space = mono_string_to_utf8_image (klass->image, tb->nspace, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->type_token = MONO_TOKEN_TYPE_DEF | tb->table_idx;\n\tklass->flags = tb->attrs;\n\t\n\tmono_profiler_class_event (klass, MONO_PROFILE_START_LOAD);\n\n\tklass->element_class = klass;\n\n\tMOVING_GC_REGISTER (&klass->reflection_info);\n\tklass->reflection_info = tb;\n\n\t/* Put into cache so mono_class_get () will find it */\n\tmono_image_add_to_name_cache (klass->image, klass->name_space, klass->name, tb->table_idx);\n\n\tmono_g_hash_table_insert (tb->module->dynamic_image->tokens,\n\t\tGUINT_TO_POINTER (MONO_TOKEN_TYPE_DEF | tb->table_idx), tb);\n\n\tif (parent != NULL) {\n\t\tmono_class_setup_parent (klass, parent);\n\t} else if (strcmp (klass->name, \"Object\") == 0 && strcmp (klass->name_space, \"System\") == 0) {\n\t\tconst char *old_n = klass->name;\n\t\t/* trick to get relative numbering right when compiling corlib */\n\t\tklass->name = \"BuildingObject\";\n\t\tmono_class_setup_parent (klass, mono_defaults.object_class);\n\t\tklass->name = old_n;\n\t}\n\n\tif ((!strcmp (klass->name, \"ValueType\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Object\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Enum\") && !strcmp (klass->name_space, \"System\"))) {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->size_inited = 1;\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\n\tmono_class_setup_mono_type (klass);\n\n\tmono_class_setup_supertypes (klass);\n\n\t/*\n\t * FIXME: handle interfaces.\n\t */\n\n\ttb->type.type = &klass->byval_arg;\n\n\tif (tb->nesting_type) {\n\t\tg_assert (tb->nesting_type->type);\n\t\tklass->nested_in = mono_class_from_mono_type (mono_reflection_type_get_handle (tb->nesting_type));\n\t}\n\n\t/*g_print (\"setup %s as %s (%p)\\n\", klass->name, ((MonoObject*)tb)->vtable->klass->name, tb);*/\n\n\tmono_profiler_class_loaded (klass, MONO_PROFILE_OK);\n\t\n\tmono_loader_unlock ();\n\treturn;\n\nfailure:\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n}\n\n/*\n * mono_reflection_setup_generic_class:\n * @tb: a TypeBuilder object\n *\n * Setup the generic class before adding the first generic parameter.\n */\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n}\n\n/*\n * mono_reflection_create_generic_class:\n * @tb: a TypeBuilder object\n *\n * Creates the generic class after all generic parameters have been added.\n */\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tcount = tb->generic_params ? mono_array_length (tb->generic_params) : 0;\n\n\tif (klass->generic_container || (count == 0))\n\t\treturn;\n\n\tg_assert (tb->generic_container && (tb->generic_container->owner.klass == klass));\n\n\tklass->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\n\tklass->generic_container->owner.klass = klass;\n\tklass->generic_container->type_argc = count;\n\tklass->generic_container->type_params = mono_image_alloc0 (klass->image, sizeof (MonoGenericParamFull) * count);\n\n\tklass->is_generic = 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam = mono_array_get (tb->generic_params, gpointer, i);\n\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gparam)->data.generic_param;\n\t\tklass->generic_container->type_params [i] = *param;\n\t\t/*Make sure we are a diferent type instance */\n\t\tklass->generic_container->type_params [i].param.owner = klass->generic_container;\n\t\tklass->generic_container->type_params [i].info.pklass = NULL;\n\t\tklass->generic_container->type_params [i].info.flags = gparam->attrs;\n\n\t\tg_assert (klass->generic_container->type_params [i].param.owner);\n\t}\n\n\tklass->generic_container->context.class_inst = mono_get_shared_generic_inst (klass->generic_container);\n}\n\n/*\n * mono_reflection_create_internal_class:\n * @tb: a TypeBuilder object\n *\n * Actually create the MonoClass that is associated with the TypeBuilder.\n */\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tmono_loader_lock ();\n\tif (klass->enumtype && mono_class_enum_basetype (klass) == NULL) {\n\t\tMonoReflectionFieldBuilder *fb;\n\t\tMonoClass *ec;\n\t\tMonoType *enum_basetype;\n\n\t\tg_assert (tb->fields != NULL);\n\t\tg_assert (mono_array_length (tb->fields) >= 1);\n\n\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, 0);\n\n\t\tif (!mono_type_is_valid_enum_basetype (mono_reflection_type_get_handle ((MonoReflectionType*)fb->type))) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn;\n\t\t}\n\n\t\tenum_basetype = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\t\tif (!klass->element_class)\n\t\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\n\t\t/*\n\t\t * get the element_class from the current corlib.\n\t\t */\n\t\tec = default_class_from_mono_type (enum_basetype);\n\t\tklass->instance_size = ec->instance_size;\n\t\tklass->size_inited = 1;\n\t\t/* \n\t\t * this is almost safe to do with enums and it's needed to be able\n\t\t * to create objects of the enum type (for use in SetConstant).\n\t\t */\n\t\t/* FIXME: Does this mean enums can't have method overrides ? */\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\tmono_loader_unlock ();\n}\n\nstatic MonoMarshalSpec*\nmono_marshal_spec_from_builder (MonoImage *image, MonoAssembly *assembly,\n\t\t\t\t\t\t\t\tMonoReflectionMarshal *minfo)\n{\n\tMonoMarshalSpec *res;\n\n\tres = image_g_new0 (image, MonoMarshalSpec, 1);\n\tres->native = minfo->type;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tres->data.array_data.elem_type = minfo->eltype;\n\t\tif (minfo->has_size) {\n\t\t\tres->data.array_data.param_num = minfo->param_num;\n\t\t\tres->data.array_data.num_elem = minfo->count;\n\t\t\tres->data.array_data.elem_mult = minfo->param_num == -1 ? 0 : 1;\n\t\t}\n\t\telse {\n\t\t\tres->data.array_data.param_num = -1;\n\t\t\tres->data.array_data.num_elem = -1;\n\t\t\tres->data.array_data.elem_mult = -1;\n\t\t}\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tres->data.array_data.num_elem = minfo->count;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->marshaltyperef)\n\t\t\tres->data.custom_data.custom_name =\n\t\t\t\ttype_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\tif (minfo->mcookie)\n\t\t\tres->data.custom_data.cookie = mono_string_to_utf8 (minfo->mcookie);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nMonoReflectionMarshal*\nmono_reflection_marshal_from_marshal_spec (MonoDomain *domain, MonoClass *klass,\n\t\t\t\t\t\t\t\t\t\t   MonoMarshalSpec *spec)\n{\n\tstatic MonoClass *System_Reflection_Emit_UnmanagedMarshalClass;\n\tMonoReflectionMarshal *minfo;\n\tMonoType *mtype;\n\n\tif (!System_Reflection_Emit_UnmanagedMarshalClass) {\n\t\tSystem_Reflection_Emit_UnmanagedMarshalClass = mono_class_from_name (\n\t\t   mono_defaults.corlib, \"System.Reflection.Emit\", \"UnmanagedMarshal\");\n\t\tg_assert (System_Reflection_Emit_UnmanagedMarshalClass);\n\t}\n\n\tminfo = (MonoReflectionMarshal*)mono_object_new (domain, System_Reflection_Emit_UnmanagedMarshalClass);\n\tminfo->type = spec->native;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tminfo->eltype = spec->data.array_data.elem_type;\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tminfo->param_num = spec->data.array_data.param_num;\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (spec->data.custom_data.custom_name) {\n\t\t\tmtype = mono_reflection_type_from_name (spec->data.custom_data.custom_name, klass->image);\n\t\t\tif (mtype)\n\t\t\t\tMONO_OBJECT_SETREF (minfo, marshaltyperef, mono_type_get_object (domain, mtype));\n\n\t\t\tMONO_OBJECT_SETREF (minfo, marshaltype, mono_string_new (domain, spec->data.custom_data.custom_name));\n\t\t}\n\t\tif (spec->data.custom_data.cookie)\n\t\t\tMONO_OBJECT_SETREF (minfo, mcookie, mono_string_new (domain, spec->data.custom_data.cookie));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn minfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoMethod*\nreflection_methodbuilder_to_mono_method (MonoClass *klass,\n\t\t\t\t\t ReflectionMethodBuilder *rmb,\n\t\t\t\t\t MonoMethodSignature *sig)\n{\n\tMonoError error;\n\tMonoMethod *m;\n\tMonoMethodNormal *pm;\n\tMonoMarshalSpec **specs;\n\tMonoReflectionMethodAux *method_aux;\n\tMonoImage *image;\n\tgboolean dynamic;\n\tint i;\n\n\tmono_error_init (&error);\n\t/*\n\t * Methods created using a MethodBuilder should have their memory allocated\n\t * inside the image mempool, while dynamic methods should have their memory\n\t * malloc'd.\n\t */\n\tdynamic = rmb->refs != NULL;\n\timage = dynamic ? NULL : klass->image;\n\n\tif (!dynamic)\n\t\tg_assert (!klass->generic_class);\n\n\tmono_loader_lock ();\n\n\tif ((rmb->attrs & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(rmb->iattrs & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodPInvoke, 1);\n\telse if (rmb->refs)\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodWrapper, 1);\n\telse\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodNormal, 1);\n\n\tpm = (MonoMethodNormal*)m;\n\n\tm->dynamic = dynamic;\n\tm->slot = -1;\n\tm->flags = rmb->attrs;\n\tm->iflags = rmb->iattrs;\n\tm->name = mono_string_to_utf8_image (image, rmb->name, &error);\n\tg_assert (mono_error_ok (&error));\n\tm->klass = klass;\n\tm->signature = sig;\n\tm->skip_visibility = rmb->skip_visibility;\n\tif (rmb->table_idx)\n\t\tm->token = MONO_TOKEN_METHOD_DEF | (*rmb->table_idx);\n\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (klass == mono_defaults.string_class && !strcmp (m->name, \".ctor\"))\n\t\t\tm->string_ctor = 1;\n\n\t\tm->signature->pinvoke = 1;\n\t} else if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tm->signature->pinvoke = 1;\n\n\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\n\t\tmethod_aux->dllentry = rmb->dllentry ? mono_string_to_utf8_image (image, rmb->dllentry, &error) : image_strdup (image, m->name);\n\t\tg_assert (mono_error_ok (&error));\n\t\tmethod_aux->dll = mono_string_to_utf8_image (image, rmb->dll, &error);\n\t\tg_assert (mono_error_ok (&error));\n\t\t\n\t\t((MonoMethodPInvoke*)m)->piflags = (rmb->native_cc << 8) | (rmb->charset ? (rmb->charset - 1) * 2 : 0) | rmb->extra_flags;\n\n\t\tif (klass->image->dynamic)\n\t\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\t\tmono_loader_unlock ();\n\n\t\treturn m;\n\t} else if (!(m->flags & METHOD_ATTRIBUTE_ABSTRACT) &&\n\t\t\t   !(m->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME)) {\n\t\tMonoMethodHeader *header;\n\t\tguint32 code_size;\n\t\tgint32 max_stack, i;\n\t\tgint32 num_locals = 0;\n\t\tgint32 num_clauses = 0;\n\t\tguint8 *code;\n\n\t\tif (rmb->ilgen) {\n\t\t\tcode = mono_array_addr (rmb->ilgen->code, guint8, 0);\n\t\t\tcode_size = rmb->ilgen->code_len;\n\t\t\tmax_stack = rmb->ilgen->max_stack;\n\t\t\tnum_locals = rmb->ilgen->locals ? mono_array_length (rmb->ilgen->locals) : 0;\n\t\t\tif (rmb->ilgen->ex_handlers)\n\t\t\t\tnum_clauses = method_count_clauses (rmb->ilgen);\n\t\t} else {\n\t\t\tif (rmb->code) {\n\t\t\t\tcode = mono_array_addr (rmb->code, guint8, 0);\n\t\t\t\tcode_size = mono_array_length (rmb->code);\n\t\t\t\t/* we probably need to run a verifier on the code... */\n\t\t\t\tmax_stack = 8; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode = NULL;\n\t\t\t\tcode_size = 0;\n\t\t\t\tmax_stack = 8;\n\t\t\t}\n\t\t}\n\n\t\theader = image_g_malloc0 (image, MONO_SIZEOF_METHOD_HEADER + num_locals * sizeof (MonoType*));\n\t\theader->code_size = code_size;\n\t\theader->code = image_g_malloc (image, code_size);\n\t\tmemcpy ((char*)header->code, code, code_size);\n\t\theader->max_stack = max_stack;\n\t\theader->init_locals = rmb->init_locals;\n\t\theader->num_locals = num_locals;\n\n\t\tfor (i = 0; i < num_locals; ++i) {\n\t\t\tMonoReflectionLocalBuilder *lb = \n\t\t\t\tmono_array_get (rmb->ilgen->locals, MonoReflectionLocalBuilder*, i);\n\n\t\t\theader->locals [i] = image_g_new0 (image, MonoType, 1);\n\t\t\tmemcpy (header->locals [i], mono_reflection_type_get_handle ((MonoReflectionType*)lb->type), MONO_SIZEOF_TYPE);\n\t\t}\n\n\t\theader->num_clauses = num_clauses;\n\t\tif (num_clauses) {\n\t\t\theader->clauses = method_encode_clauses (image, (MonoDynamicImage*)klass->image,\n\t\t\t\t rmb->ilgen, num_clauses);\n\t\t}\n\n\t\tpm->header = header;\n\t}\n\n\tif (rmb->generic_params) {\n\t\tint count = mono_array_length (rmb->generic_params);\n\t\tMonoGenericContainer *container;\n\n\t\tcontainer = rmb->generic_container;\n\t\tif (container) {\n\t\t\tm->is_generic = TRUE;\n\t\t\tmono_method_set_generic_container (m, container);\n\t\t}\n\t\tcontainer->type_argc = count;\n\t\tcontainer->type_params = image_g_new0 (image, MonoGenericParamFull, count);\n\t\tcontainer->owner.method = m;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tMonoReflectionGenericParam *gp =\n\t\t\t\tmono_array_get (rmb->generic_params, MonoReflectionGenericParam*, i);\n\t\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gp)->data.generic_param;\n\t\t\tcontainer->type_params [i] = *param;\n\t\t}\n\n\t\tif (klass->generic_container) {\n\t\t\tcontainer->parent = klass->generic_container;\n\t\t\tcontainer->context.class_inst = klass->generic_container->context.class_inst;\n\t\t}\n\t\tcontainer->context.method_inst = mono_get_shared_generic_inst (container);\n\t}\n\n\tif (rmb->refs) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)m;\n\t\tint i;\n\t\tvoid **data;\n\n\t\tm->wrapper_type = MONO_WRAPPER_DYNAMIC_METHOD;\n\n\t\tmw->method_data = data = image_g_new (image, gpointer, rmb->nrefs + 1);\n\t\tdata [0] = GUINT_TO_POINTER (rmb->nrefs);\n\t\tfor (i = 0; i < rmb->nrefs; ++i)\n\t\t\tdata [i + 1] = rmb->refs [i];\n\t}\n\n\tmethod_aux = NULL;\n\n\t/* Parameter info */\n\tif (rmb->pinfo) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_names = image_g_new0 (image, char *, mono_method_signature (m)->param_count + 1);\n\t\tfor (i = 0; i <= m->signature->param_count; ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif ((i > 0) && (pb->attrs)) {\n\t\t\t\t\t/* Make a copy since it might point to a shared type structure */\n\t\t\t\t\tm->signature->params [i - 1] = mono_metadata_type_dup (klass->image, m->signature->params [i - 1]);\n\t\t\t\t\tm->signature->params [i - 1]->attrs = pb->attrs;\n\t\t\t\t}\n\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tMonoDynamicImage *assembly;\n\t\t\t\t\tguint32 idx, def_type, len;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tconst char *p2;\n\n\t\t\t\t\tif (!method_aux->param_defaults) {\n\t\t\t\t\t\tmethod_aux->param_defaults = image_g_new0 (image, guint8*, m->signature->param_count + 1);\n\t\t\t\t\t\tmethod_aux->param_default_types = image_g_new0 (image, guint32, m->signature->param_count + 1);\n\t\t\t\t\t}\n\t\t\t\t\tassembly = (MonoDynamicImage*)klass->image;\n\t\t\t\t\tidx = encode_constant (assembly, pb->def_value, &def_type);\n\t\t\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\t\t\tp = assembly->blob.data + idx;\n\t\t\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\t\t\tlen += p2 - p;\n\t\t\t\t\tmethod_aux->param_defaults [i] = image_g_malloc (image, len);\n\t\t\t\t\tmethod_aux->param_default_types [i] = def_type;\n\t\t\t\t\tmemcpy ((gpointer)method_aux->param_defaults [i], p, len);\n\t\t\t\t}\n\n\t\t\t\tif (pb->name) {\n\t\t\t\t\tmethod_aux->param_names [i] = mono_string_to_utf8_image (image, pb->name, &error);\n\t\t\t\t\tg_assert (mono_error_ok (&error));\n\t\t\t\t}\n\t\t\t\tif (pb->cattrs) {\n\t\t\t\t\tif (!method_aux->param_cattr)\n\t\t\t\t\t\tmethod_aux->param_cattr = image_g_new0 (image, MonoCustomAttrInfo*, m->signature->param_count + 1);\n\t\t\t\t\tmethod_aux->param_cattr [i] = mono_custom_attrs_from_builders (image, klass->image, pb->cattrs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Parameter marshalling */\n\tspecs = NULL;\n\tif (rmb->pinfo)\t\t\n\t\tfor (i = 0; i < mono_array_length (rmb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tif (specs == NULL)\n\t\t\t\t\t\tspecs = image_g_new0 (image, MonoMarshalSpec*, sig->param_count + 1);\n\t\t\t\t\tspecs [pb->position] = \n\t\t\t\t\t\tmono_marshal_spec_from_builder (image, klass->image->assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (specs != NULL) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_marshall = specs;\n\t}\n\n\tif (klass->image->dynamic && method_aux)\n\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\tmono_loader_unlock ();\n\n\treturn m;\n}\t\n\nstatic MonoMethod*\nctorbuilder_to_mono_method (MonoClass *klass, MonoReflectionCtorBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = ctor_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\n\treturn mb->mhandle;\n}\n\nstatic MonoMethod*\nmethodbuilder_to_mono_method (MonoClass *klass, MonoReflectionMethodBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = method_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\treturn mb->mhandle;\n}\n\nstatic MonoClassField*\nfieldbuilder_to_mono_class_field (MonoClass *klass, MonoReflectionFieldBuilder* fb)\n{\n\tMonoClassField *field;\n\tMonoType *custom;\n\n\tfield = g_new0 (MonoClassField, 1);\n\n\tfield->name = mono_string_to_utf8 (fb->name);\n\tif (fb->attrs || fb->modreq || fb->modopt) {\n\t\tfield->type = mono_metadata_type_dup (NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\tfield->type->attrs = fb->attrs;\n\n\t\tg_assert (klass->image->dynamic);\n\t\tcustom = add_custom_modifiers ((MonoDynamicImage*)klass->image, field->type, fb->modreq, fb->modopt);\n\t\tg_free (field->type);\n\t\tfield->type = custom;\n\t} else {\n\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t}\n\tif (fb->offset != -1)\n\t\tfield->offset = fb->offset;\n\tfield->parent = klass;\n\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t// FIXME: Can't store fb->def_value/RVA, is it needed for field_on_insts ?\n\n\treturn field;\n}\n#endif\n\nMonoType*\nmono_reflection_bind_generic_parameters (MonoReflectionType *type, int type_argc, MonoType **types)\n{\n\tMonoClass *klass;\n\tMonoReflectionTypeBuilder *tb = NULL;\n\tgboolean is_dynamic = FALSE;\n\tMonoDomain *domain;\n\tMonoClass *geninst;\n\n\tmono_loader_lock ();\n\n\tdomain = mono_object_domain (type);\n\n\tif (!strcmp (((MonoObject *) type)->vtable->klass->name, \"TypeBuilder\")) {\n\t\ttb = (MonoReflectionTypeBuilder *) type;\n\n\t\tis_dynamic = TRUE;\n\t} else if (!strcmp (((MonoObject *) type)->vtable->klass->name, \"MonoGenericClass\")) {\n\t\tMonoReflectionGenericClass *rgi = (MonoReflectionGenericClass *) type;\n\n\t\ttb = rgi->generic_type;\n\t\tis_dynamic = TRUE;\n\t}\n\n\t/* FIXME: fix the CreateGenericParameters protocol to avoid the two stage setup of TypeBuilders */\n\tif (tb && tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (type));\n\tif (!klass->generic_container) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (klass->wastypebuilder) {\n\t\ttb = (MonoReflectionTypeBuilder *) klass->reflection_info;\n\n\t\tis_dynamic = TRUE;\n\t}\n\n\tmono_loader_unlock ();\n\n\tgeninst = mono_class_bind_generic_parameters (klass, type_argc, types, is_dynamic);\n\n\treturn &geninst->byval_arg;\n}\n\nMonoClass*\nmono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic)\n{\n\tMonoGenericClass *gclass;\n\tMonoGenericInst *inst;\n\n\tg_assert (klass->generic_container);\n\n\tinst = mono_metadata_get_generic_inst (type_argc, types);\n\tgclass = mono_metadata_lookup_generic_class (klass, inst, is_dynamic);\n\n\treturn mono_generic_class_get_class (gclass);\n}\n\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\n\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic MonoMethod *\ninflate_mono_method (MonoClass *klass, MonoMethod *method, MonoObject *obj)\n{\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext *context;\n\tint i;\n\n\t/*\n\t * With generic code sharing the klass might not be inflated.\n\t * This can happen because classes inflated with their own\n\t * type arguments are \"normalized\" to the uninflated class.\n\t */\n\tif (!klass->generic_class)\n\t\treturn method;\n\n\tcontext = mono_class_get_context (klass);\n\n\tif (klass->method.count) {\n\t\t/* Find the already created inflated method */\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tg_assert (klass->methods [i]->is_inflated);\n\t\t\tif (((MonoMethodInflated*)klass->methods [i])->declaring == method)\n\t\t\t\tbreak;\n\t\t}\n\t\tg_assert (i < klass->method.count);\n\t\timethod = (MonoMethodInflated*)klass->methods [i];\n\t} else {\n\t\timethod = (MonoMethodInflated *) mono_class_inflate_generic_method_full (method, klass, context);\n\t}\n\n\tif (method->is_generic && method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, obj);\n\t\tmono_loader_unlock ();\n\t}\n\treturn (MonoMethod *) imethod;\n}\n\nstatic MonoMethod *\ninflate_method (MonoReflectionGenericClass *type, MonoObject *obj)\n{\n\tMonoMethod *method;\n\tMonoClass *gklass;\n\n\tgklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type->generic_type));\n\n\tif (!strcmp (obj->vtable->klass->name, \"MethodBuilder\"))\n\t\tif (((MonoReflectionMethodBuilder*)obj)->mhandle)\n\t\t\tmethod = ((MonoReflectionMethodBuilder*)obj)->mhandle;\n\t\telse\n\t\t\tmethod = methodbuilder_to_mono_method (gklass, (MonoReflectionMethodBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"ConstructorBuilder\"))\n\t\tmethod = ctorbuilder_to_mono_method (gklass, (MonoReflectionCtorBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"MonoMethod\") || !strcmp (obj->vtable->klass->name, \"MonoCMethod\"))\n\t\tmethod = ((MonoReflectionMethod *) obj)->method;\n\telse {\n\t\tmethod = NULL; /* prevent compiler warning */\n\t\tg_error (\"can't handle type %s\", obj->vtable->klass->name);\n\t}\n\n\treturn inflate_mono_method (mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type)), method, obj);\n}\n\n/*TODO avoid saving custom attrs for generic classes as it's enough to have them on the generic type definition.*/\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoClass *klass, *gklass;\n\tMonoType *gtype;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tgtype = mono_reflection_type_get_handle ((MonoReflectionType*)type);\n\tklass = mono_class_from_mono_type (gtype);\n\tg_assert (gtype->type == MONO_TYPE_GENERICINST);\n\tgclass = gtype->data.generic_class;\n\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tif (dgclass->initialized)\n\t\treturn;\n\n\tgklass = gclass->container_class;\n\tmono_class_init (gklass);\n\n\tdgclass->count_methods = methods ? mono_array_length (methods) : 0;\n\tdgclass->count_ctors = ctors ? mono_array_length (ctors) : 0;\n\tdgclass->count_fields = fields ? mono_array_length (fields) : 0;\n\tdgclass->count_properties = properties ? mono_array_length (properties) : 0;\n\tdgclass->count_events = events ? mono_array_length (events) : 0;\n\n\tdgclass->methods = g_new0 (MonoMethod *, dgclass->count_methods);\n\tdgclass->ctors = g_new0 (MonoMethod *, dgclass->count_ctors);\n\tdgclass->fields = g_new0 (MonoClassField, dgclass->count_fields);\n\tdgclass->properties = g_new0 (MonoProperty, dgclass->count_properties);\n\tdgclass->events = g_new0 (MonoEvent, dgclass->count_events);\n\tdgclass->field_objects = g_new0 (MonoObject*, dgclass->count_fields);\n\tdgclass->field_generic_types = g_new0 (MonoType*, dgclass->count_fields);\n\n\tfor (i = 0; i < dgclass->count_methods; i++) {\n\t\tMonoObject *obj = mono_array_get (methods, gpointer, i);\n\n\t\tdgclass->methods [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_ctors; i++) {\n\t\tMonoObject *obj = mono_array_get (ctors, gpointer, i);\n\n\t\tdgclass->ctors [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_fields; i++) {\n\t\tMonoObject *obj = mono_array_get (fields, gpointer, i);\n\t\tMonoClassField *field, *inflated_field = NULL;\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"FieldBuilder\"))\n\t\t\tinflated_field = field = fieldbuilder_to_mono_class_field (klass, (MonoReflectionFieldBuilder *) obj);\n\t\telse if (!strcmp (obj->vtable->klass->name, \"MonoField\"))\n\t\t\tfield = ((MonoReflectionField *) obj)->field;\n\t\telse {\n\t\t\tfield = NULL; /* prevent compiler warning */\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tdgclass->fields [i] = *field;\n\t\tdgclass->fields [i].parent = klass;\n\t\tdgclass->fields [i].type = mono_class_inflate_generic_type (\n\t\t\tfield->type, mono_generic_class_get_context ((MonoGenericClass *) dgclass));\n\t\tdgclass->field_generic_types [i] = field->type;\n\t\tMOVING_GC_REGISTER (&dgclass->field_objects [i]);\n\t\tdgclass->field_objects [i] = obj;\n\n\t\tif (inflated_field) {\n\t\t\tg_free (inflated_field);\n\t\t} else {\n\t\t\tdgclass->fields [i].name = g_strdup (dgclass->fields [i].name);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dgclass->count_properties; i++) {\n\t\tMonoObject *obj = mono_array_get (properties, gpointer, i);\n\t\tMonoProperty *property = &dgclass->properties [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"PropertyBuilder\")) {\n\t\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *) obj;\n\n\t\t\tproperty->parent = klass;\n\t\t\tproperty->attrs = pb->attrs;\n\t\t\tproperty->name = mono_string_to_utf8 (pb->name);\n\t\t\tif (pb->get_method)\n\t\t\t\tproperty->get = inflate_method (type, (MonoObject *) pb->get_method);\n\t\t\tif (pb->set_method)\n\t\t\t\tproperty->set = inflate_method (type, (MonoObject *) pb->set_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoProperty\")) {\n\t\t\t*property = *((MonoReflectionProperty *) obj)->property;\n\t\t\tproperty->name = g_strdup (property->name);\n\n\t\t\tif (property->get)\n\t\t\t\tproperty->get = inflate_mono_method (klass, property->get, NULL);\n\t\t\tif (property->set)\n\t\t\t\tproperty->set = inflate_mono_method (klass, property->set, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tfor (i = 0; i < dgclass->count_events; i++) {\n\t\tMonoObject *obj = mono_array_get (events, gpointer, i);\n\t\tMonoEvent *event = &dgclass->events [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"EventBuilder\")) {\n\t\t\tMonoReflectionEventBuilder *eb = (MonoReflectionEventBuilder *) obj;\n\n\t\t\tevent->parent = klass;\n\t\t\tevent->attrs = eb->attrs;\n\t\t\tevent->name = mono_string_to_utf8 (eb->name);\n\t\t\tif (eb->add_method)\n\t\t\t\tevent->add = inflate_method (type, (MonoObject *) eb->add_method);\n\t\t\tif (eb->remove_method)\n\t\t\t\tevent->remove = inflate_method (type, (MonoObject *) eb->remove_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoEvent\")) {\n\t\t\t*event = *((MonoReflectionMonoEvent *) obj)->event;\n\t\t\tevent->name = g_strdup (event->name);\n\n\t\t\tif (event->add)\n\t\t\t\tevent->add = inflate_mono_method (klass, event->add, NULL);\n\t\t\tif (event->remove)\n\t\t\t\tevent->remove = inflate_mono_method (klass, event->remove, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tdgclass->initialized = TRUE;\n}\n\nstatic void\nensure_generic_class_runtime_vtable (MonoClass *klass)\n{\n\tMonoClass *gklass = klass->generic_class->container_class;\n\tint i;\n\n\tif (klass->wastypebuilder)\n\t\treturn;\n\n\tensure_runtime_vtable (gklass);\n\n\tklass->method.count = gklass->method.count;\n\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * (klass->method.count + 1));\n\n\tfor (i = 0; i < klass->method.count; i++) {\n\t\tklass->methods [i] = mono_class_inflate_generic_method_full (\n\t\t\tgklass->methods [i], klass, mono_class_get_context (klass));\n\t}\n\n\tklass->interface_count = gklass->interface_count;\n\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\tMonoType *iface_type = mono_class_inflate_generic_type (&gklass->interfaces [i]->byval_arg, mono_class_get_context (klass));\n\t\tklass->interfaces [i] = mono_class_from_mono_type (iface_type);\n\t\tmono_metadata_free_type (iface_type);\n\n\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t}\n\tklass->interfaces_inited = 1;\n\n\t/*We can only finish with this klass once it's parent has as well*/\n\tif (gklass->wastypebuilder)\n\t\tklass->wastypebuilder = TRUE;\n\treturn;\n}\n\nstatic void\nensure_runtime_vtable (MonoClass *klass)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tint i, num, j;\n\n\tif (!klass->image->dynamic || (!tb && !klass->generic_class) || klass->wastypebuilder)\n\t\treturn;\n\tif (klass->parent)\n\t\tensure_runtime_vtable (klass->parent);\n\n\tif (tb) {\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tnum += tb->num_methods;\n\t\tklass->method.count = num;\n\t\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * num);\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [i] = ctorbuilder_to_mono_method (klass, mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i));\n\t\tnum = tb->num_methods;\n\t\tj = i;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [j++] = methodbuilder_to_mono_method (klass, mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i));\n\t\n\t\tif (tb->interfaces) {\n\t\t\tklass->interface_count = mono_array_length (tb->interfaces);\n\t\t\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\t\t\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\t\t\tMonoType *iface = mono_type_array_get_and_resolve (tb->interfaces, i);\n\t\t\t\tklass->interfaces [i] = mono_class_from_mono_type (iface);\n\t\t\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t\t\t}\n\t\t\tklass->interfaces_inited = 1;\n\t\t}\n\t} else if (klass->generic_class){\n\t\tensure_generic_class_runtime_vtable (klass);\n\t}\n\n\tif (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tfor (i = 0; i < klass->method.count; ++i)\n\t\t\tklass->methods [i]->slot = i;\n\t\t\n\t\tmono_class_setup_interface_offsets (klass);\n\t\tmono_class_setup_interface_id (klass);\n\t}\n\n\t/*\n\t * The generic vtable is needed even if image->run is not set since some\n\t * runtime code like ves_icall_Type_GetMethodsByName depends on \n\t * method->slot being defined.\n\t */\n\n\t/* \n\t * tb->methods could not be freed since it is used for determining \n\t * overrides during dynamic vtable construction.\n\t */\n}\n\nstatic MonoMethod*\nmono_reflection_method_get_handle (MonoObject *method)\n{\n\tMonoClass *class = mono_object_class (method);\n\tif (is_sr_mono_method (class) || is_sr_mono_generic_method (class)) {\n\t\tMonoReflectionMethod *sr_method = (MonoReflectionMethod*)method;\n\t\treturn sr_method->method;\n\t}\n\tif (is_sre_method_builder (class)) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)method;\n\t\treturn mb->mhandle;\n\t}\n\tif (is_sre_method_on_tb_inst (class)) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)method;\n\t\tMonoMethod *result;\n\t\t/*FIXME move this to a proper method and unify with resolve_object*/\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tMonoMethod *mono_method;\n\n\t\t\tif (is_sre_method_builder (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethodBuilder *)m->mb)->mhandle;\n \t\t\telse if (is_sr_mono_method (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethod *)m->mb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"resolve_object:: can't handle a MTBI with base_method of type %s\", mono_type_get_full_name (mono_object_class (m->mb)));\n\n\t\t\tresult = inflate_mono_method (inflated_klass, mono_method, (MonoObject*)m->mb);\n\t\t}\n\t\treturn result;\n\t}\n\n\tg_error (\"Can't handle methods of type %s:%s\", class->name_space, class->name);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\tMonoReflectionTypeBuilder *tb;\n\tint i, onum;\n\n\t*overrides = NULL;\n\t*num_overrides = 0;\n\n\tg_assert (klass->image->dynamic);\n\n\tif (!klass->reflection_info)\n\t\treturn;\n\n\tg_assert (strcmp (((MonoObject*)klass->reflection_info)->vtable->klass->name, \"TypeBuilder\") == 0);\n\n\ttb = (MonoReflectionTypeBuilder*)klass->reflection_info;\n\n\tonum = 0;\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method)\n\t\t\t\tonum ++;\n\t\t}\n\t}\n\n\tif (onum) {\n\t\t*overrides = g_new0 (MonoMethod*, onum * 2);\n\n\t\tonum = 0;\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method) {\n\t\t\t\t(*overrides) [onum * 2] = mono_reflection_method_get_handle ((MonoObject *)mb->override_method);\n\t\t\t\t(*overrides) [onum * 2 + 1] = mb->mhandle;\n\n\t\t\t\tg_assert (mb->mhandle);\n\n\t\t\t\tonum ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*num_overrides = onum;\n}\n\nstatic void\ntypebuilder_setup_fields (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionFieldBuilder *fb;\n\tMonoClassField *field;\n\tMonoImage *image = klass->image;\n\tconst char *p, *p2;\n\tint i;\n\tguint32 len, idx, real_size = 0;\n\n\tklass->field.count = tb->num_fields;\n\tklass->field.first = 0;\n\n\tmono_error_init (error);\n\n\tif (tb->class_size) {\n\t\tg_assert ((tb->packing_size & 0xfffffff0) == 0);\n\t\tklass->packing_size = tb->packing_size;\n\t\treal_size = klass->instance_size + tb->class_size;\n\t}\n\n\tif (!klass->field.count) {\n\t\tklass->instance_size = MAX (klass->instance_size, real_size);\n\t\treturn;\n\t}\n\t\n\tklass->fields = image_g_new0 (image, MonoClassField, klass->field.count);\n\tmono_class_alloc_ext (klass);\n\tklass->ext->field_def_values = image_g_new0 (image, MonoFieldDefaultValue, klass->field.count);\n\t/*\n\tThis is, guess what, a hack.\n\tThe issue is that the runtime doesn't know how to setup the fields of a typebuider and crash.\n\tOn the static path no field class is resolved, only types are built. This is the right thing to do\n\tbut we suck.\n\tSetting size_inited is harmless because we're doing the same job as mono_class_setup_fields anyway.\n\t*/\n\tklass->size_inited = 1;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tfb = mono_array_get (tb->fields, gpointer, i);\n\t\tfield = &klass->fields [i];\n\t\tfield->name = mono_string_to_utf8_image (image, fb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (fb->attrs) {\n\t\t\tfield->type = mono_metadata_type_dup (klass->image, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\t\tfield->type->attrs = fb->attrs;\n\t\t} else {\n\t\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\t}\n\t\tif ((fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) && fb->rva_data)\n\t\t\tklass->ext->field_def_values [i].data = mono_array_addr (fb->rva_data, char, 0);\n\t\tif (fb->offset != -1)\n\t\t\tfield->offset = fb->offset;\n\t\tfield->parent = klass;\n\t\tfb->handle = field;\n\t\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t\tif (fb->def_value) {\n\t\t\tMonoDynamicImage *assembly = (MonoDynamicImage*)klass->image;\n\t\t\tfield->type->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\t\t\tidx = encode_constant (assembly, fb->def_value, &klass->ext->field_def_values [i].def_type);\n\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\tp = assembly->blob.data + idx;\n\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\tlen += p2 - p;\n\t\t\tklass->ext->field_def_values [i].data = mono_image_alloc (image, len);\n\t\t\tmemcpy ((gpointer)klass->ext->field_def_values [i].data, p, len);\n\t\t}\n\t}\n\n\tklass->instance_size = MAX (klass->instance_size, real_size);\n\tmono_class_layout_fields (klass);\n}\n\nstatic void\ntypebuilder_setup_properties (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionPropertyBuilder *pb;\n\tMonoImage *image = klass->image;\n\tMonoProperty *properties;\n\tint i;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->property.count = tb->properties ? mono_array_length (tb->properties) : 0;\n\tklass->ext->property.first = 0;\n\n\tproperties = image_g_new0 (image, MonoProperty, klass->ext->property.count);\n\tklass->ext->properties = properties;\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\tproperties [i].parent = klass;\n\t\tproperties [i].attrs = pb->attrs;\n\t\tproperties [i].name = mono_string_to_utf8_image (image, pb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (pb->get_method)\n\t\t\tproperties [i].get = pb->get_method->mhandle;\n\t\tif (pb->set_method)\n\t\t\tproperties [i].set = pb->set_method->mhandle;\n\n\t\tmono_save_custom_attrs (klass->image, &properties [i], pb->cattrs);\n\t}\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tMonoEvent *event = g_new0 (MonoEvent, 1);\n\tMonoClass *klass;\n\tint j;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tevent->parent = klass;\n\tevent->attrs = eb->attrs;\n\tevent->name = mono_string_to_utf8 (eb->name);\n\tif (eb->add_method)\n\t\tevent->add = eb->add_method->mhandle;\n\tif (eb->remove_method)\n\t\tevent->remove = eb->remove_method->mhandle;\n\tif (eb->raise_method)\n\t\tevent->raise = eb->raise_method->mhandle;\n\n\tif (eb->other_methods) {\n\t\tevent->other = g_new0 (MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\tevent->other [j] = mb->mhandle;\n\t\t}\n\t}\n\n\treturn mono_event_get_object (mono_object_domain (tb), klass, event);\n}\n\nstatic void\ntypebuilder_setup_events (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionEventBuilder *eb;\n\tMonoImage *image = klass->image;\n\tMonoEvent *events;\n\tint i, j;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->event.count = tb->events ? mono_array_length (tb->events) : 0;\n\tklass->ext->event.first = 0;\n\n\tevents = image_g_new0 (image, MonoEvent, klass->ext->event.count);\n\tklass->ext->events = events;\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\tevents [i].parent = klass;\n\t\tevents [i].attrs = eb->attrs;\n\t\tevents [i].name = mono_string_to_utf8_image (image, eb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (eb->add_method)\n\t\t\tevents [i].add = eb->add_method->mhandle;\n\t\tif (eb->remove_method)\n\t\t\tevents [i].remove = eb->remove_method->mhandle;\n\t\tif (eb->raise_method)\n\t\t\tevents [i].raise = eb->raise_method->mhandle;\n\n\t\tif (eb->other_methods) {\n\t\t\tevents [i].other = image_g_new0 (image, MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\t\tevents [i].other [j] = mb->mhandle;\n\t\t\t}\n\t\t}\n\t\tmono_save_custom_attrs (klass->image, &events [i], eb->cattrs);\n\t}\n}\n\nstatic gboolean\nremove_instantiations_of (gpointer key,\n\t\t\t\t\t\t  gpointer value,\n\t\t\t\t\t\t  gpointer user_data)\n{\n\tMonoType *type = (MonoType*)key;\n\tMonoClass *klass = (MonoClass*)user_data;\n\n\tif ((type->type == MONO_TYPE_GENERICINST) && (type->data.generic_class->container_class == klass))\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\nstatic void\ncheck_array_for_usertypes (MonoArray *arr)\n{\n\tint i;\n\n\tif (!arr)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (arr); ++i)\n\t\tRESOLVE_ARRAY_TYPE_ELEMENT (arr, i);\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass;\n\tMonoDomain* domain;\n\tMonoReflectionType* res;\n\tint i, j;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (tb);\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\t/*\n\t * Check for user defined Type subclasses.\n\t */\n\tRESOLVE_TYPE (tb->parent);\n\tcheck_array_for_usertypes (tb->interfaces);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < mono_array_length (tb->fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (tb->fields, gpointer, i);\n\t\t\tif (fb) {\n\t\t\t\tRESOLVE_TYPE (fb->type);\n\t\t\t\tcheck_array_for_usertypes (fb->modreq);\n\t\t\t\tcheck_array_for_usertypes (fb->modopt);\n\t\t\t\tif (fb->marshal_info && fb->marshal_info->marshaltyperef)\n\t\t\t\t\tRESOLVE_TYPE (fb->marshal_info->marshaltyperef);\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->methods) {\n\t\tfor (i = 0; i < mono_array_length (tb->methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (tb->methods, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tRESOLVE_TYPE (mb->rtype);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modreq);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modopt);\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder *mb = mono_array_get (tb->ctors, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tmono_save_custom_attrs (klass->image, klass, tb->cattrs);\n\n\t/* \n\t * we need to lock the domain because the lock will be taken inside\n\t * So, we need to keep the locking order correct.\n\t */\n\tmono_loader_lock ();\n\tmono_domain_lock (domain);\n\tif (klass->wastypebuilder) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t}\n\t/*\n\t * Fields to set in klass:\n\t * the various flags: delegate/unicode/contextbound etc.\n\t */\n\tklass->flags = tb->attrs;\n\tklass->has_cctor = 1;\n\tklass->has_finalize = 1;\n\n#if 0\n\tif (!((MonoDynamicImage*)klass->image)->run) {\n\t\tif (klass->generic_container) {\n\t\t\t/* FIXME: The code below can't handle generic classes */\n\t\t\tklass->wastypebuilder = TRUE;\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_domain_unlock (domain);\n\t\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t\t}\n\t}\n#endif\n\n\t/* enums are done right away */\n\tif (!klass->enumtype)\n\t\tensure_runtime_vtable (klass);\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtb = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tklass->ext->nested_classes = g_list_prepend_image (klass->image, klass->ext->nested_classes, mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)subtb)));\n\t\t}\n\t}\n\n\tklass->nested_classes_inited = TRUE;\n\n\t/* fields and object layout */\n\tif (klass->parent) {\n\t\tif (!klass->parent->size_inited)\n\t\t\tmono_class_init (klass->parent);\n\t\tklass->instance_size = klass->parent->instance_size;\n\t\tklass->sizes.class_size = 0;\n\t\tklass->min_align = klass->parent->min_align;\n\t\t/* if the type has no fields we won't call the field_setup\n\t\t * routine which sets up klass->has_references.\n\t\t */\n\t\tklass->has_references |= klass->parent->has_references;\n\t} else {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->min_align = 1;\n\t}\n\n\t/* FIXME: handle packing_size and instance_size */\n\ttypebuilder_setup_fields (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\ttypebuilder_setup_properties (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\ttypebuilder_setup_events (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\tklass->wastypebuilder = TRUE;\n\n\t/* \n\t * If we are a generic TypeBuilder, there might be instantiations in the type cache\n\t * which have type System.Reflection.MonoGenericClass, but after the type is created, \n\t * we want to return normal System.MonoType objects, so clear these out from the cache.\n\t */\n\tif (domain->type_hash && klass->generic_container)\n\t\tmono_g_hash_table_foreach_remove (domain->type_hash, remove_instantiations_of, klass);\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\n\tif (klass->enumtype && !mono_class_is_valid_enum (klass)) {\n\t\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\tmono_raise_exception (mono_get_exception_type_load (tb->name, NULL));\n\t}\n\n\tres = mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\tg_assert (res != (MonoReflectionType*)tb);\n\n\treturn res;\n\nfailure:\n\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\tklass->wastypebuilder = TRUE;\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tMonoGenericParamFull *param;\n\tMonoImage *image;\n\tMonoClass *pklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tparam = g_new0 (MonoGenericParamFull, 1);\n\n\tif (gparam->mbuilder) {\n\t\tif (!gparam->mbuilder->generic_container) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)gparam->mbuilder->type;\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\t\tgparam->mbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->mbuilder->generic_container->is_method = TRUE;\n\t\t\t/* \n\t\t\t * Cannot set owner.method, since the MonoMethod is not created yet.\n\t\t\t * Set the image field instead, so type_in_image () works.\n\t\t\t */\n\t\t\tgparam->mbuilder->generic_container->image = klass->image;\n\t\t}\n\t\tparam->param.owner = gparam->mbuilder->generic_container;\n\t} else if (gparam->tbuilder) {\n\t\tif (!gparam->tbuilder->generic_container) {\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)gparam->tbuilder));\n\t\t\tgparam->tbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->tbuilder->generic_container->owner.klass = klass;\n\t\t}\n\t\tparam->param.owner = gparam->tbuilder->generic_container;\n\t}\n\n\tparam->info.name = mono_string_to_utf8 (gparam->name);\n\tparam->param.num = gparam->index;\n\n\timage = &gparam->tbuilder->module->dynamic_image->image;\n\tpklass = mono_class_from_generic_parameter ((MonoGenericParam *) param, image, gparam->mbuilder != NULL);\n\n\tgparam->type.type = &pklass->byval_arg;\n\n\tMOVING_GC_REGISTER (&pklass->reflection_info);\n\tpklass->reflection_info = gparam; /* FIXME: GC pin gparam */\n\tmono_image_lock (image);\n\timage->reflection_info_unregister_classes = g_slist_prepend (image->reflection_info_unregister_classes, pklass);\n\tmono_image_unlock (image);\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tMonoReflectionModuleBuilder *module = sig->module;\n\tMonoDynamicImage *assembly = module != NULL ? module->dynamic_image : NULL;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, na);\n\tif (assembly != NULL){\n\t\tfor (i = 0; i < na; ++i) {\n\t\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, type, &buf);\n\t\t}\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tMonoDynamicImage *assembly = sig->module->dynamic_image;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x06);\n\tfor (i = 0; i < na; ++i) {\n\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, type, &buf);\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tGSList *l;\n\tint i;\n\n\tsig = dynamic_method_to_signature (mb);\n\n\treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n\n\t/*\n\t * Resolve references.\n\t */\n\t/* \n\t * Every second entry in the refs array is reserved for storing handle_class,\n\t * which is needed by the ldtoken implementation in the JIT.\n\t */\n\trmb.nrefs = mb->nrefs;\n\trmb.refs = g_new0 (gpointer, mb->nrefs + 1);\n\tfor (i = 0; i < mb->nrefs; i += 2) {\n\t\tMonoClass *handle_class;\n\t\tgpointer ref;\n\t\tMonoObject *obj = mono_array_get (mb->refs, MonoObject*, i);\n\n\t\tif (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t\t/*\n\t\t\t * The referenced DynamicMethod should already be created by the managed\n\t\t\t * code, except in the case of circular references. In that case, we store\n\t\t\t * method in the refs array, and fix it up later when the referenced \n\t\t\t * DynamicMethod is created.\n\t\t\t */\n\t\t\tif (method->mhandle) {\n\t\t\t\tref = method->mhandle;\n\t\t\t} else {\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tref = method;\n\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tmethod->referenced_by = g_slist_append (method->referenced_by, mb);\n\t\t\t}\n\t\t\thandle_class = mono_defaults.methodhandle_class;\n\t\t} else {\n\t\t\tMonoException *ex = NULL;\n\t\t\tref = resolve_object (mb->module->image, obj, &handle_class, NULL);\n\t\t\tif (!ref)\n\t\t\t\tex = mono_get_exception_type_load (NULL, NULL);\n\t\t\telse if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\t\t\tex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);\n\n\t\t\tif (ex) {\n\t\t\t\tg_free (rmb.refs);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trmb.refs [i] = ref; /* FIXME: GC object stored in unmanaged memory (change also resolve_object() signature) */\n\t\trmb.refs [i + 1] = handle_class;\n\t}\t\t\n\n\tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\n\t/* Fix up refs entries pointing at us */\n\tfor (l = mb->referenced_by; l; l = l->next) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data;\n\t\tMonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle;\n\t\tgpointer *data;\n\t\t\n\t\tg_assert (method->mhandle);\n\n\t\tdata = (gpointer*)wrapper->method_data;\n\t\tfor (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) {\n\t\t\tif ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class))\n\t\t\t\tdata [i + 1] = mb->mhandle;\n\t\t}\n\t}\n\tg_slist_free (mb->referenced_by);\n\n\tg_free (rmb.refs);\n\n\t/* ilgen is no longer needed */\n\tmb->ilgen = NULL;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\nvoid\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);\n}\n\n/**\n * \n * mono_reflection_is_valid_dynamic_token:\n * \n * Returns TRUE if token is valid.\n * \n */\ngboolean\nmono_reflection_is_valid_dynamic_token (MonoDynamicImage *image, guint32 token)\n{\n\treturn mono_g_hash_table_lookup (image->tokens, GUINT_TO_POINTER (token)) != NULL;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/**\n * mono_reflection_lookup_dynamic_token:\n *\n * Finish the Builder object pointed to by TOKEN and return the corresponding\n * runtime structure. If HANDLE_CLASS is not NULL, it is set to the class required by \n * mono_ldtoken. If valid_token is TRUE, assert if it is not found in the token->object\n * mapping table.\n *\n * LOCKING: Take the loader lock\n */\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tMonoDynamicImage *assembly = (MonoDynamicImage*)image;\n\tMonoObject *obj;\n\tMonoClass *klass;\n\n\tmono_loader_lock ();\n\tobj = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tmono_loader_unlock ();\n\tif (!obj) {\n\t\tif (valid_token)\n\t\t\tg_error (\"Could not find required dynamic token 0x%08x\", token);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tif (!handle_class)\n\t\thandle_class = &klass;\n\treturn resolve_object (image, obj, handle_class, context);\n}\n\n/*\n * ensure_complete_type:\n *\n *   Ensure that KLASS is completed if it is a dynamic type, or references\n * dynamic types.\n */\nstatic void\nensure_complete_type (MonoClass *klass)\n{\n\tif (klass->image->dynamic && !klass->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\n\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t// Asserting here could break a lot of code\n\t\t//g_assert (klass->wastypebuilder);\n\t}\n\n\tif (klass->generic_class) {\n\t\tMonoGenericInst *inst = klass->generic_class->context.class_inst;\n\t\tint i;\n\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\tensure_complete_type (mono_class_from_mono_type (inst->type_argv [i]));\n\t\t}\n\t}\n}\n\nstatic gpointer\nresolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tgpointer result = NULL;\n\n\tif (strcmp (obj->vtable->klass->name, \"String\") == 0) {\n\t\tresult = mono_string_intern ((MonoString*)obj);\n\t\t*handle_class = mono_defaults.string_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (type, context);\n\t\t\tresult = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\t\t} else {\n\t\t\tresult = mono_class_from_mono_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericMethod\") == 0) {\n\t\tresult = ((MonoReflectionMethod*)obj)->method;\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tresult = mb->mhandle;\n\t\tif (!result) {\n\t\t\t/* Type is not yet created */\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t\t/*\n\t\t\t * Hopefully this has been filled in by calling CreateType() on the\n\t\t\t * TypeBuilder.\n\t\t\t */\n\t\t\t/*\n\t\t\t * TODO: This won't work if the application finishes another \n\t\t\t * TypeBuilder instance instead of this one.\n\t\t\t */\n\t\t\tresult = mb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\n\t\tresult = cb->mhandle;\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)cb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = cb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoField\") == 0) {\n\t\tMonoClassField *field = ((MonoReflectionField*)obj)->field;\n\n\t\tensure_complete_type (field->parent);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (&field->parent->byval_arg, context);\n\t\t\tMonoClass *class = mono_class_from_mono_type (inflated);\n\t\t\tMonoClassField *inflated_field;\n\t\t\tgpointer iter = NULL;\n\t\t\tmono_metadata_free_type (inflated);\n\t\t\twhile ((inflated_field = mono_class_get_fields (class, &iter))) {\n\t\t\t\tif (!strcmp (field->name, inflated_field->name))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg_assert (inflated_field && !strcmp (field->name, inflated_field->name));\n\t\t\tresult = inflated_field;\n\t\t} else {\n\t\t\tresult = field;\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tresult = fb->handle;\n\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)fb->typeb;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = fb->handle;\n\t\t}\n\n\t\tif (fb->handle && fb->handle->parent->generic_container) {\n\t\t\tMonoClass *klass = fb->handle->parent;\n\t\t\tMonoType *type = mono_class_inflate_generic_type (&klass->byval_arg, context);\n\t\t\tMonoClass *inflated = mono_class_from_mono_type (type);\n\n\t\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (fb->handle));\n\t\t\tg_assert (result);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)tb); \n\t\tMonoClass *klass;\n\n\t\tklass = type->data.klass;\n\t\tif (klass->wastypebuilder) {\n\t\t\t/* Already created */\n\t\t\tresult = klass;\n\t\t}\n\t\telse {\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = type->data.klass;\n\t\t\tg_assert (result);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *helper = (MonoReflectionSigHelper*)obj;\n\t\tMonoMethodSignature *sig;\n\t\tint nargs, i;\n\n\t\tif (helper->arguments)\n\t\t\tnargs = mono_array_length (helper->arguments);\n\t\telse\n\t\t\tnargs = 0;\n\n\t\tsig = mono_metadata_signature_alloc (image, nargs);\n\t\tsig->explicit_this = helper->call_conv & 64 ? 1 : 0;\n\t\tsig->hasthis = helper->call_conv & 32 ? 1 : 0;\n\n\t\tif (helper->unmanaged_call_conv) { /* unmanaged */\n\t\t\tsig->call_convention = helper->unmanaged_call_conv - 1;\n\t\t\tsig->pinvoke = TRUE;\n\t\t} else if (helper->call_conv & 0x02) {\n\t\t\tsig->call_convention = MONO_CALL_VARARG;\n\t\t} else {\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\t}\n\n\t\tsig->param_count = nargs;\n\t\t/* TODO: Copy type ? */\n\t\tsig->ret = helper->return_type->type;\n\t\tfor (i = 0; i < nargs; ++i)\n\t\t\tsig->params [i] = mono_type_array_get_and_resolve (helper->arguments, i);\n\n\t\tresult = sig;\n\t\t*handle_class = NULL;\n\t} else if (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t/* Already created by the managed code */\n\t\tg_assert (method->mhandle);\n\t\tresult = method->mhandle;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\tMonoClass *inflated;\n\t\tMonoType *type;\n\n\t\ttype = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)f->inst), context);\n\t\tinflated = mono_class_from_mono_type (type);\n\n\t\tg_assert (f->fb->handle);\n\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (f->fb->handle));\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)c->inst), context);\n\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\tg_assert (c->cb->mhandle);\n\t\tresult = inflate_mono_method (inflated_klass, c->cb->mhandle, (MonoObject*)c->cb);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)m->inst), context);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tg_assert (m->mb->mhandle);\n\t\t\tresult = inflate_mono_method (inflated_klass, m->mb->mhandle, (MonoObject*)m->mb);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod*)obj;\n\t\tMonoType *mtype;\n\t\tMonoClass *klass;\n\t\tMonoMethod *method;\n\t\tgpointer iter;\n\t\tchar *name;\n\n\t\tmtype = mono_reflection_type_get_handle (m->parent);\n\t\tklass = mono_class_from_mono_type (mtype);\n\n\t\t/* Find the method */\n\n\t\tname = mono_string_to_utf8 (m->name);\n\t\titer = NULL;\n\t\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\t\tif (!strcmp (method->name, name))\n\t\t\t\tbreak;\n\t\t}\n\t\tg_free (name);\n\n\t\t// FIXME:\n\t\tg_assert (method);\n\t\t// FIXME: Check parameters/return value etc. match\n\n\t\tresult = method;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (is_sre_array (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_byref (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_pointer (mono_object_get_class(obj))) {\n\t\tMonoReflectionType *ref_type = (MonoReflectionType *)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle (ref_type);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else {\n\t\tg_print (\"%s\\n\", obj->vtable->klass->name);\n\t\tg_assert_not_reached ();\n\t}\n\treturn result;\n}\n\n#else /* DISABLE_REFLECTION_EMIT */\n\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit, so System.Reflection.Emit is not supported.\");\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tg_assert_not_reached ();\n}\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n}\n\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\t*overrides = NULL;\n\t*num_overrides = 0;\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tg_assert_not_reached ();\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n}\n\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\treturn NULL;\n}\n\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tif (!ref)\n\t\treturn NULL;\n\treturn ref->type;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/* SECURITY_ACTION_* are defined in mono/metadata/tabledefs.h */\nconst static guint32 declsec_flags_map[] = {\n\t0x00000000,\t\t\t\t\t/* empty */\n\tMONO_DECLSEC_FLAG_REQUEST,\t\t\t/* SECURITY_ACTION_REQUEST\t\t\t(x01) */\n\tMONO_DECLSEC_FLAG_DEMAND,\t\t\t/* SECURITY_ACTION_DEMAND\t\t\t(x02) */\n\tMONO_DECLSEC_FLAG_ASSERT,\t\t\t/* SECURITY_ACTION_ASSERT\t\t\t(x03) */\n\tMONO_DECLSEC_FLAG_DENY,\t\t\t\t/* SECURITY_ACTION_DENY\t\t\t\t(x04) */\n\tMONO_DECLSEC_FLAG_PERMITONLY,\t\t\t/* SECURITY_ACTION_PERMITONLY\t\t\t(x05) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND,\t\t\t/* SECURITY_ACTION_LINKDEMAND\t\t\t(x06) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND,\t\t/* SECURITY_ACTION_INHERITANCEDEMAND\t\t(x07) */\n\tMONO_DECLSEC_FLAG_REQUEST_MINIMUM,\t\t/* SECURITY_ACTION_REQUEST_MINIMUM\t\t(x08) */\n\tMONO_DECLSEC_FLAG_REQUEST_OPTIONAL,\t\t/* SECURITY_ACTION_REQUEST_OPTIONAL\t\t(x09) */\n\tMONO_DECLSEC_FLAG_REQUEST_REFUSE,\t\t/* SECURITY_ACTION_REQUEST_REFUSE\t\t(x0A) */\n\tMONO_DECLSEC_FLAG_PREJIT_GRANT,\t\t\t/* SECURITY_ACTION_PREJIT_GRANT\t\t\t(x0B) */\n\tMONO_DECLSEC_FLAG_PREJIT_DENY,\t\t\t/* SECURITY_ACTION_PREJIT_DENY\t\t\t(x0C) */\n\tMONO_DECLSEC_FLAG_NONCAS_DEMAND,\t\t/* SECURITY_ACTION_NONCAS_DEMAND\t\t(x0D) */\n\tMONO_DECLSEC_FLAG_NONCAS_LINKDEMAND,\t\t/* SECURITY_ACTION_NONCAS_LINKDEMAND\t\t(x0E) */\n\tMONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND,\t/* SECURITY_ACTION_NONCAS_INHERITANCEDEMAND\t(x0F) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND_CHOICE,\t\t/* SECURITY_ACTION_LINKDEMAND_CHOICE\t\t(x10) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE,\t/* SECURITY_ACTION_INHERITANCEDEMAND_CHOICE\t(x11) */\n\tMONO_DECLSEC_FLAG_DEMAND_CHOICE,\t\t/* SECURITY_ACTION_DEMAND_CHOICE\t\t(x12) */\n};\n\n/*\n * Returns flags that includes all available security action associated to the handle.\n * @token: metadata token (either for a class or a method)\n * @image: image where resides the metadata.\n */\nstatic guint32\nmono_declsec_get_flags (MonoImage *image, guint32 token)\n{\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_DECLSECURITY];\n\tguint32 result = 0;\n\tguint32 action;\n\tint i;\n\n\t/* HasSecurity can be present for other, not specially encoded, attributes,\n\t   e.g. SuppressUnmanagedCodeSecurityAttribute */\n\tif (index < 0)\n\t\treturn 0;\n\n\tfor (i = index; i < t->rows; i++) {\n\t\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\tbreak;\n\n\t\taction = cols [MONO_DECL_SECURITY_ACTION];\n\t\tif ((action >= MONO_DECLSEC_ACTION_MIN) && (action <= MONO_DECLSEC_ACTION_MAX)) {\n\t\t\tresult |= declsec_flags_map [action];\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified method.\n *\n * @method: The method for which we want the declarative security flags.\n * Return the declarative security flags for the method (only).\n *\n * Note: To keep MonoMethod size down we do not cache the declarative security flags\n *       (except for the stack modifiers which are kept in the MonoJitInfo structure)\n */\nguint32\nmono_declsec_flags_from_method (MonoMethod *method)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\t/* FIXME: No cache (for the moment) */\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn mono_declsec_get_flags (method->klass->image, idx);\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified class.\n *\n * @klass: The class for which we want the declarative security flags.\n * Return the declarative security flags for the class.\n *\n * Note: We cache the flags inside the MonoClass structure as this will get \n *       called very often (at least for each method).\n */\nguint32\nmono_declsec_flags_from_class (MonoClass *klass)\n{\n\tif (klass->flags & TYPE_ATTRIBUTE_HAS_SECURITY) {\n\t\tif (!klass->ext || !klass->ext->declsec_flags) {\n\t\t\tguint32 idx;\n\n\t\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tmono_loader_lock ();\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tmono_loader_unlock ();\n\t\t\t/* we cache the flags on classes */\n\t\t\tklass->ext->declsec_flags = mono_declsec_get_flags (klass->image, idx);\n\t\t}\n\t\treturn klass->ext->declsec_flags;\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified assembly.\n *\n * @assembly: The assembly for which we want the declarative security flags.\n * Return the declarative security flags for the assembly.\n */\nguint32\nmono_declsec_flags_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\treturn mono_declsec_get_flags (assembly->image, idx);\n}\n\n\n/*\n * Fill actions for the specific index (which may either be an encoded class token or\n * an encoded method token) from the metadata image.\n * Returns TRUE if some actions requiring code generation are present, FALSE otherwise.\n */\nstatic MonoBoolean\nfill_actions_from_index (MonoImage *image, guint32 token, MonoDeclSecurityActions* actions,\n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tMonoBoolean result = FALSE;\n\tMonoTableInfo *t;\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tint i;\n\n\tt  = &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\treturn result;\n\n\t\t/* if present only replace (class) permissions with method permissions */\n\t\t/* if empty accept either class or method permissions */\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == id_std) {\n\t\t\tif (!actions->demand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demand.blob = (char*) (blob + 2);\n\t\t\t\tactions->demand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_noncas) {\n\t\t\tif (!actions->noncasdemand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->noncasdemand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->noncasdemand.blob = (char*) (blob + 2);\n\t\t\t\tactions->noncasdemand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_choice) {\n\t\t\tif (!actions->demandchoice.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demandchoice.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demandchoice.blob = (char*) (blob + 2);\n\t\t\t\tactions->demandchoice.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic MonoBoolean\nmono_declsec_get_class_demands_params (MonoClass *klass, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\treturn fill_actions_from_index (klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\nstatic MonoBoolean\nmono_declsec_get_method_demands_params (MonoMethod *method, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_method_get_index (method);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\treturn fill_actions_from_index (method->klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\n/*\n * Collect all actions (that requires to generate code in mini) assigned for\n * the specified method.\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_demands (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\tguint32 mask = MONO_DECLSEC_FLAG_DEMAND | MONO_DECLSEC_FLAG_NONCAS_DEMAND | \n\t\tMONO_DECLSEC_FLAG_DEMAND_CHOICE;\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult = mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & mask) {\n\t\tif (!result) {\n\t\t\tmono_class_init (method->klass);\n\t\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\t\t}\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* The boolean return value is used as a shortcut in case nothing needs to\n\t   be generated (e.g. LinkDemand[Choice] and InheritanceDemand[Choice]) */\n\treturn result;\n}\n\n\n/*\n * Collect all Link actions: LinkDemand, NonCasLinkDemand and LinkDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_linkdemands (MonoMethod *method, MonoDeclSecurityActions* klass, MonoDeclSecurityActions *cmethod)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* results are independant - zeroize both */\n\tmemset (cmethod, 0, sizeof (MonoDeclSecurityActions));\n\tmemset (klass, 0, sizeof (MonoDeclSecurityActions));\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult = mono_declsec_get_method_demands_params (method, cmethod, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & (MONO_DECLSEC_FLAG_LINKDEMAND | MONO_DECLSEC_FLAG_NONCAS_LINKDEMAND | MONO_DECLSEC_FLAG_LINKDEMAND_CHOICE)) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, klass, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * @klass\tThe inherited class - this is the class that provides the security check (attributes)\n * @demans\t\n * return TRUE if inheritance demands (any kind) are present, FALSE otherwise.\n * \n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_class (MonoClass *klass, MonoDeclSecurityActions* demands)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (klass);\n\tif (flags & (MONO_DECLSEC_FLAG_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE)) {\n\t\tmono_class_init (klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult |= mono_declsec_get_class_demands_params (klass, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_method (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\treturn mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\treturn FALSE;\n}\n\n\nstatic MonoBoolean\nget_declsec_action (MonoImage *image, guint32 token, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tMonoTableInfo *t;\n\tint i;\n\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tif (index == -1)\n\t\treturn FALSE;\n\n\tt =  &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\t/* shortcut - index are ordered */\n\t\tif (token != cols [MONO_DECL_SECURITY_PARENT])\n\t\t\treturn FALSE;\n\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == action) {\n\t\t\tconst char *metadata = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\tentry->blob = (char*) (metadata + 2);\n\t\t\tentry->size = mono_metadata_decode_blob_size (metadata, &metadata);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_method_action (MonoMethod *method, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn get_declsec_action (method->klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_class_action (MonoClass *klass, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\t/* use cache */\n\tguint32 flags = mono_declsec_flags_from_class (klass);\n\tif (declsec_flags_map [action] & flags) {\n\t\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\treturn get_declsec_action (klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_assembly_action (MonoAssembly *assembly, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\n\treturn get_declsec_action (assembly->image, idx, action, entry);\n}\n\ngboolean\nmono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass)\n{\n\tMonoObject *res, *exc;\n\tvoid *params [1];\n\tstatic MonoClass *System_Reflection_Emit_TypeBuilder = NULL;\n\tstatic MonoMethod *method = NULL;\n\n\tif (!System_Reflection_Emit_TypeBuilder) {\n\t\tSystem_Reflection_Emit_TypeBuilder = mono_class_from_name (mono_defaults.corlib, \"System.Reflection.Emit\", \"TypeBuilder\");\n\t\tg_assert (System_Reflection_Emit_TypeBuilder);\n\t}\n\tif (method == NULL) {\n\t\tmethod = mono_class_get_method_from_name (System_Reflection_Emit_TypeBuilder, \"IsAssignableTo\", 1);\n\t\tg_assert (method);\n\t}\n\n\t/* \n\t * The result of mono_type_get_object () might be a System.MonoType but we\n\t * need a TypeBuilder so use klass->reflection_info.\n\t */\n\tg_assert (klass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)(klass->reflection_info))->vtable->klass->name, \"TypeBuilder\"));\n\n\tparams [0] = mono_type_get_object (mono_domain_get (), &oklass->byval_arg);\n\n\tres = mono_runtime_invoke (method, (MonoObject*)(klass->reflection_info), params, &exc);\n\tif (exc)\n\t\treturn FALSE;\n\telse\n\t\treturn *(MonoBoolean*)mono_object_unbox (res);\n}\n", "#ifndef __MONO_METADATA_VERIFY_INTERNAL_H__\n#define __MONO_METADATA_VERIFY_INTERNAL_H__\n\n#include <mono/metadata/metadata.h>\n\nG_BEGIN_DECLS\n\ntypedef enum {\n\tMONO_VERIFIER_MODE_OFF,\n\tMONO_VERIFIER_MODE_VALID,\n\tMONO_VERIFIER_MODE_VERIFIABLE,\n\tMONO_VERIFIER_MODE_STRICT\n} MiniVerifierMode;\n\nvoid mono_verifier_set_mode (MiniVerifierMode mode) MONO_INTERNAL;\nvoid mono_verifier_enable_verify_all (void) MONO_INTERNAL;\n\ngboolean mono_verifier_is_enabled_for_image (MonoImage *image) MONO_INTERNAL;\ngboolean mono_verifier_is_enabled_for_method (MonoMethod *method) MONO_INTERNAL;\ngboolean mono_verifier_is_enabled_for_class (MonoClass *klass) MONO_INTERNAL;\n\ngboolean mono_verifier_is_method_full_trust (MonoMethod *method) MONO_INTERNAL;\ngboolean mono_verifier_is_class_full_trust (MonoClass *klass) MONO_INTERNAL;\ngboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *class) MONO_INTERNAL;\ngboolean mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_class (MonoClass *klass) MONO_INTERNAL;\n\nGSList* mono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_pe_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_cli_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_table_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_full_table_data (MonoImage *image, GSList **error_list) MONO_INTERNAL;\n\ngboolean mono_verifier_verify_field_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_method_header (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_method_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_memberref_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_standalone_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_typespec_signature (MonoImage *image, guint32 offset, guint32 token, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_methodspec_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_verify_string_signature (MonoImage *image, guint32 offset, GSList **error_list) MONO_INTERNAL;\ngboolean mono_verifier_is_sig_compatible (MonoImage *image, MonoMethod *method, MonoMethodSignature *signature) MONO_INTERNAL;\n\nG_END_DECLS\n\n#endif  /* __MONO_METADATA_VERIFY_INTERNAL_H__ */\n\n", "/*\n * verify.c: \n *\n * Author:\n *\tMono Project (http://www.mono-project.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n */\n#include <config.h>\n\n#include <mono/metadata/object-internals.h>\n#include <mono/metadata/verify.h>\n#include <mono/metadata/verify-internals.h>\n#include <mono/metadata/opcodes.h>\n#include <mono/metadata/tabledefs.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/metadata/mono-endian.h>\n#include <mono/metadata/metadata.h>\n#include <mono/metadata/metadata-internals.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/metadata/security-manager.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/tokentype.h>\n#include <mono/metadata/mono-basic-block.h>\n#include <mono/utils/monobitset.h>\n#include <string.h>\n#include <signal.h>\n#include <ctype.h>\n\nstatic MiniVerifierMode verifier_mode = MONO_VERIFIER_MODE_OFF;\nstatic gboolean verify_all = FALSE;\n\n/*\n * Set the desired level of checks for the verfier.\n * \n */\nvoid\nmono_verifier_set_mode (MiniVerifierMode mode)\n{\n\tverifier_mode = mode;\n}\n\nvoid\nmono_verifier_enable_verify_all ()\n{\n\tverify_all = TRUE;\n}\n\n#ifndef DISABLE_VERIFIER\n/*\n * Pull the list of opcodes\n */\n#define OPDEF(a,b,c,d,e,f,g,h,i,j) \\\n\ta = i,\n\nenum {\n#include \"mono/cil/opcode.def\"\n\tLAST = 0xff\n};\n#undef OPDEF\n\n#ifdef MONO_VERIFIER_DEBUG\n#define VERIFIER_DEBUG(code) do { code } while (0)\n#else\n#define VERIFIER_DEBUG(code)\n#endif\n\n//////////////////////////////////////////////////////////////////\n#define IS_STRICT_MODE(ctx) (((ctx)->level & MONO_VERIFY_NON_STRICT) == 0)\n#define IS_FAIL_FAST_MODE(ctx) (((ctx)->level & MONO_VERIFY_FAIL_FAST) == MONO_VERIFY_FAIL_FAST)\n#define IS_SKIP_VISIBILITY(ctx) (((ctx)->level & MONO_VERIFY_SKIP_VISIBILITY) == MONO_VERIFY_SKIP_VISIBILITY)\n#define IS_REPORT_ALL_ERRORS(ctx) (((ctx)->level & MONO_VERIFY_REPORT_ALL_ERRORS) == MONO_VERIFY_REPORT_ALL_ERRORS)\n#define CLEAR_PREFIX(ctx, prefix) do { (ctx)->prefix_set &= ~(prefix); } while (0)\n#define ADD_VERIFY_INFO(__ctx, __msg, __status, __exception)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->info.status = __status;\t\\\n\t\tvinfo->info.message = ( __msg );\t\\\n\t\tvinfo->exception_type = (__exception);\t\\\n\t\t(__ctx)->list = g_slist_prepend ((__ctx)->list, vinfo);\t\\\n\t} while (0)\n\n//TODO support MONO_VERIFY_REPORT_ALL_ERRORS\n#define ADD_VERIFY_ERROR(__ctx, __msg)\t\\\n\tdo {\t\\\n\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_ERROR, MONO_EXCEPTION_INVALID_PROGRAM); \\\n\t\t(__ctx)->valid = 0; \\\n\t} while (0)\n\n#define CODE_NOT_VERIFIABLE(__ctx, __msg) \\\n\tdo {\t\\\n\t\tif ((__ctx)->verifiable || IS_REPORT_ALL_ERRORS (__ctx)) { \\\n\t\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_NOT_VERIFIABLE, MONO_EXCEPTION_UNVERIFIABLE_IL); \\\n\t\t\t(__ctx)->verifiable = 0; \\\n\t\t\tif (IS_FAIL_FAST_MODE (__ctx)) \\\n\t\t\t\t(__ctx)->valid = 0; \\\n\t\t} \\\n\t} while (0)\n\n#define ADD_VERIFY_ERROR2(__ctx, __msg, __exception)\t\\\n\tdo {\t\\\n\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_ERROR, __exception); \\\n\t\t(__ctx)->valid = 0; \\\n\t} while (0)\n\n#define CODE_NOT_VERIFIABLE2(__ctx, __msg, __exception) \\\n\tdo {\t\\\n\t\tif ((__ctx)->verifiable || IS_REPORT_ALL_ERRORS (__ctx)) { \\\n\t\t\tADD_VERIFY_INFO(__ctx, __msg, MONO_VERIFY_NOT_VERIFIABLE, __exception); \\\n\t\t\t(__ctx)->verifiable = 0; \\\n\t\t\tif (IS_FAIL_FAST_MODE (__ctx)) \\\n\t\t\t\t(__ctx)->valid = 0; \\\n\t\t} \\\n\t} while (0)\n\n#define CHECK_ADD4_OVERFLOW_UN(a, b) ((guint32)(0xFFFFFFFFU) - (guint32)(b) < (guint32)(a))\n#define CHECK_ADD8_OVERFLOW_UN(a, b) ((guint64)(0xFFFFFFFFFFFFFFFFUL) - (guint64)(b) < (guint64)(a))\n\n#if SIZEOF_VOID_P == 4\n#define CHECK_ADDP_OVERFLOW_UN(a,b) CHECK_ADD4_OVERFLOW_UN(a, b)\n#else\n#define CHECK_ADDP_OVERFLOW_UN(a,b) CHECK_ADD8_OVERFLOW_UN(a, b)\n#endif\n\n#define ADDP_IS_GREATER_OR_OVF(a, b, c) (((a) + (b) > (c)) || CHECK_ADDP_OVERFLOW_UN (a, b))\n#define ADD_IS_GREATER_OR_OVF(a, b, c) (((a) + (b) > (c)) || CHECK_ADD4_OVERFLOW_UN (a, b))\n\n/*Flags to be used with ILCodeDesc::flags */\nenum {\n\t/*Instruction has not been processed.*/\n\tIL_CODE_FLAG_NOT_PROCESSED  = 0,\n\t/*Instruction was decoded by mono_method_verify loop.*/\n\tIL_CODE_FLAG_SEEN = 1,\n\t/*Instruction was target of a branch or is at a protected block boundary.*/\n\tIL_CODE_FLAG_WAS_TARGET = 2,\n\t/*Used by stack_init to avoid double initialize each entry.*/\n\tIL_CODE_FLAG_STACK_INITED = 4,\n\t/*Used by merge_stacks to decide if it should just copy the eval stack.*/\n\tIL_CODE_STACK_MERGED = 8,\n\t/*This instruction is part of the delegate construction sequence, it cannot be target of a branch.*/\n\tIL_CODE_DELEGATE_SEQUENCE = 0x10,\n\t/*This is a delegate created from a ldftn to a non final virtual method*/\n\tIL_CODE_LDFTN_DELEGATE_NONFINAL_VIRTUAL = 0x20,\n\t/*This is a call to a non final virtual method*/\n\tIL_CODE_CALL_NONFINAL_VIRTUAL = 0x40,\n};\n\ntypedef enum {\n\tRESULT_VALID,\n\tRESULT_UNVERIFIABLE,\n\tRESULT_INVALID\n} verify_result_t;\n\ntypedef struct {\n\tMonoType *type;\n\tint stype;\n\tMonoMethod *method;\n} ILStackDesc;\n\n\ntypedef struct {\n\tILStackDesc *stack;\n\tguint16 size;\n\tguint16 flags;\n} ILCodeDesc;\n\ntypedef struct {\n\tint max_args;\n\tint max_stack;\n\tint verifiable;\n\tint valid;\n\tint level;\n\n\tint code_size;\n\tILCodeDesc *code;\n\tILCodeDesc eval;\n\n\tMonoType **params;\n\tGSList *list;\n\t/*Allocated fnptr MonoType that should be freed by us.*/\n\tGSList *funptrs;\n\t/*Type dup'ed exception types from catch blocks.*/\n\tGSList *exception_types;\n\n\tint num_locals;\n\tMonoType **locals;\n\n\t/*TODO get rid of target here, need_merge in mono_method_verify and hoist the merging code in the branching code*/\n\tint target;\n\n\tguint32 ip_offset;\n\tMonoMethodSignature *signature;\n\tMonoMethodHeader *header;\n\n\tMonoGenericContext *generic_context;\n\tMonoImage *image;\n\tMonoMethod *method;\n\n\t/*This flag helps solving a corner case of delegate verification in that you cannot have a \"starg 0\" \n\t *on a method that creates a delegate for a non-final virtual method using ldftn*/\n\tgboolean has_this_store;\n\n\t/*This flag is used to control if the contructor of the parent class has been called.\n\t *If the this pointer is pushed on the eval stack and it's a reference type constructor and\n\t * super_ctor_called is false, the uninitialized flag is set on the pushed value.\n\t * \n\t * Poping an uninitialized this ptr from the eval stack is an unverifiable operation unless\n\t * the safe variant is used. Only a few opcodes can use it : dup, pop, ldfld, stfld and call to a constructor.\n\t */\n\tgboolean super_ctor_called;\n\n\tguint32 prefix_set;\n\tgboolean has_flags;\n\tMonoType *constrained_type;\n} VerifyContext;\n\nstatic void\nmerge_stacks (VerifyContext *ctx, ILCodeDesc *from, ILCodeDesc *to, gboolean start, gboolean external);\n\nstatic int\nget_stack_type (MonoType *type);\n\nstatic gboolean\nmono_delegate_signature_equal (MonoMethodSignature *delegate_sig, MonoMethodSignature *method_sig, gboolean is_static_ldftn);\n\nstatic gboolean\nmono_class_is_valid_generic_instantiation (VerifyContext *ctx, MonoClass *klass);\n\nstatic gboolean\nmono_method_is_valid_generic_instantiation (VerifyContext *ctx, MonoMethod *method);\n//////////////////////////////////////////////////////////////////\n\n\n\nenum {\n\tTYPE_INV = 0, /* leave at 0. */\n\tTYPE_I4  = 1,\n\tTYPE_I8  = 2,\n\tTYPE_NATIVE_INT = 3,\n\tTYPE_R8  = 4,\n\t/* Used by operator tables to resolve pointer types (managed & unmanaged) and by unmanaged pointer types*/\n\tTYPE_PTR  = 5,\n\t/* value types and classes */\n\tTYPE_COMPLEX = 6,\n\t/* Number of types, used to define the size of the tables*/\n\tTYPE_MAX = 6,\n\n\t/* Used by tables to signal that a result is not verifiable*/\n\tNON_VERIFIABLE_RESULT = 0x80,\n\n\t/*Mask used to extract just the type, excluding flags */\n\tTYPE_MASK = 0x0F,\n\n\t/* The stack type is a managed pointer, unmask the value to res */\n\tPOINTER_MASK = 0x100,\n\t\n\t/*Stack type with the pointer mask*/\n\tRAW_TYPE_MASK = 0x10F,\n\n\t/* Controlled Mutability Manager Pointer */\n\tCMMP_MASK = 0x200,\n\n\t/* The stack type is a null literal*/\n\tNULL_LITERAL_MASK = 0x400,\n\t\n\t/**Used by ldarg.0 and family to let delegate verification happens.*/\n\tTHIS_POINTER_MASK = 0x800,\n\n\t/**Signals that this is a boxed value type*/\n\tBOXED_MASK = 0x1000,\n\n\t/*This is an unitialized this ref*/\n\tUNINIT_THIS_MASK = 0x2000,\n};\n\nstatic const char* const\ntype_names [TYPE_MAX + 1] = {\n\t\"Invalid\",\n\t\"Int32\",\n\t\"Int64\",\n\t\"Native Int\",\n\t\"Float64\",\n\t\"Native Pointer\",\n\t\"Complex\"\t\n};\n\nenum {\n\tPREFIX_UNALIGNED = 1,\n\tPREFIX_VOLATILE  = 2,\n\tPREFIX_TAIL      = 4,\n\tPREFIX_CONSTRAINED = 8,\n\tPREFIX_READONLY = 16\n};\n//////////////////////////////////////////////////////////////////\n\n\n/*Token validation macros and functions */\n#define IS_MEMBER_REF(token) (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF)\n#define IS_METHOD_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_METHOD)\n#define IS_METHOD_SPEC(token) (mono_metadata_token_table (token) == MONO_TABLE_METHODSPEC)\n#define IS_FIELD_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_FIELD)\n\n#define IS_TYPE_REF(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPEREF)\n#define IS_TYPE_DEF(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPEDEF)\n#define IS_TYPE_SPEC(token) (mono_metadata_token_table (token) == MONO_TABLE_TYPESPEC)\n#define IS_METHOD_DEF_OR_REF_OR_SPEC(token) (IS_METHOD_DEF (token) || IS_MEMBER_REF (token) || IS_METHOD_SPEC (token))\n#define IS_TYPE_DEF_OR_REF_OR_SPEC(token) (IS_TYPE_DEF (token) || IS_TYPE_REF (token) || IS_TYPE_SPEC (token))\n#define IS_FIELD_DEF_OR_REF(token) (IS_FIELD_DEF (token) || IS_MEMBER_REF (token))\n\n/*\n * Verify if @token refers to a valid row on int's table.\n */\nstatic gboolean\ntoken_bounds_check (MonoImage *image, guint32 token)\n{\n\tif (image->dynamic)\n\t\treturn mono_reflection_is_valid_dynamic_token ((MonoDynamicImage*)image, token);\n\treturn image->tables [mono_metadata_token_table (token)].rows >= mono_metadata_token_index (token);\n}\n\nstatic MonoType *\nmono_type_create_fnptr_from_mono_method (VerifyContext *ctx, MonoMethod *method)\n{\n\tMonoType *res = g_new0 (MonoType, 1);\n\t//FIXME use mono_method_get_signature_full\n\tres->data.method = mono_method_signature (method);\n\tres->type = MONO_TYPE_FNPTR;\n\tctx->funptrs = g_slist_prepend (ctx->funptrs, res);\n\treturn res;\n}\n\n/*\n * mono_type_is_enum_type:\n * \n * Returns TRUE if @type is an enum type. \n */\nstatic gboolean\nmono_type_is_enum_type (MonoType *type)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype)\n\t\treturn TRUE;\n\tif (type->type == MONO_TYPE_GENERICINST && type->data.generic_class->container_class->enumtype)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n/*\n * mono_type_is_value_type:\n * \n * Returns TRUE if @type is named after @namespace.@name.\n * \n */\nstatic gboolean\nmono_type_is_value_type (MonoType *type, const char *namespace, const char *name)\n{\n\treturn type->type == MONO_TYPE_VALUETYPE &&\n\t\t!strcmp (namespace, type->data.klass->name_space) &&\n\t\t!strcmp (name, type->data.klass->name);\n}\n\n/*\n * Returns TURE if @type is VAR or MVAR\n */\nstatic gboolean\nmono_type_is_generic_argument (MonoType *type)\n{\n\treturn type->type == MONO_TYPE_VAR || type->type == MONO_TYPE_MVAR;\n}\n\n/*\n * mono_type_get_underlying_type_any:\n * \n * This functions is just like mono_type_get_underlying_type but it doesn't care if the type is byref.\n * \n * Returns the underlying type of @type regardless if it is byref or not.\n */\nstatic MonoType*\nmono_type_get_underlying_type_any (MonoType *type)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype)\n\t\treturn mono_class_enum_basetype (type->data.klass);\n\tif (type->type == MONO_TYPE_GENERICINST && type->data.generic_class->container_class->enumtype)\n\t\treturn mono_class_enum_basetype (type->data.generic_class->container_class);\n\treturn type;\n}\n\nstatic const char*\nmono_type_get_stack_name (MonoType *type)\n{\n\treturn type_names [get_stack_type (type) & TYPE_MASK];\n}\n\n#define CTOR_REQUIRED_FLAGS (METHOD_ATTRIBUTE_SPECIAL_NAME | METHOD_ATTRIBUTE_RT_SPECIAL_NAME)\n#define CTOR_INVALID_FLAGS (METHOD_ATTRIBUTE_STATIC)\n\nstatic gboolean\nmono_method_is_constructor (MonoMethod *method) \n{\n\treturn ((method->flags & CTOR_REQUIRED_FLAGS) == CTOR_REQUIRED_FLAGS &&\n\t\t\t!(method->flags & CTOR_INVALID_FLAGS) &&\n\t\t\t!strcmp (\".ctor\", method->name));\n}\n\nstatic gboolean\nmono_class_has_default_constructor (MonoClass *klass)\n{\n\tMonoMethod *method;\n\tint i;\n\n\tmono_class_setup_methods (klass);\n\tif (klass->exception_type)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tmethod = klass->methods [i];\n\t\tif (mono_method_is_constructor (method) &&\n\t\t\tmono_method_signature (method) &&\n\t\t\tmono_method_signature (method)->param_count == 0 &&\n\t\t\t(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean\nmono_class_interface_implements_interface (MonoClass *candidate, MonoClass *iface)\n{\n\tMonoError error;\n\tint i;\n\tdo {\n\t\tif (candidate == iface)\n\t\t\treturn TRUE;\n\t\tmono_class_setup_interfaces (candidate, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_error_cleanup (&error);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tfor (i = 0; i < candidate->interface_count; ++i) {\n\t\t\tif (candidate->interfaces [i] == iface || mono_class_interface_implements_interface (candidate->interfaces [i], iface))\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tcandidate = candidate->parent;\n\t} while (candidate);\n\treturn FALSE;\n}\n\n/*\n * Verify if @type is valid for the given @ctx verification context.\n * this function checks for VAR and MVAR types that are invalid under the current verifier,\n */\nstatic gboolean\nmono_type_is_valid_type_in_context (MonoType *type, MonoGenericContext *context)\n{\n\tint i;\n\tMonoGenericInst *inst;\n\n\tswitch (type->type) {\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tif (!context)\n\t\t\treturn FALSE;\n\t\tinst = type->type == MONO_TYPE_VAR ? context->class_inst : context->method_inst;\n\t\tif (!inst || mono_type_get_generic_param_num (type) >= inst->type_argc)\n\t\t\treturn FALSE;\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn mono_type_is_valid_type_in_context (&type->data.klass->byval_arg, context);\n\tcase MONO_TYPE_ARRAY:\n\t\treturn mono_type_is_valid_type_in_context (&type->data.array->eklass->byval_arg, context);\n\tcase MONO_TYPE_PTR:\n\t\treturn mono_type_is_valid_type_in_context (type->data.type, context);\n\tcase MONO_TYPE_GENERICINST:\n\t\tinst = type->data.generic_class->context.class_inst;\n\t\tif (!inst->is_open)\n\t\t\tbreak;\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tif (!mono_type_is_valid_type_in_context (inst->type_argv [i], context))\n\t\t\t\treturn FALSE;\n\t\tbreak;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *klass = type->data.klass;\n\t\t/*\n\t\t * It's possible to encode generic'sh types in such a way that they disguise themselves as class or valuetype.\n\t\t * Fixing the type decoding is really tricky since under some cases this behavior is needed, for example, to\n\t\t * have a 'class' type pointing to a 'genericinst' class.\n\t\t *\n\t\t * For the runtime these non canonical (weird) encodings work fine, they worst they can cause is some\n\t\t * reflection oddities which are harmless  - to security at least.\n\t\t */\n\t\tif (klass->byval_arg.type != type->type)\n\t\t\treturn mono_type_is_valid_type_in_context (&klass->byval_arg, context);\n\t\tbreak;\n\t}\n\t}\n\treturn TRUE;\n}\n\n/*This function returns NULL if the type is not instantiatable*/\nstatic MonoType*\nverifier_inflate_type (VerifyContext *ctx, MonoType *type, MonoGenericContext *context)\n{\n\tMonoError error;\n\tMonoType *result;\n\n\tresult = mono_class_inflate_generic_type_checked (type, context, &error);\n\tif (!mono_error_ok (&error)) {\n\t\tmono_error_cleanup (&error);\n\t\treturn NULL;\n\t}\n\treturn result;\n}\n/*\n * Test if @candidate is a subtype of @target using the minimal possible information\n * TODO move the code for non finished TypeBuilders to here.\n */\nstatic gboolean\nmono_class_is_constraint_compatible (MonoClass *candidate, MonoClass *target)\n{\n\tif (candidate == target)\n\t\treturn TRUE;\n\tif (target == mono_defaults.object_class)\n\t\t\treturn TRUE;\n\n\t//setup_supertypes don't mono_class_init anything\n\tmono_class_setup_supertypes (candidate);\n\tmono_class_setup_supertypes (target);\n\n\tif (mono_class_has_parent (candidate, target))\n\t\treturn TRUE;\n\n\t//if target is not a supertype it must be an interface\n\tif (!MONO_CLASS_IS_INTERFACE (target))\n\t\t\treturn FALSE;\n\n\tif (candidate->image->dynamic && !candidate->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = candidate->reflection_info;\n\t\tint j;\n\t\tif (tb->interfaces) {\n\t\t\tfor (j = mono_array_length (tb->interfaces) - 1; j >= 0; --j) {\n\t\t\t\tMonoReflectionType *iface = mono_array_get (tb->interfaces, MonoReflectionType*, j);\n\t\t\t\tMonoClass *ifaceClass = mono_class_from_mono_type (iface->type);\n\t\t\t\tif (mono_class_is_constraint_compatible (ifaceClass, target)) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn mono_class_interface_implements_interface (candidate, target);\n}\n\nstatic gboolean\nis_valid_generic_instantiation (MonoGenericContainer *gc, MonoGenericContext *context, MonoGenericInst *ginst)\n{\n\tMonoError error;\n\tint i;\n\n\tif (ginst->type_argc != gc->type_argc)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < gc->type_argc; ++i) {\n\t\tMonoGenericParamInfo *param_info = mono_generic_container_get_param_info (gc, i);\n\t\tMonoClass *paramClass;\n\t\tMonoClass **constraints;\n\n\t\tif (!param_info->constraints && !(param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK))\n\t\t\tcontinue;\n\t\tif (mono_type_is_generic_argument (ginst->type_argv [i]))\n\t\t\tcontinue; //it's not our job to validate type variables\n\n\t\tparamClass = mono_class_from_mono_type (ginst->type_argv [i]);\n\n\t\tif (paramClass->exception_type != MONO_EXCEPTION_NONE)\n\t\t\treturn FALSE;\n\n\t\t/*it's not safe to call mono_class_init from here*/\n\t\tif (paramClass->generic_class && !paramClass->inited) {\n\t\t\tif (!mono_class_is_valid_generic_instantiation (NULL, paramClass))\n\t\t\t\treturn FALSE;\n\t\t}\n\n\t\tif ((param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_VALUE_TYPE_CONSTRAINT) && (!paramClass->valuetype || mono_class_is_nullable (paramClass)))\n\t\t\treturn FALSE;\n\n\t\tif ((param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT) && paramClass->valuetype)\n\t\t\treturn FALSE;\n\n\t\tif ((param_info->flags & GENERIC_PARAMETER_ATTRIBUTE_CONSTRUCTOR_CONSTRAINT) && !paramClass->valuetype && !mono_class_has_default_constructor (paramClass))\n\t\t\treturn FALSE;\n\n\t\tif (!param_info->constraints)\n\t\t\tcontinue;\n\n\t\tfor (constraints = param_info->constraints; *constraints; ++constraints) {\n\t\t\tMonoClass *ctr = *constraints;\n\t\t\tMonoType *inflated;\n\n\t\t\tinflated = mono_class_inflate_generic_type_checked (&ctr->byval_arg, context, &error);\n\t\t\tif (!mono_error_ok (&error)) {\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tctr = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\n\t\t\tif (!mono_class_is_constraint_compatible (paramClass, ctr))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/*\n * Return true if @candidate is constraint compatible with @target.\n * \n * This means that @candidate constraints are a super set of @target constaints\n */\nstatic gboolean\nmono_generic_param_is_constraint_compatible (VerifyContext *ctx, MonoGenericParam *target, MonoGenericParam *candidate, MonoClass *candidate_param_class, MonoGenericContext *context)\n{\n\tMonoGenericParamInfo *tinfo = mono_generic_param_info (target);\n\tMonoGenericParamInfo *cinfo = mono_generic_param_info (candidate);\n\n\tint tmask = tinfo->flags & GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK;\n\tint cmask = cinfo->flags & GENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK;\n\tif ((tmask & cmask) != tmask)\n\t\treturn FALSE;\n\n\tif (tinfo->constraints) {\n\t\tMonoClass **target_class, **candidate_class;\n\t\tfor (target_class = tinfo->constraints; *target_class; ++target_class) {\n\t\t\tMonoClass *tc;\n\t\t\tMonoType *inflated = verifier_inflate_type (ctx, &(*target_class)->byval_arg, context);\n\t\t\tif (!inflated)\n\t\t\t\treturn FALSE;\n\t\t\ttc = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\n\t\t\t/*\n\t\t\t * A constraint from @target might inflate into @candidate itself and in that case we don't need\n\t\t\t * check it's constraints since it satisfy the constraint by itself.\n\t\t\t */\n\t\t\tif (mono_metadata_type_equal (&tc->byval_arg, &candidate_param_class->byval_arg))\n\t\t\t\tcontinue;\n\n\t\t\tif (!cinfo->constraints)\n\t\t\t\treturn FALSE;\n\n\t\t\tfor (candidate_class = cinfo->constraints; *candidate_class; ++candidate_class) {\n\t\t\t\tMonoClass *cc;\n\t\t\t\tinflated = verifier_inflate_type (ctx, &(*candidate_class)->byval_arg, ctx->generic_context);\n\t\t\t\tif (!inflated)\n\t\t\t\t\treturn FALSE;\n\t\t\t\tcc = mono_class_from_mono_type (inflated);\n\t\t\t\tmono_metadata_free_type (inflated);\n\n\t\t\t\tif (mono_class_is_assignable_from (tc, cc))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*candidate_class)\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nstatic MonoGenericParam*\nverifier_get_generic_param_from_type (VerifyContext *ctx, MonoType *type)\n{\n\tMonoGenericContainer *gc;\n\tMonoMethod *method = ctx->method;\n\tint num;\n\n\tnum = mono_type_get_generic_param_num (type);\n\n\tif (type->type == MONO_TYPE_VAR) {\n\t\tMonoClass *gtd = method->klass;\n\t\tif (gtd->generic_class)\n\t\t\tgtd = gtd->generic_class->container_class;\n\t\tgc = gtd->generic_container;\n\t} else { //MVAR\n\t\tMonoMethod *gmd = method;\n\t\tif (method->is_inflated)\n\t\t\tgmd = ((MonoMethodInflated*)method)->declaring;\n\t\tgc = mono_method_get_generic_container (gmd);\n\t}\n\tif (!gc)\n\t\treturn FALSE;\n\treturn mono_generic_container_get_param (gc, num);\n}\n\n\n\n/*\n * Verify if @type is valid for the given @ctx verification context.\n * this function checks for VAR and MVAR types that are invalid under the current verifier,\n * This means that it either \n */\nstatic gboolean\nis_valid_type_in_context (VerifyContext *ctx, MonoType *type)\n{\n\treturn mono_type_is_valid_type_in_context (type, ctx->generic_context);\n}\n\nstatic gboolean\nis_valid_generic_instantiation_in_context (VerifyContext *ctx, MonoGenericInst *ginst)\n{\n\tint i;\n\tfor (i = 0; i < ginst->type_argc; ++i) {\n\t\tMonoType *type = ginst->type_argv [i];\n\t\tif (!is_valid_type_in_context (ctx, type))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\ngeneric_arguments_respect_constraints (VerifyContext *ctx, MonoGenericContainer *gc, MonoGenericContext *context, MonoGenericInst *ginst)\n{\n\tint i;\n\tfor (i = 0; i < ginst->type_argc; ++i) {\n\t\tMonoType *type = ginst->type_argv [i];\n\t\tMonoGenericParam *target = mono_generic_container_get_param (gc, i);\n\t\tMonoGenericParam *candidate;\n\t\tMonoClass *candidate_class;\n\n\t\tif (!mono_type_is_generic_argument (type))\n\t\t\tcontinue;\n\n\t\tif (!is_valid_type_in_context (ctx, type))\n\t\t\treturn FALSE;\n\n\t\tcandidate = verifier_get_generic_param_from_type (ctx, type);\n\t\tcandidate_class = mono_class_from_mono_type (type);\n\n\t\tif (!mono_generic_param_is_constraint_compatible (ctx, target, candidate, candidate_class, context))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nmono_method_repect_method_constraints (VerifyContext *ctx, MonoMethod *method)\n{\n\tMonoMethodInflated *gmethod = (MonoMethodInflated *)method;\n\tMonoGenericInst *ginst = gmethod->context.method_inst;\n\tMonoGenericContainer *gc = mono_method_get_generic_container (gmethod->declaring);\n\treturn !gc || generic_arguments_respect_constraints (ctx, gc, &gmethod->context, ginst);\n}\n\nstatic gboolean\nmono_class_repect_method_constraints (VerifyContext *ctx, MonoClass *klass)\n{\n\tMonoGenericClass *gklass = klass->generic_class;\n\tMonoGenericInst *ginst = gklass->context.class_inst;\n\tMonoGenericContainer *gc = gklass->container_class->generic_container;\n\treturn !gc || generic_arguments_respect_constraints (ctx, gc, &gklass->context, ginst);\n}\n\nstatic gboolean\nmono_method_is_valid_generic_instantiation (VerifyContext *ctx, MonoMethod *method)\n{\n\tMonoMethodInflated *gmethod = (MonoMethodInflated *)method;\n\tMonoGenericInst *ginst = gmethod->context.method_inst;\n\tMonoGenericContainer *gc = mono_method_get_generic_container (gmethod->declaring);\n\tif (!gc) /*non-generic inflated method - it's part of a generic type  */\n\t\treturn TRUE;\n\tif (ctx && !is_valid_generic_instantiation_in_context (ctx, ginst))\n\t\treturn FALSE;\n\treturn is_valid_generic_instantiation (gc, &gmethod->context, ginst);\n\n}\n\nstatic gboolean\nmono_class_is_valid_generic_instantiation (VerifyContext *ctx, MonoClass *klass)\n{\n\tMonoGenericClass *gklass = klass->generic_class;\n\tMonoGenericInst *ginst = gklass->context.class_inst;\n\tMonoGenericContainer *gc = gklass->container_class->generic_container;\n\tif (ctx && !is_valid_generic_instantiation_in_context (ctx, ginst))\n\t\treturn FALSE;\n\treturn is_valid_generic_instantiation (gc, &gklass->context, ginst);\n}\n\nstatic gboolean\nmono_type_is_valid_in_context (VerifyContext *ctx, MonoType *type)\n{\n\tMonoClass *klass;\n\n\tif (type == NULL) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid null type at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn FALSE;\n\t}\n\n\tif (!is_valid_type_in_context (ctx, type)) {\n\t\tchar *str = mono_type_full_name (type);\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic type (%s%s) (argument out of range or %s is not generic) at 0x%04x\",\n\t\t\ttype->type == MONO_TYPE_VAR ? \"!\" : \"!!\",\n\t\t\tstr,\n\t\t\ttype->type == MONO_TYPE_VAR ? \"class\" : \"method\",\n\t\t\tctx->ip_offset),\n\t\t\tMONO_EXCEPTION_BAD_IMAGE);\t\t\n\t\tg_free (str);\n\t\treturn FALSE;\n\t}\n\n\tklass = mono_class_from_mono_type (type);\n\tmono_class_init (klass);\n\tif (mono_loader_get_last_error () || klass->exception_type != MONO_EXCEPTION_NONE) {\n\t\tif (klass->generic_class && !mono_class_is_valid_generic_instantiation (NULL, klass))\n\t\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic instantiation of type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\telse\n\t\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Could not load type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\tif (klass->generic_class && klass->generic_class->container_class->exception_type != MONO_EXCEPTION_NONE) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Could not load type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\tif (!klass->generic_class)\n\t\treturn TRUE;\n\n\tif (!mono_class_is_valid_generic_instantiation (ctx, klass)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic type instantiation of type %s.%s at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\tif (!mono_class_repect_method_constraints (ctx, klass)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic type instantiation of type %s.%s (generic args don't respect target's constraints) at 0x%04x\", klass->name_space, klass->name, ctx->ip_offset), MONO_EXCEPTION_TYPE_LOAD);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic verify_result_t\nmono_method_is_valid_in_context (VerifyContext *ctx, MonoMethod *method)\n{\n\tif (!mono_type_is_valid_in_context (ctx, &method->klass->byval_arg))\n\t\treturn RESULT_INVALID;\n\n\tif (!method->is_inflated)\n\t\treturn RESULT_VALID;\n\n\tif (!mono_method_is_valid_generic_instantiation (ctx, method)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid generic method instantiation of method %s.%s::%s at 0x%04x\", method->klass->name_space, method->klass->name, method->name, ctx->ip_offset), MONO_EXCEPTION_UNVERIFIABLE_IL);\n\t\treturn RESULT_INVALID;\n\t}\n\n\tif (!mono_method_repect_method_constraints (ctx, method)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid generic method instantiation of method %s.%s::%s (generic args don't respect target's constraints) at 0x%04x\", method->klass->name_space, method->klass->name, method->name, ctx->ip_offset));\n\t\treturn RESULT_UNVERIFIABLE;\n\t}\n\treturn RESULT_VALID;\n}\n\n\t\nstatic MonoClassField*\nverifier_load_field (VerifyContext *ctx, int token, MonoClass **out_klass, const char *opcode) {\n\tMonoClassField *field;\n\tMonoClass *klass = NULL;\n\n\tif (!IS_FIELD_DEF_OR_REF (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid field token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tfield = mono_field_from_token (ctx->image, token, &klass, ctx->generic_context);\n\tif (!field || !field->parent || !klass) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Cannot load field from token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tif (!mono_type_is_valid_in_context (ctx, &klass->byval_arg))\n\t\treturn NULL;\n\n\t*out_klass = klass;\n\treturn field;\n}\n\nstatic MonoMethod*\nverifier_load_method (VerifyContext *ctx, int token, const char *opcode) {\n\tMonoMethod* method;\n\t\n\tif (!IS_METHOD_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid method token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tmethod = mono_get_method_full (ctx->image, token, NULL, ctx->generic_context);\n\n\tif (!method) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Cannot load method from token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\t\n\tif (mono_method_is_valid_in_context (ctx, method) == RESULT_INVALID)\n\t\treturn NULL;\n\n\treturn method;\n}\n\nstatic MonoType*\nverifier_load_type (VerifyContext *ctx, int token, const char *opcode) {\n\tMonoType* type;\n\t\n\tif (!IS_TYPE_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid type token 0x%08x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\ttype = mono_type_get_full (ctx->image, token, ctx->generic_context);\n\n\tif (!type) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Cannot load type from token 0x%08x for %s at 0x%04x\", token, opcode, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn NULL;\n\t}\n\n\tif (!mono_type_is_valid_in_context (ctx, type))\n\t\treturn NULL;\n\n\treturn type;\n}\n\n\n/* stack_slot_get_type:\n * \n * Returns the stack type of @value. This value includes POINTER_MASK.\n * \n * Use this function to checks that account for a managed pointer.\n */\nstatic gint32\nstack_slot_get_type (ILStackDesc *value)\n{\n\treturn value->stype & RAW_TYPE_MASK;\n}\n\n/* stack_slot_get_underlying_type:\n * \n * Returns the stack type of @value. This value does not include POINTER_MASK.\n * \n * Use this function is cases where the fact that the value could be a managed pointer is\n * irrelevant. For example, field load doesn't care about this fact of type on stack.\n */\nstatic gint32\nstack_slot_get_underlying_type (ILStackDesc *value)\n{\n\treturn value->stype & TYPE_MASK;\n}\n\n/* stack_slot_is_managed_pointer:\n * \n * Returns TRUE is @value is a managed pointer.\n */\nstatic gboolean\nstack_slot_is_managed_pointer (ILStackDesc *value)\n{\n\treturn (value->stype & POINTER_MASK) == POINTER_MASK;\n}\n\n/* stack_slot_is_managed_mutability_pointer:\n * \n * Returns TRUE is @value is a managed mutability pointer.\n */\nstatic G_GNUC_UNUSED gboolean\nstack_slot_is_managed_mutability_pointer (ILStackDesc *value)\n{\n\treturn (value->stype & CMMP_MASK) == CMMP_MASK;\n}\n\n/* stack_slot_is_null_literal:\n * \n * Returns TRUE is @value is the null literal.\n */\nstatic gboolean\nstack_slot_is_null_literal (ILStackDesc *value)\n{\n\treturn (value->stype & NULL_LITERAL_MASK) == NULL_LITERAL_MASK;\n}\n\n\n/* stack_slot_is_this_pointer:\n * \n * Returns TRUE is @value is the this literal\n */\nstatic gboolean\nstack_slot_is_this_pointer (ILStackDesc *value)\n{\n\treturn (value->stype & THIS_POINTER_MASK) == THIS_POINTER_MASK;\n}\n\n/* stack_slot_is_boxed_value:\n * \n * Returns TRUE is @value is a boxed value\n */\nstatic gboolean\nstack_slot_is_boxed_value (ILStackDesc *value)\n{\n\treturn (value->stype & BOXED_MASK) == BOXED_MASK;\n}\n\nstatic const char *\nstack_slot_get_name (ILStackDesc *value)\n{\n\treturn type_names [value->stype & TYPE_MASK];\n}\n\n#define APPEND_WITH_PREDICATE(PRED,NAME) do {\\\n\tif (PRED (value)) { \\\n\t\tif (!first) \\\n\t\t\tg_string_append (str, \", \"); \\\n\t\tg_string_append (str, NAME); \\\n\t\tfirst = FALSE; \\\n\t} } while (0)\n\nstatic char*\nstack_slot_stack_type_full_name (ILStackDesc *value)\n{\n\tGString *str = g_string_new (\"\");\n\tchar *result;\n\tgboolean has_pred = FALSE, first = TRUE;\n\n\tif ((value->stype & TYPE_MASK) != value->stype) {\n\t\tg_string_append(str, \"[\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_this_pointer, \"this\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_boxed_value, \"boxed\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_null_literal, \"null\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_managed_mutability_pointer, \"cmmp\");\n\t\tAPPEND_WITH_PREDICATE (stack_slot_is_managed_pointer, \"mp\");\n\t\thas_pred = TRUE;\n\t}\n\n\tif (mono_type_is_generic_argument (value->type) && !stack_slot_is_boxed_value (value)) {\n\t\tif (!has_pred)\n\t\t\tg_string_append(str, \"[\");\n\t\tif (!first)\n\t\t\tg_string_append (str, \", \");\n\t\tg_string_append (str, \"unboxed\");\n\t\thas_pred = TRUE;\n\t}\n\n\tif (has_pred)\n\t\tg_string_append(str, \"] \");\n\n\tg_string_append (str, stack_slot_get_name (value));\n\tresult = str->str;\n\tg_string_free (str, FALSE);\n\treturn result;\n}\n\nstatic char*\nstack_slot_full_name (ILStackDesc *value)\n{\n\tchar *type_name = mono_type_full_name (value->type);\n\tchar *stack_name = stack_slot_stack_type_full_name (value);\n\tchar *res = g_strdup_printf (\"%s (%s)\", type_name, stack_name);\n\tg_free (type_name);\n\tg_free (stack_name);\n\treturn res;\n}\n\n//////////////////////////////////////////////////////////////////\nvoid\nmono_free_verify_list (GSList *list)\n{\n\tMonoVerifyInfoExtended *info;\n\tGSList *tmp;\n\n\tfor (tmp = list; tmp; tmp = tmp->next) {\n\t\tinfo = tmp->data;\n\t\tg_free (info->info.message);\n\t\tg_free (info);\n\t}\n\tg_slist_free (list);\n}\n\n#define ADD_ERROR(list,msg)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->info.status = MONO_VERIFY_ERROR;\t\\\n\t\tvinfo->info.message = (msg);\t\\\n\t\t(list) = g_slist_prepend ((list), vinfo);\t\\\n\t} while (0)\n\n#define ADD_WARN(list,code,msg)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->info.status = (code);\t\\\n\t\tvinfo->info.message = (msg);\t\\\n\t\t(list) = g_slist_prepend ((list), vinfo);\t\\\n\t} while (0)\n\nstatic const char\nvalid_cultures[][9] = {\n\t\"ar-SA\", \"ar-IQ\", \"ar-EG\", \"ar-LY\",\n\t\"ar-DZ\", \"ar-MA\", \"ar-TN\", \"ar-OM\",\n\t\"ar-YE\", \"ar-SY\", \"ar-JO\", \"ar-LB\",\n\t\"ar-KW\", \"ar-AE\", \"ar-BH\", \"ar-QA\",\n\t\"bg-BG\", \"ca-ES\", \"zh-TW\", \"zh-CN\",\n\t\"zh-HK\", \"zh-SG\", \"zh-MO\", \"cs-CZ\",\n\t\"da-DK\", \"de-DE\", \"de-CH\", \"de-AT\",\n\t\"de-LU\", \"de-LI\", \"el-GR\", \"en-US\",\n\t\"en-GB\", \"en-AU\", \"en-CA\", \"en-NZ\",\n\t\"en-IE\", \"en-ZA\", \"en-JM\", \"en-CB\",\n\t\"en-BZ\", \"en-TT\", \"en-ZW\", \"en-PH\",\n\t\"es-ES-Ts\", \"es-MX\", \"es-ES-Is\", \"es-GT\",\n\t\"es-CR\", \"es-PA\", \"es-DO\", \"es-VE\",\n\t\"es-CO\", \"es-PE\", \"es-AR\", \"es-EC\",\n\t\"es-CL\", \"es-UY\", \"es-PY\", \"es-BO\",\n\t\"es-SV\", \"es-HN\", \"es-NI\", \"es-PR\",\n\t\"Fi-FI\", \"fr-FR\", \"fr-BE\", \"fr-CA\",\n\t\"Fr-CH\", \"fr-LU\", \"fr-MC\", \"he-IL\",\n\t\"hu-HU\", \"is-IS\", \"it-IT\", \"it-CH\",\n\t\"Ja-JP\", \"ko-KR\", \"nl-NL\", \"nl-BE\",\n\t\"nb-NO\", \"nn-NO\", \"pl-PL\", \"pt-BR\",\n\t\"pt-PT\", \"ro-RO\", \"ru-RU\", \"hr-HR\",\n\t\"Lt-sr-SP\", \"Cy-sr-SP\", \"sk-SK\", \"sq-AL\",\n\t\"sv-SE\", \"sv-FI\", \"th-TH\", \"tr-TR\",\n\t\"ur-PK\", \"id-ID\", \"uk-UA\", \"be-BY\",\n\t\"sl-SI\", \"et-EE\", \"lv-LV\", \"lt-LT\",\n\t\"fa-IR\", \"vi-VN\", \"hy-AM\", \"Lt-az-AZ\",\n\t\"Cy-az-AZ\",\n\t\"eu-ES\", \"mk-MK\", \"af-ZA\",\n\t\"ka-GE\", \"fo-FO\", \"hi-IN\", \"ms-MY\",\n\t\"ms-BN\", \"kk-KZ\", \"ky-KZ\", \"sw-KE\",\n\t\"Lt-uz-UZ\", \"Cy-uz-UZ\", \"tt-TA\", \"pa-IN\",\n\t\"gu-IN\", \"ta-IN\", \"te-IN\", \"kn-IN\",\n\t\"mr-IN\", \"sa-IN\", \"mn-MN\", \"gl-ES\",\n\t\"kok-IN\", \"syr-SY\", \"div-MV\"\n};\n\nstatic int\nis_valid_culture (const char *cname)\n{\n\tint i;\n\tint found;\n\n\tfound = *cname == 0;\n\tfor (i = 0; i < G_N_ELEMENTS (valid_cultures); ++i) {\n\t\tif (g_ascii_strcasecmp (valid_cultures [i], cname)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\nstatic int\nis_valid_assembly_flags (guint32 flags) {\n\t/* Metadata: 22.1.2 */\n\tflags &= ~(0x8000 | 0x4000); /* ignore reserved bits 0x0030? */\n\treturn ((flags == 1) || (flags == 0));\n}\n\nstatic int\nis_valid_blob (MonoImage *image, guint32 blob_index, int notnull)\n{\n\tguint32 size;\n\tconst char *p, *blob_end;\n\n\tif (blob_index >= image->heap_blob.size)\n\t\treturn 0;\n\tp = mono_metadata_blob_heap (image, blob_index);\n\tsize = mono_metadata_decode_blob_size (p, &blob_end);\n\tif (blob_index + size + (blob_end-p) > image->heap_blob.size)\n\t\treturn 0;\n\tif (notnull && !size)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic const char*\nis_valid_string (MonoImage *image, guint32 str_index, int notnull)\n{\n\tconst char *p, *blob_end, *res;\n\n\tif (str_index >= image->heap_strings.size)\n\t\treturn NULL;\n\tres = p = mono_metadata_string_heap (image, str_index);\n\tblob_end = mono_metadata_string_heap (image, image->heap_strings.size - 1);\n\tif (notnull && !*p)\n\t\treturn 0;\n\t/* \n\t * FIXME: should check it's a valid utf8 string, too.\n\t */\n\twhile (p <= blob_end) {\n\t\tif (!*p)\n\t\t\treturn res;\n\t\t++p;\n\t}\n\treturn *p? NULL: res;\n}\n\nstatic int\nis_valid_cls_ident (const char *p)\n{\n\t/*\n\t * FIXME: we need the full unicode glib support for this.\n\t * Check: http://www.unicode.org/unicode/reports/tr15/Identifier.java\n\t * We do the lame thing for now.\n\t */\n\tif (!isalpha (*p))\n\t\treturn 0;\n\t++p;\n\twhile (*p) {\n\t\tif (!isalnum (*p) && *p != '_')\n\t\t\treturn 0;\n\t\t++p;\n\t}\n\treturn 1;\n}\n\nstatic int\nis_valid_filename (const char *p)\n{\n\tif (!*p)\n\t\treturn 0;\n\treturn strpbrk (p, \"\\\\//:\")? 0: 1;\n}\n\nstatic GSList*\nverify_assembly_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_ASSEMBLY];\n\tguint32 cols [MONO_ASSEMBLY_SIZE];\n\tconst char *p;\n\n\tif (level & MONO_VERIFY_ERROR) {\n\t\tif (t->rows > 1)\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly table may only have 0 or 1 rows\"));\n\t\tmono_metadata_decode_row (t, 0, cols, MONO_ASSEMBLY_SIZE);\n\n\t\tswitch (cols [MONO_ASSEMBLY_HASH_ALG]) {\n\t\tcase ASSEMBLY_HASH_NONE:\n\t\tcase ASSEMBLY_HASH_MD5:\n\t\tcase ASSEMBLY_HASH_SHA1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tADD_ERROR (list, g_strdup_printf (\"Hash algorithm 0x%x unknown\", cols [MONO_ASSEMBLY_HASH_ALG]));\n\t\t}\n\n\t\tif (!is_valid_assembly_flags (cols [MONO_ASSEMBLY_FLAGS]))\n\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid flags in assembly: 0x%x\", cols [MONO_ASSEMBLY_FLAGS]));\n\n\t\tif (!is_valid_blob (image, cols [MONO_ASSEMBLY_PUBLIC_KEY], FALSE))\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly public key is an invalid index\"));\n\n\t\tif (!(p = is_valid_string (image, cols [MONO_ASSEMBLY_NAME], TRUE))) {\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly name is invalid\"));\n\t\t} else {\n\t\t\tif (strpbrk (p, \":\\\\/.\"))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Assembly name `%s' contains invalid chars\", p));\n\t\t}\n\n\t\tif (!(p = is_valid_string (image, cols [MONO_ASSEMBLY_CULTURE], FALSE))) {\n\t\t\tADD_ERROR (list, g_strdup (\"Assembly culture is an invalid index\"));\n\t\t} else {\n\t\t\tif (!is_valid_culture (p))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Assembly culture `%s' is invalid\", p));\n\t\t}\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_assemblyref_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_ASSEMBLYREF];\n\tguint32 cols [MONO_ASSEMBLYREF_SIZE];\n\tconst char *p;\n\tint i;\n\n\tif (level & MONO_VERIFY_ERROR) {\n\t\tfor (i = 0; i < t->rows; ++i) {\n\t\t\tmono_metadata_decode_row (t, i, cols, MONO_ASSEMBLYREF_SIZE);\n\t\t\tif (!is_valid_assembly_flags (cols [MONO_ASSEMBLYREF_FLAGS]))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid flags in assemblyref row %d: 0x%x\", i + 1, cols [MONO_ASSEMBLY_FLAGS]));\n\n\t\t\tif (!is_valid_blob (image, cols [MONO_ASSEMBLYREF_PUBLIC_KEY], FALSE))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef public key in row %d is an invalid index\", i + 1));\n\n\t\t\tif (!(p = is_valid_string (image, cols [MONO_ASSEMBLYREF_CULTURE], FALSE))) {\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef culture in row %d is invalid\", i + 1));\n\t\t\t} else {\n\t\t\t\tif (!is_valid_culture (p))\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef culture `%s' in row %d is invalid\", p, i + 1));\n\t\t\t}\n\n\t\t\tif (cols [MONO_ASSEMBLYREF_HASH_VALUE] && !is_valid_blob (image, cols [MONO_ASSEMBLYREF_HASH_VALUE], TRUE))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"AssemblyRef hash value in row %d is invalid or not null and empty\", i + 1));\n\t\t}\n\t}\n\tif (level & MONO_VERIFY_WARNING) {\n\t\t/* check for duplicated rows */\n\t\tfor (i = 0; i < t->rows; ++i) {\n\t\t}\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_class_layout_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_CLASSLAYOUT];\n\tMonoTableInfo *tdef = &image->tables [MONO_TABLE_TYPEDEF];\n\tguint32 cols [MONO_CLASS_LAYOUT_SIZE];\n\tguint32 value, i;\n\n\tif (level & MONO_VERIFY_ERROR) {\n\t\tfor (i = 0; i < t->rows; ++i) {\n\t\t\tmono_metadata_decode_row (t, i, cols, MONO_CLASS_LAYOUT_SIZE);\n\n\t\t\tif (cols [MONO_CLASS_LAYOUT_PARENT] > tdef->rows || !cols [MONO_CLASS_LAYOUT_PARENT]) {\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent in class layout is invalid in row %d\", i + 1));\n\t\t\t} else {\n\t\t\t\tvalue = mono_metadata_decode_row_col (tdef, cols [MONO_CLASS_LAYOUT_PARENT] - 1, MONO_TYPEDEF_FLAGS);\n\t\t\t\tif (value & TYPE_ATTRIBUTE_INTERFACE)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent in class layout row %d is an interface\", i + 1));\n\t\t\t\tif (value & TYPE_ATTRIBUTE_AUTO_LAYOUT)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent in class layout row %d is AutoLayout\", i + 1));\n\t\t\t\tif (value & TYPE_ATTRIBUTE_SEQUENTIAL_LAYOUT) {\n\t\t\t\t\tswitch (cols [MONO_CLASS_LAYOUT_PACKING_SIZE]) {\n\t\t\t\t\tcase 0: case 1: case 2: case 4: case 8: case 16:\n\t\t\t\t\tcase 32: case 64: case 128: break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Packing size %d in class layout row %d is invalid\", cols [MONO_CLASS_LAYOUT_PACKING_SIZE], i + 1));\n\t\t\t\t\t}\n\t\t\t\t} else if (value & TYPE_ATTRIBUTE_EXPLICIT_LAYOUT) {\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: LAMESPEC: it claims it must be 0 (it's 1, instead).\n\t\t\t\t\tif (cols [MONO_CLASS_LAYOUT_PACKING_SIZE])\n\t\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Packing size %d in class layout row %d is invalid with explicit layout\", cols [MONO_CLASS_LAYOUT_PACKING_SIZE], i + 1));\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * FIXME: we need to check that if class size != 0, \n\t\t\t\t * it needs to be greater than the class calculated size.\n\t\t\t\t * If parent is a valuetype it also needs to be smaller than\n\t\t\t\t * 1 MByte (0x100000 bytes).\n\t\t\t\t * To do both these checks we need to load the referenced \n\t\t\t\t * assemblies, though (the spec claims we didn't have to, bah).\n\t\t\t\t */\n\t\t\t\t/* \n\t\t\t\t * We need to check that the parent types have the same layout \n\t\t\t\t * type as well.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\t}\n\n\treturn list;\n}\n\nstatic GSList*\nverify_constant_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_CONSTANT];\n\tguint32 cols [MONO_CONSTANT_SIZE];\n\tguint32 value, i;\n\tGHashTable *dups = g_hash_table_new (NULL, NULL);\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_CONSTANT_SIZE);\n\n\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\tif (g_hash_table_lookup (dups, GUINT_TO_POINTER (cols [MONO_CONSTANT_PARENT])))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent 0x%08x is duplicated in Constant row %d\", cols [MONO_CONSTANT_PARENT], i + 1));\n\t\tg_hash_table_insert (dups, GUINT_TO_POINTER (cols [MONO_CONSTANT_PARENT]),\n\t\t\t\tGUINT_TO_POINTER (cols [MONO_CONSTANT_PARENT]));\n\n\t\tswitch (cols [MONO_CONSTANT_TYPE]) {\n\t\tcase MONO_TYPE_U1: /* LAMESPEC: it says I1...*/\n\t\tcase MONO_TYPE_U2:\n\t\tcase MONO_TYPE_U4:\n\t\tcase MONO_TYPE_U8:\n\t\t\tif (level & MONO_VERIFY_CLS)\n\t\t\t\tADD_WARN (list, MONO_VERIFY_CLS, g_strdup_printf (\"Type 0x%x not CLS compliant in Constant row %d\", cols [MONO_CONSTANT_TYPE], i + 1));\n\t\tcase MONO_TYPE_BOOLEAN:\n\t\tcase MONO_TYPE_CHAR:\n\t\tcase MONO_TYPE_I1:\n\t\tcase MONO_TYPE_I2:\n\t\tcase MONO_TYPE_I4:\n\t\tcase MONO_TYPE_I8:\n\t\tcase MONO_TYPE_R4:\n\t\tcase MONO_TYPE_R8:\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_CLASS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type 0x%x is invalid in Constant row %d\", cols [MONO_CONSTANT_TYPE], i + 1));\n\t\t}\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tvalue = cols [MONO_CONSTANT_PARENT] >> MONO_HASCONSTANT_BITS;\n\t\t\tswitch (cols [MONO_CONSTANT_PARENT] & MONO_HASCONSTANT_MASK) {\n\t\t\tcase MONO_HASCONSTANT_FIEDDEF:\n\t\t\t\tif (value > image->tables [MONO_TABLE_FIELD].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent (field) is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_HASCONSTANT_PARAM:\n\t\t\t\tif (value > image->tables [MONO_TABLE_PARAM].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent (param) is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_HASCONSTANT_PROPERTY:\n\t\t\t\tif (value > image->tables [MONO_TABLE_PROPERTY].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent (property) is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent is invalid in Constant row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (level & MONO_VERIFY_CLS) {\n\t\t\t/* \n\t\t\t * FIXME: verify types is consistent with the enum type\n\t\t\t * is parent is an enum.\n\t\t\t */\n\t\t}\n\t}\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_event_map_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_EVENTMAP];\n\tguint32 cols [MONO_EVENT_MAP_SIZE];\n\tguint32 i, last_event;\n\tGHashTable *dups = g_hash_table_new (NULL, NULL);\n\n\tlast_event = 0;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_EVENT_MAP_SIZE);\n\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\tif (g_hash_table_lookup (dups, GUINT_TO_POINTER (cols [MONO_EVENT_MAP_PARENT])))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent 0x%08x is duplicated in Event Map row %d\", cols [MONO_EVENT_MAP_PARENT], i + 1));\n\t\tg_hash_table_insert (dups, GUINT_TO_POINTER (cols [MONO_EVENT_MAP_PARENT]),\n\t\t\t\tGUINT_TO_POINTER (cols [MONO_EVENT_MAP_PARENT]));\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif (cols [MONO_EVENT_MAP_PARENT] > image->tables [MONO_TABLE_TYPEDEF].rows)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Parent 0x%08x is invalid in Event Map row %d\", cols [MONO_EVENT_MAP_PARENT], i + 1));\n\t\t\tif (cols [MONO_EVENT_MAP_EVENTLIST] > image->tables [MONO_TABLE_EVENT].rows)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"EventList 0x%08x is invalid in Event Map row %d\", cols [MONO_EVENT_MAP_EVENTLIST], i + 1));\n\n\t\t\tif (cols [MONO_EVENT_MAP_EVENTLIST] <= last_event)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"EventList overlap in Event Map row %d\", i + 1));\n\t\t\tlast_event = cols [MONO_EVENT_MAP_EVENTLIST];\n\t\t}\n\t}\n\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_event_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_EVENT];\n\tguint32 cols [MONO_EVENT_SIZE];\n\tconst char *p;\n\tguint32 value, i;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_EVENT_SIZE);\n\n\t\tif (cols [MONO_EVENT_FLAGS] & ~(EVENT_SPECIALNAME|EVENT_RTSPECIALNAME)) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Flags 0x%04x invalid in Event row %d\", cols [MONO_EVENT_FLAGS], i + 1));\n\t\t}\n\t\tif (!(p = is_valid_string (image, cols [MONO_EVENT_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in Event row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_CLS) {\n\t\t\t\tif (!is_valid_cls_ident (p))\n\t\t\t\t\tADD_WARN (list, MONO_VERIFY_CLS, g_strdup_printf (\"Invalid CLS name '%s` in Event row %d\", p, i + 1));\n\t\t\t}\n\t\t}\n\n\t\tif (level & MONO_VERIFY_ERROR && cols [MONO_EVENT_TYPE]) {\n\t\t\tvalue = cols [MONO_EVENT_TYPE] >> MONO_TYPEDEFORREF_BITS;\n\t\t\tswitch (cols [MONO_EVENT_TYPE] & MONO_TYPEDEFORREF_MASK) {\n\t\t\tcase MONO_TYPEDEFORREF_TYPEDEF:\n\t\t\t\tif (!value || value > image->tables [MONO_TABLE_TYPEDEF].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPEDEFORREF_TYPEREF:\n\t\t\t\tif (!value || value > image->tables [MONO_TABLE_TYPEREF].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPEDEFORREF_TYPESPEC:\n\t\t\t\tif (!value || value > image->tables [MONO_TABLE_TYPESPEC].rows)\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Type invalid in Event row %d\", i + 1));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * FIXME: check that there is 1 add and remove row in methodsemantics\n\t\t * and 0 or 1 raise and 0 or more other (maybe it's better to check for \n\t\t * these while checking methodsemantics).\n\t\t * check for duplicated names for the same type [ERROR]\n\t\t * check for CLS duplicate names for the same type [CLS]\n\t\t */\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_field_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_FIELD];\n\tguint32 cols [MONO_FIELD_SIZE];\n\tconst char *p;\n\tguint32 i, flags;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_FIELD_SIZE);\n\t\t/*\n\t\t * Check this field has only one owner and that the owner is not \n\t\t * an interface (done in verify_typedef_table() )\n\t\t */\n\t\tflags = cols [MONO_FIELD_FLAGS];\n\t\tswitch (flags & FIELD_ATTRIBUTE_FIELD_ACCESS_MASK) {\n\t\tcase FIELD_ATTRIBUTE_COMPILER_CONTROLLED:\n\t\tcase FIELD_ATTRIBUTE_PRIVATE:\n\t\tcase FIELD_ATTRIBUTE_FAM_AND_ASSEM:\n\t\tcase FIELD_ATTRIBUTE_ASSEMBLY:\n\t\tcase FIELD_ATTRIBUTE_FAMILY:\n\t\tcase FIELD_ATTRIBUTE_FAM_OR_ASSEM:\n\t\tcase FIELD_ATTRIBUTE_PUBLIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid access mask in Field row %d\", i + 1));\n\t\t\tbreak;\n\t\t}\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif ((flags & FIELD_ATTRIBUTE_LITERAL) && (flags & FIELD_ATTRIBUTE_INIT_ONLY))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Literal and InitOnly cannot be both set in Field row %d\", i + 1));\n\t\t\tif ((flags & FIELD_ATTRIBUTE_LITERAL) && !(flags & FIELD_ATTRIBUTE_STATIC))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Literal needs also Static set in Field row %d\", i + 1));\n\t\t\tif ((flags & FIELD_ATTRIBUTE_RT_SPECIAL_NAME) && !(flags & FIELD_ATTRIBUTE_SPECIAL_NAME))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"RTSpecialName needs also SpecialName set in Field row %d\", i + 1));\n\t\t\t/*\n\t\t\t * FIXME: check there is only one owner in the respective table.\n\t\t\t * if (flags & FIELD_ATTRIBUTE_HAS_FIELD_MARSHAL)\n\t\t\t * if (flags & FIELD_ATTRIBUTE_HAS_DEFAULT)\n\t\t\t * if (flags & FIELD_ATTRIBUTE_HAS_FIELD_RVA)\n\t\t\t */\n\t\t}\n\t\tif (!(p = is_valid_string (image, cols [MONO_FIELD_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in Field row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_CLS) {\n\t\t\t\tif (!is_valid_cls_ident (p))\n\t\t\t\t\tADD_WARN (list, MONO_VERIFY_CLS, g_strdup_printf (\"Invalid CLS name '%s` in Field row %d\", p, i + 1));\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * check signature.\n\t\t * if owner is module needs to be static, access mask needs to be compilercontrolled,\n\t\t * public or private (not allowed in cls mode).\n\t\t * if owner is an enum ...\n\t\t */\n\n\n\t}\n\treturn list;\n}\n\nstatic GSList*\nverify_file_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_FILE];\n\tguint32 cols [MONO_FILE_SIZE];\n\tconst char *p;\n\tguint32 i;\n\tGHashTable *dups = g_hash_table_new (g_str_hash, g_str_equal);\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_FILE_SIZE);\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif (cols [MONO_FILE_FLAGS] != FILE_CONTAINS_METADATA && cols [MONO_FILE_FLAGS] != FILE_CONTAINS_NO_METADATA)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid flags in File row %d\", i + 1));\n\t\t\tif (!is_valid_blob (image, cols [MONO_FILE_HASH_VALUE], TRUE))\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"File hash value in row %d is invalid or not null and empty\", i + 1));\n\t\t}\n\t\tif (!(p = is_valid_string (image, cols [MONO_FILE_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in File row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\t\tif (!is_valid_filename (p))\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name '%s` in File row %d\", p, i + 1));\n\t\t\t\telse if (g_hash_table_lookup (dups, p)) {\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Duplicate name '%s` in File row %d\", p, i + 1));\n\t\t\t\t}\n\t\t\t\tg_hash_table_insert (dups, (gpointer)p, (gpointer)p);\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * FIXME: I don't understand what this means:\n\t\t * If this module contains a row in the Assembly table (that is, if this module \"holds the manifest\") \n\t\t * then there shall not be any row in the File table for this module - i.e., no self-reference  [ERROR]\n\t\t */\n\n\t}\n\tif (level & MONO_VERIFY_WARNING) {\n\t\tif (!t->rows && image->tables [MONO_TABLE_EXPORTEDTYPE].rows)\n\t\t\tADD_WARN (list, MONO_VERIFY_WARNING, g_strdup (\"ExportedType table should be empty if File table is empty\"));\n\t}\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_moduleref_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_MODULEREF];\n\tMonoTableInfo *tfile = &image->tables [MONO_TABLE_FILE];\n\tguint32 cols [MONO_MODULEREF_SIZE];\n\tconst char *p, *pf;\n\tguint32 found, i, j, value;\n\tGHashTable *dups = g_hash_table_new (g_str_hash, g_str_equal);\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_MODULEREF_SIZE);\n\t\tif (!(p = is_valid_string (image, cols [MONO_MODULEREF_NAME], TRUE))) {\n\t\t\tif (level & MONO_VERIFY_ERROR)\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name in ModuleRef row %d\", i + 1));\n\t\t} else {\n\t\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\t\tif (!is_valid_filename (p))\n\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Invalid name '%s` in ModuleRef row %d\", p, i + 1));\n\t\t\t\telse if (g_hash_table_lookup (dups, p)) {\n\t\t\t\t\tADD_WARN (list, MONO_VERIFY_WARNING, g_strdup_printf (\"Duplicate name '%s` in ModuleRef row %d\", p, i + 1));\n\t\t\t\t\tg_hash_table_insert (dups, (gpointer)p, (gpointer)p);\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tfor (j = 0; j < tfile->rows; ++j) {\n\t\t\t\t\t\tvalue = mono_metadata_decode_row_col (tfile, j, MONO_FILE_NAME);\n\t\t\t\t\t\tif ((pf = is_valid_string (image, value, TRUE)))\n\t\t\t\t\t\t\tif (strcmp (p, pf) == 0) {\n\t\t\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!found)\n\t\t\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Name '%s` in ModuleRef row %d doesn't have a match in File table\", p, i + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tg_hash_table_destroy (dups);\n\treturn list;\n}\n\nstatic GSList*\nverify_standalonesig_table (MonoImage *image, GSList *list, int level)\n{\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_STANDALONESIG];\n\tguint32 cols [MONO_STAND_ALONE_SIGNATURE_SIZE];\n\tconst char *p;\n\tguint32 i;\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_STAND_ALONE_SIGNATURE_SIZE);\n\t\tif (level & MONO_VERIFY_ERROR) {\n\t\t\tif (!is_valid_blob (image, cols [MONO_STAND_ALONE_SIGNATURE], TRUE)) {\n\t\t\t\tADD_ERROR (list, g_strdup_printf (\"Signature is invalid in StandAloneSig row %d\", i + 1));\n\t\t\t} else {\n\t\t\t\tp = mono_metadata_blob_heap (image, cols [MONO_STAND_ALONE_SIGNATURE]);\n\t\t\t\t/* FIXME: check it's a valid locals or method sig.*/\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}\n\nGSList*\nmono_image_verify_tables (MonoImage *image, int level)\n{\n\tGSList *error_list = NULL;\n\n\terror_list = verify_assembly_table (image, error_list, level);\n\t/* \n\t * AssemblyOS, AssemblyProcessor, AssemblyRefOs and\n\t * AssemblyRefProcessor should be ignored, \n\t * though we may want to emit a warning, since it should not \n\t * be present in a PE file.\n\t */\n\terror_list = verify_assemblyref_table (image, error_list, level);\n\terror_list = verify_class_layout_table (image, error_list, level);\n\terror_list = verify_constant_table (image, error_list, level);\n\t/*\n\t * cutom attribute, declsecurity \n\t */\n\terror_list = verify_event_map_table (image, error_list, level);\n\terror_list = verify_event_table (image, error_list, level);\n\terror_list = verify_field_table (image, error_list, level);\n\terror_list = verify_file_table (image, error_list, level);\n\terror_list = verify_moduleref_table (image, error_list, level);\n\terror_list = verify_standalonesig_table (image, error_list, level);\n\n\treturn g_slist_reverse (error_list);\n}\n\n#define ADD_INVALID(list,msg)\t\\\n\tdo {\t\\\n\t\tMonoVerifyInfoExtended *vinfo = g_new (MonoVerifyInfoExtended, 1);\t\\\n\t\tvinfo->status = MONO_VERIFY_ERROR;\t\\\n\t\tvinfo->message = (msg);\t\\\n\t\t(list) = g_slist_prepend ((list), vinfo);\t\\\n\t\t/*G_BREAKPOINT ();*/\t\\\n\t\tgoto invalid_cil;\t\\\n\t} while (0)\n\n#define CHECK_STACK_UNDERFLOW(num)\t\\\n\tdo {\t\\\n\t\tif (cur_stack < (num))\t\\\n\t\t\tADD_INVALID (list, g_strdup_printf (\"Stack underflow at 0x%04x (%d items instead of %d)\", ip_offset, cur_stack, (num)));\t\\\n\t} while (0)\n\n#define CHECK_STACK_OVERFLOW()\t\\\n\tdo {\t\\\n\t\tif (cur_stack >= max_stack)\t\\\n\t\t\tADD_INVALID (list, g_strdup_printf (\"Maxstack exceeded at 0x%04x\", ip_offset));\t\\\n\t} while (0)\n\n\nstatic int\nin_any_block (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_CLAUSE (clause, offset))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * in_any_exception_block:\n * \n * Returns TRUE is @offset is part of any exception clause (filter, handler, catch, finally or fault).\n */\nstatic gboolean\nin_any_exception_block (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn TRUE;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/*\n * is_valid_branch_instruction:\n *\n * Verify if it's valid to perform a branch from @offset to @target.\n * This should be used with br and brtrue/false.\n * It returns 0 if valid, 1 for unverifiable and 2 for invalid.\n * The major diferent from other similiar functions is that branching into a\n * finally/fault block is invalid instead of just unverifiable.  \n */\nstatic int\nis_valid_branch_instruction (MonoMethodHeader *header, guint offset, guint target)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\t/*branching into a finally block is invalid*/\n\t\tif ((clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY || clause->flags == MONO_EXCEPTION_CLAUSE_FAULT) &&\n\t\t\t!MONO_OFFSET_IN_HANDLER (clause, offset) &&\n\t\t\tMONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 2;\n\n\t\tif (clause->try_offset != target && (MONO_OFFSET_IN_CLAUSE (clause, offset) ^ MONO_OFFSET_IN_CLAUSE (clause, target)))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset) ^ MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset) ^ MONO_OFFSET_IN_FILTER (clause, target))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * is_valid_cmp_branch_instruction:\n * \n * Verify if it's valid to perform a branch from @offset to @target.\n * This should be used with binary comparison branching instruction, like beq, bge and similars.\n * It returns 0 if valid, 1 for unverifiable and 2 for invalid.\n * \n * The major diferences from other similar functions are that most errors lead to invalid\n * code and only branching out of finally, filter or fault clauses is unverifiable. \n */\nstatic int\nis_valid_cmp_branch_instruction (MonoMethodHeader *header, guint offset, guint target)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\t/*branching out of a handler or finally*/\n\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_NONE &&\n\t\t\tMONO_OFFSET_IN_HANDLER (clause, offset) &&\n\t\t\t!MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 1;\n\n\t\tif (clause->try_offset != target && (MONO_OFFSET_IN_CLAUSE (clause, offset) ^ MONO_OFFSET_IN_CLAUSE (clause, target)))\n\t\t\treturn 2;\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset) ^ MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 2;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset) ^ MONO_OFFSET_IN_FILTER (clause, target))\n\t\t\treturn 2;\n\t}\n\treturn 0;\n}\n\n/*\n * A leave can't escape a finally block \n */\nstatic int\nis_correct_leave (MonoMethodHeader *header, guint offset, guint target)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY && MONO_OFFSET_IN_HANDLER (clause, offset) && !MONO_OFFSET_IN_HANDLER (clause, target))\n\t\t\treturn 0;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*\n * A rethrow can't happen outside of a catch handler.\n */\nstatic int\nis_correct_rethrow (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn 1;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * An endfinally can't happen outside of a finally/fault handler.\n */\nstatic int\nis_correct_endfinally (MonoMethodHeader *header, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tclause = &header->clauses [i];\n\t\tif (MONO_OFFSET_IN_HANDLER (clause, offset) && (clause->flags == MONO_EXCEPTION_CLAUSE_FAULT || clause->flags == MONO_EXCEPTION_CLAUSE_FINALLY))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n/*\n * An endfilter can only happens inside a filter clause.\n * In non-strict mode filter is allowed inside the handler clause too\n */\nstatic MonoExceptionClause *\nis_correct_endfilter (VerifyContext *ctx, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < ctx->header->num_clauses; ++i) {\n\t\tclause = &ctx->header->clauses [i];\n\t\tif (clause->flags != MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tcontinue;\n\t\tif (MONO_OFFSET_IN_FILTER (clause, offset))\n\t\t\treturn clause;\n\t\tif (!IS_STRICT_MODE (ctx) && MONO_OFFSET_IN_HANDLER (clause, offset))\n\t\t\treturn clause;\n\t}\n\treturn NULL;\n}\n\n\n/*\n * Non-strict endfilter can happens inside a try block or any handler block\n */\nstatic int\nis_unverifiable_endfilter (VerifyContext *ctx, guint offset)\n{\n\tint i;\n\tMonoExceptionClause *clause;\n\n\tfor (i = 0; i < ctx->header->num_clauses; ++i) {\n\t\tclause = &ctx->header->clauses [i];\n\t\tif (MONO_OFFSET_IN_CLAUSE (clause, offset))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic gboolean\nis_valid_bool_arg (ILStackDesc *arg)\n{\n\tif (stack_slot_is_managed_pointer (arg) || stack_slot_is_boxed_value (arg) || stack_slot_is_null_literal (arg))\n\t\treturn TRUE;\n\n\n\tswitch (stack_slot_get_underlying_type (arg)) {\n\tcase TYPE_I4:\n\tcase TYPE_I8:\n\tcase TYPE_NATIVE_INT:\n\tcase TYPE_PTR:\n\t\treturn TRUE;\n\tcase TYPE_COMPLEX:\n\t\tg_assert (arg->type);\n\t\tswitch (arg->type->type) {\n\t\tcase MONO_TYPE_CLASS:\n\t\tcase MONO_TYPE_STRING:\n\t\tcase MONO_TYPE_OBJECT:\n\t\tcase MONO_TYPE_SZARRAY:\n\t\tcase MONO_TYPE_ARRAY:\n\t\tcase MONO_TYPE_FNPTR:\n\t\tcase MONO_TYPE_PTR:\n\t\t\treturn TRUE;\n\t\tcase MONO_TYPE_GENERICINST:\n\t\t\t/*We need to check if the container class\n\t\t\t * of the generic type is a valuetype, iow:\n\t\t\t * is it a \"class Foo<T>\" or a \"struct Foo<T>\"?\n\t\t\t */\n\t\t\treturn !arg->type->data.generic_class->container_class->valuetype;\n\t\t}\n\tdefault:\n\t\treturn FALSE;\n\t}\n}\n\n\n/*Type manipulation helper*/\n\n/*Returns the byref version of the supplied MonoType*/\nstatic MonoType*\nmono_type_get_type_byref (MonoType *type)\n{\n\tif (type->byref)\n\t\treturn type;\n\treturn &mono_class_from_mono_type (type)->this_arg;\n}\n\n\n/*Returns the byval version of the supplied MonoType*/\nstatic MonoType*\nmono_type_get_type_byval (MonoType *type)\n{\n\tif (!type->byref)\n\t\treturn type;\n\treturn &mono_class_from_mono_type (type)->byval_arg;\n}\n\nstatic MonoType*\nmono_type_from_stack_slot (ILStackDesc *slot)\n{\n\tif (stack_slot_is_managed_pointer (slot))\n\t\treturn mono_type_get_type_byref (slot->type);\n\treturn slot->type;\n}\n\n/*Stack manipulation code*/\n\nstatic void\nstack_init (VerifyContext *ctx, ILCodeDesc *state) \n{\n\tif (state->flags & IL_CODE_FLAG_STACK_INITED)\n\t\treturn;\n\tstate->size = 0;\n\tstate->flags |= IL_CODE_FLAG_STACK_INITED;\n\tif (!state->stack)\n\t\tstate->stack = g_new0 (ILStackDesc, ctx->max_stack);\n}\n\nstatic void\nstack_copy (ILCodeDesc *to, ILCodeDesc *from)\n{\n\tto->size = from->size;\n\tmemcpy (to->stack, from->stack, sizeof (ILStackDesc) * from->size);\n}\n\nstatic void\ncopy_stack_value (ILStackDesc *to, ILStackDesc *from)\n{\n\tto->stype = from->stype;\n\tto->type = from->type;\n\tto->method = from->method;\n}\n\nstatic int\ncheck_underflow (VerifyContext *ctx, int size)\n{\n\tif (ctx->eval.size < size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack underflow, required %d, but have %d at 0x%04x\", size, ctx->eval.size, ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\ncheck_overflow (VerifyContext *ctx)\n{\n\tif (ctx->eval.size >= ctx->max_stack) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have stack-depth %d at 0x%04x\", ctx->eval.size + 1, ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*This reject out PTR, FNPTR and TYPEDBYREF*/\nstatic gboolean\ncheck_unmanaged_pointer (VerifyContext *ctx, ILStackDesc *value)\n{\n\tif (stack_slot_get_type (value) == TYPE_PTR) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Unmanaged pointer is not a verifiable type at 0x%04x\", ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/*TODO verify if MONO_TYPE_TYPEDBYREF is not allowed here as well.*/\nstatic gboolean\ncheck_unverifiable_type (VerifyContext *ctx, MonoType *type)\n{\n\tif (type->type == MONO_TYPE_PTR || type->type == MONO_TYPE_FNPTR) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Unmanaged pointer is not a verifiable type at 0x%04x\", ctx->ip_offset));\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n\nstatic ILStackDesc *\nstack_push (VerifyContext *ctx)\n{\n\tg_assert (ctx->eval.size < ctx->max_stack);\n\treturn & ctx->eval.stack [ctx->eval.size++];\n}\n\nstatic ILStackDesc *\nstack_push_val (VerifyContext *ctx, int stype, MonoType *type)\n{\n\tILStackDesc *top = stack_push (ctx);\n\ttop->stype = stype;\n\ttop->type = type;\n\treturn top;\n}\n\nstatic ILStackDesc *\nstack_pop (VerifyContext *ctx)\n{\n\tILStackDesc *ret;\n\tg_assert (ctx->eval.size > 0);\t\n\tret = ctx->eval.stack + --ctx->eval.size;\n\tif ((ret->stype & UNINIT_THIS_MASK) == UNINIT_THIS_MASK)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Found use of uninitialized 'this ptr' ref at 0x%04x\", ctx->ip_offset));\n\treturn ret;\n}\n\n/* This function allows to safely pop an unititialized this ptr from\n * the eval stack without marking the method as unverifiable. \n */\nstatic ILStackDesc *\nstack_pop_safe (VerifyContext *ctx)\n{\n\tg_assert (ctx->eval.size > 0);\n\treturn ctx->eval.stack + --ctx->eval.size;\n}\n\nstatic ILStackDesc *\nstack_push_stack_val (VerifyContext *ctx, ILStackDesc *value)\n{\n\tILStackDesc *top = stack_push (ctx);\n\tcopy_stack_value (top, value);\n\treturn top;\n}\n\n/* Returns the MonoType associated with the token, or NULL if it is invalid.\n * \n * A boxable type can be either a reference or value type, but cannot be a byref type or an unmanaged pointer   \n * */\nstatic MonoType*\nget_boxable_mono_type (VerifyContext* ctx, int token, const char *opcode)\n{\n\tMonoType *type;\n\tMonoClass *class;\n\n\tif (!(type = verifier_load_type (ctx, token, opcode)))\n\t\treturn NULL;\n\n\tif (type->byref && type->type != MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of byref type for %s at 0x%04x\", opcode, ctx->ip_offset));\n\t\treturn NULL;\n\t}\n\n\tif (type->type == MONO_TYPE_VOID) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of void type for %s at 0x%04x\", opcode, ctx->ip_offset));\n\t\treturn NULL;\n\t}\n\n\tif (type->type == MONO_TYPE_TYPEDBYREF)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid use of typedbyref for %s at 0x%04x\", opcode, ctx->ip_offset));\n\n\tif (!(class = mono_class_from_mono_type (type)))\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not retrieve type token for %s at 0x%04x\", opcode, ctx->ip_offset));\n\n\tif (class->generic_container && type->type != MONO_TYPE_GENERICINST)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use the generic type definition in a boxable type position for %s at 0x%04x\", opcode, ctx->ip_offset));\t\n\n\tcheck_unverifiable_type (ctx, type);\n\treturn type;\n}\n\n\n/*operation result tables */\n\nstatic const unsigned char bin_op_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_R8, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char add_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_R8, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char sub_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_R8, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_NATIVE_INT | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char int_bin_op_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char shift_op_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_I8, TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char cmp_br_op [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char cmp_br_eq_op [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_I4, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_I4 | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_I4 | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_I4, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_I4},\n};\n\nstatic const unsigned char add_ovf_un_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char sub_ovf_un_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_PTR | NON_VERIFIABLE_RESULT, TYPE_INV, TYPE_NATIVE_INT | NON_VERIFIABLE_RESULT, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\nstatic const unsigned char bin_ovf_table [TYPE_MAX][TYPE_MAX] = {\n\t{TYPE_I4, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_I8, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_NATIVE_INT, TYPE_INV, TYPE_NATIVE_INT, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n\t{TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV, TYPE_INV},\n};\n\n#ifdef MONO_VERIFIER_DEBUG\n\n/*debug helpers */\nstatic void\ndump_stack_value (ILStackDesc *value)\n{\n\tprintf (\"[(%x)(%x)\", value->type->type, value->stype);\n\n\tif (stack_slot_is_this_pointer (value))\n\t\tprintf (\"[this] \");\n\n\tif (stack_slot_is_boxed_value (value))\n\t\tprintf (\"[boxed] \");\n\n\tif (stack_slot_is_null_literal (value))\n\t\tprintf (\"[null] \");\n\n\tif (stack_slot_is_managed_mutability_pointer (value))\n\t\tprintf (\"Controled Mutability MP: \");\n\n\tif (stack_slot_is_managed_pointer (value))\n\t\tprintf (\"Managed Pointer to: \");\n\n\tswitch (stack_slot_get_underlying_type (value)) {\n\t\tcase TYPE_INV:\n\t\t\tprintf (\"invalid type]\"); \n\t\t\treturn;\n\t\tcase TYPE_I4:\n\t\t\tprintf (\"int32]\"); \n\t\t\treturn;\n\t\tcase TYPE_I8:\n\t\t\tprintf (\"int64]\"); \n\t\t\treturn;\n\t\tcase TYPE_NATIVE_INT:\n\t\t\tprintf (\"native int]\"); \n\t\t\treturn;\n\t\tcase TYPE_R8:\n\t\t\tprintf (\"float64]\"); \n\t\t\treturn;\n\t\tcase TYPE_PTR:\n\t\t\tprintf (\"unmanaged pointer]\"); \n\t\t\treturn;\n\t\tcase TYPE_COMPLEX:\n\t\t\tswitch (value->type->type) {\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_VALUETYPE:\n\t\t\t\tprintf (\"complex] (%s)\", value->type->data.klass->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\tprintf (\"complex] (string)\");\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\t\tprintf (\"complex] (object)\");\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_SZARRAY:\n\t\t\t\tprintf (\"complex] (%s [])\", value->type->data.klass->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_ARRAY:\n\t\t\t\tprintf (\"complex] (%s [%d %d %d])\",\n\t\t\t\t\tvalue->type->data.array->eklass->name,\n\t\t\t\t\tvalue->type->data.array->rank,\n\t\t\t\t\tvalue->type->data.array->numsizes,\n\t\t\t\t\tvalue->type->data.array->numlobounds);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_GENERICINST:\n\t\t\t\tprintf (\"complex] (inst of %s )\", value->type->data.generic_class->container_class->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_VAR:\n\t\t\t\tprintf (\"complex] (type generic param !%d - %s) \", value->type->data.generic_param->num, mono_generic_param_info (value->type->data.generic_param)->name);\n\t\t\t\treturn;\n\t\t\tcase MONO_TYPE_MVAR:\n\t\t\t\tprintf (\"complex] (method generic param !!%d - %s) \", value->type->data.generic_param->num, mono_generic_param_info (value->type->data.generic_param)->name);\n\t\t\t\treturn;\n\t\t\tdefault: {\n\t\t\t\t//should be a boxed value \n\t\t\t\tchar * name = mono_type_full_name (value->type);\n\t\t\t\tprintf (\"complex] %s\", name);\n\t\t\t\tg_free (name);\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tprintf (\"unknown stack %x type]\\n\", value->stype);\n\t\t\tg_assert_not_reached ();\n\t}\n}\n\nstatic void\ndump_stack_state (ILCodeDesc *state) \n{\n\tint i;\n\n\tprintf (\"(%d) \", state->size);\n\tfor (i = 0; i < state->size; ++i)\n\t\tdump_stack_value (state->stack + i);\n\tprintf (\"\\n\");\n}\n#endif\n\n/*Returns TRUE if candidate array type can be assigned to target.\n *Both parameters MUST be of type MONO_TYPE_ARRAY (target->type == MONO_TYPE_ARRAY)\n */\nstatic gboolean\nis_array_type_compatible (MonoType *target, MonoType *candidate)\n{\n\tMonoArrayType *left = target->data.array;\n\tMonoArrayType *right = candidate->data.array;\n\n\tg_assert (target->type == MONO_TYPE_ARRAY);\n\tg_assert (candidate->type == MONO_TYPE_ARRAY);\n\n\tif (left->rank != right->rank)\n\t\treturn FALSE;\n\n\treturn mono_class_is_assignable_from (left->eklass, right->eklass);\n}\n\nstatic int\nget_stack_type (MonoType *type)\n{\n\tint mask = 0;\n\tint type_kind = type->type;\n\tif (type->byref)\n\t\tmask = POINTER_MASK;\n\t/*TODO handle CMMP_MASK */\n\nhandle_enum:\n\tswitch (type_kind) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\treturn TYPE_I4 | mask;\n\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\treturn TYPE_NATIVE_INT | mask;\n\n\t/* FIXME: the spec says that you cannot have a pointer to method pointer, do we need to check this here? */ \n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TYPE_PTR | mask;\n\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\t\treturn TYPE_COMPLEX | mask;\n\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\treturn TYPE_I8 | mask;\n\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\t\treturn TYPE_R8 | mask;\n\n\tcase MONO_TYPE_GENERICINST:\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (mono_type_is_enum_type (type)) {\n\t\t\ttype = mono_type_get_underlying_type_any (type);\n\t\t\tif (!type)\n\t\t\t\treturn FALSE;\n\t\t\ttype_kind = type->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\treturn TYPE_COMPLEX | mask;\n\t\t}\n\n\tdefault:\n\t\treturn TYPE_INV;\n\t}\n}\n\n/* convert MonoType to ILStackDesc format (stype) */\nstatic gboolean\nset_stack_value (VerifyContext *ctx, ILStackDesc *stack, MonoType *type, int take_addr)\n{\n\tint mask = 0;\n\tint type_kind = type->type;\n\n\tif (type->byref || take_addr)\n\t\tmask = POINTER_MASK;\n\t/* TODO handle CMMP_MASK */\n\nhandle_enum:\n\tstack->type = type;\n\n\tswitch (type_kind) {\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\t\tstack->stype = TYPE_I4 | mask;\n\t\tbreak;\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\t\tstack->stype = TYPE_NATIVE_INT | mask;\n\t\tbreak;\n\n\t/*FIXME: Do we need to check if it's a pointer to the method pointer? The spec says it' illegal to have that.*/\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tstack->stype = TYPE_PTR | mask;\n\t\tbreak;\n\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR: \n\t\tstack->stype = TYPE_COMPLEX | mask;\n\t\tbreak;\n\t\t\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\tstack->stype = TYPE_I8 | mask;\n\t\tbreak;\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\t\tstack->stype = TYPE_R8 | mask;\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (mono_type_is_enum_type (type)) {\n\t\t\tMonoType *utype = mono_type_get_underlying_type_any (type);\n\t\t\tif (!utype) {\n\t\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not resolve underlying type of %x at %d\", type->type, ctx->ip_offset));\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\ttype = utype;\n\t\t\ttype_kind = type->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tstack->stype = TYPE_COMPLEX | mask;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tVERIFIER_DEBUG ( printf (\"unknown type 0x%02x in eval stack type\\n\", type->type); );\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Illegal value set on stack 0x%02x at %d\", type->type, ctx->ip_offset));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\n/* \n * init_stack_with_value_at_exception_boundary:\n * \n * Initialize the stack and push a given type.\n * The instruction is marked as been on the exception boundary.\n */\nstatic void\ninit_stack_with_value_at_exception_boundary (VerifyContext *ctx, ILCodeDesc *code, MonoClass *klass)\n{\n\tMonoError error;\n\tMonoType *type = mono_class_inflate_generic_type_checked (&klass->byval_arg, ctx->generic_context, &error);\n\n\tif (!mono_error_ok (&error)) {\n\t\tchar *name = mono_type_get_full_name (klass);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid class %s used for exception\", name));\n\t\tg_free (name);\n\t\tmono_error_cleanup (&error);\n\t\treturn;\n\t}\n\n\tif (!ctx->max_stack) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack overflow at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tstack_init (ctx, code);\n\tset_stack_value (ctx, code->stack, type, FALSE);\n\tctx->exception_types = g_slist_prepend (ctx->exception_types, type);\n\tcode->size = 1;\n\tcode->flags |= IL_CODE_FLAG_WAS_TARGET;\n\tif (mono_type_is_generic_argument (type))\n\t\tcode->stack->stype |= BOXED_MASK;\n}\n\n/*Verify if type 'candidate' can be stored in type 'target'.\n * \n * If strict, check for the underlying type and not the verification stack types\n */\nstatic gboolean\nverify_type_compatibility_full (VerifyContext *ctx, MonoType *target, MonoType *candidate, gboolean strict)\n{\n#define IS_ONE_OF3(T, A, B, C) (T == A || T == B || T == C)\n#define IS_ONE_OF2(T, A, B) (T == A || T == B)\n\n\tMonoType *original_candidate = candidate;\n\tVERIFIER_DEBUG ( printf (\"checking type compatibility %s x %s strict %d\\n\", mono_type_full_name (target), mono_type_full_name (candidate), strict); );\n\n \t/*only one is byref */\n\tif (candidate->byref ^ target->byref) {\n\t\t/* converting from native int to byref*/\n\t\tif (get_stack_type (candidate) == TYPE_NATIVE_INT && target->byref) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"using byref native int at 0x%04x\", ctx->ip_offset));\n\t\t\treturn TRUE;\n\t\t}\n\t\treturn FALSE;\n\t}\n\tstrict |= target->byref;\n\t/*From now on we don't care about byref anymore, so it's ok to discard it here*/\n\tcandidate = mono_type_get_underlying_type_any (candidate);\n\nhandle_enum:\n\tswitch (target->type) {\n\tcase MONO_TYPE_VOID:\n\t\treturn candidate->type == MONO_TYPE_VOID;\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\t\tif (strict)\n\t\t\treturn IS_ONE_OF3 (candidate->type, MONO_TYPE_I1, MONO_TYPE_U1, MONO_TYPE_BOOLEAN);\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\t\tif (strict)\n\t\t\treturn IS_ONE_OF3 (candidate->type, MONO_TYPE_I2, MONO_TYPE_U2, MONO_TYPE_CHAR);\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4: {\n\t\tgboolean is_native_int = IS_ONE_OF2 (candidate->type, MONO_TYPE_I, MONO_TYPE_U);\n\t\tgboolean is_int4 = IS_ONE_OF2 (candidate->type, MONO_TYPE_I4, MONO_TYPE_U4);\n\t\tif (strict)\n\t\t\treturn is_native_int || is_int4;\n\t\treturn is_native_int || get_stack_type (candidate) == TYPE_I4;\n\t}\n\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\t\treturn IS_ONE_OF2 (candidate->type, MONO_TYPE_I8, MONO_TYPE_U8);\n\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\t\tif (strict)\n\t\t\treturn candidate->type == target->type;\n\t\treturn IS_ONE_OF2 (candidate->type, MONO_TYPE_R4, MONO_TYPE_R8);\n\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U: {\n\t\tgboolean is_native_int = IS_ONE_OF2 (candidate->type, MONO_TYPE_I, MONO_TYPE_U);\n\t\tgboolean is_int4 = IS_ONE_OF2 (candidate->type, MONO_TYPE_I4, MONO_TYPE_U4);\n\t\tif (strict)\n\t\t\treturn is_native_int || is_int4;\n\t\treturn is_native_int || get_stack_type (candidate) == TYPE_I4;\n\t}\n\n\tcase MONO_TYPE_PTR:\n\t\tif (candidate->type != MONO_TYPE_PTR)\n\t\t\treturn FALSE;\n\t\t/* check the underlying type */\n\t\treturn verify_type_compatibility_full (ctx, target->data.type, candidate->data.type, TRUE);\n\n\tcase MONO_TYPE_FNPTR: {\n\t\tMonoMethodSignature *left, *right;\n\t\tif (candidate->type != MONO_TYPE_FNPTR)\n\t\t\treturn FALSE;\n\n\t\tleft = mono_type_get_signature (target);\n\t\tright = mono_type_get_signature (candidate);\n\t\treturn mono_metadata_signature_equal (left, right) && left->call_convention == right->call_convention;\n\t}\n\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoClass *target_klass;\n\t\tMonoClass *candidate_klass;\n\t\tif (mono_type_is_enum_type (target)) {\n\t\t\ttarget = mono_type_get_underlying_type_any (target);\n\t\t\tif (!target)\n\t\t\t\treturn FALSE;\n\t\t\tgoto handle_enum;\n\t\t}\n\t\t/*\n\t\t * VAR / MVAR compatibility must be checked by verify_stack_type_compatibility\n\t\t * to take boxing status into account.\n\t\t */\n\t\tif (mono_type_is_generic_argument (original_candidate))\n\t\t\treturn FALSE;\n\n\t\ttarget_klass = mono_class_from_mono_type (target);\n\t\tcandidate_klass = mono_class_from_mono_type (candidate);\n\t\tif (mono_class_is_nullable (target_klass)) {\n\t\t\tif (!mono_class_is_nullable (candidate_klass))\n\t\t\t\treturn FALSE;\n\t\t\treturn target_klass == candidate_klass;\n\t\t}\n\t\t\n\t\treturn mono_class_is_assignable_from (target_klass, candidate_klass);\n\t}\n\n\tcase MONO_TYPE_STRING:\n\t\treturn candidate->type == MONO_TYPE_STRING;\n\n\tcase MONO_TYPE_CLASS:\n\t\t/*\n\t\t * VAR / MVAR compatibility must be checked by verify_stack_type_compatibility\n\t\t * to take boxing status into account.\n\t\t */\n\t\tif (mono_type_is_generic_argument (original_candidate))\n\t\t\treturn FALSE;\n\n\t\tif (candidate->type == MONO_TYPE_VALUETYPE)\n\t\t\treturn FALSE;\n\n\t\t/* If candidate is an enum it should return true for System.Enum and supertypes.\n\t\t * That's why here we use the original type and not the underlying type.\n\t\t */ \n\t\treturn mono_class_is_assignable_from (target->data.klass, mono_class_from_mono_type (original_candidate));\n\n\tcase MONO_TYPE_OBJECT:\n\t\treturn MONO_TYPE_IS_REFERENCE (candidate);\n\n\tcase MONO_TYPE_SZARRAY: {\n\t\tMonoClass *left;\n\t\tMonoClass *right;\n\t\tif (candidate->type != MONO_TYPE_SZARRAY)\n\t\t\treturn FALSE;\n\n\t\tleft = mono_class_from_mono_type (target)->element_class;\n\t\tright = mono_class_from_mono_type (candidate)->element_class;\n\t\treturn mono_class_is_assignable_from (left, right);\n\t}\n\n\tcase MONO_TYPE_ARRAY:\n\t\tif (candidate->type != MONO_TYPE_ARRAY)\n\t\t\treturn FALSE;\n\t\treturn is_array_type_compatible (target, candidate);\n\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn candidate->type == MONO_TYPE_TYPEDBYREF;\n\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *target_klass;\n\t\tMonoClass *candidate_klass;\n\n\t\tif (candidate->type == MONO_TYPE_CLASS)\n\t\t\treturn FALSE;\n\n\t\ttarget_klass = mono_class_from_mono_type (target);\n\t\tcandidate_klass = mono_class_from_mono_type (candidate);\n\t\tif (target_klass == candidate_klass)\n\t\t\treturn TRUE;\n\t\tif (mono_type_is_enum_type (target)) {\n\t\t\ttarget = mono_type_get_underlying_type_any (target);\n\t\t\tif (!target)\n\t\t\t\treturn FALSE;\n\t\t\tgoto handle_enum;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tcase MONO_TYPE_VAR:\n\t\tif (candidate->type != MONO_TYPE_VAR)\n\t\t\treturn FALSE;\n\t\treturn mono_type_get_generic_param_num (candidate) == mono_type_get_generic_param_num (target);\n\n\tcase MONO_TYPE_MVAR:\n\t\tif (candidate->type != MONO_TYPE_MVAR)\n\t\t\treturn FALSE;\n\t\treturn mono_type_get_generic_param_num (candidate) == mono_type_get_generic_param_num (target);\n\n\tdefault:\n\t\tVERIFIER_DEBUG ( printf (\"unknown store type %d\\n\", target->type); );\n\t\tg_assert_not_reached ();\n\t\treturn FALSE;\n\t}\n\treturn 1;\n#undef IS_ONE_OF3\n#undef IS_ONE_OF2\n}\n\nstatic gboolean\nverify_type_compatibility (VerifyContext *ctx, MonoType *target, MonoType *candidate)\n{\n\treturn verify_type_compatibility_full (ctx, target, candidate, FALSE);\n}\n\n/*\n * Returns the generic param bound to the context been verified.\n * \n */\nstatic MonoGenericParam*\nget_generic_param (VerifyContext *ctx, MonoType *param) \n{\n\tguint16 param_num = mono_type_get_generic_param_num (param);\n\tif (param->type == MONO_TYPE_VAR) {\n\t\tif (!ctx->generic_context->class_inst || ctx->generic_context->class_inst->type_argc <= param_num) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid generic type argument %d\", param_num));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ctx->generic_context->class_inst->type_argv [param_num]->data.generic_param;\n\t}\n\t\n\t/*param must be a MVAR */\n\tif (!ctx->generic_context->method_inst || ctx->generic_context->method_inst->type_argc <= param_num) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid generic method argument %d\", param_num));\n\t\treturn NULL;\n\t}\n\treturn ctx->generic_context->method_inst->type_argv [param_num]->data.generic_param;\n\t\n}\n\nstatic gboolean\nrecursive_boxed_constraint_type_check (VerifyContext *ctx, MonoType *type, MonoClass *constraint_class, int recursion_level)\n{\n\tMonoType *constraint_type = &constraint_class->byval_arg;\n\tif (recursion_level <= 0)\n\t\treturn FALSE;\n\n\tif (verify_type_compatibility_full (ctx, type, mono_type_get_type_byval (constraint_type), FALSE))\n\t\treturn TRUE;\n\n\tif (mono_type_is_generic_argument (constraint_type)) {\n\t\tMonoGenericParam *param = get_generic_param (ctx, constraint_type);\n\t\tMonoClass **class;\n\t\tif (!param)\n\t\t\treturn FALSE;\n\t\tfor (class = mono_generic_param_info (param)->constraints; class && *class; ++class) {\n\t\t\tif (recursive_boxed_constraint_type_check (ctx, type, *class, recursion_level - 1))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}\n\n/*\n * is_compatible_boxed_valuetype:\n * \n * Returns TRUE if @candidate / @stack is a valid boxed valuetype. \n * \n * @type The source type. It it tested to be of the proper type.    \n * @candidate type of the boxed valuetype.\n * @stack stack slot of the boxed valuetype, separate from @candidade since one could be changed before calling this function\n * @strict if TRUE candidate must be boxed compatible to the target type\n * \n */\nstatic gboolean\nis_compatible_boxed_valuetype (VerifyContext *ctx, MonoType *type, MonoType *candidate, ILStackDesc *stack, gboolean strict)\n{\n\tif (!stack_slot_is_boxed_value (stack))\n\t\treturn FALSE;\n\tif (type->byref || candidate->byref)\n\t\treturn FALSE;\n\n\tif (mono_type_is_generic_argument (candidate)) {\n\t\tMonoGenericParam *param = get_generic_param (ctx, candidate);\n\t\tMonoClass **class;\n\t\tif (!param)\n\t\t\treturn FALSE;\n\n\t\tfor (class = mono_generic_param_info (param)->constraints; class && *class; ++class) {\n\t\t\t/*256 should be enough since there can't be more than 255 generic arguments.*/\n\t\t\tif (recursive_boxed_constraint_type_check (ctx, type, *class, 256))\n\t\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\tif (mono_type_is_generic_argument (type))\n\t\treturn FALSE;\n\n\tif (!strict)\n\t\treturn TRUE;\n\n\treturn MONO_TYPE_IS_REFERENCE (type) && mono_class_is_assignable_from (mono_class_from_mono_type (type), mono_class_from_mono_type (candidate));\n}\n\nstatic int\nverify_stack_type_compatibility_full (VerifyContext *ctx, MonoType *type, ILStackDesc *stack, gboolean drop_byref, gboolean valuetype_must_be_boxed)\n{\n\tMonoType *candidate = mono_type_from_stack_slot (stack);\n\tif (MONO_TYPE_IS_REFERENCE (type) && !type->byref && stack_slot_is_null_literal (stack))\n\t\treturn TRUE;\n\n\tif (is_compatible_boxed_valuetype (ctx, type, candidate, stack, TRUE))\n\t\treturn TRUE;\n\n\tif (valuetype_must_be_boxed && !stack_slot_is_boxed_value (stack) && !MONO_TYPE_IS_REFERENCE (candidate))\n\t\treturn FALSE;\n\n\tif (!valuetype_must_be_boxed && stack_slot_is_boxed_value (stack))\n\t\treturn FALSE;\n\n\tif (drop_byref)\n\t\treturn verify_type_compatibility_full (ctx, type, mono_type_get_type_byval (candidate), FALSE);\n\n\treturn verify_type_compatibility_full (ctx, type, candidate, FALSE);\n}\n\nstatic int\nverify_stack_type_compatibility (VerifyContext *ctx, MonoType *type, ILStackDesc *stack)\n{\n\treturn verify_stack_type_compatibility_full (ctx, type, stack, FALSE, FALSE);\n}\n\nstatic gboolean\nmono_delegate_type_equal (MonoType *target, MonoType *candidate)\n{\n\tif (candidate->byref ^ target->byref)\n\t\treturn FALSE;\n\n\tswitch (target->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn candidate->type == target->type;\n\n\tcase MONO_TYPE_PTR:\n\t\treturn mono_delegate_type_equal (target->data.type, candidate->data.type);\n\n\tcase MONO_TYPE_FNPTR:\n\t\tif (candidate->type != MONO_TYPE_FNPTR)\n\t\t\treturn FALSE;\n\t\treturn mono_delegate_signature_equal (mono_type_get_signature (target), mono_type_get_signature (candidate), FALSE);\n\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoClass *target_klass;\n\t\tMonoClass *candidate_klass;\n\t\ttarget_klass = mono_class_from_mono_type (target);\n\t\tcandidate_klass = mono_class_from_mono_type (candidate);\n\t\t/*FIXME handle nullables and enum*/\n\t\treturn mono_class_is_assignable_from (target_klass, candidate_klass);\n\t}\n\tcase MONO_TYPE_OBJECT:\n\t\treturn MONO_TYPE_IS_REFERENCE (candidate);\n\n\tcase MONO_TYPE_CLASS:\n\t\treturn mono_class_is_assignable_from(target->data.klass, mono_class_from_mono_type (candidate));\n\n\tcase MONO_TYPE_SZARRAY:\n\t\tif (candidate->type != MONO_TYPE_SZARRAY)\n\t\t\treturn FALSE;\n\t\treturn mono_class_is_assignable_from (mono_class_from_mono_type (target)->element_class, mono_class_from_mono_type (candidate)->element_class);\n\n\tcase MONO_TYPE_ARRAY:\n\t\tif (candidate->type != MONO_TYPE_ARRAY)\n\t\t\treturn FALSE;\n\t\treturn is_array_type_compatible (target, candidate);\n\n\tcase MONO_TYPE_VALUETYPE:\n\t\t/*FIXME handle nullables and enum*/\n\t\treturn mono_class_from_mono_type (candidate) == mono_class_from_mono_type (target);\n\n\tcase MONO_TYPE_VAR:\n\t\treturn candidate->type == MONO_TYPE_VAR && mono_type_get_generic_param_num (target) == mono_type_get_generic_param_num (candidate);\n\t\treturn FALSE;\n\n\tcase MONO_TYPE_MVAR:\n\t\treturn candidate->type == MONO_TYPE_MVAR && mono_type_get_generic_param_num (target) == mono_type_get_generic_param_num (candidate);\n\t\treturn FALSE;\n\n\tdefault:\n\t\tVERIFIER_DEBUG ( printf (\"Unknown type %d. Implement me!\\n\", target->type); );\n\t\tg_assert_not_reached ();\n\t\treturn FALSE;\n\t}\n}\n\nstatic gboolean\nmono_delegate_param_equal (MonoType *delegate, MonoType *method)\n{\n\tif (mono_metadata_type_equal_full (delegate, method, TRUE))\n\t\treturn TRUE;\n\n\treturn mono_delegate_type_equal (method, delegate);\n}\n\nstatic gboolean\nmono_delegate_ret_equal (MonoType *delegate, MonoType *method)\n{\n\tif (mono_metadata_type_equal_full (delegate, method, TRUE))\n\t\treturn TRUE;\n\n\treturn mono_delegate_type_equal (delegate, method);\n}\n\n/*\n * mono_delegate_signature_equal:\n * \n * Compare two signatures in the way expected by delegates.\n * \n * This function only exists due to the fact that it should ignore the 'has_this' part of the signature.\n *\n * FIXME can this function be eliminated and proper metadata functionality be used?\n */\nstatic gboolean\nmono_delegate_signature_equal (MonoMethodSignature *delegate_sig, MonoMethodSignature *method_sig, gboolean is_static_ldftn)\n{\n\tint i;\n\tint method_offset = is_static_ldftn ? 1 : 0;\n\n\tif (delegate_sig->param_count + method_offset != method_sig->param_count) \n\t\treturn FALSE;\n\n\tif (delegate_sig->call_convention != method_sig->call_convention)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < delegate_sig->param_count; i++) { \n\t\tMonoType *p1 = delegate_sig->params [i];\n\t\tMonoType *p2 = method_sig->params [i + method_offset];\n\n\t\tif (!mono_delegate_param_equal (p1, p2))\n\t\t\treturn FALSE;\n\t}\n\n\tif (!mono_delegate_ret_equal (delegate_sig->ret, method_sig->ret))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\n/* \n * verify_ldftn_delegate:\n * \n * Verify properties of ldftn based delegates.\n */\nstatic void\nverify_ldftn_delegate (VerifyContext *ctx, MonoClass *delegate, ILStackDesc *value, ILStackDesc *funptr)\n{\n\tMonoMethod *method = funptr->method;\n\n\t/*ldftn non-final virtuals only allowed if method is not static,\n\t * the object is a this arg (comes from a ldarg.0), and there is no starg.0.\n\t * This rules doesn't apply if the object on stack is a boxed valuetype.\n\t */\n\tif ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) && !(method->flags & METHOD_ATTRIBUTE_FINAL) && !(method->klass->flags & TYPE_ATTRIBUTE_SEALED) && !stack_slot_is_boxed_value (value)) {\n\t\t/*A stdarg 0 must not happen, we fail here only in fail fast mode to avoid double error reports*/\n\t\tif (IS_FAIL_FAST_MODE (ctx) && ctx->has_this_store)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid ldftn with virtual function in method with stdarg 0 at  0x%04x\", ctx->ip_offset));\n\n\t\t/*current method must not be static*/\n\t\tif (ctx->method->flags & METHOD_ATTRIBUTE_STATIC)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid ldftn with virtual function at 0x%04x\", ctx->ip_offset));\n\n\t\t/*value is the this pointer, loaded using ldarg.0 */\n\t\tif (!stack_slot_is_this_pointer (value))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid object argument, it is not the this pointer, to ldftn with virtual method at  0x%04x\", ctx->ip_offset));\n\n\t\tctx->code [ctx->ip_offset].flags |= IL_CODE_LDFTN_DELEGATE_NONFINAL_VIRTUAL;\n\t}\n}\n\n/*\n * verify_delegate_compatibility:\n * \n * Verify delegate creation sequence.\n * \n */\nstatic void\nverify_delegate_compatibility (VerifyContext *ctx, MonoClass *delegate, ILStackDesc *value, ILStackDesc *funptr)\n{\n#define IS_VALID_OPCODE(offset, opcode) (ip [ip_offset - offset] == opcode && (ctx->code [ip_offset - offset].flags & IL_CODE_FLAG_SEEN))\n#define IS_LOAD_FUN_PTR(kind) (IS_VALID_OPCODE (6, CEE_PREFIX1) && ip [ip_offset - 5] == kind)\n\n\tMonoMethod *invoke, *method;\n\tconst guint8 *ip = ctx->header->code;\n\tguint32 ip_offset = ctx->ip_offset;\n\tgboolean is_static_ldftn = FALSE, is_first_arg_bound = FALSE;\n\t\n\tif (stack_slot_get_type (funptr) != TYPE_PTR || !funptr->method) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid function pointer parameter for delegate constructor at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\t\n\tinvoke = mono_get_delegate_invoke (delegate);\n\tmethod = funptr->method;\n\n\tif (!method || !mono_method_signature (method)) {\n\t\tchar *name = mono_type_get_full_name (delegate);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid method on stack to create delegate %s construction at 0x%04x\", name, ctx->ip_offset));\n\t\tg_free (name);\n\t\treturn;\n\t}\n\n\tif (!invoke || !mono_method_signature (invoke)) {\n\t\tchar *name = mono_type_get_full_name (delegate);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Delegate type %s with bad Invoke method at 0x%04x\", name, ctx->ip_offset));\n\t\tg_free (name);\n\t\treturn;\n\t}\n\n\tis_static_ldftn = (ip_offset > 5 && IS_LOAD_FUN_PTR (CEE_LDFTN)) && method->flags & METHOD_ATTRIBUTE_STATIC;\n\n\tif (is_static_ldftn)\n\t\tis_first_arg_bound = mono_method_signature (invoke)->param_count + 1 ==  mono_method_signature (method)->param_count;\n\n\tif (!mono_delegate_signature_equal (mono_method_signature (invoke), mono_method_signature (method), is_first_arg_bound)) {\n\t\tchar *fun_sig = mono_signature_get_desc (mono_method_signature (method), FALSE);\n\t\tchar *invoke_sig = mono_signature_get_desc (mono_method_signature (invoke), FALSE);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Function pointer signature '%s' doesn't match delegate's signature '%s' at 0x%04x\", fun_sig, invoke_sig, ctx->ip_offset));\n\t\tg_free (fun_sig);\n\t\tg_free (invoke_sig);\n\t}\n\n\t/* \n\t * Delegate code sequences:\n\t * [-6] ldftn token\n\t * newobj ...\n\t * \n\t * \n\t * [-7] dup\n\t * [-6] ldvirtftn token\n\t * newobj ...\n\t * \n\t * ldftn sequence:*/\n\tif (ip_offset > 5 && IS_LOAD_FUN_PTR (CEE_LDFTN)) {\n\t\tverify_ldftn_delegate (ctx, delegate, value, funptr);\n\t} else if (ip_offset > 6 && IS_VALID_OPCODE (7, CEE_DUP) && IS_LOAD_FUN_PTR (CEE_LDVIRTFTN)) {\n\t\tctx->code [ip_offset - 6].flags |= IL_CODE_DELEGATE_SEQUENCE;\t\n\t}else {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid code sequence for delegate creation at 0x%04x\", ctx->ip_offset));\n\t}\n\tctx->code [ip_offset].flags |= IL_CODE_DELEGATE_SEQUENCE;\n\n\t//general tests\n\tif (is_first_arg_bound) {\n\t\tif (mono_method_signature (method)->param_count == 0 || !verify_stack_type_compatibility_full (ctx, mono_method_signature (method)->params [0], value, FALSE, TRUE))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"This object not compatible with function pointer for delegate creation at 0x%04x\", ctx->ip_offset));\n\t} else {\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC) {\n\t\t\tif (!stack_slot_is_null_literal (value) && !is_first_arg_bound)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Non-null this args used with static function for delegate creation at 0x%04x\", ctx->ip_offset));\n\t\t} else {\n\t\t\tif (!verify_stack_type_compatibility_full (ctx, &method->klass->byval_arg, value, FALSE, TRUE) && !stack_slot_is_null_literal (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"This object not compatible with function pointer for delegate creation at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t}\n\n\tif (stack_slot_get_type (value) != TYPE_COMPLEX)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid first parameter for delegate creation at 0x%04x\", ctx->ip_offset));\n\n#undef IS_VALID_OPCODE\n#undef IS_LOAD_FUN_PTR\n}\n\n/* implement the opcode checks*/\nstatic void\npush_arg (VerifyContext *ctx, unsigned int arg, int take_addr) \n{\n\tILStackDesc *top;\n\n\tif (arg >= ctx->max_args) {\n\t\tif (take_addr) \n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have argument %d\", arg + 1));\n\t\telse {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Method doesn't have argument %d\", arg + 1));\n\t\t\tif (check_overflow (ctx)) //FIXME: what sane value could we ever push?\n\t\t\t\tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t}\n\t} else if (check_overflow (ctx)) {\n\t\t/*We must let the value be pushed, otherwise we would get an underflow error*/\n\t\tcheck_unverifiable_type (ctx, ctx->params [arg]);\n\t\tif (ctx->params [arg]->byref && take_addr)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"ByRef of ByRef at 0x%04x\", ctx->ip_offset));\n\t\ttop = stack_push (ctx);\n\t\tif (!set_stack_value (ctx, top, ctx->params [arg], take_addr))\n\t\t\treturn;\n\n\t\tif (arg == 0 && !(ctx->method->flags & METHOD_ATTRIBUTE_STATIC)) {\n\t\t\tif (take_addr)\n\t\t\t\tctx->has_this_store = TRUE;\n\t\t\telse\n\t\t\t\ttop->stype |= THIS_POINTER_MASK;\n\t\t\tif (mono_method_is_constructor (ctx->method) && !ctx->super_ctor_called && !ctx->method->klass->valuetype)\n\t\t\t\ttop->stype |= UNINIT_THIS_MASK;\n\t\t}\n\t} \n}\n\nstatic void\npush_local (VerifyContext *ctx, guint32 arg, int take_addr) \n{\n\tif (arg >= ctx->num_locals) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have local %d\", arg + 1));\n\t} else if (check_overflow (ctx)) {\n\t\t/*We must let the value be pushed, otherwise we would get an underflow error*/\n\t\tcheck_unverifiable_type (ctx, ctx->locals [arg]);\n\t\tif (ctx->locals [arg]->byref && take_addr)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"ByRef of ByRef at 0x%04x\", ctx->ip_offset));\n\n\t\tset_stack_value (ctx, stack_push (ctx), ctx->locals [arg], take_addr);\n\t} \n}\n\nstatic void\nstore_arg (VerifyContext *ctx, guint32 arg)\n{\n\tILStackDesc *value;\n\n\tif (arg >= ctx->max_args) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Method doesn't have argument %d at 0x%04x\", arg + 1, ctx->ip_offset));\n\t\tif (check_underflow (ctx, 1))\n\t\t\tstack_pop (ctx);\n\t\treturn;\n\t}\n\n\tif (check_underflow (ctx, 1)) {\n\t\tvalue = stack_pop (ctx);\n\t\tif (!verify_stack_type_compatibility (ctx, ctx->params [arg], value)) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type %s in argument store at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\t\t}\n\t}\n\tif (arg == 0 && !(ctx->method->flags & METHOD_ATTRIBUTE_STATIC))\n\t\tctx->has_this_store = 1;\n}\n\nstatic void\nstore_local (VerifyContext *ctx, guint32 arg)\n{\n\tILStackDesc *value;\n\tif (arg >= ctx->num_locals) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method doesn't have local var %d at 0x%04x\", arg + 1, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\t/*TODO verify definite assigment */\t\t\n\tif (check_underflow (ctx, 1)) {\n\t\tvalue = stack_pop(ctx);\n\t\tif (!verify_stack_type_compatibility (ctx, ctx->locals [arg], value)) {\n\t\t\tchar *expected = mono_type_full_name (ctx->locals [arg]);\n\t\t\tchar *found = stack_slot_full_name (value);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type '%s' on stack cannot be stored to local %d with type '%s' at 0x%04x\",\n\t\t\t\t\tfound,\n\t\t\t\t\targ,\n\t\t\t\t\texpected,\n\t\t\t\t\tctx->ip_offset));\n\t\t\tg_free (expected);\n\t\t\tg_free (found);\t\n\t\t}\n\t}\n}\n\n/*FIXME add and sub needs special care here*/\nstatic void\ndo_binop (VerifyContext *ctx, unsigned int opcode, const unsigned char table [TYPE_MAX][TYPE_MAX])\n{\n\tILStackDesc *a, *b, *top;\n\tint idxa, idxb, complexMerge = 0;\n\tunsigned char res;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\tb = stack_pop (ctx);\n\ta = stack_pop (ctx);\n\n\tidxa = stack_slot_get_underlying_type (a);\n\tif (stack_slot_is_managed_pointer (a)) {\n\t\tidxa = TYPE_PTR;\n\t\tcomplexMerge = 1;\n\t}\n\n\tidxb = stack_slot_get_underlying_type (b);\n\tif (stack_slot_is_managed_pointer (b)) {\n\t\tidxb = TYPE_PTR;\n\t\tcomplexMerge = 2;\n\t}\n\n\t--idxa;\n\t--idxb;\n\tres = table [idxa][idxb];\n\n\tVERIFIER_DEBUG ( printf (\"binop res %d\\n\", res); );\n\tVERIFIER_DEBUG ( printf (\"idxa %d idxb %d\\n\", idxa, idxb); );\n\n\ttop = stack_push (ctx);\n\tif (res == TYPE_INV) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Binary instruction applyed to ill formed stack (%s x %s)\", stack_slot_get_name (a), stack_slot_get_name (b)));\n\t\tcopy_stack_value (top, a);\n\t\treturn;\n\t}\n\n \tif (res & NON_VERIFIABLE_RESULT) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Binary instruction is not verifiable (%s x %s)\", stack_slot_get_name (a), stack_slot_get_name (b)));\n\n\t\tres = res & ~NON_VERIFIABLE_RESULT;\n \t}\n\n \tif (complexMerge && res == TYPE_PTR) {\n \t\tif (complexMerge == 1) \n \t\t\tcopy_stack_value (top, a);\n \t\telse if (complexMerge == 2)\n \t\t\tcopy_stack_value (top, b);\n\t\t/*\n\t\t * There is no need to merge the type of two pointers.\n\t\t * The only valid operation is subtraction, that returns a native\n\t\t *  int as result and can be used with any 2 pointer kinds.\n\t\t * This is valid acording to Patition III 1.1.4\n\t\t */\n \t} else\n \t\ttop->stype = res;\n \t\n}\n\n\nstatic void\ndo_boolean_branch_op (VerifyContext *ctx, int delta)\n{\n\tint target = ctx->ip_offset + delta;\n\tILStackDesc *top;\n\n\tVERIFIER_DEBUG ( printf (\"boolean branch offset %d delta %d target %d\\n\", ctx->ip_offset, delta, target); );\n \n\tif (target < 0 || target >= ctx->code_size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Boolean branch target out of code at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tswitch (is_valid_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\tcase 1:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\tcase 2:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tctx->target = target;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\tif (!is_valid_bool_arg (top))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Argument type %s not valid for brtrue/brfalse at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\n\tcheck_unmanaged_pointer (ctx, top);\n}\n\nstatic gboolean\nstack_slot_is_complex_type_not_reference_type (ILStackDesc *slot)\n{\n\treturn stack_slot_get_type (slot) == TYPE_COMPLEX && !MONO_TYPE_IS_REFERENCE (slot->type) && !stack_slot_is_boxed_value (slot);\n}\n\nstatic void\ndo_branch_op (VerifyContext *ctx, signed int delta, const unsigned char table [TYPE_MAX][TYPE_MAX])\n{\n\tILStackDesc *a, *b;\n\tint idxa, idxb;\n\tunsigned char res;\n\tint target = ctx->ip_offset + delta;\n\n\tVERIFIER_DEBUG ( printf (\"branch offset %d delta %d target %d\\n\", ctx->ip_offset, delta, target); );\n \n\tif (target < 0 || target >= ctx->code_size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target out of code at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tswitch (is_valid_cmp_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\tcase 1: /*FIXME use constants and not magic numbers.*/\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\tcase 2:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tctx->target = target;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tb = stack_pop (ctx);\n\ta = stack_pop (ctx);\n\n\tidxa = stack_slot_get_underlying_type (a);\n\tif (stack_slot_is_managed_pointer (a))\n\t\tidxa = TYPE_PTR;\n\n\tidxb = stack_slot_get_underlying_type (b);\n\tif (stack_slot_is_managed_pointer (b))\n\t\tidxb = TYPE_PTR;\n\n\tif (stack_slot_is_complex_type_not_reference_type (a) || stack_slot_is_complex_type_not_reference_type (b)) {\n\t\tres = TYPE_INV;\n\t} else {\n\t\t--idxa;\n\t\t--idxb;\n\t\tres = table [idxa][idxb];\n\t}\n\n\tVERIFIER_DEBUG ( printf (\"branch res %d\\n\", res); );\n\tVERIFIER_DEBUG ( printf (\"idxa %d idxb %d\\n\", idxa, idxb); );\n\n\tif (res == TYPE_INV) {\n\t\tCODE_NOT_VERIFIABLE (ctx,\n\t\t\tg_strdup_printf (\"Compare and Branch instruction applyed to ill formed stack (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset));\n\t} else if (res & NON_VERIFIABLE_RESULT) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Compare and Branch instruction is not verifiable (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset)); \n \t\tres = res & ~NON_VERIFIABLE_RESULT;\n \t}\n}\n\nstatic void\ndo_cmp_op (VerifyContext *ctx, const unsigned char table [TYPE_MAX][TYPE_MAX], guint32 opcode)\n{\n\tILStackDesc *a, *b;\n\tint idxa, idxb;\n\tunsigned char res;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\tb = stack_pop (ctx);\n\ta = stack_pop (ctx);\n\n\tif (opcode == CEE_CGT_UN) {\n\t\tif (stack_slot_get_type (a) == TYPE_COMPLEX && stack_slot_get_type (b) == TYPE_COMPLEX) {\n\t\t\tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tidxa = stack_slot_get_underlying_type (a);\n\tif (stack_slot_is_managed_pointer (a))\n\t\tidxa = TYPE_PTR;\n\n\tidxb = stack_slot_get_underlying_type (b);\n\tif (stack_slot_is_managed_pointer (b)) \n\t\tidxb = TYPE_PTR;\n\n\tif (stack_slot_is_complex_type_not_reference_type (a) || stack_slot_is_complex_type_not_reference_type (b)) {\n\t\tres = TYPE_INV;\n\t} else {\n\t\t--idxa;\n\t\t--idxb;\n\t\tres = table [idxa][idxb];\n\t}\n\n\tif(res == TYPE_INV) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf(\"Compare instruction applyed to ill formed stack (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset));\n\t} else if (res & NON_VERIFIABLE_RESULT) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Compare instruction is not verifiable (%s x %s) at 0x%04x\", stack_slot_get_name (a), stack_slot_get_name (b), ctx->ip_offset)); \n \t\tres = res & ~NON_VERIFIABLE_RESULT;\n \t}\n \tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n}\n\nstatic void\ndo_ret (VerifyContext *ctx)\n{\n\tMonoType *ret = ctx->signature->ret;\n\tVERIFIER_DEBUG ( printf (\"checking ret\\n\"); );\n\tif (ret->type != MONO_TYPE_VOID) {\n\t\tILStackDesc *top;\n\t\tif (!check_underflow (ctx, 1))\n\t\t\treturn;\n\n\t\ttop = stack_pop(ctx);\n\n\t\tif (!verify_stack_type_compatibility (ctx, ctx->signature->ret, top)) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible return value on stack with method signature ret at 0x%04x\", ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\n\t\tif (ret->byref || ret->type == MONO_TYPE_TYPEDBYREF || mono_type_is_value_type (ret, \"System\", \"ArgIterator\") || mono_type_is_value_type (ret, \"System\", \"RuntimeArgumentHandle\"))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Method returns byref, TypedReference, ArgIterator or RuntimeArgumentHandle at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tif (ctx->eval.size > 0) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Stack not empty (%d) after ret at 0x%04x\", ctx->eval.size, ctx->ip_offset));\n\t} \n\tif (in_any_block (ctx->header, ctx->ip_offset))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"ret cannot escape exception blocks at 0x%04x\", ctx->ip_offset));\n}\n\n/*\n * FIXME we need to fix the case of a non-virtual instance method defined in the parent but call using a token pointing to a subclass.\n * \tThis is illegal but mono_get_method_full decoded it.\n * TODO handle calling .ctor outside one or calling the .ctor for other class but super  \n */\nstatic void\ndo_invoke_method (VerifyContext *ctx, int method_token, gboolean virtual)\n{\n\tint param_count, i;\n\tMonoMethodSignature *sig;\n\tILStackDesc *value;\n\tMonoMethod *method;\n\tgboolean virt_check_this = FALSE;\n\tgboolean constrained = ctx->prefix_set & PREFIX_CONSTRAINED;\n\n\tif (!(method = verifier_load_method (ctx, method_token, virtual ? \"callvirt\" : \"call\")))\n\t\treturn;\n\n\tif (virtual) {\n\t\tCLEAR_PREFIX (ctx, PREFIX_CONSTRAINED);\n\n\t\tif (method->klass->valuetype) // && !constrained ???\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use callvirtual with valuetype method at 0x%04x\", ctx->ip_offset));\n\n\t\tif ((method->flags & METHOD_ATTRIBUTE_STATIC))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use callvirtual with static method at 0x%04x\", ctx->ip_offset));\n\n\t} else {\n\t\tif (method->flags & METHOD_ATTRIBUTE_ABSTRACT) \n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use call with an abstract method at 0x%04x\", ctx->ip_offset));\n\t\t\n\t\tif ((method->flags & METHOD_ATTRIBUTE_VIRTUAL) && !(method->flags & METHOD_ATTRIBUTE_FINAL) && !(method->klass->flags & TYPE_ATTRIBUTE_SEALED)) {\n\t\t\tvirt_check_this = TRUE;\n\t\t\tctx->code [ctx->ip_offset].flags |= IL_CODE_CALL_NONFINAL_VIRTUAL;\n\t\t}\n\t}\n\n\tif (!(sig = mono_method_get_signature_full (method, ctx->image, method_token, ctx->generic_context)))\n\t\tsig = mono_method_get_signature (method, ctx->image, method_token);\n\n\tif (!sig) {\n\t\tchar *name = mono_type_get_full_name (method->klass);\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not resolve signature of %s:%s at 0x%04x\", name, method->name, ctx->ip_offset));\n\t\tg_free (name);\n\t\treturn;\n\t}\n\n\tparam_count = sig->param_count + sig->hasthis;\n\tif (!check_underflow (ctx, param_count))\n\t\treturn;\n\n\tfor (i = sig->param_count - 1; i >= 0; --i) {\n\t\tVERIFIER_DEBUG ( printf (\"verifying argument %d\\n\", i); );\n\t\tvalue = stack_pop (ctx);\n\t\tif (!verify_stack_type_compatibility (ctx, sig->params[i], value)) {\n\t\t\tchar *stack_name = stack_slot_full_name (value);\n\t\t\tchar *sig_name = mono_type_full_name (sig->params [i]);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible parameter with function signature: Calling method with signature (%s) but for argument %d there is a (%s) on stack at 0x%04x\", sig_name, i, stack_name, ctx->ip_offset));\n\t\t\tg_free (stack_name);\n\t\t\tg_free (sig_name);\n\t\t}\n\n\t\tif (stack_slot_is_managed_mutability_pointer (value))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer as argument of %s at 0x%04x\", virtual ? \"callvirt\" : \"call\",  ctx->ip_offset));\n\n\t\tif ((ctx->prefix_set & PREFIX_TAIL) && stack_slot_is_managed_pointer (value)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Cannot  pass a byref argument to a tail %s at 0x%04x\", virtual ? \"callvirt\" : \"call\",  ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (sig->hasthis) {\n\t\tMonoType *type = &method->klass->byval_arg;\n\t\tILStackDesc copy;\n\n\t\tif (mono_method_is_constructor (method) && !method->klass->valuetype) {\n\t\t\tif (!mono_method_is_constructor (ctx->method))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a constructor outside one at 0x%04x\", ctx->ip_offset));\n\t\t\tif (method->klass != ctx->method->klass->parent && method->klass != ctx->method->klass)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a constructor to a type diferent that this or super at 0x%04x\", ctx->ip_offset));\n\n\t\t\tctx->super_ctor_called = TRUE;\n\t\t\tvalue = stack_pop_safe (ctx);\n\t\t\tif ((value->stype & THIS_POINTER_MASK) != THIS_POINTER_MASK)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid 'this ptr' argument for constructor at 0x%04x\", ctx->ip_offset));\n\t\t} else {\n\t\t\tvalue = stack_pop (ctx);\n\t\t}\n\t\t\t\n\t\tcopy_stack_value (&copy, value);\n\t\t//TODO we should extract this to a 'drop_byref_argument' and use everywhere\n\t\t//Other parts of the code suffer from the same issue of \n\t\tcopy.type = mono_type_get_type_byval (copy.type);\n\t\tcopy.stype &= ~POINTER_MASK;\n\n\t\tif (virt_check_this && !stack_slot_is_this_pointer (value) && !(method->klass->valuetype || stack_slot_is_boxed_value (value)))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a non-final virtual method from an objet diferent thant the this pointer at 0x%04x\", ctx->ip_offset));\n\n\t\tif (constrained && virtual) {\n\t\t\tif (!stack_slot_is_managed_pointer (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Object is not a managed pointer for a constrained call at 0x%04x\", ctx->ip_offset));\n\t\t\tif (!mono_metadata_type_equal_full (mono_type_get_type_byval (value->type), ctx->constrained_type, TRUE))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Object not compatible with constrained type at 0x%04x\", ctx->ip_offset));\n\t\t\tcopy.stype |= BOXED_MASK;\n\t\t} else {\n\t\t\tif (stack_slot_is_managed_pointer (value) && !mono_class_from_mono_type (value->type)->valuetype)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a reference type using a managed pointer to the this arg at 0x%04x\", ctx->ip_offset));\n\t\n\t\t\tif (!virtual && mono_class_from_mono_type (value->type)->valuetype && !method->klass->valuetype && !stack_slot_is_boxed_value (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot call a valuetype baseclass at 0x%04x\", ctx->ip_offset));\n\t\n\t\t\tif (virtual && mono_class_from_mono_type (value->type)->valuetype && !stack_slot_is_boxed_value (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a valuetype with callvirt at 0x%04x\", ctx->ip_offset));\n\t\n\t\t\tif (method->klass->valuetype && (stack_slot_is_boxed_value (value) || !stack_slot_is_managed_pointer (value)))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a boxed or literal valuetype to call a valuetype method at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t\tif (!verify_stack_type_compatibility (ctx, type, &copy)) {\n\t\t\tchar *expected = mono_type_full_name (type);\n\t\t\tchar *effective = stack_slot_full_name (&copy);\n\t\t\tchar *method_name = mono_method_full_name (method, TRUE);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible this argument on stack with method signature expected '%s' but got '%s' for a call to '%s' at 0x%04x\",\n\t\t\t\t\texpected, effective, method_name, ctx->ip_offset));\n\t\t\tg_free (method_name);\n\t\t\tg_free (effective);\n\t\t\tg_free (expected);\n\t\t}\n\n\t\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_method_full (ctx->method, method, mono_class_from_mono_type (value->type))) {\n\t\t\tchar *name = mono_method_full_name (method, TRUE);\n\t\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Method %s is not accessible at 0x%04x\", name, ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\t\t\tg_free (name);\n\t\t}\n\n\t} else if (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_method_full (ctx->method, method, NULL)) {\n\t\tchar *name = mono_method_full_name (method, TRUE);\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Method %s is not accessible at 0x%04x\", name, ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\t\tg_free (name);\n\t}\n\n\tif (sig->ret->type != MONO_TYPE_VOID) {\n\t\tif (check_overflow (ctx)) {\n\t\t\tvalue = stack_push (ctx);\n\t\t\tset_stack_value (ctx, value, sig->ret, FALSE);\n\t\t\tif ((ctx->prefix_set & PREFIX_READONLY) && method->klass->rank && !strcmp (method->name, \"Address\")) {\n\t\t\t\tctx->prefix_set &= ~PREFIX_READONLY;\n\t\t\t\tvalue->stype |= CMMP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ctx->prefix_set & PREFIX_TAIL)) {\n\t\tif (!mono_delegate_ret_equal (mono_method_signature (ctx->method)->ret, sig->ret))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Tail call with incompatible return type at 0x%04x\", ctx->ip_offset));\n\t\tif (ctx->header->code [ctx->ip_offset + 5] != CEE_RET)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Tail call not followed by ret at 0x%04x\", ctx->ip_offset));\n\t}\n\n}\n\nstatic void\ndo_push_static_field (VerifyContext *ctx, int token, gboolean take_addr)\n{\n\tMonoClassField *field;\n\tMonoClass *klass;\n\tif (!check_overflow (ctx))\n\t\treturn;\n\tif (!take_addr)\n\t\tCLEAR_PREFIX (ctx, PREFIX_VOLATILE);\n\n\tif (!(field = verifier_load_field (ctx, token, &klass, take_addr ? \"ldsflda\" : \"ldsfld\")))\n\t\treturn;\n\n\tif (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC)) { \n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Cannot load non static field at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\t/*taking the address of initonly field only works from the static constructor */\n\tif (take_addr && (field->type->attrs & FIELD_ATTRIBUTE_INIT_ONLY) &&\n\t\t!(field->parent == ctx->method->klass && (ctx->method->flags & (METHOD_ATTRIBUTE_SPECIAL_NAME | METHOD_ATTRIBUTE_STATIC)) && !strcmp (\".cctor\", ctx->method->name)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot take the address of a init-only field at 0x%04x\", ctx->ip_offset));\n\n\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, NULL))\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\n\tset_stack_value (ctx, stack_push (ctx), field->type, take_addr);\n}\n\nstatic void\ndo_store_static_field (VerifyContext *ctx, int token) {\n\tMonoClassField *field;\n\tMonoClass *klass;\n\tILStackDesc *value;\n\tCLEAR_PREFIX (ctx, PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\tif (!(field = verifier_load_field (ctx, token, &klass, \"stsfld\")))\n\t\treturn;\n\n\tif (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC)) { \n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Cannot store non static field at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (field->type->type == MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Typedbyref field is an unverfiable type in store static field at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, NULL))\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\n\tif (!verify_stack_type_compatibility (ctx, field->type, value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type %s in static field store at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\t\n}\n\nstatic gboolean\ncheck_is_valid_type_for_field_ops (VerifyContext *ctx, int token, ILStackDesc *obj, MonoClassField **ret_field, const char *opcode)\n{\n\tMonoClassField *field;\n\tMonoClass *klass;\n\tgboolean is_pointer;\n\n\t/*must be a reference type, a managed pointer, an unamanaged pointer, or a valuetype*/\n\tif (!(field = verifier_load_field (ctx, token, &klass, opcode)))\n\t\treturn FALSE;\n\n\t*ret_field = field;\n\t//the value on stack is going to be used as a pointer\n\tis_pointer = stack_slot_get_type (obj) == TYPE_PTR || (stack_slot_get_type (obj) == TYPE_NATIVE_INT && !get_stack_type (&field->parent->byval_arg));\n\n\tif (field->type->type == MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Typedbyref field is an unverfiable type at 0x%04x\", ctx->ip_offset));\n\t\treturn FALSE;\n\t}\n\tg_assert (obj->type);\n\n\t/*The value on the stack must be a subclass of the defining type of the field*/ \n\t/* we need to check if we can load the field from the stack value*/\n\tif (is_pointer) {\n\t\tif (stack_slot_get_underlying_type (obj) == TYPE_NATIVE_INT)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Native int is not a verifiable type to reference a field at 0x%04x\", ctx->ip_offset));\n\n\t\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, NULL))\n\t\t\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\t} else {\n\t\tif (!field->parent->valuetype && stack_slot_is_managed_pointer (obj))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type at stack is a managed pointer to a reference type and is not compatible to reference the field at 0x%04x\", ctx->ip_offset));\n\n\t\t/*a value type can be loaded from a value or a managed pointer, but not a boxed object*/\n\t\tif (field->parent->valuetype && stack_slot_is_boxed_value (obj))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type at stack is a boxed valuetype and is not compatible to reference the field at 0x%04x\", ctx->ip_offset));\n\n\t\tif (!stack_slot_is_null_literal (obj) && !verify_stack_type_compatibility_full (ctx, &field->parent->byval_arg, obj, TRUE, FALSE)) {\n\t\t\tchar *found = stack_slot_full_name (obj);\n\t\t\tchar *expected = mono_type_full_name (&field->parent->byval_arg);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Expected type '%s' but found '%s' referencing the 'this' argument at 0x%04x\", expected, found, ctx->ip_offset));\n\t\t\tg_free (found);\n\t\t\tg_free (expected);\n\t\t}\n\n\t\tif (!IS_SKIP_VISIBILITY (ctx) && !mono_method_can_access_field_full (ctx->method, field, mono_class_from_mono_type (obj->type)))\n\t\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Type at stack is not accessible at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_FIELD_ACCESS);\n\t} \n\n\tcheck_unmanaged_pointer (ctx, obj);\n\treturn TRUE;\n}\n\nstatic void\ndo_push_field (VerifyContext *ctx, int token, gboolean take_addr)\n{\n\tILStackDesc *obj;\n\tMonoClassField *field;\n\n\tif (!take_addr)\n\t\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\tobj = stack_pop_safe (ctx);\n\n\tif (!check_is_valid_type_for_field_ops (ctx, token, obj, &field, take_addr ? \"ldflda\" : \"ldfld\"))\n\t\treturn;\n\n\tif (take_addr && field->parent->valuetype && !stack_slot_is_managed_pointer (obj))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot take the address of a temporary value-type at 0x%04x\", ctx->ip_offset));\n\n\tif (take_addr && (field->type->attrs & FIELD_ATTRIBUTE_INIT_ONLY) &&\n\t\t!(field->parent == ctx->method->klass && mono_method_is_constructor (ctx->method)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot take the address of a init-only field at 0x%04x\", ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), field->type, take_addr);\n}\n\nstatic void\ndo_store_field (VerifyContext *ctx, int token)\n{\n\tILStackDesc *value, *obj;\n\tMonoClassField *field;\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\tobj = stack_pop_safe (ctx);\n\n\tif (!check_is_valid_type_for_field_ops (ctx, token, obj, &field, \"stfld\"))\n\t\treturn;\n\n\tif (!verify_stack_type_compatibility (ctx, field->type, value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible type %s in field store at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\t\n}\n\n/*TODO proper handle for Nullable<T>*/\nstatic void\ndo_box_value (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"box\");\n\tMonoClass *klass;\t\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\t/*box is a nop for reference types*/\n\n\tif (stack_slot_get_underlying_type (value) == TYPE_COMPLEX && MONO_TYPE_IS_REFERENCE (value->type) && MONO_TYPE_IS_REFERENCE (type)) {\n\t\tstack_push_stack_val (ctx, value)->stype |= BOXED_MASK;\n\t\treturn;\n\t}\n\n\n\tif (!verify_stack_type_compatibility (ctx, type, value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for boxing operation at 0x%04x\", ctx->ip_offset));\n\n\tklass = mono_class_from_mono_type (type);\n\tif (mono_class_is_nullable (klass))\n\t\ttype = &mono_class_get_nullable_param (klass)->byval_arg;\n\tstack_push_val (ctx, TYPE_COMPLEX | BOXED_MASK, type);\n}\n\nstatic void\ndo_unbox_value (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"unbox\");\n\n\tif (!type)\n\t\treturn;\n \n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!mono_class_from_mono_type (type)->valuetype)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid reference type for unbox at 0x%04x\", ctx->ip_offset));\n\n\tvalue = stack_pop (ctx);\n\n\t/*Value should be: a boxed valuetype or a reference type*/\n\tif (!(stack_slot_get_type (value) == TYPE_COMPLEX &&\n\t\t(stack_slot_is_boxed_value (value) || !mono_class_from_mono_type (value->type)->valuetype)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type %s at stack for unbox operation at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\n\tset_stack_value (ctx, value = stack_push (ctx), mono_type_get_type_byref (type), FALSE);\n\tvalue->stype |= CMMP_MASK;\n}\n\nstatic void\ndo_unbox_any (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"unbox.any\");\n\n\tif (!type)\n\t\treturn;\n \n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\t/*Value should be: a boxed valuetype or a reference type*/\n\tif (!(stack_slot_get_type (value) == TYPE_COMPLEX &&\n\t\t(stack_slot_is_boxed_value (value) || !mono_class_from_mono_type (value->type)->valuetype)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type %s at stack for unbox.any operation at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n \n\tset_stack_value (ctx, stack_push (ctx), type, FALSE);\n}\n\nstatic void\ndo_unary_math_op (VerifyContext *ctx, int op)\n{\n\tILStackDesc *value;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\tvalue = stack_pop (ctx);\n\tswitch (stack_slot_get_type (value)) {\n\tcase TYPE_I4:\n\tcase TYPE_I8:\n\tcase TYPE_NATIVE_INT:\n\t\tbreak;\n\tcase TYPE_R8:\n\t\tif (op == CEE_NEG)\n\t\t\tbreak;\n\tcase TYPE_COMPLEX: /*only enums are ok*/\n\t\tif (mono_type_is_enum_type (value->type))\n\t\t\tbreak;\n\tdefault:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for unary not at 0x%04x\", ctx->ip_offset));\n\t}\n\tstack_push_stack_val (ctx, value);\n}\n\nstatic void\ndo_conversion (VerifyContext *ctx, int kind) \n{\n\tILStackDesc *value;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\tvalue = stack_pop (ctx);\n\n\tswitch (stack_slot_get_type (value)) {\n\tcase TYPE_I4:\n\tcase TYPE_I8:\n\tcase TYPE_NATIVE_INT:\n\tcase TYPE_R8:\n\t\tbreak;\n\tdefault:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type (%s) at stack for conversion operation. Numeric type expected at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\t}\n\n\tswitch (kind) {\n\tcase TYPE_I4:\n\t\tstack_push_val (ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\tbreak;\n\tcase TYPE_I8:\n\t\tstack_push_val (ctx,TYPE_I8, &mono_defaults.int64_class->byval_arg);\n\t\tbreak;\n\tcase TYPE_R8:\n\t\tstack_push_val (ctx, TYPE_R8, &mono_defaults.double_class->byval_arg);\n\t\tbreak;\n\tcase TYPE_NATIVE_INT:\n\t\tstack_push_val (ctx, TYPE_NATIVE_INT, &mono_defaults.int_class->byval_arg);\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"unknown type %02x in conversion\", kind);\n\n\t}\n}\n\nstatic void\ndo_load_token (VerifyContext *ctx, int token) \n{\n\tgpointer handle;\n\tMonoClass *handle_class;\n\tif (!check_overflow (ctx))\n\t\treturn;\n\n\tswitch (token & 0xff000000) {\n\tcase MONO_TOKEN_TYPE_DEF:\n\tcase MONO_TOKEN_TYPE_REF:\n\tcase MONO_TOKEN_TYPE_SPEC:\n\tcase MONO_TOKEN_FIELD_DEF:\n\tcase MONO_TOKEN_METHOD_DEF:\n\tcase MONO_TOKEN_METHOD_SPEC:\n\tcase MONO_TOKEN_MEMBER_REF:\n\t\tif (!token_bounds_check (ctx->image, token)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Table index out of range 0x%x for token %x for ldtoken at 0x%04x\", mono_metadata_token_index (token), token, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid table 0x%x for token 0x%x for ldtoken at 0x%04x\", mono_metadata_token_table (token), token, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\thandle = mono_ldtoken (ctx->image, token, &handle_class, ctx->generic_context);\n\tif (!handle) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid token 0x%x for ldtoken at 0x%04x\", token, ctx->ip_offset));\n\t\treturn;\n\t}\n\tif (handle_class == mono_defaults.typehandle_class) {\n\t\tmono_type_is_valid_in_context (ctx, (MonoType*)handle);\n\t} else if (handle_class == mono_defaults.methodhandle_class) {\n\t\tmono_method_is_valid_in_context (ctx, (MonoMethod*)handle);\t\t\n\t} else if (handle_class == mono_defaults.fieldhandle_class) {\n\t\tmono_type_is_valid_in_context (ctx, &((MonoClassField*)handle)->parent->byval_arg);\t\t\t\t\n\t} else {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid ldtoken type %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t}\n\tstack_push_val (ctx, TYPE_COMPLEX, mono_class_get_type (handle_class));\n}\n\nstatic void\ndo_ldobj_value (VerifyContext *ctx, int token) \n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"ldobj\");\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\tif (!stack_slot_is_managed_pointer (value) \n\t\t\t&& stack_slot_get_type (value) != TYPE_NATIVE_INT\n\t\t\t&& !(stack_slot_get_type (value) == TYPE_PTR && value->type->type != MONO_TYPE_FNPTR)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid argument %s to ldobj at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (stack_slot_get_type (value) == TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Using native pointer to ldobj at 0x%04x\", ctx->ip_offset));\n\n\t/*We have a byval on the stack, but the comparison must be strict. */\n\tif (!verify_type_compatibility_full (ctx, type, mono_type_get_type_byval (value->type), TRUE))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for ldojb operation at 0x%04x\", ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), type, FALSE);\n}\n\nstatic void\ndo_stobj (VerifyContext *ctx, int token) \n{\n\tILStackDesc *dest, *src;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"stobj\");\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tsrc = stack_pop (ctx);\n\tdest = stack_pop (ctx);\n\n\tif (stack_slot_is_managed_mutability_pointer (dest))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with stobj at 0x%04x\", ctx->ip_offset));\n\n\tif (!stack_slot_is_managed_pointer (dest)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid destination of stobj operation at 0x%04x\", ctx->ip_offset));\n\n\tif (stack_slot_is_boxed_value (src) && !MONO_TYPE_IS_REFERENCE (src->type) && !MONO_TYPE_IS_REFERENCE (type))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use stobj with a boxed source value that is not a reference type at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_stack_type_compatibility (ctx, type, src))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Token and source types of stobj don't match at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_type_compatibility (ctx, mono_type_get_type_byval (dest->type), type))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Destination and token types of stobj don't match at 0x%04x\", ctx->ip_offset));\n}\n\nstatic void\ndo_cpobj (VerifyContext *ctx, int token)\n{\n\tILStackDesc *dest, *src;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"cpobj\");\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tsrc = stack_pop (ctx);\n\tdest = stack_pop (ctx);\n\n\tif (!stack_slot_is_managed_pointer (src)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid source of cpobj operation at 0x%04x\", ctx->ip_offset));\n\n\tif (!stack_slot_is_managed_pointer (dest)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid destination of cpobj operation at 0x%04x\", ctx->ip_offset));\n\n\tif (stack_slot_is_managed_mutability_pointer (dest))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with cpobj at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_type_compatibility (ctx, type, mono_type_get_type_byval (src->type)))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Token and source types of cpobj don't match at 0x%04x\", ctx->ip_offset));\n\n\tif (!verify_type_compatibility (ctx, mono_type_get_type_byval (dest->type), type))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Destination and token types of cpobj don't match at 0x%04x\", ctx->ip_offset));\n}\n\nstatic void\ndo_initobj (VerifyContext *ctx, int token)\n{\n\tILStackDesc *obj;\n\tMonoType *stack, *type = get_boxable_mono_type (ctx, token, \"initobj\");\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tobj = stack_pop (ctx);\n\n\tif (!stack_slot_is_managed_pointer (obj)) \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid object address for initobj at 0x%04x\", ctx->ip_offset));\n\n\tif (stack_slot_is_managed_mutability_pointer (obj))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with initobj at 0x%04x\", ctx->ip_offset));\n\n\tstack = mono_type_get_type_byval (obj->type);\n\tif (MONO_TYPE_IS_REFERENCE (stack)) {\n\t\tif (!verify_type_compatibility (ctx, stack, type)) \n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type token of initobj not compatible with value on stack at 0x%04x\", ctx->ip_offset));\n\t\telse if (IS_STRICT_MODE (ctx) && !mono_metadata_type_equal (type, stack)) \n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type token of initobj not compatible with value on stack at 0x%04x\", ctx->ip_offset));\n\t} else if (!verify_type_compatibility (ctx, stack, type)) {\n\t\tchar *expected_name = mono_type_full_name (type);\n\t\tchar *stack_name = mono_type_full_name (stack);\n\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Initobj %s not compatible with value on stack %s at 0x%04x\", expected_name, stack_name, ctx->ip_offset));\n\t\tg_free (expected_name);\n\t\tg_free (stack_name);\n\t}\n}\n\nstatic void\ndo_newobj (VerifyContext *ctx, int token) \n{\n\tILStackDesc *value;\n\tint i;\n\tMonoMethodSignature *sig;\n\tMonoMethod *method;\n\tgboolean is_delegate = FALSE;\n\n\tif (!(method = verifier_load_method (ctx, token, \"newobj\")))\n\t\treturn;\n\n\tif (!mono_method_is_constructor (method)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Method from token 0x%08x not a constructor at 0x%04x\", token, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (method->klass->flags & (TYPE_ATTRIBUTE_ABSTRACT | TYPE_ATTRIBUTE_INTERFACE))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Trying to instantiate an abstract or interface type at 0x%04x\", ctx->ip_offset));\n\n\tif (!mono_method_can_access_method_full (ctx->method, method, NULL)) {\n\t\tchar *from = mono_method_full_name (ctx->method, TRUE);\n\t\tchar *to = mono_method_full_name (method, TRUE);\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Constructor %s not visible from %s at 0x%04x\", to, from, ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\t\tg_free (from);\n\t\tg_free (to);\n\t}\n\n\t//FIXME use mono_method_get_signature_full\n\tsig = mono_method_signature (method);\n\tif (!sig) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid constructor signature to newobj at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (!check_underflow (ctx, sig->param_count))\n\t\treturn;\n\n\tis_delegate = method->klass->parent == mono_defaults.multicastdelegate_class;\n\n\tif (is_delegate) {\n\t\tILStackDesc *funptr;\n\t\t//first arg is object, second arg is fun ptr\n\t\tif (sig->param_count != 2) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid delegate constructor at 0x%04x\", ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t\tfunptr = stack_pop (ctx);\n\t\tvalue = stack_pop (ctx);\n\t\tverify_delegate_compatibility (ctx, method->klass, value, funptr);\n\t} else {\n\t\tfor (i = sig->param_count - 1; i >= 0; --i) {\n\t\t\tVERIFIER_DEBUG ( printf (\"verifying constructor argument %d\\n\", i); );\n\t\t\tvalue = stack_pop (ctx);\n\t\t\tif (!verify_stack_type_compatibility (ctx, sig->params [i], value)) {\n\t\t\t\tchar *stack_name = stack_slot_full_name (value);\n\t\t\t\tchar *sig_name = mono_type_full_name (sig->params [i]);\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Incompatible parameter value with constructor signature: %s X %s at 0x%04x\", sig_name, stack_name, ctx->ip_offset));\n\t\t\t\tg_free (stack_name);\n\t\t\t\tg_free (sig_name);\n\t\t\t}\n\n\t\t\tif (stack_slot_is_managed_mutability_pointer (value))\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer as argument of newobj at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t}\n\n\tif (check_overflow (ctx))\n\t\tset_stack_value (ctx, stack_push (ctx),  &method->klass->byval_arg, FALSE);\n}\n\nstatic void\ndo_cast (VerifyContext *ctx, int token, const char *opcode) {\n\tILStackDesc *value;\n\tMonoType *type;\n\tgboolean is_boxed;\n\tgboolean do_box;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!(type = verifier_load_type (ctx, token, opcode)))\n\t\treturn;\n\n\tif (type->byref) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid %s type at 0x%04x\", opcode, ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tvalue = stack_pop (ctx);\n\tis_boxed = stack_slot_is_boxed_value (value);\n\n\tif (stack_slot_is_managed_pointer (value))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value for %s at 0x%04x\", opcode, ctx->ip_offset));\n\telse if (!MONO_TYPE_IS_REFERENCE  (value->type) && !is_boxed) {\n\t\tchar *name = stack_slot_full_name (value);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Expected a reference type on stack for %s but found %s at 0x%04x\", opcode, name, ctx->ip_offset));\n\t\tg_free (name);\n\t}\n\n\tswitch (value->type->type) {\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_TYPEDBYREF: \n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value for %s at 0x%04x\", opcode, ctx->ip_offset));\n\t}\n\n\tdo_box = is_boxed || mono_type_is_generic_argument(type) || mono_class_from_mono_type (type)->valuetype;\n\tstack_push_val (ctx, TYPE_COMPLEX | (do_box ? BOXED_MASK : 0), type);\n}\n\nstatic MonoType *\nmono_type_from_opcode (int opcode) {\n\tswitch (opcode) {\n\tcase CEE_LDIND_I1:\n\tcase CEE_LDIND_U1:\n\tcase CEE_STIND_I1:\n\tcase CEE_LDELEM_I1:\n\tcase CEE_LDELEM_U1:\n\tcase CEE_STELEM_I1:\n\t\treturn &mono_defaults.sbyte_class->byval_arg;\n\n\tcase CEE_LDIND_I2:\n\tcase CEE_LDIND_U2:\n\tcase CEE_STIND_I2:\n\tcase CEE_LDELEM_I2:\n\tcase CEE_LDELEM_U2:\n\tcase CEE_STELEM_I2:\n\t\treturn &mono_defaults.int16_class->byval_arg;\n\n\tcase CEE_LDIND_I4:\n\tcase CEE_LDIND_U4:\n\tcase CEE_STIND_I4:\n\tcase CEE_LDELEM_I4:\n\tcase CEE_LDELEM_U4:\n\tcase CEE_STELEM_I4:\n\t\treturn &mono_defaults.int32_class->byval_arg;\n\n\tcase CEE_LDIND_I8:\n\tcase CEE_STIND_I8:\n\tcase CEE_LDELEM_I8:\n\tcase CEE_STELEM_I8:\n\t\treturn &mono_defaults.int64_class->byval_arg;\n\n\tcase CEE_LDIND_R4:\n\tcase CEE_STIND_R4:\n\tcase CEE_LDELEM_R4:\n\tcase CEE_STELEM_R4:\n\t\treturn &mono_defaults.single_class->byval_arg;\n\n\tcase CEE_LDIND_R8:\n\tcase CEE_STIND_R8:\n\tcase CEE_LDELEM_R8:\n\tcase CEE_STELEM_R8:\n\t\treturn &mono_defaults.double_class->byval_arg;\n\n\tcase CEE_LDIND_I:\n\tcase CEE_STIND_I:\n\tcase CEE_LDELEM_I:\n\tcase CEE_STELEM_I:\n\t\treturn &mono_defaults.int_class->byval_arg;\n\n\tcase CEE_LDIND_REF:\n\tcase CEE_STIND_REF:\n\tcase CEE_LDELEM_REF:\n\tcase CEE_STELEM_REF:\n\t\treturn &mono_defaults.object_class->byval_arg;\n\n\tdefault:\n\t\tg_error (\"unknown opcode %02x in mono_type_from_opcode \", opcode);\n\t\treturn NULL;\n\t}\n}\n\nstatic void\ndo_load_indirect (VerifyContext *ctx, int opcode)\n{\n\tILStackDesc *value;\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\t\n\tvalue = stack_pop (ctx);\n\tif (!stack_slot_is_managed_pointer (value)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Load indirect not using a manager pointer at 0x%04x\", ctx->ip_offset));\n\t\tset_stack_value (ctx, stack_push (ctx), mono_type_from_opcode (opcode), FALSE);\n\t\treturn;\n\t}\n\n\tif (opcode == CEE_LDIND_REF) {\n\t\tif (stack_slot_get_underlying_type (value) != TYPE_COMPLEX || mono_class_from_mono_type (value->type)->valuetype)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for ldind_ref expected object byref operation at 0x%04x\", ctx->ip_offset));\n\t\tset_stack_value (ctx, stack_push (ctx), mono_type_get_type_byval (value->type), FALSE);\n\t} else {\n\t\tif (!verify_type_compatibility_full (ctx, mono_type_from_opcode (opcode), mono_type_get_type_byval (value->type), TRUE))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type at stack for ldind 0x%x operation at 0x%04x\", opcode, ctx->ip_offset));\n\t\tset_stack_value (ctx, stack_push (ctx), mono_type_from_opcode (opcode), FALSE);\n\t}\n}\n\nstatic void\ndo_store_indirect (VerifyContext *ctx, int opcode)\n{\n\tILStackDesc *addr, *val;\n\tCLEAR_PREFIX (ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tval = stack_pop (ctx);\n\taddr = stack_pop (ctx);\t\n\n\tcheck_unmanaged_pointer (ctx, addr);\n\n\tif (!stack_slot_is_managed_pointer (addr) && stack_slot_get_type (addr) != TYPE_PTR) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid non-pointer argument to stind at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (stack_slot_is_managed_mutability_pointer (addr)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with stind at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (!verify_type_compatibility_full (ctx, mono_type_from_opcode (opcode), mono_type_get_type_byval (addr->type), TRUE))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid addr type at stack for stind 0x%x operation at 0x%04x\", opcode, ctx->ip_offset));\n\n\tif (!verify_stack_type_compatibility (ctx, mono_type_from_opcode (opcode), val))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value type at stack for stind 0x%x operation at 0x%04x\", opcode, ctx->ip_offset));\n}\n\nstatic void\ndo_newarr (VerifyContext *ctx, int token) \n{\n\tILStackDesc *value;\n\tMonoType *type = get_boxable_mono_type (ctx, token, \"newarr\");\n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\tif (stack_slot_get_type (value) != TYPE_I4 && stack_slot_get_type (value) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Array size type on stack (%s) is not a verifiable type at 0x%04x\", stack_slot_get_name (value), ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), mono_class_get_type (mono_array_class_get (mono_class_from_mono_type (type), 1)), FALSE);\n}\n\n/*FIXME handle arrays that are not 0-indexed*/\nstatic void\ndo_ldlen (VerifyContext *ctx)\n{\n\tILStackDesc *value;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\tif (stack_slot_get_type (value) != TYPE_COMPLEX || value->type->type != MONO_TYPE_SZARRAY)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type for ldlen at 0x%04x\", ctx->ip_offset));\n\n\tstack_push_val (ctx, TYPE_NATIVE_INT, &mono_defaults.int_class->byval_arg);\t\n}\n\n/*FIXME handle arrays that are not 0-indexed*/\n/*FIXME handle readonly prefix and CMMP*/\nstatic void\ndo_ldelema (VerifyContext *ctx, int klass_token)\n{\n\tILStackDesc *index, *array, *res;\n\tMonoType *type = get_boxable_mono_type (ctx, klass_token, \"ldelema\");\n\tgboolean valid; \n\n\tif (!type)\n\t\treturn;\n\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tindex = stack_pop (ctx);\n\tarray = stack_pop (ctx);\n\n\tif (stack_slot_get_type (index) != TYPE_I4 && stack_slot_get_type (index) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Index type(%s) for ldelema is not an int or a native int at 0x%04x\", stack_slot_get_name (index), ctx->ip_offset));\n\n\tif (!stack_slot_is_null_literal (array)) {\n\t\tif (stack_slot_get_type (array) != TYPE_COMPLEX || array->type->type != MONO_TYPE_SZARRAY)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type(%s) for ldelema at 0x%04x\", stack_slot_get_name (array), ctx->ip_offset));\n\t\telse {\n\t\t\tif (get_stack_type (type) == TYPE_I4 || get_stack_type (type) == TYPE_NATIVE_INT) {\n\t\t\t\t\tvalid = verify_type_compatibility_full (ctx, type, &array->type->data.klass->byval_arg, TRUE);\n\t\t\t} else {\n\t\t\t\tvalid = mono_metadata_type_equal (type, &array->type->data.klass->byval_arg);\n\t\t\t}\n\t\t\tif (!valid)\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for ldelema at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t}\n\n\tres = stack_push (ctx);\n\tset_stack_value (ctx, res, type, TRUE);\n\tif (ctx->prefix_set & PREFIX_READONLY) {\n\t\tctx->prefix_set &= ~PREFIX_READONLY;\n\t\tres->stype |= CMMP_MASK;\n\t}\n}\n\n/*\n * FIXME handle arrays that are not 0-indexed\n * FIXME handle readonly prefix and CMMP\n */\nstatic void\ndo_ldelem (VerifyContext *ctx, int opcode, int token)\n{\n#define IS_ONE_OF2(T, A, B) (T == A || T == B)\n\tILStackDesc *index, *array;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 2))\n\t\treturn;\n\n\tif (opcode == CEE_LDELEM) {\n\t\tif (!(type = verifier_load_type (ctx, token, \"ldelem.any\"))) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Type (0x%08x) not found at 0x%04x\", token, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\ttype = mono_type_from_opcode (opcode);\n\t}\n\n\tindex = stack_pop (ctx);\n\tarray = stack_pop (ctx);\n\n\tif (stack_slot_get_type (index) != TYPE_I4 && stack_slot_get_type (index) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Index type(%s) for ldelem.X is not an int or a native int at 0x%04x\", stack_slot_get_name (index), ctx->ip_offset));\n\n\tif (!stack_slot_is_null_literal (array)) {\n\t\tif (stack_slot_get_type (array) != TYPE_COMPLEX || array->type->type != MONO_TYPE_SZARRAY)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type(%s) for ldelem.X at 0x%04x\", stack_slot_get_name (array), ctx->ip_offset));\n\t\telse {\n\t\t\tif (opcode == CEE_LDELEM_REF) {\n\t\t\t\tif (array->type->data.klass->valuetype)\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type is not a reference type for ldelem.ref 0x%04x\", ctx->ip_offset));\n\t\t\t\ttype = &array->type->data.klass->byval_arg;\n\t\t\t} else {\n\t\t\t\tMonoType *candidate = &array->type->data.klass->byval_arg;\n\t\t\t\tif (IS_STRICT_MODE (ctx)) {\n\t\t\t\t\tMonoType *underlying_type = mono_type_get_underlying_type_any (type);\n\t\t\t\t\tMonoType *underlying_candidate = mono_type_get_underlying_type_any (candidate);\n\t\t\t\t\tif ((IS_ONE_OF2 (underlying_type->type, MONO_TYPE_I4, MONO_TYPE_U4) && IS_ONE_OF2 (underlying_candidate->type, MONO_TYPE_I, MONO_TYPE_U)) ||\n\t\t\t\t\t\t(IS_ONE_OF2 (underlying_candidate->type, MONO_TYPE_I4, MONO_TYPE_U4) && IS_ONE_OF2 (underlying_type->type, MONO_TYPE_I, MONO_TYPE_U)))\n\t\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for ldelem.X at 0x%04x\", ctx->ip_offset));\n\t\t\t\t}\n\t\t\t\tif (!verify_type_compatibility_full (ctx, type, candidate, TRUE))\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for ldelem.X at 0x%04x\", ctx->ip_offset));\n\t\t\t}\n\t\t}\n\t}\n\n\tset_stack_value (ctx, stack_push (ctx), type, FALSE);\n#undef IS_ONE_OF2\n}\n\n/*\n * FIXME handle arrays that are not 0-indexed\n */\nstatic void\ndo_stelem (VerifyContext *ctx, int opcode, int token)\n{\n\tILStackDesc *index, *array, *value;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 3))\n\t\treturn;\n\n\tif (opcode == CEE_STELEM) {\n\t\tif (!(type = verifier_load_type (ctx, token, \"stelem.any\"))) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Type (0x%08x) not found at 0x%04x\", token, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\ttype = mono_type_from_opcode (opcode);\n\t}\n\t\n\tvalue = stack_pop (ctx);\n\tindex = stack_pop (ctx);\n\tarray = stack_pop (ctx);\n\n\tif (stack_slot_get_type (index) != TYPE_I4 && stack_slot_get_type (index) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Index type(%s) for stdelem.X is not an int or a native int at 0x%04x\", stack_slot_get_name (index), ctx->ip_offset));\n\n\tif (!stack_slot_is_null_literal (array)) {\n\t\tif (stack_slot_get_type (array) != TYPE_COMPLEX || array->type->type != MONO_TYPE_SZARRAY) {\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type(%s) for stelem.X at 0x%04x\", stack_slot_get_name (array), ctx->ip_offset));\n\t\t} else {\n\t\t\tif (opcode == CEE_STELEM_REF) {\n\t\t\t\tif (array->type->data.klass->valuetype)\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type is not a reference type for stelem.ref 0x%04x\", ctx->ip_offset));\n\t\t\t} else if (!verify_type_compatibility_full (ctx, &array->type->data.klass->byval_arg, type, TRUE)) {\n\t\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid array type on stack for stdelem.X at 0x%04x\", ctx->ip_offset));\n\t\t\t}\n\t\t}\n\t}\n\tif (opcode == CEE_STELEM_REF) {\n\t\tif (!stack_slot_is_boxed_value (value) && mono_class_from_mono_type (value->type)->valuetype)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value is not a reference type for stelem.ref 0x%04x\", ctx->ip_offset));\n\t} else if (opcode != CEE_STELEM_REF) {\n\t\tif (!verify_stack_type_compatibility (ctx, type, value))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid value on stack for stdelem.X at 0x%04x\", ctx->ip_offset));\n\n\t\tif (stack_slot_is_boxed_value (value) && !MONO_TYPE_IS_REFERENCE (value->type) && !MONO_TYPE_IS_REFERENCE (type))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use stobj with a boxed source value that is not a reference type at 0x%04x\", ctx->ip_offset));\n\n\t}\n}\n\nstatic void\ndo_throw (VerifyContext *ctx)\n{\n\tILStackDesc *exception;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\texception = stack_pop (ctx);\n\n\tif (!stack_slot_is_null_literal (exception) && !(stack_slot_get_type (exception) == TYPE_COMPLEX && !mono_class_from_mono_type (exception->type)->valuetype))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type on stack for throw, expected reference type at 0x%04x\", ctx->ip_offset));\n\n\tif (mono_type_is_generic_argument (exception->type) && !stack_slot_is_boxed_value (exception)) {\n\t\tchar *name = mono_type_full_name (exception->type);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid type on stack for throw, expected reference type but found unboxed %s  at 0x%04x \", name, ctx->ip_offset));\n\t\tg_free (name);\n\t}\n\t/*The stack is left empty after a throw*/\n\tctx->eval.size = 0;\n}\n\n\nstatic void\ndo_endfilter (VerifyContext *ctx)\n{\n\tMonoExceptionClause *clause;\n\n\tif (IS_STRICT_MODE (ctx)) {\n\t\tif (ctx->eval.size != 1)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Stack size must have one item for endfilter at 0x%04x\", ctx->ip_offset));\n\n\t\tif (ctx->eval.size >= 1 && stack_slot_get_type (stack_pop (ctx)) != TYPE_I4)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Stack item type is not an int32 for endfilter at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tif ((clause = is_correct_endfilter (ctx, ctx->ip_offset))) {\n\t\tif (IS_STRICT_MODE (ctx)) {\n\t\t\tif (ctx->ip_offset != clause->handler_offset - 2)\n\t\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"endfilter is not the last instruction of the filter clause at 0x%04x\", ctx->ip_offset));\t\t\t\n\t\t} else {\n\t\t\tif ((ctx->ip_offset != clause->handler_offset - 2) && !MONO_OFFSET_IN_HANDLER (clause, ctx->ip_offset))\n\t\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"endfilter is not the last instruction of the filter clause at 0x%04x\", ctx->ip_offset));\n\t\t}\n\t} else {\n\t\tif (IS_STRICT_MODE (ctx) && !is_unverifiable_endfilter (ctx, ctx->ip_offset))\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"endfilter outside filter clause at 0x%04x\", ctx->ip_offset));\n\t\telse\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"endfilter outside filter clause at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tctx->eval.size = 0;\n}\n\nstatic void\ndo_leave (VerifyContext *ctx, int delta)\n{\n\tint target = ((gint32)ctx->ip_offset) + delta;\n\tif (target >= ctx->code_size || target < 0)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target out of code at 0x%04x\", ctx->ip_offset));\n\n\tif (!is_correct_leave (ctx->header, ctx->ip_offset, target))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Leave not allowed in finally block at 0x%04x\", ctx->ip_offset));\n\tctx->eval.size = 0;\n\tctx->target = target;\n}\n\n/* \n * do_static_branch:\n * \n * Verify br and br.s opcodes.\n */\nstatic void\ndo_static_branch (VerifyContext *ctx, int delta)\n{\n\tint target = ctx->ip_offset + delta;\n\tif (target < 0 || target >= ctx->code_size) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"branch target out of code at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tswitch (is_valid_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\tcase 1:\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\tcase 2:\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Branch target escapes out of exception block at 0x%04x\", ctx->ip_offset));\n\t\tbreak;\n\t}\n\n\tctx->target = target;\n}\n\nstatic void\ndo_switch (VerifyContext *ctx, int count, const unsigned char *data)\n{\n\tint i, base = ctx->ip_offset + 5 + count * 4;\n\tILStackDesc *value;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tvalue = stack_pop (ctx);\n\n\tif (stack_slot_get_type (value) != TYPE_I4 && stack_slot_get_type (value) != TYPE_NATIVE_INT)\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid argument to switch at 0x%04x\", ctx->ip_offset));\n\n\tfor (i = 0; i < count; ++i) {\n\t\tint target = base + read32 (data + i * 4);\n\n\t\tif (target < 0 || target >= ctx->code_size) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Switch target %x out of code at 0x%04x\", i, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (is_valid_branch_instruction (ctx->header, ctx->ip_offset, target)) {\n\t\tcase 1:\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Switch target %x escapes out of exception block at 0x%04x\", i, ctx->ip_offset));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Switch target %x escapes out of exception block at 0x%04x\", i, ctx->ip_offset));\n\t\t\treturn;\n\t\t}\n\t\tmerge_stacks (ctx, &ctx->eval, &ctx->code [target], FALSE, TRUE);\n\t}\n}\n\nstatic void\ndo_load_function_ptr (VerifyContext *ctx, guint32 token, gboolean virtual)\n{\n\tILStackDesc *top;\n\tMonoMethod *method;\n\n\tif (virtual && !check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!virtual && !check_overflow (ctx))\n\t\treturn;\n\n\tif (!IS_METHOD_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid token %x for ldftn  at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\n\tif (!(method = verifier_load_method (ctx, token, virtual ? \"ldvirtfrn\" : \"ldftn\")))\n\t\treturn;\n\n\tif (mono_method_is_constructor (method))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use ldftn with a constructor at 0x%04x\", ctx->ip_offset));\n\n\tif (virtual) {\n\t\tILStackDesc *top = stack_pop (ctx);\n\t\n\t\tif (stack_slot_get_type (top) != TYPE_COMPLEX || top->type->type == MONO_TYPE_VALUETYPE)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Invalid argument to ldvirtftn at 0x%04x\", ctx->ip_offset));\n\t\n\t\tif (method->flags & METHOD_ATTRIBUTE_STATIC)\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use ldvirtftn with a constructor at 0x%04x\", ctx->ip_offset));\n\n\t\tif (!verify_stack_type_compatibility (ctx, &method->klass->byval_arg, top))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Unexpected object for ldvirtftn at 0x%04x\", ctx->ip_offset));\n\t}\n\t\n\tif (!mono_method_can_access_method_full (ctx->method, method, NULL))\n\t\tCODE_NOT_VERIFIABLE2 (ctx, g_strdup_printf (\"Loaded method is not visible for ldftn/ldvirtftn at 0x%04x\", ctx->ip_offset), MONO_EXCEPTION_METHOD_ACCESS);\n\n\ttop = stack_push_val(ctx, TYPE_PTR, mono_type_create_fnptr_from_mono_method (ctx, method));\n\ttop->method = method;\n}\n\nstatic void\ndo_sizeof (VerifyContext *ctx, int token)\n{\n\tMonoType *type;\n\n\tif (!IS_TYPE_DEF_OR_REF_OR_SPEC (token) || !token_bounds_check (ctx->image, token)) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid type token %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\t\n\tif (!(type = verifier_load_type (ctx, token, \"sizeof\")))\n\t\treturn;\n\n\tif (type->byref && type->type != MONO_TYPE_TYPEDBYREF) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of byref type at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (type->type == MONO_TYPE_VOID) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Invalid use of void type at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\tif (check_overflow (ctx))\n\t\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.uint32_class->byval_arg, FALSE);\n}\n\n/* Stack top can be of any type, the runtime doesn't care and treat everything as an int. */\nstatic void\ndo_localloc (VerifyContext *ctx)\n{\n\tILStackDesc *top;\n\t\n\tif (ctx->eval.size != 1) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack must have only size item in localloc at 0x%04x\", ctx->ip_offset));\n\t\treturn;\t\t\n\t}\n\n\tif (in_any_exception_block (ctx->header, ctx->ip_offset)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Stack must have only size item in localloc at 0x%04x\", ctx->ip_offset));\n\t\treturn;\n\t}\n\n\t/*TODO verify top type*/\n\ttop = stack_pop (ctx);\n\n\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.int_class->byval_arg, FALSE);\n\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Instruction localloc in never verifiable at 0x%04x\", ctx->ip_offset));\n}\n\nstatic void\ndo_ldstr (VerifyContext *ctx, guint32 token)\n{\n\tGSList *error = NULL;\n\tif (mono_metadata_token_code (token) != MONO_TOKEN_STRING) {\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid string token %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\n\tif (!ctx->image->dynamic && !mono_verifier_verify_string_signature (ctx->image, mono_metadata_token_index (token), &error)) {\n\t\tif (error)\n\t\t\tctx->list = g_slist_concat (ctx->list, error);\n\t\tADD_VERIFY_ERROR2 (ctx, g_strdup_printf (\"Invalid string index %x at 0x%04x\", token, ctx->ip_offset), MONO_EXCEPTION_BAD_IMAGE);\n\t\treturn;\n\t}\n\n\tif (check_overflow (ctx))\n\t\tstack_push_val (ctx, TYPE_COMPLEX,  &mono_defaults.string_class->byval_arg);\n}\n\nstatic void\ndo_refanyval (VerifyContext *ctx, int token)\n{\n\tILStackDesc *top;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!(type = get_boxable_mono_type (ctx, token, \"refanyval\")))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (top->stype != TYPE_PTR || top->type->type != MONO_TYPE_TYPEDBYREF)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Expected a typedref as argument for refanyval, but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), type, TRUE);\n}\n\nstatic void\ndo_refanytype (VerifyContext *ctx)\n{\n\tILStackDesc *top;\n\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (top->stype != TYPE_PTR || top->type->type != MONO_TYPE_TYPEDBYREF)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Expected a typedref as argument for refanytype, but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\n\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.typehandle_class->byval_arg, FALSE);\n\n}\n\nstatic void\ndo_mkrefany (VerifyContext *ctx, int token)\n{\n\tILStackDesc *top;\n\tMonoType *type;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\tif (!(type = get_boxable_mono_type (ctx, token, \"refanyval\")))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (stack_slot_is_managed_mutability_pointer (top))\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot use a readonly pointer with mkrefany at 0x%04x\", ctx->ip_offset));\n\n\tif (!stack_slot_is_managed_pointer (top)) {\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Expected a managed pointer for mkrefany, but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\n\t}else {\n\t\tMonoType *stack_type = mono_type_get_type_byval (top->type);\n\t\tif (MONO_TYPE_IS_REFERENCE (type) && !mono_metadata_type_equal (type, stack_type))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type not compatible for mkrefany at 0x%04x\", ctx->ip_offset));\n\t\t\t\n\t\tif (!MONO_TYPE_IS_REFERENCE (type) && !verify_type_compatibility_full (ctx, type, stack_type, TRUE))\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Type not compatible for mkrefany at 0x%04x\", ctx->ip_offset));\n\t}\n\n\tset_stack_value (ctx, stack_push (ctx), &mono_defaults.typed_reference_class->byval_arg, FALSE);\n}\n\nstatic void\ndo_ckfinite (VerifyContext *ctx)\n{\n\tILStackDesc *top;\n\tif (!check_underflow (ctx, 1))\n\t\treturn;\n\n\ttop = stack_pop (ctx);\n\n\tif (stack_slot_get_underlying_type (top) != TYPE_R8)\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Expected float32 or float64 on stack for ckfinit but found %s at 0x%04x\", stack_slot_get_name (top), ctx->ip_offset));\t\n\tstack_push_stack_val (ctx, top);\n}\n/*\n * merge_stacks:\n * Merge the stacks and perform compat checks. The merge check if types of @from are mergeable with type of @to \n * \n * @from holds new values for a given control path\n * @to holds the current values of a given control path\n * \n * TODO we can eliminate the from argument as all callers pass &ctx->eval\n */\nstatic void\nmerge_stacks (VerifyContext *ctx, ILCodeDesc *from, ILCodeDesc *to, gboolean start, gboolean external) \n{\n\tMonoError error;\n\tint i, j, k;\n\tstack_init (ctx, to);\n\n\tif (start) {\n\t\tif (to->flags == IL_CODE_FLAG_NOT_PROCESSED) \n\t\t\tfrom->size = 0;\n\t\telse\n\t\t\tstack_copy (&ctx->eval, to);\n\t\tgoto end_verify;\n\t} else if (!(to->flags & IL_CODE_STACK_MERGED)) {\n\t\tstack_copy (to, &ctx->eval);\n\t\tgoto end_verify;\n\t}\n\tVERIFIER_DEBUG ( printf (\"performing stack merge %d x %d\\n\", from->size, to->size); );\n\n\tif (from->size != to->size) {\n\t\tVERIFIER_DEBUG ( printf (\"different stack sizes %d x %d at 0x%04x\\n\", from->size, to->size, ctx->ip_offset); );\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Could not merge stacks, different sizes (%d x %d) at 0x%04x\", from->size, to->size, ctx->ip_offset)); \n\t\tgoto end_verify;\n\t}\n\n\t//FIXME we need to preserve CMMP attributes\n\t//FIXME we must take null literals into consideration.\n\tfor (i = 0; i < from->size; ++i) {\n\t\tILStackDesc *new_slot = from->stack + i;\n\t\tILStackDesc *old_slot = to->stack + i;\n\t\tMonoType *new_type = mono_type_from_stack_slot (new_slot);\n\t\tMonoType *old_type = mono_type_from_stack_slot (old_slot);\n\t\tMonoClass *old_class = mono_class_from_mono_type (old_type);\n\t\tMonoClass *new_class = mono_class_from_mono_type (new_type);\n\t\tMonoClass *match_class = NULL;\n\n\t\t// S := T then U = S (new value is compatible with current value, keep current)\n\t\tif (verify_stack_type_compatibility (ctx, old_type, new_slot)) {\n\t\t\tcopy_stack_value (new_slot, old_slot);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// T := S then U = T (old value is compatible with current value, use new)\n\t\tif (verify_stack_type_compatibility (ctx, new_type, old_slot)) {\n\t\t\tcopy_stack_value (old_slot, new_slot);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mono_type_is_generic_argument (old_type) || mono_type_is_generic_argument (new_type)) {\n\t\t\tchar *old_name = stack_slot_full_name (old_slot); \n\t\t\tchar *new_name = stack_slot_full_name (new_slot);\n\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Could not merge stack at depth %d, types not compatible: %s X %s at 0x%04x\", i, old_name, new_name, ctx->ip_offset));\n\t\t\tg_free (old_name);\n\t\t\tg_free (new_name);\n\t\t\tgoto end_verify;\t\t\t\n\t\t} \n\n\t\t//both are reference types, use closest common super type\n\t\tif (!mono_class_from_mono_type (old_type)->valuetype \n\t\t\t&& !mono_class_from_mono_type (new_type)->valuetype\n\t\t\t&& !stack_slot_is_managed_pointer (old_slot)\n\t\t\t&& !stack_slot_is_managed_pointer (new_slot)) {\n\t\t\t\n\t\t\tfor (j = MIN (old_class->idepth, new_class->idepth) - 1; j > 0; --j) {\n\t\t\t\tif (mono_metadata_type_equal (&old_class->supertypes [j]->byval_arg, &new_class->supertypes [j]->byval_arg)) {\n\t\t\t\t\tmatch_class = old_class->supertypes [j];\n\t\t\t\t\tgoto match_found;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmono_class_setup_interfaces (old_class, &error);\n\t\t\tif (!mono_error_ok (&error)) {\n\t\t\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Cannot merge stacks due to a TypeLoadException %s at 0x%04x\", mono_error_get_message (&error), ctx->ip_offset));\n\t\t\t\tmono_error_cleanup (&error);\n\t\t\t\tgoto end_verify;\n\t\t\t}\n\t\t\tfor (j = 0; j < old_class->interface_count; ++j) {\n\t\t\t\tfor (k = 0; k < new_class->interface_count; ++k) {\n\t\t\t\t\tif (mono_metadata_type_equal (&old_class->interfaces [j]->byval_arg, &new_class->interfaces [k]->byval_arg)) {\n\t\t\t\t\t\tmatch_class = old_class->interfaces [j];\n\t\t\t\t\t\tgoto match_found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//No decent super type found, use object\n\t\t\tmatch_class = mono_defaults.object_class;\n\t\t\tgoto match_found;\n\t\t} else if (is_compatible_boxed_valuetype (ctx,old_type, new_type, new_slot, FALSE) || is_compatible_boxed_valuetype (ctx, new_type, old_type, old_slot, FALSE)) {\n\t\t\tmatch_class = mono_defaults.object_class;\n\t\t\tgoto match_found;\n\t\t}\n\n\t\t{\n\t\tchar *old_name = stack_slot_full_name (old_slot); \n\t\tchar *new_name = stack_slot_full_name (new_slot);\n\t\tCODE_NOT_VERIFIABLE (ctx, g_strdup_printf (\"Could not merge stack at depth %d, types not compatible: %s X %s at 0x%04x\", i, old_name, new_name, ctx->ip_offset)); \n\t\tg_free (old_name);\n\t\tg_free (new_name);\n\t\t}\n\t\tset_stack_value (ctx, old_slot, &new_class->byval_arg, stack_slot_is_managed_pointer (old_slot));\n\t\tgoto end_verify;\n\nmatch_found:\n\t\tg_assert (match_class);\n\t\tset_stack_value (ctx, old_slot, &match_class->byval_arg, stack_slot_is_managed_pointer (old_slot));\n\t\tset_stack_value (ctx, new_slot, &match_class->byval_arg, stack_slot_is_managed_pointer (old_slot));\n\t\tcontinue;\n\t}\n\nend_verify:\n\tif (external)\n\t\tto->flags |= IL_CODE_FLAG_WAS_TARGET;\n\tto->flags |= IL_CODE_STACK_MERGED;\n}\n\n#define HANDLER_START(clause) ((clause)->flags == MONO_EXCEPTION_CLAUSE_FILTER ? (clause)->data.filter_offset : clause->handler_offset)\n#define IS_CATCH_OR_FILTER(clause) ((clause)->flags == MONO_EXCEPTION_CLAUSE_FILTER || (clause)->flags == MONO_EXCEPTION_CLAUSE_NONE)\n\n/*\n * is_clause_in_range :\n * \n * Returns TRUE if either the protected block or the handler of @clause is in the @start - @end range.  \n */\nstatic gboolean\nis_clause_in_range (MonoExceptionClause *clause, guint32 start, guint32 end)\n{\n\tif (clause->try_offset >= start && clause->try_offset < end)\n\t\treturn TRUE;\n\tif (HANDLER_START (clause) >= start && HANDLER_START (clause) < end)\n\t\treturn TRUE;\n\treturn FALSE;\n}\n\n/*\n * is_clause_inside_range :\n * \n * Returns TRUE if @clause lies completely inside the @start - @end range.  \n */\nstatic gboolean\nis_clause_inside_range (MonoExceptionClause *clause, guint32 start, guint32 end)\n{\n\tif (clause->try_offset < start || (clause->try_offset + clause->try_len) > end)\n\t\treturn FALSE;\n\tif (HANDLER_START (clause) < start || (clause->handler_offset + clause->handler_len) > end)\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\n/*\n * is_clause_nested :\n * \n * Returns TRUE if @nested is nested in @clause.   \n */\nstatic gboolean\nis_clause_nested (MonoExceptionClause *clause, MonoExceptionClause *nested)\n{\n\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER && is_clause_inside_range (nested, clause->data.filter_offset, clause->handler_offset))\n\t\treturn TRUE;\n\treturn is_clause_inside_range (nested, clause->try_offset, clause->try_offset + clause->try_len) ||\n\tis_clause_inside_range (nested, clause->handler_offset, clause->handler_offset + clause->handler_len);\n}\n\n/* Test the relationship between 2 exception clauses. Follow  P.1 12.4.2.7 of ECMA\n * the each pair of exception must have the following properties:\n *  - one is fully nested on another (the outer must not be a filter clause) (the nested one must come earlier)\n *  - completely disjoin (none of the 3 regions of each entry overlap with the other 3)\n *  - mutual protection (protected block is EXACT the same, handlers are disjoin and all handler are catch or all handler are filter)\n */\nstatic void\nverify_clause_relationship (VerifyContext *ctx, MonoExceptionClause *clause, MonoExceptionClause *to_test)\n{\n\t/*clause is nested*/\n\tif (to_test->flags == MONO_EXCEPTION_CLAUSE_FILTER && is_clause_inside_range (clause, to_test->data.filter_offset, to_test->handler_offset)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception clause inside filter\"));\n\t\treturn;\n\t}\n\n\t/*wrong nesting order.*/\n\tif (is_clause_nested (clause, to_test)) {\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Nested exception clause appears after enclosing clause\"));\n\t\treturn;\n\t}\n\n\t/*mutual protection*/\n\tif (clause->try_offset == to_test->try_offset && clause->try_len == to_test->try_len) {\n\t\t/*handlers are not disjoint*/\n\t\tif (is_clause_in_range (to_test, HANDLER_START (clause), clause->handler_offset + clause->handler_len)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception handlers overlap\"));\n\t\t\treturn;\n\t\t}\n\t\t/* handlers are not catch or filter */\n\t\tif (!IS_CATCH_OR_FILTER (clause) || !IS_CATCH_OR_FILTER (to_test)) {\n\t\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception clauses with shared protected block are neither catch or filter\"));\n\t\t\treturn;\n\t\t}\n\t\t/*OK*/\n\t\treturn;\n\t}\n\n\t/*not completelly disjoint*/\n\tif ((is_clause_in_range (to_test, clause->try_offset, clause->try_offset + clause->try_len) ||\n\t\tis_clause_in_range (to_test, HANDLER_START (clause), clause->handler_offset + clause->handler_len)) && !is_clause_nested (to_test, clause))\n\t\tADD_VERIFY_ERROR (ctx, g_strdup_printf (\"Exception clauses overlap\"));\n}\n\n#define code_bounds_check(size) \\\n\tif (ADDP_IS_GREATER_OR_OVF (ip, size, end)) {\\\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Code overrun starting with 0x%x at 0x%04x\", *ip, ctx.ip_offset)); \\\n\t\tbreak; \\\n\t} \\\n\nstatic gboolean\nmono_opcode_is_prefix (int op)\n{\n\tswitch (op) {\n\tcase MONO_CEE_UNALIGNED_:\n\tcase MONO_CEE_VOLATILE_:\n\tcase MONO_CEE_TAIL_:\n\tcase MONO_CEE_CONSTRAINED_:\n\tcase MONO_CEE_READONLY_:\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/*\n * FIXME: need to distinguish between valid and verifiable.\n * Need to keep track of types on the stack.\n * Verify types for opcodes.\n */\nGSList*\nmono_method_verify (MonoMethod *method, int level)\n{\n\tMonoError error;\n\tconst unsigned char *ip, *code_start;\n\tconst unsigned char *end;\n\tMonoSimpleBasicBlock *bb = NULL, *original_bb = NULL;\n\n\tint i, n, need_merge = 0, start = 0;\n\tguint token, ip_offset = 0, prefix = 0;\n\tMonoGenericContext *generic_context = NULL;\n\tMonoImage *image;\n\tVerifyContext ctx;\n\tGSList *tmp;\n\tVERIFIER_DEBUG ( printf (\"Verify IL for method %s %s %s\\n\",  method->klass->name_space,  method->klass->name, method->name); );\n\n\tif (method->iflags & (METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL | METHOD_IMPL_ATTRIBUTE_RUNTIME) ||\n\t\t\t(method->flags & (METHOD_ATTRIBUTE_PINVOKE_IMPL | METHOD_ATTRIBUTE_ABSTRACT))) {\n\t\treturn NULL;\n\t}\n\n\tmemset (&ctx, 0, sizeof (VerifyContext));\n\n\t//FIXME use mono_method_get_signature_full\n\tctx.signature = mono_method_signature (method);\n\tif (!ctx.signature) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Could not decode method signature\"));\n\t\treturn ctx.list;\n\t}\n\tctx.header = mono_method_get_header (method);\n\tif (!ctx.header) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Could not decode method header\"));\n\t\treturn ctx.list;\n\t}\n\tctx.method = method;\n\tcode_start = ip = ctx.header->code;\n\tend = ip + ctx.header->code_size;\n\tctx.image = image = method->klass->image;\n\n\n\tctx.max_args = ctx.signature->param_count + ctx.signature->hasthis;\n\tctx.max_stack = ctx.header->max_stack;\n\tctx.verifiable = ctx.valid = 1;\n\tctx.level = level;\n\n\tctx.code = g_new (ILCodeDesc, ctx.header->code_size);\n\tctx.code_size = ctx.header->code_size;\n\n\tmemset(ctx.code, 0, sizeof (ILCodeDesc) * ctx.header->code_size);\n\n\n\tctx.num_locals = ctx.header->num_locals;\n\tctx.locals = g_memdup (ctx.header->locals, sizeof (MonoType*) * ctx.header->num_locals);\n\n\tif (ctx.num_locals > 0 && !ctx.header->init_locals)\n\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Method with locals variable but without init locals set\"));\n\n\tctx.params = g_new (MonoType*, ctx.max_args);\n\tif (ctx.signature->hasthis)\n\t\tctx.params [0] = method->klass->valuetype ? &method->klass->this_arg : &method->klass->byval_arg;\n\tmemcpy (ctx.params + ctx.signature->hasthis, ctx.signature->params, sizeof (MonoType *) * ctx.signature->param_count);\n\n\tif (ctx.signature->is_inflated)\n\t\tctx.generic_context = generic_context = mono_method_get_context (method);\n\n\tif (!generic_context && (method->klass->generic_container || method->is_generic)) {\n\t\tif (method->is_generic)\n\t\t\tctx.generic_context = generic_context = &(mono_method_get_generic_container (method)->context);\n\t\telse\n\t\t\tctx.generic_context = generic_context = &method->klass->generic_container->context;\n\t}\n\n\tfor (i = 0; i < ctx.num_locals; ++i) {\n\t\tMonoType *uninflated = ctx.locals [i];\n\t\tctx.locals [i] = mono_class_inflate_generic_type_checked (ctx.locals [i], ctx.generic_context, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tchar *name = mono_type_full_name (ctx.locals [i] ? ctx.locals [i] : uninflated);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid local %d of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tmono_error_cleanup (&error);\n\t\t\t/* we must not free (in cleanup) what was not yet allocated (but only copied) */\n\t\t\tctx.num_locals = i;\n\t\t\tctx.max_args = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tfor (i = 0; i < ctx.max_args; ++i) {\n\t\tMonoType *uninflated = ctx.params [i];\n\t\tctx.params [i] = mono_class_inflate_generic_type_checked (ctx.params [i], ctx.generic_context, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tchar *name = mono_type_full_name (ctx.params [i] ? ctx.params [i] : uninflated);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid parameter %d of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tmono_error_cleanup (&error);\n\t\t\t/* we must not free (in cleanup) what was not yet allocated (but only copied) */\n\t\t\tctx.max_args = i;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tstack_init (&ctx, &ctx.eval);\n\n\tfor (i = 0; i < ctx.num_locals; ++i) {\n\t\tif (!mono_type_is_valid_in_context (&ctx, ctx.locals [i]))\n\t\t\tbreak;\n\t\tif (get_stack_type (ctx.locals [i]) == TYPE_INV) {\n\t\t\tchar *name = mono_type_full_name (ctx.locals [i]);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid local %i of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\n\tfor (i = 0; i < ctx.max_args; ++i) {\n\t\tif (!mono_type_is_valid_in_context (&ctx, ctx.params [i]))\n\t\t\tbreak;\n\n\t\tif (get_stack_type (ctx.params [i]) == TYPE_INV) {\n\t\t\tchar *name = mono_type_full_name (ctx.params [i]);\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid parameter %i of type %s\", i, name));\n\t\t\tg_free (name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx.valid)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < ctx.header->num_clauses && ctx.valid; ++i) {\n\t\tMonoExceptionClause *clause = ctx.header->clauses + i;\n\t\tVERIFIER_DEBUG (printf (\"clause try %x len %x filter at %x handler at %x len %x\\n\", clause->try_offset, clause->try_len, clause->data.filter_offset, clause->handler_offset, clause->handler_len); );\n\n\t\tif (clause->try_offset > ctx.code_size || ADD_IS_GREATER_OR_OVF (clause->try_offset, clause->try_len, ctx.code_size))\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"try clause out of bounds at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->try_len <= 0)\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"try clause len <= 0 at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->handler_offset > ctx.code_size || ADD_IS_GREATER_OR_OVF (clause->handler_offset, clause->handler_len, ctx.code_size))\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"handler clause out of bounds at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->handler_len <= 0)\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"handler clause len <= 0 at 0x%04x\", clause->try_offset));\n\n\t\tif (clause->try_offset < clause->handler_offset && ADD_IS_GREATER_OR_OVF (clause->try_offset, clause->try_len, HANDLER_START (clause)))\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"try block (at 0x%04x) includes handler block (at 0x%04x)\", clause->try_offset, clause->handler_offset));\n\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\tif (clause->data.filter_offset > ctx.code_size)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"filter clause out of bounds at 0x%04x\", clause->try_offset));\n\n\t\t\tif (clause->data.filter_offset >= clause->handler_offset)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"filter clause must come before the handler clause at 0x%04x\", clause->data.filter_offset));\n\t\t}\n\n\t\tfor (n = i + 1; n < ctx.header->num_clauses && ctx.valid; ++n)\n\t\t\tverify_clause_relationship (&ctx, clause, ctx.header->clauses + n);\n\n\t\tif (!ctx.valid)\n\t\t\tbreak;\n\n\t\tctx.code [clause->try_offset].flags |= IL_CODE_FLAG_WAS_TARGET;\n\t\tif (clause->try_offset + clause->try_len < ctx.code_size)\n\t\t\tctx.code [clause->try_offset + clause->try_len].flags |= IL_CODE_FLAG_WAS_TARGET;\n\t\tif (clause->handler_offset + clause->handler_len < ctx.code_size)\n\t\t\tctx.code [clause->handler_offset + clause->handler_len].flags |= IL_CODE_FLAG_WAS_TARGET;\n\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_NONE) {\n\t\t\tif (!clause->data.catch_class) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Catch clause %d with invalid type\", i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t\tinit_stack_with_value_at_exception_boundary (&ctx, ctx.code + clause->handler_offset, clause->data.catch_class);\n\t\t}\n\t\telse if (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER) {\n\t\t\tinit_stack_with_value_at_exception_boundary (&ctx, ctx.code + clause->data.filter_offset, mono_defaults.exception_class);\n\t\t\tinit_stack_with_value_at_exception_boundary (&ctx, ctx.code + clause->handler_offset, mono_defaults.exception_class);\t\n\t\t}\n\t}\n\n\toriginal_bb = bb = mono_basic_block_split (method, &error);\n\tif (!mono_error_ok (&error)) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid branch target: %s\", mono_error_get_message (&error)));\n\t\tmono_error_cleanup (&error);\n\t\tgoto cleanup;\n\t}\n\tg_assert (bb);\n\n\twhile (ip < end && ctx.valid) {\n\t\tint op_size;\n\t\tip_offset = ip - code_start;\n\t\t{\n\t\t\tconst unsigned char *ip_copy = ip;\n\t\t\tint op;\n\n\t\t\tif (ip_offset > bb->end) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or EH block at [0x%04x] targets middle instruction at 0x%04x\", bb->end, ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (ip_offset == bb->end)\n\t\t\t\tbb = bb->next;\n\t\n\t\t\top_size = mono_opcode_value_and_size (&ip_copy, end, &op);\n\t\t\tif (op_size == -1) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction %x at 0x%04x\", *ip, ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (ADD_IS_GREATER_OR_OVF (ip_offset, op_size, bb->end)) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or EH block targets middle of instruction at 0x%04x\", ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\t/*Last Instruction*/\n\t\t\tif (ip_offset + op_size == bb->end && mono_opcode_is_prefix (op)) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or EH block targets between prefix '%s' and instruction at 0x%04x\", mono_opcode_name (op), ip_offset));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tctx.ip_offset = ip_offset = ip - code_start;\n\n\t\t/*We need to check against fallthrou in and out of protected blocks.\n\t\t * For fallout we check the once a protected block ends, if the start flag is not set.\n\t\t * Likewise for fallthru in, we check if ip is the start of a protected block and start is not set\n\t\t * TODO convert these checks to be done using flags and not this loop\n\t\t */\n\t\tfor (i = 0; i < ctx.header->num_clauses && ctx.valid; ++i) {\n\t\t\tMonoExceptionClause *clause = ctx.header->clauses + i;\n\n\t\t\tif ((clause->try_offset + clause->try_len == ip_offset) && start == 0) {\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"fallthru off try block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif ((clause->handler_offset + clause->handler_len == ip_offset) && start == 0) {\n\t\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"fallout of handler block at 0x%04x\", ip_offset));\n\t\t\t\telse\n\t\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"fallout of handler block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER && clause->handler_offset == ip_offset && start == 0) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"fallout of filter block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (clause->handler_offset == ip_offset && start == 0) {\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"fallthru handler block at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\n\t\t\tif (clause->try_offset == ip_offset && ctx.eval.size > 0 && start == 0) {\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Try to enter try block with a non-empty stack at 0x%04x\", ip_offset));\n\t\t\t\tstart = 1;\n\t\t\t}\n\t\t}\n\n\t\t/*This must be done after fallthru detection otherwise it won't happen.*/\n\t\tif (bb->dead) {\n\t\t\t/*FIXME remove this once we move all bad branch checking code to use BB only*/\n\t\t\tctx.code [ip_offset].flags |= IL_CODE_FLAG_SEEN;\n\t\t\tip += op_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx.valid)\n\t\t\tbreak;\n\n\t\tif (need_merge) {\n\t\t\tVERIFIER_DEBUG ( printf (\"extra merge needed! 0x%04x \\n\", ctx.target); );\n\t\t\tmerge_stacks (&ctx, &ctx.eval, &ctx.code [ctx.target], FALSE, TRUE);\n\t\t\tneed_merge = 0;\t\n\t\t}\n\t\tmerge_stacks (&ctx, &ctx.eval, &ctx.code[ip_offset], start, FALSE);\n\t\tstart = 0;\n\n\t\t/*TODO we can fast detect a forward branch or exception block targeting code after prefix, we should fail fast*/\n#ifdef MONO_VERIFIER_DEBUG\n\t\t{\n\t\t\tchar *discode;\n\t\t\tdiscode = mono_disasm_code_one (NULL, method, ip, NULL);\n\t\t\tdiscode [strlen (discode) - 1] = 0; /* no \\n */\n\t\t\tg_print (\"[%d] %-29s (%d)\\n\",  ip_offset, discode, ctx.eval.size);\n\t\t\tg_free (discode);\n\t\t}\n\t\tdump_stack_state (&ctx.code [ip_offset]);\n\t\tdump_stack_state (&ctx.eval);\n#endif\n\n\t\tswitch (*ip) {\n\t\tcase CEE_NOP:\n\t\tcase CEE_BREAK:\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDARG_0:\n\t\tcase CEE_LDARG_1:\n\t\tcase CEE_LDARG_2:\n\t\tcase CEE_LDARG_3:\n\t\t\tpush_arg (&ctx, *ip - CEE_LDARG_0, FALSE);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDARG_S:\n\t\tcase CEE_LDARGA_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tpush_arg (&ctx, ip [1],  *ip == CEE_LDARGA_S);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_ADD_OVF_UN:\n\t\t\tdo_binop (&ctx, *ip, add_ovf_un_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_SUB_OVF_UN:\n\t\t\tdo_binop (&ctx, *ip, sub_ovf_un_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_ADD_OVF:\n\t\tcase CEE_SUB_OVF:\n\t\tcase CEE_MUL_OVF:\n\t\tcase CEE_MUL_OVF_UN:\n\t\t\tdo_binop (&ctx, *ip, bin_ovf_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_ADD:\n\t\t\tdo_binop (&ctx, *ip, add_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_SUB:\n\t\t\tdo_binop (&ctx, *ip, sub_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_MUL:\n\t\tcase CEE_DIV:\n\t\tcase CEE_REM:\n\t\t\tdo_binop (&ctx, *ip, bin_op_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_AND:\n\t\tcase CEE_DIV_UN:\n\t\tcase CEE_OR:\n\t\tcase CEE_REM_UN:\n\t\tcase CEE_XOR:\n\t\t\tdo_binop (&ctx, *ip, int_bin_op_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_SHL:\n\t\tcase CEE_SHR:\n\t\tcase CEE_SHR_UN:\n\t\t\tdo_binop (&ctx, *ip, shift_op_table);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_POP:\n\t\t\tif (!check_underflow (&ctx, 1))\n\t\t\t\tbreak;\n\t\t\tstack_pop_safe (&ctx);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_RET:\n\t\t\tdo_ret (&ctx);\n\t\t\t++ip;\n\t\t\tstart = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_LDLOC_0:\n\t\tcase CEE_LDLOC_1:\n\t\tcase CEE_LDLOC_2:\n\t\tcase CEE_LDLOC_3:\n\t\t\t/*TODO support definite assignment verification? */\n\t\t\tpush_local (&ctx, *ip - CEE_LDLOC_0, FALSE);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_STLOC_0:\n\t\tcase CEE_STLOC_1:\n\t\tcase CEE_STLOC_2:\n\t\tcase CEE_STLOC_3:\n\t\t\tstore_local (&ctx, *ip - CEE_STLOC_0);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_STLOC_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tstore_local (&ctx, ip [1]);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_STARG_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tstore_arg (&ctx, ip [1]);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I4_M1:\n\t\tcase CEE_LDC_I4_0:\n\t\tcase CEE_LDC_I4_1:\n\t\tcase CEE_LDC_I4_2:\n\t\tcase CEE_LDC_I4_3:\n\t\tcase CEE_LDC_I4_4:\n\t\tcase CEE_LDC_I4_5:\n\t\tcase CEE_LDC_I4_6:\n\t\tcase CEE_LDC_I4_7:\n\t\tcase CEE_LDC_I4_8:\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I4_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I4:\n\t\t\tcode_bounds_check (5);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx,TYPE_I4, &mono_defaults.int32_class->byval_arg);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_I8:\n\t\t\tcode_bounds_check (9);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx,TYPE_I8, &mono_defaults.int64_class->byval_arg);\n\t\t\tip += 9;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_R4:\n\t\t\tcode_bounds_check (5);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_R8, &mono_defaults.double_class->byval_arg);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDC_R8:\n\t\t\tcode_bounds_check (9);\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_R8, &mono_defaults.double_class->byval_arg);\n\t\t\tip += 9;\n\t\t\tbreak;\n\n\t\tcase CEE_LDNULL:\n\t\t\tif (check_overflow (&ctx))\n\t\t\t\tstack_push_val (&ctx, TYPE_COMPLEX | NULL_LITERAL_MASK, &mono_defaults.object_class->byval_arg);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_BEQ_S:\n\t\tcase CEE_BNE_UN_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_branch_op (&ctx, (signed char)ip [1] + 2, cmp_br_eq_op);\n\t\t\tip += 2;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BGE_S:\n\t\tcase CEE_BGT_S:\n\t\tcase CEE_BLE_S:\n\t\tcase CEE_BLT_S:\n\t\tcase CEE_BGE_UN_S:\n\t\tcase CEE_BGT_UN_S:\n\t\tcase CEE_BLE_UN_S:\n\t\tcase CEE_BLT_UN_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_branch_op (&ctx, (signed char)ip [1] + 2, cmp_br_op);\n\t\t\tip += 2;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BEQ:\n\t\tcase CEE_BNE_UN:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_branch_op (&ctx, (gint32)read32 (ip + 1) + 5, cmp_br_eq_op);\n\t\t\tip += 5;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BGE:\n\t\tcase CEE_BGT:\n\t\tcase CEE_BLE:\n\t\tcase CEE_BLT:\n\t\tcase CEE_BGE_UN:\n\t\tcase CEE_BGT_UN:\n\t\tcase CEE_BLE_UN:\n\t\tcase CEE_BLT_UN:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_branch_op (&ctx, (gint32)read32 (ip + 1) + 5, cmp_br_op);\n\t\t\tip += 5;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_LDLOC_S:\n\t\tcase CEE_LDLOCA_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tpush_local (&ctx, ip[1], *ip == CEE_LDLOCA_S);\n\t\t\tip += 2;\n\t\t\tbreak;\n\n\t\tcase CEE_UNUSED99:\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Use of the `unused' opcode\"));\n\t\t\t++ip;\n\t\t\tbreak; \n\n\t\tcase CEE_DUP: {\n\t\t\tILStackDesc * top;\n\t\t\tif (!check_underflow (&ctx, 1))\n\t\t\t\tbreak;\n\t\t\tif (!check_overflow (&ctx))\n\t\t\t\tbreak;\n\t\t\ttop = stack_pop_safe (&ctx);\n\t\t\tcopy_stack_value (stack_push (&ctx), top); \n\t\t\tcopy_stack_value (stack_push (&ctx), top);\n\t\t\t++ip;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase CEE_JMP:\n\t\t\tcode_bounds_check (5);\n\t\t\tif (ctx.eval.size)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Eval stack must be empty in jmp at 0x%04x\", ip_offset));\n\t\t\ttoken = read32 (ip + 1);\n\t\t\tif (in_any_block (ctx.header, ip_offset))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"jmp cannot escape exception blocks at 0x%04x\", ip_offset));\n\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Intruction jmp is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\t/*\n\t\t\t * FIXME: check signature, retval, arguments etc.\n\t\t\t */\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\tcase CEE_CALL:\n\t\tcase CEE_CALLVIRT:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_invoke_method (&ctx, read32 (ip + 1), *ip == CEE_CALLVIRT);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CALLI:\n\t\t\tcode_bounds_check (5);\n\t\t\ttoken = read32 (ip + 1);\n\t\t\t/*\n\t\t\t * FIXME: check signature, retval, arguments etc.\n\t\t\t * FIXME: check requirements for tail call\n\t\t\t */\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Intruction calli is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\tcase CEE_BR_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_static_branch (&ctx, (signed char)ip [1] + 2);\n\t\t\tneed_merge = 1;\n\t\t\tip += 2;\n\t\t\tstart = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BRFALSE_S:\n\t\tcase CEE_BRTRUE_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_boolean_branch_op (&ctx, (signed char)ip [1] + 2);\n\t\t\tip += 2;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BR:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_static_branch (&ctx, (gint32)read32 (ip + 1) + 5);\n\t\t\tneed_merge = 1;\n\t\t\tip += 5;\n\t\t\tstart = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_BRFALSE:\n\t\tcase CEE_BRTRUE:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_boolean_branch_op (&ctx, (gint32)read32 (ip + 1) + 5);\n\t\t\tip += 5;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_SWITCH: {\n\t\t\tguint32 entries;\n\t\t\tcode_bounds_check (5);\n\t\t\tentries = read32 (ip + 1);\n\n\t\t\tif (entries > 0xFFFFFFFFU / sizeof (guint32))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Too many switch entries %x at 0x%04x\", entries, ctx.ip_offset));\n\n\t\t\tip += 5;\n\t\t\tcode_bounds_check (sizeof (guint32) * entries);\n\t\t\t\n\t\t\tdo_switch (&ctx, entries, ip);\n\t\t\tip += sizeof (guint32) * entries;\n\t\t\tbreak;\n\t\t}\n\t\tcase CEE_LDIND_I1:\n\t\tcase CEE_LDIND_U1:\n\t\tcase CEE_LDIND_I2:\n\t\tcase CEE_LDIND_U2:\n\t\tcase CEE_LDIND_I4:\n\t\tcase CEE_LDIND_U4:\n\t\tcase CEE_LDIND_I8:\n\t\tcase CEE_LDIND_I:\n\t\tcase CEE_LDIND_R4:\n\t\tcase CEE_LDIND_R8:\n\t\tcase CEE_LDIND_REF:\n\t\t\tdo_load_indirect (&ctx, *ip);\n\t\t\t++ip;\n\t\t\tbreak;\n\t\t\t\n\t\tcase CEE_STIND_REF:\n\t\tcase CEE_STIND_I1:\n\t\tcase CEE_STIND_I2:\n\t\tcase CEE_STIND_I4:\n\t\tcase CEE_STIND_I8:\n\t\tcase CEE_STIND_R4:\n\t\tcase CEE_STIND_R8:\n\t\tcase CEE_STIND_I:\n\t\t\tdo_store_indirect (&ctx, *ip);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_NOT:\n\t\tcase CEE_NEG:\n\t\t\tdo_unary_math_op (&ctx, *ip);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_I1:\n\t\tcase CEE_CONV_I2:\n\t\tcase CEE_CONV_I4:\n\t\tcase CEE_CONV_U1:\n\t\tcase CEE_CONV_U2:\n\t\tcase CEE_CONV_U4:\n\t\t\tdo_conversion (&ctx, TYPE_I4);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_I8:\n\t\tcase CEE_CONV_U8:\n\t\t\tdo_conversion (&ctx, TYPE_I8);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_R4:\n\t\tcase CEE_CONV_R8:\n\t\tcase CEE_CONV_R_UN:\n\t\t\tdo_conversion (&ctx, TYPE_R8);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_I:\n\t\tcase CEE_CONV_U:\n\t\t\tdo_conversion (&ctx, TYPE_NATIVE_INT);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CPOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_cpobj (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldobj_value (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDSTR:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldstr (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_NEWOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_newobj (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CASTCLASS:\n\t\tcase CEE_ISINST:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_cast (&ctx, read32 (ip + 1), *ip == CEE_CASTCLASS ? \"castclass\" : \"isinst\");\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_UNUSED58:\n\t\tcase CEE_UNUSED1:\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Use of the `unused' opcode\"));\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_UNBOX:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_unbox_value (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_THROW:\n\t\t\tdo_throw (&ctx);\n\t\t\tstart = 1;\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDFLD:\n\t\tcase CEE_LDFLDA:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_push_field (&ctx, read32 (ip + 1), *ip == CEE_LDFLDA);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDSFLD:\n\t\tcase CEE_LDSFLDA:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_push_static_field (&ctx, read32 (ip + 1), *ip == CEE_LDSFLDA);\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STFLD:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_store_field (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STSFLD:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_store_static_field (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STOBJ:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_stobj (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I1_UN:\n\t\tcase CEE_CONV_OVF_I2_UN:\n\t\tcase CEE_CONV_OVF_I4_UN:\n\t\tcase CEE_CONV_OVF_U1_UN:\n\t\tcase CEE_CONV_OVF_U2_UN:\n\t\tcase CEE_CONV_OVF_U4_UN:\n\t\t\tdo_conversion (&ctx, TYPE_I4);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_OVF_I8_UN:\n\t\tcase CEE_CONV_OVF_U8_UN:\n\t\t\tdo_conversion (&ctx, TYPE_I8);\n\t\t\t++ip;\n\t\t\tbreak;\t\t\t\n\n\t\tcase CEE_CONV_OVF_I_UN:\n\t\tcase CEE_CONV_OVF_U_UN:\n\t\t\tdo_conversion (&ctx, TYPE_NATIVE_INT);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_BOX:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_box_value (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_NEWARR:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_newarr (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDLEN:\n\t\t\tdo_ldlen (&ctx);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDELEMA:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldelema (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDELEM_I1:\n\t\tcase CEE_LDELEM_U1:\n\t\tcase CEE_LDELEM_I2:\n\t\tcase CEE_LDELEM_U2:\n\t\tcase CEE_LDELEM_I4:\n\t\tcase CEE_LDELEM_U4:\n\t\tcase CEE_LDELEM_I8:\n\t\tcase CEE_LDELEM_I:\n\t\tcase CEE_LDELEM_R4:\n\t\tcase CEE_LDELEM_R8:\n\t\tcase CEE_LDELEM_REF:\n\t\t\tdo_ldelem (&ctx, *ip, 0);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_STELEM_I:\n\t\tcase CEE_STELEM_I1:\n\t\tcase CEE_STELEM_I2:\n\t\tcase CEE_STELEM_I4:\n\t\tcase CEE_STELEM_I8:\n\t\tcase CEE_STELEM_R4:\n\t\tcase CEE_STELEM_R8:\n\t\tcase CEE_STELEM_REF:\n\t\t\tdo_stelem (&ctx, *ip, 0);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LDELEM:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_ldelem (&ctx, *ip, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_STELEM:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_stelem (&ctx, *ip, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\t\t\t\n\t\tcase CEE_UNBOX_ANY:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_unbox_any (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I1:\n\t\tcase CEE_CONV_OVF_U1:\n\t\tcase CEE_CONV_OVF_I2:\n\t\tcase CEE_CONV_OVF_U2:\n\t\tcase CEE_CONV_OVF_I4:\n\t\tcase CEE_CONV_OVF_U4:\n\t\t\tdo_conversion (&ctx, TYPE_I4);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I8:\n\t\tcase CEE_CONV_OVF_U8:\n\t\t\tdo_conversion (&ctx, TYPE_I8);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_CONV_OVF_I:\n\t\tcase CEE_CONV_OVF_U:\n\t\t\tdo_conversion (&ctx, TYPE_NATIVE_INT);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_REFANYVAL:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_refanyval (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_CKFINITE:\n\t\t\tdo_ckfinite (&ctx);\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_MKREFANY:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_mkrefany (&ctx,  read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_LDTOKEN:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_load_token (&ctx, read32 (ip + 1));\n\t\t\tip += 5;\n\t\t\tbreak;\n\n\t\tcase CEE_ENDFINALLY:\n\t\t\tif (!is_correct_endfinally (ctx.header, ip_offset))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"endfinally must be used inside a finally/fault handler at 0x%04x\", ctx.ip_offset));\n\t\t\tctx.eval.size = 0;\n\t\t\tstart = 1;\n\t\t\t++ip;\n\t\t\tbreak;\n\n\t\tcase CEE_LEAVE:\n\t\t\tcode_bounds_check (5);\n\t\t\tdo_leave (&ctx, read32 (ip + 1) + 5);\n\t\t\tip += 5;\n\t\t\tstart = 1;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_LEAVE_S:\n\t\t\tcode_bounds_check (2);\n\t\t\tdo_leave (&ctx, (signed char)ip [1] + 2);\n\t\t\tip += 2;\n\t\t\tstart = 1;\n\t\t\tneed_merge = 1;\n\t\t\tbreak;\n\n\t\tcase CEE_PREFIX1:\n\t\t\tcode_bounds_check (2);\n\t\t\t++ip;\n\t\t\tswitch (*ip) {\n\t\t\tcase CEE_STLOC:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tstore_local (&ctx, read16 (ip + 1));\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CEQ:\n\t\t\t\tdo_cmp_op (&ctx, cmp_br_eq_op, *ip);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CGT:\n\t\t\tcase CEE_CGT_UN:\n\t\t\tcase CEE_CLT:\n\t\t\tcase CEE_CLT_UN:\n\t\t\t\tdo_cmp_op (&ctx, cmp_br_op, *ip);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_STARG:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tstore_arg (&ctx, read16 (ip + 1) );\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\n\t\t\tcase CEE_ARGLIST:\n\t\t\t\tif (!check_overflow (&ctx))\n\t\t\t\t\tbreak;\n\t\t\t\tif (ctx.signature->call_convention != MONO_CALL_VARARG)\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Cannot use arglist on method without VARGARG calling convention at 0x%04x\", ctx.ip_offset));\n\t\t\t\tset_stack_value (&ctx, stack_push (&ctx), &mono_defaults.argumenthandle_class->byval_arg, FALSE);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\n\t\t\tcase CEE_LDFTN:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_load_function_ptr (&ctx, read32 (ip + 1), FALSE);\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LDVIRTFTN:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_load_function_ptr (&ctx, read32 (ip + 1), TRUE);\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LDARG:\n\t\t\tcase CEE_LDARGA:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tpush_arg (&ctx, read16 (ip + 1),  *ip == CEE_LDARGA);\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LDLOC:\n\t\t\tcase CEE_LDLOCA:\n\t\t\t\tcode_bounds_check (3);\n\t\t\t\tpush_local (&ctx, read16 (ip + 1), *ip == CEE_LDLOCA);\n\t\t\t\tip += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_LOCALLOC:\n\t\t\t\tdo_localloc (&ctx);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_UNUSED56:\n\t\t\tcase CEE_UNUSED57:\n\t\t\tcase CEE_UNUSED70:\n\t\t\tcase CEE_UNUSED:\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Use of the `unused' opcode\"));\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\t\tcase CEE_ENDFILTER:\n\t\t\t\tdo_endfilter (&ctx);\n\t\t\t\tstart = 1;\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\t\tcase CEE_UNALIGNED_:\n\t\t\t\tcode_bounds_check (2);\n\t\t\t\tprefix |= PREFIX_UNALIGNED;\n\t\t\t\tip += 2;\n\t\t\t\tbreak;\n\t\t\tcase CEE_VOLATILE_:\n\t\t\t\tprefix |= PREFIX_VOLATILE;\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\t\t\tcase CEE_TAIL_:\n\t\t\t\tprefix |= PREFIX_TAIL;\n\t\t\t\t++ip;\n\t\t\t\tif (ip < end && (*ip != CEE_CALL && *ip != CEE_CALLI && *ip != CEE_CALLVIRT))\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"tail prefix must be used only with call opcodes at 0x%04x\", ip_offset));\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_INITOBJ:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_initobj (&ctx, read32 (ip + 1));\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CONSTRAINED_:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tctx.constrained_type = get_boxable_mono_type (&ctx, read32 (ip + 1), \"constrained.\");\n\t\t\t\tprefix |= PREFIX_CONSTRAINED;\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\t\n\t\t\tcase CEE_READONLY_:\n\t\t\t\tprefix |= PREFIX_READONLY;\n\t\t\t\tip++;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_CPBLK:\n\t\t\t\tCLEAR_PREFIX (&ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\t\t\t\tif (!check_underflow (&ctx, 3))\n\t\t\t\t\tbreak;\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Instruction cpblk is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\t\tip++;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase CEE_INITBLK:\n\t\t\t\tCLEAR_PREFIX (&ctx, PREFIX_UNALIGNED | PREFIX_VOLATILE);\n\t\t\t\tif (!check_underflow (&ctx, 3))\n\t\t\t\t\tbreak;\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Instruction initblk is not verifiable at 0x%04x\", ctx.ip_offset));\n\t\t\t\tip++;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase CEE_NO_:\n\t\t\t\tip += 2;\n\t\t\t\tbreak;\n\t\t\tcase CEE_RETHROW:\n\t\t\t\tif (!is_correct_rethrow (ctx.header, ip_offset))\n\t\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"rethrow must be used inside a catch handler at 0x%04x\", ctx.ip_offset));\n\t\t\t\tctx.eval.size = 0;\n\t\t\t\tstart = 1;\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_SIZEOF:\n\t\t\t\tcode_bounds_check (5);\n\t\t\t\tdo_sizeof (&ctx, read32 (ip + 1));\n\t\t\t\tip += 5;\n\t\t\t\tbreak;\n\n\t\t\tcase CEE_REFANYTYPE:\n\t\t\t\tdo_refanytype (&ctx);\n\t\t\t\t++ip;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction FE %x at 0x%04x\", *ip, ctx.ip_offset));\n\t\t\t\t++ip;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction %x at 0x%04x\", *ip, ctx.ip_offset));\n\t\t\t++ip;\n\t\t}\n\n\t\t/*TODO we can fast detect a forward branch or exception block targeting code after prefix, we should fail fast*/\n\t\tif (prefix) {\n\t\t\tif (!ctx.prefix_set) //first prefix\n\t\t\t\tctx.code [ctx.ip_offset].flags |= IL_CODE_FLAG_SEEN;\n\t\t\tctx.prefix_set |= prefix;\n\t\t\tctx.has_flags = TRUE;\n\t\t\tprefix = 0;\n\t\t} else {\n\t\t\tif (!ctx.has_flags)\n\t\t\t\tctx.code [ctx.ip_offset].flags |= IL_CODE_FLAG_SEEN;\n\n\t\t\tif (ctx.prefix_set & PREFIX_CONSTRAINED)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after constrained prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tif (ctx.prefix_set & PREFIX_READONLY)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after readonly prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tif (ctx.prefix_set & PREFIX_VOLATILE)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after volatile prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tif (ctx.prefix_set & PREFIX_UNALIGNED)\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Invalid instruction after unaligned prefix at 0x%04x\", ctx.ip_offset));\n\t\t\tctx.prefix_set = prefix = 0;\n\t\t\tctx.has_flags = FALSE;\n\t\t}\n\t}\n\t/*\n\t * if ip != end we overflowed: mark as error.\n\t */\n\tif ((ip != end || !start) && ctx.verifiable && !ctx.list) {\n\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Run ahead of method code at 0x%04x\", ip_offset));\n\t}\n\n\t/*We should guard against the last decoded opcode, otherwise we might add errors that doesn't make sense.*/\n\tfor (i = 0; i < ctx.code_size && i < ip_offset; ++i) {\n\t\tif (ctx.code [i].flags & IL_CODE_FLAG_WAS_TARGET) {\n\t\t\tif (!(ctx.code [i].flags & IL_CODE_FLAG_SEEN))\n\t\t\t\tADD_VERIFY_ERROR (&ctx, g_strdup_printf (\"Branch or exception block target middle of intruction at 0x%04x\", i));\n\n\t\t\tif (ctx.code [i].flags & IL_CODE_DELEGATE_SEQUENCE)\n\t\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Branch to delegate code sequence at 0x%04x\", i));\n\t\t}\n\t\tif ((ctx.code [i].flags & IL_CODE_LDFTN_DELEGATE_NONFINAL_VIRTUAL) && ctx.has_this_store)\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Invalid ldftn with virtual function in method with stdarg 0 at  0x%04x\", i));\n\n\t\tif ((ctx.code [i].flags & IL_CODE_CALL_NONFINAL_VIRTUAL) && ctx.has_this_store)\n\t\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Invalid call to a non-final virtual function in method with stdarg.0 or ldarga.0 at  0x%04x\", i));\n\t}\n\n\tif (mono_method_is_constructor (ctx.method) && !ctx.super_ctor_called && !ctx.method->klass->valuetype && ctx.method->klass != mono_defaults.object_class)\n\t\tCODE_NOT_VERIFIABLE (&ctx, g_strdup_printf (\"Constructor not calling super\\n\"));\n\ncleanup:\n\tif (ctx.code) {\n\t\tfor (i = 0; i < ctx.header->code_size; ++i) {\n\t\t\tif (ctx.code [i].stack)\n\t\t\t\tg_free (ctx.code [i].stack);\n\t\t}\n\t}\n\n\tfor (tmp = ctx.funptrs; tmp; tmp = tmp->next)\n\t\tg_free (tmp->data);\n\tg_slist_free (ctx.funptrs);\n\n\tfor (tmp = ctx.exception_types; tmp; tmp = tmp->next)\n\t\tmono_metadata_free_type (tmp->data);\n\tg_slist_free (ctx.exception_types);\n\n\tfor (i = 0; i < ctx.num_locals; ++i) {\n\t\tif (ctx.locals [i])\n\t\t\tmono_metadata_free_type (ctx.locals [i]);\n\t}\n\tfor (i = 0; i < ctx.max_args; ++i) {\n\t\tif (ctx.params [i])\n\t\t\tmono_metadata_free_type (ctx.params [i]);\n\t}\n\n\tif (ctx.eval.stack)\n\t\tg_free (ctx.eval.stack);\n\tif (ctx.code)\n\t\tg_free (ctx.code);\n\tg_free (ctx.locals);\n\tg_free (ctx.params);\n\tmono_basic_block_free (original_bb);\n\n\treturn ctx.list;\n}\n\nchar*\nmono_verify_corlib ()\n{\n\t/* This is a public API function so cannot be removed */\n\treturn NULL;\n}\n\n/*\n * Returns true if @method needs to be verified.\n * \n */\ngboolean\nmono_verifier_is_enabled_for_method (MonoMethod *method)\n{\n\treturn mono_verifier_is_enabled_for_class (method->klass) && method->wrapper_type == MONO_WRAPPER_NONE;\n}\n\n/*\n * Returns true if @klass need to be verified.\n * \n */\ngboolean\nmono_verifier_is_enabled_for_class (MonoClass *klass)\n{\n\treturn verify_all || (verifier_mode > MONO_VERIFIER_MODE_OFF && !klass->image->assembly->in_gac && klass->image != mono_defaults.corlib);\n}\n\ngboolean\nmono_verifier_is_enabled_for_image (MonoImage *image)\n{\n\treturn verify_all || verifier_mode > MONO_VERIFIER_MODE_OFF;\n}\n\ngboolean\nmono_verifier_is_method_full_trust (MonoMethod *method)\n{\n\treturn mono_verifier_is_class_full_trust (method->klass);\n}\n\n/*\n * Returns if @klass is under full trust or not.\n * \n * TODO This code doesn't take CAS into account.\n * \n * Under verify_all all user code must be verifiable if no security option was set \n * \n */\ngboolean\nmono_verifier_is_class_full_trust (MonoClass *klass)\n{\n\t/* under CoreCLR code is trusted if it is part of the \"platform\" otherwise all code inside the GAC is trusted */\n\tgboolean trusted_location = (mono_security_get_mode () != MONO_SECURITY_MODE_CORE_CLR) ? \n\t\tklass->image->assembly->in_gac : mono_security_core_clr_is_platform_image (klass->image);\n\n\tif (verify_all && verifier_mode == MONO_VERIFIER_MODE_OFF)\n\t\treturn trusted_location || klass->image == mono_defaults.corlib;\n\treturn verifier_mode < MONO_VERIFIER_MODE_VERIFIABLE || trusted_location || klass->image == mono_defaults.corlib;\n}\n\nGSList*\nmono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility)\n{\n\treturn mono_method_verify (method, \n\t\t\t(verifier_mode != MONO_VERIFIER_MODE_STRICT ? MONO_VERIFY_NON_STRICT: 0)\n\t\t\t| (!mono_verifier_is_method_full_trust (method) ? MONO_VERIFY_FAIL_FAST : 0)\n\t\t\t| (skip_visibility ? MONO_VERIFY_SKIP_VISIBILITY : 0));\n}\n\nstatic int\nget_field_end (MonoClassField *field)\n{\n\tint align;\n\tint size = mono_type_size (field->type, &align);\n\tif (size == 0)\n\t\tsize = 4; /*FIXME Is this a safe bet?*/\n\treturn size + field->offset;\n}\n\nstatic gboolean\nverify_class_for_overlapping_reference_fields (MonoClass *class)\n{\n\tint i = 0, j;\n\tgpointer iter = NULL;\n\tMonoClassField *field;\n\tgboolean is_fulltrust = mono_verifier_is_class_full_trust (class);\n\t/*We can't skip types with !has_references since this is calculated after we have run.*/\n\tif (!((class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT))\n\t\treturn TRUE;\n\n\n\t/*We must check for stuff overlapping reference fields.\n\t  The outer loop uses mono_class_get_fields to ensure that MonoClass:fields get inited.\n\t*/\n\twhile ((field = mono_class_get_fields (class, &iter))) {\n\t\tint fieldEnd = get_field_end (field);\n\t\tgboolean is_valuetype = !MONO_TYPE_IS_REFERENCE (field->type);\n\t\t++i;\n\n\t\tif (mono_field_is_deleted (field) || (field->type->attrs & FIELD_ATTRIBUTE_STATIC))\n\t\t\tcontinue;\n\n\t\tfor (j = i; j < class->field.count; ++j) {\n\t\t\tMonoClassField *other = &class->fields [j];\n\t\t\tint otherEnd = get_field_end (other);\n\t\t\tif (mono_field_is_deleted (other) || (is_valuetype && !MONO_TYPE_IS_REFERENCE (other->type)) || (other->type->attrs & FIELD_ATTRIBUTE_STATIC))\n\t\t\t\tcontinue;\n\n\t\t\tif (!is_valuetype && MONO_TYPE_IS_REFERENCE (other->type) && field->offset == other->offset && is_fulltrust)\n\t\t\t\tcontinue;\n\n\t\t\tif ((otherEnd > field->offset && otherEnd <= fieldEnd) || (other->offset >= field->offset && other->offset < fieldEnd))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n\nstatic guint\nfield_hash (gconstpointer key)\n{\n\tconst MonoClassField *field = key;\n\treturn g_str_hash (field->name) ^ mono_metadata_type_hash (field->type); /**/\n}\n\nstatic gboolean\nfield_equals (gconstpointer _a, gconstpointer _b)\n{\n\tconst MonoClassField *a = _a;\n\tconst MonoClassField *b = _b;\n\treturn !strcmp (a->name, b->name) && mono_metadata_type_equal (a->type, b->type);\n}\n\n\nstatic gboolean\nverify_class_fields (MonoClass *class)\n{\n\tgpointer iter = NULL;\n\tMonoClassField *field;\n\tMonoGenericContext *context = mono_class_get_context (class);\n\tGHashTable *unique_fields = g_hash_table_new_full (&field_hash, &field_equals, NULL, NULL);\n\tif (class->generic_container)\n\t\tcontext = &class->generic_container->context;\n\n\twhile ((field = mono_class_get_fields (class, &iter)) != NULL) {\n\t\tif (!mono_type_is_valid_type_in_context (field->type, context)) {\n\t\t\tg_hash_table_destroy (unique_fields);\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (g_hash_table_lookup (unique_fields, field)) {\n\t\t\tg_hash_table_destroy (unique_fields);\n\t\t\treturn FALSE;\n\t\t}\n\t\tg_hash_table_insert (unique_fields, field, field);\n\t}\n\tg_hash_table_destroy (unique_fields);\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_interfaces (MonoClass *class)\n{\n\tint i;\n\tfor (i = 0; i < class->interface_count; ++i) {\n\t\tMonoClass *iface = class->interfaces [i];\n\t\tif (!(iface->flags & TYPE_ATTRIBUTE_INTERFACE))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_valuetype_layout_with_target (MonoClass *class, MonoClass *target_class)\n{\n\tint type;\n\tgpointer iter = NULL;\n\tMonoClassField *field;\n\tMonoClass *field_class;\n\n\tif (!class->valuetype)\n\t\treturn TRUE;\n\n\ttype = class->byval_arg.type;\n\t/*primitive type fields are not properly decoded*/\n\tif ((type >= MONO_TYPE_BOOLEAN && type <= MONO_TYPE_R8) || (type >= MONO_TYPE_I && type <= MONO_TYPE_U))\n\t\treturn TRUE;\n\n\twhile ((field = mono_class_get_fields (class, &iter)) != NULL) {\n\t\tif (!field->type)\n\t\t\treturn FALSE;\n\n\t\tif (field->type->attrs & (FIELD_ATTRIBUTE_STATIC | FIELD_ATTRIBUTE_HAS_FIELD_RVA))\n\t\t\tcontinue;\n\n\t\tfield_class = mono_class_get_generic_type_definition (mono_class_from_mono_type (field->type));\n\n\t\tif (field_class == target_class || class == field_class || !verify_valuetype_layout_with_target (field_class, target_class))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_valuetype_layout (MonoClass *class)\n{\n\tgboolean res;\n\tres = verify_valuetype_layout_with_target (class, class);\n\treturn res;\n}\n\nstatic gboolean\nrecursive_mark_constraint_args (MonoBitSet *used_args, MonoGenericContainer *gc, MonoType *type)\n{\n\tint idx;\n\tMonoClass **constraints;\n\tMonoGenericParamInfo *param_info;\n\n\tg_assert (mono_type_is_generic_argument (type));\n\n\tidx = mono_type_get_generic_param_num (type);\n\tif (mono_bitset_test_fast (used_args, idx))\n\t\treturn FALSE;\n\n\tmono_bitset_set_fast (used_args, idx);\n\tparam_info = mono_generic_container_get_param_info (gc, idx);\n\n\tif (!param_info->constraints)\n\t\treturn TRUE;\n\n\tfor (constraints = param_info->constraints; *constraints; ++constraints) {\n\t\tMonoClass *ctr = *constraints;\n\t\tMonoType *constraint_type = &ctr->byval_arg;\n\n\t\tif (mono_type_is_generic_argument (constraint_type) && !recursive_mark_constraint_args (used_args, gc, constraint_type))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nstatic gboolean\nverify_generic_parameters (MonoClass *class)\n{\n\tint i;\n\tMonoGenericContainer *gc = class->generic_container;\n\tMonoBitSet *used_args = mono_bitset_new (gc->type_argc, 0);\n\n\tfor (i = 0; i < gc->type_argc; ++i) {\n\t\tMonoGenericParamInfo *param_info = mono_generic_container_get_param_info (gc, i);\n\t\tMonoClass **constraints;\n\n\t\tif (!param_info->constraints)\n\t\t\tcontinue;\n\n\t\tmono_bitset_clear_all (used_args);\n\t\tmono_bitset_set_fast (used_args, i);\n\n\t\tfor (constraints = param_info->constraints; *constraints; ++constraints) {\n\t\t\tMonoClass *ctr = *constraints;\n\t\t\tMonoType *constraint_type = &ctr->byval_arg;\n\n\t\t\tif (!mono_type_is_valid_type_in_context (constraint_type, &gc->context))\n\t\t\t\tgoto fail;\n\n\t\t\tif (mono_type_is_generic_argument (constraint_type) && !recursive_mark_constraint_args (used_args, gc, constraint_type))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tmono_bitset_free (used_args);\n\treturn TRUE;\n\nfail:\n\tmono_bitset_free (used_args);\n\treturn FALSE;\n}\n\n/*\n * Check if the class is verifiable.\n * \n * Right now there are no conditions that make a class a valid but not verifiable. Both overlapping reference\n * field and invalid generic instantiation are fatal errors.\n * \n * This method must be safe to be called from mono_class_init and all code must be carefull about that.\n * \n */\ngboolean\nmono_verifier_verify_class (MonoClass *class)\n{\n\t/*Neither <Module>, object or ifaces have parent.*/\n\tif (!class->parent &&\n\t\tclass != mono_defaults.object_class && \n\t\t!MONO_CLASS_IS_INTERFACE (class) &&\n\t\t(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/\n\t\treturn FALSE;\n\tif (class->parent && MONO_CLASS_IS_INTERFACE (class->parent))\n\t\treturn FALSE;\n\tif (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)\n\t\treturn FALSE;\n\tif (class->generic_container && !verify_generic_parameters (class))\n\t\treturn FALSE;\n\tif (!verify_class_for_overlapping_reference_fields (class))\n\t\treturn FALSE;\n\tif (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))\n\t\treturn FALSE;\n\tif (class->generic_class == NULL && !verify_class_fields (class))\n\t\treturn FALSE;\n\tif (class->valuetype && !verify_valuetype_layout (class))\n\t\treturn FALSE;\n\tif (!verify_interfaces (class))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n{\n\treturn mono_class_is_valid_generic_instantiation (NULL, class);\n}\n\ngboolean\nmono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n{\n\tif (!method->is_inflated)\n\t\treturn TRUE;\n\treturn mono_method_is_valid_generic_instantiation (NULL, method);\n}\n\n#else\n\ngboolean\nmono_verifier_verify_class (MonoClass *class)\n{\n\t/* The verifier was disabled at compile time */\n\treturn TRUE;\n}\n\nGSList*\nmono_method_verify_with_current_settings (MonoMethod *method, gboolean skip_visibility)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;\n}\n\ngboolean\nmono_verifier_is_class_full_trust (MonoClass *klass)\n{\n\t/* The verifier was disabled at compile time */\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_is_method_full_trust (MonoMethod *method)\n{\n\t/* The verifier was disabled at compile time */\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_is_enabled_for_image (MonoImage *image)\n{\n\t/* The verifier was disabled at compile time */\n\treturn FALSE;\n}\n\ngboolean\nmono_verifier_is_enabled_for_class (MonoClass *klass)\n{\n\t/* The verifier was disabled at compile time */\n\treturn FALSE;\n}\n\ngboolean\nmono_verifier_is_enabled_for_method (MonoMethod *method)\n{\n\t/* The verifier was disabled at compile time */\n\treturn FALSE;\n}\n\nGSList*\nmono_method_verify (MonoMethod *method, int level)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;\n}\n\nvoid\nmono_free_verify_list (GSList *list)\n{\n\t/* The verifier was disabled at compile time */\n\t/* will always be null if verifier is disabled */\n}\n\nGSList*\nmono_image_verify_tables (MonoImage *image, int level)\n{\n\t/* The verifier was disabled at compile time */\n\treturn NULL;\n}\t\n\ngboolean\nmono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n{\n\treturn TRUE;\n}\n\ngboolean\nmono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n{\n\treturn TRUE;\n}\n\n\n\n#endif\n"], "filenames": ["mono/metadata/reflection.c", "mono/metadata/verify-internals.h", "mono/metadata/verify.c"], "buggy_code_start_loc": [10178, 24, 6535], "buggy_code_end_loc": [10178, 24, 6613], "fixing_code_start_loc": [10179, 25, 6536], "fixing_code_end_loc": [10182, 26, 6629], "type": "CWE-20", "message": "Mono, when Moonlight before 2.3.0.1 or 2.99.x before 2.99.0.10 is used, does not properly validate arguments to generic methods, which allows remote attackers to bypass generic constraints, and possibly execute arbitrary code, via a crafted method call.", "other": {"cve": {"id": "CVE-2010-4254", "sourceIdentifier": "secalert@redhat.com", "published": "2010-12-06T13:44:54.157", "lastModified": "2011-02-02T06:59:41.827", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Mono, when Moonlight before 2.3.0.1 or 2.99.x before 2.99.0.10 is used, does not properly validate arguments to generic methods, which allows remote attackers to bypass generic constraints, and possibly execute arbitrary code, via a crafted method call."}, {"lang": "es", "value": "Mono, cuando Moonlight en versiones anteriores a la 2.3.0.1 o 2.99.x anteriores a la 2.99.0.10 es utilizado, no valida apropiadamente los argumentos a los m\u00e9todos gen\u00e9ricos. Lo que permite a atacantes remotos evitar las restricciones gen\u00e9ricas y posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de una llamada a un m\u00e9todo modificado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:*:*:*:*:*:*:*:*", "matchCriteriaId": "E062208D-082B-4BFD-85CA-3848ECE6F8CF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.0", "matchCriteriaId": "9F4B24CA-B511-49A1-A3F6-5128279D1339"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.99.0:*:*:*:*:*:*:*", "matchCriteriaId": "BF483675-722E-42AF-9698-4BFBE4987ADE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.99.1:*:*:*:*:*:*:*", "matchCriteriaId": "8CB09C96-4186-4828-AF42-BDAB1D52C510"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.99.2:*:*:*:*:*:*:*", "matchCriteriaId": "925AFBDD-F52F-4D71-B201-1002B0B2924B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.99.7:*:*:*:*:*:*:*", "matchCriteriaId": "DD682A37-02C5-481B-A1EB-CD8452757E7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.99.9:*:*:*:*:*:*:*", "matchCriteriaId": "AE13D028-0948-4C9C-9EF4-56956ED64006"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2010-12/msg00006.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-01/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://www.exploit-db.com/exploits/15974", "source": "secalert@redhat.com"}, {"url": "http://www.mono-project.com/Vulnerabilities#Moonlight_Generic_Constraints_Bypass_Vulnerability", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/45051", "source": "secalert@redhat.com"}, {"url": "http://www.vupen.com/english/advisories/2011/0076", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=654136", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=655847", "source": "secalert@redhat.com"}, {"url": "https://github.com/mono/mono/commit/4905ef1130feb26c3150b28b97e4a96752e0d399", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/mono/mono/commit/65292a69c837b8a5f7a392d34db63de592153358", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/mono/mono/commit/cf1ec146f7c6acdc6697032b3aaafc68ffacdcac", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mono/mono/commit/4905ef1130feb26c3150b28b97e4a96752e0d399"}}