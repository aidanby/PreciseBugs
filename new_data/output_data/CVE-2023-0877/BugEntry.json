{"buggy_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Froxlor\\Database\\Database;\n\nfinal class Froxlor\n{\n\n\t// Main version variable\n\tconst VERSION = '2.0.10';\n\n\t// Database version (YYYYMMDDC where C is a daily counter)\n\tconst DBVERSION = '202302030';\n\n\t// Distribution branding-tag (used for Debian etc.)\n\tconst BRANDING = '';\n\n\t/**\n\t * return path to where froxlor is installed, e.g.\n\t * /var/www/froxlor/\n\t *\n\t * @return string\n\t */\n\tpublic static function getInstallDir(): string\n\t{\n\t\treturn dirname(__DIR__, 2) . '/';\n\t}\n\n\t/**\n\t * return basic version\n\t *\n\t * @return string\n\t */\n\tpublic static function getVersion(): string\n\t{\n\t\treturn self::VERSION;\n\t}\n\n\t/**\n\t * return version + branding and database-version\n\t *\n\t * @return string\n\t */\n\tpublic static function getVersionString(): string\n\t{\n\t\treturn self::getFullVersion() . ' (' . self::DBVERSION . ')';\n\t}\n\n\t/**\n\t * return version + branding\n\t *\n\t * @return string\n\t */\n\tpublic static function getFullVersion(): string\n\t{\n\t\treturn self::VERSION . self::BRANDING;\n\t}\n\n\t/**\n\t * Function hasUpdates\n\t *\n\t * checks if a given version is not equal the current one\n\t *\n\t * @param string $to_check version to check, if empty current version is used\n\t *\n\t * @return bool true if version to check does not match, else false\n\t */\n\tpublic static function hasUpdates(string $to_check): bool\n\t{\n\t\tif (empty($to_check)) {\n\t\t\t$to_check = self::VERSION;\n\t\t}\n\t\tif (Settings::Get('panel.version') == null || Settings::Get('panel.version') != $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function hasDbUpdates\n\t *\n\t * checks if a given database-version is not equal the current one\n\t *\n\t * @param string $to_check version to check, if empty current dbversion is used\n\t *\n\t * @return bool true if version to check does not match, else false\n\t */\n\tpublic static function hasDbUpdates(string $to_check): bool\n\t{\n\t\tif (empty($to_check)) {\n\t\t\t$to_check = self::DBVERSION;\n\t\t}\n\t\tif (Settings::Get('panel.db_version') == null || Settings::Get('panel.db_version') != $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function isDatabaseVersion\n\t *\n\t * checks if a given database-version is the current one\n\t *\n\t * @param string $to_check version to check\n\t *\n\t * @return bool true if version to check matches, else false\n\t */\n\tpublic static function isDatabaseVersion(string $to_check): bool\n\t{\n\t\tif (Settings::Get('panel.frontend') == 'froxlor' && Settings::Get('panel.db_version') == $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function updateToDbVersion\n\t *\n\t * updates the panel.version field\n\t * to the given value (no checks here!)\n\t *\n\t * @param string $new_version new-version\n\t *\n\t * @return bool true on success, else false\n\t * @throws \\Exception\n\t */\n\tpublic static function updateToDbVersion(string $new_version): bool\n\t{\n\t\tif ($new_version != '') {\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_SETTINGS . \"` SET `value` = :newversion\n\t\t\t\tWHERE `settinggroup` = 'panel' AND `varname` = 'db_version'\");\n\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t'newversion' => $new_version\n\t\t\t]);\n\t\t\tSettings::Set('panel.db_version', $new_version);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function updateToVersion\n\t *\n\t * updates the panel.version field\n\t * to the given value (no checks here!)\n\t *\n\t * @param string $new_version new-version\n\t *\n\t * @return bool true on success, else false\n\t * @throws \\Exception\n\t */\n\tpublic static function updateToVersion(string $new_version): bool\n\t{\n\t\tif ($new_version != '') {\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_SETTINGS . \"` SET `value` = :newversion\n\t\t\t\tWHERE `settinggroup` = 'panel' AND `varname` = 'version'\");\n\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t'newversion' => $new_version\n\t\t\t]);\n\t\t\tSettings::Set('panel.version', $new_version);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function isFroxlor\n\t *\n\t * checks if the panel is froxlor\n\t *\n\t * @return bool true if panel is froxlor, else false\n\t */\n\tpublic static function isFroxlor(): bool\n\t{\n\t\tif (Settings::Get('panel.frontend') !== null && Settings::Get('panel.frontend') == 'froxlor') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function isFroxlorVersion\n\t *\n\t * checks if a given version is the\n\t * current one (and panel is froxlor)\n\t *\n\t * @param string $to_check version to check\n\t *\n\t * @return bool true if version to check matches, else false\n\t */\n\tpublic static function isFroxlorVersion(string $to_check): bool\n\t{\n\t\tif (Settings::Get('panel.frontend') == 'froxlor' && Settings::Get('panel.version') == $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * generate safe unique session id\n\t *\n\t * @param int $length\n\t * @return string\n\t * @throws \\Exception\n\t */\n\tpublic static function genSessionId(int $length = 16): string\n\t{\n\t\tif ($length <= 8) {\n\t\t\t$length = 16;\n\t\t}\n\t\tif (function_exists('random_bytes')) {\n\t\t\treturn bin2hex(random_bytes($length));\n\t\t}\n\t\tif (function_exists('mcrypt_create_iv') && defined('MCRYPT_DEV_URANDOM')) {\n\t\t\treturn bin2hex(mcrypt_create_iv($length, MCRYPT_DEV_URANDOM));\n\t\t}\n\t\tif (function_exists('openssl_random_pseudo_bytes')) {\n\t\t\treturn bin2hex(openssl_random_pseudo_bytes($length));\n\t\t}\n\t\t// if everything else fails, use unsafe fallback\n\t\treturn md5(uniqid(microtime(), 1));\n\t}\n\n\t/**\n\t * compare of froxlor versions\n\t *\n\t * @param string $a\n\t * @param string $b\n\t *\n\t * @return int 0 if equal, 1 if a>b and -1 if b>a\n\t */\n\tpublic static function versionCompare2(string $a, string $b): int\n\t{\n\t\t// split version into pieces and remove trailing .0\n\t\t$a = explode(\".\", $a);\n\t\t$b = explode(\".\", $b);\n\n\t\tself::parseVersionArray($a);\n\t\tself::parseVersionArray($b);\n\n\t\twhile (count($a) != count($b)) {\n\t\t\tif (count($a) < count($b)) {\n\t\t\t\t$a[] = '0';\n\t\t\t} elseif (count($b) < count($a)) {\n\t\t\t\t$b[] = '0';\n\t\t\t}\n\t\t}\n\n\t\tforeach ($a as $depth => $aVal) {\n\t\t\t// iterate over each piece of A\n\t\t\tif (isset($b[$depth])) {\n\t\t\t\t// if B matches A to this depth, compare the values\n\t\t\t\tif ($aVal > $b[$depth]) {\n\t\t\t\t\treturn 1; // A > B\n\t\t\t\t} elseif ($aVal < $b[$depth]) {\n\t\t\t\t\treturn -1; // B > A\n\t\t\t\t}\n\t\t\t\t// an equal result is inconclusive at this point\n\t\t\t} else {\n\t\t\t\t// if B does not match A to this depth, then A comes after B in sort order\n\t\t\t\treturn 1; // so A > B\n\t\t\t}\n\t\t}\n\t\t// at this point, we know that to the depth that A and B extend to, they are equivalent.\n\t\t// either the loop ended because A is shorter than B, or both are equal.\n\t\treturn (count($a) < count($b)) ? -1 : 0;\n\t}\n\n\t/**\n\t * @param array|null $arr\n\t * @return void\n\t */\n\tprivate static function parseVersionArray(array &$arr = null)\n\t{\n\t\t// -dev or -beta or -rc ?\n\t\tif (stripos($arr[count($arr) - 1], '-') !== false) {\n\t\t\t$x = explode(\"-\", $arr[count($arr) - 1]);\n\t\t\t$arr[count($arr) - 1] = $x[0];\n\t\t\tif (stripos($x[1], 'rc') !== false) {\n\t\t\t\t$arr[] = '-1';\n\t\t\t\t$arr[] = '2'; // dev < beta < rc\n\t\t\t\t// number of rc\n\t\t\t\t$arr[] = substr($x[1], 2);\n\t\t\t} else {\n\t\t\t\tif (stripos($x[1], 'beta') !== false) {\n\t\t\t\t\t$arr[] = '-1';\n\t\t\t\t\t$arr[] = '1'; // dev < beta < rc\n\t\t\t\t\t// number of beta\n\t\t\t\t\t$arr[] = substr($x[1], 3);\n\t\t\t\t} else {\n\t\t\t\t\tif (stripos($x[1], 'dev') !== false) {\n\t\t\t\t\t\t$arr[] = '-1';\n\t\t\t\t\t\t$arr[] = '0'; // dev < beta < rc\n\t\t\t\t\t\t// number of dev\n\t\t\t\t\t\t$arr[] = substr($x[1], 3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Exception;\nuse Froxlor\\Database\\Database;\nuse PDO;\n\n/**\n * Class SImExporter\n *\n * Import/Export settings to JSON\n */\nclass SImExporter\n{\n\t/**\n\t * settings which are not being exported\n\t *\n\t * @var array\n\t */\n\tprivate static $no_export = [\n\t\t'panel.adminmail',\n\t\t'admin.show_news_feed',\n\t\t'system.lastaccountnumber',\n\t\t'system.lastguid',\n\t\t'system.ipaddress',\n\t\t'system.last_traffic_run',\n\t\t'system.hostname',\n\t\t'system.mysql_access_host',\n\t\t'system.lastcronrun',\n\t\t'system.defaultip',\n\t\t'system.defaultsslip',\n\t\t'system.last_tasks_run',\n\t\t'system.last_archive_run',\n\t\t'system.leprivatekey',\n\t\t'system.lepublickey',\n\t\t'system.updatecheck_data',\n\t];\n\n\tpublic static function export()\n\t{\n\t\t$settings_definitions = [];\n\t\tforeach (PhpHelper::loadConfigArrayDir('./actions/admin/settings/')['groups'] as $group) {\n\t\t\tforeach ($group['fields'] as $field) {\n\t\t\t\t$settings_definitions[$field['settinggroup']][$field['varname']] = $field;\n\t\t\t}\n\t\t}\n\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_SETTINGS . \"` ORDER BY `settingid` ASC\n\t\t\");\n\t\t$_data = [];\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$index = $row['settinggroup'] . \".\" . $row['varname'];\n\t\t\tif (!in_array($index, self::$no_export)) {\n\t\t\t\t$_data[$index] = $row['value'];\n\t\t\t}\n\n\t\t\tif (array_key_exists($row['settinggroup'], $settings_definitions) && array_key_exists($row['varname'], $settings_definitions[$row['settinggroup']])) {\n\t\t\t\t// Export image file\n\t\t\t\tif ($settings_definitions[$row['settinggroup']][$row['varname']]['type'] === \"image\") {\n\t\t\t\t\tif ($row['value'] === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$_data[$index . '.image_data'] = base64_encode(file_get_contents(explode('?', $row['value'], 2)[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add checksum for validation\n\t\t$_data['_sha'] = sha1(var_export($_data, true));\n\t\t$_export = json_encode($_data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\n\t\tif (!$_export) {\n\t\t\tthrow new Exception(\"Error exporting settings: \" . json_last_error_msg());\n\t\t}\n\n\t\treturn $_export;\n\t}\n\n\tpublic static function import($json_str = null)\n\t{\n\t\t// decode data\n\t\t$_data = json_decode($json_str, true);\n\t\tif ($_data) {\n\t\t\t// get validity check data\n\t\t\t$_sha = isset($_data['_sha']) ? $_data['_sha'] : false;\n\t\t\t$_version = isset($_data['panel.version']) ? $_data['panel.version'] : false;\n\t\t\t$_dbversion = isset($_data['panel.db_version']) ? $_data['panel.db_version'] : false;\n\t\t\t// check if we have everything we need\n\t\t\tif (!$_sha || !$_version || !$_dbversion) {\n\t\t\t\tthrow new Exception(\"Invalid froxlor settings data. Unable to import.\");\n\t\t\t}\n\t\t\t// validate import file\n\t\t\tunset($_data['_sha']);\n\t\t\t// compare\n\t\t\tif ($_sha != sha1(var_export($_data, true))) {\n\t\t\t\tthrow new Exception(\"SHA check of import data failed. Unable to import.\");\n\t\t\t}\n\t\t\t// do not import version info - but we need that to possibly update settings\n\t\t\t// when there were changes in the variable-name or similar\n\t\t\tunset($_data['panel.version']);\n\t\t\tunset($_data['panel.db_version']);\n\t\t\t// validate we got ssl enabled ips when ssl is enabled\n\t\t\t// otherwise deactivate it\n\t\t\tif ($_data['system.use_ssl'] == 1) {\n\t\t\t\t$result_ssl_ipsandports_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT COUNT(*) as count_ssl_ip FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` WHERE `ssl`='1'\n\t\t\t\t\");\n\t\t\t\t$result = Database::pexecute_first($result_ssl_ipsandports_stmt);\n\t\t\t\tif ($result['count_ssl_ip'] <= 0) {\n\t\t\t\t\t// no ssl-ip -> deactivate\n\t\t\t\t\t$_data['system.use_ssl'] = 0;\n\t\t\t\t\t// deactivate other ssl-related settings\n\t\t\t\t\t$_data['system.leenabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_enabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_redirect'] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// store new data\n\t\t\tforeach ($_data as $index => $value) {\n\t\t\t\t$index_split = explode('.', $index, 3);\n\n\t\t\t\t// Catch image_data and save it\n\t\t\t\tif (isset($index_split[2]) && $index_split[2] === 'image_data' && !empty($_data[$index_split[0] . '.' . $index_split[1]])) {\n\t\t\t\t\t$path = Froxlor::getInstallDir() . '/img/';\n\t\t\t\t\tif (!is_dir($path) && !mkdir($path, 0775)) {\n\t\t\t\t\t\tthrow new Exception(\"img directory does not exist and cannot be created\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make sure we can write to the upload directory\n\t\t\t\t\tif (!is_writable($path)) {\n\t\t\t\t\t\tif (!chmod($path, 0775)) {\n\t\t\t\t\t\t\tthrow new Exception(\"Cannot write to img directory\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t$img_data = base64_decode($value);\n\t\t\t\t\t$img_filename = Froxlor::getInstallDir() . '/' . str_replace('../', '', explode('?', $_data[$index_split[0] . '.' . $index_split[1]], 2)[0]);\n\n\t\t\t\t\tfile_put_contents($img_filename, $img_data);\n\n\t\t\t\t\tif (function_exists('finfo_open')) {\n\t\t\t\t\t\t$finfo = finfo_open(FILEINFO_MIME_TYPE);\n\t\t\t\t\t\t$mimetype = finfo_file($finfo, $img_filename);\n\t\t\t\t\t\tfinfo_close($finfo);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$mimetype = mime_content_type($img_filename);\n\t\t\t\t\t}\n\t\t\t\t\tif (empty($mimetype)) {\n\t\t\t\t\t\t$mimetype = 'application/octet-stream';\n\t\t\t\t\t}\n\t\t\t\t\tif (!in_array($mimetype, ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'])) {\n\t\t\t\t\t\t@unlink($img_filename);\n\t\t\t\t\t\tthrow new Exception(\"Uploaded file is not a valid image\");\n\t\t\t\t\t}\n\n\t\t\t\t\t$spl = explode('.', $img_filename);\n\t\t\t\t\t$file_extension = strtolower(array_pop($spl));\n\t\t\t\t\tunset($spl);\n\n\t\t\t\t\tif (!in_array($file_extension, [\n\t\t\t\t\t\t'jpeg',\n\t\t\t\t\t\t'jpg',\n\t\t\t\t\t\t'png',\n\t\t\t\t\t\t'gif'\n\t\t\t\t\t])) {\n\t\t\t\t\t\t@unlink($img_filename);\n\t\t\t\t\t\tthrow new Exception(\"Invalid file-extension, use one of: jpeg, jpg, png, gif\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSettings::Set($index, $value);\n\t\t\t}\n\t\t\t// save to DB\n\t\t\tSettings::Flush();\n\t\t\t// all good\n\t\t\treturn true;\n\t\t}\n\t\tthrow new Exception(\"Invalid JSON data: \" . json_last_error_msg());\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Froxlor\\Database\\Database;\nuse PDO;\nuse PDOStatement;\n\n/**\n * Class Settings\n *\n * Interaction with settings from the db\n */\nclass Settings\n{\n\t/**\n\t * settings data\n\t *\n\t * @var array\n\t */\n\tprivate static $data = null;\n\n\t/**\n\t * local config overrides\n\t *\n\t * @var array\n\t */\n\tprivate static $conf = null;\n\n\t/**\n\t * changed and unsaved settings data\n\t *\n\t * @var array\n\t */\n\tprivate static $updatedata = null;\n\n\t/**\n\t * prepared statement for updating the\n\t * settings table\n\t *\n\t * @var PDOStatement\n\t */\n\tprivate static $updstmt = null;\n\n\t/**\n\t * tests if a setting-value that i s a comma separated list contains an entry\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t * @param string $entry\n\t *            the entry that is expected to be in the list\n\t *\n\t * @return boolean true, if the list contains $entry\n\t */\n\tpublic static function IsInList($setting = null, $entry = null)\n\t{\n\t\tself::init();\n\t\t$svalue = self::Get($setting);\n\t\tif ($svalue == null) {\n\t\t\treturn false;\n\t\t}\n\t\t$slist = explode(\",\", $svalue);\n\t\treturn in_array($entry, $slist);\n\t}\n\n\t/**\n\t * private constructor, reads in all settings\n\t */\n\tprivate static function init()\n\t{\n\t\tif (empty(self::$data)) {\n\t\t\tself::readSettings();\n\t\t\tself::readConfig();\n\t\t\tself::$updatedata = [];\n\n\t\t\t// prepare statement\n\t\t\tself::$updstmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_SETTINGS . \"` SET `value` = :value\n\t\t\t\tWHERE `settinggroup` = :group AND `varname` = :varname\n\t\t\t\");\n\t\t}\n\t}\n\n\t/**\n\t * Read in all settings from the database\n\t * and set the internal $_data array\n\t */\n\tprivate static function readSettings()\n\t{\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT `settingid`, `settinggroup`, `varname`, `value`\n\t\t\tFROM `\" . TABLE_PANEL_SETTINGS . \"`\n\t\t\");\n\t\tself::$data = [];\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tself::$data[$row['settinggroup']][$row['varname']] = $row['value'];\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Read in all config overrides from\n\t * config/config.inc.php\n\t */\n\tprivate static function readConfig()\n\t{\n\t\t// set defaults\n\t\tself::$conf = [\n\t\t\t'enable_webupdate' => false\n\t\t];\n\n\t\t$configfile = Froxlor::getInstallDir() . '/lib/config.inc.php';\n\t\tif (@file_exists($configfile) && is_readable($configfile)) {\n\t\t\tself::$conf = include $configfile;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * return a setting-value by its group and varname\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t *\n\t * @return mixed\n\t */\n\tpublic static function Get($setting = null)\n\t{\n\t\tself::init();\n\t\t$sstr = explode(\".\", $setting);\n\t\t// no separator - do'h\n\t\tif (!isset($sstr[1])) {\n\t\t\treturn null;\n\t\t}\n\t\t$result = null;\n\t\tif (isset(self::$data[$sstr[0]][$sstr[1]])) {\n\t\t\t$result = self::$data[$sstr[0]][$sstr[1]];\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * update a setting / set a new value\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t * @param string $value\n\t * @param boolean $instant_save\n\t *\n\t * @return bool\n\t */\n\tpublic static function Set($setting = null, $value = null, $instant_save = true)\n\t{\n\t\tself::init();\n\t\t// check whether the setting exists\n\t\tif (self::Get($setting) !== null) {\n\t\t\t// set new value in array\n\t\t\t$sstr = explode(\".\", $setting);\n\t\t\tif (!isset($sstr[1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tself::$data[$sstr[0]][$sstr[1]] = $value;\n\t\t\t// should we store to db instantly?\n\t\t\tif ($instant_save) {\n\t\t\t\tself::storeSetting($sstr[0], $sstr[1], $value);\n\t\t\t} else {\n\t\t\t\t// set temporary data for usage\n\t\t\t\tif (!isset(self::$data[$sstr[0]]) || !is_array(self::$data[$sstr[0]])) {\n\t\t\t\t\tself::$data[$sstr[0]] = [];\n\t\t\t\t}\n\t\t\t\tself::$data[$sstr[0]][$sstr[1]] = $value;\n\t\t\t\t// set update-data when invoking Flush()\n\t\t\t\tif (!isset(self::$updatedata[$sstr[0]]) || !is_array(self::$updatedata[$sstr[0]])) {\n\t\t\t\t\tself::$updatedata[$sstr[0]] = [];\n\t\t\t\t}\n\t\t\t\tself::$updatedata[$sstr[0]][$sstr[1]] = $value;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * update a value in the database\n\t *\n\t * @param string $group\n\t * @param string $varname\n\t * @param string $value\n\t */\n\tprivate static function storeSetting($group = null, $varname = null, $value = null)\n\t{\n\t\t$upd_data = [\n\t\t\t'group' => $group,\n\t\t\t'varname' => $varname,\n\t\t\t'value' => $value\n\t\t];\n\t\tDatabase::pexecute(self::$updstmt, $upd_data);\n\t}\n\n\t/**\n\t * add a new setting to the database (mainly used in updater)\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t * @param string $value\n\t *\n\t * @return boolean\n\t */\n\tpublic static function AddNew($setting = null, $value = null)\n\t{\n\t\tself::init();\n\t\t// first check if it doesn't exist\n\t\tif (self::Get($setting) === null) {\n\t\t\t// validate parameter\n\t\t\t$sstr = explode(\".\", $setting);\n\t\t\tif (!isset($sstr[1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// prepare statement\n\t\t\t$ins_stmt = Database::prepare(\"\n\t\t\t\t\tINSERT INTO `\" . TABLE_PANEL_SETTINGS . \"` SET\n\t\t\t\t\t`settinggroup` = :group,\n\t\t\t\t\t`varname` = :varname,\n\t\t\t\t\t`value` = :value\n\t\t\t\t\t\");\n\t\t\t$ins_data = [\n\t\t\t\t'group' => $sstr[0],\n\t\t\t\t'varname' => $sstr[1],\n\t\t\t\t'value' => $value\n\t\t\t];\n\t\t\tDatabase::pexecute($ins_stmt, $ins_data);\n\t\t\t// also set new value to internal array and make it available\n\t\t\tself::$data[$sstr[0]][$sstr[1]] = $value;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Store all un-saved changes to the database and\n\t * re-read in all settings\n\t */\n\tpublic static function Flush()\n\t{\n\t\tself::init();\n\t\tif (is_array(self::$updatedata) && count(self::$updatedata) > 0) {\n\t\t\t// save all un-saved changes to the settings\n\t\t\tforeach (self::$updatedata as $group => $vargroup) {\n\t\t\t\tforeach ($vargroup as $varname => $value) {\n\t\t\t\t\tself::storeSetting($group, $varname, $value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// now empty the array\n\t\t\tself::$updatedata = [];\n\t\t\t// re-read in all settings\n\t\t\treturn self::readSettings();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * forget all un-saved changes to settings\n\t */\n\tpublic static function Stash()\n\t{\n\t\tself::init();\n\t\t// empty update array\n\t\tself::$updatedata = [];\n\t\t// re-read in all settings\n\t\treturn self::readSettings();\n\t}\n\n\tpublic static function loadSettingsInto(&$settings_data)\n\t{\n\t\tif (is_array($settings_data) && isset($settings_data['groups']) && is_array($settings_data['groups'])) {\n\t\t\t// prepare for use in for-loop\n\t\t\t$row_stmt = Database::prepare(\"\n\t\t\t\tSELECT `settinggroup`, `varname`, `value`\n\t\t\t\tFROM `\" . TABLE_PANEL_SETTINGS . \"`\n\t\t\t\tWHERE `settinggroup` = :group AND `varname` = :varname\n\t\t\t\");\n\n\t\t\tforeach ($settings_data['groups'] as $settings_part => $settings_part_details) {\n\t\t\t\tif (is_array($settings_part_details) && isset($settings_part_details['fields']) && is_array($settings_part_details['fields'])) {\n\t\t\t\t\tforeach ($settings_part_details['fields'] as $field_name => $field_details) {\n\t\t\t\t\t\tif (isset($field_details['settinggroup']) && isset($field_details['varname']) && isset($field_details['default'])) {\n\t\t\t\t\t\t\t// execute prepared statement\n\t\t\t\t\t\t\t$row = Database::pexecute_first($row_stmt, [\n\t\t\t\t\t\t\t\t'group' => $field_details['settinggroup'],\n\t\t\t\t\t\t\t\t'varname' => $field_details['varname']\n\t\t\t\t\t\t\t]);\n\n\t\t\t\t\t\t\tif (!empty($row)) {\n\t\t\t\t\t\t\t\t$varvalue = $row['value'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$varvalue = $field_details['default'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$varvalue = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$settings_data['groups'][$settings_part]['fields'][$field_name]['value'] = $varvalue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * get value from config by identifier\n\t */\n\tpublic static function Config(string $config)\n\t{\n\t\tself::init();\n\t\t$sstr = explode(\".\", $config);\n\t\t$result = self::$conf;\n\t\tforeach ($sstr as $key) {\n\t\t\t$result = $result[$key] ?? null;\n\t\t\tif (empty($result)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\UI;\n\nuse Froxlor\\Settings;\nuse Froxlor\\Validate\\Check;\n\nclass Form\n{\n\tpublic static function buildForm(array $form, string $part = ''): array\n\t{\n\t\t$fields = [];\n\n\t\tif (\\Froxlor\\Validate\\Form::validateFormDefinition($form)) {\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\t// check for advanced mode sections\n\t\t\t\tif (isset($groupdetails['advanced_mode']) && $groupdetails['advanced_mode'] && (int)Settings::Get('panel.settings_mode') == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// show overview\n\t\t\t\tif ($part == '' || $part == 'all') {\n\t\t\t\t\tif (isset($groupdetails['title']) && $groupdetails['title'] != '') {\n\t\t\t\t\t\t$fields[] = self::getFormOverviewGroupOutput($groupname, $groupdetails);\n\t\t\t\t\t}\n\t\t\t\t} elseif ($part != '' && $groupname == $part) {\n\t\t\t\t\t// only show one section\n\t\t\t\t\t/**\n\t\t\t\t\t * this part checks for the 'websrv_avail' entry in the settings-array\n\t\t\t\t\t * if found, we check if the current webserver is in the array.\n\t\t\t\t\t * If this\n\t\t\t\t\t * is not the case, we change the setting type to \"hidden\", #502\n\t\t\t\t\t */\n\t\t\t\t\t$do_show = true;\n\t\t\t\t\tif (isset($groupdetails['websrv_avail']) && is_array($groupdetails['websrv_avail'])) {\n\t\t\t\t\t\t$websrv = Settings::Get('system.webserver');\n\t\t\t\t\t\tif (!in_array($websrv, $groupdetails['websrv_avail'])) {\n\t\t\t\t\t\t\t$do_show = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// visible = Settings::Get('phpfpm.enabled') for example would result in false if not enabled\n\t\t\t\t\t// and therefore not shown as intended. Only check if do_show is still true as it might\n\t\t\t\t\t// be false due to websrv_avail\n\t\t\t\t\tif (isset($groupdetails['visible']) && $do_show) {\n\t\t\t\t\t\t$do_show = $groupdetails['visible'];\n\t\t\t\t\t}\n\n\t\t\t\t\t$fields['_group'] = [\n\t\t\t\t\t\t'title' => $groupdetails['title'] ?? 'unknown group',\n\t\t\t\t\t\t'do_show' => $do_show\n\t\t\t\t\t];\n\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Collect form field output\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\t// check for advanced mode sections\n\t\t\t\t\t\t\tif (isset($fielddetails['advanced_mode']) && $fielddetails['advanced_mode'] && (int)Settings::Get('panel.settings_mode') == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$fields[$fieldname] = self::getFormFieldOutput($fieldname, $fielddetails);\n\t\t\t\t\t\t\t$fields[$fieldname] = array_merge($fields[$fieldname], self::prefetchFormFieldData($fieldname, $fielddetails));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $fields;\n\t}\n\n\tpublic static function getFormOverviewGroupOutput($groupname, $groupdetails)\n\t{\n\t\t$activated = true;\n\t\tif (isset($groupdetails['fields'])) {\n\t\t\tforeach ($groupdetails['fields'] as $fielddetails) {\n\t\t\t\tif (isset($fielddetails['overview_option']) && $fielddetails['overview_option'] == true) {\n\t\t\t\t\tif ($fielddetails['type'] != 'checkbox') {\n\t\t\t\t\t\t// throw exception here as this is most likely an internal issue\n\t\t\t\t\t\t// if we messed up the arrays\n\t\t\t\t\t\tResponse::standardError('overviewsettingoptionisnotavalidfield', '', true);\n\t\t\t\t\t}\n\t\t\t\t\t$activated = (int)Settings::Get($fielddetails['settinggroup'] . '.' . $fielddetails['varname']);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$item = [\n\t\t\t'title' => $groupdetails['title'],\n\t\t\t'icon' => $groupdetails['icon'] ?? 'fa-solid fa-circle-question',\n\t\t\t'part' => $groupname,\n\t\t\t'activated' => $activated\n\t\t];\n\n\t\t/**\n\t\t * this part checks for the 'websrv_avail' entry in the settings\n\t\t * if found, we check if the current webserver is in the array.\n\t\t * If this is not the case, we change the setting type to \"hidden\", #502\n\t\t */\n\t\tif (isset($groupdetails['websrv_avail']) && is_array($groupdetails['websrv_avail'])) {\n\t\t\t$websrv = Settings::Get('system.webserver');\n\t\t\tif (!in_array($websrv, $groupdetails['websrv_avail'])) {\n\t\t\t\t$item['info'] = lng('serversettings.option_unavailable_websrv', [implode(\", \", $groupdetails['websrv_avail'])]);\n\t\t\t\t$item['visible'] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn $item;\n\t}\n\n\tpublic static function getFormFieldOutput($fieldname, $fielddata): array\n\t{\n\t\t$returnvalue = [];\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] != '') {\n\t\t\tif (!isset($fielddata['value'])) {\n\t\t\t\tif (isset($fielddata['default'])) {\n\t\t\t\t\t$fielddata['value'] = $fielddata['default'];\n\t\t\t\t} else {\n\t\t\t\t\t$fielddata['value'] = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set value according to type\n\t\t\tswitch ($fielddata['type']) {\n\t\t\t\tcase 'select':\n\t\t\t\t\t$fielddata['selected'] = $fielddata['value'];\n\t\t\t\t\tunset($fielddata['value']);\n\t\t\t\t\tif (isset($fielddata['select_mode']) && $fielddata['select_mode'] == 'multiple') {\n\t\t\t\t\t\t$fielddata['selected'] = array_flip(explode(\",\", $fielddata['selected']));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'checkbox':\n\t\t\t\t\t$fielddata['checked'] = (bool)$fielddata['value'];\n\t\t\t\t\t$fielddata['value'] = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * this part checks for the 'websrv_avail' entry in the settings-array\n\t\t\t * if found, we check if the current webserver is in the array.\n\t\t\t * If this\n\t\t\t * is not the case, we change the setting type to \"hidden\", #502\n\t\t\t */\n\t\t\t$do_show = true;\n\t\t\tif (isset($fielddata['websrv_avail']) && is_array($fielddata['websrv_avail'])) {\n\t\t\t\t$websrv = Settings::Get('system.webserver');\n\t\t\t\tif (!in_array($websrv, $fielddata['websrv_avail'])) {\n\t\t\t\t\t$do_show = false;\n\t\t\t\t\t$fielddata['note'] = lng('serversettings.option_unavailable_websrv', [implode(\", \", $fielddata['websrv_avail'])]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// visible = Settings::Get('phpfpm.enabled') for example would result in false if not enabled\n\t\t\t// and therefore not shown as intended. Only check if do_show is still true as it might\n\t\t\t// be false due to websrv_avail\n\t\t\tif (isset($fielddata['visible']) && $do_show) {\n\t\t\t\t$do_show = $fielddata['visible'];\n\t\t\t\tif (!$do_show) {\n\t\t\t\t\t$fielddata['note'] = lng('serversettings.option_unavailable');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$do_show) {\n\t\t\t\t$fielddata['visible'] = false;\n\t\t\t}\n\n\t\t\t$returnvalue = $fielddata;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function prefetchFormFieldData($fieldname, $fielddata)\n\t{\n\t\t$returnvalue = [];\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] == 'select') {\n\t\t\tif ((!isset($fielddata['select_var']) || !is_array($fielddata['select_var']) || empty($fielddata['select_var'])) && (isset($fielddata['option_options_method']))) {\n\t\t\t\t$returnvalue['select_var'] = call_user_func($fielddata['option_options_method']);\n\t\t\t}\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function processForm(&$form, &$input, $url_params = [], $part = null, $settings_all = [], $settings_part = null, $only_enabledisable = false)\n\t{\n\t\tif (\\Froxlor\\Validate\\Form::validateFormDefinition($form)) {\n\t\t\t$submitted_fields = [];\n\t\t\t$changed_fields = [];\n\t\t\t$saved_fields = [];\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Prefetch form fields\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option']))) {\n\t\t\t\t\t\t\t\t$groupdetails['fields'][$fieldname] = self::arrayMergePrefix($fielddetails, $fielddetails['type'], self::prefetchFormFieldData($fieldname, $fielddetails));\n\t\t\t\t\t\t\t\t$form['groups'][$groupname]['fields'][$fieldname] = $groupdetails['fields'][$fieldname];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Validate fields\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (((isset($fielddetails['visible']) && $fielddetails['visible']) || !isset($fielddetails['visible'])) && (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option'])))) {\n\t\t\t\t\t\t\t\t$newfieldvalue = self::getFormFieldData($fieldname, $fielddetails, $input);\n\t\t\t\t\t\t\t\tif ($newfieldvalue != $fielddetails['value']) {\n\t\t\t\t\t\t\t\t\tif (($error = \\Froxlor\\Validate\\Form::validateFormField($fieldname, $fielddetails, $newfieldvalue)) != true) {\n\t\t\t\t\t\t\t\t\t\tResponse::standardError($error, $fieldname);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t$changed_fields[$fieldname] = $newfieldvalue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t$submitted_fields[$fieldname] = $newfieldvalue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Check fields for plausibility\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option']))) {\n\t\t\t\t\t\t\t\tif (($plausibility_check = self::checkPlausibilityFormField($fieldname, $fielddetails, $submitted_fields[$fieldname], $submitted_fields)) !== false) {\n\t\t\t\t\t\t\t\t\tif (is_array($plausibility_check) && isset($plausibility_check[0])) {\n\t\t\t\t\t\t\t\t\t\tif ($plausibility_check[0] == Check::FORMFIELDS_PLAUSIBILITY_CHECK_OK) {\n\t\t\t\t\t\t\t\t\t\t\t// Nothing to do here, everything's okay\n\t\t\t\t\t\t\t\t\t\t} elseif ($plausibility_check[0] == Check::FORMFIELDS_PLAUSIBILITY_CHECK_ERROR) {\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[0]);\n\t\t\t\t\t\t\t\t\t\t\t$error = $plausibility_check[1];\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[1]);\n\t\t\t\t\t\t\t\t\t\t\t$targetname = implode(' ', $plausibility_check);\n\t\t\t\t\t\t\t\t\t\t\tResponse::standardError($error, $targetname);\n\t\t\t\t\t\t\t\t\t\t} elseif ($plausibility_check[0] == Check::FORMFIELDS_PLAUSIBILITY_CHECK_QUESTION) {\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[0]);\n\t\t\t\t\t\t\t\t\t\t\t$question = $plausibility_check[1];\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[1]);\n\t\t\t\t\t\t\t\t\t\t\t$targetname = implode(' ', $plausibility_check);\n\t\t\t\t\t\t\t\t\t\t\tif (!isset($input[$question])) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (is_array($url_params) && isset($url_params['filename'])) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$filename = $url_params['filename'];\n\t\t\t\t\t\t\t\t\t\t\t\t\tunset($url_params['filename']);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$filename = '';\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tHTML::askYesNo($question, $filename, array_merge($url_params, $submitted_fields, [\n\t\t\t\t\t\t\t\t\t\t\t\t\t$question => $question\n\t\t\t\t\t\t\t\t\t\t\t\t]), $targetname);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tResponse::standardError('plausibilitychecknotunderstood');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Save fields\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option']))) {\n\t\t\t\t\t\t\t\tif (isset($changed_fields[$fieldname])) {\n\t\t\t\t\t\t\t\t\tif (($saved_field = self::saveFormField($fieldname, $fielddetails, self::manipulateFormFieldData($fieldname, $fielddetails, $changed_fields[$fieldname]))) !== false) {\n\t\t\t\t\t\t\t\t\t\t$saved_fields = array_merge($saved_fields, $saved_field);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tResponse::standardError('errorwhensaving', $fieldname);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save form\n\t\t\treturn self::saveForm($form, $saved_fields);\n\t\t}\n\t}\n\n\tprivate static function arrayMergePrefix($array1, $key_prefix, $array2)\n\t{\n\t\tif (is_array($array1) && is_array($array2)) {\n\t\t\tif ($key_prefix != '') {\n\t\t\t\tforeach ($array2 as $key => $value) {\n\t\t\t\t\t$array1[$key_prefix . '_' . $key] = $value;\n\t\t\t\t\tunset($array2[$key]);\n\t\t\t\t}\n\t\t\t\tunset($array2);\n\t\t\t\treturn $array1;\n\t\t\t} else {\n\t\t\t\treturn array_merge($array1, $array2);\n\t\t\t}\n\t\t} else {\n\t\t\treturn $array1;\n\t\t}\n\t}\n\n\tpublic static function getFormFieldData($fieldname, $fielddata, &$input)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] != '' && method_exists('\\\\Froxlor\\\\UI\\\\Data', 'getFormFieldData' . ucfirst($fielddata['type']))) {\n\t\t\t$newfieldvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\UI\\\\Data',\n\t\t\t\t'getFormFieldData' . ucfirst($fielddata['type'])\n\t\t\t], $fieldname, $fielddata, $input);\n\t\t} else {\n\t\t\tif (isset($input[$fieldname])) {\n\t\t\t\t$newfieldvalue = $input[$fieldname];\n\t\t\t} elseif (isset($fielddata['default'])) {\n\t\t\t\t$newfieldvalue = $fielddata['default'];\n\t\t\t} else {\n\t\t\t\t$newfieldvalue = false;\n\t\t\t}\n\t\t}\n\n\t\treturn trim($newfieldvalue);\n\t}\n\n\tpublic static function checkPlausibilityFormField($fieldname, $fielddata, $newfieldvalue, $allnewfieldvalues)\n\t{\n\t\t$returnvalue = '';\n\t\tif (is_array($fielddata) && isset($fielddata['plausibility_check_method']) && $fielddata['plausibility_check_method'] != '' && method_exists($fielddata['plausibility_check_method'][0], $fielddata['plausibility_check_method'][1])) {\n\t\t\t$returnvalue = call_user_func($fielddata['plausibility_check_method'], $fieldname, $fielddata, $newfieldvalue, $allnewfieldvalues);\n\t\t} else {\n\t\t\t$returnvalue = false;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function saveFormField($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = '';\n\t\tif (is_array($fielddata) && isset($fielddata['save_method']) && $fielddata['save_method'] != '') {\n\t\t\t$returnvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\Settings\\\\Store',\n\t\t\t\t$fielddata['save_method']\n\t\t\t], $fieldname, $fielddata, $newfieldvalue);\n\t\t} elseif (is_array($fielddata) && !isset($fielddata['save_method'])) {\n\t\t\t$returnvalue = [];\n\t\t} else {\n\t\t\t$returnvalue = false;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function manipulateFormFieldData($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] != '' && method_exists('\\\\Froxlor\\\\UI\\\\Data', 'manipulateFormFieldData' . ucfirst($fielddata['type']))) {\n\t\t\t$newfieldvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\UI\\\\Data',\n\t\t\t\t'manipulateFormFieldData' . ucfirst($fielddata['type'])\n\t\t\t], $fieldname, $fielddata, $newfieldvalue);\n\t\t}\n\n\t\treturn $newfieldvalue;\n\t}\n\n\tpublic static function saveForm($fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = '';\n\t\tif (is_array($fielddata) && isset($fielddata['save_method']) && $fielddata['save_method'] != '') {\n\t\t\t$returnvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\Settings\\\\Store',\n\t\t\t\t$fielddata['save_method']\n\t\t\t], $fielddata, $newfieldvalue);\n\t\t} elseif (is_array($fielddata) && !isset($fielddata['save_method'])) {\n\t\t\t$returnvalue = true;\n\t\t} else {\n\t\t\t$returnvalue = false;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Froxlor\\Database\\Database;\n\nfinal class Froxlor\n{\n\n\t// Main version variable\n\tconst VERSION = '2.0.10';\n\n\t// Database version (YYYYMMDDC where C is a daily counter)\n\tconst DBVERSION = '202302030';\n\n\t// Distribution branding-tag (used for Debian etc.)\n\tconst BRANDING = '';\n\n\t/**\n\t * return path to where froxlor is installed, e.g.\n\t * /var/www/froxlor/\n\t *\n\t * @return string\n\t */\n\tpublic static function getInstallDir(): string\n\t{\n\t\treturn dirname(__DIR__, 2) . '/';\n\t}\n\n\t/**\n\t * return basic version\n\t *\n\t * @return string\n\t */\n\tpublic static function getVersion(): string\n\t{\n\t\treturn self::VERSION;\n\t}\n\n\t/**\n\t * return version + branding and database-version\n\t *\n\t * @return string\n\t */\n\tpublic static function getVersionString(): string\n\t{\n\t\treturn self::getFullVersion() . ' (' . self::DBVERSION . ')';\n\t}\n\n\t/**\n\t * return version + branding\n\t *\n\t * @return string\n\t */\n\tpublic static function getFullVersion(): string\n\t{\n\t\treturn self::VERSION . self::BRANDING;\n\t}\n\n\t/**\n\t * Function hasUpdates\n\t *\n\t * checks if a given version is not equal the current one\n\t *\n\t * @param string $to_check version to check, if empty current version is used\n\t *\n\t * @return bool true if version to check does not match, else false\n\t */\n\tpublic static function hasUpdates(string $to_check = ''): bool\n\t{\n\t\tif (empty($to_check)) {\n\t\t\t$to_check = self::VERSION;\n\t\t}\n\t\tif (Settings::Get('panel.version') == null || Settings::Get('panel.version') != $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function hasDbUpdates\n\t *\n\t * checks if a given database-version is not equal the current one\n\t *\n\t * @param string $to_check version to check, if empty current dbversion is used\n\t *\n\t * @return bool true if version to check does not match, else false\n\t */\n\tpublic static function hasDbUpdates(string $to_check = ''): bool\n\t{\n\t\tif (empty($to_check)) {\n\t\t\t$to_check = self::DBVERSION;\n\t\t}\n\t\tif (Settings::Get('panel.db_version') == null || Settings::Get('panel.db_version') != $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function isDatabaseVersion\n\t *\n\t * checks if a given database-version is the current one\n\t *\n\t * @param string $to_check version to check\n\t *\n\t * @return bool true if version to check matches, else false\n\t */\n\tpublic static function isDatabaseVersion(string $to_check): bool\n\t{\n\t\tif (Settings::Get('panel.frontend') == 'froxlor' && Settings::Get('panel.db_version') == $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function updateToDbVersion\n\t *\n\t * updates the panel.version field\n\t * to the given value (no checks here!)\n\t *\n\t * @param string $new_version new-version\n\t *\n\t * @return bool true on success, else false\n\t * @throws \\Exception\n\t */\n\tpublic static function updateToDbVersion(string $new_version): bool\n\t{\n\t\tif ($new_version != '') {\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_SETTINGS . \"` SET `value` = :newversion\n\t\t\t\tWHERE `settinggroup` = 'panel' AND `varname` = 'db_version'\");\n\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t'newversion' => $new_version\n\t\t\t]);\n\t\t\tSettings::Set('panel.db_version', $new_version);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function updateToVersion\n\t *\n\t * updates the panel.version field\n\t * to the given value (no checks here!)\n\t *\n\t * @param string $new_version new-version\n\t *\n\t * @return bool true on success, else false\n\t * @throws \\Exception\n\t */\n\tpublic static function updateToVersion(string $new_version): bool\n\t{\n\t\tif ($new_version != '') {\n\t\t\t$upd_stmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_SETTINGS . \"` SET `value` = :newversion\n\t\t\t\tWHERE `settinggroup` = 'panel' AND `varname` = 'version'\");\n\t\t\tDatabase::pexecute($upd_stmt, [\n\t\t\t\t'newversion' => $new_version\n\t\t\t]);\n\t\t\tSettings::Set('panel.version', $new_version);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function isFroxlor\n\t *\n\t * checks if the panel is froxlor\n\t *\n\t * @return bool true if panel is froxlor, else false\n\t */\n\tpublic static function isFroxlor(): bool\n\t{\n\t\tif (Settings::Get('panel.frontend') !== null && Settings::Get('panel.frontend') == 'froxlor') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Function isFroxlorVersion\n\t *\n\t * checks if a given version is the\n\t * current one (and panel is froxlor)\n\t *\n\t * @param string $to_check version to check\n\t *\n\t * @return bool true if version to check matches, else false\n\t */\n\tpublic static function isFroxlorVersion(string $to_check): bool\n\t{\n\t\tif (Settings::Get('panel.frontend') == 'froxlor' && Settings::Get('panel.version') == $to_check) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * generate safe unique session id\n\t *\n\t * @param int $length\n\t * @return string\n\t * @throws \\Exception\n\t */\n\tpublic static function genSessionId(int $length = 16): string\n\t{\n\t\tif ($length <= 8) {\n\t\t\t$length = 16;\n\t\t}\n\t\tif (function_exists('random_bytes')) {\n\t\t\treturn bin2hex(random_bytes($length));\n\t\t}\n\t\tif (function_exists('mcrypt_create_iv') && defined('MCRYPT_DEV_URANDOM')) {\n\t\t\treturn bin2hex(mcrypt_create_iv($length, MCRYPT_DEV_URANDOM));\n\t\t}\n\t\tif (function_exists('openssl_random_pseudo_bytes')) {\n\t\t\treturn bin2hex(openssl_random_pseudo_bytes($length));\n\t\t}\n\t\t// if everything else fails, use unsafe fallback\n\t\treturn md5(uniqid(microtime(), 1));\n\t}\n\n\t/**\n\t * compare of froxlor versions\n\t *\n\t * @param string $a\n\t * @param string $b\n\t *\n\t * @return int 0 if equal, 1 if a>b and -1 if b>a\n\t */\n\tpublic static function versionCompare2(string $a, string $b): int\n\t{\n\t\t// split version into pieces and remove trailing .0\n\t\t$a = explode(\".\", $a);\n\t\t$b = explode(\".\", $b);\n\n\t\tself::parseVersionArray($a);\n\t\tself::parseVersionArray($b);\n\n\t\twhile (count($a) != count($b)) {\n\t\t\tif (count($a) < count($b)) {\n\t\t\t\t$a[] = '0';\n\t\t\t} elseif (count($b) < count($a)) {\n\t\t\t\t$b[] = '0';\n\t\t\t}\n\t\t}\n\n\t\tforeach ($a as $depth => $aVal) {\n\t\t\t// iterate over each piece of A\n\t\t\tif (isset($b[$depth])) {\n\t\t\t\t// if B matches A to this depth, compare the values\n\t\t\t\tif ($aVal > $b[$depth]) {\n\t\t\t\t\treturn 1; // A > B\n\t\t\t\t} elseif ($aVal < $b[$depth]) {\n\t\t\t\t\treturn -1; // B > A\n\t\t\t\t}\n\t\t\t\t// an equal result is inconclusive at this point\n\t\t\t} else {\n\t\t\t\t// if B does not match A to this depth, then A comes after B in sort order\n\t\t\t\treturn 1; // so A > B\n\t\t\t}\n\t\t}\n\t\t// at this point, we know that to the depth that A and B extend to, they are equivalent.\n\t\t// either the loop ended because A is shorter than B, or both are equal.\n\t\treturn (count($a) < count($b)) ? -1 : 0;\n\t}\n\n\t/**\n\t * @param array|null $arr\n\t * @return void\n\t */\n\tprivate static function parseVersionArray(array &$arr = null)\n\t{\n\t\t// -dev or -beta or -rc ?\n\t\tif (stripos($arr[count($arr) - 1], '-') !== false) {\n\t\t\t$x = explode(\"-\", $arr[count($arr) - 1]);\n\t\t\t$arr[count($arr) - 1] = $x[0];\n\t\t\tif (stripos($x[1], 'rc') !== false) {\n\t\t\t\t$arr[] = '-1';\n\t\t\t\t$arr[] = '2'; // dev < beta < rc\n\t\t\t\t// number of rc\n\t\t\t\t$arr[] = substr($x[1], 2);\n\t\t\t} else {\n\t\t\t\tif (stripos($x[1], 'beta') !== false) {\n\t\t\t\t\t$arr[] = '-1';\n\t\t\t\t\t$arr[] = '1'; // dev < beta < rc\n\t\t\t\t\t// number of beta\n\t\t\t\t\t$arr[] = substr($x[1], 3);\n\t\t\t\t} else {\n\t\t\t\t\tif (stripos($x[1], 'dev') !== false) {\n\t\t\t\t\t\t$arr[] = '-1';\n\t\t\t\t\t\t$arr[] = '0'; // dev < beta < rc\n\t\t\t\t\t\t// number of dev\n\t\t\t\t\t\t$arr[] = substr($x[1], 3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Exception;\nuse Froxlor\\Database\\Database;\nuse Froxlor\\UI\\Form;\nuse PDO;\n\n/**\n * Class SImExporter\n *\n * Import/Export settings to JSON\n */\nclass SImExporter\n{\n\t/**\n\t * settings which are not being exported\n\t *\n\t * @var array\n\t */\n\tprivate static $no_export = [\n\t\t'panel.adminmail',\n\t\t'admin.show_news_feed',\n\t\t'system.lastaccountnumber',\n\t\t'system.lastguid',\n\t\t'system.ipaddress',\n\t\t'system.last_traffic_run',\n\t\t'system.hostname',\n\t\t'system.mysql_access_host',\n\t\t'system.lastcronrun',\n\t\t'system.defaultip',\n\t\t'system.defaultsslip',\n\t\t'system.last_tasks_run',\n\t\t'system.last_archive_run',\n\t\t'system.leprivatekey',\n\t\t'system.lepublickey',\n\t\t'system.updatecheck_data',\n\t];\n\n\tpublic static function export()\n\t{\n\t\t$settings_definitions = [];\n\t\tforeach (PhpHelper::loadConfigArrayDir('./actions/admin/settings/')['groups'] as $group) {\n\t\t\tforeach ($group['fields'] as $field) {\n\t\t\t\t$settings_definitions[$field['settinggroup']][$field['varname']] = $field;\n\t\t\t}\n\t\t}\n\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT * FROM `\" . TABLE_PANEL_SETTINGS . \"` ORDER BY `settingid` ASC\n\t\t\");\n\t\t$_data = [];\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\t$index = $row['settinggroup'] . \".\" . $row['varname'];\n\t\t\tif (!in_array($index, self::$no_export)) {\n\t\t\t\t$_data[$index] = $row['value'];\n\t\t\t}\n\n\t\t\tif (array_key_exists($row['settinggroup'], $settings_definitions) && array_key_exists($row['varname'],\n\t\t\t\t\t$settings_definitions[$row['settinggroup']])) {\n\t\t\t\t// Export image file\n\t\t\t\tif ($settings_definitions[$row['settinggroup']][$row['varname']]['type'] === \"image\") {\n\t\t\t\t\tif ($row['value'] === \"\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$_data[$index . '.image_data'] = base64_encode(file_get_contents(explode('?', $row['value'],\n\t\t\t\t\t\t2)[0]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// add checksum for validation\n\t\t$_data['_sha'] = sha1(var_export($_data, true));\n\t\t$_export = json_encode($_data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);\n\t\tif (!$_export) {\n\t\t\tthrow new Exception(\"Error exporting settings: \" . json_last_error_msg());\n\t\t}\n\n\t\treturn $_export;\n\t}\n\n\tpublic static function import($json_str = null)\n\t{\n\t\t// decode data\n\t\t$_data = json_decode($json_str, true);\n\t\tif ($_data) {\n\t\t\t// get validity check data\n\t\t\t$_sha = isset($_data['_sha']) ? $_data['_sha'] : false;\n\t\t\t$_version = isset($_data['panel.version']) ? $_data['panel.version'] : false;\n\t\t\t$_dbversion = isset($_data['panel.db_version']) ? $_data['panel.db_version'] : false;\n\t\t\t// check if we have everything we need\n\t\t\tif (!$_sha || !$_version || !$_dbversion) {\n\t\t\t\tthrow new Exception(\"Invalid froxlor settings data. Unable to import.\");\n\t\t\t}\n\t\t\t// validate import file\n\t\t\tunset($_data['_sha']);\n\t\t\t// compare\n\t\t\tif ($_sha != sha1(var_export($_data, true))) {\n\t\t\t\tthrow new Exception(\"SHA check of import data failed. Unable to import.\");\n\t\t\t}\n\t\t\t// do not import version info - but we need that to possibly update settings\n\t\t\t// when there were changes in the variable-name or similar\n\t\t\tunset($_data['panel.version']);\n\t\t\tunset($_data['panel.db_version']);\n\t\t\t// validate we got ssl enabled ips when ssl is enabled\n\t\t\t// otherwise deactivate it\n\t\t\tif ($_data['system.use_ssl'] == 1) {\n\t\t\t\t$result_ssl_ipsandports_stmt = Database::prepare(\"\n\t\t\t\t\tSELECT COUNT(*) as count_ssl_ip FROM `\" . TABLE_PANEL_IPSANDPORTS . \"` WHERE `ssl`='1'\n\t\t\t\t\");\n\t\t\t\t$result = Database::pexecute_first($result_ssl_ipsandports_stmt);\n\t\t\t\tif ($result['count_ssl_ip'] <= 0) {\n\t\t\t\t\t// no ssl-ip -> deactivate\n\t\t\t\t\t$_data['system.use_ssl'] = 0;\n\t\t\t\t\t// deactivate other ssl-related settings\n\t\t\t\t\t$_data['system.leenabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_enabled'] = 0;\n\t\t\t\t\t$_data['system.le_froxlor_redirect'] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$form_data = [];\n\t\t\t// read in all current settings\n\t\t\t$current_settings = Settings::getAll();\n\t\t\tforeach ($current_settings as $setting_group => $setting) {\n\t\t\t\tforeach ($setting as $varname => $value) {\n\t\t\t\t\t// set all group/varname:values which are not in the import file\n\t\t\t\t\tif (!isset($_data[$setting_group.'.'.$varname])) {\n\t\t\t\t\t\t$_data[$setting_group.'.'.$varname] = $value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// re-format the array-key for Form::processForm\n\t\t\tforeach ($_data as $key => $value) {\n\t\t\t\t$form_data[str_replace(\".\", \"_\", $key)] = $value;\n\t\t\t}\n\n\t\t\t// store new data\n\t\t\t$settings_data = PhpHelper::loadConfigArrayDir(Froxlor::getInstallDir() . '/actions/admin/settings/');\n\t\t\tSettings::loadSettingsInto($settings_data);\n\n\t\t\tif (Form::processForm($settings_data, $form_data, [], null, true)) {\n\t\t\t\t// save to DB\n\t\t\t\tSettings::Flush();\n\t\t\t\t// all good\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"Importing settings failed\");\n\t\t\t}\n\t\t}\n\t\tthrow new Exception(\"Invalid JSON data: \" . json_last_error_msg());\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor;\n\nuse Froxlor\\Database\\Database;\nuse PDO;\nuse PDOStatement;\n\n/**\n * Class Settings\n *\n * Interaction with settings from the db\n */\nclass Settings\n{\n\t/**\n\t * settings data\n\t *\n\t * @var array\n\t */\n\tprivate static $data = null;\n\n\t/**\n\t * local config overrides\n\t *\n\t * @var array\n\t */\n\tprivate static $conf = null;\n\n\t/**\n\t * changed and unsaved settings data\n\t *\n\t * @var array\n\t */\n\tprivate static $updatedata = null;\n\n\t/**\n\t * prepared statement for updating the\n\t * settings table\n\t *\n\t * @var PDOStatement\n\t */\n\tprivate static $updstmt = null;\n\n\t/**\n\t * tests if a setting-value that i s a comma separated list contains an entry\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t * @param string $entry\n\t *            the entry that is expected to be in the list\n\t *\n\t * @return boolean true, if the list contains $entry\n\t */\n\tpublic static function IsInList($setting = null, $entry = null)\n\t{\n\t\tself::init();\n\t\t$svalue = self::Get($setting);\n\t\tif ($svalue == null) {\n\t\t\treturn false;\n\t\t}\n\t\t$slist = explode(\",\", $svalue);\n\t\treturn in_array($entry, $slist);\n\t}\n\n\t/**\n\t * private constructor, reads in all settings\n\t */\n\tprivate static function init()\n\t{\n\t\tif (empty(self::$data)) {\n\t\t\tself::readSettings();\n\t\t\tself::readConfig();\n\t\t\tself::$updatedata = [];\n\n\t\t\t// prepare statement\n\t\t\tself::$updstmt = Database::prepare(\"\n\t\t\t\tUPDATE `\" . TABLE_PANEL_SETTINGS . \"` SET `value` = :value\n\t\t\t\tWHERE `settinggroup` = :group AND `varname` = :varname\n\t\t\t\");\n\t\t}\n\t}\n\n\t/**\n\t * Read in all settings from the database\n\t * and set the internal $_data array\n\t */\n\tprivate static function readSettings()\n\t{\n\t\t$result_stmt = Database::query(\"\n\t\t\tSELECT `settingid`, `settinggroup`, `varname`, `value`\n\t\t\tFROM `\" . TABLE_PANEL_SETTINGS . \"`\n\t\t\");\n\t\tself::$data = [];\n\t\twhile ($row = $result_stmt->fetch(PDO::FETCH_ASSOC)) {\n\t\t\tself::$data[$row['settinggroup']][$row['varname']] = $row['value'];\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Read in all config overrides from\n\t * config/config.inc.php\n\t */\n\tprivate static function readConfig()\n\t{\n\t\t// set defaults\n\t\tself::$conf = [\n\t\t\t'enable_webupdate' => false\n\t\t];\n\n\t\t$configfile = Froxlor::getInstallDir() . '/lib/config.inc.php';\n\t\tif (@file_exists($configfile) && is_readable($configfile)) {\n\t\t\tself::$conf = include $configfile;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * return a setting-value by its group and varname\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t *\n\t * @return mixed\n\t */\n\tpublic static function Get($setting = null)\n\t{\n\t\tself::init();\n\t\t$sstr = explode(\".\", $setting);\n\t\t// no separator - do'h\n\t\tif (!isset($sstr[1])) {\n\t\t\treturn null;\n\t\t}\n\t\t$result = null;\n\t\tif (isset(self::$data[$sstr[0]][$sstr[1]])) {\n\t\t\t$result = self::$data[$sstr[0]][$sstr[1]];\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * update a setting / set a new value\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t * @param string $value\n\t * @param boolean $instant_save\n\t *\n\t * @return bool\n\t */\n\tpublic static function Set($setting = null, $value = null, $instant_save = true)\n\t{\n\t\tself::init();\n\t\t// check whether the setting exists\n\t\tif (self::Get($setting) !== null) {\n\t\t\t// set new value in array\n\t\t\t$sstr = explode(\".\", $setting);\n\t\t\tif (!isset($sstr[1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tself::$data[$sstr[0]][$sstr[1]] = $value;\n\t\t\t// should we store to db instantly?\n\t\t\tif ($instant_save) {\n\t\t\t\tself::storeSetting($sstr[0], $sstr[1], $value);\n\t\t\t} else {\n\t\t\t\t// set temporary data for usage\n\t\t\t\tif (!isset(self::$data[$sstr[0]]) || !is_array(self::$data[$sstr[0]])) {\n\t\t\t\t\tself::$data[$sstr[0]] = [];\n\t\t\t\t}\n\t\t\t\tself::$data[$sstr[0]][$sstr[1]] = $value;\n\t\t\t\t// set update-data when invoking Flush()\n\t\t\t\tif (!isset(self::$updatedata[$sstr[0]]) || !is_array(self::$updatedata[$sstr[0]])) {\n\t\t\t\t\tself::$updatedata[$sstr[0]] = [];\n\t\t\t\t}\n\t\t\t\tself::$updatedata[$sstr[0]][$sstr[1]] = $value;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * update a value in the database\n\t *\n\t * @param string $group\n\t * @param string $varname\n\t * @param string $value\n\t */\n\tprivate static function storeSetting($group = null, $varname = null, $value = null)\n\t{\n\t\t$upd_data = [\n\t\t\t'group' => $group,\n\t\t\t'varname' => $varname,\n\t\t\t'value' => $value\n\t\t];\n\t\tDatabase::pexecute(self::$updstmt, $upd_data);\n\t}\n\n\t/**\n\t * add a new setting to the database (mainly used in updater)\n\t *\n\t * @param string $setting\n\t *            a group and a varname separated by a dot (group.varname)\n\t * @param string $value\n\t *\n\t * @return boolean\n\t */\n\tpublic static function AddNew($setting = null, $value = null)\n\t{\n\t\tself::init();\n\t\t// first check if it doesn't exist\n\t\tif (self::Get($setting) === null) {\n\t\t\t// validate parameter\n\t\t\t$sstr = explode(\".\", $setting);\n\t\t\tif (!isset($sstr[1])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// prepare statement\n\t\t\t$ins_stmt = Database::prepare(\"\n\t\t\t\t\tINSERT INTO `\" . TABLE_PANEL_SETTINGS . \"` SET\n\t\t\t\t\t`settinggroup` = :group,\n\t\t\t\t\t`varname` = :varname,\n\t\t\t\t\t`value` = :value\n\t\t\t\t\t\");\n\t\t\t$ins_data = [\n\t\t\t\t'group' => $sstr[0],\n\t\t\t\t'varname' => $sstr[1],\n\t\t\t\t'value' => $value\n\t\t\t];\n\t\t\tDatabase::pexecute($ins_stmt, $ins_data);\n\t\t\t// also set new value to internal array and make it available\n\t\t\tself::$data[$sstr[0]][$sstr[1]] = $value;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Store all un-saved changes to the database and\n\t * re-read in all settings\n\t */\n\tpublic static function Flush()\n\t{\n\t\tself::init();\n\t\tif (is_array(self::$updatedata) && count(self::$updatedata) > 0) {\n\t\t\t// save all un-saved changes to the settings\n\t\t\tforeach (self::$updatedata as $group => $vargroup) {\n\t\t\t\tforeach ($vargroup as $varname => $value) {\n\t\t\t\t\tself::storeSetting($group, $varname, $value);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// now empty the array\n\t\t\tself::$updatedata = [];\n\t\t\t// re-read in all settings\n\t\t\treturn self::readSettings();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * forget all un-saved changes to settings\n\t */\n\tpublic static function Stash()\n\t{\n\t\tself::init();\n\t\t// empty update array\n\t\tself::$updatedata = [];\n\t\t// re-read in all settings\n\t\treturn self::readSettings();\n\t}\n\n\tpublic static function loadSettingsInto(&$settings_data)\n\t{\n\t\tif (is_array($settings_data) && isset($settings_data['groups']) && is_array($settings_data['groups'])) {\n\t\t\t// prepare for use in for-loop\n\t\t\t$row_stmt = Database::prepare(\"\n\t\t\t\tSELECT `settinggroup`, `varname`, `value`\n\t\t\t\tFROM `\" . TABLE_PANEL_SETTINGS . \"`\n\t\t\t\tWHERE `settinggroup` = :group AND `varname` = :varname\n\t\t\t\");\n\n\t\t\tforeach ($settings_data['groups'] as $settings_part => $settings_part_details) {\n\t\t\t\tif (is_array($settings_part_details) && isset($settings_part_details['fields']) && is_array($settings_part_details['fields'])) {\n\t\t\t\t\tforeach ($settings_part_details['fields'] as $field_name => $field_details) {\n\t\t\t\t\t\tif (isset($field_details['settinggroup']) && isset($field_details['varname']) && isset($field_details['default'])) {\n\t\t\t\t\t\t\t// execute prepared statement\n\t\t\t\t\t\t\t$row = Database::pexecute_first($row_stmt, [\n\t\t\t\t\t\t\t\t'group' => $field_details['settinggroup'],\n\t\t\t\t\t\t\t\t'varname' => $field_details['varname']\n\t\t\t\t\t\t\t]);\n\n\t\t\t\t\t\t\tif (!empty($row)) {\n\t\t\t\t\t\t\t\t$varvalue = $row['value'];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t$varvalue = $field_details['default'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$varvalue = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$settings_data['groups'][$settings_part]['fields'][$field_name]['value'] = $varvalue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static function getAll() : array\n\t{\n\t\tself::init();\n\t\treturn self::$data;\n\t}\n\n\t/**\n\t * get value from config by identifier\n\t */\n\tpublic static function Config(string $config)\n\t{\n\t\tself::init();\n\t\t$sstr = explode(\".\", $config);\n\t\t$result = self::$conf;\n\t\tforeach ($sstr as $key) {\n\t\t\t$result = $result[$key] ?? null;\n\t\t\tif (empty($result)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn $result;\n\t}\n}\n", "<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, you can also view it online at\n * https://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  the authors\n * @author     Froxlor team <team@froxlor.org>\n * @license    https://files.froxlor.org/misc/COPYING.txt GPLv2\n */\n\nnamespace Froxlor\\UI;\n\nuse Froxlor\\Settings;\nuse Froxlor\\Validate\\Check;\n\nclass Form\n{\n\tpublic static function buildForm(array $form, string $part = ''): array\n\t{\n\t\t$fields = [];\n\n\t\tif (\\Froxlor\\Validate\\Form::validateFormDefinition($form)) {\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\t// check for advanced mode sections\n\t\t\t\tif (isset($groupdetails['advanced_mode']) && $groupdetails['advanced_mode'] && (int)Settings::Get('panel.settings_mode') == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// show overview\n\t\t\t\tif ($part == '' || $part == 'all') {\n\t\t\t\t\tif (isset($groupdetails['title']) && $groupdetails['title'] != '') {\n\t\t\t\t\t\t$fields[] = self::getFormOverviewGroupOutput($groupname, $groupdetails);\n\t\t\t\t\t}\n\t\t\t\t} elseif ($part != '' && $groupname == $part) {\n\t\t\t\t\t// only show one section\n\t\t\t\t\t/**\n\t\t\t\t\t * this part checks for the 'websrv_avail' entry in the settings-array\n\t\t\t\t\t * if found, we check if the current webserver is in the array.\n\t\t\t\t\t * If this\n\t\t\t\t\t * is not the case, we change the setting type to \"hidden\", #502\n\t\t\t\t\t */\n\t\t\t\t\t$do_show = true;\n\t\t\t\t\tif (isset($groupdetails['websrv_avail']) && is_array($groupdetails['websrv_avail'])) {\n\t\t\t\t\t\t$websrv = Settings::Get('system.webserver');\n\t\t\t\t\t\tif (!in_array($websrv, $groupdetails['websrv_avail'])) {\n\t\t\t\t\t\t\t$do_show = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// visible = Settings::Get('phpfpm.enabled') for example would result in false if not enabled\n\t\t\t\t\t// and therefore not shown as intended. Only check if do_show is still true as it might\n\t\t\t\t\t// be false due to websrv_avail\n\t\t\t\t\tif (isset($groupdetails['visible']) && $do_show) {\n\t\t\t\t\t\t$do_show = $groupdetails['visible'];\n\t\t\t\t\t}\n\n\t\t\t\t\t$fields['_group'] = [\n\t\t\t\t\t\t'title' => $groupdetails['title'] ?? 'unknown group',\n\t\t\t\t\t\t'do_show' => $do_show\n\t\t\t\t\t];\n\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Collect form field output\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\t// check for advanced mode sections\n\t\t\t\t\t\t\tif (isset($fielddetails['advanced_mode']) && $fielddetails['advanced_mode'] && (int)Settings::Get('panel.settings_mode') == 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$fields[$fieldname] = self::getFormFieldOutput($fieldname, $fielddetails);\n\t\t\t\t\t\t\t$fields[$fieldname] = array_merge($fields[$fieldname], self::prefetchFormFieldData($fieldname, $fielddetails));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn $fields;\n\t}\n\n\tpublic static function getFormOverviewGroupOutput($groupname, $groupdetails)\n\t{\n\t\t$activated = true;\n\t\tif (isset($groupdetails['fields'])) {\n\t\t\tforeach ($groupdetails['fields'] as $fielddetails) {\n\t\t\t\tif (isset($fielddetails['overview_option']) && $fielddetails['overview_option'] == true) {\n\t\t\t\t\tif ($fielddetails['type'] != 'checkbox') {\n\t\t\t\t\t\t// throw exception here as this is most likely an internal issue\n\t\t\t\t\t\t// if we messed up the arrays\n\t\t\t\t\t\tResponse::standardError('overviewsettingoptionisnotavalidfield', '', true);\n\t\t\t\t\t}\n\t\t\t\t\t$activated = (int)Settings::Get($fielddetails['settinggroup'] . '.' . $fielddetails['varname']);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$item = [\n\t\t\t'title' => $groupdetails['title'],\n\t\t\t'icon' => $groupdetails['icon'] ?? 'fa-solid fa-circle-question',\n\t\t\t'part' => $groupname,\n\t\t\t'activated' => $activated\n\t\t];\n\n\t\t/**\n\t\t * this part checks for the 'websrv_avail' entry in the settings\n\t\t * if found, we check if the current webserver is in the array.\n\t\t * If this is not the case, we change the setting type to \"hidden\", #502\n\t\t */\n\t\tif (isset($groupdetails['websrv_avail']) && is_array($groupdetails['websrv_avail'])) {\n\t\t\t$websrv = Settings::Get('system.webserver');\n\t\t\tif (!in_array($websrv, $groupdetails['websrv_avail'])) {\n\t\t\t\t$item['info'] = lng('serversettings.option_unavailable_websrv', [implode(\", \", $groupdetails['websrv_avail'])]);\n\t\t\t\t$item['visible'] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn $item;\n\t}\n\n\tpublic static function getFormFieldOutput($fieldname, $fielddata): array\n\t{\n\t\t$returnvalue = [];\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] != '') {\n\t\t\tif (!isset($fielddata['value'])) {\n\t\t\t\tif (isset($fielddata['default'])) {\n\t\t\t\t\t$fielddata['value'] = $fielddata['default'];\n\t\t\t\t} else {\n\t\t\t\t\t$fielddata['value'] = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// set value according to type\n\t\t\tswitch ($fielddata['type']) {\n\t\t\t\tcase 'select':\n\t\t\t\t\t$fielddata['selected'] = $fielddata['value'];\n\t\t\t\t\tunset($fielddata['value']);\n\t\t\t\t\tif (isset($fielddata['select_mode']) && $fielddata['select_mode'] == 'multiple') {\n\t\t\t\t\t\t$fielddata['selected'] = array_flip(explode(\",\", $fielddata['selected']));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'checkbox':\n\t\t\t\t\t$fielddata['checked'] = (bool)$fielddata['value'];\n\t\t\t\t\t$fielddata['value'] = 1;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * this part checks for the 'websrv_avail' entry in the settings-array\n\t\t\t * if found, we check if the current webserver is in the array.\n\t\t\t * If this\n\t\t\t * is not the case, we change the setting type to \"hidden\", #502\n\t\t\t */\n\t\t\t$do_show = true;\n\t\t\tif (isset($fielddata['websrv_avail']) && is_array($fielddata['websrv_avail'])) {\n\t\t\t\t$websrv = Settings::Get('system.webserver');\n\t\t\t\tif (!in_array($websrv, $fielddata['websrv_avail'])) {\n\t\t\t\t\t$do_show = false;\n\t\t\t\t\t$fielddata['note'] = lng('serversettings.option_unavailable_websrv', [implode(\", \", $fielddata['websrv_avail'])]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// visible = Settings::Get('phpfpm.enabled') for example would result in false if not enabled\n\t\t\t// and therefore not shown as intended. Only check if do_show is still true as it might\n\t\t\t// be false due to websrv_avail\n\t\t\tif (isset($fielddata['visible']) && $do_show) {\n\t\t\t\t$do_show = $fielddata['visible'];\n\t\t\t\tif (!$do_show) {\n\t\t\t\t\t$fielddata['note'] = lng('serversettings.option_unavailable');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!$do_show) {\n\t\t\t\t$fielddata['visible'] = false;\n\t\t\t}\n\n\t\t\t$returnvalue = $fielddata;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function prefetchFormFieldData($fieldname, $fielddata)\n\t{\n\t\t$returnvalue = [];\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] == 'select') {\n\t\t\tif ((!isset($fielddata['select_var']) || !is_array($fielddata['select_var']) || empty($fielddata['select_var'])) && (isset($fielddata['option_options_method']))) {\n\t\t\t\t$returnvalue['select_var'] = call_user_func($fielddata['option_options_method']);\n\t\t\t}\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function processForm(&$form, &$input, $url_params = [], $part = null, bool $settings_all = false, $settings_part = null, bool $only_enabledisable = false)\n\t{\n\t\tif (\\Froxlor\\Validate\\Form::validateFormDefinition($form)) {\n\t\t\t$submitted_fields = [];\n\t\t\t$changed_fields = [];\n\t\t\t$saved_fields = [];\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Prefetch form fields\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option']))) {\n\t\t\t\t\t\t\t\t$groupdetails['fields'][$fieldname] = self::arrayMergePrefix($fielddetails, $fielddetails['type'], self::prefetchFormFieldData($fieldname, $fielddetails));\n\t\t\t\t\t\t\t\t$form['groups'][$groupname]['fields'][$fieldname] = $groupdetails['fields'][$fieldname];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Validate fields\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (((isset($fielddetails['visible']) && $fielddetails['visible']) || !isset($fielddetails['visible'])) && (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option'])))) {\n\t\t\t\t\t\t\t\t$newfieldvalue = self::getFormFieldData($fieldname, $fielddetails, $input);\n\t\t\t\t\t\t\t\tif ($newfieldvalue != $fielddetails['value']) {\n\t\t\t\t\t\t\t\t\tif (($error = \\Froxlor\\Validate\\Form::validateFormField($fieldname, $fielddetails, $newfieldvalue)) != true) {\n\t\t\t\t\t\t\t\t\t\tResponse::standardError($error, $fieldname);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t$changed_fields[$fieldname] = $newfieldvalue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t$submitted_fields[$fieldname] = $newfieldvalue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Check fields for plausibility\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option']))) {\n\t\t\t\t\t\t\t\tif (($plausibility_check = self::checkPlausibilityFormField($fieldname, $fielddetails, $submitted_fields[$fieldname], $submitted_fields)) !== false) {\n\t\t\t\t\t\t\t\t\tif (is_array($plausibility_check) && isset($plausibility_check[0])) {\n\t\t\t\t\t\t\t\t\t\tif ($plausibility_check[0] == Check::FORMFIELDS_PLAUSIBILITY_CHECK_OK) {\n\t\t\t\t\t\t\t\t\t\t\t// Nothing to do here, everything's okay\n\t\t\t\t\t\t\t\t\t\t} elseif ($plausibility_check[0] == Check::FORMFIELDS_PLAUSIBILITY_CHECK_ERROR) {\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[0]);\n\t\t\t\t\t\t\t\t\t\t\t$error = $plausibility_check[1];\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[1]);\n\t\t\t\t\t\t\t\t\t\t\t$targetname = implode(' ', $plausibility_check);\n\t\t\t\t\t\t\t\t\t\t\tResponse::standardError($error, $targetname);\n\t\t\t\t\t\t\t\t\t\t} elseif ($plausibility_check[0] == Check::FORMFIELDS_PLAUSIBILITY_CHECK_QUESTION) {\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[0]);\n\t\t\t\t\t\t\t\t\t\t\t$question = $plausibility_check[1];\n\t\t\t\t\t\t\t\t\t\t\tunset($plausibility_check[1]);\n\t\t\t\t\t\t\t\t\t\t\t$targetname = implode(' ', $plausibility_check);\n\t\t\t\t\t\t\t\t\t\t\tif (!isset($input[$question])) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (is_array($url_params) && isset($url_params['filename'])) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$filename = $url_params['filename'];\n\t\t\t\t\t\t\t\t\t\t\t\t\tunset($url_params['filename']);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t$filename = '';\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tHTML::askYesNo($question, $filename, array_merge($url_params, $submitted_fields, [\n\t\t\t\t\t\t\t\t\t\t\t\t\t$question => $question\n\t\t\t\t\t\t\t\t\t\t\t\t]), $targetname);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tResponse::standardError('plausibilitychecknotunderstood');\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach ($form['groups'] as $groupname => $groupdetails) {\n\t\t\t\tif (($settings_part && $part == $groupname) || $settings_all || $only_enabledisable) {\n\t\t\t\t\tif (\\Froxlor\\Validate\\Form::validateFieldDefinition($groupdetails)) {\n\t\t\t\t\t\t// Save fields\n\t\t\t\t\t\tforeach ($groupdetails['fields'] as $fieldname => $fielddetails) {\n\t\t\t\t\t\t\tif (!$only_enabledisable || ($only_enabledisable && isset($fielddetails['overview_option']))) {\n\t\t\t\t\t\t\t\tif (isset($changed_fields[$fieldname])) {\n\t\t\t\t\t\t\t\t\tif (($saved_field = self::saveFormField($fieldname, $fielddetails, self::manipulateFormFieldData($fieldname, $fielddetails, $changed_fields[$fieldname]))) !== false) {\n\t\t\t\t\t\t\t\t\t\t$saved_fields = array_merge($saved_fields, $saved_field);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tResponse::standardError('errorwhensaving', $fieldname);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save form\n\t\t\treturn self::saveForm($form, $saved_fields);\n\t\t}\n\t}\n\n\tprivate static function arrayMergePrefix($array1, $key_prefix, $array2)\n\t{\n\t\tif (is_array($array1) && is_array($array2)) {\n\t\t\tif ($key_prefix != '') {\n\t\t\t\tforeach ($array2 as $key => $value) {\n\t\t\t\t\t$array1[$key_prefix . '_' . $key] = $value;\n\t\t\t\t\tunset($array2[$key]);\n\t\t\t\t}\n\t\t\t\tunset($array2);\n\t\t\t\treturn $array1;\n\t\t\t} else {\n\t\t\t\treturn array_merge($array1, $array2);\n\t\t\t}\n\t\t} else {\n\t\t\treturn $array1;\n\t\t}\n\t}\n\n\tpublic static function getFormFieldData($fieldname, $fielddata, &$input)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] != '' && method_exists('\\\\Froxlor\\\\UI\\\\Data', 'getFormFieldData' . ucfirst($fielddata['type']))) {\n\t\t\t$newfieldvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\UI\\\\Data',\n\t\t\t\t'getFormFieldData' . ucfirst($fielddata['type'])\n\t\t\t], $fieldname, $fielddata, $input);\n\t\t} else {\n\t\t\tif (isset($input[$fieldname])) {\n\t\t\t\t$newfieldvalue = $input[$fieldname];\n\t\t\t} elseif (isset($fielddata['default'])) {\n\t\t\t\t$newfieldvalue = $fielddata['default'];\n\t\t\t} else {\n\t\t\t\t$newfieldvalue = false;\n\t\t\t}\n\t\t}\n\n\t\treturn trim($newfieldvalue);\n\t}\n\n\tpublic static function checkPlausibilityFormField($fieldname, $fielddata, $newfieldvalue, $allnewfieldvalues)\n\t{\n\t\t$returnvalue = '';\n\t\tif (is_array($fielddata) && isset($fielddata['plausibility_check_method']) && $fielddata['plausibility_check_method'] != '' && method_exists($fielddata['plausibility_check_method'][0], $fielddata['plausibility_check_method'][1])) {\n\t\t\t$returnvalue = call_user_func($fielddata['plausibility_check_method'], $fieldname, $fielddata, $newfieldvalue, $allnewfieldvalues);\n\t\t} else {\n\t\t\t$returnvalue = false;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function saveFormField($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = '';\n\t\tif (is_array($fielddata) && isset($fielddata['save_method']) && $fielddata['save_method'] != '') {\n\t\t\t$returnvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\Settings\\\\Store',\n\t\t\t\t$fielddata['save_method']\n\t\t\t], $fieldname, $fielddata, $newfieldvalue);\n\t\t} elseif (is_array($fielddata) && !isset($fielddata['save_method'])) {\n\t\t\t$returnvalue = [];\n\t\t} else {\n\t\t\t$returnvalue = false;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n\n\tpublic static function manipulateFormFieldData($fieldname, $fielddata, $newfieldvalue)\n\t{\n\t\tif (is_array($fielddata) && isset($fielddata['type']) && $fielddata['type'] != '' && method_exists('\\\\Froxlor\\\\UI\\\\Data', 'manipulateFormFieldData' . ucfirst($fielddata['type']))) {\n\t\t\t$newfieldvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\UI\\\\Data',\n\t\t\t\t'manipulateFormFieldData' . ucfirst($fielddata['type'])\n\t\t\t], $fieldname, $fielddata, $newfieldvalue);\n\t\t}\n\n\t\treturn $newfieldvalue;\n\t}\n\n\tpublic static function saveForm($fielddata, $newfieldvalue)\n\t{\n\t\t$returnvalue = '';\n\t\tif (is_array($fielddata) && isset($fielddata['save_method']) && $fielddata['save_method'] != '') {\n\t\t\t$returnvalue = call_user_func([\n\t\t\t\t'\\\\Froxlor\\\\Settings\\\\Store',\n\t\t\t\t$fielddata['save_method']\n\t\t\t], $fielddata, $newfieldvalue);\n\t\t} elseif (is_array($fielddata) && !isset($fielddata['save_method'])) {\n\t\t\t$returnvalue = true;\n\t\t} else {\n\t\t\t$returnvalue = false;\n\t\t}\n\t\treturn $returnvalue;\n\t}\n}\n"], "filenames": ["lib/Froxlor/Froxlor.php", "lib/Froxlor/SImExporter.php", "lib/Froxlor/Settings.php", "lib/Froxlor/UI/Form.php"], "buggy_code_start_loc": [92, 29, 331, 206], "buggy_code_end_loc": [113, 203, 331, 207], "fixing_code_start_loc": [92, 30, 332, 206], "fixing_code_end_loc": [113, 174, 338, 207], "type": "CWE-94", "message": "Code Injection in GitHub repository froxlor/froxlor prior to 2.0.11.", "other": {"cve": {"id": "CVE-2023-0877", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-17T01:15:10.663", "lastModified": "2023-02-25T03:37:57.583", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Code Injection in GitHub repository froxlor/froxlor prior to 2.0.11."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:froxlor:froxlor:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.11", "matchCriteriaId": "C1635360-5CD8-4058-99AD-C8F00ED696A9"}]}]}], "references": [{"url": "https://github.com/froxlor/froxlor/commit/aa48ffca2bcaf7ae57be3b8147bb3138abdab984", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/b29cf038-06f1-4fb0-9437-08f2991f92a8", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/froxlor/froxlor/commit/aa48ffca2bcaf7ae57be3b8147bb3138abdab984"}}