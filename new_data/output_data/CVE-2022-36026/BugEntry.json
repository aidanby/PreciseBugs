{"buggy_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op_requires.h\"\n#define EIGEN_USE_THREADS\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/kernels/quantize_and_dequantize_op.h\"\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\ntypedef Eigen::GpuDevice GPUDevice;\n\n// Simulate quantization precision loss in a float tensor by:\n// 1. Quantize the tensor to fixed point numbers, which should match the target\n//    quantization method when it is used in inference.\n// 2. Dequantize it back to floating point numbers for the following ops, most\n//    likely matmul.\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeV2Op : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(\n        ctx, axis_ >= -1,\n        errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n    OP_REQUIRES(\n        ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n        errors::InvalidArgument(\"Shape must be at least rank \", axis_ + 1,\n                                \" but is rank \", input.shape().dims()));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    Tensor input_min_tensor;\n    Tensor input_max_tensor;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    if (range_given_) {\n      input_min_tensor = ctx->input(1);\n      input_max_tensor = ctx->input(2);\n      if (axis_ == -1) {\n        auto min_val = input_min_tensor.scalar<T>()();\n        auto max_val = input_max_tensor.scalar<T>()();\n        OP_REQUIRES(ctx, min_val <= max_val,\n                    errors::InvalidArgument(\"Invalid range: input_min \",\n                                            min_val, \" > input_max \", max_val));\n      } else {\n        OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n                    errors::InvalidArgument(\n                        \"input_min_tensor has incorrect size, was \",\n                        input_min_tensor.dim_size(0), \" expected \", depth,\n                        \" to match dim \", axis_, \" of the input \",\n                        input_min_tensor.shape()));\n        OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n                    errors::InvalidArgument(\n                        \"input_max_tensor has incorrect size, was \",\n                        input_max_tensor.dim_size(0), \" expected \", depth,\n                        \" to match dim \", axis_, \" of the input \",\n                        input_max_tensor.shape()));\n      }\n    } else {\n      auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_max_tensor));\n    }\n\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_, num_bits_,\n        range_given_, &input_min_tensor, &input_max_tensor, round_mode_,\n        narrow_range_, output->flat<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1), signed_input_,\n        num_bits_, range_given_, &input_min_tensor, &input_max_tensor,\n        round_mode_, narrow_range_,\n        output->template flat_inner_outer_dims<T, 3>(axis_ - 1));\n    }\n  }\n\n private:\n  int num_bits_;\n  int axis_;\n  QuantizerRoundMode round_mode_;\n  bool signed_input_;\n  bool range_given_;\n  bool narrow_range_;\n};\n\n// Implementation of QuantizeAndDequantizeV4GradientOp.\n// When back-propagating the error through a quantized layer, the following\n// paper gives evidence that clipped-ReLU is better than non-clipped:\n// \"Deep Learning with Low Precision by Half-wave Gaussian Quantization\"\n// http://zpascal.net/cvpr2017/Cai_Deep_Learning_With_CVPR_2017_paper.pdf\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeV4GradientOp : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeV4GradientOp(OpKernelConstruction* ctx)\n      : OpKernel::OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& gradient = ctx->input(0);\n    const Tensor& input = ctx->input(1);\n    Tensor* input_backprop = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, input.shape(), &input_backprop));\n    OP_REQUIRES(\n        ctx, axis_ >= -1,\n        errors::InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n    OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n                errors::InvalidArgument(\n                    \"Axis should be -1 or 0 or a positive value less than \",\n                    input.shape().dims(), \"but given axis value was \", axis_));\n\n    OP_REQUIRES(\n        ctx, input.IsSameSize(gradient),\n        errors::InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    const Tensor& input_min_tensor = ctx->input(2);\n    OP_REQUIRES(ctx,\n                input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,\n                errors::InvalidArgument(\n                    \"Input min tensor must have dimension 0 or 1. Received \",\n                    input_min_tensor.dims(), \".\"));\n    const Tensor& input_max_tensor = ctx->input(3);\n    OP_REQUIRES(ctx,\n                input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,\n                errors::InvalidArgument(\n                    \"Input max tensor must have dimension 0 or 1. Received \",\n                    input_max_tensor.dims(), \".\"));\n    if (axis_ != -1) {\n      OP_REQUIRES(\n          ctx, input_min_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"min has incorrect size, expected \", depth,\n                                  \" was \", input_min_tensor.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_tensor.dim_size(0) == depth,\n          errors::InvalidArgument(\"max has incorrect size, expected \", depth,\n                                  \" was \", input_max_tensor.dim_size(0)));\n    }\n\n    TensorShape min_max_shape(input_min_tensor.shape());\n    Tensor* input_min_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, min_max_shape, &input_min_backprop));\n\n    Tensor* input_max_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n\n    if (axis_ == -1) {\n      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"input_min must be a scalar if axis is unspecified\"));\n      OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),\n                  errors::InvalidArgument(\n                      \"input_max must be a scalar if axis is unspecified\"));\n      functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n        input.template flat<T>(), input_min_tensor.scalar<T>(),\n        input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),\n        input_min_backprop->template scalar<T>(),\n        input_max_backprop->template scalar<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        &input_min_tensor, &input_max_tensor,\n        input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input_min_backprop->template flat<T>(),\n        input_max_backprop->template flat<T>());\n    }\n  }\n\n private:\n  int axis_;\n};\n\n// Simulate quantization precision loss in a float tensor by:\n// 1. Quantize the tensor to fixed point numbers, which should match the target\n//    quantization method when it is used in inference.\n// 2. Dequantize it back to floating point numbers for the following ops, most\n//    likely matmul.\n// Almost identical to QuantizeAndDequantizeV2Op, except that num_bits is a\n// tensor.\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeV3Op : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeV3Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, axis_ < input.dims(),\n                errors::InvalidArgument(\n                    \"Axis requested is larger than input dimensions. Axis: \",\n                    axis_, \" Input Dimensions: \", input.dims()));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    Tensor num_bits_tensor;\n    num_bits_tensor = ctx->input(3);\n    int num_bits_val = num_bits_tensor.scalar<int32>()();\n\n    OP_REQUIRES(\n        ctx, num_bits_val > 0 && num_bits_val < (signed_input_ ? 62 : 63),\n        errors::InvalidArgument(\"num_bits is out of range: \", num_bits_val,\n                                \" with signed_input_ \", signed_input_));\n\n    Tensor input_min_tensor;\n    Tensor input_max_tensor;\n    if (range_given_) {\n      input_min_tensor = ctx->input(1);\n      input_max_tensor = ctx->input(2);\n      if (axis_ == -1) {\n        auto min_val = input_min_tensor.scalar<T>()();\n        auto max_val = input_max_tensor.scalar<T>()();\n        OP_REQUIRES(ctx, min_val <= max_val,\n                    errors::InvalidArgument(\"Invalid range: input_min \",\n                                            min_val, \" > input_max \", max_val));\n      } else {\n        OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n                    errors::InvalidArgument(\n                        \"input_min_tensor has incorrect size, was \",\n                        input_min_tensor.dim_size(0), \" expected \", depth,\n                        \" to match dim \", axis_, \" of the input \",\n                        input_min_tensor.shape()));\n        OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n                    errors::InvalidArgument(\n                        \"input_max_tensor has incorrect size, was \",\n                        input_max_tensor.dim_size(0), \" expected \", depth,\n                        \" to match dim \", axis_, \" of the input \",\n                        input_max_tensor.shape()));\n      }\n    } else {\n      auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_max_tensor));\n    }\n\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_,\n        num_bits_val, range_given_, &input_min_tensor, &input_max_tensor,\n        ROUND_HALF_TO_EVEN, narrow_range_, output->flat<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1), signed_input_,\n        num_bits_val, range_given_, &input_min_tensor, &input_max_tensor,\n        ROUND_HALF_TO_EVEN, narrow_range_,\n        output->template flat_inner_outer_dims<T, 3>(axis_ - 1));\n    }\n  }\n\n private:\n  int axis_;\n  bool signed_input_;\n  bool range_given_;\n  bool narrow_range_;\n};\n\n// DEPRECATED: Use QuantizeAndDequantizeV2Op.\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeOp : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(\n          ctx, input_min_ <= input_max_,\n          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    // One global scale.\n    Tensor input_min_tensor(DataTypeToEnum<T>::value, TensorShape());\n    Tensor input_max_tensor(DataTypeToEnum<T>::value, TensorShape());\n    // Initialize the tensors with the values in the Attrs.\n    input_min_tensor.template scalar<T>()() = static_cast<T>(input_min_);\n    input_max_tensor.template scalar<T>()() = static_cast<T>(input_max_);\n\n    functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> functor;\n    functor(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_,\n            num_bits_, range_given_, &input_min_tensor, &input_max_tensor,\n            ROUND_HALF_TO_EVEN, /*narrow_range=*/false, output->flat<T>());\n  }\n\n private:\n  bool signed_input_;\n  int num_bits_;\n  bool range_given_;\n  float input_min_;\n  float input_max_;\n};\n\n// Specializations for CPUDevice.\n\nnamespace functor {\ntemplate <typename T>\nstruct QuantizeAndDequantizeOneScaleFunctor<CPUDevice, T> {\n  void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,\n                  const bool signed_input, const int num_bits,\n                  const bool range_given, Tensor* input_min_tensor,\n                  Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                  bool narrow_range, typename TTypes<T>::Vec out) {\n    QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }\n};\n\ntemplate <typename T>\nstruct QuantizeAndDequantizePerChannelFunctor<CPUDevice, T> {\n  void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                  bool signed_input, int num_bits, bool range_given,\n                  Tensor* input_min_tensor, Tensor* input_max_tensor,\n                  QuantizerRoundMode round_mode, bool narrow_range,\n                  typename TTypes<T, 3>::Tensor out) {\n    QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }\n};\n\ntemplate <typename T>\nstruct QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice, T> {\n  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }\n};\n\ntemplate <typename T>\nstruct QuantizeAndDequantizePerChannelGradientFunctor<CPUDevice, T> {\n  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }\n};\n\ntemplate struct functor::QuantizeAndDequantizeOneScaleGradientFunctor<CPUDevice,\n                                                                      float>;\ntemplate struct functor::QuantizeAndDequantizePerChannelGradientFunctor<\n    CPUDevice, double>;\n\n}  // namespace functor\n\n#define REGISTER_CPU_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV2\")                      \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<CPUDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV3\")                      \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV3Op<CPUDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4\")                      \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<CPUDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4Grad\")                  \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV4GradientOp<CPUDevice, T>);    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"QuantizeAndDequantize\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      QuantizeAndDequantizeOp<CPUDevice, T>);\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n#define REGISTER_GPU_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV2\")                      \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<GPUDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV3\")                      \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .HostMemory(\"num_bits\")                          \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV3Op<GPUDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4\")                      \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<GPUDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4Grad\")                  \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV4GradientOp<GPUDevice, T>);    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"QuantizeAndDequantize\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      QuantizeAndDequantizeOp<GPUDevice, T>);\nTF_CALL_float(REGISTER_GPU_KERNEL);\nTF_CALL_double(REGISTER_GPU_KERNEL);\n#undef REGISTER_GPU_KERNEL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tf.quantize ops.\"\"\"\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import nn_ops\nfrom tensorflow.python.platform import googletest\n\n\nclass FakeQuantWithMinMaxVarsOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars(\n              inputs=inputs, min=0.0, max=[[1.0], [2.0], [4.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars(\n              inputs=inputs, min=[[1.0], [2.0], [4.0]], max=1.0))\n\n\nclass FakeQuantWithMinMaxVarsPerChannelOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[[0.0]], max=[1.0]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Dimensions must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[0.0, 0.1], max=[1.0]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[1.0], max=[[1.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Dimensions must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n\n\nclass FakeQuantWithMinMaxVarsGradientOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    gradients = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be equal rank|must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_gradient(\n              gradients=gradients,\n              inputs=inputs,\n              min=0.0,\n              max=[[1.0], [2.0], [4.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_gradient(\n              gradients=gradients,\n              inputs=inputs,\n              min=[[1.0], [2.0], [4.0]],\n              max=[[1.0], [2.0], [4.0]]))\n\n\nclass FakeQuantWithMinMaxVarsPerChannelGradientOpTest(\n    test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    gradients = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shapes must be equal rank|must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[[0.0]], max=[1.0]))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"Dimension 0 in both shapes must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[0.0, 0.1], max=[1.0]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shapes must be equal rank|must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[1.0], max=[[1.0]]))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"Dimension 0 in both shapes must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n\n\nclass QuantizedBiasedAddTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.qint8)\n    bias = constant_op.constant(np.int8(0), shape=[3], dtype=dtypes.qint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=[],\n              max_input=1.0,\n              min_bias=0.0,\n              max_bias=1.0,\n              out_type=dtypes.qint32))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=0.0,\n              max_input=[],\n              min_bias=0.0,\n              max_bias=1.0,\n              out_type=dtypes.qint32))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=0.0,\n              max_input=1.0,\n              min_bias=[],\n              max_bias=1.0,\n              out_type=dtypes.qint32))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=0.0,\n              max_input=1.0,\n              min_bias=0.0,\n              max_bias=[],\n              out_type=dtypes.qint32))\n\n\nclass QuantizedInstanceNormOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.quantized_instance_norm(\n              x=inputs, x_min=0.0, x_max=[[1.0], [2.0], [4.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.quantized_instance_norm(\n              x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))\n\n\nclass QuantizedAvgPoolingOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n    ksize = [1, 1, 1, 1]\n    strides = [1, 1, 1, 1]\n    padding = \"SAME\"\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_avg_pool(\n              input=inputs,\n              min_input=[],\n              max_input=1.0,\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_avg_pool(\n              input=inputs,\n              min_input=0.0,\n              max_input=[],\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n\nclass QuantizedMaxPoolingOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n    ksize = [1, 1, 1, 1]\n    strides = [1, 1, 1, 1]\n    padding = \"SAME\"\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_max_pool(\n              input=inputs,\n              min_input=[],\n              max_input=1.0,\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_max_pool(\n              input=inputs,\n              min_input=0.0,\n              max_input=[],\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n\nclass RequantizeOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int32(0), shape=[3, 3, 3, 3], dtype=dtypes.qint32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=[],\n              input_max=1.0,\n              requested_output_min=0.0,\n              requested_output_max=1.0,\n              out_type=dtypes.qint8))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=0.0,\n              input_max=[],\n              requested_output_min=0.0,\n              requested_output_max=1.0,\n              out_type=dtypes.qint8))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=0.0,\n              input_max=1.0,\n              requested_output_min=[],\n              requested_output_max=1.0,\n              out_type=dtypes.qint8))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=0.0,\n              input_max=1.0,\n              requested_output_min=0.0,\n              requested_output_max=[],\n              out_type=dtypes.qint8))\n\n\nclass QuantizedAddOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    x = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n    y = constant_op.constant(np.int8(0), shape=[3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.quantized_add(\n              x=x,\n              y=y,\n              min_x=[],\n              max_x=1.0,\n              min_y=0.0,\n              max_y=1.0,\n              Toutput=dtypes.qint32))\n\n\nclass QuantizedReluOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_relu(\n              features=inputs,\n              min_features=[],\n              max_features=127.0,\n              out_type=dtypes.quint8))\n\n\nclass QuantizedRelu6OpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_relu6(\n              features=inputs,\n              min_features=[],\n              max_features=127.0,\n              out_type=dtypes.quint8))\n\n\nclass QuantizeDownAndShrinkRangeOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int32(0), shape=[3, 3, 3, 3], dtype=dtypes.qint32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.quantize_down_and_shrink_range(\n              input=inputs, input_min=[], input_max=4.0,\n              out_type=dtypes.quint8))\n\n\nif __name__ == \"__main__\":\n  googletest.main()\n"], "fixing_code": ["/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"tensorflow/core/framework/op_requires.h\"\n#define EIGEN_USE_THREADS\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n#define EIGEN_USE_GPU\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/type_traits.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/quantize_and_dequantize_op.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n\nnamespace tensorflow {\nnamespace {\n\nusing CpuDevice = ::Eigen::ThreadPoolDevice;\nusing GpuDevice = ::Eigen::GpuDevice;\nusing ::tensorflow::errors::InvalidArgument;\n\n}  // namespace\n\n// Simulate quantization precision loss in a float tensor by:\n// 1. Quantize the tensor to fixed point numbers, which should match the target\n//    quantization method when it is used in inference.\n// 2. Dequantize it back to floating point numbers for the following ops, most\n//    likely matmul.\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeV2Op : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        InvalidArgument(\"Round mode string must be \"\n                        \"'HALF_UP' or \"\n                        \"'HALF_TO_EVEN', is '\" +\n                        round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, axis_ >= -1,\n                InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n    OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n                InvalidArgument(\"Shape must be at least rank \", axis_ + 1,\n                                \" but is rank \", input.shape().dims()));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    Tensor input_min_tensor;\n    Tensor input_max_tensor;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    if (range_given_) {\n      input_min_tensor = ctx->input(1);\n      input_max_tensor = ctx->input(2);\n      if (axis_ == -1) {\n        auto min_val = input_min_tensor.scalar<T>()();\n        auto max_val = input_max_tensor.scalar<T>()();\n        OP_REQUIRES(ctx, min_val <= max_val,\n                    InvalidArgument(\"Invalid range: input_min \", min_val,\n                                    \" > input_max \", max_val));\n      } else {\n        OP_REQUIRES(\n            ctx, input_min_tensor.dim_size(0) == depth,\n            InvalidArgument(\"input_min_tensor has incorrect size, was \",\n                            input_min_tensor.dim_size(0), \" expected \", depth,\n                            \" to match dim \", axis_, \" of the input \",\n                            input_min_tensor.shape()));\n        OP_REQUIRES(\n            ctx, input_max_tensor.dim_size(0) == depth,\n            InvalidArgument(\"input_max_tensor has incorrect size, was \",\n                            input_max_tensor.dim_size(0), \" expected \", depth,\n                            \" to match dim \", axis_, \" of the input \",\n                            input_max_tensor.shape()));\n      }\n    } else {\n      auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_max_tensor));\n    }\n\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_, num_bits_,\n        range_given_, &input_min_tensor, &input_max_tensor, round_mode_,\n        narrow_range_, output->flat<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1), signed_input_,\n        num_bits_, range_given_, &input_min_tensor, &input_max_tensor,\n        round_mode_, narrow_range_,\n        output->template flat_inner_outer_dims<T, 3>(axis_ - 1));\n    }\n  }\n\n private:\n  int num_bits_;\n  int axis_;\n  QuantizerRoundMode round_mode_;\n  bool signed_input_;\n  bool range_given_;\n  bool narrow_range_;\n};\n\n// Implementation of QuantizeAndDequantizeV4GradientOp.\n// When back-propagating the error through a quantized layer, the following\n// paper gives evidence that clipped-ReLU is better than non-clipped:\n// \"Deep Learning with Low Precision by Half-wave Gaussian Quantization\"\n// http://zpascal.net/cvpr2017/Cai_Deep_Learning_With_CVPR_2017_paper.pdf\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeV4GradientOp : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeV4GradientOp(OpKernelConstruction* ctx)\n      : OpKernel::OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& gradient = ctx->input(0);\n    const Tensor& input = ctx->input(1);\n    Tensor* input_backprop = nullptr;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, input.shape(), &input_backprop));\n    OP_REQUIRES(ctx, axis_ >= -1,\n                InvalidArgument(\"Axis must be at least -1. Found \", axis_));\n    OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),\n                InvalidArgument(\n                    \"Axis should be -1 or 0 or a positive value less than \",\n                    input.shape().dims(), \"but given axis value was \", axis_));\n\n    OP_REQUIRES(ctx, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    const Tensor& input_min_tensor = ctx->input(2);\n    OP_REQUIRES(ctx,\n                input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,\n                InvalidArgument(\n                    \"Input min tensor must have dimension 0 or 1. Received \",\n                    input_min_tensor.dims(), \".\"));\n    const Tensor& input_max_tensor = ctx->input(3);\n    OP_REQUIRES(ctx,\n                input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,\n                InvalidArgument(\n                    \"Input max tensor must have dimension 0 or 1. Received \",\n                    input_max_tensor.dims(), \".\"));\n    if (axis_ != -1) {\n      OP_REQUIRES(ctx, input_min_tensor.dim_size(0) == depth,\n                  InvalidArgument(\"min has incorrect size, expected \", depth,\n                                  \" was \", input_min_tensor.dim_size(0)));\n      OP_REQUIRES(ctx, input_max_tensor.dim_size(0) == depth,\n                  InvalidArgument(\"max has incorrect size, expected \", depth,\n                                  \" was \", input_max_tensor.dim_size(0)));\n    }\n\n    TensorShape min_max_shape(input_min_tensor.shape());\n    Tensor* input_min_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, min_max_shape, &input_min_backprop));\n\n    Tensor* input_max_backprop;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, min_max_shape, &input_max_backprop));\n\n    if (axis_ == -1) {\n      OP_REQUIRES(\n          ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),\n          InvalidArgument(\"input_min must be a scalar if axis is unspecified\"));\n      OP_REQUIRES(\n          ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),\n          InvalidArgument(\"input_max must be a scalar if axis is unspecified\"));\n      functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), gradient.template flat<T>(),\n        input.template flat<T>(), input_min_tensor.scalar<T>(),\n        input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),\n        input_min_backprop->template scalar<T>(),\n        input_max_backprop->template scalar<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        &input_min_tensor, &input_max_tensor,\n        input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),\n        input_min_backprop->template flat<T>(),\n        input_max_backprop->template flat<T>());\n    }\n  }\n\n private:\n  int axis_;\n};\n\n// Simulate quantization precision loss in a float tensor by:\n// 1. Quantize the tensor to fixed point numbers, which should match the target\n//    quantization method when it is used in inference.\n// 2. Dequantize it back to floating point numbers for the following ops, most\n//    likely matmul.\n// Almost identical to QuantizeAndDequantizeV2Op, except that num_bits is a\n// tensor.\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeV3Op : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeV3Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, axis_ < input.dims(),\n                InvalidArgument(\n                    \"Axis requested is larger than input dimensions. Axis: \",\n                    axis_, \" Input Dimensions: \", input.dims()));\n    const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    // Get num_bits and validate.\n    const Tensor num_bits_tensor = ctx->input(3);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(num_bits_tensor.shape()),\n                InvalidArgument(\"Invalid shape. The `num_bits` tensor should \"\n                                \"be a scalar. Got dimensions: \",\n                                num_bits_tensor.dims()));\n\n    const int num_bits_val = num_bits_tensor.scalar<int32>()();\n    OP_REQUIRES(ctx,\n                num_bits_val > 0 && num_bits_val < (signed_input_ ? 62 : 63),\n                InvalidArgument(\"num_bits is out of range: \", num_bits_val,\n                                \" with `signed_input_` \", signed_input_));\n\n    Tensor input_min_tensor;\n    Tensor input_max_tensor;\n    if (range_given_) {\n      input_min_tensor = ctx->input(1);\n      input_max_tensor = ctx->input(2);\n      if (axis_ == -1) {\n        const auto min_val = input_min_tensor.scalar<T>()();\n        const auto max_val = input_max_tensor.scalar<T>()();\n        OP_REQUIRES(ctx, min_val <= max_val,\n                    InvalidArgument(\"Invalid range: input_min \", min_val,\n                                    \" > input_max \", max_val));\n      } else {\n        OP_REQUIRES(\n            ctx, input_min_tensor.dim_size(0) == depth,\n            InvalidArgument(\"input_min_tensor has incorrect size, was \",\n                            input_min_tensor.dim_size(0), \" expected \", depth,\n                            \" to match dim \", axis_, \" of the input \",\n                            input_min_tensor.shape()));\n        OP_REQUIRES(\n            ctx, input_max_tensor.dim_size(0) == depth,\n            InvalidArgument(\"input_max_tensor has incorrect size, was \",\n                            input_max_tensor.dim_size(0), \" expected \", depth,\n                            \" to match dim \", axis_, \" of the input \",\n                            input_max_tensor.shape()));\n      }\n    } else {\n      auto range_shape = (axis_ == -1) ? TensorShape({}) : TensorShape({depth});\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n                                             range_shape, &input_max_tensor));\n    }\n\n    if (axis_ == -1) {\n      functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_,\n        num_bits_val, range_given_, &input_min_tensor, &input_max_tensor,\n        ROUND_HALF_TO_EVEN, narrow_range_, output->flat<T>());\n    } else {\n      functor::QuantizeAndDequantizePerChannelFunctor<Device, T> f;\n      f(ctx->eigen_device<Device>(),\n        input.template flat_inner_outer_dims<T, 3>(axis_ - 1), signed_input_,\n        num_bits_val, range_given_, &input_min_tensor, &input_max_tensor,\n        ROUND_HALF_TO_EVEN, narrow_range_,\n        output->template flat_inner_outer_dims<T, 3>(axis_ - 1));\n    }\n  }\n\n private:\n  int axis_;\n  bool signed_input_;\n  bool range_given_;\n  bool narrow_range_;\n};\n\n// DEPRECATED: Use QuantizeAndDequantizeV2Op.\ntemplate <typename Device, typename T>\nclass QuantizeAndDequantizeOp : public OpKernel {\n public:\n  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(ctx, input_min_ <= input_max_,\n                  InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }\n\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    // One global scale.\n    Tensor input_min_tensor(DataTypeToEnum<T>::value, TensorShape());\n    Tensor input_max_tensor(DataTypeToEnum<T>::value, TensorShape());\n    // Initialize the tensors with the values in the Attrs.\n    input_min_tensor.template scalar<T>()() = static_cast<T>(input_min_);\n    input_max_tensor.template scalar<T>()() = static_cast<T>(input_max_);\n\n    functor::QuantizeAndDequantizeOneScaleFunctor<Device, T> functor;\n    functor(ctx->eigen_device<Device>(), input.flat<T>(), signed_input_,\n            num_bits_, range_given_, &input_min_tensor, &input_max_tensor,\n            ROUND_HALF_TO_EVEN, /*narrow_range=*/false, output->flat<T>());\n  }\n\n private:\n  bool signed_input_;\n  int num_bits_;\n  bool range_given_;\n  float input_min_;\n  float input_max_;\n};\n\n// Specializations for CpuDevice.\n\nnamespace functor {\ntemplate <typename T>\nstruct QuantizeAndDequantizeOneScaleFunctor<CpuDevice, T> {\n  void operator()(const CpuDevice& d, typename TTypes<T>::ConstVec input,\n                  const bool signed_input, const int num_bits,\n                  const bool range_given, Tensor* input_min_tensor,\n                  Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                  bool narrow_range, typename TTypes<T>::Vec out) {\n    QuantizeAndDequantizeOneScaleImpl<CpuDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }\n};\n\ntemplate <typename T>\nstruct QuantizeAndDequantizePerChannelFunctor<CpuDevice, T> {\n  void operator()(const CpuDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                  bool signed_input, int num_bits, bool range_given,\n                  Tensor* input_min_tensor, Tensor* input_max_tensor,\n                  QuantizerRoundMode round_mode, bool narrow_range,\n                  typename TTypes<T, 3>::Tensor out) {\n    QuantizeAndDequantizePerChannelImpl<CpuDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }\n};\n\ntemplate <typename T>\nstruct QuantizeAndDequantizeOneScaleGradientFunctor<CpuDevice, T> {\n  void operator()(const CpuDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CpuDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }\n};\n\ntemplate <typename T>\nstruct QuantizeAndDequantizePerChannelGradientFunctor<CpuDevice, T> {\n  void operator()(const CpuDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CpuDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }\n};\n\ntemplate struct functor::QuantizeAndDequantizeOneScaleGradientFunctor<CpuDevice,\n                                                                      float>;\ntemplate struct functor::QuantizeAndDequantizePerChannelGradientFunctor<\n    CpuDevice, double>;\n\n}  // namespace functor\n\n#define REGISTER_CPU_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV2\")                      \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<CpuDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV3\")                      \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV3Op<CpuDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4\")                      \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<CpuDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4Grad\")                  \\\n                              .Device(DEVICE_CPU)                              \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV4GradientOp<CpuDevice, T>);    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"QuantizeAndDequantize\").Device(DEVICE_CPU).TypeConstraint<T>(\"T\"), \\\n      QuantizeAndDequantizeOp<CpuDevice, T>);\nTF_CALL_float(REGISTER_CPU_KERNEL);\nTF_CALL_double(REGISTER_CPU_KERNEL);\n#undef REGISTER_CPU_KERNEL\n\n#if (defined(GOOGLE_CUDA) && GOOGLE_CUDA) || \\\n    (defined(TENSORFLOW_USE_ROCM) && TENSORFLOW_USE_ROCM)\n#define REGISTER_GPU_KERNEL(T)                                                 \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV2\")                      \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<GpuDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV3\")                      \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .HostMemory(\"num_bits\")                          \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV3Op<GpuDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4\")                      \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV2Op<GpuDevice, T>);            \\\n  REGISTER_KERNEL_BUILDER(Name(\"QuantizeAndDequantizeV4Grad\")                  \\\n                              .Device(DEVICE_GPU)                              \\\n                              .HostMemory(\"input_min\")                         \\\n                              .HostMemory(\"input_max\")                         \\\n                              .TypeConstraint<T>(\"T\"),                         \\\n                          QuantizeAndDequantizeV4GradientOp<GpuDevice, T>);    \\\n  REGISTER_KERNEL_BUILDER(                                                     \\\n      Name(\"QuantizeAndDequantize\").Device(DEVICE_GPU).TypeConstraint<T>(\"T\"), \\\n      QuantizeAndDequantizeOp<GpuDevice, T>);\nTF_CALL_float(REGISTER_GPU_KERNEL);\nTF_CALL_double(REGISTER_GPU_KERNEL);\n#undef REGISTER_GPU_KERNEL\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tf.quantize ops.\"\"\"\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import nn_ops\nfrom tensorflow.python.platform import googletest\n\n\nclass FakeQuantWithMinMaxVarsOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars(\n              inputs=inputs, min=0.0, max=[[1.0], [2.0], [4.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars(\n              inputs=inputs, min=[[1.0], [2.0], [4.0]], max=1.0))\n\n\nclass FakeQuantWithMinMaxVarsPerChannelOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[[0.0]], max=[1.0]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Dimensions must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[0.0, 0.1], max=[1.0]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[1.0], max=[[1.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Dimensions must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel(\n              inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n\n\nclass FakeQuantWithMinMaxVarsGradientOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    gradients = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be equal rank|must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_gradient(\n              gradients=gradients,\n              inputs=inputs,\n              min=0.0,\n              max=[[1.0], [2.0], [4.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_gradient(\n              gradients=gradients,\n              inputs=inputs,\n              min=[[1.0], [2.0], [4.0]],\n              max=[[1.0], [2.0], [4.0]]))\n\n\nclass FakeQuantWithMinMaxVarsPerChannelGradientOpTest(\n    test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    gradients = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n    inputs = constant_op.constant(\n        value=[[1.0], [2.0], [4.0]], dtype=dtypes.float32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shapes must be equal rank|must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[[0.0]], max=[1.0]))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"Dimension 0 in both shapes must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[0.0, 0.1], max=[1.0]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"Shapes must be equal rank|must be rank 1\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[1.0], max=[[1.0]]))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"Dimension 0 in both shapes must be equal|incorrect size\"):\n      self.evaluate(\n          array_ops.fake_quant_with_min_max_vars_per_channel_gradient(\n              gradients=gradients, inputs=inputs, min=[0.0], max=[1.0, 1.1]))\n\n\nclass QuantizedBiasedAddTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.qint8)\n    bias = constant_op.constant(np.int8(0), shape=[3], dtype=dtypes.qint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=[],\n              max_input=1.0,\n              min_bias=0.0,\n              max_bias=1.0,\n              out_type=dtypes.qint32))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=0.0,\n              max_input=[],\n              min_bias=0.0,\n              max_bias=1.0,\n              out_type=dtypes.qint32))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=0.0,\n              max_input=1.0,\n              min_bias=[],\n              max_bias=1.0,\n              out_type=dtypes.qint32))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_bias_add(\n              input=inputs,\n              bias=bias,\n              min_input=0.0,\n              max_input=1.0,\n              min_bias=0.0,\n              max_bias=[],\n              out_type=dtypes.qint32))\n\n\nclass QuantizedInstanceNormOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.quantized_instance_norm(\n              x=inputs, x_min=0.0, x_max=[[1.0], [2.0], [4.0]]))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          array_ops.quantized_instance_norm(\n              x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))\n\n\nclass QuantizedAvgPoolingOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n    ksize = [1, 1, 1, 1]\n    strides = [1, 1, 1, 1]\n    padding = \"SAME\"\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_avg_pool(\n              input=inputs,\n              min_input=[],\n              max_input=1.0,\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_avg_pool(\n              input=inputs,\n              min_input=0.0,\n              max_input=[],\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n\nclass QuantizedMaxPoolingOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n    ksize = [1, 1, 1, 1]\n    strides = [1, 1, 1, 1]\n    padding = \"SAME\"\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_max_pool(\n              input=inputs,\n              min_input=[],\n              max_input=1.0,\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                \"must be.* rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_max_pool(\n              input=inputs,\n              min_input=0.0,\n              max_input=[],\n              ksize=ksize,\n              strides=strides,\n              padding=padding))\n\n\nclass RequantizeOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int32(0), shape=[3, 3, 3, 3], dtype=dtypes.qint32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=[],\n              input_max=1.0,\n              requested_output_min=0.0,\n              requested_output_max=1.0,\n              out_type=dtypes.qint8))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=0.0,\n              input_max=[],\n              requested_output_min=0.0,\n              requested_output_max=1.0,\n              out_type=dtypes.qint8))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=0.0,\n              input_max=1.0,\n              requested_output_min=[],\n              requested_output_max=1.0,\n              out_type=dtypes.qint8))\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.requantize(\n              input=inputs,\n              input_min=0.0,\n              input_max=1.0,\n              requested_output_min=0.0,\n              requested_output_max=[],\n              out_type=dtypes.qint8))\n\n\nclass QuantizedAddOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    x = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n    y = constant_op.constant(np.int8(0), shape=[3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.quantized_add(\n              x=x,\n              y=y,\n              min_x=[],\n              max_x=1.0,\n              min_y=0.0,\n              max_y=1.0,\n              Toutput=dtypes.qint32))\n\n\nclass QuantizedReluOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_relu(\n              features=inputs,\n              min_features=[],\n              max_features=127.0,\n              out_type=dtypes.quint8))\n\n\nclass QuantizedRelu6OpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          nn_ops.quantized_relu6(\n              features=inputs,\n              min_features=[],\n              max_features=127.0,\n              out_type=dtypes.quint8))\n\n\nclass QuantizeDownAndShrinkRangeOpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    inputs = constant_op.constant(\n        np.int32(0), shape=[3, 3, 3, 3], dtype=dtypes.qint32)\n\n    with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),\n                                \"must be rank 0\"):\n      self.evaluate(\n          math_ops.quantize_down_and_shrink_range(\n              input=inputs, input_min=[], input_max=4.0,\n              out_type=dtypes.quint8))\n\n\nclass QuantizeAndDequantizeV3OpTest(test_util.TensorFlowTestCase):\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_valid(self):\n    with ops.Graph().as_default(), context.eager_mode():\n      input_value = constant_op.constant([-0.8, -0.5, 0, 0.3, 0.8, -2.0],\n                                         shape=(6,),\n                                         dtype=dtypes.float32),\n      input_min = constant_op.constant(-127, shape=(), dtype=dtypes.float32)\n      input_max = constant_op.constant(127, shape=(), dtype=dtypes.float32)\n      num_bits = constant_op.constant(8, shape=(), dtype=dtypes.int32)\n\n      quantized = array_ops.quantize_and_dequantize_v3(\n          input_value,\n          input_min,\n          input_max,\n          num_bits,\n          signed_input=True,\n          range_given=False)\n      self.assertSequenceAlmostEqual(\n          input_value[0].numpy(), quantized.numpy()[0], delta=0.05)\n\n  @test_util.run_in_graph_and_eager_modes\n  def test_invalid_inputs(self):\n    input_value = constant_op.constant([-0.8, -0.5, 0, 0.3, 0.8, -2.0],\n                                       shape=(6,),\n                                       dtype=dtypes.float32),\n    input_min = constant_op.constant(-127, shape=(), dtype=dtypes.float32)\n    input_max = constant_op.constant(127, shape=(), dtype=dtypes.float32)\n    # Tensor with invalid shape and invalid number of elements.\n    num_bits = constant_op.constant([], shape=(0,), dtype=dtypes.int32)\n\n    # Test that running the op raises error. It raises different errors\n    # depending on whether the shape inference is run first or the op's\n    # Compute() is run first.\n    try:\n      array_ops.quantize_and_dequantize_v3(\n          input_value, input_min, input_max, num_bits, signed_input=True)\n    except Exception as ex:  # pylint: disable=broad-except\n      if isinstance(ex, errors.InvalidArgumentError):\n        self.assertRegex(str(ex), \"The `num_bits` tensor should be a scalar.\")\n      elif isinstance(ex, ValueError):\n        self.assertRegex(str(ex), \"Shape must be rank 0\")\n      else:\n        self.fail(\n            \"Raised exception other than expected: %s. \"\n            \"Expected exceptions are errors.InvalidArgumentError or ValueError\",\n            ex.__name__)\n    else:\n      self.fail(\n          \"Did not raise an exception where it is expected to raise either \"\n          \"a ValueError or errors.InvalidArgumentError.\")\n\n\nif __name__ == \"__main__\":\n  googletest.main()\n"], "filenames": ["tensorflow/core/kernels/quantize_and_dequantize_op.cc", "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"], "buggy_code_start_loc": [24, 17], "buggy_code_end_loc": [496, 409], "fixing_code_start_loc": [23, 18], "fixing_code_end_loc": [497, 466], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. If `QuantizeAndDequantizeV3` is given a nonscalar `num_bits` input tensor, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-36026", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T22:15:11.953", "lastModified": "2022-09-20T14:55:34.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. If `QuantizeAndDequantizeV3` is given a nonscalar `num_bits` input tensor, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Si a \"QuantizeAndDequantizeV3\" le es dado un tensor de entrada \"num_bits\" no escalar, es producido un fallo de \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713 de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/f3f9cb38ecfe5a8a703f2c4a8fead434ef291713", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-9cr2-8pwr-fhfq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/f3f9cb38ecfe5a8a703f2c4a8fead434ef291713"}}