{"buggy_code": ["package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// UserController user controller\ntype UserController struct {\n\tuserService           *service.UserService\n\tauthService           *auth.AuthService\n\tactionService         *action.CaptchaService\n\tuploaderService       *uploader.UploaderService\n\temailService          *export.EmailService\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService\n}\n\n// NewUserController new controller\nfunc NewUserController(\n\tauthService *auth.AuthService,\n\tuserService *service.UserService,\n\tactionService *action.CaptchaService,\n\temailService *export.EmailService,\n\tuploaderService *uploader.UploaderService,\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService,\n) *UserController {\n\treturn &UserController{\n\t\tauthService:           authService,\n\t\tuserService:           userService,\n\t\tactionService:         actionService,\n\t\tuploaderService:       uploaderService,\n\t\temailService:          emailService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// GetUserInfoByUserID get user info, if user no login response http code is 200, but user info is null\n// @Summary GetUserInfoByUserID\n// @Description get user info, if user no login response http code is 200, but user info is null\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.GetUserToSetShowResp}\n// @Router /answer/api/v1/user/info [get]\nfunc (uc *UserController) GetUserInfoByUserID(ctx *gin.Context) {\n\ttoken := middleware.ExtractToken(ctx)\n\tif len(token) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\t// if user is no login return null in data\n\tuserInfo, _ := uc.authService.GetUserCacheInfo(ctx, token)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetUserInfoByUserID(ctx, token, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// GetOtherUserInfoByUsername godoc\n// @Summary GetOtherUserInfoByUsername\n// @Description GetOtherUserInfoByUsername\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param username query string true \"username\"\n// @Success 200 {object} handler.RespBody{data=schema.GetOtherUserInfoResp}\n// @Router /answer/api/v1/personal/user/info [get]\nfunc (uc *UserController) GetOtherUserInfoByUsername(ctx *gin.Context) {\n\treq := &schema.GetOtherUserInfoByUsernameReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetOtherUserInfoByUsername(ctx, req.Username)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserEmailLogin godoc\n// @Summary UserEmailLogin\n// @Description UserEmailLogin\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserEmailLogin true \"UserEmailLogin\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/login/email [post]\nfunc (uc *UserController) UserEmailLogin(ctx *gin.Context) {\n\treq := &schema.UserEmailLogin{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.EmailLogin(ctx, req)\n\tif err != nil {\n\t\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.EmailOrPasswordWrong),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.EmailOrPasswordWrong), errFields)\n\t\treturn\n\t}\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\thandler.HandleResponse(ctx, nil, resp)\n}\n\n// RetrievePassWord godoc\n// @Summary RetrievePassWord\n// @Description RetrievePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRetrievePassWordRequest  true \"UserRetrievePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/reset [post]\nfunc (uc *UserController) RetrievePassWord(ctx *gin.Context) {\n\treq := &schema.UserRetrievePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\tcode, err := uc.userService.RetrievePassWord(ctx, req)\n\thandler.HandleResponse(ctx, err, code)\n}\n\n// UseRePassWord godoc\n// @Summary UseRePassWord\n// @Description UseRePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRePassWordRequest  true \"UserRePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/replacement [post]\nfunc (uc *UserController) UseRePassWord(ctx *gin.Context) {\n\treq := &schema.UserRePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UseRePassword(ctx, req)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserLogout user logout\n// @Summary user logout\n// @Description user logout\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/logout [get]\nfunc (uc *UserController) UserLogout(ctx *gin.Context) {\n\taccessToken := middleware.ExtractToken(ctx)\n\tif len(accessToken) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\t_ = uc.authService.RemoveUserCacheInfo(ctx, accessToken)\n\thandler.HandleResponse(ctx, nil, nil)\n}\n\n// UserRegisterByEmail godoc\n// @Summary UserRegisterByEmail\n// @Description UserRegisterByEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserRegisterReq true \"UserRegisterReq\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/email [post]\nfunc (uc *UserController) UserRegisterByEmail(ctx *gin.Context) {\n\t// check whether site allow register or not\n\tsiteInfo, err := uc.siteInfoCommonService.GetSiteLogin(ctx)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !siteInfo.AllowNewRegistrations {\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NotAllowedRegistration), nil)\n\t\treturn\n\t}\n\n\treq := &schema.UserRegisterReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\tcaptchaPass := uc.actionService.UserRegisterVerifyCaptcha(ctx, req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, errFields, err := uc.userService.UserRegisterByEmail(ctx, req)\n\tif len(errFields) > 0 {\n\t\tfor _, field := range errFields {\n\t\t\tfield.ErrorMsg = translator.\n\t\t\t\tTr(handler.GetLang(ctx), field.ErrorMsg)\n\t\t}\n\t\thandler.HandleResponse(ctx, err, errFields)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVerifyEmail godoc\n// @Summary UserVerifyEmail\n// @Description UserVerifyEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param code query string true \"code\" default()\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/email/verification [post]\nfunc (uc *UserController) UserVerifyEmail(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserVerifyEmail(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserVerifyEmailSend godoc\n// @Summary UserVerifyEmailSend\n// @Description UserVerifyEmailSend\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param captcha_id query string false \"captcha_id\"  default()\n// @Param captcha_code query string false \"captcha_code\"  default()\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/email/verification/send [post]\nfunc (uc *UserController) UserVerifyEmailSend(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailSendReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tuserInfo := middleware.GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(),\n\t\treq.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, err := uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\terr = uc.userService.UserVerifyEmailSend(ctx, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserModifyPassWord godoc\n// @Summary UserModifyPassWord\n// @Description UserModifyPassWord\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserModifyPassWordRequest  true \"UserModifyPassWordRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/password [put]\nfunc (uc *UserController) UserModifyPassWord(ctx *gin.Context) {\n\treq := &schema.UserModifyPassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\toldPassVerification, err := uc.userService.UserModifyPassWordVerification(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !oldPassVerification {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"old_pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.OldPasswordVerificationFailed), errFields)\n\t\treturn\n\t}\n\tif req.OldPass == req.Pass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.NewPasswordSameAsPreviousSetting),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NewPasswordSameAsPreviousSetting), errFields)\n\t\treturn\n\t}\n\terr = uc.userService.UserModifyPassword(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserUpdateInfo update user info\n// @Summary UserUpdateInfo update user info\n// @Description UserUpdateInfo update user info\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateInfoRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/info [put]\nfunc (uc *UserController) UserUpdateInfo(ctx *gin.Context) {\n\treq := &schema.UpdateInfoRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\terrFields, err := uc.userService.UpdateInfo(ctx, req)\n\tfor _, field := range errFields {\n\t\tfield.ErrorMsg = translator.Tr(handler.GetLang(ctx), field.ErrorMsg)\n\t}\n\thandler.HandleResponse(ctx, err, errFields)\n}\n\n// UserUpdateInterface update user interface config\n// @Summary UserUpdateInterface update user interface config\n// @Description UserUpdateInterface update user interface config\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateUserInterfaceRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/interface [put]\nfunc (uc *UserController) UserUpdateInterface(ctx *gin.Context) {\n\treq := &schema.UpdateUserInterfaceRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserId = middleware.GetLoginUserIDFromContext(ctx)\n\terr := uc.userService.UserUpdateInterface(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// ActionRecord godoc\n// @Summary ActionRecord\n// @Description ActionRecord\n// @Tags User\n// @Param action query string true \"action\" Enums(login, e_mail, find_pass)\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.ActionRecordResp}\n// @Router /answer/api/v1/user/action/record [get]\nfunc (uc *UserController) ActionRecord(ctx *gin.Context) {\n\treq := &schema.ActionRecordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\n\tresp, err := uc.actionService.ActionRecord(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRegisterCaptcha godoc\n// @Summary UserRegisterCaptcha\n// @Description UserRegisterCaptcha\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/captcha [get]\nfunc (uc *UserController) UserRegisterCaptcha(ctx *gin.Context) {\n\tresp, err := uc.actionService.UserRegisterCaptcha(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserNoticeSet godoc\n// @Summary UserNoticeSet\n// @Description UserNoticeSet\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserNoticeSetRequest true \"UserNoticeSetRequest\"\n// @Success 200 {object} handler.RespBody{data=schema.UserNoticeSetResp}\n// @Router /answer/api/v1/user/notice/set [post]\nfunc (uc *UserController) UserNoticeSet(ctx *gin.Context) {\n\treq := &schema.UserNoticeSetRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tresp, err := uc.userService.UserNoticeSet(ctx, req.UserID, req.NoticeSwitch)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserChangeEmailSendCode send email to the user email then change their email\n// @Summary send email to the user email then change their email\n// @Description send email to the user email then change their email\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserChangeEmailSendCodeReq true \"UserChangeEmailSendCodeReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/change/code [post]\nfunc (uc *UserController) UserChangeEmailSendCode(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailSendCodeReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\t// If the user is not logged in, the api cannot be used.\n\t// If the user email is not verified, that also can use this api to modify the email.\n\tif len(req.UserID) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tresp, err := uc.userService.UserChangeEmailSendCode(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t\treturn\n\t}\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserChangeEmailVerify user change email verification\n// @Summary user change email verification\n// @Description user change email verification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserChangeEmailVerifyReq true \"UserChangeEmailVerifyReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email [put]\nfunc (uc *UserController) UserChangeEmailVerify(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailVerifyReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserChangeEmailVerify(ctx, req.Content)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserRanking get user ranking\n// @Summary get user ranking\n// @Description get user ranking\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.UserRankingResp}\n// @Router /answer/api/v1/user/ranking [get]\nfunc (uc *UserController) UserRanking(ctx *gin.Context) {\n\tresp, err := uc.userService.UserRanking(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserUnsubscribeEmailNotification unsubscribe email notification\n// @Summary unsubscribe email notification\n// @Description unsubscribe email notification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/notification [put]\nfunc (uc *UserController) UserUnsubscribeEmailNotification(ctx *gin.Context) {\n\treq := &schema.UserUnsubscribeEmailNotificationReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserUnsubscribeEmailNotification(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n"], "fixing_code": ["package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/base/validator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\t\"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// UserController user controller\ntype UserController struct {\n\tuserService           *service.UserService\n\tauthService           *auth.AuthService\n\tactionService         *action.CaptchaService\n\tuploaderService       *uploader.UploaderService\n\temailService          *export.EmailService\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService\n}\n\n// NewUserController new controller\nfunc NewUserController(\n\tauthService *auth.AuthService,\n\tuserService *service.UserService,\n\tactionService *action.CaptchaService,\n\temailService *export.EmailService,\n\tuploaderService *uploader.UploaderService,\n\tsiteInfoCommonService *siteinfo_common.SiteInfoCommonService,\n) *UserController {\n\treturn &UserController{\n\t\tauthService:           authService,\n\t\tuserService:           userService,\n\t\tactionService:         actionService,\n\t\tuploaderService:       uploaderService,\n\t\temailService:          emailService,\n\t\tsiteInfoCommonService: siteInfoCommonService,\n\t}\n}\n\n// GetUserInfoByUserID get user info, if user no login response http code is 200, but user info is null\n// @Summary GetUserInfoByUserID\n// @Description get user info, if user no login response http code is 200, but user info is null\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.GetUserToSetShowResp}\n// @Router /answer/api/v1/user/info [get]\nfunc (uc *UserController) GetUserInfoByUserID(ctx *gin.Context) {\n\ttoken := middleware.ExtractToken(ctx)\n\tif len(token) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\t// if user is no login return null in data\n\tuserInfo, _ := uc.authService.GetUserCacheInfo(ctx, token)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetUserInfoByUserID(ctx, token, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// GetOtherUserInfoByUsername godoc\n// @Summary GetOtherUserInfoByUsername\n// @Description GetOtherUserInfoByUsername\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param username query string true \"username\"\n// @Success 200 {object} handler.RespBody{data=schema.GetOtherUserInfoResp}\n// @Router /answer/api/v1/personal/user/info [get]\nfunc (uc *UserController) GetOtherUserInfoByUsername(ctx *gin.Context) {\n\treq := &schema.GetOtherUserInfoByUsernameReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.GetOtherUserInfoByUsername(ctx, req.Username)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserEmailLogin godoc\n// @Summary UserEmailLogin\n// @Description UserEmailLogin\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserEmailLogin true \"UserEmailLogin\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/login/email [post]\nfunc (uc *UserController) UserEmailLogin(ctx *gin.Context) {\n\treq := &schema.UserEmailLogin{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.EmailLogin(ctx, req)\n\tif err != nil {\n\t\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"e_mail\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.EmailOrPasswordWrong),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.EmailOrPasswordWrong), errFields)\n\t\treturn\n\t}\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeLogin, ctx.ClientIP())\n\thandler.HandleResponse(ctx, nil, resp)\n}\n\n// RetrievePassWord godoc\n// @Summary RetrievePassWord\n// @Description RetrievePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRetrievePassWordRequest  true \"UserRetrievePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/reset [post]\nfunc (uc *UserController) RetrievePassWord(ctx *gin.Context) {\n\treq := &schema.UserRetrievePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\t_, err := uc.userService.RetrievePassWord(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UseRePassWord godoc\n// @Summary UseRePassWord\n// @Description UseRePassWord\n// @Tags User\n// @Accept  json\n// @Produce  json\n// @Param data body schema.UserRePassWordRequest  true \"UserRePassWordRequest\"\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/password/replacement [post]\nfunc (uc *UserController) UseRePassWord(ctx *gin.Context) {\n\treq := &schema.UserRePassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UseRePassword(ctx, req)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeFindPass, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserLogout user logout\n// @Summary user logout\n// @Description user logout\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/logout [get]\nfunc (uc *UserController) UserLogout(ctx *gin.Context) {\n\taccessToken := middleware.ExtractToken(ctx)\n\tif len(accessToken) == 0 {\n\t\thandler.HandleResponse(ctx, nil, nil)\n\t\treturn\n\t}\n\t_ = uc.authService.RemoveUserCacheInfo(ctx, accessToken)\n\thandler.HandleResponse(ctx, nil, nil)\n}\n\n// UserRegisterByEmail godoc\n// @Summary UserRegisterByEmail\n// @Description UserRegisterByEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserRegisterReq true \"UserRegisterReq\"\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/email [post]\nfunc (uc *UserController) UserRegisterByEmail(ctx *gin.Context) {\n\t// check whether site allow register or not\n\tsiteInfo, err := uc.siteInfoCommonService.GetSiteLogin(ctx)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !siteInfo.AllowNewRegistrations {\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NotAllowedRegistration), nil)\n\t\treturn\n\t}\n\n\treq := &schema.UserRegisterReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\tcaptchaPass := uc.actionService.UserRegisterVerifyCaptcha(ctx, req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\n\tresp, errFields, err := uc.userService.UserRegisterByEmail(ctx, req)\n\tif len(errFields) > 0 {\n\t\tfor _, field := range errFields {\n\t\t\tfield.ErrorMsg = translator.\n\t\t\t\tTr(handler.GetLang(ctx), field.ErrorMsg)\n\t\t}\n\t\thandler.HandleResponse(ctx, err, errFields)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVerifyEmail godoc\n// @Summary UserVerifyEmail\n// @Description UserVerifyEmail\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param code query string true \"code\" default()\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/email/verification [post]\nfunc (uc *UserController) UserVerifyEmail(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\tresp, err := uc.userService.UserVerifyEmail(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserVerifyEmailSend godoc\n// @Summary UserVerifyEmailSend\n// @Description UserVerifyEmailSend\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param captcha_id query string false \"captcha_id\"  default()\n// @Param captcha_code query string false \"captcha_code\"  default()\n// @Success 200 {string} string \"\"\n// @Router /answer/api/v1/user/email/verification/send [post]\nfunc (uc *UserController) UserVerifyEmailSend(ctx *gin.Context) {\n\treq := &schema.UserVerifyEmailSendReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\tuserInfo := middleware.GetUserInfoFromContext(ctx)\n\tif userInfo == nil {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(),\n\t\treq.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, err := uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\terr = uc.userService.UserVerifyEmailSend(ctx, userInfo.UserID)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserModifyPassWord godoc\n// @Summary UserModifyPassWord\n// @Description UserModifyPassWord\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserModifyPassWordRequest  true \"UserModifyPassWordRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/password [put]\nfunc (uc *UserController) UserModifyPassWord(ctx *gin.Context) {\n\treq := &schema.UserModifyPassWordRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\toldPassVerification, err := uc.userService.UserModifyPassWordVerification(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !oldPassVerification {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"old_pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.OldPasswordVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.OldPasswordVerificationFailed), errFields)\n\t\treturn\n\t}\n\tif req.OldPass == req.Pass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"pass\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.NewPasswordSameAsPreviousSetting),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.NewPasswordSameAsPreviousSetting), errFields)\n\t\treturn\n\t}\n\terr = uc.userService.UserModifyPassword(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserUpdateInfo update user info\n// @Summary UserUpdateInfo update user info\n// @Description UserUpdateInfo update user info\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateInfoRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/info [put]\nfunc (uc *UserController) UserUpdateInfo(ctx *gin.Context) {\n\treq := &schema.UpdateInfoRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\terrFields, err := uc.userService.UpdateInfo(ctx, req)\n\tfor _, field := range errFields {\n\t\tfield.ErrorMsg = translator.Tr(handler.GetLang(ctx), field.ErrorMsg)\n\t}\n\thandler.HandleResponse(ctx, err, errFields)\n}\n\n// UserUpdateInterface update user interface config\n// @Summary UserUpdateInterface update user interface config\n// @Description UserUpdateInterface update user interface config\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param Authorization header string true \"access-token\"\n// @Param data body schema.UpdateUserInterfaceRequest true \"UpdateInfoRequest\"\n// @Success 200 {object} handler.RespBody\n// @Router /answer/api/v1/user/interface [put]\nfunc (uc *UserController) UserUpdateInterface(ctx *gin.Context) {\n\treq := &schema.UpdateUserInterfaceRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserId = middleware.GetLoginUserIDFromContext(ctx)\n\terr := uc.userService.UserUpdateInterface(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// ActionRecord godoc\n// @Summary ActionRecord\n// @Description ActionRecord\n// @Tags User\n// @Param action query string true \"action\" Enums(login, e_mail, find_pass)\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.ActionRecordResp}\n// @Router /answer/api/v1/user/action/record [get]\nfunc (uc *UserController) ActionRecord(ctx *gin.Context) {\n\treq := &schema.ActionRecordReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.IP = ctx.ClientIP()\n\n\tresp, err := uc.actionService.ActionRecord(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserRegisterCaptcha godoc\n// @Summary UserRegisterCaptcha\n// @Description UserRegisterCaptcha\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{data=schema.GetUserResp}\n// @Router /answer/api/v1/user/register/captcha [get]\nfunc (uc *UserController) UserRegisterCaptcha(ctx *gin.Context) {\n\tresp, err := uc.actionService.UserRegisterCaptcha(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserNoticeSet godoc\n// @Summary UserNoticeSet\n// @Description UserNoticeSet\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserNoticeSetRequest true \"UserNoticeSetRequest\"\n// @Success 200 {object} handler.RespBody{data=schema.UserNoticeSetResp}\n// @Router /answer/api/v1/user/notice/set [post]\nfunc (uc *UserController) UserNoticeSet(ctx *gin.Context) {\n\treq := &schema.UserNoticeSetRequest{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tresp, err := uc.userService.UserNoticeSet(ctx, req.UserID, req.NoticeSwitch)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserChangeEmailSendCode send email to the user email then change their email\n// @Summary send email to the user email then change their email\n// @Description send email to the user email then change their email\n// @Tags User\n// @Accept json\n// @Produce json\n// @Param data body schema.UserChangeEmailSendCodeReq true \"UserChangeEmailSendCodeReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/change/code [post]\nfunc (uc *UserController) UserChangeEmailSendCode(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailSendCodeReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\t// If the user is not logged in, the api cannot be used.\n\t// If the user email is not verified, that also can use this api to modify the email.\n\tif len(req.UserID) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Unauthorized(reason.UnauthorizedError), nil)\n\t\treturn\n\t}\n\n\tcaptchaPass := uc.actionService.ActionRecordVerifyCaptcha(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP(), req.CaptchaID, req.CaptchaCode)\n\tif !captchaPass {\n\t\terrFields := append([]*validator.FormErrorField{}, &validator.FormErrorField{\n\t\t\tErrorField: \"captcha_code\",\n\t\t\tErrorMsg:   translator.Tr(handler.GetLang(ctx), reason.CaptchaVerificationFailed),\n\t\t})\n\t\thandler.HandleResponse(ctx, errors.BadRequest(reason.CaptchaVerificationFailed), errFields)\n\t\treturn\n\t}\n\t_, _ = uc.actionService.ActionRecordAdd(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\tresp, err := uc.userService.UserChangeEmailSendCode(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t\treturn\n\t}\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserChangeEmailVerify user change email verification\n// @Summary user change email verification\n// @Description user change email verification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.UserChangeEmailVerifyReq true \"UserChangeEmailVerifyReq\"\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email [put]\nfunc (uc *UserController) UserChangeEmailVerify(ctx *gin.Context) {\n\treq := &schema.UserChangeEmailVerifyReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserChangeEmailVerify(ctx, req.Content)\n\tuc.actionService.ActionRecordDel(ctx, schema.ActionRecordTypeEmail, ctx.ClientIP())\n\thandler.HandleResponse(ctx, err, nil)\n}\n\n// UserRanking get user ranking\n// @Summary get user ranking\n// @Description get user ranking\n// @Tags User\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Success 200 {object} handler.RespBody{data=schema.UserRankingResp}\n// @Router /answer/api/v1/user/ranking [get]\nfunc (uc *UserController) UserRanking(ctx *gin.Context) {\n\tresp, err := uc.userService.UserRanking(ctx)\n\thandler.HandleResponse(ctx, err, resp)\n}\n\n// UserUnsubscribeEmailNotification unsubscribe email notification\n// @Summary unsubscribe email notification\n// @Description unsubscribe email notification\n// @Tags User\n// @Accept json\n// @Produce json\n// @Success 200 {object} handler.RespBody{}\n// @Router /answer/api/v1/user/email/notification [put]\nfunc (uc *UserController) UserUnsubscribeEmailNotification(ctx *gin.Context) {\n\treq := &schema.UserUnsubscribeEmailNotificationReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\n\treq.Content = uc.emailService.VerifyUrlExpired(ctx, req.Code)\n\tif len(req.Content) == 0 {\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.EmailVerifyURLExpired),\n\t\t\t&schema.ForbiddenResp{Type: schema.ForbiddenReasonTypeURLExpired})\n\t\treturn\n\t}\n\n\terr := uc.userService.UserUnsubscribeEmailNotification(ctx, req)\n\thandler.HandleResponse(ctx, err, nil)\n}\n"], "filenames": ["internal/controller/user_controller.go"], "buggy_code_start_loc": [160], "buggy_code_end_loc": [162], "fixing_code_start_loc": [160], "fixing_code_end_loc": [162], "type": "CWE-284", "message": "Improper Access Control in GitHub repository answerdev/answer prior to 1.0.4.", "other": {"cve": {"id": "CVE-2023-0744", "sourceIdentifier": "security@huntr.dev", "published": "2023-02-08T08:15:08.537", "lastModified": "2023-04-06T17:15:10.143", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository answerdev/answer prior to 1.0.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.4", "matchCriteriaId": "6C25084E-B0C5-46D7-BDD3-E024EEB1E764"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/171733/Answerdev-1.0.3-Account-Takeover.html", "source": "security@huntr.dev"}, {"url": "https://github.com/answerdev/answer/commit/c1fa2b13f6b547b96da60b23350bbe2b29de542d", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/35a0e12f-1d54-4fc0-8779-6a4949b7c434", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/c1fa2b13f6b547b96da60b23350bbe2b29de542d"}}