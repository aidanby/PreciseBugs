{"buggy_code": ["/*\n * Copyright 2016 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.linecorp.armeria.internal.common;\n\nimport static com.google.common.collect.ImmutableSet.toImmutableSet;\nimport static io.netty.util.AsciiString.EMPTY_STRING;\nimport static io.netty.util.ByteProcessor.FIND_COMMA;\nimport static io.netty.util.internal.StringUtil.decodeHexNibble;\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.InetSocketAddress;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.function.BiConsumer;\n\nimport com.github.benmanes.caffeine.cache.Caffeine;\nimport com.github.benmanes.caffeine.cache.LoadingCache;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableSet;\n\nimport com.linecorp.armeria.common.Flags;\nimport com.linecorp.armeria.common.Http1HeaderNaming;\nimport com.linecorp.armeria.common.HttpData;\nimport com.linecorp.armeria.common.HttpHeaderNames;\nimport com.linecorp.armeria.common.HttpHeaders;\nimport com.linecorp.armeria.common.HttpHeadersBuilder;\nimport com.linecorp.armeria.common.HttpMethod;\nimport com.linecorp.armeria.common.HttpStatus;\nimport com.linecorp.armeria.common.RequestHeaders;\nimport com.linecorp.armeria.common.RequestHeadersBuilder;\nimport com.linecorp.armeria.common.ResponseHeaders;\nimport com.linecorp.armeria.common.ResponseHeadersBuilder;\nimport com.linecorp.armeria.common.annotation.Nullable;\nimport com.linecorp.armeria.common.util.Version;\nimport com.linecorp.armeria.internal.common.util.TemporaryThreadLocals;\nimport com.linecorp.armeria.server.ServerConfig;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.DefaultHeaders;\nimport io.netty.handler.codec.UnsupportedValueConverter;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.HttpConversionUtil;\nimport io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\nimport io.netty.util.AsciiString;\nimport io.netty.util.HashingStrategy;\nimport io.netty.util.internal.StringUtil;\n\n/**\n * Provides various utility functions for internal use related with HTTP.\n *\n * <p>The conversion between HTTP/1 and HTTP/2 has been forked from Netty's {@link HttpConversionUtil}.\n */\npublic final class ArmeriaHttpUtil {\n\n    // Forked from Netty 4.1.34 at 4921f62c8ab8205fd222439dcd1811760b05daf1\n\n    /**\n     * The default case-insensitive {@link AsciiString} hasher and comparator for HTTP/2 headers.\n     */\n    private static final HashingStrategy<AsciiString> HTTP2_HEADER_NAME_HASHER =\n            new HashingStrategy<AsciiString>() {\n                @Override\n                public int hashCode(AsciiString o) {\n                    return o.hashCode();\n                }\n\n                @Override\n                public boolean equals(AsciiString a, AsciiString b) {\n                    return a.contentEqualsIgnoreCase(b);\n                }\n            };\n\n    /**\n     * The default HTTP content-type charset.\n     *\n     * <p>Note that we use {@link StandardCharsets#UTF_8} as default because it is common practice even though\n     * it's not the HTTP standard.\n     */\n    public static final Charset HTTP_DEFAULT_CONTENT_CHARSET = StandardCharsets.UTF_8;\n\n    /**\n     * The old {@code \"proxy-connection\"} header which has been superceded by {@code \"connection\"}.\n     */\n    public static final AsciiString HEADER_NAME_PROXY_CONNECTION = AsciiString.cached(\"proxy-connection\");\n\n    /**\n     * The set of headers that should not be directly copied when converting headers from HTTP/1 to HTTP/2.\n     */\n    private static final CaseInsensitiveMap HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST = new CaseInsensitiveMap();\n\n    /**\n     * The set of headers that should not be directly copied when converting headers from HTTP/2 to HTTP/1.\n     */\n    private static final CaseInsensitiveMap HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST = new CaseInsensitiveMap();\n\n    /**\n     * The set of headers that must not be directly copied when converting trailers.\n     */\n    private static final CaseInsensitiveMap HTTP_TRAILER_DISALLOWED_LIST = new CaseInsensitiveMap();\n\n    static {\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.CONNECTION, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.KEEP_ALIVE, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HEADER_NAME_PROXY_CONNECTION, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.TRANSFER_ENCODING, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.UPGRADE, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.STREAM_ID.text(), EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.SCHEME.text(), EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.PATH.text(), EMPTY_STRING);\n\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.AUTHORITY, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.METHOD, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.PATH, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.SCHEME, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.STATUS, EMPTY_STRING);\n\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1\n        // The \"chunked\" transfer encoding defined in Section 4.1 of [RFC7230] MUST NOT be used in HTTP/2.\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.TRANSFER_ENCODING, EMPTY_STRING);\n\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.STREAM_ID.text(), EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.SCHEME.text(), EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.PATH.text(), EMPTY_STRING);\n\n        // https://datatracker.ietf.org/doc/html/rfc7230#section-4.1.2\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1\n        // A sender MUST NOT generate a trailer that contains a field necessary for message framing:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.TRANSFER_ENCODING, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_LENGTH, EMPTY_STRING);\n\n        // for request modifiers:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CACHE_CONTROL, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.EXPECT, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.HOST, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.MAX_FORWARDS, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.PRAGMA, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.RANGE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.TE, EMPTY_STRING);\n\n        // for authentication:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.WWW_AUTHENTICATE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.AUTHORIZATION, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.PROXY_AUTHENTICATE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.PROXY_AUTHORIZATION, EMPTY_STRING);\n\n        // for response control data:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.DATE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.LOCATION, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.RETRY_AFTER, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.VARY, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.WARNING, EMPTY_STRING);\n\n        // or for determining how to process the payload:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_ENCODING, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_TYPE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_RANGE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.TRAILER, EMPTY_STRING);\n    }\n\n    static final Set<AsciiString> ADDITIONAL_REQUEST_HEADER_DISALLOWED_LIST = ImmutableSet.of(\n            HttpHeaderNames.SCHEME, HttpHeaderNames.STATUS, HttpHeaderNames.METHOD, HttpHeaderNames.AUTHORITY);\n\n    private static final Set<AsciiString> REQUEST_PSEUDO_HEADERS = ImmutableSet.of(\n            HttpHeaderNames.METHOD, HttpHeaderNames.SCHEME, HttpHeaderNames.AUTHORITY,\n            HttpHeaderNames.PATH, HttpHeaderNames.PROTOCOL);\n\n    private static final Set<AsciiString> PSEUDO_HEADERS = ImmutableSet.<AsciiString>builder()\n                                                                       .addAll(REQUEST_PSEUDO_HEADERS)\n                                                                       .add(HttpHeaderNames.STATUS)\n                                                                       .build();\n\n    public static final String SERVER_HEADER =\n            \"Armeria/\" + Version.get(\"armeria\", ArmeriaHttpUtil.class.getClassLoader())\n                                .artifactVersion();\n\n    /**\n     * Translations from HTTP/2 header name to the HTTP/1.x equivalent. Currently, we expect these headers to\n     * only allow a single value in the request. If adding headers that can potentially have multiple values,\n     * please check the usage in code accordingly.\n     */\n    private static final CaseInsensitiveMap REQUEST_HEADER_TRANSLATIONS = new CaseInsensitiveMap();\n\n    static {\n        REQUEST_HEADER_TRANSLATIONS.add(Http2Headers.PseudoHeaderName.AUTHORITY.value(),\n                                        HttpHeaderNames.HOST);\n    }\n\n    /**\n     * <a href=\"https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\">rfc7540, 8.1.2.3</a> states the path must not\n     * be empty, and instead should be {@code /}.\n     */\n    private static final String EMPTY_REQUEST_PATH = \"/\";\n\n    private static final Splitter COOKIE_SPLITTER = Splitter.on(';').trimResults().omitEmptyStrings();\n    private static final String COOKIE_SEPARATOR = \"; \";\n    private static final Joiner COOKIE_JOINER = Joiner.on(COOKIE_SEPARATOR);\n\n    @Nullable\n    private static final LoadingCache<AsciiString, String> HEADER_VALUE_CACHE =\n            Flags.headerValueCacheSpec() != null ? buildCache(Flags.headerValueCacheSpec()) : null;\n    private static final Set<AsciiString> CACHED_HEADERS = Flags.cachedHeaders().stream().map(AsciiString::of)\n                                                                .collect(toImmutableSet());\n\n    private static LoadingCache<AsciiString, String> buildCache(String spec) {\n        return Caffeine.from(spec).build(AsciiString::toString);\n    }\n\n    /**\n     * Concatenates two path strings.\n     */\n    public static String concatPaths(@Nullable String path1, @Nullable String path2) {\n        path2 = path2 == null ? \"\" : path2;\n\n        if (path1 == null || path1.isEmpty() || EMPTY_REQUEST_PATH.equals(path1)) {\n            if (path2.isEmpty()) {\n                return EMPTY_REQUEST_PATH;\n            }\n\n            if (path2.charAt(0) == '/') {\n                return path2; // Most requests will land here.\n            }\n\n            return '/' + path2;\n        }\n\n        // At this point, we are sure path1 is neither empty nor null.\n        if (path2.isEmpty()) {\n            // Only path1 is non-empty. No need to concatenate.\n            return path1;\n        }\n\n        if (path1.charAt(path1.length() - 1) == '/') {\n            if (path2.charAt(0) == '/') {\n                // path1 ends with '/' and path2 starts with '/'.\n                // Avoid double-slash by stripping the first slash of path2.\n                return new StringBuilder(path1.length() + path2.length() - 1)\n                        .append(path1).append(path2, 1, path2.length()).toString();\n            }\n\n            // path1 ends with '/' and path2 does not start with '/'.\n            // Simple concatenation would suffice.\n            return path1 + path2;\n        }\n\n        if (path2.charAt(0) == '/' || path2.charAt(0) == '?') {\n            // path1 does not end with '/' and path2 starts with '/' or '?'\n            // Simple concatenation would suffice.\n            return path1 + path2;\n        }\n\n        // path1 does not end with '/' and path2 does not start with '/' or '?'.\n        // Need to insert '/' between path1 and path2.\n        return path1 + '/' + path2;\n    }\n\n    /**\n     * Decodes a percent-encoded path string.\n     */\n    public static String decodePath(String path) {\n        if (path.indexOf('%') < 0) {\n            // No need to decoded; not percent-encoded\n            return path;\n        }\n\n        // Decode percent-encoded characters.\n        // An invalid character is replaced with 0xFF, which will be replaced into '\ufffd' by UTF-8 decoder.\n        final int len = path.length();\n        try (TemporaryThreadLocals tempThreadLocals = TemporaryThreadLocals.acquire()) {\n            final byte[] buf = tempThreadLocals.byteArray(len);\n            int dstLen = 0;\n            for (int i = 0; i < len; i++) {\n                final char ch = path.charAt(i);\n                if (ch != '%') {\n                    buf[dstLen++] = (byte) ((ch & 0xFF80) == 0 ? ch : 0xFF);\n                    continue;\n                }\n\n                // Decode a percent-encoded character.\n                final int hexEnd = i + 3;\n                if (hexEnd > len) {\n                    // '%' or '%x' (must be followed by two hexadigits)\n                    buf[dstLen++] = (byte) 0xFF;\n                    break;\n                }\n\n                final int digit1 = decodeHexNibble(path.charAt(++i));\n                final int digit2 = decodeHexNibble(path.charAt(++i));\n                if (digit1 < 0 || digit2 < 0) {\n                    // The first or second digit is not hexadecimal.\n                    buf[dstLen++] = (byte) 0xFF;\n                } else {\n                    buf[dstLen++] = (byte) ((digit1 << 4) | digit2);\n                }\n            }\n\n            return new String(buf, 0, dstLen, StandardCharsets.UTF_8);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the specified {@code path} is an absolute {@code URI}.\n     */\n    public static boolean isAbsoluteUri(@Nullable String maybeUri) {\n        if (maybeUri == null) {\n            return false;\n        }\n        final int firstColonIdx = maybeUri.indexOf(':');\n        if (firstColonIdx <= 0 || firstColonIdx + 3 >= maybeUri.length()) {\n            return false;\n        }\n        final int firstSlashIdx = maybeUri.indexOf('/');\n        if (firstSlashIdx <= 0 || firstSlashIdx < firstColonIdx) {\n            return false;\n        }\n\n        return maybeUri.charAt(firstColonIdx + 1) == '/' && maybeUri.charAt(firstColonIdx + 2) == '/';\n    }\n\n    /**\n     * Returns {@code true} if the specified HTTP status string represents an informational status.\n     */\n    public static boolean isInformational(@Nullable String statusText) {\n        return statusText != null && !statusText.isEmpty() && statusText.charAt(0) == '1';\n    }\n\n    /**\n     * Returns {@code true} if the content of the response with the given {@link HttpStatus} is one of\n     * {@link HttpStatus#NO_CONTENT}, {@link HttpStatus#RESET_CONTENT} and {@link HttpStatus#NOT_MODIFIED}.\n     *\n     * @throws IllegalArgumentException if the specified {@code content} is not empty when the specified\n     *                                  {@link HttpStatus} is one of {@link HttpStatus#NO_CONTENT},\n     *                                  {@link HttpStatus#RESET_CONTENT} and {@link HttpStatus#NOT_MODIFIED}.\n     */\n    public static boolean isContentAlwaysEmptyWithValidation(HttpStatus status, HttpData content) {\n        if (!status.isContentAlwaysEmpty()) {\n            return false;\n        }\n\n        if (!content.isEmpty()) {\n            throw new IllegalArgumentException(\n                    \"A \" + status + \" response must have empty content: \" + content.length() + \" byte(s)\");\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns {@code true} if the specified {@code request} is a CORS preflight request.\n     */\n    public static boolean isCorsPreflightRequest(com.linecorp.armeria.common.HttpRequest request) {\n        requireNonNull(request, \"request\");\n        return request.method() == HttpMethod.OPTIONS &&\n               request.headers().contains(HttpHeaderNames.ORIGIN) &&\n               request.headers().contains(HttpHeaderNames.ACCESS_CONTROL_REQUEST_METHOD);\n    }\n\n    /**\n     * Returns the disallowed response headers.\n     */\n    @VisibleForTesting\n    static Set<AsciiString> disallowedResponseHeaderNames() {\n        // Request Pseudo-Headers are not allowed for response headers.\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\n        return REQUEST_PSEUDO_HEADERS;\n    }\n\n    /**\n     * Parses the specified HTTP header directives and invokes the specified {@code callback}\n     * with the directive names and values.\n     */\n    public static void parseDirectives(String directives, BiConsumer<String, String> callback) {\n        final int len = directives.length();\n        for (int i = 0; i < len;) {\n            final int nameStart = i;\n            final String name;\n            final String value;\n\n            // Find the name.\n            for (; i < len; i++) {\n                final char ch = directives.charAt(i);\n                if (ch == ',' || ch == '=') {\n                    break;\n                }\n            }\n            name = directives.substring(nameStart, i).trim();\n\n            // Find the value.\n            if (i == len || directives.charAt(i) == ',') {\n                // Skip comma or go beyond 'len' to break the loop.\n                i++;\n                value = null;\n            } else {\n                // Skip '='.\n                i++;\n\n                // Skip whitespaces.\n                for (; i < len; i++) {\n                    final char ch = directives.charAt(i);\n                    if (ch != ' ' && ch != '\\t') {\n                        break;\n                    }\n                }\n\n                if (i < len && directives.charAt(i) == '\\\"') {\n                    // Handle quoted string.\n                    // Skip the opening quote.\n                    i++;\n                    final int valueStart = i;\n\n                    // Find the closing quote.\n                    for (; i < len; i++) {\n                        if (directives.charAt(i) == '\\\"') {\n                            break;\n                        }\n                    }\n                    value = directives.substring(valueStart, i);\n\n                    // Skip the closing quote.\n                    i++;\n\n                    // Find the comma and skip it.\n                    for (; i < len; i++) {\n                        if (directives.charAt(i) == ',') {\n                            i++;\n                            break;\n                        }\n                    }\n                } else {\n                    // Handle unquoted string.\n                    final int valueStart = i;\n\n                    // Find the comma.\n                    for (; i < len; i++) {\n                        if (directives.charAt(i) == ',') {\n                            break;\n                        }\n                    }\n                    value = directives.substring(valueStart, i).trim();\n\n                    // Skip the comma.\n                    i++;\n                }\n            }\n\n            if (!name.isEmpty()) {\n                callback.accept(Ascii.toLowerCase(name), Strings.emptyToNull(value));\n            }\n        }\n    }\n\n    /**\n     * Converts the specified HTTP header directive value into a long integer.\n     *\n     * @return the converted value if {@code value} is equal to or greater than {@code 0}.\n     *         {@code -1} otherwise, i.e. if a negative integer or not a number.\n     */\n    public static long parseDirectiveValueAsSeconds(@Nullable String value) {\n        if (value == null) {\n            return -1;\n        }\n\n        try {\n            final long converted = Long.parseLong(value);\n            return converted >= 0 ? converted : -1;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n\n    /**\n     * Converts the specified Netty HTTP/2 into Armeria HTTP/2 {@link RequestHeaders}.\n     */\n    public static RequestHeaders toArmeriaRequestHeaders(ChannelHandlerContext ctx, Http2Headers headers,\n                                                         boolean endOfStream, String scheme,\n                                                         ServerConfig cfg) {\n        assert headers instanceof ArmeriaHttp2Headers;\n        final HttpHeadersBuilder builder = ((ArmeriaHttp2Headers) headers).delegate();\n        builder.endOfStream(endOfStream);\n        // A CONNECT request might not have \":scheme\". See https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\n        if (!builder.contains(HttpHeaderNames.SCHEME)) {\n            builder.add(HttpHeaderNames.SCHEME, scheme);\n        }\n\n        if (builder.get(HttpHeaderNames.AUTHORITY) == null && builder.get(HttpHeaderNames.HOST) == null) {\n            final String defaultHostname = cfg.defaultVirtualHost().defaultHostname();\n            final int port = ((InetSocketAddress) ctx.channel().localAddress()).getPort();\n            builder.add(HttpHeaderNames.AUTHORITY, defaultHostname + ':' + port);\n        }\n        final List<String> cookies = builder.getAll(HttpHeaderNames.COOKIE);\n        if (cookies.size() > 1) {\n            // Cookies must be concatenated into a single octet string.\n            // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n            builder.set(HttpHeaderNames.COOKIE, COOKIE_JOINER.join(cookies));\n        }\n        return RequestHeaders.of(builder.build());\n    }\n\n    /**\n     * Converts the specified Netty HTTP/2 into Armeria HTTP/2 headers.\n     */\n    public static HttpHeaders toArmeria(Http2Headers http2Headers, boolean request, boolean endOfStream) {\n        assert http2Headers instanceof ArmeriaHttp2Headers;\n        final HttpHeadersBuilder delegate = ((ArmeriaHttp2Headers) http2Headers).delegate();\n        delegate.endOfStream(endOfStream);\n        HttpHeaders headers = delegate.build();\n\n        if (request) {\n            if (headers.contains(HttpHeaderNames.METHOD)) {\n                headers = RequestHeaders.of(headers);\n            }\n            // http2Headers should be a trailers\n        } else {\n            if (headers.contains(HttpHeaderNames.STATUS)) {\n                headers = ResponseHeaders.of(headers);\n            }\n        }\n        return headers;\n    }\n\n    /**\n     * Converts the headers of the given Netty HTTP/1.x request into Armeria HTTP/2 headers.\n     * The following headers are only used if they can not be found in the {@code HOST} header or the\n     * {@code Request-Line} as defined by <a href=\"https://datatracker.ietf.org/doc/rfc7230/\">rfc7230</a>\n     * <ul>\n     * <li>{@link ExtensionHeaderNames#SCHEME}</li>\n     * </ul>\n     * {@link ExtensionHeaderNames#PATH} is ignored and instead extracted from the {@code Request-Line}.\n     */\n    public static RequestHeaders toArmeria(ChannelHandlerContext ctx, HttpRequest in,\n                                           ServerConfig cfg, String scheme) throws URISyntaxException {\n\n        final String path = in.uri();\n        if (path.charAt(0) != '/' && !\"*\".equals(path)) {\n            // We support only origin form and asterisk form.\n            throw new URISyntaxException(path, \"neither origin form nor asterisk form\");\n        }\n\n        final io.netty.handler.codec.http.HttpHeaders inHeaders = in.headers();\n        final RequestHeadersBuilder out = RequestHeaders.builder();\n        out.sizeHint(inHeaders.size());\n        out.method(HttpMethod.valueOf(in.method().name()))\n           .path(path)\n           .scheme(scheme);\n\n        // Add the HTTP headers which have not been consumed above\n        toArmeria(inHeaders, out);\n        if (!out.contains(HttpHeaderNames.HOST)) {\n            // The client violates the spec that the request headers must contain a Host header.\n            // But we just add Host header to allow the request.\n            // https://datatracker.ietf.org/doc/html/rfc7230#section-5.4\n            final String defaultHostname = cfg.defaultVirtualHost().defaultHostname();\n            final int port = ((InetSocketAddress) ctx.channel().localAddress()).getPort();\n            out.add(HttpHeaderNames.HOST, defaultHostname + ':' + port);\n        }\n        return out.build();\n    }\n\n    /**\n     * Converts the headers of the given Netty HTTP/1.x response into Armeria HTTP/2 headers.\n     */\n    public static ResponseHeaders toArmeria(HttpResponse in) {\n        final io.netty.handler.codec.http.HttpHeaders inHeaders = in.headers();\n        final ResponseHeadersBuilder out = ResponseHeaders.builder();\n        out.sizeHint(inHeaders.size());\n        out.status(HttpStatus.valueOf(in.status().code()));\n        // Add the HTTP headers which have not been consumed above\n        toArmeria(inHeaders, out);\n        return out.build();\n    }\n\n    /**\n     * Converts the specified Netty HTTP/1 headers into Armeria HTTP/2 headers.\n     */\n    public static HttpHeaders toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders) {\n        if (inHeaders.isEmpty()) {\n            return HttpHeaders.of();\n        }\n\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        out.sizeHint(inHeaders.size());\n        toArmeria(inHeaders, out);\n        return out.build();\n    }\n\n    /**\n     * Converts the specified Netty HTTP/1 headers into Armeria HTTP/2 headers.\n     */\n    public static void toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders, HttpHeadersBuilder out) {\n        final Iterator<Entry<CharSequence, CharSequence>> iter = inHeaders.iteratorCharSequence();\n        // Choose 8 as a default size because it is unlikely we will see more than 4 Connection headers values,\n        // but still allowing for \"enough\" space in the map to reduce the chance of hash code collision.\n        final CaseInsensitiveMap connectionDisallowedList =\n                toLowercaseMap(inHeaders.valueCharSequenceIterator(HttpHeaderNames.CONNECTION), 8);\n        StringJoiner cookieJoiner = null;\n        while (iter.hasNext()) {\n            final Entry<CharSequence, CharSequence> entry = iter.next();\n            final AsciiString aName = HttpHeaderNames.of(entry.getKey()).toLowerCase();\n            if (HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.contains(aName) ||\n                connectionDisallowedList.contains(aName)) {\n                continue;\n            }\n\n            // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.2 makes a special exception for TE\n            if (aName.equals(HttpHeaderNames.TE)) {\n                toHttp2HeadersFilterTE(entry, out);\n                continue;\n            }\n\n            // Cookies must be concatenated into a single octet string.\n            // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n            final CharSequence value = entry.getValue();\n            if (aName.equals(HttpHeaderNames.COOKIE)) {\n                if (cookieJoiner == null) {\n                    cookieJoiner = new StringJoiner(COOKIE_SEPARATOR);\n                }\n                COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n            } else {\n                out.add(aName, convertHeaderValue(aName, value));\n            }\n        }\n\n        if (cookieJoiner != null && cookieJoiner.length() != 0) {\n            out.add(HttpHeaderNames.COOKIE, cookieJoiner.toString());\n        }\n    }\n\n    private static CaseInsensitiveMap toLowercaseMap(Iterator<? extends CharSequence> valuesIter,\n                                                     int arraySizeHint) {\n        final CaseInsensitiveMap result = new CaseInsensitiveMap(arraySizeHint);\n\n        while (valuesIter.hasNext()) {\n            final AsciiString lowerCased = AsciiString.of(valuesIter.next()).toLowerCase();\n            try {\n                int index = lowerCased.forEachByte(FIND_COMMA);\n                if (index != -1) {\n                    int start = 0;\n                    do {\n                        result.add(lowerCased.subSequence(start, index, false).trim(), EMPTY_STRING);\n                        start = index + 1;\n                    } while (start < lowerCased.length() &&\n                             (index = lowerCased.forEachByte(start,\n                                                             lowerCased.length() - start, FIND_COMMA)) != -1);\n                    result.add(lowerCased.subSequence(start, lowerCased.length(), false).trim(), EMPTY_STRING);\n                } else {\n                    result.add(lowerCased.trim(), EMPTY_STRING);\n                }\n            } catch (Exception e) {\n                // This is not expect to happen because FIND_COMMA never throws but must be caught\n                // because of the ByteProcessor interface.\n                throw new IllegalStateException(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Filter the {@link HttpHeaderNames#TE} header according to the\n     * <a href=\"https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.2\">special rules in the HTTP/2 RFC</a>.\n     *\n     * @param entry the entry whose name is {@link HttpHeaderNames#TE}.\n     * @param out the resulting HTTP/2 headers.\n     */\n    private static void toHttp2HeadersFilterTE(Entry<CharSequence, CharSequence> entry,\n                                               HttpHeadersBuilder out) {\n        if (AsciiString.indexOf(entry.getValue(), ',', 0) == -1) {\n            if (AsciiString.contentEqualsIgnoreCase(AsciiString.trim(entry.getValue()),\n                                                    HttpHeaderValues.TRAILERS)) {\n                out.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS.toString());\n            }\n        } else {\n            final List<CharSequence> teValues = StringUtil.unescapeCsvFields(entry.getValue());\n            for (CharSequence teValue : teValues) {\n                if (AsciiString.contentEqualsIgnoreCase(AsciiString.trim(teValue),\n                                                        HttpHeaderValues.TRAILERS)) {\n                    out.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS.toString());\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 {@link ResponseHeaders} into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 response headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ServerHeaders(HttpHeadersBuilder inputHeaders) {\n        for (Entry<AsciiString, AsciiString> disallowed : HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST) {\n            inputHeaders.remove(disallowed.getKey());\n        }\n        // TODO(ikhoon): Implement HttpHeadersBuilder.remove(Predicate<AsciiString>) to remove values\n        //               with a predicate.\n        for (AsciiString disallowed : disallowedResponseHeaderNames()) {\n            inputHeaders.remove(disallowed);\n        }\n        return new ArmeriaHttp2Headers(inputHeaders);\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 response headers into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 response headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ServerTrailers(HttpHeaders inputHeaders) {\n        final HttpHeadersBuilder builder = inputHeaders.toBuilder();\n\n        for (Entry<AsciiString, AsciiString> disallowed : HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST) {\n            builder.remove(disallowed.getKey());\n        }\n        for (AsciiString disallowed : PSEUDO_HEADERS) {\n           builder.remove(disallowed);\n        }\n        for (Entry<AsciiString, AsciiString> disallowed : HTTP_TRAILER_DISALLOWED_LIST) {\n            builder.remove(disallowed.getKey());\n        }\n\n        return new ArmeriaHttp2Headers(builder);\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ClientHeaders(HttpHeaders inputHeaders) {\n        final int headerSizeHint = inputHeaders.size() + 3; // User_Agent, :scheme and :authority.\n        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n        toNettyHttp2Client(inputHeaders, outputHeaders, false);\n        return outputHeaders;\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ClientTrailers(HttpHeaders inputHeaders) {\n        final int headerSizeHint = inputHeaders.size();\n        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n        toNettyHttp2Client(inputHeaders, outputHeaders, true);\n        return outputHeaders;\n    }\n\n    private static void toNettyHttp2Client(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n                                           boolean isTrailer) {\n        for (Entry<AsciiString, String> entry : inputHeaders) {\n            final AsciiString name = entry.getKey();\n            final String value = entry.getValue();\n            if (HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.contains(name)) {\n                continue;\n            }\n\n            if (isTrailer && isTrailerDisallowed(name)) {\n                continue;\n            }\n\n            outputHeaders.add(name, value);\n        }\n\n        if (!outputHeaders.contains(HttpHeaderNames.COOKIE)) {\n            return;\n        }\n\n        // Split up cookies to allow for better compression.\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n        final List<CharSequence> cookies = outputHeaders.getAllAndRemove(HttpHeaderNames.COOKIE);\n        for (CharSequence c : cookies) {\n            outputHeaders.add(HttpHeaderNames.COOKIE, COOKIE_SPLITTER.split(c));\n        }\n    }\n\n    /**\n     * Translates and adds HTTP/2 response headers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders the HTTP/2 response headers to convert.\n     * @param outputHeaders the object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ServerHeaders(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Server(inputHeaders, outputHeaders, http1HeaderNaming, false);\n        HttpUtil.setKeepAlive(outputHeaders, HttpVersion.HTTP_1_1, true);\n    }\n\n    /**\n     * Translates and adds HTTP/2 response trailers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders The HTTP/2 response headers to convert.\n     * @param outputHeaders The object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ServerTrailers(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Server(inputHeaders, outputHeaders, http1HeaderNaming, true);\n    }\n\n    private static void toNettyHttp1Server(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming, boolean isTrailer) {\n        for (Entry<AsciiString, String> entry : inputHeaders) {\n            final AsciiString name = entry.getKey();\n            final String value = entry.getValue();\n            if (HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.contains(name)) {\n                continue;\n            }\n\n            if (isTrailer && isTrailerDisallowed(name)) {\n                continue;\n            }\n            outputHeaders.add(http1HeaderNaming.convert(name), value);\n        }\n    }\n\n    /**\n     * Translates and adds HTTP/2 request headers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     * @param outputHeaders the object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ClientHeaders(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Client(inputHeaders, outputHeaders, http1HeaderNaming, false);\n        HttpUtil.setKeepAlive(outputHeaders, HttpVersion.HTTP_1_1, true);\n    }\n\n    /**\n     * Translates and adds HTTP/2 request headers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     * @param outputHeaders the object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ClientTrailers(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Client(inputHeaders, outputHeaders, http1HeaderNaming, true);\n    }\n\n    private static void toNettyHttp1Client(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming, boolean isTrailer) {\n        StringJoiner cookieJoiner = null;\n\n        for (Entry<AsciiString, String> entry : inputHeaders) {\n            final AsciiString name = entry.getKey();\n            final String value = entry.getValue();\n            final AsciiString translatedName = REQUEST_HEADER_TRANSLATIONS.get(name);\n            if (translatedName != null && !inputHeaders.contains(translatedName)) {\n                outputHeaders.add(translatedName, value);\n                continue;\n            }\n\n            if (HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.contains(name)) {\n                continue;\n            }\n\n            if (isTrailer && isTrailerDisallowed(name)) {\n                continue;\n            }\n\n            if (HttpHeaderNames.COOKIE.equals(name)) {\n                // combine the cookie values into 1 header entry.\n                // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n                if (cookieJoiner == null) {\n                    cookieJoiner = new StringJoiner(COOKIE_SEPARATOR);\n                }\n                COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n            } else {\n                outputHeaders.add(http1HeaderNaming.convert(name), value);\n            }\n        }\n\n        if (cookieJoiner != null && cookieJoiner.length() != 0) {\n            outputHeaders.add(HttpHeaderNames.COOKIE, cookieJoiner.toString());\n        }\n    }\n\n    /**\n     * Returns a {@link ResponseHeaders} whose {@link HttpHeaderNames#CONTENT_LENGTH} is added or removed\n     * according to the status of the specified {@code headers}, {@code content} and {@code trailers}.\n     * The {@link HttpHeaderNames#CONTENT_LENGTH} is removed when:\n     * <ul>\n     *   <li>the status of the specified {@code headers} is one of {@link HttpStatus#NO_CONTENT},\n     *       {@link HttpStatus#RESET_CONTENT} or {@link HttpStatus#NOT_MODIFIED}</li>\n     *   <li>the trailers exists</li>\n     * </ul>\n     * The {@link HttpHeaderNames#CONTENT_LENGTH} is added when the state of the specified {@code headers}\n     * does not meet the conditions above and {@link HttpHeaderNames#CONTENT_LENGTH} is not present\n     * regardless of the fact that the content is empty or not.\n     *\n     * @throws IllegalArgumentException if the specified {@code content} is not empty when the specified\n     *                                  {@link HttpStatus} is one of {@link HttpStatus#NO_CONTENT},\n     *                                  {@link HttpStatus#RESET_CONTENT} and {@link HttpStatus#NOT_MODIFIED}.\n     */\n    public static ResponseHeaders setOrRemoveContentLength(ResponseHeaders headers, HttpData content,\n                                                           HttpHeaders trailers) {\n        requireNonNull(headers, \"headers\");\n        requireNonNull(content, \"content\");\n        requireNonNull(trailers, \"trailers\");\n\n        final HttpStatus status = headers.status();\n\n        if (isContentAlwaysEmptyWithValidation(status, content)) {\n            if (status != HttpStatus.NOT_MODIFIED) {\n                if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n                    final ResponseHeadersBuilder builder = headers.toBuilder();\n                    builder.remove(HttpHeaderNames.CONTENT_LENGTH);\n                    return builder.build();\n                }\n            } else {\n                // 304 response can have the \"content-length\" header when it is a response to a conditional\n                // GET request. See https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2\n            }\n\n            return headers;\n        }\n\n        if (!trailers.isEmpty()) {\n            // Some of the client implementations such as \"curl\" ignores trailers if\n            // the \"content-length\" header is present. We should not set \"content-length\" header when\n            // trailers exists so that those clients can receive the trailers.\n            // The response is sent using chunked transfer encoding in HTTP/1 or a DATA frame payload\n            // in HTTP/2, so it's no worry.\n            if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n                final ResponseHeadersBuilder builder = headers.toBuilder();\n                builder.remove(HttpHeaderNames.CONTENT_LENGTH);\n                return builder.build();\n            }\n\n            return headers;\n        }\n\n        if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH) || !content.isEmpty()) {\n            return headers.toBuilder()\n                          .contentLength(content.length())\n                          .build();\n        }\n\n        // The header contains \"content-length\" header and the content is empty.\n        // Do not overwrite the header because a response to a HEAD request\n        // will have no content even if it has non-zero content-length header.\n        return headers;\n    }\n\n    public static String convertHeaderValue(AsciiString name, CharSequence value) {\n        if (!(value instanceof AsciiString)) {\n            return value.toString();\n        }\n        if (HEADER_VALUE_CACHE != null && CACHED_HEADERS.contains(name)) {\n            final String converted = HEADER_VALUE_CACHE.get((AsciiString) value);\n            assert converted != null; // loader does not return null.\n            return converted;\n        }\n        return value.toString();\n    }\n\n    /**\n     * Returns {@code true} if the specified header name is not allowed for HTTP trailers.\n     */\n    public static boolean isTrailerDisallowed(AsciiString name) {\n        return HTTP_TRAILER_DISALLOWED_LIST.contains(name);\n    }\n\n    private static final class CaseInsensitiveMap\n            extends DefaultHeaders<AsciiString, AsciiString, CaseInsensitiveMap> {\n\n        CaseInsensitiveMap() {\n            super(HTTP2_HEADER_NAME_HASHER, UnsupportedValueConverter.instance());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        CaseInsensitiveMap(int size) {\n            super(HTTP2_HEADER_NAME_HASHER, UnsupportedValueConverter.instance(), NameValidator.NOT_NULL, size);\n        }\n    }\n\n    /**\n     * Returns a authority header value of specified host and port.\n     */\n    public static String authorityHeader(String host, int port, int defaultPort) {\n        if (port == defaultPort) {\n            return host;\n        } else {\n            final StringBuilder buf = new StringBuilder(host.length() + 6);\n            buf.append(host);\n            buf.append(':');\n            buf.append(port);\n            return buf.toString();\n        }\n    }\n\n    /**\n     * A 408 Request Timeout response can be received even without a request.\n     * More details can be found at https://github.com/line/armeria/issues/3055.\n     */\n    public static boolean isRequestTimeoutResponse(HttpResponse httpResponse) {\n        return httpResponse.status() == HttpResponseStatus.REQUEST_TIMEOUT &&\n               \"close\".equalsIgnoreCase(httpResponse.headers().get(HttpHeaderNames.CONNECTION));\n    }\n\n    private ArmeriaHttpUtil() {}\n}\n", "/*\n * Copyright 2017 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.internal.common;\n\nimport static io.netty.util.internal.StringUtil.decodeHexNibble;\nimport static java.util.Objects.requireNonNull;\n\nimport java.util.BitSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport com.github.benmanes.caffeine.cache.Cache;\nimport com.github.benmanes.caffeine.cache.Caffeine;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport com.linecorp.armeria.common.Flags;\nimport com.linecorp.armeria.common.annotation.Nullable;\nimport com.linecorp.armeria.common.metric.MeterIdPrefix;\nimport com.linecorp.armeria.internal.common.metric.CaffeineMetricSupport;\n\nimport io.micrometer.core.instrument.MeterRegistry;\nimport it.unimi.dsi.fastutil.Arrays;\nimport it.unimi.dsi.fastutil.bytes.ByteArrays;\n\n/**\n * A parser of the raw path and query components of an HTTP path. Performs validation and allows caching of\n * results.\n */\npublic final class PathAndQuery {\n\n    private static final PathAndQuery ROOT_PATH_QUERY = new PathAndQuery(\"/\", null);\n\n    private static final BitSet ALLOWED_PATH_CHARS = new BitSet();\n    private static final BitSet ALLOWED_QUERY_CHARS = new BitSet();\n\n    private static final int PERCENT_ENCODING_MARKER = 0xFF;\n\n    private static final byte[] RAW_CHAR_TO_MARKER = new byte[256];\n    private static final String[] MARKER_TO_PERCENT_ENCODED_CHAR = new String[256];\n\n    static {\n        final String allowedPathChars =\n                \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=\";\n        for (int i = 0; i < allowedPathChars.length(); i++) {\n            ALLOWED_PATH_CHARS.set(allowedPathChars.charAt(i));\n        }\n\n        final String allowedQueryChars =\n                \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*,;=\";\n        for (int i = 0; i < allowedQueryChars.length(); i++) {\n            ALLOWED_QUERY_CHARS.set(allowedQueryChars.charAt(i));\n        }\n\n        for (final ReservedChar reservedChar : ReservedChar.values()) {\n            RAW_CHAR_TO_MARKER[reservedChar.rawChar] = reservedChar.marker;\n            MARKER_TO_PERCENT_ENCODED_CHAR[reservedChar.marker] = reservedChar.percentEncodedChar;\n        }\n    }\n\n    private static final Bytes EMPTY_QUERY = new Bytes(0);\n    private static final Bytes ROOT_PATH = new Bytes(new byte[] { '/' });\n\n    @Nullable\n    private static final Cache<String, PathAndQuery> CACHE =\n            Flags.parsedPathCacheSpec() != null ? buildCache(Flags.parsedPathCacheSpec()) : null;\n\n    private static Cache<String, PathAndQuery> buildCache(String spec) {\n        return Caffeine.from(spec).build();\n    }\n\n    public static void registerMetrics(MeterRegistry registry, MeterIdPrefix idPrefix) {\n        if (CACHE != null) {\n            CaffeineMetricSupport.setup(registry, idPrefix, CACHE);\n        }\n    }\n\n    /**\n     * Clears the currently cached parsed paths. Only for use in tests.\n     */\n    @VisibleForTesting\n    public static void clearCachedPaths() {\n        requireNonNull(CACHE, \"CACHE\");\n        CACHE.asMap().clear();\n    }\n\n    /**\n     * Returns paths that have had their parse result cached. Only for use in tests.\n     */\n    @VisibleForTesting\n    public static Set<String> cachedPaths() {\n        requireNonNull(CACHE, \"CACHE\");\n        return CACHE.asMap().keySet();\n    }\n\n    /**\n     * Validates the {@link String} that contains an absolute path and a query, and splits them into\n     * the path part and the query part. If the path is usable (e.g., can be served a successful response from\n     * the server and doesn't have variable path parameters), {@link PathAndQuery#storeInCache(String)} should\n     * be called to cache the parsing result for faster future invocations.\n     *\n     * @return a {@link PathAndQuery} with the absolute path and query, or {@code null} if the specified\n     *         {@link String} is not an absolute path or invalid.\n     */\n    @Nullable\n    public static PathAndQuery parse(@Nullable String rawPath) {\n        if (CACHE != null && rawPath != null) {\n            final PathAndQuery parsed = CACHE.getIfPresent(rawPath);\n            if (parsed != null) {\n                return parsed;\n            }\n        }\n        return splitPathAndQuery(rawPath);\n    }\n\n    /**\n     * Stores this {@link PathAndQuery} into cache for the given raw path. This should be used by callers when\n     * the parsed result was valid (e.g., when a server is able to successfully handle the parsed path).\n     */\n    public void storeInCache(@Nullable String rawPath) {\n        if (CACHE != null && !cached && rawPath != null) {\n            cached = true;\n            CACHE.put(rawPath, this);\n        }\n    }\n\n    private final String path;\n    @Nullable\n    private final String query;\n\n    private boolean cached;\n\n    private PathAndQuery(String path, @Nullable String query) {\n        this.path = path;\n        this.query = query;\n    }\n\n    public String path() {\n        return path;\n    }\n\n    @Nullable\n    public String query() {\n        return query;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof PathAndQuery)) {\n            return false;\n        }\n\n        final PathAndQuery that = (PathAndQuery) o;\n        return Objects.equals(path, that.path) &&\n               Objects.equals(query, that.query);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(path, query);\n    }\n\n    @Override\n    public String toString() {\n        if (query == null) {\n            return path;\n        }\n        return path + \"?\" + query;\n    }\n\n    @Nullable\n    private static PathAndQuery splitPathAndQuery(@Nullable final String pathAndQuery) {\n        final Bytes path;\n        final Bytes query;\n\n        if (pathAndQuery == null) {\n            return ROOT_PATH_QUERY;\n        }\n\n        // Split by the first '?'.\n        final int queryPos = pathAndQuery.indexOf('?');\n        if (queryPos >= 0) {\n            if ((path = decodePercentsAndEncodeToUtf8(\n                    pathAndQuery, 0, queryPos, true)) == null) {\n                return null;\n            }\n            if ((query = decodePercentsAndEncodeToUtf8(\n                    pathAndQuery, queryPos + 1, pathAndQuery.length(), false)) == null) {\n                return null;\n            }\n        } else {\n            if ((path = decodePercentsAndEncodeToUtf8(\n                    pathAndQuery, 0, pathAndQuery.length(), true)) == null) {\n                return null;\n            }\n            query = null;\n        }\n\n        if (path.data[0] != '/') {\n            // Do not accept a relative path.\n            return null;\n        }\n\n        // Reject the prohibited patterns.\n        if (pathContainsDoubleDots(path)) {\n            return null;\n        }\n\n        return new PathAndQuery(encodeToPercents(path, true),\n                                query != null ? encodeToPercents(query, false) : null);\n    }\n\n    @Nullable\n    private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int end, boolean isPath) {\n        final int length = end - start;\n        if (length == 0) {\n            return isPath ? ROOT_PATH : EMPTY_QUERY;\n        }\n\n        final Bytes buf = new Bytes(Math.max(length * 3 / 2, 4));\n        boolean wasSlash = false;\n        for (final CodePointIterator i = new CodePointIterator(value, start, end);\n             i.hasNextCodePoint();/* noop */) {\n            final int pos = i.position();\n            final int cp = i.nextCodePoint();\n\n            if (cp == '%') {\n                final int hexEnd = pos + 3;\n                if (hexEnd > end) {\n                    // '%' or '%x' (must be followed by two hexadigits)\n                    return null;\n                }\n\n                final int digit1 = decodeHexNibble(value.charAt(pos + 1));\n                final int digit2 = decodeHexNibble(value.charAt(pos + 2));\n                if (digit1 < 0 || digit2 < 0) {\n                    // The first or second digit is not hexadecimal.\n                    return null;\n                }\n\n                final int decoded = (digit1 << 4) | digit2;\n                if (isPath) {\n                    if (decoded == '/') {\n                        // Do not decode '%2F' and '%2f' in the path to '/' for compatibility with\n                        // other implementations in the ecosystem, e.g. HTTP/JSON to gRPC transcoding.\n                        // https://github.com/googleapis/googleapis/blob/02710fa0ea5312d79d7fb986c9c9823fb41049a9/google/api/http.proto#L257-L258\n\n                        // Insert a special mark so we can distinguish a raw character ('/') and\n                        // percent-encoded character ('%2F') in a path string.\n                        // We will encode this mark back into a percent-encoded character later.\n                        final byte marker = RAW_CHAR_TO_MARKER['/'];\n                        buf.ensure(2);\n                        buf.add((byte) PERCENT_ENCODING_MARKER);\n                        buf.add(marker);\n                        wasSlash = false;\n                    } else {\n                        if (appendOneByte(buf, decoded, wasSlash, isPath)) {\n                            wasSlash = false;\n                        } else {\n                            return null;\n                        }\n                    }\n                } else {\n                    // If query:\n                    final byte marker = RAW_CHAR_TO_MARKER[decoded];\n                    if (marker != 0) {\n                        // Insert a special mark so we can distinguish a raw character and percent-encoded\n                        // character in a query string, such as '&' and '%26'.\n                        // We will encode this mark back into a percent-encoded character later.\n                        buf.ensure(2);\n                        buf.add((byte) PERCENT_ENCODING_MARKER);\n                        buf.add(marker);\n                        wasSlash = false;\n                    } else if (appendOneByte(buf, decoded, wasSlash, isPath)) {\n                        wasSlash = decoded == '/';\n                    } else {\n                        return null;\n                    }\n                }\n\n                i.position(hexEnd);\n                continue;\n            }\n\n            if (cp == '+' && !isPath) {\n                buf.ensure(1);\n                buf.add((byte) ' ');\n                wasSlash = false;\n                continue;\n            }\n\n            if (cp <= 0x7F) {\n                if (!appendOneByte(buf, cp, wasSlash, isPath)) {\n                    return null;\n                }\n                wasSlash = cp == '/';\n                continue;\n            }\n\n            if (cp <= 0x7ff) {\n                buf.ensure(2);\n                buf.add((byte) ((cp >>> 6) | 0b110_00000));\n                buf.add((byte) (cp & 0b111111 | 0b10_000000));\n            } else if (cp <= 0xffff) {\n                buf.ensure(3);\n                buf.add((byte) ((cp >>> 12) | 0b1110_0000));\n                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n            } else if (cp <= 0x1fffff) {\n                buf.ensure(4);\n                buf.add((byte) ((cp >>> 18) | 0b11110_000));\n                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n            } else if (cp <= 0x3ffffff) {\n                // A valid unicode character will never reach here, but for completeness.\n                // http://unicode.org/mail-arch/unicode-ml/Archives-Old/UML018/0330.html\n                buf.ensure(5);\n                buf.add((byte) ((cp >>> 24) | 0b111110_00));\n                buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n            } else {\n                // A valid unicode character will never reach here, but for completeness.\n                // http://unicode.org/mail-arch/unicode-ml/Archives-Old/UML018/0330.html\n                buf.ensure(6);\n                buf.add((byte) ((cp >>> 30) | 0b1111110_0));\n                buf.add((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));\n                buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.add((byte) ((cp & 0b111111) | 0b10_000000));\n            }\n\n            wasSlash = false;\n        }\n\n        return buf;\n    }\n\n    private static boolean appendOneByte(Bytes buf, int cp, boolean wasSlash, boolean isPath) {\n        if (cp == 0x7F) {\n            // Reject the control character: 0x7F\n            return false;\n        }\n\n        if (cp >>> 5 == 0) {\n            // Reject the control characters: 0x00..0x1F\n            if (isPath) {\n                return false;\n            } else if (cp != 0x0A && cp != 0x0D && cp != 0x09) {\n                // .. except 0x0A (LF), 0x0D (CR) and 0x09 (TAB) because they are used in a form.\n                return false;\n            }\n        }\n\n        if (cp == '/' && isPath) {\n            if (!wasSlash) {\n                buf.ensure(1);\n                buf.add((byte) '/');\n            } else {\n                // Remove the consecutive slashes: '/path//with///consecutive////slashes'.\n            }\n        } else {\n            buf.ensure(1);\n            buf.add((byte) cp);\n        }\n\n        return true;\n    }\n\n    private static boolean pathContainsDoubleDots(Bytes path) {\n        final int length = path.length;\n        byte b0 = 0;\n        byte b1 = 0;\n        byte b2 = '/';\n        for (int i = 1; i < length; i++) {\n            final byte b3 = path.data[i];\n            if (b3 == '/' && b2 == '.' && b1 == '.' && b0 == '/') {\n                return true;\n            }\n            b0 = b1;\n            b1 = b2;\n            b2 = b3;\n        }\n\n        return b0 == '/' && b1 == '.' && b2 == '.';\n    }\n\n    private static String encodeToPercents(Bytes value, boolean isPath) {\n        final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;\n        final int length = value.length;\n        boolean needsEncoding = false;\n        for (int i = 0; i < length; i++) {\n            if (!allowedChars.get(value.data[i] & 0xFF)) {\n                needsEncoding = true;\n                break;\n            }\n        }\n\n        if (!needsEncoding) {\n            // Deprecated, but it fits perfect for our use case.\n            // noinspection deprecation\n            return new String(value.data, 0, 0, length);\n        }\n\n        final StringBuilder buf = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            final int b = value.data[i] & 0xFF;\n\n            if (b == PERCENT_ENCODING_MARKER && (i + 1) < length) {\n                final int marker = value.data[i + 1] & 0xFF;\n                final String percentEncodedChar = MARKER_TO_PERCENT_ENCODED_CHAR[marker];\n                if (percentEncodedChar != null) {\n                    buf.append(percentEncodedChar);\n                    i++;\n                    continue;\n                }\n            }\n\n            if (allowedChars.get(b)) {\n                buf.append((char) b);\n            } else if (b == ' ') {\n                if (isPath) {\n                    buf.append(\"%20\");\n                } else {\n                    buf.append('+');\n                }\n            } else {\n                buf.append('%');\n                appendHexNibble(buf, b >>> 4);\n                appendHexNibble(buf, b & 0xF);\n            }\n        }\n\n        return buf.toString();\n    }\n\n    private static void appendHexNibble(StringBuilder buf, int nibble) {\n        if (nibble < 10) {\n            buf.append((char) ('0' + nibble));\n        } else {\n            buf.append((char) ('A' + nibble - 10));\n        }\n    }\n\n    private static final class Bytes {\n        byte[] data;\n        int length;\n\n        Bytes(int initialCapacity) {\n            data = new byte[initialCapacity];\n        }\n\n        Bytes(byte[] data) {\n            this.data = data;\n            length = data.length;\n        }\n\n        void add(byte b) {\n            data[length++] = b;\n        }\n\n        void ensure(int numBytes) {\n            int newCapacity = length + numBytes;\n            if (newCapacity <= data.length) {\n                return;\n            }\n\n            newCapacity =\n                    (int) Math.max(Math.min((long) data.length + (data.length >> 1), Arrays.MAX_ARRAY_SIZE),\n                                   newCapacity);\n\n            data = ByteArrays.forceCapacity(data, newCapacity, length);\n        }\n    }\n\n    private static final class CodePointIterator {\n        private final CharSequence str;\n        private final int end;\n        private int pos;\n\n        CodePointIterator(CharSequence str, int start, int end) {\n            this.str = str;\n            this.end = end;\n            pos = start;\n        }\n\n        int position() {\n            return pos;\n        }\n\n        void position(int pos) {\n            this.pos = pos;\n        }\n\n        boolean hasNextCodePoint() {\n            return pos < end;\n        }\n\n        int nextCodePoint() {\n            assert pos < end;\n\n            final char c1 = str.charAt(pos++);\n            if (Character.isHighSurrogate(c1) && pos < end) {\n                final char c2 = str.charAt(pos);\n                if (Character.isLowSurrogate(c2)) {\n                    pos++;\n                    return Character.toCodePoint(c1, c2);\n                }\n            }\n\n            return c1;\n        }\n    }\n\n    /**\n     * Reserved characters which require percent-encoding. These values are only used for constructing\n     * {@link #RAW_CHAR_TO_MARKER} and {@link #MARKER_TO_PERCENT_ENCODED_CHAR} mapping tables.\n     *\n     * @see <a href=\"https://datatracker.ietf.org/doc/html/rfc3986#section-2.2\">RFC 3986, section 2.2</a>\n     */\n    private enum ReservedChar {\n        GEN_DELIM_01(':', \"%3A\", (byte) 0x01),\n        GEN_DELIM_02('/', \"%2F\", (byte) 0x02),\n        GEN_DELIM_03('?', \"%3F\", (byte) 0x03),\n        GEN_DELIM_04('#', \"%23\", (byte) 0x04),\n        GEN_DELIM_05('[', \"%5B\", (byte) 0x05),\n        GEN_DELIM_06(']', \"%5D\", (byte) 0x06),\n        GEN_DELIM_07('@', \"%40\", (byte) 0x07),\n\n        SUB_DELIM_01('!', \"%21\", (byte) 0x11),\n        SUB_DELIM_02('$', \"%24\", (byte) 0x12),\n        SUB_DELIM_03('&', \"%26\", (byte) 0x13),\n        SUB_DELIM_04('\\'', \"%27\", (byte) 0x14),\n        SUB_DELIM_05('(', \"%28\", (byte) 0x15),\n        SUB_DELIM_06(')', \"%29\", (byte) 0x16),\n        SUB_DELIM_07('*', \"%2A\", (byte) 0x17),\n        SUB_DELIM_08('+', \"%2B\", (byte) 0x18),\n        SUB_DELIM_09(',', \"%2C\", (byte) 0x19),\n        SUB_DELIM_10(';', \"%3B\", (byte) 0x1A),\n        SUB_DELIM_11('=', \"%3D\", (byte) 0x1B);\n\n        private final int rawChar;\n        private final String percentEncodedChar;\n        private final byte marker;\n\n        ReservedChar(int rawChar, String percentEncodedChar, byte marker) {\n            this.rawChar = rawChar;\n            this.percentEncodedChar = percentEncodedChar;\n            this.marker = marker;\n        }\n    }\n}\n", "/*\n * Copyright 2019 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.server;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.linecorp.armeria.server.RoutingResult.LOWEST_SCORE;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.collect.ImmutableMap;\n\nimport com.linecorp.armeria.common.MediaType;\nimport com.linecorp.armeria.common.annotation.Nullable;\nimport com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n\n/**\n * Builds a new {@link RoutingResult}.\n */\npublic final class RoutingResultBuilder {\n\n    private RoutingResultType type = RoutingResultType.MATCHED;\n\n    @Nullable\n    private String path;\n\n    @Nullable\n    private String query;\n\n    @Nullable\n    private ImmutableMap.Builder<String, String> pathParams;\n\n    private int score = LOWEST_SCORE;\n\n    @Nullable\n    private MediaType negotiatedResponseMediaType;\n\n    RoutingResultBuilder() {}\n\n    RoutingResultBuilder(int expectedNumParams) {\n        pathParams = ImmutableMap.builderWithExpectedSize(expectedNumParams);\n    }\n\n    /**\n     * Sets the result type.\n     *\n     * @param type {@link RoutingResultType#MATCHED} or {@link RoutingResultType#CORS_PREFLIGHT}.\n     */\n    public RoutingResultBuilder type(RoutingResultType type) {\n        requireNonNull(type, \"type\");\n        checkArgument(type != RoutingResultType.NOT_MATCHED,\n                      \"type: %s (expected: %s or %s)\",\n                      type, RoutingResultType.MATCHED, RoutingResultType.CORS_PREFLIGHT);\n        this.type = type;\n        return this;\n    }\n\n    /**\n     * Sets the mapped path, encoded as defined in <a href=\"https://datatracker.ietf.org/doc/rfc3986/\">RFC3986</a>.\n     */\n    public RoutingResultBuilder path(String path) {\n        this.path = requireNonNull(path, \"path\");\n        return this;\n    }\n\n    /**\n     * Sets the specified query.\n     */\n    public RoutingResultBuilder query(@Nullable String query) {\n        this.query = query;\n        return this;\n    }\n\n    /**\n     * Adds a decoded path parameter.\n     */\n    public RoutingResultBuilder decodedParam(String name, String value) {\n        pathParams().put(requireNonNull(name, \"name\"), requireNonNull(value, \"value\"));\n        return this;\n    }\n\n    /**\n     * Adds an encoded path parameter, which will be decoded in UTF-8 automatically.\n     */\n    public RoutingResultBuilder rawParam(String name, String value) {\n        pathParams().put(requireNonNull(name, \"name\"),\n                         ArmeriaHttpUtil.decodePath(requireNonNull(value, \"value\")));\n        return this;\n    }\n\n    /**\n     * Sets the score.\n     */\n    public RoutingResultBuilder score(int score) {\n        this.score = score;\n        return this;\n    }\n\n    /**\n     * Sets the negotiated producible {@link MediaType}.\n     */\n    public RoutingResultBuilder negotiatedResponseMediaType(MediaType negotiatedResponseMediaType) {\n        this.negotiatedResponseMediaType = requireNonNull(negotiatedResponseMediaType,\n                                                          \"negotiatedResponseMediaType\");\n        return this;\n    }\n\n    /**\n     * Returns a newly-created {@link RoutingResult}.\n     */\n    public RoutingResult build() {\n        if (path == null) {\n            return RoutingResult.empty();\n        }\n\n        return new RoutingResult(type, path, query,\n                                 pathParams != null ? pathParams.build() : ImmutableMap.of(),\n                                 score, negotiatedResponseMediaType);\n    }\n\n    private ImmutableMap.Builder<String, String> pathParams() {\n        if (pathParams != null) {\n            return pathParams;\n        }\n        return pathParams = ImmutableMap.builder();\n    }\n}\n", "/*\n * Copyright 2017 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.internal.common;\n\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.concatPaths;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.decodePath;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.parseDirectives;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toArmeria;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ClientHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ServerHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp2ClientHeaders;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.net.InetSocketAddress;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.google.common.collect.ImmutableList;\n\nimport com.linecorp.armeria.common.Http1HeaderNaming;\nimport com.linecorp.armeria.common.HttpHeaderNames;\nimport com.linecorp.armeria.common.HttpHeaders;\nimport com.linecorp.armeria.common.HttpHeadersBuilder;\nimport com.linecorp.armeria.common.HttpResponse;\nimport com.linecorp.armeria.common.HttpStatus;\nimport com.linecorp.armeria.common.MediaType;\nimport com.linecorp.armeria.common.RequestHeaders;\nimport com.linecorp.armeria.common.ResponseHeaders;\nimport com.linecorp.armeria.common.ResponseHeadersBuilder;\nimport com.linecorp.armeria.server.Server;\nimport com.linecorp.armeria.server.ServerConfig;\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\nimport io.netty.util.AsciiString;\n\nclass ArmeriaHttpUtilTest {\n\n    @Test\n    void testConcatPaths() throws Exception {\n        assertThat(concatPaths(null, \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(null, \"/a\")).isEqualTo(\"/a\");\n\n        assertThat(concatPaths(\"\", \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"\", \"/a\")).isEqualTo(\"/a\");\n\n        assertThat(concatPaths(\"/\", \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"/\", \"/a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"/\", \"/\")).isEqualTo(\"/\");\n\n        assertThat(concatPaths(\"/a\", \"b\")).isEqualTo(\"/a/b\");\n        assertThat(concatPaths(\"/a\", \"/b\")).isEqualTo(\"/a/b\");\n        assertThat(concatPaths(\"/a/\", \"/b\")).isEqualTo(\"/a/b\");\n\n        assertThat(concatPaths(\"/a\", \"\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"/a/\", \"\")).isEqualTo(\"/a/\");\n        assertThat(concatPaths(\"/a\", \"?foo=bar\")).isEqualTo(\"/a?foo=bar\");\n        assertThat(concatPaths(\"/a/\", \"?foo=bar\")).isEqualTo(\"/a/?foo=bar\");\n    }\n\n    @Test\n    void testDecodePath() throws Exception {\n        // Fast path\n        final String pathThatDoesNotNeedDecode = \"/foo_bar_baz\";\n        assertThat(decodePath(pathThatDoesNotNeedDecode)).isSameAs(pathThatDoesNotNeedDecode);\n\n        // Slow path\n        assertThat(decodePath(\"/foo%20bar\\u007fbaz\")).isEqualTo(\"/foo bar\\u007fbaz\");\n        assertThat(decodePath(\"/%C2%A2\")).isEqualTo(\"/\u00a2\"); // Valid UTF-8 sequence\n        assertThat(decodePath(\"/%20\\u0080\")).isEqualTo(\"/ \ufffd\"); // Unallowed character\n        assertThat(decodePath(\"/%\")).isEqualTo(\"/\ufffd\"); // No digit\n        assertThat(decodePath(\"/%1\")).isEqualTo(\"/\ufffd\"); // Only a single digit\n        assertThat(decodePath(\"/%G0\")).isEqualTo(\"/\ufffd\"); // First digit is not hex.\n        assertThat(decodePath(\"/%0G\")).isEqualTo(\"/\ufffd\"); // Second digit is not hex.\n        assertThat(decodePath(\"/%C3%28\")).isEqualTo(\"/\ufffd(\"); // Invalid UTF-8 sequence\n    }\n\n    @Test\n    void testParseDirectives() {\n        final Map<String, String> values = new LinkedHashMap<>();\n        final BiConsumer<String, String> cb = (name, value) -> assertThat(values.put(name, value)).isNull();\n\n        // Make sure an effectively empty string does not invoke a callback.\n        parseDirectives(\"\", cb);\n        assertThat(values).isEmpty();\n        parseDirectives(\" \\t \", cb);\n        assertThat(values).isEmpty();\n        parseDirectives(\" ,,=, =,= ,\", cb);\n        assertThat(values).isEmpty();\n\n        // Name only.\n        parseDirectives(\"no-cache\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"no-cache\", null);\n        values.clear();\n        parseDirectives(\" no-cache \", cb);\n        assertThat(values).hasSize(1).containsEntry(\"no-cache\", null);\n        values.clear();\n        parseDirectives(\"no-cache ,\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"no-cache\", null);\n        values.clear();\n\n        // Name and value.\n        parseDirectives(\"max-age=86400\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = 86400 \", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = 86400 ,\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\"max-age=\\\"86400\\\"\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = \\\"86400\\\" \", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = \\\"86400\\\" ,\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n\n        // Multiple names and values.\n        parseDirectives(\"a,b=c,d,e=\\\"f\\\",g\", cb);\n        assertThat(values).hasSize(5)\n                          .containsEntry(\"a\", null)\n                          .containsEntry(\"b\", \"c\")\n                          .containsEntry(\"d\", null)\n                          .containsEntry(\"e\", \"f\")\n                          .containsEntry(\"g\", null);\n    }\n\n    @Test\n    void outboundCookiesMustBeMergedForHttp1() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.COOKIE, \"a=b; c=d\")\n                                          .add(HttpHeaderNames.COOKIE, \"e=f;g=h\")\n                                          .addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8)\n                                          .add(HttpHeaderNames.COOKIE, \"i=j\")\n                                          .add(HttpHeaderNames.COOKIE, \"k=l;\")\n                                          .build();\n\n        final io.netty.handler.codec.http.HttpHeaders out =\n                new DefaultHttpHeaders();\n\n        toNettyHttp1ClientHeaders(in, out, Http1HeaderNaming.ofDefault());\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b; c=d; e=f; g=h; i=j; k=l\");\n    }\n\n    @Test\n    void outboundCookiesMustBeSplitForHttp2() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.COOKIE, \"a=b; c=d\")\n                                          .add(HttpHeaderNames.COOKIE, \"e=f;g=h\")\n                                          .addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8)\n                                          .add(HttpHeaderNames.COOKIE, \"i=j\")\n                                          .add(HttpHeaderNames.COOKIE, \"k=l;\")\n                                          .build();\n\n        final Http2Headers out = toNettyHttp2ClientHeaders(in);\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b\", \"c=d\", \"e=f\", \"g=h\", \"i=j\", \"k=l\");\n    }\n\n    @Test\n    void inboundCookiesMustBeMergedForHttp1() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n        in.add(HttpHeaderNames.COOKIE, \"e=f;g=h\");\n        in.add(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8);\n        in.add(HttpHeaderNames.COOKIE, \"i=j\");\n        in.add(HttpHeaderNames.COOKIE, \"k=l;\");\n\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b; c=d; e=f; g=h; i=j; k=l\");\n    }\n\n    @Test\n    void endOfStreamSet() {\n        final Http2Headers in = new ArmeriaHttp2Headers();\n        in.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n        final HttpHeaders out = toArmeria(in, true, true);\n        assertThat(out.isEndOfStream()).isTrue();\n\n        final HttpHeaders out2 = toArmeria(in, true, false);\n        assertThat(out2.isEndOfStream()).isFalse();\n    }\n\n    @Test\n    void endOfStreamSetEmpty() {\n        final Http2Headers in = new ArmeriaHttp2Headers();\n        final HttpHeaders out = toArmeria(in, true, true);\n        assertThat(out.isEndOfStream()).isTrue();\n\n        final HttpHeaders out2 = toArmeria(in, true, false);\n        assertThat(out2.isEndOfStream()).isFalse();\n    }\n\n    @Test\n    void inboundCookiesMustBeMergedForHttp2() {\n        final Http2Headers in = new ArmeriaHttp2Headers();\n\n        in.add(HttpHeaderNames.METHOD, \"GET\");\n        in.add(HttpHeaderNames.SCHEME, \"http\");\n        in.add(HttpHeaderNames.AUTHORITY, \"foo.com\");\n        in.add(HttpHeaderNames.PATH, \"/\");\n        in.add(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n        in.add(HttpHeaderNames.COOKIE, \"e=f;g=h\");\n        in.addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8);\n        in.add(HttpHeaderNames.COOKIE, \"i=j\");\n        in.add(HttpHeaderNames.COOKIE, \"k=l;\");\n\n        final RequestHeaders out = ArmeriaHttpUtil.toArmeriaRequestHeaders(null, in, false, \"http\", null);\n\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b; c=d; e=f;g=h; i=j; k=l;\");\n    }\n\n    @Test\n    void addHostHeaderIfMissing() throws URISyntaxException {\n        final io.netty.handler.codec.http.HttpHeaders headers = new DefaultHttpHeaders();\n        headers.add(HttpHeaderNames.HOST, \"bar\");\n\n        final HttpRequest originReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/hello\", headers);\n\n        final InetSocketAddress socketAddress = new InetSocketAddress(36462);\n        final Channel channel = mock(Channel.class);\n        when(channel.localAddress()).thenReturn(socketAddress);\n\n        final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n        when(ctx.channel()).thenReturn(channel);\n\n        RequestHeaders armeriaHeaders = toArmeria(ctx, originReq, serverConfig(), \"http\");\n        assertThat(armeriaHeaders.get(HttpHeaderNames.HOST)).isEqualTo(\"bar\");\n        assertThat(armeriaHeaders.authority()).isEqualTo(\"bar\");\n        assertThat(armeriaHeaders.scheme()).isEqualTo(\"http\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"/hello\");\n\n        // Remove Host header.\n        headers.remove(HttpHeaderNames.HOST);\n        armeriaHeaders = toArmeria(ctx, originReq, serverConfig(), \"https\");\n        assertThat(armeriaHeaders.get(HttpHeaderNames.HOST)).isEqualTo(\"foo:36462\"); // The default hostname.\n        assertThat(armeriaHeaders.authority()).isEqualTo(\"foo:36462\");\n        assertThat(armeriaHeaders.scheme()).isEqualTo(\"https\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"/hello\");\n    }\n\n    @Test\n    void pathValidation() throws Exception {\n        final InetSocketAddress socketAddress = new InetSocketAddress(36462);\n        final Channel channel = mock(Channel.class);\n        when(channel.localAddress()).thenReturn(socketAddress);\n\n        final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n        when(ctx.channel()).thenReturn(channel);\n\n        // Should not be overly strict, e.g. allow `\"` in the path.\n        final HttpRequest doubleQuoteReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/\\\"?\\\"\",\n                                       new DefaultHttpHeaders());\n        RequestHeaders armeriaHeaders = toArmeria(ctx, doubleQuoteReq, serverConfig(), \"http\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"/\\\"?\\\"\");\n\n        // Should accept an asterisk request.\n        final HttpRequest asteriskReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"*\", new DefaultHttpHeaders());\n        armeriaHeaders = toArmeria(ctx, asteriskReq, serverConfig(), \"http\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"*\");\n\n        // Should reject an absolute URI.\n        final HttpRequest absoluteUriReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,\n                                       \"http://example.com/hello\", new DefaultHttpHeaders());\n        assertThatThrownBy(() -> toArmeria(ctx, absoluteUriReq, serverConfig(), \"http\"))\n                .isInstanceOf(URISyntaxException.class)\n                .hasMessageContaining(\"neither origin form nor asterisk form\");\n\n        // Should not accept a path that starts with an asterisk.\n        final HttpRequest badAsteriskReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"*/\", new DefaultHttpHeaders());\n        assertThatThrownBy(() -> toArmeria(ctx, badAsteriskReq, serverConfig(), \"http\"))\n                .isInstanceOf(URISyntaxException.class)\n                .hasMessageContaining(\"neither origin form nor asterisk form\");\n    }\n\n    @Test\n    void stripTEHeaders() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP);\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out).isEmpty();\n    }\n\n    @Test\n    void stripTEHeadersExcludingTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP);\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.get(HttpHeaderNames.TE)).isEqualTo(HttpHeaderValues.TRAILERS.toString());\n    }\n\n    @Test\n    void stripTEHeadersCsvSeparatedExcludingTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP + \",\" + HttpHeaderValues.TRAILERS);\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.get(HttpHeaderNames.TE)).isEqualTo(HttpHeaderValues.TRAILERS.toString());\n    }\n\n    @Test\n    void stripTEHeadersCsvSeparatedAccountsForValueSimilarToTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP + \",\" + HttpHeaderValues.TRAILERS + \"foo\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.contains(HttpHeaderNames.TE)).isFalse();\n    }\n\n    @Test\n    void stripTEHeadersAccountsForValueSimilarToTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS + \"foo\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.contains(HttpHeaderNames.TE)).isFalse();\n    }\n\n    @Test\n    void stripTEHeadersAccountsForOWS() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, \" \" + HttpHeaderValues.TRAILERS + ' ');\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.get(HttpHeaderNames.TE)).isEqualTo(HttpHeaderValues.TRAILERS.toString());\n    }\n\n    @Test\n    void stripConnectionHeadersAndNominees() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.CONNECTION, \"foo\");\n        in.add(\"foo\", \"bar\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out).isEmpty();\n    }\n\n    @Test\n    void stripConnectionNomineesWithCsv() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.CONNECTION, \"foo,  bar\");\n        in.add(\"foo\", \"baz\");\n        in.add(\"bar\", \"qux\");\n        in.add(\"hello\", \"world\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out).hasSize(1);\n        assertThat(out.get(HttpHeaderNames.of(\"hello\"))).isEqualTo(\"world\");\n    }\n\n    @Test\n    void excludeDisallowedHeadersWhileHttp2ToHttp1() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.TRAILER, \"foo\")\n                                          .add(HttpHeaderNames.HOST, \"bar\")\n                                          .add(HttpHeaderNames.PATH, \"dummy\")\n                                          .add(HttpHeaderNames.METHOD, \"dummy\")\n                                          .add(HttpHeaderNames.SCHEME, \"dummy\")\n                                          .add(HttpHeaderNames.STATUS, \"dummy\")\n                                          .add(HttpHeaderNames.TRANSFER_ENCODING, \"dummy\")\n                                          .add(ExtensionHeaderNames.STREAM_ID.text(), \"dummy\")\n                                          .add(ExtensionHeaderNames.SCHEME.text(), \"dummy\")\n                                          .add(ExtensionHeaderNames.PATH.text(), \"dummy\")\n                                          .build();\n\n        final io.netty.handler.codec.http.HttpHeaders out =\n                new DefaultHttpHeaders();\n\n        toNettyHttp1ServerHeaders(in, out, Http1HeaderNaming.ofDefault());\n        assertThat(out).isEqualTo(new DefaultHttpHeaders()\n                                          .add(io.netty.handler.codec.http.HttpHeaderNames.TRAILER, \"foo\")\n                                          .add(io.netty.handler.codec.http.HttpHeaderNames.HOST, \"bar\"));\n    }\n\n    @Test\n    void excludeDisallowedInTrailers() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.of(\"foo\"), \"bar\")\n                                          .add(HttpHeaderNames.TRANSFER_ENCODING, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_LENGTH, \"dummy\")\n                                          .add(HttpHeaderNames.CACHE_CONTROL, \"dummy\")\n                                          .add(HttpHeaderNames.EXPECT, \"dummy\")\n                                          .add(HttpHeaderNames.HOST, \"dummy\")\n                                          .add(HttpHeaderNames.MAX_FORWARDS, \"dummy\")\n                                          .add(HttpHeaderNames.PRAGMA, \"dummy\")\n                                          .add(HttpHeaderNames.RANGE, \"dummy\")\n                                          .add(HttpHeaderNames.TE, \"dummy\")\n                                          .add(HttpHeaderNames.WWW_AUTHENTICATE, \"dummy\")\n                                          .add(HttpHeaderNames.AUTHORIZATION, \"dummy\")\n                                          .add(HttpHeaderNames.PROXY_AUTHENTICATE, \"dummy\")\n                                          .add(HttpHeaderNames.PROXY_AUTHORIZATION, \"dummy\")\n                                          .add(HttpHeaderNames.DATE, \"dummy\")\n                                          .add(HttpHeaderNames.LOCATION, \"dummy\")\n                                          .add(HttpHeaderNames.RETRY_AFTER, \"dummy\")\n                                          .add(HttpHeaderNames.VARY, \"dummy\")\n                                          .add(HttpHeaderNames.WARNING, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_ENCODING, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_TYPE, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_RANGE, \"dummy\")\n                                          .add(HttpHeaderNames.TRAILER, \"dummy\")\n                                          .build();\n        final Http2Headers nettyHeaders = ArmeriaHttpUtil.toNettyHttp2ServerTrailers(in);\n        assertThat(nettyHeaders.size()).isOne();\n        assertThat(nettyHeaders.get(\"foo\")).isEqualTo(\"bar\");\n    }\n\n    @Test\n    void excludeDisallowedInResponseHeaders() {\n        final ResponseHeadersBuilder in = ResponseHeaders.builder()\n                                                         .add(HttpHeaderNames.STATUS, \"200\")\n                                                         .add(HttpHeaderNames.AUTHORITY, \"dummy\")\n                                                         .add(HttpHeaderNames.METHOD, \"dummy\")\n                                                         .add(HttpHeaderNames.PATH, \"dummy\")\n                                                         .add(HttpHeaderNames.SCHEME, \"dummy\");\n        final Http2Headers nettyHeaders = ArmeriaHttpUtil.toNettyHttp2ServerHeaders(in);\n        assertThat(nettyHeaders.size()).isOne();\n        assertThat(nettyHeaders.get(HttpHeaderNames.STATUS)).isEqualTo(\"200\");\n    }\n\n    @Test\n    void traditionalHeaderNaming() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.of(\"foo\"), \"bar\")\n                                          .add(HttpHeaderNames.AUTHORIZATION, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_LENGTH, \"dummy\")\n                                          .add(HttpHeaderNames.CACHE_CONTROL, \"dummy\")\n                                          .build();\n\n        final io.netty.handler.codec.http.HttpHeaders clientOutHeaders =\n                new DefaultHttpHeaders();\n        toNettyHttp1ClientHeaders(in, clientOutHeaders, Http1HeaderNaming.traditional());\n        assertThat(clientOutHeaders).isEqualTo(new DefaultHttpHeaders()\n                                                       .add(\"foo\", \"bar\")\n                                                       .add(\"Authorization\", \"dummy\")\n                                                       .add(\"Content-Length\", \"dummy\")\n                                                       .add(\"Cache-Control\", \"dummy\"));\n\n        final io.netty.handler.codec.http.HttpHeaders serverOutHeaders =\n                new DefaultHttpHeaders();\n        toNettyHttp1ServerHeaders(in, serverOutHeaders, Http1HeaderNaming.traditional());\n        assertThat(serverOutHeaders).isEqualTo(new DefaultHttpHeaders()\n                                                       .add(\"foo\", \"bar\")\n                                                       .add(\"Authorization\", \"dummy\")\n                                                       .add(\"Content-Length\", \"dummy\")\n                                                       .add(\"Cache-Control\", \"dummy\"));\n    }\n\n    @Test\n    void convertedHeaderTypes() {\n        final Http2Headers in = new ArmeriaHttp2Headers().set(\"a\", \"b\");\n\n        // Request headers without pseudo headers.\n        assertThat(toArmeria(in, true, false)).isInstanceOf(HttpHeaders.class)\n                                              .isNotInstanceOf(RequestHeaders.class)\n                                              .isNotInstanceOf(ResponseHeaders.class);\n\n        // Response headers without pseudo headers.\n        assertThat(toArmeria(in, false, false)).isInstanceOf(HttpHeaders.class)\n                                               .isNotInstanceOf(RequestHeaders.class)\n                                               .isNotInstanceOf(ResponseHeaders.class);\n\n        // Request headers with pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.METHOD, \"GET\")\n          .set(HttpHeaderNames.PATH, \"/\");\n        assertThat(toArmeria(in, true, false)).isInstanceOf(RequestHeaders.class)\n                                              .isNotInstanceOf(ResponseHeaders.class);\n\n        // Response headers with pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.STATUS, \"200\");\n        assertThat(toArmeria(in, false, false)).isInstanceOf(ResponseHeaders.class)\n                                               .isNotInstanceOf(RequestHeaders.class);\n\n        // Request headers with mixed pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.METHOD, \"GET\")\n          .set(HttpHeaderNames.PATH, \"/\")\n          .set(HttpHeaderNames.STATUS, \"200\");\n        assertThat(toArmeria(in, true, false)).isInstanceOf(RequestHeaders.class)\n                                              .isNotInstanceOf(ResponseHeaders.class);\n\n        // Response headers with mixed pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.STATUS, \"200\")\n          .set(HttpHeaderNames.METHOD, \"GET\");\n        assertThat(toArmeria(in, false, false)).isInstanceOf(ResponseHeaders.class)\n                                               .isNotInstanceOf(RequestHeaders.class);\n    }\n\n    @Test\n    void toArmeriaRequestHeaders() {\n        final Http2Headers in = new ArmeriaHttp2Headers().set(\"a\", \"b\");\n\n        final InetSocketAddress socketAddress = new InetSocketAddress(36462);\n        final Channel channel = mock(Channel.class);\n        when(channel.localAddress()).thenReturn(socketAddress);\n\n        final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n        when(ctx.channel()).thenReturn(channel);\n\n        in.set(HttpHeaderNames.METHOD, \"GET\")\n          .set(HttpHeaderNames.PATH, \"/\");\n        // Request headers without pseudo headers.\n        final RequestHeaders headers =\n                ArmeriaHttpUtil.toArmeriaRequestHeaders(ctx, in, false, \"https\", serverConfig());\n        assertThat(headers.scheme()).isEqualTo(\"https\");\n        assertThat(headers.authority()).isEqualTo(\"foo:36462\");\n    }\n\n    @Test\n    void isAbsoluteUri() {\n        final String good = \"none+http://a.com\";\n        assertThat(ArmeriaHttpUtil.isAbsoluteUri(good)).isTrue();\n        final List<String> bad = Arrays.asList(\n                \"none+http:/a\",\n                \"//a\",\n                \"://a\",\n                \"a/b://c\",\n                \"http://\",\n                \"://\",\n                \"\",\n                null);\n        bad.forEach(path -> assertThat(ArmeriaHttpUtil.isAbsoluteUri(path)).isFalse());\n    }\n\n    @Test\n    void serverHeader() {\n        final String pattern = \"Armeria/(\\\\d+).(\\\\d+).(\\\\d+)(-SNAPSHOT)?\";\n        assertThat(\"Armeria/1.0.0\").containsPattern(pattern);\n        assertThat(\"Armeria/1.0.0-SNAPSHOT\").containsPattern(pattern);\n        assertThat(ArmeriaHttpUtil.SERVER_HEADER).containsPattern(pattern);\n    }\n\n    @Test\n    void disallowedResponseHeaderNames() {\n        for (AsciiString headerName : ImmutableList.of(HttpHeaderNames.METHOD,\n                                                       HttpHeaderNames.AUTHORITY,\n                                                       HttpHeaderNames.SCHEME,\n                                                       HttpHeaderNames.PATH,\n                                                       HttpHeaderNames.PROTOCOL)) {\n            assertThat(ArmeriaHttpUtil.disallowedResponseHeaderNames().contains(headerName)).isTrue();\n        }\n        assertThat(ArmeriaHttpUtil.disallowedResponseHeaderNames()).doesNotContain(HttpHeaderNames.STATUS);\n        assertThat(ArmeriaHttpUtil.disallowedResponseHeaderNames()).doesNotContain(HttpHeaderNames.LOCATION);\n    }\n\n    private static ServerConfig serverConfig() {\n        final Server server = Server.builder()\n                                    .defaultHostname(\"foo\")\n                                    .service(\"/\", (ctx, req) -> HttpResponse.of(HttpStatus.OK))\n                                    .build();\n        return server.config();\n    }\n}\n", "/*\n * Copyright 2018 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.linecorp.armeria.internal.common;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.google.common.base.Ascii;\n\nclass PathAndQueryTest {\n    @Test\n    void empty() {\n        final PathAndQuery res = PathAndQuery.parse(null);\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/\");\n        assertThat(res.query()).isNull();\n\n        final PathAndQuery res2 = PathAndQuery.parse(\"\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/\");\n        assertThat(res2.query()).isNull();\n\n        final PathAndQuery res3 = PathAndQuery.parse(\"?\");\n        assertThat(res3).isNotNull();\n        assertThat(res3.path()).isEqualTo(\"/\");\n        assertThat(res3.query()).isEqualTo(\"\");\n    }\n\n    @Test\n    void relative() {\n        assertThat(PathAndQuery.parse(\"foo\")).isNull();\n    }\n\n    @Test\n    void doubleDots() {\n        assertThat(PathAndQuery.parse(\"/..\")).isNull();\n        assertThat(PathAndQuery.parse(\"/../\")).isNull();\n        assertThat(PathAndQuery.parse(\"/../foo\")).isNull();\n        assertThat(PathAndQuery.parse(\"/foo/..\")).isNull();\n        assertThat(PathAndQuery.parse(\"/foo/../\")).isNull();\n        assertThat(PathAndQuery.parse(\"/foo/../bar\")).isNull();\n\n        // Escaped\n        assertThat(PathAndQuery.parse(\"/.%2e\")).isNull();\n        assertThat(PathAndQuery.parse(\"/%2E./\")).isNull();\n        assertThat(PathAndQuery.parse(\"/foo/.%2e\")).isNull();\n        assertThat(PathAndQuery.parse(\"/foo/%2E./\")).isNull();\n\n        // Not the double dots we are looking for.\n        final PathAndQuery res = PathAndQuery.parse(\"/..a\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/..a\");\n        final PathAndQuery res2 = PathAndQuery.parse(\"/a..\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/a..\");\n    }\n\n    @Test\n    void hexadecimal() {\n        assertThat(PathAndQuery.parse(\"/%\")).isNull();\n        assertThat(PathAndQuery.parse(\"/%0\")).isNull();\n        assertThat(PathAndQuery.parse(\"/%0X\")).isNull();\n        assertThat(PathAndQuery.parse(\"/%X0\")).isNull();\n    }\n\n    @Test\n    void controlChars() {\n        assertThat(PathAndQuery.parse(\"/\\0\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a\\nb\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a\\u007fb\")).isNull();\n\n        // Escaped\n        assertThat(PathAndQuery.parse(\"/%00\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a%09b\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a%0ab\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a%0db\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a%7fb\")).isNull();\n\n        // With query string\n        assertThat(PathAndQuery.parse(\"/\\0?c\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a\\tb?c\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a\\nb?c\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a\\rb?c\")).isNull();\n        assertThat(PathAndQuery.parse(\"/a\\u007fb?c\")).isNull();\n\n        // With query string with control chars\n        assertThat(PathAndQuery.parse(\"/?\\0\")).isNull();\n        assertThat(PathAndQuery.parse(\"/?%00\")).isNull();\n        assertThat(PathAndQuery.parse(\"/?a\\u007fb\")).isNull();\n        assertThat(PathAndQuery.parse(\"/?a%7Fb\")).isNull();\n        // However, 0x0A, 0x0D, 0x09 should be accepted in a query string.\n        assertThat(PathAndQuery.parse(\"/?a\\tb\").query()).isEqualTo(\"a%09b\");\n        assertThat(PathAndQuery.parse(\"/?a\\nb\").query()).isEqualTo(\"a%0Ab\");\n        assertThat(PathAndQuery.parse(\"/?a\\rb\").query()).isEqualTo(\"a%0Db\");\n        assertThat(PathAndQuery.parse(\"/?a%09b\").query()).isEqualTo(\"a%09b\");\n        assertThat(PathAndQuery.parse(\"/?a%0Ab\").query()).isEqualTo(\"a%0Ab\");\n        assertThat(PathAndQuery.parse(\"/?a%0Db\").query()).isEqualTo(\"a%0Db\");\n    }\n\n    @Test\n    void percent() {\n        final PathAndQuery res = PathAndQuery.parse(\"/%25\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/%25\");\n        assertThat(res.query()).isNull();\n    }\n\n    @Test\n    void shouldNotDecodeSlash() {\n        final PathAndQuery res = PathAndQuery.parse(\"%2F?%2F\");\n        // Do not accept a relative path.\n        assertThat(res).isNull();\n        final PathAndQuery res1 = PathAndQuery.parse(\"/%2F?%2F\");\n        assertThat(res1).isNotNull();\n        assertThat(res1.path()).isEqualTo(\"/%2F\");\n        assertThat(res1.query()).isEqualTo(\"%2F\");\n\n        final PathAndQuery pathOnly = PathAndQuery.parse(\"/foo%2F\");\n        assertThat(pathOnly).isNotNull();\n        assertThat(pathOnly.path()).isEqualTo(\"/foo%2F\");\n        assertThat(pathOnly.query()).isNull();\n\n        final PathAndQuery queryOnly = PathAndQuery.parse(\"/?%2f=%2F\");\n        assertThat(queryOnly).isNotNull();\n        assertThat(queryOnly.path()).isEqualTo(\"/\");\n        assertThat(queryOnly.query()).isEqualTo(\"%2F=%2F\");\n    }\n\n    @Test\n    void consecutiveSlashes() {\n        final PathAndQuery res = PathAndQuery.parse(\n                \"/path//with///consecutive////slashes?/query//with///consecutive////slashes\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/path/with/consecutive/slashes\");\n        assertThat(res.query()).isEqualTo(\"/query//with///consecutive////slashes\");\n\n        // Encoded slashes\n        final PathAndQuery res2 = PathAndQuery.parse(\n                \"/path%2F/with/%2F/consecutive//%2F%2Fslashes?/query%2F/with/%2F/consecutive//%2F%2Fslashes\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/path%2F/with/%2F/consecutive/%2F%2Fslashes\");\n        assertThat(res2.query()).isEqualTo(\"/query%2F/with/%2F/consecutive//%2F%2Fslashes\");\n    }\n\n    @Test\n    void colon() {\n        assertThat(PathAndQuery.parse(\"/:\")).isNotNull();\n        assertThat(PathAndQuery.parse(\"/:/\")).isNotNull();\n        assertThat(PathAndQuery.parse(\"/a/:\")).isNotNull();\n        assertThat(PathAndQuery.parse(\"/a/:/\")).isNotNull();\n    }\n\n    @Test\n    void rawUnicode() {\n        // 2- and 3-byte UTF-8\n        final PathAndQuery res1 = PathAndQuery.parse(\"/\\u00A2?\\u20AC\"); // \u00a2 and \u20ac\n        assertThat(res1).isNotNull();\n        assertThat(res1.path()).isEqualTo(\"/%C2%A2\");\n        assertThat(res1.query()).isEqualTo(\"%E2%82%AC\");\n\n        // 4-byte UTF-8\n        final PathAndQuery res2 = PathAndQuery.parse(\"/\\uD800\\uDF48\"); // \ud800\udf48\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/%F0%90%8D%88\");\n        assertThat(res2.query()).isNull();\n\n        // 5- and 6-byte forms are only theoretically possible, so we won't test them here.\n    }\n\n    @Test\n    void encodedUnicode() {\n        final String encodedPath = \"/%ec%95%88\";\n        final String encodedQuery = \"%eb%85%95\";\n        final PathAndQuery res = PathAndQuery.parse(encodedPath + '?' + encodedQuery);\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(Ascii.toUpperCase(encodedPath));\n        assertThat(res.query()).isEqualTo(Ascii.toUpperCase(encodedQuery));\n    }\n\n    @Test\n    void noEncoding() {\n        final PathAndQuery res = PathAndQuery.parse(\"/a?b=c\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/a\");\n        assertThat(res.query()).isEqualTo(\"b=c\");\n    }\n\n    @Test\n    void space() {\n        final PathAndQuery res = PathAndQuery.parse(\"/ ? \");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/%20\");\n        assertThat(res.query()).isEqualTo(\"+\");\n\n        final PathAndQuery res2 = PathAndQuery.parse(\"/%20?%20\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/%20\");\n        assertThat(res2.query()).isEqualTo(\"+\");\n    }\n\n    @Test\n    void plus() {\n        final PathAndQuery res = PathAndQuery.parse(\"/+?a+b=c+d\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/+\");\n        assertThat(res.query()).isEqualTo(\"a+b=c+d\");\n\n        final PathAndQuery res2 = PathAndQuery.parse(\"/%2b?a%2bb=c%2bd\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/+\");\n        assertThat(res2.query()).isEqualTo(\"a%2Bb=c%2Bd\");\n    }\n\n    @Test\n    void ampersand() {\n        final PathAndQuery res = PathAndQuery.parse(\"/&?a=1&a=2&b=3\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/&\");\n        assertThat(res.query()).isEqualTo(\"a=1&a=2&b=3\");\n\n        // '%26' in a query string should never be decoded into '&'.\n        final PathAndQuery res2 = PathAndQuery.parse(\"/%26?a=1%26a=2&b=3\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/&\");\n        assertThat(res2.query()).isEqualTo(\"a=1%26a=2&b=3\");\n    }\n\n    @Test\n    void semicolon() {\n        final PathAndQuery res = PathAndQuery.parse(\"/;?a=b;c=d\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/;\");\n        assertThat(res.query()).isEqualTo(\"a=b;c=d\");\n\n        // '%3B' in a query string should never be decoded into ';'.\n        final PathAndQuery res2 = PathAndQuery.parse(\"/%3b?a=b%3Bc=d\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/;\");\n        assertThat(res2.query()).isEqualTo(\"a=b%3Bc=d\");\n    }\n\n    @Test\n    void equal() {\n        final PathAndQuery res = PathAndQuery.parse(\"/=?a=b=1\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/=\");\n        assertThat(res.query()).isEqualTo(\"a=b=1\");\n\n        // '%3D' in a query string should never be decoded into '='.\n        final PathAndQuery res2 = PathAndQuery.parse(\"/%3D?a%3db=1\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/=\");\n        assertThat(res2.query()).isEqualTo(\"a%3Db=1\");\n    }\n\n    @Test\n    void sharp() {\n        final PathAndQuery res = PathAndQuery.parse(\"/#?a=b#1\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/#\");\n        assertThat(res.query()).isEqualTo(\"a=b#1\");\n\n        // '%23' in a query string should never be decoded into '#'.\n        final PathAndQuery res2 = PathAndQuery.parse(\"/%23?a=b%231\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/#\");\n        assertThat(res2.query()).isEqualTo(\"a=b%231\");\n    }\n\n    @Test\n    void allReservedCharacters() {\n        final PathAndQuery res = PathAndQuery.parse(\"/#/:[]@!$&'()*+,;=?a=/#/:[]@!$&'()*+,;=\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/#/:[]@!$&'()*+,;=\");\n        assertThat(res.query()).isEqualTo(\"a=/#/:[]@!$&'()*+,;=\");\n\n        final PathAndQuery res2 =\n                PathAndQuery.parse(\"/%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\" +\n                                   \"?a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/#%2F:[]@!$&'()*+,;=?\");\n        assertThat(res2.query()).isEqualTo(\"a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n    }\n\n    @Test\n    void doubleQuote() {\n        final PathAndQuery res = PathAndQuery.parse(\"/\\\"?\\\"\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/%22\");\n        assertThat(res.query()).isEqualTo(\"%22\");\n    }\n}\n", "/*\n * Copyright 2019 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.server;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.net.URISyntaxException;\nimport java.util.AbstractMap.SimpleEntry;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.linecorp.armeria.common.MediaType;\n\nclass RoutingResultTest {\n\n    @Test\n    void empty() {\n        final RoutingResultBuilder builder = RoutingResult.builder();\n        final RoutingResult routingResult = builder.build();\n        assertThat(routingResult).isSameAs(RoutingResult.empty());\n    }\n\n    @Test\n    void routingResult() throws URISyntaxException {\n        final RoutingResultBuilder builder = RoutingResult.builder();\n        final RoutingResult routingResult = builder.path(\"/foo\")\n                                                   .query(\"bar=baz\")\n                                                   .rawParam(\"qux\", \"quux\")\n                                                   .negotiatedResponseMediaType(MediaType.JSON_UTF_8)\n                                                   .build();\n        assertThat(routingResult.isPresent()).isTrue();\n        assertThat(routingResult.path()).isEqualTo(\"/foo\");\n        assertThat(routingResult.query()).isEqualTo(\"bar=baz\");\n        assertThat(routingResult.pathParams()).containsOnly(new SimpleEntry<>(\"qux\", \"quux\"));\n        assertThat(routingResult.negotiatedResponseMediaType()).isSameAs(MediaType.JSON_UTF_8);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2016 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.linecorp.armeria.internal.common;\n\nimport static com.google.common.collect.ImmutableSet.toImmutableSet;\nimport static io.netty.util.AsciiString.EMPTY_STRING;\nimport static io.netty.util.ByteProcessor.FIND_COMMA;\nimport static io.netty.util.internal.StringUtil.decodeHexNibble;\nimport static java.util.Objects.requireNonNull;\n\nimport java.net.InetSocketAddress;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.StringJoiner;\nimport java.util.function.BiConsumer;\n\nimport com.github.benmanes.caffeine.cache.Caffeine;\nimport com.github.benmanes.caffeine.cache.LoadingCache;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableSet;\n\nimport com.linecorp.armeria.common.Flags;\nimport com.linecorp.armeria.common.Http1HeaderNaming;\nimport com.linecorp.armeria.common.HttpData;\nimport com.linecorp.armeria.common.HttpHeaderNames;\nimport com.linecorp.armeria.common.HttpHeaders;\nimport com.linecorp.armeria.common.HttpHeadersBuilder;\nimport com.linecorp.armeria.common.HttpMethod;\nimport com.linecorp.armeria.common.HttpStatus;\nimport com.linecorp.armeria.common.RequestHeaders;\nimport com.linecorp.armeria.common.RequestHeadersBuilder;\nimport com.linecorp.armeria.common.ResponseHeaders;\nimport com.linecorp.armeria.common.ResponseHeadersBuilder;\nimport com.linecorp.armeria.common.annotation.Nullable;\nimport com.linecorp.armeria.common.util.Version;\nimport com.linecorp.armeria.internal.common.util.TemporaryThreadLocals;\nimport com.linecorp.armeria.server.ServerConfig;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.DefaultHeaders;\nimport io.netty.handler.codec.UnsupportedValueConverter;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.HttpConversionUtil;\nimport io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\nimport io.netty.util.AsciiString;\nimport io.netty.util.HashingStrategy;\nimport io.netty.util.internal.StringUtil;\n\n/**\n * Provides various utility functions for internal use related with HTTP.\n *\n * <p>The conversion between HTTP/1 and HTTP/2 has been forked from Netty's {@link HttpConversionUtil}.\n */\npublic final class ArmeriaHttpUtil {\n\n    // Forked from Netty 4.1.34 at 4921f62c8ab8205fd222439dcd1811760b05daf1\n\n    /**\n     * The default case-insensitive {@link AsciiString} hasher and comparator for HTTP/2 headers.\n     */\n    private static final HashingStrategy<AsciiString> HTTP2_HEADER_NAME_HASHER =\n            new HashingStrategy<AsciiString>() {\n                @Override\n                public int hashCode(AsciiString o) {\n                    return o.hashCode();\n                }\n\n                @Override\n                public boolean equals(AsciiString a, AsciiString b) {\n                    return a.contentEqualsIgnoreCase(b);\n                }\n            };\n\n    /**\n     * The default HTTP content-type charset.\n     *\n     * <p>Note that we use {@link StandardCharsets#UTF_8} as default because it is common practice even though\n     * it's not the HTTP standard.\n     */\n    public static final Charset HTTP_DEFAULT_CONTENT_CHARSET = StandardCharsets.UTF_8;\n\n    /**\n     * The old {@code \"proxy-connection\"} header which has been superceded by {@code \"connection\"}.\n     */\n    public static final AsciiString HEADER_NAME_PROXY_CONNECTION = AsciiString.cached(\"proxy-connection\");\n\n    /**\n     * The set of headers that should not be directly copied when converting headers from HTTP/1 to HTTP/2.\n     */\n    private static final CaseInsensitiveMap HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST = new CaseInsensitiveMap();\n\n    /**\n     * The set of headers that should not be directly copied when converting headers from HTTP/2 to HTTP/1.\n     */\n    private static final CaseInsensitiveMap HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST = new CaseInsensitiveMap();\n\n    /**\n     * The set of headers that must not be directly copied when converting trailers.\n     */\n    private static final CaseInsensitiveMap HTTP_TRAILER_DISALLOWED_LIST = new CaseInsensitiveMap();\n\n    static {\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.CONNECTION, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.KEEP_ALIVE, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HEADER_NAME_PROXY_CONNECTION, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.TRANSFER_ENCODING, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.UPGRADE, EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.STREAM_ID.text(), EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.SCHEME.text(), EMPTY_STRING);\n        HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.PATH.text(), EMPTY_STRING);\n\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.AUTHORITY, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.METHOD, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.PATH, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.SCHEME, EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.STATUS, EMPTY_STRING);\n\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1\n        // The \"chunked\" transfer encoding defined in Section 4.1 of [RFC7230] MUST NOT be used in HTTP/2.\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(HttpHeaderNames.TRANSFER_ENCODING, EMPTY_STRING);\n\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.STREAM_ID.text(), EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.SCHEME.text(), EMPTY_STRING);\n        HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.add(ExtensionHeaderNames.PATH.text(), EMPTY_STRING);\n\n        // https://datatracker.ietf.org/doc/html/rfc7230#section-4.1.2\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1\n        // A sender MUST NOT generate a trailer that contains a field necessary for message framing:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.TRANSFER_ENCODING, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_LENGTH, EMPTY_STRING);\n\n        // for request modifiers:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CACHE_CONTROL, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.EXPECT, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.HOST, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.MAX_FORWARDS, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.PRAGMA, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.RANGE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.TE, EMPTY_STRING);\n\n        // for authentication:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.WWW_AUTHENTICATE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.AUTHORIZATION, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.PROXY_AUTHENTICATE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.PROXY_AUTHORIZATION, EMPTY_STRING);\n\n        // for response control data:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.DATE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.LOCATION, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.RETRY_AFTER, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.VARY, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.WARNING, EMPTY_STRING);\n\n        // or for determining how to process the payload:\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_ENCODING, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_TYPE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.CONTENT_RANGE, EMPTY_STRING);\n        HTTP_TRAILER_DISALLOWED_LIST.add(HttpHeaderNames.TRAILER, EMPTY_STRING);\n    }\n\n    static final Set<AsciiString> ADDITIONAL_REQUEST_HEADER_DISALLOWED_LIST = ImmutableSet.of(\n            HttpHeaderNames.SCHEME, HttpHeaderNames.STATUS, HttpHeaderNames.METHOD, HttpHeaderNames.AUTHORITY);\n\n    private static final Set<AsciiString> REQUEST_PSEUDO_HEADERS = ImmutableSet.of(\n            HttpHeaderNames.METHOD, HttpHeaderNames.SCHEME, HttpHeaderNames.AUTHORITY,\n            HttpHeaderNames.PATH, HttpHeaderNames.PROTOCOL);\n\n    private static final Set<AsciiString> PSEUDO_HEADERS = ImmutableSet.<AsciiString>builder()\n                                                                       .addAll(REQUEST_PSEUDO_HEADERS)\n                                                                       .add(HttpHeaderNames.STATUS)\n                                                                       .build();\n\n    public static final String SERVER_HEADER =\n            \"Armeria/\" + Version.get(\"armeria\", ArmeriaHttpUtil.class.getClassLoader())\n                                .artifactVersion();\n\n    /**\n     * Translations from HTTP/2 header name to the HTTP/1.x equivalent. Currently, we expect these headers to\n     * only allow a single value in the request. If adding headers that can potentially have multiple values,\n     * please check the usage in code accordingly.\n     */\n    private static final CaseInsensitiveMap REQUEST_HEADER_TRANSLATIONS = new CaseInsensitiveMap();\n\n    static {\n        REQUEST_HEADER_TRANSLATIONS.add(Http2Headers.PseudoHeaderName.AUTHORITY.value(),\n                                        HttpHeaderNames.HOST);\n    }\n\n    /**\n     * <a href=\"https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\">rfc7540, 8.1.2.3</a> states the path must not\n     * be empty, and instead should be {@code /}.\n     */\n    private static final String EMPTY_REQUEST_PATH = \"/\";\n\n    private static final Splitter COOKIE_SPLITTER = Splitter.on(';').trimResults().omitEmptyStrings();\n    private static final String COOKIE_SEPARATOR = \"; \";\n    private static final Joiner COOKIE_JOINER = Joiner.on(COOKIE_SEPARATOR);\n\n    @Nullable\n    private static final LoadingCache<AsciiString, String> HEADER_VALUE_CACHE =\n            Flags.headerValueCacheSpec() != null ? buildCache(Flags.headerValueCacheSpec()) : null;\n    private static final Set<AsciiString> CACHED_HEADERS = Flags.cachedHeaders().stream().map(AsciiString::of)\n                                                                .collect(toImmutableSet());\n\n    private static LoadingCache<AsciiString, String> buildCache(String spec) {\n        return Caffeine.from(spec).build(AsciiString::toString);\n    }\n\n    /**\n     * Concatenates two path strings.\n     */\n    public static String concatPaths(@Nullable String path1, @Nullable String path2) {\n        path2 = path2 == null ? \"\" : path2;\n\n        if (path1 == null || path1.isEmpty() || EMPTY_REQUEST_PATH.equals(path1)) {\n            if (path2.isEmpty()) {\n                return EMPTY_REQUEST_PATH;\n            }\n\n            if (path2.charAt(0) == '/') {\n                return path2; // Most requests will land here.\n            }\n\n            return '/' + path2;\n        }\n\n        // At this point, we are sure path1 is neither empty nor null.\n        if (path2.isEmpty()) {\n            // Only path1 is non-empty. No need to concatenate.\n            return path1;\n        }\n\n        if (path1.charAt(path1.length() - 1) == '/') {\n            if (path2.charAt(0) == '/') {\n                // path1 ends with '/' and path2 starts with '/'.\n                // Avoid double-slash by stripping the first slash of path2.\n                return new StringBuilder(path1.length() + path2.length() - 1)\n                        .append(path1).append(path2, 1, path2.length()).toString();\n            }\n\n            // path1 ends with '/' and path2 does not start with '/'.\n            // Simple concatenation would suffice.\n            return path1 + path2;\n        }\n\n        if (path2.charAt(0) == '/' || path2.charAt(0) == '?') {\n            // path1 does not end with '/' and path2 starts with '/' or '?'\n            // Simple concatenation would suffice.\n            return path1 + path2;\n        }\n\n        // path1 does not end with '/' and path2 does not start with '/' or '?'.\n        // Need to insert '/' between path1 and path2.\n        return path1 + '/' + path2;\n    }\n\n    /**\n     * Decodes a percent-encoded path string.\n     */\n    public static String decodePath(String path) {\n        if (path.indexOf('%') < 0) {\n            // No need to decode because it's not percent-encoded\n            return path;\n        }\n\n        // Decode percent-encoded characters, but don't decode %2F into /, so that a user can choose\n        // to use it as a non-separator.\n        //\n        // For example, for the path pattern `/orgs/{org_name}/agents/{agent_name}`:\n        // - orgs/mi6/agents/ethan-hunt\n        //   - org_name: mi6\n        //   - agent_name: ethan-hunt\n        // - orgs/mi%2F6/agents/ethan-hunt\n        //   - org_name: mi/6\n        //   - agent_name: ethan-hunt\n        return slowDecodePath(path, false);\n    }\n\n    /**\n     * Decodes a single percent-encoded path parameter.\n     */\n    public static String decodePathParam(String pathParam) {\n        if (pathParam.indexOf('%') < 0) {\n            // No need to decode because it's not percent-encoded\n            return pathParam;\n        }\n\n        // Decode percent-encoded characters.\n        return slowDecodePath(pathParam, true);\n    }\n\n    private static String slowDecodePath(String path, boolean decodeSlash) {\n        // An invalid character is replaced with 0xFF, which will be replaced into '\ufffd' by UTF-8 decoder.\n        final int len = path.length();\n        try (TemporaryThreadLocals tempThreadLocals = TemporaryThreadLocals.acquire()) {\n            final byte[] buf = tempThreadLocals.byteArray(len);\n            int dstLen = 0;\n            for (int i = 0; i < len; i++) {\n                final char ch = path.charAt(i);\n                if (ch != '%') {\n                    buf[dstLen++] = (byte) ((ch & 0xFF80) == 0 ? ch : 0xFF);\n                    continue;\n                }\n\n                // Decode a percent-encoded character.\n                final int hexEnd = i + 3;\n                if (hexEnd > len) {\n                    // '%' or '%x' (must be followed by two hexadigits)\n                    buf[dstLen++] = (byte) 0xFF;\n                    break;\n                }\n\n                final int digit1 = decodeHexNibble(path.charAt(++i));\n                final int digit2 = decodeHexNibble(path.charAt(++i));\n                if (digit1 < 0 || digit2 < 0) {\n                    // The first or second digit is not hexadecimal.\n                    buf[dstLen++] = (byte) 0xFF;\n                } else {\n                    final byte decoded = (byte) ((digit1 << 4) | digit2);\n                    if (decodeSlash || decoded != 0x2F) {\n                        buf[dstLen++] = decoded;\n                    } else {\n                        buf[dstLen++] = '%';\n                        buf[dstLen++] = '2';\n                        buf[dstLen++] = (byte) path.charAt(i); // f or F - preserve the case.\n                    }\n                }\n            }\n\n            return new String(buf, 0, dstLen, StandardCharsets.UTF_8);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the specified {@code path} is an absolute {@code URI}.\n     */\n    public static boolean isAbsoluteUri(@Nullable String maybeUri) {\n        if (maybeUri == null) {\n            return false;\n        }\n        final int firstColonIdx = maybeUri.indexOf(':');\n        if (firstColonIdx <= 0 || firstColonIdx + 3 >= maybeUri.length()) {\n            return false;\n        }\n        final int firstSlashIdx = maybeUri.indexOf('/');\n        if (firstSlashIdx <= 0 || firstSlashIdx < firstColonIdx) {\n            return false;\n        }\n\n        return maybeUri.charAt(firstColonIdx + 1) == '/' && maybeUri.charAt(firstColonIdx + 2) == '/';\n    }\n\n    /**\n     * Returns {@code true} if the specified HTTP status string represents an informational status.\n     */\n    public static boolean isInformational(@Nullable String statusText) {\n        return statusText != null && !statusText.isEmpty() && statusText.charAt(0) == '1';\n    }\n\n    /**\n     * Returns {@code true} if the content of the response with the given {@link HttpStatus} is one of\n     * {@link HttpStatus#NO_CONTENT}, {@link HttpStatus#RESET_CONTENT} and {@link HttpStatus#NOT_MODIFIED}.\n     *\n     * @throws IllegalArgumentException if the specified {@code content} is not empty when the specified\n     *                                  {@link HttpStatus} is one of {@link HttpStatus#NO_CONTENT},\n     *                                  {@link HttpStatus#RESET_CONTENT} and {@link HttpStatus#NOT_MODIFIED}.\n     */\n    public static boolean isContentAlwaysEmptyWithValidation(HttpStatus status, HttpData content) {\n        if (!status.isContentAlwaysEmpty()) {\n            return false;\n        }\n\n        if (!content.isEmpty()) {\n            throw new IllegalArgumentException(\n                    \"A \" + status + \" response must have empty content: \" + content.length() + \" byte(s)\");\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns {@code true} if the specified {@code request} is a CORS preflight request.\n     */\n    public static boolean isCorsPreflightRequest(com.linecorp.armeria.common.HttpRequest request) {\n        requireNonNull(request, \"request\");\n        return request.method() == HttpMethod.OPTIONS &&\n               request.headers().contains(HttpHeaderNames.ORIGIN) &&\n               request.headers().contains(HttpHeaderNames.ACCESS_CONTROL_REQUEST_METHOD);\n    }\n\n    /**\n     * Returns the disallowed response headers.\n     */\n    @VisibleForTesting\n    static Set<AsciiString> disallowedResponseHeaderNames() {\n        // Request Pseudo-Headers are not allowed for response headers.\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\n        return REQUEST_PSEUDO_HEADERS;\n    }\n\n    /**\n     * Parses the specified HTTP header directives and invokes the specified {@code callback}\n     * with the directive names and values.\n     */\n    public static void parseDirectives(String directives, BiConsumer<String, String> callback) {\n        final int len = directives.length();\n        for (int i = 0; i < len;) {\n            final int nameStart = i;\n            final String name;\n            final String value;\n\n            // Find the name.\n            for (; i < len; i++) {\n                final char ch = directives.charAt(i);\n                if (ch == ',' || ch == '=') {\n                    break;\n                }\n            }\n            name = directives.substring(nameStart, i).trim();\n\n            // Find the value.\n            if (i == len || directives.charAt(i) == ',') {\n                // Skip comma or go beyond 'len' to break the loop.\n                i++;\n                value = null;\n            } else {\n                // Skip '='.\n                i++;\n\n                // Skip whitespaces.\n                for (; i < len; i++) {\n                    final char ch = directives.charAt(i);\n                    if (ch != ' ' && ch != '\\t') {\n                        break;\n                    }\n                }\n\n                if (i < len && directives.charAt(i) == '\\\"') {\n                    // Handle quoted string.\n                    // Skip the opening quote.\n                    i++;\n                    final int valueStart = i;\n\n                    // Find the closing quote.\n                    for (; i < len; i++) {\n                        if (directives.charAt(i) == '\\\"') {\n                            break;\n                        }\n                    }\n                    value = directives.substring(valueStart, i);\n\n                    // Skip the closing quote.\n                    i++;\n\n                    // Find the comma and skip it.\n                    for (; i < len; i++) {\n                        if (directives.charAt(i) == ',') {\n                            i++;\n                            break;\n                        }\n                    }\n                } else {\n                    // Handle unquoted string.\n                    final int valueStart = i;\n\n                    // Find the comma.\n                    for (; i < len; i++) {\n                        if (directives.charAt(i) == ',') {\n                            break;\n                        }\n                    }\n                    value = directives.substring(valueStart, i).trim();\n\n                    // Skip the comma.\n                    i++;\n                }\n            }\n\n            if (!name.isEmpty()) {\n                callback.accept(Ascii.toLowerCase(name), Strings.emptyToNull(value));\n            }\n        }\n    }\n\n    /**\n     * Converts the specified HTTP header directive value into a long integer.\n     *\n     * @return the converted value if {@code value} is equal to or greater than {@code 0}.\n     *         {@code -1} otherwise, i.e. if a negative integer or not a number.\n     */\n    public static long parseDirectiveValueAsSeconds(@Nullable String value) {\n        if (value == null) {\n            return -1;\n        }\n\n        try {\n            final long converted = Long.parseLong(value);\n            return converted >= 0 ? converted : -1;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n\n    /**\n     * Converts the specified Netty HTTP/2 into Armeria HTTP/2 {@link RequestHeaders}.\n     */\n    public static RequestHeaders toArmeriaRequestHeaders(ChannelHandlerContext ctx, Http2Headers headers,\n                                                         boolean endOfStream, String scheme,\n                                                         ServerConfig cfg) {\n        assert headers instanceof ArmeriaHttp2Headers;\n        final HttpHeadersBuilder builder = ((ArmeriaHttp2Headers) headers).delegate();\n        builder.endOfStream(endOfStream);\n        // A CONNECT request might not have \":scheme\". See https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.3\n        if (!builder.contains(HttpHeaderNames.SCHEME)) {\n            builder.add(HttpHeaderNames.SCHEME, scheme);\n        }\n\n        if (builder.get(HttpHeaderNames.AUTHORITY) == null && builder.get(HttpHeaderNames.HOST) == null) {\n            final String defaultHostname = cfg.defaultVirtualHost().defaultHostname();\n            final int port = ((InetSocketAddress) ctx.channel().localAddress()).getPort();\n            builder.add(HttpHeaderNames.AUTHORITY, defaultHostname + ':' + port);\n        }\n        final List<String> cookies = builder.getAll(HttpHeaderNames.COOKIE);\n        if (cookies.size() > 1) {\n            // Cookies must be concatenated into a single octet string.\n            // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n            builder.set(HttpHeaderNames.COOKIE, COOKIE_JOINER.join(cookies));\n        }\n        return RequestHeaders.of(builder.build());\n    }\n\n    /**\n     * Converts the specified Netty HTTP/2 into Armeria HTTP/2 headers.\n     */\n    public static HttpHeaders toArmeria(Http2Headers http2Headers, boolean request, boolean endOfStream) {\n        assert http2Headers instanceof ArmeriaHttp2Headers;\n        final HttpHeadersBuilder delegate = ((ArmeriaHttp2Headers) http2Headers).delegate();\n        delegate.endOfStream(endOfStream);\n        HttpHeaders headers = delegate.build();\n\n        if (request) {\n            if (headers.contains(HttpHeaderNames.METHOD)) {\n                headers = RequestHeaders.of(headers);\n            }\n            // http2Headers should be a trailers\n        } else {\n            if (headers.contains(HttpHeaderNames.STATUS)) {\n                headers = ResponseHeaders.of(headers);\n            }\n        }\n        return headers;\n    }\n\n    /**\n     * Converts the headers of the given Netty HTTP/1.x request into Armeria HTTP/2 headers.\n     * The following headers are only used if they can not be found in the {@code HOST} header or the\n     * {@code Request-Line} as defined by <a href=\"https://datatracker.ietf.org/doc/rfc7230/\">rfc7230</a>\n     * <ul>\n     * <li>{@link ExtensionHeaderNames#SCHEME}</li>\n     * </ul>\n     * {@link ExtensionHeaderNames#PATH} is ignored and instead extracted from the {@code Request-Line}.\n     */\n    public static RequestHeaders toArmeria(ChannelHandlerContext ctx, HttpRequest in,\n                                           ServerConfig cfg, String scheme) throws URISyntaxException {\n\n        final String path = in.uri();\n        if (path.charAt(0) != '/' && !\"*\".equals(path)) {\n            // We support only origin form and asterisk form.\n            throw new URISyntaxException(path, \"neither origin form nor asterisk form\");\n        }\n\n        final io.netty.handler.codec.http.HttpHeaders inHeaders = in.headers();\n        final RequestHeadersBuilder out = RequestHeaders.builder();\n        out.sizeHint(inHeaders.size());\n        out.method(HttpMethod.valueOf(in.method().name()))\n           .path(path)\n           .scheme(scheme);\n\n        // Add the HTTP headers which have not been consumed above\n        toArmeria(inHeaders, out);\n        if (!out.contains(HttpHeaderNames.HOST)) {\n            // The client violates the spec that the request headers must contain a Host header.\n            // But we just add Host header to allow the request.\n            // https://datatracker.ietf.org/doc/html/rfc7230#section-5.4\n            final String defaultHostname = cfg.defaultVirtualHost().defaultHostname();\n            final int port = ((InetSocketAddress) ctx.channel().localAddress()).getPort();\n            out.add(HttpHeaderNames.HOST, defaultHostname + ':' + port);\n        }\n        return out.build();\n    }\n\n    /**\n     * Converts the headers of the given Netty HTTP/1.x response into Armeria HTTP/2 headers.\n     */\n    public static ResponseHeaders toArmeria(HttpResponse in) {\n        final io.netty.handler.codec.http.HttpHeaders inHeaders = in.headers();\n        final ResponseHeadersBuilder out = ResponseHeaders.builder();\n        out.sizeHint(inHeaders.size());\n        out.status(HttpStatus.valueOf(in.status().code()));\n        // Add the HTTP headers which have not been consumed above\n        toArmeria(inHeaders, out);\n        return out.build();\n    }\n\n    /**\n     * Converts the specified Netty HTTP/1 headers into Armeria HTTP/2 headers.\n     */\n    public static HttpHeaders toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders) {\n        if (inHeaders.isEmpty()) {\n            return HttpHeaders.of();\n        }\n\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        out.sizeHint(inHeaders.size());\n        toArmeria(inHeaders, out);\n        return out.build();\n    }\n\n    /**\n     * Converts the specified Netty HTTP/1 headers into Armeria HTTP/2 headers.\n     */\n    public static void toArmeria(io.netty.handler.codec.http.HttpHeaders inHeaders, HttpHeadersBuilder out) {\n        final Iterator<Entry<CharSequence, CharSequence>> iter = inHeaders.iteratorCharSequence();\n        // Choose 8 as a default size because it is unlikely we will see more than 4 Connection headers values,\n        // but still allowing for \"enough\" space in the map to reduce the chance of hash code collision.\n        final CaseInsensitiveMap connectionDisallowedList =\n                toLowercaseMap(inHeaders.valueCharSequenceIterator(HttpHeaderNames.CONNECTION), 8);\n        StringJoiner cookieJoiner = null;\n        while (iter.hasNext()) {\n            final Entry<CharSequence, CharSequence> entry = iter.next();\n            final AsciiString aName = HttpHeaderNames.of(entry.getKey()).toLowerCase();\n            if (HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.contains(aName) ||\n                connectionDisallowedList.contains(aName)) {\n                continue;\n            }\n\n            // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.2 makes a special exception for TE\n            if (aName.equals(HttpHeaderNames.TE)) {\n                toHttp2HeadersFilterTE(entry, out);\n                continue;\n            }\n\n            // Cookies must be concatenated into a single octet string.\n            // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n            final CharSequence value = entry.getValue();\n            if (aName.equals(HttpHeaderNames.COOKIE)) {\n                if (cookieJoiner == null) {\n                    cookieJoiner = new StringJoiner(COOKIE_SEPARATOR);\n                }\n                COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n            } else {\n                out.add(aName, convertHeaderValue(aName, value));\n            }\n        }\n\n        if (cookieJoiner != null && cookieJoiner.length() != 0) {\n            out.add(HttpHeaderNames.COOKIE, cookieJoiner.toString());\n        }\n    }\n\n    private static CaseInsensitiveMap toLowercaseMap(Iterator<? extends CharSequence> valuesIter,\n                                                     int arraySizeHint) {\n        final CaseInsensitiveMap result = new CaseInsensitiveMap(arraySizeHint);\n\n        while (valuesIter.hasNext()) {\n            final AsciiString lowerCased = AsciiString.of(valuesIter.next()).toLowerCase();\n            try {\n                int index = lowerCased.forEachByte(FIND_COMMA);\n                if (index != -1) {\n                    int start = 0;\n                    do {\n                        result.add(lowerCased.subSequence(start, index, false).trim(), EMPTY_STRING);\n                        start = index + 1;\n                    } while (start < lowerCased.length() &&\n                             (index = lowerCased.forEachByte(start,\n                                                             lowerCased.length() - start, FIND_COMMA)) != -1);\n                    result.add(lowerCased.subSequence(start, lowerCased.length(), false).trim(), EMPTY_STRING);\n                } else {\n                    result.add(lowerCased.trim(), EMPTY_STRING);\n                }\n            } catch (Exception e) {\n                // This is not expect to happen because FIND_COMMA never throws but must be caught\n                // because of the ByteProcessor interface.\n                throw new IllegalStateException(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Filter the {@link HttpHeaderNames#TE} header according to the\n     * <a href=\"https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.2\">special rules in the HTTP/2 RFC</a>.\n     *\n     * @param entry the entry whose name is {@link HttpHeaderNames#TE}.\n     * @param out the resulting HTTP/2 headers.\n     */\n    private static void toHttp2HeadersFilterTE(Entry<CharSequence, CharSequence> entry,\n                                               HttpHeadersBuilder out) {\n        if (AsciiString.indexOf(entry.getValue(), ',', 0) == -1) {\n            if (AsciiString.contentEqualsIgnoreCase(AsciiString.trim(entry.getValue()),\n                                                    HttpHeaderValues.TRAILERS)) {\n                out.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS.toString());\n            }\n        } else {\n            final List<CharSequence> teValues = StringUtil.unescapeCsvFields(entry.getValue());\n            for (CharSequence teValue : teValues) {\n                if (AsciiString.contentEqualsIgnoreCase(AsciiString.trim(teValue),\n                                                        HttpHeaderValues.TRAILERS)) {\n                    out.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS.toString());\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 {@link ResponseHeaders} into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 response headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ServerHeaders(HttpHeadersBuilder inputHeaders) {\n        for (Entry<AsciiString, AsciiString> disallowed : HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST) {\n            inputHeaders.remove(disallowed.getKey());\n        }\n        // TODO(ikhoon): Implement HttpHeadersBuilder.remove(Predicate<AsciiString>) to remove values\n        //               with a predicate.\n        for (AsciiString disallowed : disallowedResponseHeaderNames()) {\n            inputHeaders.remove(disallowed);\n        }\n        return new ArmeriaHttp2Headers(inputHeaders);\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 response headers into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 response headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ServerTrailers(HttpHeaders inputHeaders) {\n        final HttpHeadersBuilder builder = inputHeaders.toBuilder();\n\n        for (Entry<AsciiString, AsciiString> disallowed : HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST) {\n            builder.remove(disallowed.getKey());\n        }\n        for (AsciiString disallowed : PSEUDO_HEADERS) {\n           builder.remove(disallowed);\n        }\n        for (Entry<AsciiString, AsciiString> disallowed : HTTP_TRAILER_DISALLOWED_LIST) {\n            builder.remove(disallowed.getKey());\n        }\n\n        return new ArmeriaHttp2Headers(builder);\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ClientHeaders(HttpHeaders inputHeaders) {\n        final int headerSizeHint = inputHeaders.size() + 3; // User_Agent, :scheme and :authority.\n        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n        toNettyHttp2Client(inputHeaders, outputHeaders, false);\n        return outputHeaders;\n    }\n\n    /**\n     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     */\n    public static Http2Headers toNettyHttp2ClientTrailers(HttpHeaders inputHeaders) {\n        final int headerSizeHint = inputHeaders.size();\n        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n        toNettyHttp2Client(inputHeaders, outputHeaders, true);\n        return outputHeaders;\n    }\n\n    private static void toNettyHttp2Client(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n                                           boolean isTrailer) {\n        for (Entry<AsciiString, String> entry : inputHeaders) {\n            final AsciiString name = entry.getKey();\n            final String value = entry.getValue();\n            if (HTTP_TO_HTTP2_HEADER_DISALLOWED_LIST.contains(name)) {\n                continue;\n            }\n\n            if (isTrailer && isTrailerDisallowed(name)) {\n                continue;\n            }\n\n            outputHeaders.add(name, value);\n        }\n\n        if (!outputHeaders.contains(HttpHeaderNames.COOKIE)) {\n            return;\n        }\n\n        // Split up cookies to allow for better compression.\n        // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n        final List<CharSequence> cookies = outputHeaders.getAllAndRemove(HttpHeaderNames.COOKIE);\n        for (CharSequence c : cookies) {\n            outputHeaders.add(HttpHeaderNames.COOKIE, COOKIE_SPLITTER.split(c));\n        }\n    }\n\n    /**\n     * Translates and adds HTTP/2 response headers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders the HTTP/2 response headers to convert.\n     * @param outputHeaders the object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ServerHeaders(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Server(inputHeaders, outputHeaders, http1HeaderNaming, false);\n        HttpUtil.setKeepAlive(outputHeaders, HttpVersion.HTTP_1_1, true);\n    }\n\n    /**\n     * Translates and adds HTTP/2 response trailers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders The HTTP/2 response headers to convert.\n     * @param outputHeaders The object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ServerTrailers(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Server(inputHeaders, outputHeaders, http1HeaderNaming, true);\n    }\n\n    private static void toNettyHttp1Server(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming, boolean isTrailer) {\n        for (Entry<AsciiString, String> entry : inputHeaders) {\n            final AsciiString name = entry.getKey();\n            final String value = entry.getValue();\n            if (HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.contains(name)) {\n                continue;\n            }\n\n            if (isTrailer && isTrailerDisallowed(name)) {\n                continue;\n            }\n            outputHeaders.add(http1HeaderNaming.convert(name), value);\n        }\n    }\n\n    /**\n     * Translates and adds HTTP/2 request headers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     * @param outputHeaders the object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ClientHeaders(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Client(inputHeaders, outputHeaders, http1HeaderNaming, false);\n        HttpUtil.setKeepAlive(outputHeaders, HttpVersion.HTTP_1_1, true);\n    }\n\n    /**\n     * Translates and adds HTTP/2 request headers to HTTP/1.1 headers.\n     *\n     * @param inputHeaders the HTTP/2 request headers to convert.\n     * @param outputHeaders the object which will contain the resulting HTTP/1.1 headers.\n     */\n    public static void toNettyHttp1ClientTrailers(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming) {\n        toNettyHttp1Client(inputHeaders, outputHeaders, http1HeaderNaming, true);\n    }\n\n    private static void toNettyHttp1Client(\n            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n            Http1HeaderNaming http1HeaderNaming, boolean isTrailer) {\n        StringJoiner cookieJoiner = null;\n\n        for (Entry<AsciiString, String> entry : inputHeaders) {\n            final AsciiString name = entry.getKey();\n            final String value = entry.getValue();\n            final AsciiString translatedName = REQUEST_HEADER_TRANSLATIONS.get(name);\n            if (translatedName != null && !inputHeaders.contains(translatedName)) {\n                outputHeaders.add(translatedName, value);\n                continue;\n            }\n\n            if (HTTP2_TO_HTTP_HEADER_DISALLOWED_LIST.contains(name)) {\n                continue;\n            }\n\n            if (isTrailer && isTrailerDisallowed(name)) {\n                continue;\n            }\n\n            if (HttpHeaderNames.COOKIE.equals(name)) {\n                // combine the cookie values into 1 header entry.\n                // https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5\n                if (cookieJoiner == null) {\n                    cookieJoiner = new StringJoiner(COOKIE_SEPARATOR);\n                }\n                COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n            } else {\n                outputHeaders.add(http1HeaderNaming.convert(name), value);\n            }\n        }\n\n        if (cookieJoiner != null && cookieJoiner.length() != 0) {\n            outputHeaders.add(HttpHeaderNames.COOKIE, cookieJoiner.toString());\n        }\n    }\n\n    /**\n     * Returns a {@link ResponseHeaders} whose {@link HttpHeaderNames#CONTENT_LENGTH} is added or removed\n     * according to the status of the specified {@code headers}, {@code content} and {@code trailers}.\n     * The {@link HttpHeaderNames#CONTENT_LENGTH} is removed when:\n     * <ul>\n     *   <li>the status of the specified {@code headers} is one of {@link HttpStatus#NO_CONTENT},\n     *       {@link HttpStatus#RESET_CONTENT} or {@link HttpStatus#NOT_MODIFIED}</li>\n     *   <li>the trailers exists</li>\n     * </ul>\n     * The {@link HttpHeaderNames#CONTENT_LENGTH} is added when the state of the specified {@code headers}\n     * does not meet the conditions above and {@link HttpHeaderNames#CONTENT_LENGTH} is not present\n     * regardless of the fact that the content is empty or not.\n     *\n     * @throws IllegalArgumentException if the specified {@code content} is not empty when the specified\n     *                                  {@link HttpStatus} is one of {@link HttpStatus#NO_CONTENT},\n     *                                  {@link HttpStatus#RESET_CONTENT} and {@link HttpStatus#NOT_MODIFIED}.\n     */\n    public static ResponseHeaders setOrRemoveContentLength(ResponseHeaders headers, HttpData content,\n                                                           HttpHeaders trailers) {\n        requireNonNull(headers, \"headers\");\n        requireNonNull(content, \"content\");\n        requireNonNull(trailers, \"trailers\");\n\n        final HttpStatus status = headers.status();\n\n        if (isContentAlwaysEmptyWithValidation(status, content)) {\n            if (status != HttpStatus.NOT_MODIFIED) {\n                if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n                    final ResponseHeadersBuilder builder = headers.toBuilder();\n                    builder.remove(HttpHeaderNames.CONTENT_LENGTH);\n                    return builder.build();\n                }\n            } else {\n                // 304 response can have the \"content-length\" header when it is a response to a conditional\n                // GET request. See https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2\n            }\n\n            return headers;\n        }\n\n        if (!trailers.isEmpty()) {\n            // Some of the client implementations such as \"curl\" ignores trailers if\n            // the \"content-length\" header is present. We should not set \"content-length\" header when\n            // trailers exists so that those clients can receive the trailers.\n            // The response is sent using chunked transfer encoding in HTTP/1 or a DATA frame payload\n            // in HTTP/2, so it's no worry.\n            if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n                final ResponseHeadersBuilder builder = headers.toBuilder();\n                builder.remove(HttpHeaderNames.CONTENT_LENGTH);\n                return builder.build();\n            }\n\n            return headers;\n        }\n\n        if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH) || !content.isEmpty()) {\n            return headers.toBuilder()\n                          .contentLength(content.length())\n                          .build();\n        }\n\n        // The header contains \"content-length\" header and the content is empty.\n        // Do not overwrite the header because a response to a HEAD request\n        // will have no content even if it has non-zero content-length header.\n        return headers;\n    }\n\n    public static String convertHeaderValue(AsciiString name, CharSequence value) {\n        if (!(value instanceof AsciiString)) {\n            return value.toString();\n        }\n        if (HEADER_VALUE_CACHE != null && CACHED_HEADERS.contains(name)) {\n            final String converted = HEADER_VALUE_CACHE.get((AsciiString) value);\n            assert converted != null; // loader does not return null.\n            return converted;\n        }\n        return value.toString();\n    }\n\n    /**\n     * Returns {@code true} if the specified header name is not allowed for HTTP trailers.\n     */\n    public static boolean isTrailerDisallowed(AsciiString name) {\n        return HTTP_TRAILER_DISALLOWED_LIST.contains(name);\n    }\n\n    private static final class CaseInsensitiveMap\n            extends DefaultHeaders<AsciiString, AsciiString, CaseInsensitiveMap> {\n\n        CaseInsensitiveMap() {\n            super(HTTP2_HEADER_NAME_HASHER, UnsupportedValueConverter.instance());\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        CaseInsensitiveMap(int size) {\n            super(HTTP2_HEADER_NAME_HASHER, UnsupportedValueConverter.instance(), NameValidator.NOT_NULL, size);\n        }\n    }\n\n    /**\n     * Returns a authority header value of specified host and port.\n     */\n    public static String authorityHeader(String host, int port, int defaultPort) {\n        if (port == defaultPort) {\n            return host;\n        } else {\n            final StringBuilder buf = new StringBuilder(host.length() + 6);\n            buf.append(host);\n            buf.append(':');\n            buf.append(port);\n            return buf.toString();\n        }\n    }\n\n    /**\n     * A 408 Request Timeout response can be received even without a request.\n     * More details can be found at https://github.com/line/armeria/issues/3055.\n     */\n    public static boolean isRequestTimeoutResponse(HttpResponse httpResponse) {\n        return httpResponse.status() == HttpResponseStatus.REQUEST_TIMEOUT &&\n               \"close\".equalsIgnoreCase(httpResponse.headers().get(HttpHeaderNames.CONNECTION));\n    }\n\n    private ArmeriaHttpUtil() {}\n}\n", "/*\n * Copyright 2017 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.internal.common;\n\nimport static io.netty.util.internal.StringUtil.decodeHexNibble;\nimport static java.util.Objects.requireNonNull;\n\nimport java.util.BitSet;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport com.github.benmanes.caffeine.cache.Cache;\nimport com.github.benmanes.caffeine.cache.Caffeine;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport com.linecorp.armeria.common.Flags;\nimport com.linecorp.armeria.common.annotation.Nullable;\nimport com.linecorp.armeria.common.metric.MeterIdPrefix;\nimport com.linecorp.armeria.internal.common.metric.CaffeineMetricSupport;\n\nimport io.micrometer.core.instrument.MeterRegistry;\nimport it.unimi.dsi.fastutil.Arrays;\nimport it.unimi.dsi.fastutil.bytes.ByteArrays;\n\n/**\n * A parser of the raw path and query components of an HTTP path. Performs validation and allows caching of\n * results.\n */\npublic final class PathAndQuery {\n\n    private static final PathAndQuery ROOT_PATH_QUERY = new PathAndQuery(\"/\", null);\n\n    /**\n     * The lookup table for the characters allowed in a path.\n     */\n    private static final BitSet ALLOWED_PATH_CHARS = new BitSet();\n\n    /**\n     * The lookup table for the characters allowed in a query string.\n     */\n    private static final BitSet ALLOWED_QUERY_CHARS = new BitSet();\n\n    /**\n     * The lookup table for the reserved characters that require percent-encoding.\n     */\n    private static final BitSet RESERVED_CHARS = new BitSet();\n\n    /**\n     * The table that converts a byte into a percent-encoded chars, e.g. 'A' -> \"%41\".\n     */\n    private static final char[][] TO_PERCENT_ENCODED_CHARS = new char[256][];\n\n    static {\n        final String allowedPathChars =\n                \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=\";\n        for (int i = 0; i < allowedPathChars.length(); i++) {\n            ALLOWED_PATH_CHARS.set(allowedPathChars.charAt(i));\n        }\n\n        final String allowedQueryChars =\n                \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*,;=\";\n        for (int i = 0; i < allowedQueryChars.length(); i++) {\n            ALLOWED_QUERY_CHARS.set(allowedQueryChars.charAt(i));\n        }\n\n        final String reservedChars = \":/?#[]@!$&'()*+,;=\";\n        for (int i = 0; i < reservedChars.length(); i++) {\n            RESERVED_CHARS.set(reservedChars.charAt(i));\n        }\n\n        for (int i = 0; i < TO_PERCENT_ENCODED_CHARS.length; i++) {\n            TO_PERCENT_ENCODED_CHARS[i] = String.format(\"%%%02X\", i).toCharArray();\n        }\n    }\n\n    private static final Bytes EMPTY_QUERY = new Bytes(0);\n    private static final Bytes ROOT_PATH = new Bytes(new byte[] { '/' });\n\n    @Nullable\n    private static final Cache<String, PathAndQuery> CACHE =\n            Flags.parsedPathCacheSpec() != null ? buildCache(Flags.parsedPathCacheSpec()) : null;\n\n    private static Cache<String, PathAndQuery> buildCache(String spec) {\n        return Caffeine.from(spec).build();\n    }\n\n    public static void registerMetrics(MeterRegistry registry, MeterIdPrefix idPrefix) {\n        if (CACHE != null) {\n            CaffeineMetricSupport.setup(registry, idPrefix, CACHE);\n        }\n    }\n\n    /**\n     * Clears the currently cached parsed paths. Only for use in tests.\n     */\n    @VisibleForTesting\n    public static void clearCachedPaths() {\n        requireNonNull(CACHE, \"CACHE\");\n        CACHE.asMap().clear();\n    }\n\n    /**\n     * Returns paths that have had their parse result cached. Only for use in tests.\n     */\n    @VisibleForTesting\n    public static Set<String> cachedPaths() {\n        requireNonNull(CACHE, \"CACHE\");\n        return CACHE.asMap().keySet();\n    }\n\n    /**\n     * Validates the {@link String} that contains an absolute path and a query, and splits them into\n     * the path part and the query part. If the path is usable (e.g., can be served a successful response from\n     * the server and doesn't have variable path parameters), {@link PathAndQuery#storeInCache(String)} should\n     * be called to cache the parsing result for faster future invocations.\n     *\n     * @return a {@link PathAndQuery} with the absolute path and query, or {@code null} if the specified\n     *         {@link String} is not an absolute path or invalid.\n     */\n    @Nullable\n    public static PathAndQuery parse(@Nullable String rawPath) {\n        if (CACHE != null && rawPath != null) {\n            final PathAndQuery parsed = CACHE.getIfPresent(rawPath);\n            if (parsed != null) {\n                return parsed;\n            }\n        }\n        return splitPathAndQuery(rawPath);\n    }\n\n    /**\n     * Stores this {@link PathAndQuery} into cache for the given raw path. This should be used by callers when\n     * the parsed result was valid (e.g., when a server is able to successfully handle the parsed path).\n     */\n    public void storeInCache(@Nullable String rawPath) {\n        if (CACHE != null && !cached && rawPath != null) {\n            cached = true;\n            CACHE.put(rawPath, this);\n        }\n    }\n\n    private final String path;\n    @Nullable\n    private final String query;\n\n    private boolean cached;\n\n    private PathAndQuery(String path, @Nullable String query) {\n        this.path = path;\n        this.query = query;\n    }\n\n    public String path() {\n        return path;\n    }\n\n    @Nullable\n    public String query() {\n        return query;\n    }\n\n    @Override\n    public boolean equals(@Nullable Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (!(o instanceof PathAndQuery)) {\n            return false;\n        }\n\n        final PathAndQuery that = (PathAndQuery) o;\n        return Objects.equals(path, that.path) &&\n               Objects.equals(query, that.query);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(path, query);\n    }\n\n    @Override\n    public String toString() {\n        if (query == null) {\n            return path;\n        }\n        return path + '?' + query;\n    }\n\n    @Nullable\n    private static PathAndQuery splitPathAndQuery(@Nullable final String pathAndQuery) {\n        final Bytes path;\n        final Bytes query;\n\n        if (pathAndQuery == null) {\n            return ROOT_PATH_QUERY;\n        }\n\n        // Split by the first '?'.\n        final int queryPos = pathAndQuery.indexOf('?');\n        if (queryPos >= 0) {\n            if ((path = decodePercentsAndEncodeToUtf8(\n                    pathAndQuery, 0, queryPos, true)) == null) {\n                return null;\n            }\n            if ((query = decodePercentsAndEncodeToUtf8(\n                    pathAndQuery, queryPos + 1, pathAndQuery.length(), false)) == null) {\n                return null;\n            }\n        } else {\n            if ((path = decodePercentsAndEncodeToUtf8(\n                    pathAndQuery, 0, pathAndQuery.length(), true)) == null) {\n                return null;\n            }\n            query = null;\n        }\n\n        if (path.data[0] != '/' || path.isEncoded(0)) {\n            // Do not accept a relative path.\n            return null;\n        }\n\n        // Reject the prohibited patterns.\n        if (pathContainsDoubleDots(path) || queryContainsDoubleDots(query)) {\n            return null;\n        }\n\n        return new PathAndQuery(encodePathToPercents(path), encodeQueryToPercents(query));\n    }\n\n    @Nullable\n    private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int end, boolean isPath) {\n        final int length = end - start;\n        if (length == 0) {\n            return isPath ? ROOT_PATH : EMPTY_QUERY;\n        }\n\n        final Bytes buf = new Bytes(Math.max(length * 3 / 2, 4));\n        boolean wasSlash = false;\n        for (final CodePointIterator i = new CodePointIterator(value, start, end);\n             i.hasNextCodePoint();/* noop */) {\n            final int pos = i.position();\n            final int cp = i.nextCodePoint();\n\n            if (cp == '%') {\n                final int hexEnd = pos + 3;\n                if (hexEnd > end) {\n                    // '%' or '%x' (must be followed by two hexadigits)\n                    return null;\n                }\n\n                final int digit1 = decodeHexNibble(value.charAt(pos + 1));\n                final int digit2 = decodeHexNibble(value.charAt(pos + 2));\n                if (digit1 < 0 || digit2 < 0) {\n                    // The first or second digit is not hexadecimal.\n                    return null;\n                }\n\n                final int decoded = (digit1 << 4) | digit2;\n                if (isPath) {\n                    if (decoded == '/') {\n                        // Do not decode '%2F' and '%2f' in the path to '/' for compatibility with\n                        // other implementations in the ecosystem, e.g. HTTP/JSON to gRPC transcoding.\n                        // https://github.com/googleapis/googleapis/blob/02710fa0ea5312d79d7fb986c9c9823fb41049a9/google/api/http.proto#L257-L258\n                        buf.ensure(1);\n                        buf.addEncoded((byte) '/');\n                        wasSlash = false;\n                    } else {\n                        if (appendOneByte(buf, decoded, wasSlash, isPath)) {\n                            wasSlash = false;\n                        } else {\n                            return null;\n                        }\n                    }\n                } else {\n                    // If query:\n                    if (RESERVED_CHARS.get(decoded)) {\n                        buf.ensure(1);\n                        buf.addEncoded((byte) decoded);\n                        wasSlash = false;\n                    } else if (appendOneByte(buf, decoded, wasSlash, isPath)) {\n                        wasSlash = decoded == '/';\n                    } else {\n                        return null;\n                    }\n                }\n\n                i.position(hexEnd);\n                continue;\n            }\n\n            if (cp == '+' && !isPath) {\n                buf.ensure(1);\n                buf.addEncoded((byte) ' ');\n                wasSlash = false;\n                continue;\n            }\n\n            if (cp <= 0x7F) {\n                if (!appendOneByte(buf, cp, wasSlash, isPath)) {\n                    return null;\n                }\n                wasSlash = cp == '/';\n                continue;\n            }\n\n            if (cp <= 0x7ff) {\n                buf.ensure(2);\n                buf.addEncoded((byte) ((cp >>> 6) | 0b110_00000));\n                buf.addEncoded((byte) (cp & 0b111111 | 0b10_000000));\n            } else if (cp <= 0xffff) {\n                buf.ensure(3);\n                buf.addEncoded((byte) ((cp >>> 12) | 0b1110_0000));\n                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n            } else if (cp <= 0x1fffff) {\n                buf.ensure(4);\n                buf.addEncoded((byte) ((cp >>> 18) | 0b11110_000));\n                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n            } else if (cp <= 0x3ffffff) {\n                // A valid unicode character will never reach here, but for completeness.\n                // http://unicode.org/mail-arch/unicode-ml/Archives-Old/UML018/0330.html\n                buf.ensure(5);\n                buf.addEncoded((byte) ((cp >>> 24) | 0b111110_00));\n                buf.addEncoded((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n            } else {\n                // A valid unicode character will never reach here, but for completeness.\n                // http://unicode.org/mail-arch/unicode-ml/Archives-Old/UML018/0330.html\n                buf.ensure(6);\n                buf.addEncoded((byte) ((cp >>> 30) | 0b1111110_0));\n                buf.addEncoded((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));\n                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));\n            }\n\n            wasSlash = false;\n        }\n\n        return buf;\n    }\n\n    private static boolean appendOneByte(Bytes buf, int cp, boolean wasSlash, boolean isPath) {\n        if (cp == 0x7F) {\n            // Reject the control character: 0x7F\n            return false;\n        }\n\n        if (cp >>> 5 == 0) {\n            // Reject the control characters: 0x00..0x1F\n            if (isPath) {\n                return false;\n            } else if (cp != 0x0A && cp != 0x0D && cp != 0x09) {\n                // .. except 0x0A (LF), 0x0D (CR) and 0x09 (TAB) because they are used in a form.\n                return false;\n            }\n        }\n\n        if (cp == '/' && isPath) {\n            if (!wasSlash) {\n                buf.ensure(1);\n                buf.add((byte) '/');\n            } else {\n                // Remove the consecutive slashes: '/path//with///consecutive////slashes'.\n            }\n        } else {\n            final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;\n            buf.ensure(1);\n            if (allowedChars.get(cp)) {\n                buf.add((byte) cp);\n            } else {\n                buf.addEncoded((byte) cp);\n            }\n        }\n\n        return true;\n    }\n\n    private static boolean pathContainsDoubleDots(Bytes path) {\n        final int length = path.length;\n        byte b0 = 0;\n        byte b1 = 0;\n        byte b2 = '/';\n        for (int i = 1; i < length; i++) {\n            final byte b3 = path.data[i];\n            // Flag if the last four bytes are `/../`.\n            if (b1 == '.' && b2 == '.' && isSlash(b0) && isSlash(b3)) {\n                return true;\n            }\n            b0 = b1;\n            b1 = b2;\n            b2 = b3;\n        }\n\n        // Flag if the last three bytes are `/..`.\n        return b1 == '.' && b2 == '.' && isSlash(b0);\n    }\n\n    private static boolean queryContainsDoubleDots(@Nullable Bytes query) {\n        if (query == null) {\n            return false;\n        }\n\n        final int length = query.length;\n        boolean lookingForEquals = true;\n        byte b0 = 0;\n        byte b1 = 0;\n        byte b2 = '/';\n        for (int i = 0; i < length; i++) {\n            byte b3 = query.data[i];\n\n            // Treat the delimiters as `/` so that we can use isSlash() for matching them.\n            switch (b3) {\n                case '=':\n                    // Treat only the first `=` as `/`, e.g.\n                    // - `foo=..` and `foo=../` should be flagged.\n                    // - `foo=..=` shouldn't be flagged because `..=` is not a relative path.\n                    if (lookingForEquals) {\n                        lookingForEquals = false;\n                        b3 = '/';\n                    }\n                    break;\n                case '&':\n                case ';':\n                    b3 = '/';\n                    lookingForEquals = true;\n                    break;\n            }\n\n            // Flag if the last four bytes are `/../` or `/..&`\n            if (b1 == '.' && b2 == '.' && isSlash(b0) && isSlash(b3)) {\n                return true;\n            }\n\n            b0 = b1;\n            b1 = b2;\n            b2 = b3;\n        }\n\n        return b1 == '.' && b2 == '.' && isSlash(b0);\n    }\n\n    private static boolean isSlash(byte b) {\n        switch (b) {\n            case '/':\n            case '\\\\':\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    private static String encodePathToPercents(Bytes value) {\n        if (!value.hasEncodedBytes()) {\n            // Deprecated, but it fits perfect for our use case.\n            // noinspection deprecation\n            return new String(value.data, 0, 0, value.length);\n        }\n\n        // Slow path: some percent-encoded chars.\n        return slowEncodePathToPercents(value);\n    }\n\n    @Nullable\n    private static String encodeQueryToPercents(@Nullable Bytes value) {\n        if (value == null) {\n            return null;\n        }\n\n        if (!value.hasEncodedBytes()) {\n            // Deprecated, but it fits perfect for our use case.\n            // noinspection deprecation\n            return new String(value.data, 0, 0, value.length);\n        }\n\n        // Slow path: some percent-encoded chars.\n        return slowEncodeQueryToPercents(value);\n    }\n\n    private static String slowEncodePathToPercents(Bytes value) {\n        final int length = value.length;\n        final StringBuilder buf = new StringBuilder(length + value.numEncodedBytes() * 2);\n        for (int i = 0; i < length; i++) {\n            final int b = value.data[i] & 0xFF;\n\n            if (value.isEncoded(i)) {\n                buf.append(TO_PERCENT_ENCODED_CHARS[b]);\n                continue;\n            }\n\n            buf.append((char) b);\n        }\n\n        return buf.toString();\n    }\n\n    private static String slowEncodeQueryToPercents(Bytes value) {\n        final int length = value.length;\n        final StringBuilder buf = new StringBuilder(length + value.numEncodedBytes() * 2);\n        for (int i = 0; i < length; i++) {\n            final int b = value.data[i] & 0xFF;\n\n            if (value.isEncoded(i)) {\n                if (b == ' ') {\n                    buf.append('+');\n                } else {\n                    buf.append(TO_PERCENT_ENCODED_CHARS[b]);\n                }\n                continue;\n            }\n\n            buf.append((char) b);\n        }\n\n        return buf.toString();\n    }\n\n    private static final class Bytes {\n        byte[] data;\n        int length;\n        @Nullable\n        private BitSet encoded;\n        private int numEncodedBytes;\n\n        Bytes(int initialCapacity) {\n            data = new byte[initialCapacity];\n        }\n\n        Bytes(byte[] data) {\n            this.data = data;\n            length = data.length;\n        }\n\n        void add(byte b) {\n            data[length++] = b;\n        }\n\n        void addEncoded(byte b) {\n            if (encoded == null) {\n                encoded = new BitSet();\n            }\n            encoded.set(length);\n            data[length++] = b;\n            numEncodedBytes++;\n        }\n\n        boolean isEncoded(int index) {\n            return encoded != null && encoded.get(index);\n        }\n\n        boolean hasEncodedBytes() {\n            return encoded != null;\n        }\n\n        int numEncodedBytes() {\n            return numEncodedBytes;\n        }\n\n        void ensure(int numBytes) {\n            int newCapacity = length + numBytes;\n            if (newCapacity <= data.length) {\n                return;\n            }\n\n            newCapacity =\n                    (int) Math.max(Math.min((long) data.length + (data.length >> 1), Arrays.MAX_ARRAY_SIZE),\n                                   newCapacity);\n\n            data = ByteArrays.forceCapacity(data, newCapacity, length);\n        }\n    }\n\n    private static final class CodePointIterator {\n        private final CharSequence str;\n        private final int end;\n        private int pos;\n\n        CodePointIterator(CharSequence str, int start, int end) {\n            this.str = str;\n            this.end = end;\n            pos = start;\n        }\n\n        int position() {\n            return pos;\n        }\n\n        void position(int pos) {\n            this.pos = pos;\n        }\n\n        boolean hasNextCodePoint() {\n            return pos < end;\n        }\n\n        int nextCodePoint() {\n            assert pos < end;\n\n            final char c1 = str.charAt(pos++);\n            if (Character.isHighSurrogate(c1) && pos < end) {\n                final char c2 = str.charAt(pos);\n                if (Character.isLowSurrogate(c2)) {\n                    pos++;\n                    return Character.toCodePoint(c1, c2);\n                }\n            }\n\n            return c1;\n        }\n    }\n}\n", "/*\n * Copyright 2019 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.server;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.linecorp.armeria.server.RoutingResult.LOWEST_SCORE;\nimport static java.util.Objects.requireNonNull;\n\nimport com.google.common.collect.ImmutableMap;\n\nimport com.linecorp.armeria.common.MediaType;\nimport com.linecorp.armeria.common.annotation.Nullable;\nimport com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n\n/**\n * Builds a new {@link RoutingResult}.\n */\npublic final class RoutingResultBuilder {\n\n    private RoutingResultType type = RoutingResultType.MATCHED;\n\n    @Nullable\n    private String path;\n\n    @Nullable\n    private String query;\n\n    @Nullable\n    private ImmutableMap.Builder<String, String> pathParams;\n\n    private int score = LOWEST_SCORE;\n\n    @Nullable\n    private MediaType negotiatedResponseMediaType;\n\n    RoutingResultBuilder() {}\n\n    RoutingResultBuilder(int expectedNumParams) {\n        pathParams = ImmutableMap.builderWithExpectedSize(expectedNumParams);\n    }\n\n    /**\n     * Sets the result type.\n     *\n     * @param type {@link RoutingResultType#MATCHED} or {@link RoutingResultType#CORS_PREFLIGHT}.\n     */\n    public RoutingResultBuilder type(RoutingResultType type) {\n        requireNonNull(type, \"type\");\n        checkArgument(type != RoutingResultType.NOT_MATCHED,\n                      \"type: %s (expected: %s or %s)\",\n                      type, RoutingResultType.MATCHED, RoutingResultType.CORS_PREFLIGHT);\n        this.type = type;\n        return this;\n    }\n\n    /**\n     * Sets the mapped path, encoded as defined in <a href=\"https://datatracker.ietf.org/doc/rfc3986/\">RFC3986</a>.\n     */\n    public RoutingResultBuilder path(String path) {\n        this.path = requireNonNull(path, \"path\");\n        return this;\n    }\n\n    /**\n     * Sets the specified query.\n     */\n    public RoutingResultBuilder query(@Nullable String query) {\n        this.query = query;\n        return this;\n    }\n\n    /**\n     * Adds a decoded path parameter.\n     */\n    public RoutingResultBuilder decodedParam(String name, String value) {\n        pathParams().put(requireNonNull(name, \"name\"), requireNonNull(value, \"value\"));\n        return this;\n    }\n\n    /**\n     * Adds an encoded path parameter, which will be decoded in UTF-8 automatically.\n     */\n    public RoutingResultBuilder rawParam(String name, String value) {\n        pathParams().put(requireNonNull(name, \"name\"),\n                         ArmeriaHttpUtil.decodePathParam(requireNonNull(value, \"value\")));\n        return this;\n    }\n\n    /**\n     * Sets the score.\n     */\n    public RoutingResultBuilder score(int score) {\n        this.score = score;\n        return this;\n    }\n\n    /**\n     * Sets the negotiated producible {@link MediaType}.\n     */\n    public RoutingResultBuilder negotiatedResponseMediaType(MediaType negotiatedResponseMediaType) {\n        this.negotiatedResponseMediaType = requireNonNull(negotiatedResponseMediaType,\n                                                          \"negotiatedResponseMediaType\");\n        return this;\n    }\n\n    /**\n     * Returns a newly-created {@link RoutingResult}.\n     */\n    public RoutingResult build() {\n        if (path == null) {\n            return RoutingResult.empty();\n        }\n\n        return new RoutingResult(type, path, query,\n                                 pathParams != null ? pathParams.build() : ImmutableMap.of(),\n                                 score, negotiatedResponseMediaType);\n    }\n\n    private ImmutableMap.Builder<String, String> pathParams() {\n        if (pathParams != null) {\n            return pathParams;\n        }\n        return pathParams = ImmutableMap.builder();\n    }\n}\n", "/*\n * Copyright 2017 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.internal.common;\n\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.concatPaths;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.decodePath;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.parseDirectives;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toArmeria;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ClientHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp1ServerHeaders;\nimport static com.linecorp.armeria.internal.common.ArmeriaHttpUtil.toNettyHttp2ClientHeaders;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\nimport java.net.InetSocketAddress;\nimport java.net.URISyntaxException;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nimport com.google.common.collect.ImmutableList;\n\nimport com.linecorp.armeria.common.Http1HeaderNaming;\nimport com.linecorp.armeria.common.HttpHeaderNames;\nimport com.linecorp.armeria.common.HttpHeaders;\nimport com.linecorp.armeria.common.HttpHeadersBuilder;\nimport com.linecorp.armeria.common.HttpResponse;\nimport com.linecorp.armeria.common.HttpStatus;\nimport com.linecorp.armeria.common.MediaType;\nimport com.linecorp.armeria.common.RequestHeaders;\nimport com.linecorp.armeria.common.ResponseHeaders;\nimport com.linecorp.armeria.common.ResponseHeadersBuilder;\nimport com.linecorp.armeria.server.Server;\nimport com.linecorp.armeria.server.ServerConfig;\n\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.DefaultHttpRequest;\nimport io.netty.handler.codec.http.HttpHeaderValues;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\nimport io.netty.util.AsciiString;\n\nclass ArmeriaHttpUtilTest {\n\n    @Test\n    void testConcatPaths() throws Exception {\n        assertThat(concatPaths(null, \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(null, \"/a\")).isEqualTo(\"/a\");\n\n        assertThat(concatPaths(\"\", \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"\", \"/a\")).isEqualTo(\"/a\");\n\n        assertThat(concatPaths(\"/\", \"a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"/\", \"/a\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"/\", \"/\")).isEqualTo(\"/\");\n\n        assertThat(concatPaths(\"/a\", \"b\")).isEqualTo(\"/a/b\");\n        assertThat(concatPaths(\"/a\", \"/b\")).isEqualTo(\"/a/b\");\n        assertThat(concatPaths(\"/a/\", \"/b\")).isEqualTo(\"/a/b\");\n\n        assertThat(concatPaths(\"/a\", \"\")).isEqualTo(\"/a\");\n        assertThat(concatPaths(\"/a/\", \"\")).isEqualTo(\"/a/\");\n        assertThat(concatPaths(\"/a\", \"?foo=bar\")).isEqualTo(\"/a?foo=bar\");\n        assertThat(concatPaths(\"/a/\", \"?foo=bar\")).isEqualTo(\"/a/?foo=bar\");\n    }\n\n    @ParameterizedTest\n    @CsvSource({ \"true\", \"false\" })\n    void testDecodePath(boolean isPathParam) throws Exception {\n        final Function<String, String> decodeFunc;\n        if (isPathParam) {\n            decodeFunc = ArmeriaHttpUtil::decodePathParam;\n        } else {\n            decodeFunc = ArmeriaHttpUtil::decodePath;\n        }\n\n        // Fast path\n        final String pathThatDoesNotNeedDecode = \"/foo_bar_baz\";\n        assertThat(decodeFunc.apply(pathThatDoesNotNeedDecode)).isSameAs(pathThatDoesNotNeedDecode);\n\n        // Slow path\n        assertThat(decodeFunc.apply(\"/foo%20bar\\u007fbaz\")).isEqualTo(\"/foo bar\\u007fbaz\");\n        assertThat(decodeFunc.apply(\"/%C2%A2\")).isEqualTo(\"/\u00a2\"); // Valid UTF-8 sequence\n        assertThat(decodeFunc.apply(\"/%20\\u0080\")).isEqualTo(\"/ \ufffd\"); // Unallowed character\n        assertThat(decodeFunc.apply(\"/%\")).isEqualTo(\"/\ufffd\"); // No digit\n        assertThat(decodeFunc.apply(\"/%1\")).isEqualTo(\"/\ufffd\"); // Only a single digit\n        assertThat(decodeFunc.apply(\"/%G0\")).isEqualTo(\"/\ufffd\"); // First digit is not hex.\n        assertThat(decodeFunc.apply(\"/%0G\")).isEqualTo(\"/\ufffd\"); // Second digit is not hex.\n        assertThat(decodeFunc.apply(\"/%C3%28\")).isEqualTo(\"/\ufffd(\"); // Invalid UTF-8 sequence\n\n        // %2F (/) must be decoded only for path parameters.\n        if (isPathParam) {\n            assertThat(decodeFunc.apply(\"/%2F\")).isEqualTo(\"//\");\n        } else {\n            assertThat(decodeFunc.apply(\"/%2F\")).isEqualTo(\"/%2F\");\n        }\n    }\n\n    @Test\n    void testParseDirectives() {\n        final Map<String, String> values = new LinkedHashMap<>();\n        final BiConsumer<String, String> cb = (name, value) -> assertThat(values.put(name, value)).isNull();\n\n        // Make sure an effectively empty string does not invoke a callback.\n        parseDirectives(\"\", cb);\n        assertThat(values).isEmpty();\n        parseDirectives(\" \\t \", cb);\n        assertThat(values).isEmpty();\n        parseDirectives(\" ,,=, =,= ,\", cb);\n        assertThat(values).isEmpty();\n\n        // Name only.\n        parseDirectives(\"no-cache\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"no-cache\", null);\n        values.clear();\n        parseDirectives(\" no-cache \", cb);\n        assertThat(values).hasSize(1).containsEntry(\"no-cache\", null);\n        values.clear();\n        parseDirectives(\"no-cache ,\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"no-cache\", null);\n        values.clear();\n\n        // Name and value.\n        parseDirectives(\"max-age=86400\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = 86400 \", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = 86400 ,\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\"max-age=\\\"86400\\\"\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = \\\"86400\\\" \", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n        parseDirectives(\" max-age = \\\"86400\\\" ,\", cb);\n        assertThat(values).hasSize(1).containsEntry(\"max-age\", \"86400\");\n        values.clear();\n\n        // Multiple names and values.\n        parseDirectives(\"a,b=c,d,e=\\\"f\\\",g\", cb);\n        assertThat(values).hasSize(5)\n                          .containsEntry(\"a\", null)\n                          .containsEntry(\"b\", \"c\")\n                          .containsEntry(\"d\", null)\n                          .containsEntry(\"e\", \"f\")\n                          .containsEntry(\"g\", null);\n    }\n\n    @Test\n    void outboundCookiesMustBeMergedForHttp1() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.COOKIE, \"a=b; c=d\")\n                                          .add(HttpHeaderNames.COOKIE, \"e=f;g=h\")\n                                          .addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8)\n                                          .add(HttpHeaderNames.COOKIE, \"i=j\")\n                                          .add(HttpHeaderNames.COOKIE, \"k=l;\")\n                                          .build();\n\n        final io.netty.handler.codec.http.HttpHeaders out =\n                new DefaultHttpHeaders();\n\n        toNettyHttp1ClientHeaders(in, out, Http1HeaderNaming.ofDefault());\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b; c=d; e=f; g=h; i=j; k=l\");\n    }\n\n    @Test\n    void outboundCookiesMustBeSplitForHttp2() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.COOKIE, \"a=b; c=d\")\n                                          .add(HttpHeaderNames.COOKIE, \"e=f;g=h\")\n                                          .addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8)\n                                          .add(HttpHeaderNames.COOKIE, \"i=j\")\n                                          .add(HttpHeaderNames.COOKIE, \"k=l;\")\n                                          .build();\n\n        final Http2Headers out = toNettyHttp2ClientHeaders(in);\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b\", \"c=d\", \"e=f\", \"g=h\", \"i=j\", \"k=l\");\n    }\n\n    @Test\n    void inboundCookiesMustBeMergedForHttp1() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n        in.add(HttpHeaderNames.COOKIE, \"e=f;g=h\");\n        in.add(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8);\n        in.add(HttpHeaderNames.COOKIE, \"i=j\");\n        in.add(HttpHeaderNames.COOKIE, \"k=l;\");\n\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b; c=d; e=f; g=h; i=j; k=l\");\n    }\n\n    @Test\n    void endOfStreamSet() {\n        final Http2Headers in = new ArmeriaHttp2Headers();\n        in.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n        final HttpHeaders out = toArmeria(in, true, true);\n        assertThat(out.isEndOfStream()).isTrue();\n\n        final HttpHeaders out2 = toArmeria(in, true, false);\n        assertThat(out2.isEndOfStream()).isFalse();\n    }\n\n    @Test\n    void endOfStreamSetEmpty() {\n        final Http2Headers in = new ArmeriaHttp2Headers();\n        final HttpHeaders out = toArmeria(in, true, true);\n        assertThat(out.isEndOfStream()).isTrue();\n\n        final HttpHeaders out2 = toArmeria(in, true, false);\n        assertThat(out2.isEndOfStream()).isFalse();\n    }\n\n    @Test\n    void inboundCookiesMustBeMergedForHttp2() {\n        final Http2Headers in = new ArmeriaHttp2Headers();\n\n        in.add(HttpHeaderNames.METHOD, \"GET\");\n        in.add(HttpHeaderNames.SCHEME, \"http\");\n        in.add(HttpHeaderNames.AUTHORITY, \"foo.com\");\n        in.add(HttpHeaderNames.PATH, \"/\");\n        in.add(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n        in.add(HttpHeaderNames.COOKIE, \"e=f;g=h\");\n        in.addObject(HttpHeaderNames.CONTENT_TYPE, MediaType.PLAIN_TEXT_UTF_8);\n        in.add(HttpHeaderNames.COOKIE, \"i=j\");\n        in.add(HttpHeaderNames.COOKIE, \"k=l;\");\n\n        final RequestHeaders out = ArmeriaHttpUtil.toArmeriaRequestHeaders(null, in, false, \"http\", null);\n\n        assertThat(out.getAll(HttpHeaderNames.COOKIE))\n                .containsExactly(\"a=b; c=d; e=f;g=h; i=j; k=l;\");\n    }\n\n    @Test\n    void addHostHeaderIfMissing() throws URISyntaxException {\n        final io.netty.handler.codec.http.HttpHeaders headers = new DefaultHttpHeaders();\n        headers.add(HttpHeaderNames.HOST, \"bar\");\n\n        final HttpRequest originReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/hello\", headers);\n\n        final InetSocketAddress socketAddress = new InetSocketAddress(36462);\n        final Channel channel = mock(Channel.class);\n        when(channel.localAddress()).thenReturn(socketAddress);\n\n        final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n        when(ctx.channel()).thenReturn(channel);\n\n        RequestHeaders armeriaHeaders = toArmeria(ctx, originReq, serverConfig(), \"http\");\n        assertThat(armeriaHeaders.get(HttpHeaderNames.HOST)).isEqualTo(\"bar\");\n        assertThat(armeriaHeaders.authority()).isEqualTo(\"bar\");\n        assertThat(armeriaHeaders.scheme()).isEqualTo(\"http\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"/hello\");\n\n        // Remove Host header.\n        headers.remove(HttpHeaderNames.HOST);\n        armeriaHeaders = toArmeria(ctx, originReq, serverConfig(), \"https\");\n        assertThat(armeriaHeaders.get(HttpHeaderNames.HOST)).isEqualTo(\"foo:36462\"); // The default hostname.\n        assertThat(armeriaHeaders.authority()).isEqualTo(\"foo:36462\");\n        assertThat(armeriaHeaders.scheme()).isEqualTo(\"https\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"/hello\");\n    }\n\n    @Test\n    void pathValidation() throws Exception {\n        final InetSocketAddress socketAddress = new InetSocketAddress(36462);\n        final Channel channel = mock(Channel.class);\n        when(channel.localAddress()).thenReturn(socketAddress);\n\n        final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n        when(ctx.channel()).thenReturn(channel);\n\n        // Should not be overly strict, e.g. allow `\"` in the path.\n        final HttpRequest doubleQuoteReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"/\\\"?\\\"\",\n                                       new DefaultHttpHeaders());\n        RequestHeaders armeriaHeaders = toArmeria(ctx, doubleQuoteReq, serverConfig(), \"http\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"/\\\"?\\\"\");\n\n        // Should accept an asterisk request.\n        final HttpRequest asteriskReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"*\", new DefaultHttpHeaders());\n        armeriaHeaders = toArmeria(ctx, asteriskReq, serverConfig(), \"http\");\n        assertThat(armeriaHeaders.path()).isEqualTo(\"*\");\n\n        // Should reject an absolute URI.\n        final HttpRequest absoluteUriReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,\n                                       \"http://example.com/hello\", new DefaultHttpHeaders());\n        assertThatThrownBy(() -> toArmeria(ctx, absoluteUriReq, serverConfig(), \"http\"))\n                .isInstanceOf(URISyntaxException.class)\n                .hasMessageContaining(\"neither origin form nor asterisk form\");\n\n        // Should not accept a path that starts with an asterisk.\n        final HttpRequest badAsteriskReq =\n                new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, \"*/\", new DefaultHttpHeaders());\n        assertThatThrownBy(() -> toArmeria(ctx, badAsteriskReq, serverConfig(), \"http\"))\n                .isInstanceOf(URISyntaxException.class)\n                .hasMessageContaining(\"neither origin form nor asterisk form\");\n    }\n\n    @Test\n    void stripTEHeaders() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP);\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out).isEmpty();\n    }\n\n    @Test\n    void stripTEHeadersExcludingTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP);\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS);\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.get(HttpHeaderNames.TE)).isEqualTo(HttpHeaderValues.TRAILERS.toString());\n    }\n\n    @Test\n    void stripTEHeadersCsvSeparatedExcludingTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP + \",\" + HttpHeaderValues.TRAILERS);\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.get(HttpHeaderNames.TE)).isEqualTo(HttpHeaderValues.TRAILERS.toString());\n    }\n\n    @Test\n    void stripTEHeadersCsvSeparatedAccountsForValueSimilarToTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.GZIP + \",\" + HttpHeaderValues.TRAILERS + \"foo\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.contains(HttpHeaderNames.TE)).isFalse();\n    }\n\n    @Test\n    void stripTEHeadersAccountsForValueSimilarToTrailers() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, HttpHeaderValues.TRAILERS + \"foo\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.contains(HttpHeaderNames.TE)).isFalse();\n    }\n\n    @Test\n    void stripTEHeadersAccountsForOWS() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.TE, \" \" + HttpHeaderValues.TRAILERS + ' ');\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out.get(HttpHeaderNames.TE)).isEqualTo(HttpHeaderValues.TRAILERS.toString());\n    }\n\n    @Test\n    void stripConnectionHeadersAndNominees() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.CONNECTION, \"foo\");\n        in.add(\"foo\", \"bar\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out).isEmpty();\n    }\n\n    @Test\n    void stripConnectionNomineesWithCsv() {\n        final io.netty.handler.codec.http.HttpHeaders in = new DefaultHttpHeaders();\n        in.add(HttpHeaderNames.CONNECTION, \"foo,  bar\");\n        in.add(\"foo\", \"baz\");\n        in.add(\"bar\", \"qux\");\n        in.add(\"hello\", \"world\");\n        final HttpHeadersBuilder out = HttpHeaders.builder();\n        toArmeria(in, out);\n        assertThat(out).hasSize(1);\n        assertThat(out.get(HttpHeaderNames.of(\"hello\"))).isEqualTo(\"world\");\n    }\n\n    @Test\n    void excludeDisallowedHeadersWhileHttp2ToHttp1() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.TRAILER, \"foo\")\n                                          .add(HttpHeaderNames.HOST, \"bar\")\n                                          .add(HttpHeaderNames.PATH, \"dummy\")\n                                          .add(HttpHeaderNames.METHOD, \"dummy\")\n                                          .add(HttpHeaderNames.SCHEME, \"dummy\")\n                                          .add(HttpHeaderNames.STATUS, \"dummy\")\n                                          .add(HttpHeaderNames.TRANSFER_ENCODING, \"dummy\")\n                                          .add(ExtensionHeaderNames.STREAM_ID.text(), \"dummy\")\n                                          .add(ExtensionHeaderNames.SCHEME.text(), \"dummy\")\n                                          .add(ExtensionHeaderNames.PATH.text(), \"dummy\")\n                                          .build();\n\n        final io.netty.handler.codec.http.HttpHeaders out =\n                new DefaultHttpHeaders();\n\n        toNettyHttp1ServerHeaders(in, out, Http1HeaderNaming.ofDefault());\n        assertThat(out).isEqualTo(new DefaultHttpHeaders()\n                                          .add(io.netty.handler.codec.http.HttpHeaderNames.TRAILER, \"foo\")\n                                          .add(io.netty.handler.codec.http.HttpHeaderNames.HOST, \"bar\"));\n    }\n\n    @Test\n    void excludeDisallowedInTrailers() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.of(\"foo\"), \"bar\")\n                                          .add(HttpHeaderNames.TRANSFER_ENCODING, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_LENGTH, \"dummy\")\n                                          .add(HttpHeaderNames.CACHE_CONTROL, \"dummy\")\n                                          .add(HttpHeaderNames.EXPECT, \"dummy\")\n                                          .add(HttpHeaderNames.HOST, \"dummy\")\n                                          .add(HttpHeaderNames.MAX_FORWARDS, \"dummy\")\n                                          .add(HttpHeaderNames.PRAGMA, \"dummy\")\n                                          .add(HttpHeaderNames.RANGE, \"dummy\")\n                                          .add(HttpHeaderNames.TE, \"dummy\")\n                                          .add(HttpHeaderNames.WWW_AUTHENTICATE, \"dummy\")\n                                          .add(HttpHeaderNames.AUTHORIZATION, \"dummy\")\n                                          .add(HttpHeaderNames.PROXY_AUTHENTICATE, \"dummy\")\n                                          .add(HttpHeaderNames.PROXY_AUTHORIZATION, \"dummy\")\n                                          .add(HttpHeaderNames.DATE, \"dummy\")\n                                          .add(HttpHeaderNames.LOCATION, \"dummy\")\n                                          .add(HttpHeaderNames.RETRY_AFTER, \"dummy\")\n                                          .add(HttpHeaderNames.VARY, \"dummy\")\n                                          .add(HttpHeaderNames.WARNING, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_ENCODING, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_TYPE, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_RANGE, \"dummy\")\n                                          .add(HttpHeaderNames.TRAILER, \"dummy\")\n                                          .build();\n        final Http2Headers nettyHeaders = ArmeriaHttpUtil.toNettyHttp2ServerTrailers(in);\n        assertThat(nettyHeaders.size()).isOne();\n        assertThat(nettyHeaders.get(\"foo\")).isEqualTo(\"bar\");\n    }\n\n    @Test\n    void excludeDisallowedInResponseHeaders() {\n        final ResponseHeadersBuilder in = ResponseHeaders.builder()\n                                                         .add(HttpHeaderNames.STATUS, \"200\")\n                                                         .add(HttpHeaderNames.AUTHORITY, \"dummy\")\n                                                         .add(HttpHeaderNames.METHOD, \"dummy\")\n                                                         .add(HttpHeaderNames.PATH, \"dummy\")\n                                                         .add(HttpHeaderNames.SCHEME, \"dummy\");\n        final Http2Headers nettyHeaders = ArmeriaHttpUtil.toNettyHttp2ServerHeaders(in);\n        assertThat(nettyHeaders.size()).isOne();\n        assertThat(nettyHeaders.get(HttpHeaderNames.STATUS)).isEqualTo(\"200\");\n    }\n\n    @Test\n    void traditionalHeaderNaming() {\n        final HttpHeaders in = HttpHeaders.builder()\n                                          .add(HttpHeaderNames.of(\"foo\"), \"bar\")\n                                          .add(HttpHeaderNames.AUTHORIZATION, \"dummy\")\n                                          .add(HttpHeaderNames.CONTENT_LENGTH, \"dummy\")\n                                          .add(HttpHeaderNames.CACHE_CONTROL, \"dummy\")\n                                          .build();\n\n        final io.netty.handler.codec.http.HttpHeaders clientOutHeaders =\n                new DefaultHttpHeaders();\n        toNettyHttp1ClientHeaders(in, clientOutHeaders, Http1HeaderNaming.traditional());\n        assertThat(clientOutHeaders).isEqualTo(new DefaultHttpHeaders()\n                                                       .add(\"foo\", \"bar\")\n                                                       .add(\"Authorization\", \"dummy\")\n                                                       .add(\"Content-Length\", \"dummy\")\n                                                       .add(\"Cache-Control\", \"dummy\"));\n\n        final io.netty.handler.codec.http.HttpHeaders serverOutHeaders =\n                new DefaultHttpHeaders();\n        toNettyHttp1ServerHeaders(in, serverOutHeaders, Http1HeaderNaming.traditional());\n        assertThat(serverOutHeaders).isEqualTo(new DefaultHttpHeaders()\n                                                       .add(\"foo\", \"bar\")\n                                                       .add(\"Authorization\", \"dummy\")\n                                                       .add(\"Content-Length\", \"dummy\")\n                                                       .add(\"Cache-Control\", \"dummy\"));\n    }\n\n    @Test\n    void convertedHeaderTypes() {\n        final Http2Headers in = new ArmeriaHttp2Headers().set(\"a\", \"b\");\n\n        // Request headers without pseudo headers.\n        assertThat(toArmeria(in, true, false)).isInstanceOf(HttpHeaders.class)\n                                              .isNotInstanceOf(RequestHeaders.class)\n                                              .isNotInstanceOf(ResponseHeaders.class);\n\n        // Response headers without pseudo headers.\n        assertThat(toArmeria(in, false, false)).isInstanceOf(HttpHeaders.class)\n                                               .isNotInstanceOf(RequestHeaders.class)\n                                               .isNotInstanceOf(ResponseHeaders.class);\n\n        // Request headers with pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.METHOD, \"GET\")\n          .set(HttpHeaderNames.PATH, \"/\");\n        assertThat(toArmeria(in, true, false)).isInstanceOf(RequestHeaders.class)\n                                              .isNotInstanceOf(ResponseHeaders.class);\n\n        // Response headers with pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.STATUS, \"200\");\n        assertThat(toArmeria(in, false, false)).isInstanceOf(ResponseHeaders.class)\n                                               .isNotInstanceOf(RequestHeaders.class);\n\n        // Request headers with mixed pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.METHOD, \"GET\")\n          .set(HttpHeaderNames.PATH, \"/\")\n          .set(HttpHeaderNames.STATUS, \"200\");\n        assertThat(toArmeria(in, true, false)).isInstanceOf(RequestHeaders.class)\n                                              .isNotInstanceOf(ResponseHeaders.class);\n\n        // Response headers with mixed pseudo headers.\n        in.clear()\n          .set(HttpHeaderNames.STATUS, \"200\")\n          .set(HttpHeaderNames.METHOD, \"GET\");\n        assertThat(toArmeria(in, false, false)).isInstanceOf(ResponseHeaders.class)\n                                               .isNotInstanceOf(RequestHeaders.class);\n    }\n\n    @Test\n    void toArmeriaRequestHeaders() {\n        final Http2Headers in = new ArmeriaHttp2Headers().set(\"a\", \"b\");\n\n        final InetSocketAddress socketAddress = new InetSocketAddress(36462);\n        final Channel channel = mock(Channel.class);\n        when(channel.localAddress()).thenReturn(socketAddress);\n\n        final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);\n        when(ctx.channel()).thenReturn(channel);\n\n        in.set(HttpHeaderNames.METHOD, \"GET\")\n          .set(HttpHeaderNames.PATH, \"/\");\n        // Request headers without pseudo headers.\n        final RequestHeaders headers =\n                ArmeriaHttpUtil.toArmeriaRequestHeaders(ctx, in, false, \"https\", serverConfig());\n        assertThat(headers.scheme()).isEqualTo(\"https\");\n        assertThat(headers.authority()).isEqualTo(\"foo:36462\");\n    }\n\n    @Test\n    void isAbsoluteUri() {\n        final String good = \"none+http://a.com\";\n        assertThat(ArmeriaHttpUtil.isAbsoluteUri(good)).isTrue();\n        final List<String> bad = Arrays.asList(\n                \"none+http:/a\",\n                \"//a\",\n                \"://a\",\n                \"a/b://c\",\n                \"http://\",\n                \"://\",\n                \"\",\n                null);\n        bad.forEach(path -> assertThat(ArmeriaHttpUtil.isAbsoluteUri(path)).isFalse());\n    }\n\n    @Test\n    void serverHeader() {\n        final String pattern = \"Armeria/(\\\\d+).(\\\\d+).(\\\\d+)(-SNAPSHOT)?\";\n        assertThat(\"Armeria/1.0.0\").containsPattern(pattern);\n        assertThat(\"Armeria/1.0.0-SNAPSHOT\").containsPattern(pattern);\n        assertThat(ArmeriaHttpUtil.SERVER_HEADER).containsPattern(pattern);\n    }\n\n    @Test\n    void disallowedResponseHeaderNames() {\n        for (AsciiString headerName : ImmutableList.of(HttpHeaderNames.METHOD,\n                                                       HttpHeaderNames.AUTHORITY,\n                                                       HttpHeaderNames.SCHEME,\n                                                       HttpHeaderNames.PATH,\n                                                       HttpHeaderNames.PROTOCOL)) {\n            assertThat(ArmeriaHttpUtil.disallowedResponseHeaderNames().contains(headerName)).isTrue();\n        }\n        assertThat(ArmeriaHttpUtil.disallowedResponseHeaderNames()).doesNotContain(HttpHeaderNames.STATUS);\n        assertThat(ArmeriaHttpUtil.disallowedResponseHeaderNames()).doesNotContain(HttpHeaderNames.LOCATION);\n    }\n\n    private static ServerConfig serverConfig() {\n        final Server server = Server.builder()\n                                    .defaultHostname(\"foo\")\n                                    .service(\"/\", (ctx, req) -> HttpResponse.of(HttpStatus.OK))\n                                    .build();\n        return server.config();\n    }\n}\n", "/*\n * Copyright 2018 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.linecorp.armeria.internal.common;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\n\nimport com.linecorp.armeria.common.QueryParams;\nimport com.linecorp.armeria.common.annotation.Nullable;\n\nclass PathAndQueryTest {\n\n    private static final Logger logger = LoggerFactory.getLogger(PathAndQueryTest.class);\n\n    private static final Set<String> QUERY_SEPARATORS = ImmutableSet.of(\"&\", \";\");\n\n    private static final Set<String> BAD_DOUBLE_DOT_PATTERNS = ImmutableSet.of(\n            \"..\", \"/..\", \"../\", \"/../\",\n            \"../foo\", \"/../foo\",\n            \"foo/..\", \"/foo/..\",\n            \"foo/../\", \"/foo/../\",\n            \"foo/../bar\", \"/foo/../bar\",\n\n            // Dots escaped\n            \".%2e\", \"/.%2e\", \"%2E./\", \"/%2E./\", \".%2E/\", \"/.%2E/\",\n            \"foo/.%2e\", \"/foo/.%2e\",\n            \"foo/%2E./\", \"/foo/%2E./\",\n            \"foo/%2E./bar\", \"/foo/%2E./bar\",\n\n            // Slashes escaped\n            \"%2f..\", \"..%2F\", \"/..%2F\", \"%2F../\", \"%2f..%2f\",\n            \"/foo%2f..\", \"/foo%2f../\", \"/foo/..%2f\",\"/foo%2F..%2F\",\n\n            // Dots and slashes escaped\n            \".%2E%2F\"\n    );\n\n    private static final Set<String> GOOD_DOUBLE_DOT_PATTERNS = ImmutableSet.of(\n            \"..a\", \"a..\", \"a..b\",\n            \"/..a\", \"/a..\", \"/a..b\",\n            \"..a/\", \"a../\", \"a..b/\",\n            \"/..a/\", \"/a../\", \"/a..b/\"\n    );\n\n    @Test\n    void empty() {\n        final PathAndQuery res = parse(null);\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/\");\n        assertThat(res.query()).isNull();\n\n        final PathAndQuery res2 = parse(\"\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/\");\n        assertThat(res2.query()).isNull();\n\n        final PathAndQuery res3 = parse(\"?\");\n        assertThat(res3).isNotNull();\n        assertThat(res3.path()).isEqualTo(\"/\");\n        assertThat(res3.query()).isEqualTo(\"\");\n    }\n\n    @Test\n    void relative() {\n        assertThat(parse(\"foo\")).isNull();\n    }\n\n    @Test\n    void doubleDotsInPath() {\n        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> assertProhibited(pattern));\n        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            final String path = pattern.startsWith(\"/\") ? pattern : '/' + pattern;\n            final PathAndQuery res = parse(path);\n            assertThat(res).as(\"Ensure %s is allowed.\", path).isNotNull();\n            assertThat(res.path()).as(\"Ensure %s is parsed as-is.\", path).isEqualTo(path);\n        });\n    }\n\n    @Test\n    void doubleDotsInFreeFormQuery() {\n        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            assertProhibited(\"/?\" + pattern);\n        });\n\n        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            assertQueryStringAllowed(\"/?\" + pattern, pattern);\n        });\n    }\n\n    @Test\n    void doubleDotsInNameValueQuery() {\n        // Dots in a query param name.\n        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            assertProhibited(\"/?\" + pattern + \"=foo\");\n        });\n        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            assertQueryStringAllowed(\"/?\" + pattern + \"=foo\");\n        });\n\n        // Dots in a query param value.\n        BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            assertProhibited(\"/?foo=\" + pattern);\n        });\n        GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n            assertQueryStringAllowed(\"/?foo=\" + pattern);\n        });\n\n        QUERY_SEPARATORS.forEach(qs -> {\n            // Dots in the second query param name.\n            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertProhibited(\"/?a=b\" + qs + pattern + \"=c\");\n            });\n            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertQueryStringAllowed(\"/?a=b\" + qs + pattern + \"=c\");\n            });\n\n            // Dots in the second query param value.\n            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertProhibited(\"/?a=b\" + qs + \"c=\" + pattern);\n            });\n            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertQueryStringAllowed(\"/?a=b\" + qs + \"c=\" + pattern);\n            });\n\n            // Dots in the name of the query param in the middle.\n            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertProhibited(\"/?a=b\" + qs + pattern + \"=c\" + qs + \"d=e\");\n            });\n            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertQueryStringAllowed(\"/?a=b\" + qs + pattern + \"=c\" + qs + \"d=e\");\n            });\n\n            // Dots in the value of the query param in the middle.\n            BAD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertProhibited(\"/?a=b\" + qs + \"c=\" + pattern + qs + \"d=e\");\n            });\n            GOOD_DOUBLE_DOT_PATTERNS.forEach(pattern -> {\n                assertQueryStringAllowed(\"/?a=b\" + qs + \"c=\" + pattern + qs + \"d=e\");\n            });\n        });\n    }\n\n    /**\n     * {@link PathAndQuery} treats the first `=` in a query parameter as `/` internally to simplify\n     * the detection the logic. This test makes sure the `=` appeared later is not treated as `/`.\n     */\n    @Test\n    void dotsAndEqualsInNameValueQuery() {\n        QUERY_SEPARATORS.forEach(qs -> {\n            final PathAndQuery res = parse(\"/?a=..=\" + qs + \"b=..=\");\n            assertThat(res).isNotNull();\n            assertThat(res.query()).isEqualTo(\"a=..=\" + qs + \"b=..=\");\n            assertThat(QueryParams.fromQueryString(res.query(), true)).containsExactly(\n                    Maps.immutableEntry(\"a\", \"..=\"),\n                    Maps.immutableEntry(\"b\", \"..=\")\n            );\n\n            final PathAndQuery res2 = parse(\"/?a==..\" + qs + \"b==..\");\n            assertThat(res2).isNotNull();\n            assertThat(res2.query()).isEqualTo(\"a==..\" + qs + \"b==..\");\n            assertThat(QueryParams.fromQueryString(res2.query(), true)).containsExactly(\n                    Maps.immutableEntry(\"a\", \"=..\"),\n                    Maps.immutableEntry(\"b\", \"=..\")\n            );\n\n            final PathAndQuery res3 = parse(\"/?a==..=\" + qs + \"b==..=\");\n            assertThat(res3).isNotNull();\n            assertThat(res3.query()).isEqualTo(\"a==..=\" + qs + \"b==..=\");\n            assertThat(QueryParams.fromQueryString(res3.query(), true)).containsExactly(\n                    Maps.immutableEntry(\"a\", \"=..=\"),\n                    Maps.immutableEntry(\"b\", \"=..=\")\n            );\n        });\n    }\n\n    @Test\n    void hexadecimal() {\n        assertThat(parse(\"/%\")).isNull();\n        assertThat(parse(\"/%0\")).isNull();\n        assertThat(parse(\"/%0X\")).isNull();\n        assertThat(parse(\"/%X0\")).isNull();\n    }\n\n    @Test\n    void controlChars() {\n        assertThat(parse(\"/\\0\")).isNull();\n        assertThat(parse(\"/a\\nb\")).isNull();\n        assertThat(parse(\"/a\\u007fb\")).isNull();\n\n        // Escaped\n        assertThat(parse(\"/%00\")).isNull();\n        assertThat(parse(\"/a%09b\")).isNull();\n        assertThat(parse(\"/a%0ab\")).isNull();\n        assertThat(parse(\"/a%0db\")).isNull();\n        assertThat(parse(\"/a%7fb\")).isNull();\n\n        // With query string\n        assertThat(parse(\"/\\0?c\")).isNull();\n        assertThat(parse(\"/a\\tb?c\")).isNull();\n        assertThat(parse(\"/a\\nb?c\")).isNull();\n        assertThat(parse(\"/a\\rb?c\")).isNull();\n        assertThat(parse(\"/a\\u007fb?c\")).isNull();\n\n        // With query string with control chars\n        assertThat(parse(\"/?\\0\")).isNull();\n        assertThat(parse(\"/?%00\")).isNull();\n        assertThat(parse(\"/?a\\u007fb\")).isNull();\n        assertThat(parse(\"/?a%7Fb\")).isNull();\n        // However, 0x0A, 0x0D, 0x09 should be accepted in a query string.\n        assertThat(parse(\"/?a\\tb\").query()).isEqualTo(\"a%09b\");\n        assertThat(parse(\"/?a\\nb\").query()).isEqualTo(\"a%0Ab\");\n        assertThat(parse(\"/?a\\rb\").query()).isEqualTo(\"a%0Db\");\n        assertThat(parse(\"/?a%09b\").query()).isEqualTo(\"a%09b\");\n        assertThat(parse(\"/?a%0Ab\").query()).isEqualTo(\"a%0Ab\");\n        assertThat(parse(\"/?a%0Db\").query()).isEqualTo(\"a%0Db\");\n    }\n\n    @Test\n    void percent() {\n        final PathAndQuery res = parse(\"/%25\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/%25\");\n        assertThat(res.query()).isNull();\n    }\n\n    @Test\n    void shouldNotDecodeSlash() {\n        final PathAndQuery res = parse(\"%2F?%2F\");\n        // Do not accept a relative path.\n        assertThat(res).isNull();\n        final PathAndQuery res1 = parse(\"/%2F?%2F\");\n        assertThat(res1).isNotNull();\n        assertThat(res1.path()).isEqualTo(\"/%2F\");\n        assertThat(res1.query()).isEqualTo(\"%2F\");\n\n        final PathAndQuery pathOnly = parse(\"/foo%2F\");\n        assertThat(pathOnly).isNotNull();\n        assertThat(pathOnly.path()).isEqualTo(\"/foo%2F\");\n        assertThat(pathOnly.query()).isNull();\n\n        final PathAndQuery queryOnly = parse(\"/?%2f=%2F\");\n        assertThat(queryOnly).isNotNull();\n        assertThat(queryOnly.path()).isEqualTo(\"/\");\n        assertThat(queryOnly.query()).isEqualTo(\"%2F=%2F\");\n    }\n\n    @Test\n    void consecutiveSlashes() {\n        final PathAndQuery res = parse(\n                \"/path//with///consecutive////slashes?/query//with///consecutive////slashes\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/path/with/consecutive/slashes\");\n        assertThat(res.query()).isEqualTo(\"/query//with///consecutive////slashes\");\n\n        // Encoded slashes\n        final PathAndQuery res2 = parse(\n                \"/path%2F/with/%2F/consecutive//%2F%2Fslashes?/query%2F/with/%2F/consecutive//%2F%2Fslashes\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/path%2F/with/%2F/consecutive/%2F%2Fslashes\");\n        assertThat(res2.query()).isEqualTo(\"/query%2F/with/%2F/consecutive//%2F%2Fslashes\");\n    }\n\n    @Test\n    void colon() {\n        assertThat(parse(\"/:\")).isNotNull();\n        assertThat(parse(\"/:/\")).isNotNull();\n        assertThat(parse(\"/a/:\")).isNotNull();\n        assertThat(parse(\"/a/:/\")).isNotNull();\n    }\n\n    @Test\n    void rawUnicode() {\n        // 2- and 3-byte UTF-8\n        final PathAndQuery res1 = parse(\"/\\u00A2?\\u20AC\"); // \u00a2 and \u20ac\n        assertThat(res1).isNotNull();\n        assertThat(res1.path()).isEqualTo(\"/%C2%A2\");\n        assertThat(res1.query()).isEqualTo(\"%E2%82%AC\");\n\n        // 4-byte UTF-8\n        final PathAndQuery res2 = parse(\"/\\uD800\\uDF48\"); // \ud800\udf48\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/%F0%90%8D%88\");\n        assertThat(res2.query()).isNull();\n\n        // 5- and 6-byte forms are only theoretically possible, so we won't test them here.\n    }\n\n    @Test\n    void encodedUnicode() {\n        final String encodedPath = \"/%ec%95%88\";\n        final String encodedQuery = \"%eb%85%95\";\n        final PathAndQuery res = parse(encodedPath + '?' + encodedQuery);\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(Ascii.toUpperCase(encodedPath));\n        assertThat(res.query()).isEqualTo(Ascii.toUpperCase(encodedQuery));\n    }\n\n    @Test\n    void noEncoding() {\n        final PathAndQuery res = parse(\"/a?b=c\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/a\");\n        assertThat(res.query()).isEqualTo(\"b=c\");\n    }\n\n    @Test\n    void space() {\n        final PathAndQuery res = parse(\"/ ? \");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/%20\");\n        assertThat(res.query()).isEqualTo(\"+\");\n\n        final PathAndQuery res2 = parse(\"/%20?%20\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/%20\");\n        assertThat(res2.query()).isEqualTo(\"+\");\n    }\n\n    @Test\n    void plus() {\n        final PathAndQuery res = parse(\"/+?a+b=c+d\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/+\");\n        assertThat(res.query()).isEqualTo(\"a+b=c+d\");\n\n        final PathAndQuery res2 = parse(\"/%2b?a%2bb=c%2bd\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/+\");\n        assertThat(res2.query()).isEqualTo(\"a%2Bb=c%2Bd\");\n    }\n\n    @Test\n    void ampersand() {\n        final PathAndQuery res = parse(\"/&?a=1&a=2&b=3\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/&\");\n        assertThat(res.query()).isEqualTo(\"a=1&a=2&b=3\");\n\n        // '%26' in a query string should never be decoded into '&'.\n        final PathAndQuery res2 = parse(\"/%26?a=1%26a=2&b=3\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/&\");\n        assertThat(res2.query()).isEqualTo(\"a=1%26a=2&b=3\");\n    }\n\n    @Test\n    void semicolon() {\n        final PathAndQuery res = parse(\"/;?a=b;c=d\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/;\");\n        assertThat(res.query()).isEqualTo(\"a=b;c=d\");\n\n        // '%3B' in a query string should never be decoded into ';'.\n        final PathAndQuery res2 = parse(\"/%3b?a=b%3Bc=d\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/;\");\n        assertThat(res2.query()).isEqualTo(\"a=b%3Bc=d\");\n    }\n\n    @Test\n    void equal() {\n        final PathAndQuery res = parse(\"/=?a=b=1\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/=\");\n        assertThat(res.query()).isEqualTo(\"a=b=1\");\n\n        // '%3D' in a query string should never be decoded into '='.\n        final PathAndQuery res2 = parse(\"/%3D?a%3db=1\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/=\");\n        assertThat(res2.query()).isEqualTo(\"a%3Db=1\");\n    }\n\n    @Test\n    void sharp() {\n        final PathAndQuery res = parse(\"/#?a=b#1\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/#\");\n        assertThat(res.query()).isEqualTo(\"a=b#1\");\n\n        // '%23' in a query string should never be decoded into '#'.\n        final PathAndQuery res2 = parse(\"/%23?a=b%231\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/#\");\n        assertThat(res2.query()).isEqualTo(\"a=b%231\");\n    }\n\n    @Test\n    void allReservedCharacters() {\n        final PathAndQuery res = parse(\"/#/:[]@!$&'()*+,;=?a=/#/:[]@!$&'()*+,;=\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/#/:[]@!$&'()*+,;=\");\n        assertThat(res.query()).isEqualTo(\"a=/#/:[]@!$&'()*+,;=\");\n\n        final PathAndQuery res2 =\n                parse(\"/%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\" +\n                      \"?a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n        assertThat(res2).isNotNull();\n        assertThat(res2.path()).isEqualTo(\"/#%2F:[]@!$&'()*+,;=?\");\n        assertThat(res2.query()).isEqualTo(\"a=%23%2F%3A%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%3F\");\n    }\n\n    @Test\n    void doubleQuote() {\n        final PathAndQuery res = parse(\"/\\\"?\\\"\");\n        assertThat(res).isNotNull();\n        assertThat(res.path()).isEqualTo(\"/%22\");\n        assertThat(res.query()).isEqualTo(\"%22\");\n    }\n\n    private static void assertProhibited(String rawPath) {\n        assertThat(parse(rawPath))\n                .as(\"Ensure parse(\\\"%s\\\") returns null.\", rawPath)\n                .isNull();\n    }\n\n    private static void assertQueryStringAllowed(String rawPath) {\n        assertThat(rawPath).startsWith(\"/?\");\n        final String expectedQuery = rawPath.substring(2);\n        assertQueryStringAllowed(rawPath, expectedQuery);\n    }\n\n    private static void assertQueryStringAllowed(String rawPath, String expectedQuery) {\n        final PathAndQuery res = parse(rawPath);\n        assertThat(res)\n                .as(\"parse(\\\"%s\\\") must return non-null.\", rawPath)\n                .isNotNull();\n        assertThat(res.query())\n                .as(\"parse(\\\"%s\\\").query() must return \\\"%s\\\".\", rawPath, expectedQuery)\n                .isEqualTo(expectedQuery);\n    }\n\n    @Nullable\n    private static PathAndQuery parse(@Nullable String rawPath) {\n        final PathAndQuery res = PathAndQuery.parse(rawPath);\n        if (res != null) {\n            logger.info(\"parse({}) => path: {}, query: {}\", rawPath, res.path(), res.query());\n        } else {\n            logger.info(\"parse({}) => null\", rawPath);\n        }\n        return res;\n    }\n}\n", "/*\n * Copyright 2019 LINE Corporation\n *\n * LINE Corporation licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.linecorp.armeria.server;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.net.URISyntaxException;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.google.common.collect.Maps;\n\nimport com.linecorp.armeria.common.MediaType;\n\nclass RoutingResultTest {\n\n    @Test\n    void empty() {\n        final RoutingResultBuilder builder = RoutingResult.builder();\n        final RoutingResult routingResult = builder.build();\n        assertThat(routingResult).isSameAs(RoutingResult.empty());\n    }\n\n    @Test\n    void routingResult() throws URISyntaxException {\n        final RoutingResultBuilder builder = RoutingResult.builder();\n        final RoutingResult routingResult = builder.path(\"/foo\")\n                                                   .query(\"bar=baz\")\n                                                   .rawParam(\"qux\", \"quux\")\n                                                   .negotiatedResponseMediaType(MediaType.JSON_UTF_8)\n                                                   .build();\n        assertThat(routingResult.isPresent()).isTrue();\n        assertThat(routingResult.path()).isEqualTo(\"/foo\");\n        assertThat(routingResult.query()).isEqualTo(\"bar=baz\");\n        assertThat(routingResult.pathParams()).containsOnly(Maps.immutableEntry(\"qux\", \"quux\"));\n        assertThat(routingResult.negotiatedResponseMediaType()).isSameAs(MediaType.JSON_UTF_8);\n    }\n\n    @Test\n    void percentEncodedPathParam() {\n        final RoutingResultBuilder builder = RoutingResult.builder();\n        final RoutingResult routingResult = builder.path(\"/foo\")\n                                                   .rawParam(\"bar\", \"%62az%2Fqu%78\")\n                                                   .build();\n        assertThat(routingResult.pathParams()).containsOnly(Maps.immutableEntry(\"bar\", \"baz/qux\"));\n    }\n}\n"], "filenames": ["core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java", "core/src/main/java/com/linecorp/armeria/internal/common/PathAndQuery.java", "core/src/main/java/com/linecorp/armeria/server/RoutingResultBuilder.java", "core/src/test/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtilTest.java", "core/src/test/java/com/linecorp/armeria/internal/common/PathAndQueryTest.java", "core/src/test/java/com/linecorp/armeria/server/RoutingResultTest.java"], "buggy_code_start_loc": [307, 46, 99, 37, 19, 22], "buggy_code_end_loc": [339, 572, 100, 107, 305, 50], "fixing_code_start_loc": [307, 47, 99, 38, 20, 21], "fixing_code_end_loc": [372, 630, 100, 125, 465, 61], "type": "CWE-22", "message": "Armeria is an open source microservice framework. In affected versions an attacker can access an Armeria server's local file system beyond its restricted directory by sending an HTTP request whose path contains `%2F` (encoded `/`), such as `/files/..%2Fsecrets.txt`, bypassing Armeria's path validation logic. Armeria 1.13.4 or above contains the hardened path validation logic that handles `%2F` properly. This vulnerability can be worked around by inserting a decorator that performs an additional validation on the request path.", "other": {"cve": {"id": "CVE-2021-43795", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-02T18:15:08.267", "lastModified": "2021-12-06T18:24:45.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Armeria is an open source microservice framework. In affected versions an attacker can access an Armeria server's local file system beyond its restricted directory by sending an HTTP request whose path contains `%2F` (encoded `/`), such as `/files/..%2Fsecrets.txt`, bypassing Armeria's path validation logic. Armeria 1.13.4 or above contains the hardened path validation logic that handles `%2F` properly. This vulnerability can be worked around by inserting a decorator that performs an additional validation on the request path."}, {"lang": "es", "value": "Armeria es un framework de microservicios de c\u00f3digo abierto. En las versiones afectadas, un atacante puede acceder al sistema de archivos local de un servidor de Armeria m\u00e1s all\u00e1 de su directorio restringido mediante el env\u00edo de una petici\u00f3n HTTP cuya ruta contenga \"%2F\" (codificado \"/\"), como \"/files/..%2Fsecrets.txt\", omitiendo la l\u00f3gica de comprobaci\u00f3n de rutas de Armeria. Armeria versi\u00f3n 1.13.4 o superior, contiene una l\u00f3gica de comprobaci\u00f3n de rutas reforzada que maneja \"%2F\" apropiadamente. Esta vulnerabilidad puede solucionarse al insertar un decorador que lleve a cabo una comprobaci\u00f3n adicional en la ruta de petici\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linecorp:armeria:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.4", "matchCriteriaId": "1C4CC5EF-C8FD-41AB-A2C6-DA8D6E3ED2B6"}]}]}], "references": [{"url": "https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/line/armeria/pull/3855", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/line/armeria/security/advisories/GHSA-8fp4-rp6c-5gcv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/line/armeria/commit/e2697a575e9df6692b423e02d731f293c1313284"}}