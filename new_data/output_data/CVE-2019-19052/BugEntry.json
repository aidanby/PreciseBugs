{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/* CAN driver for Geschwister Schneider USB/CAN devices\n * and bytewerk.org candleLight USB CAN interfaces.\n *\n * Copyright (C) 2013-2016 Geschwister Schneider Technologie-,\n * Entwicklungs- und Vertriebs UG (Haftungsbeschr\u00e4nkt).\n * Copyright (C) 2016 Hubert Denkmair\n *\n * Many thanks to all socketcan devs!\n */\n\n#include <linux/init.h>\n#include <linux/signal.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n/* Device specific constants */\n#define USB_GSUSB_1_VENDOR_ID      0x1d50\n#define USB_GSUSB_1_PRODUCT_ID     0x606f\n\n#define USB_CANDLELIGHT_VENDOR_ID  0x1209\n#define USB_CANDLELIGHT_PRODUCT_ID 0x2323\n\n#define GSUSB_ENDPOINT_IN          1\n#define GSUSB_ENDPOINT_OUT         2\n\n/* Device specific constants */\nenum gs_usb_breq {\n\tGS_USB_BREQ_HOST_FORMAT = 0,\n\tGS_USB_BREQ_BITTIMING,\n\tGS_USB_BREQ_MODE,\n\tGS_USB_BREQ_BERR,\n\tGS_USB_BREQ_BT_CONST,\n\tGS_USB_BREQ_DEVICE_CONFIG,\n\tGS_USB_BREQ_TIMESTAMP,\n\tGS_USB_BREQ_IDENTIFY,\n};\n\nenum gs_can_mode {\n\t/* reset a channel. turns it off */\n\tGS_CAN_MODE_RESET = 0,\n\t/* starts a channel */\n\tGS_CAN_MODE_START\n};\n\nenum gs_can_state {\n\tGS_CAN_STATE_ERROR_ACTIVE = 0,\n\tGS_CAN_STATE_ERROR_WARNING,\n\tGS_CAN_STATE_ERROR_PASSIVE,\n\tGS_CAN_STATE_BUS_OFF,\n\tGS_CAN_STATE_STOPPED,\n\tGS_CAN_STATE_SLEEPING\n};\n\nenum gs_can_identify_mode {\n\tGS_CAN_IDENTIFY_OFF = 0,\n\tGS_CAN_IDENTIFY_ON\n};\n\n/* data types passed between host and device */\nstruct gs_host_config {\n\tu32 byte_order;\n} __packed;\n/* All data exchanged between host and device is exchanged in host byte order,\n * thanks to the struct gs_host_config byte_order member, which is sent first\n * to indicate the desired byte order.\n */\n\nstruct gs_device_config {\n\tu8 reserved1;\n\tu8 reserved2;\n\tu8 reserved3;\n\tu8 icount;\n\tu32 sw_version;\n\tu32 hw_version;\n} __packed;\n\n#define GS_CAN_MODE_NORMAL               0\n#define GS_CAN_MODE_LISTEN_ONLY          BIT(0)\n#define GS_CAN_MODE_LOOP_BACK            BIT(1)\n#define GS_CAN_MODE_TRIPLE_SAMPLE        BIT(2)\n#define GS_CAN_MODE_ONE_SHOT             BIT(3)\n\nstruct gs_device_mode {\n\tu32 mode;\n\tu32 flags;\n} __packed;\n\nstruct gs_device_state {\n\tu32 state;\n\tu32 rxerr;\n\tu32 txerr;\n} __packed;\n\nstruct gs_device_bittiming {\n\tu32 prop_seg;\n\tu32 phase_seg1;\n\tu32 phase_seg2;\n\tu32 sjw;\n\tu32 brp;\n} __packed;\n\nstruct gs_identify_mode {\n\tu32 mode;\n} __packed;\n\n#define GS_CAN_FEATURE_LISTEN_ONLY      BIT(0)\n#define GS_CAN_FEATURE_LOOP_BACK        BIT(1)\n#define GS_CAN_FEATURE_TRIPLE_SAMPLE    BIT(2)\n#define GS_CAN_FEATURE_ONE_SHOT         BIT(3)\n#define GS_CAN_FEATURE_HW_TIMESTAMP     BIT(4)\n#define GS_CAN_FEATURE_IDENTIFY         BIT(5)\n\nstruct gs_device_bt_const {\n\tu32 feature;\n\tu32 fclk_can;\n\tu32 tseg1_min;\n\tu32 tseg1_max;\n\tu32 tseg2_min;\n\tu32 tseg2_max;\n\tu32 sjw_max;\n\tu32 brp_min;\n\tu32 brp_max;\n\tu32 brp_inc;\n} __packed;\n\n#define GS_CAN_FLAG_OVERFLOW 1\n\nstruct gs_host_frame {\n\tu32 echo_id;\n\tu32 can_id;\n\n\tu8 can_dlc;\n\tu8 channel;\n\tu8 flags;\n\tu8 reserved;\n\n\tu8 data[8];\n} __packed;\n/* The GS USB devices make use of the same flags and masks as in\n * linux/can.h and linux/can/error.h, and no additional mapping is necessary.\n */\n\n/* Only send a max of GS_MAX_TX_URBS frames per channel at a time. */\n#define GS_MAX_TX_URBS 10\n/* Only launch a max of GS_MAX_RX_URBS usb requests at a time. */\n#define GS_MAX_RX_URBS 30\n/* Maximum number of interfaces the driver supports per device.\n * Current hardware only supports 2 interfaces. The future may vary.\n */\n#define GS_MAX_INTF 2\n\nstruct gs_tx_context {\n\tstruct gs_can *dev;\n\tunsigned int echo_id;\n};\n\nstruct gs_can {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct gs_usb *parent;\n\n\tstruct net_device *netdev;\n\tstruct usb_device *udev;\n\tstruct usb_interface *iface;\n\n\tstruct can_bittiming_const bt_const;\n\tunsigned int channel;\t/* channel number */\n\n\t/* This lock prevents a race condition between xmit and receive. */\n\tspinlock_t tx_ctx_lock;\n\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];\n\n\tstruct usb_anchor tx_submitted;\n\tatomic_t active_tx_urbs;\n};\n\n/* usb interface struct */\nstruct gs_usb {\n\tstruct gs_can *canch[GS_MAX_INTF];\n\tstruct usb_anchor rx_submitted;\n\tatomic_t active_channels;\n\tstruct usb_device *udev;\n};\n\n/* 'allocate' a tx context.\n * returns a valid tx context or NULL if there is no space.\n */\nstatic struct gs_tx_context *gs_alloc_tx_context(struct gs_can *dev)\n{\n\tint i = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\n\tfor (; i < GS_MAX_TX_URBS; i++) {\n\t\tif (dev->tx_context[i].echo_id == GS_MAX_TX_URBS) {\n\t\t\tdev->tx_context[i].echo_id = i;\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[i];\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\treturn NULL;\n}\n\n/* releases a tx context\n */\nstatic void gs_free_tx_context(struct gs_tx_context *txc)\n{\n\ttxc->echo_id = GS_MAX_TX_URBS;\n}\n\n/* Get a tx context by id.\n */\nstatic struct gs_tx_context *gs_get_tx_context(struct gs_can *dev,\n\t\t\t\t\t       unsigned int id)\n{\n\tunsigned long flags;\n\n\tif (id < GS_MAX_TX_URBS) {\n\t\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\t\tif (dev->tx_context[id].echo_id == id) {\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[id];\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t}\n\treturn NULL;\n}\n\nstatic int gs_cmd_reset(struct gs_can *gsdev)\n{\n\tstruct gs_device_mode *dm;\n\tstruct usb_interface *intf = gsdev->iface;\n\tint rc;\n\n\tdm = kzalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\tdm->mode = GS_CAN_MODE_RESET;\n\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     gsdev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tkfree(dm);\n\n\treturn rc;\n}\n\nstatic void gs_update_state(struct gs_can *dev, struct can_frame *cf)\n{\n\tstruct can_device_stats *can_stats = &dev->can.can_stats;\n\n\tif (cf->can_id & CAN_ERR_RESTARTED) {\n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcan_stats->restarts++;\n\t} else if (cf->can_id & CAN_ERR_BUSOFF) {\n\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\tcan_stats->bus_off++;\n\t} else if (cf->can_id & CAN_ERR_CRTL) {\n\t\tif ((cf->data[1] & CAN_ERR_CRTL_TX_WARNING) ||\n\t\t    (cf->data[1] & CAN_ERR_CRTL_RX_WARNING)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_stats->error_warning++;\n\t\t} else if ((cf->data[1] & CAN_ERR_CRTL_TX_PASSIVE) ||\n\t\t\t   (cf->data[1] & CAN_ERR_CRTL_RX_PASSIVE)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_stats->error_passive++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *usbcan = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!usbcan);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto resubmit_urb;\n\n\tdev = usbcan->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tskb = alloc_can_skb(dev->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = hf->can_id;\n\n\t\tcf->can_dlc = get_can_dlc(hf->can_dlc);\n\t\tmemcpy(cf->data, hf->data, 8);\n\n\t\t/* ERROR frames tell us information about the controller */\n\t\tif (hf->can_id & CAN_ERR_FLAG)\n\t\t\tgs_update_state(dev, cf);\n\n\t\tnetdev->stats.rx_packets++;\n\t\tnetdev->stats.rx_bytes += hf->can_dlc;\n\n\t\tnetif_rx(skb);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += hf->can_dlc;\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tcan_get_echo_skb(netdev, hf->echo_id);\n\n\t\tgs_free_tx_context(txc);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->can_dlc = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tnetif_rx(skb);\n\t}\n\n resubmit_urb:\n\tusb_fill_bulk_urb(urb,\n\t\t\t  usbcan->udev,\n\t\t\t  usb_rcvbulkpipe(usbcan->udev, GSUSB_ENDPOINT_IN),\n\t\t\t  hf,\n\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t  usbcan\n\t\t\t  );\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (usbcan->canch[rc])\n\t\t\t\tnetif_device_detach(usbcan->canch[rc]->netdev);\n\t\t}\n\t}\n}\n\nstatic int gs_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tstruct usb_interface *intf = dev->iface;\n\tint rc;\n\tstruct gs_device_bittiming *dbt;\n\n\tdbt = kmalloc(sizeof(*dbt), GFP_KERNEL);\n\tif (!dbt)\n\t\treturn -ENOMEM;\n\n\tdbt->prop_seg = bt->prop_seg;\n\tdbt->phase_seg1 = bt->phase_seg1;\n\tdbt->phase_seg2 = bt->phase_seg2;\n\tdbt->sjw = bt->sjw;\n\tdbt->brp = bt->brp;\n\n\t/* request bit timings */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BITTIMING,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dbt,\n\t\t\t     sizeof(*dbt),\n\t\t\t     1000);\n\n\tkfree(dbt);\n\n\tif (rc < 0)\n\t\tdev_err(netdev->dev.parent, \"Couldn't set bittimings (err=%d)\",\n\t\t\trc);\n\n\treturn (rc > 0) ? 0 : rc;\n}\n\nstatic void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"usb xmit fail %d\\n\", txc->echo_id);\n\n\tusb_free_coherent(urb->dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n}\n\nstatic netdev_tx_t gs_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\tstruct urb *urb;\n\tstruct gs_host_frame *hf;\n\tstruct can_frame *cf;\n\tint rc;\n\tunsigned int idx;\n\tstruct gs_tx_context *txc;\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* find an empty context to keep track of transmission */\n\ttxc = gs_alloc_tx_context(dev);\n\tif (!txc)\n\t\treturn NETDEV_TX_BUSY;\n\n\t/* create a URB, and a buffer for it */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem_urb;\n\n\thf = usb_alloc_coherent(dev->udev, sizeof(*hf), GFP_ATOMIC,\n\t\t\t\t&urb->transfer_dma);\n\tif (!hf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomem_hf;\n\t}\n\n\tidx = txc->echo_id;\n\n\tif (idx >= GS_MAX_TX_URBS) {\n\t\tnetdev_err(netdev, \"Invalid tx context %d\\n\", idx);\n\t\tgoto badidx;\n\t}\n\n\thf->echo_id = idx;\n\thf->channel = dev->channel;\n\n\tcf = (struct can_frame *)skb->data;\n\n\thf->can_id = cf->can_id;\n\thf->can_dlc = cf->can_dlc;\n\tmemcpy(hf->data, cf->data, cf->can_dlc);\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, GSUSB_ENDPOINT_OUT),\n\t\t\t  hf,\n\t\t\t  sizeof(*hf),\n\t\t\t  gs_usb_xmit_callback,\n\t\t\t  txc);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, idx);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(rc)) {\t\t\t/* usb send failed */\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tcan_free_echo_skb(netdev, idx);\n\t\tgs_free_tx_context(txc);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev,\n\t\t\t\t  sizeof(*hf),\n\t\t\t\t  hf,\n\t\t\t\t  urb->transfer_dma);\n\n\t\tif (rc == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_err(netdev, \"usb_submit failed (err=%d)\\n\", rc);\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= GS_MAX_TX_URBS)\n\t\t\tnetif_stop_queue(netdev);\n\t}\n\n\t/* let usb core take care of this urb */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\n badidx:\n\tusb_free_coherent(dev->udev,\n\t\t\t  sizeof(*hf),\n\t\t\t  hf,\n\t\t\t  urb->transfer_dma);\n nomem_hf:\n\tusb_free_urb(urb);\n\n nomem_urb:\n\tgs_free_tx_context(txc);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic int gs_can_close(struct net_device *netdev)\n{\n\tint rc;\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tif (atomic_dec_and_test(&parent->active_channels))\n\t\tusb_kill_anchored_urbs(&parent->rx_submitted);\n\n\t/* Stop sending URBs */\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\t/* reset the device */\n\trc = gs_cmd_reset(dev);\n\tif (rc < 0)\n\t\tnetdev_warn(netdev, \"Couldn't shutdown device (err=%d)\", rc);\n\n\t/* reset tx contexts */\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* close the netdev */\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops gs_usb_netdev_ops = {\n\t.ndo_open = gs_can_open,\n\t.ndo_stop = gs_can_close,\n\t.ndo_start_xmit = gs_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic int gs_usb_set_identify(struct net_device *netdev, bool do_identify)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_identify_mode *imode;\n\tint rc;\n\n\timode = kmalloc(sizeof(*imode), GFP_KERNEL);\n\n\tif (!imode)\n\t\treturn -ENOMEM;\n\n\tif (do_identify)\n\t\timode->mode = GS_CAN_IDENTIFY_ON;\n\telse\n\t\timode->mode = GS_CAN_IDENTIFY_OFF;\n\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface),\n\t\t\t\t\t     0),\n\t\t\t     GS_USB_BREQ_IDENTIFY,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     imode,\n\t\t\t     sizeof(*imode),\n\t\t\t     100);\n\n\tkfree(imode);\n\n\treturn (rc > 0) ? 0 : rc;\n}\n\n/* blink LED's for finding the this interface */\nstatic int gs_usb_set_phys_id(struct net_device *dev,\n\t\t\t      enum ethtool_phys_id_state state)\n{\n\tint rc = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_ON);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_OFF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops gs_usb_ethtool_ops = {\n\t.set_phys_id = gs_usb_set_phys_id,\n};\n\nstatic struct gs_can *gs_make_candev(unsigned int channel,\n\t\t\t\t     struct usb_interface *intf,\n\t\t\t\t     struct gs_device_config *dconf)\n{\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct gs_device_bt_const *bt_const;\n\n\tbt_const = kmalloc(sizeof(*bt_const), GFP_KERNEL);\n\tif (!bt_const)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* fetch bit timing constants */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BT_CONST,\n\t\t\t     USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     channel,\n\t\t\t     0,\n\t\t\t     bt_const,\n\t\t\t     sizeof(*bt_const),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't get bit timing const for channel (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* create netdev */\n\tnetdev = alloc_candev(sizeof(struct gs_can), GS_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't allocate candev\\n\");\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &gs_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support full roundtrip echo */\n\n\t/* dev settup */\n\tstrcpy(dev->bt_const.name, \"gs_usb\");\n\tdev->bt_const.tseg1_min = bt_const->tseg1_min;\n\tdev->bt_const.tseg1_max = bt_const->tseg1_max;\n\tdev->bt_const.tseg2_min = bt_const->tseg2_min;\n\tdev->bt_const.tseg2_max = bt_const->tseg2_max;\n\tdev->bt_const.sjw_max = bt_const->sjw_max;\n\tdev->bt_const.brp_min = bt_const->brp_min;\n\tdev->bt_const.brp_max = bt_const->brp_max;\n\tdev->bt_const.brp_inc = bt_const->brp_inc;\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->iface = intf;\n\tdev->netdev = netdev;\n\tdev->channel = channel;\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\tspin_lock_init(&dev->tx_ctx_lock);\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* can settup */\n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = bt_const->fclk_can;\n\tdev->can.bittiming_const = &dev->bt_const;\n\tdev->can.do_set_bittiming = gs_usb_set_bittiming;\n\n\tdev->can.ctrlmode_supported = 0;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LISTEN_ONLY)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LOOP_BACK)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tif (dconf->sw_version > 1)\n\t\tif (bt_const->feature & GS_CAN_FEATURE_IDENTIFY)\n\t\t\tnetdev->ethtool_ops = &gs_usb_ethtool_ops;\n\n\tkfree(bt_const);\n\n\trc = register_candev(dev->netdev);\n\tif (rc) {\n\t\tfree_candev(dev->netdev);\n\t\tdev_err(&intf->dev, \"Couldn't register candev (err=%d)\\n\", rc);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn dev;\n}\n\nstatic void gs_destroy_candev(struct gs_can *dev)\n{\n\tunregister_candev(dev->netdev);\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tfree_candev(dev->netdev);\n}\n\nstatic int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\n\thconf->byte_order = 0x0000beef;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\n\tkfree(hconf);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n\tif (!dconf)\n\t\treturn -ENOMEM;\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     dconf,\n\t\t\t     sizeof(*dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(dconf);\n\t\treturn rc;\n\t}\n\n\ticount = dconf->icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\tkfree(dconf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(dconf);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tatomic_set(&dev->active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dconf);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\n\tkfree(dconf);\n\n\treturn 0;\n}\n\nstatic void gs_usb_disconnect(struct usb_interface *intf)\n{\n\tunsigned i;\n\tstruct gs_usb *dev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!dev) {\n\t\tdev_err(&intf->dev, \"Disconnect (nodata)\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < GS_MAX_INTF; i++)\n\t\tif (dev->canch[i])\n\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\tkfree(dev);\n}\n\nstatic const struct usb_device_id gs_usb_table[] = {\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_GSUSB_1_VENDOR_ID,\n\t\t\t\t      USB_GSUSB_1_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_CANDLELIGHT_VENDOR_ID,\n\t\t\t\t      USB_CANDLELIGHT_PRODUCT_ID, 0) },\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, gs_usb_table);\n\nstatic struct usb_driver gs_usb_driver = {\n\t.name       = \"gs_usb\",\n\t.probe      = gs_usb_probe,\n\t.disconnect = gs_usb_disconnect,\n\t.id_table   = gs_usb_table,\n};\n\nmodule_usb_driver(gs_usb_driver);\n\nMODULE_AUTHOR(\"Maximilian Schneider <mws@schneidersoft.net>\");\nMODULE_DESCRIPTION(\n\"Socket CAN device driver for Geschwister Schneider Technologie-, \"\n\"Entwicklungs- und Vertriebs UG. USB2.0 to CAN interfaces\\n\"\n\"and bytewerk.org candleLight USB CAN interfaces.\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/* CAN driver for Geschwister Schneider USB/CAN devices\n * and bytewerk.org candleLight USB CAN interfaces.\n *\n * Copyright (C) 2013-2016 Geschwister Schneider Technologie-,\n * Entwicklungs- und Vertriebs UG (Haftungsbeschr\u00e4nkt).\n * Copyright (C) 2016 Hubert Denkmair\n *\n * Many thanks to all socketcan devs!\n */\n\n#include <linux/init.h>\n#include <linux/signal.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n/* Device specific constants */\n#define USB_GSUSB_1_VENDOR_ID      0x1d50\n#define USB_GSUSB_1_PRODUCT_ID     0x606f\n\n#define USB_CANDLELIGHT_VENDOR_ID  0x1209\n#define USB_CANDLELIGHT_PRODUCT_ID 0x2323\n\n#define GSUSB_ENDPOINT_IN          1\n#define GSUSB_ENDPOINT_OUT         2\n\n/* Device specific constants */\nenum gs_usb_breq {\n\tGS_USB_BREQ_HOST_FORMAT = 0,\n\tGS_USB_BREQ_BITTIMING,\n\tGS_USB_BREQ_MODE,\n\tGS_USB_BREQ_BERR,\n\tGS_USB_BREQ_BT_CONST,\n\tGS_USB_BREQ_DEVICE_CONFIG,\n\tGS_USB_BREQ_TIMESTAMP,\n\tGS_USB_BREQ_IDENTIFY,\n};\n\nenum gs_can_mode {\n\t/* reset a channel. turns it off */\n\tGS_CAN_MODE_RESET = 0,\n\t/* starts a channel */\n\tGS_CAN_MODE_START\n};\n\nenum gs_can_state {\n\tGS_CAN_STATE_ERROR_ACTIVE = 0,\n\tGS_CAN_STATE_ERROR_WARNING,\n\tGS_CAN_STATE_ERROR_PASSIVE,\n\tGS_CAN_STATE_BUS_OFF,\n\tGS_CAN_STATE_STOPPED,\n\tGS_CAN_STATE_SLEEPING\n};\n\nenum gs_can_identify_mode {\n\tGS_CAN_IDENTIFY_OFF = 0,\n\tGS_CAN_IDENTIFY_ON\n};\n\n/* data types passed between host and device */\nstruct gs_host_config {\n\tu32 byte_order;\n} __packed;\n/* All data exchanged between host and device is exchanged in host byte order,\n * thanks to the struct gs_host_config byte_order member, which is sent first\n * to indicate the desired byte order.\n */\n\nstruct gs_device_config {\n\tu8 reserved1;\n\tu8 reserved2;\n\tu8 reserved3;\n\tu8 icount;\n\tu32 sw_version;\n\tu32 hw_version;\n} __packed;\n\n#define GS_CAN_MODE_NORMAL               0\n#define GS_CAN_MODE_LISTEN_ONLY          BIT(0)\n#define GS_CAN_MODE_LOOP_BACK            BIT(1)\n#define GS_CAN_MODE_TRIPLE_SAMPLE        BIT(2)\n#define GS_CAN_MODE_ONE_SHOT             BIT(3)\n\nstruct gs_device_mode {\n\tu32 mode;\n\tu32 flags;\n} __packed;\n\nstruct gs_device_state {\n\tu32 state;\n\tu32 rxerr;\n\tu32 txerr;\n} __packed;\n\nstruct gs_device_bittiming {\n\tu32 prop_seg;\n\tu32 phase_seg1;\n\tu32 phase_seg2;\n\tu32 sjw;\n\tu32 brp;\n} __packed;\n\nstruct gs_identify_mode {\n\tu32 mode;\n} __packed;\n\n#define GS_CAN_FEATURE_LISTEN_ONLY      BIT(0)\n#define GS_CAN_FEATURE_LOOP_BACK        BIT(1)\n#define GS_CAN_FEATURE_TRIPLE_SAMPLE    BIT(2)\n#define GS_CAN_FEATURE_ONE_SHOT         BIT(3)\n#define GS_CAN_FEATURE_HW_TIMESTAMP     BIT(4)\n#define GS_CAN_FEATURE_IDENTIFY         BIT(5)\n\nstruct gs_device_bt_const {\n\tu32 feature;\n\tu32 fclk_can;\n\tu32 tseg1_min;\n\tu32 tseg1_max;\n\tu32 tseg2_min;\n\tu32 tseg2_max;\n\tu32 sjw_max;\n\tu32 brp_min;\n\tu32 brp_max;\n\tu32 brp_inc;\n} __packed;\n\n#define GS_CAN_FLAG_OVERFLOW 1\n\nstruct gs_host_frame {\n\tu32 echo_id;\n\tu32 can_id;\n\n\tu8 can_dlc;\n\tu8 channel;\n\tu8 flags;\n\tu8 reserved;\n\n\tu8 data[8];\n} __packed;\n/* The GS USB devices make use of the same flags and masks as in\n * linux/can.h and linux/can/error.h, and no additional mapping is necessary.\n */\n\n/* Only send a max of GS_MAX_TX_URBS frames per channel at a time. */\n#define GS_MAX_TX_URBS 10\n/* Only launch a max of GS_MAX_RX_URBS usb requests at a time. */\n#define GS_MAX_RX_URBS 30\n/* Maximum number of interfaces the driver supports per device.\n * Current hardware only supports 2 interfaces. The future may vary.\n */\n#define GS_MAX_INTF 2\n\nstruct gs_tx_context {\n\tstruct gs_can *dev;\n\tunsigned int echo_id;\n};\n\nstruct gs_can {\n\tstruct can_priv can; /* must be the first member */\n\n\tstruct gs_usb *parent;\n\n\tstruct net_device *netdev;\n\tstruct usb_device *udev;\n\tstruct usb_interface *iface;\n\n\tstruct can_bittiming_const bt_const;\n\tunsigned int channel;\t/* channel number */\n\n\t/* This lock prevents a race condition between xmit and receive. */\n\tspinlock_t tx_ctx_lock;\n\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];\n\n\tstruct usb_anchor tx_submitted;\n\tatomic_t active_tx_urbs;\n};\n\n/* usb interface struct */\nstruct gs_usb {\n\tstruct gs_can *canch[GS_MAX_INTF];\n\tstruct usb_anchor rx_submitted;\n\tatomic_t active_channels;\n\tstruct usb_device *udev;\n};\n\n/* 'allocate' a tx context.\n * returns a valid tx context or NULL if there is no space.\n */\nstatic struct gs_tx_context *gs_alloc_tx_context(struct gs_can *dev)\n{\n\tint i = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\n\tfor (; i < GS_MAX_TX_URBS; i++) {\n\t\tif (dev->tx_context[i].echo_id == GS_MAX_TX_URBS) {\n\t\t\tdev->tx_context[i].echo_id = i;\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[i];\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\treturn NULL;\n}\n\n/* releases a tx context\n */\nstatic void gs_free_tx_context(struct gs_tx_context *txc)\n{\n\ttxc->echo_id = GS_MAX_TX_URBS;\n}\n\n/* Get a tx context by id.\n */\nstatic struct gs_tx_context *gs_get_tx_context(struct gs_can *dev,\n\t\t\t\t\t       unsigned int id)\n{\n\tunsigned long flags;\n\n\tif (id < GS_MAX_TX_URBS) {\n\t\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\t\tif (dev->tx_context[id].echo_id == id) {\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[id];\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t}\n\treturn NULL;\n}\n\nstatic int gs_cmd_reset(struct gs_can *gsdev)\n{\n\tstruct gs_device_mode *dm;\n\tstruct usb_interface *intf = gsdev->iface;\n\tint rc;\n\n\tdm = kzalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\tdm->mode = GS_CAN_MODE_RESET;\n\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     gsdev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tkfree(dm);\n\n\treturn rc;\n}\n\nstatic void gs_update_state(struct gs_can *dev, struct can_frame *cf)\n{\n\tstruct can_device_stats *can_stats = &dev->can.can_stats;\n\n\tif (cf->can_id & CAN_ERR_RESTARTED) {\n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcan_stats->restarts++;\n\t} else if (cf->can_id & CAN_ERR_BUSOFF) {\n\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\tcan_stats->bus_off++;\n\t} else if (cf->can_id & CAN_ERR_CRTL) {\n\t\tif ((cf->data[1] & CAN_ERR_CRTL_TX_WARNING) ||\n\t\t    (cf->data[1] & CAN_ERR_CRTL_RX_WARNING)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_stats->error_warning++;\n\t\t} else if ((cf->data[1] & CAN_ERR_CRTL_TX_PASSIVE) ||\n\t\t\t   (cf->data[1] & CAN_ERR_CRTL_RX_PASSIVE)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_stats->error_passive++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *usbcan = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!usbcan);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto resubmit_urb;\n\n\tdev = usbcan->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tskb = alloc_can_skb(dev->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = hf->can_id;\n\n\t\tcf->can_dlc = get_can_dlc(hf->can_dlc);\n\t\tmemcpy(cf->data, hf->data, 8);\n\n\t\t/* ERROR frames tell us information about the controller */\n\t\tif (hf->can_id & CAN_ERR_FLAG)\n\t\t\tgs_update_state(dev, cf);\n\n\t\tnetdev->stats.rx_packets++;\n\t\tnetdev->stats.rx_bytes += hf->can_dlc;\n\n\t\tnetif_rx(skb);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += hf->can_dlc;\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %d\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tcan_get_echo_skb(netdev, hf->echo_id);\n\n\t\tgs_free_tx_context(txc);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->can_dlc = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tnetif_rx(skb);\n\t}\n\n resubmit_urb:\n\tusb_fill_bulk_urb(urb,\n\t\t\t  usbcan->udev,\n\t\t\t  usb_rcvbulkpipe(usbcan->udev, GSUSB_ENDPOINT_IN),\n\t\t\t  hf,\n\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t  usbcan\n\t\t\t  );\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (usbcan->canch[rc])\n\t\t\t\tnetif_device_detach(usbcan->canch[rc]->netdev);\n\t\t}\n\t}\n}\n\nstatic int gs_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tstruct usb_interface *intf = dev->iface;\n\tint rc;\n\tstruct gs_device_bittiming *dbt;\n\n\tdbt = kmalloc(sizeof(*dbt), GFP_KERNEL);\n\tif (!dbt)\n\t\treturn -ENOMEM;\n\n\tdbt->prop_seg = bt->prop_seg;\n\tdbt->phase_seg1 = bt->phase_seg1;\n\tdbt->phase_seg2 = bt->phase_seg2;\n\tdbt->sjw = bt->sjw;\n\tdbt->brp = bt->brp;\n\n\t/* request bit timings */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BITTIMING,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dbt,\n\t\t\t     sizeof(*dbt),\n\t\t\t     1000);\n\n\tkfree(dbt);\n\n\tif (rc < 0)\n\t\tdev_err(netdev->dev.parent, \"Couldn't set bittimings (err=%d)\",\n\t\t\trc);\n\n\treturn (rc > 0) ? 0 : rc;\n}\n\nstatic void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"usb xmit fail %d\\n\", txc->echo_id);\n\n\tusb_free_coherent(urb->dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n}\n\nstatic netdev_tx_t gs_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\tstruct urb *urb;\n\tstruct gs_host_frame *hf;\n\tstruct can_frame *cf;\n\tint rc;\n\tunsigned int idx;\n\tstruct gs_tx_context *txc;\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* find an empty context to keep track of transmission */\n\ttxc = gs_alloc_tx_context(dev);\n\tif (!txc)\n\t\treturn NETDEV_TX_BUSY;\n\n\t/* create a URB, and a buffer for it */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem_urb;\n\n\thf = usb_alloc_coherent(dev->udev, sizeof(*hf), GFP_ATOMIC,\n\t\t\t\t&urb->transfer_dma);\n\tif (!hf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomem_hf;\n\t}\n\n\tidx = txc->echo_id;\n\n\tif (idx >= GS_MAX_TX_URBS) {\n\t\tnetdev_err(netdev, \"Invalid tx context %d\\n\", idx);\n\t\tgoto badidx;\n\t}\n\n\thf->echo_id = idx;\n\thf->channel = dev->channel;\n\n\tcf = (struct can_frame *)skb->data;\n\n\thf->can_id = cf->can_id;\n\thf->can_dlc = cf->can_dlc;\n\tmemcpy(hf->data, cf->data, cf->can_dlc);\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, GSUSB_ENDPOINT_OUT),\n\t\t\t  hf,\n\t\t\t  sizeof(*hf),\n\t\t\t  gs_usb_xmit_callback,\n\t\t\t  txc);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, idx);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(rc)) {\t\t\t/* usb send failed */\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tcan_free_echo_skb(netdev, idx);\n\t\tgs_free_tx_context(txc);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev,\n\t\t\t\t  sizeof(*hf),\n\t\t\t\t  hf,\n\t\t\t\t  urb->transfer_dma);\n\n\t\tif (rc == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_err(netdev, \"usb_submit failed (err=%d)\\n\", rc);\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= GS_MAX_TX_URBS)\n\t\t\tnetif_stop_queue(netdev);\n\t}\n\n\t/* let usb core take care of this urb */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\n badidx:\n\tusb_free_coherent(dev->udev,\n\t\t\t  sizeof(*hf),\n\t\t\t  hf,\n\t\t\t  urb->transfer_dma);\n nomem_hf:\n\tusb_free_urb(urb);\n\n nomem_urb:\n\tgs_free_tx_context(txc);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tint rc, i;\n\tstruct gs_device_mode *dm;\n\tu32 ctrlmode;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tif (atomic_add_return(1, &parent->active_channels) == 1) {\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tstruct urb *urb;\n\t\t\tu8 *buf;\n\n\t\t\t/* alloc rx urb */\n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* alloc rx buffer */\n\t\t\tbuf = usb_alloc_coherent(dev->udev,\n\t\t\t\t\t\t sizeof(struct gs_host_frame),\n\t\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t\t &urb->transfer_dma);\n\t\t\tif (!buf) {\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"No memory left for USB buffer\\n\");\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t/* fill, anchor, and submit rx urb */\n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GSUSB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  sizeof(struct gs_host_frame),\n\t\t\t\t\t  gs_usb_receive_bulk_callback,\n\t\t\t\t\t  parent);\n\t\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit failed (err=%d)\\n\",\n\t\t\t\t\t   rc);\n\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Drop reference,\n\t\t\t * USB core will take care of freeing it\n\t\t\t */\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\tdm = kmalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\n\t/* flags */\n\tctrlmode = dev->can.ctrlmode;\n\tdm->flags = 0;\n\n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tdm->flags |= GS_CAN_MODE_LOOP_BACK;\n\telse if (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tdm->flags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\t/* Controller is not allowed to retry TX\n\t * this mode is unavailable on atmels uc3c hardware\n\t */\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdm->flags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tdm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\t/* finally start device */\n\tdm->mode = GS_CAN_MODE_START;\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tkfree(dm);\n\t\treturn rc;\n\t}\n\n\tkfree(dm);\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic int gs_can_close(struct net_device *netdev)\n{\n\tint rc;\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tif (atomic_dec_and_test(&parent->active_channels))\n\t\tusb_kill_anchored_urbs(&parent->rx_submitted);\n\n\t/* Stop sending URBs */\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\t/* reset the device */\n\trc = gs_cmd_reset(dev);\n\tif (rc < 0)\n\t\tnetdev_warn(netdev, \"Couldn't shutdown device (err=%d)\", rc);\n\n\t/* reset tx contexts */\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* close the netdev */\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops gs_usb_netdev_ops = {\n\t.ndo_open = gs_can_open,\n\t.ndo_stop = gs_can_close,\n\t.ndo_start_xmit = gs_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic int gs_usb_set_identify(struct net_device *netdev, bool do_identify)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_identify_mode *imode;\n\tint rc;\n\n\timode = kmalloc(sizeof(*imode), GFP_KERNEL);\n\n\tif (!imode)\n\t\treturn -ENOMEM;\n\n\tif (do_identify)\n\t\timode->mode = GS_CAN_IDENTIFY_ON;\n\telse\n\t\timode->mode = GS_CAN_IDENTIFY_OFF;\n\n\trc = usb_control_msg(interface_to_usbdev(dev->iface),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(dev->iface),\n\t\t\t\t\t     0),\n\t\t\t     GS_USB_BREQ_IDENTIFY,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t     USB_RECIP_INTERFACE,\n\t\t\t     dev->channel,\n\t\t\t     0,\n\t\t\t     imode,\n\t\t\t     sizeof(*imode),\n\t\t\t     100);\n\n\tkfree(imode);\n\n\treturn (rc > 0) ? 0 : rc;\n}\n\n/* blink LED's for finding the this interface */\nstatic int gs_usb_set_phys_id(struct net_device *dev,\n\t\t\t      enum ethtool_phys_id_state state)\n{\n\tint rc = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_ON);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\trc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_OFF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct ethtool_ops gs_usb_ethtool_ops = {\n\t.set_phys_id = gs_usb_set_phys_id,\n};\n\nstatic struct gs_can *gs_make_candev(unsigned int channel,\n\t\t\t\t     struct usb_interface *intf,\n\t\t\t\t     struct gs_device_config *dconf)\n{\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct gs_device_bt_const *bt_const;\n\n\tbt_const = kmalloc(sizeof(*bt_const), GFP_KERNEL);\n\tif (!bt_const)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* fetch bit timing constants */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_BT_CONST,\n\t\t\t     USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     channel,\n\t\t\t     0,\n\t\t\t     bt_const,\n\t\t\t     sizeof(*bt_const),\n\t\t\t     1000);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't get bit timing const for channel (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t/* create netdev */\n\tnetdev = alloc_candev(sizeof(struct gs_can), GS_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't allocate candev\\n\");\n\t\tkfree(bt_const);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &gs_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support full roundtrip echo */\n\n\t/* dev settup */\n\tstrcpy(dev->bt_const.name, \"gs_usb\");\n\tdev->bt_const.tseg1_min = bt_const->tseg1_min;\n\tdev->bt_const.tseg1_max = bt_const->tseg1_max;\n\tdev->bt_const.tseg2_min = bt_const->tseg2_min;\n\tdev->bt_const.tseg2_max = bt_const->tseg2_max;\n\tdev->bt_const.sjw_max = bt_const->sjw_max;\n\tdev->bt_const.brp_min = bt_const->brp_min;\n\tdev->bt_const.brp_max = bt_const->brp_max;\n\tdev->bt_const.brp_inc = bt_const->brp_inc;\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->iface = intf;\n\tdev->netdev = netdev;\n\tdev->channel = channel;\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\tspin_lock_init(&dev->tx_ctx_lock);\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t/* can settup */\n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = bt_const->fclk_can;\n\tdev->can.bittiming_const = &dev->bt_const;\n\tdev->can.do_set_bittiming = gs_usb_set_bittiming;\n\n\tdev->can.ctrlmode_supported = 0;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LISTEN_ONLY)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_LOOP_BACK)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\tif (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tif (dconf->sw_version > 1)\n\t\tif (bt_const->feature & GS_CAN_FEATURE_IDENTIFY)\n\t\t\tnetdev->ethtool_ops = &gs_usb_ethtool_ops;\n\n\tkfree(bt_const);\n\n\trc = register_candev(dev->netdev);\n\tif (rc) {\n\t\tfree_candev(dev->netdev);\n\t\tdev_err(&intf->dev, \"Couldn't register candev (err=%d)\\n\", rc);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn dev;\n}\n\nstatic void gs_destroy_candev(struct gs_can *dev)\n{\n\tunregister_candev(dev->netdev);\n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tfree_candev(dev->netdev);\n}\n\nstatic int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\n\thconf->byte_order = 0x0000beef;\n\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\n\tkfree(hconf);\n\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n\tif (!dconf)\n\t\treturn -ENOMEM;\n\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     dconf,\n\t\t\t     sizeof(*dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(dconf);\n\t\treturn rc;\n\t}\n\n\ticount = dconf->icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\tkfree(dconf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(dconf);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tatomic_set(&dev->active_channels, 0);\n\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dconf);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\n\tkfree(dconf);\n\n\treturn 0;\n}\n\nstatic void gs_usb_disconnect(struct usb_interface *intf)\n{\n\tunsigned i;\n\tstruct gs_usb *dev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!dev) {\n\t\tdev_err(&intf->dev, \"Disconnect (nodata)\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < GS_MAX_INTF; i++)\n\t\tif (dev->canch[i])\n\t\t\tgs_destroy_candev(dev->canch[i]);\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\tkfree(dev);\n}\n\nstatic const struct usb_device_id gs_usb_table[] = {\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_GSUSB_1_VENDOR_ID,\n\t\t\t\t      USB_GSUSB_1_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_CANDLELIGHT_VENDOR_ID,\n\t\t\t\t      USB_CANDLELIGHT_PRODUCT_ID, 0) },\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, gs_usb_table);\n\nstatic struct usb_driver gs_usb_driver = {\n\t.name       = \"gs_usb\",\n\t.probe      = gs_usb_probe,\n\t.disconnect = gs_usb_disconnect,\n\t.id_table   = gs_usb_table,\n};\n\nmodule_usb_driver(gs_usb_driver);\n\nMODULE_AUTHOR(\"Maximilian Schneider <mws@schneidersoft.net>\");\nMODULE_DESCRIPTION(\n\"Socket CAN device driver for Geschwister Schneider Technologie-, \"\n\"Entwicklungs- und Vertriebs UG. USB2.0 to CAN interfaces\\n\"\n\"and bytewerk.org candleLight USB CAN interfaces.\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/net/can/usb/gs_usb.c"], "buggy_code_start_loc": [625], "buggy_code_end_loc": [625], "fixing_code_start_loc": [626], "fixing_code_end_loc": [627], "type": "CWE-401", "message": "A memory leak in the gs_can_open() function in drivers/net/can/usb/gs_usb.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-fb5be6a7b486.", "other": {"cve": {"id": "CVE-2019-19052", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.827", "lastModified": "2023-01-19T16:48:31.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the gs_can_open() function in drivers/net/can/usb/gs_usb.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-fb5be6a7b486."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n gs_can_open() en el archivo drivers/net/can/usb/gs_usb.c en el kernel de Linux versiones anteriores a la versi\u00f3n  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n usb_submit_urb(), tambi\u00e9n se conoce como CID -fb5be6a7b486."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.16", "versionEndExcluding": "3.16.79", "matchCriteriaId": "466E8514-77DE-442B-A416-897414E503AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "4.4.201", "matchCriteriaId": "FFFFB7E1-E073-4F1D-BE6C-47BC329AB8AB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.201", "matchCriteriaId": "07F85281-8267-466C-A6C2-316BB0201848"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.154", "matchCriteriaId": "F36AD3D1-719C-427A-B906-E8DA4D38A536"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.84", "matchCriteriaId": "439D2F45-FE93-4C28-9BD9-4289B375BAAB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.3.11", "matchCriteriaId": "76866D41-FE21-4B5A-A2A0-DDBA43C04B9C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:sd-wan_edge:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "78C99571-0F3C-43E6-84B3-7D80E045EF8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C0ADE5D-F91D-4E0D-B6C5-3511B19665F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "8AFF1109-26F3-43A5-A4CB-0F169FDBC0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AF71C49-ADEF-4EE2-802C-6159ADD51355"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.20:*:*:*:*:*:*:*", "matchCriteriaId": "B3BC6E59-2134-4A28-AAD2-77C8AE236BCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.25:*:*:*:*:*:*:*", "matchCriteriaId": "24377899-5389-4BDC-AC82-0E4186F4DE53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30:*:*:*:*:*:*:*", "matchCriteriaId": "23FE83DE-AE7C-4313-88E3-886110C31302"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30.5r3:*:*:*:*:*:*:*", "matchCriteriaId": "490B327B-AC20-419B-BB76-8AB6971304BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40:*:*:*:*:*:*:*", "matchCriteriaId": "8DCE2754-7A9E-4B3B-91D1-DCF90C1BABE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.3r2:*:*:*:*:*:*:*", "matchCriteriaId": "6CA74E8B-51E2-4A7C-8A98-0583D31134A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B64AB37-A1D9-4163-A51B-4C780361F1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.1:*:*:*:*:*:*:*", "matchCriteriaId": "7BE9C9D7-9CED-4184-A190-1024A6FB8C82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:-:*:*:*:*:*:*", "matchCriteriaId": "B73D4C3C-A511-4E14-B19F-91F561ACB1B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:p1:*:*:*:*:*:*", "matchCriteriaId": "0C47D72C-9B6B-4E52-AF0E-56AD58E4A930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60:*:*:*:*:*:*:*", "matchCriteriaId": "039C3790-5AA2-4895-AEAE-CC84A71DB907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4592238-D1F2-43D6-9BAB-2F63ECF9C965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BA78068-80E9-4E49-9056-88EAB7E3682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.3:*:*:*:*:*:*:*", "matchCriteriaId": "092F366C-E8B0-4BE5-B106-0B7A73B08D34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.1:*:*:*:*:*:*:*", "matchCriteriaId": "E7992E92-B159-4810-B895-01A9B944058A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.2:*:*:*:*:*:*:*", "matchCriteriaId": "5BDD7AAB-2BF3-4E8C-BEE2-5217E2926C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas\\/aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "66EEA3CA-8CC7-4F0B-8204-6132D4114873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h610s:*:*:*:*:*:*:*", "matchCriteriaId": "DE7C6010-F736-4BDA-9E3B-C4370BBFA149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:broadcom:brocade_fabric_operating_system_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B2748912-FC54-47F6-8C0C-B96784765B8E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.11", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/fb5be6a7b4863ecc44963bb80ca614584b6c7817", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4227-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4228-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4228-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fb5be6a7b4863ecc44963bb80ca614584b6c7817"}}