{"buggy_code": ["package converter\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/asaskevich/govalidator\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"github.com/yuin/goldmark\"\n\t\"github.com/yuin/goldmark/ast\"\n\t\"github.com/yuin/goldmark/extension\"\n\t\"github.com/yuin/goldmark/parser\"\n\t\"github.com/yuin/goldmark/renderer\"\n\t\"github.com/yuin/goldmark/renderer/html\"\n\tgoldmarkHTML \"github.com/yuin/goldmark/renderer/html\"\n\t\"github.com/yuin/goldmark/util\"\n)\n\n// Markdown2HTML convert markdown to html\nfunc Markdown2HTML(source string) string {\n\tmdConverter := goldmark.New(\n\t\tgoldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),\n\t\tgoldmark.WithParserOptions(\n\t\t\tparser.WithAutoHeadingID(),\n\t\t),\n\t\tgoldmark.WithRendererOptions(\n\t\t\tgoldmarkHTML.WithHardWraps(),\n\t\t),\n\t)\n\tvar buf bytes.Buffer\n\tif err := mdConverter.Convert([]byte(source), &buf); err != nil {\n\t\tlog.Error(err)\n\t\treturn source\n\t}\n\treturn buf.String()\n}\n\n// Markdown2BasicHTML convert markdown to html ,Only basic syntax can be used\nfunc Markdown2BasicHTML(source string) string {\n\tcontent := Markdown2HTML(source)\n\tfilter := bluemonday.NewPolicy()\n\tfilter.AllowElements(\"p\", \"b\", \"br\")\n\tfilter.AllowAttrs(\"src\").OnElements(\"img\")\n\tfilter.AddSpaceWhenStrippingTag(true)\n\tcontent = filter.Sanitize(content)\n\treturn content\n}\n\ntype DangerousHTMLFilterExtension struct {\n}\n\nfunc (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {\n\tm.Renderer().AddOptions(renderer.WithNodeRenderers(\n\t\tutil.Prioritized(&DangerousHTMLRenderer{\n\t\t\tConfig: goldmarkHTML.NewConfig(),\n\t\t\tFilter: bluemonday.UGCPolicy(),\n\t\t}, 1),\n\t))\n}\n\ntype DangerousHTMLRenderer struct {\n\tgoldmarkHTML.Config\n\tFilter *bluemonday.Policy\n}\n\n// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.\nfunc (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {\n\treg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)\n\treg.Register(ast.KindRawHTML, r.renderRawHTML)\n\treg.Register(ast.KindLink, r.renderLink)\n\treg.Register(ast.KindAutoLink, r.renderAutoLink)\n\n}\n\nfunc (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tif !entering {\n\t\treturn ast.WalkSkipChildren, nil\n\t}\n\tn := node.(*ast.RawHTML)\n\tl := n.Segments.Len()\n\tfor i := 0; i < l; i++ {\n\t\tsegment := n.Segments.At(i)\n\t\t_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))\n\t}\n\treturn ast.WalkSkipChildren, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.HTMLBlock)\n\tif entering {\n\t\tl := n.Lines().Len()\n\t\tfor i := 0; i < l; i++ {\n\t\t\tline := n.Lines().At(i)\n\t\t\tr.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))\n\t\t}\n\t} else {\n\t\tif n.HasClosure() {\n\t\t\tclosure := n.ClosureLine\n\t\t\tr.Writer.SecureWrite(w, closure.Value(source))\n\t\t}\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\n\tn := node.(*ast.Link)\n\tif entering && r.renderLinkIsUrl(string(n.Destination)) {\n\t\t_, _ = w.WriteString(\"<a href=\\\"\")\n\t\tif r.Unsafe || !html.IsDangerousURL(n.Destination) {\n\t\t\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))\n\t\t}\n\t\t_ = w.WriteByte('\"')\n\t\tif n.Title != nil {\n\t\t\t_, _ = w.WriteString(` title=\"`)\n\t\t\tr.Writer.Write(w, n.Title)\n\t\t\t_ = w.WriteByte('\"')\n\t\t}\n\t\tif n.Attributes() != nil {\n\t\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t}\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(\"</a>\")\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.AutoLink)\n\n\tif !entering || !r.renderLinkIsUrl(string(n.URL(source))) {\n\t\treturn ast.WalkContinue, nil\n\t}\n\t_, _ = w.WriteString(`<a href=\"`)\n\turl := n.URL(source)\n\tlabel := n.Label(source)\n\tif n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(\"mailto:\")) {\n\t\t_, _ = w.WriteString(\"mailto:\")\n\t}\n\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))\n\tif n.Attributes() != nil {\n\t\t_ = w.WriteByte('\"')\n\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(`\">`)\n\t}\n\t_, _ = w.Write(util.EscapeHTML(label))\n\t_, _ = w.WriteString(`</a>`)\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {\n\treturn govalidator.IsURL(verifyUrl)\n}\n"], "fixing_code": ["package converter\n\nimport (\n\t\"bytes\"\n\n\t\"github.com/asaskevich/govalidator\"\n\t\"github.com/microcosm-cc/bluemonday\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"github.com/yuin/goldmark\"\n\t\"github.com/yuin/goldmark/ast\"\n\t\"github.com/yuin/goldmark/extension\"\n\t\"github.com/yuin/goldmark/parser\"\n\t\"github.com/yuin/goldmark/renderer\"\n\t\"github.com/yuin/goldmark/renderer/html\"\n\tgoldmarkHTML \"github.com/yuin/goldmark/renderer/html\"\n\t\"github.com/yuin/goldmark/util\"\n)\n\n// Markdown2HTML convert markdown to html\nfunc Markdown2HTML(source string) string {\n\tmdConverter := goldmark.New(\n\t\tgoldmark.WithExtensions(&DangerousHTMLFilterExtension{}, extension.GFM),\n\t\tgoldmark.WithParserOptions(\n\t\t\tparser.WithAutoHeadingID(),\n\t\t),\n\t\tgoldmark.WithRendererOptions(\n\t\t\tgoldmarkHTML.WithHardWraps(),\n\t\t),\n\t)\n\tvar buf bytes.Buffer\n\tif err := mdConverter.Convert([]byte(source), &buf); err != nil {\n\t\tlog.Error(err)\n\t\treturn source\n\t}\n\thtml := buf.String()\n\tfilter := bluemonday.NewPolicy()\n\thtml = filter.Sanitize(html)\n\treturn html\n}\n\n// Markdown2BasicHTML convert markdown to html ,Only basic syntax can be used\nfunc Markdown2BasicHTML(source string) string {\n\tcontent := Markdown2HTML(source)\n\tfilter := bluemonday.NewPolicy()\n\tfilter.AllowElements(\"p\", \"b\", \"br\")\n\tfilter.AllowAttrs(\"src\").OnElements(\"img\")\n\tfilter.AddSpaceWhenStrippingTag(true)\n\tcontent = filter.Sanitize(content)\n\treturn content\n}\n\ntype DangerousHTMLFilterExtension struct {\n}\n\nfunc (e *DangerousHTMLFilterExtension) Extend(m goldmark.Markdown) {\n\tm.Renderer().AddOptions(renderer.WithNodeRenderers(\n\t\tutil.Prioritized(&DangerousHTMLRenderer{\n\t\t\tConfig: goldmarkHTML.NewConfig(),\n\t\t\tFilter: bluemonday.UGCPolicy(),\n\t\t}, 1),\n\t))\n}\n\ntype DangerousHTMLRenderer struct {\n\tgoldmarkHTML.Config\n\tFilter *bluemonday.Policy\n}\n\n// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.\nfunc (r *DangerousHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {\n\treg.Register(ast.KindHTMLBlock, r.renderHTMLBlock)\n\treg.Register(ast.KindRawHTML, r.renderRawHTML)\n\treg.Register(ast.KindLink, r.renderLink)\n\treg.Register(ast.KindAutoLink, r.renderAutoLink)\n\n}\n\nfunc (r *DangerousHTMLRenderer) renderRawHTML(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tif !entering {\n\t\treturn ast.WalkSkipChildren, nil\n\t}\n\tn := node.(*ast.RawHTML)\n\tl := n.Segments.Len()\n\tfor i := 0; i < l; i++ {\n\t\tsegment := n.Segments.At(i)\n\t\t_, _ = w.Write(r.Filter.SanitizeBytes(segment.Value(source)))\n\t}\n\treturn ast.WalkSkipChildren, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderHTMLBlock(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.HTMLBlock)\n\tif entering {\n\t\tl := n.Lines().Len()\n\t\tfor i := 0; i < l; i++ {\n\t\t\tline := n.Lines().At(i)\n\t\t\tr.Writer.SecureWrite(w, r.Filter.SanitizeBytes(line.Value(source)))\n\t\t}\n\t} else {\n\t\tif n.HasClosure() {\n\t\t\tclosure := n.ClosureLine\n\t\t\tr.Writer.SecureWrite(w, closure.Value(source))\n\t\t}\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\n\tn := node.(*ast.Link)\n\tif entering && r.renderLinkIsUrl(string(n.Destination)) {\n\t\t_, _ = w.WriteString(\"<a href=\\\"\")\n\t\tif r.Unsafe || !html.IsDangerousURL(n.Destination) {\n\t\t\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))\n\t\t}\n\t\t_ = w.WriteByte('\"')\n\t\tif n.Title != nil {\n\t\t\t_, _ = w.WriteString(` title=\"`)\n\t\t\tr.Writer.Write(w, n.Title)\n\t\t\t_ = w.WriteByte('\"')\n\t\t}\n\t\tif n.Attributes() != nil {\n\t\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t}\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(\"</a>\")\n\t}\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) {\n\tn := node.(*ast.AutoLink)\n\n\tif !entering || !r.renderLinkIsUrl(string(n.URL(source))) {\n\t\treturn ast.WalkContinue, nil\n\t}\n\t_, _ = w.WriteString(`<a href=\"`)\n\turl := n.URL(source)\n\tlabel := n.Label(source)\n\tif n.AutoLinkType == ast.AutoLinkEmail && !bytes.HasPrefix(bytes.ToLower(url), []byte(\"mailto:\")) {\n\t\t_, _ = w.WriteString(\"mailto:\")\n\t}\n\t_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))\n\tif n.Attributes() != nil {\n\t\t_ = w.WriteByte('\"')\n\t\thtml.RenderAttributes(w, n, html.LinkAttributeFilter)\n\t\t_ = w.WriteByte('>')\n\t} else {\n\t\t_, _ = w.WriteString(`\">`)\n\t}\n\t_, _ = w.Write(util.EscapeHTML(label))\n\t_, _ = w.WriteString(`</a>`)\n\treturn ast.WalkContinue, nil\n}\n\nfunc (r *DangerousHTMLRenderer) renderLinkIsUrl(verifyUrl string) bool {\n\treturn govalidator.IsURL(verifyUrl)\n}\n"], "filenames": ["pkg/converter/markdown.go"], "buggy_code_start_loc": [35], "buggy_code_end_loc": [36], "fixing_code_start_loc": [35], "fixing_code_end_loc": [39], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository answerdev/answer prior to 1.0.7.", "other": {"cve": {"id": "CVE-2023-1536", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-21T05:15:09.630", "lastModified": "2023-03-23T15:13:25.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository answerdev/answer prior to 1.0.7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.7", "matchCriteriaId": "04A638AA-976E-4A76-B0C0-A1B167B41572"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/c3743bad4f2a69f69f8f1e1e5b4b6524fc03da25", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/538207f4-f805-419a-a314-51716643f05e", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/c3743bad4f2a69f69f8f1e1e5b4b6524fc03da25"}}