{"buggy_code": ["//For jQuery 1.3.2\n\ndojo.provide(\"dojox.jq\");\ndojo.require(\"dojo.NodeList-traverse\");\ndojo.require(\"dojo.NodeList-manipulate\");\ndojo.require(\"dojo.io.script\");\n\n/*\nTo get jquery tests to pass:\n- add spaces between span>form selectors, other ones like one,two\n- .last() instead of :last\n- $(\"<div>\").find(\"#foo\") does not work unless the div is attached to the body.\n\n- trigger .test not work\n- No jquery.Event thing.\n\n- jQuery.ajax() modifies incoming arguments?\n- test framework not good for our io methods, async, poll.\n- Dojo ajax is async: we fire ajaxStop more than jquery.\n\n- jquery makes assumptions of a value to set for an element\nby inserting an element and checking display. Does not seem to\naccount for nested styles, only captures generic tag name style off\nof body. Why can't we just set display to empty?\n\n\n\n\n\nOK for failures:\n- test(\"jQuery.ajax - beforeSend, cancel request (#2688)\"\n  We cancel the deferred which triggers error and complete callbacks.\n\n\nLooked at jquery code for:\n- how it handled text(): did not use textContent/innerText, but use recursive look over childNodes and nodeValue,\nso it may have impact on how <br> is serialized, but it has uniform behavior across browsers.\n- Looked at trigger: how it triggered actions on dom nodes. This seemed unsafe.\n*/\n\n/*\ndojo.query differences that cause some tests to fail:\n- does not support XML queries\n- $(\"#sap>form\") does not find a match but $(\"#sap > form\") does. Similar issue with comma instead of > (see is() tests)\n- \"$(\"form:last\") should return the last form object, not if that particular form is that last related\n  to its siblings? Same issue with :first?\n- $(\"p\").filter(\"#ap, #sndp\"): filter does not work.\n- dojo.NodeList uses d.NodeList a few places in the code. Would be nice to use a ctor that can be configured.\n  That would make the filter function operate better.\n- filterQueryResult, cannot handle queries like \"p, div\"? See andSelf test with parents().\n- adjacent \"p + p\" not supported?\n= a:only-child not supported?\n- nth(1)\n- even/odd\n- eq/gt/lt\n- #form :radio:checked does not run the first :radio psuedo selector? Seems to be a general issue where only the last pseud\n  is run. For example, \"#form :checked:radio\" does only the radio pseudo.\n*/\n\n(function(){\n\t//Enable io topic publishing.   But don't mask the original definition of ioPublish from the doc parser.\n\t/*===== var ioPublish = dojo.config.ioPublish; =====*/\n\tdojo.config.ioPublish = true;\n\t/*===== dojo.config.ioPublish = ioPublish; =====*/\n\n\t//Support stuff for toDom\n\tvar selfClosedTags = \"|img|meta|hr|br|input|\";\n\n\tfunction toDom(/*String*/html, /*Document?*/doc){\n\t\t//summary converts HTML string into DOM nodes.\n\t\t//Make sure html is a string.\n\t\thtml += \"\";\n\n\t\t//Convert <tag/> into <tag></tag>\n\t\thtml = html.replace(/<\\s*(\\w+)([^\\/\\>]*)\\/\\s*>/g, function(tag, name, contents){\n\t\t\tif(selfClosedTags.indexOf(\"|\" + name + \"|\") == -1){\n\t\t\t\treturn \"<\" + name + contents + \"></\" + name + \">\";\n\t\t\t}else{\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t});\n\n\t\treturn dojo._toDom(html, doc);\n\t}\n\n\tfunction cssNameToJs(name){\n\t\tvar index = name.indexOf(\"-\");\n\t\tif(index != -1){\n\t\t\t//Strip off beginning dash\n\t\t\tif(index == 0){\n\t\t\t\tname = name.substring(1);\n\t\t\t}\n\t\t\tname = name.replace(/-(\\w)/g, function(match, match1){\n\t\t\t\treturn match1.toUpperCase();\n\t\t\t});\n\t\t}\n\t\treturn name;\n\t}\n\n\tvar _old$ = dojo.global.$;\n\tvar _oldJQuery = dojo.global.jQuery;\n\n\tvar $ = dojo.global.$ = dojo.global.jQuery = function(){\n\t\tvar arg = arguments[0];\n\t\tif(!arg){\n\t\t\treturn $._wrap([], null, $);\n\t\t}else if(dojo.isString(arg)){\n\t\t\tif(arg.charAt(0) == \"<\"){\n\t\t\t\t//String of html that needs nodes created.\n\t\t\t\targ = toDom(arg);\n\t\t\t\t//If a DocumentFragment, convert to use its children\n\t\t\t\t//since we want to treat all top level nodes as elements\n\t\t\t\t//in the NodeList array.\n\t\t\t\tif(arg.nodeType == 11){\n\t\t\t\t\targ = arg.childNodes;\n\t\t\t\t}else{\n\t\t\t\t\treturn $._wrap([arg], null, $);\n\t\t\t\t}\n\t\t\t\t//Use end case of nodelist to finish work.\n\t\t\t}else{\n\t\t\t\t//Normal dojo.query selector.\n\t\t\t\t//Switch out query's NodeList constructor to be our specialized\n\t\t\t\t//NodeList constructor.\n\t\t\t\tvar listCtor = dojo._NodeListCtor;\n\t\t\t\tdojo._NodeListCtor = $;\n\n\t\t\t\t//If the second arg is one of our fake NodeLists then\n\t\t\t\t//use the first parent for the call.\n\t\t\t\tvar arg2 = arguments[1];\n\t\t\t\tif(arg2 && arg2._is$){\n\t\t\t\t\targ2 = arg2[0];\n\t\t\t\t}else if(dojo.isString(arg2)){\n\t\t\t\t\targ2 = dojo.query(arg2)[0];\n\t\t\t\t}\n\n\t\t\t\tvar nl = dojo.query.call(this, arg, arg2);\n\t\t\t\tdojo._NodeListCtor = listCtor;\n\t\t\t\treturn nl;\n\t\t\t}\n\t\t}else if(dojo.isFunction(arg)){\n\t\t\t//The addOnLoad case\n\t\t\t$.ready(arg);\n\t\t\treturn $;\n\t\t}else if(arg == document || arg == window){\n\t\t\t//If the arg is the document or window,\n\t\t\t//then just use it directly.\n\t\t\treturn $._wrap([arg], null, $);\n\t\t}else if(dojo.isArray(arg)){\n\t\t\t//Input is a plain array.\n\t\t\t//Filter out duplicates.\n\t\t\tvar ary = [];\n\t\t\tfor(var i = 0; i < arg.length; i++){\n\t\t\t\tif(dojo.indexOf(ary, arg[i]) == -1){\n\t\t\t\t\tary.push(arg[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $._wrap(arg, null, $);\n\t\t}else if(\"nodeType\" in arg){\n\t\t\t//A DOM Node\n\t\t\treturn $._wrap([arg], null, $);\n\t\t}\n\n\t\t//A native NodeList that does not conform to dojo.isArray().\n\t\t//Convert it to a workable array and create new NodeList.\n\t\treturn $._wrap(dojo._toArray(arg), null, $);\n\n\t};\n\n\t//Set up plugin extension point.\n\tvar nlProto = dojo.NodeList.prototype;\n\n\t//Need a delegate, because at least one method conflicts with jquery\n\t//API: attr(name) in jQuery only returns a single, first value, where\n\t//dojo.attr will return an array.\n\tvar f = $.fn = $.prototype = dojo.delegate(nlProto);\n\n\t//_wrap is required for proper use in dojo.query, but the _adaptAs* methods\n\t//do not have to placed on $ -- they can be used directly off dojo.NodeList.\n\t$._wrap = dojo.NodeList._wrap;\n\n\t//Add in some pseudos selectors\n\tvar headerRegExp = /^H\\d/i;\n\tvar pseudos = dojo.query.pseudos;\n\tdojo.mixin(pseudos, {\n\t\thas: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn $(condition, elem).length;\n\t\t\t}\n\t\t},\n\t\tvisible: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn dojo.style(elem, \"visible\") != \"hidden\" && dojo.style(elem, \"display\") != \"none\";\n\t\t\t}\n\t\t},\n\t\thidden: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.type == \"hidden\" || dojo.style(elem, \"visible\") == \"hidden\" || dojo.style(elem, \"display\") == \"none\";\n\t\t\t}\n\t\t},\n\t\tselected: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.selected;\n\t\t\t}\n\t\t},\n\t\tchecked: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.nodeName.toUpperCase() == \"INPUT\" && elem.checked;\n\t\t\t}\n\t\t},\n\t\tdisabled: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.getAttribute(\"disabled\");\n\t\t\t}\n\t\t},\n\t\tenabled: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn !elem.getAttribute(\"disabled\");\n\t\t\t}\n\t\t},\n\t\tinput: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\tvar n = elem.nodeName.toUpperCase();\n\t\t\t\treturn n == \"INPUT\" || n == \"SELECT\" || n == \"TEXTAREA\" || n == \"BUTTON\";\n\t\t\t}\n\t\t},\n\t\tbutton: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn (elem.nodeName.toUpperCase() == \"INPUT\" && elem.type == \"button\") || elem.nodeName.toUpperCase() == \"BUTTON\";\n\t\t\t}\n\t\t},\n\t\theader: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.nodeName.match(headerRegExp);\n\t\t\t}\n\t\t}\n\t\t//TODO: implement :animated\n\t});\n\n\n\t//Add the input type selectors to pseudos\n\tvar inputPseudos = {};\n\tdojo.forEach([\n\t\t\"text\", \"password\", \"radio\", \"checkbox\", \"submit\", \"image\", \"reset\", \"file\"\n\t], function(type) {\n\t\tinputPseudos[type] = function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.nodeName.toUpperCase() == \"INPUT\" && elem.type == type;\n\t\t\t}\n\t\t};\n\t});\n\tdojo.mixin(pseudos, inputPseudos);\n\n\t//Set up browser sniff.\n\t$.browser = {\n\t\tmozilla: dojo.isMoz,\n\t\tmsie: dojo.isIE,\n\t\topera: dojo.isOpera,\n\t\tsafari: dojo.isSafari\n\t};\n\t$.browser.version = dojo.isIE || dojo.isMoz || dojo.isOpera || dojo.isSafari || dojo.isWebKit;\n\t\n\t//Map back into dojo\n\t//Hmm maybe this is not so good. Dojo\n\t//modules may still be holding on to old\n\t//dojo (example: the d._NodeListCtor in query.js)\n\t//dojo = dojo.mixin($, dojo);\n\n\t// Add $.ready\n\t$.ready = $.fn.ready = function(callback){\n\t\tdojo.addOnLoad(dojo.hitch(null, callback, $));\n\t\treturn this;\n\t}\n\n\t//START jquery Core API methods\n\t//http://docs.jquery.com/Core\n\tf._is$ = true;\n\tf.size = function(){return this.length; };\n\n\t$.prop = function(node, propCheck){\n\t\t//TODO: not sure about this one, could not find the docs?\n\t\tif(dojo.isFunction(propCheck)){\n\t\t\treturn propCheck.call(node);\n\t\t}else{\n\t\t\treturn propCheck;\n\t\t}\n\t}\n\n\t$.className = {\n\t\tadd: dojo.addClass,\n\t\tremove: dojo.removeClass,\n\t\thas: dojo.hasClass\n\t};\n\n\t$.makeArray = function(thing){\n\t\tif(typeof thing == \"undefined\"){\n\t\t\treturn [];\n\t\t}else if(thing.length && !dojo.isString(thing) && !(\"location\" in thing)){\n\t\t\t//Location check was for excluding window objects that have a length.\n\t\t\treturn dojo._toArray(thing);\n\t\t}else{\n\t\t\treturn [thing];\n\t\t}\n\t}\n\t\n\t$.merge = function(ary1, ary2){\n\t\t//Alters first array by adding in the element.\n\t\tvar args = [ary1.length, 0];\n\t\targs = args.concat(ary2);\n\t\tary1.splice.apply(ary1, args);\n\t\treturn ary1;\n\t}\n\n\t$.each = function(/*Array||ArrayLike*/list, /*Function*/cb){\n\t\t//each differs from dojo.NodeList.forEach in that\n\t\t//\"this\" is the current cycled node. Breaking\n\t\t//the loop is also possible. Also, index is first arg\n\t\t//to the callback.\n\t\tif(dojo.isArrayLike(list)){\n\t\t\tfor(var i = 0; i < list.length; i++){\n\t\t\t\tif(cb.call(list[i], i, list[i]) === false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dojo.isObject(list)){\n\t\t\tfor(var param in list){\n\t\t\t\tif(cb.call(list[param], param, list[param]) === false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\tf.each = function(/*Function*/cb){\n\t\treturn $.each.call(this, this, cb);\n\t};\n\t//f.length already implemented by NodeList\n\tf.eq = function(){\n\t\t//Direct copy of dojo.NodeList.at, but want\n\t\t//to use our NodeList class.\n\t\tvar nl = $();\n\t\tdojo.forEach(arguments, function(i) { if(this[i]) { nl.push(this[i]); } }, this);\n\t\treturn nl; // dojo.NodeList\n\t};\n\tf.get = function(/*Number*/index){\n\t\tif(index || index == 0){\n\t\t\treturn this[index];\n\t\t}\n\t\treturn this;\n\t};\n\tf.index = function(arg){\n\t\t//Hmm, allows passing in a $ nodelist. Apparently in that\n\t\t//case take the first item in that array and match\n\t\tif(arg._is$){\n\t\t\targ = arg[0];\n\t\t}\n\t\treturn this.indexOf(arg);\n\t}\n\n\t//.data implementation\n\tvar dataStore = [];\n\tvar dataId = 0;\n\tvar dataAttr = dojo._scopeName + \"DataId\";\n\t\n\tvar getDataId = function(node){\n\t\tvar id = node.getAttribute(dataAttr);\n\t\tif(!id){\n\t\t\tid = dataId++;\n\t\t\tnode.setAttribute(dataAttr, id);\n\t\t}\n\t}\n\t\n\tvar getData = function(node){\n\t\tvar data = {};\n\t\tif(node.nodeType == 1){\n\t\t\tvar id = getDataId(node);\n\t\t\tdata = dataStore[id];\n\t\t\tif(!data){\n\t\t\t\tdata = dataStore[id] = {};\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\t$.data = function(/*DOMNode*/node, /*String*/name, /*String*/value){\n\t\tvar result = null;\n\t\tif(name == \"events\"){\n\t\t\t//Special case \"events\", since jquery tests seem to use it to\n\t\t\t//get the event handler storage for jquery. So for jquery apps\n\t\t\t//\"events\" is probably a reserved word anyway.\n\t\t\tresult = listeners[node.getAttribute(eventAttr)];\n\t\t\tvar isEmpty = true;\n\t\t\tif(result){\n\t\t\t\tfor(var param in result){\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isEmpty ? null : result;\n\t\t}\n\n\t\tvar data = getData(node);\n\t\tif(typeof value != \"undefined\"){\n\t\t\tdata[name] = value;\n\t\t}else{\n\t\t\tresult = data[name];\n\t\t}\n\t\treturn value ? this : result;\n\t}\n\n\t$.removeData = function(/*DOMNode*/node, /*String*/name){\n\t\tvar data = getData(node);\n\t\tdelete data[name];\n\t\tif(node.nodeType == 1){\n\t\t\tvar isEmpty = true;\n\t\t\tfor(var param in data){\n\t\t\t\tisEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(isEmpty){\n\t\t\t\tnode.removeAttribute(dataAttr);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tf.data = function(/*String*/name, /*String*/value){\n\t\tvar result = null;\n\t\tthis.forEach(function(node){\n\t\t\tresult = $.data(node, name, value);\n\t\t});\n\n\t\treturn value ? this : result;\n\t}\n\n\tf.removeData = function(/*String*/name){\n\t\tthis.forEach(function(node){\n\t\t\t$.removeData(node, name);\n\t\t});\n\t\treturn this;\n\t}\n\t\n\tfunction jqMix(obj, props){\n\t\t// summary:\n\t\t//\t\tan attempt at a mixin that follows\n\t\t//\t\tjquery's .extend rules. Seems odd. Not sure how\n\t\t//\t\tto resolve this with dojo.mixin and what the use\n\t\t//\t\tcases are for the jquery version.\n\t\t//\t\tCopying some code from dojo._mixin.\n\t\tif(obj == props){\n\t\t\treturn obj;\n\t\t}\n\t\tvar tobj = {};\n\t\tfor(var x in props){\n\t\t\t// the \"tobj\" condition avoid copying properties in \"props\"\n\t\t\t// inherited from Object.prototype.  For example, if obj has a custom\n\t\t\t// toString() method, don't overwrite it with the toString() method\n\t\t\t// that props inherited from Object.prototype\n\t\t\tif((tobj[x] === undefined || tobj[x] != props[x]) && props[x] !== undefined && obj != props[x]){\n\t\t\t\tif(dojo.isObject(obj[x]) && dojo.isObject(props[x])){\n\t\t\t\t\tif(dojo.isArray(props[x])){\n\t\t\t\t\t\tobj[x] = props[x];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tobj[x] = jqMix(obj[x], props[x]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tobj[x] = props[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// IE doesn't recognize custom toStrings in for..in\n\t\tif(dojo.isIE && props){\n\t\t\tvar p = props.toString;\n\t\t\tif(typeof p == \"function\" && p != obj.toString && p != tobj.toString &&\n\t\t\t\tp != \"\\nfunction toString() {\\n    [native code]\\n}\\n\"){\n\t\t\t\t\tobj.toString = props.toString;\n\t\t\t}\n\t\t}\n\t\treturn obj; // Object\n\t}\n\n\tf.extend = function(){\n\t\tvar args = [this];\n\t\targs = args.concat(arguments);\n\t\treturn $.extend.apply($, args);\n\t}\n\n\t$.extend = function(){\n\t\t//Could have multiple args to mix in. Similar to dojo.mixin,\n\t\t//but has some different rules, and the mixins all get applied\n\t\t//to the first arg.\n\t\tvar args = arguments, finalObj;\n\t\tfor(var i = 0; i < args.length; i++){\n\t\t\tvar obj = args[i];\n\t\t\tif(obj && dojo.isObject(obj)){\n\t\t\t\tif(!finalObj){\n\t\t\t\t\tfinalObj = obj;\n\t\t\t\t}else{\n\t\t\t\t\tjqMix(finalObj, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn finalObj;\n\t}\n\n\t$.noConflict = function(/*Boolean*/extreme){\n\t\tvar me = $;\n\t\tdojo.global.$ = _old$;\n\t\tif(extreme){\n\t\t\tdojo.global.jQuery = _oldJQuery;\n\t\t}\n\t\treturn me;\n\t}\n\t//END jquery Core API methods\n\t\n\t//START jquery Attribute API methods\n\t//http://docs.jquery.com/Attributes\n\tf.attr = function(name, value){\n\t\t//The isObject tests below are to weed out where something\n\t\t//like a form node has an input called \"action\" but we really\n\t\t//want to get the attribute \"action\". But in general, favor\n\t\t//a property value over a DOM attribute value.\n\t\tif(arguments.length == 1 && dojo.isString(arguments[0])){\n\t\t\t//The get case, return first match.\n\t\t\tvar first = this[0];\n\t\t\t\n\t\t\t//Weed out empty nodes\n\t\t\tif(!first){\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar arg = arguments[0];\n\t\t\t//favor properties over attributes.\n\t\t\tvar attr = dojo.attr(first, arg);\n\t\t\tvar prop = first[arg];\n\t\t\tif((arg in first) && !dojo.isObject(prop) && name != \"href\"){\n\t\t\t\treturn prop;\n\t\t\t}else{\n\t\t\t\treturn attr || prop;\n\t\t\t}\n\t\t}else if(dojo.isObject(name)){\n\t\t\t//A setter, using an object.\n\t\t\tfor(var param in name){\n\t\t\t\tthis.attr(param, name[param]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}else{\n\t\t\t//The setter case. Figure out if value is a function.\n\t\t\tvar isFunc = dojo.isFunction(value);\n\t\t\tthis.forEach(function(node, index){\n\t\t\t\tvar prop = node[name];\n\t\t\t\tif((name in node) && !dojo.isObject(prop) && name != \"href\"){\n\t\t\t\t\tnode[name] = (isFunc ? value.call(node, index) : value);\n\t\t\t\t}else if(node.nodeType == 1){\n\t\t\t\t\tdojo.attr(node, name, (isFunc ? value.call(node, index) : value));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tf.removeAttr = function(name){\n\t\tthis.forEach(function(node, index){\n\t\t\tvar prop = node[name];\n\t\t\tif((name in node) && !dojo.isObject(prop) && name != \"href\"){\n\t\t\t\tdelete node[name];\n\t\t\t}else if(node.nodeType == 1){\n\t\t\t\tif(name == \"class\"){\n\t\t\t\t\t//TODO: push this fix into dojo.removeAttr\n\t\t\t\t\tnode.removeAttribute(name);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.removeAttr(node, name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t//addClass, removeClass exist in dojo.NodeList. toggleClass in jQuery case\n\t//just means add/remove the classname if it missing/exists. So need custom override.\n\tf.toggleClass = function(/*String*/name, /*Expression?*/condition){\n\t\tvar hasCondition = arguments.length > 1;\n\t\tthis.forEach(function(node){\n\t\t\tdojo.toggleClass(node, name,  hasCondition ? condition : !dojo.hasClass(node, name));\n\t\t});\n\t\treturn this;\n\t}\n\n\t//Action depends on arguments: if an array of functions do one thing,\n\t//If no args, do a display toggle,\n\t//If an expression, something that evaluates to true or false,\n\t//then toggle display accordingly.\n\t//If first arg is a String/Number, then do animation. Second arg\n\t//is an optional callback.\n\tf.toggle = function(){\n\t\t//If more than two args and we have a function as first arg, then\n\t\t//probably the onclick toggle variant: takes variable args that are\n\t\t//functions and cycles through them on click actions.\n\t\tvar args = arguments;\n\t\tif(arguments.length > 1 && dojo.isFunction(arguments[0])){\n\t\t\tvar index = 0;\n\t\t\tvar func = function(){\n\t\t\t\tvar result = args[index].apply(this, arguments);\n\t\t\t\tindex += 1;\n\t\t\t\tif(index > args.length - 1){\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn this.bind(\"click\", func);\n\t\t}else{\n\t\t\t//The display/hide/show case.\n\t\t\tvar condition = arguments.length == 1 ? arguments[0] : undefined;\n\t\t\tthis.forEach(function(node){\n\t\t\t\tvar result = typeof condition == \"undefined\" ? dojo.style(node, \"display\") == \"none\" : condition;\n\t\t\t\tvar action = (result ? \"show\" : \"hide\");\n\t\t\t\tvar nl = $(node);\n\t\t\t\tnl[action].apply(nl, args);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t//hasClass just returns true if any of the nodes has the class.\n\tf.hasClass = function(/*String*/name){\n\t\treturn this.some(function(node){\n\t\t\treturn dojo.hasClass(node, name);\n\t\t});\n\t}\n\n\t//use the html method from dojo.NodeList-manipulate.\n\tf.html = f.innerHTML;\n\n\t//END jquery Attribute API methods\n\n\t\n\t//START jquery Traversing API methods\n\t//http://docs.jquery.com/Traversing\n\tdojo.forEach([\"filter\", \"slice\"], function(item){\n\t\tf[item] = function(){\n\t\t\t//Convert the \"this\" value for functions passed in:\n\t\t\tvar nl;\n\t\t\tif(dojo.isFunction(arguments[0])){\n\t\t\t\tvar origFunc = arguments[0];\n\t\t\t\targuments[0] = function(item, index){\n\t\t\t\t\treturn origFunc.call(item, item, index);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(item == \"filter\" && dojo.isString(arguments[0])){\n\t\t\t\tvar nl = this._filterQueryResult(this, arguments[0]);\n\t\t\t}else{\n\t\t\t\tvar oldCtor = dojo._NodeListCtor;\n\t\t\t\tdojo._NodeListCtor = f;\n\t\t\t\t//Need to wrap in a $() call since internally some\n\t\t\t\t//dojo.NodeList functions reference dojo.NodeList directly.\n\t\t\t\t//Need to get a configurable constructor for dojo.NodeList.\n\t\t\t\tnl = $(nlProto[item].apply(this, arguments));\n\t\t\t\tdojo._NodeListCtor = oldCtor;\n\t\t\t}\n\n\t\t\treturn nl._stash(this);\n\t\t}\n\t});\n\n\tf.map = function(/*Function*/callback){\n\t\t//Hmm, this is not like array map/dojo.map where you get one item back for\n\t\t//each input.\n\t\treturn this._buildArrayFromCallback(callback);\n\t}\n\t$.map = function(/*Array*/ary, /*Function*/callback){\n\t\t//Hmm, this is not like array map/dojo.map where you get one item back for\n\t\t//each input.\n\t\treturn f._buildArrayFromCallback.call(ary, callback);\n\t}\n\n\t$.inArray = function(value, /*Array*/ary){\n\t\treturn dojo.indexOf(ary, value);\n\t}\n\n\tf.is = function(query){\n\t\treturn (query ? !!this.filter(query).length : false);\n\t}\n\n\t//TODO: probably a better way to do this.\n\tf.not = function(){\n\t\tvar notList = $.apply($, arguments);\n\t\t//TODO: another place where if dojo.NodeList can configure a constructor,\n\t\t//then we could avoid the $() wrapper below.\n\t\tvar nl = $(nlProto.filter.call(this, function(node){\n\t\t\treturn notList.indexOf(node) == -1;\n\t\t}));\n\t\treturn nl._stash(this);\n\t}\n\n\tf.add = function(){\n\t\treturn this.concat.apply(this, arguments);\n\t}\n\n\tfunction iframeDoc(/*DOMNode*/iframeNode){\n\t\t// summary:\n\t\t//\t\tReturns the document object associated with the iframe DOM Node argument.\n\n\t\t//Taken from dojo.io.iframe.doc(). Needed for contents() function below.\n\n\t\tvar doc = iframeNode.contentDocument || // W3\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t(iframeNode.name) && (iframeNode.document) &&\n\t\t\t\t\t(document.getElementsByTagName(\"iframe\")[iframeNode.name].contentWindow) &&\n\t\t\t\t\t(document.getElementsByTagName(\"iframe\")[iframeNode.name].contentWindow.document)\n\t\t\t\t)\n\t\t\t) ||  // IE\n\t\t\t(\n\t\t\t\t(iframeNode.name)&&(document.frames[iframeNode.name])&&\n\t\t\t\t(document.frames[iframeNode.name].document)\n\t\t\t) || null;\n\t\treturn doc;\n\t}\n\n\tf.contents = function(){\n\t\tvar ary = [];\n\t\tthis.forEach(function(node){\n\t\t\tif(node.nodeName.toUpperCase() == \"IFRAME\"){\n\t\t\t\tvar doc = iframeDoc(node);\n\t\t\t\tif(doc){\n\t\t\t\t\tary.push(doc);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//TODO: code similar to children() function. Refactor?\n\t\t\t\tvar children = node.childNodes;\n\t\t\t\t//Using for loop for better speed.\n\t\t\t\tfor(var i = 0; i < children.length; i++){\n\t\t\t\t\tary.push(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._wrap(ary)._stash(this);\n\t}\n\n\tf.find = function(/*String*/query){\n\t\tvar ary = [];\n\t\tthis.forEach(function(node){\n\t\t\tif(node.nodeType == 1){\n\t\t\t\tary = ary.concat(dojo._toArray($(query, node)));\n\t\t\t}\n\t\t});\n\t\treturn this._getUniqueAsNodeList(ary)._stash(this);\n\t}\n\n\tf.andSelf = function(){\n\t\treturn this.add(this._parent);\n\t}\n\n\t//END jquery Traversing API methods\n\n\t//START jquery Manipulation API methods\n\t//http://docs.jquery.com/Manipulation\n\n\tf.remove = function(/*String?*/query){\n\t\t//Override NodeList-manipulate's remove so we can remove data.\n\t\tvar nl = (query ? this._filterQueryResult(this, query) : this);\n\t\t\n\t\t//Remove data\n\t\tnl.removeData();\n\t\t\n\t\t//Remove event listeners.\n\t\t//TODO! do this, once event stuff is built out.\n\t\t\n\t\t//Remove the items from the DOM, but keep them in this\n\t\t//node list.\n\t\tnl.forEach(function(node){\n\t\t\tnode.parentNode.removeChild(node);\n\t\t});\n\t\t\n\t\treturn this;\n\t}\n\n\t//START jquery CSS API methods\n\t//http://docs.jquery.com/CSS\n\t$.css = function(/*DOMNode*/node, /*String|Object*/name, /*String|Number?*/value){\n\t\tname = cssNameToJs(name);\n\t\t\n\t\t//Hmm, dojo.style does an arguments. length check.\n\t\tvar result = (value ? dojo.style(node, name, value) : dojo.style(node, name));\n\t\treturn result;\n\t}\n\n\tf.css = function(/*String|Object*/name, /*String|Number?*/value){\n\t\tif(dojo.isString(name)){\n\t\t\t//Convert name to JS name if needed.\n\t\t\tname = cssNameToJs(name);\n\t\t\tif(arguments.length == 2){\n\t\t\t\t//set the value. Cannot directly delegate to\n\t\t\t\t//this.style, since non-element nodes may be in the mix?\n\t\t\t\t//this.contents() in particular will return some funky stuff.\n\t\t\t\t\n\t\t\t\t//Need to be sure to add \"px\" if appropriate.\n\t\t\t\tif(!dojo.isString(value) && name != \"zIndex\"){\n\t\t\t\t\tvalue = value + \"px\";\n\t\t\t\t}\n\n\t\t\t\tthis.forEach(function(node){\n\t\t\t\t\tif(node.nodeType == 1){\n\t\t\t\t\t\tdojo.style(node, name, value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t}else{\n\t\t\t\t//return the value\n\t\t\t\tvalue = dojo.style(this[0], name);\n\t\t\t\t//Need to be sure to add \"px\" if appropriate.\n\t\t\t\tif(!dojo.isString(value) && name != \"zIndex\"){\n\t\t\t\t\tvalue = value + \"px\";\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(var param in name){\n\t\t\t\tthis.css(param, name[param]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}\n\t\n\tfunction doBox(/*NodeList*/nl, /*String*/boxType, /*String*/prop, /*String||Number*/value){;\n\t\tif(value){\n\t\t\t//Set height for all elements.\n\t\t\tvar mod = {};\n\t\t\tmod[prop] = value;\n\t\t\tnl.forEach(function(node){\n\t\t\t\tdojo[boxType](node, mod);\n\t\t\t});\n\t\t\treturn nl;\n\t\t}else{\n\t\t\t//Just get first node's height.\n\t\t\t//Hmm. width is negative when element is display none in FF3?\n\t\t\treturn Math.abs(Math.round(dojo[boxType](nl[0])[prop]));\n\t\t}\n\t}\n\n\tf.height = function(value){\n\t\treturn doBox(this, \"contentBox\", \"h\", value);\n\t}\n\n\tf.width = function(value){\n\t\treturn doBox(this, \"contentBox\", \"w\", value);\n\t}\n\n\tfunction getDimensions(/*DOMNode*/node, /*String*/type, /*Boolean*/usePadding, /*Boolean*/useBorder, /*Boolean*/useMargin){\n\t\t// summary:\n\t\t//\t\tsums up the different parts of the width/height based on arguments.\n\n\t\t//If hidden, temporarily show it, do measurements then close.\n\t\tvar rehide = false;\n\t\tif((rehide = node.style.display == \"none\")){\n\t\t\tnode.style.display = \"block\";\n\t\t}\n\n\t\tvar cs = dojo.getComputedStyle(node);\n\t\tvar content = Math.abs(Math.round(dojo._getContentBox(node, cs)[type]));\n\t\tvar pad = usePadding ? Math.abs(Math.round(dojo._getPadExtents(node, cs)[type])) : 0;\n\t\tvar border = useBorder ? Math.abs(Math.round(dojo._getBorderExtents(node, cs)[type])) : 0;\n\t\tvar margin = useMargin ? Math.abs(Math.round(dojo._getMarginExtents(node, cs)[type])) : 0;\n\t\t\n\t\tif(rehide){\n\t\t\tnode.style.display = \"none\";\n\t\t}\n\n\t\treturn pad + content + border + margin;\n\t}\n\n\tf.innerHeight = function(){\n\t\treturn getDimensions(this[0], \"h\", true);\n\t}\n\n\tf.innerWidth = function(){\n\t\treturn getDimensions(this[0], \"w\", true);\n\t}\n\n\tf.outerHeight = function(useMargin){\n\t\treturn getDimensions(this[0], \"h\", true, true, useMargin);\n\t}\n\n\tf.outerWidth = function(useMargin){\n\t\treturn getDimensions(this[0], \"w\", true, true, useMargin);\n\t}\n\n\t//END jquery CSS API methods\n\n\n\t//START jquery Events API methods\n\t//http://docs.jquery.com/Events\n\t\n\t//ready() already defined above.\n\n\t//Event plumbing.\n\tvar listeners = [];\n\tvar listenId = 1;\n\tvar eventAttr = dojo._scopeName + \"eventid\";\n\tvar currentEvtData;\n\n\tfunction getNonNamespacedName(/*String*/evtName){\n\t\t// summary:\n\t\t//\t\tgets name of the event before the first \".\".\n\n\t\t//The $$ stuff is special ids used to create unique names\n\t\t//for bound functions that did not have a unique namespace name.\n\t\tevtName = evtName.split(\"$$\")[0];\n\t\tvar dotIndex = evtName.indexOf(\".\");\n\t\tif(dotIndex != -1){\n\t\t\tevtName = evtName.substring(0, dotIndex);\n\t\t}\n\t\treturn evtName;\n\t}\n\n\tfunction domConnect(/*DOMNode*/node, /*String*/evtName){\n\t\t// summary:\n\t\t//\t\thandles creating the connection with a real DOM event.\n\n\t\t//This work should only be done one time per evName type.\n\t\t//If the event if an ajax event, use dojo.subscribe instead.\n\t\tif(evtName.indexOf(\"ajax\") == 0){\n\t\t\treturn dojo.subscribe(topics[evtName], function(dfd, res){\n\t\t\t\tvar fakeEvt = new $.Event(evtName);\n\t\t\t\tif(\"ajaxComplete|ajaxSend|ajaxSuccess\".indexOf(evtName) != -1){\n\t\t\t\t\ttriggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args]);\n\t\t\t\t}else if(evtName == \"ajaxError\"){\n\t\t\t\t\ttriggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args, res]);\n\t\t\t\t}else{\n\t\t\t\t\t//ajaxStart|ajaxStop\n\t\t\t\t\ttriggerHandlers(node, [fakeEvt]);\n\t\t\t\t}\n\t\t\t});\n\t\t}else{\n\t\t\treturn dojo.connect(node, \"on\" + evtName, function(e){\n\t\t\t\ttriggerHandlers(node, arguments);\n\t\t\t}); //Object\n\t\t}\n\t}\n\n\t//Event object for compatibility for some tests.\n\t$.Event = function(/*String*/type){\n\t\t//Allow for calling function without \"new\"\n\t\tif(this == $){\n\t\t\treturn new $.Event(type);\n\t\t}\n\t\tif(typeof type == \"string\"){\n\t\t\tthis.type = type.replace(/!/, \"\");\n\t\t}else{\n\t\t\tdojo.mixin(this, type);\n\t\t}\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\tthis._isFake = true;\n\t\tthis._isStrict = (this.type.indexOf(\"!\") != -1);\n\t\t\n\t}\n\t\n\tvar ep = $.Event.prototype = {\n\t\tpreventDefault: function(){\n\t\t\tthis.isDefaultPrevented = this._true;\n\t\t},\n\t\tstopPropagation: function(){\n\t\t\tthis.isPropagationStopped = this._true;\n\t\t},\n\t\tstopImmediatePropagation: function(){\n\t\t\tthis.isPropagationStopped = this._true;\n\t\t\tthis.isImmediatePropagationStopped = this._true;\n\t\t},\n\t\t_true: function(){ return true; },\n\t\t_false: function(){ return false; }\n\t}\n\tdojo.mixin(ep, {\n\t\tisPropagationStopped: ep._false,\n\t\tisImmediatePropagationStopped: ep._false,\n\t\tisDefaultPrevented: ep._false\n\t});\n\n\tfunction makeTriggerData(data, type){\n\t\t// summary:\n\t\t//\t\tmakes sure that the data array is copied\n\t\t//\t\tand has an event as the first arg. If this function generates\n\t\t//\t\ta fake event (known by the data[0]._isFake property being true)\n\t\t//\t\tthen the data[0].target needs to be set by the consumer of this function.\n\t\t\n\t\tdata = data || [];\n\t\tdata = [].concat(data);\n\n\t\t//If first data item is not an event, make one up.\n\t\t//Need to set up target: prop in the consumers of this\n\t\t//function.\n\t\tvar evt = data[0];\n\t\tif(!evt || !evt.preventDefault){\n\t\t\tevt = type && type.preventDefault ? type : new $.Event(type);\n\t\t\tdata.unshift(evt);\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tvar triggerHandlersCalled = false;\n\n\tfunction triggerHandlers(/*DOMNode*/node, /*Array*/data, /*Function?*/extraFunc){\n\t\t// summary:\n\t\t//\t\thandles the actual callbacks to the handlers.\n\t\t\n\t\t//Indicate triggerHandlers was called.\n\t\ttriggerHandlersCalled = true;\n\t\t\n\t\t//Uses currentEvtData if this is a simulated event.\n\t\tdata = data || currentEvtData;\n\t\textraFunc = extraFunc;\n\n\t\t//Normalize on a real element if dealing with a document.\n\t\tif(node.nodeType == 9){\n\t\t\tnode = node.documentElement;\n\t\t}\n\n\t\tvar nodeId = node.getAttribute(eventAttr);\n\t\tif(!nodeId){\n\t\t\treturn;\n\t\t}\n\n\t\tvar evt = data[0];\n\t\tvar evtFullName = evt.type;\n\t\tvar evtName = getNonNamespacedName(evtFullName);\n\n\t\tvar cbs = listeners[nodeId][evtName];\n\n\t\tvar result;\n\t\t//Apply the extra function. What is that about? Not mentioned in the\n\t\t//public APIs?\n\t\tif(extraFunc){\n\t\t\tresult = extraFunc.apply(node, data);\n\t\t}\n\n\t\tif (result !== false){\n\t\t\tfor(var param in cbs){\n\t\t\t\tif(param != \"_connectId\" && (!evt._isStrict && (param.indexOf(evtFullName) == 0) || (evt._isStrict && param == evtFullName))){\n\t\t\t\t\t//Store the callback ID in case unbind is called with this event\n\t\t\t\t\t//so we can only unbind that one callback.\n\t\t\t\t\tevt[dojo._scopeName + \"callbackId\"] = param;\n\n\t\t\t\t\tvar cb = cbs[param];\n\t\t\t\t\tif(typeof cb.data != \"undefined\"){\n\t\t\t\t\t\tevt.data = cb.data;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tevt.data = null;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Do the actual callback.\n\t\t\t\t\tif ((result = cb.fn.apply(evt.target, data)) === false && !evt._isFake){\n\t\t\t\t\t\tdojo.stopEvent(evt);\n\t\t\t\t\t}\n\t\t\t\t\tevt.result = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tf.triggerHandler = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){\n\t\t//Only triggers handlers on the first node. Huh.\n\t\tvar node = this[0];\n\t\tif(node && node.nodeType != 3 && node.nodeType != 8){\n\t\t\tdata = makeTriggerData(data, type);\n\t\t\treturn triggerHandlers(node, data, extraFunc);\n\t\t}else{\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tf.trigger = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){\n\t\t//Copy data since we may need to modify by adding a\n\t\tdata = makeTriggerData(data, type);\n\t\tvar evt = data[0];\n\t\tvar type = getNonNamespacedName(evt.type);\n\t\t\n\t\t//Store the current event data in case handlers need\n\t\t//to reference it because of a simulated event.\n\t\tcurrentEvtData = data;\n\t\tcurrentExtraFunc = extraFunc;\n\n\t\tvar result = null;\n\t\tvar needTarget = !evt.target;\n\t\tthis.forEach(function(node){\n\t\t\t//Only handle non text/comment nodes.\n\t\t\tif(node.nodeType != 3 && node.nodeType != 8){\n\n\t\t\t\t//Normalize on a real element if dealing with a document.\n\t\t\t\tif(node.nodeType == 9){\n\t\t\t\t\tnode = node.documentElement;\n\t\t\t\t}\n\n\t\t\t\t//Set the node target appropriately for fake events.\n\t\t\t\tif(evt._isFake){\n\t\t\t\t\tevt.currentTarget = node;\n\t\t\t\t\tif(needTarget){\n\t\t\t\t\t\tevt.target = node;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Bizarre extra function thing. Not really demonstrated in public\n\t\t\t\t//API docs.\n\t\t\t\tif(extraFunc){\n\t\t\t\t\tvar funcData = data.slice(1);\n\t\t\t\t\tresult = extraFunc.apply(node, (result = null ? funcData : funcData.concat(result)));\n\t\t\t\t}\n\n\t\t\t\tif(result !== false){\n\t\t\t\t\t//Trigger DOM event. onclick is handled differently than\n\t\t\t\t\t//others.\n\t\t\t\t\t/*\n\t\t\t\t\tif(type == 'click' && node.onclick && node.nodeName.toUpperCase() == \"A\"){\n\t\t\t\t\t\tresult = node.onclick.apply(node, data);\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t//Set the \"global\" flag that indicates if triggerHandlers was called.\n\t\t\t\t\t//If the direct node.event/onevent does not trigger the handlers, do so\n\t\t\t\t\t//manually at the end.\n\t\t\t\t\ttriggerHandlersCalled = false;\n\t\t\t\t\t\n\t\t\t\t\t//Trigger functions registered directly on the DOM node.\n\t\t\t\t\tif(node[type]){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tresult = node[type]();\n\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t//Apparently IE throws on some hidden elements. Just eat it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(node[\"on\" + type]){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tresult = node[\"on\" + type]();\n\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t//Apparently IE throws on some hidden elements. Just eat it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!triggerHandlersCalled){\n\t\t\t\t\t\t//Finally triggerHandlers directly if the above code did not trigger it yet.\n\t\t\t\t\t\tresult = triggerHandlers(node, data);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bubble the event up.\n\t\t\t\t\t//TODO: optimize this path so we don't have to do forEach and NodeList work.\n\t\t\t\t\tvar parentNode = node.parentNode;\n\t\t\t\t\tif(result !== false && !evt.isImmediatePropagationStopped() && !evt.isPropagationStopped() && parentNode && parentNode.nodeType == 1){\n\t\t\t\t\t\t$(parentNode).trigger(type, data, extraFunc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t//Clear current event data.\n\t\tcurrentEvtData = null;\n\t\tcurrentExtraFunc = null;\n\n\t\treturn this;\n\t}\n\n\tvar bindIdCounter = 0;\n\n\tf.bind = function(/*String*/type, /*Array||Function?*/data, /*Function*/fn){\n\t\t//Type can be space separated values.\n\t\ttype = type.split(\" \");\n\t\t\n\t\t//May not have data argument.\n\t\tif(!fn){\n\t\t\tfn = data;\n\t\t\tdata = null;\n\t\t}\n\n\t\tthis.forEach(function(node){\n\t\t\t//Only handle non text/comment nodes.\n\t\t\tif(node.nodeType != 3 && node.nodeType != 8){\n\t\t\t\n\t\t\t\t//If document, bind to documentElement\n\t\t\t\tif(node.nodeType == 9){\n\t\t\t\t\tnode = node.documentElement;\n\t\t\t\t}\n\n\t\t\t\t//If no nodeId, then create one and attach it to the DOM node.\n\t\t\t\tvar nodeId = node.getAttribute(eventAttr);\n\t\t\t\tif(!nodeId){\n\t\t\t\t\tnodeId = listenId++;\n\t\t\t\t\tnode.setAttribute(eventAttr, nodeId);\n\t\t\t\t\tlisteners[nodeId] = {};\n\t\t\t\t}\n\t\n\t\t\t\t//Process each event type.\n\t\t\t\tfor(var i = 0; i < type.length; i++){\n\t\t\t\t\t//Get event name, if have a dot on it, it is namespaced,\n\t\t\t\t\t//be sure to get the core event name.\n\t\t\t\t\tvar evtFullName = type[i];\n\t\t\t\t\tvar evtName = getNonNamespacedName(evtFullName);\n\t\t\t\t\tif(evtName == evtFullName){\n\t\t\t\t\t\t//Generate a unique ID for this function binding\n\t\t\t\t\t\tevtFullName = evtName + \"$$\" + (bindIdCounter++);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Get the event listeners for the event name, the complete name.\n\t\t\t\t\tvar lls = listeners[nodeId];\n\t\t\t\t\tif(!lls[evtName]){\n\t\t\t\t\t\tlls[evtName] = {\n\t\t\t\t\t\t\t_connectId: domConnect(node, evtName)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Add the callback to the list of listeners.\n\t\t\t\t\tlls[evtName][evtFullName] = {\n\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\tdata: data\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn this;\n\t}\n\n\tfunction copyEventHandlers(/*DOMNode*/ src, /*DOMNode*/ target){\n\t\t// summary:\n\t\t//\t\tcopies the event handlers from onne src *element* node to\n\t\t//\t\tanother target *element* node. Assumes that target had\n\t\t//\t\tno previous events on it, and is a clone of the src node.\n\n\t\t//Get src listeners.\n\t\tvar srcNodeId = target.getAttribute(eventAttr);\n\t\tvar sls = listeners[srcNodeId];\n\t\tif(!sls){\n\t\t\treturn;\n\t\t}\n\n\t\t//Generate listeners area for target.\n\t\tvar nodeId = nodeId = listenId++;\n\t\ttarget.setAttribute(eventAttr, nodeId);\n\t\tvar tls = listeners[nodeId] = {};\n\n\t\t//Loope through events in source. Protect against bad\n\t\t//code modifying Object.prototype.\n\t\tvar empty = {};\n\t\tfor (var evtName in sls){\n\t\t\tvar tEvtData = tls[evtName] = {\n\t\t\t\t_connectId: domConnect(target, evtName)\n\t\t\t};\n\t\t\tvar sEvtData = sls[evtName];\n\n\t\t\tfor (var evtFullName in sEvtData){\n\t\t\t\ttEvtData[evtFullName] = {\n\t\t\t\t\tfn: sEvtData[evtFullName].fn,\n\t\t\t\t\tdata: sEvtData[evtFullName].data\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction listenerUnbind(lls, evtName, evtFullName, callbackId, fn){\n\t\t//Handles the real remove of an event and dojo.disconnects DOM handler if necessary.\n\t\t//This has to be broken out of the main unbind function because we have to support\n\t\t//things like unbind(\".test\") that go across major event names. Yuck.\n\t\tvar handles = lls[evtName];\n\t\tif(handles){\n\t\t\tvar hasDot = evtFullName.indexOf(\".\") != -1;\n\t\t\tvar forceDelete = false;\n\n\t\t\tif(callbackId){\n\t\t\t\t//Only need to unbind that one callback\n\t\t\t\tdelete handles[callbackId];\n\t\t\t}else if(!hasDot && !fn){\n\t\t\t\tforceDelete = true;\n\t\t\t}else if(hasDot){\n\t\t\t\t//A namespaced event.\n\t\t\t\t//Problem is the namespaced event could be something like\n\t\t\t\t//\".test\" which means remove all that end in .test. Yuck.\n\t\t\t\tif(evtFullName.charAt(0) == \".\"){\n\t\t\t\t\tfor(var param in handles){\n\t\t\t\t\t\tif(param.indexOf(evtFullName) == param.length - evtFullName.length){\n\t\t\t\t\t\t\tdelete handles[param];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdelete handles[evtFullName];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//Not a namespaced event. Cycle through the $$ names\n\t\t\t\t//to find a function match.\n\t\t\t\tfor(var param in handles){\n\t\t\t\t\tif(param.indexOf(\"$$\") != -1 && handles[param].fn == fn){\n\t\t\t\t\t\tdelete handles[param];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Remove handles/disconnect dom if no other params.\n\t\t\tvar allDone = true;\n\t\t\tfor(var param in handles){\n\t\t\t\tif(param != \"_connectId\"){\n\t\t\t\t\tallDone = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(forceDelete || allDone){\n\t\t\t\tif(evtName.indexOf(\"ajax\") != -1){\n\t\t\t\t\tdojo.unsubscribe(handles._connectId);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.disconnect(handles._connectId);\n\t\t\t\t}\n\t\t\t\tdelete lls[evtName];\n\t\t\t}\n\t\t}\n\t}\n\n\tf.unbind = function(/*String*/type, /*Function*/fn){\n\t\t\n\t\t//See if event has a callbackId, if so, then we only unbind\n\t\t//that one callback.\n\t\tvar callbackId = type ? type[dojo._scopeName + \"callbackId\"] : null;\n\n\t\t//Type can be space separated values.\n\t\ttype = type && type.type ? type.type : type;\n\t\ttype = type ? type.split(\" \") : type;\n\n\t\tthis.forEach(function(node){\n\t\t\t//Only handle non text/comment nodes.\n\t\t\tif(node.nodeType != 3 && node.nodeType != 8){\n\t\t\t\t//If document, bind to documentElement\n\t\t\t\tif(node.nodeType == 9){\n\t\t\t\t\tnode = node.documentElement;\n\t\t\t\t}\n\n\t\t\t\t//If no nodeId, then create one and attach it to the DOM node.\n\t\t\t\tvar nodeId = node.getAttribute(eventAttr);\n\t\t\t\t\n\t\t\t\tif(nodeId){\n\t\t\t\t\t//Get the event listeners for the event name, the complete name.\n\t\t\t\t\tvar lls = listeners[nodeId];\n\t\t\t\t\tif(lls){\n\t\t\t\t\t\t//If no type, then it means do all bound types. Make a list of them.\n\t\t\t\t\t\tvar etypes = type;\n\t\t\t\t\t\tif(!etypes){\n\t\t\t\t\t\t\tetypes = [];\n\t\t\t\t\t\t\tfor(var param in lls){\n\t\t\t\t\t\t\t\tetypes.push(param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Process each event type.\n\t\t\t\t\t\tfor(var i = 0; i < etypes.length; i++){\n\t\t\t\t\t\t\t//Get event name, if have a dot on it, it is namespaced,\n\t\t\t\t\t\t\t//be sure to get the core event name.\n\t\t\t\t\t\t\tvar evtFullName = etypes[i];\n\t\t\t\t\t\t\tvar evtName = getNonNamespacedName(evtFullName);\n\t\t\t\n\t\t\t\t\t\t\t//Problem is the namespaced event could be something like\n\t\t\t\t\t\t\t//\".test\" which means remove all that end in .test. Yuck.\n\t\t\t\t\t\t\tif(evtFullName.charAt(0) == \".\"){\n\t\t\t\t\t\t\t\tfor(var param in lls) {\n\t\t\t\t\t\t\t\t\tlistenerUnbind(lls, param, evtFullName, callbackId, fn);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tlistenerUnbind(lls, evtName, evtFullName, callbackId, fn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tf.one = function(/*String*/evtName, /*Function*/func){\n\t\tvar oneFunc = function(){\n\t\t\t$(this).unbind(evtName, arguments.callee);\n\t\t\treturn func.apply(this, arguments);\n\t\t}\n\n\t\treturn this.bind(evtName, oneFunc);\n\t};\n\n\tf._cloneNode = function(/*DOMNode*/ src){\n\t\t// summary:\n\t\t//\t\tprivate utiltity to clone a node. Copies event handlers too.\n\t\tvar target = src.cloneNode(true);\n\n\t\tif(src.nodeType == 1){\n\t\t\t//Look for event handlers in target.\n\t\t\tvar evNodes = dojo.query(\"[\" + eventAttr + \"]\", target);\n\t\t\tfor(var i = 0, newNode; newNode = evNodes[i]; i++){\n\t\t\t\tvar oldNode = dojo.query('[' + eventAttr + '=\"' + newNode.getAttribute(eventAttr) + '\"]', src)[0];\n\t\t\t\tif(oldNode){\n\t\t\t\t\tcopyEventHandlers(oldNode, newNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t};\n\n\t//Temporary testing shim to get past jquery test setup errors.\n\tdojo.getObject(\"$.event.global\", true);\n\n\t//Set up event handlers\n\tdojo.forEach([\n\t\t\"blur\", \"focus\", \"dblclick\", \"click\", \"error\", \"keydown\", \"keypress\", \"keyup\", \"load\", \"mousedown\",\n\t\t\"mouseenter\", \"mouseleave\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"submit\",\n\t\t\"ajaxStart\", \"ajaxSend\", \"ajaxSuccess\", \"ajaxError\", \"ajaxComplete\", \"ajaxStop\"\n\t\t], function(evt){\n\t\t\tf[evt] = function(callback){\n\t\t\t\tif(callback){\n\t\t\t\t\tthis.bind(evt, callback);\n\t\t\t\t}else{\n\t\t\t\t\tthis.trigger(evt);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\n\t//END jquery Events API methods\n\n\n\t//START jquery Effects API methods\n\t//http://docs.jquery.com/Effects\n\tfunction speedInt(speed){\n\t\t//Fix speed setting, translate string values to numbers.\n\t\tif(dojo.isString(speed)){\n\t\t\tif(speed == \"slow\"){\n\t\t\t\tspeed = 700;\n\t\t\t}else if(speed == \"fast\"){\n\t\t\t\tspeed = 300;\n\t\t\t}else{\n\t\t\t\t//Everything else is considered normal speed.\n\t\t\t\tspeed = 500;\n\t\t\t}\n\t\t}\n\t\treturn speed;\n\t}\n\t\n\tf.hide = function(/*String||Number*/speed, /*Function?*/callback){\n\t\t//Fix speed setting, translate string values to numbers.\n\t\tspeed = speedInt(speed);\n\n\t\tthis.forEach(function(node){\n\t\t\tvar style = node.style;\n\t\t\t\n\t\t\t//Skip if already hidden\n\t\t\tvar cs = dojo.getComputedStyle(node);\n\t\t\tif(cs.display == \"none\"){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tstyle.display = \"block\";\n\t\t\t\n\t\t\tif(speed){\n\t\t\t\t//It is alive!\n\t\t\t\tdojo.anim(\n\t\t\t\t\tnode,\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\theight: 0,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t},\n\t\t\t\t\tspeed,\n\t\t\t\t\tnull,\n\t\t\t\t\tfunction(){\n\t\t\t\t\t\tstyle.width = \"\";\n\t\t\t\t\t\tstyle.height = \"\";\n\t\t\t\t\t\tstyle.display = \"none\";\n\t\t\t\t\t\treturn callback && callback.call(node);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}else{\n\t\t\t\t//No need for animation, fast path it.\n\t\t\t\tdojo.style(node, \"display\", \"none\");\n\t\t\t\tif(callback){\n\t\t\t\t\tcallback.call(node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tf.show = function(/*String||Number*/speed, /*Function?*/callback){\n\t\t//Fix speed setting, translate string values to numbers.\n\t\tspeed = speedInt(speed);\n\n\t\tthis.forEach(function(node){\n\t\t\tvar style = node.style;\n\t\t\t//Skip if the node is already showing.\n\t\t\tvar cs = dojo.getComputedStyle(node);\n\t\t\tif(cs.display != \"none\"){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(speed){\n\t\t\t\t//Figure out size of element\n\t\t\t\t//so we know when to stop animation.\n\t\t\t\t//Try the easy path first.\n\t\t\t\tvar width = parseFloat(style.width);\n\t\t\t\tvar height = parseFloat(style.height);\n\t\t\t\tif(!width || !height){\n\t\t\t\t\t//temporarily show the element to get\n\t\t\t\t\t//dimensions\n\t\t\t\t\tstyle.display = \"block\";\n\t\t\t\t\tvar box = dojo.marginBox(node);\n\t\t\t\t\twidth = box.w;\n\t\t\t\t\theight = box.h;\n\t\t\t\t}\n\n\t\t\t\t//Make sure values are set to hidden state.\n\t\t\t\tstyle.width = 0;\n\t\t\t\tstyle.height = 0;\n\t\t\t\tstyle.overflow = \"hidden\";\n\t\t\t\tdojo.attr(node, \"opacity\", 0);\n\t\t\t\tstyle.display = \"block\";\n\n\t\t\t\t//It is alive!\n\t\t\t\tdojo.anim(\n\t\t\t\t\tnode,\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: height,\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t},\n\t\t\t\t\tspeed,\n\t\t\t\t\tnull,\n\t\t\t\t\tcallback ? dojo.hitch(node, callback) : undefined\n\t\t\t\t);\n\t\t\t}else{\n\t\t\t\tdojo.style(node, \"display\", \"block\");\n\t\t\t\tif(callback){\n\t\t\t\t\tcallback.call(node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\n\t//END jquery Effects API methods\n\n\n\t//START jquery Ajax API methods\n\t//http://docs.jquery.com/Ajax\n\t\n\t$.ajaxSettings = {\n\t};\n\n\t$.ajaxSetup = function(/*Object*/args){\n\t\tdojo.mixin($.ajaxSettings, args);\n\t}\n\n\tvar topics = {\n\t\t\"ajaxStart\": \"/dojo/io/start\",\n\t\t\"ajaxSend\": \"/dojo/io/send\",\n\t\t\"ajaxSuccess\": \"/dojo/io/load\",\n\t\t\"ajaxError\": \"/dojo/io/error\",\n\t\t\"ajaxComplete\": \"/dojo/io/done\",\n\t\t\"ajaxStop\": \"/dojo/io/stop\"\n\t};\n\n\tfor(var fnName in topics){\n\t\t//Make sure we are dealing with properties\n\t\t//we care about and not something another toolkit added.\n\t\tif(fnName.indexOf(\"ajax\") == 0){\n\t\t\t;(function(fnName){\n\t\t\t\tf[fnName] = function(callback){\n\t\t\t\t\tthis.forEach(function(node){\n\t\t\t\t\t\tdojo.subscribe(topics[fnName], function(){\n\t\t\t\t\t\t\tvar fakeEvt = new $.Event(fnName);\n\t\t\t\t\t\t\tvar ioArgs = arguments[0] && arguments[0].ioArgs;\n\t\t\t\t\t\t\tvar xhr = ioArgs && ioArgs.xhr;\n\t\t\t\t\t\t\tvar args = ioArgs && ioArgs.args;\n\t\t\t\t\t\t\tvar res = arguments[1];\n\t\t\t\t\t\t\tif(\"ajaxComplete|ajaxSend|ajaxSuccess\".indexOf(fnName) != -1){\n\t\t\t\t\t\t\t\treturn callback.call(node, fakeEvt, xhr, args);\n\t\t\t\t\t\t\t}else if(fnName == \"ajaxError\"){\n\t\t\t\t\t\t\t\treturn callback.call(node, fakeEvt, xhr, args, res);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//ajaxStart|ajaxStop\n\t\t\t\t\t\t\t\treturn callback.call(node, fakeEvt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t})(fnName);\n\t\t}\n\t};\n\n\t//Override dojo._xhrObj(dfd.ioArgs.args) to support beforeSend\n\t//Do not understand the reason for beforeSend, particularly\n\t//returning false stops the request.\n\t//WARNING: even with this code, the error and complete callbacks\n\t//will be fired because the deferred is cancelled. I feel this is\n\t//correct behavior for dojo, and not sure why beforeSend is needed.\n\tvar _oldXhrObj = dojo._xhrObj;\n\tdojo._xhrObj = function(args){\n\t\tvar xhr = _oldXhrObj.apply(dojo, arguments);\n\t\tif(args && args.beforeSend){\n\t\t\tif(args.beforeSend(xhr) === false){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn xhr;\n\t}\n\n\t$.ajax = function(/*Object*/args){\n\t\t//Not sure if the args are considered mutable.\n\t\t//Copy them to be safe.\n\t\tvar temp = dojo.delegate($.ajaxSettings);\n\t\tfor(var param in args){\n\t\t\t//For data objects merge the data do not overwrite.\n\t\t\tif(param == \"data\" && dojo.isObject(args[param]) && dojo.isObject(temp.data)){\n\t\t\t\tfor(var prop in args[param]){\n\t\t\t\t\ttemp.data[prop] = args[param][prop];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttemp[param] = args[param];\n\t\t\t}\n\t\t}\n\t\targs = temp;\n\t\tvar url = args.url;\n\n\t\tif(\"async\" in args){\n\t\t\targs.sync = !args.async;\n\t\t}\n\n\t\t//Turn off topic publications\n\t\tif(args.global === false){\n\t\t\targs.ioPublish = false;\n\t\t}\n\n\t\tif(args.data){\n\t\t\tvar data = args.data;\n\t\t\tif(dojo.isString(data)){\n\t\t\t\t//convert to an object.\n\t\t\t\targs.content = dojo.queryToObject(data);\n\t\t\t}else{\n\t\t\t\t//data property values could be a function, be sure to call them if so.\n\t\t\t\t//Hmm, this seems to be of dubious value.\n\t\t\t\tfor(var param in data){\n\t\t\t\t\tif(dojo.isFunction(data[param])){\n\t\t\t\t\t\tdata[param] = data[param]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.content = data;\n\t\t\t}\n\t\t}\n\n\t\t//dataType\n\t\tvar dataType = args.dataType;\n\t\tif(\"dataType\" in args){\n\t\t\tif(dataType == \"script\"){\n\t\t\t\tdataType = \"javascript\";\n\t\t\t}else if(dataType == \"html\"){\n\t\t\t\tdataType = \"text\";\n\t\t\t}\n\t\t\targs.handleAs = dataType;\n\t\t}else{\n\t\t\t//Make a guess based on the URL.\n\t\t\tdataType = args.handleAs = \"text\";\n\t\t\targs.guessedType = true;\n\t\t}\n\n\t\t//cache:\n\t\tif(\"cache\" in args){\n\t\t\targs.preventCache = !args.cache;\n\t\t}else{\n\t\t\tif(args.dataType == \"script\" || args.dataType == \"jsonp\"){\n\t\t\t\targs.preventCache = true;\n\t\t\t}\n\t\t}\n\n\t\t//Hide error since dojo treats it different.\n\t\tif(args.error){\n\t\t\targs._jqueryError = args.error;\n\t\t\tdelete args.error;\n\t\t}\n\t\t\n\t\t//TODO: dataFilter\n\n\t\t//Set up callbacks.\n\t\targs.handle = function(result, ioArgs){\n\t\t\tvar textStatus = \"success\";\n\t\t\tif(result instanceof Error){\n\t\t\t\ttextStatus = (result.dojoType == \"timeout\" ? \"timeout\" : \"error\");\n\t\t\t\tif(args._jqueryError){\n\t\t\t\t\targs._jqueryError(ioArgs.xhr, textStatus, result);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//If we guessed the type, see if it should be XML.\n\t\t\t\tvar xml = (ioArgs.args.guessedType && ioArgs.xhr && ioArgs.xhr.responseXML);\n\t\t\t\tif(xml){\n\t\t\t\t\tresult = xml;\n\t\t\t\t}\n\n\t\t\t\tif(args.success){\n\t\t\t\t\targs.success(result, textStatus, ioArgs.xhr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(args.complete){\n\t\t\t\targs.complete(result, textStatus, ioArgs.xhr);\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t};\n\t\t\n\t\t//Use a script tag if the request is xdomain or a jsonp thing.\n\t\tvar useScript = (dataType == \"jsonp\");\n\t\tif(dataType == \"javascript\"){\n\t\t\t//Get protocol and domain.\n\t\t\tvar colonIndex = url.indexOf(\":\");\n\t\t\tvar slashIndex = url.indexOf(\"/\");\n\t\t\tif(colonIndex > 0 && colonIndex < slashIndex){\n\t\t\t\t//Possibly xdomain. Peel off protocol and hostname to find out.\n\t\t\t\tvar lastSlash = url.indexOf(\"/\", slashIndex + 2);\n\t\t\t\tif(lastSlash == -1){\n\t\t\t\t\tlastSlash = url.length;\n\t\t\t\t}\n\t\t\t\tif(location.protocol != url.substring(0, colonIndex + 1) ||\n\t\t\t\t\tlocation.hostname != url.substring(slashIndex + 2, lastSlash)){\n\t\t\t\t\tuseScript = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(useScript){\n\t\t\tif(dataType == \"jsonp\"){\n\t\t\t\t//Look for callback param\n\t\t\t\tvar cb = args.jsonp;\n\t\t\t\tif(!cb){\n\t\t\t\t\t//Look in the URL\n\t\t\t\t\tvar params = args.url.split(\"?\")[1];\n\t\t\t\t\tif(params && (params = dojo.queryToObject(params))){\n\t\t\t\t\t\tcb = findJsonpCallback(params);\n\t\t\t\t\t\tif(cb){\n\t\t\t\t\t\t\t//Remove the cb from the url.\n\t\t\t\t\t\t\tvar regex = new RegExp(\"([&\\\\?])?\" + cb + \"=?\");\n\t\t\t\t\t\t\targs.url = args.url.replace(regex + \"=?\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Look in the content.\n\t\t\t\t\tif(!cb){\n\t\t\t\t\t\tcb = findJsonpCallback(args.content);\n\t\t\t\t\t\tif(cb){\n\t\t\t\t\t\t\tdelete args.content[cb];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.jsonp = cb || \"callback\";\n\t\t\t}\n\t\t\tvar dfd = dojo.io.script.get(args);\n\t\t\treturn dfd;\n\t\t}else{\n\t\t\tvar dfd = dojo.xhr(args.type || \"GET\", args);\n\t\t\t//If the XHR object is false, it means beforeSend canceled the request.\n\t\t\treturn dfd.ioArgs.xhr === false ? false : dfd.ioArgs.xhr;\n\t\t}\n\t}\n\n\tfunction findJsonpCallback(obj){\n\t\tfor(var prop in obj){\n\t\t\tif(prop.indexOf(\"callback\") == prop.length - 8){\n\t\t\t\treturn prop;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t$.getpost = function(httpType, url, data, callback, dataType){\n\t\tvar args = {\n\t\t\turl: url,\n\t\t\ttype: httpType\n\t\t};\n\n\t\t//Normalize data, considering it may be the real\n\t\t//callback.\n\t\tif(data){\n\t\t\tif(dojo.isFunction(data) && !callback){\n\t\t\t\targs.complete = data;\n\t\t\t}else{\n\t\t\t\targs.data = data;\n\t\t\t}\n\t\t}\n\n\t\t//Normalize callback, considering it may be\n\t\t//the datatype.\n\t\tif(callback){\n\t\t\tif(dojo.isString(callback) && !dataType){\n\t\t\t\tdataType = callback;\n\t\t\t}else{\n\t\t\t\targs.complete = callback;\n\t\t\t}\n\t\t}\n\n\t\tif(dataType){\n\t\t\targs.dataType = dataType;\n\t\t}\n\n\t\treturn $.ajax(args);\n\t};\n\n\t$.get = dojo.hitch($, \"getpost\", \"GET\");\n\t$.post = dojo.hitch($, \"getpost\", \"POST\");\n\t$.getJSON = function(url, data, callback){\n\t\treturn $.getpost(\"GET\", url, data, callback, \"json\");\n\t}\n\t$.getScript = function(url, callback){\n\t\treturn $.ajax({\n\t\t\turl: url,\n\t\t\tsuccess: callback,\n\t\t\tdataType: \"script\"\n\t\t});\n\t}\n\n\tf.load = function(url, data, callback){\n\t\t\n\t\t//See if this is a window or document. If so, then want to\n\t\t//register onload handler.\n\t\tvar node = this[0];\n\t\tif(!node || !node.nodeType || node.nodeType == 9){\n\t\t\tdojo.addOnLoad(url);\n\t\t\treturn this;\n\t\t}\n\n\t\t//The rest of this function is the ajax HTML load case.\n\t\t//Pull off selector if it is on the url.\n\t\tvar parts = url.split(/\\s+/);\n\t\turl = parts[0];\n\t\tvar query = parts[1];\n\t\t\n\t\tvar finalCb = callback || data;\n\n\t\tvar cb = dojo.hitch(this, function(result, textStatus, xhr){\n\t\t\t//Try to find all the body content.\n\t\t\tvar match = result.match(/\\<\\s*body[^>]+>.*<\\/body\\s*>/i);\n\t\t\tif(match){\n\t\t\t\tresult = match;\n\t\t\t}\n\n\t\t\t//Convert to DOM nodes.\n\t\t\tvar nodes = dojo._toDom(result);\n\n\t\t\t//Apply query, using a temp div to do the filtering.\n\t\t\tif(query){\n\t\t\t\tvar temp = $(dojo.create(\"div\"));\n\t\t\t\ttemp.append(nodes);\n\t\t\t\tnodes = temp.find(query);\n\t\t\t}else{\n\t\t\t\tnodes = $(nodes.nodeType == 11 ? nodes.childNodes : nodes);\n\t\t\t}\n\n\t\t\t//Add the HTML to all nodes in this node list.\n\t\t\tthis.html(nodes);\n\n\t\t\t//Call the user's callback.\n\t\t\t//Use a timeout to allow any embedded scripts that\n\t\t\t//were just inserted to run.\n\t\t\tif(finalCb){\n\t\t\t\tsetTimeout(dojo.hitch(this, function(){\n\t\t\t\t\tthis.forEach(function(node){\n\t\t\t\t\t\tfinalCb.call(node, result, textStatus, xhr);\n\t\t\t\t\t});\n\t\t\t\t}), 10);\n\t\t\t}\n\t\t});\n\n\t\t//Adjust parameters since they are variable.\n\t\tif(!callback){\n\t\t\tdata = cb;\n\t\t}else{\n\t\t\tcallback = cb;\n\t\t}\n\n\t\t//Set HTTP method. If the data is a string, use get, if it is an object,\n\t\t//use post.\n\t\tvar method = \"GET\";\n\t\tif(data && dojo.isObject(data)){\n\t\t\tmethod = \"POST\";\n\t\t}\n\n\t\t$.getpost(method, url, data, callback, \"html\");\n\t\treturn this;\n\t}\n\n\tvar serializeExclude = \"file|submit|image|reset|button|\";\n\tf.serialize = function(){\n\t\tvar ret = \"\";\n\t\tvar strs = this.map(function(node){\n\t\t\tif(node.nodeName.toUpperCase() == \"FORM\"){\n\t\t\t\treturn dojo.formToQuery(node);\n\t\t\t}else{\n\t\t\t\tvar type = (node.type||\"\").toLowerCase();\n\t\t\t\tif(serializeExclude.indexOf(type) == -1){\n\t\t\t\t\tvar val = dojo.fieldToObject(node);\n\t\t\t\t\tif(node.name && val != null){\n\t\t\t\t\t\tvar q = {};\n\t\t\t\t\t\tq[node.name] = val;\n\t\t\t\t\t\treturn dojo.objectToQuery(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn ret + strs.join(\"&\");\n\t}\n\n\t$.param = function(obj){\n\t\tif(obj._is$ && obj.serialize){\n\t\t\treturn obj.serialize();\n\t\t}else if(dojo.isArray(obj)){\n\t\t\treturn dojo.map(obj, function(item){\n\t\t\t\treturn $.param(item);\n\t\t\t}).join(\"&\");\n\t\t}else{\n\t\t\treturn dojo.objectToQuery(obj);\n\t\t}\n\t}\n\t\n\t//END jquery Ajax API methods\n\n\t//START jquery Utilities API methods\n\t//http://docs.jquery.com/Utilities\n\t//TODO:\n\t\n\t$.isFunction = function(){\n\t\tvar result = dojo.isFunction.apply(dojo, arguments);\n\t\t//Make sure Object does not return true\n\t\tif(result){\n\t\t\tresult = (typeof(arguments[0]) != \"object\");\n\t\t}\n\t\treturn result;\n\t}\n\n\t//END jquery Utilities API methods\n\n\t\n})();\n\n"], "fixing_code": ["//For jQuery 1.3.2\n\ndojo.provide(\"dojox.jq\");\ndojo.require(\"dojo.NodeList-traverse\");\ndojo.require(\"dojo.NodeList-manipulate\");\ndojo.require(\"dojo.io.script\");\n\n/*\nTo get jquery tests to pass:\n- add spaces between span>form selectors, other ones like one,two\n- .last() instead of :last\n- $(\"<div>\").find(\"#foo\") does not work unless the div is attached to the body.\n\n- trigger .test not work\n- No jquery.Event thing.\n\n- jQuery.ajax() modifies incoming arguments?\n- test framework not good for our io methods, async, poll.\n- Dojo ajax is async: we fire ajaxStop more than jquery.\n\n- jquery makes assumptions of a value to set for an element\nby inserting an element and checking display. Does not seem to\naccount for nested styles, only captures generic tag name style off\nof body. Why can't we just set display to empty?\n\n\n\n\n\nOK for failures:\n- test(\"jQuery.ajax - beforeSend, cancel request (#2688)\"\n  We cancel the deferred which triggers error and complete callbacks.\n\n\nLooked at jquery code for:\n- how it handled text(): did not use textContent/innerText, but use recursive look over childNodes and nodeValue,\nso it may have impact on how <br> is serialized, but it has uniform behavior across browsers.\n- Looked at trigger: how it triggered actions on dom nodes. This seemed unsafe.\n*/\n\n/*\ndojo.query differences that cause some tests to fail:\n- does not support XML queries\n- $(\"#sap>form\") does not find a match but $(\"#sap > form\") does. Similar issue with comma instead of > (see is() tests)\n- \"$(\"form:last\") should return the last form object, not if that particular form is that last related\n  to its siblings? Same issue with :first?\n- $(\"p\").filter(\"#ap, #sndp\"): filter does not work.\n- dojo.NodeList uses d.NodeList a few places in the code. Would be nice to use a ctor that can be configured.\n  That would make the filter function operate better.\n- filterQueryResult, cannot handle queries like \"p, div\"? See andSelf test with parents().\n- adjacent \"p + p\" not supported?\n= a:only-child not supported?\n- nth(1)\n- even/odd\n- eq/gt/lt\n- #form :radio:checked does not run the first :radio psuedo selector? Seems to be a general issue where only the last pseud\n  is run. For example, \"#form :checked:radio\" does only the radio pseudo.\n*/\n\n(function(){\n\t//Enable io topic publishing.   But don't mask the original definition of ioPublish from the doc parser.\n\t/*===== var ioPublish = dojo.config.ioPublish; =====*/\n\tdojo.config.ioPublish = true;\n\t/*===== dojo.config.ioPublish = ioPublish; =====*/\n\n\t//Support stuff for toDom\n\tvar selfClosedTags = \"|img|meta|hr|br|input|\";\n\n\tfunction toDom(/*String*/html, /*Document?*/doc){\n\t\t//summary converts HTML string into DOM nodes.\n\t\t//Make sure html is a string.\n\t\thtml += \"\";\n\n\t\t//Convert <tag/> into <tag></tag>\n\t\thtml = html.replace(/<\\s*(\\w+)([^\\/\\>]*)\\/\\s*>/g, function(tag, name, contents){\n\t\t\tif(selfClosedTags.indexOf(\"|\" + name + \"|\") == -1){\n\t\t\t\treturn \"<\" + name + contents + \"></\" + name + \">\";\n\t\t\t}else{\n\t\t\t\treturn tag;\n\t\t\t}\n\t\t});\n\n\t\treturn dojo._toDom(html, doc);\n\t}\n\n\tfunction cssNameToJs(name){\n\t\tvar index = name.indexOf(\"-\");\n\t\tif(index != -1){\n\t\t\t//Strip off beginning dash\n\t\t\tif(index == 0){\n\t\t\t\tname = name.substring(1);\n\t\t\t}\n\t\t\tname = name.replace(/-(\\w)/g, function(match, match1){\n\t\t\t\treturn match1.toUpperCase();\n\t\t\t});\n\t\t}\n\t\treturn name;\n\t}\n\n\tvar _old$ = dojo.global.$;\n\tvar _oldJQuery = dojo.global.jQuery;\n\n\tvar $ = dojo.global.$ = dojo.global.jQuery = function(){\n\t\tvar arg = arguments[0];\n\t\tif(!arg){\n\t\t\treturn $._wrap([], null, $);\n\t\t}else if(dojo.isString(arg)){\n\t\t\tif(arg.charAt(0) == \"<\"){\n\t\t\t\t//String of html that needs nodes created.\n\t\t\t\targ = toDom(arg);\n\t\t\t\t//If a DocumentFragment, convert to use its children\n\t\t\t\t//since we want to treat all top level nodes as elements\n\t\t\t\t//in the NodeList array.\n\t\t\t\tif(arg.nodeType == 11){\n\t\t\t\t\targ = arg.childNodes;\n\t\t\t\t}else{\n\t\t\t\t\treturn $._wrap([arg], null, $);\n\t\t\t\t}\n\t\t\t\t//Use end case of nodelist to finish work.\n\t\t\t}else{\n\t\t\t\t//Normal dojo.query selector.\n\t\t\t\t//Switch out query's NodeList constructor to be our specialized\n\t\t\t\t//NodeList constructor.\n\t\t\t\tvar listCtor = dojo._NodeListCtor;\n\t\t\t\tdojo._NodeListCtor = $;\n\n\t\t\t\t//If the second arg is one of our fake NodeLists then\n\t\t\t\t//use the first parent for the call.\n\t\t\t\tvar arg2 = arguments[1];\n\t\t\t\tif(arg2 && arg2._is$){\n\t\t\t\t\targ2 = arg2[0];\n\t\t\t\t}else if(dojo.isString(arg2)){\n\t\t\t\t\targ2 = dojo.query(arg2)[0];\n\t\t\t\t}\n\n\t\t\t\tvar nl = dojo.query.call(this, arg, arg2);\n\t\t\t\tdojo._NodeListCtor = listCtor;\n\t\t\t\treturn nl;\n\t\t\t}\n\t\t}else if(dojo.isFunction(arg)){\n\t\t\t//The addOnLoad case\n\t\t\t$.ready(arg);\n\t\t\treturn $;\n\t\t}else if(arg == document || arg == window){\n\t\t\t//If the arg is the document or window,\n\t\t\t//then just use it directly.\n\t\t\treturn $._wrap([arg], null, $);\n\t\t}else if(dojo.isArray(arg)){\n\t\t\t//Input is a plain array.\n\t\t\t//Filter out duplicates.\n\t\t\tvar ary = [];\n\t\t\tfor(var i = 0; i < arg.length; i++){\n\t\t\t\tif(dojo.indexOf(ary, arg[i]) == -1){\n\t\t\t\t\tary.push(arg[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $._wrap(arg, null, $);\n\t\t}else if(\"nodeType\" in arg){\n\t\t\t//A DOM Node\n\t\t\treturn $._wrap([arg], null, $);\n\t\t}\n\n\t\t//A native NodeList that does not conform to dojo.isArray().\n\t\t//Convert it to a workable array and create new NodeList.\n\t\treturn $._wrap(dojo._toArray(arg), null, $);\n\n\t};\n\n\t//Set up plugin extension point.\n\tvar nlProto = dojo.NodeList.prototype;\n\n\t//Need a delegate, because at least one method conflicts with jquery\n\t//API: attr(name) in jQuery only returns a single, first value, where\n\t//dojo.attr will return an array.\n\tvar f = $.fn = $.prototype = dojo.delegate(nlProto);\n\n\t//_wrap is required for proper use in dojo.query, but the _adaptAs* methods\n\t//do not have to placed on $ -- they can be used directly off dojo.NodeList.\n\t$._wrap = dojo.NodeList._wrap;\n\n\t//Add in some pseudos selectors\n\tvar headerRegExp = /^H\\d/i;\n\tvar pseudos = dojo.query.pseudos;\n\tdojo.mixin(pseudos, {\n\t\thas: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn $(condition, elem).length;\n\t\t\t}\n\t\t},\n\t\tvisible: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn dojo.style(elem, \"visible\") != \"hidden\" && dojo.style(elem, \"display\") != \"none\";\n\t\t\t}\n\t\t},\n\t\thidden: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.type == \"hidden\" || dojo.style(elem, \"visible\") == \"hidden\" || dojo.style(elem, \"display\") == \"none\";\n\t\t\t}\n\t\t},\n\t\tselected: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.selected;\n\t\t\t}\n\t\t},\n\t\tchecked: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.nodeName.toUpperCase() == \"INPUT\" && elem.checked;\n\t\t\t}\n\t\t},\n\t\tdisabled: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.getAttribute(\"disabled\");\n\t\t\t}\n\t\t},\n\t\tenabled: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn !elem.getAttribute(\"disabled\");\n\t\t\t}\n\t\t},\n\t\tinput: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\tvar n = elem.nodeName.toUpperCase();\n\t\t\t\treturn n == \"INPUT\" || n == \"SELECT\" || n == \"TEXTAREA\" || n == \"BUTTON\";\n\t\t\t}\n\t\t},\n\t\tbutton: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn (elem.nodeName.toUpperCase() == \"INPUT\" && elem.type == \"button\") || elem.nodeName.toUpperCase() == \"BUTTON\";\n\t\t\t}\n\t\t},\n\t\theader: function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.nodeName.match(headerRegExp);\n\t\t\t}\n\t\t}\n\t\t//TODO: implement :animated\n\t});\n\n\n\t//Add the input type selectors to pseudos\n\tvar inputPseudos = {};\n\tdojo.forEach([\n\t\t\"text\", \"password\", \"radio\", \"checkbox\", \"submit\", \"image\", \"reset\", \"file\"\n\t], function(type) {\n\t\tinputPseudos[type] = function(name, condition){\n\t\t\treturn function(elem){\n\t\t\t\treturn elem.nodeName.toUpperCase() == \"INPUT\" && elem.type == type;\n\t\t\t}\n\t\t};\n\t});\n\tdojo.mixin(pseudos, inputPseudos);\n\n\t//Set up browser sniff.\n\t$.browser = {\n\t\tmozilla: dojo.isMoz,\n\t\tmsie: dojo.isIE,\n\t\topera: dojo.isOpera,\n\t\tsafari: dojo.isSafari\n\t};\n\t$.browser.version = dojo.isIE || dojo.isMoz || dojo.isOpera || dojo.isSafari || dojo.isWebKit;\n\t\n\t//Map back into dojo\n\t//Hmm maybe this is not so good. Dojo\n\t//modules may still be holding on to old\n\t//dojo (example: the d._NodeListCtor in query.js)\n\t//dojo = dojo.mixin($, dojo);\n\n\t// Add $.ready\n\t$.ready = $.fn.ready = function(callback){\n\t\tdojo.addOnLoad(dojo.hitch(null, callback, $));\n\t\treturn this;\n\t}\n\n\t//START jquery Core API methods\n\t//http://docs.jquery.com/Core\n\tf._is$ = true;\n\tf.size = function(){return this.length; };\n\n\t$.prop = function(node, propCheck){\n\t\t//TODO: not sure about this one, could not find the docs?\n\t\tif(dojo.isFunction(propCheck)){\n\t\t\treturn propCheck.call(node);\n\t\t}else{\n\t\t\treturn propCheck;\n\t\t}\n\t}\n\n\t$.className = {\n\t\tadd: dojo.addClass,\n\t\tremove: dojo.removeClass,\n\t\thas: dojo.hasClass\n\t};\n\n\t$.makeArray = function(thing){\n\t\tif(typeof thing == \"undefined\"){\n\t\t\treturn [];\n\t\t}else if(thing.length && !dojo.isString(thing) && !(\"location\" in thing)){\n\t\t\t//Location check was for excluding window objects that have a length.\n\t\t\treturn dojo._toArray(thing);\n\t\t}else{\n\t\t\treturn [thing];\n\t\t}\n\t}\n\t\n\t$.merge = function(ary1, ary2){\n\t\t//Alters first array by adding in the element.\n\t\tvar args = [ary1.length, 0];\n\t\targs = args.concat(ary2);\n\t\tary1.splice.apply(ary1, args);\n\t\treturn ary1;\n\t}\n\n\t$.each = function(/*Array||ArrayLike*/list, /*Function*/cb){\n\t\t//each differs from dojo.NodeList.forEach in that\n\t\t//\"this\" is the current cycled node. Breaking\n\t\t//the loop is also possible. Also, index is first arg\n\t\t//to the callback.\n\t\tif(dojo.isArrayLike(list)){\n\t\t\tfor(var i = 0; i < list.length; i++){\n\t\t\t\tif(cb.call(list[i], i, list[i]) === false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dojo.isObject(list)){\n\t\t\tfor(var param in list){\n\t\t\t\tif(cb.call(list[param], param, list[param]) === false){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\tf.each = function(/*Function*/cb){\n\t\treturn $.each.call(this, this, cb);\n\t};\n\t//f.length already implemented by NodeList\n\tf.eq = function(){\n\t\t//Direct copy of dojo.NodeList.at, but want\n\t\t//to use our NodeList class.\n\t\tvar nl = $();\n\t\tdojo.forEach(arguments, function(i) { if(this[i]) { nl.push(this[i]); } }, this);\n\t\treturn nl; // dojo.NodeList\n\t};\n\tf.get = function(/*Number*/index){\n\t\tif(index || index == 0){\n\t\t\treturn this[index];\n\t\t}\n\t\treturn this;\n\t};\n\tf.index = function(arg){\n\t\t//Hmm, allows passing in a $ nodelist. Apparently in that\n\t\t//case take the first item in that array and match\n\t\tif(arg._is$){\n\t\t\targ = arg[0];\n\t\t}\n\t\treturn this.indexOf(arg);\n\t}\n\n\t//.data implementation\n\tvar dataStore = [];\n\tvar dataId = 0;\n\tvar dataAttr = dojo._scopeName + \"DataId\";\n\t\n\tvar getDataId = function(node){\n\t\tvar id = node.getAttribute(dataAttr);\n\t\tif(!id){\n\t\t\tid = dataId++;\n\t\t\tnode.setAttribute(dataAttr, id);\n\t\t}\n\t}\n\t\n\tvar getData = function(node){\n\t\tvar data = {};\n\t\tif(node.nodeType == 1){\n\t\t\tvar id = getDataId(node);\n\t\t\tdata = dataStore[id];\n\t\t\tif(!data){\n\t\t\t\tdata = dataStore[id] = {};\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\t$.data = function(/*DOMNode*/node, /*String*/name, /*String*/value){\n\t\tvar result = null;\n\t\tif(name == \"events\"){\n\t\t\t//Special case \"events\", since jquery tests seem to use it to\n\t\t\t//get the event handler storage for jquery. So for jquery apps\n\t\t\t//\"events\" is probably a reserved word anyway.\n\t\t\tresult = listeners[node.getAttribute(eventAttr)];\n\t\t\tvar isEmpty = true;\n\t\t\tif(result){\n\t\t\t\tfor(var param in result){\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isEmpty ? null : result;\n\t\t}\n\n\t\tvar data = getData(node);\n\t\tif(typeof value != \"undefined\"){\n\t\t\tdata[name] = value;\n\t\t}else{\n\t\t\tresult = data[name];\n\t\t}\n\t\treturn value ? this : result;\n\t}\n\n\t$.removeData = function(/*DOMNode*/node, /*String*/name){\n\t\tvar data = getData(node);\n\t\tdelete data[name];\n\t\tif(node.nodeType == 1){\n\t\t\tvar isEmpty = true;\n\t\t\tfor(var param in data){\n\t\t\t\tisEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(isEmpty){\n\t\t\t\tnode.removeAttribute(dataAttr);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tf.data = function(/*String*/name, /*String*/value){\n\t\tvar result = null;\n\t\tthis.forEach(function(node){\n\t\t\tresult = $.data(node, name, value);\n\t\t});\n\n\t\treturn value ? this : result;\n\t}\n\n\tf.removeData = function(/*String*/name){\n\t\tthis.forEach(function(node){\n\t\t\t$.removeData(node, name);\n\t\t});\n\t\treturn this;\n\t}\n\t\n\tfunction jqMix(obj, props){\n\t\t// summary:\n\t\t//\t\tan attempt at a mixin that follows\n\t\t//\t\tjquery's .extend rules. Seems odd. Not sure how\n\t\t//\t\tto resolve this with dojo.mixin and what the use\n\t\t//\t\tcases are for the jquery version.\n\t\t//\t\tCopying some code from dojo._mixin.\n\t\tif(obj == props){\n\t\t\treturn obj;\n\t\t}\n\t\tvar tobj = {};\n\t\tfor(var x in props){\n\t\t\t// the \"tobj\" condition avoid copying properties in \"props\"\n\t\t\t// inherited from Object.prototype.  For example, if obj has a custom\n\t\t\t// toString() method, don't overwrite it with the toString() method\n\t\t\t// that props inherited from Object.prototype\n\t\t\tif(x !== '__proto__ ' && ((tobj[x] === undefined || tobj[x] != props[x])) && props[x] !== undefined && obj != props[x]){\n\t\t\t\tif(dojo.isObject(obj[x]) && dojo.isObject(props[x])){\n\t\t\t\t\tif(dojo.isArray(props[x])){\n\t\t\t\t\t\tobj[x] = props[x];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tobj[x] = jqMix(obj[x], props[x]);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tobj[x] = props[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// IE doesn't recognize custom toStrings in for..in\n\t\tif(dojo.isIE && props){\n\t\t\tvar p = props.toString;\n\t\t\tif(typeof p == \"function\" && p != obj.toString && p != tobj.toString &&\n\t\t\t\tp != \"\\nfunction toString() {\\n    [native code]\\n}\\n\"){\n\t\t\t\t\tobj.toString = props.toString;\n\t\t\t}\n\t\t}\n\t\treturn obj; // Object\n\t}\n\n\tf.extend = function(){\n\t\tvar args = [this];\n\t\targs = args.concat(arguments);\n\t\treturn $.extend.apply($, args);\n\t}\n\n\t$.extend = function(){\n\t\t//Could have multiple args to mix in. Similar to dojo.mixin,\n\t\t//but has some different rules, and the mixins all get applied\n\t\t//to the first arg.\n\t\tvar args = arguments, finalObj;\n\t\tfor(var i = 0; i < args.length; i++){\n\t\t\tvar obj = args[i];\n\t\t\tif(obj && dojo.isObject(obj)){\n\t\t\t\tif(!finalObj){\n\t\t\t\t\tfinalObj = obj;\n\t\t\t\t}else{\n\t\t\t\t\tjqMix(finalObj, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn finalObj;\n\t}\n\n\t$.noConflict = function(/*Boolean*/extreme){\n\t\tvar me = $;\n\t\tdojo.global.$ = _old$;\n\t\tif(extreme){\n\t\t\tdojo.global.jQuery = _oldJQuery;\n\t\t}\n\t\treturn me;\n\t}\n\t//END jquery Core API methods\n\t\n\t//START jquery Attribute API methods\n\t//http://docs.jquery.com/Attributes\n\tf.attr = function(name, value){\n\t\t//The isObject tests below are to weed out where something\n\t\t//like a form node has an input called \"action\" but we really\n\t\t//want to get the attribute \"action\". But in general, favor\n\t\t//a property value over a DOM attribute value.\n\t\tif(arguments.length == 1 && dojo.isString(arguments[0])){\n\t\t\t//The get case, return first match.\n\t\t\tvar first = this[0];\n\t\t\t\n\t\t\t//Weed out empty nodes\n\t\t\tif(!first){\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar arg = arguments[0];\n\t\t\t//favor properties over attributes.\n\t\t\tvar attr = dojo.attr(first, arg);\n\t\t\tvar prop = first[arg];\n\t\t\tif((arg in first) && !dojo.isObject(prop) && name != \"href\"){\n\t\t\t\treturn prop;\n\t\t\t}else{\n\t\t\t\treturn attr || prop;\n\t\t\t}\n\t\t}else if(dojo.isObject(name)){\n\t\t\t//A setter, using an object.\n\t\t\tfor(var param in name){\n\t\t\t\tthis.attr(param, name[param]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}else{\n\t\t\t//The setter case. Figure out if value is a function.\n\t\t\tvar isFunc = dojo.isFunction(value);\n\t\t\tthis.forEach(function(node, index){\n\t\t\t\tvar prop = node[name];\n\t\t\t\tif((name in node) && !dojo.isObject(prop) && name != \"href\"){\n\t\t\t\t\tnode[name] = (isFunc ? value.call(node, index) : value);\n\t\t\t\t}else if(node.nodeType == 1){\n\t\t\t\t\tdojo.attr(node, name, (isFunc ? value.call(node, index) : value));\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tf.removeAttr = function(name){\n\t\tthis.forEach(function(node, index){\n\t\t\tvar prop = node[name];\n\t\t\tif((name in node) && !dojo.isObject(prop) && name != \"href\"){\n\t\t\t\tdelete node[name];\n\t\t\t}else if(node.nodeType == 1){\n\t\t\t\tif(name == \"class\"){\n\t\t\t\t\t//TODO: push this fix into dojo.removeAttr\n\t\t\t\t\tnode.removeAttribute(name);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.removeAttr(node, name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t//addClass, removeClass exist in dojo.NodeList. toggleClass in jQuery case\n\t//just means add/remove the classname if it missing/exists. So need custom override.\n\tf.toggleClass = function(/*String*/name, /*Expression?*/condition){\n\t\tvar hasCondition = arguments.length > 1;\n\t\tthis.forEach(function(node){\n\t\t\tdojo.toggleClass(node, name,  hasCondition ? condition : !dojo.hasClass(node, name));\n\t\t});\n\t\treturn this;\n\t}\n\n\t//Action depends on arguments: if an array of functions do one thing,\n\t//If no args, do a display toggle,\n\t//If an expression, something that evaluates to true or false,\n\t//then toggle display accordingly.\n\t//If first arg is a String/Number, then do animation. Second arg\n\t//is an optional callback.\n\tf.toggle = function(){\n\t\t//If more than two args and we have a function as first arg, then\n\t\t//probably the onclick toggle variant: takes variable args that are\n\t\t//functions and cycles through them on click actions.\n\t\tvar args = arguments;\n\t\tif(arguments.length > 1 && dojo.isFunction(arguments[0])){\n\t\t\tvar index = 0;\n\t\t\tvar func = function(){\n\t\t\t\tvar result = args[index].apply(this, arguments);\n\t\t\t\tindex += 1;\n\t\t\t\tif(index > args.length - 1){\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn this.bind(\"click\", func);\n\t\t}else{\n\t\t\t//The display/hide/show case.\n\t\t\tvar condition = arguments.length == 1 ? arguments[0] : undefined;\n\t\t\tthis.forEach(function(node){\n\t\t\t\tvar result = typeof condition == \"undefined\" ? dojo.style(node, \"display\") == \"none\" : condition;\n\t\t\t\tvar action = (result ? \"show\" : \"hide\");\n\t\t\t\tvar nl = $(node);\n\t\t\t\tnl[action].apply(nl, args);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t//hasClass just returns true if any of the nodes has the class.\n\tf.hasClass = function(/*String*/name){\n\t\treturn this.some(function(node){\n\t\t\treturn dojo.hasClass(node, name);\n\t\t});\n\t}\n\n\t//use the html method from dojo.NodeList-manipulate.\n\tf.html = f.innerHTML;\n\n\t//END jquery Attribute API methods\n\n\t\n\t//START jquery Traversing API methods\n\t//http://docs.jquery.com/Traversing\n\tdojo.forEach([\"filter\", \"slice\"], function(item){\n\t\tf[item] = function(){\n\t\t\t//Convert the \"this\" value for functions passed in:\n\t\t\tvar nl;\n\t\t\tif(dojo.isFunction(arguments[0])){\n\t\t\t\tvar origFunc = arguments[0];\n\t\t\t\targuments[0] = function(item, index){\n\t\t\t\t\treturn origFunc.call(item, item, index);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(item == \"filter\" && dojo.isString(arguments[0])){\n\t\t\t\tvar nl = this._filterQueryResult(this, arguments[0]);\n\t\t\t}else{\n\t\t\t\tvar oldCtor = dojo._NodeListCtor;\n\t\t\t\tdojo._NodeListCtor = f;\n\t\t\t\t//Need to wrap in a $() call since internally some\n\t\t\t\t//dojo.NodeList functions reference dojo.NodeList directly.\n\t\t\t\t//Need to get a configurable constructor for dojo.NodeList.\n\t\t\t\tnl = $(nlProto[item].apply(this, arguments));\n\t\t\t\tdojo._NodeListCtor = oldCtor;\n\t\t\t}\n\n\t\t\treturn nl._stash(this);\n\t\t}\n\t});\n\n\tf.map = function(/*Function*/callback){\n\t\t//Hmm, this is not like array map/dojo.map where you get one item back for\n\t\t//each input.\n\t\treturn this._buildArrayFromCallback(callback);\n\t}\n\t$.map = function(/*Array*/ary, /*Function*/callback){\n\t\t//Hmm, this is not like array map/dojo.map where you get one item back for\n\t\t//each input.\n\t\treturn f._buildArrayFromCallback.call(ary, callback);\n\t}\n\n\t$.inArray = function(value, /*Array*/ary){\n\t\treturn dojo.indexOf(ary, value);\n\t}\n\n\tf.is = function(query){\n\t\treturn (query ? !!this.filter(query).length : false);\n\t}\n\n\t//TODO: probably a better way to do this.\n\tf.not = function(){\n\t\tvar notList = $.apply($, arguments);\n\t\t//TODO: another place where if dojo.NodeList can configure a constructor,\n\t\t//then we could avoid the $() wrapper below.\n\t\tvar nl = $(nlProto.filter.call(this, function(node){\n\t\t\treturn notList.indexOf(node) == -1;\n\t\t}));\n\t\treturn nl._stash(this);\n\t}\n\n\tf.add = function(){\n\t\treturn this.concat.apply(this, arguments);\n\t}\n\n\tfunction iframeDoc(/*DOMNode*/iframeNode){\n\t\t// summary:\n\t\t//\t\tReturns the document object associated with the iframe DOM Node argument.\n\n\t\t//Taken from dojo.io.iframe.doc(). Needed for contents() function below.\n\n\t\tvar doc = iframeNode.contentDocument || // W3\n\t\t\t(\n\t\t\t\t(\n\t\t\t\t\t(iframeNode.name) && (iframeNode.document) &&\n\t\t\t\t\t(document.getElementsByTagName(\"iframe\")[iframeNode.name].contentWindow) &&\n\t\t\t\t\t(document.getElementsByTagName(\"iframe\")[iframeNode.name].contentWindow.document)\n\t\t\t\t)\n\t\t\t) ||  // IE\n\t\t\t(\n\t\t\t\t(iframeNode.name)&&(document.frames[iframeNode.name])&&\n\t\t\t\t(document.frames[iframeNode.name].document)\n\t\t\t) || null;\n\t\treturn doc;\n\t}\n\n\tf.contents = function(){\n\t\tvar ary = [];\n\t\tthis.forEach(function(node){\n\t\t\tif(node.nodeName.toUpperCase() == \"IFRAME\"){\n\t\t\t\tvar doc = iframeDoc(node);\n\t\t\t\tif(doc){\n\t\t\t\t\tary.push(doc);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//TODO: code similar to children() function. Refactor?\n\t\t\t\tvar children = node.childNodes;\n\t\t\t\t//Using for loop for better speed.\n\t\t\t\tfor(var i = 0; i < children.length; i++){\n\t\t\t\t\tary.push(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this._wrap(ary)._stash(this);\n\t}\n\n\tf.find = function(/*String*/query){\n\t\tvar ary = [];\n\t\tthis.forEach(function(node){\n\t\t\tif(node.nodeType == 1){\n\t\t\t\tary = ary.concat(dojo._toArray($(query, node)));\n\t\t\t}\n\t\t});\n\t\treturn this._getUniqueAsNodeList(ary)._stash(this);\n\t}\n\n\tf.andSelf = function(){\n\t\treturn this.add(this._parent);\n\t}\n\n\t//END jquery Traversing API methods\n\n\t//START jquery Manipulation API methods\n\t//http://docs.jquery.com/Manipulation\n\n\tf.remove = function(/*String?*/query){\n\t\t//Override NodeList-manipulate's remove so we can remove data.\n\t\tvar nl = (query ? this._filterQueryResult(this, query) : this);\n\t\t\n\t\t//Remove data\n\t\tnl.removeData();\n\t\t\n\t\t//Remove event listeners.\n\t\t//TODO! do this, once event stuff is built out.\n\t\t\n\t\t//Remove the items from the DOM, but keep them in this\n\t\t//node list.\n\t\tnl.forEach(function(node){\n\t\t\tnode.parentNode.removeChild(node);\n\t\t});\n\t\t\n\t\treturn this;\n\t}\n\n\t//START jquery CSS API methods\n\t//http://docs.jquery.com/CSS\n\t$.css = function(/*DOMNode*/node, /*String|Object*/name, /*String|Number?*/value){\n\t\tname = cssNameToJs(name);\n\t\t\n\t\t//Hmm, dojo.style does an arguments. length check.\n\t\tvar result = (value ? dojo.style(node, name, value) : dojo.style(node, name));\n\t\treturn result;\n\t}\n\n\tf.css = function(/*String|Object*/name, /*String|Number?*/value){\n\t\tif(dojo.isString(name)){\n\t\t\t//Convert name to JS name if needed.\n\t\t\tname = cssNameToJs(name);\n\t\t\tif(arguments.length == 2){\n\t\t\t\t//set the value. Cannot directly delegate to\n\t\t\t\t//this.style, since non-element nodes may be in the mix?\n\t\t\t\t//this.contents() in particular will return some funky stuff.\n\t\t\t\t\n\t\t\t\t//Need to be sure to add \"px\" if appropriate.\n\t\t\t\tif(!dojo.isString(value) && name != \"zIndex\"){\n\t\t\t\t\tvalue = value + \"px\";\n\t\t\t\t}\n\n\t\t\t\tthis.forEach(function(node){\n\t\t\t\t\tif(node.nodeType == 1){\n\t\t\t\t\t\tdojo.style(node, name, value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t}else{\n\t\t\t\t//return the value\n\t\t\t\tvalue = dojo.style(this[0], name);\n\t\t\t\t//Need to be sure to add \"px\" if appropriate.\n\t\t\t\tif(!dojo.isString(value) && name != \"zIndex\"){\n\t\t\t\t\tvalue = value + \"px\";\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(var param in name){\n\t\t\t\tthis.css(param, name[param]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t}\n\t\n\tfunction doBox(/*NodeList*/nl, /*String*/boxType, /*String*/prop, /*String||Number*/value){;\n\t\tif(value){\n\t\t\t//Set height for all elements.\n\t\t\tvar mod = {};\n\t\t\tmod[prop] = value;\n\t\t\tnl.forEach(function(node){\n\t\t\t\tdojo[boxType](node, mod);\n\t\t\t});\n\t\t\treturn nl;\n\t\t}else{\n\t\t\t//Just get first node's height.\n\t\t\t//Hmm. width is negative when element is display none in FF3?\n\t\t\treturn Math.abs(Math.round(dojo[boxType](nl[0])[prop]));\n\t\t}\n\t}\n\n\tf.height = function(value){\n\t\treturn doBox(this, \"contentBox\", \"h\", value);\n\t}\n\n\tf.width = function(value){\n\t\treturn doBox(this, \"contentBox\", \"w\", value);\n\t}\n\n\tfunction getDimensions(/*DOMNode*/node, /*String*/type, /*Boolean*/usePadding, /*Boolean*/useBorder, /*Boolean*/useMargin){\n\t\t// summary:\n\t\t//\t\tsums up the different parts of the width/height based on arguments.\n\n\t\t//If hidden, temporarily show it, do measurements then close.\n\t\tvar rehide = false;\n\t\tif((rehide = node.style.display == \"none\")){\n\t\t\tnode.style.display = \"block\";\n\t\t}\n\n\t\tvar cs = dojo.getComputedStyle(node);\n\t\tvar content = Math.abs(Math.round(dojo._getContentBox(node, cs)[type]));\n\t\tvar pad = usePadding ? Math.abs(Math.round(dojo._getPadExtents(node, cs)[type])) : 0;\n\t\tvar border = useBorder ? Math.abs(Math.round(dojo._getBorderExtents(node, cs)[type])) : 0;\n\t\tvar margin = useMargin ? Math.abs(Math.round(dojo._getMarginExtents(node, cs)[type])) : 0;\n\t\t\n\t\tif(rehide){\n\t\t\tnode.style.display = \"none\";\n\t\t}\n\n\t\treturn pad + content + border + margin;\n\t}\n\n\tf.innerHeight = function(){\n\t\treturn getDimensions(this[0], \"h\", true);\n\t}\n\n\tf.innerWidth = function(){\n\t\treturn getDimensions(this[0], \"w\", true);\n\t}\n\n\tf.outerHeight = function(useMargin){\n\t\treturn getDimensions(this[0], \"h\", true, true, useMargin);\n\t}\n\n\tf.outerWidth = function(useMargin){\n\t\treturn getDimensions(this[0], \"w\", true, true, useMargin);\n\t}\n\n\t//END jquery CSS API methods\n\n\n\t//START jquery Events API methods\n\t//http://docs.jquery.com/Events\n\t\n\t//ready() already defined above.\n\n\t//Event plumbing.\n\tvar listeners = [];\n\tvar listenId = 1;\n\tvar eventAttr = dojo._scopeName + \"eventid\";\n\tvar currentEvtData;\n\n\tfunction getNonNamespacedName(/*String*/evtName){\n\t\t// summary:\n\t\t//\t\tgets name of the event before the first \".\".\n\n\t\t//The $$ stuff is special ids used to create unique names\n\t\t//for bound functions that did not have a unique namespace name.\n\t\tevtName = evtName.split(\"$$\")[0];\n\t\tvar dotIndex = evtName.indexOf(\".\");\n\t\tif(dotIndex != -1){\n\t\t\tevtName = evtName.substring(0, dotIndex);\n\t\t}\n\t\treturn evtName;\n\t}\n\n\tfunction domConnect(/*DOMNode*/node, /*String*/evtName){\n\t\t// summary:\n\t\t//\t\thandles creating the connection with a real DOM event.\n\n\t\t//This work should only be done one time per evName type.\n\t\t//If the event if an ajax event, use dojo.subscribe instead.\n\t\tif(evtName.indexOf(\"ajax\") == 0){\n\t\t\treturn dojo.subscribe(topics[evtName], function(dfd, res){\n\t\t\t\tvar fakeEvt = new $.Event(evtName);\n\t\t\t\tif(\"ajaxComplete|ajaxSend|ajaxSuccess\".indexOf(evtName) != -1){\n\t\t\t\t\ttriggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args]);\n\t\t\t\t}else if(evtName == \"ajaxError\"){\n\t\t\t\t\ttriggerHandlers(node, [fakeEvt, dfd.ioArgs.xhr, dfd.ioArgs.args, res]);\n\t\t\t\t}else{\n\t\t\t\t\t//ajaxStart|ajaxStop\n\t\t\t\t\ttriggerHandlers(node, [fakeEvt]);\n\t\t\t\t}\n\t\t\t});\n\t\t}else{\n\t\t\treturn dojo.connect(node, \"on\" + evtName, function(e){\n\t\t\t\ttriggerHandlers(node, arguments);\n\t\t\t}); //Object\n\t\t}\n\t}\n\n\t//Event object for compatibility for some tests.\n\t$.Event = function(/*String*/type){\n\t\t//Allow for calling function without \"new\"\n\t\tif(this == $){\n\t\t\treturn new $.Event(type);\n\t\t}\n\t\tif(typeof type == \"string\"){\n\t\t\tthis.type = type.replace(/!/, \"\");\n\t\t}else{\n\t\t\tdojo.mixin(this, type);\n\t\t}\n\t\tthis.timeStamp = (new Date()).getTime();\n\t\tthis._isFake = true;\n\t\tthis._isStrict = (this.type.indexOf(\"!\") != -1);\n\t\t\n\t}\n\t\n\tvar ep = $.Event.prototype = {\n\t\tpreventDefault: function(){\n\t\t\tthis.isDefaultPrevented = this._true;\n\t\t},\n\t\tstopPropagation: function(){\n\t\t\tthis.isPropagationStopped = this._true;\n\t\t},\n\t\tstopImmediatePropagation: function(){\n\t\t\tthis.isPropagationStopped = this._true;\n\t\t\tthis.isImmediatePropagationStopped = this._true;\n\t\t},\n\t\t_true: function(){ return true; },\n\t\t_false: function(){ return false; }\n\t}\n\tdojo.mixin(ep, {\n\t\tisPropagationStopped: ep._false,\n\t\tisImmediatePropagationStopped: ep._false,\n\t\tisDefaultPrevented: ep._false\n\t});\n\n\tfunction makeTriggerData(data, type){\n\t\t// summary:\n\t\t//\t\tmakes sure that the data array is copied\n\t\t//\t\tand has an event as the first arg. If this function generates\n\t\t//\t\ta fake event (known by the data[0]._isFake property being true)\n\t\t//\t\tthen the data[0].target needs to be set by the consumer of this function.\n\t\t\n\t\tdata = data || [];\n\t\tdata = [].concat(data);\n\n\t\t//If first data item is not an event, make one up.\n\t\t//Need to set up target: prop in the consumers of this\n\t\t//function.\n\t\tvar evt = data[0];\n\t\tif(!evt || !evt.preventDefault){\n\t\t\tevt = type && type.preventDefault ? type : new $.Event(type);\n\t\t\tdata.unshift(evt);\n\t\t}\n\t\treturn data;\n\t}\n\t\n\tvar triggerHandlersCalled = false;\n\n\tfunction triggerHandlers(/*DOMNode*/node, /*Array*/data, /*Function?*/extraFunc){\n\t\t// summary:\n\t\t//\t\thandles the actual callbacks to the handlers.\n\t\t\n\t\t//Indicate triggerHandlers was called.\n\t\ttriggerHandlersCalled = true;\n\t\t\n\t\t//Uses currentEvtData if this is a simulated event.\n\t\tdata = data || currentEvtData;\n\t\textraFunc = extraFunc;\n\n\t\t//Normalize on a real element if dealing with a document.\n\t\tif(node.nodeType == 9){\n\t\t\tnode = node.documentElement;\n\t\t}\n\n\t\tvar nodeId = node.getAttribute(eventAttr);\n\t\tif(!nodeId){\n\t\t\treturn;\n\t\t}\n\n\t\tvar evt = data[0];\n\t\tvar evtFullName = evt.type;\n\t\tvar evtName = getNonNamespacedName(evtFullName);\n\n\t\tvar cbs = listeners[nodeId][evtName];\n\n\t\tvar result;\n\t\t//Apply the extra function. What is that about? Not mentioned in the\n\t\t//public APIs?\n\t\tif(extraFunc){\n\t\t\tresult = extraFunc.apply(node, data);\n\t\t}\n\n\t\tif (result !== false){\n\t\t\tfor(var param in cbs){\n\t\t\t\tif(param != \"_connectId\" && (!evt._isStrict && (param.indexOf(evtFullName) == 0) || (evt._isStrict && param == evtFullName))){\n\t\t\t\t\t//Store the callback ID in case unbind is called with this event\n\t\t\t\t\t//so we can only unbind that one callback.\n\t\t\t\t\tevt[dojo._scopeName + \"callbackId\"] = param;\n\n\t\t\t\t\tvar cb = cbs[param];\n\t\t\t\t\tif(typeof cb.data != \"undefined\"){\n\t\t\t\t\t\tevt.data = cb.data;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tevt.data = null;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Do the actual callback.\n\t\t\t\t\tif ((result = cb.fn.apply(evt.target, data)) === false && !evt._isFake){\n\t\t\t\t\t\tdojo.stopEvent(evt);\n\t\t\t\t\t}\n\t\t\t\t\tevt.result = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tf.triggerHandler = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){\n\t\t//Only triggers handlers on the first node. Huh.\n\t\tvar node = this[0];\n\t\tif(node && node.nodeType != 3 && node.nodeType != 8){\n\t\t\tdata = makeTriggerData(data, type);\n\t\t\treturn triggerHandlers(node, data, extraFunc);\n\t\t}else{\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\tf.trigger = function(/*String*/type, /*Array?*/data, /*Function?*/extraFunc){\n\t\t//Copy data since we may need to modify by adding a\n\t\tdata = makeTriggerData(data, type);\n\t\tvar evt = data[0];\n\t\tvar type = getNonNamespacedName(evt.type);\n\t\t\n\t\t//Store the current event data in case handlers need\n\t\t//to reference it because of a simulated event.\n\t\tcurrentEvtData = data;\n\t\tcurrentExtraFunc = extraFunc;\n\n\t\tvar result = null;\n\t\tvar needTarget = !evt.target;\n\t\tthis.forEach(function(node){\n\t\t\t//Only handle non text/comment nodes.\n\t\t\tif(node.nodeType != 3 && node.nodeType != 8){\n\n\t\t\t\t//Normalize on a real element if dealing with a document.\n\t\t\t\tif(node.nodeType == 9){\n\t\t\t\t\tnode = node.documentElement;\n\t\t\t\t}\n\n\t\t\t\t//Set the node target appropriately for fake events.\n\t\t\t\tif(evt._isFake){\n\t\t\t\t\tevt.currentTarget = node;\n\t\t\t\t\tif(needTarget){\n\t\t\t\t\t\tevt.target = node;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Bizarre extra function thing. Not really demonstrated in public\n\t\t\t\t//API docs.\n\t\t\t\tif(extraFunc){\n\t\t\t\t\tvar funcData = data.slice(1);\n\t\t\t\t\tresult = extraFunc.apply(node, (result = null ? funcData : funcData.concat(result)));\n\t\t\t\t}\n\n\t\t\t\tif(result !== false){\n\t\t\t\t\t//Trigger DOM event. onclick is handled differently than\n\t\t\t\t\t//others.\n\t\t\t\t\t/*\n\t\t\t\t\tif(type == 'click' && node.onclick && node.nodeName.toUpperCase() == \"A\"){\n\t\t\t\t\t\tresult = node.onclick.apply(node, data);\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t//Set the \"global\" flag that indicates if triggerHandlers was called.\n\t\t\t\t\t//If the direct node.event/onevent does not trigger the handlers, do so\n\t\t\t\t\t//manually at the end.\n\t\t\t\t\ttriggerHandlersCalled = false;\n\t\t\t\t\t\n\t\t\t\t\t//Trigger functions registered directly on the DOM node.\n\t\t\t\t\tif(node[type]){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tresult = node[type]();\n\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t//Apparently IE throws on some hidden elements. Just eat it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(node[\"on\" + type]){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\tresult = node[\"on\" + type]();\n\t\t\t\t\t\t}catch(e){\n\t\t\t\t\t\t\t//Apparently IE throws on some hidden elements. Just eat it.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!triggerHandlersCalled){\n\t\t\t\t\t\t//Finally triggerHandlers directly if the above code did not trigger it yet.\n\t\t\t\t\t\tresult = triggerHandlers(node, data);\n\t\t\t\t\t}\n\n\t\t\t\t\t//Bubble the event up.\n\t\t\t\t\t//TODO: optimize this path so we don't have to do forEach and NodeList work.\n\t\t\t\t\tvar parentNode = node.parentNode;\n\t\t\t\t\tif(result !== false && !evt.isImmediatePropagationStopped() && !evt.isPropagationStopped() && parentNode && parentNode.nodeType == 1){\n\t\t\t\t\t\t$(parentNode).trigger(type, data, extraFunc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t//Clear current event data.\n\t\tcurrentEvtData = null;\n\t\tcurrentExtraFunc = null;\n\n\t\treturn this;\n\t}\n\n\tvar bindIdCounter = 0;\n\n\tf.bind = function(/*String*/type, /*Array||Function?*/data, /*Function*/fn){\n\t\t//Type can be space separated values.\n\t\ttype = type.split(\" \");\n\t\t\n\t\t//May not have data argument.\n\t\tif(!fn){\n\t\t\tfn = data;\n\t\t\tdata = null;\n\t\t}\n\n\t\tthis.forEach(function(node){\n\t\t\t//Only handle non text/comment nodes.\n\t\t\tif(node.nodeType != 3 && node.nodeType != 8){\n\t\t\t\n\t\t\t\t//If document, bind to documentElement\n\t\t\t\tif(node.nodeType == 9){\n\t\t\t\t\tnode = node.documentElement;\n\t\t\t\t}\n\n\t\t\t\t//If no nodeId, then create one and attach it to the DOM node.\n\t\t\t\tvar nodeId = node.getAttribute(eventAttr);\n\t\t\t\tif(!nodeId){\n\t\t\t\t\tnodeId = listenId++;\n\t\t\t\t\tnode.setAttribute(eventAttr, nodeId);\n\t\t\t\t\tlisteners[nodeId] = {};\n\t\t\t\t}\n\t\n\t\t\t\t//Process each event type.\n\t\t\t\tfor(var i = 0; i < type.length; i++){\n\t\t\t\t\t//Get event name, if have a dot on it, it is namespaced,\n\t\t\t\t\t//be sure to get the core event name.\n\t\t\t\t\tvar evtFullName = type[i];\n\t\t\t\t\tvar evtName = getNonNamespacedName(evtFullName);\n\t\t\t\t\tif(evtName == evtFullName){\n\t\t\t\t\t\t//Generate a unique ID for this function binding\n\t\t\t\t\t\tevtFullName = evtName + \"$$\" + (bindIdCounter++);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Get the event listeners for the event name, the complete name.\n\t\t\t\t\tvar lls = listeners[nodeId];\n\t\t\t\t\tif(!lls[evtName]){\n\t\t\t\t\t\tlls[evtName] = {\n\t\t\t\t\t\t\t_connectId: domConnect(node, evtName)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t//Add the callback to the list of listeners.\n\t\t\t\t\tlls[evtName][evtFullName] = {\n\t\t\t\t\t\tfn: fn,\n\t\t\t\t\t\tdata: data\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn this;\n\t}\n\n\tfunction copyEventHandlers(/*DOMNode*/ src, /*DOMNode*/ target){\n\t\t// summary:\n\t\t//\t\tcopies the event handlers from onne src *element* node to\n\t\t//\t\tanother target *element* node. Assumes that target had\n\t\t//\t\tno previous events on it, and is a clone of the src node.\n\n\t\t//Get src listeners.\n\t\tvar srcNodeId = target.getAttribute(eventAttr);\n\t\tvar sls = listeners[srcNodeId];\n\t\tif(!sls){\n\t\t\treturn;\n\t\t}\n\n\t\t//Generate listeners area for target.\n\t\tvar nodeId = nodeId = listenId++;\n\t\ttarget.setAttribute(eventAttr, nodeId);\n\t\tvar tls = listeners[nodeId] = {};\n\n\t\t//Loope through events in source. Protect against bad\n\t\t//code modifying Object.prototype.\n\t\tvar empty = {};\n\t\tfor (var evtName in sls){\n\t\t\tvar tEvtData = tls[evtName] = {\n\t\t\t\t_connectId: domConnect(target, evtName)\n\t\t\t};\n\t\t\tvar sEvtData = sls[evtName];\n\n\t\t\tfor (var evtFullName in sEvtData){\n\t\t\t\ttEvtData[evtFullName] = {\n\t\t\t\t\tfn: sEvtData[evtFullName].fn,\n\t\t\t\t\tdata: sEvtData[evtFullName].data\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction listenerUnbind(lls, evtName, evtFullName, callbackId, fn){\n\t\t//Handles the real remove of an event and dojo.disconnects DOM handler if necessary.\n\t\t//This has to be broken out of the main unbind function because we have to support\n\t\t//things like unbind(\".test\") that go across major event names. Yuck.\n\t\tvar handles = lls[evtName];\n\t\tif(handles){\n\t\t\tvar hasDot = evtFullName.indexOf(\".\") != -1;\n\t\t\tvar forceDelete = false;\n\n\t\t\tif(callbackId){\n\t\t\t\t//Only need to unbind that one callback\n\t\t\t\tdelete handles[callbackId];\n\t\t\t}else if(!hasDot && !fn){\n\t\t\t\tforceDelete = true;\n\t\t\t}else if(hasDot){\n\t\t\t\t//A namespaced event.\n\t\t\t\t//Problem is the namespaced event could be something like\n\t\t\t\t//\".test\" which means remove all that end in .test. Yuck.\n\t\t\t\tif(evtFullName.charAt(0) == \".\"){\n\t\t\t\t\tfor(var param in handles){\n\t\t\t\t\t\tif(param.indexOf(evtFullName) == param.length - evtFullName.length){\n\t\t\t\t\t\t\tdelete handles[param];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdelete handles[evtFullName];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//Not a namespaced event. Cycle through the $$ names\n\t\t\t\t//to find a function match.\n\t\t\t\tfor(var param in handles){\n\t\t\t\t\tif(param.indexOf(\"$$\") != -1 && handles[param].fn == fn){\n\t\t\t\t\t\tdelete handles[param];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Remove handles/disconnect dom if no other params.\n\t\t\tvar allDone = true;\n\t\t\tfor(var param in handles){\n\t\t\t\tif(param != \"_connectId\"){\n\t\t\t\t\tallDone = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(forceDelete || allDone){\n\t\t\t\tif(evtName.indexOf(\"ajax\") != -1){\n\t\t\t\t\tdojo.unsubscribe(handles._connectId);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.disconnect(handles._connectId);\n\t\t\t\t}\n\t\t\t\tdelete lls[evtName];\n\t\t\t}\n\t\t}\n\t}\n\n\tf.unbind = function(/*String*/type, /*Function*/fn){\n\t\t\n\t\t//See if event has a callbackId, if so, then we only unbind\n\t\t//that one callback.\n\t\tvar callbackId = type ? type[dojo._scopeName + \"callbackId\"] : null;\n\n\t\t//Type can be space separated values.\n\t\ttype = type && type.type ? type.type : type;\n\t\ttype = type ? type.split(\" \") : type;\n\n\t\tthis.forEach(function(node){\n\t\t\t//Only handle non text/comment nodes.\n\t\t\tif(node.nodeType != 3 && node.nodeType != 8){\n\t\t\t\t//If document, bind to documentElement\n\t\t\t\tif(node.nodeType == 9){\n\t\t\t\t\tnode = node.documentElement;\n\t\t\t\t}\n\n\t\t\t\t//If no nodeId, then create one and attach it to the DOM node.\n\t\t\t\tvar nodeId = node.getAttribute(eventAttr);\n\t\t\t\t\n\t\t\t\tif(nodeId){\n\t\t\t\t\t//Get the event listeners for the event name, the complete name.\n\t\t\t\t\tvar lls = listeners[nodeId];\n\t\t\t\t\tif(lls){\n\t\t\t\t\t\t//If no type, then it means do all bound types. Make a list of them.\n\t\t\t\t\t\tvar etypes = type;\n\t\t\t\t\t\tif(!etypes){\n\t\t\t\t\t\t\tetypes = [];\n\t\t\t\t\t\t\tfor(var param in lls){\n\t\t\t\t\t\t\t\tetypes.push(param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Process each event type.\n\t\t\t\t\t\tfor(var i = 0; i < etypes.length; i++){\n\t\t\t\t\t\t\t//Get event name, if have a dot on it, it is namespaced,\n\t\t\t\t\t\t\t//be sure to get the core event name.\n\t\t\t\t\t\t\tvar evtFullName = etypes[i];\n\t\t\t\t\t\t\tvar evtName = getNonNamespacedName(evtFullName);\n\t\t\t\n\t\t\t\t\t\t\t//Problem is the namespaced event could be something like\n\t\t\t\t\t\t\t//\".test\" which means remove all that end in .test. Yuck.\n\t\t\t\t\t\t\tif(evtFullName.charAt(0) == \".\"){\n\t\t\t\t\t\t\t\tfor(var param in lls) {\n\t\t\t\t\t\t\t\t\tlistenerUnbind(lls, param, evtFullName, callbackId, fn);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tlistenerUnbind(lls, evtName, evtFullName, callbackId, fn);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tf.one = function(/*String*/evtName, /*Function*/func){\n\t\tvar oneFunc = function(){\n\t\t\t$(this).unbind(evtName, arguments.callee);\n\t\t\treturn func.apply(this, arguments);\n\t\t}\n\n\t\treturn this.bind(evtName, oneFunc);\n\t};\n\n\tf._cloneNode = function(/*DOMNode*/ src){\n\t\t// summary:\n\t\t//\t\tprivate utiltity to clone a node. Copies event handlers too.\n\t\tvar target = src.cloneNode(true);\n\n\t\tif(src.nodeType == 1){\n\t\t\t//Look for event handlers in target.\n\t\t\tvar evNodes = dojo.query(\"[\" + eventAttr + \"]\", target);\n\t\t\tfor(var i = 0, newNode; newNode = evNodes[i]; i++){\n\t\t\t\tvar oldNode = dojo.query('[' + eventAttr + '=\"' + newNode.getAttribute(eventAttr) + '\"]', src)[0];\n\t\t\t\tif(oldNode){\n\t\t\t\t\tcopyEventHandlers(oldNode, newNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t};\n\n\t//Temporary testing shim to get past jquery test setup errors.\n\tdojo.getObject(\"$.event.global\", true);\n\n\t//Set up event handlers\n\tdojo.forEach([\n\t\t\"blur\", \"focus\", \"dblclick\", \"click\", \"error\", \"keydown\", \"keypress\", \"keyup\", \"load\", \"mousedown\",\n\t\t\"mouseenter\", \"mouseleave\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"submit\",\n\t\t\"ajaxStart\", \"ajaxSend\", \"ajaxSuccess\", \"ajaxError\", \"ajaxComplete\", \"ajaxStop\"\n\t\t], function(evt){\n\t\t\tf[evt] = function(callback){\n\t\t\t\tif(callback){\n\t\t\t\t\tthis.bind(evt, callback);\n\t\t\t\t}else{\n\t\t\t\t\tthis.trigger(evt);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\n\t//END jquery Events API methods\n\n\n\t//START jquery Effects API methods\n\t//http://docs.jquery.com/Effects\n\tfunction speedInt(speed){\n\t\t//Fix speed setting, translate string values to numbers.\n\t\tif(dojo.isString(speed)){\n\t\t\tif(speed == \"slow\"){\n\t\t\t\tspeed = 700;\n\t\t\t}else if(speed == \"fast\"){\n\t\t\t\tspeed = 300;\n\t\t\t}else{\n\t\t\t\t//Everything else is considered normal speed.\n\t\t\t\tspeed = 500;\n\t\t\t}\n\t\t}\n\t\treturn speed;\n\t}\n\t\n\tf.hide = function(/*String||Number*/speed, /*Function?*/callback){\n\t\t//Fix speed setting, translate string values to numbers.\n\t\tspeed = speedInt(speed);\n\n\t\tthis.forEach(function(node){\n\t\t\tvar style = node.style;\n\t\t\t\n\t\t\t//Skip if already hidden\n\t\t\tvar cs = dojo.getComputedStyle(node);\n\t\t\tif(cs.display == \"none\"){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tstyle.display = \"block\";\n\t\t\t\n\t\t\tif(speed){\n\t\t\t\t//It is alive!\n\t\t\t\tdojo.anim(\n\t\t\t\t\tnode,\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\theight: 0,\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t},\n\t\t\t\t\tspeed,\n\t\t\t\t\tnull,\n\t\t\t\t\tfunction(){\n\t\t\t\t\t\tstyle.width = \"\";\n\t\t\t\t\t\tstyle.height = \"\";\n\t\t\t\t\t\tstyle.display = \"none\";\n\t\t\t\t\t\treturn callback && callback.call(node);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}else{\n\t\t\t\t//No need for animation, fast path it.\n\t\t\t\tdojo.style(node, \"display\", \"none\");\n\t\t\t\tif(callback){\n\t\t\t\t\tcallback.call(node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tf.show = function(/*String||Number*/speed, /*Function?*/callback){\n\t\t//Fix speed setting, translate string values to numbers.\n\t\tspeed = speedInt(speed);\n\n\t\tthis.forEach(function(node){\n\t\t\tvar style = node.style;\n\t\t\t//Skip if the node is already showing.\n\t\t\tvar cs = dojo.getComputedStyle(node);\n\t\t\tif(cs.display != \"none\"){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(speed){\n\t\t\t\t//Figure out size of element\n\t\t\t\t//so we know when to stop animation.\n\t\t\t\t//Try the easy path first.\n\t\t\t\tvar width = parseFloat(style.width);\n\t\t\t\tvar height = parseFloat(style.height);\n\t\t\t\tif(!width || !height){\n\t\t\t\t\t//temporarily show the element to get\n\t\t\t\t\t//dimensions\n\t\t\t\t\tstyle.display = \"block\";\n\t\t\t\t\tvar box = dojo.marginBox(node);\n\t\t\t\t\twidth = box.w;\n\t\t\t\t\theight = box.h;\n\t\t\t\t}\n\n\t\t\t\t//Make sure values are set to hidden state.\n\t\t\t\tstyle.width = 0;\n\t\t\t\tstyle.height = 0;\n\t\t\t\tstyle.overflow = \"hidden\";\n\t\t\t\tdojo.attr(node, \"opacity\", 0);\n\t\t\t\tstyle.display = \"block\";\n\n\t\t\t\t//It is alive!\n\t\t\t\tdojo.anim(\n\t\t\t\t\tnode,\n\t\t\t\t\t{\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: height,\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t},\n\t\t\t\t\tspeed,\n\t\t\t\t\tnull,\n\t\t\t\t\tcallback ? dojo.hitch(node, callback) : undefined\n\t\t\t\t);\n\t\t\t}else{\n\t\t\t\tdojo.style(node, \"display\", \"block\");\n\t\t\t\tif(callback){\n\t\t\t\t\tcallback.call(node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\n\t//END jquery Effects API methods\n\n\n\t//START jquery Ajax API methods\n\t//http://docs.jquery.com/Ajax\n\t\n\t$.ajaxSettings = {\n\t};\n\n\t$.ajaxSetup = function(/*Object*/args){\n\t\tdojo.mixin($.ajaxSettings, args);\n\t}\n\n\tvar topics = {\n\t\t\"ajaxStart\": \"/dojo/io/start\",\n\t\t\"ajaxSend\": \"/dojo/io/send\",\n\t\t\"ajaxSuccess\": \"/dojo/io/load\",\n\t\t\"ajaxError\": \"/dojo/io/error\",\n\t\t\"ajaxComplete\": \"/dojo/io/done\",\n\t\t\"ajaxStop\": \"/dojo/io/stop\"\n\t};\n\n\tfor(var fnName in topics){\n\t\t//Make sure we are dealing with properties\n\t\t//we care about and not something another toolkit added.\n\t\tif(fnName.indexOf(\"ajax\") == 0){\n\t\t\t;(function(fnName){\n\t\t\t\tf[fnName] = function(callback){\n\t\t\t\t\tthis.forEach(function(node){\n\t\t\t\t\t\tdojo.subscribe(topics[fnName], function(){\n\t\t\t\t\t\t\tvar fakeEvt = new $.Event(fnName);\n\t\t\t\t\t\t\tvar ioArgs = arguments[0] && arguments[0].ioArgs;\n\t\t\t\t\t\t\tvar xhr = ioArgs && ioArgs.xhr;\n\t\t\t\t\t\t\tvar args = ioArgs && ioArgs.args;\n\t\t\t\t\t\t\tvar res = arguments[1];\n\t\t\t\t\t\t\tif(\"ajaxComplete|ajaxSend|ajaxSuccess\".indexOf(fnName) != -1){\n\t\t\t\t\t\t\t\treturn callback.call(node, fakeEvt, xhr, args);\n\t\t\t\t\t\t\t}else if(fnName == \"ajaxError\"){\n\t\t\t\t\t\t\t\treturn callback.call(node, fakeEvt, xhr, args, res);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t//ajaxStart|ajaxStop\n\t\t\t\t\t\t\t\treturn callback.call(node, fakeEvt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t})(fnName);\n\t\t}\n\t};\n\n\t//Override dojo._xhrObj(dfd.ioArgs.args) to support beforeSend\n\t//Do not understand the reason for beforeSend, particularly\n\t//returning false stops the request.\n\t//WARNING: even with this code, the error and complete callbacks\n\t//will be fired because the deferred is cancelled. I feel this is\n\t//correct behavior for dojo, and not sure why beforeSend is needed.\n\tvar _oldXhrObj = dojo._xhrObj;\n\tdojo._xhrObj = function(args){\n\t\tvar xhr = _oldXhrObj.apply(dojo, arguments);\n\t\tif(args && args.beforeSend){\n\t\t\tif(args.beforeSend(xhr) === false){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn xhr;\n\t}\n\n\t$.ajax = function(/*Object*/args){\n\t\t//Not sure if the args are considered mutable.\n\t\t//Copy them to be safe.\n\t\tvar temp = dojo.delegate($.ajaxSettings);\n\t\tfor(var param in args){\n\t\t\t//For data objects merge the data do not overwrite.\n\t\t\tif(param == \"data\" && dojo.isObject(args[param]) && dojo.isObject(temp.data)){\n\t\t\t\tfor(var prop in args[param]){\n\t\t\t\t\ttemp.data[prop] = args[param][prop];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ttemp[param] = args[param];\n\t\t\t}\n\t\t}\n\t\targs = temp;\n\t\tvar url = args.url;\n\n\t\tif(\"async\" in args){\n\t\t\targs.sync = !args.async;\n\t\t}\n\n\t\t//Turn off topic publications\n\t\tif(args.global === false){\n\t\t\targs.ioPublish = false;\n\t\t}\n\n\t\tif(args.data){\n\t\t\tvar data = args.data;\n\t\t\tif(dojo.isString(data)){\n\t\t\t\t//convert to an object.\n\t\t\t\targs.content = dojo.queryToObject(data);\n\t\t\t}else{\n\t\t\t\t//data property values could be a function, be sure to call them if so.\n\t\t\t\t//Hmm, this seems to be of dubious value.\n\t\t\t\tfor(var param in data){\n\t\t\t\t\tif(dojo.isFunction(data[param])){\n\t\t\t\t\t\tdata[param] = data[param]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.content = data;\n\t\t\t}\n\t\t}\n\n\t\t//dataType\n\t\tvar dataType = args.dataType;\n\t\tif(\"dataType\" in args){\n\t\t\tif(dataType == \"script\"){\n\t\t\t\tdataType = \"javascript\";\n\t\t\t}else if(dataType == \"html\"){\n\t\t\t\tdataType = \"text\";\n\t\t\t}\n\t\t\targs.handleAs = dataType;\n\t\t}else{\n\t\t\t//Make a guess based on the URL.\n\t\t\tdataType = args.handleAs = \"text\";\n\t\t\targs.guessedType = true;\n\t\t}\n\n\t\t//cache:\n\t\tif(\"cache\" in args){\n\t\t\targs.preventCache = !args.cache;\n\t\t}else{\n\t\t\tif(args.dataType == \"script\" || args.dataType == \"jsonp\"){\n\t\t\t\targs.preventCache = true;\n\t\t\t}\n\t\t}\n\n\t\t//Hide error since dojo treats it different.\n\t\tif(args.error){\n\t\t\targs._jqueryError = args.error;\n\t\t\tdelete args.error;\n\t\t}\n\t\t\n\t\t//TODO: dataFilter\n\n\t\t//Set up callbacks.\n\t\targs.handle = function(result, ioArgs){\n\t\t\tvar textStatus = \"success\";\n\t\t\tif(result instanceof Error){\n\t\t\t\ttextStatus = (result.dojoType == \"timeout\" ? \"timeout\" : \"error\");\n\t\t\t\tif(args._jqueryError){\n\t\t\t\t\targs._jqueryError(ioArgs.xhr, textStatus, result);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//If we guessed the type, see if it should be XML.\n\t\t\t\tvar xml = (ioArgs.args.guessedType && ioArgs.xhr && ioArgs.xhr.responseXML);\n\t\t\t\tif(xml){\n\t\t\t\t\tresult = xml;\n\t\t\t\t}\n\n\t\t\t\tif(args.success){\n\t\t\t\t\targs.success(result, textStatus, ioArgs.xhr);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(args.complete){\n\t\t\t\targs.complete(result, textStatus, ioArgs.xhr);\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t};\n\t\t\n\t\t//Use a script tag if the request is xdomain or a jsonp thing.\n\t\tvar useScript = (dataType == \"jsonp\");\n\t\tif(dataType == \"javascript\"){\n\t\t\t//Get protocol and domain.\n\t\t\tvar colonIndex = url.indexOf(\":\");\n\t\t\tvar slashIndex = url.indexOf(\"/\");\n\t\t\tif(colonIndex > 0 && colonIndex < slashIndex){\n\t\t\t\t//Possibly xdomain. Peel off protocol and hostname to find out.\n\t\t\t\tvar lastSlash = url.indexOf(\"/\", slashIndex + 2);\n\t\t\t\tif(lastSlash == -1){\n\t\t\t\t\tlastSlash = url.length;\n\t\t\t\t}\n\t\t\t\tif(location.protocol != url.substring(0, colonIndex + 1) ||\n\t\t\t\t\tlocation.hostname != url.substring(slashIndex + 2, lastSlash)){\n\t\t\t\t\tuseScript = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(useScript){\n\t\t\tif(dataType == \"jsonp\"){\n\t\t\t\t//Look for callback param\n\t\t\t\tvar cb = args.jsonp;\n\t\t\t\tif(!cb){\n\t\t\t\t\t//Look in the URL\n\t\t\t\t\tvar params = args.url.split(\"?\")[1];\n\t\t\t\t\tif(params && (params = dojo.queryToObject(params))){\n\t\t\t\t\t\tcb = findJsonpCallback(params);\n\t\t\t\t\t\tif(cb){\n\t\t\t\t\t\t\t//Remove the cb from the url.\n\t\t\t\t\t\t\tvar regex = new RegExp(\"([&\\\\?])?\" + cb + \"=?\");\n\t\t\t\t\t\t\targs.url = args.url.replace(regex + \"=?\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//Look in the content.\n\t\t\t\t\tif(!cb){\n\t\t\t\t\t\tcb = findJsonpCallback(args.content);\n\t\t\t\t\t\tif(cb){\n\t\t\t\t\t\t\tdelete args.content[cb];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\targs.jsonp = cb || \"callback\";\n\t\t\t}\n\t\t\tvar dfd = dojo.io.script.get(args);\n\t\t\treturn dfd;\n\t\t}else{\n\t\t\tvar dfd = dojo.xhr(args.type || \"GET\", args);\n\t\t\t//If the XHR object is false, it means beforeSend canceled the request.\n\t\t\treturn dfd.ioArgs.xhr === false ? false : dfd.ioArgs.xhr;\n\t\t}\n\t}\n\n\tfunction findJsonpCallback(obj){\n\t\tfor(var prop in obj){\n\t\t\tif(prop.indexOf(\"callback\") == prop.length - 8){\n\t\t\t\treturn prop;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t$.getpost = function(httpType, url, data, callback, dataType){\n\t\tvar args = {\n\t\t\turl: url,\n\t\t\ttype: httpType\n\t\t};\n\n\t\t//Normalize data, considering it may be the real\n\t\t//callback.\n\t\tif(data){\n\t\t\tif(dojo.isFunction(data) && !callback){\n\t\t\t\targs.complete = data;\n\t\t\t}else{\n\t\t\t\targs.data = data;\n\t\t\t}\n\t\t}\n\n\t\t//Normalize callback, considering it may be\n\t\t//the datatype.\n\t\tif(callback){\n\t\t\tif(dojo.isString(callback) && !dataType){\n\t\t\t\tdataType = callback;\n\t\t\t}else{\n\t\t\t\targs.complete = callback;\n\t\t\t}\n\t\t}\n\n\t\tif(dataType){\n\t\t\targs.dataType = dataType;\n\t\t}\n\n\t\treturn $.ajax(args);\n\t};\n\n\t$.get = dojo.hitch($, \"getpost\", \"GET\");\n\t$.post = dojo.hitch($, \"getpost\", \"POST\");\n\t$.getJSON = function(url, data, callback){\n\t\treturn $.getpost(\"GET\", url, data, callback, \"json\");\n\t}\n\t$.getScript = function(url, callback){\n\t\treturn $.ajax({\n\t\t\turl: url,\n\t\t\tsuccess: callback,\n\t\t\tdataType: \"script\"\n\t\t});\n\t}\n\n\tf.load = function(url, data, callback){\n\t\t\n\t\t//See if this is a window or document. If so, then want to\n\t\t//register onload handler.\n\t\tvar node = this[0];\n\t\tif(!node || !node.nodeType || node.nodeType == 9){\n\t\t\tdojo.addOnLoad(url);\n\t\t\treturn this;\n\t\t}\n\n\t\t//The rest of this function is the ajax HTML load case.\n\t\t//Pull off selector if it is on the url.\n\t\tvar parts = url.split(/\\s+/);\n\t\turl = parts[0];\n\t\tvar query = parts[1];\n\t\t\n\t\tvar finalCb = callback || data;\n\n\t\tvar cb = dojo.hitch(this, function(result, textStatus, xhr){\n\t\t\t//Try to find all the body content.\n\t\t\tvar match = result.match(/\\<\\s*body[^>]+>.*<\\/body\\s*>/i);\n\t\t\tif(match){\n\t\t\t\tresult = match;\n\t\t\t}\n\n\t\t\t//Convert to DOM nodes.\n\t\t\tvar nodes = dojo._toDom(result);\n\n\t\t\t//Apply query, using a temp div to do the filtering.\n\t\t\tif(query){\n\t\t\t\tvar temp = $(dojo.create(\"div\"));\n\t\t\t\ttemp.append(nodes);\n\t\t\t\tnodes = temp.find(query);\n\t\t\t}else{\n\t\t\t\tnodes = $(nodes.nodeType == 11 ? nodes.childNodes : nodes);\n\t\t\t}\n\n\t\t\t//Add the HTML to all nodes in this node list.\n\t\t\tthis.html(nodes);\n\n\t\t\t//Call the user's callback.\n\t\t\t//Use a timeout to allow any embedded scripts that\n\t\t\t//were just inserted to run.\n\t\t\tif(finalCb){\n\t\t\t\tsetTimeout(dojo.hitch(this, function(){\n\t\t\t\t\tthis.forEach(function(node){\n\t\t\t\t\t\tfinalCb.call(node, result, textStatus, xhr);\n\t\t\t\t\t});\n\t\t\t\t}), 10);\n\t\t\t}\n\t\t});\n\n\t\t//Adjust parameters since they are variable.\n\t\tif(!callback){\n\t\t\tdata = cb;\n\t\t}else{\n\t\t\tcallback = cb;\n\t\t}\n\n\t\t//Set HTTP method. If the data is a string, use get, if it is an object,\n\t\t//use post.\n\t\tvar method = \"GET\";\n\t\tif(data && dojo.isObject(data)){\n\t\t\tmethod = \"POST\";\n\t\t}\n\n\t\t$.getpost(method, url, data, callback, \"html\");\n\t\treturn this;\n\t}\n\n\tvar serializeExclude = \"file|submit|image|reset|button|\";\n\tf.serialize = function(){\n\t\tvar ret = \"\";\n\t\tvar strs = this.map(function(node){\n\t\t\tif(node.nodeName.toUpperCase() == \"FORM\"){\n\t\t\t\treturn dojo.formToQuery(node);\n\t\t\t}else{\n\t\t\t\tvar type = (node.type||\"\").toLowerCase();\n\t\t\t\tif(serializeExclude.indexOf(type) == -1){\n\t\t\t\t\tvar val = dojo.fieldToObject(node);\n\t\t\t\t\tif(node.name && val != null){\n\t\t\t\t\t\tvar q = {};\n\t\t\t\t\t\tq[node.name] = val;\n\t\t\t\t\t\treturn dojo.objectToQuery(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn ret + strs.join(\"&\");\n\t}\n\n\t$.param = function(obj){\n\t\tif(obj._is$ && obj.serialize){\n\t\t\treturn obj.serialize();\n\t\t}else if(dojo.isArray(obj)){\n\t\t\treturn dojo.map(obj, function(item){\n\t\t\t\treturn $.param(item);\n\t\t\t}).join(\"&\");\n\t\t}else{\n\t\t\treturn dojo.objectToQuery(obj);\n\t\t}\n\t}\n\t\n\t//END jquery Ajax API methods\n\n\t//START jquery Utilities API methods\n\t//http://docs.jquery.com/Utilities\n\t//TODO:\n\t\n\t$.isFunction = function(){\n\t\tvar result = dojo.isFunction.apply(dojo, arguments);\n\t\t//Make sure Object does not return true\n\t\tif(result){\n\t\t\tresult = (typeof(arguments[0]) != \"object\");\n\t\t}\n\t\treturn result;\n\t}\n\n\t//END jquery Utilities API methods\n\n\t\n})();\n\n"], "filenames": ["jq.js"], "buggy_code_start_loc": [458], "buggy_code_end_loc": [459], "fixing_code_start_loc": [458], "fixing_code_end_loc": [459], "type": "CWE-74", "message": "In affected versions of dojox (NPM package), the jqMix method is vulnerable to Prototype Pollution. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values. This has been patched in versions 1.11.10, 1.12.8, 1.13.7, 1.14.6, 1.15.3 and 1.16.2", "other": {"cve": {"id": "CVE-2020-5259", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-10T18:15:12.203", "lastModified": "2020-03-11T21:15:11.830", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In affected versions of dojox (NPM package), the jqMix method is vulnerable to Prototype Pollution. Prototype Pollution refers to the ability to inject properties into existing JavaScript language construct prototypes, such as objects. An attacker manipulates these attributes to overwrite, or pollute, a JavaScript application object prototype of the base object by injecting other values. This has been patched in versions 1.11.10, 1.12.8, 1.13.7, 1.14.6, 1.15.3 and 1.16.2"}, {"lang": "es", "value": "En las versiones afectadas de dojox (paquete NPM), el m\u00e9todo jqMix es vulnerable a una Contaminaci\u00f3n de Prototipo. La Contaminaci\u00f3n de Prototipo se refiere a la capacidad de inyectar propiedades en prototipos de construcciones de lenguaje JavaScript existentes, tales como objetos. Un atacante manipula estos atributos para sobrescribir o contaminar un prototipo de objeto de la aplicaci\u00f3n JavaScript del objeto base mediante la inyecci\u00f3n de otros valores. Esto ha sido parcheado en las versiones 1.11.10, 1.12.8, 1.13.7, 1.14.6, 1.15.3 y 1.16.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dojox:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.11.10", "matchCriteriaId": "8FE926F0-90A5-4A7D-9C47-15B5D220D9AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dojox:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.12.0", "versionEndExcluding": "1.12.8", "matchCriteriaId": "B998EEAA-ED31-4484-B7FE-D984B1ED0A07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dojox:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.13.0", "versionEndExcluding": "1.13.7", "matchCriteriaId": "0A7B41CB-57BF-418C-B449-FFDA07D13BAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dojox:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.14.0", "versionEndExcluding": "1.14.6", "matchCriteriaId": "4273C6F4-9F0C-49D1-B18C-B333C767084A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dojox:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.15.0", "versionEndExcluding": "1.15.3", "matchCriteriaId": "4869AB30-553C-44D1-A946-AB51D440D2F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dojox:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "1.16.0", "versionEndExcluding": "1.16.2", "matchCriteriaId": "CCC82759-D49E-4D83-A4C1-7C59BE897A32"}]}]}], "references": [{"url": "https://github.com/dojo/dojox/commit/47d1b302b5b23d94e875b77b9b9a8c4f5622c9da", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dojo/dojox/security/advisories/GHSA-3hw5-q855-g6cw", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00012.html", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/dojo/dojox/commit/47d1b302b5b23d94e875b77b9b9a8c4f5622c9da"}}