{"buggy_code": ["<?php\n\n/**\n * Prime Finite Fields\n *\n * Utilizes the factory design pattern\n *\n * PHP version 5 and 7\n *\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2017 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://pear.php.net/package/Math_BigInteger\n */\n\nnamespace phpseclib3\\Math;\n\nuse phpseclib3\\Math\\Common\\FiniteField;\nuse phpseclib3\\Math\\PrimeField\\Integer;\n\n/**\n * Prime Finite Fields\n *\n * @author  Jim Wigginton <terrafrost@php.net>\n */\nclass PrimeField extends FiniteField\n{\n    /**\n     * Instance Counter\n     *\n     * @var int\n     */\n    private static $instanceCounter = 0;\n\n    /**\n     * Keeps track of current instance\n     *\n     * @var int\n     */\n    protected $instanceID;\n\n    /**\n     * Default constructor\n     */\n    public function __construct(BigInteger $modulo)\n    {\n        //if (!$modulo->isPrime()) {\n        //    throw new \\UnexpectedValueException('PrimeField requires a prime number be passed to the constructor');\n        //}\n\n        $this->instanceID = self::$instanceCounter++;\n        Integer::setModulo($this->instanceID, $modulo);\n        Integer::setRecurringModuloFunction($this->instanceID, $modulo->createRecurringModuloFunction());\n    }\n\n    /**\n     * Use a custom defined modular reduction function\n     *\n     * @return void\n     */\n    public function setReduction(\\Closure $func)\n    {\n        $this->reduce = $func->bindTo($this, $this);\n    }\n\n    /**\n     * Returns an instance of a dynamically generated PrimeFieldInteger class\n     *\n     * @return Integer\n     */\n    public function newInteger(BigInteger $num)\n    {\n        return new Integer($this->instanceID, $num);\n    }\n\n    /**\n     * Returns an integer on the finite field between one and the prime modulo\n     *\n     * @return Integer\n     */\n    public function randomInteger()\n    {\n        static $one;\n        if (!isset($one)) {\n            $one = new BigInteger(1);\n        }\n\n        return new Integer($this->instanceID, BigInteger::randomRange($one, Integer::getModulo($this->instanceID)));\n    }\n\n    /**\n     * Returns the length of the modulo in bytes\n     *\n     * @return int\n     */\n    public function getLengthInBytes()\n    {\n        return Integer::getModulo($this->instanceID)->getLengthInBytes();\n    }\n\n    /**\n     * Returns the length of the modulo in bits\n     *\n     * @return int\n     */\n    public function getLength()\n    {\n        return Integer::getModulo($this->instanceID)->getLength();\n    }\n\n    /**\n     *  Destructor\n     */\n    public function __destruct()\n    {\n        Integer::cleanupCache($this->instanceID);\n    }\n}\n", "<?php\n\n/**\n * Prime Finite Fields\n *\n * PHP version 5 and 7\n *\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2017 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n */\n\nnamespace phpseclib3\\Math\\PrimeField;\n\nuse phpseclib3\\Common\\Functions\\Strings;\nuse phpseclib3\\Math\\BigInteger;\nuse phpseclib3\\Math\\Common\\FiniteField\\Integer as Base;\n\n/**\n * Prime Finite Fields\n *\n * @author  Jim Wigginton <terrafrost@php.net>\n */\nclass Integer extends Base\n{\n    /**\n     * Holds the PrimeField's value\n     *\n     * @var BigInteger\n     */\n    protected $value;\n\n    /**\n     * Keeps track of current instance\n     *\n     * @var int\n     */\n    protected $instanceID;\n\n    /**\n     * Holds the PrimeField's modulo\n     *\n     * @var array<int, BigInteger>\n     */\n    protected static $modulo;\n\n    /**\n     * Holds a pre-generated function to perform modulo reductions\n     *\n     * @var array<int, callable(BigInteger):BigInteger>\n     */\n    protected static $reduce;\n\n    /**\n     * Zero\n     *\n     * @var BigInteger\n     */\n    protected static $zero;\n\n    /**\n     * Default constructor\n     *\n     * @param int $instanceID\n     */\n    public function __construct($instanceID, BigInteger $num = null)\n    {\n        $this->instanceID = $instanceID;\n        if (!isset($num)) {\n            $this->value = clone static::$zero[static::class];\n        } else {\n            $reduce = static::$reduce[$instanceID];\n            $this->value = $reduce($num);\n        }\n    }\n\n    /**\n     * Set the modulo for a given instance\n     *\n     * @param int $instanceID\n     * @return void\n     */\n    public static function setModulo($instanceID, BigInteger $modulo)\n    {\n        static::$modulo[$instanceID] = $modulo;\n    }\n\n    /**\n     * Set the modulo for a given instance\n     *\n     * @param int $instanceID\n     * @return void\n     */\n    public static function setRecurringModuloFunction($instanceID, callable $function)\n    {\n        static::$reduce[$instanceID] = $function;\n        if (!isset(static::$zero[static::class])) {\n            static::$zero[static::class] = new BigInteger();\n        }\n    }\n\n    /**\n     * Delete the modulo for a given instance\n     */\n    public static function cleanupCache($instanceID)\n    {\n        unset(static::$modulo[$instanceID]);\n        unset(static::$reduce[$instanceID]);\n    }\n\n    /**\n     * Returns the modulo\n     *\n     * @param int $instanceID\n     * @return BigInteger\n     */\n    public static function getModulo($instanceID)\n    {\n        return static::$modulo[$instanceID];\n    }\n\n    /**\n     * Tests a parameter to see if it's of the right instance\n     *\n     * Throws an exception if the incorrect class is being utilized\n     *\n     * @return void\n     */\n    public static function checkInstance(self $x, self $y)\n    {\n        if ($x->instanceID != $y->instanceID) {\n            throw new \\UnexpectedValueException('The instances of the two PrimeField\\Integer objects do not match');\n        }\n    }\n\n    /**\n     * Tests the equality of two numbers.\n     *\n     * @return bool\n     */\n    public function equals(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        return $this->value->equals($x->value);\n    }\n\n    /**\n     * Compares two numbers.\n     *\n     * @return int\n     */\n    public function compare(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        return $this->value->compare($x->value);\n    }\n\n    /**\n     * Adds two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function add(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        $temp = new static($this->instanceID);\n        $temp->value = $this->value->add($x->value);\n        if ($temp->value->compare(static::$modulo[$this->instanceID]) >= 0) {\n            $temp->value = $temp->value->subtract(static::$modulo[$this->instanceID]);\n        }\n\n        return $temp;\n    }\n\n    /**\n     * Subtracts two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function subtract(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        $temp = new static($this->instanceID);\n        $temp->value = $this->value->subtract($x->value);\n        if ($temp->value->isNegative()) {\n            $temp->value = $temp->value->add(static::$modulo[$this->instanceID]);\n        }\n\n        return $temp;\n    }\n\n    /**\n     * Multiplies two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function multiply(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        return new static($this->instanceID, $this->value->multiply($x->value));\n    }\n\n    /**\n     * Divides two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function divide(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        $denominator = $x->value->modInverse(static::$modulo[$this->instanceID]);\n        return new static($this->instanceID, $this->value->multiply($denominator));\n    }\n\n    /**\n     * Performs power operation on a PrimeFieldInteger.\n     *\n     * @return static\n     */\n    public function pow(BigInteger $x)\n    {\n        $temp = new static($this->instanceID);\n        $temp->value = $this->value->powMod($x, static::$modulo[$this->instanceID]);\n\n        return $temp;\n    }\n\n    /**\n     * Calculates the square root\n     *\n     * @link https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm\n     * @return static|false\n     */\n    public function squareRoot()\n    {\n        static $one, $two;\n        if (!isset($one)) {\n            $one = new BigInteger(1);\n            $two = new BigInteger(2);\n        }\n        $reduce = static::$reduce[$this->instanceID];\n        $p_1 = static::$modulo[$this->instanceID]->subtract($one);\n        $q = clone $p_1;\n        $s = BigInteger::scan1divide($q);\n        list($pow) = $p_1->divide($two);\n        for ($z = $one; !$z->equals(static::$modulo[$this->instanceID]); $z = $z->add($one)) {\n            $temp = $z->powMod($pow, static::$modulo[$this->instanceID]);\n            if ($temp->equals($p_1)) {\n                break;\n            }\n        }\n\n        $m = new BigInteger($s);\n        $c = $z->powMod($q, static::$modulo[$this->instanceID]);\n        $t = $this->value->powMod($q, static::$modulo[$this->instanceID]);\n        list($temp) = $q->add($one)->divide($two);\n        $r = $this->value->powMod($temp, static::$modulo[$this->instanceID]);\n\n        while (!$t->equals($one)) {\n            $i = clone $one;\n\n            while (!$t->powMod($two->pow($i), static::$modulo[$this->instanceID])->equals($one)) {\n                $i = $i->add($one);\n            }\n\n            if ($i->compare($m) >= 0) {\n                return false;\n            }\n            $b = $c->powMod($two->pow($m->subtract($i)->subtract($one)), static::$modulo[$this->instanceID]);\n            $m = $i;\n            $c = $reduce($b->multiply($b));\n            $t = $reduce($t->multiply($c));\n            $r = $reduce($r->multiply($b));\n        }\n\n        return new static($this->instanceID, $r);\n    }\n\n    /**\n     * Is Odd?\n     *\n     * @return bool\n     */\n    public function isOdd()\n    {\n        return $this->value->isOdd();\n    }\n\n    /**\n     * Negate\n     *\n     * A negative number can be written as 0-12. With modulos, 0 is the same thing as the modulo\n     * so 0-12 is the same thing as modulo-12\n     *\n     * @return static\n     */\n    public function negate()\n    {\n        return new static($this->instanceID, static::$modulo[$this->instanceID]->subtract($this->value));\n    }\n\n    /**\n     * Converts an Integer to a byte string (eg. base-256).\n     *\n     * @return string\n     */\n    public function toBytes()\n    {\n        $length = static::$modulo[$this->instanceID]->getLengthInBytes();\n        return str_pad($this->value->toBytes(), $length, \"\\0\", STR_PAD_LEFT);\n    }\n\n    /**\n     * Converts an Integer to a hex string (eg. base-16).\n     *\n     * @return string\n     */\n    public function toHex()\n    {\n        return Strings::bin2hex($this->toBytes());\n    }\n\n    /**\n     * Converts an Integer to a bit string (eg. base-2).\n     *\n     * @return string\n     */\n    public function toBits()\n    {\n        // return $this->value->toBits();\n        static $length;\n        if (!isset($length)) {\n            $length = static::$modulo[$this->instanceID]->getLength();\n        }\n\n        return str_pad($this->value->toBits(), $length, '0', STR_PAD_LEFT);\n    }\n\n    /**\n     * Returns the w-ary non-adjacent form (wNAF)\n     *\n     * @param int $w optional\n     * @return array<int, int>\n     */\n    public function getNAF($w = 1)\n    {\n        $w++;\n\n        $mask = new BigInteger((1 << $w) - 1);\n        $sub = new BigInteger(1 << $w);\n        //$sub = new BigInteger(1 << ($w - 1));\n        $d = $this->toBigInteger();\n        $d_i = [];\n\n        $i = 0;\n        while ($d->compare(static::$zero[static::class]) > 0) {\n            if ($d->isOdd()) {\n                // start mods\n\n                $bigInteger = $d->testBit($w - 1) ?\n                    $d->bitwise_and($mask)->subtract($sub) :\n                    //$sub->subtract($d->bitwise_and($mask)) :\n                    $d->bitwise_and($mask);\n                // end mods\n                $d = $d->subtract($bigInteger);\n                $d_i[$i] = (int) $bigInteger->toString();\n            } else {\n                $d_i[$i] = 0;\n            }\n            $shift = !$d->equals(static::$zero[static::class]) && $d->bitwise_and($mask)->equals(static::$zero[static::class]) ? $w : 1; // $w or $w + 1?\n            $d = $d->bitwise_rightShift($shift);\n            while (--$shift > 0) {\n                $d_i[++$i] = 0;\n            }\n            $i++;\n        }\n\n        return $d_i;\n    }\n\n    /**\n     * Converts an Integer to a BigInteger\n     *\n     * @return BigInteger\n     */\n    public function toBigInteger()\n    {\n        return clone $this->value;\n    }\n\n    /**\n     *  __toString() magic method\n     *\n     * @return string\n     */\n    public function __toString()\n    {\n        return (string) $this->value;\n    }\n\n    /**\n     *  __debugInfo() magic method\n     *\n     * @return array\n     */\n    public function __debugInfo()\n    {\n        return ['value' => $this->toHex()];\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Prime Finite Fields\n *\n * Utilizes the factory design pattern\n *\n * PHP version 5 and 7\n *\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2017 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n * @link      http://pear.php.net/package/Math_BigInteger\n */\n\nnamespace phpseclib3\\Math;\n\nuse phpseclib3\\Math\\Common\\FiniteField;\nuse phpseclib3\\Math\\PrimeField\\Integer;\n\n/**\n * Prime Finite Fields\n *\n * @author  Jim Wigginton <terrafrost@php.net>\n */\nclass PrimeField extends FiniteField\n{\n    /**\n     * Instance Counter\n     *\n     * @var int\n     */\n    private static $instanceCounter = 0;\n\n    /**\n     * Keeps track of current instance\n     *\n     * @var int\n     */\n    protected $instanceID;\n\n    /**\n     * Default constructor\n     */\n    public function __construct(BigInteger $modulo)\n    {\n        if (!$modulo->isPrime()) {\n            throw new \\UnexpectedValueException('PrimeField requires a prime number be passed to the constructor');\n        }\n\n        $this->instanceID = self::$instanceCounter++;\n        Integer::setModulo($this->instanceID, $modulo);\n        Integer::setRecurringModuloFunction($this->instanceID, $modulo->createRecurringModuloFunction());\n    }\n\n    /**\n     * Use a custom defined modular reduction function\n     *\n     * @return void\n     */\n    public function setReduction(\\Closure $func)\n    {\n        $this->reduce = $func->bindTo($this, $this);\n    }\n\n    /**\n     * Returns an instance of a dynamically generated PrimeFieldInteger class\n     *\n     * @return Integer\n     */\n    public function newInteger(BigInteger $num)\n    {\n        return new Integer($this->instanceID, $num);\n    }\n\n    /**\n     * Returns an integer on the finite field between one and the prime modulo\n     *\n     * @return Integer\n     */\n    public function randomInteger()\n    {\n        static $one;\n        if (!isset($one)) {\n            $one = new BigInteger(1);\n        }\n\n        return new Integer($this->instanceID, BigInteger::randomRange($one, Integer::getModulo($this->instanceID)));\n    }\n\n    /**\n     * Returns the length of the modulo in bytes\n     *\n     * @return int\n     */\n    public function getLengthInBytes()\n    {\n        return Integer::getModulo($this->instanceID)->getLengthInBytes();\n    }\n\n    /**\n     * Returns the length of the modulo in bits\n     *\n     * @return int\n     */\n    public function getLength()\n    {\n        return Integer::getModulo($this->instanceID)->getLength();\n    }\n\n    /**\n     *  Destructor\n     */\n    public function __destruct()\n    {\n        Integer::cleanupCache($this->instanceID);\n    }\n}\n", "<?php\n\n/**\n * Prime Finite Fields\n *\n * PHP version 5 and 7\n *\n * @author    Jim Wigginton <terrafrost@php.net>\n * @copyright 2017 Jim Wigginton\n * @license   http://www.opensource.org/licenses/mit-license.html  MIT License\n */\n\nnamespace phpseclib3\\Math\\PrimeField;\n\nuse phpseclib3\\Common\\Functions\\Strings;\nuse phpseclib3\\Math\\BigInteger;\nuse phpseclib3\\Math\\Common\\FiniteField\\Integer as Base;\n\n/**\n * Prime Finite Fields\n *\n * @author  Jim Wigginton <terrafrost@php.net>\n */\nclass Integer extends Base\n{\n    /**\n     * Holds the PrimeField's value\n     *\n     * @var BigInteger\n     */\n    protected $value;\n\n    /**\n     * Keeps track of current instance\n     *\n     * @var int\n     */\n    protected $instanceID;\n\n    /**\n     * Holds the PrimeField's modulo\n     *\n     * @var array<int, BigInteger>\n     */\n    protected static $modulo;\n\n    /**\n     * Holds a pre-generated function to perform modulo reductions\n     *\n     * @var array<int, callable(BigInteger):BigInteger>\n     */\n    protected static $reduce;\n\n    /**\n     * Zero\n     *\n     * @var BigInteger\n     */\n    protected static $zero;\n\n    /**\n     * Default constructor\n     *\n     * @param int $instanceID\n     */\n    public function __construct($instanceID, BigInteger $num = null)\n    {\n        $this->instanceID = $instanceID;\n        if (!isset($num)) {\n            $this->value = clone static::$zero[static::class];\n        } else {\n            $reduce = static::$reduce[$instanceID];\n            $this->value = $reduce($num);\n        }\n    }\n\n    /**\n     * Set the modulo for a given instance\n     *\n     * @param int $instanceID\n     * @return void\n     */\n    public static function setModulo($instanceID, BigInteger $modulo)\n    {\n        static::$modulo[$instanceID] = $modulo;\n    }\n\n    /**\n     * Set the modulo for a given instance\n     *\n     * @param int $instanceID\n     * @return void\n     */\n    public static function setRecurringModuloFunction($instanceID, callable $function)\n    {\n        static::$reduce[$instanceID] = $function;\n        if (!isset(static::$zero[static::class])) {\n            static::$zero[static::class] = new BigInteger();\n        }\n    }\n\n    /**\n     * Delete the modulo for a given instance\n     */\n    public static function cleanupCache($instanceID)\n    {\n        unset(static::$modulo[$instanceID]);\n        unset(static::$reduce[$instanceID]);\n    }\n\n    /**\n     * Returns the modulo\n     *\n     * @param int $instanceID\n     * @return BigInteger\n     */\n    public static function getModulo($instanceID)\n    {\n        return static::$modulo[$instanceID];\n    }\n\n    /**\n     * Tests a parameter to see if it's of the right instance\n     *\n     * Throws an exception if the incorrect class is being utilized\n     *\n     * @return void\n     */\n    public static function checkInstance(self $x, self $y)\n    {\n        if ($x->instanceID != $y->instanceID) {\n            throw new \\UnexpectedValueException('The instances of the two PrimeField\\Integer objects do not match');\n        }\n    }\n\n    /**\n     * Tests the equality of two numbers.\n     *\n     * @return bool\n     */\n    public function equals(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        return $this->value->equals($x->value);\n    }\n\n    /**\n     * Compares two numbers.\n     *\n     * @return int\n     */\n    public function compare(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        return $this->value->compare($x->value);\n    }\n\n    /**\n     * Adds two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function add(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        $temp = new static($this->instanceID);\n        $temp->value = $this->value->add($x->value);\n        if ($temp->value->compare(static::$modulo[$this->instanceID]) >= 0) {\n            $temp->value = $temp->value->subtract(static::$modulo[$this->instanceID]);\n        }\n\n        return $temp;\n    }\n\n    /**\n     * Subtracts two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function subtract(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        $temp = new static($this->instanceID);\n        $temp->value = $this->value->subtract($x->value);\n        if ($temp->value->isNegative()) {\n            $temp->value = $temp->value->add(static::$modulo[$this->instanceID]);\n        }\n\n        return $temp;\n    }\n\n    /**\n     * Multiplies two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function multiply(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        return new static($this->instanceID, $this->value->multiply($x->value));\n    }\n\n    /**\n     * Divides two PrimeFieldIntegers.\n     *\n     * @return static\n     */\n    public function divide(self $x)\n    {\n        static::checkInstance($this, $x);\n\n        $denominator = $x->value->modInverse(static::$modulo[$this->instanceID]);\n        return new static($this->instanceID, $this->value->multiply($denominator));\n    }\n\n    /**\n     * Performs power operation on a PrimeFieldInteger.\n     *\n     * @return static\n     */\n    public function pow(BigInteger $x)\n    {\n        $temp = new static($this->instanceID);\n        $temp->value = $this->value->powMod($x, static::$modulo[$this->instanceID]);\n\n        return $temp;\n    }\n\n    /**\n     * Calculates the square root\n     *\n     * @link https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm\n     * @return static|false\n     */\n    public function squareRoot()\n    {\n        static $one, $two;\n        if (!isset($one)) {\n            $one = new BigInteger(1);\n            $two = new BigInteger(2);\n        }\n        $reduce = static::$reduce[$this->instanceID];\n        $p_1 = static::$modulo[$this->instanceID]->subtract($one);\n        $q = clone $p_1;\n        $s = BigInteger::scan1divide($q);\n        list($pow) = $p_1->divide($two);\n        for ($z = $one; !$z->equals(static::$modulo[$this->instanceID]); $z = $z->add($one)) {\n            $temp = $z->powMod($pow, static::$modulo[$this->instanceID]);\n            if ($temp->equals($p_1)) {\n                break;\n            }\n        }\n\n        $m = new BigInteger($s);\n        $c = $z->powMod($q, static::$modulo[$this->instanceID]);\n        $t = $this->value->powMod($q, static::$modulo[$this->instanceID]);\n        list($temp) = $q->add($one)->divide($two);\n        $r = $this->value->powMod($temp, static::$modulo[$this->instanceID]);\n\n        while (!$t->equals($one)) {\n            for ($i == clone $one; $i->compare($m) < 0; $i = $i->add($one)) {\n                if ($t->powMod($two->pow($i), static::$modulo[$this->instanceID])->equals($one)) {\n                    break;\n                }\n            }\n\n            if ($i->compare($m) == 0) {\n                return false;\n            }\n            $b = $c->powMod($two->pow($m->subtract($i)->subtract($one)), static::$modulo[$this->instanceID]);\n            $m = $i;\n            $c = $reduce($b->multiply($b));\n            $t = $reduce($t->multiply($c));\n            $r = $reduce($r->multiply($b));\n        }\n\n        return new static($this->instanceID, $r);\n    }\n\n    /**\n     * Is Odd?\n     *\n     * @return bool\n     */\n    public function isOdd()\n    {\n        return $this->value->isOdd();\n    }\n\n    /**\n     * Negate\n     *\n     * A negative number can be written as 0-12. With modulos, 0 is the same thing as the modulo\n     * so 0-12 is the same thing as modulo-12\n     *\n     * @return static\n     */\n    public function negate()\n    {\n        return new static($this->instanceID, static::$modulo[$this->instanceID]->subtract($this->value));\n    }\n\n    /**\n     * Converts an Integer to a byte string (eg. base-256).\n     *\n     * @return string\n     */\n    public function toBytes()\n    {\n        $length = static::$modulo[$this->instanceID]->getLengthInBytes();\n        return str_pad($this->value->toBytes(), $length, \"\\0\", STR_PAD_LEFT);\n    }\n\n    /**\n     * Converts an Integer to a hex string (eg. base-16).\n     *\n     * @return string\n     */\n    public function toHex()\n    {\n        return Strings::bin2hex($this->toBytes());\n    }\n\n    /**\n     * Converts an Integer to a bit string (eg. base-2).\n     *\n     * @return string\n     */\n    public function toBits()\n    {\n        // return $this->value->toBits();\n        static $length;\n        if (!isset($length)) {\n            $length = static::$modulo[$this->instanceID]->getLength();\n        }\n\n        return str_pad($this->value->toBits(), $length, '0', STR_PAD_LEFT);\n    }\n\n    /**\n     * Returns the w-ary non-adjacent form (wNAF)\n     *\n     * @param int $w optional\n     * @return array<int, int>\n     */\n    public function getNAF($w = 1)\n    {\n        $w++;\n\n        $mask = new BigInteger((1 << $w) - 1);\n        $sub = new BigInteger(1 << $w);\n        //$sub = new BigInteger(1 << ($w - 1));\n        $d = $this->toBigInteger();\n        $d_i = [];\n\n        $i = 0;\n        while ($d->compare(static::$zero[static::class]) > 0) {\n            if ($d->isOdd()) {\n                // start mods\n\n                $bigInteger = $d->testBit($w - 1) ?\n                    $d->bitwise_and($mask)->subtract($sub) :\n                    //$sub->subtract($d->bitwise_and($mask)) :\n                    $d->bitwise_and($mask);\n                // end mods\n                $d = $d->subtract($bigInteger);\n                $d_i[$i] = (int) $bigInteger->toString();\n            } else {\n                $d_i[$i] = 0;\n            }\n            $shift = !$d->equals(static::$zero[static::class]) && $d->bitwise_and($mask)->equals(static::$zero[static::class]) ? $w : 1; // $w or $w + 1?\n            $d = $d->bitwise_rightShift($shift);\n            while (--$shift > 0) {\n                $d_i[++$i] = 0;\n            }\n            $i++;\n        }\n\n        return $d_i;\n    }\n\n    /**\n     * Converts an Integer to a BigInteger\n     *\n     * @return BigInteger\n     */\n    public function toBigInteger()\n    {\n        return clone $this->value;\n    }\n\n    /**\n     *  __toString() magic method\n     *\n     * @return string\n     */\n    public function __toString()\n    {\n        return (string) $this->value;\n    }\n\n    /**\n     *  __debugInfo() magic method\n     *\n     * @return array\n     */\n    public function __debugInfo()\n    {\n        return ['value' => $this->toHex()];\n    }\n}\n"], "filenames": ["phpseclib/Math/PrimeField.php", "phpseclib/Math/PrimeField/Integer.php"], "buggy_code_start_loc": [47, 266], "buggy_code_end_loc": [50, 273], "fixing_code_start_loc": [47, 266], "fixing_code_end_loc": [50, 273], "type": "CWE-835", "message": "Math/PrimeField.php in phpseclib 3.x before 3.0.19 has an infinite loop with composite primefields.", "other": {"cve": {"id": "CVE-2023-27560", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-03T06:15:08.653", "lastModified": "2023-03-10T18:54:55.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Math/PrimeField.php in phpseclib 3.x before 3.0.19 has an infinite loop with composite primefields."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:phpseclib:phpseclib:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.19", "matchCriteriaId": "D2243A87-8051-428C-8C5F-6FB463E453BB"}]}]}], "references": [{"url": "https://github.com/phpseclib/phpseclib/commit/6298d1cd55c3ffa44533bd41906caec246b60440", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/phpseclib/phpseclib/releases/tag/3.0.19", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/phpseclib/phpseclib/commit/6298d1cd55c3ffa44533bd41906caec246b60440"}}