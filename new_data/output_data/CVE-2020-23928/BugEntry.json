{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthor: Romain Bouqueau, Jean Le Feuvre\n *\t\t\tCopyright (c) Romain Bouqueau 2012- Telecom Paris 2019-\n *\t\t\t\tAll rights reserved\n *\n *          Note: this development was kindly sponsorized by Vizion'R (http://vizionr.com)\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid abst_box_del(GF_Box *s)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->movie_identifier)\n\t\tgf_free(ptr->movie_identifier);\n\tif (ptr->drm_data)\n\t\tgf_free(ptr->drm_data);\n\tif (ptr->meta_data)\n\t\tgf_free(ptr->meta_data);\n\n\twhile (gf_list_count(ptr->server_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->server_entry_table, 0));\n\t\tgf_list_rem(ptr->server_entry_table, 0);\n\t}\n\tgf_list_del(ptr->server_entry_table);\n\n\twhile (gf_list_count(ptr->quality_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->quality_entry_table, 0));\n\t\tgf_list_rem(ptr->quality_entry_table, 0);\n\t}\n\tgf_list_del(ptr->quality_entry_table);\n\n\n\twhile (gf_list_count(ptr->segment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->segment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->segment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->segment_run_table_entries);\n\n\twhile (gf_list_count(ptr->fragment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->fragment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_table_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size-8;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n\nGF_Box *abst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeBootstrapInfoBox, GF_ISOM_BOX_TYPE_ABST);\n\ttmp->server_entry_table = gf_list_new();\n\ttmp->quality_entry_table = gf_list_new();\n\ttmp->segment_run_table_entries = gf_list_new();\n\ttmp->fragment_run_table_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err abst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->bootstrapinfo_version);\n\tgf_bs_write_int(bs, ptr->profile, 2);\n\tgf_bs_write_int(bs, ptr->live, 1);\n\tgf_bs_write_int(bs, ptr->update, 1);\n\tgf_bs_write_int(bs, ptr->reserved, 4);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\tgf_bs_write_u64(bs, ptr->current_media_time);\n\tgf_bs_write_u64(bs, ptr->smpte_time_code_offset);\n\tif (ptr->movie_identifier)\n\t\tgf_bs_write_data(bs, ptr->movie_identifier, (u32)strlen(ptr->movie_identifier) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->server_entry_count);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->server_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tif (ptr->drm_data)\n\t\tgf_bs_write_data(bs, ptr->drm_data, (u32)strlen(ptr->drm_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->meta_data)\n\t\tgf_bs_write_data(bs, ptr->meta_data, (u32)strlen(ptr->meta_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->segment_run_table_count);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->segment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\tgf_bs_write_u8(bs, ptr->fragment_run_table_count);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err abst_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\ts->size += 25\n\t           + (ptr->movie_identifier ? (strlen(ptr->movie_identifier) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->server_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->server_entry_table, i)) + 1;\n\n\ts->size += 1;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_entry_table, i)) + 1;\n\n\ts->size += (ptr->drm_data ? (strlen(ptr->drm_data) + 1) : 1)\n\t           + (ptr->meta_data ? (strlen(ptr->meta_data) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->segment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\n\ts->size += 1;\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afra_box_del(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->local_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->local_access_entries, 0));\n\t\tgf_list_rem(ptr->local_access_entries, 0);\n\t}\n\tgf_list_del(ptr->local_access_entries);\n\n\twhile (gf_list_count(ptr->global_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->global_access_entries, 0));\n\t\tgf_list_rem(ptr->global_access_entries, 0);\n\t}\n\tgf_list_del(ptr->global_access_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->entry_count * (ptr->long_offsets ? 16 : 12))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragRandomAccessBox, GF_ISOM_BOX_TYPE_AFRA);\n\ttmp->local_access_entries = gf_list_new();\n\ttmp->global_access_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->long_ids, 1);\n\tgf_bs_write_int(bs, ptr->long_offsets, 1);\n\tgf_bs_write_int(bs, ptr->global_entries, 1);\n\tgf_bs_write_int(bs, 0, 5);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(ptr->local_access_entries, i);\n\t\tgf_bs_write_u64(bs, ae->time);\n\t\tif (ptr->long_offsets)\n\t\t\tgf_bs_write_u64(bs, ae->offset);\n\t\telse\n\t\t\tgf_bs_write_u32(bs, (u32)ae->offset);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tgf_bs_write_u32(bs, ptr->global_entry_count);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(ptr->global_access_entries, i);\n\t\t\tgf_bs_write_u64(bs, gae->time);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tgf_bs_write_u32(bs, gae->segment);\n\t\t\t\tgf_bs_write_u32(bs, gae->fragment);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->segment);\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->fragment);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tgf_bs_write_u64(bs, gae->afra_offset);\n\t\t\t\tgf_bs_write_u64(bs, gae->offset_from_afra);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->afra_offset);\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->offset_from_afra);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afra_box_size(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\ts->size += 9\n\t           + ptr->entry_count * (ptr->long_offsets ? 16 : 12)\n\t           + (ptr->global_entries ? 4 + ptr->global_entry_count * (4 + (ptr->long_offsets ? 16 : 8) + (ptr->long_ids ? 8 : 4)) : 0);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid asrt_box_del(GF_Box *s)\n{\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->segment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->segment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->segment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->segment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->segment_run_entry_count*8)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *asrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeSegmentRunTableBox, GF_ISOM_BOX_TYPE_ASRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->segment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err asrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->segment_run_entry_count);\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = (GF_AdobeSegmentRunEntry *)gf_list_get(ptr->segment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, sre->first_segment);\n\t\tgf_bs_write_u32(bs, sre->fragment_per_segment);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err asrt_box_size(GF_Box *s)\n{\n\tint i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += ptr->segment_run_entry_count * sizeof(GF_AdobeSegmentRunEntry);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afrt_box_del(GF_Box *s)\n{\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->fragment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->fragment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->fragment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size-8;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->fragment_run_entry_count*16)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_ISOM_INVALID_FILE;\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragmentRunTableBox, GF_ISOM_BOX_TYPE_AFRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->fragment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->fragment_run_entry_count);\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, fre->first_fragment);\n\t\tgf_bs_write_u64(bs, fre->first_fragment_timestamp);\n\t\tgf_bs_write_u32(bs, fre->fragment_duration);\n\t\tif (!fre->fragment_duration)\n\t\t\tgf_bs_write_u8(bs, fre->discontinuity_indicator);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afrt_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += 4;\n\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tif (fre->fragment_duration)\n\t\t\ts->size += 16;\n\t\telse\n\t\t\ts->size += 17;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthor: Romain Bouqueau, Jean Le Feuvre\n *\t\t\tCopyright (c) Romain Bouqueau 2012- Telecom Paris 2019-\n *\t\t\t\tAll rights reserved\n *\n *          Note: this development was kindly sponsorized by Vizion'R (http://vizionr.com)\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\n#ifndef GPAC_DISABLE_ISOM\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\nvoid abst_box_del(GF_Box *s)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tif (ptr == NULL) return;\n\n\tif (ptr->movie_identifier)\n\t\tgf_free(ptr->movie_identifier);\n\tif (ptr->drm_data)\n\t\tgf_free(ptr->drm_data);\n\tif (ptr->meta_data)\n\t\tgf_free(ptr->meta_data);\n\n\twhile (gf_list_count(ptr->server_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->server_entry_table, 0));\n\t\tgf_list_rem(ptr->server_entry_table, 0);\n\t}\n\tgf_list_del(ptr->server_entry_table);\n\n\twhile (gf_list_count(ptr->quality_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->quality_entry_table, 0));\n\t\tgf_list_rem(ptr->quality_entry_table, 0);\n\t}\n\tgf_list_del(ptr->quality_entry_table);\n\n\n\twhile (gf_list_count(ptr->segment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->segment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->segment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->segment_run_table_entries);\n\n\twhile (gf_list_count(ptr->fragment_run_table_entries)) {\n\t\tgf_isom_box_del((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, 0));\n\t\tgf_list_rem(ptr->fragment_run_table_entries, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_table_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\tint i;\n\tu32 tmp_strsize;\n\tchar *tmp_str;\n\tGF_Err e;\n\n\tISOM_DECREASE_SIZE(ptr, 25)\n\tptr->bootstrapinfo_version = gf_bs_read_u32(bs);\n\tptr->profile = gf_bs_read_int(bs, 2);\n\tptr->live = gf_bs_read_int(bs, 1);\n\tptr->update = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 4);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\tptr->current_media_time = gf_bs_read_u64(bs);\n\tptr->smpte_time_code_offset = gf_bs_read_u64(bs);\n\n\ti=0;\n\tif (ptr->size<8) return GF_ISOM_INVALID_FILE;\n\ttmp_strsize =(u32)ptr->size;\n\ttmp_str = gf_malloc(sizeof(char)*tmp_strsize);\n\tif (!tmp_str) return GF_OUT_OF_MEM;\n\tmemset(tmp_str, 0, sizeof(char)*tmp_strsize);\n\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->movie_identifier = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->server_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\ttmp_strsize=(u32)ptr->size;\n\t\twhile (tmp_strsize) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\n\t\tif (j) {\n\t\t\tgf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);\n\t\t}\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->drm_data = gf_strdup(tmp_str);\n\t}\n\n\ti=0;\n\ttmp_strsize=(u32)ptr->size;\n\twhile (tmp_strsize) {\n\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\ttmp_str[i] = gf_bs_read_u8(bs);\n\t\ttmp_strsize--;\n\t\tif (!tmp_str[i])\n\t\t\tbreak;\n\t\ti++;\n\t}\n\tif (i) {\n\t\tptr->meta_data = gf_strdup(tmp_str);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->segment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_AdobeSegmentRunTableBox *asrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&asrt, bs);\n\t\tif (e) {\n\t\t\tif (asrt) gf_isom_box_del((GF_Box*)asrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->segment_run_table_entries, asrt);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->fragment_run_table_count = gf_bs_read_u8(bs);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_AdobeFragmentRunTableBox *afrt = NULL;\n\t\te = gf_isom_box_parse((GF_Box **)&afrt, bs);\n\t\tif (e) {\n\t\t\tif (afrt) gf_isom_box_del((GF_Box*)afrt);\n\t\t\tgf_free(tmp_str);\n\t\t\treturn e;\n\t\t}\n\t\tgf_list_add(ptr->fragment_run_table_entries, afrt);\n\t}\n\n\tgf_free(tmp_str);\n\n\treturn GF_OK;\n}\n\nGF_Box *abst_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeBootstrapInfoBox, GF_ISOM_BOX_TYPE_ABST);\n\ttmp->server_entry_table = gf_list_new();\n\ttmp->quality_entry_table = gf_list_new();\n\ttmp->segment_run_table_entries = gf_list_new();\n\ttmp->fragment_run_table_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err abst_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->bootstrapinfo_version);\n\tgf_bs_write_int(bs, ptr->profile, 2);\n\tgf_bs_write_int(bs, ptr->live, 1);\n\tgf_bs_write_int(bs, ptr->update, 1);\n\tgf_bs_write_int(bs, ptr->reserved, 4);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\tgf_bs_write_u64(bs, ptr->current_media_time);\n\tgf_bs_write_u64(bs, ptr->smpte_time_code_offset);\n\tif (ptr->movie_identifier)\n\t\tgf_bs_write_data(bs, ptr->movie_identifier, (u32)strlen(ptr->movie_identifier) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->server_entry_count);\n\tfor (i=0; i<ptr->server_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->server_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_entry_table, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tif (ptr->drm_data)\n\t\tgf_bs_write_data(bs, ptr->drm_data, (u32)strlen(ptr->drm_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tif (ptr->meta_data)\n\t\tgf_bs_write_data(bs, ptr->meta_data, (u32)strlen(ptr->meta_data) + 1);\n\telse\n\t\tgf_bs_write_u8(bs, 0);\n\n\tgf_bs_write_u8(bs, ptr->segment_run_table_count);\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->segment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\tgf_bs_write_u8(bs, ptr->fragment_run_table_count);\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\te = gf_isom_box_write((GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i), bs);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Err abst_box_size(GF_Box *s)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;\n\n\ts->size += 25\n\t           + (ptr->movie_identifier ? (strlen(ptr->movie_identifier) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->server_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->server_entry_table, i)) + 1;\n\n\ts->size += 1;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_entry_table, i)) + 1;\n\n\ts->size += (ptr->drm_data ? (strlen(ptr->drm_data) + 1) : 1)\n\t           + (ptr->meta_data ? (strlen(ptr->meta_data) + 1) : 1)\n\t           + 1;\n\n\tfor (i=0; i<ptr->segment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->segment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\n\ts->size += 1;\n\tfor (i=0; i<ptr->fragment_run_table_count; i++) {\n\t\tGF_Box *box = (GF_Box *)gf_list_get(ptr->fragment_run_table_entries, i);\n\t\te = gf_isom_box_size(box);\n\t\tif (e) return e;\n\t\ts->size += box->size;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afra_box_del(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->local_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->local_access_entries, 0));\n\t\tgf_list_rem(ptr->local_access_entries, 0);\n\t}\n\tgf_list_del(ptr->local_access_entries);\n\n\twhile (gf_list_count(ptr->global_access_entries)) {\n\t\tgf_free(gf_list_get(ptr->global_access_entries, 0));\n\t\tgf_list_rem(ptr->global_access_entries, 0);\n\t}\n\tgf_list_del(ptr->global_access_entries);\n\n\tgf_free(ptr);\n}\n\nGF_Err afra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 9)\n\tptr->long_ids = gf_bs_read_int(bs, 1);\n\tptr->long_offsets = gf_bs_read_int(bs, 1);\n\tptr->global_entries = gf_bs_read_int(bs, 1);\n\tptr->reserved = gf_bs_read_int(bs, 5);\n\tptr->time_scale = gf_bs_read_u32(bs);\n\n\tptr->entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->entry_count * (ptr->long_offsets ? 16 : 12))\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry));\n\t\tif (!ae) return GF_OUT_OF_MEM;\n\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tae->time = gf_bs_read_u64(bs);\n\t\tif (ptr->long_offsets) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->offset = gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tae->offset = gf_bs_read_u32(bs);\n\t\t}\n\n\t\tgf_list_insert(ptr->local_access_entries, ae, i);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\tptr->global_entry_count = gf_bs_read_u32(bs);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry));\n\t\t\tif (!ae) return GF_OUT_OF_MEM;\n\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\tae->time = gf_bs_read_u64(bs);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->segment = gf_bs_read_u32(bs);\n\t\t\t\tae->fragment = gf_bs_read_u32(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\t\tae->segment = gf_bs_read_u16(bs);\n\t\t\t\tae->fragment = gf_bs_read_u16(bs);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\t\t\tae->afra_offset = gf_bs_read_u64(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u64(bs);\n\t\t\t} else {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\t\t\tae->afra_offset = gf_bs_read_u32(bs);\n\t\t\t\tae->offset_from_afra = gf_bs_read_u32(bs);\n\t\t\t}\n\n\t\t\tgf_list_insert(ptr->global_access_entries, ae, i);\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afra_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragRandomAccessBox, GF_ISOM_BOX_TYPE_AFRA);\n\ttmp->local_access_entries = gf_list_new();\n\ttmp->global_access_entries = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afra_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_int(bs, ptr->long_ids, 1);\n\tgf_bs_write_int(bs, ptr->long_offsets, 1);\n\tgf_bs_write_int(bs, ptr->global_entries, 1);\n\tgf_bs_write_int(bs, 0, 5);\n\tgf_bs_write_u32(bs, ptr->time_scale);\n\n\tgf_bs_write_u32(bs, ptr->entry_count);\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tGF_AfraEntry *ae = (GF_AfraEntry *)gf_list_get(ptr->local_access_entries, i);\n\t\tgf_bs_write_u64(bs, ae->time);\n\t\tif (ptr->long_offsets)\n\t\t\tgf_bs_write_u64(bs, ae->offset);\n\t\telse\n\t\t\tgf_bs_write_u32(bs, (u32)ae->offset);\n\t}\n\n\tif (ptr->global_entries) {\n\t\tgf_bs_write_u32(bs, ptr->global_entry_count);\n\t\tfor (i=0; i<ptr->global_entry_count; i++) {\n\t\t\tGF_GlobalAfraEntry *gae = (GF_GlobalAfraEntry *)gf_list_get(ptr->global_access_entries, i);\n\t\t\tgf_bs_write_u64(bs, gae->time);\n\t\t\tif (ptr->long_ids) {\n\t\t\t\tgf_bs_write_u32(bs, gae->segment);\n\t\t\t\tgf_bs_write_u32(bs, gae->fragment);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->segment);\n\t\t\t\tgf_bs_write_u16(bs, (u16)gae->fragment);\n\t\t\t}\n\t\t\tif (ptr->long_offsets) {\n\t\t\t\tgf_bs_write_u64(bs, gae->afra_offset);\n\t\t\t\tgf_bs_write_u64(bs, gae->offset_from_afra);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->afra_offset);\n\t\t\t\tgf_bs_write_u32(bs, (u32)gae->offset_from_afra);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afra_box_size(GF_Box *s)\n{\n\tGF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s;\n\n\ts->size += 9\n\t           + ptr->entry_count * (ptr->long_offsets ? 16 : 12)\n\t           + (ptr->global_entries ? 4 + ptr->global_entry_count * (4 + (ptr->long_offsets ? 16 : 8) + (ptr->long_ids ? 8 : 4)) : 0);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid asrt_box_del(GF_Box *s)\n{\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->segment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->segment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->segment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->segment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err asrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 1)\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, 4)\n\tptr->segment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->segment_run_entry_count*8)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = gf_malloc(sizeof(GF_AdobeSegmentRunEntry));\n\t\tif (!sre) return GF_OUT_OF_MEM;\n\t\tISOM_DECREASE_SIZE(ptr, 8)\n\t\tsre->first_segment = gf_bs_read_u32(bs);\n\t\tsre->fragment_per_segment = gf_bs_read_u32(bs);\n\t\tgf_list_insert(ptr->segment_run_entry_table, sre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *asrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeSegmentRunTableBox, GF_ISOM_BOX_TYPE_ASRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->segment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err asrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->segment_run_entry_count);\n\tfor (i=0; i<ptr->segment_run_entry_count; i++) {\n\t\tGF_AdobeSegmentRunEntry *sre = (GF_AdobeSegmentRunEntry *)gf_list_get(ptr->segment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, sre->first_segment);\n\t\tgf_bs_write_u32(bs, sre->fragment_per_segment);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err asrt_box_size(GF_Box *s)\n{\n\tint i;\n\tGF_AdobeSegmentRunTableBox *ptr = (GF_AdobeSegmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += ptr->segment_run_entry_count * sizeof(GF_AdobeSegmentRunEntry);\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nvoid afrt_box_del(GF_Box *s)\n{\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\tif (ptr == NULL) return;\n\n\twhile (gf_list_count(ptr->quality_segment_url_modifiers)) {\n\t\tgf_free(gf_list_get(ptr->quality_segment_url_modifiers, 0));\n\t\tgf_list_rem(ptr->quality_segment_url_modifiers, 0);\n\t}\n\tgf_list_del(ptr->quality_segment_url_modifiers);\n\n\twhile (gf_list_count(ptr->fragment_run_entry_table)) {\n\t\tgf_free(gf_list_get(ptr->fragment_run_entry_table, 0));\n\t\tgf_list_rem(ptr->fragment_run_entry_table, 0);\n\t}\n\tgf_list_del(ptr->fragment_run_entry_table);\n\n\tgf_free(ptr);\n}\n\nGF_Err afrt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 5)\n\tptr->timescale = gf_bs_read_u32(bs);\n\n\tptr->quality_entry_count = gf_bs_read_u8(bs);\n\tif (ptr->size < ptr->quality_entry_count)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tint j=0;\n\t\tu32 tmp_strsize=(u32)ptr->size-8;\n\t\tchar *tmp_str = (char*) gf_malloc(tmp_strsize);\n\t\tif (!tmp_str) return GF_OUT_OF_MEM;\n\t\twhile (tmp_strsize) {\n\t\t\ttmp_str[j] = gf_bs_read_u8(bs);\n\t\t\ttmp_strsize--;\n\t\t\tif (!tmp_str[j])\n\t\t\t\tbreak;\n\t\t\tj++;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, j)\n\t\tgf_list_insert(ptr->quality_segment_url_modifiers, tmp_str, i);\n\t}\n\n\tptr->fragment_run_entry_count = gf_bs_read_u32(bs);\n\tif (ptr->size < ptr->fragment_run_entry_count*16)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = gf_malloc(sizeof(GF_AdobeFragmentRunEntry));\n\t\tif (!fre) return GF_ISOM_INVALID_FILE;\n\t\tISOM_DECREASE_SIZE(ptr, 16)\n\t\tfre->first_fragment = gf_bs_read_u32(bs);\n\t\tfre->first_fragment_timestamp = gf_bs_read_u64(bs);\n\t\tfre->fragment_duration = gf_bs_read_u32(bs);\n\t\tif (!fre->fragment_duration) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 1)\n\t\t\tfre->discontinuity_indicator = gf_bs_read_u8(bs);\n\t\t}\n\t\tgf_list_insert(ptr->fragment_run_entry_table, fre, i);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_Box *afrt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFragmentRunTableBox, GF_ISOM_BOX_TYPE_AFRT);\n\ttmp->quality_segment_url_modifiers = gf_list_new();\n\ttmp->fragment_run_entry_table = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err afrt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tunsigned int i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u32(bs, ptr->timescale);\n\tgf_bs_write_u8(bs, ptr->quality_entry_count);\n\tfor (i=0; i<ptr->quality_entry_count; i++) {\n\t\tchar *str = (char*)gf_list_get(ptr->quality_segment_url_modifiers, i);\n\t\tgf_bs_write_data(bs, str, (u32)strlen(str) + 1);\n\t}\n\n\tgf_bs_write_u32(bs, ptr->fragment_run_entry_count);\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tgf_bs_write_u32(bs, fre->first_fragment);\n\t\tgf_bs_write_u64(bs, fre->first_fragment_timestamp);\n\t\tgf_bs_write_u32(bs, fre->fragment_duration);\n\t\tif (!fre->fragment_duration)\n\t\t\tgf_bs_write_u8(bs, fre->discontinuity_indicator);\n\t}\n\n\treturn GF_OK;\n}\n\n\nGF_Err afrt_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_AdobeFragmentRunTableBox *ptr = (GF_AdobeFragmentRunTableBox *)s;\n\n\ts->size += 5;\n\n\tfor (i=0; i<ptr->quality_entry_count; i++)\n\t\ts->size += strlen(gf_list_get(ptr->quality_segment_url_modifiers, i)) + 1;\n\n\ts->size += 4;\n\n\tfor (i=0; i<ptr->fragment_run_entry_count; i++) {\n\t\tGF_AdobeFragmentRunEntry *fre = (GF_AdobeFragmentRunEntry *)gf_list_get(ptr->fragment_run_entry_table, i);\n\t\tif (fre->fragment_duration)\n\t\t\ts->size += 16;\n\t\telse\n\t\t\ts->size += 17;\n\t}\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM_FRAGMENTS*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n\n#endif /*GPAC_DISABLE_ISOM_ADOBE*/\n"], "filenames": ["src/isomedia/box_code_adobe.c"], "buggy_code_start_loc": [96], "buggy_code_end_loc": [97], "fixing_code_start_loc": [96], "fixing_code_end_loc": [97], "type": "CWE-125", "message": "An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read.", "other": {"cve": {"id": "CVE-2020-23928", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-21T18:15:08.383", "lastModified": "2022-10-26T13:48:47.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read."}, {"lang": "es", "value": "Se detect\u00f3 un problema en gpac versiones anteriores a 1.0.1.&#xa0;La funci\u00f3n abst_box_read en el archivo box_code_adobe.c presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "CCA1FE1D-17AE-45F9-A7BD-A8316EE859D6"}]}]}], "references": [{"url": "https://cwe.mitre.org/data/definitions/126.html", "source": "cve@mitre.org", "tags": ["Technical Description"]}, {"url": "https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1568", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1569", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/8e05648d6b4459facbc783025c5c42d301fef5c3"}}