{"buggy_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h>\n\n/*-----------------------------------------------------------------------------\n * Hash type API\n *----------------------------------------------------------------------------*/\n\n/* Check the length of a number of objects to see if we need to convert a\n * listpack to a real hash. Note that we only check string encoded objects\n * as their string length can be queried in constant time. */\nvoid hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    size_t sum = 0;\n\n    if (o->encoding != OBJ_ENCODING_LISTPACK) return;\n\n    for (i = start; i <= end; i++) {\n        if (!sdsEncodedObject(argv[i]))\n            continue;\n        size_t len = sdslen(argv[i]->ptr);\n        if (len > server.hash_max_listpack_value) {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            return;\n        }\n        sum += len;\n    }\n    if (!lpSafeToAdd(o->ptr, sum))\n        hashTypeConvert(o, OBJ_ENCODING_HT);\n}\n\n/* Get the value from a listpack encoded hash, identified by field.\n * Returns -1 when the field cannot be found. */\nint hashTypeGetFromListpack(robj *o, sds field,\n                            unsigned char **vstr,\n                            unsigned int *vlen,\n                            long long *vll)\n{\n    unsigned char *zl, *fptr = NULL, *vptr = NULL;\n\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    zl = o->ptr;\n    fptr = lpFirst(zl);\n    if (fptr != NULL) {\n        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n        if (fptr != NULL) {\n            /* Grab pointer to the value (fptr points to the field) */\n            vptr = lpNext(zl, fptr);\n            serverAssert(vptr != NULL);\n        }\n    }\n\n    if (vptr != NULL) {\n        *vstr = lpGetValue(vptr, vlen, vll);\n        return 0;\n    }\n\n    return -1;\n}\n\n/* Get the value from a hash table encoded hash, identified by field.\n * Returns NULL when the field cannot be found, otherwise the SDS value\n * is returned. */\nsds hashTypeGetFromHashTable(robj *o, sds field) {\n    dictEntry *de;\n\n    serverAssert(o->encoding == OBJ_ENCODING_HT);\n\n    de = dictFind(o->ptr, field);\n    if (de == NULL) return NULL;\n    return dictGetVal(de);\n}\n\n/* Higher level function of hashTypeGet*() that returns the hash value\n * associated with the specified field. If the field is found C_OK\n * is returned, otherwise C_ERR. The returned object is returned by\n * reference in either *vstr and *vlen if it's returned in string form,\n * or stored in *vll if it's returned as a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * for C_OK and checking if vll (or vstr) is NULL. */\nint hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)\n            return C_OK;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        sds value;\n        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {\n            *vstr = (unsigned char*) value;\n            *vlen = sdslen(value);\n            return C_OK;\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_ERR;\n}\n\n/* Like hashTypeGetValue() but returns a Redis object, which is useful for\n * interaction with the hash type outside t_hash.c.\n * The function returns NULL if the field is not found in the hash. Otherwise\n * a newly allocated string object with the value is returned. */\nrobj *hashTypeGetValueObject(robj *o, sds field) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;\n    if (vstr) return createStringObject((char*)vstr,vlen);\n    else return createStringObjectFromLongLong(vll);\n}\n\n/* Higher level function using hashTypeGet*() to return the length of the\n * object associated with the requested field, or 0 if the field does not\n * exist. */\nsize_t hashTypeGetValueLength(robj *o, sds field) {\n    size_t len = 0;\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)\n        len = vstr ? vlen : sdigits10(vll);\n\n    return len;\n}\n\n/* Test if the specified field exists in the given hash. Returns 1 if the field\n * exists, and 0 when it doesn't. */\nint hashTypeExists(robj *o, sds field) {\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;\n}\n\n/* Add a new field, overwrite the old with the new value if it already exists.\n * Return 0 on insert and 1 on update.\n *\n * By default, the key and value SDS strings are copied if needed, so the\n * caller retains ownership of the strings passed. However this behavior\n * can be effected by passing appropriate flags (possibly bitwise OR-ed):\n *\n * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.\n * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.\n *\n * When the flags are used the caller does not need to release the passed\n * SDS string(s). It's up to the function to use the string to create a new\n * entry or to free the SDS string before returning to the caller.\n *\n * HASH_SET_COPY corresponds to no flags passed, and means the default\n * semantics of copying the values if needed.\n *\n */\n#define HASH_SET_TAKE_FIELD (1<<0)\n#define HASH_SET_TAKE_VALUE (1<<1)\n#define HASH_SET_COPY 0\nint hashTypeSet(robj *o, sds field, sds value, int flags) {\n    int update = 0;\n\n    /* Check if the field is too long for listpack, and convert before adding the item.\n     * This is needed for HINCRBY* case since in other commands this is handled early by\n     * hashTypeTryConversion, so this check will be a NOP. */\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    }\n    \n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr, *vptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Grab pointer to the value (fptr points to the field) */\n                vptr = lpNext(zl, fptr);\n                serverAssert(vptr != NULL);\n                update = 1;\n\n                /* Replace value */\n                zl = lpReplace(zl, &vptr, (unsigned char*)value, sdslen(value));\n            }\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the listpack */\n            zl = lpAppend(zl, (unsigned char*)field, sdslen(field));\n            zl = lpAppend(zl, (unsigned char*)value, sdslen(value));\n        }\n        o->ptr = zl;\n\n        /* Check if the listpack needs to be converted to a hash table */\n        if (hashTypeLength(o) > server.hash_max_listpack_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        dict *ht = o->ptr;\n        dictEntry *de, *existing;\n        sds v;\n        if (flags & HASH_SET_TAKE_VALUE) {\n            v = value;\n            value = NULL;\n        } else {\n            v = sdsdup(value);\n        }\n        de = dictAddRaw(ht, field, &existing);\n        if (de) {\n            dictSetVal(ht, de, v);\n            if (flags & HASH_SET_TAKE_FIELD) {\n                field = NULL;\n            } else {\n                dictSetKey(ht, de, sdsdup(field));\n            }\n        } else {\n            sdsfree(dictGetVal(existing));\n            dictSetVal(ht, existing, v);\n            update = 1;\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n\n    /* Free SDS strings we did not referenced elsewhere if the flags\n     * want this function to be responsible. */\n    if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);\n    if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);\n    return update;\n}\n\n/* Delete an element from a hash.\n * Return 1 on deleted and 0 on not found. */\nint hashTypeDelete(robj *o, sds field) {\n    int deleted = 0;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Delete both of the key and the value. */\n                zl = lpDeleteRangeWithEntry(zl,&fptr,2);\n                o->ptr = zl;\n                deleted = 1;\n            }\n        }\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete((dict*)o->ptr, field) == C_OK) {\n            deleted = 1;\n\n            /* Always check if the dictionary needs a resize after a delete. */\n            if (htNeedsResize(o->ptr)) dictResize(o->ptr);\n        }\n\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return deleted;\n}\n\n/* Return the number of elements in a hash. */\nunsigned long hashTypeLength(const robj *o) {\n    unsigned long length = ULONG_MAX;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        length = lpLength(o->ptr) / 2;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        length = dictSize((const dict*)o->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return length;\n}\n\nhashTypeIterator *hashTypeInitIterator(robj *subject) {\n    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));\n    hi->subject = subject;\n    hi->encoding = subject->encoding;\n\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        hi->fptr = NULL;\n        hi->vptr = NULL;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        hi->di = dictGetIterator(subject->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hi;\n}\n\nvoid hashTypeReleaseIterator(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(hi->di);\n    zfree(hi);\n}\n\n/* Move to the next entry in the hash. Return C_OK when the next entry\n * could be found and C_ERR when the iterator reaches the end. */\nint hashTypeNext(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl;\n        unsigned char *fptr, *vptr;\n\n        zl = hi->subject->ptr;\n        fptr = hi->fptr;\n        vptr = hi->vptr;\n\n        if (fptr == NULL) {\n            /* Initialize cursor */\n            serverAssert(vptr == NULL);\n            fptr = lpFirst(zl);\n        } else {\n            /* Advance cursor */\n            serverAssert(vptr != NULL);\n            fptr = lpNext(zl, vptr);\n        }\n        if (fptr == NULL) return C_ERR;\n\n        /* Grab pointer to the value (fptr points to the field) */\n        vptr = lpNext(zl, fptr);\n        serverAssert(vptr != NULL);\n\n        /* fptr, vptr now point to the first or next pair */\n        hi->fptr = fptr;\n        hi->vptr = vptr;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_OK;\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a listpack. Prototype is similar to `hashTypeGetFromListpack`. */\nvoid hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,\n                                 unsigned char **vstr,\n                                 unsigned int *vlen,\n                                 long long *vll)\n{\n    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (what & OBJ_HASH_KEY) {\n        *vstr = lpGetValue(hi->fptr, vlen, vll);\n    } else {\n        *vstr = lpGetValue(hi->vptr, vlen, vll);\n    }\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a hash table. Prototype is similar to\n * `hashTypeGetFromHashTable`. */\nsds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {\n    serverAssert(hi->encoding == OBJ_ENCODING_HT);\n\n    if (what & OBJ_HASH_KEY) {\n        return dictGetKey(hi->de);\n    } else {\n        return dictGetVal(hi->de);\n    }\n}\n\n/* Higher level function of hashTypeCurrent*() that returns the hash value\n * at current iterator position.\n *\n * The returned element is returned by reference in either *vstr and *vlen if\n * it's returned in string form, or stored in *vll if it's returned as\n * a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * type checking if vstr == NULL. */\nvoid hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        hashTypeCurrentFromListpack(hi, what, vstr, vlen, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds ele = hashTypeCurrentFromHashTable(hi, what);\n        *vstr = (unsigned char*) ele;\n        *vlen = sdslen(ele);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* Return the key or value at the current iterator position as a new\n * SDS string. */\nsds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);\n    if (vstr) return sdsnewlen(vstr,vlen);\n    return sdsfromlonglong(vll);\n}\n\nrobj *hashTypeLookupWriteOrCreate(client *c, robj *key) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (checkType(c,o,OBJ_HASH)) return NULL;\n\n    if (o == NULL) {\n        o = createHashObject();\n        dbAdd(c->db,key,o);\n    }\n    return o;\n}\n\n\nvoid hashTypeConvertListpack(robj *o, int enc) {\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (enc == OBJ_ENCODING_LISTPACK) {\n        /* Nothing to do... */\n\n    } else if (enc == OBJ_ENCODING_HT) {\n        hashTypeIterator *hi;\n        dict *dict;\n        int ret;\n\n        hi = hashTypeInitIterator(o);\n        dict = dictCreate(&hashDictType);\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(dict,hashTypeLength(o));\n\n        while (hashTypeNext(hi) != C_ERR) {\n            sds key, value;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(dict, key, value);\n            if (ret != DICT_OK) {\n                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */\n                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */\n                serverLogHexDump(LL_WARNING,\"listpack with dup elements dump\",\n                    o->ptr,lpBytes(o->ptr));\n                serverPanic(\"Listpack corruption detected\");\n            }\n        }\n        hashTypeReleaseIterator(hi);\n        zfree(o->ptr);\n        o->encoding = OBJ_ENCODING_HT;\n        o->ptr = dict;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid hashTypeConvert(robj *o, int enc) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        hashTypeConvertListpack(o, enc);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        serverPanic(\"Not implemented\");\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a hash object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *hashTypeDup(robj *o) {\n    robj *hobj;\n    hashTypeIterator *hi;\n\n    serverAssert(o->type == OBJ_HASH);\n\n    if(o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = o->ptr;\n        size_t sz = lpBytes(zl);\n        unsigned char *new_zl = zmalloc(sz);\n        memcpy(new_zl, zl, sz);\n        hobj = createObject(OBJ_HASH, new_zl);\n        hobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else if(o->encoding == OBJ_ENCODING_HT){\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, dictSize((const dict*)o->ptr));\n\n        hi = hashTypeInitIterator(o);\n        while (hashTypeNext(hi) != C_ERR) {\n            sds field, value;\n            sds newfield, newvalue;\n            /* Extract a field-value pair from an original hash object.*/\n            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);\n            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);\n            newfield = sdsdup(field);\n            newvalue = sdsdup(value);\n\n            /* Add a field-value pair to a new hash object. */\n            dictAdd(d,newfield,newvalue);\n        }\n        hashTypeReleaseIterator(hi);\n\n        hobj = createObject(OBJ_HASH, d);\n        hobj->encoding = OBJ_ENCODING_HT;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hobj;\n}\n\n/* Create a new sds string from the listpack entry. */\nsds hashSdsFromListpackEntry(listpackEntry *e) {\n    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);\n}\n\n/* Reply with bulk string from the listpack entry. */\nvoid hashReplyFromListpackEntry(client *c, listpackEntry *e) {\n    if (e->sval)\n        addReplyBulkCBuffer(c, e->sval, e->slen);\n    else\n        addReplyBulkLongLong(c, e->lval);\n}\n\n/* Return random element from a non empty hash.\n * 'key' and 'val' will be set to hold the element.\n * The memory in them is not to be freed or modified by the caller.\n * 'val' can be NULL in which case it's not extracted. */\nvoid hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {\n    if (hashobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);\n        sds s = dictGetKey(de);\n        key->sval = (unsigned char*)s;\n        key->slen = sdslen(s);\n        if (val) {\n            sds s = dictGetVal(de);\n            val->sval = (unsigned char*)s;\n            val->slen = sdslen(s);\n        }\n    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {\n        lpRandomPair(hashobj->ptr, hashsize, key, val);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n\n/*-----------------------------------------------------------------------------\n * Hash type commands\n *----------------------------------------------------------------------------*/\n\nvoid hsetnxCommand(client *c) {\n    robj *o;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n\n    if (hashTypeExists(o, c->argv[2]->ptr)) {\n        addReply(c, shared.czero);\n    } else {\n        hashTypeTryConversion(o,c->argv,2,3);\n        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);\n        addReply(c, shared.cone);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid hsetCommand(client *c) {\n    int i, created = 0;\n    robj *o;\n\n    if ((c->argc % 2) == 1) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,c->argc-1);\n\n    for (i = 2; i < c->argc; i += 2)\n        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);\n\n    /* HMSET (deprecated) and HSET return value is different. */\n    char *cmdname = c->argv[0]->ptr;\n    if (cmdname[1] == 's' || cmdname[1] == 'S') {\n        /* HSET */\n        addReplyLongLong(c, created);\n    } else {\n        /* HMSET */\n        addReply(c, shared.ok);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n    server.dirty += (c->argc - 2)/2;\n}\n\nvoid hincrbyCommand(client *c) {\n    long long value, incr, oldvalue;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {\n        if (vstr) {\n            if (string2ll((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not an integer\");\n                return;\n            }\n        } /* Else hashTypeGetValue() already stored it into &value */\n    } else {\n        value = 0;\n    }\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n    new = sdsfromlonglong(value);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyLongLong(c,value);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrby\",c->argv[1],c->db->id);\n    server.dirty++;\n}\n\nvoid hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n\nstatic void addHashFieldToReply(client *c, robj *o, sds field) {\n    if (o == NULL) {\n        addReplyNull(c);\n        return;\n    }\n\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {\n        if (vstr) {\n            addReplyBulkCBuffer(c, vstr, vlen);\n        } else {\n            addReplyBulkLongLong(c, vll);\n        }\n    } else {\n        addReplyNull(c);\n    }\n}\n\nvoid hgetCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addHashFieldToReply(c, o, c->argv[2]->ptr);\n}\n\nvoid hmgetCommand(client *c) {\n    robj *o;\n    int i;\n\n    /* Don't abort when the key cannot be found. Non-existing keys are empty\n     * hashes, where HMGET should respond with a series of null bulks. */\n    o = lookupKeyRead(c->db, c->argv[1]);\n    if (checkType(c,o,OBJ_HASH)) return;\n\n    addReplyArrayLen(c, c->argc-2);\n    for (i = 2; i < c->argc; i++) {\n        addHashFieldToReply(c, o, c->argv[i]->ptr);\n    }\n}\n\nvoid hdelCommand(client *c) {\n    robj *o;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (hashTypeDelete(o,c->argv[j]->ptr)) {\n            deleted++;\n            if (hashTypeLength(o) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hdel\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid hlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReplyLongLong(c,hashTypeLength(o));\n}\n\nvoid hstrlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));\n}\n\nstatic void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *vstr = NULL;\n        unsigned int vlen = UINT_MAX;\n        long long vll = LLONG_MAX;\n\n        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);\n        if (vstr)\n            addReplyBulkCBuffer(c, vstr, vlen);\n        else\n            addReplyBulkLongLong(c, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds value = hashTypeCurrentFromHashTable(hi, what);\n        addReplyBulkCBuffer(c, value, sdslen(value));\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid genericHgetallCommand(client *c, int flags) {\n    robj *o;\n    hashTypeIterator *hi;\n    int length, count = 0;\n\n    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?\n        shared.emptymap[c->resp] : shared.emptyarray;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))\n        == NULL || checkType(c,o,OBJ_HASH)) return;\n\n    /* We return a map if the user requested keys and values, like in the\n     * HGETALL case. Otherwise to use a flat array makes more sense. */\n    length = hashTypeLength(o);\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {\n        addReplyMapLen(c, length);\n    } else {\n        addReplyArrayLen(c, length);\n    }\n\n    hi = hashTypeInitIterator(o);\n    while (hashTypeNext(hi) != C_ERR) {\n        if (flags & OBJ_HASH_KEY) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            count++;\n        }\n        if (flags & OBJ_HASH_VALUE) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n            count++;\n        }\n    }\n\n    hashTypeReleaseIterator(hi);\n\n    /* Make sure we returned the right number of elements. */\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) count /= 2;\n    serverAssert(count == length);\n}\n\nvoid hkeysCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY);\n}\n\nvoid hvalsCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_VALUE);\n}\n\nvoid hgetallCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);\n}\n\nvoid hexistsCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);\n}\n\nvoid hscanCommand(client *c) {\n    robj *o;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    scanGenericCommand(c,o,cursor);\n}\n\nstatic void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {\n    for (unsigned long i = 0; i < count; i++) {\n        if (vals && c->resp > 2)\n            addReplyArrayLen(c,2);\n        if (keys[i].sval)\n            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);\n        else\n            addReplyBulkLongLong(c, keys[i].lval);\n        if (vals) {\n            if (vals[i].sval)\n                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);\n            else\n                addReplyBulkLongLong(c, vals[i].lval);\n        }\n    }\n}\n\n/* How many times bigger should be the hash compared to the requested size\n * for us to not use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define HRANDFIELD_SUB_STRATEGY_MUL 3\n\n/* If client is trying to ask for a very large number of random elements,\n * queuing may consume an unlimited amount of memory, so we want to limit\n * the number of randoms per time. */\n#define HRANDFIELD_RANDOM_SAMPLE_LIMIT 1000\n\nvoid hrandfieldWithCountCommand(client *c, long l, int withvalues) {\n    unsigned long count, size;\n    int uniq = 1;\n    robj *hash;\n\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,hash,OBJ_HASH)) return;\n    size = hashTypeLength(hash);\n\n    if(l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        count = -l;\n        uniq = 0;\n    }\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        if (withvalues && c->resp == 2)\n            addReplyArrayLen(c, count*2);\n        else\n            addReplyArrayLen(c, count);\n        if (hash->encoding == OBJ_ENCODING_HT) {\n            sds key, value;\n            while (count--) {\n                dictEntry *de = dictGetFairRandomKey(hash->ptr);\n                key = dictGetKey(de);\n                value = dictGetVal(de);\n                if (withvalues && c->resp > 2)\n                    addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c, key, sdslen(key));\n                if (withvalues)\n                    addReplyBulkCBuffer(c, value, sdslen(value));\n            }\n        } else if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            listpackEntry *keys, *vals = NULL;\n            unsigned long limit, sample_count;\n\n            limit = count > HRANDFIELD_RANDOM_SAMPLE_LIMIT ? HRANDFIELD_RANDOM_SAMPLE_LIMIT : count;\n            keys = zmalloc(sizeof(listpackEntry)*limit);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*limit);\n            while (count) {\n                sample_count = count > limit ? limit : count;\n                count -= sample_count;\n                lpRandomPairs(hash->ptr, sample_count, keys, vals);\n                hrandfieldReplyWithListpack(c, sample_count, keys, vals);\n            }\n            zfree(keys);\n            zfree(vals);\n        }\n        return;\n    }\n\n    /* Initiate reply count, RESP3 responds with nested array, RESP2 with flat one. */\n    long reply_size = count < size ? count : size;\n    if (withvalues && c->resp == 2)\n        addReplyArrayLen(c, reply_size*2);\n    else\n        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the hash: simply return the whole hash. */\n    if(count >= size) {\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n        while (hashTypeNext(hi) != C_ERR) {\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            if (withvalues)\n                addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n        }\n        hashTypeReleaseIterator(hi);\n        return;\n    }\n\n    /* CASE 3:\n     * The number of elements inside the hash is not greater than\n     * HRANDFIELD_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a hash from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the hash, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*HRANDFIELD_SUB_STRATEGY_MUL > size) {\n        dict *d = dictCreate(&sdsReplyDictType);\n        dictExpand(d, size);\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n\n        /* Add all the elements into the temporary dictionary. */\n        while ((hashTypeNext(hi)) != C_ERR) {\n            int ret = DICT_ERR;\n            sds key, value = NULL;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            if (withvalues)\n                value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(d, key, value);\n\n            serverAssert(ret == DICT_OK);\n        }\n        serverAssert(dictSize(d) == size);\n        hashTypeReleaseIterator(hi);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            sdsfree(dictGetVal(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n\n        /* Reply with what's in the dict and release memory */\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(d);\n        while ((de = dictNext(di)) != NULL) {\n            sds key = dictGetKey(de);\n            sds value = dictGetVal(de);\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, key);\n            if (withvalues)\n                addReplyBulkSds(c, value);\n        }\n\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n\n    /* CASE 4: We have a big hash compared to the requested number of elements.\n     * In this case we can simply get random elements from the hash and add\n     * to the temporary hash, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            /* it is inefficient to repeatedly pick one random element from a\n             * listpack. so we use this instead: */\n            listpackEntry *keys, *vals = NULL;\n            keys = zmalloc(sizeof(listpackEntry)*count);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*count);\n            serverAssert(lpRandomPairsUnique(hash->ptr, count, keys, vals) == count);\n            hrandfieldReplyWithListpack(c, count, keys, vals);\n            zfree(keys);\n            zfree(vals);\n            return;\n        }\n\n        /* Hashtable encoding (generic implementation) */\n        unsigned long added = 0;\n        listpackEntry key, value;\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, count);\n        while(added < count) {\n            hashTypeRandomElement(hash, size, &key, withvalues? &value : NULL);\n\n            /* Try to add the object to the dictionary. If it already exists\n            * free it, otherwise increment the number of objects we have\n            * in the result dictionary. */\n            sds skey = hashSdsFromListpackEntry(&key);\n            if (dictAdd(d,skey,NULL) != DICT_OK) {\n                sdsfree(skey);\n                continue;\n            }\n            added++;\n\n            /* We can reply right away, so that we don't need to store the value in the dict. */\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            hashReplyFromListpackEntry(c, &key);\n            if (withvalues)\n                hashReplyFromListpackEntry(c, &value);\n        }\n\n        /* Release memory */\n        dictRelease(d);\n    }\n}\n\n/* HRANDFIELD key [<count> [WITHVALUES]] */\nvoid hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}\n", "start_server {tags {\"hash\"}} {\n    test {HSET/HLEN - Small hash creation} {\n        array set smallhash {}\n        for {set i 0} {$i < 8} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists smallhash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset smallhash $key $val\n            set smallhash($key) $val\n        }\n        list [r hlen smallhash]\n    } {8}\n\n    test {Is the small hash encoded with a listpack?} {\n        assert_encoding listpack smallhash\n    }\n\n    proc create_hash {key entries} {\n        r del $key\n        foreach entry $entries {\n            r hset $key [lindex $entry 0] [lindex $entry 1]\n        }\n    }\n\n    proc get_keys {l} {\n        set res {}\n        foreach entry $l {\n            set key [lindex $entry 0]\n            lappend res $key\n        }\n        return $res\n    }\n\n    foreach {type contents} \"listpack {{a 1} {b 2} {c 3}} hashtable {{a 1} {b 2} {[randstring 70 90 alpha] 3}}\" {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-ziplist-value 10\n        create_hash myhash $contents\n        assert_encoding $type myhash\n\n        # coverage for objectComputeSize\n        assert_morethan [memory_usage myhash] 0\n\n        test \"HRANDFIELD - $type\" {\n            unset -nocomplain myhash\n            array set myhash {}\n            for {set i 0} {$i < 100} {incr i} {\n                set key [r hrandfield myhash]\n                set myhash($key) 1\n            }\n            assert_equal [lsort [get_keys $contents]] [lsort [array names myhash]]\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n    test \"HRANDFIELD with RESP3\" {\n        r hello 3\n        set res [r hrandfield myhash 3 withvalues]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 2\n\n        set res [r hrandfield myhash 3]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 1\n        r hello 2\n    }\n\n    test \"HRANDFIELD count of 0 is handled correctly\" {\n        r hrandfield myhash 0\n    } {}\n\n    test \"HRANDFIELD with <count> against non existing key\" {\n        r hrandfield nonexisting_key 100\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"HRANDFIELD count of 0 is handled correctly - emptyarray\" {\n        r hrandfield myhash 0\n    } {*0}\n\n    test \"HRANDFIELD with <count> against non existing key - emptyarray\" {\n        r hrandfield nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} \"\n        hashtable {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {[randstring 70 90 alpha] 10}}\n        listpack {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {10 j}} \" {\n        test \"HRANDFIELD with <count> - $type\" {\n            set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n            r config set hash-max-ziplist-value 10\n            create_hash myhash $contents\n            assert_encoding $type myhash\n\n            # create a dict for easy lookup\n            set mydict [dict create {*}[r hgetall myhash]]\n\n            # We'll stress different parts of the code, see the implementation\n            # of HRANDFIELD for more information, but basically there are\n            # four different code paths.\n\n            # PATH 1: Use negative count.\n\n            # 1) Check that it returns repeated elements with and without values.\n            set res [r hrandfield myhash -20]\n            assert_equal [llength $res] 20\n            set res [r hrandfield myhash -1001]\n            assert_equal [llength $res] 1001\n            # again with WITHVALUES\n            set res [r hrandfield myhash -20 withvalues]\n            assert_equal [llength $res] 40\n            set res [r hrandfield myhash -1001 withvalues]\n            assert_equal [llength $res] 2002\n\n            # Test random uniform distribution\n            # df = 9, 40 means 0.00001 probability\n            set res [r hrandfield myhash -1000]\n            assert_lessthan [chi_square_value $res] 40\n\n            # 2) Check that all the elements actually belong to the original hash.\n            foreach {key val} $res {\n                assert {[dict exists $mydict $key]}\n            }\n\n            # 3) Check that eventually all the elements are returned.\n            #    Use both WITHVALUES and without\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                if {[expr {$iterations % 2}] == 0} {\n                    set res [r hrandfield myhash -3 withvalues]\n                    foreach {key val} $res {\n                        dict append auxset $key $val\n                    }\n                } else {\n                    set res [r hrandfield myhash -3]\n                    foreach key $res {\n                        dict append auxset $key $val\n                    }\n                }\n                if {[lsort [dict keys $mydict]] eq\n                    [lsort [dict keys $auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {10 20} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] 10\n                assert_equal [lsort $res] [lsort [dict keys $mydict]]\n\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] 20\n                assert_equal [lsort $res] [lsort $mydict]\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n            foreach size {8 2} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] $size\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] [expr {$size * 2}]\n\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                foreach ele [dict keys $res] {\n                    assert {[dict exists $mydict $ele]}\n                }\n\n                # 2) Check that eventually all the elements are returned.\n                #    Use both WITHVALUES and without\n                unset -nocomplain auxset\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                set all_ele_return false\n                while {$iterations != 0} {\n                    incr iterations -1\n                    if {[expr {$iterations % 2}] == 0} {\n                        set res [r hrandfield myhash $size withvalues]\n                        foreach {key value} $res {\n                            dict append auxset $key $value\n                            lappend allkey $key\n                        }\n                    } else {\n                        set res [r hrandfield myhash $size]\n                        foreach key $res {\n                            dict append auxset $key\n                            lappend allkey $key\n                        }\n                    }\n                    if {[lsort [dict keys $mydict]] eq\n                        [lsort [dict keys $auxset]]} {\n                        set all_ele_return true\n                    }\n                }\n                assert_equal $all_ele_return true\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n\n    test {HSET/HLEN - Big hash creation} {\n        array set bighash {}\n        for {set i 0} {$i < 1024} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists bighash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset bighash $key $val\n            set bighash($key) $val\n        }\n        list [r hlen bighash]\n    } {1024}\n\n    test {Is the big hash encoded with an hash table?} {\n        assert_encoding hashtable bighash\n    }\n\n    test {HGET against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {$smallhash($k) ne [r hget smallhash $k]} {\n                set err \"$smallhash($k) != [r hget smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {$bighash($k) ne [r hget bighash $k]} {\n                set err \"$bighash($k) != [r hget bighash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against non existing key} {\n        set rv {}\n        lappend rv [r hget smallhash __123123123__]\n        lappend rv [r hget bighash __123123123__]\n        set _ $rv\n    } {{} {}}\n\n    test {HSET in update and insert mode} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hset smallhash $k newval1]\n        set smallhash($k) newval1\n        lappend rv [r hget smallhash $k]\n        lappend rv [r hset smallhash __foobar123__ newval]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hset bighash $k newval2]\n        set bighash($k) newval2\n        lappend rv [r hget bighash $k]\n        lappend rv [r hset bighash __foobar123__ newval]\n        lappend rv [r hdel smallhash __foobar123__]\n        lappend rv [r hdel bighash __foobar123__]\n        set _ $rv\n    } {0 newval1 1 0 newval2 1 1 1}\n\n    test {HSETNX target key missing - small hash} {\n        r hsetnx smallhash __123123123__ foo\n        r hget smallhash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - small hash} {\n        r hsetnx smallhash __123123123__ bar\n        set result [r hget smallhash __123123123__]\n        r hdel smallhash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSETNX target key missing - big hash} {\n        r hsetnx bighash __123123123__ foo\n        r hget bighash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - big hash} {\n        r hsetnx bighash __123123123__ bar\n        set result [r hget bighash __123123123__]\n        r hdel bighash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSET/HMSET wrong number of args} {\n        assert_error {*wrong number of arguments for 'hset' command} {r hset smallhash key1 val1 key2}\n        assert_error {*wrong number of arguments for 'hmset' command} {r hmset smallhash key1 val1 key2}\n    }\n\n    test {HMSET - small hash} {\n        set args {}\n        foreach {k v} [array get smallhash] {\n            set newval [randstring 0 8 alpha]\n            set smallhash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset smallhash {*}$args\n    } {OK}\n\n    test {HMSET - big hash} {\n        set args {}\n        foreach {k v} [array get bighash] {\n            set newval [randstring 0 8 alpha]\n            set bighash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset bighash {*}$args\n    } {OK}\n\n    test {HMGET against non existing key and fields} {\n        set rv {}\n        lappend rv [r hmget doesntexist __123123123__ __456456456__]\n        lappend rv [r hmget smallhash __123123123__ __456456456__]\n        lappend rv [r hmget bighash __123123123__ __456456456__]\n        set _ $rv\n    } {{{} {}} {{} {}} {{} {}}}\n\n    test {HMGET against wrong type} {\n        r set wrongtype somevalue\n        assert_error \"*wrong*\" {r hmget wrongtype field1 field2}\n    }\n\n    test {HMGET - small hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget smallhash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HMGET - big hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget bighash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HKEYS - small hash} {\n        lsort [r hkeys smallhash]\n    } [lsort [array names smallhash *]]\n\n    test {HKEYS - big hash} {\n        lsort [r hkeys bighash]\n    } [lsort [array names bighash *]]\n\n    test {HVALS - small hash} {\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals smallhash]]\n\n    test {HVALS - big hash} {\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals bighash]]\n\n    test {HGETALL - small hash} {\n        lsort [r hgetall smallhash]\n    } [lsort [array get smallhash]]\n\n    test {HGETALL - big hash} {\n        lsort [r hgetall bighash]\n    } [lsort [array get bighash]]\n\n    test {HDEL and return value} {\n        set rv {}\n        lappend rv [r hdel smallhash nokey]\n        lappend rv [r hdel bighash nokey]\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hget smallhash $k]\n        unset smallhash($k)\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hget bighash $k]\n        unset bighash($k)\n        set _ $rv\n    } {0 0 1 0 {} 1 0 {}}\n\n    test {HDEL - more than a single value} {\n        set rv {}\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 0 [r hdel myhash x y]\n        assert_equal 2 [r hdel myhash a c f]\n        r hgetall myhash\n    } {b 2}\n\n    test {HDEL - hash becomes empty before deleting all specified fields} {\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 3 [r hdel myhash a b c d e]\n        assert_equal 0 [r exists myhash]\n    }\n\n    test {HEXISTS} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hexists smallhash $k]\n        lappend rv [r hexists smallhash nokey]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hexists bighash $k]\n        lappend rv [r hexists bighash nokey]\n    } {1 0 1 0}\n\n    test {Is a ziplist encoded Hash promoted on big payload?} {\n        r hset smallhash foo [string repeat a 1024]\n        r debug object smallhash\n    } {*hashtable*} {needs:debug}\n\n    test {HINCRBY against non existing database key} {\n        r del htest\n        list [r hincrby htest foo 2]\n    } {2}\n\n    test {HINCRBY against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [r hincrby smallhash tmp 2]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 2]\n        lappend rv [r hget bighash tmp]\n    } {2 2 2 2}\n\n    test {HINCRBY against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [r hincrby smallhash tmp 3]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 3]\n        lappend rv [r hget bighash tmp]\n    } {5 5 5 5}\n\n    test {HINCRBY against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [r hincrby smallhash tmp 2] [r hincrby bighash tmp 2]\n    } {102 102}\n\n    test {HINCRBY over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 1] [r hincrby bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBY over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 17179869184] [r hincrby bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBY fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY can detect overflows} {\n        set e {}\n        r hset hash n -9223372036854775484\n        assert {[r hincrby hash n -1] == -9223372036854775485}\n        catch {r hincrby hash n -10000} e\n        set e\n    } {*overflow*}\n\n    test {HINCRBYFLOAT against non existing database key} {\n        r del htest\n        list [r hincrbyfloat htest foo 2.5]\n    } {2.5}\n\n    test {HINCRBYFLOAT against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 2.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {2.5 2.5 2.5 2.5}\n\n    test {HINCRBYFLOAT against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 3.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 3.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {6 6 6 6}\n\n    test {HINCRBYFLOAT against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [roundFloat [r hincrbyfloat smallhash tmp 2.5]] \\\n             [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n    } {102.5 102.5}\n\n    test {HINCRBYFLOAT over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 1] \\\n             [r hincrbyfloat bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBYFLOAT over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 17179869184] \\\n             [r hincrbyfloat bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle} {\n        r hset h f \"1\\x002\"\n        catch {r hincrbyfloat h f 1} err\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $err]\n    } {1}\n\n    test {HSTRLEN against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {[string length $smallhash($k)] ne [r hstrlen smallhash $k]} {\n                set err \"[string length $smallhash($k)] != [r hstrlen smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {[string length $bighash($k)] ne [r hstrlen bighash $k]} {\n                set err \"[string length $bighash($k)] != [r hstrlen bighash $k]\"\n                puts \"HSTRLEN and logical length mismatch:\"\n                puts \"key: $k\"\n                puts \"Logical content: $bighash($k)\"\n                puts \"Server  content: [r hget bighash $k]\"\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against non existing field} {\n        set rv {}\n        lappend rv [r hstrlen smallhash __123123123__]\n        lappend rv [r hstrlen bighash __123123123__]\n        set _ $rv\n    } {0 0}\n\n    test {HSTRLEN corner cases} {\n        set vals {\n            -9223372036854775808 9223372036854775807 9223372036854775808\n            {} 0 -1 x\n        }\n        foreach v $vals {\n            r hmset smallhash field $v\n            r hmset bighash field $v\n            set len1 [string length $v]\n            set len2 [r hstrlen smallhash field]\n            set len3 [r hstrlen bighash field]\n            assert {$len1 == $len2}\n            assert {$len2 == $len3}\n        }\n    }\n\n    test {HINCRBYFLOAT over hash-max-listpack-value encoded with a listpack} {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-listpack-value 8\n        \n        # hash's value exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hset smallhash tmp 0\n        r hset bighash tmp 0\n        r hincrbyfloat smallhash tmp 0.000005\n        r hincrbyfloat bighash tmp 0.0000005\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        # hash's field exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hincrbyfloat smallhash abcdefgh 1\n        r hincrbyfloat bighash abcdefghi 1\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        r config set hash-max-listpack-value $original_max_value\n    }\n\n    test {Hash ziplist regression test for large keys} {\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk a\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk b\n        r hget hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\n    } {b}\n\n    foreach size {10 512} {\n        test \"Hash fuzzing #1 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    set field [randomValue]\n                    set value [randomValue]\n                    r hset hash $field $value\n                    set hash($field) $value\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n\n        test \"Hash fuzzing #2 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    randpath {\n                        set field [randomValue]\n                        set value [randomValue]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        set field [randomSignedInt 512]\n                        set value [randomSignedInt 512]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        randpath {\n                            set field [randomValue]\n                        } {\n                            set field [randomSignedInt 512]\n                        }\n                        r hdel hash $field\n                        unset -nocomplain hash($field)\n                    }\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n    }\n\n    test {Stress test the hash ziplist -> hashtable encoding conversion} {\n        r config set hash-max-ziplist-entries 32\n        for {set j 0} {$j < 100} {incr j} {\n            r del myhash\n            for {set i 0} {$i < 64} {incr i} {\n                r hset myhash [randomValue] [randomValue]\n            }\n            assert_encoding hashtable myhash\n        }\n    }\n\n    # The following test can only be executed if we don't use Valgrind, and if\n    # we are using x86_64 architecture, because:\n    #\n    # 1) Valgrind has floating point limitations, no support for 80 bits math.\n    # 2) Other archs may have the same limits.\n    #\n    # 1.23 cannot be represented correctly with 64 bit doubles, so we skip\n    # the test, since we are only testing pretty printing here and is not\n    # a bug if the program outputs things like 1.299999...\n    if {!$::valgrind && [string match *x86_64* [exec uname -a]]} {\n        test {Test HINCRBYFLOAT for correct float representation (issue #2846)} {\n            r del myhash\n            assert {[r hincrbyfloat myhash float 1.23] eq {1.23}}\n            assert {[r hincrbyfloat myhash float 0.77] eq {2}}\n            assert {[r hincrbyfloat myhash float -0.1] eq {1.9}}\n        }\n    }\n\n    test {Hash ziplist of various encodings} {\n        r del k\n        config_set hash-max-ziplist-entries 1000000000\n        config_set hash-max-ziplist-value 1000000000\n        r hset k ZIP_INT_8B 127\n        r hset k ZIP_INT_16B 32767\n        r hset k ZIP_INT_32B 2147483647\n        r hset k ZIP_INT_64B 9223372036854775808\n        r hset k ZIP_INT_IMM_MIN 0\n        r hset k ZIP_INT_IMM_MAX 12\n        r hset k ZIP_STR_06B [string repeat x 31]\n        r hset k ZIP_STR_14B [string repeat x 8191]\n        r hset k ZIP_STR_32B [string repeat x 65535]\n        set k [r hgetall k]\n        set dump [r dump k]\n\n        # will be converted to dict at RESTORE\n        config_set hash-max-ziplist-entries 2\n        config_set sanitize-dump-payload no mayfail\n        r restore kk 0 $dump\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n    test {Hash ziplist of various encodings - sanitize dump} {\n        config_set sanitize-dump-payload yes mayfail\n        r restore kk 0 $dump replace\n        set k [r hgetall k]\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include <math.h>\n\n/*-----------------------------------------------------------------------------\n * Hash type API\n *----------------------------------------------------------------------------*/\n\n/* Check the length of a number of objects to see if we need to convert a\n * listpack to a real hash. Note that we only check string encoded objects\n * as their string length can be queried in constant time. */\nvoid hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    size_t sum = 0;\n\n    if (o->encoding != OBJ_ENCODING_LISTPACK) return;\n\n    for (i = start; i <= end; i++) {\n        if (!sdsEncodedObject(argv[i]))\n            continue;\n        size_t len = sdslen(argv[i]->ptr);\n        if (len > server.hash_max_listpack_value) {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            return;\n        }\n        sum += len;\n    }\n    if (!lpSafeToAdd(o->ptr, sum))\n        hashTypeConvert(o, OBJ_ENCODING_HT);\n}\n\n/* Get the value from a listpack encoded hash, identified by field.\n * Returns -1 when the field cannot be found. */\nint hashTypeGetFromListpack(robj *o, sds field,\n                            unsigned char **vstr,\n                            unsigned int *vlen,\n                            long long *vll)\n{\n    unsigned char *zl, *fptr = NULL, *vptr = NULL;\n\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    zl = o->ptr;\n    fptr = lpFirst(zl);\n    if (fptr != NULL) {\n        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n        if (fptr != NULL) {\n            /* Grab pointer to the value (fptr points to the field) */\n            vptr = lpNext(zl, fptr);\n            serverAssert(vptr != NULL);\n        }\n    }\n\n    if (vptr != NULL) {\n        *vstr = lpGetValue(vptr, vlen, vll);\n        return 0;\n    }\n\n    return -1;\n}\n\n/* Get the value from a hash table encoded hash, identified by field.\n * Returns NULL when the field cannot be found, otherwise the SDS value\n * is returned. */\nsds hashTypeGetFromHashTable(robj *o, sds field) {\n    dictEntry *de;\n\n    serverAssert(o->encoding == OBJ_ENCODING_HT);\n\n    de = dictFind(o->ptr, field);\n    if (de == NULL) return NULL;\n    return dictGetVal(de);\n}\n\n/* Higher level function of hashTypeGet*() that returns the hash value\n * associated with the specified field. If the field is found C_OK\n * is returned, otherwise C_ERR. The returned object is returned by\n * reference in either *vstr and *vlen if it's returned in string form,\n * or stored in *vll if it's returned as a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * for C_OK and checking if vll (or vstr) is NULL. */\nint hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)\n            return C_OK;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        sds value;\n        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {\n            *vstr = (unsigned char*) value;\n            *vlen = sdslen(value);\n            return C_OK;\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_ERR;\n}\n\n/* Like hashTypeGetValue() but returns a Redis object, which is useful for\n * interaction with the hash type outside t_hash.c.\n * The function returns NULL if the field is not found in the hash. Otherwise\n * a newly allocated string object with the value is returned. */\nrobj *hashTypeGetValueObject(robj *o, sds field) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;\n    if (vstr) return createStringObject((char*)vstr,vlen);\n    else return createStringObjectFromLongLong(vll);\n}\n\n/* Higher level function using hashTypeGet*() to return the length of the\n * object associated with the requested field, or 0 if the field does not\n * exist. */\nsize_t hashTypeGetValueLength(robj *o, sds field) {\n    size_t len = 0;\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)\n        len = vstr ? vlen : sdigits10(vll);\n\n    return len;\n}\n\n/* Test if the specified field exists in the given hash. Returns 1 if the field\n * exists, and 0 when it doesn't. */\nint hashTypeExists(robj *o, sds field) {\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;\n}\n\n/* Add a new field, overwrite the old with the new value if it already exists.\n * Return 0 on insert and 1 on update.\n *\n * By default, the key and value SDS strings are copied if needed, so the\n * caller retains ownership of the strings passed. However this behavior\n * can be effected by passing appropriate flags (possibly bitwise OR-ed):\n *\n * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.\n * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.\n *\n * When the flags are used the caller does not need to release the passed\n * SDS string(s). It's up to the function to use the string to create a new\n * entry or to free the SDS string before returning to the caller.\n *\n * HASH_SET_COPY corresponds to no flags passed, and means the default\n * semantics of copying the values if needed.\n *\n */\n#define HASH_SET_TAKE_FIELD (1<<0)\n#define HASH_SET_TAKE_VALUE (1<<1)\n#define HASH_SET_COPY 0\nint hashTypeSet(robj *o, sds field, sds value, int flags) {\n    int update = 0;\n\n    /* Check if the field is too long for listpack, and convert before adding the item.\n     * This is needed for HINCRBY* case since in other commands this is handled early by\n     * hashTypeTryConversion, so this check will be a NOP. */\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    }\n    \n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr, *vptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Grab pointer to the value (fptr points to the field) */\n                vptr = lpNext(zl, fptr);\n                serverAssert(vptr != NULL);\n                update = 1;\n\n                /* Replace value */\n                zl = lpReplace(zl, &vptr, (unsigned char*)value, sdslen(value));\n            }\n        }\n\n        if (!update) {\n            /* Push new field/value pair onto the tail of the listpack */\n            zl = lpAppend(zl, (unsigned char*)field, sdslen(field));\n            zl = lpAppend(zl, (unsigned char*)value, sdslen(value));\n        }\n        o->ptr = zl;\n\n        /* Check if the listpack needs to be converted to a hash table */\n        if (hashTypeLength(o) > server.hash_max_listpack_entries)\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        dict *ht = o->ptr;\n        dictEntry *de, *existing;\n        sds v;\n        if (flags & HASH_SET_TAKE_VALUE) {\n            v = value;\n            value = NULL;\n        } else {\n            v = sdsdup(value);\n        }\n        de = dictAddRaw(ht, field, &existing);\n        if (de) {\n            dictSetVal(ht, de, v);\n            if (flags & HASH_SET_TAKE_FIELD) {\n                field = NULL;\n            } else {\n                dictSetKey(ht, de, sdsdup(field));\n            }\n        } else {\n            sdsfree(dictGetVal(existing));\n            dictSetVal(ht, existing, v);\n            update = 1;\n        }\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n\n    /* Free SDS strings we did not referenced elsewhere if the flags\n     * want this function to be responsible. */\n    if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);\n    if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);\n    return update;\n}\n\n/* Delete an element from a hash.\n * Return 1 on deleted and 0 on not found. */\nint hashTypeDelete(robj *o, sds field) {\n    int deleted = 0;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl, *fptr;\n\n        zl = o->ptr;\n        fptr = lpFirst(zl);\n        if (fptr != NULL) {\n            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);\n            if (fptr != NULL) {\n                /* Delete both of the key and the value. */\n                zl = lpDeleteRangeWithEntry(zl,&fptr,2);\n                o->ptr = zl;\n                deleted = 1;\n            }\n        }\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        if (dictDelete((dict*)o->ptr, field) == C_OK) {\n            deleted = 1;\n\n            /* Always check if the dictionary needs a resize after a delete. */\n            if (htNeedsResize(o->ptr)) dictResize(o->ptr);\n        }\n\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return deleted;\n}\n\n/* Return the number of elements in a hash. */\nunsigned long hashTypeLength(const robj *o) {\n    unsigned long length = ULONG_MAX;\n\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        length = lpLength(o->ptr) / 2;\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        length = dictSize((const dict*)o->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return length;\n}\n\nhashTypeIterator *hashTypeInitIterator(robj *subject) {\n    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));\n    hi->subject = subject;\n    hi->encoding = subject->encoding;\n\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        hi->fptr = NULL;\n        hi->vptr = NULL;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        hi->di = dictGetIterator(subject->ptr);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hi;\n}\n\nvoid hashTypeReleaseIterator(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_HT)\n        dictReleaseIterator(hi->di);\n    zfree(hi);\n}\n\n/* Move to the next entry in the hash. Return C_OK when the next entry\n * could be found and C_ERR when the iterator reaches the end. */\nint hashTypeNext(hashTypeIterator *hi) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl;\n        unsigned char *fptr, *vptr;\n\n        zl = hi->subject->ptr;\n        fptr = hi->fptr;\n        vptr = hi->vptr;\n\n        if (fptr == NULL) {\n            /* Initialize cursor */\n            serverAssert(vptr == NULL);\n            fptr = lpFirst(zl);\n        } else {\n            /* Advance cursor */\n            serverAssert(vptr != NULL);\n            fptr = lpNext(zl, vptr);\n        }\n        if (fptr == NULL) return C_ERR;\n\n        /* Grab pointer to the value (fptr points to the field) */\n        vptr = lpNext(zl, fptr);\n        serverAssert(vptr != NULL);\n\n        /* fptr, vptr now point to the first or next pair */\n        hi->fptr = fptr;\n        hi->vptr = vptr;\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return C_OK;\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a listpack. Prototype is similar to `hashTypeGetFromListpack`. */\nvoid hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,\n                                 unsigned char **vstr,\n                                 unsigned int *vlen,\n                                 long long *vll)\n{\n    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (what & OBJ_HASH_KEY) {\n        *vstr = lpGetValue(hi->fptr, vlen, vll);\n    } else {\n        *vstr = lpGetValue(hi->vptr, vlen, vll);\n    }\n}\n\n/* Get the field or value at iterator cursor, for an iterator on a hash value\n * encoded as a hash table. Prototype is similar to\n * `hashTypeGetFromHashTable`. */\nsds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {\n    serverAssert(hi->encoding == OBJ_ENCODING_HT);\n\n    if (what & OBJ_HASH_KEY) {\n        return dictGetKey(hi->de);\n    } else {\n        return dictGetVal(hi->de);\n    }\n}\n\n/* Higher level function of hashTypeCurrent*() that returns the hash value\n * at current iterator position.\n *\n * The returned element is returned by reference in either *vstr and *vlen if\n * it's returned in string form, or stored in *vll if it's returned as\n * a number.\n *\n * If *vll is populated *vstr is set to NULL, so the caller\n * can always check the function return by checking the return value\n * type checking if vstr == NULL. */\nvoid hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        *vstr = NULL;\n        hashTypeCurrentFromListpack(hi, what, vstr, vlen, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds ele = hashTypeCurrentFromHashTable(hi, what);\n        *vstr = (unsigned char*) ele;\n        *vlen = sdslen(ele);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* Return the key or value at the current iterator position as a new\n * SDS string. */\nsds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {\n    unsigned char *vstr;\n    unsigned int vlen;\n    long long vll;\n\n    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);\n    if (vstr) return sdsnewlen(vstr,vlen);\n    return sdsfromlonglong(vll);\n}\n\nrobj *hashTypeLookupWriteOrCreate(client *c, robj *key) {\n    robj *o = lookupKeyWrite(c->db,key);\n    if (checkType(c,o,OBJ_HASH)) return NULL;\n\n    if (o == NULL) {\n        o = createHashObject();\n        dbAdd(c->db,key,o);\n    }\n    return o;\n}\n\n\nvoid hashTypeConvertListpack(robj *o, int enc) {\n    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);\n\n    if (enc == OBJ_ENCODING_LISTPACK) {\n        /* Nothing to do... */\n\n    } else if (enc == OBJ_ENCODING_HT) {\n        hashTypeIterator *hi;\n        dict *dict;\n        int ret;\n\n        hi = hashTypeInitIterator(o);\n        dict = dictCreate(&hashDictType);\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(dict,hashTypeLength(o));\n\n        while (hashTypeNext(hi) != C_ERR) {\n            sds key, value;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(dict, key, value);\n            if (ret != DICT_OK) {\n                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */\n                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */\n                serverLogHexDump(LL_WARNING,\"listpack with dup elements dump\",\n                    o->ptr,lpBytes(o->ptr));\n                serverPanic(\"Listpack corruption detected\");\n            }\n        }\n        hashTypeReleaseIterator(hi);\n        zfree(o->ptr);\n        o->encoding = OBJ_ENCODING_HT;\n        o->ptr = dict;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid hashTypeConvert(robj *o, int enc) {\n    if (o->encoding == OBJ_ENCODING_LISTPACK) {\n        hashTypeConvertListpack(o, enc);\n    } else if (o->encoding == OBJ_ENCODING_HT) {\n        serverPanic(\"Not implemented\");\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n/* This is a helper function for the COPY command.\n * Duplicate a hash object, with the guarantee that the returned object\n * has the same encoding as the original one.\n *\n * The resulting object always has refcount set to 1 */\nrobj *hashTypeDup(robj *o) {\n    robj *hobj;\n    hashTypeIterator *hi;\n\n    serverAssert(o->type == OBJ_HASH);\n\n    if(o->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = o->ptr;\n        size_t sz = lpBytes(zl);\n        unsigned char *new_zl = zmalloc(sz);\n        memcpy(new_zl, zl, sz);\n        hobj = createObject(OBJ_HASH, new_zl);\n        hobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else if(o->encoding == OBJ_ENCODING_HT){\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, dictSize((const dict*)o->ptr));\n\n        hi = hashTypeInitIterator(o);\n        while (hashTypeNext(hi) != C_ERR) {\n            sds field, value;\n            sds newfield, newvalue;\n            /* Extract a field-value pair from an original hash object.*/\n            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);\n            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);\n            newfield = sdsdup(field);\n            newvalue = sdsdup(value);\n\n            /* Add a field-value pair to a new hash object. */\n            dictAdd(d,newfield,newvalue);\n        }\n        hashTypeReleaseIterator(hi);\n\n        hobj = createObject(OBJ_HASH, d);\n        hobj->encoding = OBJ_ENCODING_HT;\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n    return hobj;\n}\n\n/* Create a new sds string from the listpack entry. */\nsds hashSdsFromListpackEntry(listpackEntry *e) {\n    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);\n}\n\n/* Reply with bulk string from the listpack entry. */\nvoid hashReplyFromListpackEntry(client *c, listpackEntry *e) {\n    if (e->sval)\n        addReplyBulkCBuffer(c, e->sval, e->slen);\n    else\n        addReplyBulkLongLong(c, e->lval);\n}\n\n/* Return random element from a non empty hash.\n * 'key' and 'val' will be set to hold the element.\n * The memory in them is not to be freed or modified by the caller.\n * 'val' can be NULL in which case it's not extracted. */\nvoid hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {\n    if (hashobj->encoding == OBJ_ENCODING_HT) {\n        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);\n        sds s = dictGetKey(de);\n        key->sval = (unsigned char*)s;\n        key->slen = sdslen(s);\n        if (val) {\n            sds s = dictGetVal(de);\n            val->sval = (unsigned char*)s;\n            val->slen = sdslen(s);\n        }\n    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {\n        lpRandomPair(hashobj->ptr, hashsize, key, val);\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\n\n/*-----------------------------------------------------------------------------\n * Hash type commands\n *----------------------------------------------------------------------------*/\n\nvoid hsetnxCommand(client *c) {\n    robj *o;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n\n    if (hashTypeExists(o, c->argv[2]->ptr)) {\n        addReply(c, shared.czero);\n    } else {\n        hashTypeTryConversion(o,c->argv,2,3);\n        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);\n        addReply(c, shared.cone);\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n}\n\nvoid hsetCommand(client *c) {\n    int i, created = 0;\n    robj *o;\n\n    if ((c->argc % 2) == 1) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    hashTypeTryConversion(o,c->argv,2,c->argc-1);\n\n    for (i = 2; i < c->argc; i += 2)\n        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);\n\n    /* HMSET (deprecated) and HSET return value is different. */\n    char *cmdname = c->argv[0]->ptr;\n    if (cmdname[1] == 's' || cmdname[1] == 'S') {\n        /* HSET */\n        addReplyLongLong(c, created);\n    } else {\n        /* HMSET */\n        addReply(c, shared.ok);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hset\",c->argv[1],c->db->id);\n    server.dirty += (c->argc - 2)/2;\n}\n\nvoid hincrbyCommand(client *c) {\n    long long value, incr, oldvalue;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {\n        if (vstr) {\n            if (string2ll((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not an integer\");\n                return;\n            }\n        } /* Else hashTypeGetValue() already stored it into &value */\n    } else {\n        value = 0;\n    }\n\n    oldvalue = value;\n    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||\n        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {\n        addReplyError(c,\"increment or decrement would overflow\");\n        return;\n    }\n    value += incr;\n    new = sdsfromlonglong(value);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyLongLong(c,value);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrby\",c->argv[1],c->db->id);\n    server.dirty++;\n}\n\nvoid hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n\nstatic void addHashFieldToReply(client *c, robj *o, sds field) {\n    if (o == NULL) {\n        addReplyNull(c);\n        return;\n    }\n\n    unsigned char *vstr = NULL;\n    unsigned int vlen = UINT_MAX;\n    long long vll = LLONG_MAX;\n\n    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {\n        if (vstr) {\n            addReplyBulkCBuffer(c, vstr, vlen);\n        } else {\n            addReplyBulkLongLong(c, vll);\n        }\n    } else {\n        addReplyNull(c);\n    }\n}\n\nvoid hgetCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addHashFieldToReply(c, o, c->argv[2]->ptr);\n}\n\nvoid hmgetCommand(client *c) {\n    robj *o;\n    int i;\n\n    /* Don't abort when the key cannot be found. Non-existing keys are empty\n     * hashes, where HMGET should respond with a series of null bulks. */\n    o = lookupKeyRead(c->db, c->argv[1]);\n    if (checkType(c,o,OBJ_HASH)) return;\n\n    addReplyArrayLen(c, c->argc-2);\n    for (i = 2; i < c->argc; i++) {\n        addHashFieldToReply(c, o, c->argv[i]->ptr);\n    }\n}\n\nvoid hdelCommand(client *c) {\n    robj *o;\n    int j, deleted = 0, keyremoved = 0;\n\n    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    for (j = 2; j < c->argc; j++) {\n        if (hashTypeDelete(o,c->argv[j]->ptr)) {\n            deleted++;\n            if (hashTypeLength(o) == 0) {\n                dbDelete(c->db,c->argv[1]);\n                keyremoved = 1;\n                break;\n            }\n        }\n    }\n    if (deleted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_HASH,\"hdel\",c->argv[1],c->db->id);\n        if (keyremoved)\n            notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],\n                                c->db->id);\n        server.dirty += deleted;\n    }\n    addReplyLongLong(c,deleted);\n}\n\nvoid hlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReplyLongLong(c,hashTypeLength(o));\n}\n\nvoid hstrlenCommand(client *c) {\n    robj *o;\n\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));\n}\n\nstatic void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {\n    if (hi->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *vstr = NULL;\n        unsigned int vlen = UINT_MAX;\n        long long vll = LLONG_MAX;\n\n        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);\n        if (vstr)\n            addReplyBulkCBuffer(c, vstr, vlen);\n        else\n            addReplyBulkLongLong(c, vll);\n    } else if (hi->encoding == OBJ_ENCODING_HT) {\n        sds value = hashTypeCurrentFromHashTable(hi, what);\n        addReplyBulkCBuffer(c, value, sdslen(value));\n    } else {\n        serverPanic(\"Unknown hash encoding\");\n    }\n}\n\nvoid genericHgetallCommand(client *c, int flags) {\n    robj *o;\n    hashTypeIterator *hi;\n    int length, count = 0;\n\n    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?\n        shared.emptymap[c->resp] : shared.emptyarray;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))\n        == NULL || checkType(c,o,OBJ_HASH)) return;\n\n    /* We return a map if the user requested keys and values, like in the\n     * HGETALL case. Otherwise to use a flat array makes more sense. */\n    length = hashTypeLength(o);\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {\n        addReplyMapLen(c, length);\n    } else {\n        addReplyArrayLen(c, length);\n    }\n\n    hi = hashTypeInitIterator(o);\n    while (hashTypeNext(hi) != C_ERR) {\n        if (flags & OBJ_HASH_KEY) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            count++;\n        }\n        if (flags & OBJ_HASH_VALUE) {\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n            count++;\n        }\n    }\n\n    hashTypeReleaseIterator(hi);\n\n    /* Make sure we returned the right number of elements. */\n    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) count /= 2;\n    serverAssert(count == length);\n}\n\nvoid hkeysCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY);\n}\n\nvoid hvalsCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_VALUE);\n}\n\nvoid hgetallCommand(client *c) {\n    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);\n}\n\nvoid hexistsCommand(client *c) {\n    robj *o;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n\n    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);\n}\n\nvoid hscanCommand(client *c) {\n    robj *o;\n    unsigned long cursor;\n\n    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;\n    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||\n        checkType(c,o,OBJ_HASH)) return;\n    scanGenericCommand(c,o,cursor);\n}\n\nstatic void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {\n    for (unsigned long i = 0; i < count; i++) {\n        if (vals && c->resp > 2)\n            addReplyArrayLen(c,2);\n        if (keys[i].sval)\n            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);\n        else\n            addReplyBulkLongLong(c, keys[i].lval);\n        if (vals) {\n            if (vals[i].sval)\n                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);\n            else\n                addReplyBulkLongLong(c, vals[i].lval);\n        }\n    }\n}\n\n/* How many times bigger should be the hash compared to the requested size\n * for us to not use the \"remove elements\" strategy? Read later in the\n * implementation for more info. */\n#define HRANDFIELD_SUB_STRATEGY_MUL 3\n\n/* If client is trying to ask for a very large number of random elements,\n * queuing may consume an unlimited amount of memory, so we want to limit\n * the number of randoms per time. */\n#define HRANDFIELD_RANDOM_SAMPLE_LIMIT 1000\n\nvoid hrandfieldWithCountCommand(client *c, long l, int withvalues) {\n    unsigned long count, size;\n    int uniq = 1;\n    robj *hash;\n\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))\n        == NULL || checkType(c,hash,OBJ_HASH)) return;\n    size = hashTypeLength(hash);\n\n    if(l >= 0) {\n        count = (unsigned long) l;\n    } else {\n        count = -l;\n        uniq = 0;\n    }\n\n    /* If count is zero, serve it ASAP to avoid special cases later. */\n    if (count == 0) {\n        addReply(c,shared.emptyarray);\n        return;\n    }\n\n    /* CASE 1: The count was negative, so the extraction method is just:\n     * \"return N random elements\" sampling the whole set every time.\n     * This case is trivial and can be served without auxiliary data\n     * structures. This case is the only one that also needs to return the\n     * elements in random order. */\n    if (!uniq || count == 1) {\n        if (withvalues && c->resp == 2)\n            addReplyArrayLen(c, count*2);\n        else\n            addReplyArrayLen(c, count);\n        if (hash->encoding == OBJ_ENCODING_HT) {\n            sds key, value;\n            while (count--) {\n                dictEntry *de = dictGetFairRandomKey(hash->ptr);\n                key = dictGetKey(de);\n                value = dictGetVal(de);\n                if (withvalues && c->resp > 2)\n                    addReplyArrayLen(c,2);\n                addReplyBulkCBuffer(c, key, sdslen(key));\n                if (withvalues)\n                    addReplyBulkCBuffer(c, value, sdslen(value));\n            }\n        } else if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            listpackEntry *keys, *vals = NULL;\n            unsigned long limit, sample_count;\n\n            limit = count > HRANDFIELD_RANDOM_SAMPLE_LIMIT ? HRANDFIELD_RANDOM_SAMPLE_LIMIT : count;\n            keys = zmalloc(sizeof(listpackEntry)*limit);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*limit);\n            while (count) {\n                sample_count = count > limit ? limit : count;\n                count -= sample_count;\n                lpRandomPairs(hash->ptr, sample_count, keys, vals);\n                hrandfieldReplyWithListpack(c, sample_count, keys, vals);\n            }\n            zfree(keys);\n            zfree(vals);\n        }\n        return;\n    }\n\n    /* Initiate reply count, RESP3 responds with nested array, RESP2 with flat one. */\n    long reply_size = count < size ? count : size;\n    if (withvalues && c->resp == 2)\n        addReplyArrayLen(c, reply_size*2);\n    else\n        addReplyArrayLen(c, reply_size);\n\n    /* CASE 2:\n    * The number of requested elements is greater than the number of\n    * elements inside the hash: simply return the whole hash. */\n    if(count >= size) {\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n        while (hashTypeNext(hi) != C_ERR) {\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);\n            if (withvalues)\n                addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);\n        }\n        hashTypeReleaseIterator(hi);\n        return;\n    }\n\n    /* CASE 3:\n     * The number of elements inside the hash is not greater than\n     * HRANDFIELD_SUB_STRATEGY_MUL times the number of requested elements.\n     * In this case we create a hash from scratch with all the elements, and\n     * subtract random elements to reach the requested number of elements.\n     *\n     * This is done because if the number of requested elements is just\n     * a bit less than the number of elements in the hash, the natural approach\n     * used into CASE 4 is highly inefficient. */\n    if (count*HRANDFIELD_SUB_STRATEGY_MUL > size) {\n        dict *d = dictCreate(&sdsReplyDictType);\n        dictExpand(d, size);\n        hashTypeIterator *hi = hashTypeInitIterator(hash);\n\n        /* Add all the elements into the temporary dictionary. */\n        while ((hashTypeNext(hi)) != C_ERR) {\n            int ret = DICT_ERR;\n            sds key, value = NULL;\n\n            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);\n            if (withvalues)\n                value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);\n            ret = dictAdd(d, key, value);\n\n            serverAssert(ret == DICT_OK);\n        }\n        serverAssert(dictSize(d) == size);\n        hashTypeReleaseIterator(hi);\n\n        /* Remove random elements to reach the right count. */\n        while (size > count) {\n            dictEntry *de;\n            de = dictGetFairRandomKey(d);\n            dictUnlink(d,dictGetKey(de));\n            sdsfree(dictGetKey(de));\n            sdsfree(dictGetVal(de));\n            dictFreeUnlinkedEntry(d,de);\n            size--;\n        }\n\n        /* Reply with what's in the dict and release memory */\n        dictIterator *di;\n        dictEntry *de;\n        di = dictGetIterator(d);\n        while ((de = dictNext(di)) != NULL) {\n            sds key = dictGetKey(de);\n            sds value = dictGetVal(de);\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            addReplyBulkSds(c, key);\n            if (withvalues)\n                addReplyBulkSds(c, value);\n        }\n\n        dictReleaseIterator(di);\n        dictRelease(d);\n    }\n\n    /* CASE 4: We have a big hash compared to the requested number of elements.\n     * In this case we can simply get random elements from the hash and add\n     * to the temporary hash, trying to eventually get enough unique elements\n     * to reach the specified count. */\n    else {\n        if (hash->encoding == OBJ_ENCODING_LISTPACK) {\n            /* it is inefficient to repeatedly pick one random element from a\n             * listpack. so we use this instead: */\n            listpackEntry *keys, *vals = NULL;\n            keys = zmalloc(sizeof(listpackEntry)*count);\n            if (withvalues)\n                vals = zmalloc(sizeof(listpackEntry)*count);\n            serverAssert(lpRandomPairsUnique(hash->ptr, count, keys, vals) == count);\n            hrandfieldReplyWithListpack(c, count, keys, vals);\n            zfree(keys);\n            zfree(vals);\n            return;\n        }\n\n        /* Hashtable encoding (generic implementation) */\n        unsigned long added = 0;\n        listpackEntry key, value;\n        dict *d = dictCreate(&hashDictType);\n        dictExpand(d, count);\n        while(added < count) {\n            hashTypeRandomElement(hash, size, &key, withvalues? &value : NULL);\n\n            /* Try to add the object to the dictionary. If it already exists\n            * free it, otherwise increment the number of objects we have\n            * in the result dictionary. */\n            sds skey = hashSdsFromListpackEntry(&key);\n            if (dictAdd(d,skey,NULL) != DICT_OK) {\n                sdsfree(skey);\n                continue;\n            }\n            added++;\n\n            /* We can reply right away, so that we don't need to store the value in the dict. */\n            if (withvalues && c->resp > 2)\n                addReplyArrayLen(c,2);\n            hashReplyFromListpackEntry(c, &key);\n            if (withvalues)\n                hashReplyFromListpackEntry(c, &value);\n        }\n\n        /* Release memory */\n        dictRelease(d);\n    }\n}\n\n/* HRANDFIELD key [<count> [WITHVALUES]] */\nvoid hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}\n", "start_server {tags {\"hash\"}} {\n    test {HSET/HLEN - Small hash creation} {\n        array set smallhash {}\n        for {set i 0} {$i < 8} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists smallhash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset smallhash $key $val\n            set smallhash($key) $val\n        }\n        list [r hlen smallhash]\n    } {8}\n\n    test {Is the small hash encoded with a listpack?} {\n        assert_encoding listpack smallhash\n    }\n\n    proc create_hash {key entries} {\n        r del $key\n        foreach entry $entries {\n            r hset $key [lindex $entry 0] [lindex $entry 1]\n        }\n    }\n\n    proc get_keys {l} {\n        set res {}\n        foreach entry $l {\n            set key [lindex $entry 0]\n            lappend res $key\n        }\n        return $res\n    }\n\n    foreach {type contents} \"listpack {{a 1} {b 2} {c 3}} hashtable {{a 1} {b 2} {[randstring 70 90 alpha] 3}}\" {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-ziplist-value 10\n        create_hash myhash $contents\n        assert_encoding $type myhash\n\n        # coverage for objectComputeSize\n        assert_morethan [memory_usage myhash] 0\n\n        test \"HRANDFIELD - $type\" {\n            unset -nocomplain myhash\n            array set myhash {}\n            for {set i 0} {$i < 100} {incr i} {\n                set key [r hrandfield myhash]\n                set myhash($key) 1\n            }\n            assert_equal [lsort [get_keys $contents]] [lsort [array names myhash]]\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n    test \"HRANDFIELD with RESP3\" {\n        r hello 3\n        set res [r hrandfield myhash 3 withvalues]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 2\n\n        set res [r hrandfield myhash 3]\n        assert_equal [llength $res] 3\n        assert_equal [llength [lindex $res 1]] 1\n        r hello 2\n    }\n\n    test \"HRANDFIELD count of 0 is handled correctly\" {\n        r hrandfield myhash 0\n    } {}\n\n    test \"HRANDFIELD with <count> against non existing key\" {\n        r hrandfield nonexisting_key 100\n    } {}\n\n    # Make sure we can distinguish between an empty array and a null response\n    r readraw 1\n\n    test \"HRANDFIELD count of 0 is handled correctly - emptyarray\" {\n        r hrandfield myhash 0\n    } {*0}\n\n    test \"HRANDFIELD with <count> against non existing key - emptyarray\" {\n        r hrandfield nonexisting_key 100\n    } {*0}\n\n    r readraw 0\n\n    foreach {type contents} \"\n        hashtable {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {[randstring 70 90 alpha] 10}}\n        listpack {{a 1} {b 2} {c 3} {d 4} {e 5} {6 f} {7 g} {8 h} {9 i} {10 j}} \" {\n        test \"HRANDFIELD with <count> - $type\" {\n            set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n            r config set hash-max-ziplist-value 10\n            create_hash myhash $contents\n            assert_encoding $type myhash\n\n            # create a dict for easy lookup\n            set mydict [dict create {*}[r hgetall myhash]]\n\n            # We'll stress different parts of the code, see the implementation\n            # of HRANDFIELD for more information, but basically there are\n            # four different code paths.\n\n            # PATH 1: Use negative count.\n\n            # 1) Check that it returns repeated elements with and without values.\n            set res [r hrandfield myhash -20]\n            assert_equal [llength $res] 20\n            set res [r hrandfield myhash -1001]\n            assert_equal [llength $res] 1001\n            # again with WITHVALUES\n            set res [r hrandfield myhash -20 withvalues]\n            assert_equal [llength $res] 40\n            set res [r hrandfield myhash -1001 withvalues]\n            assert_equal [llength $res] 2002\n\n            # Test random uniform distribution\n            # df = 9, 40 means 0.00001 probability\n            set res [r hrandfield myhash -1000]\n            assert_lessthan [chi_square_value $res] 40\n\n            # 2) Check that all the elements actually belong to the original hash.\n            foreach {key val} $res {\n                assert {[dict exists $mydict $key]}\n            }\n\n            # 3) Check that eventually all the elements are returned.\n            #    Use both WITHVALUES and without\n            unset -nocomplain auxset\n            set iterations 1000\n            while {$iterations != 0} {\n                incr iterations -1\n                if {[expr {$iterations % 2}] == 0} {\n                    set res [r hrandfield myhash -3 withvalues]\n                    foreach {key val} $res {\n                        dict append auxset $key $val\n                    }\n                } else {\n                    set res [r hrandfield myhash -3]\n                    foreach key $res {\n                        dict append auxset $key $val\n                    }\n                }\n                if {[lsort [dict keys $mydict]] eq\n                    [lsort [dict keys $auxset]]} {\n                    break;\n                }\n            }\n            assert {$iterations != 0}\n\n            # PATH 2: positive count (unique behavior) with requested size\n            # equal or greater than set size.\n            foreach size {10 20} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] 10\n                assert_equal [lsort $res] [lsort [dict keys $mydict]]\n\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] 20\n                assert_equal [lsort $res] [lsort $mydict]\n            }\n\n            # PATH 3: Ask almost as elements as there are in the set.\n            # In this case the implementation will duplicate the original\n            # set and will remove random elements up to the requested size.\n            #\n            # PATH 4: Ask a number of elements definitely smaller than\n            # the set size.\n            #\n            # We can test both the code paths just changing the size but\n            # using the same code.\n            foreach size {8 2} {\n                set res [r hrandfield myhash $size]\n                assert_equal [llength $res] $size\n                # again with WITHVALUES\n                set res [r hrandfield myhash $size withvalues]\n                assert_equal [llength $res] [expr {$size * 2}]\n\n                # 1) Check that all the elements actually belong to the\n                # original set.\n                foreach ele [dict keys $res] {\n                    assert {[dict exists $mydict $ele]}\n                }\n\n                # 2) Check that eventually all the elements are returned.\n                #    Use both WITHVALUES and without\n                unset -nocomplain auxset\n                unset -nocomplain allkey\n                set iterations [expr {1000 / $size}]\n                set all_ele_return false\n                while {$iterations != 0} {\n                    incr iterations -1\n                    if {[expr {$iterations % 2}] == 0} {\n                        set res [r hrandfield myhash $size withvalues]\n                        foreach {key value} $res {\n                            dict append auxset $key $value\n                            lappend allkey $key\n                        }\n                    } else {\n                        set res [r hrandfield myhash $size]\n                        foreach key $res {\n                            dict append auxset $key\n                            lappend allkey $key\n                        }\n                    }\n                    if {[lsort [dict keys $mydict]] eq\n                        [lsort [dict keys $auxset]]} {\n                        set all_ele_return true\n                    }\n                }\n                assert_equal $all_ele_return true\n                # df = 9, 40 means 0.00001 probability\n                assert_lessthan [chi_square_value $allkey] 40\n            }\n        }\n        r config set hash-max-ziplist-value $original_max_value\n    }\n\n\n    test {HSET/HLEN - Big hash creation} {\n        array set bighash {}\n        for {set i 0} {$i < 1024} {incr i} {\n            set key __avoid_collisions__[randstring 0 8 alpha]\n            set val __avoid_collisions__[randstring 0 8 alpha]\n            if {[info exists bighash($key)]} {\n                incr i -1\n                continue\n            }\n            r hset bighash $key $val\n            set bighash($key) $val\n        }\n        list [r hlen bighash]\n    } {1024}\n\n    test {Is the big hash encoded with an hash table?} {\n        assert_encoding hashtable bighash\n    }\n\n    test {HGET against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {$smallhash($k) ne [r hget smallhash $k]} {\n                set err \"$smallhash($k) != [r hget smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {$bighash($k) ne [r hget bighash $k]} {\n                set err \"$bighash($k) != [r hget bighash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HGET against non existing key} {\n        set rv {}\n        lappend rv [r hget smallhash __123123123__]\n        lappend rv [r hget bighash __123123123__]\n        set _ $rv\n    } {{} {}}\n\n    test {HSET in update and insert mode} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hset smallhash $k newval1]\n        set smallhash($k) newval1\n        lappend rv [r hget smallhash $k]\n        lappend rv [r hset smallhash __foobar123__ newval]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hset bighash $k newval2]\n        set bighash($k) newval2\n        lappend rv [r hget bighash $k]\n        lappend rv [r hset bighash __foobar123__ newval]\n        lappend rv [r hdel smallhash __foobar123__]\n        lappend rv [r hdel bighash __foobar123__]\n        set _ $rv\n    } {0 newval1 1 0 newval2 1 1 1}\n\n    test {HSETNX target key missing - small hash} {\n        r hsetnx smallhash __123123123__ foo\n        r hget smallhash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - small hash} {\n        r hsetnx smallhash __123123123__ bar\n        set result [r hget smallhash __123123123__]\n        r hdel smallhash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSETNX target key missing - big hash} {\n        r hsetnx bighash __123123123__ foo\n        r hget bighash __123123123__\n    } {foo}\n\n    test {HSETNX target key exists - big hash} {\n        r hsetnx bighash __123123123__ bar\n        set result [r hget bighash __123123123__]\n        r hdel bighash __123123123__\n        set _ $result\n    } {foo}\n\n    test {HSET/HMSET wrong number of args} {\n        assert_error {*wrong number of arguments for 'hset' command} {r hset smallhash key1 val1 key2}\n        assert_error {*wrong number of arguments for 'hmset' command} {r hmset smallhash key1 val1 key2}\n    }\n\n    test {HMSET - small hash} {\n        set args {}\n        foreach {k v} [array get smallhash] {\n            set newval [randstring 0 8 alpha]\n            set smallhash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset smallhash {*}$args\n    } {OK}\n\n    test {HMSET - big hash} {\n        set args {}\n        foreach {k v} [array get bighash] {\n            set newval [randstring 0 8 alpha]\n            set bighash($k) $newval\n            lappend args $k $newval\n        }\n        r hmset bighash {*}$args\n    } {OK}\n\n    test {HMGET against non existing key and fields} {\n        set rv {}\n        lappend rv [r hmget doesntexist __123123123__ __456456456__]\n        lappend rv [r hmget smallhash __123123123__ __456456456__]\n        lappend rv [r hmget bighash __123123123__ __456456456__]\n        set _ $rv\n    } {{{} {}} {{} {}} {{} {}}}\n\n    test {HMGET against wrong type} {\n        r set wrongtype somevalue\n        assert_error \"*wrong*\" {r hmget wrongtype field1 field2}\n    }\n\n    test {HMGET - small hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget smallhash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HMGET - big hash} {\n        set keys {}\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend keys $k\n            lappend vals $v\n        }\n        set err {}\n        set result [r hmget bighash {*}$keys]\n        if {$vals ne $result} {\n            set err \"$vals != $result\"\n            break\n        }\n        set _ $err\n    } {}\n\n    test {HKEYS - small hash} {\n        lsort [r hkeys smallhash]\n    } [lsort [array names smallhash *]]\n\n    test {HKEYS - big hash} {\n        lsort [r hkeys bighash]\n    } [lsort [array names bighash *]]\n\n    test {HVALS - small hash} {\n        set vals {}\n        foreach {k v} [array get smallhash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals smallhash]]\n\n    test {HVALS - big hash} {\n        set vals {}\n        foreach {k v} [array get bighash] {\n            lappend vals $v\n        }\n        set _ [lsort $vals]\n    } [lsort [r hvals bighash]]\n\n    test {HGETALL - small hash} {\n        lsort [r hgetall smallhash]\n    } [lsort [array get smallhash]]\n\n    test {HGETALL - big hash} {\n        lsort [r hgetall bighash]\n    } [lsort [array get bighash]]\n\n    test {HDEL and return value} {\n        set rv {}\n        lappend rv [r hdel smallhash nokey]\n        lappend rv [r hdel bighash nokey]\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hdel smallhash $k]\n        lappend rv [r hget smallhash $k]\n        unset smallhash($k)\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hdel bighash $k]\n        lappend rv [r hget bighash $k]\n        unset bighash($k)\n        set _ $rv\n    } {0 0 1 0 {} 1 0 {}}\n\n    test {HDEL - more than a single value} {\n        set rv {}\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 0 [r hdel myhash x y]\n        assert_equal 2 [r hdel myhash a c f]\n        r hgetall myhash\n    } {b 2}\n\n    test {HDEL - hash becomes empty before deleting all specified fields} {\n        r del myhash\n        r hmset myhash a 1 b 2 c 3\n        assert_equal 3 [r hdel myhash a b c d e]\n        assert_equal 0 [r exists myhash]\n    }\n\n    test {HEXISTS} {\n        set rv {}\n        set k [lindex [array names smallhash *] 0]\n        lappend rv [r hexists smallhash $k]\n        lappend rv [r hexists smallhash nokey]\n        set k [lindex [array names bighash *] 0]\n        lappend rv [r hexists bighash $k]\n        lappend rv [r hexists bighash nokey]\n    } {1 0 1 0}\n\n    test {Is a ziplist encoded Hash promoted on big payload?} {\n        r hset smallhash foo [string repeat a 1024]\n        r debug object smallhash\n    } {*hashtable*} {needs:debug}\n\n    test {HINCRBY against non existing database key} {\n        r del htest\n        list [r hincrby htest foo 2]\n    } {2}\n\n    test {HINCRBY against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [r hincrby smallhash tmp 2]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 2]\n        lappend rv [r hget bighash tmp]\n    } {2 2 2 2}\n\n    test {HINCRBY against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [r hincrby smallhash tmp 3]\n        lappend rv [r hget smallhash tmp]\n        lappend rv [r hincrby bighash tmp 3]\n        lappend rv [r hget bighash tmp]\n    } {5 5 5 5}\n\n    test {HINCRBY against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [r hincrby smallhash tmp 2] [r hincrby bighash tmp 2]\n    } {102 102}\n\n    test {HINCRBY over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 1] [r hincrby bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBY over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrby smallhash tmp 17179869184] [r hincrby bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBY fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrby smallhash str 1} smallerr\n        catch {r hincrby bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not an integer*\" $smallerr]\n        lappend rv [string match \"ERR *not an integer*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBY can detect overflows} {\n        set e {}\n        r hset hash n -9223372036854775484\n        assert {[r hincrby hash n -1] == -9223372036854775485}\n        catch {r hincrby hash n -10000} e\n        set e\n    } {*overflow*}\n\n    test {HINCRBYFLOAT against non existing database key} {\n        r del htest\n        list [r hincrbyfloat htest foo 2.5]\n    } {2.5}\n\n    test {HINCRBYFLOAT against non existing hash key} {\n        set rv {}\n        r hdel smallhash tmp\n        r hdel bighash tmp\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 2.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {2.5 2.5 2.5 2.5}\n\n    test {HINCRBYFLOAT against hash key created by hincrby itself} {\n        set rv {}\n        lappend rv [roundFloat [r hincrbyfloat smallhash tmp 3.5]]\n        lappend rv [roundFloat [r hget smallhash tmp]]\n        lappend rv [roundFloat [r hincrbyfloat bighash tmp 3.5]]\n        lappend rv [roundFloat [r hget bighash tmp]]\n    } {6 6 6 6}\n\n    test {HINCRBYFLOAT against hash key originally set with HSET} {\n        r hset smallhash tmp 100\n        r hset bighash tmp 100\n        list [roundFloat [r hincrbyfloat smallhash tmp 2.5]] \\\n             [roundFloat [r hincrbyfloat bighash tmp 2.5]]\n    } {102.5 102.5}\n\n    test {HINCRBYFLOAT over 32bit value} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 1] \\\n             [r hincrbyfloat bighash tmp 1]\n    } {17179869185 17179869185}\n\n    test {HINCRBYFLOAT over 32bit value with over 32bit increment} {\n        r hset smallhash tmp 17179869184\n        r hset bighash tmp 17179869184\n        list [r hincrbyfloat smallhash tmp 17179869184] \\\n             [r hincrbyfloat bighash tmp 17179869184]\n    } {34359738368 34359738368}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (left)} {\n        r hset smallhash str \" 11\"\n        r hset bighash str \" 11\"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value with spaces (right)} {\n        r hset smallhash str \"11 \"\n        r hset bighash str \"11 \"\n        catch {r hincrbyfloat smallhash str 1} smallerr\n        catch {r hincrbyfloat bighash str 1} bigerr\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $smallerr]\n        lappend rv [string match \"ERR *not*float*\" $bigerr]\n    } {1 1}\n\n    test {HINCRBYFLOAT fails against hash value that contains a null-terminator in the middle} {\n        r hset h f \"1\\x002\"\n        catch {r hincrbyfloat h f 1} err\n        set rv {}\n        lappend rv [string match \"ERR *not*float*\" $err]\n    } {1}\n\n    test {HSTRLEN against the small hash} {\n        set err {}\n        foreach k [array names smallhash *] {\n            if {[string length $smallhash($k)] ne [r hstrlen smallhash $k]} {\n                set err \"[string length $smallhash($k)] != [r hstrlen smallhash $k]\"\n                break\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against the big hash} {\n        set err {}\n        foreach k [array names bighash *] {\n            if {[string length $bighash($k)] ne [r hstrlen bighash $k]} {\n                set err \"[string length $bighash($k)] != [r hstrlen bighash $k]\"\n                puts \"HSTRLEN and logical length mismatch:\"\n                puts \"key: $k\"\n                puts \"Logical content: $bighash($k)\"\n                puts \"Server  content: [r hget bighash $k]\"\n            }\n        }\n        set _ $err\n    } {}\n\n    test {HSTRLEN against non existing field} {\n        set rv {}\n        lappend rv [r hstrlen smallhash __123123123__]\n        lappend rv [r hstrlen bighash __123123123__]\n        set _ $rv\n    } {0 0}\n\n    test {HSTRLEN corner cases} {\n        set vals {\n            -9223372036854775808 9223372036854775807 9223372036854775808\n            {} 0 -1 x\n        }\n        foreach v $vals {\n            r hmset smallhash field $v\n            r hmset bighash field $v\n            set len1 [string length $v]\n            set len2 [r hstrlen smallhash field]\n            set len3 [r hstrlen bighash field]\n            assert {$len1 == $len2}\n            assert {$len2 == $len3}\n        }\n    }\n\n    test {HINCRBYFLOAT over hash-max-listpack-value encoded with a listpack} {\n        set original_max_value [lindex [r config get hash-max-ziplist-value] 1]\n        r config set hash-max-listpack-value 8\n        \n        # hash's value exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hset smallhash tmp 0\n        r hset bighash tmp 0\n        r hincrbyfloat smallhash tmp 0.000005\n        r hincrbyfloat bighash tmp 0.0000005\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        # hash's field exceeds hash-max-listpack-value\n        r del smallhash\n        r del bighash\n        r hincrbyfloat smallhash abcdefgh 1\n        r hincrbyfloat bighash abcdefghi 1\n        assert_encoding listpack smallhash\n        assert_encoding hashtable bighash\n\n        r config set hash-max-listpack-value $original_max_value\n    }\n\n    test {Hash ziplist regression test for large keys} {\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk a\n        r hset hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk b\n        r hget hash kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk\n    } {b}\n\n    foreach size {10 512} {\n        test \"Hash fuzzing #1 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    set field [randomValue]\n                    set value [randomValue]\n                    r hset hash $field $value\n                    set hash($field) $value\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n\n        test \"Hash fuzzing #2 - $size fields\" {\n            for {set times 0} {$times < 10} {incr times} {\n                catch {unset hash}\n                array set hash {}\n                r del hash\n\n                # Create\n                for {set j 0} {$j < $size} {incr j} {\n                    randpath {\n                        set field [randomValue]\n                        set value [randomValue]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        set field [randomSignedInt 512]\n                        set value [randomSignedInt 512]\n                        r hset hash $field $value\n                        set hash($field) $value\n                    } {\n                        randpath {\n                            set field [randomValue]\n                        } {\n                            set field [randomSignedInt 512]\n                        }\n                        r hdel hash $field\n                        unset -nocomplain hash($field)\n                    }\n                }\n\n                # Verify\n                foreach {k v} [array get hash] {\n                    assert_equal $v [r hget hash $k]\n                }\n                assert_equal [array size hash] [r hlen hash]\n            }\n        }\n    }\n\n    test {Stress test the hash ziplist -> hashtable encoding conversion} {\n        r config set hash-max-ziplist-entries 32\n        for {set j 0} {$j < 100} {incr j} {\n            r del myhash\n            for {set i 0} {$i < 64} {incr i} {\n                r hset myhash [randomValue] [randomValue]\n            }\n            assert_encoding hashtable myhash\n        }\n    }\n\n    # The following test can only be executed if we don't use Valgrind, and if\n    # we are using x86_64 architecture, because:\n    #\n    # 1) Valgrind has floating point limitations, no support for 80 bits math.\n    # 2) Other archs may have the same limits.\n    #\n    # 1.23 cannot be represented correctly with 64 bit doubles, so we skip\n    # the test, since we are only testing pretty printing here and is not\n    # a bug if the program outputs things like 1.299999...\n    if {!$::valgrind && [string match *x86_64* [exec uname -a]]} {\n        test {Test HINCRBYFLOAT for correct float representation (issue #2846)} {\n            r del myhash\n            assert {[r hincrbyfloat myhash float 1.23] eq {1.23}}\n            assert {[r hincrbyfloat myhash float 0.77] eq {2}}\n            assert {[r hincrbyfloat myhash float -0.1] eq {1.9}}\n        }\n    }\n\n    test {Hash ziplist of various encodings} {\n        r del k\n        config_set hash-max-ziplist-entries 1000000000\n        config_set hash-max-ziplist-value 1000000000\n        r hset k ZIP_INT_8B 127\n        r hset k ZIP_INT_16B 32767\n        r hset k ZIP_INT_32B 2147483647\n        r hset k ZIP_INT_64B 9223372036854775808\n        r hset k ZIP_INT_IMM_MIN 0\n        r hset k ZIP_INT_IMM_MAX 12\n        r hset k ZIP_STR_06B [string repeat x 31]\n        r hset k ZIP_STR_14B [string repeat x 8191]\n        r hset k ZIP_STR_32B [string repeat x 65535]\n        set k [r hgetall k]\n        set dump [r dump k]\n\n        # will be converted to dict at RESTORE\n        config_set hash-max-ziplist-entries 2\n        config_set sanitize-dump-payload no mayfail\n        r restore kk 0 $dump\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n    test {Hash ziplist of various encodings - sanitize dump} {\n        config_set sanitize-dump-payload yes mayfail\n        r restore kk 0 $dump replace\n        set k [r hgetall k]\n        set kk [r hgetall kk]\n\n        # make sure the values are right\n        assert_equal [lsort $k] [lsort $kk]\n        assert_equal [dict get $k ZIP_STR_06B] [string repeat x 31]\n        set k [dict remove $k ZIP_STR_06B]\n        assert_equal [dict get $k ZIP_STR_14B] [string repeat x 8191]\n        set k [dict remove $k ZIP_STR_14B]\n        assert_equal [dict get $k ZIP_STR_32B] [string repeat x 65535]\n        set k [dict remove $k ZIP_STR_32B]\n        set _ $k\n    } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n\n    test {HINCRBYFLOAT does not allow NaN or Infinity} {\n        assert_error \"*value is NaN or Infinity*\" {r hincrbyfloat hfoo field +inf}\n        assert_equal 0 [r exists hfoo]\n    }\n}\n"], "filenames": ["src/t_hash.c", "tests/unit/type/hash.tcl"], "buggy_code_start_loc": [668, 821], "buggy_code_end_loc": [668, 821], "fixing_code_start_loc": [669, 822], "fixing_code_end_loc": [673, 826], "type": "CWE-617", "message": "Redis is an open source, in-memory database that persists on disk. Authenticated users can use the `HINCRBYFLOAT` command to create an invalid hash field that will crash Redis on access in affected versions. This issue has been addressed in in versions 7.0.11, 6.2.12, and 6.0.19. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-28856", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-18T21:15:09.313", "lastModified": "2023-06-01T14:15:11.300", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Redis is an open source, in-memory database that persists on disk. Authenticated users can use the `HINCRBYFLOAT` command to create an invalid hash field that will crash Redis on access in affected versions. This issue has been addressed in in versions 7.0.11, 6.2.12, and 6.0.19. Users are advised to upgrade. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.19", "matchCriteriaId": "F2B03AA7-7246-4AEB-9C34-37E63E9D734C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.12", "matchCriteriaId": "34A547EB-9F9A-4554-97D5-0141CAE18222"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redis:redis:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.11", "matchCriteriaId": "ADC8DBA4-6974-4E79-9218-286251C25982"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://github.com/redis/redis/commit/bc7fe41e5857a0854d524e2a63a028e9394d2a5c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/redis/redis/pull/11149", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/redis/redis/security/advisories/GHSA-hjv8-vjf6-wcr6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/04/msg00023.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EQ4DJSO4DMR55AWK6OPVJH5UTEB35R2Z/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LPUTH7NBQTZDVJWFNUD24ZCS6NDUFYS6/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OQGKMKSQE67L32HE6W5EI2I2YKW5VWHI/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230601-0007/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/redis/redis/commit/bc7fe41e5857a0854d524e2a63a028e9394d2a5c"}}