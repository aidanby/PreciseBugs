{"buggy_code": ["/*\n *\tDCCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tBased on net/dccp6/ipv6.c\n *\n *\tArnaldo Carvalho de Melo <acme@ghostprotocols.net>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/xfrm.h>\n\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_sock.h>\n#include <net/inet6_connection_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n\n#include \"dccp.h\"\n#include \"ipv6.h\"\n#include \"feat.h\"\n\n/* The per-net dccp.v6_ctl_sk is used for sending RSTs and ACKs */\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops;\n\n/* add pseudo-header to DCCP checksum stored in skb->csum */\nstatic inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,\n\t\t\t\t      const struct in6_addr *saddr,\n\t\t\t\t      const struct in6_addr *daddr)\n{\n\treturn csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);\n}\n\nstatic inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tdccp_csum_outgoing(skb);\n\tdh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &sk->sk_v6_daddr);\n}\n\nstatic inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}\n\nstatic void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct dccp_hdr *dh;\n\tstruct dccp_sock *dp;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\t__u64 seq;\n\tstruct net *net = dev_net(skb->dev);\n\n\t/* Only need dccph_dport & dccph_sport which are the first\n\t * 4 bytes in dccp header.\n\t * Our caller (icmpv6_notify()) already pulled 8 bytes for us.\n\t */\n\tBUILD_BUG_ON(offsetofend(struct dccp_hdr, dccph_sport) > 8);\n\tBUILD_BUG_ON(offsetofend(struct dccp_hdr, dccph_dport) > 8);\n\tdh = (struct dccp_hdr *)(skb->data + offset);\n\n\tsk = __inet6_lookup_established(net, &dccp_hashinfo,\n\t\t\t\t\t&hdr->daddr, dh->dccph_dport,\n\t\t\t\t\t&hdr->saddr, ntohs(dh->dccph_sport),\n\t\t\t\t\tinet6_iif(skb));\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = dccp_hdr_seq(dh);\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV)\n\t\treturn dccp_req_err(sk, seq);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tdp = dccp_sk(sk);\n\tif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\n\t    !between48(seq, dp->dccps_awl, dp->dccps_awh)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tstruct dst_entry *dst = NULL;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tgoto out;\n\t\tif ((1 << sk->sk_state) & (DCCPF_LISTEN | DCCPF_CLOSED))\n\t\t\tgoto out;\n\n\t\tdst = inet6_csk_update_pmtu(sk, ntohl(info));\n\t\tif (!dst)\n\t\t\tgoto out;\n\n\t\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst))\n\t\t\tdccp_sync_mss(sk, dst_mtu(dst));\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\tcase DCCP_RESPOND:  /* Cannot happen.\n\t\t\t       It can, it SYNs are crossed. --ANK */\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\t\t\tsk->sk_err = err;\n\t\t\t/*\n\t\t\t * Wake people up to see the error\n\t\t\t * (see connect in sock.c)\n\t\t\t */\n\t\t\tsk->sk_error_report(sk);\n\t\t\tdccp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, &fl6, sk->sk_mark, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic void dccp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tdccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\nstatic void dccp_v6_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\n{\n\tconst struct ipv6hdr *rxip6h;\n\tstruct sk_buff *skb;\n\tstruct flowi6 fl6;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct sock *ctl_sk = net->dccp.v6_ctl_sk;\n\tstruct dst_entry *dst;\n\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (!ipv6_unicast_destination(rxskb))\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\treturn;\n\n\trxip6h = ipv6_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v6_csum_finish(skb, &rxip6h->saddr,\n\t\t\t\t\t\t\t    &rxip6h->daddr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = rxip6h->saddr;\n\tfl6.saddr = rxip6h->daddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.flowi6_oif = inet6_iif(rxskb);\n\tfl6.fl6_dport = dccp_hdr(skb)->dccph_dport;\n\tfl6.fl6_sport = dccp_hdr(skb)->dccph_sport;\n\tsecurity_skb_classify_flow(rxskb, flowi6_to_flowi(&fl6));\n\n\t/* sk = NULL, but it is safe for now. RST socket required. */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(skb, dst);\n\t\tip6_xmit(ctl_sk, skb, &fl6, 0, NULL, 0);\n\t\tDCCP_INC_STATS(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS(DCCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic struct request_sock_ops dccp6_request_sock_ops = {\n\t.family\t\t= AF_INET6,\n\t.obj_size\t= sizeof(struct dccp6_request_sock),\n\t.rtx_syn_ack\t= dccp_v6_send_response,\n\t.send_ack\t= dccp_reqsk_send_ack,\n\t.destructor\t= dccp_v6_reqsk_destructor,\n\t.send_reset\t= dccp_v6_ctl_send_reset,\n\t.syn_ack_timeout = dccp_syn_ack_timeout,\n};\n\nstatic int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct request_sock *req;\n\tstruct dccp_request_sock *dreq;\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\treturn 0;\t/* discard, don't send a reset here */\n\n\tif (dccp_bad_service_code(sk, service)) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\n\t\tgoto drop;\n\t}\n\t/*\n\t * There are no SYN attacks on IPv6, yet...\n\t */\n\tdcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\n\tif (inet_csk_reqsk_queue_is_full(sk))\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto drop;\n\n\treq = inet_reqsk_alloc(&dccp6_request_sock_ops, sk, true);\n\tif (req == NULL)\n\t\tgoto drop;\n\n\tif (dccp_reqsk_init(req, dccp_sk(sk), skb))\n\t\tgoto drop_and_free;\n\n\tdreq = dccp_rsk(req);\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\tgoto drop_and_free;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tireq = inet_rsk(req);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tireq->ireq_family = AF_INET6;\n\n\tif (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = inet6_iif(skb);\n\n\t/*\n\t * Step 3: Process LISTEN state\n\t *\n\t *   Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookie\n\t *\n\t * Setting S.SWL/S.SWH to is deferred to dccp_create_openreq_child().\n\t */\n\tdreq->dreq_isr\t   = dcb->dccpd_seq;\n\tdreq->dreq_gsr     = dreq->dreq_isr;\n\tdreq->dreq_iss\t   = dccp_v6_init_sequence(skb);\n\tdreq->dreq_gss     = dreq->dreq_iss;\n\tdreq->dreq_service = service;\n\n\tif (dccp_v6_send_response(sk, req))\n\t\tgoto drop_and_free;\n\n\tinet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\n\treturn 0;\n\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\treturn -1;\n}\n\nstatic struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t/* Clone pktoptions received with SYN, if we own the req */\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, dccp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   dccp_v6_hnd_req and dccp_v6_ctl_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t * socket locking is here for SMP purposes as backlog rcv is currently\n\t * called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t/*\n\t * FIXME: Add handling of IPV6_PKTOPTIONS skb. See the comments below\n\t *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.\n\t */\n\t\topt_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (sk->sk_state == DCCP_OPEN) { /* Fast path */\n\t\tif (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))\n\t\t\tgoto reset;\n\t\tif (opt_skb) {\n\t\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t\t__kfree_skb(opt_skb);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies\n\t *\t      Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t *\n\t * NOTE: the check for the packet types is done in\n\t *\t dccp_rcv_state_process\n\t */\n\n\tif (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))\n\t\tgoto reset;\n\tif (opt_skb) {\n\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t__kfree_skb(opt_skb);\n\t}\n\treturn 0;\n\nreset:\n\tdccp_v6_ctl_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb != NULL)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int dccp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t/* Step 1: If header checksum is incorrect, drop packet and return. */\n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb), &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = dccp_check_req(sk, skb, req);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * RFC 4340, sec. 9.2.1: Minimum Checksum Coverage\n\t *\to if MinCsCov = 0, only packets with CsCov = 0 are accepted\n\t *\to if MinCsCov > 0, also accept packets with CsCov >= MinCsCov\n\t */\n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov  &&  (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t/* FIXME: send Data Dropped option (see also dccp_v4_rcv) */\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\treturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4,\n\t\t\t\trefcounted) ? -1 : 0;\n\nno_dccp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t/*\n\t * Step 2:\n\t *\tIf no socket ...\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n}\n\nstatic int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t   int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\t/*\n\t * connect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t * DCCP over IPv4\n\t */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\n\t\terr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &dccp_ipv6_af_ops;\n\t\t\tsk->sk_backlog_rcv = dccp_v6_do_rcv;\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (saddr == NULL) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\n\tinet->inet_dport = usin->sin6_port;\n\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet6_hash_connect(&dccp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tdp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t      sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t      inet->inet_sport,\n\t\t\t\t\t\t      inet->inet_dport);\n\terr = dccp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\tdccp_set_state(sk, DCCP_CLOSED);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = dccp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/*\n *\tDCCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = dccp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int dccp_v6_init_sock(struct sock *sk)\n{\n\tstatic __u8 dccp_v6_ctl_sock_initialized;\n\tint err = dccp_init_sock(sk, dccp_v6_ctl_sock_initialized);\n\n\tif (err == 0) {\n\t\tif (unlikely(!dccp_v6_ctl_sock_initialized))\n\t\t\tdccp_v6_ctl_sock_initialized = 1;\n\t\tinet_csk(sk)->icsk_af_ops = &dccp_ipv6_af_ops;\n\t}\n\n\treturn err;\n}\n\nstatic void dccp_v6_destroy_sock(struct sock *sk)\n{\n\tdccp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstatic struct timewait_sock_ops dccp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct dccp6_timewait_sock),\n};\n\nstatic struct proto dccp_v6_prot = {\n\t.name\t\t   = \"DCCPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = dccp_close,\n\t.connect\t   = dccp_v6_connect,\n\t.disconnect\t   = dccp_disconnect,\n\t.ioctl\t\t   = dccp_ioctl,\n\t.init\t\t   = dccp_v6_init_sock,\n\t.setsockopt\t   = dccp_setsockopt,\n\t.getsockopt\t   = dccp_getsockopt,\n\t.sendmsg\t   = dccp_sendmsg,\n\t.recvmsg\t   = dccp_recvmsg,\n\t.backlog_rcv\t   = dccp_v6_do_rcv,\n\t.hash\t\t   = inet6_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.accept\t\t   = inet_csk_accept,\n\t.get_port\t   = inet_csk_get_port,\n\t.shutdown\t   = dccp_shutdown,\n\t.destroy\t   = dccp_v6_destroy_sock,\n\t.orphan_count\t   = &dccp_orphan_count,\n\t.max_header\t   = MAX_DCCP_HEADER,\n\t.obj_size\t   = sizeof(struct dccp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.rsk_prot\t   = &dccp6_request_sock_ops,\n\t.twsk_prot\t   = &dccp6_timewait_sock_ops,\n\t.h.hashinfo\t   = &dccp_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_dccp_setsockopt,\n\t.compat_getsockopt = compat_dccp_getsockopt,\n#endif\n};\n\nstatic const struct inet6_protocol dccp_v6_protocol = {\n\t.handler\t= dccp_v6_rcv,\n\t.err_handler\t= dccp_v6_err,\n\t.flags\t\t= INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic const struct proto_ops inet6_dccp_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = dccp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = inet_dccp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw dccp_v6_protosw = {\n\t.type\t\t= SOCK_DCCP,\n\t.protocol\t= IPPROTO_DCCP,\n\t.prot\t\t= &dccp_v6_prot,\n\t.ops\t\t= &inet6_dccp_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int __net_init dccp_v6_init_net(struct net *net)\n{\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&net->dccp.v6_ctl_sk, PF_INET6,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n\nstatic void __net_exit dccp_v6_exit_net(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->dccp.v6_ctl_sk);\n}\n\nstatic void __net_exit dccp_v6_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&dccp_hashinfo, AF_INET6);\n}\n\nstatic struct pernet_operations dccp_v6_ops = {\n\t.init   = dccp_v6_init_net,\n\t.exit   = dccp_v6_exit_net,\n\t.exit_batch = dccp_v6_exit_batch,\n};\n\nstatic int __init dccp_v6_init(void)\n{\n\tint err = proto_register(&dccp_v6_prot, 1);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\n\tinet6_register_protosw(&dccp_v6_protosw);\n\n\terr = register_pernet_subsys(&dccp_v6_ops);\n\tif (err != 0)\n\t\tgoto out_destroy_ctl_sock;\nout:\n\treturn err;\n\nout_destroy_ctl_sock:\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\nout_unregister_proto:\n\tproto_unregister(&dccp_v6_prot);\n\tgoto out;\n}\n\nstatic void __exit dccp_v6_exit(void)\n{\n\tunregister_pernet_subsys(&dccp_v6_ops);\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\n\tproto_unregister(&dccp_v6_prot);\n}\n\nmodule_init(dccp_v6_init);\nmodule_exit(dccp_v6_exit);\n\n/*\n * __stringify doesn't likes enums, so use SOCK_DCCP (6) and IPPROTO_DCCP (33)\n * values directly, Also cover the case where the protocol is not specified,\n * i.e. net-pf-PF_INET6-proto-0-type-SOCK_DCCP\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 33, 6);\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 0, 6);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@mandriva.com>\");\nMODULE_DESCRIPTION(\"DCCPv6 - Datagram Congestion Controlled Protocol\");\n", "/*\n *\tTCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on:\n *\tlinux/net/ipv4/tcp.c\n *\tlinux/net/ipv4/tcp_input.c\n *\tlinux/net/ipv4/tcp_output.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *\tYOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/tcp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nstatic int\ttcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t\tinet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic u32 tcp_v6_init_seq(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_seq(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\tipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\ttcp_hdr(skb)->dest,\n\t\t\t\ttcp_hdr(skb)->source);\n}\n\nstatic u32 tcp_v6_init_ts_off(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_ts_off(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t   ipv6_hdr(skb)->saddr.s6_addr32);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\tstruct inet_timewait_death_row *tcp_death_row = &sock_net(sk)->ipv4.tcp_death_row;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t/*\n\t *\tconnect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\n\tif (ipv6_addr_any(&usin->sin6_addr)) {\n\t\tif (ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr))\n\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),\n\t\t\t\t\t       &usin->sin6_addr);\n\t\telse\n\t\t\tusin->sin6_addr = in6addr_loopback;\n\t}\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq = 0;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t *\tTCP over IPv4\n\t */\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &ipv6_mapped;\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &ipv6_specific;\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tfl6.flowi6_uid = sk->sk_uid;\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n\t\t\t\t\t opt->opt_nflen;\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (likely(!tp->repair)) {\n\t\tif (!tp->write_seq)\n\t\t\ttp->write_seq = secure_tcpv6_seq(np->saddr.s6_addr32,\n\t\t\t\t\t\t\t sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t\t inet->inet_sport,\n\t\t\t\t\t\t\t inet->inet_dport);\n\t\ttp->tsoffset = secure_tcpv6_ts_off(np->saddr.s6_addr32,\n\t\t\t\t\t\t   sk->sk_v6_daddr.s6_addr32);\n\t}\n\n\tif (tcp_fastopen_defer_connect(sk, &err))\n\t\treturn err;\n\tif (err)\n\t\tgoto late_failure;\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, tcp_sk(sk)->mtu_info);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq, fatal);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, fl6, sk->sk_mark, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn tcp_md5_do_lookup(sk, (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n}\n\nstatic int tcp_v6_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\t/* 1. TCP pseudo-header (RFC2460) */\n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic bool tcp_v6_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tu8 newhash[16];\n\n\thash_expected = tcp_v6_md5_do_lookup(sk, &ip6h->saddr);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* check the signature */\n\tgenhash = tcp_v6_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);\n\t\tnet_info_ratelimited(\"MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t\t     genhash ? \"failed\" : \"mismatch\",\n\t\t\t\t     &ip6h->saddr, ntohs(th->source),\n\t\t\t\t     &ip6h->daddr, ntohs(th->dest));\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req)\n{\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v6_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_seq,\n\t.init_ts_off\t=\ttcp_v6_init_ts_off,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, __be32 label)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\tstruct dst_entry *dst;\n\t__be32 *topt;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\tbuff = alloc_skb(MAX_HEADER + sizeof(struct ipv6hdr) + tot_len,\n\t\t\t GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);\n\n\tt1 = (struct tcphdr *) skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t/* Swap the send and the receive. */\n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\tbuff->csum = 0;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse {\n\t\tif (!oif && netif_index_is_l3_master(net, skb->skb_iif))\n\t\t\toif = skb->skb_iif;\n\n\t\tfl6.flowi6_oif = oif;\n\t}\n\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tfl6.flowi6_uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\t/* Pass a socket to ip6_dst_lookup either it is for RST\n\t * Underlying function will use this to retrieve the network\n\t * namespace\n\t */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, fl6.flowi6_mark, NULL, tclass);\n\t\tTCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tint oif;\n\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tkey = tcp_v6_md5_do_lookup(sk, &ipv6h->saddr);\n\t} else if (hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = inet6_lookup_listener(dev_net(skb_dst(skb)->dev),\n\t\t\t\t\t   &tcp_hashinfo, NULL, 0,\n\t\t\t\t\t   &ipv6h->saddr,\n\t\t\t\t\t   th->source, &ipv6h->daddr,\n\t\t\t\t\t   ntohs(th->source), tcp_v6_iif(skb));\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\toif = sk ? sk->sk_bound_dev_if : 0;\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    __be32 label)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\t/* RFC 7323 2.3\n\t * The window field (SEG.WND) of every outgoing segment, with the\n\t * exception of <SYN> segments, MUST be right-shifted by\n\t * Rcv.Wind.Shift bits:\n\t */\n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp + tcp_rsk(req)->ts_off,\n\t\t\treq->ts_recent, sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),\n\t\t\t0, 0);\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0; /* don't send reset */\n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t/* We need to move header back to the beginning if xfrm6_policy_check()\n\t * and tcp_v6_fill_cb() are going to be called again.\n\t * ip6_datagram_recv_specific_ctl() also expects IP6CB to be there.\n\t */\n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_mask(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_mask(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions) {\n\t\t\t\ttcp_v6_restore_cb(newnp->pktoptions);\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\ttcp_listendrop(sk);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t/* This is tricky: we move IP6CB at its correct location into\n\t * TCP_SKB_CB(). It must be done after xfrm6_policy_check(), because\n\t * _decode_session6() uses IP6CB().\n\t * barrier() makes sure compiler won't play aliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n}\n\nstatic int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr)/4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb),\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nstatic void tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t/* Note : We use inet6_iif() here, not tcp_v6_iif() */\n\tsk = __inet6_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nstatic const struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/*\n *\tTCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\nstatic void tcp_v6_destroy_sock(struct sock *sk)\n{\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCPv6 sock list dumping. */\nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0, /* could print option size, but that is af dependent. */\n\t\t   1,   /* timers active (only the expire timer) */\n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,  /* non standard timer */\n\t\t   0, /* open_requests have no inode */\n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sp->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   tp->write_seq - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\t   tp->snd_cwnd,\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct file_operations tcp6_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.name\t\t= \"tcp6\",\n\t.family\t\t= AF_INET6,\n\t.seq_fops\t= &tcp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp6_seq_show,\n\t},\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp6_seq_afinfo);\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}\n#endif\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v6_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.keepalive\t\t= tcp_set_keepalive,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet6_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n\t.diag_destroy\t\t= tcp_abort,\n};\n\nstatic struct inet6_protocol tcpv6_protocol = {\n\t.early_demux\t=\ttcp_v6_early_demux,\n\t.early_demux_handler =  tcp_v6_early_demux,\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n"], "fixing_code": ["/*\n *\tDCCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tBased on net/dccp6/ipv6.c\n *\n *\tArnaldo Carvalho de Melo <acme@ghostprotocols.net>\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/xfrm.h>\n\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_sock.h>\n#include <net/inet6_connection_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n#include <net/secure_seq.h>\n\n#include \"dccp.h\"\n#include \"ipv6.h\"\n#include \"feat.h\"\n\n/* The per-net dccp.v6_ctl_sk is used for sending RSTs and ACKs */\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops;\n\n/* add pseudo-header to DCCP checksum stored in skb->csum */\nstatic inline __sum16 dccp_v6_csum_finish(struct sk_buff *skb,\n\t\t\t\t      const struct in6_addr *saddr,\n\t\t\t\t      const struct in6_addr *daddr)\n{\n\treturn csum_ipv6_magic(saddr, daddr, skb->len, IPPROTO_DCCP, skb->csum);\n}\n\nstatic inline void dccp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\n\tdccp_csum_outgoing(skb);\n\tdh->dccph_checksum = dccp_v6_csum_finish(skb, &np->saddr, &sk->sk_v6_daddr);\n}\n\nstatic inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}\n\nstatic void dccp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct dccp_hdr *dh;\n\tstruct dccp_sock *dp;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\t__u64 seq;\n\tstruct net *net = dev_net(skb->dev);\n\n\t/* Only need dccph_dport & dccph_sport which are the first\n\t * 4 bytes in dccp header.\n\t * Our caller (icmpv6_notify()) already pulled 8 bytes for us.\n\t */\n\tBUILD_BUG_ON(offsetofend(struct dccp_hdr, dccph_sport) > 8);\n\tBUILD_BUG_ON(offsetofend(struct dccp_hdr, dccph_dport) > 8);\n\tdh = (struct dccp_hdr *)(skb->data + offset);\n\n\tsk = __inet6_lookup_established(net, &dccp_hashinfo,\n\t\t\t\t\t&hdr->daddr, dh->dccph_dport,\n\t\t\t\t\t&hdr->saddr, ntohs(dh->dccph_sport),\n\t\t\t\t\tinet6_iif(skb));\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = dccp_hdr_seq(dh);\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV)\n\t\treturn dccp_req_err(sk, seq);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == DCCP_CLOSED)\n\t\tgoto out;\n\n\tdp = dccp_sk(sk);\n\tif ((1 << sk->sk_state) & ~(DCCPF_REQUESTING | DCCPF_LISTEN) &&\n\t    !between48(seq, dp->dccps_awl, dp->dccps_awh)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tstruct dst_entry *dst = NULL;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\tif (sock_owned_by_user(sk))\n\t\t\tgoto out;\n\t\tif ((1 << sk->sk_state) & (DCCPF_LISTEN | DCCPF_CLOSED))\n\t\t\tgoto out;\n\n\t\tdst = inet6_csk_update_pmtu(sk, ntohl(info));\n\t\tif (!dst)\n\t\t\tgoto out;\n\n\t\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst))\n\t\t\tdccp_sync_mss(sk, dst_mtu(dst));\n\t\tgoto out;\n\t}\n\n\ticmpv6_err_convert(type, code, &err);\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\tcase DCCP_RESPOND:  /* Cannot happen.\n\t\t\t       It can, it SYNs are crossed. --ANK */\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\t\t\tsk->sk_err = err;\n\t\t\t/*\n\t\t\t * Wake people up to see the error\n\t\t\t * (see connect in sock.c)\n\t\t\t */\n\t\t\tsk->sk_error_report(sk);\n\t\t\tdccp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, &fl6, sk->sk_mark, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic void dccp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tdccp_feat_list_purge(&dccp_rsk(req)->dreq_featneg);\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\nstatic void dccp_v6_ctl_send_reset(const struct sock *sk, struct sk_buff *rxskb)\n{\n\tconst struct ipv6hdr *rxip6h;\n\tstruct sk_buff *skb;\n\tstruct flowi6 fl6;\n\tstruct net *net = dev_net(skb_dst(rxskb)->dev);\n\tstruct sock *ctl_sk = net->dccp.v6_ctl_sk;\n\tstruct dst_entry *dst;\n\n\tif (dccp_hdr(rxskb)->dccph_type == DCCP_PKT_RESET)\n\t\treturn;\n\n\tif (!ipv6_unicast_destination(rxskb))\n\t\treturn;\n\n\tskb = dccp_ctl_make_reset(ctl_sk, rxskb);\n\tif (skb == NULL)\n\t\treturn;\n\n\trxip6h = ipv6_hdr(rxskb);\n\tdccp_hdr(skb)->dccph_checksum = dccp_v6_csum_finish(skb, &rxip6h->saddr,\n\t\t\t\t\t\t\t    &rxip6h->daddr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = rxip6h->saddr;\n\tfl6.saddr = rxip6h->daddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.flowi6_oif = inet6_iif(rxskb);\n\tfl6.fl6_dport = dccp_hdr(skb)->dccph_dport;\n\tfl6.fl6_sport = dccp_hdr(skb)->dccph_sport;\n\tsecurity_skb_classify_flow(rxskb, flowi6_to_flowi(&fl6));\n\n\t/* sk = NULL, but it is safe for now. RST socket required. */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(skb, dst);\n\t\tip6_xmit(ctl_sk, skb, &fl6, 0, NULL, 0);\n\t\tDCCP_INC_STATS(DCCP_MIB_OUTSEGS);\n\t\tDCCP_INC_STATS(DCCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic struct request_sock_ops dccp6_request_sock_ops = {\n\t.family\t\t= AF_INET6,\n\t.obj_size\t= sizeof(struct dccp6_request_sock),\n\t.rtx_syn_ack\t= dccp_v6_send_response,\n\t.send_ack\t= dccp_reqsk_send_ack,\n\t.destructor\t= dccp_v6_reqsk_destructor,\n\t.send_reset\t= dccp_v6_ctl_send_reset,\n\t.syn_ack_timeout = dccp_syn_ack_timeout,\n};\n\nstatic int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct request_sock *req;\n\tstruct dccp_request_sock *dreq;\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tconst __be32 service = dccp_hdr_request(skb)->dccph_req_service;\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\treturn 0;\t/* discard, don't send a reset here */\n\n\tif (dccp_bad_service_code(sk, service)) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_BAD_SERVICE_CODE;\n\t\tgoto drop;\n\t}\n\t/*\n\t * There are no SYN attacks on IPv6, yet...\n\t */\n\tdcb->dccpd_reset_code = DCCP_RESET_CODE_TOO_BUSY;\n\tif (inet_csk_reqsk_queue_is_full(sk))\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto drop;\n\n\treq = inet_reqsk_alloc(&dccp6_request_sock_ops, sk, true);\n\tif (req == NULL)\n\t\tgoto drop;\n\n\tif (dccp_reqsk_init(req, dccp_sk(sk), skb))\n\t\tgoto drop_and_free;\n\n\tdreq = dccp_rsk(req);\n\tif (dccp_parse_options(sk, dreq, skb))\n\t\tgoto drop_and_free;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto drop_and_free;\n\n\tireq = inet_rsk(req);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\tireq->ireq_family = AF_INET6;\n\n\tif (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\tireq->ir_iif = sk->sk_bound_dev_if;\n\n\t/* So that link locals have meaning */\n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = inet6_iif(skb);\n\n\t/*\n\t * Step 3: Process LISTEN state\n\t *\n\t *   Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookie\n\t *\n\t * Setting S.SWL/S.SWH to is deferred to dccp_create_openreq_child().\n\t */\n\tdreq->dreq_isr\t   = dcb->dccpd_seq;\n\tdreq->dreq_gsr     = dreq->dreq_isr;\n\tdreq->dreq_iss\t   = dccp_v6_init_sequence(skb);\n\tdreq->dreq_gss     = dreq->dreq_iss;\n\tdreq->dreq_service = service;\n\n\tif (dccp_v6_send_response(sk, req))\n\t\tgoto drop_and_free;\n\n\tinet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);\n\treturn 0;\n\ndrop_and_free:\n\treqsk_free(req);\ndrop:\n\t__DCCP_INC_STATS(DCCP_MIB_ATTEMPTFAILS);\n\treturn -1;\n}\n\nstatic struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct request_sock *req,\n\t\t\t\t\t      struct dst_entry *dst,\n\t\t\t\t\t      struct request_sock *req_unhash,\n\t\t\t\t\t      bool *own_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tstruct dccp6_sock *newdp6;\n\tstruct sock *newsk;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t  req_unhash, own_req);\n\t\tif (newsk == NULL)\n\t\t\treturn NULL;\n\n\t\tnewdp6 = (struct dccp6_sock *)newsk;\n\t\tnewinet = inet_sk(newsk);\n\t\tnewinet->pinet6 = &newdp6->inet6;\n\t\tnewnp = inet6_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->ipv6_mc_list = NULL;\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->mcast_oif   = inet6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, dccp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, dccp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |\n\t\t\t\t\t\t      NETIF_F_TSO);\n\tnewdp6 = (struct dccp6_sock *)newsk;\n\tnewinet = inet_sk(newsk);\n\tnewinet->pinet6 = &newdp6->inet6;\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;\n\tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if\t= ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = inet6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\n\t/*\n\t * Clone native IPv6 options from listening socket (if any)\n\t *\n\t * Yes, keeping reference count would be much more clever, but we make\n\t * one more one thing there: reattach optmem to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\tdccp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\t/* Clone pktoptions received with SYN, if we own the req */\n\tif (*own_req && ireq->pktopts) {\n\t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);\n\t\tconsume_skb(ireq->pktopts);\n\t\tireq->pktopts = NULL;\n\t\tif (newnp->pktoptions)\n\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int dccp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, dccp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   dccp_v6_hnd_req and dccp_v6_ctl_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn dccp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t * socket locking is here for SMP purposes as backlog rcv is currently\n\t * called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t/*\n\t * FIXME: Add handling of IPV6_PKTOPTIONS skb. See the comments below\n\t *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.\n\t */\n\t\topt_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (sk->sk_state == DCCP_OPEN) { /* Fast path */\n\t\tif (dccp_rcv_established(sk, skb, dccp_hdr(skb), skb->len))\n\t\t\tgoto reset;\n\t\tif (opt_skb) {\n\t\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t\t__kfree_skb(opt_skb);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init Cookies\n\t *\t      Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t *\n\t * NOTE: the check for the packet types is done in\n\t *\t dccp_rcv_state_process\n\t */\n\n\tif (dccp_rcv_state_process(sk, skb, dccp_hdr(skb), skb->len))\n\t\tgoto reset;\n\tif (opt_skb) {\n\t\t/* XXX This is where we would goto ipv6_pktoptions. */\n\t\t__kfree_skb(opt_skb);\n\t}\n\treturn 0;\n\nreset:\n\tdccp_v6_ctl_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb != NULL)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int dccp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct dccp_hdr *dh;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint min_cov;\n\n\t/* Step 1: Check header basics */\n\n\tif (dccp_invalid_packet(skb))\n\t\tgoto discard_it;\n\n\t/* Step 1: If header checksum is incorrect, drop packet and return. */\n\tif (dccp_v6_csum_finish(skb, &ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr)) {\n\t\tDCCP_WARN(\"dropped packet with invalid checksum\\n\");\n\t\tgoto discard_it;\n\t}\n\n\tdh = dccp_hdr(skb);\n\n\tDCCP_SKB_CB(skb)->dccpd_seq  = dccp_hdr_seq(dh);\n\tDCCP_SKB_CB(skb)->dccpd_type = dh->dccph_type;\n\n\tif (dccp_packet_without_ack(skb))\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = DCCP_PKT_WITHOUT_ACK_SEQ;\n\telse\n\t\tDCCP_SKB_CB(skb)->dccpd_ack_seq = dccp_hdr_ack_seq(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&dccp_hashinfo, skb, __dccp_hdr_len(dh),\n\t\t\t        dh->dccph_sport, dh->dccph_dport,\n\t\t\t\tinet6_iif(skb), &refcounted);\n\tif (!sk) {\n\t\tdccp_pr_debug(\"failed to look up flow ID in table and \"\n\t\t\t      \"get corresponding socket\\n\");\n\t\tgoto no_dccp_socket;\n\t}\n\n\t/*\n\t * Step 2:\n\t *\t... or S.state == TIMEWAIT,\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (sk->sk_state == DCCP_TIME_WAIT) {\n\t\tdccp_pr_debug(\"sk->sk_state == DCCP_TIME_WAIT: do_time_wait\\n\");\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto no_dccp_socket;\n\t}\n\n\tif (sk->sk_state == DCCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(sk->sk_state != DCCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = dccp_check_req(sk, skb, req);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (dccp_child_process(sk, nsk, skb)) {\n\t\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * RFC 4340, sec. 9.2.1: Minimum Checksum Coverage\n\t *\to if MinCsCov = 0, only packets with CsCov = 0 are accepted\n\t *\to if MinCsCov > 0, also accept packets with CsCov >= MinCsCov\n\t */\n\tmin_cov = dccp_sk(sk)->dccps_pcrlen;\n\tif (dh->dccph_cscov  &&  (min_cov == 0 || dh->dccph_cscov < min_cov))  {\n\t\tdccp_pr_debug(\"Packet CsCov %d does not satisfy MinCsCov %d\\n\",\n\t\t\t      dh->dccph_cscov, min_cov);\n\t\t/* FIXME: send Data Dropped option (see also dccp_v4_rcv) */\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\treturn __sk_receive_skb(sk, skb, 1, dh->dccph_doff * 4,\n\t\t\t\trefcounted) ? -1 : 0;\n\nno_dccp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\t/*\n\t * Step 2:\n\t *\tIf no socket ...\n\t *\t\tGenerate Reset(No Connection) unless P.type == Reset\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type != DCCP_PKT_RESET) {\n\t\tDCCP_SKB_CB(skb)->dccpd_reset_code =\n\t\t\t\t\tDCCP_RESET_CODE_NO_CONNECTION;\n\t\tdccp_v6_ctl_send_reset(sk, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n}\n\nstatic int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t   int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\t/*\n\t * connect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\tif (ipv6_addr_any(&usin->sin6_addr))\n\t\tusin->sin6_addr.s6_addr[15] = 1;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t * DCCP over IPv4\n\t */\n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &dccp_ipv6_mapped;\n\t\tsk->sk_backlog_rcv = dccp_v4_do_rcv;\n\n\t\terr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &dccp_ipv6_af_ops;\n\t\t\tsk->sk_backlog_rcv = dccp_v6_do_rcv;\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (saddr == NULL) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\n\tinet->inet_dport = usin->sin6_port;\n\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet6_hash_connect(&dccp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tdp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,\n\t\t\t\t\t\t      sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t      inet->inet_sport,\n\t\t\t\t\t\t      inet->inet_dport);\n\terr = dccp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\tdccp_set_state(sk, DCCP_CLOSED);\n\t__sk_dst_reset(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_af_ops = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = dccp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/*\n *\tDCCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops dccp_ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = dccp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.conn_request\t   = dccp_v6_conn_request,\n\t.syn_recv_sock\t   = dccp_v6_request_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n};\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int dccp_v6_init_sock(struct sock *sk)\n{\n\tstatic __u8 dccp_v6_ctl_sock_initialized;\n\tint err = dccp_init_sock(sk, dccp_v6_ctl_sock_initialized);\n\n\tif (err == 0) {\n\t\tif (unlikely(!dccp_v6_ctl_sock_initialized))\n\t\t\tdccp_v6_ctl_sock_initialized = 1;\n\t\tinet_csk(sk)->icsk_af_ops = &dccp_ipv6_af_ops;\n\t}\n\n\treturn err;\n}\n\nstatic void dccp_v6_destroy_sock(struct sock *sk)\n{\n\tdccp_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\nstatic struct timewait_sock_ops dccp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct dccp6_timewait_sock),\n};\n\nstatic struct proto dccp_v6_prot = {\n\t.name\t\t   = \"DCCPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = dccp_close,\n\t.connect\t   = dccp_v6_connect,\n\t.disconnect\t   = dccp_disconnect,\n\t.ioctl\t\t   = dccp_ioctl,\n\t.init\t\t   = dccp_v6_init_sock,\n\t.setsockopt\t   = dccp_setsockopt,\n\t.getsockopt\t   = dccp_getsockopt,\n\t.sendmsg\t   = dccp_sendmsg,\n\t.recvmsg\t   = dccp_recvmsg,\n\t.backlog_rcv\t   = dccp_v6_do_rcv,\n\t.hash\t\t   = inet6_hash,\n\t.unhash\t\t   = inet_unhash,\n\t.accept\t\t   = inet_csk_accept,\n\t.get_port\t   = inet_csk_get_port,\n\t.shutdown\t   = dccp_shutdown,\n\t.destroy\t   = dccp_v6_destroy_sock,\n\t.orphan_count\t   = &dccp_orphan_count,\n\t.max_header\t   = MAX_DCCP_HEADER,\n\t.obj_size\t   = sizeof(struct dccp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.rsk_prot\t   = &dccp6_request_sock_ops,\n\t.twsk_prot\t   = &dccp6_timewait_sock_ops,\n\t.h.hashinfo\t   = &dccp_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_dccp_setsockopt,\n\t.compat_getsockopt = compat_dccp_getsockopt,\n#endif\n};\n\nstatic const struct inet6_protocol dccp_v6_protocol = {\n\t.handler\t= dccp_v6_rcv,\n\t.err_handler\t= dccp_v6_err,\n\t.flags\t\t= INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic const struct proto_ops inet6_dccp_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = dccp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.listen\t\t   = inet_dccp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.sendpage\t   = sock_no_sendpage,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_sock_common_setsockopt,\n\t.compat_getsockopt = compat_sock_common_getsockopt,\n#endif\n};\n\nstatic struct inet_protosw dccp_v6_protosw = {\n\t.type\t\t= SOCK_DCCP,\n\t.protocol\t= IPPROTO_DCCP,\n\t.prot\t\t= &dccp_v6_prot,\n\t.ops\t\t= &inet6_dccp_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int __net_init dccp_v6_init_net(struct net *net)\n{\n\tif (dccp_hashinfo.bhash == NULL)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\treturn inet_ctl_sock_create(&net->dccp.v6_ctl_sk, PF_INET6,\n\t\t\t\t    SOCK_DCCP, IPPROTO_DCCP, net);\n}\n\nstatic void __net_exit dccp_v6_exit_net(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->dccp.v6_ctl_sk);\n}\n\nstatic void __net_exit dccp_v6_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&dccp_hashinfo, AF_INET6);\n}\n\nstatic struct pernet_operations dccp_v6_ops = {\n\t.init   = dccp_v6_init_net,\n\t.exit   = dccp_v6_exit_net,\n\t.exit_batch = dccp_v6_exit_batch,\n};\n\nstatic int __init dccp_v6_init(void)\n{\n\tint err = proto_register(&dccp_v6_prot, 1);\n\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tif (err != 0)\n\t\tgoto out_unregister_proto;\n\n\tinet6_register_protosw(&dccp_v6_protosw);\n\n\terr = register_pernet_subsys(&dccp_v6_ops);\n\tif (err != 0)\n\t\tgoto out_destroy_ctl_sock;\nout:\n\treturn err;\n\nout_destroy_ctl_sock:\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\nout_unregister_proto:\n\tproto_unregister(&dccp_v6_prot);\n\tgoto out;\n}\n\nstatic void __exit dccp_v6_exit(void)\n{\n\tunregister_pernet_subsys(&dccp_v6_ops);\n\tinet6_del_protocol(&dccp_v6_protocol, IPPROTO_DCCP);\n\tinet6_unregister_protosw(&dccp_v6_protosw);\n\tproto_unregister(&dccp_v6_prot);\n}\n\nmodule_init(dccp_v6_init);\nmodule_exit(dccp_v6_exit);\n\n/*\n * __stringify doesn't likes enums, so use SOCK_DCCP (6) and IPPROTO_DCCP (33)\n * values directly, Also cover the case where the protocol is not specified,\n * i.e. net-pf-PF_INET6-proto-0-type-SOCK_DCCP\n */\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 33, 6);\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 0, 6);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arnaldo Carvalho de Melo <acme@mandriva.com>\");\nMODULE_DESCRIPTION(\"DCCPv6 - Datagram Congestion Controlled Protocol\");\n", "/*\n *\tTCP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on:\n *\tlinux/net/ipv4/tcp.c\n *\tlinux/net/ipv4/tcp_input.c\n *\tlinux/net/ipv4/tcp_output.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *\tYOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/tcp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nstatic int\ttcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nstatic const struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn NULL;\n}\n#endif\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tsk->sk_rx_dst = dst;\n\t\tinet_sk(sk)->rx_dst_ifindex = skb->skb_iif;\n\t\tinet6_sk(sk)->rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic u32 tcp_v6_init_seq(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_seq(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\tipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\ttcp_hdr(skb)->dest,\n\t\t\t\ttcp_hdr(skb)->source);\n}\n\nstatic u32 tcp_v6_init_ts_off(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_ts_off(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t   ipv6_hdr(skb)->saddr.s6_addr32);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_type;\n\tint err;\n\tstruct inet_timewait_death_row *tcp_death_row = &sock_net(sk)->ipv4.tcp_death_row;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t/*\n\t *\tconnect() to INADDR_ANY means loopback (BSD'ism).\n\t */\n\n\tif (ipv6_addr_any(&usin->sin6_addr)) {\n\t\tif (ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr))\n\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),\n\t\t\t\t\t       &usin->sin6_addr);\n\t\telse\n\t\t\tusin->sin6_addr = in6addr_loopback;\n\t}\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t/* If interface is set while binding, indices\n\t\t\t * must coincide.\n\t\t\t */\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t/* Connect to link-local address requires an interface */\n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\ttp->write_seq = 0;\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t/*\n\t *\tTCP over IPv4\n\t */\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");\n\n\t\tif (__ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\ticsk->icsk_af_ops = &ipv6_mapped;\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\ticsk->icsk_af_ops = &ipv6_specific;\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tfl6.flowi6_uid = sk->sk_uid;\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\t\tsk->sk_v6_rcv_saddr = *saddr;\n\t}\n\n\t/* set the source address */\n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n\t\t\t\t\t opt->opt_nflen;\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (likely(!tp->repair)) {\n\t\tif (!tp->write_seq)\n\t\t\ttp->write_seq = secure_tcpv6_seq(np->saddr.s6_addr32,\n\t\t\t\t\t\t\t sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t\t inet->inet_sport,\n\t\t\t\t\t\t\t inet->inet_dport);\n\t\ttp->tsoffset = secure_tcpv6_ts_off(np->saddr.s6_addr32,\n\t\t\t\t\t\t   sk->sk_v6_daddr.s6_addr32);\n\t}\n\n\tif (tcp_fastopen_defer_connect(sk, &err))\n\t\treturn err;\n\tif (err)\n\t\tgoto late_failure;\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, tcp_sk(sk)->mtu_info);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic void tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, &tcp_hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex);\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn tcp_req_err(sk, seq, fatal);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (ipv6_hdr(skb)->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto out;\n\t}\n\n\ttp = tcp_sk(sk);\n\t/* XXX (TFO) - tp->snd_una should be ISN (tcp_create_openreq_child() */\n\tfastopen = tp->fastopen_rsk;\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\t/* We are not interested in TCP_LISTEN and open_requests\n\t\t * (SYN-ACKs send out by Linux are always <576bytes so\n\t\t * they should go through unfragmented).\n\t\t */\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\ttp->mtu_info = ntohl(info);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t/* Might be for an request_sock */\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t/* Only in fast or simultaneous open. If a fast open socket is\n\t\t * is already accepted it is treated as a connected one below.\n\t\t */\n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tsk->sk_err = err;\n\t\t\tsk->sk_error_report(sk);\t\t/* Wake people up to see the error (see connect in sock.c) */\n\n\t\t\ttcp_done(sk);\n\t\t} else\n\t\t\tsk->sk_err_soft = err;\n\t\tgoto out;\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tsk->sk_err_soft = err;\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t/* First, grab a route. */\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, fl6, sk->sk_mark, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\treturn tcp_md5_do_lookup(sk, (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, char __user *optval,\n\t\t\t\t int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, cmd.tcpm_key, cmd.tcpm_keylen, GFP_KERNEL);\n}\n\nstatic int tcp_v6_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\t/* 1. TCP pseudo-header (RFC2460) */\n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) { /* valid for establish/request sockets */\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic bool tcp_v6_inbound_md5_hash(const struct sock *sk,\n\t\t\t\t    const struct sk_buff *skb)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct tcp_md5sig_key *hash_expected;\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tint genhash;\n\tu8 newhash[16];\n\n\thash_expected = tcp_v6_md5_do_lookup(sk, &ip6h->saddr);\n\thash_location = tcp_parse_md5sig_option(th);\n\n\t/* We've parsed the options - do we have a hash? */\n\tif (!hash_expected && !hash_location)\n\t\treturn false;\n\n\tif (hash_expected && !hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5NOTFOUND);\n\t\treturn true;\n\t}\n\n\tif (!hash_expected && hash_location) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5UNEXPECTED);\n\t\treturn true;\n\t}\n\n\t/* check the signature */\n\tgenhash = tcp_v6_md5_hash_skb(newhash,\n\t\t\t\t      hash_expected,\n\t\t\t\t      NULL, skb);\n\n\tif (genhash || memcmp(hash_location, newhash, 16) != 0) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMD5FAILURE);\n\t\tnet_info_ratelimited(\"MD5 Hash %s for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t\t     genhash ? \"failed\" : \"mismatch\",\n\t\t\t\t     &ip6h->saddr, ntohs(th->source),\n\t\t\t\t     &ip6h->daddr, ntohs(th->dest));\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  const struct request_sock *req)\n{\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nstatic const struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n\t.init_req\t=\ttcp_v6_init_req,\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_seq,\n\t.init_ts_off\t=\ttcp_v6_init_ts_off,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, __be32 label)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\tstruct dst_entry *dst;\n\t__be32 *topt;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\tbuff = alloc_skb(MAX_HEADER + sizeof(struct ipv6hdr) + tot_len,\n\t\t\t GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_HEADER + sizeof(struct ipv6hdr) + tot_len);\n\n\tt1 = (struct tcphdr *) skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t/* Swap the send and the receive. */\n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\tbuff->csum = 0;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse {\n\t\tif (!oif && netif_index_is_l3_master(net, skb->skb_iif))\n\t\t\toif = skb->skb_iif;\n\n\t\tfl6.flowi6_oif = oif;\n\t}\n\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark);\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tfl6.flowi6_uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi(&fl6));\n\n\t/* Pass a socket to ip6_dst_lookup either it is for RST\n\t * Underlying function will use this to retrieve the network\n\t * namespace\n\t */\n\tdst = ip6_dst_lookup_flow(ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, fl6.flowi6_mark, NULL, tclass);\n\t\tTCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\tint oif;\n\n\tif (th->rst)\n\t\treturn;\n\n\t/* If sk not NULL, it means we did a successful lookup and incoming\n\t * route had to be correct. prequeue might have dropped our dst.\n\t */\n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tkey = tcp_v6_md5_do_lookup(sk, &ipv6h->saddr);\n\t} else if (hash_location) {\n\t\t/*\n\t\t * active side is lost. Try to find listening socket through\n\t\t * source port, and then find md5 key through listening socket.\n\t\t * we are not loose security here:\n\t\t * Incoming packet is checked with md5 hash with finding key,\n\t\t * no RST generated if md5 hash doesn't match.\n\t\t */\n\t\tsk1 = inet6_lookup_listener(dev_net(skb_dst(skb)->dev),\n\t\t\t\t\t   &tcp_hashinfo, NULL, 0,\n\t\t\t\t\t   &ipv6h->saddr,\n\t\t\t\t\t   th->source, &ipv6h->daddr,\n\t\t\t\t\t   ntohs(th->source), tcp_v6_iif(skb));\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\toif = sk ? sk->sk_bound_dev_if : 0;\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    __be32 label)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel));\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\t/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV\n\t * sk->sk_state == TCP_SYN_RECV -> for Fast Open.\n\t */\n\t/* RFC 7323 2.3\n\t * The window field (SEG.WND) of every outgoing segment, with the\n\t * exception of <SYN> segments, MUST be right-shifted by\n\t * Rcv.Wind.Shift bits:\n\t */\n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp + tcp_rsk(req)->ts_off,\n\t\t\treq->ts_recent, sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),\n\t\t\t0, 0);\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0; /* don't send reset */\n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t/* We need to move header back to the beginning if xfrm6_policy_check()\n\t * and tcp_v6_fill_cb() are going to be called again.\n\t * ip6_datagram_recv_specific_ctl() also expects IP6CB to be there.\n\t */\n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct tcp6_sock *newtcp6sk;\n\tstruct inet_sock *newinet;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t/*\n\t\t *\tv6 mapped\n\t\t */\n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\t\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\t\tnewinet = inet_sk(newsk);\n\t\tnewnp = inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_mc_list = NULL;\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = tcp_v6_iif(skb);\n\t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;\n\t\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t\t/*\n\t\t * No need to charge this sock to the relevant IPv6 refcnt debug socks count\n\t\t * here, tcp_create_openreq_child now does this for us, see the comment in\n\t\t * that function for the gory details. -acme\n\t\t */\n\n\t\t/* It is tricky place. Until this moment IPv4 tcp\n\t\t   worked with IPv6 icsk.icsk_af_ops.\n\t\t   Sync it now.\n\t\t */\n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t/*\n\t * No need to charge this sock to the relevant IPv6 refcnt debug socks\n\t * count here, tcp_create_openreq_child now does this for us, see the\n\t * comment in that function for the gory details. -acme\n\t */\n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tnewtcp6sk = (struct tcp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newtcp6sk->inet6;\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t/* Now IPv6 options...\n\n\t   First: no IPv4 options.\n\t */\n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t/* Clone RX bits */\n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t/* Clone native IPv6 options from listening socket (if any)\n\n\t   Yes, keeping reference count would be much more clever,\n\t   but we make one more one thing there: reattach optmem\n\t   to newsk.\n\t */\n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\t/* Copy over the MD5 key from the original socket */\n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);\n\tif (key) {\n\t\t/* We're using one, so create a matching key\n\t\t * on the newsk structure. If we fail to get\n\t\t * memory, then we end up not copying the key\n\t\t * across. Shucks.\n\t\t */\n\t\ttcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,\n\t\t\t       AF_INET6, key->key, key->keylen,\n\t\t\t       sk_gfp_mask(sk, GFP_ATOMIC));\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t/* Clone pktoptions received with SYN, if we own the req */\n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone(ireq->pktopts,\n\t\t\t\t\t\t      sk_gfp_mask(sk, GFP_ATOMIC));\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions) {\n\t\t\t\ttcp_v6_restore_cb(newnp->pktoptions);\n\t\t\t\tskb_set_owner_r(newnp->pktoptions, newsk);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\ttcp_listendrop(sk);\n\treturn NULL;\n}\n\n/* The socket must have it's spinlock held when we get\n * here, unless it is a TCP_LISTEN socket.\n *\n * We have a potential double-lock case here, so even when\n * doing backlog processing we use the BH locking scheme.\n * This is because we cannot sleep with the original spinlock\n * held.\n */\nstatic int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t/* This is tricky: we move IP6CB at its correct location into\n\t * TCP_SKB_CB(). It must be done after xfrm6_policy_check(), because\n\t * _decode_session6() uses IP6CB().\n\t * barrier() makes sure compiler won't play aliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n}\n\nstatic int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr)/4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb),\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nstatic void tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t/* Note : We use inet6_iif() here, not tcp_v6_iif() */\n\tsk = __inet6_lookup_established(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = READ_ONCE(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, inet6_sk(sk)->rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    inet_sk(sk)->rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nstatic const struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/*\n *\tTCP over IPv4 via INET6 API\n */\nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_ipv6_setsockopt,\n\t.compat_getsockopt = compat_ipv6_getsockopt,\n#endif\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n/* NOTE: A lot of things set to zero explicitly by call to\n *       sk_alloc() so need not be done here.\n */\nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\nstatic void tcp_v6_destroy_sock(struct sock *sk)\n{\n\ttcp_v4_destroy_sock(sk);\n\tinet6_destroy_sock(sk);\n}\n\n#ifdef CONFIG_PROC_FS\n/* Proc filesystem TCPv6 sock list dumping. */\nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0, /* could print option size, but that is af dependent. */\n\t\t   1,   /* timers active (only the expire timer) */\n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,  /* non standard timer */\n\t\t   0, /* open_requests have no inode */\n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = sp->sk_ack_backlog;\n\telse\n\t\t/* Because we don't lock the socket,\n\t\t * we might find a transient negative value.\n\t\t */\n\t\trx_queue = max_t(int, tp->rcv_nxt - tp->copied_seq, 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   tp->write_seq - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | icsk->icsk_ack.pingpong,\n\t\t   tp->snd_cwnd,\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   atomic_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct file_operations tcp6_afinfo_seq_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = tcp_seq_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release_net\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.name\t\t= \"tcp6\",\n\t.family\t\t= AF_INET6,\n\t.seq_fops\t= &tcp6_afinfo_seq_fops,\n\t.seq_ops\t= {\n\t\t.show\t\t= tcp6_seq_show,\n\t},\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp6_seq_afinfo);\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\ttcp_proc_unregister(net, &tcp6_seq_afinfo);\n}\n#endif\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v6_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.keepalive\t\t= tcp_set_keepalive,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.sendpage\t\t= tcp_sendpage,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet6_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem\t\t= sysctl_tcp_wmem,\n\t.sysctl_rmem\t\t= sysctl_tcp_rmem,\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.slab_flags\t\t= SLAB_DESTROY_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= &tcp_hashinfo,\n\t.no_autobind\t\t= true,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt\t= compat_tcp_setsockopt,\n\t.compat_getsockopt\t= compat_tcp_getsockopt,\n#endif\n\t.diag_destroy\t\t= tcp_abort,\n};\n\nstatic struct inet6_protocol tcpv6_protocol = {\n\t.early_demux\t=\ttcp_v6_early_demux,\n\t.early_demux_handler =  tcp_v6_early_demux,\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\tinet_twsk_purge(&tcp_hashinfo, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t/* register inet6 protocol */\n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\nout:\n\treturn ret;\n\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n"], "filenames": ["net/dccp/ipv6.c", "net/ipv6/tcp_ipv6.c"], "buggy_code_start_loc": [428, 1064], "buggy_code_end_loc": [492, 1133], "fixing_code_start_loc": [429, 1065], "fixing_code_end_loc": [499, 1136], "type": "NVD-CWE-noinfo", "message": "The tcp_v6_syn_recv_sock function in net/ipv6/tcp_ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890.", "other": {"cve": {"id": "CVE-2017-9077", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-19T14:29:00.217", "lastModified": "2023-02-24T18:38:56.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The tcp_v6_syn_recv_sock function in net/ipv6/tcp_ipv6.c in the Linux kernel through 4.11.1 mishandles inheritance, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls, a related issue to CVE-2017-8890."}, {"lang": "es", "value": "La funci\u00f3n tcp_v6_syn_recv_sock en el archivo  net/ipv6/tcp_ipv6.c en el kernel de Linux hasta versi\u00f3n 4.11.1, el manejo inapropiado de la herencia, permite a los usuarios locales causar una denegaci\u00f3n de servicio o posiblemente tener otro impacto no especificado por medio de llamadas del sistema, un problema relacionado con CVE-2017 -8890."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.89", "matchCriteriaId": "9A5C1F01-214B-4477-A3A1-F6DF10181D3C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.44", "matchCriteriaId": "8C1901E2-6C4D-488B-A7CE-F7E14A38418F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.84", "matchCriteriaId": "DB67DFF9-D1AD-49F9-AC6A-2BBFE1619CE2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.4.71", "matchCriteriaId": "A4AF9D2F-2101-41EE-9E8C-95EE62CB1186"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.31", "matchCriteriaId": "001F55C3-810A-444F-AE18-F067A84F6B31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.11.4", "matchCriteriaId": "1A25FD29-5617-4236-AC9A-6D68DC220925"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=83eaddab4378db256d00d295bda6ca997cd13a52", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3886", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98583", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1842", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2077", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2669", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1854", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://patchwork.ozlabs.org/patch/760370/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-11-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/83eaddab4378db256d00d295bda6ca997cd13a52"}}