{"buggy_code": ["/*\n\tgd_bmp.c\n\n\tBitmap format support for libgd\n\n\t* Written 2007, Scott MacVicar\n\t---------------------------------------------------------------------------\n\n\tTodo:\n\n\tBitfield encoding\n\n\t----------------------------------------------------------------------------\n */\n\n/**\n * File: BMP IO\n *\n * Read and write BMP images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"bmp.h\"\n\nstatic int compress_row(unsigned char *uncompressed_row, int length);\nstatic int build_rle_packet(unsigned char *row, int packet_type, int length, unsigned char *data);\n\nstatic int bmp_read_header(gdIOCtxPtr infile, bmp_hdr_t *hdr);\nstatic int bmp_read_info(gdIOCtxPtr infile, bmp_info_t *info);\nstatic int bmp_read_windows_v3_info(gdIOCtxPtr infile, bmp_info_t *info);\nstatic int bmp_read_os2_v1_info(gdIOCtxPtr infile, bmp_info_t *info);\nstatic int bmp_read_os2_v2_info(gdIOCtxPtr infile, bmp_info_t *info);\n\nstatic int bmp_read_direct(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_1bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_4bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_8bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_rle(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info);\n\nstatic int _gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression);\n\n#define BMP_DEBUG(s)\n\nstatic int gdBMPPutWord(gdIOCtx *out, int w)\n{\n\t/* Byte order is little-endian */\n\tgdPutC(w & 0xFF, out);\n\tgdPutC((w >> 8) & 0xFF, out);\n\treturn 0;\n}\n\nstatic int gdBMPPutInt(gdIOCtx *out, int w)\n{\n\t/* Byte order is little-endian */\n\tgdPutC(w & 0xFF, out);\n\tgdPutC((w >> 8) & 0xFF, out);\n\tgdPutC((w >> 16) & 0xFF, out);\n\tgdPutC((w >> 24) & 0xFF, out);\n\treturn 0;\n}\n\n/*\n\tFunction: gdImageBmpPtr\n\n\tOutputs the given image as BMP data, but using a <gdIOCtx> instead\n\tof a file. See <gdImageBmp>.\n\n\tParameters:\n\t\tim\t\t\t- the image to save.\n\t\tsize \t\t- Output: size in bytes of the result.\n\t\tcompression - whether to apply RLE or not.\n\n\tReturns:\n\n\t\tA pointer to memory containing the image data or NULL on error.\n*/\nBGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageBmpCtx(im, out, compression))\n\t\trv = gdDPExtractData(out, size);\n\telse\n\t\trv = NULL;\n\tout->gd_free(out);\n\treturn rv;\n}\n\n/*\n\tFunction: gdImageBmp\n\n    <gdImageBmp> outputs the specified image to the specified file in\n    BMP format. The file must be open for writing. Under MSDOS and all\n    versions of Windows, it is important to use \"wb\" as opposed to\n    simply \"w\" as the mode when opening the file, and under Unix there\n    is no penalty for doing so. <gdImageBmp> does not close the file;\n    your code must do so.\n\n    In addition, <gdImageBmp> allows to specify whether RLE compression\n    should be applied.\n\n\tVariants:\n\n\t\t<gdImageBmpCtx> write via a <gdIOCtx> instead of a file handle.\n\n\t\t<gdImageBmpPtr> store the image file to memory.\n\n\tParameters:\n\n\t\tim\t\t\t- the image to save.\n\t\toutFile\t\t- the output FILE* object.\n\t\tcompression - whether to apply RLE or not.\n\n\tReturns:\n\t\tnothing\n*/\nBGD_DECLARE(void) gdImageBmp(gdImagePtr im, FILE *outFile, int compression)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) return;\n\tgdImageBmpCtx(im, out, compression);\n\tout->gd_free(out);\n}\n\n/*\n\tFunction: gdImageBmpCtx\n\n\tOutputs the given image as BMP data, but using a <gdIOCtx> instead\n\tof a file. See <gdImageBmp>.\n\n\tParameters:\n\t\tim\t\t\t- the image to save.\n\t\tout \t\t- the <gdIOCtx> to write to.\n\t\tcompression - whether to apply RLE or not.\n*/\nBGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)\n{\n\t_gdImageBmpCtx(im, out, compression);\n}\n\nstatic int _gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)\n{\n\tint bitmap_size = 0, info_size, total_size, padding;\n\tint i, row, xpos, pixel;\n\tint error = 0;\n\tunsigned char *uncompressed_row = NULL, *uncompressed_row_start = NULL;\n\tFILE *tmpfile_for_compression = NULL;\n\tgdIOCtxPtr out_original = NULL;\n\tint ret = 1;\n\n\t/* No compression if its true colour or we don't support seek */\n\tif (im->trueColor) {\n\t\tcompression = 0;\n\t}\n\n\tif (compression && !out->seek) {\n\t\t/* Try to create a temp file where we can seek */\n\t\tif ((tmpfile_for_compression = tmpfile()) == NULL) {\n\t\t\tcompression = 0;\n\t\t} else {\n\t\t\tout_original = out;\n\t\t\tif ((out = (gdIOCtxPtr)gdNewFileCtx(tmpfile_for_compression)) == NULL) {\n\t\t\t\tout = out_original;\n\t\t\t\tout_original = NULL;\n\t\t\t\tcompression = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbitmap_size = ((im->sx * (im->trueColor ? 24 : 8)) / 8) * im->sy;\n\n\t/* 40 byte Windows v3 header */\n\tinfo_size = BMP_WINDOWS_V3;\n\n\t/* data for the palette */\n\tif (!im->trueColor) {\n\t\tinfo_size += im->colorsTotal * 4;\n\t\tif (compression) {\n\t\t\tbitmap_size = 0;\n\t\t}\n\t}\n\n\t/* bitmap header + info header + data */\n\ttotal_size = 14 + info_size + bitmap_size;\n\n\t/* write bmp header info */\n\tgdPutBuf(\"BM\", 2, out);\n\tgdBMPPutInt(out, total_size);\n\tgdBMPPutWord(out, 0);\n\tgdBMPPutWord(out, 0);\n\tgdBMPPutInt(out, 14 + info_size);\n\n\t/* write Windows v3 headers */\n\tgdBMPPutInt(out, BMP_WINDOWS_V3); /* header size */\n\tgdBMPPutInt(out, im->sx); /* width */\n\tgdBMPPutInt(out, im->sy); /* height */\n\tgdBMPPutWord(out, 1); /* colour planes */\n\tgdBMPPutWord(out, (im->trueColor ? 24 : 8)); /* bit count */\n\tgdBMPPutInt(out, (compression ? BMP_BI_RLE8 : BMP_BI_RGB)); /* compression */\n\tgdBMPPutInt(out, bitmap_size); /* image size */\n\tgdBMPPutInt(out, 0); /* H resolution */\n\tgdBMPPutInt(out, 0); /* V ressolution */\n\tgdBMPPutInt(out, im->colorsTotal); /* colours used */\n\tgdBMPPutInt(out, 0); /* important colours */\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = ((int)(im->trueColor ? 3 : 1) * im->sx) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\t/* 8-bit colours */\n\tif (!im->trueColor) {\n\t\tfor(i = 0; i< im->colorsTotal; ++i) {\n\t\t\tgdPutC(gdImageBlue(im, i), out);\n\t\t\tgdPutC(gdImageGreen(im, i), out);\n\t\t\tgdPutC(gdImageRed(im, i), out);\n\t\t\tgdPutC(0, out);\n\t\t}\n\n\t\tif (compression) {\n\t\t\t/* Can potentially change this to X + ((X / 128) * 3) */\n\t\t\tuncompressed_row = uncompressed_row_start = (unsigned char *) gdCalloc(gdImageSX(im) * 2, sizeof(char));\n\t\t\tif (!uncompressed_row) {\n\t\t\t\t/* malloc failed */\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tfor (row = (im->sy - 1); row >= 0; row--) {\n\t\t\tif (compression) {\n\t\t\t\tmemset (uncompressed_row, 0, gdImageSX(im));\n\t\t\t}\n\n\t\t\tfor (xpos = 0; xpos < im->sx; xpos++) {\n\t\t\t\tif (compression) {\n\t\t\t\t\t*uncompressed_row++ = (unsigned char)gdImageGetPixel(im, xpos, row);\n\t\t\t\t} else {\n\t\t\t\t\tgdPutC(gdImageGetPixel(im, xpos, row), out);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!compression) {\n\t\t\t\t/* Add padding to make sure we have n mod 4 == 0 bytes per row */\n\t\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\t\tgdPutC('\\0', out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint compressed_size = 0;\n\t\t\t\tuncompressed_row = uncompressed_row_start;\n\t\t\t\tif ((compressed_size = compress_row(uncompressed_row, gdImageSX(im))) < 0) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbitmap_size += compressed_size;\n\n\n\t\t\t\tgdPutBuf(uncompressed_row, compressed_size, out);\n\t\t\t\tgdPutC(BMP_RLE_COMMAND, out);\n\t\t\t\tgdPutC(BMP_RLE_ENDOFLINE, out);\n\t\t\t\tbitmap_size += 2;\n\t\t\t}\n\t\t}\n\n\t\tif (compression && uncompressed_row) {\n\t\t\tgdFree(uncompressed_row);\n\t\t\tif (error != 0) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Update filesize based on new values and set compression flag */\n\t\t\tgdPutC(BMP_RLE_COMMAND, out);\n\t\t\tgdPutC(BMP_RLE_ENDOFBITMAP, out);\n\t\t\tbitmap_size += 2;\n\n\t\t\t/* Write new total bitmap size */\n\t\t\tgdSeek(out, 2);\n\t\t\tgdBMPPutInt(out, total_size + bitmap_size);\n\n\t\t\t/* Total length of image data */\n\t\t\tgdSeek(out, 34);\n\t\t\tgdBMPPutInt(out, bitmap_size);\n\t\t}\n\n\t} else {\n\t\tfor (row = (im->sy - 1); row >= 0; row--) {\n\t\t\tfor (xpos = 0; xpos < im->sx; xpos++) {\n\t\t\t\tpixel = gdImageGetPixel(im, xpos, row);\n\n\t\t\t\tgdPutC(gdTrueColorGetBlue(pixel), out);\n\t\t\t\tgdPutC(gdTrueColorGetGreen(pixel), out);\n\t\t\t\tgdPutC(gdTrueColorGetRed(pixel), out);\n\t\t\t}\n\n\t\t\t/* Add padding to make sure we have n mod 4 == 0 bytes per row */\n\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\tgdPutC('\\0', out);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/* If we needed a tmpfile for compression copy it over to out_original */\n\tif (tmpfile_for_compression) {\n\t\tunsigned char* copy_buffer = NULL;\n\t\tint buffer_size = 0;\n\n\t\tgdSeek(out, 0);\n\t\tcopy_buffer = (unsigned char *) gdMalloc(1024 * sizeof(unsigned char));\n\t\tif (copy_buffer == NULL) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\twhile ((buffer_size = gdGetBuf(copy_buffer, 1024, out)) != EOF) {\n\t\t\tif (buffer_size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgdPutBuf(copy_buffer , buffer_size, out_original);\n\t\t}\n\t\tgdFree(copy_buffer);\n\n\t\t/* Replace the temp with the original which now has data */\n\t\tout->gd_free(out);\n\t\tout = out_original;\n\t\tout_original = NULL;\n\t}\n\n\tret = 0;\ncleanup:\n\tif (tmpfile_for_compression) {\n#ifdef _WIN32\n\t\t_rmtmp();\n#else\n\t\tfclose(tmpfile_for_compression);\n#endif\n\t\ttmpfile_for_compression = NULL;\n\t}\n\n\tif (out_original) {\n\t\tout_original->gd_free(out_original);\n\t}\n\treturn ret;\n}\n\nstatic int compress_row(unsigned char *row, int length)\n{\n\tint rle_type = 0;\n\tint compressed_length = 0;\n\tint pixel = 0, compressed_run = 0, rle_compression = 0;\n\tunsigned char *uncompressed_row = NULL, *uncompressed_rowp = NULL, *uncompressed_start = NULL;\n\n\tuncompressed_row = (unsigned char *) gdMalloc(length);\n\tif (!uncompressed_row) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(uncompressed_row, row, length);\n\tuncompressed_start = uncompressed_rowp = uncompressed_row;\n\n\tfor (pixel = 0; pixel < length; pixel++) {\n\t\tif (compressed_run == 0) {\n\t\t\tuncompressed_row = uncompressed_rowp;\n\t\t\tcompressed_run++;\n\t\t\tuncompressed_rowp++;\n\t\t\trle_type = BMP_RLE_TYPE_RAW;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (compressed_run == 1) {\n\t\t\t/* Compare next byte */\n\t\t\tif (memcmp(uncompressed_rowp, uncompressed_rowp - 1, 1) == 0) {\n\t\t\t\trle_type = BMP_RLE_TYPE_RLE;\n\t\t\t}\n\t\t}\n\n\t\tif (rle_type == BMP_RLE_TYPE_RLE) {\n\t\t\tif (compressed_run >= 128 || memcmp(uncompressed_rowp, uncompressed_rowp - 1, 1) != 0) {\n\t\t\t\t/* more than what we can store in a single run or run is over due to non match, force write */\n\t\t\t\trle_compression = build_rle_packet(row, rle_type, compressed_run, uncompressed_row);\n\t\t\t\trow += rle_compression;\n\t\t\t\tcompressed_length += rle_compression;\n\t\t\t\tcompressed_run = 0;\n\t\t\t\tpixel--;\n\t\t\t} else {\n\t\t\t\tcompressed_run++;\n\t\t\t\tuncompressed_rowp++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (compressed_run >= 128 || memcmp(uncompressed_rowp, uncompressed_rowp - 1, 1) == 0) {\n\t\t\t\t/* more than what we can store in a single run or run is over due to match, force write */\n\t\t\t\trle_compression = build_rle_packet(row, rle_type, compressed_run, uncompressed_row);\n\t\t\t\trow += rle_compression;\n\t\t\t\tcompressed_length += rle_compression;\n\t\t\t\tcompressed_run = 0;\n\t\t\t\tpixel--;\n\t\t\t} else {\n\t\t\t\t/* add this pixel to the row */\n\t\t\t\tcompressed_run++;\n\t\t\t\tuncompressed_rowp++;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (compressed_run) {\n\t\tcompressed_length += build_rle_packet(row, rle_type, compressed_run, uncompressed_row);\n\t}\n\n\tgdFree(uncompressed_start);\n\n\treturn compressed_length;\n}\n\nstatic int build_rle_packet(unsigned char *row, int packet_type, int length, unsigned char *data)\n{\n\tint compressed_size = 0;\n\tif (length < 1 || length > 128) {\n\t\treturn 0;\n\t}\n\n\t/* Bitmap specific cases is that we can't have uncompressed rows of length 1 or 2 */\n\tif (packet_type == BMP_RLE_TYPE_RAW && length < 3) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tcompressed_size += 2;\n\t\t\tmemset(row, 1, 1);\n\t\t\trow++;\n\n\t\t\tmemcpy(row, data++, 1);\n\t\t\trow++;\n\t\t}\n\t} else if (packet_type == BMP_RLE_TYPE_RLE) {\n\t\tcompressed_size = 2;\n\t\tmemset(row, length, 1);\n\t\trow++;\n\n\t\tmemcpy(row, data, 1);\n\t\trow++;\n\t} else {\n\t\tcompressed_size = 2 + length;\n\t\tmemset(row, BMP_RLE_COMMAND, 1);\n\t\trow++;\n\n\t\tmemset(row, length, 1);\n\t\trow++;\n\n\t\tmemcpy(row, data, length);\n\t\trow += length;\n\n\t\t/* Must be an even number for an uncompressed run */\n\t\tif (length % 2) {\n\t\t\tmemset(row, 0, 1);\n\t\t\trow++;\n\t\t\tcompressed_size++;\n\t\t}\n\t}\n\treturn compressed_size;\n}\n\n/*\n\tFunction: gdImageCreateFromBmp\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromBmp(FILE * inFile)\n{\n\tgdImagePtr im = 0;\n\tgdIOCtx *in = gdNewFileCtx(inFile);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromBmpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n\tFunction: gdImageCreateFromBmpPtr\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromBmpPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromBmpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n\tFunction: gdImageCreateFromBmpCtx\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromBmpCtx(gdIOCtxPtr infile)\n{\n\tbmp_hdr_t *hdr;\n\tbmp_info_t *info;\n\tgdImagePtr im = NULL;\n\tint error = 0;\n\n\tif (!(hdr= (bmp_hdr_t *)gdCalloc(1, sizeof(bmp_hdr_t)))) {\n\t\treturn NULL;\n\t}\n\n\tif (bmp_read_header(infile, hdr)) {\n\t\tgdFree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (hdr->magic != 0x4d42) {\n\t\tgdFree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!(info = (bmp_info_t *)gdCalloc(1, sizeof(bmp_info_t)))) {\n\t\tgdFree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (bmp_read_info(infile, info)) {\n\t\tgdFree(hdr);\n\t\tgdFree(info);\n\t\treturn NULL;\n\t}\n\n\tBMP_DEBUG(printf(\"Numcolours: %d\\n\", info->numcolors));\n\tBMP_DEBUG(printf(\"Width: %d\\n\", info->width));\n\tBMP_DEBUG(printf(\"Height: %d\\n\", info->height));\n\tBMP_DEBUG(printf(\"Planes: %d\\n\", info->numplanes));\n\tBMP_DEBUG(printf(\"Depth: %d\\n\", info->depth));\n\tBMP_DEBUG(printf(\"Offset: %d\\n\", hdr->off));\n\n\tif (info->depth >= 16) {\n\t\tim = gdImageCreateTrueColor(info->width, info->height);\n\t} else {\n\t\tim = gdImageCreate(info->width, info->height);\n\t}\n\n\tif (!im) {\n\t\tgdFree(hdr);\n\t\tgdFree(info);\n\t\treturn NULL;\n\t}\n\n\tswitch (info->depth) {\n\tcase 1:\n\t\tBMP_DEBUG(printf(\"1-bit image\\n\"));\n\t\terror = bmp_read_1bit(im, infile, info, hdr);\n\t\tbreak;\n\tcase 4:\n\t\tBMP_DEBUG(printf(\"4-bit image\\n\"));\n\t\terror = bmp_read_4bit(im, infile, info, hdr);\n\t\tbreak;\n\tcase 8:\n\t\tBMP_DEBUG(printf(\"8-bit image\\n\"));\n\t\terror = bmp_read_8bit(im, infile, info, hdr);\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tBMP_DEBUG(printf(\"Direct BMP image\\n\"));\n\t\terror = bmp_read_direct(im, infile, info, hdr);\n\t\tbreak;\n\tdefault:\n\t\tBMP_DEBUG(printf(\"Unknown bit count\\n\"));\n\t\terror = 1;\n\t}\n\n\tgdFree(hdr);\n\tgdFree(info);\n\n\tif (error) {\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\n\treturn im;\n}\n\nstatic int bmp_read_header(gdIOCtx *infile, bmp_hdr_t *hdr)\n{\n\tif(\n\t    !gdGetWordLSB(&hdr->magic, infile) ||\n\t    !gdGetIntLSB(&hdr->size, infile) ||\n\t    !gdGetWordLSB(&hdr->reserved1, infile) ||\n\t    !gdGetWordLSB(&hdr->reserved2 , infile) ||\n\t    !gdGetIntLSB(&hdr->off , infile)\n\t) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_info(gdIOCtx *infile, bmp_info_t *info)\n{\n\t/* read BMP length so we can work out the version */\n\tif (!gdGetIntLSB(&info->len, infile)) {\n\t\treturn 1;\n\t}\n\n\tswitch (info->len) {\n\t\t/* For now treat Windows v4 + v5 as v3 */\n\tcase BMP_WINDOWS_V3:\n\tcase BMP_WINDOWS_V4:\n\tcase BMP_WINDOWS_V5:\n\t\tBMP_DEBUG(printf(\"Reading Windows Header\\n\"));\n\t\tif (bmp_read_windows_v3_info(infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_OS2_V1:\n\t\tif (bmp_read_os2_v1_info(infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_OS2_V2:\n\t\tif (bmp_read_os2_v2_info(infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBMP_DEBUG(printf(\"Unhandled bitmap\\n\"));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_windows_v3_info(gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tif (\n\t    !gdGetIntLSB(&info->width, infile) ||\n\t    !gdGetIntLSB(&info->height, infile) ||\n\t    !gdGetWordLSB(&info->numplanes, infile) ||\n\t    !gdGetWordLSB(&info->depth, infile) ||\n\t    !gdGetIntLSB(&info->enctype, infile) ||\n\t    !gdGetIntLSB(&info->size, infile) ||\n\t    !gdGetIntLSB(&info->hres, infile) ||\n\t    !gdGetIntLSB(&info->vres, infile) ||\n\t    !gdGetIntLSB(&info->numcolors, infile) ||\n\t    !gdGetIntLSB(&info->mincolors, infile)\n\t) {\n\t\treturn 1;\n\t}\n\n\t/* Unlikely, but possible -- largest signed value won't fit in unsigned. */\n\tif (info->height == 0 || info->height == INT_MIN)\n\t\treturn 1;\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tinfo->type = BMP_PALETTE_4;\n\n\t/* Height was checked above. */\n\tif (info->width <= 0 || info->numplanes <= 0 || info->depth <= 0 ||\n\t        info->numcolors < 0 || info->mincolors < 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_os2_v1_info(gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tif (\n\t    !gdGetWordLSB((signed short int *)&info->width, infile) ||\n\t    !gdGetWordLSB((signed short int *)&info->height, infile) ||\n\t    !gdGetWordLSB(&info->numplanes, infile) ||\n\t    !gdGetWordLSB(&info->depth, infile)\n\t) {\n\t\treturn 1;\n\t}\n\n\t/* OS2 v1 doesn't support topdown */\n\tinfo->topdown = 0;\n\n\t/* The spec says the depth can only be a few value values. */\n\tif (info->depth != 1 && info->depth != 4 && info->depth != 8 &&\n\t        info->depth != 16 && info->depth != 24) {\n\t\treturn 1;\n\t}\n\n\tinfo->numcolors = 1 << info->depth;\n\tinfo->type = BMP_PALETTE_3;\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_os2_v2_info(gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tchar useless_bytes[24];\n\tif (\n\t    !gdGetIntLSB(&info->width, infile) ||\n\t    !gdGetIntLSB(&info->height, infile) ||\n\t    !gdGetWordLSB(&info->numplanes, infile) ||\n\t    !gdGetWordLSB(&info->depth, infile) ||\n\t    !gdGetIntLSB(&info->enctype, infile) ||\n\t    !gdGetIntLSB(&info->size, infile) ||\n\t    !gdGetIntLSB(&info->hres, infile) ||\n\t    !gdGetIntLSB(&info->vres, infile) ||\n\t    !gdGetIntLSB(&info->numcolors, infile) ||\n\t    !gdGetIntLSB(&info->mincolors, infile)\n\t) {\n\t\treturn 1;\n\t}\n\n\t/* Lets seek the next 24 pointless bytes, we don't care too much about it */\n\tif (!gdGetBuf(useless_bytes, 24, infile)) {\n\t\treturn 1;\n\t}\n\n\t/* Unlikely, but possible -- largest signed value won't fit in unsigned. */\n\tif (info->height == 0 || info->height == INT_MIN)\n\t\treturn 1;\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tinfo->type = BMP_PALETTE_4;\n\n\t/* Height was checked above. */\n\tif (info->width <= 0 || info->numplanes <= 0 || info->depth <= 0 ||\n\t        info->numcolors < 0 || info->mincolors < 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_direct(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0;\n\tint padding = 0, alpha = 0, red = 0, green = 0, blue = 0;\n\tsigned short int data = 0;\n\n\tswitch(info->enctype) {\n\tcase BMP_BI_RGB:\n\t\t/* no-op */\n\t\tbreak;\n\n\tcase BMP_BI_BITFIELDS:\n\t\tif (info->depth == 24) {\n\t\t\tBMP_DEBUG(printf(\"Bitfield compression isn't supported for 24-bit\\n\"));\n\t\t\treturn 1;\n\t\t}\n\t\tBMP_DEBUG(printf(\"Currently no bitfield support\\n\"));\n\t\treturn 1;\n\t\tbreak;\n\n\tcase BMP_BI_RLE8:\n\t\tif (info->depth != 8) {\n\t\t\tBMP_DEBUG(printf(\"RLE is only valid for 8-bit images\\n\"));\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_BI_RLE4:\n\t\tif (info->depth != 4) {\n\t\t\tBMP_DEBUG(printf(\"RLE is only valid for 4-bit images\\n\"));\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_BI_JPEG:\n\tcase BMP_BI_PNG:\n\tdefault:\n\t\tBMP_DEBUG(printf(\"Unsupported BMP compression format\\n\"));\n\t\treturn 1;\n\t}\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = ((int)(info->depth / 8) * info->width) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\n\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\tif (info->topdown) {\n\t\t\trow = ypos;\n\t\t} else {\n\t\t\trow = info->height - ypos - 1;\n\t\t}\n\n\t\tfor (xpos = 0; xpos < info->width; xpos++) {\n\t\t\tif (info->depth == 16) {\n\t\t\t\tif (!gdGetWordLSB(&data, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tBMP_DEBUG(printf(\"Data: %X\\n\", data));\n\t\t\t\tred = ((data & 0x7C00) >> 10) << 3;\n\t\t\t\tgreen = ((data & 0x3E0) >> 5) << 3;\n\t\t\t\tblue = (data & 0x1F) << 3;\n\t\t\t\tBMP_DEBUG(printf(\"R: %d, G: %d, B: %d\\n\", red, green, blue));\n\t\t\t} else if (info->depth == 24) {\n\t\t\t\tif (!gdGetByte(&blue, infile) || !gdGetByte(&green, infile) || !gdGetByte(&red, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!gdGetByte(&blue, infile) || !gdGetByte(&green, infile) || !gdGetByte(&red, infile) || !gdGetByte(&alpha, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*alpha = gdAlphaMax - (alpha >> 1);*/\n\t\t\tgdImageSetPixel(im, xpos, row, gdTrueColor(red, green, blue));\n\t\t}\n\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\tif (!gdGetByte(&red, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_palette(gdImagePtr im, gdIOCtxPtr infile, int count, int read_four)\n{\n\tint i;\n\tint r, g, b, z;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (\n\t\t    !gdGetByte(&b, infile) ||\n\t\t    !gdGetByte(&g, infile) ||\n\t\t    !gdGetByte(&r, infile) ||\n\t\t    (read_four && !gdGetByte(&z, infile))\n\t\t) {\n\t\t\treturn 1;\n\t\t}\n\t\tim->red[i] = r;\n\t\tim->green[i] = g;\n\t\tim->blue[i] = b;\n\t\tim->open[i] = 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_1bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint padding = 0, current_byte = 0, bit = 0;\n\n\tif (info->enctype != BMP_BI_RGB) {\n\t\treturn 1;\n\t}\n\n\tif (!info->numcolors) {\n\t\tinfo->numcolors = 2;\n\t} else if (info->numcolors < 0 || info->numcolors > 2) {\n\t\treturn 1;\n\t}\n\n\tif (bmp_read_palette(im, infile, info->numcolors, (info->type == BMP_PALETTE_4))) {\n\t\treturn 1;\n\t}\n\n\tim->colorsTotal = info->numcolors;\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be aligned on a 32 bits word, else it is padded with zeros */\n\tpadding = (info->width + 7) / 8 % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\tif (info->topdown) {\n\t\t\trow = ypos;\n\t\t} else {\n\t\t\trow = info->height - ypos - 1;\n\t\t}\n\n\t\tfor (xpos = 0; xpos < info->width; xpos += 8) {\n\t\t\t/* Bitmaps are always aligned in bytes so we'll never overflow */\n\t\t\tif (!gdGetByte(&current_byte, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tfor (bit = 0; bit < 8; bit++) {\n\t\t\t\tindex = ((current_byte & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos + bit, row, index);\n\t\t\t\t/* No need to read anything extra */\n\t\t\t\tif ((xpos + bit) >= info->width) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_4bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint padding = 0, current_byte = 0;\n\n\tif (info->enctype != BMP_BI_RGB && info->enctype != BMP_BI_RLE4) {\n\t\treturn 1;\n\t}\n\n\tif (!info->numcolors) {\n\t\tinfo->numcolors = 16;\n\t} else if (info->numcolors < 0 || info->numcolors > 16) {\n\t\treturn 1;\n\t}\n\n\tif (bmp_read_palette(im, infile, info->numcolors, (info->type == BMP_PALETTE_4))) {\n\t\treturn 1;\n\t}\n\n\tim->colorsTotal = info->numcolors;\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = ((int)ceil(0.5 * info->width)) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\tswitch (info->enctype) {\n\tcase BMP_BI_RGB:\n\t\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\t\tif (info->topdown) {\n\t\t\t\trow = ypos;\n\t\t\t} else {\n\t\t\t\trow = info->height - ypos - 1;\n\t\t\t}\n\n\t\t\tfor (xpos = 0; xpos < info->width; xpos += 2) {\n\t\t\t\tif (!gdGetByte(&current_byte, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tindex = (current_byte >> 4) & 0x0f;\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos, row, index);\n\n\t\t\t\t/* This condition may get called often, potential optimsations */\n\t\t\t\tif (xpos >= info->width) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tindex = current_byte & 0x0f;\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos + 1, row, index);\n\t\t\t}\n\n\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMP_BI_RLE4:\n\t\tif (bmp_read_rle(im, infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_8bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint padding = 0;\n\n\tif (info->enctype != BMP_BI_RGB && info->enctype != BMP_BI_RLE8) {\n\t\treturn 1;\n\t}\n\n\tif (!info->numcolors) {\n\t\tinfo->numcolors = 256;\n\t} else if (info->numcolors < 0 || info->numcolors > 256) {\n\t\treturn 1;\n\t}\n\n\tif (bmp_read_palette(im, infile, info->numcolors, (info->type == BMP_PALETTE_4))) {\n\t\treturn 1;\n\t}\n\n\tim->colorsTotal = info->numcolors;\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = (1 * info->width) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\tswitch (info->enctype) {\n\tcase BMP_BI_RGB:\n\t\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\t\tif (info->topdown) {\n\t\t\t\trow = ypos;\n\t\t\t} else {\n\t\t\t\trow = info->height - ypos - 1;\n\t\t\t}\n\n\t\t\tfor (xpos = 0; xpos < info->width; ++xpos) {\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos, row, index);\n\t\t\t}\n\t\t\t/* Could create a new variable, but it isn't really worth it */\n\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMP_BI_RLE8:\n\t\tif (bmp_read_rle(im, infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_rle(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint rle_length = 0, rle_data = 0;\n\tint padding = 0;\n\tint i = 0, j = 0;\n\tint pixels_per_byte = 8 / info->depth;\n\n\tfor (ypos = 0; ypos < info->height && xpos <= info->width;) {\n\t\tif (!gdGetByte(&rle_length, infile) || !gdGetByte(&rle_data, infile)) {\n\t\t\treturn 1;\n\t\t}\n\t\trow = info->height - ypos - 1;\n\n\t\tif (rle_length != BMP_RLE_COMMAND) {\n\t\t\tif (im->open[rle_data]) {\n\t\t\t\tim->open[rle_data] = 0;\n\t\t\t}\n\n\t\t\tfor (i = 0; (i < rle_length) && (xpos < info->width);) {\n\t\t\t\tfor (j = 1; (j <= pixels_per_byte) && (xpos < info->width) && (i < rle_length); j++, xpos++, i++) {\n\t\t\t\t\tindex = (rle_data & (((1 << info->depth) - 1) << (8 - (j * info->depth)))) >> (8 - (j * info->depth));\n\t\t\t\t\tif (im->open[index]) {\n\t\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgdImageSetPixel(im, xpos, row, index);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data > 2) {\n\t\t\t/* Uncompressed RLE needs to be even */\n\t\t\tpadding = 0;\n\t\t\tfor (i = 0; (i < rle_data) && (xpos < info->width); i += pixels_per_byte) {\n\t\t\t\tint max_pixels = pixels_per_byte;\n\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpadding++;\n\n\t\t\t\tif (rle_data - i < max_pixels) {\n\t\t\t\t\tmax_pixels = rle_data - i;\n\t\t\t\t}\n\n\t\t\t\tfor (j = 1; (j <= max_pixels)  && (xpos < info->width); j++, xpos++) {\n\t\t\t\t\tint temp = (index >> (8 - (j * info->depth))) & ((1 << info->depth) - 1);\n\t\t\t\t\tif (im->open[temp]) {\n\t\t\t\t\t\tim->open[temp] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgdImageSetPixel(im, xpos, row, temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Make sure the bytes read are even */\n\t\t\tif (padding % 2 && !gdGetByte(&index, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data == BMP_RLE_ENDOFLINE) {\n\t\t\t/* Next Line */\n\t\t\txpos = 0;\n\t\t\typos++;\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data == BMP_RLE_DELTA) {\n\t\t\t/* Delta Record, used for bmp files that contain other data*/\n\t\t\tif (!gdGetByte(&rle_length, infile) || !gdGetByte(&rle_data, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\txpos += rle_length;\n\t\t\typos += rle_data;\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data == BMP_RLE_ENDOFBITMAP) {\n\t\t\t/* End of bitmap */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n", "/**\n * File: WebP IO\n *\n * Read and write WebP images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n#ifdef HAVE_LIBWEBP\n#include \"webp/decode.h\"\n#include \"webp/encode.h\"\n\n#define GD_WEBP_ALLOC_STEP (4*1024)\n\n/*\n  Function: gdImageCreateFromWebp\n\n    <gdImageCreateFromWebp> is called to load truecolor images from\n    WebP format files. Invoke <gdImageCreateFromWebp> with an\n    already opened pointer to a file containing the desired\n    image. <gdImageCreateFromWebp> returns a <gdImagePtr> to the new\n    truecolor image, or NULL if unable to load the image (most often\n    because the file is corrupt or does not contain a WebP\n    image). <gdImageCreateFromWebp> does not close the file.\n\n    You can inspect the sx and sy members of the image to determine\n    its size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n    *The returned image is always a truecolor image.*\n\n  Variants:\n\n    <gdImageCreateFromWebpPtr> creates an image from WebP data\n    already in memory.\n\n    <gdImageCreateFromWebpCtx> reads its data via the function\n    pointers in a <gdIOCtx> structure.\n\n  Parameters:\n\n    infile - The input FILE pointer.\n\n  Returns:\n\n    A pointer to the new *truecolor* image.  This will need to be\n    destroyed with <gdImageDestroy> once it is no longer needed.\n\n    On error, returns NULL.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewFileCtx(inFile);\n\tif (!in) {\n\t\treturn 0;\n\t}\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\n\treturn im;\n}\n\n\n/*\n  Function: gdImageCreateFromWebpPtr\n\n    See <gdImageCreateFromWebp>.\n\n  Parameters:\n\n    size            - size of WebP data in bytes.\n    data            - pointer to WebP data.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromWebpCtx\n\n    See <gdImageCreateFromWebp>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tint    width, height;\n\tuint8_t   *filedata = NULL;\n\tuint8_t    *argb = NULL;\n\tunsigned char   *read, *temp;\n\tssize_t size = 0, n;\n\tgdImagePtr im;\n\tint x, y;\n\tuint8_t *p;\n\n\tdo {\n\t\ttemp = gdRealloc(filedata, size+GD_WEBP_ALLOC_STEP);\n\t\tif (temp) {\n\t\t\tfiledata = temp;\n\t\t\tread = temp + size;\n\t\t} else {\n\t\t\tif (filedata) {\n\t\t\t\tgdFree(filedata);\n\t\t\t}\n\t\t\tgd_error(\"WebP decode: realloc failed\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tn = gdGetBuf(read, GD_WEBP_ALLOC_STEP, infile);\n\t\tif (n>0 && n!=EOF) {\n\t\t\tsize += n;\n\t\t}\n\t} while (n>0 && n!=EOF);\n\n\tif (WebPGetInfo(filedata,size, &width, &height) == 0) {\n\t\tgd_error(\"gd-webp cannot get webp info\");\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\n\tim = gdImageCreateTrueColor(width, height);\n\tif (!im) {\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\targb = WebPDecodeARGB(filedata, size, &width, &height);\n\tif (!argb) {\n\t\tgd_error(\"gd-webp cannot allocate temporary buffer\");\n\t\tgdFree(temp);\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\tfor (y = 0, p = argb;  y < height; y++) {\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tregister uint8_t a = gdAlphaMax - (*(p++) >> 1);\n\t\t\tregister uint8_t r = *(p++);\n\t\t\tregister uint8_t g = *(p++);\n\t\t\tregister uint8_t b = *(p++);\n\t\t\tim->tpixels[y][x] = gdTrueColorAlpha(r, g, b, a);\n\t\t}\n\t}\n\t/* do not use gdFree here, in case gdFree/alloc is mapped to something else than libc */\n\tfree(argb);\n\tgdFree(temp);\n\tim->saveAlphaFlag = 1;\n\treturn im;\n}\n\n\n/* returns 0 on success, 1 on failure */\nstatic int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n    int ret = 0;\n\n\tif (im == NULL) {\n\t\treturn 1;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Palette image not supported by webp\");\n\t\treturn 1;\n\t}\n\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn 1;\n\t}\n\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn 1;\n\t}\n\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn 1;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c);\n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tif (quality >= gdWebpLossless) {\n\t\tout_size = WebPEncodeLosslessRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, &out);\n\t} else {\n\t\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\t}\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n        ret = 1;\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n\n    return ret;\n}\n\n\n/*\n  Function: gdImageWebpCtx\n\n    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n    for more details.\n\n  Parameters:\n\n    im      - The image to write.\n    outfile - The output sink.\n    quality - Image quality.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageWebpCtx(im, outfile, quality);\n}\n\n/*\n  Function: gdImageWebpEx\n\n    <gdImageWebpEx> outputs the specified image to the specified file in\n    WebP format. The file must be open for writing. Under MSDOS and\n    all versions of Windows, it is important to use \"wb\" as opposed to\n    simply \"w\" as the mode when opening the file, and under Unix there\n    is no penalty for doing so. <gdImageWebpEx> does not close the file;\n    your code must do so.\n\n\tIf _quality_ is -1, a reasonable quality value (which should yield a\n\tgood general quality / size tradeoff for most situations) is used. Otherwise\n\t_quality_ should be a value in the range 0-100, higher quality values\n\tusually implying both higher quality and larger image sizes.\n\n\tIf _quality_ is greater than or equal to <gdWebpLossless> then the image\n\twill be written in the lossless WebP format.\n\n  Variants:\n\n    <gdImageWebpCtx> stores the image using a <gdIOCtx> struct.\n\n    <gdImageWebpPtrEx> stores the image to RAM.\n\n  Parameters:\n\n    im      - The image to save.\n    outFile - The FILE pointer to write to.\n    quality - Compression quality (0-100).\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebp\n\n    Variant of <gdImageWebpEx> which uses the default quality (-1).\n\n  Parameters:\n\n    im      - The image to save\n    outFile - The FILE pointer to write to.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebpPtr\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}\n\n/*\n  Function: gdImageWebpPtrEx\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, quality)) {\n        rv = NULL;\n    } else {\n        rv = gdDPExtractData(out, size);\n    }\n\tout->gd_free(out);\n\treturn rv;\n}\n\n#else /* !HAVE_LIBWEBP */\n\nstatic void _noWebpError(void)\n{\n\tgd_error(\"WEBP image support has been disabled\\n\");\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n\tARG_NOT_USED(inFile);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(data);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tARG_NOT_USED(infile);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outfile);\n\tARG_NOT_USED(quality);\n\t_noWebpError();\n}\n\nBGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outFile);\n\tARG_NOT_USED(quality);\n\t_noWebpError();\n}\n\nBGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outFile);\n\t_noWebpError();\n}\n\nBGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(size);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(quality);\n\t_noWebpError();\n\treturn NULL;\n}\n\n#endif /* HAVE_LIBWEBP */\n"], "fixing_code": ["/*\n\tgd_bmp.c\n\n\tBitmap format support for libgd\n\n\t* Written 2007, Scott MacVicar\n\t---------------------------------------------------------------------------\n\n\tTodo:\n\n\tBitfield encoding\n\n\t----------------------------------------------------------------------------\n */\n\n/**\n * File: BMP IO\n *\n * Read and write BMP images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gdhelpers.h\"\n#include \"gd_errors.h\"\n#include \"bmp.h\"\n\nstatic int compress_row(unsigned char *uncompressed_row, int length);\nstatic int build_rle_packet(unsigned char *row, int packet_type, int length, unsigned char *data);\n\nstatic int bmp_read_header(gdIOCtxPtr infile, bmp_hdr_t *hdr);\nstatic int bmp_read_info(gdIOCtxPtr infile, bmp_info_t *info);\nstatic int bmp_read_windows_v3_info(gdIOCtxPtr infile, bmp_info_t *info);\nstatic int bmp_read_os2_v1_info(gdIOCtxPtr infile, bmp_info_t *info);\nstatic int bmp_read_os2_v2_info(gdIOCtxPtr infile, bmp_info_t *info);\n\nstatic int bmp_read_direct(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_1bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_4bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_8bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header);\nstatic int bmp_read_rle(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info);\n\nstatic int _gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression);\n\n#define BMP_DEBUG(s)\n\nstatic int gdBMPPutWord(gdIOCtx *out, int w)\n{\n\t/* Byte order is little-endian */\n\tgdPutC(w & 0xFF, out);\n\tgdPutC((w >> 8) & 0xFF, out);\n\treturn 0;\n}\n\nstatic int gdBMPPutInt(gdIOCtx *out, int w)\n{\n\t/* Byte order is little-endian */\n\tgdPutC(w & 0xFF, out);\n\tgdPutC((w >> 8) & 0xFF, out);\n\tgdPutC((w >> 16) & 0xFF, out);\n\tgdPutC((w >> 24) & 0xFF, out);\n\treturn 0;\n}\n\n/*\n\tFunction: gdImageBmpPtr\n\n\tOutputs the given image as BMP data, but using a <gdIOCtx> instead\n\tof a file. See <gdImageBmp>.\n\n\tParameters:\n\t\tim\t\t\t- the image to save.\n\t\tsize \t\t- Output: size in bytes of the result.\n\t\tcompression - whether to apply RLE or not.\n\n\tReturns:\n\n\t\tA pointer to memory containing the image data or NULL on error.\n*/\nBGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageBmpCtx(im, out, compression))\n\t\trv = gdDPExtractData(out, size);\n\telse\n\t\trv = NULL;\n\tout->gd_free(out);\n\treturn rv;\n}\n\n/*\n\tFunction: gdImageBmp\n\n    <gdImageBmp> outputs the specified image to the specified file in\n    BMP format. The file must be open for writing. Under MSDOS and all\n    versions of Windows, it is important to use \"wb\" as opposed to\n    simply \"w\" as the mode when opening the file, and under Unix there\n    is no penalty for doing so. <gdImageBmp> does not close the file;\n    your code must do so.\n\n    In addition, <gdImageBmp> allows to specify whether RLE compression\n    should be applied.\n\n\tVariants:\n\n\t\t<gdImageBmpCtx> write via a <gdIOCtx> instead of a file handle.\n\n\t\t<gdImageBmpPtr> store the image file to memory.\n\n\tParameters:\n\n\t\tim\t\t\t- the image to save.\n\t\toutFile\t\t- the output FILE* object.\n\t\tcompression - whether to apply RLE or not.\n\n\tReturns:\n\t\tnothing\n*/\nBGD_DECLARE(void) gdImageBmp(gdImagePtr im, FILE *outFile, int compression)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) return;\n\tgdImageBmpCtx(im, out, compression);\n\tout->gd_free(out);\n}\n\n/*\n\tFunction: gdImageBmpCtx\n\n\tOutputs the given image as BMP data, but using a <gdIOCtx> instead\n\tof a file. See <gdImageBmp>.\n\n\tParameters:\n\t\tim\t\t\t- the image to save.\n\t\tout \t\t- the <gdIOCtx> to write to.\n\t\tcompression - whether to apply RLE or not.\n*/\nBGD_DECLARE(void) gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)\n{\n\t_gdImageBmpCtx(im, out, compression);\n}\n\nstatic int _gdImageBmpCtx(gdImagePtr im, gdIOCtxPtr out, int compression)\n{\n\tint bitmap_size = 0, info_size, total_size, padding;\n\tint i, row, xpos, pixel;\n\tint error = 0;\n\tunsigned char *uncompressed_row = NULL, *uncompressed_row_start = NULL;\n\tFILE *tmpfile_for_compression = NULL;\n\tgdIOCtxPtr out_original = NULL;\n\tint ret = 1;\n\n\t/* No compression if its true colour or we don't support seek */\n\tif (im->trueColor) {\n\t\tcompression = 0;\n\t}\n\n\tif (compression && !out->seek) {\n\t\t/* Try to create a temp file where we can seek */\n\t\tif ((tmpfile_for_compression = tmpfile()) == NULL) {\n\t\t\tcompression = 0;\n\t\t} else {\n\t\t\tout_original = out;\n\t\t\tif ((out = (gdIOCtxPtr)gdNewFileCtx(tmpfile_for_compression)) == NULL) {\n\t\t\t\tout = out_original;\n\t\t\t\tout_original = NULL;\n\t\t\t\tcompression = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbitmap_size = ((im->sx * (im->trueColor ? 24 : 8)) / 8) * im->sy;\n\n\t/* 40 byte Windows v3 header */\n\tinfo_size = BMP_WINDOWS_V3;\n\n\t/* data for the palette */\n\tif (!im->trueColor) {\n\t\tinfo_size += im->colorsTotal * 4;\n\t\tif (compression) {\n\t\t\tbitmap_size = 0;\n\t\t}\n\t}\n\n\t/* bitmap header + info header + data */\n\ttotal_size = 14 + info_size + bitmap_size;\n\n\t/* write bmp header info */\n\tgdPutBuf(\"BM\", 2, out);\n\tgdBMPPutInt(out, total_size);\n\tgdBMPPutWord(out, 0);\n\tgdBMPPutWord(out, 0);\n\tgdBMPPutInt(out, 14 + info_size);\n\n\t/* write Windows v3 headers */\n\tgdBMPPutInt(out, BMP_WINDOWS_V3); /* header size */\n\tgdBMPPutInt(out, im->sx); /* width */\n\tgdBMPPutInt(out, im->sy); /* height */\n\tgdBMPPutWord(out, 1); /* colour planes */\n\tgdBMPPutWord(out, (im->trueColor ? 24 : 8)); /* bit count */\n\tgdBMPPutInt(out, (compression ? BMP_BI_RLE8 : BMP_BI_RGB)); /* compression */\n\tgdBMPPutInt(out, bitmap_size); /* image size */\n\tgdBMPPutInt(out, 0); /* H resolution */\n\tgdBMPPutInt(out, 0); /* V ressolution */\n\tgdBMPPutInt(out, im->colorsTotal); /* colours used */\n\tgdBMPPutInt(out, 0); /* important colours */\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = ((int)(im->trueColor ? 3 : 1) * im->sx) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\t/* 8-bit colours */\n\tif (!im->trueColor) {\n\t\tfor(i = 0; i< im->colorsTotal; ++i) {\n\t\t\tgdPutC(gdImageBlue(im, i), out);\n\t\t\tgdPutC(gdImageGreen(im, i), out);\n\t\t\tgdPutC(gdImageRed(im, i), out);\n\t\t\tgdPutC(0, out);\n\t\t}\n\n\t\tif (compression) {\n\t\t\t/* Can potentially change this to X + ((X / 128) * 3) */\n\t\t\tuncompressed_row = uncompressed_row_start = (unsigned char *) gdCalloc(gdImageSX(im) * 2, sizeof(char));\n\t\t\tif (!uncompressed_row) {\n\t\t\t\t/* malloc failed */\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tfor (row = (im->sy - 1); row >= 0; row--) {\n\t\t\tif (compression) {\n\t\t\t\tmemset (uncompressed_row, 0, gdImageSX(im));\n\t\t\t}\n\n\t\t\tfor (xpos = 0; xpos < im->sx; xpos++) {\n\t\t\t\tif (compression) {\n\t\t\t\t\t*uncompressed_row++ = (unsigned char)gdImageGetPixel(im, xpos, row);\n\t\t\t\t} else {\n\t\t\t\t\tgdPutC(gdImageGetPixel(im, xpos, row), out);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!compression) {\n\t\t\t\t/* Add padding to make sure we have n mod 4 == 0 bytes per row */\n\t\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\t\tgdPutC('\\0', out);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint compressed_size = 0;\n\t\t\t\tuncompressed_row = uncompressed_row_start;\n\t\t\t\tif ((compressed_size = compress_row(uncompressed_row, gdImageSX(im))) < 0) {\n\t\t\t\t\terror = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbitmap_size += compressed_size;\n\n\n\t\t\t\tif (gdPutBuf(uncompressed_row, compressed_size, out) != compressed_size){\n\t\t\t\t\tgd_error(\"gd-bmp write error\\n\");\n\t\t\t\t\terror = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgdPutC(BMP_RLE_COMMAND, out);\n\t\t\t\tgdPutC(BMP_RLE_ENDOFLINE, out);\n\t\t\t\tbitmap_size += 2;\n\t\t\t}\n\t\t}\n\n\t\tif (compression && uncompressed_row) {\n\t\t\tgdFree(uncompressed_row);\n\t\t\tif (error != 0) {\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t/* Update filesize based on new values and set compression flag */\n\t\t\tgdPutC(BMP_RLE_COMMAND, out);\n\t\t\tgdPutC(BMP_RLE_ENDOFBITMAP, out);\n\t\t\tbitmap_size += 2;\n\n\t\t\t/* Write new total bitmap size */\n\t\t\tgdSeek(out, 2);\n\t\t\tgdBMPPutInt(out, total_size + bitmap_size);\n\n\t\t\t/* Total length of image data */\n\t\t\tgdSeek(out, 34);\n\t\t\tgdBMPPutInt(out, bitmap_size);\n\t\t}\n\n\t} else {\n\t\tfor (row = (im->sy - 1); row >= 0; row--) {\n\t\t\tfor (xpos = 0; xpos < im->sx; xpos++) {\n\t\t\t\tpixel = gdImageGetPixel(im, xpos, row);\n\n\t\t\t\tgdPutC(gdTrueColorGetBlue(pixel), out);\n\t\t\t\tgdPutC(gdTrueColorGetGreen(pixel), out);\n\t\t\t\tgdPutC(gdTrueColorGetRed(pixel), out);\n\t\t\t}\n\n\t\t\t/* Add padding to make sure we have n mod 4 == 0 bytes per row */\n\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\tgdPutC('\\0', out);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/* If we needed a tmpfile for compression copy it over to out_original */\n\tif (tmpfile_for_compression) {\n\t\tunsigned char* copy_buffer = NULL;\n\t\tint buffer_size = 0;\n\n\t\tgdSeek(out, 0);\n\t\tcopy_buffer = (unsigned char *) gdMalloc(1024 * sizeof(unsigned char));\n\t\tif (copy_buffer == NULL) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\twhile ((buffer_size = gdGetBuf(copy_buffer, 1024, out)) != EOF) {\n\t\t\tif (buffer_size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gdPutBuf(copy_buffer , buffer_size, out_original) != buffer_size) {\n\t\t\t\tgd_error(\"gd-bmp write error\\n\");\n\t\t\t\terror = 1;\n\t\t\t}\n\t\t}\n\t\tgdFree(copy_buffer);\n\n\t\t/* Replace the temp with the original which now has data */\n\t\tout->gd_free(out);\n\t\tout = out_original;\n\t\tout_original = NULL;\n\t}\n\n\tret = error;\ncleanup:\n\tif (tmpfile_for_compression) {\n#ifdef _WIN32\n\t\t_rmtmp();\n#else\n\t\tfclose(tmpfile_for_compression);\n#endif\n\t\ttmpfile_for_compression = NULL;\n\t}\n\n\tif (out_original) {\n\t\tout_original->gd_free(out_original);\n\t}\n\treturn ret;\n}\n\nstatic int compress_row(unsigned char *row, int length)\n{\n\tint rle_type = 0;\n\tint compressed_length = 0;\n\tint pixel = 0, compressed_run = 0, rle_compression = 0;\n\tunsigned char *uncompressed_row = NULL, *uncompressed_rowp = NULL, *uncompressed_start = NULL;\n\n\tuncompressed_row = (unsigned char *) gdMalloc(length);\n\tif (!uncompressed_row) {\n\t\treturn -1;\n\t}\n\n\tmemcpy(uncompressed_row, row, length);\n\tuncompressed_start = uncompressed_rowp = uncompressed_row;\n\n\tfor (pixel = 0; pixel < length; pixel++) {\n\t\tif (compressed_run == 0) {\n\t\t\tuncompressed_row = uncompressed_rowp;\n\t\t\tcompressed_run++;\n\t\t\tuncompressed_rowp++;\n\t\t\trle_type = BMP_RLE_TYPE_RAW;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (compressed_run == 1) {\n\t\t\t/* Compare next byte */\n\t\t\tif (memcmp(uncompressed_rowp, uncompressed_rowp - 1, 1) == 0) {\n\t\t\t\trle_type = BMP_RLE_TYPE_RLE;\n\t\t\t}\n\t\t}\n\n\t\tif (rle_type == BMP_RLE_TYPE_RLE) {\n\t\t\tif (compressed_run >= 128 || memcmp(uncompressed_rowp, uncompressed_rowp - 1, 1) != 0) {\n\t\t\t\t/* more than what we can store in a single run or run is over due to non match, force write */\n\t\t\t\trle_compression = build_rle_packet(row, rle_type, compressed_run, uncompressed_row);\n\t\t\t\trow += rle_compression;\n\t\t\t\tcompressed_length += rle_compression;\n\t\t\t\tcompressed_run = 0;\n\t\t\t\tpixel--;\n\t\t\t} else {\n\t\t\t\tcompressed_run++;\n\t\t\t\tuncompressed_rowp++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (compressed_run >= 128 || memcmp(uncompressed_rowp, uncompressed_rowp - 1, 1) == 0) {\n\t\t\t\t/* more than what we can store in a single run or run is over due to match, force write */\n\t\t\t\trle_compression = build_rle_packet(row, rle_type, compressed_run, uncompressed_row);\n\t\t\t\trow += rle_compression;\n\t\t\t\tcompressed_length += rle_compression;\n\t\t\t\tcompressed_run = 0;\n\t\t\t\tpixel--;\n\t\t\t} else {\n\t\t\t\t/* add this pixel to the row */\n\t\t\t\tcompressed_run++;\n\t\t\t\tuncompressed_rowp++;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif (compressed_run) {\n\t\tcompressed_length += build_rle_packet(row, rle_type, compressed_run, uncompressed_row);\n\t}\n\n\tgdFree(uncompressed_start);\n\n\treturn compressed_length;\n}\n\nstatic int build_rle_packet(unsigned char *row, int packet_type, int length, unsigned char *data)\n{\n\tint compressed_size = 0;\n\tif (length < 1 || length > 128) {\n\t\treturn 0;\n\t}\n\n\t/* Bitmap specific cases is that we can't have uncompressed rows of length 1 or 2 */\n\tif (packet_type == BMP_RLE_TYPE_RAW && length < 3) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tcompressed_size += 2;\n\t\t\tmemset(row, 1, 1);\n\t\t\trow++;\n\n\t\t\tmemcpy(row, data++, 1);\n\t\t\trow++;\n\t\t}\n\t} else if (packet_type == BMP_RLE_TYPE_RLE) {\n\t\tcompressed_size = 2;\n\t\tmemset(row, length, 1);\n\t\trow++;\n\n\t\tmemcpy(row, data, 1);\n\t\trow++;\n\t} else {\n\t\tcompressed_size = 2 + length;\n\t\tmemset(row, BMP_RLE_COMMAND, 1);\n\t\trow++;\n\n\t\tmemset(row, length, 1);\n\t\trow++;\n\n\t\tmemcpy(row, data, length);\n\t\trow += length;\n\n\t\t/* Must be an even number for an uncompressed run */\n\t\tif (length % 2) {\n\t\t\tmemset(row, 0, 1);\n\t\t\trow++;\n\t\t\tcompressed_size++;\n\t\t}\n\t}\n\treturn compressed_size;\n}\n\n/*\n\tFunction: gdImageCreateFromBmp\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromBmp(FILE * inFile)\n{\n\tgdImagePtr im = 0;\n\tgdIOCtx *in = gdNewFileCtx(inFile);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromBmpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n\tFunction: gdImageCreateFromBmpPtr\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromBmpPtr(int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (in == NULL) return NULL;\n\tim = gdImageCreateFromBmpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n\tFunction: gdImageCreateFromBmpCtx\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromBmpCtx(gdIOCtxPtr infile)\n{\n\tbmp_hdr_t *hdr;\n\tbmp_info_t *info;\n\tgdImagePtr im = NULL;\n\tint error = 0;\n\n\tif (!(hdr= (bmp_hdr_t *)gdCalloc(1, sizeof(bmp_hdr_t)))) {\n\t\treturn NULL;\n\t}\n\n\tif (bmp_read_header(infile, hdr)) {\n\t\tgdFree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (hdr->magic != 0x4d42) {\n\t\tgdFree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (!(info = (bmp_info_t *)gdCalloc(1, sizeof(bmp_info_t)))) {\n\t\tgdFree(hdr);\n\t\treturn NULL;\n\t}\n\n\tif (bmp_read_info(infile, info)) {\n\t\tgdFree(hdr);\n\t\tgdFree(info);\n\t\treturn NULL;\n\t}\n\n\tBMP_DEBUG(printf(\"Numcolours: %d\\n\", info->numcolors));\n\tBMP_DEBUG(printf(\"Width: %d\\n\", info->width));\n\tBMP_DEBUG(printf(\"Height: %d\\n\", info->height));\n\tBMP_DEBUG(printf(\"Planes: %d\\n\", info->numplanes));\n\tBMP_DEBUG(printf(\"Depth: %d\\n\", info->depth));\n\tBMP_DEBUG(printf(\"Offset: %d\\n\", hdr->off));\n\n\tif (info->depth >= 16) {\n\t\tim = gdImageCreateTrueColor(info->width, info->height);\n\t} else {\n\t\tim = gdImageCreate(info->width, info->height);\n\t}\n\n\tif (!im) {\n\t\tgdFree(hdr);\n\t\tgdFree(info);\n\t\treturn NULL;\n\t}\n\n\tswitch (info->depth) {\n\tcase 1:\n\t\tBMP_DEBUG(printf(\"1-bit image\\n\"));\n\t\terror = bmp_read_1bit(im, infile, info, hdr);\n\t\tbreak;\n\tcase 4:\n\t\tBMP_DEBUG(printf(\"4-bit image\\n\"));\n\t\terror = bmp_read_4bit(im, infile, info, hdr);\n\t\tbreak;\n\tcase 8:\n\t\tBMP_DEBUG(printf(\"8-bit image\\n\"));\n\t\terror = bmp_read_8bit(im, infile, info, hdr);\n\t\tbreak;\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tBMP_DEBUG(printf(\"Direct BMP image\\n\"));\n\t\terror = bmp_read_direct(im, infile, info, hdr);\n\t\tbreak;\n\tdefault:\n\t\tBMP_DEBUG(printf(\"Unknown bit count\\n\"));\n\t\terror = 1;\n\t}\n\n\tgdFree(hdr);\n\tgdFree(info);\n\n\tif (error) {\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\n\treturn im;\n}\n\nstatic int bmp_read_header(gdIOCtx *infile, bmp_hdr_t *hdr)\n{\n\tif(\n\t    !gdGetWordLSB(&hdr->magic, infile) ||\n\t    !gdGetIntLSB(&hdr->size, infile) ||\n\t    !gdGetWordLSB(&hdr->reserved1, infile) ||\n\t    !gdGetWordLSB(&hdr->reserved2 , infile) ||\n\t    !gdGetIntLSB(&hdr->off , infile)\n\t) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_info(gdIOCtx *infile, bmp_info_t *info)\n{\n\t/* read BMP length so we can work out the version */\n\tif (!gdGetIntLSB(&info->len, infile)) {\n\t\treturn 1;\n\t}\n\n\tswitch (info->len) {\n\t\t/* For now treat Windows v4 + v5 as v3 */\n\tcase BMP_WINDOWS_V3:\n\tcase BMP_WINDOWS_V4:\n\tcase BMP_WINDOWS_V5:\n\t\tBMP_DEBUG(printf(\"Reading Windows Header\\n\"));\n\t\tif (bmp_read_windows_v3_info(infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_OS2_V1:\n\t\tif (bmp_read_os2_v1_info(infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_OS2_V2:\n\t\tif (bmp_read_os2_v2_info(infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBMP_DEBUG(printf(\"Unhandled bitmap\\n\"));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_windows_v3_info(gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tif (\n\t    !gdGetIntLSB(&info->width, infile) ||\n\t    !gdGetIntLSB(&info->height, infile) ||\n\t    !gdGetWordLSB(&info->numplanes, infile) ||\n\t    !gdGetWordLSB(&info->depth, infile) ||\n\t    !gdGetIntLSB(&info->enctype, infile) ||\n\t    !gdGetIntLSB(&info->size, infile) ||\n\t    !gdGetIntLSB(&info->hres, infile) ||\n\t    !gdGetIntLSB(&info->vres, infile) ||\n\t    !gdGetIntLSB(&info->numcolors, infile) ||\n\t    !gdGetIntLSB(&info->mincolors, infile)\n\t) {\n\t\treturn 1;\n\t}\n\n\t/* Unlikely, but possible -- largest signed value won't fit in unsigned. */\n\tif (info->height == 0 || info->height == INT_MIN)\n\t\treturn 1;\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tinfo->type = BMP_PALETTE_4;\n\n\t/* Height was checked above. */\n\tif (info->width <= 0 || info->numplanes <= 0 || info->depth <= 0 ||\n\t        info->numcolors < 0 || info->mincolors < 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_os2_v1_info(gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tif (\n\t    !gdGetWordLSB((signed short int *)&info->width, infile) ||\n\t    !gdGetWordLSB((signed short int *)&info->height, infile) ||\n\t    !gdGetWordLSB(&info->numplanes, infile) ||\n\t    !gdGetWordLSB(&info->depth, infile)\n\t) {\n\t\treturn 1;\n\t}\n\n\t/* OS2 v1 doesn't support topdown */\n\tinfo->topdown = 0;\n\n\t/* The spec says the depth can only be a few value values. */\n\tif (info->depth != 1 && info->depth != 4 && info->depth != 8 &&\n\t        info->depth != 16 && info->depth != 24) {\n\t\treturn 1;\n\t}\n\n\tinfo->numcolors = 1 << info->depth;\n\tinfo->type = BMP_PALETTE_3;\n\n\tif (info->width <= 0 || info->height <= 0 || info->numplanes <= 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_os2_v2_info(gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tchar useless_bytes[24];\n\tif (\n\t    !gdGetIntLSB(&info->width, infile) ||\n\t    !gdGetIntLSB(&info->height, infile) ||\n\t    !gdGetWordLSB(&info->numplanes, infile) ||\n\t    !gdGetWordLSB(&info->depth, infile) ||\n\t    !gdGetIntLSB(&info->enctype, infile) ||\n\t    !gdGetIntLSB(&info->size, infile) ||\n\t    !gdGetIntLSB(&info->hres, infile) ||\n\t    !gdGetIntLSB(&info->vres, infile) ||\n\t    !gdGetIntLSB(&info->numcolors, infile) ||\n\t    !gdGetIntLSB(&info->mincolors, infile)\n\t) {\n\t\treturn 1;\n\t}\n\n\t/* Lets seek the next 24 pointless bytes, we don't care too much about it */\n\tif (!gdGetBuf(useless_bytes, 24, infile)) {\n\t\treturn 1;\n\t}\n\n\t/* Unlikely, but possible -- largest signed value won't fit in unsigned. */\n\tif (info->height == 0 || info->height == INT_MIN)\n\t\treturn 1;\n\tif (info->height < 0) {\n\t\tinfo->topdown = 1;\n\t\tinfo->height = -info->height;\n\t} else {\n\t\tinfo->topdown = 0;\n\t}\n\n\tinfo->type = BMP_PALETTE_4;\n\n\t/* Height was checked above. */\n\tif (info->width <= 0 || info->numplanes <= 0 || info->depth <= 0 ||\n\t        info->numcolors < 0 || info->mincolors < 0) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_direct(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0;\n\tint padding = 0, alpha = 0, red = 0, green = 0, blue = 0;\n\tsigned short int data = 0;\n\n\tswitch(info->enctype) {\n\tcase BMP_BI_RGB:\n\t\t/* no-op */\n\t\tbreak;\n\n\tcase BMP_BI_BITFIELDS:\n\t\tif (info->depth == 24) {\n\t\t\tBMP_DEBUG(printf(\"Bitfield compression isn't supported for 24-bit\\n\"));\n\t\t\treturn 1;\n\t\t}\n\t\tBMP_DEBUG(printf(\"Currently no bitfield support\\n\"));\n\t\treturn 1;\n\t\tbreak;\n\n\tcase BMP_BI_RLE8:\n\t\tif (info->depth != 8) {\n\t\t\tBMP_DEBUG(printf(\"RLE is only valid for 8-bit images\\n\"));\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_BI_RLE4:\n\t\tif (info->depth != 4) {\n\t\t\tBMP_DEBUG(printf(\"RLE is only valid for 4-bit images\\n\"));\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase BMP_BI_JPEG:\n\tcase BMP_BI_PNG:\n\tdefault:\n\t\tBMP_DEBUG(printf(\"Unsupported BMP compression format\\n\"));\n\t\treturn 1;\n\t}\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = ((int)(info->depth / 8) * info->width) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\n\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\tif (info->topdown) {\n\t\t\trow = ypos;\n\t\t} else {\n\t\t\trow = info->height - ypos - 1;\n\t\t}\n\n\t\tfor (xpos = 0; xpos < info->width; xpos++) {\n\t\t\tif (info->depth == 16) {\n\t\t\t\tif (!gdGetWordLSB(&data, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tBMP_DEBUG(printf(\"Data: %X\\n\", data));\n\t\t\t\tred = ((data & 0x7C00) >> 10) << 3;\n\t\t\t\tgreen = ((data & 0x3E0) >> 5) << 3;\n\t\t\t\tblue = (data & 0x1F) << 3;\n\t\t\t\tBMP_DEBUG(printf(\"R: %d, G: %d, B: %d\\n\", red, green, blue));\n\t\t\t} else if (info->depth == 24) {\n\t\t\t\tif (!gdGetByte(&blue, infile) || !gdGetByte(&green, infile) || !gdGetByte(&red, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!gdGetByte(&blue, infile) || !gdGetByte(&green, infile) || !gdGetByte(&red, infile) || !gdGetByte(&alpha, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*alpha = gdAlphaMax - (alpha >> 1);*/\n\t\t\tgdImageSetPixel(im, xpos, row, gdTrueColor(red, green, blue));\n\t\t}\n\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\tif (!gdGetByte(&red, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bmp_read_palette(gdImagePtr im, gdIOCtxPtr infile, int count, int read_four)\n{\n\tint i;\n\tint r, g, b, z;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (\n\t\t    !gdGetByte(&b, infile) ||\n\t\t    !gdGetByte(&g, infile) ||\n\t\t    !gdGetByte(&r, infile) ||\n\t\t    (read_four && !gdGetByte(&z, infile))\n\t\t) {\n\t\t\treturn 1;\n\t\t}\n\t\tim->red[i] = r;\n\t\tim->green[i] = g;\n\t\tim->blue[i] = b;\n\t\tim->open[i] = 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_1bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint padding = 0, current_byte = 0, bit = 0;\n\n\tif (info->enctype != BMP_BI_RGB) {\n\t\treturn 1;\n\t}\n\n\tif (!info->numcolors) {\n\t\tinfo->numcolors = 2;\n\t} else if (info->numcolors < 0 || info->numcolors > 2) {\n\t\treturn 1;\n\t}\n\n\tif (bmp_read_palette(im, infile, info->numcolors, (info->type == BMP_PALETTE_4))) {\n\t\treturn 1;\n\t}\n\n\tim->colorsTotal = info->numcolors;\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be aligned on a 32 bits word, else it is padded with zeros */\n\tpadding = (info->width + 7) / 8 % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\tif (info->topdown) {\n\t\t\trow = ypos;\n\t\t} else {\n\t\t\trow = info->height - ypos - 1;\n\t\t}\n\n\t\tfor (xpos = 0; xpos < info->width; xpos += 8) {\n\t\t\t/* Bitmaps are always aligned in bytes so we'll never overflow */\n\t\t\tif (!gdGetByte(&current_byte, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tfor (bit = 0; bit < 8; bit++) {\n\t\t\t\tindex = ((current_byte & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos + bit, row, index);\n\t\t\t\t/* No need to read anything extra */\n\t\t\t\tif ((xpos + bit) >= info->width) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_4bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint padding = 0, current_byte = 0;\n\n\tif (info->enctype != BMP_BI_RGB && info->enctype != BMP_BI_RLE4) {\n\t\treturn 1;\n\t}\n\n\tif (!info->numcolors) {\n\t\tinfo->numcolors = 16;\n\t} else if (info->numcolors < 0 || info->numcolors > 16) {\n\t\treturn 1;\n\t}\n\n\tif (bmp_read_palette(im, infile, info->numcolors, (info->type == BMP_PALETTE_4))) {\n\t\treturn 1;\n\t}\n\n\tim->colorsTotal = info->numcolors;\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = ((int)ceil(0.5 * info->width)) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\tswitch (info->enctype) {\n\tcase BMP_BI_RGB:\n\t\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\t\tif (info->topdown) {\n\t\t\t\trow = ypos;\n\t\t\t} else {\n\t\t\t\trow = info->height - ypos - 1;\n\t\t\t}\n\n\t\t\tfor (xpos = 0; xpos < info->width; xpos += 2) {\n\t\t\t\tif (!gdGetByte(&current_byte, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tindex = (current_byte >> 4) & 0x0f;\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos, row, index);\n\n\t\t\t\t/* This condition may get called often, potential optimsations */\n\t\t\t\tif (xpos >= info->width) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tindex = current_byte & 0x0f;\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos + 1, row, index);\n\t\t\t}\n\n\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMP_BI_RLE4:\n\t\tif (bmp_read_rle(im, infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_8bit(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info, bmp_hdr_t *header)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint padding = 0;\n\n\tif (info->enctype != BMP_BI_RGB && info->enctype != BMP_BI_RLE8) {\n\t\treturn 1;\n\t}\n\n\tif (!info->numcolors) {\n\t\tinfo->numcolors = 256;\n\t} else if (info->numcolors < 0 || info->numcolors > 256) {\n\t\treturn 1;\n\t}\n\n\tif (bmp_read_palette(im, infile, info->numcolors, (info->type == BMP_PALETTE_4))) {\n\t\treturn 1;\n\t}\n\n\tim->colorsTotal = info->numcolors;\n\n\t/* There is a chance the data isn't until later, would be weird but it is possible */\n\tif (gdTell(infile) != header->off) {\n\t\t/* Should make sure we don't seek past the file size */\n\t\tif (!gdSeek(infile, header->off)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* The line must be divisible by 4, else its padded with NULLs */\n\tpadding = (1 * info->width) % 4;\n\tif (padding) {\n\t\tpadding = 4 - padding;\n\t}\n\n\tswitch (info->enctype) {\n\tcase BMP_BI_RGB:\n\t\tfor (ypos = 0; ypos < info->height; ++ypos) {\n\t\t\tif (info->topdown) {\n\t\t\t\trow = ypos;\n\t\t\t} else {\n\t\t\t\trow = info->height - ypos - 1;\n\t\t\t}\n\n\t\t\tfor (xpos = 0; xpos < info->width; ++xpos) {\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (im->open[index]) {\n\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t}\n\t\t\t\tgdImageSetPixel(im, xpos, row, index);\n\t\t\t}\n\t\t\t/* Could create a new variable, but it isn't really worth it */\n\t\t\tfor (xpos = padding; xpos > 0; --xpos) {\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BMP_BI_RLE8:\n\t\tif (bmp_read_rle(im, infile, info)) {\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int bmp_read_rle(gdImagePtr im, gdIOCtxPtr infile, bmp_info_t *info)\n{\n\tint ypos = 0, xpos = 0, row = 0, index = 0;\n\tint rle_length = 0, rle_data = 0;\n\tint padding = 0;\n\tint i = 0, j = 0;\n\tint pixels_per_byte = 8 / info->depth;\n\n\tfor (ypos = 0; ypos < info->height && xpos <= info->width;) {\n\t\tif (!gdGetByte(&rle_length, infile) || !gdGetByte(&rle_data, infile)) {\n\t\t\treturn 1;\n\t\t}\n\t\trow = info->height - ypos - 1;\n\n\t\tif (rle_length != BMP_RLE_COMMAND) {\n\t\t\tif (im->open[rle_data]) {\n\t\t\t\tim->open[rle_data] = 0;\n\t\t\t}\n\n\t\t\tfor (i = 0; (i < rle_length) && (xpos < info->width);) {\n\t\t\t\tfor (j = 1; (j <= pixels_per_byte) && (xpos < info->width) && (i < rle_length); j++, xpos++, i++) {\n\t\t\t\t\tindex = (rle_data & (((1 << info->depth) - 1) << (8 - (j * info->depth)))) >> (8 - (j * info->depth));\n\t\t\t\t\tif (im->open[index]) {\n\t\t\t\t\t\tim->open[index] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgdImageSetPixel(im, xpos, row, index);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data > 2) {\n\t\t\t/* Uncompressed RLE needs to be even */\n\t\t\tpadding = 0;\n\t\t\tfor (i = 0; (i < rle_data) && (xpos < info->width); i += pixels_per_byte) {\n\t\t\t\tint max_pixels = pixels_per_byte;\n\n\t\t\t\tif (!gdGetByte(&index, infile)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tpadding++;\n\n\t\t\t\tif (rle_data - i < max_pixels) {\n\t\t\t\t\tmax_pixels = rle_data - i;\n\t\t\t\t}\n\n\t\t\t\tfor (j = 1; (j <= max_pixels)  && (xpos < info->width); j++, xpos++) {\n\t\t\t\t\tint temp = (index >> (8 - (j * info->depth))) & ((1 << info->depth) - 1);\n\t\t\t\t\tif (im->open[temp]) {\n\t\t\t\t\t\tim->open[temp] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tgdImageSetPixel(im, xpos, row, temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Make sure the bytes read are even */\n\t\t\tif (padding % 2 && !gdGetByte(&index, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data == BMP_RLE_ENDOFLINE) {\n\t\t\t/* Next Line */\n\t\t\txpos = 0;\n\t\t\typos++;\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data == BMP_RLE_DELTA) {\n\t\t\t/* Delta Record, used for bmp files that contain other data*/\n\t\t\tif (!gdGetByte(&rle_length, infile) || !gdGetByte(&rle_data, infile)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\txpos += rle_length;\n\t\t\typos += rle_data;\n\t\t} else if (rle_length == BMP_RLE_COMMAND && rle_data == BMP_RLE_ENDOFBITMAP) {\n\t\t\t/* End of bitmap */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n", "/**\n * File: WebP IO\n *\n * Read and write WebP images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n\n#ifdef HAVE_LIBWEBP\n#include \"webp/decode.h\"\n#include \"webp/encode.h\"\n\n#define GD_WEBP_ALLOC_STEP (4*1024)\n\n/*\n  Function: gdImageCreateFromWebp\n\n    <gdImageCreateFromWebp> is called to load truecolor images from\n    WebP format files. Invoke <gdImageCreateFromWebp> with an\n    already opened pointer to a file containing the desired\n    image. <gdImageCreateFromWebp> returns a <gdImagePtr> to the new\n    truecolor image, or NULL if unable to load the image (most often\n    because the file is corrupt or does not contain a WebP\n    image). <gdImageCreateFromWebp> does not close the file.\n\n    You can inspect the sx and sy members of the image to determine\n    its size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n    *The returned image is always a truecolor image.*\n\n  Variants:\n\n    <gdImageCreateFromWebpPtr> creates an image from WebP data\n    already in memory.\n\n    <gdImageCreateFromWebpCtx> reads its data via the function\n    pointers in a <gdIOCtx> structure.\n\n  Parameters:\n\n    infile - The input FILE pointer.\n\n  Returns:\n\n    A pointer to the new *truecolor* image.  This will need to be\n    destroyed with <gdImageDestroy> once it is no longer needed.\n\n    On error, returns NULL.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewFileCtx(inFile);\n\tif (!in) {\n\t\treturn 0;\n\t}\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\n\treturn im;\n}\n\n\n/*\n  Function: gdImageCreateFromWebpPtr\n\n    See <gdImageCreateFromWebp>.\n\n  Parameters:\n\n    size            - size of WebP data in bytes.\n    data            - pointer to WebP data.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromWebpCtx\n\n    See <gdImageCreateFromWebp>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tint    width, height;\n\tuint8_t   *filedata = NULL;\n\tuint8_t    *argb = NULL;\n\tunsigned char   *read, *temp;\n\tssize_t size = 0, n;\n\tgdImagePtr im;\n\tint x, y;\n\tuint8_t *p;\n\n\tdo {\n\t\ttemp = gdRealloc(filedata, size+GD_WEBP_ALLOC_STEP);\n\t\tif (temp) {\n\t\t\tfiledata = temp;\n\t\t\tread = temp + size;\n\t\t} else {\n\t\t\tif (filedata) {\n\t\t\t\tgdFree(filedata);\n\t\t\t}\n\t\t\tgd_error(\"WebP decode: realloc failed\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tn = gdGetBuf(read, GD_WEBP_ALLOC_STEP, infile);\n\t\tif (n>0 && n!=EOF) {\n\t\t\tsize += n;\n\t\t}\n\t} while (n>0 && n!=EOF);\n\n\tif (WebPGetInfo(filedata,size, &width, &height) == 0) {\n\t\tgd_error(\"gd-webp cannot get webp info\");\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\n\tim = gdImageCreateTrueColor(width, height);\n\tif (!im) {\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\targb = WebPDecodeARGB(filedata, size, &width, &height);\n\tif (!argb) {\n\t\tgd_error(\"gd-webp cannot allocate temporary buffer\");\n\t\tgdFree(temp);\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\tfor (y = 0, p = argb;  y < height; y++) {\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tregister uint8_t a = gdAlphaMax - (*(p++) >> 1);\n\t\t\tregister uint8_t r = *(p++);\n\t\t\tregister uint8_t g = *(p++);\n\t\t\tregister uint8_t b = *(p++);\n\t\t\tim->tpixels[y][x] = gdTrueColorAlpha(r, g, b, a);\n\t\t}\n\t}\n\t/* do not use gdFree here, in case gdFree/alloc is mapped to something else than libc */\n\tfree(argb);\n\tgdFree(temp);\n\tim->saveAlphaFlag = 1;\n\treturn im;\n}\n\n\n/* returns 0 on success, 1 on failure */\nstatic int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n    int ret = 0;\n\n\tif (im == NULL) {\n\t\treturn 1;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Palette image not supported by webp\");\n\t\treturn 1;\n\t}\n\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn 1;\n\t}\n\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn 1;\n\t}\n\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn 1;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c);\n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tif (quality >= gdWebpLossless) {\n\t\tout_size = WebPEncodeLosslessRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, &out);\n\t} else {\n\t\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\t}\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n        ret = 1;\n\t\tgoto freeargb;\n\t}\n\n\tint res = gdPutBuf(out, out_size, outfile);\n\tfree(out);\n\tif (res != out_size) {\n\t\tgd_error(\"gd-webp write error\\n\");\n\t\tret = 1;\n\t}\n\nfreeargb:\n\tgdFree(argb);\n\n    return ret;\n}\n\n\n/*\n  Function: gdImageWebpCtx\n\n    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n    for more details.\n\n  Parameters:\n\n    im      - The image to write.\n    outfile - The output sink.\n    quality - Image quality.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageWebpCtx(im, outfile, quality);\n}\n\n/*\n  Function: gdImageWebpEx\n\n    <gdImageWebpEx> outputs the specified image to the specified file in\n    WebP format. The file must be open for writing. Under MSDOS and\n    all versions of Windows, it is important to use \"wb\" as opposed to\n    simply \"w\" as the mode when opening the file, and under Unix there\n    is no penalty for doing so. <gdImageWebpEx> does not close the file;\n    your code must do so.\n\n\tIf _quality_ is -1, a reasonable quality value (which should yield a\n\tgood general quality / size tradeoff for most situations) is used. Otherwise\n\t_quality_ should be a value in the range 0-100, higher quality values\n\tusually implying both higher quality and larger image sizes.\n\n\tIf _quality_ is greater than or equal to <gdWebpLossless> then the image\n\twill be written in the lossless WebP format.\n\n  Variants:\n\n    <gdImageWebpCtx> stores the image using a <gdIOCtx> struct.\n\n    <gdImageWebpPtrEx> stores the image to RAM.\n\n  Parameters:\n\n    im      - The image to save.\n    outFile - The FILE pointer to write to.\n    quality - Compression quality (0-100).\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebp\n\n    Variant of <gdImageWebpEx> which uses the default quality (-1).\n\n  Parameters:\n\n    im      - The image to save\n    outFile - The FILE pointer to write to.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebpPtr\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}\n\n/*\n  Function: gdImageWebpPtrEx\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, quality)) {\n        rv = NULL;\n    } else {\n        rv = gdDPExtractData(out, size);\n    }\n\tout->gd_free(out);\n\treturn rv;\n}\n\n#else /* !HAVE_LIBWEBP */\n\nstatic void _noWebpError(void)\n{\n\tgd_error(\"WEBP image support has been disabled\\n\");\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n\tARG_NOT_USED(inFile);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(data);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tARG_NOT_USED(infile);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outfile);\n\tARG_NOT_USED(quality);\n\t_noWebpError();\n}\n\nBGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outFile);\n\tARG_NOT_USED(quality);\n\t_noWebpError();\n}\n\nBGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(outFile);\n\t_noWebpError();\n}\n\nBGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(size);\n\t_noWebpError();\n\treturn NULL;\n}\n\nBGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tARG_NOT_USED(im);\n\tARG_NOT_USED(size);\n\tARG_NOT_USED(quality);\n\t_noWebpError();\n\treturn NULL;\n}\n\n#endif /* HAVE_LIBWEBP */\n"], "filenames": ["src/gd_bmp.c", "src/gd_webp.c"], "buggy_code_start_loc": [32, 230], "buggy_code_end_loc": [339, 231], "fixing_code_start_loc": [33, 230], "fixing_code_end_loc": [347, 237], "type": "CWE-125", "message": "The GD Graphics Library (aka LibGD) through 2.3.2 has an out-of-bounds read because of the lack of certain gdGetBuf and gdPutBuf return value checks.", "other": {"cve": {"id": "CVE-2021-40812", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-08T21:15:14.083", "lastModified": "2021-09-15T15:07:24.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The GD Graphics Library (aka LibGD) through 2.3.2 has an out-of-bounds read because of the lack of certain gdGetBuf and gdPutBuf return value checks."}, {"lang": "es", "value": "GD Graphics Library (tambi\u00e9n se conoce como LibGD) versiones hasta 2.3.2, presenta una lectura fuera de l\u00edmites debido a una falta de ciertas comprobaciones de los valores de retorno de gdGetBuf y gdPutBuf"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.2", "matchCriteriaId": "BC97C2E1-5409-4013-BFB0-8BDD23AEFF0E"}]}]}], "references": [{"url": "https://github.com/libgd/libgd/commit/6f5136821be86e7068fcdf651ae9420b5d42e9a9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgd/libgd/issues/750#issuecomment-914872385", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/6f5136821be86e7068fcdf651ae9420b5d42e9a9"}}