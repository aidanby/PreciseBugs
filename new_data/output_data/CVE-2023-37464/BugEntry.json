{"buggy_code": ["/*!\n * Copyrights\n *\n * Portions created or assigned to Cisco Systems, Inc. are\n * Copyright (c) 2014-2016 Cisco Systems, Inc.  All Rights Reserved.\n */\n\n#define OPENSSL_API_COMPAT 0x10000000L\n\n#include <cjose/base64.h>\n#include <cjose/header.h>\n#include <cjose/jwe.h>\n#include <cjose/util.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/hmac.h>\n\n#include \"include/concatkdf_int.h\"\n#include \"include/header_int.h\"\n#include \"include/jwk_int.h\"\n#include \"include/jwe_int.h\"\n#include \"include/util_int.h\"\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_cek_aes_gcm(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err);\n\nstatic bool _cjose_jwe_set_cek_aes_cbc(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_encrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_decrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_encrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_decrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_set_iv_aes_gcm(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic bool _cjose_jwe_set_iv_aes_cbc(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_dat_aes_gcm(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_dat_aes_cbc(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_dat_aes_cbc(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic void _cjose_release_cek(uint8_t **cek, size_t cek_len)\n{\n\n    if (NULL == *cek)\n    {\n        return;\n    }\n\n    memset(*cek, 0, cek_len);\n    cjose_get_dealloc()(*cek);\n    *cek = 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_empty_json(json_t *arg)\n{\n\n    return (NULL == arg || json_is_null(arg) || (json_is_object(arg) && NULL == json_object_iter_key(arg)));\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic void _cjose_dealloc_part(struct _cjose_jwe_part_int *part)\n{\n\n    cjose_get_dealloc()(part->raw);\n    cjose_get_dealloc()(part->b64u);\n}\n\nstatic json_t *_cjose_parse_json_object(const char *str, size_t len, cjose_err *err)\n{\n\n    // unfortunately, it's not possible to tell whether the error is due\n    // to syntax, or memory shortage. See https://github.com/akheron/jansson/issues/352\n\n    json_error_t j_err;\n    json_t *json = json_loadb(str, len, 0, &j_err);\n    if (NULL == json || !json_is_object(json))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        json_decref(json);\n        return NULL;\n    }\n\n    return json;\n}\n\nstatic inline bool _cjose_convert_part(struct _cjose_jwe_part_int *part, cjose_err *err)\n{\n\n    if ((NULL == part->b64u)\n        && (!cjose_base64url_encode((const uint8_t *)part->raw, part->raw_len, &part->b64u, &part->b64u_len, err)))\n    {\n\n        return false;\n    }\n\n    // dealloc the raw part, we will never need it again\n    cjose_get_dealloc()(part->raw);\n    part->raw = NULL;\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_convert_to_base64(struct _cjose_jwe_int *jwe, cjose_err *err)\n{\n\n    if (!_cjose_convert_part(&jwe->enc_header, err) || !_cjose_convert_part(&jwe->enc_iv, err)\n        || !_cjose_convert_part(&jwe->enc_iv, err) || !_cjose_convert_part(&jwe->enc_ct, err)\n        || !_cjose_convert_part(&jwe->enc_auth_tag, err))\n    {\n\n        return false;\n    }\n\n    for (int i = 0; i < jwe->to_count; i++)\n    {\n        if (!_cjose_convert_part(&jwe->to[i].enc_key, err))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic size_t _keylen_from_enc(const char *alg)\n{\n    size_t keylen = 0;\n\n    if (0 == strcmp(alg, CJOSE_HDR_ENC_A128GCM))\n    {\n        keylen = 128;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A192GCM))\n    {\n        keylen = 192;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A256GCM))\n    {\n        keylen = 256;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A128CBC_HS256))\n    {\n        keylen = 256;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A192CBC_HS384))\n    {\n        keylen = 384;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A256CBC_HS512))\n    {\n        keylen = 512;\n    }\n\n    return keylen;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_malloc(size_t bytes, bool random, uint8_t **buffer, cjose_err *err)\n{\n    *buffer = (uint8_t *)cjose_get_alloc()(bytes);\n    if (NULL == *buffer)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return false;\n    }\n    if (random)\n    {\n        if (RAND_bytes((unsigned char *)*buffer, bytes) != 1)\n        {\n            cjose_get_dealloc()(*buffer);\n            CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n            return false;\n        }\n    }\n    else\n    {\n        memset(*buffer, 0, bytes);\n    }\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_build_hdr(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // serialize the header\n    char *hdr_str = json_dumps(jwe->hdr, JSON_ENCODE_ANY | JSON_PRESERVE_ORDER);\n    if (NULL == hdr_str)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return false;\n    }\n\n    // copy the serialized header to JWE (hdr_str is owned by header object)\n    size_t len = strlen(hdr_str);\n    uint8_t *data = (uint8_t *)_cjose_strndup(hdr_str, len, err);\n    if (!data)\n    {\n        cjose_get_dealloc()(hdr_str);\n        return false;\n    }\n\n    jwe->enc_header.raw = data;\n    jwe->enc_header.raw_len = len;\n    cjose_get_dealloc()(hdr_str);\n\n    return true;\n}\n\nstatic const char *_cjose_jwe_get_from_headers(cjose_header_t *protected_header,\n                                               cjose_header_t *unprotected_header,\n                                               cjose_header_t *personal_header,\n                                               const char *key)\n{\n\n    // TODO: https://github.com/cisco/cjose/issues/52\n    cjose_header_t *headers[] = { personal_header, unprotected_header, protected_header };\n\n    for (int i = 0; i < 3; i++)\n    {\n        if (NULL == headers[i])\n        {\n            continue;\n        }\n        json_t *obj = json_object_get((json_t *)headers[i], key);\n        if (NULL == obj)\n        {\n            continue;\n        }\n        const char *value = json_string_value(obj);\n        if (NULL == value)\n        {\n            continue;\n        }\n        return value;\n    }\n\n    return NULL;\n}\n\nstatic bool _cjose_jwe_validate_enc(cjose_jwe_t *jwe, cjose_header_t *protected_header, cjose_err *err)\n{\n\n    const char *enc = cjose_header_get(protected_header, CJOSE_HDR_ENC, err);\n    if (NULL == enc)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    if ((strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0) || (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        || (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0))\n    {\n        jwe->fns.set_cek = _cjose_jwe_set_cek_aes_gcm;\n        jwe->fns.set_iv = _cjose_jwe_set_iv_aes_gcm;\n        jwe->fns.encrypt_dat = _cjose_jwe_encrypt_dat_aes_gcm;\n        jwe->fns.decrypt_dat = _cjose_jwe_decrypt_dat_aes_gcm;\n    }\n    if ((strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0) || (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n        || (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0))\n    {\n        jwe->fns.set_cek = _cjose_jwe_set_cek_aes_cbc;\n        jwe->fns.set_iv = _cjose_jwe_set_iv_aes_cbc;\n        jwe->fns.encrypt_dat = _cjose_jwe_encrypt_dat_aes_cbc;\n        jwe->fns.decrypt_dat = _cjose_jwe_decrypt_dat_aes_cbc;\n    }\n\n    if (NULL == jwe->fns.set_cek || NULL == jwe->fns.set_iv || NULL == jwe->fns.encrypt_dat || NULL == jwe->fns.decrypt_dat)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_validate_alg(cjose_header_t *protected_header,\n                                    cjose_header_t *unprotected_header,\n                                    bool is_multiple,\n                                    _jwe_int_recipient_t *recipient,\n                                    cjose_err *err)\n{\n\n    const char *alg = _cjose_jwe_get_from_headers(protected_header, unprotected_header, (cjose_header_t *)recipient->unprotected,\n                                                  CJOSE_HDR_ALG);\n\n    if (NULL == alg)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // set JWE build functions based on header contents\n    if (strcmp(alg, CJOSE_HDR_ALG_RSA_OAEP) == 0)\n    {\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_rsa_oaep;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_rsa_oaep;\n    }\n    if (strcmp(alg, CJOSE_HDR_ALG_RSA1_5) == 0)\n    {\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_rsa1_5;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_rsa1_5;\n    }\n    if (strcmp(alg, CJOSE_HDR_ALG_ECDH_ES) == 0)\n    {\n        if (is_multiple)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_ecdh_es;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_ecdh_es;\n    }\n    if (strcmp(alg, CJOSE_HDR_ALG_DIR) == 0)\n    {\n        if (is_multiple)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_dir;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_dir;\n    }\n    if ((strcmp(alg, CJOSE_HDR_ALG_A128KW) == 0) || (strcmp(alg, CJOSE_HDR_ALG_A192KW) == 0)\n        || (strcmp(alg, CJOSE_HDR_ALG_A256KW) == 0))\n    {\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_aes_kw;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_aes_kw;\n    }\n\n    // ensure required builders have been assigned\n    if (NULL == recipient->fns.encrypt_ek || NULL == recipient->fns.decrypt_ek)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_cek_aes_gcm(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err)\n{\n    if (NULL != jwe->cek)\n    {\n        return true;\n    }\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // determine the CEK key size based on the encryption algorithm\n    size_t keysize = 0;\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        keysize = 16;\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        keysize = 24;\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        keysize = 32;\n\n    // if no JWK is provided, generate a random key\n    if (NULL == jwk)\n    {\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, random, &jwe->cek, err))\n        {\n            return false;\n        }\n        jwe->cek_len = keysize;\n    }\n    else\n    {\n        // if a JWK is provided, it must be a symmetric key of correct size\n        if (CJOSE_JWK_KTY_OCT != cjose_jwk_get_kty(jwk, err) || jwk->keysize != keysize * 8 || NULL == jwk->keydata)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n\n        // copy the key material directly from jwk to the jwe->cek\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, false, &jwe->cek, err))\n        {\n            return false;\n        }\n        memcpy(jwe->cek, jwk->keydata, keysize);\n        jwe->cek_len = keysize;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_cek_aes_cbc(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err)\n{\n\n    if (NULL != jwe->cek)\n    {\n        return true;\n    }\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // determine the CEK key size based on the encryption algorithm\n    size_t keysize = 0;\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n        keysize = 32;\n    if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n        keysize = 48;\n    if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n        keysize = 64;\n\n    if (NULL == jwk)\n    {\n        // allocate memory for the CEK and fill with random bytes or 0's\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, !random, &jwe->cek, err))\n        {\n            return false;\n        }\n        jwe->cek_len = keysize;\n    }\n    else\n    {\n        // if a JWK is provided, it must be a symmetric key of correct size\n        if (CJOSE_JWK_KTY_OCT != cjose_jwk_get_kty(jwk, err) || jwk->keysize != keysize * 8 || NULL == jwk->keydata)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n\n        // copy the key material directly from jwk to the jwe->cek\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, false, &jwe->cek, err))\n        {\n            return false;\n        }\n        memcpy(jwe->cek, jwk->keydata, keysize);\n        jwe->cek_len = keysize;\n    }\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    // for direct encryption, JWE sec 5.1, step 6: let CEK be the symmetric key.\n    if (!jwe->fns.set_cek(jwe, jwk, false, err))\n    {\n        return false;\n    }\n\n    // for direct encryption, JWE sec 5.1, step 5: let EK be empty octet seq.\n    recipient->enc_key.raw = NULL;\n    recipient->enc_key.raw_len = 0;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    // do not try and decrypt the ek. that's impossible.\n    // instead... only try to realize the truth.  there is no ek.\n    return jwe->fns.set_cek(jwe, jwk, false, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must be OCT\n    if (jwk->kty != CJOSE_JWK_KTY_OCT)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // generate random CEK\n    if (!jwe->fns.set_cek(jwe, NULL, true, err))\n    {\n        return false;\n    }\n\n    // create the AES encryption key from the shared key\n    AES_KEY akey;\n    if (AES_set_encrypt_key(jwk->keydata, jwk->keysize, &akey) < 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    // allocate buffer for encrypted CEK (=cek_len + 8)\n    if (!_cjose_jwe_malloc(jwe->cek_len + 8, false, &recipient->enc_key.raw, err))\n    {\n        return false;\n    }\n\n    // AES wrap the CEK\n    int len = AES_wrap_key(&akey, NULL, recipient->enc_key.raw, jwe->cek, jwe->cek_len);\n    if (len <= 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n    recipient->enc_key.raw_len = len;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must be OCT\n    if (jwk->kty != CJOSE_JWK_KTY_OCT)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // create the AES decryption key from the shared key\n    AES_KEY akey;\n    if (AES_set_decrypt_key(jwk->keydata, jwk->keysize, &akey) < 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    if (!jwe->fns.set_cek(jwe, NULL, false, err))\n    {\n        return false;\n    }\n\n    // AES unwrap the CEK in to jwe->cek\n    int len = AES_unwrap_key(&akey, (const unsigned char *)NULL, jwe->cek, (const unsigned char *)recipient->enc_key.raw,\n                             recipient->enc_key.raw_len);\n    if (len <= 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n    jwe->cek_len = len;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_rsa_padding(\n    _jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, int padding, cjose_err *err)\n{\n    // jwk must be RSA\n    if (jwk->kty != CJOSE_JWK_KTY_RSA || NULL == jwk->keydata)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must have the necessary public parts set\n    BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n    _cjose_jwk_rsa_get((RSA *)jwk->keydata, &rsa_n, &rsa_e, &rsa_d);\n    if (NULL == rsa_e || NULL == rsa_n)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // generate random cek\n    if (!jwe->fns.set_cek(jwe, NULL, true, err))\n    {\n        return false;\n    }\n\n    // the size of the ek will match the size of the RSA key\n    recipient->enc_key.raw_len = RSA_size((RSA *)jwk->keydata);\n\n    // for OAEP padding - the RSA size - 41 must be greater than input\n    if (jwe->cek_len >= recipient->enc_key.raw_len - 41)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // allocate memory for RSA encryption\n    cjose_get_dealloc()(recipient->enc_key.raw);\n    if (!_cjose_jwe_malloc(recipient->enc_key.raw_len, false, &recipient->enc_key.raw, err))\n    {\n        return false;\n    }\n\n    // encrypt the CEK using RSA v1.5 or OAEP padding\n    if (RSA_public_encrypt(jwe->cek_len, jwe->cek, recipient->enc_key.raw, (RSA *)jwk->keydata, padding)\n        != recipient->enc_key.raw_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_rsa_padding(\n    _jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, int padding, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must be RSA\n    if (jwk->kty != CJOSE_JWK_KTY_RSA)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must have the necessary private parts set\n    BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n    _cjose_jwk_rsa_get((RSA *)jwk->keydata, &rsa_n, &rsa_e, &rsa_d);\n    if (NULL == rsa_e || NULL == rsa_n || NULL == rsa_d)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // we don't know the size of the key to expect, but must be < RSA_size\n    _cjose_release_cek(&jwe->cek, jwe->cek_len);\n    size_t buflen = RSA_size((RSA *)jwk->keydata);\n    if (!_cjose_jwe_malloc(buflen, false, &jwe->cek, err))\n    {\n        return false;\n    }\n\n    // decrypt the CEK using RSA v1.5 or OAEP padding\n    int len = RSA_private_decrypt(recipient->enc_key.raw_len, recipient->enc_key.raw, jwe->cek, (RSA *)jwk->keydata, padding);\n    if (-1 == len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    jwe->cek_len = len;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool\n_cjose_jwe_encrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_encrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_OAEP_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool\n_cjose_jwe_decrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_decrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_OAEP_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_encrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_decrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    cjose_jwk_t *epk_jwk = NULL;\n    char *epk_json = NULL;\n    uint8_t *secret = NULL;\n    size_t secret_len = 0;\n    uint8_t *otherinfo = NULL;\n    size_t otherinfo_len = 0;\n    uint8_t *derived = NULL;\n    bool result = false;\n\n    // generate and export random EPK\n    epk_jwk = cjose_jwk_create_EC_random(cjose_jwk_EC_get_curve(jwk, err), err);\n    if (NULL == epk_jwk)\n    {\n        // error details already set\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n    epk_json = cjose_jwk_to_json(epk_jwk, false, err);\n    if (NULL == epk_json)\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n    if (!cjose_header_set_raw(jwe->hdr, CJOSE_HDR_EPK, epk_json, err))\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    // perform ECDH (private=epk_jwk, public=jwk)\n    if (!cjose_jwk_derive_ecdh_bits(epk_jwk, jwk, &secret, &secret_len, err))\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    // perform label, ConcatKDF\n    // - assemble otherInfo from:\n    //   * alg (== {enc})\n    //   * apu (default = \"\")\n    //   * apv (default = \"\")\n    //   * keylen (determined from {enc})\n    cjose_header_t *hdr = jwe->hdr;\n    const char *algId = cjose_header_get(hdr, CJOSE_HDR_ENC, err);\n    const size_t keylen = _keylen_from_enc(algId) / 8;\n\n    if (!cjose_concatkdf_create_otherinfo(algId, keylen * 8, hdr, &otherinfo, &otherinfo_len, err))\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    derived = cjose_concatkdf_derive(keylen, secret, secret_len, otherinfo, otherinfo_len, err);\n    if (NULL == derived)\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    jwe->cek = derived;\n    jwe->cek_len = keylen;\n    recipient->enc_key.raw = NULL;\n    recipient->enc_key.raw_len = 0;\n    result = true;\n\ncjose_encrypt_ek_ecdh_es_finish:\n\n    cjose_jwk_release(epk_jwk);\n    cjose_get_dealloc()(epk_json);\n    cjose_get_dealloc()(secret);\n    cjose_get_dealloc()(otherinfo);\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    cjose_jwk_t *epk_jwk = NULL;\n    uint8_t *secret = NULL;\n    size_t secret_len = 0;\n    uint8_t *otherinfo = NULL;\n    size_t otherinfo_len = 0;\n    uint8_t *derived = NULL;\n    bool result = false;\n\n    memset(err, 0, sizeof(cjose_err));\n    char *epk_json = cjose_header_get_raw(jwe->hdr, CJOSE_HDR_EPK, err);\n    if (NULL != epk_json)\n    {\n        epk_jwk = cjose_jwk_import(epk_json, strlen(epk_json), err);\n    }\n    else if (CJOSE_ERR_NONE == err->code)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    if (NULL == epk_jwk)\n    {\n        // error details already set\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    // perform ECDH (private=jwk, public=epk_jwk)\n    if (!cjose_jwk_derive_ecdh_bits(jwk, epk_jwk, &secret, &secret_len, err))\n    {\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    // perform label, ConcatKDF\n    // - assemble otherInfo from:\n    //   * alg (== {enc})\n    //   * apu (default = \"\")\n    //   * apv (default = \"\")\n    //   * keylen (determined from {enc})\n    cjose_header_t *hdr = jwe->hdr;\n    const char *algId = cjose_header_get(hdr, CJOSE_HDR_ENC, err);\n    const size_t keylen = _keylen_from_enc(algId) / 8;\n\n    if (!cjose_concatkdf_create_otherinfo(algId, keylen * 8, hdr, &otherinfo, &otherinfo_len, err))\n    {\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    derived = cjose_concatkdf_derive(keylen, secret, secret_len, otherinfo, otherinfo_len, err);\n    if (NULL == derived)\n    {\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    jwe->cek = derived;\n    jwe->cek_len = keylen;\n    recipient->enc_key.raw = NULL;\n    recipient->enc_key.raw_len = 0;\n    result = true;\n\ncjose_decrypt_ek_ecdh_es_finish:\n\n    cjose_jwk_release(epk_jwk);\n    cjose_get_dealloc()(epk_json);\n    cjose_get_dealloc()(secret);\n    cjose_get_dealloc()(otherinfo);\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_iv_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // generate IV as random 96 bit value\n    cjose_get_dealloc()(jwe->enc_iv.raw);\n    jwe->enc_iv.raw_len = 12;\n    if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, true, &jwe->enc_iv.raw, err))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_iv_aes_cbc(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    cjose_get_dealloc()(jwe->enc_iv.raw);\n\n    // RFC 7516 (https://tools.ietf.org/html/rfc7516) is unclear about\n    // the size of the IV for AES-CBC. In section 5.1\n    // (https://tools.ietf.org/html/rfc7516#section-5.1), they state in no. 9.:\n    // \"Generate a random JWE Initialization Vector of the correct size\n    // for the content encryption algorithm\"\n    // And in the example in A.2.4 (https://tools.ietf.org/html/rfc7516#appendix-A.2.4)\n    // they provide an example for AES128-CBC, which results (naturally) in the IV size of 128Bit.\n    //\n    // The CISCO implementation chooses for the size of the IV the key size of the\n    // cipher algorithm, which seems to be wrong.\n    //\n    // According to RFC 3602 section 3 (https://tools.ietf.org/html/rfc3602#section-3):\n    // \"The IV field MUST be the same size as the block size of the cipher algorithm being used.\"\n    // And because the block size for AES cipher is always 16 Byte, the IV must be 16 Byte long.\n    //\n    // IV size for AES CBC is always 16 Byte\n    jwe->enc_iv.raw_len = 16;\n\n    // generate IV as random iv_size * 8 bit value\n    if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, true, &jwe->enc_iv.raw, err))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n#if defined(CJOSE_OPENSSL_11X)\n#define CJOSE_EVP_CTRL_GCM_GET_TAG EVP_CTRL_AEAD_GET_TAG\n#define CJOSE_EVP_CTRL_GCM_SET_TAG EVP_CTRL_AEAD_SET_TAG\n#else\n#define CJOSE_EVP_CTRL_GCM_GET_TAG EVP_CTRL_GCM_GET_TAG\n#define CJOSE_EVP_CTRL_GCM_SET_TAG EVP_CTRL_GCM_SET_TAG\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_dat_aes_gcm(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    if (NULL == plaintext)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for encryption using AES GCM cipher and CEK and IV\n    if (EVP_EncryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // we need the header in base64url encoding as input for encryption\n    if ((NULL == jwe->enc_header.b64u)\n        && (!cjose_base64url_encode((const uint8_t *)jwe->enc_header.raw, jwe->enc_header.raw_len, &jwe->enc_header.b64u,\n                                    &jwe->enc_header.b64u_len, err)))\n    {\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_encrypted = 0;\n    if (EVP_EncryptUpdate(ctx, NULL, &bytes_encrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_encrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // allocate buffer for the ciphertext\n    cjose_get_dealloc()(jwe->enc_ct.raw);\n    jwe->enc_ct.raw_len = plaintext_len;\n    if (!_cjose_jwe_malloc(jwe->enc_ct.raw_len, false, &jwe->enc_ct.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // encrypt entire plaintext to ciphertext buffer\n    if (EVP_EncryptUpdate(ctx, jwe->enc_ct.raw, &bytes_encrypted, plaintext, plaintext_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n    jwe->enc_ct.raw_len = bytes_encrypted;\n\n    // finalize the encryption and set the ciphertext length to correct value\n    if (EVP_EncryptFinal_ex(ctx, NULL, &bytes_encrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // allocate buffer for the authentication tag\n    cjose_get_dealloc()(jwe->enc_auth_tag.raw);\n    jwe->enc_auth_tag.raw_len = 16;\n    if (!_cjose_jwe_malloc(jwe->enc_auth_tag.raw_len, false, &jwe->enc_auth_tag.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // get the GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_GET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_encrypt_dat_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_calc_auth_tag(const char *enc, cjose_jwe_t *jwe, uint8_t *md, unsigned int *md_len, cjose_err *err)\n{\n    bool retval = false;\n    const EVP_MD *hash = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n    {\n        hash = EVP_sha256();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n    {\n        hash = EVP_sha384();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n    {\n        hash = EVP_sha512();\n    }\n\n    if (NULL == hash)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    uint8_t *msg = NULL;\n\n    // calculate the Authentication Tag value over AAD + IV + ciphertext + AAD length\n\n    // 0 = header\n    // 1 = cek\n    // 2 = iv\n    // 3 = ciphertext\n    // 4 = authentication tag\n\n    // Additional Authentication Data length (base64encoded header) in # of bits in 64 bit length field\n    uint64_t al = jwe->enc_header.b64u_len * 8;\n\n    // concatenate AAD + IV + ciphertext + AAD length field\n    int msg_len = jwe->enc_header.b64u_len + jwe->enc_iv.raw_len + jwe->enc_ct.raw_len + sizeof(uint64_t);\n    if (!_cjose_jwe_malloc(msg_len, false, &msg, err))\n    {\n        goto _cjose_jwe_calc_auth_tag_end;\n    }\n\n    // construct AAD + IV + ciphertext + AAD input\n    uint8_t *p = msg;\n    memcpy(p, jwe->enc_header.b64u, jwe->enc_header.b64u_len);\n    p += jwe->enc_header.b64u_len;\n    memcpy(p, jwe->enc_iv.raw, jwe->enc_iv.raw_len);\n    p += jwe->enc_iv.raw_len;\n    memcpy(p, jwe->enc_ct.raw, jwe->enc_ct.raw_len);\n    p += jwe->enc_ct.raw_len;\n\n    // check if we are on a big endian or little endian machine\n    int c = 1;\n    if (*(char *)&c == 1)\n    {\n        // little endian machine: reverse AAD length for big endian representation\n        al = (al & 0x00000000FFFFFFFF) << 32 | (al & 0xFFFFFFFF00000000) >> 32;\n        al = (al & 0x0000FFFF0000FFFF) << 16 | (al & 0xFFFF0000FFFF0000) >> 16;\n        al = (al & 0x00FF00FF00FF00FF) << 8 | (al & 0xFF00FF00FF00FF00) >> 8;\n    }\n    memcpy(p, &al, sizeof(uint64_t));\n\n    // HMAC the input\n    if (!HMAC(hash, jwe->cek, jwe->cek_len / 2, msg, msg_len, md, md_len))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_calc_auth_tag_end;\n    }\n\n    // use only the first half of the bits\n    *md_len = *md_len / 2;\n    retval = true;\n\n_cjose_jwe_calc_auth_tag_end:\n    if (msg)\n    {\n        cjose_get_dealloc()(msg);\n    }\n    return retval;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_dat_aes_cbc(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err)\n{\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get the AES cipher\n    EVP_CIPHER_CTX *ctx = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n        cipher = EVP_aes_128_cbc();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n        cipher = EVP_aes_192_cbc();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n        cipher = EVP_aes_256_cbc();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using the cipher, the 2nd half of the CEK and the IV\n    if (EVP_EncryptInit_ex(ctx, cipher, NULL, jwe->cek + jwe->cek_len / 2, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    // we need the header in base64url encoding as input for encryption\n    if ((NULL == jwe->enc_header.b64u)\n        && (!cjose_base64url_encode((const uint8_t *)jwe->enc_header.raw, jwe->enc_header.raw_len, &jwe->enc_header.b64u,\n                                    &jwe->enc_header.b64u_len, err)))\n    {\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    // allocate buffer for the ciphertext (plaintext + block size)\n    cjose_get_dealloc()(jwe->enc_ct.raw);\n    jwe->enc_ct.raw_len = plaintext_len + EVP_CIPHER_block_size(cipher);\n    if (!_cjose_jwe_malloc(jwe->enc_ct.raw_len, false, &jwe->enc_ct.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    // encrypt entire plaintext to ciphertext buffer\n    int bytes_encrypted = 0;\n    if (EVP_EncryptUpdate(ctx, jwe->enc_ct.raw, &bytes_encrypted, plaintext, plaintext_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    jwe->enc_ct.raw_len = bytes_encrypted;\n\n    // finalize the encryption and set the ciphertext length to correct value\n    if (EVP_EncryptFinal_ex(ctx, jwe->enc_ct.raw + bytes_encrypted, &bytes_encrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    jwe->enc_ct.raw_len += bytes_encrypted;\n\n    // calculate Authentication Tag\n    unsigned int tag_len = 0;\n    uint8_t tag[EVP_MAX_MD_SIZE];\n    if (_cjose_jwe_calc_auth_tag(enc, jwe, (unsigned char *)&tag, &tag_len, err) == false)\n    {\n        return false;\n    }\n\n    // allocate buffer for the authentication tag\n    cjose_get_dealloc()(jwe->enc_auth_tag.raw);\n    jwe->enc_auth_tag.raw_len = tag_len;\n    if (!_cjose_jwe_malloc(jwe->enc_auth_tag.raw_len, false, &jwe->enc_auth_tag.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    memcpy(jwe->enc_auth_tag.raw, tag, tag_len);\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return true;\n\n_cjose_jwe_encrypt_dat_aes_cbc_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set the expected GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_dat_aes_cbc(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // calculate Authentication Tag\n    unsigned int tag_len = 0;\n    uint8_t tag[EVP_MAX_MD_SIZE];\n    if (_cjose_jwe_calc_auth_tag(enc, jwe, (unsigned char *)&tag, &tag_len, err) == false)\n    {\n        return false;\n    }\n\n    // compare the provided Authentication Tag against our calculation\n    if ((tag_len != jwe->enc_auth_tag.raw_len) || (cjose_const_memcmp(tag, jwe->enc_auth_tag.raw, tag_len) != 0))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    // get the AES cipher\n    EVP_CIPHER_CTX *ctx = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n    {\n        cipher = EVP_aes_128_cbc();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n    {\n        cipher = EVP_aes_192_cbc();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n    {\n        cipher = EVP_aes_256_cbc();\n    }\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using the cipher, the 2nd half of the CEK and the IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek + jwe->cek_len / 2, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // allocate buffer for the plaintext + one block padding\n    int p_len = jwe->enc_ct.raw_len, f_len = 0;\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = p_len + AES_BLOCK_SIZE;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &p_len, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, jwe->dat + p_len, &f_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n    jwe->dat_len = p_len + f_len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_cbc_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt_iv(const cjose_jwk_t *jwk,\n                                  cjose_header_t *protected_header,\n                                  const uint8_t *iv,\n                                  size_t iv_len,\n                                  const uint8_t *plaintext,\n                                  size_t plaintext_len,\n                                  cjose_err *err)\n{\n\n    cjose_jwe_recipient_t rec = { .jwk = jwk, .unprotected_header = NULL };\n\n    return cjose_jwe_encrypt_multi_iv(&rec, 1, protected_header, NULL, iv, iv_len, plaintext, plaintext_len, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt(\n    const cjose_jwk_t *jwk, cjose_header_t *protected_header, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err)\n{\n    return cjose_jwe_encrypt_iv(jwk, protected_header, NULL, 0, plaintext, plaintext_len, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt_multi_iv(const cjose_jwe_recipient_t *recipients,\n                                        size_t recipient_count,\n                                        cjose_header_t *protected_header,\n                                        cjose_header_t *shared_unprotected_header,\n                                        const uint8_t *iv,\n                                        size_t iv_len,\n                                        const uint8_t *plaintext,\n                                        size_t plaintext_len,\n                                        cjose_err *err)\n{\n    cjose_jwe_t *jwe = NULL;\n\n    if (NULL == recipients || NULL == protected_header || recipient_count < 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // allocate and initialize a new JWE object\n    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))\n    {\n        return NULL;\n    }\n\n    jwe->to_count = recipient_count;\n    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t) * recipient_count, false, (uint8_t **)&jwe->to, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    if (!_cjose_jwe_validate_enc(jwe, protected_header, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // validate JWE header\n    for (size_t i = 0; i < recipient_count; i++)\n    {\n\n        if (NULL == recipients[i].jwk)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n\n        jwe->to[i].unprotected = json_incref(recipients[i].unprotected_header);\n\n        // make sure we have an alg header\n        if (!_cjose_jwe_validate_alg(protected_header, jwe->to[i].unprotected, recipient_count > 1, jwe->to + i, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n    }\n\n    // prepare JWE headers\n    jwe->hdr = json_deep_copy(protected_header);\n    if (jwe->hdr == NULL)\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n    jwe->shared_hdr = json_incref(shared_unprotected_header);\n\n    for (size_t i = 0; i < recipient_count; i++)\n    {\n\n        // build JWE content-encryption key and encrypted key\n        if (!jwe->to[i].fns.encrypt_ek(jwe->to + i, jwe, recipients[i].jwk, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n    }\n\n    // build JWE header\n    if (!_cjose_jwe_build_hdr(jwe, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // build JWE initialization vector\n    if (iv == NULL)\n    {\n        if (!jwe->fns.set_iv(jwe, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n    }\n    else\n    {\n        cjose_get_dealloc()(jwe->enc_iv.raw);\n        jwe->enc_iv.raw_len = iv_len;\n        if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, false, &jwe->enc_iv.raw, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n        memcpy(jwe->enc_iv.raw, iv, iv_len);\n    }\n\n    // build JWE encrypted data and authentication tag\n    if (!jwe->fns.encrypt_dat(jwe, plaintext, plaintext_len, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    _cjose_release_cek(&jwe->cek, jwe->cek_len);\n\n    return jwe;\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt_multi(const cjose_jwe_recipient_t *recipients,\n                                     size_t recipient_count,\n                                     cjose_header_t *protected_header,\n                                     cjose_header_t *shared_unprotected_header,\n                                     const uint8_t *plaintext,\n                                     size_t plaintext_len,\n                                     cjose_err *err)\n{\n    return cjose_jwe_encrypt_multi_iv(recipients, recipient_count, protected_header, shared_unprotected_header, NULL, 0, plaintext,\n                                      plaintext_len, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nvoid cjose_jwe_release(cjose_jwe_t *jwe)\n{\n    if (NULL == jwe)\n    {\n        return;\n    }\n\n    json_decref(jwe->hdr);\n    json_decref(jwe->shared_hdr);\n\n    _cjose_dealloc_part(&jwe->enc_header);\n    _cjose_dealloc_part(&jwe->enc_iv);\n    _cjose_dealloc_part(&jwe->enc_ct);\n    _cjose_dealloc_part(&jwe->enc_auth_tag);\n\n    for (int i = 0; i < jwe->to_count; ++i)\n    {\n        json_decref(jwe->to[i].unprotected);\n        _cjose_dealloc_part(&jwe->to[i].enc_key);\n    }\n\n    cjose_get_dealloc()(jwe->to);\n\n    _cjose_release_cek(&jwe->cek, jwe->cek_len);\n\n    cjose_get_dealloc()(jwe->dat);\n    cjose_get_dealloc()(jwe);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nchar *cjose_jwe_export(cjose_jwe_t *jwe, cjose_err *err)\n{\n    char *cser = NULL;\n    size_t cser_len = 0;\n\n    if (NULL == jwe || jwe->to_count > 1 || !_cjose_empty_json(jwe->shared_hdr) || !_cjose_empty_json(jwe->to[0].unprotected))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    if (!_cjose_convert_to_base64(jwe, err))\n    {\n        return NULL;\n    }\n\n    // make sure all parts are b64u encoded\n    cser_len = jwe->enc_header.b64u_len + jwe->to[0].enc_key.b64u_len + jwe->enc_iv.b64u_len + jwe->enc_ct.b64u_len\n               + jwe->enc_auth_tag.b64u_len + 5;\n\n    // allocate buffer for compact serialization\n    if (!_cjose_jwe_malloc(cser_len, false, (uint8_t **)&cser, err))\n    {\n        return NULL;\n    }\n\n    // build the compact serialization\n    snprintf(cser, cser_len, \"%s.%s.%s.%s.%s\", jwe->enc_header.b64u, jwe->to[0].enc_key.b64u, jwe->enc_iv.b64u, jwe->enc_ct.b64u,\n             jwe->enc_auth_tag.b64u);\n\n    return cser;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic inline bool _cjose_add_json_part(json_t *obj, const char *key, struct _cjose_jwe_part_int *part, cjose_err *err)\n{\n    json_t *str = json_stringn(part->b64u, part->b64u_len);\n    if (NULL == str)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return false;\n    }\n    json_object_set_new(obj, key, str);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nchar *cjose_jwe_export_json(cjose_jwe_t *jwe, cjose_err *err)\n{\n\n    if (!_cjose_convert_to_base64(jwe, err))\n    {\n        return NULL;\n    }\n\n    json_t *form = json_object();\n    if (NULL == form)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return NULL;\n    }\n\n    if (!_cjose_add_json_part(form, \"protected\", &jwe->enc_header, err) || !_cjose_add_json_part(form, \"iv\", &jwe->enc_iv, err)\n        || !_cjose_add_json_part(form, \"ciphertext\", &jwe->enc_ct, err)\n        || !_cjose_add_json_part(form, \"tag\", &jwe->enc_auth_tag, err))\n    {\n        json_delete(form);\n        return NULL;\n    }\n\n    json_object_set(form, \"unprotected\", jwe->shared_hdr);\n\n    if (jwe->to_count == 1)\n    {\n        json_object_set(form, \"header\", jwe->to[0].unprotected);\n        if (!_cjose_add_json_part(form, \"encrypted_key\", &jwe->to[0].enc_key, err))\n        {\n            json_delete(form);\n            return NULL;\n        }\n    }\n    else\n    {\n\n        json_t *recipients = json_array();\n        if (NULL == recipients)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n            json_delete(form);\n            return NULL;\n        }\n\n        json_object_set_new(form, \"recipients\", recipients);\n\n        for (int i = 0; i < jwe->to_count; i++)\n        {\n\n            json_t *recipient = json_object();\n            if (NULL == recipient)\n            {\n                CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n                json_delete(form);\n                return NULL;\n            }\n\n            json_array_append_new(recipients, recipient);\n\n            json_object_set(recipient, \"header\", jwe->to[i].unprotected);\n            if (!_cjose_add_json_part(recipient, \"encrypted_key\", &jwe->to[i].enc_key, err))\n            {\n                json_delete(form);\n                return NULL;\n            }\n        }\n    }\n\n    char *json_str = json_dumps(form, JSON_PRESERVE_ORDER);\n    if (NULL == json_str)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        json_delete(form);\n        return NULL;\n    }\n\n    json_delete(form);\n    return json_str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool\n_cjose_jwe_import_part(struct _cjose_jwe_part_int *part, bool empty_ok, const char *b64u, size_t b64u_len, cjose_err *err)\n{\n    // only the ek and the data parts may be of zero length\n    if (b64u_len == 0 && !empty_ok)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // copy the b64u part to the jwe\n    part->b64u = _cjose_strndup(b64u, b64u_len, err);\n    part->b64u_len = b64u_len;\n\n    // b64u decode the part\n    if (!cjose_base64url_decode(part->b64u, part->b64u_len, (uint8_t **)&part->raw, &part->raw_len, err) || NULL == part->raw)\n    {\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool _cjose_jwe_import_json_part(struct _cjose_jwe_part_int *part, bool empty_ok, json_t *json, cjose_err *err)\n{\n\n    if (NULL == json || !json_is_string(json))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    const char *str = json_string_value(json);\n    // TODO: if json_is_string() was true, are we guaranteed that str is !NULL?\n\n    return _cjose_jwe_import_part(part, empty_ok, str, strlen(str), err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_import(const char *cser, size_t cser_len, cjose_err *err)\n{\n    cjose_jwe_t *jwe = NULL;\n\n    if (NULL == cser)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // allocate and initialize a new JWE object\n    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))\n    {\n        return NULL;\n    }\n\n    jwe->to_count = 1;\n    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t), false, (uint8_t **)&jwe->to, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    struct _cjose_jwe_part_int *parts[] = {\n        &jwe->enc_header, &jwe->to[0].enc_key, &jwe->enc_iv, &jwe->enc_ct, &jwe->enc_auth_tag,\n    };\n\n    // import each part of the compact serialization\n    int part = 0;\n    size_t idx = 0;\n    size_t start_idx = 0;\n    while (idx <= cser_len && part < 5)\n    {\n        if ((idx == cser_len) || (cser[idx] == '.'))\n        {\n            if (!_cjose_jwe_import_part(parts[part], 1 == part || 3 == part, cser + start_idx, idx - start_idx, err))\n            {\n                cjose_jwe_release(jwe);\n                return NULL;\n            }\n            part++;\n            start_idx = idx + 1;\n        }\n        if (part < 5)\n            ++idx;\n    }\n\n    // fail if we didn't find enough parts\n    if (part != 5)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // fail if we finished early (e.g. more than 5 parts)\n    if (idx != cser_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // deserialize JSON header\n    jwe->hdr = _cjose_parse_json_object((const char *)jwe->enc_header.raw, jwe->enc_header.raw_len, err);\n    if (NULL == jwe->hdr)\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // validate the JSON header. No unprotected headers can exist.\n    if (!_cjose_jwe_validate_alg((cjose_header_t *)jwe->hdr, NULL, false, jwe->to, err)\n        || !_cjose_jwe_validate_enc(jwe, (cjose_header_t *)jwe->hdr, err))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    return jwe;\n}\n\nstatic inline bool _cjose_read_json_recipient(cjose_jwe_t *jwe,\n                                              cjose_header_t *protected_header,\n                                              bool is_multiple,\n                                              _jwe_int_recipient_t *recipient,\n                                              json_t *obj,\n                                              cjose_err *err)\n{\n\n    if (!json_is_object(obj))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    if (!_cjose_jwe_import_json_part(&recipient->enc_key, true, json_object_get(obj, \"encrypted_key\"), err))\n    {\n        return false;\n    };\n\n    recipient->unprotected = json_incref(json_object_get(obj, \"header\"));\n\n    // it's OK to have empty/null unprotected header\n    if (recipient->unprotected && !json_is_object(recipient->unprotected))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    return _cjose_jwe_validate_alg(protected_header, jwe->shared_hdr, is_multiple, recipient, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_import_json(const char *cser, size_t cser_len, cjose_err *err)\n{\n    cjose_jwe_t *jwe = NULL;\n    json_t *form = NULL;\n    json_t *protected_header = NULL;\n\n    if (NULL == cser)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // allocate and initialize a new JWE object\n    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))\n    {\n        return NULL;\n    }\n\n    form = _cjose_parse_json_object(cser, cser_len, err);\n    if (NULL == form)\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    json_t *recipients = json_object_get(form, \"recipients\");\n    if (NULL != recipients)\n    {\n        if (!json_is_array(recipients))\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            goto _cjose_jwe_import_json_fail;\n        }\n        jwe->to_count = json_array_size(recipients);\n        if (jwe->to_count < 1)\n        {\n            // TODO: is empty recipients array allowed?\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            goto _cjose_jwe_import_json_fail;\n        }\n    }\n    else\n    {\n        jwe->to_count = 1;\n    }\n\n    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t) * jwe->to_count, false, (uint8_t **)&jwe->to, err))\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    if (!_cjose_jwe_import_json_part(&jwe->enc_header, false, json_object_get(form, \"protected\"), err))\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    protected_header = _cjose_parse_json_object((const char *)jwe->enc_header.raw, jwe->enc_header.raw_len, err);\n    if (NULL == protected_header)\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    if (NULL == recipients)\n    {\n\n        if (!_cjose_read_json_recipient(jwe, protected_header, false, jwe->to, form, err))\n        {\n            goto _cjose_jwe_import_json_fail;\n        }\n    }\n    else\n    {\n\n        for (size_t i = 0; i < jwe->to_count; i++)\n        {\n\n            if (!_cjose_read_json_recipient(jwe, protected_header, jwe->to_count > 1, jwe->to + i, json_array_get(recipients, i),\n                                            err))\n            {\n                goto _cjose_jwe_import_json_fail;\n            }\n        }\n    }\n\n    if (!_cjose_jwe_validate_enc(jwe, protected_header, err))\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    if (!_cjose_jwe_import_json_part(&jwe->enc_iv, false, json_object_get(form, \"iv\"), err)\n        || !_cjose_jwe_import_json_part(&jwe->enc_ct, false, json_object_get(form, \"ciphertext\"), err)\n        || !_cjose_jwe_import_json_part(&jwe->enc_auth_tag, false, json_object_get(form, \"tag\"), err))\n    {\n\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    jwe->hdr = json_incref(protected_header);\n\n    json_decref(form);\n    json_decref(protected_header);\n\n    return jwe;\n\n_cjose_jwe_import_json_fail:\n    json_decref(form);\n    json_decref(protected_header);\n    cjose_jwe_release(jwe);\n    return NULL;\n}\n\nuint8_t *cjose_jwe_decrypt_multi(cjose_jwe_t *jwe, cjose_key_locator key_locator, void *data, size_t *content_len, cjose_err *err)\n{\n\n    uint8_t *cek = 0;\n    size_t cek_len = 0;\n    uint8_t *content = NULL;\n\n    if (NULL == jwe || NULL == key_locator || NULL == content_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    for (size_t i = 0; i < jwe->to_count; i++)\n    {\n\n        const cjose_jwk_t *key = key_locator(jwe, (cjose_header_t *)jwe->to[i].unprotected, data);\n        if (NULL == key)\n        {\n            continue;\n        }\n\n        // decrypt JWE content-encryption key from encrypted key\n        if (!jwe->to[i].fns.decrypt_ek(jwe->to + i, jwe, key, err))\n        {\n            // if one key failed to decrypt, fail everything.\n            goto _cjose_jwe_decrypt_multi_fail;\n        }\n\n        if (NULL == cek)\n        {\n            cek_len = jwe->cek_len;\n            cek = cjose_get_alloc()(cek_len);\n            if (!cek)\n            {\n                CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n                return NULL;\n            }\n            memcpy(cek, jwe->cek, cek_len);\n        }\n        else\n        {\n            if (cek_len != jwe->cek_len || memcmp(jwe->cek, cek, cek_len))\n            {\n                CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n                goto _cjose_jwe_decrypt_multi_fail;\n            }\n        }\n    }\n\n    if (NULL == jwe->cek)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_multi_fail;\n    }\n\n    // decrypt JWE encrypted data\n    if (!jwe->fns.decrypt_dat(jwe, err))\n    {\n        goto _cjose_jwe_decrypt_multi_fail;\n    }\n\n    // take the plaintext data from the jwe object\n    content = jwe->dat;\n    *content_len = jwe->dat_len;\n\n    jwe->dat = NULL;\n    jwe->dat_len = 0;\n\n_cjose_jwe_decrypt_multi_fail:\n\n    _cjose_release_cek(&cek, cek_len);\n\n    return content;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nuint8_t *cjose_jwe_decrypt(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, size_t *content_len, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk || NULL == content_len || jwe->to_count > 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // decrypt JWE content-encryption key from encrypted key\n    if (!jwe->to[0].fns.decrypt_ek(jwe->to, jwe, jwk, err))\n    {\n        return NULL;\n    }\n\n    // decrypt JWE encrypted data\n    if (!jwe->fns.decrypt_dat(jwe, err))\n    {\n        return NULL;\n    }\n\n    // take the plaintext data from the jwe object\n    uint8_t *content = jwe->dat;\n    *content_len = jwe->dat_len;\n    jwe->dat = NULL;\n    jwe->dat_len = 0;\n\n    return content;\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_header_t *cjose_jwe_get_protected(cjose_jwe_t *jwe)\n{\n    if (NULL == jwe)\n    {\n        return NULL;\n    }\n    return (cjose_header_t *)jwe->hdr;\n}\n", "/*!\n *\n */\n\n#include \"check_cjose.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <check.h>\n#include <cjose/cjose.h>\n#include <jansson.h>\n#include \"include/jwk_int.h\"\n#include \"include/jwe_int.h\"\n#include <openssl/rsa.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <cjose/error.h>\n\n// a JWK of type RSA\nstatic const char *JWK_RSA\n    = \"{ \\\"kty\\\": \\\"RSA\\\", \"\n      \"\\\"e\\\": \\\"AQAB\\\", \"\n      \"\\\"n\\\": \"\n      \"\\\"wsqJbopx18NQFYLYOq4ZeMSE89yGiEankUpf25yV8QqroKUGrASj_OeqTWUjwPGKTN1vGFFuHYxiJeAUQH2qQPmg9Oqk6-\"\n      \"ATBEKn9COKYniQ5459UxCwmZA2RL6ufhrNyq0JF3GfXkjLDBfhU9zJJEOhknsA0L_c-X4AI3d_NbFdMqxNe1V_\"\n      \"UWAlLcbKdwO6iC9fAvwUmDQxgy6R0DC1CMouQpenMRcALaSHar1cm4K-syoNobv3HEuqgZ3s6-hOOSqauqAO0GUozPpaIA7OeruyRl5sTWT0r-\"\n      \"iz39bchID2bIKtcqLiFcSYPLBcxmsaQCqRlGhmv6stjTCLV1yT9w\\\", \"\n      \"\\\"kid\\\": \\\"ff3c5c96-392e-46ef-a839-6ff16027af78\\\", \"\n      \"\\\"d\\\": \"\n      \"\\\"b9hXfQ8lOtw8mX1dpqPcoElGhbczz_-xq2znCXQpbBPSZBUddZvchRSH5pSSKPEHlgb3CSGIdpLqsBCv0C_XmCM9ViN8uqsYgDO9uCLIDK5plWttbkqA_\"\n      \"EufvW03R9UgIKWmOL3W4g4t-\"\n      \"C2mBb8aByaGGVNjLnlb6i186uBsPGkvaeLHbQcRQKAvhOUTeNiyiiCbUGJwCm4avMiZrsz1r81Y1Z5izo0ERxdZymxM3FRZ9vjTB-\"\n      \"6DtitvTXXnaAm1JTu6TIpj38u2mnNLkGMbflOpgelMNKBZVxSmfobIbFN8CHVc1UqLK2ElsZ9RCQANgkMHlMkOMj-XT0wHa3VBUQ\\\", \"\n      \"\\\"p\\\": \"\n      \"\\\"8mgriveKJAp1S7SHqirQAfZafxVuAK_A2QBYPsAUhikfBOvN0HtZjgurPXSJSdgR8KbWV7ZjdJM_eOivIb_XiuAaUdIOXbLRet7t9a_\"\n      \"NJtmX9iybhoa9VOJFMBq_rbnbbte2kq0-FnXmv3cukbC2LaEw3aEcDgyURLCgWFqt7M0\\\", \"\n      \"\\\"q\\\": \"\n      \"\\\"zbbTv5421GowOfKVEuVoA35CEWgl8mdasnEZac2LWxMwKExikKU5LLacLQlcOt7A6n1ZGUC2wyH8mstO5tV34Eug3fnNrbnxFUEE_ZB_njs_\"\n      \"rtZnwz57AoUXOXVnd194seIZF9PjdzZcuwXwXbrZ2RSVW8if_ZH5OVYEM1EsA9M\\\", \"\n      \"\\\"dp\\\": \"\n      \"\\\"1BaIYmIKn1X3InGlcSFcNRtSOnaJdFhRpotCqkRssKUx2qBlxs7ln_5dqLtZkx5VM_UE_GE7yzc6BZOwBxtOftdsr8HVh-14ksSR9rAGEsO2zVBiEuW4qZf_\"\n      \"aQM-ScWfU--wcczZ0dT-Ou8P87Bk9K9fjcn0PeaLoz3WTPepzNE\\\", \"\n      \"\\\"dq\\\": \"\n      \"\\\"kYw2u4_UmWvcXVOeV_VKJ5aQZkJ6_sxTpodRBMPyQmkMHKcW4eKU1mcJju_\"\n      \"deqWadw5jGPPpm5yTXm5UkAwfOeookoWpGa7CvVf4kPNI6Aphn3GBjunJHNpPuU6w-wvomGsxd-NqQDGNYKHuFFMcyXO_zWXglQdP_1o1tJ1M-BM\\\", \"\n      \"\\\"qi\\\": \"\n      \"\\\"j94Ens784M8zsfwWoJhYq9prcSZOGgNbtFWQZO8HP8pcNM9ls7YA4snTtAS_\"\n      \"B4peWWFAFZ0LSKPCxAvJnrq69ocmEKEk7ss1Jo062f9pLTQ6cnhMjev3IqLocIFt5Vbsg_PWYpFSR7re6FRbF9EYOM7F2-HRv1idxKCWoyQfBqk\\\" }\";\n\n// a JWK of type EC\nstatic const char *JWK_EC = \"{ \\\"kty\\\": \\\"EC\\\", \"\n                            \"\\\"crv\\\": \\\"P-256\\\", \"\n                            \"\\\"x\\\": \\\"DxaAKzwruXJh4IkdieycIJER6w8M1TYMCV3qOa-l9CM\\\", \"\n                            \"\\\"y\\\": \\\"_kRI1aD7-PMFwhUpXmcRzw6hALF_xdKwADuKOM-xsak\\\", \"\n                            \"\\\"d\\\":\\\"SOu5eRc40yn5yVrg069VjWNH4wsoErN8_AxmH4cI88s\\\" }\";\n\n// a JWK of type oct\nstatic const char *JWK_OCT_16 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"3921VrO5TrLvPQ-NFLlghQ\\\"}\";\nstatic const char *JWK_OCT_24 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"dC4ZvqLVuS-esAz331EEd8HiwCBM1dih\\\"}\";\nstatic const char *JWK_OCT_32 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"ZMpktzGq1g6_r4fKVdnx9OaYr4HjxPjIs7l7SwAsgsg\\\"}\";\nstatic const char *JWK_OCT_48 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"2xAZsjSXMTg6XtY5AESrM3slgXzUaXHFEaGrALThNPyC_9JeO8Hg4PZpLDdhDIlk\\\"}\";\nstatic const char *JWK_OCT_64 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"Jc2RE4DiwDGZsDTVt0Am3ZI_6IhSuoeQdRaHs_XKl_WnmFkHuvGr8px7h_2rme4rpYGHx93I7jl4p9swfJwlzQ\\\"}\";\n\n// a JWE encrypted with the above JWK_RSA key (using node-jose)\nstatic const char *JWE_RSA\n    = \"eyJraWQiOiJmZjNjNWM5Ni0zOTJlLTQ2ZWYtYTgzOS02ZmYxNjAyN2FmNzgiLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n      \"FGQ9IUhjmSJr4dAntH0DP-dAJiZPfKCRhg-SjUywNFqmG-ruhRvio1K7qy2Z0joatZxdJmkOInlsGvGIZeyapTtOndshCsfTlazHH-4fqFyepIm6o-gZ8gfntDG_\"\n      \"sa9hi9uw1KxeJfNmaL94JMjq-QVmocdCeruIE7_bL90MNflQ8qf5vhuh_hF_Ea_vUnHlIbbQsF1ZF4rRsEGBR7CxTBxusMgErct0kp3La6qQbnX8fDJMqL_\"\n      \"aeot4xZRm3zobIYqKePaGBaSJ7wooWslM1w57IrYXN0UVODRAFO6L5ldF_PHpWbBnFx4k_-FWCOVb-iVpQmLtBkniKG6iItXVUQ.ebcXmjWfUMq-brIT.\"\n      \"BPt7F9tcIwQpoAjlyguagOGftJE392-j3kSnP5I6nB-WhWKfpPAeChIW23oWTUHlUbadOeBaiI6r-2TLTZzf3jFKc8Wwr-F0q_iEUQjmg3om-PKR_Pgl_\"\n      \"ncDTXjkxSQjbHOAV1JByh61G-WFuEC1UItyib0AOq9R.Mlo2kQF8Zn2hwwdDl_4Lnw\";\n\n// the plaintext payload of the above JWE object(s)\nstatic const char *PLAINTEXT = \"If you reveal your secrets to the wind, you should not blame the \"\n                               \"wind for revealing them to the trees. \u2014 Kahlil Gibran\";\n\nstatic const cjose_jwk_t *cjose_multi_key_locator(cjose_jwe_t *jwe, cjose_header_t *hdr, void *data)\n{\n    const char *kid = cjose_header_get(hdr, CJOSE_HDR_KID, NULL);\n    if (NULL != kid)\n    {\n\n        ;\n        for (cjose_jwe_recipient_t *recs = data; recs->jwk; recs++)\n        {\n            const char *t_kid = cjose_jwk_get_kid(recs->jwk, NULL);\n            if (NULL != t_kid && !strcmp(t_kid, kid))\n            {\n                return recs->jwk;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic const cjose_jwk_t *cjose_multi_key_locator_none(cjose_jwe_t *jwe, cjose_header_t *hdr, void *data) { return NULL; }\n\nSTART_TEST(test_cjose_jwe_node_jose_encrypt_self_decrypt)\n{\n    cjose_err err;\n\n    // import the JWK\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_RSA, strlen(JWK_RSA), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the JWE\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA, strlen(JWE_RSA), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain2_len = 0;\n    uint8_t *plain2 = cjose_jwe_decrypt(jwe, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_get_plaintext failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain2 == PLAINTEXT\n    ck_assert_msg(plain2_len == strlen(PLAINTEXT),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(PLAINTEXT), plain2_len);\n    ck_assert_msg(strncmp(PLAINTEXT, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_jwk_release(jwk);\n    cjose_jwe_release(jwe);\n}\nEND_TEST\n\nstatic void _self_encrypt_self_decrypt_with_key(const char *alg, const char *enc, const char *key, const char *plain1)\n{\n    cjose_err err;\n\n    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE\n    cjose_header_t *hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, alg, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, enc, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // create the JWE\n    size_t plain1_len = strlen(plain1);\n    cjose_jwe_t *jwe1 = cjose_jwe_encrypt(jwk, hdr, plain1, plain1_len, &err);\n    ck_assert_msg(NULL != jwe1, \"cjose_jwe_encrypt failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n    // ck_assert(hdr == cjose_jwe_get_protected(jwe1));\n\n    // get the compact serialization of JWE\n    char *compact = cjose_jwe_export(jwe1, &err);\n    ck_assert_msg(NULL != compact, \"cjose_jwe_export failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n\n    // deserialize the compact representation to a new JWE\n    cjose_jwe_t *jwe2 = cjose_jwe_import(compact, strlen(compact), &err);\n    ck_assert_msg(NULL != jwe2,\n                  \"cjose_jwe_import failed for algo %s, method %s: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  alg, enc, err.message, err.file, err.function, err.line);\n\n    // get the decrypted plaintext\n    uint8_t *plain2 = NULL;\n    size_t plain2_len = 0;\n    plain2 = cjose_jwe_decrypt(jwe2, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_decrypt failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain2 == plain1\n    ck_assert(json_equal((json_t *)cjose_jwe_get_protected(jwe1), (json_t *)cjose_jwe_get_protected(jwe2)));\n    ck_assert_msg(plain2_len == strlen(plain1),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(plain1), plain2_len);\n    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_header_release(hdr);\n    cjose_jwe_release(jwe1);\n    cjose_jwe_release(jwe2);\n    cjose_jwk_release(jwk);\n    cjose_get_dealloc()(compact);\n}\n\nstatic void _self_encrypt_self_decrypt(const char *plain1)\n{\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A128GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A128GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A192GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A192GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192GCM, JWK_OCT_24, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A256GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A256GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256GCM, JWK_OCT_32, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_32, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_48, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_64, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A192KW, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_24, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A256KW, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_32, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A128GCM, JWK_EC, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A192GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A192GCM, JWK_EC, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A256GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A256GCM, JWK_EC, plain1);\n}\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt)\n{\n    _self_encrypt_self_decrypt(\"Sed ut perspiciatis unde omnis iste natus error sit voluptatem \"\n                               \"doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo \"\n                               \"veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo \"\n                               \"ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed \"\n                               \"consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \"\n                               \"porro quisquam est, qui dolorem ipsum quia dolor sit amet, \"\n                               \"adipisci velit, sed quia non numquam eius modi tempora incidunt ut \"\n                               \"dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, \"\n                               \"nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut \"\n                               \"ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in \"\n                               \"voluptate velit esse quam nihil molestiae consequatur, vel illum qui \"\n                               \"eum fugiat quo voluptas nulla pariatur?\");\n}\nEND_TEST\n\nstatic void\n_self_encrypt_self_decrypt_with_key_iv(const char *alg, const char *enc, const char *key, size_t iv_len, const char *plain1)\n{\n    cjose_err err;\n\n    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE\n    cjose_header_t *hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, alg, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, enc, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // generate a random IV\n    uint8_t *iv = (uint8_t *)malloc(iv_len);\n    ck_assert_msg(RAND_bytes(iv, iv_len) == 1, \"RAND_bytes failed\");\n\n    // create the JWE\n    size_t plain1_len = strlen(plain1);\n    cjose_jwe_t *jwe1 = cjose_jwe_encrypt_iv(jwk, hdr, iv, iv_len, plain1, plain1_len, &err);\n    ck_assert_msg(NULL != jwe1, \"cjose_jwe_encrypt failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n    // ck_assert(hdr == cjose_jwe_get_protected(jwe1));\n\n    // get the compact serialization of JWE\n    char *compact = cjose_jwe_export(jwe1, &err);\n    ck_assert_msg(NULL != compact, \"cjose_jwe_export failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n\n    // deserialize the compact representation to a new JWE\n    cjose_jwe_t *jwe2 = cjose_jwe_import(compact, strlen(compact), &err);\n    ck_assert_msg(NULL != jwe2,\n                  \"cjose_jwe_import failed for algo %s, method %s: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  alg, enc, err.message, err.file, err.function, err.line);\n\n    // get the decrypted plaintext\n    uint8_t *plain2 = NULL;\n    size_t plain2_len = 0;\n    plain2 = cjose_jwe_decrypt(jwe2, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_decrypt failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain2 == plain1\n    ck_assert(json_equal((json_t *)cjose_jwe_get_protected(jwe1), (json_t *)cjose_jwe_get_protected(jwe2)));\n    ck_assert_msg(plain2_len == strlen(plain1),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(plain1), plain2_len);\n    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_header_release(hdr);\n    free(iv);\n    cjose_jwe_release(jwe1);\n    cjose_jwe_release(jwe2);\n    cjose_jwk_release(jwk);\n    cjose_get_dealloc()(compact);\n}\n\nstatic void _self_encrypt_self_decrypt_iv(const char *plain1)\n{\n    // Tests for when #85 (A128GCM and A192GCM support) is merged\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A128GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A128GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A192GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A192GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192GCM, JWK_OCT_24, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A256GCM, JWK_RSA, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A256GCM, JWK_RSA, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256GCM, JWK_OCT_32, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_32, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_48, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_64, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_16, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A192KW, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_24, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A256KW, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_32, 16, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A128GCM, JWK_EC, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A192GCM, JWK_OCT_16, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A192GCM, JWK_EC, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A256GCM, JWK_OCT_16, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A256GCM, JWK_EC, 12, plain1);\n}\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_iv)\n{\n    _self_encrypt_self_decrypt_iv(\"Sed ut perspiciatis unde omnis iste natus error sit voluptatem \"\n                                  \"doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo \"\n                                  \"veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo \"\n                                  \"ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed \"\n                                  \"consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \"\n                                  \"porro quisquam est, qui dolorem ipsum quia dolor sit amet, \"\n                                  \"adipisci velit, sed quia non numquam eius modi tempora incidunt ut \"\n                                  \"dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, \"\n                                  \"nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut \"\n                                  \"ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in \"\n                                  \"voluptate velit esse quam nihil molestiae consequatur, vel illum qui \"\n                                  \"eum fugiat quo voluptas nulla pariatur?\");\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_short) { _self_encrypt_self_decrypt(\"Setec Astronomy\"); }\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_empty) { _self_encrypt_self_decrypt(\"\"); }\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_large)\n{\n    // encrypt and decrypt a 4MB buffer of z's\n    size_t len = 1024 * 4096;\n    char *plain = (char *)malloc(len);\n    memset(plain, 'z', len);\n    plain[len - 1] = 0;\n    // _self_encrypt_self_decrypt(plain);\n    free(plain);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_many)\n{\n    // encrypt and decrypt a whole lot of randomly sized payloads\n    for (int i = 0; i < 100; ++i)\n    {\n        size_t len = random() % 1024;\n        char *plain = (char *)malloc(len);\n        ck_assert_msg(RAND_bytes(plain, len) == 1, \"RAND_bytes failed\");\n        plain[len - 1] = 0;\n        _self_encrypt_self_decrypt(plain);\n        free(plain);\n    }\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_encrypt_with_bad_header)\n{\n    cjose_header_t *hdr = NULL;\n    cjose_jwe_t *jwe = NULL;\n    cjose_err err;\n\n    static const char *plain = \"The mind is everything. What you think you become.\";\n    size_t plain_len = strlen(plain);\n\n    static const char *JWK\n        = \"{ \\\"kty\\\": \\\"RSA\\\", \"\n          \"\\\"kid\\\": \\\"9ebf9edb-3a24-48b4-b2cb-21f0cf747ea7\\\", \"\n          \"\\\"e\\\": \\\"AQAB\\\", \"\n          \"\\\"n\\\": \"\n          \"\\\"0a5nKJLjaB1xdebYWfhvlhYhgfzkw49HAUIjyvb6fNPKhwlBQMoAS5jM3kI17_OMGrHxL7ZP00OE-24__\"\n          \"VWDCAhOQsSvlgCvw2XOOCtSWWLpb03dTrCMFeemqS4S9jrKd3NbUk3UJ2dVb_EIbQEC_BVjZStr_\"\n          \"HcCrKsj4AluaQUn09H7TuK0yZFBzZMhJ1J8Yi3nAPkxzdGah0XuWhLObMAvANSVmHzRXwnTDw9Dh_\"\n          \"bJ4G1xd1DE7W94uoUlcSDx59aSdzTpQzJh1l3lXc6JRUrXTESYgHpMv0O1n0gbIxX8X1ityBlMiccDjfZIKLnwz6hQObvRtRIpxEdq4SYS-w\\\" }\";\n\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK, strlen(JWK), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE with bad alg\n    hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, \"Cayley-Purser\", &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // create a JWE\n    jwe = cjose_jwe_encrypt(jwk, hdr, plain, plain_len, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad header\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    // set header for JWE with bad enc\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, \"Twofish\", &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // create a JWE\n    jwe = cjose_jwe_encrypt(jwk, hdr, plain, plain_len, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad header\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    cjose_header_release(hdr);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_encrypt_with_bad_key)\n{\n    cjose_header_t *hdr = NULL;\n    cjose_jwe_t *jwe = NULL;\n    cjose_err err;\n\n    static const char *plain = \"The mind is everything. What you think you become.\";\n    size_t plain_len = strlen(plain);\n\n    // some bad keys to test with\n    static const char *JWK_BAD[] = {\n\n        // importing private key with a missing public part 'e' fails at cjose_jwk_import\n\n        // currently unsupported key type (EC)\n        \"{ \\\"kty\\\": \\\"EC\\\", \\\"crv\\\": \\\"P-256\\\", \"\n        \"\\\"x\\\": \\\"VoFkf6Wk5kDQ1ob6csBmiMPHU8jALwdtaap35Fsj20M\\\", \"\n        \"\\\"y\\\": \\\"XymwN6u2PmsKbIPy5iij6qZ-mIyej5dvZWB_75lnRgQ\\\", \"\n        \"\\\"kid\\\": \\\"4E34BAFD-E5D9-479C-964D-009C419C38DB\\\" }\",\n\n        NULL\n    };\n\n    // set header for JWE\n    hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // attempt encryption with each bad key\n    for (int i = 0; NULL != JWK_BAD[i]; ++i)\n    {\n        cjose_jwk_t *jwk = cjose_jwk_import(JWK_BAD[i], strlen(JWK_BAD[i]), &err);\n        ck_assert_msg(NULL != jwk,\n                      \"cjose_jwk_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        jwe = cjose_jwe_encrypt(jwk, hdr, plain, plain_len, &err);\n        ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad key\");\n        ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n        cjose_jwk_release(jwk);\n    }\n\n    jwe = cjose_jwe_encrypt(NULL, hdr, plain, plain_len, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad key\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    cjose_header_release(hdr);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_encrypt_with_bad_content)\n{\n    cjose_header_t *hdr = NULL;\n    cjose_jwe_t *jwe = NULL;\n    cjose_err err;\n\n    static const char *JWK\n        = \"{ \\\"kty\\\": \\\"RSA\\\", \"\n          \"\\\"kid\\\": \\\"9ebf9edb-3a24-48b4-b2cb-21f0cf747ea7\\\", \"\n          \"\\\"e\\\": \\\"AQAB\\\", \"\n          \"\\\"n\\\": \"\n          \"\\\"0a5nKJLjaB1xdebYWfhvlhYhgfzkw49HAUIjyvb6fNPKhwlBQMoAS5jM3kI17_OMGrHxL7ZP00OE-24__\"\n          \"VWDCAhOQsSvlgCvw2XOOCtSWWLpb03dTrCMFeemqS4S9jrKd3NbUk3UJ2dVb_EIbQEC_BVjZStr_\"\n          \"HcCrKsj4AluaQUn09H7TuK0yZFBzZMhJ1J8Yi3nAPkxzdGah0XuWhLObMAvANSVmHzRXwnTDw9Dh_\"\n          \"bJ4G1xd1DE7W94uoUlcSDx59aSdzTpQzJh1l3lXc6JRUrXTESYgHpMv0O1n0gbIxX8X1ityBlMiccDjfZIKLnwz6hQObvRtRIpxEdq4SYS-w\\\" }\";\n\n    // import the key\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK, strlen(JWK), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE\n    hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    jwe = cjose_jwe_encrypt(jwk, hdr, NULL, 1024, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with NULL plaintext\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    jwe = cjose_jwe_encrypt(jwk, hdr, NULL, 0, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with NULL plaintext\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    cjose_jwk_release(jwk);\n    cjose_header_release(hdr);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_import_export_compare)\n{\n    cjose_err err;\n\n    // import the common key\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_RSA, strlen(JWK_RSA), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the jwe created with the common key\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA, strlen(JWE_RSA), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // re-export the jwe object\n    char *cser = cjose_jwe_export(jwe, &err);\n    ck_assert_msg(NULL != cser,\n                  \"re-export of imported JWE failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // compare the re-export to the original serialization\n    ck_assert_msg(strncmp(JWE_RSA, cser, strlen(JWE_RSA)) == 0, \"export of imported JWE doesn't match original\");\n\n    cjose_jwk_release(jwk);\n    cjose_jwe_release(jwe);\n    cjose_get_dealloc()(cser);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_import_invalid_serialization)\n{\n    cjose_err err;\n\n    static const char *JWE_BAD[]\n        = { \"eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk.jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg.x\",\n            \"eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk.jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg.\",\n            \"eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk..jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg\",\n            \".eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk.jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg\",\n            \"AAAA.BBBB.CCCC.DDDD\",\n            \"AAAA.BBBB.CCCC\",\n            \"AAAA.BBBB\",\n            \"AAAA\",\n            \"\",\n            \"....\",\n            \"this test is dedicated to swhitsel\",\n            NULL };\n\n    for (int i = 0; NULL != JWE_BAD[i]; ++i)\n    {\n        cjose_jwe_t *jwe = cjose_jwe_import(JWE_BAD[i], strlen(JWE_BAD[i]), &err);\n        ck_assert_msg(NULL == jwe, \"cjose_jwe_import of bad JWE succeeded (%d)\", i);\n        ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_import returned wrong err.code\");\n    }\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_bad_params)\n{\n    cjose_err err;\n    size_t len = 0;\n\n    // some bad keys to test with\n    static const char *JWK_BAD[] = {\n\n        // missing private part 'd' needed for encryption\n        \"{ \\\"kty\\\": \\\"RSA\\\", \"\n        \"\\\"e\\\": \\\"AQAB\\\", \"\n        \"\\\"n\\\": \"\n        \"\\\"0a5nKJLjaB1xdebYWfhvlhYhgfzkw49HAUIjyvb6fNPKhwlBQMoAS5jM3kI17_OMGrHxL7ZP00OE-24__\"\n        \"VWDCAhOQsSvlgCvw2XOOCtSWWLpb03dTrCMFeemqS4S9jrKd3NbUk3UJ2dVb_EIbQEC_BVjZStr_\"\n        \"HcCrKsj4AluaQUn09H7TuK0yZFBzZMhJ1J8Yi3nAPkxzdGah0XuWhLObMAvANSVmHzRXwnTDw9Dh_\"\n        \"bJ4G1xd1DE7W94uoUlcSDx59aSdzTpQzJh1l3lXc6JRUrXTESYgHpMv0O1n0gbIxX8X1ityBlMiccDjfZIKLnwz6hQObvRtRIpxEdq4SYS-w\\\", \"\n        \"\\\"kid\\\": \\\"9ebf9edb-3a24-48b4-b2cb-21f0cf747ea7\\\" }\",\n\n        // currently unsupported key type (EC)\n        \"{ \\\"kty\\\": \\\"EC\\\", \\\"crv\\\": \\\"P-256\\\", \"\n        \"\\\"x\\\": \\\"VoFkf6Wk5kDQ1ob6csBmiMPHU8jALwdtaap35Fsj20M\\\", \"\n        \"\\\"y\\\": \\\"XymwN6u2PmsKbIPy5iij6qZ-mIyej5dvZWB_75lnRgQ\\\", \"\n        \"\\\"kid\\\": \\\"4E34BAFD-E5D9-479C-964D-009C419C38DB\\\" }\",\n\n        NULL\n    };\n\n    // import the common key\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_RSA, strlen(JWK_RSA), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the jwe created with the common key\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA, strlen(JWE_RSA), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // try to decrypt a NULL jwe\n    ck_assert_msg(!cjose_jwe_decrypt(NULL, jwk, &len, &err), \"cjose_jwe_decrypt succeeded with NULL jwe\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_decrypt returned wrong err.code\");\n\n    // try to decrypt with a NULL jwk\n    ck_assert_msg(!cjose_jwe_decrypt(jwe, NULL, &len, &err), \"cjose_jwe_decrypt succeeded with NULL jwk\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_decrypt returned wrong err.code\");\n\n    // try to decrypt with bad/wrong/unsupported keys\n    for (int i = 0; NULL != JWK_BAD[i]; ++i)\n    {\n        cjose_jwk_t *jwk_bad = cjose_jwk_import(JWK_BAD[i], strlen(JWK_BAD[i]), &err);\n        ck_assert_msg(NULL != jwk_bad, \"cjose_jwk_import failed\");\n\n        ck_assert_msg(!cjose_jwe_decrypt(jwe, NULL, &len, &err), \"cjose_jwe_decrypt succeeded with bad jwk\");\n        ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_decrypt returned wrong err.code\");\n\n        cjose_jwk_release(jwk_bad);\n    }\n\n    cjose_jwe_release(jwe);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_aes)\n{\n    // https://tools.ietf.org/html/rfc7516#appendix-A.3\n    // JWE Using AES Key Wrap and AES_128_CBC_HMAC_SHA_256\n    static const char *JWK_S = \"{\\\"kty\\\":\\\"oct\\\", \\\"k\\\":\\\"GawgguFyGrWKav7AX4VKUg\\\"}\";\n    static const char *JWE_S = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                               \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                               \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                               \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                               \"U0m_YmjN04DJvceFICbCVQ\";\n    static const char *PLAINTEXT_S = \"Live long and prosper.\";\n\n    cjose_err err;\n\n    // import the JWK\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_S, strlen(JWK_S), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the JWE\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_S, strlen(JWE_S), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain1_len = 0;\n    uint8_t *plain1 = cjose_jwe_decrypt(jwe, jwk, &plain1_len, &err);\n    ck_assert_msg(NULL != plain1,\n                  \"cjose_jwe_get_plaintext failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain == PLAINTEXT_S\n    ck_assert_msg(plain1_len == strlen(PLAINTEXT_S),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(PLAINTEXT_S), plain1_len);\n    ck_assert_msg(strncmp(PLAINTEXT_S, plain1, plain1_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain1);\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_AT = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                         \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                         \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                         \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                         \"U0m_YmjN04DJvceFICbCVq\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_AT, strlen(JWE_TAMPERED_AT), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain2_len = 0;\n    uint8_t *plain2 = cjose_jwe_decrypt(jwe, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL == plain2, \"cjose_jwe_get_plaintext succeeded for tampered authentication tag\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_CIPHERTEXT = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                                 \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                                 \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                                 \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGy.\"\n                                                 \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_CIPHERTEXT, strlen(JWE_TAMPERED_CIPHERTEXT), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain3_len = 0;\n    uint8_t *plain3 = cjose_jwe_decrypt(jwe, jwk, &plain3_len, &err);\n    ck_assert_msg(NULL == plain3, \"cjose_jwe_get_plaintext succeeded for tampered ciphertext\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_IV = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                         \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                         \"AxY8DCtDaGlsbGljb3RoZq.\"\n                                         \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                         \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_IV, strlen(JWE_TAMPERED_IV), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain4_len = 0;\n    uint8_t *plain4 = cjose_jwe_decrypt(jwe, jwk, &plain4_len, &err);\n    ck_assert_msg(NULL == plain4, \"cjose_jwe_get_plaintext succeeded for tampered IV\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_CEK = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                          \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOq.\"\n                                          \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                          \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                          \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_CEK, strlen(JWE_TAMPERED_CEK), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain5_len = 0;\n    uint8_t *plain5 = cjose_jwe_decrypt(jwe, jwk, &plain5_len, &err);\n    ck_assert_msg(NULL == plain5, \"cjose_jwe_get_plaintext succeeded for tampered content encryption key\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_HDR = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2IiB9.\"\n                                          \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                          \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                          \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                          \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_HDR, strlen(JWE_TAMPERED_HDR), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain6_len = 0;\n    uint8_t *plain6 = cjose_jwe_decrypt(jwe, jwk, &plain6_len, &err);\n    ck_assert_msg(NULL == plain6, \"cjose_jwe_get_plaintext succeeded for tampered header\");\n\n    cjose_jwe_release(jwe);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_rsa)\n{\n    struct cjose_jwe_decrypt_rsa\n    {\n        const char *jwe;\n        const char *plaintext;\n        const char *jwk;\n    };\n\n    static const struct cjose_jwe_decrypt_rsa JWE_RSA[] = {\n\n        // https://tools.ietf.org/html/rfc7516#appendix-A.1\n        // JWE using RSAES-OAEP and AES GCM\n        { \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n          \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\"\n          \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\"\n          \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\"\n          \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\"\n          \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\"\n          \"6UklfCpIMfIjf7iGdXKHzg.\"\n          \"48V1_ALb6US04U3b.\"\n          \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\"\n          \"SdiwkIr3ajwQzaBtQD_A.\"\n          \"XFBoMYUZodetZdvTiFvSkQ\",\n\n          \"The true sign of intelligence is not knowledge but imagination.\",\n\n          \"{\\\"kty\\\":\\\"RSA\\\",\"\n          \"\\\"n\\\":\\\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\"\n          \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\"\n          \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\"\n          \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\"\n          \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\"\n          \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\\\",\"\n          \"\\\"e\\\":\\\"AQAB\\\",\"\n          \"\\\"d\\\":\\\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\"\n          \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\"\n          \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\"\n          \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\"\n          \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\"\n          \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\\\",\"\n          \"\\\"p\\\":\\\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\"\n          \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\"\n          \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\\\",\"\n          \"\\\"q\\\":\\\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\"\n          \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\"\n          \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\\\",\"\n          \"\\\"dp\\\":\\\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\"\n          \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\"\n          \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\\\",\"\n          \"\\\"dq\\\":\\\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\"\n          \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\"\n          \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\\\",\"\n          \"\\\"qi\\\":\\\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\"\n          \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\"\n          \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\\\" }\" },\n\n        // https://tools.ietf.org/html/rfc7516#appendix-A.2\n        // JWE using RSAES-PKCS1-v1_5 and AES_128_CBC_HMAC_SHA_256\n        { \"eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n          \"UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm\"\n          \"1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc\"\n          \"HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF\"\n          \"NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8\"\n          \"rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv\"\n          \"-B3oWh2TbqmScqXMR4gp_A.\"\n          \"AxY8DCtDaGlsbGljb3RoZQ.\"\n          \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n          \"9hH0vgRfYgPnAHOd8stkvw\",\n\n          \"Live long and prosper.\",\n\n          \"{\\\"kty\\\":\\\"RSA\\\",\"\n          \"\\\"n\\\":\\\"sXchDaQebHnPiGvyDOAT4saGEUetSyo9MKLOoWFsueri23bOdgWp4Dy1Wl\"\n          \"UzewbgBHod5pcM9H95GQRV3JDXboIRROSBigeC5yjU1hGzHHyXss8UDpre\"\n          \"cbAYxknTcQkhslANGRUZmdTOQ5qTRsLAt6BTYuyvVRdhS8exSZEy_c4gs_\"\n          \"7svlJJQ4H9_NxsiIoLwAEk7-Q3UXERGYw_75IDrGA84-lA_-Ct4eTlXHBI\"\n          \"Y2EaV7t7LjJaynVJCpkv4LKjTTAumiGUIuQhrNhZLuF_RJLqHpM2kgWFLU\"\n          \"7-VTdL1VbC2tejvcI2BlMkEpk1BzBZI0KQB0GaDWFLN-aEAw3vRw\\\",\"\n          \"\\\"e\\\":\\\"AQAB\\\",\"\n          \"\\\"d\\\":\\\"VFCWOqXr8nvZNyaaJLXdnNPXZKRaWCjkU5Q2egQQpTBMwhprMzWzpR8Sxq\"\n          \"1OPThh_J6MUD8Z35wky9b8eEO0pwNS8xlh1lOFRRBoNqDIKVOku0aZb-ry\"\n          \"nq8cxjDTLZQ6Fz7jSjR1Klop-YKaUHc9GsEofQqYruPhzSA-QgajZGPbE_\"\n          \"0ZaVDJHfyd7UUBUKunFMScbflYAAOYJqVIVwaYR5zWEEceUjNnTNo_CVSj\"\n          \"-VvXLO5VZfCUAVLgW4dpf1SrtZjSt34YLsRarSb127reG_DUwg9Ch-Kyvj\"\n          \"T1SkHgUWRVGcyly7uvVGRSDwsXypdrNinPA4jlhoNdizK2zF2CWQ\\\",\"\n          \"\\\"p\\\":\\\"9gY2w6I6S6L0juEKsbeDAwpd9WMfgqFoeA9vEyEUuk4kLwBKcoe1x4HG68\"\n          \"ik918hdDSE9vDQSccA3xXHOAFOPJ8R9EeIAbTi1VwBYnbTp87X-xcPWlEP\"\n          \"krdoUKW60tgs1aNd_Nnc9LEVVPMS390zbFxt8TN_biaBgelNgbC95sM\\\",\"\n          \"\\\"q\\\":\\\"uKlCKvKv_ZJMVcdIs5vVSU_6cPtYI1ljWytExV_skstvRSNi9r66jdd9-y\"\n          \"BhVfuG4shsp2j7rGnIio901RBeHo6TPKWVVykPu1iYhQXw1jIABfw-MVsN\"\n          \"-3bQ76WLdt2SDxsHs7q7zPyUyHXmps7ycZ5c72wGkUwNOjYelmkiNS0\\\",\"\n          \"\\\"dp\\\":\\\"w0kZbV63cVRvVX6yk3C8cMxo2qCM4Y8nsq1lmMSYhG4EcL6FWbX5h9yuv\"\n          \"ngs4iLEFk6eALoUS4vIWEwcL4txw9LsWH_zKI-hwoReoP77cOdSL4AVcra\"\n          \"Hawlkpyd2TWjE5evgbhWtOxnZee3cXJBkAi64Ik6jZxbvk-RR3pEhnCs\\\",\"\n          \"\\\"dq\\\":\\\"o_8V14SezckO6CNLKs_btPdFiO9_kC1DsuUTd2LAfIIVeMZ7jn1Gus_Ff\"\n          \"7B7IVx3p5KuBGOVF8L-qifLb6nQnLysgHDh132NDioZkhH7mI7hPG-PYE_\"\n          \"odApKdnqECHWw0J-F0JWnUd6D2B_1TvF9mXA2Qx-iGYn8OVV1Bsmp6qU\\\",\"\n          \"\\\"qi\\\":\\\"eNho5yRBEBxhGBtQRww9QirZsB66TrfFReG_CcteI1aCneT0ELGhYlRlC\"\n          \"tUkTRclIfuEPmNsNDPbLoLqqCVznFbvdB7x-Tl-m0l_eFTj2KiqwGqE9PZ\"\n          \"B9nNTwMVvH3VRRSLWACvPnSiwP8N5Usy-WRXS-V7TbpxIhvepTfE0NNo\\\" }\" },\n\n        { NULL, NULL, NULL }\n    };\n\n    for (int i = 0; NULL != JWE_RSA[i].jwe; ++i)\n    {\n        cjose_err err;\n\n        // import the JWK\n        cjose_jwk_t *jwk = cjose_jwk_import(JWE_RSA[i].jwk, strlen(JWE_RSA[i].jwk), &err);\n        ck_assert_msg(NULL != jwk,\n                      \"cjose_jwk_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        // import the JWE\n        cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA[i].jwe, strlen(JWE_RSA[i].jwe), &err);\n        ck_assert_msg(NULL != jwe,\n                      \"cjose_jwe_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        // decrypt the imported JWE\n        size_t plain1_len = 0;\n        uint8_t *plain1 = cjose_jwe_decrypt(jwe, jwk, &plain1_len, &err);\n        ck_assert_msg(NULL != plain1,\n                      \"cjose_jwe_get_plaintext failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        // confirm plain == PLAINTEXT_S\n        ck_assert_msg(plain1_len == strlen(JWE_RSA[i].plaintext),\n                      \"length of decrypted plaintext does not match length of original, \"\n                      \"expected: %lu, found: %lu\",\n                      strlen(JWE_RSA[i].plaintext), plain1_len);\n        ck_assert_msg(strncmp(JWE_RSA[i].plaintext, plain1, plain1_len) == 0,\n                      \"decrypted plaintext does not match encrypted plaintext\");\n\n        cjose_get_dealloc()(plain1);\n        cjose_jwe_release(jwe);\n        cjose_jwk_release(jwk);\n    }\n}\nEND_TEST\n\nstatic void _cjose_test_json_serial(const char *json, const char *match_json, cjose_jwe_recipient_t *rec)\n{\n\n    cjose_jwe_t *jwe;\n    cjose_err err;\n\n    jwe = cjose_jwe_import_json(json, strlen(json), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to import multi-recipient json: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    size_t decoded_len;\n    char *decoded = cjose_jwe_decrypt_multi(jwe, cjose_multi_key_locator, rec, &decoded_len, &err);\n    ck_assert_msg(NULL != decoded,\n                  \"failed to decrypt for multiple recipients: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg(memcmp(decoded, PLAINTEXT, decoded_len) == 0 && decoded_len == strlen(PLAINTEXT) + 1,\n                  \"decrypted plaintext does not match\");\n    cjose_get_dealloc()(decoded);\n\n    decoded = cjose_jwe_export_json(jwe, &err);\n    ck_assert_msg(NULL != decoded,\n                  \"failed to serialize JWE into json: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg(strcmp(decoded, match_json) == 0, \"serialized json doesn't match expectation\");\n\n    cjose_get_dealloc()(decoded);\n\n    cjose_jwe_release(jwe);\n}\n\nstatic void _cjose_test_empty_headers(cjose_jwk_t *key)\n{\n\n    cjose_jwe_t *jwe;\n    cjose_err err;\n    cjose_header_t *hdr;\n\n    // regression test - if we created json without unprotected headers, we must\n    // be able to read it back.\n\n    hdr = cjose_header_new(&err);\n    cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err);\n    cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256CBC_HS512, &err);\n\n    cjose_jwe_recipient_t rec = { .jwk = (const cjose_jwk_t *)key, .unprotected_header = 0 };\n\n    jwe = cjose_jwe_encrypt_multi(&rec, 1, hdr, 0, (uint8_t *)\"\", 1, &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to encrypt test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    char *json = cjose_jwe_export_json(jwe, &err);\n    ck_assert_msg(NULL != json,\n                  \"failed to serialize test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    cjose_jwe_release(jwe);\n    cjose_header_release(hdr);\n\n    // import the json back\n\n    jwe = cjose_jwe_import_json(json, strlen(json), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to import test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    size_t len;\n    char *test = (char *)cjose_jwe_decrypt(jwe, key, &len, &err);\n    ck_assert_msg(NULL != test,\n                  \"failed to decrypt test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg((len == 1) && (*test == 0), \"Decrypted data does not match original\");\n\n    free(test);\n    free(json);\n    cjose_jwe_release(jwe);\n}\n\nSTART_TEST(test_cjose_jwe_multiple_recipients)\n{\n\n    char *rsa[] = { \"{\\\"kty\\\":\\\"RSA\\\",\\\"e\\\":\\\"AQAB\\\",\\\"n\\\":\\\"pXldOFJS1PKXlkkkcCKtBt6efl84jkZinEzVF1HcksvO_b\"\n                    \"QUFJbUPcZwyzKk8fYnGbu0LwnY3hhCSDk-Ki8S2h_8VOiR7AY2ptI_TjeGp0DDqSnmJEdDrwIbw0yGTgOHZ63xms0aE4\"\n                    \"fv9tdrw5U4v_A3AfOwUtCyxuyZP_7WlNj0sMsWwiyp0BGvCUB4xuhVtsEsbSWvSAO8CYHEy3fVGZ6bLXh7DbF7WlbfZ9K\"\n                    \"bZCiLhP4RAmNtBQQ8jYpzTedr6qGvAz8TNl7mSfG7aQk465xCHOCrk0TLrHMDI1G4ZaFAkhXeg-KsoC8C1Mktaz3zLZwam_\"\n                    \"ZsMHyl5UNxl4MzZQ\\\",\\\"d\\\":\\\"Zgss2JGz8QxVPOGILfrEVysr9GSGPP7cyuR6uHHMI166HCxUAcptwlbAsh5eJ7STskPVv\"\n                    \"vhEm9m77kwWsO7sokT9V-NAMZw3UbLwRSzqxfOjdYuYGCE2dRNIyaxEWpHEi8Rx7PO0s_ytl7yLAUbhg0QAuBxuTPPUe-XmL\"\n                    \"9fYvlr6mxbA0Pxtr_ZcisDOL5gUWhpb-rWzIUH_G9519J_Th7z9_C5v3q88UiA7VomBiMg8TKz23GKsG4TPmGnAW7ctHKP\"\n                    \"2b3xl6b868IuPOr1YqqlnOCh6T9-mKuOlCMcU89UR5TTgRn0HoRQBumbw3qYGn8YbxcW38jbR9imKTcbrPQ\\\",\\\"\"\n                    \"p\\\":\\\"1v7ar4cL2Jh0h9DigLcyC1F8-MlDKtDzrqhpJsk49aYoc4vsdsBYUQCKbnarxhmItbLMq178p8nu31qSYXhkg0D-YeL\"\n                    \"o3RIbLqfC1HElVp6E3U41L7AGSjg6WdwInfqwfRfiCNNPKKtb-gHbtEP54PezqdcIXfjSlFim1vBmCA0\\\",\\\"\"\n                    \"q\\\":\\\"xQigtlXLQX8J93V_PK2ZRGvTAFHDTZkJ-1CUPphOXZNezvMzEgv4tPsHJPUZU_muFjwlEs17qGO8xaZlfU-ohD13h\"\n                    \"kpVh_xqJj6Cl5kOVXIW6COE_M6dGGJDzCIiXurN3QjQXututMlhO-anmRspaI3v6vby2JXjZIdJqpm6ark\\\",\"\n                    \"\\\"dp\\\":\\\"C4VswqtB_0FsPTr8aFlo3SJoyAxBBTJdXKa5u9Jcsw1MbaS570MveGfHA1RosBz-Ln5-aVCVyYgQvPdlkMO\"\n                    \"a303EVAqM4AvwWPe0gR3vGk00YYenYf7U13Vb6yTXcV_VxV5aRo7MVymXrDYdR_O8mEmt3xQe5qpG3pxBlJMdZKE\\\",\"\n                    \"\\\"dq\\\":\\\"nIyBXL4H868jVRlnEegAeeuNx5gvK-1nj-VzE9Thltnrn1R-BF28qtc00vlmuWENH5-D-U-Ia79rEkNmKc1r4\"\n                    \"D4SRIG1OYmlMWPDUP4L9Hnkl2b5WAA1s1UH9x473tyC2pcRMAmxeTTz66sVCMIbAXac5Dx3sPxOouYW8tSX2Ak\\\",\"\n                    \"\\\"qi\\\":\\\"PphvSiKY95wBif4o2AUOxk9p7v2KdMZ9FY92v-moGML8k5_Gy7xHYUIzoeGGwzp_4V4kI1zTct76K-Q\"\n                    \"zDebf2wv1_v4AKFjcAUleEpDVVnGPQ3-ftftkc0UFmkoKorHLZ5Q5ZjKxa313V1pYQwbdra54xabl7LvPStYJ3asw2Yc\\\"}\",\n\n                    \"{\\\"kty\\\":\\\"RSA\\\",\\\"e\\\":\\\"AQAB\\\",\\\"n\\\":\\\"zi97QZsWWOkQ1x1gnZvcJPh1jse60KxJMHruvWI0D3klI3_\"\n                    \"29gamVgkdl9M0_t0OCq0PZZB2jzXp7b7M07sYg6MEyjOQ61KznN-fEm1QKjXznIUQghOll5u04Tjmm8dXtWNV6on2LpsN1\"\n                    \"J9hz3088ekOaYwdTntx2fZPDRmxYOBJOoX9sswW6iL-PrFCcLtwcpsyJsU_A9Am7whHQSS2dmzM5ruz7P6d9NDwlPhGLXV\"\n                    \"qRYlPc1kr3_vzwLDI8Yo1GUEzdEQ2HWWP7dL2ySl8s8ExoUTcl8AKT5w805ZmpfmhK1mxixFpbCTvJX3WPo3GWJ614XO6\"\n                    \"lZZRoh5ypt0Rsw\\\",\"\n                    \"\\\"d\\\":\\\"vpmIAFrEasZwydqfYLMe65I-4hFicdqCAe3yWmG4rIEZwtpdSotVIn1kvOACwoNIorfeXs4Pu01khWF26Vew\"\n                    \"TqfZGq5WjiMyZJcX7qncjFi5bXxYiVZuIltO91BpZaH-Q3CjkJ-eUvEE9QOtIGiueRYvO4TJ5q4YzhtycjLJFTo3vIDX\"\n                    \"woOb4R4TW5qtSlzg0baW4qEyMzqiink9kT6OvXwt6FC6RMquLlPtOYzr5KvoaBf-qbBUU9L5M9bfmPUjgk_Suz9QLYOgE\"\n                    \"ZDxUj0jyJiXgCnjidqd094iCHpBIevByfhLJmBqjIlPAZ9O1svHeA0jpE73E6ZZyKDOES3qgQ\\\",\"\n                    \"\\\"p\\\":\\\"6oIBg20lS5YIESnUM7SpGLaWCMem-c-IRolnN6gRLHkpb_mudUhO-RuQNYUzB8we5dmBkVyJxR2W4J79rFj\"\n                    \"bmilUO_8NcGYvGPYM_rOzPIP02Sltaea_vrNr-dS6-Q-lICL6845E8VeTBKRRKRr-uf-AWZfrr-ncNZaTuqa9rsE\\\",\"\n                    \"\\\"q\\\":\\\"4RT608xr6KN1Q2uj9ADXu5ZY3k1-Lf7RrtwXO-5U56777Ww7POvZi5EZoySEgWeBA426Ty5QIm0oqClCSlS0s\"\n                    \"CkYwrno0zEePsvJ9nb0BHRi_x1NVL_1iuL0dy3g5LgThhvaoMTQwiSNRRFveQhRYgB89eHIHxPw_FYSFl780XM\\\",\"\n                    \"\\\"dp\\\":\\\"rPrUzvM1rXmv3akzJCjBCr-0ECnlWyPga9dy0bUhZeLB1B0iuNRrnIjeaPwl1jyVFgrI7kaKQWJAJtRgXj\"\n                    \"71TdPqlI7ghOZ7Gzh0AXTgY2UauQ077gANtEd5AEIQ4SLPNNNYtUteQ3_LrILgcye8ecqkDHJpocspakX2FppkFIE\\\",\"\n                    \"\\\"dq\\\":\\\"hgBAiGG2iKzv_jCSTo1F4pdS1x5ZlbaUTT8Y0gRFJh3GPIZoCg_71xyOn9L41DWz2FLDbaqL6MMGJn9RyQD\"\n                    \"_BbWh2SRnWXxvnkEjPwl4o0JLQcjHJkKWQ5Z0ppN4xZJVhU0F7xrdkgfC1zDXJb5u_SJ_Qr-lreLoYMI5SHpKl8M\\\",\"\n                    \"\\\"qi\\\":\\\"Boxvcq8bIswXo8BPCcZurLjacS0TlUzbs2mLJD3noJKd361fgGoO2XdG94bqkbGg-5wbGDZL2YqGKlA2Y\"\n                    \"j8yU8ZiULaLsm3HadNVxkLTy90j59urbf0MSnMkljACZUfH2yfxVbzgZd0DWS7eDtMBP4VrQ_tQmR_djRaLOMh5yxg\\\"}\" };\n\n    char *multi_json\n        = \"{\\\"protected\\\": \\\"eyJlbmMiOiAiQTI1NkdDTSJ9\\\", \\\"iv\\\": \\\"cGHj6gmN4kC0cLTh\\\", \\\"ciphertext\\\": \"\n          \"\\\"ffgBXOZoYfCxPrbXXe4qOK0bll4F74wo3qGObUqllCdM6Vp4SyOagnFDUFMAwSA_-vVCYW37dJIBOExDQgGK0Q48cVKfiTQ5R6iKIFs6Fkc6FfXfTNKa_\"\n          \"M46Ay66lY3kFHGqWMtS6DcQs9nYltUf8uo0hEsUl1D1eA\\\", \\\"tag\\\": \\\"5LF0d_O23WKHq4c1ijaJqg\\\", \\\"recipients\\\": [{\\\"header\\\": \"\n          \"{\\\"kid\\\": \\\"test-0\\\", \\\"alg\\\": \\\"RSA-OAEP\\\"}, \\\"encrypted_key\\\": \"\n          \"\\\"hfrpxvv57nnZKJ5Whic5nEvMp2Iob5JSkht25fGRbRBj3Q9_hgbCKiMV10sSX5qVLwIsfdfSYH3QvvsI_aPV4qB326cp7SuHDgvqdKnQs-\"\n          \"qDwHrg7Erc9tJFjpR-t_VfnV8wZvEP92xvCaZ4-kx86718Op2Gb82M7ojaHufwoxN_\"\n          \"Al5oNrBNZgLZgvKROT7HmvlxHSCr0XamI8txtOt7pawZ4ENqVc1VKGYu7il-h4htMvYT7Ix0OSBWoAG1NxW-tqcD75dR_\"\n          \"SEmPkgbeC8ofbulq1lL22PLAQzpi1Op69tOIvBQ3j0JZDOUpSQajYNAyZdD26BHV_STVb-hkUCFmA\\\"}, {\\\"header\\\": {\\\"kid\\\": \\\"test-1\\\", \"\n          \"\\\"alg\\\": \\\"RSA1_5\\\"}, \\\"encrypted_key\\\": \"\n          \"\\\"Hro4KVp4KfI-7NBtAPJ67N9Oas0RrU8qs01o6fOGiVtAO9yvfvzmC6dSYOAmrhMfASm5EI3K_miQT40agyRUC5wpfV6x5NKTFaJRgGJeF5xdQyE_\"\n          \"fVNthG67GLcc-_LY5Shu2Jm5Ih1pSb4mRl6zOVBVw0HroPJLiMmRU3ai5YFLNp7M87igWHznkFWFljLONVcgV7QTJ4KDEhJUmasDqCpQ_kf5_\"\n          \"b5u4aNWqNv4FMMTgQ5XcfCVHOnYjhD3HkeqsWe4VnL3GFKBU96Lwtff-qzC55DLxtUKDrP5ZRdFKnxJX1t_X7DzgYQYxr19fx6Y-aXmflBAqIdN5-\"\n          \"OyENlWxQ\\\"}]}\";\n    char *single_json = \"{\\\"protected\\\":\\\"eyJlbmMiOiAiQTI1NkdDTSJ9\\\",\\\"iv\\\":\\\"cGHj6gmN4kC0cLTh\\\",\\\"ciphertext\\\":\"\n                        \"\\\"ffgBXOZoYfCxPrbXXe4qOK0bll4F74wo3qGObUqllCdM6Vp4SyOagnFDUFMAwSA_-\"\n                        \"vVCYW37dJIBOExDQgGK0Q48cVKfiTQ5R6iKIFs6Fkc6FfXfTNKa_M46Ay66lY3kFHGqWMtS6DcQs9nYltUf8uo0hEsUl1D1eA\\\",\"\n                        \"\\\"tag\\\":\\\"5LF0d_O23WKHq4c1ijaJqg\\\",\\\"recipients\\\":[{\\\"header\\\":{\\\"kid\\\":\\\"test-1\\\",\\\"alg\\\":\\\"RSA1_5\\\"},\"\n                        \"\\\"encrypted_key\\\":\\\"Hro4KVp4KfI-7NBtAPJ67N9Oas0RrU8qs01o6fOGiVtAO9yvfvzmC6dSYOAmrhMfASm5EI3K_\"\n                        \"miQT40agyRUC5wpfV6x5NKTFaJRgGJeF5xdQyE_fVNthG67GLcc-_\"\n                        \"LY5Shu2Jm5Ih1pSb4mRl6zOVBVw0HroPJLiMmRU3ai5YFLNp7M87igWHznkFWFljLONVcgV7QTJ4KDEhJUmasDqCpQ_kf5_\"\n                        \"b5u4aNWqNv4FMMTgQ5XcfCVHOnYjhD3HkeqsWe4VnL3GFKBU96Lwtff-qzC55DLxtUKDrP5ZRdFKnxJX1t_X7DzgYQYxr19fx6Y-\"\n                        \"aXmflBAqIdN5-OyENlWxQ\\\"}]}\";\n    char *single_flat_json\n        = \"{\\\"protected\\\": \\\"eyJlbmMiOiAiQTI1NkdDTSJ9\\\", \\\"iv\\\": \\\"cGHj6gmN4kC0cLTh\\\", \\\"ciphertext\\\": \"\n          \"\\\"ffgBXOZoYfCxPrbXXe4qOK0bll4F74wo3qGObUqllCdM6Vp4SyOagnFDUFMAwSA_-vVCYW37dJIBOExDQgGK0Q48cVKfiTQ5R6iKIFs6Fkc6FfXfTNKa_\"\n          \"M46Ay66lY3kFHGqWMtS6DcQs9nYltUf8uo0hEsUl1D1eA\\\", \\\"tag\\\": \\\"5LF0d_O23WKHq4c1ijaJqg\\\", \\\"header\\\": {\\\"kid\\\": \\\"test-1\\\", \"\n          \"\\\"alg\\\": \\\"RSA1_5\\\"}, \\\"encrypted_key\\\": \"\n          \"\\\"Hro4KVp4KfI-7NBtAPJ67N9Oas0RrU8qs01o6fOGiVtAO9yvfvzmC6dSYOAmrhMfASm5EI3K_miQT40agyRUC5wpfV6x5NKTFaJRgGJeF5xdQyE_\"\n          \"fVNthG67GLcc-_LY5Shu2Jm5Ih1pSb4mRl6zOVBVw0HroPJLiMmRU3ai5YFLNp7M87igWHznkFWFljLONVcgV7QTJ4KDEhJUmasDqCpQ_kf5_\"\n          \"b5u4aNWqNv4FMMTgQ5XcfCVHOnYjhD3HkeqsWe4VnL3GFKBU96Lwtff-qzC55DLxtUKDrP5ZRdFKnxJX1t_X7DzgYQYxr19fx6Y-aXmflBAqIdN5-\"\n          \"OyENlWxQ\\\"}\";\n\n    const char *algs[2] = { CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ALG_RSA1_5 };\n\n    cjose_err err;\n\n    cjose_jwe_recipient_t rec[2];\n\n    for (int i = 0; i < 2; i++)\n    {\n\n        char kid[32];\n\n        cjose_jwk_t *jwk = cjose_jwk_import(rsa[i], strlen(rsa[i]), &err);\n        ck_assert_msg(NULL != jwk,\n                      \"cjose_jwk_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        memset(kid, 0, 32);\n        snprintf(kid, 31, \"test-%d\", i);\n\n        ck_assert_msg(cjose_jwk_set_kid(jwk, kid, strlen(kid), &err),\n                      \"cjose_jwk_set_kid failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        rec[i].jwk = jwk;\n\n        cjose_header_t *unprotected;\n\n        ck_assert_msg((unprotected = cjose_header_new(&err)) && cjose_header_set(unprotected, \"kid\", kid, &err)\n                          && cjose_header_set(unprotected, CJOSE_HDR_ALG, algs[i], &err),\n                      \"failed to set KID into a header: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n        rec[i].unprotected_header = unprotected;\n    }\n\n    cjose_header_t *protected_header = cjose_header_new(&err);\n\n    ck_assert_msg(cjose_header_set(protected_header, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    cjose_jwe_t *jwe = cjose_jwe_encrypt_multi(rec, 2, protected_header, NULL, PLAINTEXT, strlen(PLAINTEXT) + 1, &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to encrypt to multiple recipients:\"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    size_t decoded_len;\n\n    CJOSE_ERROR(&err, CJOSE_ERR_NONE);\n    uint8_t *decoded = cjose_jwe_decrypt_multi(jwe, cjose_multi_key_locator_none, rec, &decoded_len, &err);\n    ck_assert_msg(NULL == decoded, \"did not expect to decode with selected key\");\n    ck_assert_msg(err.code == CJOSE_ERR_CRYPTO, \"expected error to be set to CRYPTO\");\n\n    decoded = cjose_jwe_decrypt_multi(jwe, cjose_multi_key_locator, rec, &decoded_len, &err);\n    ck_assert_msg(NULL != decoded,\n                  \"failed to decrypt for multiple recipients: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg(memcmp(decoded, PLAINTEXT, decoded_len) == 0 && decoded_len == strlen(PLAINTEXT) + 1,\n                  \"decrypted plaintext does not match\");\n\n    char *ser = cjose_jwe_export(jwe, &err);\n    ck_assert_msg(ser == NULL && err.code == CJOSE_ERR_INVALID_ARG,\n                  \"succeeded in creating compact serialization for multiple recipients\");\n\n    cjose_jwe_release(jwe);\n    cjose_get_dealloc()(decoded);\n\n    _cjose_test_json_serial(multi_json, multi_json, rec);\n    _cjose_test_json_serial(single_json, single_flat_json, rec);\n    _cjose_test_json_serial(single_flat_json, single_flat_json, rec);\n    _cjose_test_empty_headers(rec[0].jwk);\n\n    for (int i = 0; i < 2; i++)\n    {\n        cjose_jwk_release(rec[i].jwk);\n        cjose_header_release(rec[i].unprotected_header);\n    }\n\n    cjose_header_release(protected_header);\n}\nEND_TEST\n\nSuite *cjose_jwe_suite()\n{\n    Suite *suite = suite_create(\"jwe\");\n\n    TCase *tc_jwe = tcase_create(\"core\");\n    tcase_set_timeout(tc_jwe, 120.0);\n    tcase_add_test(tc_jwe, test_cjose_jwe_node_jose_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_iv);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_short);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_empty);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_content);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_export_compare);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_invalid_serialization);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_bad_params);\n    tcase_add_test(tc_jwe, test_cjose_jwe_multiple_recipients);\n    suite_add_tcase(suite, tc_jwe);\n\n    return suite;\n}\n"], "fixing_code": ["/*!\n * Copyrights\n *\n * Portions created or assigned to Cisco Systems, Inc. are\n * Copyright (c) 2014-2016 Cisco Systems, Inc.  All Rights Reserved.\n */\n\n#define OPENSSL_API_COMPAT 0x10000000L\n\n#include <cjose/base64.h>\n#include <cjose/header.h>\n#include <cjose/jwe.h>\n#include <cjose/util.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n#include <openssl/hmac.h>\n\n#include \"include/concatkdf_int.h\"\n#include \"include/header_int.h\"\n#include \"include/jwk_int.h\"\n#include \"include/jwe_int.h\"\n#include \"include/util_int.h\"\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_cek_aes_gcm(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err);\n\nstatic bool _cjose_jwe_set_cek_aes_cbc(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_encrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_decrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_encrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool\n_cjose_jwe_decrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err);\n\nstatic bool _cjose_jwe_set_iv_aes_gcm(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic bool _cjose_jwe_set_iv_aes_cbc(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_dat_aes_gcm(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err);\n\nstatic bool _cjose_jwe_encrypt_dat_aes_cbc(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic bool _cjose_jwe_decrypt_dat_aes_cbc(cjose_jwe_t *jwe, cjose_err *err);\n\nstatic void _cjose_release_cek(uint8_t **cek, size_t cek_len)\n{\n\n    if (NULL == *cek)\n    {\n        return;\n    }\n\n    memset(*cek, 0, cek_len);\n    cjose_get_dealloc()(*cek);\n    *cek = 0;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_empty_json(json_t *arg)\n{\n\n    return (NULL == arg || json_is_null(arg) || (json_is_object(arg) && NULL == json_object_iter_key(arg)));\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic void _cjose_dealloc_part(struct _cjose_jwe_part_int *part)\n{\n\n    cjose_get_dealloc()(part->raw);\n    cjose_get_dealloc()(part->b64u);\n}\n\nstatic json_t *_cjose_parse_json_object(const char *str, size_t len, cjose_err *err)\n{\n\n    // unfortunately, it's not possible to tell whether the error is due\n    // to syntax, or memory shortage. See https://github.com/akheron/jansson/issues/352\n\n    json_error_t j_err;\n    json_t *json = json_loadb(str, len, 0, &j_err);\n    if (NULL == json || !json_is_object(json))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        json_decref(json);\n        return NULL;\n    }\n\n    return json;\n}\n\nstatic inline bool _cjose_convert_part(struct _cjose_jwe_part_int *part, cjose_err *err)\n{\n\n    if ((NULL == part->b64u)\n        && (!cjose_base64url_encode((const uint8_t *)part->raw, part->raw_len, &part->b64u, &part->b64u_len, err)))\n    {\n\n        return false;\n    }\n\n    // dealloc the raw part, we will never need it again\n    cjose_get_dealloc()(part->raw);\n    part->raw = NULL;\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_convert_to_base64(struct _cjose_jwe_int *jwe, cjose_err *err)\n{\n\n    if (!_cjose_convert_part(&jwe->enc_header, err) || !_cjose_convert_part(&jwe->enc_iv, err)\n        || !_cjose_convert_part(&jwe->enc_iv, err) || !_cjose_convert_part(&jwe->enc_ct, err)\n        || !_cjose_convert_part(&jwe->enc_auth_tag, err))\n    {\n\n        return false;\n    }\n\n    for (int i = 0; i < jwe->to_count; i++)\n    {\n        if (!_cjose_convert_part(&jwe->to[i].enc_key, err))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic size_t _keylen_from_enc(const char *alg)\n{\n    size_t keylen = 0;\n\n    if (0 == strcmp(alg, CJOSE_HDR_ENC_A128GCM))\n    {\n        keylen = 128;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A192GCM))\n    {\n        keylen = 192;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A256GCM))\n    {\n        keylen = 256;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A128CBC_HS256))\n    {\n        keylen = 256;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A192CBC_HS384))\n    {\n        keylen = 384;\n    }\n    else if (0 == strcmp(alg, CJOSE_HDR_ENC_A256CBC_HS512))\n    {\n        keylen = 512;\n    }\n\n    return keylen;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_malloc(size_t bytes, bool random, uint8_t **buffer, cjose_err *err)\n{\n    *buffer = (uint8_t *)cjose_get_alloc()(bytes);\n    if (NULL == *buffer)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return false;\n    }\n    if (random)\n    {\n        if (RAND_bytes((unsigned char *)*buffer, bytes) != 1)\n        {\n            cjose_get_dealloc()(*buffer);\n            CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n            return false;\n        }\n    }\n    else\n    {\n        memset(*buffer, 0, bytes);\n    }\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_build_hdr(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // serialize the header\n    char *hdr_str = json_dumps(jwe->hdr, JSON_ENCODE_ANY | JSON_PRESERVE_ORDER);\n    if (NULL == hdr_str)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return false;\n    }\n\n    // copy the serialized header to JWE (hdr_str is owned by header object)\n    size_t len = strlen(hdr_str);\n    uint8_t *data = (uint8_t *)_cjose_strndup(hdr_str, len, err);\n    if (!data)\n    {\n        cjose_get_dealloc()(hdr_str);\n        return false;\n    }\n\n    jwe->enc_header.raw = data;\n    jwe->enc_header.raw_len = len;\n    cjose_get_dealloc()(hdr_str);\n\n    return true;\n}\n\nstatic const char *_cjose_jwe_get_from_headers(cjose_header_t *protected_header,\n                                               cjose_header_t *unprotected_header,\n                                               cjose_header_t *personal_header,\n                                               const char *key)\n{\n\n    // TODO: https://github.com/cisco/cjose/issues/52\n    cjose_header_t *headers[] = { personal_header, unprotected_header, protected_header };\n\n    for (int i = 0; i < 3; i++)\n    {\n        if (NULL == headers[i])\n        {\n            continue;\n        }\n        json_t *obj = json_object_get((json_t *)headers[i], key);\n        if (NULL == obj)\n        {\n            continue;\n        }\n        const char *value = json_string_value(obj);\n        if (NULL == value)\n        {\n            continue;\n        }\n        return value;\n    }\n\n    return NULL;\n}\n\nstatic bool _cjose_jwe_validate_enc(cjose_jwe_t *jwe, cjose_header_t *protected_header, cjose_err *err)\n{\n\n    const char *enc = cjose_header_get(protected_header, CJOSE_HDR_ENC, err);\n    if (NULL == enc)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    if ((strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0) || (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        || (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0))\n    {\n        jwe->fns.set_cek = _cjose_jwe_set_cek_aes_gcm;\n        jwe->fns.set_iv = _cjose_jwe_set_iv_aes_gcm;\n        jwe->fns.encrypt_dat = _cjose_jwe_encrypt_dat_aes_gcm;\n        jwe->fns.decrypt_dat = _cjose_jwe_decrypt_dat_aes_gcm;\n    }\n    if ((strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0) || (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n        || (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0))\n    {\n        jwe->fns.set_cek = _cjose_jwe_set_cek_aes_cbc;\n        jwe->fns.set_iv = _cjose_jwe_set_iv_aes_cbc;\n        jwe->fns.encrypt_dat = _cjose_jwe_encrypt_dat_aes_cbc;\n        jwe->fns.decrypt_dat = _cjose_jwe_decrypt_dat_aes_cbc;\n    }\n\n    if (NULL == jwe->fns.set_cek || NULL == jwe->fns.set_iv || NULL == jwe->fns.encrypt_dat || NULL == jwe->fns.decrypt_dat)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_validate_alg(cjose_header_t *protected_header,\n                                    cjose_header_t *unprotected_header,\n                                    bool is_multiple,\n                                    _jwe_int_recipient_t *recipient,\n                                    cjose_err *err)\n{\n\n    const char *alg = _cjose_jwe_get_from_headers(protected_header, unprotected_header, (cjose_header_t *)recipient->unprotected,\n                                                  CJOSE_HDR_ALG);\n\n    if (NULL == alg)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // set JWE build functions based on header contents\n    if (strcmp(alg, CJOSE_HDR_ALG_RSA_OAEP) == 0)\n    {\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_rsa_oaep;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_rsa_oaep;\n    }\n    if (strcmp(alg, CJOSE_HDR_ALG_RSA1_5) == 0)\n    {\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_rsa1_5;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_rsa1_5;\n    }\n    if (strcmp(alg, CJOSE_HDR_ALG_ECDH_ES) == 0)\n    {\n        if (is_multiple)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_ecdh_es;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_ecdh_es;\n    }\n    if (strcmp(alg, CJOSE_HDR_ALG_DIR) == 0)\n    {\n        if (is_multiple)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_dir;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_dir;\n    }\n    if ((strcmp(alg, CJOSE_HDR_ALG_A128KW) == 0) || (strcmp(alg, CJOSE_HDR_ALG_A192KW) == 0)\n        || (strcmp(alg, CJOSE_HDR_ALG_A256KW) == 0))\n    {\n        recipient->fns.encrypt_ek = _cjose_jwe_encrypt_ek_aes_kw;\n        recipient->fns.decrypt_ek = _cjose_jwe_decrypt_ek_aes_kw;\n    }\n\n    // ensure required builders have been assigned\n    if (NULL == recipient->fns.encrypt_ek || NULL == recipient->fns.decrypt_ek)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_cek_aes_gcm(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err)\n{\n    if (NULL != jwe->cek)\n    {\n        return true;\n    }\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // determine the CEK key size based on the encryption algorithm\n    size_t keysize = 0;\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        keysize = 16;\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        keysize = 24;\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        keysize = 32;\n\n    // if no JWK is provided, generate a random key\n    if (NULL == jwk)\n    {\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, random, &jwe->cek, err))\n        {\n            return false;\n        }\n        jwe->cek_len = keysize;\n    }\n    else\n    {\n        // if a JWK is provided, it must be a symmetric key of correct size\n        if (CJOSE_JWK_KTY_OCT != cjose_jwk_get_kty(jwk, err) || jwk->keysize != keysize * 8 || NULL == jwk->keydata)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n\n        // copy the key material directly from jwk to the jwe->cek\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, false, &jwe->cek, err))\n        {\n            return false;\n        }\n        memcpy(jwe->cek, jwk->keydata, keysize);\n        jwe->cek_len = keysize;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_cek_aes_cbc(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, bool random, cjose_err *err)\n{\n\n    if (NULL != jwe->cek)\n    {\n        return true;\n    }\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // determine the CEK key size based on the encryption algorithm\n    size_t keysize = 0;\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n        keysize = 32;\n    if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n        keysize = 48;\n    if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n        keysize = 64;\n\n    if (NULL == jwk)\n    {\n        // allocate memory for the CEK and fill with random bytes or 0's\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, !random, &jwe->cek, err))\n        {\n            return false;\n        }\n        jwe->cek_len = keysize;\n    }\n    else\n    {\n        // if a JWK is provided, it must be a symmetric key of correct size\n        if (CJOSE_JWK_KTY_OCT != cjose_jwk_get_kty(jwk, err) || jwk->keysize != keysize * 8 || NULL == jwk->keydata)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            return false;\n        }\n\n        // copy the key material directly from jwk to the jwe->cek\n        _cjose_release_cek(&jwe->cek, jwe->cek_len);\n        if (!_cjose_jwe_malloc(keysize, false, &jwe->cek, err))\n        {\n            return false;\n        }\n        memcpy(jwe->cek, jwk->keydata, keysize);\n        jwe->cek_len = keysize;\n    }\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    // for direct encryption, JWE sec 5.1, step 6: let CEK be the symmetric key.\n    if (!jwe->fns.set_cek(jwe, jwk, false, err))\n    {\n        return false;\n    }\n\n    // for direct encryption, JWE sec 5.1, step 5: let EK be empty octet seq.\n    recipient->enc_key.raw = NULL;\n    recipient->enc_key.raw_len = 0;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_dir(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    // do not try and decrypt the ek. that's impossible.\n    // instead... only try to realize the truth.  there is no ek.\n    return jwe->fns.set_cek(jwe, jwk, false, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must be OCT\n    if (jwk->kty != CJOSE_JWK_KTY_OCT)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // generate random CEK\n    if (!jwe->fns.set_cek(jwe, NULL, true, err))\n    {\n        return false;\n    }\n\n    // create the AES encryption key from the shared key\n    AES_KEY akey;\n    if (AES_set_encrypt_key(jwk->keydata, jwk->keysize, &akey) < 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    // allocate buffer for encrypted CEK (=cek_len + 8)\n    if (!_cjose_jwe_malloc(jwe->cek_len + 8, false, &recipient->enc_key.raw, err))\n    {\n        return false;\n    }\n\n    // AES wrap the CEK\n    int len = AES_wrap_key(&akey, NULL, recipient->enc_key.raw, jwe->cek, jwe->cek_len);\n    if (len <= 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n    recipient->enc_key.raw_len = len;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_aes_kw(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must be OCT\n    if (jwk->kty != CJOSE_JWK_KTY_OCT)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // create the AES decryption key from the shared key\n    AES_KEY akey;\n    if (AES_set_decrypt_key(jwk->keydata, jwk->keysize, &akey) < 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    if (!jwe->fns.set_cek(jwe, NULL, false, err))\n    {\n        return false;\n    }\n\n    // AES unwrap the CEK in to jwe->cek\n    int len = AES_unwrap_key(&akey, (const unsigned char *)NULL, jwe->cek, (const unsigned char *)recipient->enc_key.raw,\n                             recipient->enc_key.raw_len);\n    if (len <= 0)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n    jwe->cek_len = len;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_rsa_padding(\n    _jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, int padding, cjose_err *err)\n{\n    // jwk must be RSA\n    if (jwk->kty != CJOSE_JWK_KTY_RSA || NULL == jwk->keydata)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must have the necessary public parts set\n    BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n    _cjose_jwk_rsa_get((RSA *)jwk->keydata, &rsa_n, &rsa_e, &rsa_d);\n    if (NULL == rsa_e || NULL == rsa_n)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // generate random cek\n    if (!jwe->fns.set_cek(jwe, NULL, true, err))\n    {\n        return false;\n    }\n\n    // the size of the ek will match the size of the RSA key\n    recipient->enc_key.raw_len = RSA_size((RSA *)jwk->keydata);\n\n    // for OAEP padding - the RSA size - 41 must be greater than input\n    if (jwe->cek_len >= recipient->enc_key.raw_len - 41)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // allocate memory for RSA encryption\n    cjose_get_dealloc()(recipient->enc_key.raw);\n    if (!_cjose_jwe_malloc(recipient->enc_key.raw_len, false, &recipient->enc_key.raw, err))\n    {\n        return false;\n    }\n\n    // encrypt the CEK using RSA v1.5 or OAEP padding\n    if (RSA_public_encrypt(jwe->cek_len, jwe->cek, recipient->enc_key.raw, (RSA *)jwk->keydata, padding)\n        != recipient->enc_key.raw_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_rsa_padding(\n    _jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, int padding, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must be RSA\n    if (jwk->kty != CJOSE_JWK_KTY_RSA)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // jwk must have the necessary private parts set\n    BIGNUM *rsa_n = NULL, *rsa_e = NULL, *rsa_d = NULL;\n    _cjose_jwk_rsa_get((RSA *)jwk->keydata, &rsa_n, &rsa_e, &rsa_d);\n    if (NULL == rsa_e || NULL == rsa_n || NULL == rsa_d)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // we don't know the size of the key to expect, but must be < RSA_size\n    _cjose_release_cek(&jwe->cek, jwe->cek_len);\n    size_t buflen = RSA_size((RSA *)jwk->keydata);\n    if (!_cjose_jwe_malloc(buflen, false, &jwe->cek, err))\n    {\n        return false;\n    }\n\n    // decrypt the CEK using RSA v1.5 or OAEP padding\n    int len = RSA_private_decrypt(recipient->enc_key.raw_len, recipient->enc_key.raw, jwe->cek, (RSA *)jwk->keydata, padding);\n    if (-1 == len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    jwe->cek_len = len;\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool\n_cjose_jwe_encrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_encrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_OAEP_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool\n_cjose_jwe_decrypt_ek_rsa_oaep(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_decrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_OAEP_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_encrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_rsa1_5(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    return _cjose_jwe_decrypt_ek_rsa_padding(recipient, jwe, jwk, RSA_PKCS1_PADDING, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    cjose_jwk_t *epk_jwk = NULL;\n    char *epk_json = NULL;\n    uint8_t *secret = NULL;\n    size_t secret_len = 0;\n    uint8_t *otherinfo = NULL;\n    size_t otherinfo_len = 0;\n    uint8_t *derived = NULL;\n    bool result = false;\n\n    // generate and export random EPK\n    epk_jwk = cjose_jwk_create_EC_random(cjose_jwk_EC_get_curve(jwk, err), err);\n    if (NULL == epk_jwk)\n    {\n        // error details already set\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n    epk_json = cjose_jwk_to_json(epk_jwk, false, err);\n    if (NULL == epk_json)\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n    if (!cjose_header_set_raw(jwe->hdr, CJOSE_HDR_EPK, epk_json, err))\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    // perform ECDH (private=epk_jwk, public=jwk)\n    if (!cjose_jwk_derive_ecdh_bits(epk_jwk, jwk, &secret, &secret_len, err))\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    // perform label, ConcatKDF\n    // - assemble otherInfo from:\n    //   * alg (== {enc})\n    //   * apu (default = \"\")\n    //   * apv (default = \"\")\n    //   * keylen (determined from {enc})\n    cjose_header_t *hdr = jwe->hdr;\n    const char *algId = cjose_header_get(hdr, CJOSE_HDR_ENC, err);\n    const size_t keylen = _keylen_from_enc(algId) / 8;\n\n    if (!cjose_concatkdf_create_otherinfo(algId, keylen * 8, hdr, &otherinfo, &otherinfo_len, err))\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    derived = cjose_concatkdf_derive(keylen, secret, secret_len, otherinfo, otherinfo_len, err);\n    if (NULL == derived)\n    {\n        goto cjose_encrypt_ek_ecdh_es_finish;\n    }\n\n    jwe->cek = derived;\n    jwe->cek_len = keylen;\n    recipient->enc_key.raw = NULL;\n    recipient->enc_key.raw_len = 0;\n    result = true;\n\ncjose_encrypt_ek_ecdh_es_finish:\n\n    cjose_jwk_release(epk_jwk);\n    cjose_get_dealloc()(epk_json);\n    cjose_get_dealloc()(secret);\n    cjose_get_dealloc()(otherinfo);\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)\n{\n    cjose_jwk_t *epk_jwk = NULL;\n    uint8_t *secret = NULL;\n    size_t secret_len = 0;\n    uint8_t *otherinfo = NULL;\n    size_t otherinfo_len = 0;\n    uint8_t *derived = NULL;\n    bool result = false;\n\n    memset(err, 0, sizeof(cjose_err));\n    char *epk_json = cjose_header_get_raw(jwe->hdr, CJOSE_HDR_EPK, err);\n    if (NULL != epk_json)\n    {\n        epk_jwk = cjose_jwk_import(epk_json, strlen(epk_json), err);\n    }\n    else if (CJOSE_ERR_NONE == err->code)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    if (NULL == epk_jwk)\n    {\n        // error details already set\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    // perform ECDH (private=jwk, public=epk_jwk)\n    if (!cjose_jwk_derive_ecdh_bits(jwk, epk_jwk, &secret, &secret_len, err))\n    {\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    // perform label, ConcatKDF\n    // - assemble otherInfo from:\n    //   * alg (== {enc})\n    //   * apu (default = \"\")\n    //   * apv (default = \"\")\n    //   * keylen (determined from {enc})\n    cjose_header_t *hdr = jwe->hdr;\n    const char *algId = cjose_header_get(hdr, CJOSE_HDR_ENC, err);\n    const size_t keylen = _keylen_from_enc(algId) / 8;\n\n    if (!cjose_concatkdf_create_otherinfo(algId, keylen * 8, hdr, &otherinfo, &otherinfo_len, err))\n    {\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    derived = cjose_concatkdf_derive(keylen, secret, secret_len, otherinfo, otherinfo_len, err);\n    if (NULL == derived)\n    {\n        goto cjose_decrypt_ek_ecdh_es_finish;\n    }\n\n    jwe->cek = derived;\n    jwe->cek_len = keylen;\n    recipient->enc_key.raw = NULL;\n    recipient->enc_key.raw_len = 0;\n    result = true;\n\ncjose_decrypt_ek_ecdh_es_finish:\n\n    cjose_jwk_release(epk_jwk);\n    cjose_get_dealloc()(epk_json);\n    cjose_get_dealloc()(secret);\n    cjose_get_dealloc()(otherinfo);\n\n    return result;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_iv_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // generate IV as random 96 bit value\n    cjose_get_dealloc()(jwe->enc_iv.raw);\n    jwe->enc_iv.raw_len = 12;\n    if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, true, &jwe->enc_iv.raw, err))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_set_iv_aes_cbc(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    cjose_get_dealloc()(jwe->enc_iv.raw);\n\n    // RFC 7516 (https://tools.ietf.org/html/rfc7516) is unclear about\n    // the size of the IV for AES-CBC. In section 5.1\n    // (https://tools.ietf.org/html/rfc7516#section-5.1), they state in no. 9.:\n    // \"Generate a random JWE Initialization Vector of the correct size\n    // for the content encryption algorithm\"\n    // And in the example in A.2.4 (https://tools.ietf.org/html/rfc7516#appendix-A.2.4)\n    // they provide an example for AES128-CBC, which results (naturally) in the IV size of 128Bit.\n    //\n    // The CISCO implementation chooses for the size of the IV the key size of the\n    // cipher algorithm, which seems to be wrong.\n    //\n    // According to RFC 3602 section 3 (https://tools.ietf.org/html/rfc3602#section-3):\n    // \"The IV field MUST be the same size as the block size of the cipher algorithm being used.\"\n    // And because the block size for AES cipher is always 16 Byte, the IV must be 16 Byte long.\n    //\n    // IV size for AES CBC is always 16 Byte\n    jwe->enc_iv.raw_len = 16;\n\n    // generate IV as random iv_size * 8 bit value\n    if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, true, &jwe->enc_iv.raw, err))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n#if defined(CJOSE_OPENSSL_11X)\n#define CJOSE_EVP_CTRL_GCM_GET_TAG EVP_CTRL_AEAD_GET_TAG\n#define CJOSE_EVP_CTRL_GCM_SET_TAG EVP_CTRL_AEAD_SET_TAG\n#else\n#define CJOSE_EVP_CTRL_GCM_GET_TAG EVP_CTRL_GCM_GET_TAG\n#define CJOSE_EVP_CTRL_GCM_SET_TAG EVP_CTRL_GCM_SET_TAG\n#endif\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_dat_aes_gcm(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    if (NULL == plaintext)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for encryption using AES GCM cipher and CEK and IV\n    if (EVP_EncryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // we need the header in base64url encoding as input for encryption\n    if ((NULL == jwe->enc_header.b64u)\n        && (!cjose_base64url_encode((const uint8_t *)jwe->enc_header.raw, jwe->enc_header.raw_len, &jwe->enc_header.b64u,\n                                    &jwe->enc_header.b64u_len, err)))\n    {\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_encrypted = 0;\n    if (EVP_EncryptUpdate(ctx, NULL, &bytes_encrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_encrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // allocate buffer for the ciphertext\n    cjose_get_dealloc()(jwe->enc_ct.raw);\n    jwe->enc_ct.raw_len = plaintext_len;\n    if (!_cjose_jwe_malloc(jwe->enc_ct.raw_len, false, &jwe->enc_ct.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // encrypt entire plaintext to ciphertext buffer\n    if (EVP_EncryptUpdate(ctx, jwe->enc_ct.raw, &bytes_encrypted, plaintext, plaintext_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n    jwe->enc_ct.raw_len = bytes_encrypted;\n\n    // finalize the encryption and set the ciphertext length to correct value\n    if (EVP_EncryptFinal_ex(ctx, NULL, &bytes_encrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // allocate buffer for the authentication tag\n    cjose_get_dealloc()(jwe->enc_auth_tag.raw);\n    jwe->enc_auth_tag.raw_len = 16;\n    if (!_cjose_jwe_malloc(jwe->enc_auth_tag.raw_len, false, &jwe->enc_auth_tag.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    // get the GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_GET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_encrypt_dat_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_calc_auth_tag(const char *enc, cjose_jwe_t *jwe, uint8_t *md, unsigned int *md_len, cjose_err *err)\n{\n    bool retval = false;\n    const EVP_MD *hash = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n    {\n        hash = EVP_sha256();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n    {\n        hash = EVP_sha384();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n    {\n        hash = EVP_sha512();\n    }\n\n    if (NULL == hash)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    uint8_t *msg = NULL;\n\n    // calculate the Authentication Tag value over AAD + IV + ciphertext + AAD length\n\n    // 0 = header\n    // 1 = cek\n    // 2 = iv\n    // 3 = ciphertext\n    // 4 = authentication tag\n\n    // Additional Authentication Data length (base64encoded header) in # of bits in 64 bit length field\n    uint64_t al = jwe->enc_header.b64u_len * 8;\n\n    // concatenate AAD + IV + ciphertext + AAD length field\n    int msg_len = jwe->enc_header.b64u_len + jwe->enc_iv.raw_len + jwe->enc_ct.raw_len + sizeof(uint64_t);\n    if (!_cjose_jwe_malloc(msg_len, false, &msg, err))\n    {\n        goto _cjose_jwe_calc_auth_tag_end;\n    }\n\n    // construct AAD + IV + ciphertext + AAD input\n    uint8_t *p = msg;\n    memcpy(p, jwe->enc_header.b64u, jwe->enc_header.b64u_len);\n    p += jwe->enc_header.b64u_len;\n    memcpy(p, jwe->enc_iv.raw, jwe->enc_iv.raw_len);\n    p += jwe->enc_iv.raw_len;\n    memcpy(p, jwe->enc_ct.raw, jwe->enc_ct.raw_len);\n    p += jwe->enc_ct.raw_len;\n\n    // check if we are on a big endian or little endian machine\n    int c = 1;\n    if (*(char *)&c == 1)\n    {\n        // little endian machine: reverse AAD length for big endian representation\n        al = (al & 0x00000000FFFFFFFF) << 32 | (al & 0xFFFFFFFF00000000) >> 32;\n        al = (al & 0x0000FFFF0000FFFF) << 16 | (al & 0xFFFF0000FFFF0000) >> 16;\n        al = (al & 0x00FF00FF00FF00FF) << 8 | (al & 0xFF00FF00FF00FF00) >> 8;\n    }\n    memcpy(p, &al, sizeof(uint64_t));\n\n    // HMAC the input\n    if (!HMAC(hash, jwe->cek, jwe->cek_len / 2, msg, msg_len, md, md_len))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_calc_auth_tag_end;\n    }\n\n    // use only the first half of the bits\n    *md_len = *md_len / 2;\n    retval = true;\n\n_cjose_jwe_calc_auth_tag_end:\n    if (msg)\n    {\n        cjose_get_dealloc()(msg);\n    }\n    return retval;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_encrypt_dat_aes_cbc(cjose_jwe_t *jwe, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err)\n{\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get the AES cipher\n    EVP_CIPHER_CTX *ctx = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n        cipher = EVP_aes_128_cbc();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n        cipher = EVP_aes_192_cbc();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n        cipher = EVP_aes_256_cbc();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using the cipher, the 2nd half of the CEK and the IV\n    if (EVP_EncryptInit_ex(ctx, cipher, NULL, jwe->cek + jwe->cek_len / 2, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    // we need the header in base64url encoding as input for encryption\n    if ((NULL == jwe->enc_header.b64u)\n        && (!cjose_base64url_encode((const uint8_t *)jwe->enc_header.raw, jwe->enc_header.raw_len, &jwe->enc_header.b64u,\n                                    &jwe->enc_header.b64u_len, err)))\n    {\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    // allocate buffer for the ciphertext (plaintext + block size)\n    cjose_get_dealloc()(jwe->enc_ct.raw);\n    jwe->enc_ct.raw_len = plaintext_len + EVP_CIPHER_block_size(cipher);\n    if (!_cjose_jwe_malloc(jwe->enc_ct.raw_len, false, &jwe->enc_ct.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    // encrypt entire plaintext to ciphertext buffer\n    int bytes_encrypted = 0;\n    if (EVP_EncryptUpdate(ctx, jwe->enc_ct.raw, &bytes_encrypted, plaintext, plaintext_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    jwe->enc_ct.raw_len = bytes_encrypted;\n\n    // finalize the encryption and set the ciphertext length to correct value\n    if (EVP_EncryptFinal_ex(ctx, jwe->enc_ct.raw + bytes_encrypted, &bytes_encrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n    jwe->enc_ct.raw_len += bytes_encrypted;\n\n    // calculate Authentication Tag\n    unsigned int tag_len = 0;\n    uint8_t tag[EVP_MAX_MD_SIZE];\n    if (_cjose_jwe_calc_auth_tag(enc, jwe, (unsigned char *)&tag, &tag_len, err) == false)\n    {\n        return false;\n    }\n\n    // allocate buffer for the authentication tag\n    cjose_get_dealloc()(jwe->enc_auth_tag.raw);\n    jwe->enc_auth_tag.raw_len = tag_len;\n    if (!_cjose_jwe_malloc(jwe->enc_auth_tag.raw_len, false, &jwe->enc_auth_tag.raw, err))\n    {\n        goto _cjose_jwe_encrypt_dat_aes_cbc_fail;\n    }\n\n    memcpy(jwe->enc_auth_tag.raw, tag, tag_len);\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return true;\n\n_cjose_jwe_encrypt_dat_aes_cbc_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    if (jwe->enc_auth_tag.raw_len != 16)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set the expected GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool _cjose_jwe_decrypt_dat_aes_cbc(cjose_jwe_t *jwe, cjose_err *err)\n{\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // calculate Authentication Tag\n    unsigned int tag_len = 0;\n    uint8_t tag[EVP_MAX_MD_SIZE];\n    if (_cjose_jwe_calc_auth_tag(enc, jwe, (unsigned char *)&tag, &tag_len, err) == false)\n    {\n        return false;\n    }\n\n    // compare the provided Authentication Tag against our calculation\n    if ((tag_len != jwe->enc_auth_tag.raw_len) || (cjose_const_memcmp(tag, jwe->enc_auth_tag.raw, tag_len) != 0))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        return false;\n    }\n\n    // get the AES cipher\n    EVP_CIPHER_CTX *ctx = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128CBC_HS256) == 0)\n    {\n        cipher = EVP_aes_128_cbc();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A192CBC_HS384) == 0)\n    {\n        cipher = EVP_aes_192_cbc();\n    }\n    else if (strcmp(enc, CJOSE_HDR_ENC_A256CBC_HS512) == 0)\n    {\n        cipher = EVP_aes_256_cbc();\n    }\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using the cipher, the 2nd half of the CEK and the IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek + jwe->cek_len / 2, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // allocate buffer for the plaintext + one block padding\n    int p_len = jwe->enc_ct.raw_len, f_len = 0;\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = p_len + AES_BLOCK_SIZE;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &p_len, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, jwe->dat + p_len, &f_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_cbc_fail;\n    }\n    jwe->dat_len = p_len + f_len;\n\n    EVP_CIPHER_CTX_free(ctx);\n\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_cbc_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt_iv(const cjose_jwk_t *jwk,\n                                  cjose_header_t *protected_header,\n                                  const uint8_t *iv,\n                                  size_t iv_len,\n                                  const uint8_t *plaintext,\n                                  size_t plaintext_len,\n                                  cjose_err *err)\n{\n\n    cjose_jwe_recipient_t rec = { .jwk = jwk, .unprotected_header = NULL };\n\n    return cjose_jwe_encrypt_multi_iv(&rec, 1, protected_header, NULL, iv, iv_len, plaintext, plaintext_len, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt(\n    const cjose_jwk_t *jwk, cjose_header_t *protected_header, const uint8_t *plaintext, size_t plaintext_len, cjose_err *err)\n{\n    return cjose_jwe_encrypt_iv(jwk, protected_header, NULL, 0, plaintext, plaintext_len, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt_multi_iv(const cjose_jwe_recipient_t *recipients,\n                                        size_t recipient_count,\n                                        cjose_header_t *protected_header,\n                                        cjose_header_t *shared_unprotected_header,\n                                        const uint8_t *iv,\n                                        size_t iv_len,\n                                        const uint8_t *plaintext,\n                                        size_t plaintext_len,\n                                        cjose_err *err)\n{\n    cjose_jwe_t *jwe = NULL;\n\n    if (NULL == recipients || NULL == protected_header || recipient_count < 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // allocate and initialize a new JWE object\n    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))\n    {\n        return NULL;\n    }\n\n    jwe->to_count = recipient_count;\n    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t) * recipient_count, false, (uint8_t **)&jwe->to, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    if (!_cjose_jwe_validate_enc(jwe, protected_header, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // validate JWE header\n    for (size_t i = 0; i < recipient_count; i++)\n    {\n\n        if (NULL == recipients[i].jwk)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n\n        jwe->to[i].unprotected = json_incref(recipients[i].unprotected_header);\n\n        // make sure we have an alg header\n        if (!_cjose_jwe_validate_alg(protected_header, jwe->to[i].unprotected, recipient_count > 1, jwe->to + i, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n    }\n\n    // prepare JWE headers\n    jwe->hdr = json_deep_copy(protected_header);\n    if (jwe->hdr == NULL)\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n    jwe->shared_hdr = json_incref(shared_unprotected_header);\n\n    for (size_t i = 0; i < recipient_count; i++)\n    {\n\n        // build JWE content-encryption key and encrypted key\n        if (!jwe->to[i].fns.encrypt_ek(jwe->to + i, jwe, recipients[i].jwk, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n    }\n\n    // build JWE header\n    if (!_cjose_jwe_build_hdr(jwe, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // build JWE initialization vector\n    if (iv == NULL)\n    {\n        if (!jwe->fns.set_iv(jwe, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n    }\n    else\n    {\n        cjose_get_dealloc()(jwe->enc_iv.raw);\n        jwe->enc_iv.raw_len = iv_len;\n        if (!_cjose_jwe_malloc(jwe->enc_iv.raw_len, false, &jwe->enc_iv.raw, err))\n        {\n            cjose_jwe_release(jwe);\n            return NULL;\n        }\n        memcpy(jwe->enc_iv.raw, iv, iv_len);\n    }\n\n    // build JWE encrypted data and authentication tag\n    if (!jwe->fns.encrypt_dat(jwe, plaintext, plaintext_len, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    _cjose_release_cek(&jwe->cek, jwe->cek_len);\n\n    return jwe;\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_encrypt_multi(const cjose_jwe_recipient_t *recipients,\n                                     size_t recipient_count,\n                                     cjose_header_t *protected_header,\n                                     cjose_header_t *shared_unprotected_header,\n                                     const uint8_t *plaintext,\n                                     size_t plaintext_len,\n                                     cjose_err *err)\n{\n    return cjose_jwe_encrypt_multi_iv(recipients, recipient_count, protected_header, shared_unprotected_header, NULL, 0, plaintext,\n                                      plaintext_len, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nvoid cjose_jwe_release(cjose_jwe_t *jwe)\n{\n    if (NULL == jwe)\n    {\n        return;\n    }\n\n    json_decref(jwe->hdr);\n    json_decref(jwe->shared_hdr);\n\n    _cjose_dealloc_part(&jwe->enc_header);\n    _cjose_dealloc_part(&jwe->enc_iv);\n    _cjose_dealloc_part(&jwe->enc_ct);\n    _cjose_dealloc_part(&jwe->enc_auth_tag);\n\n    for (int i = 0; i < jwe->to_count; ++i)\n    {\n        json_decref(jwe->to[i].unprotected);\n        _cjose_dealloc_part(&jwe->to[i].enc_key);\n    }\n\n    cjose_get_dealloc()(jwe->to);\n\n    _cjose_release_cek(&jwe->cek, jwe->cek_len);\n\n    cjose_get_dealloc()(jwe->dat);\n    cjose_get_dealloc()(jwe);\n}\n\n////////////////////////////////////////////////////////////////////////////////\nchar *cjose_jwe_export(cjose_jwe_t *jwe, cjose_err *err)\n{\n    char *cser = NULL;\n    size_t cser_len = 0;\n\n    if (NULL == jwe || jwe->to_count > 1 || !_cjose_empty_json(jwe->shared_hdr) || !_cjose_empty_json(jwe->to[0].unprotected))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    if (!_cjose_convert_to_base64(jwe, err))\n    {\n        return NULL;\n    }\n\n    // make sure all parts are b64u encoded\n    cser_len = jwe->enc_header.b64u_len + jwe->to[0].enc_key.b64u_len + jwe->enc_iv.b64u_len + jwe->enc_ct.b64u_len\n               + jwe->enc_auth_tag.b64u_len + 5;\n\n    // allocate buffer for compact serialization\n    if (!_cjose_jwe_malloc(cser_len, false, (uint8_t **)&cser, err))\n    {\n        return NULL;\n    }\n\n    // build the compact serialization\n    snprintf(cser, cser_len, \"%s.%s.%s.%s.%s\", jwe->enc_header.b64u, jwe->to[0].enc_key.b64u, jwe->enc_iv.b64u, jwe->enc_ct.b64u,\n             jwe->enc_auth_tag.b64u);\n\n    return cser;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic inline bool _cjose_add_json_part(json_t *obj, const char *key, struct _cjose_jwe_part_int *part, cjose_err *err)\n{\n    json_t *str = json_stringn(part->b64u, part->b64u_len);\n    if (NULL == str)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return false;\n    }\n    json_object_set_new(obj, key, str);\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nchar *cjose_jwe_export_json(cjose_jwe_t *jwe, cjose_err *err)\n{\n\n    if (!_cjose_convert_to_base64(jwe, err))\n    {\n        return NULL;\n    }\n\n    json_t *form = json_object();\n    if (NULL == form)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        return NULL;\n    }\n\n    if (!_cjose_add_json_part(form, \"protected\", &jwe->enc_header, err) || !_cjose_add_json_part(form, \"iv\", &jwe->enc_iv, err)\n        || !_cjose_add_json_part(form, \"ciphertext\", &jwe->enc_ct, err)\n        || !_cjose_add_json_part(form, \"tag\", &jwe->enc_auth_tag, err))\n    {\n        json_delete(form);\n        return NULL;\n    }\n\n    json_object_set(form, \"unprotected\", jwe->shared_hdr);\n\n    if (jwe->to_count == 1)\n    {\n        json_object_set(form, \"header\", jwe->to[0].unprotected);\n        if (!_cjose_add_json_part(form, \"encrypted_key\", &jwe->to[0].enc_key, err))\n        {\n            json_delete(form);\n            return NULL;\n        }\n    }\n    else\n    {\n\n        json_t *recipients = json_array();\n        if (NULL == recipients)\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n            json_delete(form);\n            return NULL;\n        }\n\n        json_object_set_new(form, \"recipients\", recipients);\n\n        for (int i = 0; i < jwe->to_count; i++)\n        {\n\n            json_t *recipient = json_object();\n            if (NULL == recipient)\n            {\n                CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n                json_delete(form);\n                return NULL;\n            }\n\n            json_array_append_new(recipients, recipient);\n\n            json_object_set(recipient, \"header\", jwe->to[i].unprotected);\n            if (!_cjose_add_json_part(recipient, \"encrypted_key\", &jwe->to[i].enc_key, err))\n            {\n                json_delete(form);\n                return NULL;\n            }\n        }\n    }\n\n    char *json_str = json_dumps(form, JSON_PRESERVE_ORDER);\n    if (NULL == json_str)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n        json_delete(form);\n        return NULL;\n    }\n\n    json_delete(form);\n    return json_str;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nstatic bool\n_cjose_jwe_import_part(struct _cjose_jwe_part_int *part, bool empty_ok, const char *b64u, size_t b64u_len, cjose_err *err)\n{\n    // only the ek and the data parts may be of zero length\n    if (b64u_len == 0 && !empty_ok)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    // copy the b64u part to the jwe\n    part->b64u = _cjose_strndup(b64u, b64u_len, err);\n    part->b64u_len = b64u_len;\n\n    // b64u decode the part\n    if (!cjose_base64url_decode(part->b64u, part->b64u_len, (uint8_t **)&part->raw, &part->raw_len, err) || NULL == part->raw)\n    {\n        return false;\n    }\n\n    return true;\n}\n\nstatic bool _cjose_jwe_import_json_part(struct _cjose_jwe_part_int *part, bool empty_ok, json_t *json, cjose_err *err)\n{\n\n    if (NULL == json || !json_is_string(json))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    const char *str = json_string_value(json);\n    // TODO: if json_is_string() was true, are we guaranteed that str is !NULL?\n\n    return _cjose_jwe_import_part(part, empty_ok, str, strlen(str), err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_import(const char *cser, size_t cser_len, cjose_err *err)\n{\n    cjose_jwe_t *jwe = NULL;\n\n    if (NULL == cser)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // allocate and initialize a new JWE object\n    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))\n    {\n        return NULL;\n    }\n\n    jwe->to_count = 1;\n    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t), false, (uint8_t **)&jwe->to, err))\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    struct _cjose_jwe_part_int *parts[] = {\n        &jwe->enc_header, &jwe->to[0].enc_key, &jwe->enc_iv, &jwe->enc_ct, &jwe->enc_auth_tag,\n    };\n\n    // import each part of the compact serialization\n    int part = 0;\n    size_t idx = 0;\n    size_t start_idx = 0;\n    while (idx <= cser_len && part < 5)\n    {\n        if ((idx == cser_len) || (cser[idx] == '.'))\n        {\n            if (!_cjose_jwe_import_part(parts[part], 1 == part || 3 == part, cser + start_idx, idx - start_idx, err))\n            {\n                cjose_jwe_release(jwe);\n                return NULL;\n            }\n            part++;\n            start_idx = idx + 1;\n        }\n        if (part < 5)\n            ++idx;\n    }\n\n    // fail if we didn't find enough parts\n    if (part != 5)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // fail if we finished early (e.g. more than 5 parts)\n    if (idx != cser_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // deserialize JSON header\n    jwe->hdr = _cjose_parse_json_object((const char *)jwe->enc_header.raw, jwe->enc_header.raw_len, err);\n    if (NULL == jwe->hdr)\n    {\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    // validate the JSON header. No unprotected headers can exist.\n    if (!_cjose_jwe_validate_alg((cjose_header_t *)jwe->hdr, NULL, false, jwe->to, err)\n        || !_cjose_jwe_validate_enc(jwe, (cjose_header_t *)jwe->hdr, err))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        cjose_jwe_release(jwe);\n        return NULL;\n    }\n\n    return jwe;\n}\n\nstatic inline bool _cjose_read_json_recipient(cjose_jwe_t *jwe,\n                                              cjose_header_t *protected_header,\n                                              bool is_multiple,\n                                              _jwe_int_recipient_t *recipient,\n                                              json_t *obj,\n                                              cjose_err *err)\n{\n\n    if (!json_is_object(obj))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    if (!_cjose_jwe_import_json_part(&recipient->enc_key, true, json_object_get(obj, \"encrypted_key\"), err))\n    {\n        return false;\n    };\n\n    recipient->unprotected = json_incref(json_object_get(obj, \"header\"));\n\n    // it's OK to have empty/null unprotected header\n    if (recipient->unprotected && !json_is_object(recipient->unprotected))\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n\n    return _cjose_jwe_validate_alg(protected_header, jwe->shared_hdr, is_multiple, recipient, err);\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_jwe_t *cjose_jwe_import_json(const char *cser, size_t cser_len, cjose_err *err)\n{\n    cjose_jwe_t *jwe = NULL;\n    json_t *form = NULL;\n    json_t *protected_header = NULL;\n\n    if (NULL == cser)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // allocate and initialize a new JWE object\n    if (!_cjose_jwe_malloc(sizeof(cjose_jwe_t), false, (uint8_t **)&jwe, err))\n    {\n        return NULL;\n    }\n\n    form = _cjose_parse_json_object(cser, cser_len, err);\n    if (NULL == form)\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    json_t *recipients = json_object_get(form, \"recipients\");\n    if (NULL != recipients)\n    {\n        if (!json_is_array(recipients))\n        {\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            goto _cjose_jwe_import_json_fail;\n        }\n        jwe->to_count = json_array_size(recipients);\n        if (jwe->to_count < 1)\n        {\n            // TODO: is empty recipients array allowed?\n            CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n            goto _cjose_jwe_import_json_fail;\n        }\n    }\n    else\n    {\n        jwe->to_count = 1;\n    }\n\n    if (!_cjose_jwe_malloc(sizeof(_jwe_int_recipient_t) * jwe->to_count, false, (uint8_t **)&jwe->to, err))\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    if (!_cjose_jwe_import_json_part(&jwe->enc_header, false, json_object_get(form, \"protected\"), err))\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    protected_header = _cjose_parse_json_object((const char *)jwe->enc_header.raw, jwe->enc_header.raw_len, err);\n    if (NULL == protected_header)\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    if (NULL == recipients)\n    {\n\n        if (!_cjose_read_json_recipient(jwe, protected_header, false, jwe->to, form, err))\n        {\n            goto _cjose_jwe_import_json_fail;\n        }\n    }\n    else\n    {\n\n        for (size_t i = 0; i < jwe->to_count; i++)\n        {\n\n            if (!_cjose_read_json_recipient(jwe, protected_header, jwe->to_count > 1, jwe->to + i, json_array_get(recipients, i),\n                                            err))\n            {\n                goto _cjose_jwe_import_json_fail;\n            }\n        }\n    }\n\n    if (!_cjose_jwe_validate_enc(jwe, protected_header, err))\n    {\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    if (!_cjose_jwe_import_json_part(&jwe->enc_iv, false, json_object_get(form, \"iv\"), err)\n        || !_cjose_jwe_import_json_part(&jwe->enc_ct, false, json_object_get(form, \"ciphertext\"), err)\n        || !_cjose_jwe_import_json_part(&jwe->enc_auth_tag, false, json_object_get(form, \"tag\"), err))\n    {\n\n        goto _cjose_jwe_import_json_fail;\n    }\n\n    jwe->hdr = json_incref(protected_header);\n\n    json_decref(form);\n    json_decref(protected_header);\n\n    return jwe;\n\n_cjose_jwe_import_json_fail:\n    json_decref(form);\n    json_decref(protected_header);\n    cjose_jwe_release(jwe);\n    return NULL;\n}\n\nuint8_t *cjose_jwe_decrypt_multi(cjose_jwe_t *jwe, cjose_key_locator key_locator, void *data, size_t *content_len, cjose_err *err)\n{\n\n    uint8_t *cek = 0;\n    size_t cek_len = 0;\n    uint8_t *content = NULL;\n\n    if (NULL == jwe || NULL == key_locator || NULL == content_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    for (size_t i = 0; i < jwe->to_count; i++)\n    {\n\n        const cjose_jwk_t *key = key_locator(jwe, (cjose_header_t *)jwe->to[i].unprotected, data);\n        if (NULL == key)\n        {\n            continue;\n        }\n\n        // decrypt JWE content-encryption key from encrypted key\n        if (!jwe->to[i].fns.decrypt_ek(jwe->to + i, jwe, key, err))\n        {\n            // if one key failed to decrypt, fail everything.\n            goto _cjose_jwe_decrypt_multi_fail;\n        }\n\n        if (NULL == cek)\n        {\n            cek_len = jwe->cek_len;\n            cek = cjose_get_alloc()(cek_len);\n            if (!cek)\n            {\n                CJOSE_ERROR(err, CJOSE_ERR_NO_MEMORY);\n                return NULL;\n            }\n            memcpy(cek, jwe->cek, cek_len);\n        }\n        else\n        {\n            if (cek_len != jwe->cek_len || memcmp(jwe->cek, cek, cek_len))\n            {\n                CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n                goto _cjose_jwe_decrypt_multi_fail;\n            }\n        }\n    }\n\n    if (NULL == jwe->cek)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_multi_fail;\n    }\n\n    // decrypt JWE encrypted data\n    if (!jwe->fns.decrypt_dat(jwe, err))\n    {\n        goto _cjose_jwe_decrypt_multi_fail;\n    }\n\n    // take the plaintext data from the jwe object\n    content = jwe->dat;\n    *content_len = jwe->dat_len;\n\n    jwe->dat = NULL;\n    jwe->dat_len = 0;\n\n_cjose_jwe_decrypt_multi_fail:\n\n    _cjose_release_cek(&cek, cek_len);\n\n    return content;\n}\n\n////////////////////////////////////////////////////////////////////////////////\nuint8_t *cjose_jwe_decrypt(cjose_jwe_t *jwe, const cjose_jwk_t *jwk, size_t *content_len, cjose_err *err)\n{\n    if (NULL == jwe || NULL == jwk || NULL == content_len || jwe->to_count > 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return NULL;\n    }\n\n    // decrypt JWE content-encryption key from encrypted key\n    if (!jwe->to[0].fns.decrypt_ek(jwe->to, jwe, jwk, err))\n    {\n        return NULL;\n    }\n\n    // decrypt JWE encrypted data\n    if (!jwe->fns.decrypt_dat(jwe, err))\n    {\n        return NULL;\n    }\n\n    // take the plaintext data from the jwe object\n    uint8_t *content = jwe->dat;\n    *content_len = jwe->dat_len;\n    jwe->dat = NULL;\n    jwe->dat_len = 0;\n\n    return content;\n}\n\n////////////////////////////////////////////////////////////////////////////////\ncjose_header_t *cjose_jwe_get_protected(cjose_jwe_t *jwe)\n{\n    if (NULL == jwe)\n    {\n        return NULL;\n    }\n    return (cjose_header_t *)jwe->hdr;\n}\n", "/*!\n *\n */\n\n#include \"check_cjose.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <check.h>\n#include <cjose/cjose.h>\n#include <jansson.h>\n#include \"include/jwk_int.h\"\n#include \"include/jwe_int.h\"\n#include <openssl/rsa.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <cjose/error.h>\n\n// a JWK of type RSA\nstatic const char *JWK_RSA\n    = \"{ \\\"kty\\\": \\\"RSA\\\", \"\n      \"\\\"e\\\": \\\"AQAB\\\", \"\n      \"\\\"n\\\": \"\n      \"\\\"wsqJbopx18NQFYLYOq4ZeMSE89yGiEankUpf25yV8QqroKUGrASj_OeqTWUjwPGKTN1vGFFuHYxiJeAUQH2qQPmg9Oqk6-\"\n      \"ATBEKn9COKYniQ5459UxCwmZA2RL6ufhrNyq0JF3GfXkjLDBfhU9zJJEOhknsA0L_c-X4AI3d_NbFdMqxNe1V_\"\n      \"UWAlLcbKdwO6iC9fAvwUmDQxgy6R0DC1CMouQpenMRcALaSHar1cm4K-syoNobv3HEuqgZ3s6-hOOSqauqAO0GUozPpaIA7OeruyRl5sTWT0r-\"\n      \"iz39bchID2bIKtcqLiFcSYPLBcxmsaQCqRlGhmv6stjTCLV1yT9w\\\", \"\n      \"\\\"kid\\\": \\\"ff3c5c96-392e-46ef-a839-6ff16027af78\\\", \"\n      \"\\\"d\\\": \"\n      \"\\\"b9hXfQ8lOtw8mX1dpqPcoElGhbczz_-xq2znCXQpbBPSZBUddZvchRSH5pSSKPEHlgb3CSGIdpLqsBCv0C_XmCM9ViN8uqsYgDO9uCLIDK5plWttbkqA_\"\n      \"EufvW03R9UgIKWmOL3W4g4t-\"\n      \"C2mBb8aByaGGVNjLnlb6i186uBsPGkvaeLHbQcRQKAvhOUTeNiyiiCbUGJwCm4avMiZrsz1r81Y1Z5izo0ERxdZymxM3FRZ9vjTB-\"\n      \"6DtitvTXXnaAm1JTu6TIpj38u2mnNLkGMbflOpgelMNKBZVxSmfobIbFN8CHVc1UqLK2ElsZ9RCQANgkMHlMkOMj-XT0wHa3VBUQ\\\", \"\n      \"\\\"p\\\": \"\n      \"\\\"8mgriveKJAp1S7SHqirQAfZafxVuAK_A2QBYPsAUhikfBOvN0HtZjgurPXSJSdgR8KbWV7ZjdJM_eOivIb_XiuAaUdIOXbLRet7t9a_\"\n      \"NJtmX9iybhoa9VOJFMBq_rbnbbte2kq0-FnXmv3cukbC2LaEw3aEcDgyURLCgWFqt7M0\\\", \"\n      \"\\\"q\\\": \"\n      \"\\\"zbbTv5421GowOfKVEuVoA35CEWgl8mdasnEZac2LWxMwKExikKU5LLacLQlcOt7A6n1ZGUC2wyH8mstO5tV34Eug3fnNrbnxFUEE_ZB_njs_\"\n      \"rtZnwz57AoUXOXVnd194seIZF9PjdzZcuwXwXbrZ2RSVW8if_ZH5OVYEM1EsA9M\\\", \"\n      \"\\\"dp\\\": \"\n      \"\\\"1BaIYmIKn1X3InGlcSFcNRtSOnaJdFhRpotCqkRssKUx2qBlxs7ln_5dqLtZkx5VM_UE_GE7yzc6BZOwBxtOftdsr8HVh-14ksSR9rAGEsO2zVBiEuW4qZf_\"\n      \"aQM-ScWfU--wcczZ0dT-Ou8P87Bk9K9fjcn0PeaLoz3WTPepzNE\\\", \"\n      \"\\\"dq\\\": \"\n      \"\\\"kYw2u4_UmWvcXVOeV_VKJ5aQZkJ6_sxTpodRBMPyQmkMHKcW4eKU1mcJju_\"\n      \"deqWadw5jGPPpm5yTXm5UkAwfOeookoWpGa7CvVf4kPNI6Aphn3GBjunJHNpPuU6w-wvomGsxd-NqQDGNYKHuFFMcyXO_zWXglQdP_1o1tJ1M-BM\\\", \"\n      \"\\\"qi\\\": \"\n      \"\\\"j94Ens784M8zsfwWoJhYq9prcSZOGgNbtFWQZO8HP8pcNM9ls7YA4snTtAS_\"\n      \"B4peWWFAFZ0LSKPCxAvJnrq69ocmEKEk7ss1Jo062f9pLTQ6cnhMjev3IqLocIFt5Vbsg_PWYpFSR7re6FRbF9EYOM7F2-HRv1idxKCWoyQfBqk\\\" }\";\n\n// a JWK of type EC\nstatic const char *JWK_EC = \"{ \\\"kty\\\": \\\"EC\\\", \"\n                            \"\\\"crv\\\": \\\"P-256\\\", \"\n                            \"\\\"x\\\": \\\"DxaAKzwruXJh4IkdieycIJER6w8M1TYMCV3qOa-l9CM\\\", \"\n                            \"\\\"y\\\": \\\"_kRI1aD7-PMFwhUpXmcRzw6hALF_xdKwADuKOM-xsak\\\", \"\n                            \"\\\"d\\\":\\\"SOu5eRc40yn5yVrg069VjWNH4wsoErN8_AxmH4cI88s\\\" }\";\n\n// a JWK of type oct\nstatic const char *JWK_OCT_16 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"3921VrO5TrLvPQ-NFLlghQ\\\"}\";\nstatic const char *JWK_OCT_24 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"dC4ZvqLVuS-esAz331EEd8HiwCBM1dih\\\"}\";\nstatic const char *JWK_OCT_32 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"ZMpktzGq1g6_r4fKVdnx9OaYr4HjxPjIs7l7SwAsgsg\\\"}\";\nstatic const char *JWK_OCT_48 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"2xAZsjSXMTg6XtY5AESrM3slgXzUaXHFEaGrALThNPyC_9JeO8Hg4PZpLDdhDIlk\\\"}\";\nstatic const char *JWK_OCT_64 = \"{\\\"kty\\\":\\\"oct\\\", \"\n                                \"\\\"k\\\":\\\"Jc2RE4DiwDGZsDTVt0Am3ZI_6IhSuoeQdRaHs_XKl_WnmFkHuvGr8px7h_2rme4rpYGHx93I7jl4p9swfJwlzQ\\\"}\";\n\n// a JWE encrypted with the above JWK_RSA key (using node-jose)\nstatic const char *JWE_RSA\n    = \"eyJraWQiOiJmZjNjNWM5Ni0zOTJlLTQ2ZWYtYTgzOS02ZmYxNjAyN2FmNzgiLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n      \"FGQ9IUhjmSJr4dAntH0DP-dAJiZPfKCRhg-SjUywNFqmG-ruhRvio1K7qy2Z0joatZxdJmkOInlsGvGIZeyapTtOndshCsfTlazHH-4fqFyepIm6o-gZ8gfntDG_\"\n      \"sa9hi9uw1KxeJfNmaL94JMjq-QVmocdCeruIE7_bL90MNflQ8qf5vhuh_hF_Ea_vUnHlIbbQsF1ZF4rRsEGBR7CxTBxusMgErct0kp3La6qQbnX8fDJMqL_\"\n      \"aeot4xZRm3zobIYqKePaGBaSJ7wooWslM1w57IrYXN0UVODRAFO6L5ldF_PHpWbBnFx4k_-FWCOVb-iVpQmLtBkniKG6iItXVUQ.ebcXmjWfUMq-brIT.\"\n      \"BPt7F9tcIwQpoAjlyguagOGftJE392-j3kSnP5I6nB-WhWKfpPAeChIW23oWTUHlUbadOeBaiI6r-2TLTZzf3jFKc8Wwr-F0q_iEUQjmg3om-PKR_Pgl_\"\n      \"ncDTXjkxSQjbHOAV1JByh61G-WFuEC1UItyib0AOq9R.Mlo2kQF8Zn2hwwdDl_4Lnw\";\n\n// the plaintext payload of the above JWE object(s)\nstatic const char *PLAINTEXT = \"If you reveal your secrets to the wind, you should not blame the \"\n                               \"wind for revealing them to the trees. \u2014 Kahlil Gibran\";\n\nstatic const cjose_jwk_t *cjose_multi_key_locator(cjose_jwe_t *jwe, cjose_header_t *hdr, void *data)\n{\n    const char *kid = cjose_header_get(hdr, CJOSE_HDR_KID, NULL);\n    if (NULL != kid)\n    {\n\n        ;\n        for (cjose_jwe_recipient_t *recs = data; recs->jwk; recs++)\n        {\n            const char *t_kid = cjose_jwk_get_kid(recs->jwk, NULL);\n            if (NULL != t_kid && !strcmp(t_kid, kid))\n            {\n                return recs->jwk;\n            }\n        }\n    }\n\n    return NULL;\n}\n\nstatic const cjose_jwk_t *cjose_multi_key_locator_none(cjose_jwe_t *jwe, cjose_header_t *hdr, void *data) { return NULL; }\n\nSTART_TEST(test_cjose_jwe_node_jose_encrypt_self_decrypt)\n{\n    cjose_err err;\n\n    // import the JWK\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_RSA, strlen(JWK_RSA), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the JWE\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA, strlen(JWE_RSA), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain2_len = 0;\n    uint8_t *plain2 = cjose_jwe_decrypt(jwe, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_get_plaintext failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain2 == PLAINTEXT\n    ck_assert_msg(plain2_len == strlen(PLAINTEXT),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(PLAINTEXT), plain2_len);\n    ck_assert_msg(strncmp(PLAINTEXT, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_jwk_release(jwk);\n    cjose_jwe_release(jwe);\n}\nEND_TEST\n\nstatic void _self_encrypt_self_decrypt_with_key(const char *alg, const char *enc, const char *key, const char *plain1)\n{\n    cjose_err err;\n\n    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE\n    cjose_header_t *hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, alg, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, enc, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // create the JWE\n    size_t plain1_len = strlen(plain1);\n    cjose_jwe_t *jwe1 = cjose_jwe_encrypt(jwk, hdr, plain1, plain1_len, &err);\n    ck_assert_msg(NULL != jwe1, \"cjose_jwe_encrypt failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n    // ck_assert(hdr == cjose_jwe_get_protected(jwe1));\n\n    // get the compact serialization of JWE\n    char *compact = cjose_jwe_export(jwe1, &err);\n    ck_assert_msg(NULL != compact, \"cjose_jwe_export failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n\n    // deserialize the compact representation to a new JWE\n    cjose_jwe_t *jwe2 = cjose_jwe_import(compact, strlen(compact), &err);\n    ck_assert_msg(NULL != jwe2,\n                  \"cjose_jwe_import failed for algo %s, method %s: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  alg, enc, err.message, err.file, err.function, err.line);\n\n    // get the decrypted plaintext\n    uint8_t *plain2 = NULL;\n    size_t plain2_len = 0;\n    plain2 = cjose_jwe_decrypt(jwe2, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_decrypt failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain2 == plain1\n    ck_assert(json_equal((json_t *)cjose_jwe_get_protected(jwe1), (json_t *)cjose_jwe_get_protected(jwe2)));\n    ck_assert_msg(plain2_len == strlen(plain1),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(plain1), plain2_len);\n    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_header_release(hdr);\n    cjose_jwe_release(jwe1);\n    cjose_jwe_release(jwe2);\n    cjose_jwk_release(jwk);\n    cjose_get_dealloc()(compact);\n}\n\nstatic void _self_encrypt_self_decrypt(const char *plain1)\n{\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A128GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A128GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A192GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A192GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192GCM, JWK_OCT_24, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A256GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A256GCM, JWK_RSA, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256GCM, JWK_OCT_32, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_32, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_48, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_64, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A192KW, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_24, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A256KW, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_32, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A128GCM, JWK_EC, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A192GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A192GCM, JWK_EC, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A256GCM, JWK_OCT_16, plain1);\n\n    _self_encrypt_self_decrypt_with_key(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A256GCM, JWK_EC, plain1);\n}\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt)\n{\n    _self_encrypt_self_decrypt(\"Sed ut perspiciatis unde omnis iste natus error sit voluptatem \"\n                               \"doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo \"\n                               \"veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo \"\n                               \"ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed \"\n                               \"consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \"\n                               \"porro quisquam est, qui dolorem ipsum quia dolor sit amet, \"\n                               \"adipisci velit, sed quia non numquam eius modi tempora incidunt ut \"\n                               \"dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, \"\n                               \"nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut \"\n                               \"ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in \"\n                               \"voluptate velit esse quam nihil molestiae consequatur, vel illum qui \"\n                               \"eum fugiat quo voluptas nulla pariatur?\");\n}\nEND_TEST\n\nstatic void\n_self_encrypt_self_decrypt_with_key_iv(const char *alg, const char *enc, const char *key, size_t iv_len, const char *plain1)\n{\n    cjose_err err;\n\n    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE\n    cjose_header_t *hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, alg, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, enc, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // generate a random IV\n    uint8_t *iv = (uint8_t *)malloc(iv_len);\n    ck_assert_msg(RAND_bytes(iv, iv_len) == 1, \"RAND_bytes failed\");\n\n    // create the JWE\n    size_t plain1_len = strlen(plain1);\n    cjose_jwe_t *jwe1 = cjose_jwe_encrypt_iv(jwk, hdr, iv, iv_len, plain1, plain1_len, &err);\n    ck_assert_msg(NULL != jwe1, \"cjose_jwe_encrypt failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n    // ck_assert(hdr == cjose_jwe_get_protected(jwe1));\n\n    // get the compact serialization of JWE\n    char *compact = cjose_jwe_export(jwe1, &err);\n    ck_assert_msg(NULL != compact, \"cjose_jwe_export failed: %s, file: %s, function: %s, line: %ld\", err.message, err.file,\n                  err.function, err.line);\n\n    // deserialize the compact representation to a new JWE\n    cjose_jwe_t *jwe2 = cjose_jwe_import(compact, strlen(compact), &err);\n    ck_assert_msg(NULL != jwe2,\n                  \"cjose_jwe_import failed for algo %s, method %s: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  alg, enc, err.message, err.file, err.function, err.line);\n\n    // get the decrypted plaintext\n    uint8_t *plain2 = NULL;\n    size_t plain2_len = 0;\n    plain2 = cjose_jwe_decrypt(jwe2, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_decrypt failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain2 == plain1\n    ck_assert(json_equal((json_t *)cjose_jwe_get_protected(jwe1), (json_t *)cjose_jwe_get_protected(jwe2)));\n    ck_assert_msg(plain2_len == strlen(plain1),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(plain1), plain2_len);\n    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_header_release(hdr);\n    free(iv);\n    cjose_jwe_release(jwe1);\n    cjose_jwe_release(jwe2);\n    cjose_jwk_release(jwk);\n    cjose_get_dealloc()(compact);\n}\n\nstatic void _self_encrypt_self_decrypt_iv(const char *plain1)\n{\n    // Tests for when #85 (A128GCM and A192GCM support) is merged\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A128GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A128GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A192GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A192GCM, JWK_RSA, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192GCM, JWK_OCT_24, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ENC_A256GCM, JWK_RSA, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_RSA1_5, CJOSE_HDR_ENC_A256GCM, JWK_RSA, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256GCM, JWK_OCT_32, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_32, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_48, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_DIR, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_64, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128CBC_HS256, JWK_OCT_16, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A192KW, CJOSE_HDR_ENC_A192CBC_HS384, JWK_OCT_24, 16, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A256KW, CJOSE_HDR_ENC_A256CBC_HS512, JWK_OCT_32, 16, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A128GCM, JWK_OCT_16, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A128GCM, JWK_EC, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A192GCM, JWK_OCT_16, 12, plain1);\n\n    // _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A192GCM, JWK_EC, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_A128KW, CJOSE_HDR_ENC_A256GCM, JWK_OCT_16, 12, plain1);\n\n    _self_encrypt_self_decrypt_with_key_iv(CJOSE_HDR_ALG_ECDH_ES, CJOSE_HDR_ENC_A256GCM, JWK_EC, 12, plain1);\n}\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_iv)\n{\n    _self_encrypt_self_decrypt_iv(\"Sed ut perspiciatis unde omnis iste natus error sit voluptatem \"\n                                  \"doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo \"\n                                  \"veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo \"\n                                  \"ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed \"\n                                  \"consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. \"\n                                  \"porro quisquam est, qui dolorem ipsum quia dolor sit amet, \"\n                                  \"adipisci velit, sed quia non numquam eius modi tempora incidunt ut \"\n                                  \"dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, \"\n                                  \"nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut \"\n                                  \"ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in \"\n                                  \"voluptate velit esse quam nihil molestiae consequatur, vel illum qui \"\n                                  \"eum fugiat quo voluptas nulla pariatur?\");\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_short) { _self_encrypt_self_decrypt(\"Setec Astronomy\"); }\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_empty) { _self_encrypt_self_decrypt(\"\"); }\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_large)\n{\n    // encrypt and decrypt a 4MB buffer of z's\n    size_t len = 1024 * 4096;\n    char *plain = (char *)malloc(len);\n    memset(plain, 'z', len);\n    plain[len - 1] = 0;\n    // _self_encrypt_self_decrypt(plain);\n    free(plain);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_self_encrypt_self_decrypt_many)\n{\n    // encrypt and decrypt a whole lot of randomly sized payloads\n    for (int i = 0; i < 100; ++i)\n    {\n        size_t len = random() % 1024;\n        char *plain = (char *)malloc(len);\n        ck_assert_msg(RAND_bytes(plain, len) == 1, \"RAND_bytes failed\");\n        plain[len - 1] = 0;\n        _self_encrypt_self_decrypt(plain);\n        free(plain);\n    }\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_encrypt_with_bad_header)\n{\n    cjose_header_t *hdr = NULL;\n    cjose_jwe_t *jwe = NULL;\n    cjose_err err;\n\n    static const char *plain = \"The mind is everything. What you think you become.\";\n    size_t plain_len = strlen(plain);\n\n    static const char *JWK\n        = \"{ \\\"kty\\\": \\\"RSA\\\", \"\n          \"\\\"kid\\\": \\\"9ebf9edb-3a24-48b4-b2cb-21f0cf747ea7\\\", \"\n          \"\\\"e\\\": \\\"AQAB\\\", \"\n          \"\\\"n\\\": \"\n          \"\\\"0a5nKJLjaB1xdebYWfhvlhYhgfzkw49HAUIjyvb6fNPKhwlBQMoAS5jM3kI17_OMGrHxL7ZP00OE-24__\"\n          \"VWDCAhOQsSvlgCvw2XOOCtSWWLpb03dTrCMFeemqS4S9jrKd3NbUk3UJ2dVb_EIbQEC_BVjZStr_\"\n          \"HcCrKsj4AluaQUn09H7TuK0yZFBzZMhJ1J8Yi3nAPkxzdGah0XuWhLObMAvANSVmHzRXwnTDw9Dh_\"\n          \"bJ4G1xd1DE7W94uoUlcSDx59aSdzTpQzJh1l3lXc6JRUrXTESYgHpMv0O1n0gbIxX8X1ityBlMiccDjfZIKLnwz6hQObvRtRIpxEdq4SYS-w\\\" }\";\n\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK, strlen(JWK), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE with bad alg\n    hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, \"Cayley-Purser\", &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // create a JWE\n    jwe = cjose_jwe_encrypt(jwk, hdr, plain, plain_len, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad header\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    // set header for JWE with bad enc\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, \"Twofish\", &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // create a JWE\n    jwe = cjose_jwe_encrypt(jwk, hdr, plain, plain_len, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad header\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    cjose_header_release(hdr);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_encrypt_with_bad_key)\n{\n    cjose_header_t *hdr = NULL;\n    cjose_jwe_t *jwe = NULL;\n    cjose_err err;\n\n    static const char *plain = \"The mind is everything. What you think you become.\";\n    size_t plain_len = strlen(plain);\n\n    // some bad keys to test with\n    static const char *JWK_BAD[] = {\n\n        // importing private key with a missing public part 'e' fails at cjose_jwk_import\n\n        // currently unsupported key type (EC)\n        \"{ \\\"kty\\\": \\\"EC\\\", \\\"crv\\\": \\\"P-256\\\", \"\n        \"\\\"x\\\": \\\"VoFkf6Wk5kDQ1ob6csBmiMPHU8jALwdtaap35Fsj20M\\\", \"\n        \"\\\"y\\\": \\\"XymwN6u2PmsKbIPy5iij6qZ-mIyej5dvZWB_75lnRgQ\\\", \"\n        \"\\\"kid\\\": \\\"4E34BAFD-E5D9-479C-964D-009C419C38DB\\\" }\",\n\n        NULL\n    };\n\n    // set header for JWE\n    hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // attempt encryption with each bad key\n    for (int i = 0; NULL != JWK_BAD[i]; ++i)\n    {\n        cjose_jwk_t *jwk = cjose_jwk_import(JWK_BAD[i], strlen(JWK_BAD[i]), &err);\n        ck_assert_msg(NULL != jwk,\n                      \"cjose_jwk_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        jwe = cjose_jwe_encrypt(jwk, hdr, plain, plain_len, &err);\n        ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad key\");\n        ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n        cjose_jwk_release(jwk);\n    }\n\n    jwe = cjose_jwe_encrypt(NULL, hdr, plain, plain_len, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with bad key\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    cjose_header_release(hdr);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_encrypt_with_bad_content)\n{\n    cjose_header_t *hdr = NULL;\n    cjose_jwe_t *jwe = NULL;\n    cjose_err err;\n\n    static const char *JWK\n        = \"{ \\\"kty\\\": \\\"RSA\\\", \"\n          \"\\\"kid\\\": \\\"9ebf9edb-3a24-48b4-b2cb-21f0cf747ea7\\\", \"\n          \"\\\"e\\\": \\\"AQAB\\\", \"\n          \"\\\"n\\\": \"\n          \"\\\"0a5nKJLjaB1xdebYWfhvlhYhgfzkw49HAUIjyvb6fNPKhwlBQMoAS5jM3kI17_OMGrHxL7ZP00OE-24__\"\n          \"VWDCAhOQsSvlgCvw2XOOCtSWWLpb03dTrCMFeemqS4S9jrKd3NbUk3UJ2dVb_EIbQEC_BVjZStr_\"\n          \"HcCrKsj4AluaQUn09H7TuK0yZFBzZMhJ1J8Yi3nAPkxzdGah0XuWhLObMAvANSVmHzRXwnTDw9Dh_\"\n          \"bJ4G1xd1DE7W94uoUlcSDx59aSdzTpQzJh1l3lXc6JRUrXTESYgHpMv0O1n0gbIxX8X1ityBlMiccDjfZIKLnwz6hQObvRtRIpxEdq4SYS-w\\\" }\";\n\n    // import the key\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK, strlen(JWK), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // set header for JWE\n    hdr = cjose_header_new(&err);\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    jwe = cjose_jwe_encrypt(jwk, hdr, NULL, 1024, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with NULL plaintext\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    jwe = cjose_jwe_encrypt(jwk, hdr, NULL, 0, &err);\n    ck_assert_msg(NULL == jwe, \"cjose_jwe_encrypt created with NULL plaintext\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_encrypt returned bad err.code\");\n\n    cjose_jwk_release(jwk);\n    cjose_header_release(hdr);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_import_export_compare)\n{\n    cjose_err err;\n\n    // import the common key\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_RSA, strlen(JWK_RSA), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the jwe created with the common key\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA, strlen(JWE_RSA), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // re-export the jwe object\n    char *cser = cjose_jwe_export(jwe, &err);\n    ck_assert_msg(NULL != cser,\n                  \"re-export of imported JWE failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // compare the re-export to the original serialization\n    ck_assert_msg(strncmp(JWE_RSA, cser, strlen(JWE_RSA)) == 0, \"export of imported JWE doesn't match original\");\n\n    cjose_jwk_release(jwk);\n    cjose_jwe_release(jwe);\n    cjose_get_dealloc()(cser);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_import_invalid_serialization)\n{\n    cjose_err err;\n\n    static const char *JWE_BAD[]\n        = { \"eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk.jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg.x\",\n            \"eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk.jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg.\",\n            \"eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk..jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg\",\n            \".eyJraWQiOiI5ZWJmOWVkYi0zYTI0LTQ4YjQtYjJjYi0yMWYwY2Y3NDdlYTciLCJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n            \"D4Od2xiHoO5SYtoUXt_I_oZvxFfCA29dxbyz21Uw6sP-uQpoPxu-jQ7NUJtmzZIf4VIWHN5YOrV0-UqKkP-Woipug26blBPkIV4YzoNFJD3sMW3Bbc91M_\"\n            \"Rwd03QID6eGv0REkCo1KbbLnw_u56PGBtPVHJNIMwNTKdU-FJwxEkahZGU3FS8RLw8-0BeFvLbjg3yTCUVuZex2mZ3QL_sXrCYADSMpYDWC41nxEWt26Z_\"\n            \"cxGhGmRU_5fjsE_AWHrIWS1-qdZcAlYrv-wMg0pRqsElGVVcFSkfXBfyGFURcAqB-a2ge2IxxQ-G3Jkhl7EFIWhhD1ZtQWGEpBVjHZeH3w.\"\n            \"NnDIbUkIHi1suUKk.jUGOQ2vKzL_nrjbaK6qwnDBTtU26Ut9HiyUsblnEs_0aO0aJ50f13bu2EBic5e0e50Lu8jVUlMSfwPgfqKePV9xbHmE6GPn_\"\n            \"E59VxnzJpMVoxohjqezkG50ydvqXg_lJ84BLk8R0dR_LtUZxJdbzNo-B8YRloiKPOee7zyZ6tU9h-_\"\n            \"so37XgLBy6uDDeGxGlK6TnG8q9oqLB7zLF03Seyv8XBl-Bved7V8sor_sr4efoyW_\"\n            \"oKneqqBSqnaQ0OApMnFTQ7yudwfI19R9CvYI62bfluDSknai0Lwm3cGDOSningMxKpPVja_Ieyb5cJNHsnR5u5bCYjBl5l7wL7ttXBBURaFDO6i67KxHq-\"\n            \"K02AAxyAWkJM9DWt_IXsx4vxvYCgUQQxmMvZRAzxdrT1UOvpyJoh64LcuKuj4LGY_b6xaSV72CpeNQWXaSJDSNtQKsoO3-S4QAcqHTUXb9-_\"\n            \"HKIi8sZJgqxeyHYs2oJRD0WItq0BUVoHvaQmR2gRm-rhXuujOWJW_xk9Wp8lpbJR8tANdcai7O84WR9noA0-z3BdYdLOftK-YAR1Fa8OEE1-\"\n            \"VSAI7TfRjMdAMw01pGJZmwn4VhbcE60QS0uESnNPRq9abpVqVlEA6WdFtAgv6oUJ34YpSQ5hXEXbTSz0XL948q58QZ0oadVeR-\"\n            \"1JOm3fjCgvJgvvcdmDs1kZy2iPPmMhsmwiTQCBXlgwbj7xUxuA9EtcVcIylL3X1BmRqDJG8kyJLBFvRtBwe6OC0uApr_\"\n            \"74evzbnihMFk1bBEeL0H8yJWvWpl20SHF6gjlEHb7OqF1fMGj3oqxRjYrRcNj2EV-Acq8WVbRuizYSxREnBt5_\"\n            \"sWoiUHtbSpgNeMEv3Go9fzVsa93KKF6llT2KBo6V8Vx4XxjmGG6U5oUS_SX1S3bnHPqepv9izstL2Stlz8_\"\n            \"UwxqVER1aotgywX1ez70YGA37Ikr6gO9LPKCYVQtcRG7P597mka0STnYFf6arOF0DUC_hyWYLjwoiTj9QVg9JPqMuxSo8JFTpkGeNQf6slLiYc9WDd4J-\"\n            \"QfFmSZBBguWmxq3ch_sg9YfPlBXir5oCVu3GDTZX2oH1h5gGwWHCgqM8qv2fsQoLwAZR9EhThb6zi1u12WxyLlwApw5O32GiJpOj1bWr-_\"\n            \"69Lo4Mpc66EYdmoKDXl4qmp6b0yhCUVS9e1Miu0vsXFq2NJwP4HUUnN_FojhS1F5EYOSW8ue1K3ESyqVrKKoF5sVqGJZESiveiR5ypVpmAOSfmZltJ-\"\n            \"GVO5cOcGKvtYG4PQz_wN7T_I0g9XWP9hBW5G0BZTR-rvT8mwobLT2ijFA_5TMkRualT2NzAttEbx7ThGwEJoU3-2k3_hqykZtfQv7KxwwYdezVsxV-\"\n            \"ukbMfzrOsOU517tIZ9wNdf1BV4c1sINlWfllAi9Sm54KqoLyqTtzvtM54InuknS4H-mEMMK3J7geH3GKpuAz-RUiim6OKihuOJvKSsyLxRL32u-\"\n            \"HnszlczfShAOfWA_1nfWzRYzVxtqfv3PXPQguF8A4-VhE_YSPQc6Bnwh_LzliqA-8Vk5WZiAwDN_\"\n            \"WybhPmZg5UnwVh5x7tnBPq82HSuCU4uefjaLBfjYnfRul2UY86HlHlpXVgyZEAvhRFPQwklqcfmlf3lCFz-g6P9wKYj0uncG3T9NUs28Oksy-\"\n            \"o9MdC3aekP-0LszrxQbfwps0nq45dVsnURJCGyT7vwCObUTPDGFCMg.B4xpiaoieUnluhz5U4ivTg\",\n            \"AAAA.BBBB.CCCC.DDDD\",\n            \"AAAA.BBBB.CCCC\",\n            \"AAAA.BBBB\",\n            \"AAAA\",\n            \"\",\n            \"....\",\n            \"this test is dedicated to swhitsel\",\n            NULL };\n\n    for (int i = 0; NULL != JWE_BAD[i]; ++i)\n    {\n        cjose_jwe_t *jwe = cjose_jwe_import(JWE_BAD[i], strlen(JWE_BAD[i]), &err);\n        ck_assert_msg(NULL == jwe, \"cjose_jwe_import of bad JWE succeeded (%d)\", i);\n        ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_import returned wrong err.code\");\n    }\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_bad_params)\n{\n    cjose_err err;\n    size_t len = 0;\n\n    // some bad keys to test with\n    static const char *JWK_BAD[] = {\n\n        // missing private part 'd' needed for encryption\n        \"{ \\\"kty\\\": \\\"RSA\\\", \"\n        \"\\\"e\\\": \\\"AQAB\\\", \"\n        \"\\\"n\\\": \"\n        \"\\\"0a5nKJLjaB1xdebYWfhvlhYhgfzkw49HAUIjyvb6fNPKhwlBQMoAS5jM3kI17_OMGrHxL7ZP00OE-24__\"\n        \"VWDCAhOQsSvlgCvw2XOOCtSWWLpb03dTrCMFeemqS4S9jrKd3NbUk3UJ2dVb_EIbQEC_BVjZStr_\"\n        \"HcCrKsj4AluaQUn09H7TuK0yZFBzZMhJ1J8Yi3nAPkxzdGah0XuWhLObMAvANSVmHzRXwnTDw9Dh_\"\n        \"bJ4G1xd1DE7W94uoUlcSDx59aSdzTpQzJh1l3lXc6JRUrXTESYgHpMv0O1n0gbIxX8X1ityBlMiccDjfZIKLnwz6hQObvRtRIpxEdq4SYS-w\\\", \"\n        \"\\\"kid\\\": \\\"9ebf9edb-3a24-48b4-b2cb-21f0cf747ea7\\\" }\",\n\n        // currently unsupported key type (EC)\n        \"{ \\\"kty\\\": \\\"EC\\\", \\\"crv\\\": \\\"P-256\\\", \"\n        \"\\\"x\\\": \\\"VoFkf6Wk5kDQ1ob6csBmiMPHU8jALwdtaap35Fsj20M\\\", \"\n        \"\\\"y\\\": \\\"XymwN6u2PmsKbIPy5iij6qZ-mIyej5dvZWB_75lnRgQ\\\", \"\n        \"\\\"kid\\\": \\\"4E34BAFD-E5D9-479C-964D-009C419C38DB\\\" }\",\n\n        NULL\n    };\n\n    // import the common key\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_RSA, strlen(JWK_RSA), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the jwe created with the common key\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA, strlen(JWE_RSA), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // try to decrypt a NULL jwe\n    ck_assert_msg(!cjose_jwe_decrypt(NULL, jwk, &len, &err), \"cjose_jwe_decrypt succeeded with NULL jwe\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_decrypt returned wrong err.code\");\n\n    // try to decrypt with a NULL jwk\n    ck_assert_msg(!cjose_jwe_decrypt(jwe, NULL, &len, &err), \"cjose_jwe_decrypt succeeded with NULL jwk\");\n    ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_decrypt returned wrong err.code\");\n\n    // try to decrypt with bad/wrong/unsupported keys\n    for (int i = 0; NULL != JWK_BAD[i]; ++i)\n    {\n        cjose_jwk_t *jwk_bad = cjose_jwk_import(JWK_BAD[i], strlen(JWK_BAD[i]), &err);\n        ck_assert_msg(NULL != jwk_bad, \"cjose_jwk_import failed\");\n\n        ck_assert_msg(!cjose_jwe_decrypt(jwe, NULL, &len, &err), \"cjose_jwe_decrypt succeeded with bad jwk\");\n        ck_assert_msg(err.code == CJOSE_ERR_INVALID_ARG, \"cjose_jwe_decrypt returned wrong err.code\");\n\n        cjose_jwk_release(jwk_bad);\n    }\n\n    cjose_jwe_release(jwe);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_aes)\n{\n    // https://tools.ietf.org/html/rfc7516#appendix-A.3\n    // JWE Using AES Key Wrap and AES_128_CBC_HMAC_SHA_256\n    static const char *JWK_S = \"{\\\"kty\\\":\\\"oct\\\", \\\"k\\\":\\\"GawgguFyGrWKav7AX4VKUg\\\"}\";\n    static const char *JWE_S = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                               \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                               \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                               \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                               \"U0m_YmjN04DJvceFICbCVQ\";\n    static const char *PLAINTEXT_S = \"Live long and prosper.\";\n\n    cjose_err err;\n\n    // import the JWK\n    cjose_jwk_t *jwk = cjose_jwk_import(JWK_S, strlen(JWK_S), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // import the JWE\n    cjose_jwe_t *jwe = cjose_jwe_import(JWE_S, strlen(JWE_S), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain1_len = 0;\n    uint8_t *plain1 = cjose_jwe_decrypt(jwe, jwk, &plain1_len, &err);\n    ck_assert_msg(NULL != plain1,\n                  \"cjose_jwe_get_plaintext failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // confirm plain == PLAINTEXT_S\n    ck_assert_msg(plain1_len == strlen(PLAINTEXT_S),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(PLAINTEXT_S), plain1_len);\n    ck_assert_msg(strncmp(PLAINTEXT_S, plain1, plain1_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain1);\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_AT = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                         \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                         \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                         \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                         \"U0m_YmjN04DJvceFICbCVq\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_AT, strlen(JWE_TAMPERED_AT), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain2_len = 0;\n    uint8_t *plain2 = cjose_jwe_decrypt(jwe, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL == plain2, \"cjose_jwe_get_plaintext succeeded for tampered authentication tag\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_CIPHERTEXT = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                                 \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                                 \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                                 \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGy.\"\n                                                 \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_CIPHERTEXT, strlen(JWE_TAMPERED_CIPHERTEXT), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain3_len = 0;\n    uint8_t *plain3 = cjose_jwe_decrypt(jwe, jwk, &plain3_len, &err);\n    ck_assert_msg(NULL == plain3, \"cjose_jwe_get_plaintext succeeded for tampered ciphertext\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_IV = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                         \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                         \"AxY8DCtDaGlsbGljb3RoZq.\"\n                                         \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                         \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_IV, strlen(JWE_TAMPERED_IV), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain4_len = 0;\n    uint8_t *plain4 = cjose_jwe_decrypt(jwe, jwk, &plain4_len, &err);\n    ck_assert_msg(NULL == plain4, \"cjose_jwe_get_plaintext succeeded for tampered IV\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_CEK = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n                                          \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOq.\"\n                                          \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                          \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                          \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_CEK, strlen(JWE_TAMPERED_CEK), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain5_len = 0;\n    uint8_t *plain5 = cjose_jwe_decrypt(jwe, jwk, &plain5_len, &err);\n    ck_assert_msg(NULL == plain5, \"cjose_jwe_get_plaintext succeeded for tampered content encryption key\");\n\n    cjose_jwe_release(jwe);\n\n    static const char *JWE_TAMPERED_HDR = \"eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2IiB9.\"\n                                          \"6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.\"\n                                          \"AxY8DCtDaGlsbGljb3RoZQ.\"\n                                          \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n                                          \"U0m_YmjN04DJvceFICbCVQ\";\n\n    // import the JWE\n    jwe = cjose_jwe_import(JWE_TAMPERED_HDR, strlen(JWE_TAMPERED_HDR), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    // decrypt the imported JWE\n    size_t plain6_len = 0;\n    uint8_t *plain6 = cjose_jwe_decrypt(jwe, jwk, &plain6_len, &err);\n    ck_assert_msg(NULL == plain6, \"cjose_jwe_get_plaintext succeeded for tampered header\");\n\n    cjose_jwe_release(jwe);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_aes_gcm)\n{\n    cjose_err err;\n\n    const char *key = JWK_OCT_32;\n    const char *plain1 = \"Live long and prosper.\";\n    char *compact1 = \"eyJhbGciOiAiZGlyIiwgImVuYyI6ICJBMjU2R0NNIn0..Du_9fxxV-zrReaWC.aS_rpokeuxkaPc2sykcQDCQuJCYoww.GpeKGEqd8KQ0v6JNea5aSA\";\n    char *compact2 = \"eyJhbGciOiAiZGlyIiwgImVuYyI6ICJBMjU2R0NNIn0..Du_9fxxV-zrReaWC.aS_rpokeuxkaPc2sykcQDCQuJCYoww.Gp\";\n\n    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n    ck_assert_msg(NULL != jwk,\n                  \"cjose_jwk_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    cjose_jwe_t *jwe1 = cjose_jwe_import(compact1, strlen(compact1), &err);\n    ck_assert_msg(NULL != jwe1,\n                  \"cjose_jwe_import failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    uint8_t *plain2 = NULL;\n    size_t plain2_len = 0;\n    plain2 = cjose_jwe_decrypt(jwe1, jwk, &plain2_len, &err);\n    ck_assert_msg(NULL != plain2,\n                  \"cjose_jwe_decrypt failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    ck_assert_msg(plain2_len == strlen(plain1),\n                  \"length of decrypted plaintext does not match length of original, \"\n                  \"expected: %lu, found: %lu\",\n                  strlen(plain1), plain2_len);\n    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n\n    cjose_get_dealloc()(plain2);\n    cjose_jwe_release(jwe1);\n\n    cjose_jwe_t *jwe2 = cjose_jwe_import(compact2, strlen(compact2), &err);\n    ck_assert_msg(NULL != jwe2,\n                   \"cjose_jwe_import failed: \"\n                   \"%s, file: %s, function: %s, line: %ld\",\n                   err.message, err.file, err.function, err.line);\n\n    uint8_t *plain3 = NULL;\n    size_t plain3_len = 0;\n    plain3 = cjose_jwe_decrypt(jwe2, jwk, &plain3_len, &err);\n    ck_assert_msg(NULL == plain3,\n                   \"cjose_jwe_decrypt succeeded where it should have failed: \"\n                   \"%s, file: %s, function: %s, line: %ld\",\n                   err.message, err.file, err.function, err.line);\n\n    cjose_jwe_release(jwe2);\n    cjose_jwk_release(jwk);\n}\nEND_TEST\n\nSTART_TEST(test_cjose_jwe_decrypt_rsa)\n{\n    struct cjose_jwe_decrypt_rsa\n    {\n        const char *jwe;\n        const char *plaintext;\n        const char *jwk;\n    };\n\n    static const struct cjose_jwe_decrypt_rsa JWE_RSA[] = {\n\n        // https://tools.ietf.org/html/rfc7516#appendix-A.1\n        // JWE using RSAES-OAEP and AES GCM\n        { \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkEyNTZHQ00ifQ.\"\n          \"OKOawDo13gRp2ojaHV7LFpZcgV7T6DVZKTyKOMTYUmKoTCVJRgckCL9kiMT03JGe\"\n          \"ipsEdY3mx_etLbbWSrFr05kLzcSr4qKAq7YN7e9jwQRb23nfa6c9d-StnImGyFDb\"\n          \"Sv04uVuxIp5Zms1gNxKKK2Da14B8S4rzVRltdYwam_lDp5XnZAYpQdb76FdIKLaV\"\n          \"mqgfwX7XWRxv2322i-vDxRfqNzo_tETKzpVLzfiwQyeyPGLBIO56YJ7eObdv0je8\"\n          \"1860ppamavo35UgoRdbYaBcoh9QcfylQr66oc6vFWXRcZ_ZT2LawVCWTIy3brGPi\"\n          \"6UklfCpIMfIjf7iGdXKHzg.\"\n          \"48V1_ALb6US04U3b.\"\n          \"5eym8TW_c8SuK0ltJ3rpYIzOeDQz7TALvtu6UG9oMo4vpzs9tX_EFShS8iB7j6ji\"\n          \"SdiwkIr3ajwQzaBtQD_A.\"\n          \"XFBoMYUZodetZdvTiFvSkQ\",\n\n          \"The true sign of intelligence is not knowledge but imagination.\",\n\n          \"{\\\"kty\\\":\\\"RSA\\\",\"\n          \"\\\"n\\\":\\\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUW\"\n          \"cJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3S\"\n          \"psk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2a\"\n          \"sbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMS\"\n          \"tPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2dj\"\n          \"YgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\\\",\"\n          \"\\\"e\\\":\\\"AQAB\\\",\"\n          \"\\\"d\\\":\\\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5N\"\n          \"WV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD9\"\n          \"3Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghk\"\n          \"qDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vl\"\n          \"t3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSnd\"\n          \"VTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\\\",\"\n          \"\\\"p\\\":\\\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-\"\n          \"SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lf\"\n          \"fNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\\\",\"\n          \"\\\"q\\\":\\\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBm\"\n          \"UDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aX\"\n          \"IWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\\\",\"\n          \"\\\"dp\\\":\\\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KL\"\n          \"hMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827\"\n          \"rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\\\",\"\n          \"\\\"dq\\\":\\\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCj\"\n          \"ywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDB\"\n          \"UfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\\\",\"\n          \"\\\"qi\\\":\\\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7\"\n          \"AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3\"\n          \"eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\\\" }\" },\n\n        // https://tools.ietf.org/html/rfc7516#appendix-A.2\n        // JWE using RSAES-PKCS1-v1_5 and AES_128_CBC_HMAC_SHA_256\n        { \"eyJhbGciOiJSU0ExXzUiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.\"\n          \"UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-kFm\"\n          \"1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKxGHZ7Pc\"\n          \"HALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3YvkkysZIF\"\n          \"NPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPhcCdZ6XDP0_F8\"\n          \"rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPgwCp6X-nZZd9OHBv\"\n          \"-B3oWh2TbqmScqXMR4gp_A.\"\n          \"AxY8DCtDaGlsbGljb3RoZQ.\"\n          \"KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.\"\n          \"9hH0vgRfYgPnAHOd8stkvw\",\n\n          \"Live long and prosper.\",\n\n          \"{\\\"kty\\\":\\\"RSA\\\",\"\n          \"\\\"n\\\":\\\"sXchDaQebHnPiGvyDOAT4saGEUetSyo9MKLOoWFsueri23bOdgWp4Dy1Wl\"\n          \"UzewbgBHod5pcM9H95GQRV3JDXboIRROSBigeC5yjU1hGzHHyXss8UDpre\"\n          \"cbAYxknTcQkhslANGRUZmdTOQ5qTRsLAt6BTYuyvVRdhS8exSZEy_c4gs_\"\n          \"7svlJJQ4H9_NxsiIoLwAEk7-Q3UXERGYw_75IDrGA84-lA_-Ct4eTlXHBI\"\n          \"Y2EaV7t7LjJaynVJCpkv4LKjTTAumiGUIuQhrNhZLuF_RJLqHpM2kgWFLU\"\n          \"7-VTdL1VbC2tejvcI2BlMkEpk1BzBZI0KQB0GaDWFLN-aEAw3vRw\\\",\"\n          \"\\\"e\\\":\\\"AQAB\\\",\"\n          \"\\\"d\\\":\\\"VFCWOqXr8nvZNyaaJLXdnNPXZKRaWCjkU5Q2egQQpTBMwhprMzWzpR8Sxq\"\n          \"1OPThh_J6MUD8Z35wky9b8eEO0pwNS8xlh1lOFRRBoNqDIKVOku0aZb-ry\"\n          \"nq8cxjDTLZQ6Fz7jSjR1Klop-YKaUHc9GsEofQqYruPhzSA-QgajZGPbE_\"\n          \"0ZaVDJHfyd7UUBUKunFMScbflYAAOYJqVIVwaYR5zWEEceUjNnTNo_CVSj\"\n          \"-VvXLO5VZfCUAVLgW4dpf1SrtZjSt34YLsRarSb127reG_DUwg9Ch-Kyvj\"\n          \"T1SkHgUWRVGcyly7uvVGRSDwsXypdrNinPA4jlhoNdizK2zF2CWQ\\\",\"\n          \"\\\"p\\\":\\\"9gY2w6I6S6L0juEKsbeDAwpd9WMfgqFoeA9vEyEUuk4kLwBKcoe1x4HG68\"\n          \"ik918hdDSE9vDQSccA3xXHOAFOPJ8R9EeIAbTi1VwBYnbTp87X-xcPWlEP\"\n          \"krdoUKW60tgs1aNd_Nnc9LEVVPMS390zbFxt8TN_biaBgelNgbC95sM\\\",\"\n          \"\\\"q\\\":\\\"uKlCKvKv_ZJMVcdIs5vVSU_6cPtYI1ljWytExV_skstvRSNi9r66jdd9-y\"\n          \"BhVfuG4shsp2j7rGnIio901RBeHo6TPKWVVykPu1iYhQXw1jIABfw-MVsN\"\n          \"-3bQ76WLdt2SDxsHs7q7zPyUyHXmps7ycZ5c72wGkUwNOjYelmkiNS0\\\",\"\n          \"\\\"dp\\\":\\\"w0kZbV63cVRvVX6yk3C8cMxo2qCM4Y8nsq1lmMSYhG4EcL6FWbX5h9yuv\"\n          \"ngs4iLEFk6eALoUS4vIWEwcL4txw9LsWH_zKI-hwoReoP77cOdSL4AVcra\"\n          \"Hawlkpyd2TWjE5evgbhWtOxnZee3cXJBkAi64Ik6jZxbvk-RR3pEhnCs\\\",\"\n          \"\\\"dq\\\":\\\"o_8V14SezckO6CNLKs_btPdFiO9_kC1DsuUTd2LAfIIVeMZ7jn1Gus_Ff\"\n          \"7B7IVx3p5KuBGOVF8L-qifLb6nQnLysgHDh132NDioZkhH7mI7hPG-PYE_\"\n          \"odApKdnqECHWw0J-F0JWnUd6D2B_1TvF9mXA2Qx-iGYn8OVV1Bsmp6qU\\\",\"\n          \"\\\"qi\\\":\\\"eNho5yRBEBxhGBtQRww9QirZsB66TrfFReG_CcteI1aCneT0ELGhYlRlC\"\n          \"tUkTRclIfuEPmNsNDPbLoLqqCVznFbvdB7x-Tl-m0l_eFTj2KiqwGqE9PZ\"\n          \"B9nNTwMVvH3VRRSLWACvPnSiwP8N5Usy-WRXS-V7TbpxIhvepTfE0NNo\\\" }\" },\n\n        { NULL, NULL, NULL }\n    };\n\n    for (int i = 0; NULL != JWE_RSA[i].jwe; ++i)\n    {\n        cjose_err err;\n\n        // import the JWK\n        cjose_jwk_t *jwk = cjose_jwk_import(JWE_RSA[i].jwk, strlen(JWE_RSA[i].jwk), &err);\n        ck_assert_msg(NULL != jwk,\n                      \"cjose_jwk_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        // import the JWE\n        cjose_jwe_t *jwe = cjose_jwe_import(JWE_RSA[i].jwe, strlen(JWE_RSA[i].jwe), &err);\n        ck_assert_msg(NULL != jwe,\n                      \"cjose_jwe_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        // decrypt the imported JWE\n        size_t plain1_len = 0;\n        uint8_t *plain1 = cjose_jwe_decrypt(jwe, jwk, &plain1_len, &err);\n        ck_assert_msg(NULL != plain1,\n                      \"cjose_jwe_get_plaintext failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        // confirm plain == PLAINTEXT_S\n        ck_assert_msg(plain1_len == strlen(JWE_RSA[i].plaintext),\n                      \"length of decrypted plaintext does not match length of original, \"\n                      \"expected: %lu, found: %lu\",\n                      strlen(JWE_RSA[i].plaintext), plain1_len);\n        ck_assert_msg(strncmp(JWE_RSA[i].plaintext, plain1, plain1_len) == 0,\n                      \"decrypted plaintext does not match encrypted plaintext\");\n\n        cjose_get_dealloc()(plain1);\n        cjose_jwe_release(jwe);\n        cjose_jwk_release(jwk);\n    }\n}\nEND_TEST\n\nstatic void _cjose_test_json_serial(const char *json, const char *match_json, cjose_jwe_recipient_t *rec)\n{\n\n    cjose_jwe_t *jwe;\n    cjose_err err;\n\n    jwe = cjose_jwe_import_json(json, strlen(json), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to import multi-recipient json: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    size_t decoded_len;\n    char *decoded = cjose_jwe_decrypt_multi(jwe, cjose_multi_key_locator, rec, &decoded_len, &err);\n    ck_assert_msg(NULL != decoded,\n                  \"failed to decrypt for multiple recipients: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg(memcmp(decoded, PLAINTEXT, decoded_len) == 0 && decoded_len == strlen(PLAINTEXT) + 1,\n                  \"decrypted plaintext does not match\");\n    cjose_get_dealloc()(decoded);\n\n    decoded = cjose_jwe_export_json(jwe, &err);\n    ck_assert_msg(NULL != decoded,\n                  \"failed to serialize JWE into json: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg(strcmp(decoded, match_json) == 0, \"serialized json doesn't match expectation\");\n\n    cjose_get_dealloc()(decoded);\n\n    cjose_jwe_release(jwe);\n}\n\nstatic void _cjose_test_empty_headers(cjose_jwk_t *key)\n{\n\n    cjose_jwe_t *jwe;\n    cjose_err err;\n    cjose_header_t *hdr;\n\n    // regression test - if we created json without unprotected headers, we must\n    // be able to read it back.\n\n    hdr = cjose_header_new(&err);\n    cjose_header_set(hdr, CJOSE_HDR_ALG, CJOSE_HDR_ALG_RSA_OAEP, &err);\n    cjose_header_set(hdr, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256CBC_HS512, &err);\n\n    cjose_jwe_recipient_t rec = { .jwk = (const cjose_jwk_t *)key, .unprotected_header = 0 };\n\n    jwe = cjose_jwe_encrypt_multi(&rec, 1, hdr, 0, (uint8_t *)\"\", 1, &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to encrypt test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    char *json = cjose_jwe_export_json(jwe, &err);\n    ck_assert_msg(NULL != json,\n                  \"failed to serialize test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    cjose_jwe_release(jwe);\n    cjose_header_release(hdr);\n\n    // import the json back\n\n    jwe = cjose_jwe_import_json(json, strlen(json), &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to import test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    size_t len;\n    char *test = (char *)cjose_jwe_decrypt(jwe, key, &len, &err);\n    ck_assert_msg(NULL != test,\n                  \"failed to decrypt test data: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg((len == 1) && (*test == 0), \"Decrypted data does not match original\");\n\n    free(test);\n    free(json);\n    cjose_jwe_release(jwe);\n}\n\nSTART_TEST(test_cjose_jwe_multiple_recipients)\n{\n\n    char *rsa[] = { \"{\\\"kty\\\":\\\"RSA\\\",\\\"e\\\":\\\"AQAB\\\",\\\"n\\\":\\\"pXldOFJS1PKXlkkkcCKtBt6efl84jkZinEzVF1HcksvO_b\"\n                    \"QUFJbUPcZwyzKk8fYnGbu0LwnY3hhCSDk-Ki8S2h_8VOiR7AY2ptI_TjeGp0DDqSnmJEdDrwIbw0yGTgOHZ63xms0aE4\"\n                    \"fv9tdrw5U4v_A3AfOwUtCyxuyZP_7WlNj0sMsWwiyp0BGvCUB4xuhVtsEsbSWvSAO8CYHEy3fVGZ6bLXh7DbF7WlbfZ9K\"\n                    \"bZCiLhP4RAmNtBQQ8jYpzTedr6qGvAz8TNl7mSfG7aQk465xCHOCrk0TLrHMDI1G4ZaFAkhXeg-KsoC8C1Mktaz3zLZwam_\"\n                    \"ZsMHyl5UNxl4MzZQ\\\",\\\"d\\\":\\\"Zgss2JGz8QxVPOGILfrEVysr9GSGPP7cyuR6uHHMI166HCxUAcptwlbAsh5eJ7STskPVv\"\n                    \"vhEm9m77kwWsO7sokT9V-NAMZw3UbLwRSzqxfOjdYuYGCE2dRNIyaxEWpHEi8Rx7PO0s_ytl7yLAUbhg0QAuBxuTPPUe-XmL\"\n                    \"9fYvlr6mxbA0Pxtr_ZcisDOL5gUWhpb-rWzIUH_G9519J_Th7z9_C5v3q88UiA7VomBiMg8TKz23GKsG4TPmGnAW7ctHKP\"\n                    \"2b3xl6b868IuPOr1YqqlnOCh6T9-mKuOlCMcU89UR5TTgRn0HoRQBumbw3qYGn8YbxcW38jbR9imKTcbrPQ\\\",\\\"\"\n                    \"p\\\":\\\"1v7ar4cL2Jh0h9DigLcyC1F8-MlDKtDzrqhpJsk49aYoc4vsdsBYUQCKbnarxhmItbLMq178p8nu31qSYXhkg0D-YeL\"\n                    \"o3RIbLqfC1HElVp6E3U41L7AGSjg6WdwInfqwfRfiCNNPKKtb-gHbtEP54PezqdcIXfjSlFim1vBmCA0\\\",\\\"\"\n                    \"q\\\":\\\"xQigtlXLQX8J93V_PK2ZRGvTAFHDTZkJ-1CUPphOXZNezvMzEgv4tPsHJPUZU_muFjwlEs17qGO8xaZlfU-ohD13h\"\n                    \"kpVh_xqJj6Cl5kOVXIW6COE_M6dGGJDzCIiXurN3QjQXututMlhO-anmRspaI3v6vby2JXjZIdJqpm6ark\\\",\"\n                    \"\\\"dp\\\":\\\"C4VswqtB_0FsPTr8aFlo3SJoyAxBBTJdXKa5u9Jcsw1MbaS570MveGfHA1RosBz-Ln5-aVCVyYgQvPdlkMO\"\n                    \"a303EVAqM4AvwWPe0gR3vGk00YYenYf7U13Vb6yTXcV_VxV5aRo7MVymXrDYdR_O8mEmt3xQe5qpG3pxBlJMdZKE\\\",\"\n                    \"\\\"dq\\\":\\\"nIyBXL4H868jVRlnEegAeeuNx5gvK-1nj-VzE9Thltnrn1R-BF28qtc00vlmuWENH5-D-U-Ia79rEkNmKc1r4\"\n                    \"D4SRIG1OYmlMWPDUP4L9Hnkl2b5WAA1s1UH9x473tyC2pcRMAmxeTTz66sVCMIbAXac5Dx3sPxOouYW8tSX2Ak\\\",\"\n                    \"\\\"qi\\\":\\\"PphvSiKY95wBif4o2AUOxk9p7v2KdMZ9FY92v-moGML8k5_Gy7xHYUIzoeGGwzp_4V4kI1zTct76K-Q\"\n                    \"zDebf2wv1_v4AKFjcAUleEpDVVnGPQ3-ftftkc0UFmkoKorHLZ5Q5ZjKxa313V1pYQwbdra54xabl7LvPStYJ3asw2Yc\\\"}\",\n\n                    \"{\\\"kty\\\":\\\"RSA\\\",\\\"e\\\":\\\"AQAB\\\",\\\"n\\\":\\\"zi97QZsWWOkQ1x1gnZvcJPh1jse60KxJMHruvWI0D3klI3_\"\n                    \"29gamVgkdl9M0_t0OCq0PZZB2jzXp7b7M07sYg6MEyjOQ61KznN-fEm1QKjXznIUQghOll5u04Tjmm8dXtWNV6on2LpsN1\"\n                    \"J9hz3088ekOaYwdTntx2fZPDRmxYOBJOoX9sswW6iL-PrFCcLtwcpsyJsU_A9Am7whHQSS2dmzM5ruz7P6d9NDwlPhGLXV\"\n                    \"qRYlPc1kr3_vzwLDI8Yo1GUEzdEQ2HWWP7dL2ySl8s8ExoUTcl8AKT5w805ZmpfmhK1mxixFpbCTvJX3WPo3GWJ614XO6\"\n                    \"lZZRoh5ypt0Rsw\\\",\"\n                    \"\\\"d\\\":\\\"vpmIAFrEasZwydqfYLMe65I-4hFicdqCAe3yWmG4rIEZwtpdSotVIn1kvOACwoNIorfeXs4Pu01khWF26Vew\"\n                    \"TqfZGq5WjiMyZJcX7qncjFi5bXxYiVZuIltO91BpZaH-Q3CjkJ-eUvEE9QOtIGiueRYvO4TJ5q4YzhtycjLJFTo3vIDX\"\n                    \"woOb4R4TW5qtSlzg0baW4qEyMzqiink9kT6OvXwt6FC6RMquLlPtOYzr5KvoaBf-qbBUU9L5M9bfmPUjgk_Suz9QLYOgE\"\n                    \"ZDxUj0jyJiXgCnjidqd094iCHpBIevByfhLJmBqjIlPAZ9O1svHeA0jpE73E6ZZyKDOES3qgQ\\\",\"\n                    \"\\\"p\\\":\\\"6oIBg20lS5YIESnUM7SpGLaWCMem-c-IRolnN6gRLHkpb_mudUhO-RuQNYUzB8we5dmBkVyJxR2W4J79rFj\"\n                    \"bmilUO_8NcGYvGPYM_rOzPIP02Sltaea_vrNr-dS6-Q-lICL6845E8VeTBKRRKRr-uf-AWZfrr-ncNZaTuqa9rsE\\\",\"\n                    \"\\\"q\\\":\\\"4RT608xr6KN1Q2uj9ADXu5ZY3k1-Lf7RrtwXO-5U56777Ww7POvZi5EZoySEgWeBA426Ty5QIm0oqClCSlS0s\"\n                    \"CkYwrno0zEePsvJ9nb0BHRi_x1NVL_1iuL0dy3g5LgThhvaoMTQwiSNRRFveQhRYgB89eHIHxPw_FYSFl780XM\\\",\"\n                    \"\\\"dp\\\":\\\"rPrUzvM1rXmv3akzJCjBCr-0ECnlWyPga9dy0bUhZeLB1B0iuNRrnIjeaPwl1jyVFgrI7kaKQWJAJtRgXj\"\n                    \"71TdPqlI7ghOZ7Gzh0AXTgY2UauQ077gANtEd5AEIQ4SLPNNNYtUteQ3_LrILgcye8ecqkDHJpocspakX2FppkFIE\\\",\"\n                    \"\\\"dq\\\":\\\"hgBAiGG2iKzv_jCSTo1F4pdS1x5ZlbaUTT8Y0gRFJh3GPIZoCg_71xyOn9L41DWz2FLDbaqL6MMGJn9RyQD\"\n                    \"_BbWh2SRnWXxvnkEjPwl4o0JLQcjHJkKWQ5Z0ppN4xZJVhU0F7xrdkgfC1zDXJb5u_SJ_Qr-lreLoYMI5SHpKl8M\\\",\"\n                    \"\\\"qi\\\":\\\"Boxvcq8bIswXo8BPCcZurLjacS0TlUzbs2mLJD3noJKd361fgGoO2XdG94bqkbGg-5wbGDZL2YqGKlA2Y\"\n                    \"j8yU8ZiULaLsm3HadNVxkLTy90j59urbf0MSnMkljACZUfH2yfxVbzgZd0DWS7eDtMBP4VrQ_tQmR_djRaLOMh5yxg\\\"}\" };\n\n    char *multi_json\n        = \"{\\\"protected\\\": \\\"eyJlbmMiOiAiQTI1NkdDTSJ9\\\", \\\"iv\\\": \\\"cGHj6gmN4kC0cLTh\\\", \\\"ciphertext\\\": \"\n          \"\\\"ffgBXOZoYfCxPrbXXe4qOK0bll4F74wo3qGObUqllCdM6Vp4SyOagnFDUFMAwSA_-vVCYW37dJIBOExDQgGK0Q48cVKfiTQ5R6iKIFs6Fkc6FfXfTNKa_\"\n          \"M46Ay66lY3kFHGqWMtS6DcQs9nYltUf8uo0hEsUl1D1eA\\\", \\\"tag\\\": \\\"5LF0d_O23WKHq4c1ijaJqg\\\", \\\"recipients\\\": [{\\\"header\\\": \"\n          \"{\\\"kid\\\": \\\"test-0\\\", \\\"alg\\\": \\\"RSA-OAEP\\\"}, \\\"encrypted_key\\\": \"\n          \"\\\"hfrpxvv57nnZKJ5Whic5nEvMp2Iob5JSkht25fGRbRBj3Q9_hgbCKiMV10sSX5qVLwIsfdfSYH3QvvsI_aPV4qB326cp7SuHDgvqdKnQs-\"\n          \"qDwHrg7Erc9tJFjpR-t_VfnV8wZvEP92xvCaZ4-kx86718Op2Gb82M7ojaHufwoxN_\"\n          \"Al5oNrBNZgLZgvKROT7HmvlxHSCr0XamI8txtOt7pawZ4ENqVc1VKGYu7il-h4htMvYT7Ix0OSBWoAG1NxW-tqcD75dR_\"\n          \"SEmPkgbeC8ofbulq1lL22PLAQzpi1Op69tOIvBQ3j0JZDOUpSQajYNAyZdD26BHV_STVb-hkUCFmA\\\"}, {\\\"header\\\": {\\\"kid\\\": \\\"test-1\\\", \"\n          \"\\\"alg\\\": \\\"RSA1_5\\\"}, \\\"encrypted_key\\\": \"\n          \"\\\"Hro4KVp4KfI-7NBtAPJ67N9Oas0RrU8qs01o6fOGiVtAO9yvfvzmC6dSYOAmrhMfASm5EI3K_miQT40agyRUC5wpfV6x5NKTFaJRgGJeF5xdQyE_\"\n          \"fVNthG67GLcc-_LY5Shu2Jm5Ih1pSb4mRl6zOVBVw0HroPJLiMmRU3ai5YFLNp7M87igWHznkFWFljLONVcgV7QTJ4KDEhJUmasDqCpQ_kf5_\"\n          \"b5u4aNWqNv4FMMTgQ5XcfCVHOnYjhD3HkeqsWe4VnL3GFKBU96Lwtff-qzC55DLxtUKDrP5ZRdFKnxJX1t_X7DzgYQYxr19fx6Y-aXmflBAqIdN5-\"\n          \"OyENlWxQ\\\"}]}\";\n    char *single_json = \"{\\\"protected\\\":\\\"eyJlbmMiOiAiQTI1NkdDTSJ9\\\",\\\"iv\\\":\\\"cGHj6gmN4kC0cLTh\\\",\\\"ciphertext\\\":\"\n                        \"\\\"ffgBXOZoYfCxPrbXXe4qOK0bll4F74wo3qGObUqllCdM6Vp4SyOagnFDUFMAwSA_-\"\n                        \"vVCYW37dJIBOExDQgGK0Q48cVKfiTQ5R6iKIFs6Fkc6FfXfTNKa_M46Ay66lY3kFHGqWMtS6DcQs9nYltUf8uo0hEsUl1D1eA\\\",\"\n                        \"\\\"tag\\\":\\\"5LF0d_O23WKHq4c1ijaJqg\\\",\\\"recipients\\\":[{\\\"header\\\":{\\\"kid\\\":\\\"test-1\\\",\\\"alg\\\":\\\"RSA1_5\\\"},\"\n                        \"\\\"encrypted_key\\\":\\\"Hro4KVp4KfI-7NBtAPJ67N9Oas0RrU8qs01o6fOGiVtAO9yvfvzmC6dSYOAmrhMfASm5EI3K_\"\n                        \"miQT40agyRUC5wpfV6x5NKTFaJRgGJeF5xdQyE_fVNthG67GLcc-_\"\n                        \"LY5Shu2Jm5Ih1pSb4mRl6zOVBVw0HroPJLiMmRU3ai5YFLNp7M87igWHznkFWFljLONVcgV7QTJ4KDEhJUmasDqCpQ_kf5_\"\n                        \"b5u4aNWqNv4FMMTgQ5XcfCVHOnYjhD3HkeqsWe4VnL3GFKBU96Lwtff-qzC55DLxtUKDrP5ZRdFKnxJX1t_X7DzgYQYxr19fx6Y-\"\n                        \"aXmflBAqIdN5-OyENlWxQ\\\"}]}\";\n    char *single_flat_json\n        = \"{\\\"protected\\\": \\\"eyJlbmMiOiAiQTI1NkdDTSJ9\\\", \\\"iv\\\": \\\"cGHj6gmN4kC0cLTh\\\", \\\"ciphertext\\\": \"\n          \"\\\"ffgBXOZoYfCxPrbXXe4qOK0bll4F74wo3qGObUqllCdM6Vp4SyOagnFDUFMAwSA_-vVCYW37dJIBOExDQgGK0Q48cVKfiTQ5R6iKIFs6Fkc6FfXfTNKa_\"\n          \"M46Ay66lY3kFHGqWMtS6DcQs9nYltUf8uo0hEsUl1D1eA\\\", \\\"tag\\\": \\\"5LF0d_O23WKHq4c1ijaJqg\\\", \\\"header\\\": {\\\"kid\\\": \\\"test-1\\\", \"\n          \"\\\"alg\\\": \\\"RSA1_5\\\"}, \\\"encrypted_key\\\": \"\n          \"\\\"Hro4KVp4KfI-7NBtAPJ67N9Oas0RrU8qs01o6fOGiVtAO9yvfvzmC6dSYOAmrhMfASm5EI3K_miQT40agyRUC5wpfV6x5NKTFaJRgGJeF5xdQyE_\"\n          \"fVNthG67GLcc-_LY5Shu2Jm5Ih1pSb4mRl6zOVBVw0HroPJLiMmRU3ai5YFLNp7M87igWHznkFWFljLONVcgV7QTJ4KDEhJUmasDqCpQ_kf5_\"\n          \"b5u4aNWqNv4FMMTgQ5XcfCVHOnYjhD3HkeqsWe4VnL3GFKBU96Lwtff-qzC55DLxtUKDrP5ZRdFKnxJX1t_X7DzgYQYxr19fx6Y-aXmflBAqIdN5-\"\n          \"OyENlWxQ\\\"}\";\n\n    const char *algs[2] = { CJOSE_HDR_ALG_RSA_OAEP, CJOSE_HDR_ALG_RSA1_5 };\n\n    cjose_err err;\n\n    cjose_jwe_recipient_t rec[2];\n\n    for (int i = 0; i < 2; i++)\n    {\n\n        char kid[32];\n\n        cjose_jwk_t *jwk = cjose_jwk_import(rsa[i], strlen(rsa[i]), &err);\n        ck_assert_msg(NULL != jwk,\n                      \"cjose_jwk_import failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        memset(kid, 0, 32);\n        snprintf(kid, 31, \"test-%d\", i);\n\n        ck_assert_msg(cjose_jwk_set_kid(jwk, kid, strlen(kid), &err),\n                      \"cjose_jwk_set_kid failed: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n\n        rec[i].jwk = jwk;\n\n        cjose_header_t *unprotected;\n\n        ck_assert_msg((unprotected = cjose_header_new(&err)) && cjose_header_set(unprotected, \"kid\", kid, &err)\n                          && cjose_header_set(unprotected, CJOSE_HDR_ALG, algs[i], &err),\n                      \"failed to set KID into a header: \"\n                      \"%s, file: %s, function: %s, line: %ld\",\n                      err.message, err.file, err.function, err.line);\n        rec[i].unprotected_header = unprotected;\n    }\n\n    cjose_header_t *protected_header = cjose_header_new(&err);\n\n    ck_assert_msg(cjose_header_set(protected_header, CJOSE_HDR_ENC, CJOSE_HDR_ENC_A256GCM, &err),\n                  \"cjose_header_set failed: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    cjose_jwe_t *jwe = cjose_jwe_encrypt_multi(rec, 2, protected_header, NULL, PLAINTEXT, strlen(PLAINTEXT) + 1, &err);\n    ck_assert_msg(NULL != jwe,\n                  \"failed to encrypt to multiple recipients:\"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n\n    size_t decoded_len;\n\n    CJOSE_ERROR(&err, CJOSE_ERR_NONE);\n    uint8_t *decoded = cjose_jwe_decrypt_multi(jwe, cjose_multi_key_locator_none, rec, &decoded_len, &err);\n    ck_assert_msg(NULL == decoded, \"did not expect to decode with selected key\");\n    ck_assert_msg(err.code == CJOSE_ERR_CRYPTO, \"expected error to be set to CRYPTO\");\n\n    decoded = cjose_jwe_decrypt_multi(jwe, cjose_multi_key_locator, rec, &decoded_len, &err);\n    ck_assert_msg(NULL != decoded,\n                  \"failed to decrypt for multiple recipients: \"\n                  \"%s, file: %s, function: %s, line: %ld\",\n                  err.message, err.file, err.function, err.line);\n    ck_assert_msg(memcmp(decoded, PLAINTEXT, decoded_len) == 0 && decoded_len == strlen(PLAINTEXT) + 1,\n                  \"decrypted plaintext does not match\");\n\n    char *ser = cjose_jwe_export(jwe, &err);\n    ck_assert_msg(ser == NULL && err.code == CJOSE_ERR_INVALID_ARG,\n                  \"succeeded in creating compact serialization for multiple recipients\");\n\n    cjose_jwe_release(jwe);\n    cjose_get_dealloc()(decoded);\n\n    _cjose_test_json_serial(multi_json, multi_json, rec);\n    _cjose_test_json_serial(single_json, single_flat_json, rec);\n    _cjose_test_json_serial(single_flat_json, single_flat_json, rec);\n    _cjose_test_empty_headers(rec[0].jwk);\n\n    for (int i = 0; i < 2; i++)\n    {\n        cjose_jwk_release(rec[i].jwk);\n        cjose_header_release(rec[i].unprotected_header);\n    }\n\n    cjose_header_release(protected_header);\n}\nEND_TEST\n\nSuite *cjose_jwe_suite()\n{\n    Suite *suite = suite_create(\"jwe\");\n\n    TCase *tc_jwe = tcase_create(\"core\");\n    tcase_set_timeout(tc_jwe, 120.0);\n    tcase_add_test(tc_jwe, test_cjose_jwe_node_jose_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_iv);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_short);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_empty);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_content);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_export_compare);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_invalid_serialization);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_bad_params);\n    tcase_add_test(tc_jwe, test_cjose_jwe_multiple_recipients);\n    suite_add_tcase(suite, tc_jwe);\n\n    return suite;\n}\n"], "filenames": ["src/jwe.c", "test/check_jwe.c"], "buggy_code_start_loc": [1288, 969], "buggy_code_end_loc": [1288, 1375], "fixing_code_start_loc": [1289, 970], "fixing_code_end_loc": [1295, 1434], "type": "CWE-327", "message": "OpenIDC/cjose is a C library implementing the Javascript Object Signing and Encryption (JOSE). The AES GCM decryption routine incorrectly uses the Tag length from the actual Authentication Tag provided in the JWE. The spec  says that a fixed length of 16 octets must be applied. Therefore this bug allows an attacker to provide a truncated Authentication Tag and to modify the JWE accordingly. Users should upgrade to a version >= 0.6.2.2. Users unable to upgrade should avoid using AES GCM encryption and replace it with another encryption algorithm (e.g. AES CBC).", "other": {"cve": {"id": "CVE-2023-37464", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-14T21:15:08.903", "lastModified": "2023-09-15T22:15:13.967", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "OpenIDC/cjose is a C library implementing the Javascript Object Signing and Encryption (JOSE). The AES GCM decryption routine incorrectly uses the Tag length from the actual Authentication Tag provided in the JWE. The spec  says that a fixed length of 16 octets must be applied. Therefore this bug allows an attacker to provide a truncated Authentication Tag and to modify the JWE accordingly. Users should upgrade to a version >= 0.6.2.2. Users unable to upgrade should avoid using AES GCM encryption and replace it with another encryption algorithm (e.g. AES CBC)."}, {"lang": "es", "value": "OpenIDC/cjose es una biblioteca C que implementa Javascript Object Signing and Encryption (JOSE). La rutina de descifrado AES GCM utiliza incorrectamente la longitud de la etiqueta de la etiqueta de autenticaci\u00f3n real proporcionada en el JWE. La especificaci\u00f3n dice que se debe aplicar una longitud fija de 16 octetos. Por lo tanto, este error permite a un atacante proporcionar una etiqueta de autenticaci\u00f3n truncada y modificar el JWE en consecuencia. Los usuarios deben actualizar a una versi\u00f3n &gt;= 0.6.2.2. Los usuarios que no puedan actualizar deben evitar el uso del cifrado AES GCM y reemplazarlo con otro algoritmo de cifrado (por ejemplo, AES CBC)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-327"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cisco:cjose:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.2.2", "matchCriteriaId": "03D82D74-C8C8-4602-933C-DD2940EF4E2C"}]}]}], "references": [{"url": "https://datatracker.ietf.org/doc/html/rfc7518#section-4.7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/OpenIDC/cjose/commit/7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenIDC/cjose/releases/tag/v0.6.2.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/OpenIDC/cjose/security/advisories/GHSA-3rhg-3gf2-6xgj", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/08/msg00002.html", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DFWAPMYYVBO2U65HPYDTBEKNSXG4TP5C/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LCQJXKDPCWCXB2V4JMQ3UWYJ4UIBPUW6/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTZHOVGY7AHGNMEY245HK4Q36AMA53AL/", "source": "security-advisories@github.com"}, {"url": "https://www.debian.org/security/2023/dsa-5472", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/OpenIDC/cjose/commit/7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e"}}