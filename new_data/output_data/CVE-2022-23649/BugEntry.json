{"buggy_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/sign\"\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\n// VerifyCommand verifies a signature on a supplied container image\n// nolint\ntype VerifyCommand struct {\n\toptions.RegistryOptions\n\tCheckClaims    bool\n\tKeyRef         string\n\tCertRef        string\n\tCertEmail      string\n\tCertOidcIssuer string\n\tSk             bool\n\tSlot           string\n\tOutput         string\n\tRekorURL       string\n\tAttachment     string\n\tAnnotations    sigs.AnnotationsMap\n\tSignatureRef   string\n\tHashAlgorithm  crypto.Hash\n\tLocalImage     bool\n}\n\n// Exec runs the verification command\nfunc (c *VerifyCommand) Exec(ctx context.Context, images []string) (err error) {\n\tif len(images) == 0 {\n\t\treturn flag.ErrHelp\n\t}\n\n\tswitch c.Attachment {\n\tcase \"sbom\", \"\":\n\t\tbreak\n\tdefault:\n\t\treturn flag.ErrHelp\n\t}\n\n\t// always default to sha256 if the algorithm hasn't been explicitly set\n\tif c.HashAlgorithm == 0 {\n\t\tc.HashAlgorithm = crypto.SHA256\n\t}\n\n\tif !options.OneOf(c.KeyRef, c.CertRef, c.Sk) && !options.EnableExperimental() {\n\t\treturn &options.KeyParseError{}\n\t}\n\tociremoteOpts, err := c.ClientOpts(ctx)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"constructing client options\")\n\t}\n\tco := &cosign.CheckOpts{\n\t\tAnnotations:        c.Annotations.Annotations,\n\t\tRegistryClientOpts: ociremoteOpts,\n\t\tCertEmail:          c.CertEmail,\n\t\tCertOidcIssuer:     c.CertOidcIssuer,\n\t\tSignatureRef:       c.SignatureRef,\n\t}\n\tif c.CheckClaims {\n\t\tco.ClaimVerifier = cosign.SimpleClaimVerifier\n\t}\n\tif options.EnableExperimental() {\n\t\tif c.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(c.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"creating Rekor client\")\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t\tco.RootCerts = fulcio.GetRoots()\n\t}\n\tkeyRef := c.KeyRef\n\tcertRef := c.CertRef\n\n\t// Keys are optional!\n\tvar pubKey signature.Verifier\n\tswitch {\n\tcase keyRef != \"\":\n\t\tpubKey, err = sigs.PublicKeyFromKeyRefWithHashAlgo(ctx, keyRef, c.HashAlgorithm)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"loading public key\")\n\t\t}\n\t\tpkcs11Key, ok := pubKey.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase c.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(c.Slot)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"opening piv token\")\n\t\t}\n\t\tdefer sk.Close()\n\t\tpubKey, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"initializing piv token verifier\")\n\t\t}\n\tcase certRef != \"\":\n\t\tcert, err := loadCertFromFileOrURL(c.CertRef)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpubKey, err = signature.LoadECDSAVerifier(cert.PublicKey.(*ecdsa.PublicKey), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tco.SigVerifier = pubKey\n\n\tfor _, img := range images {\n\t\tif c.LocalImage {\n\t\t\tverified, bundleVerified, err := cosign.VerifyLocalImageSignatures(ctx, img, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tPrintVerificationHeader(img, co, bundleVerified)\n\t\t\tPrintVerification(img, verified, c.Output)\n\t\t} else {\n\t\t\tref, err := name.ParseReference(img)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"parsing reference\")\n\t\t\t}\n\t\t\tref, err = sign.GetAttachedImageRef(ref, c.Attachment, ociremoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"resolving attachment type %s for image %s\", c.Attachment, img)\n\t\t\t}\n\n\t\t\tverified, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tPrintVerificationHeader(ref.Name(), co, bundleVerified)\n\t\t\tPrintVerification(ref.Name(), verified, c.Output)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc PrintVerificationHeader(imgRef string, co *cosign.CheckOpts, bundleVerified bool) {\n\tfmt.Fprintf(os.Stderr, \"\\nVerification for %s --\\n\", imgRef)\n\tfmt.Fprintln(os.Stderr, \"The following checks were performed on each of these signatures:\")\n\tif co.ClaimVerifier != nil {\n\t\tif co.Annotations != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"  - The specified annotations were verified.\")\n\t\t}\n\t\tfmt.Fprintln(os.Stderr, \"  - The cosign claims were validated\")\n\t}\n\tif bundleVerified {\n\t\tfmt.Fprintln(os.Stderr, \"  - Existence of the claims in the transparency log was verified offline\")\n\t} else if co.RekorClient != nil {\n\t\tfmt.Fprintln(os.Stderr, \"  - The claims were present in the transparency log\")\n\t\tfmt.Fprintln(os.Stderr, \"  - The signatures were integrated into the transparency log when the certificate was valid\")\n\t}\n\tif co.SigVerifier != nil {\n\t\tfmt.Fprintln(os.Stderr, \"  - The signatures were verified against the specified public key\")\n\t}\n\tfmt.Fprintln(os.Stderr, \"  - Any certificates were verified against the Fulcio roots.\")\n}\n\n// PrintVerification logs details about the verification to stdout\nfunc PrintVerification(imgRef string, verified []oci.Signature, output string) {\n\tswitch output {\n\tcase \"text\":\n\t\tfor _, sig := range verified {\n\t\t\tif cert, err := sig.Cert(); err == nil && cert != nil {\n\t\t\t\tfmt.Println(\"Certificate subject: \", sigs.CertSubject(cert))\n\t\t\t\tif issuerURL := sigs.CertIssuerExtension(cert); issuerURL != \"\" {\n\t\t\t\t\tfmt.Println(\"Certificate issuer URL: \", issuerURL)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp, err := sig.Payload()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error fetching payload: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(string(p))\n\t\t}\n\n\tdefault:\n\t\tvar outputKeys []payload.SimpleContainerImage\n\t\tfor _, sig := range verified {\n\t\t\tp, err := sig.Payload()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error fetching payload: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tss := payload.SimpleContainerImage{}\n\t\t\tif err := json.Unmarshal(p, &ss); err != nil {\n\t\t\t\tfmt.Println(\"error decoding the payload:\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif cert, err := sig.Cert(); err == nil && cert != nil {\n\t\t\t\tif ss.Optional == nil {\n\t\t\t\t\tss.Optional = make(map[string]interface{})\n\t\t\t\t}\n\t\t\t\tss.Optional[\"Subject\"] = sigs.CertSubject(cert)\n\t\t\t\tif issuerURL := sigs.CertIssuerExtension(cert); issuerURL != \"\" {\n\t\t\t\t\tss.Optional[\"Issuer\"] = issuerURL\n\t\t\t\t}\n\t\t\t}\n\t\t\tif bundle, err := sig.Bundle(); err == nil && bundle != nil {\n\t\t\t\tif ss.Optional == nil {\n\t\t\t\t\tss.Optional = make(map[string]interface{})\n\t\t\t\t}\n\t\t\t\tss.Optional[\"Bundle\"] = bundle\n\t\t\t}\n\n\t\t\toutputKeys = append(outputKeys, ss)\n\t\t}\n\n\t\tb, err := json.Marshal(outputKeys)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error when generating the output:\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Printf(\"\\n%s\\n\", string(b))\n\t}\n}\n\nfunc loadCertFromFileOrURL(path string) (*x509.Certificate, error) {\n\tpems, err := blob.LoadFileOrURL(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn loadCertFromPEM(pems)\n}\n\nfunc loadCertFromPEM(pems []byte) (*x509.Certificate, error) {\n\tvar out []byte\n\tout, err := base64.StdEncoding.DecodeString(string(pems))\n\tif err != nil {\n\t\t// not a base64\n\t\tout = pems\n\t}\n\n\tcerts, err := cryptoutils.UnmarshalCertificatesFromPEM(out)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(certs) == 0 {\n\t\treturn nil, errors.New(\"no certs found in pem file\")\n\t}\n\treturn certs[0], nil\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\t\"github.com/sigstore/cosign/pkg/cosign/rego\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/cue\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n)\n\n// VerifyAttestationCommand verifies a signature on a supplied container image\n// nolint\ntype VerifyAttestationCommand struct {\n\toptions.RegistryOptions\n\tCheckClaims    bool\n\tCertRef        string\n\tCertEmail      string\n\tCertOidcIssuer string\n\tKeyRef         string\n\tSk             bool\n\tSlot           string\n\tOutput         string\n\tRekorURL       string\n\tPredicateType  string\n\tPolicies       []string\n\tLocalImage     bool\n}\n\n// Exec runs the verification command\nfunc (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (err error) {\n\tif len(images) == 0 {\n\t\treturn flag.ErrHelp\n\t}\n\n\tif !options.OneOf(c.KeyRef, c.Sk, c.CertRef) && !options.EnableExperimental() {\n\t\treturn &options.KeyParseError{}\n\t}\n\n\tociremoteOpts, err := c.ClientOpts(ctx)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"constructing client options\")\n\t}\n\tco := &cosign.CheckOpts{\n\t\tRegistryClientOpts: ociremoteOpts,\n\t\tCertEmail:          c.CertEmail,\n\t\tCertOidcIssuer:     c.CertOidcIssuer,\n\t}\n\tif c.CheckClaims {\n\t\tco.ClaimVerifier = cosign.IntotoSubjectClaimVerifier\n\t}\n\tif options.EnableExperimental() {\n\t\tif c.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(c.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"creating Rekor client\")\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t\tco.RootCerts = fulcio.GetRoots()\n\t}\n\tkeyRef := c.KeyRef\n\n\t// Keys are optional!\n\tswitch {\n\tcase keyRef != \"\":\n\t\tco.SigVerifier, err = sigs.PublicKeyFromKeyRef(ctx, keyRef)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"loading public key\")\n\t\t}\n\t\tpkcs11Key, ok := co.SigVerifier.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase c.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(c.Slot)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"opening piv token\")\n\t\t}\n\t\tdefer sk.Close()\n\t\tco.SigVerifier, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"initializing piv token verifier\")\n\t\t}\n\tcase c.CertRef != \"\":\n\t\tcert, err := loadCertFromFileOrURL(c.CertRef)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"loading certificate from reference\")\n\t\t}\n\t\tco.SigVerifier, err = signature.LoadECDSAVerifier(cert.PublicKey.(*ecdsa.PublicKey), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"creating certificate verifier\")\n\t\t}\n\t}\n\n\tfor _, imageRef := range images {\n\t\tvar verified []oci.Signature\n\t\tvar bundleVerified bool\n\n\t\tif c.LocalImage {\n\t\t\tverified, bundleVerified, err = cosign.VerifyLocalImageAttestations(ctx, imageRef, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tref, err := name.ParseReference(imageRef)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tverified, bundleVerified, err = cosign.VerifyImageAttestations(ctx, ref, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tvar cuePolicies, regoPolicies []string\n\n\t\tfor _, policy := range c.Policies {\n\t\t\tswitch filepath.Ext(policy) {\n\t\t\tcase \".rego\":\n\t\t\t\tregoPolicies = append(regoPolicies, policy)\n\t\t\tcase \".cue\":\n\t\t\t\tcuePolicies = append(cuePolicies, policy)\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid policy format, expected .cue or .rego\")\n\t\t\t}\n\t\t}\n\n\t\tvar validationErrors []error\n\t\tfor _, vp := range verified {\n\t\t\tvar payloadData map[string]interface{}\n\n\t\t\tp, err := vp.Payload()\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"could not get payload\")\n\t\t\t}\n\n\t\t\terr = json.Unmarshal(p, &payloadData)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"unmarshal payload data\")\n\t\t\t}\n\n\t\t\tpredicateURI, ok := options.PredicateTypeMap[c.PredicateType]\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"invalid predicate type: %s\", c.PredicateType)\n\t\t\t}\n\n\t\t\t// sanity checks\n\t\t\tif val, ok := payloadData[\"payloadType\"]; ok {\n\t\t\t\t// we need to check only given type from the cli flag\n\t\t\t\t// so we are skipping other types\n\t\t\t\tif predicateURI != val {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"could not find 'payloadType' in payload data\")\n\t\t\t}\n\n\t\t\tvar decodedPayload []byte\n\t\t\tif val, ok := payloadData[\"payload\"]; ok {\n\t\t\t\tdecodedPayload, err = base64.StdEncoding.DecodeString(val.(string))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"could not decode 'payload': %w\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"could not find 'payload' in payload data\")\n\t\t\t}\n\n\t\t\tvar payload []byte\n\t\t\tswitch c.PredicateType {\n\t\t\tcase options.PredicateCustom:\n\t\t\t\tvar cosignStatement in_toto.Statement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &cosignStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal CosignStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(cosignStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating CosignStatement: %w\", err)\n\t\t\t\t}\n\t\t\tcase options.PredicateLink:\n\t\t\t\tvar linkStatement in_toto.LinkStatement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &linkStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal LinkStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(linkStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating LinkStatement: %w\", err)\n\t\t\t\t}\n\t\t\tcase options.PredicateSLSA:\n\t\t\t\tvar slsaProvenanceStatement in_toto.ProvenanceStatement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &slsaProvenanceStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal ProvenanceStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(slsaProvenanceStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating ProvenanceStatement: %w\", err)\n\t\t\t\t}\n\t\t\tcase options.PredicateSPDX:\n\t\t\t\tvar spdxStatement in_toto.SPDXStatement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &spdxStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal SPDXStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(spdxStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating SPDXStatement: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(cuePolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against CUE policies: %v\\n\", cuePolicies)\n\t\t\t\tcueValidationErr := cue.ValidateJSON(payload, cuePolicies)\n\t\t\t\tif cueValidationErr != nil {\n\t\t\t\t\tvalidationErrors = append(validationErrors, cueValidationErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(regoPolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against Rego policies: %v\\n\", regoPolicies)\n\t\t\t\tregoValidationErrs := rego.ValidateJSON(payload, regoPolicies)\n\t\t\t\tif len(regoValidationErrs) > 0 {\n\t\t\t\t\tvalidationErrors = append(validationErrors, regoValidationErrs...)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(validationErrors) > 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"There are %d number of errors occurred during the validation:\\n\", len(validationErrors))\n\t\t\tfor _, v := range validationErrors {\n\t\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"- %v\\n\", v)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%d validation errors occurred\", len(validationErrors))\n\t\t}\n\n\t\t// TODO: add CUE validation report to `PrintVerificationHeader`.\n\t\tPrintVerificationHeader(imageRef, co, bundleVerified)\n\t\t// The attestations are always JSON, so use the raw \"text\" mode for outputting them instead of conversion\n\t\tPrintVerification(imageRef, verified, \"text\")\n\t}\n\n\treturn nil\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/asn1\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\tcbundle \"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/cosign/tuf\"\n\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n\t\"github.com/pkg/errors\"\n\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/cosign/pkg/oci/layout\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n\tsigPayload \"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\n// CheckOpts are the options for checking signatures.\ntype CheckOpts struct {\n\t// RegistryClientOpts are the options for interacting with the container registry.\n\tRegistryClientOpts []ociremote.Option\n\n\t// Annotations optionally specifies image signature annotations to verify.\n\tAnnotations map[string]interface{}\n\t// ClaimVerifier, if provided, verifies claims present in the oci.Signature.\n\tClaimVerifier func(sig oci.Signature, imageDigest v1.Hash, annotations map[string]interface{}) error\n\n\t// RekorClient, if set, is used to use to verify signatures and public keys.\n\tRekorClient *client.Rekor\n\n\t// SigVerifier is used to verify signatures.\n\tSigVerifier signature.Verifier\n\t// PKOpts are the options provided to `SigVerifier.PublicKey()`.\n\tPKOpts []signature.PublicKeyOption\n\n\t// RootCerts are the root CA certs used to verify a signature's chained certificate.\n\tRootCerts *x509.CertPool\n\t// CertEmail is the email expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertEmail string\n\t// CertOidcIssuer is the OIDC issuer expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertOidcIssuer string\n\n\t// SignatureRef is the reference to the signature file\n\tSignatureRef string\n}\n\nfunc getSignedEntity(signedImgRef name.Reference, regClientOpts []ociremote.Option) (oci.SignedEntity, v1.Hash, error) {\n\tse, err := ociremote.SignedEntity(signedImgRef, regClientOpts...)\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\t// Both of the SignedEntity types implement Digest()\n\th, err := se.(interface{ Digest() (v1.Hash, error) }).Digest()\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\treturn se, h, nil\n}\n\nfunc verifyOCISignature(ctx context.Context, verifier signature.Verifier, sig oci.Signature) error {\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsignature, err := base64.StdEncoding.DecodeString(b64sig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(payload), options.WithContext(ctx))\n}\n\n// For unit testing\ntype payloader interface {\n\tPayload() ([]byte, error)\n}\n\nfunc verifyOCIAttestation(_ context.Context, verifier signature.Verifier, att payloader) error {\n\tpayload, err := att.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tenv := ssldsse.Envelope{}\n\tif err := json.Unmarshal(payload, &env); err != nil {\n\t\treturn err\n\t}\n\n\tif env.PayloadType != types.IntotoPayloadType {\n\t\treturn fmt.Errorf(\"invalid payloadType %s on envelope. Expected %s\", env.PayloadType, types.IntotoPayloadType)\n\t}\n\tdssev, err := ssldsse.NewEnvelopeVerifier(&dsse.VerifierAdapter{SignatureVerifier: verifier})\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = dssev.Verify(&env)\n\treturn err\n}\n\n// ValidateAndUnpackCert creates a Verifier from a certificate. Veries that the certificate\n// chains up to a trusted root. Optionally verifies the subject of the certificate.\nfunc ValidateAndUnpackCert(cert *x509.Certificate, co *CheckOpts) (signature.Verifier, error) {\n\tverifier, err := signature.LoadECDSAVerifier(cert.PublicKey.(*ecdsa.PublicKey), crypto.SHA256)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"invalid certificate found on signature\")\n\t}\n\n\t// Now verify the cert, then the signature.\n\tif err := TrustedCert(cert, co.RootCerts); err != nil {\n\t\treturn nil, err\n\t}\n\tif co.CertEmail != \"\" {\n\t\temailVerified := false\n\t\tfor _, em := range cert.EmailAddresses {\n\t\t\tif co.CertEmail == em {\n\t\t\t\temailVerified = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !emailVerified {\n\t\t\treturn nil, errors.New(\"expected email not found in certificate\")\n\t\t}\n\t}\n\tif co.CertOidcIssuer != \"\" {\n\t\tissuer := \"\"\n\t\tfor _, ext := range cert.Extensions {\n\t\t\tif ext.Id.Equal(asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1}) {\n\t\t\t\tissuer = string(ext.Value)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif issuer != co.CertOidcIssuer {\n\t\t\treturn nil, errors.New(\"expected oidc issuer not found in certificate\")\n\t\t}\n\t}\n\treturn verifier, nil\n}\n\nfunc tlogValidatePublicKey(ctx context.Context, rekorClient *client.Rekor, pub crypto.PublicKey, sig oci.Signature) error {\n\tpemBytes, err := cryptoutils.MarshalPublicKeyToPEM(pub)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, _, err = FindTlogEntry(ctx, rekorClient, b64sig, payload, pemBytes)\n\treturn err\n}\n\nfunc tlogValidateCertificate(ctx context.Context, rekorClient *client.Rekor, sig oci.Signature) error {\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpemBytes, err := cryptoutils.MarshalCertificateToPEM(cert)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\tuuid, _, err := FindTlogEntry(ctx, rekorClient, b64sig, payload, pemBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// if we have a cert, we should check expiry\n\t// The IntegratedTime verified in VerifyTlog\n\te, err := GetTlogEntry(ctx, rekorClient, uuid)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn CheckExpiry(cert, time.Unix(*e.IntegratedTime, 0))\n}\n\ntype fakeOCISignatures struct {\n\toci.Signatures\n\tsignatures []oci.Signature\n}\n\nfunc (fos *fakeOCISignatures) Get() ([]oci.Signature, error) {\n\treturn fos.signatures, nil\n}\n\n// VerifyImageSignatures does all the main cosign checks in a loop, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyImageSignatures(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar sigs oci.Signatures\n\tsigRef := co.SignatureRef\n\tif sigRef == \"\" {\n\t\tsigs, err = se.Signatures()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t} else {\n\t\tsigs, err = loadSignatureFromFile(sigRef, signedImgRef, co)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\n// VerifyLocalImageSignatures verifies signatures from a saved, local image, without any network calls, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageSignatures(ctx context.Context, path string, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tsigs, err := se.Signatures()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\nfunc verifySignatures(ctx context.Context, sigs oci.Signatures, h v1.Hash, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := sigs.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\n\tfor _, sig := range sl {\n\t\tverified, err := VerifyImageSignature(ctx, sig, h, co)\n\t\tbundleVerified = bundleVerified || verified\n\t\tif err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedSignatures = append(checkedSignatures, sig)\n\t}\n\tif len(checkedSignatures) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"no matching signatures:\\n%s\", strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedSignatures, bundleVerified, nil\n}\n\n// VerifyImageSignature verifies a signature\nfunc VerifyImageSignature(ctx context.Context, sig oci.Signature, h v1.Hash, co *CheckOpts) (bundleVerified bool, err error) {\n\tverifier := co.SigVerifier\n\tif verifier == nil {\n\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\tcert, err := sig.Cert()\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t\tif cert == nil {\n\t\t\treturn bundleVerified, errors.New(\"no certificate found on signature\")\n\t\t}\n\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tif err := verifyOCISignature(ctx, verifier, sig); err != nil {\n\t\treturn bundleVerified, err\n\t}\n\n\t// We can't check annotations without claims, both require unmarshalling the payload.\n\tif co.ClaimVerifier != nil {\n\t\tif err := co.ClaimVerifier(sig, h, co.Annotations); err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tbundleVerified, err = VerifyBundle(ctx, sig)\n\tif err != nil && co.RekorClient == nil {\n\t\treturn false, errors.Wrap(err, \"unable to verify bundle\")\n\t}\n\n\tif !bundleVerified && co.RekorClient != nil {\n\t\tif co.SigVerifier != nil {\n\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn bundleVerified, err\n\t\t\t}\n\t\t\treturn bundleVerified, tlogValidatePublicKey(ctx, co.RekorClient, pub, sig)\n\t\t}\n\n\t\treturn bundleVerified, tlogValidateCertificate(ctx, co.RekorClient, sig)\n\t}\n\n\treturn bundleVerified, nil\n}\n\nfunc loadSignatureFromFile(sigRef string, signedImgRef name.Reference, co *CheckOpts) (oci.Signatures, error) {\n\tvar b64sig string\n\ttargetSig, err := blob.LoadFileOrURL(sigRef)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\ttargetSig = []byte(sigRef)\n\t}\n\n\t_, err = base64.StdEncoding.DecodeString(string(targetSig))\n\n\tif err == nil {\n\t\tb64sig = string(targetSig)\n\t} else {\n\t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n\t}\n\n\tdigest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpayload, err := (&sigPayload.Cosign{Image: digest}).MarshalJSON()\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsig, err := static.NewSignature(payload, b64sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fakeOCISignatures{\n\t\tsignatures: []oci.Signature{sig},\n\t}, nil\n}\n\n// VerifyAttestations does all the main cosign checks in a loop, returning the verified attestations.\n// If there were no valid attestations, we return an error.\nfunc VerifyImageAttestations(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\n// VerifyLocalImageAttestations verifies attestations from a saved, local image, without any network calls,\n// returning the verified attestations.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageAttestations(ctx context.Context, path string, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\nfunc verifyImageAttestations(ctx context.Context, atts oci.Signatures, h v1.Hash, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := atts.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\tfor _, att := range sl {\n\t\tif err := func(att oci.Signature) error {\n\t\t\tverifier := co.SigVerifier\n\t\t\tif verifier == nil {\n\t\t\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\t\t\tcert, err := att.Cert()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif cert == nil {\n\t\t\t\t\treturn errors.New(\"no certificate found on attestation\")\n\t\t\t\t}\n\t\t\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := verifyOCIAttestation(ctx, verifier, att); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// We can't check annotations without claims, both require unmarshalling the payload.\n\t\t\tif co.ClaimVerifier != nil {\n\t\t\t\tif err := co.ClaimVerifier(att, h, co.Annotations); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverified, err := VerifyBundle(ctx, att)\n\t\t\tif err != nil && co.RekorClient == nil {\n\t\t\t\treturn errors.Wrap(err, \"unable to verify bundle\")\n\t\t\t}\n\t\t\tbundleVerified = bundleVerified || verified\n\n\t\t\tif !verified && co.RekorClient != nil {\n\t\t\t\tif co.SigVerifier != nil {\n\t\t\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn tlogValidatePublicKey(ctx, co.RekorClient, pub, att)\n\t\t\t\t}\n\n\t\t\t\treturn tlogValidateCertificate(ctx, co.RekorClient, att)\n\t\t\t}\n\t\t\treturn nil\n\t\t}(att); err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedAttestations = append(checkedAttestations, att)\n\t}\n\tif len(checkedAttestations) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"no matching attestations:\\n%s\", strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedAttestations, bundleVerified, nil\n}\n\n// CheckExpiry confirms the time provided is within the valid period of the cert\nfunc CheckExpiry(cert *x509.Certificate, it time.Time) error {\n\tft := func(t time.Time) string {\n\t\treturn t.Format(time.RFC3339)\n\t}\n\tif cert.NotAfter.Before(it) {\n\t\treturn fmt.Errorf(\"certificate expired before signatures were entered in log: %s is before %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\tif cert.NotBefore.After(it) {\n\t\treturn fmt.Errorf(\"certificate was issued after signatures were entered in log: %s is after %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\treturn nil\n}\n\nfunc VerifyBundle(ctx context.Context, sig oci.Signature) (bool, error) {\n\tbundle, err := sig.Bundle()\n\tif err != nil {\n\t\treturn false, err\n\t} else if bundle == nil {\n\t\treturn false, nil\n\t}\n\n\tpublicKeys, err := GetRekorPubs(ctx)\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"retrieving rekor public key\")\n\t}\n\n\tvar entryVerError error\n\tfor _, pubKey := range publicKeys {\n\t\tentryVerError = VerifySET(bundle.Payload, bundle.SignedEntryTimestamp, pubKey.PubKey)\n\t\t// Exit early with successful verification\n\t\tif entryVerError == nil {\n\t\t\tif pubKey.Status != tuf.Active {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif entryVerError != nil {\n\t\treturn false, entryVerError\n\t}\n\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn false, err\n\t} else if cert == nil {\n\t\treturn true, nil\n\t}\n\n\t// verify the cert against the integrated time\n\tif err := CheckExpiry(cert, time.Unix(bundle.Payload.IntegratedTime, 0)); err != nil {\n\t\treturn false, errors.Wrap(err, \"checking expiry on cert\")\n\t}\n\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"reading payload\")\n\t}\n\tsignature, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"reading base64signature\")\n\t}\n\n\talg, bundlehash, err := bundleHash(bundle.Payload.Body.(string), signature)\n\th := sha256.Sum256(payload)\n\tpayloadHash := hex.EncodeToString(h[:])\n\n\tif alg != \"sha256\" || bundlehash != payloadHash {\n\t\treturn false, errors.Wrap(err, \"matching bundle to payload\")\n\t}\n\treturn true, nil\n}\n\nfunc bundleHash(bundleBody, signature string) (string, string, error) {\n\tvar toto models.Intoto\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar intotoObj models.IntotoV001Schema\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\t// The fact that there's no signature (or empty rather), implies\n\t// that this is an Attestation that we're verifying.\n\tif len(signature) == 0 {\n\t\terr = json.Unmarshal(bodyDecoded, &toto)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tspecMarshal, err := json.Marshal(toto.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &intotoObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\treturn *intotoObj.Content.Hash.Algorithm, *intotoObj.Content.Hash.Value, nil\n\t}\n\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &rekordObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\treturn *rekordObj.Data.Hash.Algorithm, *rekordObj.Data.Hash.Value, nil\n\t}\n\n\t// Try hashedRekordObj\n\terr = json.Unmarshal(bodyDecoded, &hrekord)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\terr = json.Unmarshal(specMarshal, &hrekordObj)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn *hrekordObj.Data.Hash.Algorithm, *hrekordObj.Data.Hash.Value, nil\n}\n\nfunc VerifySET(bundlePayload cbundle.RekorPayload, signature []byte, pub *ecdsa.PublicKey) error {\n\tcontents, err := json.Marshal(bundlePayload)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"marshaling\")\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(contents)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"canonicalizing\")\n\t}\n\n\t// verify the SET against the public key\n\thash := sha256.Sum256(canonicalized)\n\tif !ecdsa.VerifyASN1(pub, hash[:], signature) {\n\t\treturn errors.New(\"unable to verify\")\n\t}\n\treturn nil\n}\n\nfunc TrustedCert(cert *x509.Certificate, roots *x509.CertPool) error {\n\tif _, err := cert.Verify(x509.VerifyOptions{\n\t\t// THIS IS IMPORTANT: WE DO NOT CHECK TIMES HERE\n\t\t// THE CERTIFICATE IS TREATED AS TRUSTED FOREVER\n\t\t// WE CHECK THAT THE SIGNATURES WERE CREATED DURING THIS WINDOW\n\t\tCurrentTime: cert.NotBefore,\n\t\tRoots:       roots,\n\t\tKeyUsages: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageCodeSigning,\n\t\t},\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc correctAnnotations(wanted, have map[string]interface{}) bool {\n\tfor k, v := range wanted {\n\t\tif have[k] != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/cosign/test\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype mockVerifier struct {\n\tshouldErr bool\n}\n\nfunc (m *mockVerifier) PublicKey(opts ...signature.PublicKeyOption) (crypto.PublicKey, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockVerifier) VerifySignature(signature, message io.Reader, opts ...signature.VerifyOption) error {\n\tif m.shouldErr {\n\t\treturn errors.New(\"failure\")\n\t}\n\treturn nil\n}\n\nvar _ signature.Verifier = (*mockVerifier)(nil)\n\ntype mockAttestation struct {\n\tpayload interface{}\n}\n\nvar _ payloader = (*mockAttestation)(nil)\n\nfunc (m *mockAttestation) Annotations() (map[string]string, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockAttestation) Payload() ([]byte, error) {\n\treturn json.Marshal(m.payload)\n}\nfunc Test_verifyOCIAttestation(t *testing.T) {\n\tstmt, err := json.Marshal(in_toto.ProvenanceStatement{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvalid := map[string]interface{}{\n\t\t\"payloadType\": types.IntotoPayloadType,\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\t// Should Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: valid}); err != nil {\n\t\tt.Errorf(\"verifyOCIAttestation() error = %v\", err)\n\t}\n\n\tinvalid := map[string]interface{}{\n\t\t\"payloadType\": \"not valid type\",\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\n\t// Should Not Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: invalid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{shouldErr: true}, &mockAttestation{payload: valid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccess(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccessAllowAllValues(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts: rootPool,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertInvalidRoot(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\totherRoot, _, _ := test.GenerateRootCa()\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(otherRoot)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"certificate signed by unknown authority\")\n}\n\nfunc TestValidateAndUnpackCertInvalidOidcIssuer(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: \"other\",\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected oidc issuer not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidEmail(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      \"other\",\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage sget\n\nimport (\n\t\"context\"\n\t\"io\"\n\n\t\"github.com/google/go-containerregistry/pkg/authn\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/verify\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n)\n\nfunc New(image, key string, out io.Writer) *SecureGet {\n\treturn &SecureGet{\n\t\tImageRef: image,\n\t\tKeyRef:   key,\n\t\tOut:      out,\n\t}\n}\n\ntype SecureGet struct {\n\tImageRef string\n\tKeyRef   string\n\tOut      io.Writer\n}\n\nfunc (sg *SecureGet) Do(ctx context.Context) error {\n\tref, err := name.ParseReference(sg.ImageRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\topts := []remote.Option{\n\t\tremote.WithAuthFromKeychain(authn.DefaultKeychain),\n\t\tremote.WithContext(ctx),\n\t}\n\n\tco := &cosign.CheckOpts{\n\t\tClaimVerifier:      cosign.SimpleClaimVerifier,\n\t\tRegistryClientOpts: []ociremote.Option{ociremote.WithRemoteOptions(opts...)},\n\t}\n\tif _, ok := ref.(name.Tag); ok {\n\t\tif sg.KeyRef == \"\" && !options.EnableExperimental() {\n\t\t\treturn errors.New(\"public key must be specified when fetching by tag, you must fetch by digest or supply a public key\")\n\t\t}\n\t}\n\t// Overwrite \"ref\" with a digest to avoid a race where we verify the tag,\n\t// and then access the file through the tag.  This has a race where we\n\t// might download content that isn't what we verified.\n\tref, err = ociremote.ResolveDigest(ref, co.RegistryClientOpts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sg.KeyRef != \"\" {\n\t\tpub, err := sigs.LoadPublicKey(ctx, sg.KeyRef)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tco.SigVerifier = pub\n\t}\n\n\tif co.SigVerifier != nil || options.EnableExperimental() {\n\t\tco.RootCerts = fulcio.GetRoots()\n\n\t\tsp, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tverify.PrintVerificationHeader(sg.ImageRef, co, bundleVerified)\n\t\tverify.PrintVerification(sg.ImageRef, sp, \"text\")\n\t}\n\n\t// TODO(mattmoor): Depending on what this is, use the higher-level stuff.\n\timg, err := remote.Image(ref, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlayers, err := img.Layers()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(layers) != 1 {\n\t\treturn errors.New(\"invalid artifact\")\n\t}\n\trc, err := layers[0].Compressed()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(sg.Out, rc)\n\treturn err\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build e2e\n// +build e2e\n\npackage test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-containerregistry/pkg/authn\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/registry\"\n\t\"github.com/google/go-containerregistry/pkg/v1/random\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/attach\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/attest\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/download\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/generate\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/publickey\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/sign\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/upload\"\n\tcliverify \"github.com/sigstore/cosign/cmd/cosign/cli/verify\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/kubernetes\"\n\tcremote \"github.com/sigstore/cosign/pkg/cosign/remote\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/cosign/pkg/sget\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\nconst (\n\tserverEnv = \"REKOR_SERVER\"\n\trekorURL  = \"https://rekor.sigstore.dev\"\n)\n\nvar keyPass = []byte(\"hello\")\n\nvar passFunc = func(_ bool) ([]byte, error) {\n\treturn keyPass, nil\n}\n\nvar verify = func(keyRef, imageRef string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tRekorURL:      rekorURL,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\n// Used to verify local images stored on disk\nvar verifyLocal = func(keyRef, path string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tLocalImage:    true,\n\t}\n\n\targs := []string{path}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar ro = &options.RootOptions{Timeout: options.DefaultTimeout}\n\nfunc TestSignVerify(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\t// Sign the image with an annotation\n\tannotations := map[string]interface{}{\"foo\": \"bar\"}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, annotations, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// It should match this time.\n\tmust(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\t// But two doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\", \"baz\": \"bat\"}, \"\"), t)\n}\n\nfunc TestSignVerifyClean(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestImportSignVerifyClean(t *testing.T) {\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := importKeyPair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestAttestVerify(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Verify should fail at first\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef: pubKeyPath,\n\t}\n\n\t// Fail case when using without type and policy flag\n\tmustErr(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"slsaprovenance\", false, 30*time.Second), t)\n\n\t// Use cue to verify attestation\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation.PredicateType = \"slsaprovenance\"\n\tverifyAttestation.Policies = []string{policyPath}\n\n\t// Fail case\n\tcuePolicy := `builder: id: \"1\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Success case\n\tcuePolicy = `builder: id: \"2\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n}\n\nfunc TestAttestationReplace(t *testing.T) {\n\t// This test is currently failing, see https://github.com/sigstore/cosign/issues/1378\n\t// The replace option for attest does not appear to work on random.Image() generated images\n\tt.Skip()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-replace-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest once with with replace=false creating an attestation\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"slsaprovenance\", false, 30*time.Second), t)\n\t// Attest again with replace=true, replacing the previous attestation\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"slsaprovenance\", true, 30*time.Second), t)\n\t// Attest once more replace=true using a different predicate, to ensure it adds a new attestation\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"custom\", true, 30*time.Second), t)\n\n\t// Download and count the attestations\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 2 {\n\t\tt.Fatal(fmt.Errorf(\"Expected len(attestations) == 2, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestRekorBundle(t *testing.T) {\n\t// turn on the tlog\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := sign.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestDuplicateSign(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\tref, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Signing again should work just fine...\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\tmust(err, t)\n\tsigs, err := se.Signatures()\n\tmust(err, t)\n\tsignatures, err := sigs.Get()\n\tmust(err, t)\n\n\tif len(signatures) > 1 {\n\t\tt.Errorf(\"expected there to only be one signature, got %v\", signatures)\n\t}\n}\n\nfunc TestKeyURLVerify(t *testing.T) {\n\t// TODO: re-enable once distroless images are being signed by the new client\n\tt.Skip()\n\t// Verify that an image can be verified via key url\n\tkeyRef := \"https://raw.githubusercontent.com/GoogleContainerTools/distroless/main/cosign.pub\"\n\timg := \"gcr.io/distroless/base:latest\"\n\n\tmust(verify(keyRef, img, true, nil, \"\"), t)\n}\n\nfunc TestGenerateKeyPairEnvVar(t *testing.T) {\n\tdefer setenv(t, \"COSIGN_PASSWORD\", \"foo\")()\n\tkeys, err := cosign.GenerateKeyPair(generate.GetPass)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := cosign.LoadPrivateKey(keys.PrivateBytes, []byte(\"foo\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGenerateKeyPairK8s(t *testing.T) {\n\ttd := t.TempDir()\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tpassword := \"foo\"\n\tdefer setenv(t, \"COSIGN_PASSWORD\", password)()\n\tctx := context.Background()\n\tname := \"cosign-secret\"\n\tnamespace := \"default\"\n\tif err := kubernetes.KeyPairSecret(ctx, fmt.Sprintf(\"k8s://%s/%s\", namespace, name), generate.GetPass); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// make sure the secret actually exists\n\tclient, err := kubernetes.Client()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := client.CoreV1().Secrets(namespace).Get(ctx, name, metav1.GetOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v, ok := s.Data[\"cosign.password\"]; !ok || string(v) != password {\n\t\tt.Fatalf(\"password is incorrect, got %v expected %v\", v, \"foo\")\n\t}\n}\n\nfunc TestMultipleSignatures(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, priv1, pub1 := keypair(t, td1)\n\t_, priv2, pub2 := keypair(t, td2)\n\n\t// Verify should fail at first for both keys\n\tmustErr(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image with one key\n\tko := sign.KeyOpts{KeyRef: priv1, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign with the other key too\n\tko.KeyRef = priv2\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify should work with both\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmust(verify(pub2, imgName, true, nil, \"\"), t)\n}\n\nfunc TestSignBlob(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t\tos.RemoveAll(td2)\n\t})\n\tbp := filepath.Join(td1, blob)\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\tctx := context.Background()\n\n\tko1 := sign.KeyOpts{\n\t\tKeyRef: pubKeyPath1,\n\t}\n\tko2 := sign.KeyOpts{\n\t\tKeyRef: pubKeyPath2,\n\t}\n\t// Verify should fail on a bad input\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko1, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, \"badsig\", blob), t)\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko2, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, \"badsig\", blob), t)\n\n\t// Now sign the blob with one key\n\tko := sign.KeyOpts{\n\t\tKeyRef:   privKeyPath1,\n\t\tPassFunc: passFunc,\n\t}\n\tsig, err := sign.SignBlobCmd(ro, ko, options.RegistryOptions{}, bp, true, \"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work with that one, but not the other\n\tmust(cliverify.VerifyBlobCmd(ctx, ko1, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, string(sig), bp), t)\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko2, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, string(sig), bp), t)\n}\n\nfunc TestSignBlobBundle(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\tbp := filepath.Join(td1, blob)\n\tbundlePath := filepath.Join(td1, \"bundle.sig\")\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\n\tko1 := sign.KeyOpts{\n\t\tKeyRef:     pubKeyPath1,\n\t\tBundlePath: bundlePath,\n\t}\n\t// Verify should fail on a bad input\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko1, \"\", \"\", \"\", \"\", blob), t)\n\n\t// Now sign the blob with one key\n\tko := sign.KeyOpts{\n\t\tKeyRef:     privKeyPath1,\n\t\tPassFunc:   passFunc,\n\t\tBundlePath: bundlePath,\n\t\tRekorURL:   rekorURL,\n\t}\n\tif _, err := sign.SignBlobCmd(ro, ko, options.RegistryOptions{}, bp, true, \"\", \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work\n\tmust(cliverify.VerifyBlobCmd(ctx, ko1, \"\", \"\", \"\", \"\", bp), t)\n\n\t// Now we turn on the tlog and sign again\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\tif _, err := sign.SignBlobCmd(ro, ko, options.RegistryOptions{}, bp, true, \"\", \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Point to a fake rekor server to make sure offline verification of the tlog entry works\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(cliverify.VerifyBlobCmd(ctx, ko1, \"\", \"\", \"\", \"\", bp), t)\n}\n\nfunc TestGenerate(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\t_, desc, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t// Generate the payload for the image, and check the digest.\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\tss := payload.SimpleContainerImage{}\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\n\t// Now try with some annotations.\n\tb.Reset()\n\ta := map[string]interface{}{\"foo\": \"bar\"}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, a, &b), t)\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\tequals(ss.Optional[\"foo\"], \"bar\", t)\n}\n\nfunc keypair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tkeys, err := cosign.GenerateKeyPair(passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n}\n\nfunc importKeyPair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\n\tconst validrsa1 = `-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAx5piWVlE62NnZ0UzJ8Z6oKiKOC4dbOZ1HsNhIRtqkM+Oq4G+\n25yq6P+0JU/Qvr9veOGEb3R/J9u8JBo+hv2i5X8OtgvP2V2pi6f1s6vK7L0+6uRb\n4YTT/UdMshaVf97MgEqbq41Jf/cuvh+3AV0tZ1BpixZg4aXMKpY6HUP69lbsu27o\nSUN1myMv7TSgZiV4CYs3l/gkEfpysBptWlcHRuw5RsB+C0RbjRtbJ/5VxmE/vd3M\nlafd5t1WSpMb8yf0a84u5NFaXwZ7CweMfXeOddS0yb19ShSuW3PPRadruBM1mq15\njs9GfagPxDS75Imcs+fA62lWvHxEujTGjYHxawIDAQABAoIBAH+sgLwmHa9zJfEo\nklAe5NFe/QpydN/ziXbkAnzqzH9URC3wD+TpkWj4JoK3Sw635NWtasjf+3XDV9S/\n9L7j/g5N91r6sziWcJykEsWaXXKQmm4lI6BdFjwsHyLKz1W7bZOiJXDWLu1rbrqu\nDqEQuLoc9WXCKrYrFy0maoXNtfla/1p05kKN0bMigcnnyAQ+xBTwoyco4tkIz5se\nIYxorz7qzXrkHQI+knz5BawmNe3ekoSaXUPoLoOR7TRTGsLteL5yukvWAi8S/0rE\ngftC+PZCQpoQhSUYq7wXe7RowJ1f+kXb7HsSedOTfTSW1D/pUb/uW+CcRKig42ZI\nI9H9TAECgYEA5XGBML6fJyWVqx64sHbUAjQsmQ0RwU6Zo7sqHIEPf6tYVYp7KtzK\nKOfi8seOOL5FSy4pjCo11Dzyrh9bn45RNmtjSYTgOnVPSoCfuRNfOcpG+/wCHjYf\nEjDvdrCpbg59kVUeaMeBDiyWAlM48HJAn8O7ez2U/iKQCyJmOIwFhSkCgYEA3rSz\nFi1NzqYWxWos4NBmg8iKcQ9SMkmPdgRLAs/WNnZJ8fdgJZwihevkXGytRGJEmav2\nGMKRx1g6ey8fjXTQH9WM8X/kJC5fv8wLHnUCH/K3Mcp9CYwn7PFvSnBr4kQoc/el\nbURhcF1+/opEC8vNX/Wk3zAG7Xs1PREXlH2SIHMCgYBV/3kgwBH/JkM25EjtO1yz\nhsLAivmAruk/SUO7c1RP0fVF+qW3pxHOyztxLALOmeJ3D1JbSubqKf377Zz17O3b\nq9yHDdrNjnKtxhAX2n7ytjJs+EQC9t4mf1kB761RpvTBqFnBhCWHHocLUA4jcW9v\ncnmu86IIrwO2aKpPv4vCIQKBgHU9gY3qOazRSOmSlJ+hdmZn+2G7pBTvHsQNTIPl\ncCrpqNHl3crO4GnKHkT9vVVjuiOAIKU2QNJFwzu4Og8Y8LvhizpTjoHxm9x3iV72\nUDELcJ+YrqyJCTe2flUcy96o7Pbn50GXnwgtYD6WAW6IUszyn2ITgYIhu4wzZEt6\ns6O7AoGAPTKbRA87L34LMlXyUBJma+etMARIP1zu8bXJ7hSJeMcog8zaLczN7ruT\npGAaLxggvtvuncMuTrG+cdmsR9SafSFKRS92NCxhOUonQ+NP6mLskIGzJZoQ5JvQ\nqGzRVIDGbNkrVHM0IsAtHRpC0rYrtZY+9OwiraGcsqUMLwwQdCA=\n-----END RSA PRIVATE KEY-----`\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\terr = os.WriteFile(\"validrsa1.key\", []byte(validrsa1), 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tkeys, err := cosign.ImportKeyPair(\"validrsa1.key\", passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"import-cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"import-cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n\n}\n\nfunc TestUploadDownload(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\n\ttestCases := map[string]struct {\n\t\tsignature     string\n\t\tsignatureType attach.SignatureArgType\n\t\texpectedErr   bool\n\t}{\n\t\t\"file containing signature\": {\n\t\t\tsignature:     \"testsignaturefile\",\n\t\t\tsignatureType: attach.FileSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"raw signature as argument\": {\n\t\t\tsignature:     \"testsignatureraw\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"empty signature as argument\": {\n\t\t\tsignature:     \"\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   true,\n\t\t},\n\t}\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\tfor testName, testCase := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tref, _, cleanup := mkimage(t, imgName)\n\t\t\tpayload := \"testpayload\"\n\t\t\tpayloadPath := mkfile(payload, td, t)\n\t\t\tsignature := base64.StdEncoding.EncodeToString([]byte(testCase.signature))\n\n\t\t\tvar sigRef string\n\t\t\tif testCase.signatureType == attach.FileSignature {\n\t\t\t\tsigRef = mkfile(signature, td, t)\n\t\t\t} else {\n\t\t\t\tsigRef = signature\n\t\t\t}\n\n\t\t\t// Upload it!\n\t\t\terr := attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadPath, imgName)\n\t\t\tif testCase.expectedErr {\n\t\t\t\tmustErr(err, t)\n\t\t\t} else {\n\t\t\t\tmust(err, t)\n\t\t\t}\n\n\t\t\t// Now download it!\n\t\t\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\t\t\tmust(err, t)\n\t\t\tsigs, err := se.Signatures()\n\t\t\tmust(err, t)\n\t\t\tsignatures, err := sigs.Get()\n\t\t\tmust(err, t)\n\n\t\t\tif testCase.expectedErr {\n\t\t\t\tif len(signatures) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 0\", len(signatures))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(signatures) != 1 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 1\", len(signatures))\n\t\t\t\t}\n\n\t\t\t\tif b64sig, err := signatures[0].Base64Signature(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Base64Signature() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(b64sig, signature); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\n\t\t\t\tif p, err := signatures[0].Payload(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Payload() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(p, []byte(payload)); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now delete it!\n\t\t\tcleanup()\n\t\t})\n\t}\n}\n\nfunc TestUploadBlob(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\n\timgName := path.Join(repo, \"/cosign-upload-e2e\")\n\tpayload := \"testpayload\"\n\tpayloadPath := mkfile(payload, td, t)\n\n\t// Upload it!\n\tfiles := []cremote.File{cremote.FileFromFlag(payloadPath)}\n\tmust(upload.BlobCmd(ctx, options.RegistryOptions{}, files, \"\", imgName), t)\n\n\t// Check it\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now download it with sget (this should fail by tag)\n\tif err := sget.New(imgName, \"\", os.Stdout).Do(ctx); err == nil {\n\t\tt.Error(\"expected download to fail\")\n\t}\n\n\timg, err := remote.Image(ref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdgst, err := img.Digest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult := &bytes.Buffer{}\n\n\t// But pass by digest\n\tif err := sget.New(imgName+\"@\"+dgst.String(), \"\", result).Do(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb, err := io.ReadAll(result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != payload {\n\t\tt.Errorf(\"expected contents to be %s, got %s\", payload, string(b))\n\t}\n}\n\nfunc TestSaveLoad(t *testing.T) {\n\ttests := []struct {\n\t\tdescription     string\n\t\tgetSignedEntity func(t *testing.T, n string) (name.Reference, *remote.Descriptor, func())\n\t}{\n\t\t{\n\t\t\tdescription:     \"save and load an image\",\n\t\t\tgetSignedEntity: mkimage,\n\t\t},\n\t\t{\n\t\t\tdescription:     \"save and load an image index\",\n\t\t\tgetSignedEntity: mkimageindex,\n\t\t},\n\t}\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\trepo, stop := reg(t)\n\t\t\tdefer stop()\n\t\t\tkeysDir := t.TempDir()\n\n\t\t\timgName := path.Join(repo, fmt.Sprintf(\"save-load-%d\", i))\n\n\t\t\t_, _, cleanup := test.getSignedEntity(t, imgName)\n\t\t\tdefer cleanup()\n\n\t\t\t_, privKeyPath, pubKeyPath := keypair(t, keysDir)\n\n\t\t\tctx := context.Background()\n\t\t\t// Now sign the image and verify it\n\t\t\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\t\t\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t\t\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t\t\t// save the image to a temp dir\n\t\t\timageDir := t.TempDir()\n\t\t\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t\t\t// verify the local image using a local key\n\t\t\tmust(verifyLocal(pubKeyPath, imageDir, true, nil, \"\"), t)\n\n\t\t\t// load the image from the temp dir into a new image and verify the new image\n\t\t\timgName2 := path.Join(repo, fmt.Sprintf(\"save-load-%d-2\", i))\n\t\t\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\t\t\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t\t})\n\t}\n}\n\nfunc TestSaveLoadAttestation(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"save-load\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Now sign the image and verify it\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// now, append an attestation to the image\n\tslsaAttestation := `{ \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko = sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"custom\", false, 30*time.Second), t)\n\n\t// save the image to a temp dir\n\timageDir := t.TempDir()\n\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t// load the image from the temp dir into a new image and verify the new image\n\timgName2 := path.Join(repo, \"save-load-2\")\n\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t// Use cue to verify attestation on the new image\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef: pubKeyPath,\n\t}\n\tverifyAttestation.PredicateType = \"slsaprovenance\"\n\tverifyAttestation.Policies = []string{policyPath}\n\t// Success case (remote)\n\tcuePolicy := `builder: id: \"2\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName2}), t)\n\t// Success case (local)\n\tverifyAttestation.LocalImage = true\n\tmust(verifyAttestation.Exec(ctx, []string{imageDir}), t)\n}\n\nfunc TestAttachSBOM(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\tctx := context.Background()\n\n\timgName := path.Join(repo, \"sbom-image\")\n\timg, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tout := bytes.Buffer{}\n\t_, err := download.SBOMCmd(ctx, options.RegistryOptions{}, img.Name(), &out)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tt.Log(out.String())\n\tout.Reset()\n\n\t// Upload it!\n\tmust(attach.SBOMCmd(ctx, options.RegistryOptions{}, \"./testdata/bom-go-mod.spdx\", \"spdx\", imgName), t)\n\n\tsboms, err := download.SBOMCmd(ctx, options.RegistryOptions{}, imgName, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(out.String())\n\tif len(sboms) != 1 {\n\t\tt.Fatalf(\"Expected one sbom, got %d\", len(sboms))\n\t}\n\twant, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := cmp.Diff(string(want), sboms[0]); diff != \"\" {\n\t\tt.Errorf(\"diff: %s\", diff)\n\t}\n\n\t// Generate key pairs to sign the sbom\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\t// Verify should fail on a bad input\n\tmustErr(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n\n\t// Now sign the sbom with one key\n\tko1 := sign.KeyOpts{KeyRef: privKeyPath1, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko1, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"sbom\"), t)\n\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n}\n\nfunc setenv(t *testing.T, k, v string) func() {\n\tif err := os.Setenv(k, v); err != nil {\n\t\tt.Fatalf(\"error setting env: %v\", err)\n\t}\n\treturn func() {\n\t\tos.Unsetenv(k)\n\t}\n}\n\nfunc TestTlog(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image without the tlog\n\tko := sign.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now we turn on the tlog!\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\n\t// Verify shouldn't work since we haven't put anything in it yet.\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Sign again with the tlog env var on\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t// And now verify works!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestGetPublicKeyCustomOut(t *testing.T) {\n\ttd := t.TempDir()\n\tkeys, privKeyPath, _ := keypair(t, td)\n\tctx := context.Background()\n\n\toutFile := \"output.pub\"\n\toutPath := filepath.Join(td, outFile)\n\toutWriter, err := os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE, 0600)\n\tmust(err, t)\n\n\tpk := publickey.Pkopts{\n\t\tKeyRef: privKeyPath,\n\t}\n\tmust(publickey.GetPublicKey(ctx, pk, publickey.NamedWriter{Name: outPath, Writer: outWriter}, passFunc), t)\n\n\toutput, err := os.ReadFile(outPath)\n\tmust(err, t)\n\tequals(keys.PublicBytes, output, t)\n}\n\nfunc mkfile(contents, td string, t *testing.T) string {\n\tf, err := os.CreateTemp(td, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tif _, err := f.Write([]byte(contents)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn f.Name()\n}\n\nfunc mkimage(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\timg, err := random.Image(512, 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.Write(ref, img, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteImage, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteImage.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteImage, cleanup\n}\n\nfunc mkimageindex(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tii, err := random.Index(512, 5, 4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.WriteIndex(ref, ii, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteIndex, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteIndex.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteIndex, cleanup\n}\n\nfunc must(err error, t *testing.T) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc mustErr(err error, t *testing.T) {\n\tt.Helper()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc equals(v1, v2 interface{}, t *testing.T) {\n\tif diff := cmp.Diff(v1, v2); diff != \"\" {\n\t\tt.Error(diff)\n\t}\n}\n\nfunc reg(t *testing.T) (string, func()) {\n\trepo := os.Getenv(\"COSIGN_TEST_REPO\")\n\tif repo != \"\" {\n\t\treturn repo, func() {}\n\t}\n\n\tt.Log(\"COSIGN_TEST_REPO unset, using fake registry\")\n\tr := httptest.NewServer(registry.New())\n\tu, err := url.Parse(r.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn u.Host, r.Close\n}\n\nfunc registryClientOpts(ctx context.Context) []remote.Option {\n\treturn []remote.Option{\n\t\tremote.WithAuthFromKeychain(authn.DefaultKeychain),\n\t\tremote.WithContext(ctx),\n\t}\n}\n"], "fixing_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/sign\"\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\n// VerifyCommand verifies a signature on a supplied container image\n// nolint\ntype VerifyCommand struct {\n\toptions.RegistryOptions\n\tCheckClaims    bool\n\tKeyRef         string\n\tCertRef        string\n\tCertEmail      string\n\tCertOidcIssuer string\n\tSk             bool\n\tSlot           string\n\tOutput         string\n\tRekorURL       string\n\tAttachment     string\n\tAnnotations    sigs.AnnotationsMap\n\tSignatureRef   string\n\tHashAlgorithm  crypto.Hash\n\tLocalImage     bool\n}\n\n// Exec runs the verification command\nfunc (c *VerifyCommand) Exec(ctx context.Context, images []string) (err error) {\n\tif len(images) == 0 {\n\t\treturn flag.ErrHelp\n\t}\n\n\tswitch c.Attachment {\n\tcase \"sbom\", \"\":\n\t\tbreak\n\tdefault:\n\t\treturn flag.ErrHelp\n\t}\n\n\t// always default to sha256 if the algorithm hasn't been explicitly set\n\tif c.HashAlgorithm == 0 {\n\t\tc.HashAlgorithm = crypto.SHA256\n\t}\n\n\tif !options.OneOf(c.KeyRef, c.CertRef, c.Sk) && !options.EnableExperimental() {\n\t\treturn &options.KeyParseError{}\n\t}\n\tociremoteOpts, err := c.ClientOpts(ctx)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"constructing client options\")\n\t}\n\tco := &cosign.CheckOpts{\n\t\tAnnotations:        c.Annotations.Annotations,\n\t\tRegistryClientOpts: ociremoteOpts,\n\t\tCertEmail:          c.CertEmail,\n\t\tCertOidcIssuer:     c.CertOidcIssuer,\n\t\tSignatureRef:       c.SignatureRef,\n\t}\n\tif c.CheckClaims {\n\t\tco.ClaimVerifier = cosign.SimpleClaimVerifier\n\t}\n\tif options.EnableExperimental() {\n\t\tif c.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(c.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"creating Rekor client\")\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t\tco.RootCerts = fulcio.GetRoots()\n\t}\n\tkeyRef := c.KeyRef\n\tcertRef := c.CertRef\n\n\t// Keys are optional!\n\tvar pubKey signature.Verifier\n\tswitch {\n\tcase keyRef != \"\":\n\t\tpubKey, err = sigs.PublicKeyFromKeyRefWithHashAlgo(ctx, keyRef, c.HashAlgorithm)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"loading public key\")\n\t\t}\n\t\tpkcs11Key, ok := pubKey.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase c.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(c.Slot)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"opening piv token\")\n\t\t}\n\t\tdefer sk.Close()\n\t\tpubKey, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"initializing piv token verifier\")\n\t\t}\n\tcase certRef != \"\":\n\t\tcert, err := loadCertFromFileOrURL(c.CertRef)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpubKey, err = signature.LoadECDSAVerifier(cert.PublicKey.(*ecdsa.PublicKey), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tco.SigVerifier = pubKey\n\n\t// NB: There are only 2 kinds of verification right now:\n\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n\t// was performed so we don't need to use this fragile logic here.\n\tfulcioVerified := (co.SigVerifier == nil)\n\n\tfor _, img := range images {\n\t\tif c.LocalImage {\n\t\t\tverified, bundleVerified, err := cosign.VerifyLocalImageSignatures(ctx, img, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tPrintVerificationHeader(img, co, bundleVerified, fulcioVerified)\n\t\t\tPrintVerification(img, verified, c.Output)\n\t\t} else {\n\t\t\tref, err := name.ParseReference(img)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"parsing reference\")\n\t\t\t}\n\t\t\tref, err = sign.GetAttachedImageRef(ref, c.Attachment, ociremoteOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"resolving attachment type %s for image %s\", c.Attachment, img)\n\t\t\t}\n\n\t\t\tverified, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tPrintVerificationHeader(ref.Name(), co, bundleVerified, fulcioVerified)\n\t\t\tPrintVerification(ref.Name(), verified, c.Output)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc PrintVerificationHeader(imgRef string, co *cosign.CheckOpts, bundleVerified, fulcioVerified bool) {\n\tfmt.Fprintf(os.Stderr, \"\\nVerification for %s --\\n\", imgRef)\n\tfmt.Fprintln(os.Stderr, \"The following checks were performed on each of these signatures:\")\n\tif co.ClaimVerifier != nil {\n\t\tif co.Annotations != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"  - The specified annotations were verified.\")\n\t\t}\n\t\tfmt.Fprintln(os.Stderr, \"  - The cosign claims were validated\")\n\t}\n\tif bundleVerified {\n\t\tfmt.Fprintln(os.Stderr, \"  - Existence of the claims in the transparency log was verified offline\")\n\t} else if co.RekorClient != nil {\n\t\tfmt.Fprintln(os.Stderr, \"  - The claims were present in the transparency log\")\n\t\tfmt.Fprintln(os.Stderr, \"  - The signatures were integrated into the transparency log when the certificate was valid\")\n\t}\n\tif co.SigVerifier != nil {\n\t\tfmt.Fprintln(os.Stderr, \"  - The signatures were verified against the specified public key\")\n\t}\n\tif fulcioVerified {\n\t\tfmt.Fprintln(os.Stderr, \"  - Any certificates were verified against the Fulcio roots.\")\n\t}\n}\n\n// PrintVerification logs details about the verification to stdout\nfunc PrintVerification(imgRef string, verified []oci.Signature, output string) {\n\tswitch output {\n\tcase \"text\":\n\t\tfor _, sig := range verified {\n\t\t\tif cert, err := sig.Cert(); err == nil && cert != nil {\n\t\t\t\tfmt.Println(\"Certificate subject: \", sigs.CertSubject(cert))\n\t\t\t\tif issuerURL := sigs.CertIssuerExtension(cert); issuerURL != \"\" {\n\t\t\t\t\tfmt.Println(\"Certificate issuer URL: \", issuerURL)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp, err := sig.Payload()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error fetching payload: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfmt.Println(string(p))\n\t\t}\n\n\tdefault:\n\t\tvar outputKeys []payload.SimpleContainerImage\n\t\tfor _, sig := range verified {\n\t\t\tp, err := sig.Payload()\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"Error fetching payload: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tss := payload.SimpleContainerImage{}\n\t\t\tif err := json.Unmarshal(p, &ss); err != nil {\n\t\t\t\tfmt.Println(\"error decoding the payload:\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif cert, err := sig.Cert(); err == nil && cert != nil {\n\t\t\t\tif ss.Optional == nil {\n\t\t\t\t\tss.Optional = make(map[string]interface{})\n\t\t\t\t}\n\t\t\t\tss.Optional[\"Subject\"] = sigs.CertSubject(cert)\n\t\t\t\tif issuerURL := sigs.CertIssuerExtension(cert); issuerURL != \"\" {\n\t\t\t\t\tss.Optional[\"Issuer\"] = issuerURL\n\t\t\t\t}\n\t\t\t}\n\t\t\tif bundle, err := sig.Bundle(); err == nil && bundle != nil {\n\t\t\t\tif ss.Optional == nil {\n\t\t\t\t\tss.Optional = make(map[string]interface{})\n\t\t\t\t}\n\t\t\t\tss.Optional[\"Bundle\"] = bundle\n\t\t\t}\n\n\t\t\toutputKeys = append(outputKeys, ss)\n\t\t}\n\n\t\tb, err := json.Marshal(outputKeys)\n\t\tif err != nil {\n\t\t\tfmt.Println(\"error when generating the output:\", err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Printf(\"\\n%s\\n\", string(b))\n\t}\n}\n\nfunc loadCertFromFileOrURL(path string) (*x509.Certificate, error) {\n\tpems, err := blob.LoadFileOrURL(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn loadCertFromPEM(pems)\n}\n\nfunc loadCertFromPEM(pems []byte) (*x509.Certificate, error) {\n\tvar out []byte\n\tout, err := base64.StdEncoding.DecodeString(string(pems))\n\tif err != nil {\n\t\t// not a base64\n\t\tout = pems\n\t}\n\n\tcerts, err := cryptoutils.UnmarshalCertificatesFromPEM(out)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(certs) == 0 {\n\t\treturn nil, errors.New(\"no certs found in pem file\")\n\t}\n\treturn certs[0], nil\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\t\"github.com/sigstore/cosign/pkg/cosign/rego\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/cue\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n)\n\n// VerifyAttestationCommand verifies a signature on a supplied container image\n// nolint\ntype VerifyAttestationCommand struct {\n\toptions.RegistryOptions\n\tCheckClaims    bool\n\tCertRef        string\n\tCertEmail      string\n\tCertOidcIssuer string\n\tKeyRef         string\n\tSk             bool\n\tSlot           string\n\tOutput         string\n\tRekorURL       string\n\tPredicateType  string\n\tPolicies       []string\n\tLocalImage     bool\n}\n\n// Exec runs the verification command\nfunc (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (err error) {\n\tif len(images) == 0 {\n\t\treturn flag.ErrHelp\n\t}\n\n\tif !options.OneOf(c.KeyRef, c.Sk, c.CertRef) && !options.EnableExperimental() {\n\t\treturn &options.KeyParseError{}\n\t}\n\n\tociremoteOpts, err := c.ClientOpts(ctx)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"constructing client options\")\n\t}\n\tco := &cosign.CheckOpts{\n\t\tRegistryClientOpts: ociremoteOpts,\n\t\tCertEmail:          c.CertEmail,\n\t\tCertOidcIssuer:     c.CertOidcIssuer,\n\t}\n\tif c.CheckClaims {\n\t\tco.ClaimVerifier = cosign.IntotoSubjectClaimVerifier\n\t}\n\tif options.EnableExperimental() {\n\t\tif c.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(c.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"creating Rekor client\")\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t\tco.RootCerts = fulcio.GetRoots()\n\t}\n\tkeyRef := c.KeyRef\n\n\t// Keys are optional!\n\tswitch {\n\tcase keyRef != \"\":\n\t\tco.SigVerifier, err = sigs.PublicKeyFromKeyRef(ctx, keyRef)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"loading public key\")\n\t\t}\n\t\tpkcs11Key, ok := co.SigVerifier.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase c.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(c.Slot)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"opening piv token\")\n\t\t}\n\t\tdefer sk.Close()\n\t\tco.SigVerifier, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"initializing piv token verifier\")\n\t\t}\n\tcase c.CertRef != \"\":\n\t\tcert, err := loadCertFromFileOrURL(c.CertRef)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"loading certificate from reference\")\n\t\t}\n\t\tco.SigVerifier, err = signature.LoadECDSAVerifier(cert.PublicKey.(*ecdsa.PublicKey), crypto.SHA256)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"creating certificate verifier\")\n\t\t}\n\t}\n\n\t// NB: There are only 2 kinds of verification right now:\n\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n\t// was performed so we don't need to use this fragile logic here.\n\tfulcioVerified := (co.SigVerifier == nil)\n\n\tfor _, imageRef := range images {\n\t\tvar verified []oci.Signature\n\t\tvar bundleVerified bool\n\n\t\tif c.LocalImage {\n\t\t\tverified, bundleVerified, err = cosign.VerifyLocalImageAttestations(ctx, imageRef, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tref, err := name.ParseReference(imageRef)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tverified, bundleVerified, err = cosign.VerifyImageAttestations(ctx, ref, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tvar cuePolicies, regoPolicies []string\n\n\t\tfor _, policy := range c.Policies {\n\t\t\tswitch filepath.Ext(policy) {\n\t\t\tcase \".rego\":\n\t\t\t\tregoPolicies = append(regoPolicies, policy)\n\t\t\tcase \".cue\":\n\t\t\t\tcuePolicies = append(cuePolicies, policy)\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid policy format, expected .cue or .rego\")\n\t\t\t}\n\t\t}\n\n\t\tvar validationErrors []error\n\t\tfor _, vp := range verified {\n\t\t\tvar payloadData map[string]interface{}\n\n\t\t\tp, err := vp.Payload()\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"could not get payload\")\n\t\t\t}\n\n\t\t\terr = json.Unmarshal(p, &payloadData)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"unmarshal payload data\")\n\t\t\t}\n\n\t\t\tpredicateURI, ok := options.PredicateTypeMap[c.PredicateType]\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"invalid predicate type: %s\", c.PredicateType)\n\t\t\t}\n\n\t\t\t// sanity checks\n\t\t\tif val, ok := payloadData[\"payloadType\"]; ok {\n\t\t\t\t// we need to check only given type from the cli flag\n\t\t\t\t// so we are skipping other types\n\t\t\t\tif predicateURI != val {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"could not find 'payloadType' in payload data\")\n\t\t\t}\n\n\t\t\tvar decodedPayload []byte\n\t\t\tif val, ok := payloadData[\"payload\"]; ok {\n\t\t\t\tdecodedPayload, err = base64.StdEncoding.DecodeString(val.(string))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"could not decode 'payload': %w\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"could not find 'payload' in payload data\")\n\t\t\t}\n\n\t\t\tvar payload []byte\n\t\t\tswitch c.PredicateType {\n\t\t\tcase options.PredicateCustom:\n\t\t\t\tvar cosignStatement in_toto.Statement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &cosignStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal CosignStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(cosignStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating CosignStatement: %w\", err)\n\t\t\t\t}\n\t\t\tcase options.PredicateLink:\n\t\t\t\tvar linkStatement in_toto.LinkStatement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &linkStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal LinkStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(linkStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating LinkStatement: %w\", err)\n\t\t\t\t}\n\t\t\tcase options.PredicateSLSA:\n\t\t\t\tvar slsaProvenanceStatement in_toto.ProvenanceStatement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &slsaProvenanceStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal ProvenanceStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(slsaProvenanceStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating ProvenanceStatement: %w\", err)\n\t\t\t\t}\n\t\t\tcase options.PredicateSPDX:\n\t\t\t\tvar spdxStatement in_toto.SPDXStatement\n\t\t\t\tif err := json.Unmarshal(decodedPayload, &spdxStatement); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"unmarshal SPDXStatement: %w\", err)\n\t\t\t\t}\n\t\t\t\tpayload, err = json.Marshal(spdxStatement)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error when generating SPDXStatement: %w\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(cuePolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against CUE policies: %v\\n\", cuePolicies)\n\t\t\t\tcueValidationErr := cue.ValidateJSON(payload, cuePolicies)\n\t\t\t\tif cueValidationErr != nil {\n\t\t\t\t\tvalidationErrors = append(validationErrors, cueValidationErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(regoPolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against Rego policies: %v\\n\", regoPolicies)\n\t\t\t\tregoValidationErrs := rego.ValidateJSON(payload, regoPolicies)\n\t\t\t\tif len(regoValidationErrs) > 0 {\n\t\t\t\t\tvalidationErrors = append(validationErrors, regoValidationErrs...)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(validationErrors) > 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"There are %d number of errors occurred during the validation:\\n\", len(validationErrors))\n\t\t\tfor _, v := range validationErrors {\n\t\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"- %v\\n\", v)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%d validation errors occurred\", len(validationErrors))\n\t\t}\n\n\t\t// TODO: add CUE validation report to `PrintVerificationHeader`.\n\t\tPrintVerificationHeader(imageRef, co, bundleVerified, fulcioVerified)\n\t\t// The attestations are always JSON, so use the raw \"text\" mode for outputting them instead of conversion\n\t\tPrintVerification(imageRef, verified, \"text\")\n\t}\n\n\treturn nil\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/asn1\"\n\t\"encoding/base64\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\tcbundle \"github.com/sigstore/cosign/pkg/cosign/bundle\"\n\t\"github.com/sigstore/cosign/pkg/cosign/tuf\"\n\n\t\"github.com/sigstore/cosign/pkg/blob\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\n\t\"github.com/cyberphone/json-canonicalization/go/src/webpki.org/jsoncanonicalizer\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\tv1 \"github.com/google/go-containerregistry/pkg/v1\"\n\t\"github.com/pkg/errors\"\n\n\tssldsse \"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/cosign/pkg/oci/layout\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/rekor/pkg/generated/client\"\n\t\"github.com/sigstore/rekor/pkg/generated/models\"\n\t\"github.com/sigstore/sigstore/pkg/cryptoutils\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/dsse\"\n\t\"github.com/sigstore/sigstore/pkg/signature/options\"\n\tsigPayload \"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\n// CheckOpts are the options for checking signatures.\ntype CheckOpts struct {\n\t// RegistryClientOpts are the options for interacting with the container registry.\n\tRegistryClientOpts []ociremote.Option\n\n\t// Annotations optionally specifies image signature annotations to verify.\n\tAnnotations map[string]interface{}\n\t// ClaimVerifier, if provided, verifies claims present in the oci.Signature.\n\tClaimVerifier func(sig oci.Signature, imageDigest v1.Hash, annotations map[string]interface{}) error\n\n\t// RekorClient, if set, is used to use to verify signatures and public keys.\n\tRekorClient *client.Rekor\n\n\t// SigVerifier is used to verify signatures.\n\tSigVerifier signature.Verifier\n\t// PKOpts are the options provided to `SigVerifier.PublicKey()`.\n\tPKOpts []signature.PublicKeyOption\n\n\t// RootCerts are the root CA certs used to verify a signature's chained certificate.\n\tRootCerts *x509.CertPool\n\t// CertEmail is the email expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertEmail string\n\t// CertOidcIssuer is the OIDC issuer expected for a certificate to be valid. The empty string means any certificate can be valid.\n\tCertOidcIssuer string\n\n\t// SignatureRef is the reference to the signature file\n\tSignatureRef string\n}\n\nfunc getSignedEntity(signedImgRef name.Reference, regClientOpts []ociremote.Option) (oci.SignedEntity, v1.Hash, error) {\n\tse, err := ociremote.SignedEntity(signedImgRef, regClientOpts...)\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\t// Both of the SignedEntity types implement Digest()\n\th, err := se.(interface{ Digest() (v1.Hash, error) }).Digest()\n\tif err != nil {\n\t\treturn nil, v1.Hash{}, err\n\t}\n\treturn se, h, nil\n}\n\nfunc verifyOCISignature(ctx context.Context, verifier signature.Verifier, sig oci.Signature) error {\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsignature, err := base64.StdEncoding.DecodeString(b64sig)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(payload), options.WithContext(ctx))\n}\n\n// For unit testing\ntype payloader interface {\n\tPayload() ([]byte, error)\n}\n\nfunc verifyOCIAttestation(_ context.Context, verifier signature.Verifier, att payloader) error {\n\tpayload, err := att.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tenv := ssldsse.Envelope{}\n\tif err := json.Unmarshal(payload, &env); err != nil {\n\t\treturn err\n\t}\n\n\tif env.PayloadType != types.IntotoPayloadType {\n\t\treturn fmt.Errorf(\"invalid payloadType %s on envelope. Expected %s\", env.PayloadType, types.IntotoPayloadType)\n\t}\n\tdssev, err := ssldsse.NewEnvelopeVerifier(&dsse.VerifierAdapter{SignatureVerifier: verifier})\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = dssev.Verify(&env)\n\treturn err\n}\n\n// ValidateAndUnpackCert creates a Verifier from a certificate. Veries that the certificate\n// chains up to a trusted root. Optionally verifies the subject of the certificate.\nfunc ValidateAndUnpackCert(cert *x509.Certificate, co *CheckOpts) (signature.Verifier, error) {\n\tverifier, err := signature.LoadECDSAVerifier(cert.PublicKey.(*ecdsa.PublicKey), crypto.SHA256)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"invalid certificate found on signature\")\n\t}\n\n\t// Now verify the cert, then the signature.\n\tif err := TrustedCert(cert, co.RootCerts); err != nil {\n\t\treturn nil, err\n\t}\n\tif co.CertEmail != \"\" {\n\t\temailVerified := false\n\t\tfor _, em := range cert.EmailAddresses {\n\t\t\tif co.CertEmail == em {\n\t\t\t\temailVerified = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !emailVerified {\n\t\t\treturn nil, errors.New(\"expected email not found in certificate\")\n\t\t}\n\t}\n\tif co.CertOidcIssuer != \"\" {\n\t\tissuer := \"\"\n\t\tfor _, ext := range cert.Extensions {\n\t\t\tif ext.Id.Equal(asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 57264, 1, 1}) {\n\t\t\t\tissuer = string(ext.Value)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif issuer != co.CertOidcIssuer {\n\t\t\treturn nil, errors.New(\"expected oidc issuer not found in certificate\")\n\t\t}\n\t}\n\treturn verifier, nil\n}\n\nfunc tlogValidatePublicKey(ctx context.Context, rekorClient *client.Rekor, pub crypto.PublicKey, sig oci.Signature) error {\n\tpemBytes, err := cryptoutils.MarshalPublicKeyToPEM(pub)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, _, err = FindTlogEntry(ctx, rekorClient, b64sig, payload, pemBytes)\n\treturn err\n}\n\nfunc tlogValidateCertificate(ctx context.Context, rekorClient *client.Rekor, sig oci.Signature) error {\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpemBytes, err := cryptoutils.MarshalCertificateToPEM(cert)\n\tif err != nil {\n\t\treturn err\n\t}\n\tb64sig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn err\n\t}\n\tuuid, _, err := FindTlogEntry(ctx, rekorClient, b64sig, payload, pemBytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// if we have a cert, we should check expiry\n\t// The IntegratedTime verified in VerifyTlog\n\te, err := GetTlogEntry(ctx, rekorClient, uuid)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn CheckExpiry(cert, time.Unix(*e.IntegratedTime, 0))\n}\n\ntype fakeOCISignatures struct {\n\toci.Signatures\n\tsignatures []oci.Signature\n}\n\nfunc (fos *fakeOCISignatures) Get() ([]oci.Signature, error) {\n\treturn fos.signatures, nil\n}\n\n// VerifyImageSignatures does all the main cosign checks in a loop, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyImageSignatures(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar sigs oci.Signatures\n\tsigRef := co.SignatureRef\n\tif sigRef == \"\" {\n\t\tsigs, err = se.Signatures()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t} else {\n\t\tsigs, err = loadSignatureFromFile(sigRef, signedImgRef, co)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\n// VerifyLocalImageSignatures verifies signatures from a saved, local image, without any network calls, returning the verified signatures.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageSignatures(ctx context.Context, path string, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tsigs, err := se.Signatures()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifySignatures(ctx, sigs, h, co)\n}\n\nfunc verifySignatures(ctx context.Context, sigs oci.Signatures, h v1.Hash, co *CheckOpts) (checkedSignatures []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := sigs.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\n\tfor _, sig := range sl {\n\t\tverified, err := VerifyImageSignature(ctx, sig, h, co)\n\t\tbundleVerified = bundleVerified || verified\n\t\tif err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedSignatures = append(checkedSignatures, sig)\n\t}\n\tif len(checkedSignatures) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"no matching signatures:\\n%s\", strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedSignatures, bundleVerified, nil\n}\n\n// VerifyImageSignature verifies a signature\nfunc VerifyImageSignature(ctx context.Context, sig oci.Signature, h v1.Hash, co *CheckOpts) (bundleVerified bool, err error) {\n\tverifier := co.SigVerifier\n\tif verifier == nil {\n\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\tcert, err := sig.Cert()\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t\tif cert == nil {\n\t\t\treturn bundleVerified, errors.New(\"no certificate found on signature\")\n\t\t}\n\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\tif err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tif err := verifyOCISignature(ctx, verifier, sig); err != nil {\n\t\treturn bundleVerified, err\n\t}\n\n\t// We can't check annotations without claims, both require unmarshalling the payload.\n\tif co.ClaimVerifier != nil {\n\t\tif err := co.ClaimVerifier(sig, h, co.Annotations); err != nil {\n\t\t\treturn bundleVerified, err\n\t\t}\n\t}\n\n\tbundleVerified, err = VerifyBundle(ctx, sig)\n\tif err != nil && co.RekorClient == nil {\n\t\treturn false, errors.Wrap(err, \"unable to verify bundle\")\n\t}\n\n\tif !bundleVerified && co.RekorClient != nil {\n\t\tif co.SigVerifier != nil {\n\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\tif err != nil {\n\t\t\t\treturn bundleVerified, err\n\t\t\t}\n\t\t\treturn bundleVerified, tlogValidatePublicKey(ctx, co.RekorClient, pub, sig)\n\t\t}\n\n\t\treturn bundleVerified, tlogValidateCertificate(ctx, co.RekorClient, sig)\n\t}\n\n\treturn bundleVerified, nil\n}\n\nfunc loadSignatureFromFile(sigRef string, signedImgRef name.Reference, co *CheckOpts) (oci.Signatures, error) {\n\tvar b64sig string\n\ttargetSig, err := blob.LoadFileOrURL(sigRef)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\ttargetSig = []byte(sigRef)\n\t}\n\n\t_, err = base64.StdEncoding.DecodeString(string(targetSig))\n\n\tif err == nil {\n\t\tb64sig = string(targetSig)\n\t} else {\n\t\tb64sig = base64.StdEncoding.EncodeToString(targetSig)\n\t}\n\n\tdigest, err := ociremote.ResolveDigest(signedImgRef, co.RegistryClientOpts...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpayload, err := (&sigPayload.Cosign{Image: digest}).MarshalJSON()\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsig, err := static.NewSignature(payload, b64sig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fakeOCISignatures{\n\t\tsignatures: []oci.Signature{sig},\n\t}, nil\n}\n\n// VerifyAttestations does all the main cosign checks in a loop, returning the verified attestations.\n// If there were no valid attestations, we return an error.\nfunc VerifyImageAttestations(ctx context.Context, signedImgRef name.Reference, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\t// TODO(mattmoor): We could implement recursive verification if we just wrapped\n\t// most of the logic below here in a call to mutate.Map\n\n\tse, h, err := getSignedEntity(signedImgRef, co.RegistryClientOpts)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\n// VerifyLocalImageAttestations verifies attestations from a saved, local image, without any network calls,\n// returning the verified attestations.\n// If there were no valid signatures, we return an error.\nfunc VerifyLocalImageAttestations(ctx context.Context, path string, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\t// Enforce this up front.\n\tif co.RootCerts == nil && co.SigVerifier == nil {\n\t\treturn nil, false, errors.New(\"one of verifier or root certs is required\")\n\t}\n\n\tse, err := layout.SignedImageIndex(path)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvar h v1.Hash\n\t// Verify either an image index or image.\n\tii, err := se.SignedImageIndex(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\ti, err := se.SignedImage(v1.Hash{})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tswitch {\n\tcase ii != nil:\n\t\th, err = ii.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tcase i != nil:\n\t\th, err = i.Digest()\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\tdefault:\n\t\treturn nil, false, errors.New(\"must verify either an image index or image\")\n\t}\n\n\tatts, err := se.Attestations()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn verifyImageAttestations(ctx, atts, h, co)\n}\n\nfunc verifyImageAttestations(ctx context.Context, atts oci.Signatures, h v1.Hash, co *CheckOpts) (checkedAttestations []oci.Signature, bundleVerified bool, err error) {\n\tsl, err := atts.Get()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\tvalidationErrs := []string{}\n\tfor _, att := range sl {\n\t\tif err := func(att oci.Signature) error {\n\t\t\tverifier := co.SigVerifier\n\t\t\tif verifier == nil {\n\t\t\t\t// If we don't have a public key to check against, we can try a root cert.\n\t\t\t\tcert, err := att.Cert()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif cert == nil {\n\t\t\t\t\treturn errors.New(\"no certificate found on attestation\")\n\t\t\t\t}\n\t\t\t\tverifier, err = ValidateAndUnpackCert(cert, co)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := verifyOCIAttestation(ctx, verifier, att); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// We can't check annotations without claims, both require unmarshalling the payload.\n\t\t\tif co.ClaimVerifier != nil {\n\t\t\t\tif err := co.ClaimVerifier(att, h, co.Annotations); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverified, err := VerifyBundle(ctx, att)\n\t\t\tif err != nil && co.RekorClient == nil {\n\t\t\t\treturn errors.Wrap(err, \"unable to verify bundle\")\n\t\t\t}\n\t\t\tbundleVerified = bundleVerified || verified\n\n\t\t\tif !verified && co.RekorClient != nil {\n\t\t\t\tif co.SigVerifier != nil {\n\t\t\t\t\tpub, err := co.SigVerifier.PublicKey(co.PKOpts...)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn tlogValidatePublicKey(ctx, co.RekorClient, pub, att)\n\t\t\t\t}\n\n\t\t\t\treturn tlogValidateCertificate(ctx, co.RekorClient, att)\n\t\t\t}\n\t\t\treturn nil\n\t\t}(att); err != nil {\n\t\t\tvalidationErrs = append(validationErrs, err.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\t// Phew, we made it.\n\t\tcheckedAttestations = append(checkedAttestations, att)\n\t}\n\tif len(checkedAttestations) == 0 {\n\t\treturn nil, false, fmt.Errorf(\"no matching attestations:\\n%s\", strings.Join(validationErrs, \"\\n \"))\n\t}\n\treturn checkedAttestations, bundleVerified, nil\n}\n\n// CheckExpiry confirms the time provided is within the valid period of the cert\nfunc CheckExpiry(cert *x509.Certificate, it time.Time) error {\n\tft := func(t time.Time) string {\n\t\treturn t.Format(time.RFC3339)\n\t}\n\tif cert.NotAfter.Before(it) {\n\t\treturn fmt.Errorf(\"certificate expired before signatures were entered in log: %s is before %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\tif cert.NotBefore.After(it) {\n\t\treturn fmt.Errorf(\"certificate was issued after signatures were entered in log: %s is after %s\",\n\t\t\tft(cert.NotAfter), ft(it))\n\t}\n\treturn nil\n}\n\nfunc VerifyBundle(ctx context.Context, sig oci.Signature) (bool, error) {\n\tbundle, err := sig.Bundle()\n\tif err != nil {\n\t\treturn false, err\n\t} else if bundle == nil {\n\t\treturn false, nil\n\t}\n\n\tif err := compareSigs(bundle.Payload.Body.(string), sig); err != nil {\n\t\treturn false, err\n\t}\n\n\tpublicKeys, err := GetRekorPubs(ctx)\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"retrieving rekor public key\")\n\t}\n\n\tvar entryVerError error\n\tfor _, pubKey := range publicKeys {\n\t\tentryVerError = VerifySET(bundle.Payload, bundle.SignedEntryTimestamp, pubKey.PubKey)\n\t\t// Exit early with successful verification\n\t\tif entryVerError == nil {\n\t\t\tif pubKey.Status != tuf.Active {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"**Info** Successfully verified Rekor entry using an expired verification key\\n\")\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif entryVerError != nil {\n\t\treturn false, entryVerError\n\t}\n\n\tcert, err := sig.Cert()\n\tif err != nil {\n\t\treturn false, err\n\t} else if cert == nil {\n\t\treturn true, nil\n\t}\n\n\t// verify the cert against the integrated time\n\tif err := CheckExpiry(cert, time.Unix(bundle.Payload.IntegratedTime, 0)); err != nil {\n\t\treturn false, errors.Wrap(err, \"checking expiry on cert\")\n\t}\n\n\tpayload, err := sig.Payload()\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"reading payload\")\n\t}\n\tsignature, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn false, errors.Wrap(err, \"reading base64signature\")\n\t}\n\n\talg, bundlehash, err := bundleHash(bundle.Payload.Body.(string), signature)\n\th := sha256.Sum256(payload)\n\tpayloadHash := hex.EncodeToString(h[:])\n\n\tif alg != \"sha256\" || bundlehash != payloadHash {\n\t\treturn false, errors.Wrap(err, \"matching bundle to payload\")\n\t}\n\treturn true, nil\n}\n\n// compare bundle signature to the signature we are verifying\nfunc compareSigs(bundleBody string, sig oci.Signature) error {\n\t// TODO(nsmith5): modify function signature to make it more clear _why_\n\t// we've returned nil (there are several reasons possible here).\n\tactualSig, err := sig.Base64Signature()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"base64 signature\")\n\t}\n\tif actualSig == \"\" {\n\t\t// NB: empty sig means this is an attestation\n\t\treturn nil\n\t}\n\tbundleSignature, err := bundleSig(bundleBody)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to extract signature from bundle\")\n\t}\n\tif bundleSignature == \"\" {\n\t\treturn nil\n\t}\n\tif bundleSignature != actualSig {\n\t\treturn fmt.Errorf(\"signature in bundle does not match signature being verified\")\n\t}\n\treturn nil\n}\n\nfunc bundleHash(bundleBody, signature string) (string, string, error) {\n\tvar toto models.Intoto\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar intotoObj models.IntotoV001Schema\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\t// The fact that there's no signature (or empty rather), implies\n\t// that this is an Attestation that we're verifying.\n\tif len(signature) == 0 {\n\t\terr = json.Unmarshal(bodyDecoded, &toto)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\tspecMarshal, err := json.Marshal(toto.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &intotoObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\n\t\treturn *intotoObj.Content.Hash.Algorithm, *intotoObj.Content.Hash.Value, nil\n\t}\n\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\terr = json.Unmarshal(specMarshal, &rekordObj)\n\t\tif err != nil {\n\t\t\treturn \"\", \"\", err\n\t\t}\n\t\treturn *rekordObj.Data.Hash.Algorithm, *rekordObj.Data.Hash.Value, nil\n\t}\n\n\t// Try hashedRekordObj\n\terr = json.Unmarshal(bodyDecoded, &hrekord)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\terr = json.Unmarshal(specMarshal, &hrekordObj)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn *hrekordObj.Data.Hash.Algorithm, *hrekordObj.Data.Hash.Value, nil\n}\n\n// bundleSig extracts the signature from the rekor bundle body\nfunc bundleSig(bundleBody string) (string, error) {\n\tvar rekord models.Rekord\n\tvar hrekord models.Hashedrekord\n\tvar rekordObj models.RekordV001Schema\n\tvar hrekordObj models.HashedrekordV001Schema\n\n\tbodyDecoded, err := base64.StdEncoding.DecodeString(bundleBody)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"decoding bundleBody\")\n\t}\n\n\t// Try Rekord\n\tif err := json.Unmarshal(bodyDecoded, &rekord); err == nil {\n\t\tspecMarshal, err := json.Marshal(rekord.Spec)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif err := json.Unmarshal(specMarshal, &rekordObj); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn rekordObj.Signature.Content.String(), nil\n\t}\n\n\t// Try hashedRekordObj\n\tif err := json.Unmarshal(bodyDecoded, &hrekord); err != nil {\n\t\treturn \"\", err\n\t}\n\tspecMarshal, err := json.Marshal(hrekord.Spec)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := json.Unmarshal(specMarshal, &hrekordObj); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn hrekordObj.Signature.Content.String(), nil\n}\n\nfunc VerifySET(bundlePayload cbundle.RekorPayload, signature []byte, pub *ecdsa.PublicKey) error {\n\tcontents, err := json.Marshal(bundlePayload)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"marshaling\")\n\t}\n\tcanonicalized, err := jsoncanonicalizer.Transform(contents)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"canonicalizing\")\n\t}\n\n\t// verify the SET against the public key\n\thash := sha256.Sum256(canonicalized)\n\tif !ecdsa.VerifyASN1(pub, hash[:], signature) {\n\t\treturn errors.New(\"unable to verify\")\n\t}\n\treturn nil\n}\n\nfunc TrustedCert(cert *x509.Certificate, roots *x509.CertPool) error {\n\tif _, err := cert.Verify(x509.VerifyOptions{\n\t\t// THIS IS IMPORTANT: WE DO NOT CHECK TIMES HERE\n\t\t// THE CERTIFICATE IS TREATED AS TRUSTED FOREVER\n\t\t// WE CHECK THAT THE SIGNATURES WERE CREATED DURING THIS WINDOW\n\t\tCurrentTime: cert.NotBefore,\n\t\tRoots:       roots,\n\t\tKeyUsages: []x509.ExtKeyUsage{\n\t\t\tx509.ExtKeyUsageCodeSigning,\n\t\t},\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc correctAnnotations(wanted, have map[string]interface{}) bool {\n\tfor k, v := range wanted {\n\t\tif have[k] != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage cosign\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/in-toto/in-toto-golang/in_toto\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/secure-systems-lab/go-securesystemslib/dsse\"\n\t\"github.com/sigstore/cosign/pkg/oci/static\"\n\t\"github.com/sigstore/cosign/pkg/types\"\n\t\"github.com/sigstore/cosign/test\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype mockVerifier struct {\n\tshouldErr bool\n}\n\nfunc (m *mockVerifier) PublicKey(opts ...signature.PublicKeyOption) (crypto.PublicKey, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockVerifier) VerifySignature(signature, message io.Reader, opts ...signature.VerifyOption) error {\n\tif m.shouldErr {\n\t\treturn errors.New(\"failure\")\n\t}\n\treturn nil\n}\n\nvar _ signature.Verifier = (*mockVerifier)(nil)\n\ntype mockAttestation struct {\n\tpayload interface{}\n}\n\nvar _ payloader = (*mockAttestation)(nil)\n\nfunc (m *mockAttestation) Annotations() (map[string]string, error) {\n\treturn nil, nil\n}\n\nfunc (m *mockAttestation) Payload() ([]byte, error) {\n\treturn json.Marshal(m.payload)\n}\nfunc Test_verifyOCIAttestation(t *testing.T) {\n\tstmt, err := json.Marshal(in_toto.ProvenanceStatement{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvalid := map[string]interface{}{\n\t\t\"payloadType\": types.IntotoPayloadType,\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\t// Should Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: valid}); err != nil {\n\t\tt.Errorf(\"verifyOCIAttestation() error = %v\", err)\n\t}\n\n\tinvalid := map[string]interface{}{\n\t\t\"payloadType\": \"not valid type\",\n\t\t\"payload\":     stmt,\n\t\t\"signatures\":  []dsse.Signature{{Sig: base64.StdEncoding.EncodeToString([]byte(\"foobar\"))}},\n\t}\n\n\t// Should Not Verify\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{}, &mockAttestation{payload: invalid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n\n\tif err := verifyOCIAttestation(context.TODO(), &mockVerifier{shouldErr: true}, &mockAttestation{payload: valid}); err == nil {\n\t\tt.Error(\"verifyOCIAttestation() expected invalid payload type error, got nil\")\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccess(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertSuccessAllowAllValues(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts: rootPool,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\tif err != nil {\n\t\tt.Errorf(\"ValidateAndUnpackCert expected no error, got err = %v\", err)\n\t}\n}\n\nfunc TestValidateAndUnpackCertInvalidRoot(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\totherRoot, _, _ := test.GenerateRootCa()\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(otherRoot)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"certificate signed by unknown authority\")\n}\n\nfunc TestValidateAndUnpackCertInvalidOidcIssuer(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      subject,\n\t\tCertOidcIssuer: \"other\",\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected oidc issuer not found in certificate\")\n}\n\nfunc TestValidateAndUnpackCertInvalidEmail(t *testing.T) {\n\tsubject := \"email@email\"\n\toidcIssuer := \"https://accounts.google.com\"\n\n\trootCert, rootKey, _ := test.GenerateRootCa()\n\tleafCert, _, _ := test.GenerateLeafCert(subject, oidcIssuer, rootCert, rootKey)\n\n\trootPool := x509.NewCertPool()\n\trootPool.AddCert(rootCert)\n\n\tco := &CheckOpts{\n\t\tRootCerts:      rootPool,\n\t\tCertEmail:      \"other\",\n\t\tCertOidcIssuer: oidcIssuer,\n\t}\n\n\t_, err := ValidateAndUnpackCert(leafCert, co)\n\trequire.Contains(t, err.Error(), \"expected email not found in certificate\")\n}\n\nfunc TestCompareSigs(t *testing.T) {\n\t//TODO(nsmith5): Add test cases for invalid signature, missing signature etc\n\ttests := []struct {\n\t\tdescription string\n\t\tb64sig      string\n\t\tbundleBody  string\n\t\tshouldErr   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"sigs match\",\n\t\t\tb64sig:      \"MEQCIDO3XHbLovPWK+bk8ItCig2cwlr/8MXbLvz3UFzxMGIMAiA1lqdM9IqqUvCUqzOjufTq3sKU3qSn7R5tPqPz0ddNwQ==\",\n\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n\t\t},\n\t\t{\n\t\t\tdescription: \"sigs don't match\",\n\t\t\tb64sig:      \"bm9wZQo=\",\n\t\t\tbundleBody:  `eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIzODE1MmQxZGQzMjZhZjQwNWY4OTlkYmNjMmNlMzUwYjVmMTZkNDVkZjdmMjNjNDg4ZjQ4NTBhZmExY2Q4NmQxIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FUUNJRE8zWEhiTG92UFdLK2JrOEl0Q2lnMmN3bHIvOE1YYkx2ejNVRnp4TUdJTUFpQTFscWRNOUlxcVV2Q1Vxek9qdWZUcTNzS1UzcVNuN1I1dFBxUHowZGROd1E9PSIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCUVZVSk1TVU1nUzBWWkxTMHRMUzBLVFVacmQwVjNXVWhMYjFwSmVtb3dRMEZSV1VsTGIxcEplbW93UkVGUlkwUlJaMEZGVUN0RVIyb3ZXWFV4VG5vd01XVjVSV2hVZDNRMlQya3hXV3BGWXdwSloxRldjRlZTTjB0bUwwSm1hVk16Y1ZReFVHd3dkbGh3ZUZwNVMyWkpSMHMyZWxoQ04ybE5aV3RFVTA1M1dHWldPSEpKYUdaMmRrOW5QVDBLTFMwdExTMUZUa1FnVUZWQ1RFbERJRXRGV1MwdExTMHRDZz09In19fX0=`,\n\t\t\tshouldErr:   true,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tsig, err := static.NewSignature([]byte(\"payload\"), test.b64sig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create static signature: %v\", err)\n\t\t\t}\n\t\t\terr = compareSigs(test.bundleBody, sig)\n\t\t\tif err == nil && test.shouldErr {\n\t\t\t\tt.Fatal(\"test should have errored\")\n\t\t\t}\n\t\t\tif err != nil && !test.shouldErr {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage sget\n\nimport (\n\t\"context\"\n\t\"io\"\n\n\t\"github.com/google/go-containerregistry/pkg/authn\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/verify\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n)\n\nfunc New(image, key string, out io.Writer) *SecureGet {\n\treturn &SecureGet{\n\t\tImageRef: image,\n\t\tKeyRef:   key,\n\t\tOut:      out,\n\t}\n}\n\ntype SecureGet struct {\n\tImageRef string\n\tKeyRef   string\n\tOut      io.Writer\n}\n\nfunc (sg *SecureGet) Do(ctx context.Context) error {\n\tref, err := name.ParseReference(sg.ImageRef)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\topts := []remote.Option{\n\t\tremote.WithAuthFromKeychain(authn.DefaultKeychain),\n\t\tremote.WithContext(ctx),\n\t}\n\n\tco := &cosign.CheckOpts{\n\t\tClaimVerifier:      cosign.SimpleClaimVerifier,\n\t\tRegistryClientOpts: []ociremote.Option{ociremote.WithRemoteOptions(opts...)},\n\t}\n\tif _, ok := ref.(name.Tag); ok {\n\t\tif sg.KeyRef == \"\" && !options.EnableExperimental() {\n\t\t\treturn errors.New(\"public key must be specified when fetching by tag, you must fetch by digest or supply a public key\")\n\t\t}\n\t}\n\t// Overwrite \"ref\" with a digest to avoid a race where we verify the tag,\n\t// and then access the file through the tag.  This has a race where we\n\t// might download content that isn't what we verified.\n\tref, err = ociremote.ResolveDigest(ref, co.RegistryClientOpts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sg.KeyRef != \"\" {\n\t\tpub, err := sigs.LoadPublicKey(ctx, sg.KeyRef)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tco.SigVerifier = pub\n\t}\n\n\tif co.SigVerifier != nil || options.EnableExperimental() {\n\t\t// NB: There are only 2 kinds of verification right now:\n\t\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n\t\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n\t\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n\t\t// was performed so we don't need to use this fragile logic here.\n\t\tfulcioVerified := (co.SigVerifier == nil)\n\n\t\tco.RootCerts = fulcio.GetRoots()\n\n\t\tsp, bundleVerified, err := cosign.VerifyImageSignatures(ctx, ref, co)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tverify.PrintVerificationHeader(sg.ImageRef, co, bundleVerified, fulcioVerified)\n\t\tverify.PrintVerification(sg.ImageRef, sp, \"text\")\n\t}\n\n\t// TODO(mattmoor): Depending on what this is, use the higher-level stuff.\n\timg, err := remote.Image(ref, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tlayers, err := img.Layers()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(layers) != 1 {\n\t\treturn errors.New(\"invalid artifact\")\n\t}\n\trc, err := layers[0].Compressed()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(sg.Out, rc)\n\treturn err\n}\n", "//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build e2e\n// +build e2e\n\npackage test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-containerregistry/pkg/authn\"\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/google/go-containerregistry/pkg/registry\"\n\t\"github.com/google/go-containerregistry/pkg/v1/random\"\n\t\"github.com/google/go-containerregistry/pkg/v1/remote\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/attach\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/attest\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/download\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/generate\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/publickey\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/sign\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/upload\"\n\tcliverify \"github.com/sigstore/cosign/cmd/cosign/cli/verify\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/kubernetes\"\n\tcremote \"github.com/sigstore/cosign/pkg/cosign/remote\"\n\t\"github.com/sigstore/cosign/pkg/oci/mutate\"\n\tociremote \"github.com/sigstore/cosign/pkg/oci/remote\"\n\t\"github.com/sigstore/cosign/pkg/sget\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n\t\"github.com/sigstore/sigstore/pkg/signature/payload\"\n)\n\nconst (\n\tserverEnv = \"REKOR_SERVER\"\n\trekorURL  = \"https://rekor.sigstore.dev\"\n)\n\nvar keyPass = []byte(\"hello\")\n\nvar passFunc = func(_ bool) ([]byte, error) {\n\treturn keyPass, nil\n}\n\nvar verify = func(keyRef, imageRef string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tRekorURL:      rekorURL,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t}\n\n\targs := []string{imageRef}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\n// Used to verify local images stored on disk\nvar verifyLocal = func(keyRef, path string, checkClaims bool, annotations map[string]interface{}, attachment string) error {\n\tcmd := cliverify.VerifyCommand{\n\t\tKeyRef:        keyRef,\n\t\tCheckClaims:   checkClaims,\n\t\tAnnotations:   sigs.AnnotationsMap{Annotations: annotations},\n\t\tAttachment:    attachment,\n\t\tHashAlgorithm: crypto.SHA256,\n\t\tLocalImage:    true,\n\t}\n\n\targs := []string{path}\n\n\treturn cmd.Exec(context.Background(), args)\n}\n\nvar ro = &options.RootOptions{Timeout: options.DefaultTimeout}\n\nfunc TestSignVerify(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\t// Sign the image with an annotation\n\tannotations := map[string]interface{}{\"foo\": \"bar\"}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, annotations, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// It should match this time.\n\tmust(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n\n\t// But two doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\", \"baz\": \"bat\"}, \"\"), t)\n}\n\nfunc TestSignVerifyClean(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestImportSignVerifyClean(t *testing.T) {\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, _ = mkimage(t, imgName)\n\n\t_, privKeyPath, pubKeyPath := importKeyPair(t, td)\n\n\tctx := context.Background()\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now clean signature from the given image\n\tmust(cli.CleanCmd(ctx, options.RegistryOptions{}, \"all\", imgName), t)\n\n\t// It doesn't work\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestAttestVerify(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Verify should fail at first\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef: pubKeyPath,\n\t}\n\n\t// Fail case when using without type and policy flag\n\tmustErr(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"slsaprovenance\", false, 30*time.Second), t)\n\n\t// Use cue to verify attestation\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation.PredicateType = \"slsaprovenance\"\n\tverifyAttestation.Policies = []string{policyPath}\n\n\t// Fail case\n\tcuePolicy := `builder: id: \"1\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Success case\n\tcuePolicy = `builder: id: \"2\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName}), t)\n\n\t// Look for a specific annotation\n\tmustErr(verify(pubKeyPath, imgName, true, map[string]interface{}{\"foo\": \"bar\"}, \"\"), t)\n}\n\nfunc TestAttestationReplace(t *testing.T) {\n\t// This test is currently failing, see https://github.com/sigstore/cosign/issues/1378\n\t// The replace option for attest does not appear to work on random.Image() generated images\n\tt.Skip()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-attest-replace-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, _ := keypair(t, td)\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\n\tctx := context.Background()\n\n\tslsaAttestation := `{ \"buildType\": \"x\", \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Attest once with with replace=false creating an attestation\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"slsaprovenance\", false, 30*time.Second), t)\n\t// Attest again with replace=true, replacing the previous attestation\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"slsaprovenance\", true, 30*time.Second), t)\n\t// Attest once more replace=true using a different predicate, to ensure it adds a new attestation\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"custom\", true, 30*time.Second), t)\n\n\t// Download and count the attestations\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tregOpts := options.RegistryOptions{}\n\tociremoteOpts, err := regOpts.ClientOpts(ctx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tattestations, err := cosign.FetchAttestationsForReference(ctx, ref, ociremoteOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(attestations) != 2 {\n\t\tt.Fatal(fmt.Errorf(\"Expected len(attestations) == 2, got %d\", len(attestations)))\n\t}\n}\n\nfunc TestRekorBundle(t *testing.T) {\n\t// turn on the tlog\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tko := sign.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\n\t// Sign the image\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t// Make sure verify works\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Make sure offline verification works with bundling\n\t// use rekor prod since we have hardcoded the public key\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestDuplicateSign(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\tref, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\t// So should download\n\tmustErr(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Now sign the image\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify and download should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\tmust(download.SignatureCmd(ctx, options.RegistryOptions{}, imgName), t)\n\n\t// Signing again should work just fine...\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\tmust(err, t)\n\tsigs, err := se.Signatures()\n\tmust(err, t)\n\tsignatures, err := sigs.Get()\n\tmust(err, t)\n\n\tif len(signatures) > 1 {\n\t\tt.Errorf(\"expected there to only be one signature, got %v\", signatures)\n\t}\n}\n\nfunc TestKeyURLVerify(t *testing.T) {\n\t// TODO: re-enable once distroless images are being signed by the new client\n\tt.Skip()\n\t// Verify that an image can be verified via key url\n\tkeyRef := \"https://raw.githubusercontent.com/GoogleContainerTools/distroless/main/cosign.pub\"\n\timg := \"gcr.io/distroless/base:latest\"\n\n\tmust(verify(keyRef, img, true, nil, \"\"), t)\n}\n\nfunc TestGenerateKeyPairEnvVar(t *testing.T) {\n\tdefer setenv(t, \"COSIGN_PASSWORD\", \"foo\")()\n\tkeys, err := cosign.GenerateKeyPair(generate.GetPass)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := cosign.LoadPrivateKey(keys.PrivateBytes, []byte(\"foo\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestGenerateKeyPairK8s(t *testing.T) {\n\ttd := t.TempDir()\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tpassword := \"foo\"\n\tdefer setenv(t, \"COSIGN_PASSWORD\", password)()\n\tctx := context.Background()\n\tname := \"cosign-secret\"\n\tnamespace := \"default\"\n\tif err := kubernetes.KeyPairSecret(ctx, fmt.Sprintf(\"k8s://%s/%s\", namespace, name), generate.GetPass); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// make sure the secret actually exists\n\tclient, err := kubernetes.Client()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts, err := client.CoreV1().Secrets(namespace).Get(ctx, name, metav1.GetOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v, ok := s.Data[\"cosign.password\"]; !ok || string(v) != password {\n\t\tt.Fatalf(\"password is incorrect, got %v expected %v\", v, \"foo\")\n\t}\n}\n\nfunc TestMultipleSignatures(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, priv1, pub1 := keypair(t, td1)\n\t_, priv2, pub2 := keypair(t, td2)\n\n\t// Verify should fail at first for both keys\n\tmustErr(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image with one key\n\tko := sign.KeyOpts{KeyRef: priv1, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmustErr(verify(pub2, imgName, true, nil, \"\"), t)\n\n\t// Now sign with the other key too\n\tko.KeyRef = priv2\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify should work with both\n\tmust(verify(pub1, imgName, true, nil, \"\"), t)\n\tmust(verify(pub2, imgName, true, nil, \"\"), t)\n}\n\nfunc TestSignBlob(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t\tos.RemoveAll(td2)\n\t})\n\tbp := filepath.Join(td1, blob)\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\tctx := context.Background()\n\n\tko1 := sign.KeyOpts{\n\t\tKeyRef: pubKeyPath1,\n\t}\n\tko2 := sign.KeyOpts{\n\t\tKeyRef: pubKeyPath2,\n\t}\n\t// Verify should fail on a bad input\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko1, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, \"badsig\", blob), t)\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko2, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, \"badsig\", blob), t)\n\n\t// Now sign the blob with one key\n\tko := sign.KeyOpts{\n\t\tKeyRef:   privKeyPath1,\n\t\tPassFunc: passFunc,\n\t}\n\tsig, err := sign.SignBlobCmd(ro, ko, options.RegistryOptions{}, bp, true, \"\", \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work with that one, but not the other\n\tmust(cliverify.VerifyBlobCmd(ctx, ko1, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, string(sig), bp), t)\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko2, \"\" /*certRef*/, \"\" /*certEmail*/, \"\" /*certOidcIssuer*/, string(sig), bp), t)\n}\n\nfunc TestSignBlobBundle(t *testing.T) {\n\tblob := \"someblob\"\n\ttd1 := t.TempDir()\n\tt.Cleanup(func() {\n\t\tos.RemoveAll(td1)\n\t})\n\tbp := filepath.Join(td1, blob)\n\tbundlePath := filepath.Join(td1, \"bundle.sig\")\n\n\tif err := os.WriteFile(bp, []byte(blob), 0644); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\n\tctx := context.Background()\n\n\tko1 := sign.KeyOpts{\n\t\tKeyRef:     pubKeyPath1,\n\t\tBundlePath: bundlePath,\n\t}\n\t// Verify should fail on a bad input\n\tmustErr(cliverify.VerifyBlobCmd(ctx, ko1, \"\", \"\", \"\", \"\", blob), t)\n\n\t// Now sign the blob with one key\n\tko := sign.KeyOpts{\n\t\tKeyRef:     privKeyPath1,\n\t\tPassFunc:   passFunc,\n\t\tBundlePath: bundlePath,\n\t\tRekorURL:   rekorURL,\n\t}\n\tif _, err := sign.SignBlobCmd(ro, ko, options.RegistryOptions{}, bp, true, \"\", \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// Now verify should work\n\tmust(cliverify.VerifyBlobCmd(ctx, ko1, \"\", \"\", \"\", \"\", bp), t)\n\n\t// Now we turn on the tlog and sign again\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\tif _, err := sign.SignBlobCmd(ro, ko, options.RegistryOptions{}, bp, true, \"\", \"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Point to a fake rekor server to make sure offline verification of the tlog entry works\n\tos.Setenv(serverEnv, \"notreal\")\n\tmust(cliverify.VerifyBlobCmd(ctx, ko1, \"\", \"\", \"\", \"\", bp), t)\n}\n\nfunc TestGenerate(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\t_, desc, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t// Generate the payload for the image, and check the digest.\n\tb := bytes.Buffer{}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, nil, &b), t)\n\tss := payload.SimpleContainerImage{}\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\n\t// Now try with some annotations.\n\tb.Reset()\n\ta := map[string]interface{}{\"foo\": \"bar\"}\n\tmust(generate.GenerateCmd(context.Background(), options.RegistryOptions{}, imgName, a, &b), t)\n\tmust(json.Unmarshal(b.Bytes(), &ss), t)\n\n\tequals(desc.Digest.String(), ss.Critical.Image.DockerManifestDigest, t)\n\tequals(ss.Optional[\"foo\"], \"bar\", t)\n}\n\nfunc keypair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\tkeys, err := cosign.GenerateKeyPair(passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n}\n\nfunc importKeyPair(t *testing.T, td string) (*cosign.KeysBytes, string, string) {\n\n\tconst validrsa1 = `-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAx5piWVlE62NnZ0UzJ8Z6oKiKOC4dbOZ1HsNhIRtqkM+Oq4G+\n25yq6P+0JU/Qvr9veOGEb3R/J9u8JBo+hv2i5X8OtgvP2V2pi6f1s6vK7L0+6uRb\n4YTT/UdMshaVf97MgEqbq41Jf/cuvh+3AV0tZ1BpixZg4aXMKpY6HUP69lbsu27o\nSUN1myMv7TSgZiV4CYs3l/gkEfpysBptWlcHRuw5RsB+C0RbjRtbJ/5VxmE/vd3M\nlafd5t1WSpMb8yf0a84u5NFaXwZ7CweMfXeOddS0yb19ShSuW3PPRadruBM1mq15\njs9GfagPxDS75Imcs+fA62lWvHxEujTGjYHxawIDAQABAoIBAH+sgLwmHa9zJfEo\nklAe5NFe/QpydN/ziXbkAnzqzH9URC3wD+TpkWj4JoK3Sw635NWtasjf+3XDV9S/\n9L7j/g5N91r6sziWcJykEsWaXXKQmm4lI6BdFjwsHyLKz1W7bZOiJXDWLu1rbrqu\nDqEQuLoc9WXCKrYrFy0maoXNtfla/1p05kKN0bMigcnnyAQ+xBTwoyco4tkIz5se\nIYxorz7qzXrkHQI+knz5BawmNe3ekoSaXUPoLoOR7TRTGsLteL5yukvWAi8S/0rE\ngftC+PZCQpoQhSUYq7wXe7RowJ1f+kXb7HsSedOTfTSW1D/pUb/uW+CcRKig42ZI\nI9H9TAECgYEA5XGBML6fJyWVqx64sHbUAjQsmQ0RwU6Zo7sqHIEPf6tYVYp7KtzK\nKOfi8seOOL5FSy4pjCo11Dzyrh9bn45RNmtjSYTgOnVPSoCfuRNfOcpG+/wCHjYf\nEjDvdrCpbg59kVUeaMeBDiyWAlM48HJAn8O7ez2U/iKQCyJmOIwFhSkCgYEA3rSz\nFi1NzqYWxWos4NBmg8iKcQ9SMkmPdgRLAs/WNnZJ8fdgJZwihevkXGytRGJEmav2\nGMKRx1g6ey8fjXTQH9WM8X/kJC5fv8wLHnUCH/K3Mcp9CYwn7PFvSnBr4kQoc/el\nbURhcF1+/opEC8vNX/Wk3zAG7Xs1PREXlH2SIHMCgYBV/3kgwBH/JkM25EjtO1yz\nhsLAivmAruk/SUO7c1RP0fVF+qW3pxHOyztxLALOmeJ3D1JbSubqKf377Zz17O3b\nq9yHDdrNjnKtxhAX2n7ytjJs+EQC9t4mf1kB761RpvTBqFnBhCWHHocLUA4jcW9v\ncnmu86IIrwO2aKpPv4vCIQKBgHU9gY3qOazRSOmSlJ+hdmZn+2G7pBTvHsQNTIPl\ncCrpqNHl3crO4GnKHkT9vVVjuiOAIKU2QNJFwzu4Og8Y8LvhizpTjoHxm9x3iV72\nUDELcJ+YrqyJCTe2flUcy96o7Pbn50GXnwgtYD6WAW6IUszyn2ITgYIhu4wzZEt6\ns6O7AoGAPTKbRA87L34LMlXyUBJma+etMARIP1zu8bXJ7hSJeMcog8zaLczN7ruT\npGAaLxggvtvuncMuTrG+cdmsR9SafSFKRS92NCxhOUonQ+NP6mLskIGzJZoQ5JvQ\nqGzRVIDGbNkrVHM0IsAtHRpC0rYrtZY+9OwiraGcsqUMLwwQdCA=\n-----END RSA PRIVATE KEY-----`\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chdir(td); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tos.Chdir(wd)\n\t}()\n\n\terr = os.WriteFile(\"validrsa1.key\", []byte(validrsa1), 0600)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tkeys, err := cosign.ImportKeyPair(\"validrsa1.key\", passFunc)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tprivKeyPath := filepath.Join(td, \"import-cosign.key\")\n\tif err := os.WriteFile(privKeyPath, keys.PrivateBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpubKeyPath := filepath.Join(td, \"import-cosign.pub\")\n\tif err := os.WriteFile(pubKeyPath, keys.PublicBytes, 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn keys, privKeyPath, pubKeyPath\n\n}\n\nfunc TestUploadDownload(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\n\ttestCases := map[string]struct {\n\t\tsignature     string\n\t\tsignatureType attach.SignatureArgType\n\t\texpectedErr   bool\n\t}{\n\t\t\"file containing signature\": {\n\t\t\tsignature:     \"testsignaturefile\",\n\t\t\tsignatureType: attach.FileSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"raw signature as argument\": {\n\t\t\tsignature:     \"testsignatureraw\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   false,\n\t\t},\n\t\t\"empty signature as argument\": {\n\t\t\tsignature:     \"\",\n\t\t\tsignatureType: attach.RawSignature,\n\t\t\texpectedErr:   true,\n\t\t},\n\t}\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\tfor testName, testCase := range testCases {\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tref, _, cleanup := mkimage(t, imgName)\n\t\t\tpayload := \"testpayload\"\n\t\t\tpayloadPath := mkfile(payload, td, t)\n\t\t\tsignature := base64.StdEncoding.EncodeToString([]byte(testCase.signature))\n\n\t\t\tvar sigRef string\n\t\t\tif testCase.signatureType == attach.FileSignature {\n\t\t\t\tsigRef = mkfile(signature, td, t)\n\t\t\t} else {\n\t\t\t\tsigRef = signature\n\t\t\t}\n\n\t\t\t// Upload it!\n\t\t\terr := attach.SignatureCmd(ctx, options.RegistryOptions{}, sigRef, payloadPath, imgName)\n\t\t\tif testCase.expectedErr {\n\t\t\t\tmustErr(err, t)\n\t\t\t} else {\n\t\t\t\tmust(err, t)\n\t\t\t}\n\n\t\t\t// Now download it!\n\t\t\tse, err := ociremote.SignedEntity(ref, ociremote.WithRemoteOptions(registryClientOpts(ctx)...))\n\t\t\tmust(err, t)\n\t\t\tsigs, err := se.Signatures()\n\t\t\tmust(err, t)\n\t\t\tsignatures, err := sigs.Get()\n\t\t\tmust(err, t)\n\n\t\t\tif testCase.expectedErr {\n\t\t\t\tif len(signatures) != 0 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 0\", len(signatures))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif len(signatures) != 1 {\n\t\t\t\t\tt.Fatalf(\"unexpected signatures %d, wanted 1\", len(signatures))\n\t\t\t\t}\n\n\t\t\t\tif b64sig, err := signatures[0].Base64Signature(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Base64Signature() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(b64sig, signature); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\n\t\t\t\tif p, err := signatures[0].Payload(); err != nil {\n\t\t\t\t\tt.Fatalf(\"Payload() = %v\", err)\n\t\t\t\t} else if diff := cmp.Diff(p, []byte(payload)); diff != \"\" {\n\t\t\t\t\tt.Error(diff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now delete it!\n\t\t\tcleanup()\n\t\t})\n\t}\n}\n\nfunc TestUploadBlob(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\tctx := context.Background()\n\n\timgName := path.Join(repo, \"/cosign-upload-e2e\")\n\tpayload := \"testpayload\"\n\tpayloadPath := mkfile(payload, td, t)\n\n\t// Upload it!\n\tfiles := []cremote.File{cremote.FileFromFlag(payloadPath)}\n\tmust(upload.BlobCmd(ctx, options.RegistryOptions{}, files, \"\", imgName), t)\n\n\t// Check it\n\tref, err := name.ParseReference(imgName)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now download it with sget (this should fail by tag)\n\tif err := sget.New(imgName, \"\", os.Stdout).Do(ctx); err == nil {\n\t\tt.Error(\"expected download to fail\")\n\t}\n\n\timg, err := remote.Image(ref)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdgst, err := img.Digest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresult := &bytes.Buffer{}\n\n\t// But pass by digest\n\tif err := sget.New(imgName+\"@\"+dgst.String(), \"\", result).Do(ctx); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb, err := io.ReadAll(result)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(b) != payload {\n\t\tt.Errorf(\"expected contents to be %s, got %s\", payload, string(b))\n\t}\n}\n\nfunc TestSaveLoad(t *testing.T) {\n\ttests := []struct {\n\t\tdescription     string\n\t\tgetSignedEntity func(t *testing.T, n string) (name.Reference, *remote.Descriptor, func())\n\t}{\n\t\t{\n\t\t\tdescription:     \"save and load an image\",\n\t\t\tgetSignedEntity: mkimage,\n\t\t},\n\t\t{\n\t\t\tdescription:     \"save and load an image index\",\n\t\t\tgetSignedEntity: mkimageindex,\n\t\t},\n\t}\n\tfor i, test := range tests {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\trepo, stop := reg(t)\n\t\t\tdefer stop()\n\t\t\tkeysDir := t.TempDir()\n\n\t\t\timgName := path.Join(repo, fmt.Sprintf(\"save-load-%d\", i))\n\n\t\t\t_, _, cleanup := test.getSignedEntity(t, imgName)\n\t\t\tdefer cleanup()\n\n\t\t\t_, privKeyPath, pubKeyPath := keypair(t, keysDir)\n\n\t\t\tctx := context.Background()\n\t\t\t// Now sign the image and verify it\n\t\t\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\t\t\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t\t\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t\t\t// save the image to a temp dir\n\t\t\timageDir := t.TempDir()\n\t\t\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t\t\t// verify the local image using a local key\n\t\t\tmust(verifyLocal(pubKeyPath, imageDir, true, nil, \"\"), t)\n\n\t\t\t// load the image from the temp dir into a new image and verify the new image\n\t\t\timgName2 := path.Join(repo, fmt.Sprintf(\"save-load-%d-2\", i))\n\t\t\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\t\t\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t\t})\n\t}\n}\n\nfunc TestSaveLoadAttestation(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"save-load\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\t// Now sign the image and verify it\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// now, append an attestation to the image\n\tslsaAttestation := `{ \"builder\": { \"id\": \"2\" }, \"recipe\": {} }`\n\tslsaAttestationPath := filepath.Join(td, \"attestation.slsa.json\")\n\tif err := os.WriteFile(slsaAttestationPath, []byte(slsaAttestation), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Now attest the image\n\tko = sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc}\n\tmust(attest.AttestCmd(ctx, ko, options.RegistryOptions{}, imgName, \"\", false, slsaAttestationPath, false,\n\t\t\"custom\", false, 30*time.Second), t)\n\n\t// save the image to a temp dir\n\timageDir := t.TempDir()\n\tmust(cli.SaveCmd(ctx, options.SaveOptions{Directory: imageDir}, imgName), t)\n\n\t// load the image from the temp dir into a new image and verify the new image\n\timgName2 := path.Join(repo, \"save-load-2\")\n\tmust(cli.LoadCmd(ctx, options.LoadOptions{Directory: imageDir}, imgName2), t)\n\tmust(verify(pubKeyPath, imgName2, true, nil, \"\"), t)\n\t// Use cue to verify attestation on the new image\n\tpolicyPath := filepath.Join(td, \"policy.cue\")\n\tverifyAttestation := cliverify.VerifyAttestationCommand{\n\t\tKeyRef: pubKeyPath,\n\t}\n\tverifyAttestation.PredicateType = \"slsaprovenance\"\n\tverifyAttestation.Policies = []string{policyPath}\n\t// Success case (remote)\n\tcuePolicy := `builder: id: \"2\"`\n\tif err := os.WriteFile(policyPath, []byte(cuePolicy), 0600); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmust(verifyAttestation.Exec(ctx, []string{imgName2}), t)\n\t// Success case (local)\n\tverifyAttestation.LocalImage = true\n\tmust(verifyAttestation.Exec(ctx, []string{imageDir}), t)\n}\n\nfunc TestAttachSBOM(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\tctx := context.Background()\n\n\timgName := path.Join(repo, \"sbom-image\")\n\timg, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\tout := bytes.Buffer{}\n\t_, err := download.SBOMCmd(ctx, options.RegistryOptions{}, img.Name(), &out)\n\tif err == nil {\n\t\tt.Fatal(\"Expected error\")\n\t}\n\tt.Log(out.String())\n\tout.Reset()\n\n\t// Upload it!\n\tmust(attach.SBOMCmd(ctx, options.RegistryOptions{}, \"./testdata/bom-go-mod.spdx\", \"spdx\", imgName), t)\n\n\tsboms, err := download.SBOMCmd(ctx, options.RegistryOptions{}, imgName, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Log(out.String())\n\tif len(sboms) != 1 {\n\t\tt.Fatalf(\"Expected one sbom, got %d\", len(sboms))\n\t}\n\twant, err := os.ReadFile(\"./testdata/bom-go-mod.spdx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := cmp.Diff(string(want), sboms[0]); diff != \"\" {\n\t\tt.Errorf(\"diff: %s\", diff)\n\t}\n\n\t// Generate key pairs to sign the sbom\n\ttd1 := t.TempDir()\n\ttd2 := t.TempDir()\n\t_, privKeyPath1, pubKeyPath1 := keypair(t, td1)\n\t_, _, pubKeyPath2 := keypair(t, td2)\n\n\t// Verify should fail on a bad input\n\tmustErr(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n\n\t// Now sign the sbom with one key\n\tko1 := sign.KeyOpts{KeyRef: privKeyPath1, PassFunc: passFunc}\n\tmust(sign.SignCmd(ro, ko1, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"sbom\"), t)\n\n\t// Now verify should work with that one, but not the other\n\tmust(verify(pubKeyPath1, imgName, true, nil, \"sbom\"), t)\n\tmustErr(verify(pubKeyPath2, imgName, true, nil, \"sbom\"), t)\n}\n\nfunc setenv(t *testing.T, k, v string) func() {\n\tif err := os.Setenv(k, v); err != nil {\n\t\tt.Fatalf(\"error setting env: %v\", err)\n\t}\n\treturn func() {\n\t\tos.Unsetenv(k)\n\t}\n}\n\nfunc TestTlog(t *testing.T) {\n\trepo, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timgName := path.Join(repo, \"cosign-e2e\")\n\n\t_, _, cleanup := mkimage(t, imgName)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\t// Verify should fail at first\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now sign the image without the tlog\n\tko := sign.KeyOpts{\n\t\tKeyRef:   privKeyPath,\n\t\tPassFunc: passFunc,\n\t\tRekorURL: rekorURL,\n\t}\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\n\t// Now verify should work!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Now we turn on the tlog!\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\n\t// Verify shouldn't work since we haven't put anything in it yet.\n\tmustErr(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n\n\t// Sign again with the tlog env var on\n\tmust(sign.SignCmd(ro, ko, options.RegistryOptions{}, nil, []string{imgName}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\t// And now verify works!\n\tmust(verify(pubKeyPath, imgName, true, nil, \"\"), t)\n}\n\nfunc TestGetPublicKeyCustomOut(t *testing.T) {\n\ttd := t.TempDir()\n\tkeys, privKeyPath, _ := keypair(t, td)\n\tctx := context.Background()\n\n\toutFile := \"output.pub\"\n\toutPath := filepath.Join(td, outFile)\n\toutWriter, err := os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE, 0600)\n\tmust(err, t)\n\n\tpk := publickey.Pkopts{\n\t\tKeyRef: privKeyPath,\n\t}\n\tmust(publickey.GetPublicKey(ctx, pk, publickey.NamedWriter{Name: outPath, Writer: outWriter}, passFunc), t)\n\n\toutput, err := os.ReadFile(outPath)\n\tmust(err, t)\n\tequals(keys.PublicBytes, output, t)\n}\n\nfunc mkfile(contents, td string, t *testing.T) string {\n\tf, err := os.CreateTemp(td, \"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tif _, err := f.Write([]byte(contents)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn f.Name()\n}\n\nfunc mkimage(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\timg, err := random.Image(512, 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.Write(ref, img, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteImage, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteImage.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteImage, cleanup\n}\n\nfunc mkimageindex(t *testing.T, n string) (name.Reference, *remote.Descriptor, func()) {\n\tref, err := name.ParseReference(n, name.WeakValidation)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tii, err := random.Index(512, 5, 4)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tregClientOpts := registryClientOpts(context.Background())\n\n\tif err := remote.WriteIndex(ref, ii, regClientOpts...); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tremoteIndex, err := remote.Get(ref, regClientOpts...)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func() {\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t\tref, _ := ociremote.SignatureTag(ref.Context().Digest(remoteIndex.Descriptor.Digest.String()), ociremote.WithRemoteOptions(regClientOpts...))\n\t\t_ = remote.Delete(ref, regClientOpts...)\n\t}\n\treturn ref, remoteIndex, cleanup\n}\n\nfunc must(err error, t *testing.T) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc mustErr(err error, t *testing.T) {\n\tt.Helper()\n\tif err == nil {\n\t\tt.Fatal(\"expected error\")\n\t}\n}\n\nfunc equals(v1, v2 interface{}, t *testing.T) {\n\tif diff := cmp.Diff(v1, v2); diff != \"\" {\n\t\tt.Error(diff)\n\t}\n}\n\nfunc reg(t *testing.T) (string, func()) {\n\trepo := os.Getenv(\"COSIGN_TEST_REPO\")\n\tif repo != \"\" {\n\t\treturn repo, func() {}\n\t}\n\n\tt.Log(\"COSIGN_TEST_REPO unset, using fake registry\")\n\tr := httptest.NewServer(registry.New())\n\tu, err := url.Parse(r.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn u.Host, r.Close\n}\n\nfunc registryClientOpts(ctx context.Context) []remote.Option {\n\treturn []remote.Option{\n\t\tremote.WithAuthFromKeychain(authn.DefaultKeychain),\n\t\tremote.WithContext(ctx),\n\t}\n}\n\n// If a signature has a bundle, but *not for that signature*, cosign verification should fail\n// This test is pretty long, so here are the basic points:\n//    1. Sign image1 with a keypair, store entry in rekor\n//    2. Sign image2 with keypair, DO NOT store entry in rekor\n//    3. Take the bundle from image1 and store it on the signature in image2\n//    4. Verification of image2 should now fail, since the bundle is for a different signature\nfunc TestInvalidBundle(t *testing.T) {\n\tregName, stop := reg(t)\n\tdefer stop()\n\ttd := t.TempDir()\n\n\timg1 := path.Join(regName, \"cosign-e2e\")\n\n\timgRef, _, cleanup := mkimage(t, img1)\n\tdefer cleanup()\n\n\t_, privKeyPath, pubKeyPath := keypair(t, td)\n\n\tctx := context.Background()\n\n\t// Sign image1 and store the entry in rekor\n\t// (we're just using it for its bundle)\n\tdefer setenv(t, options.ExperimentalEnv, \"1\")()\n\tremoteOpts := ociremote.WithRemoteOptions(registryClientOpts(ctx)...)\n\tko := sign.KeyOpts{KeyRef: privKeyPath, PassFunc: passFunc, RekorURL: rekorURL}\n\tregOpts := options.RegistryOptions{}\n\n\tmust(sign.SignCmd(ro, ko, regOpts, nil, []string{img1}, \"\", true, \"\", \"\", \"\", true, false, \"\"), t)\n\t// verify image1\n\tmust(verify(pubKeyPath, img1, true, nil, \"\"), t)\n\t// extract the bundle from image1\n\tsi, err := ociremote.SignedImage(imgRef, remoteOpts)\n\tmust(err, t)\n\timgSigs, err := si.Signatures()\n\tmust(err, t)\n\tsigs, err := imgSigs.Get()\n\tmust(err, t)\n\tif l := len(sigs); l != 1 {\n\t\tt.Error(\"expected one signature\")\n\t}\n\tbund, err := sigs[0].Bundle()\n\tmust(err, t)\n\tif bund == nil {\n\t\tt.Fail()\n\t}\n\n\t// Now, we move on to image2\n\t// Sign image2 and DO NOT store the entry in rekor\n\tdefer setenv(t, options.ExperimentalEnv, \"0\")()\n\timg2 := path.Join(regName, \"unrelated\")\n\timgRef2, _, cleanup := mkimage(t, img2)\n\tdefer cleanup()\n\tmust(sign.SignCmd(ro, ko, regOpts, nil, []string{img2}, \"\", true, \"\", \"\", \"\", false, false, \"\"), t)\n\tmust(verify(pubKeyPath, img2, true, nil, \"\"), t)\n\n\tsi2, err := ociremote.SignedEntity(imgRef2, remoteOpts)\n\tmust(err, t)\n\tsigs2, err := si2.Signatures()\n\tmust(err, t)\n\tgottenSigs2, err := sigs2.Get()\n\tmust(err, t)\n\tif len(gottenSigs2) != 1 {\n\t\tt.Fatal(\"there should be one signature\")\n\t}\n\tsigsTag, err := ociremote.SignatureTag(imgRef2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// At this point, we would mutate the signature to add the bundle annotation\n\t// since we don't have a function for it at the moment, mock this by deleting the signature\n\t// and pushing a new signature with the additional bundle annotation\n\tif err := remote.Delete(sigsTag); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmustErr(verify(pubKeyPath, img2, true, nil, \"\"), t)\n\n\tnewSig, err := mutate.Signature(gottenSigs2[0], mutate.WithBundle(bund))\n\tmust(err, t)\n\tsi2, err = ociremote.SignedEntity(imgRef2, remoteOpts)\n\tmust(err, t)\n\tnewImage, err := mutate.AttachSignatureToEntity(si2, newSig)\n\tmust(err, t)\n\tif err := ociremote.WriteSignatures(sigsTag.Repository, newImage); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// veriyfing image2 now should fail\n\tmustErr(verify(pubKeyPath, img2, true, nil, \"\"), t)\n}\n"], "filenames": ["cmd/cosign/cli/verify/verify.go", "cmd/cosign/cli/verify/verify_attestation.go", "pkg/cosign/verify.go", "pkg/cosign/verify_test.go", "pkg/sget/sget.go", "test/e2e_test.go"], "buggy_code_start_loc": [148, 129, 588, 28, 85, 57], "buggy_code_end_loc": [199, 271, 698, 198, 93, 1158], "fixing_code_start_loc": [149, 130, 589, 29, 86, 58], "fixing_code_end_loc": [208, 278, 766, 237, 100, 1251], "type": "CWE-295", "message": "Cosign provides container signing, verification, and storage in an OCI registry for the sigstore project. Prior to version 1.5.2, Cosign can be manipulated to claim that an entry for a signature exists in the Rekor transparency log even if it doesn't. This requires the attacker to have pull and push permissions for the signature in OCI. This can happen with both standard signing with a keypair and \"keyless signing\" with Fulcio. If an attacker has access to the signature in OCI, they can manipulate cosign into believing the entry was stored in Rekor even though it wasn't. The vulnerability has been patched in v1.5.2 of Cosign. The `signature` in the `signedEntryTimestamp` provided by Rekor is now compared to the `signature` that is being verified. If these don't match, then an error is returned. If a valid bundle is copied to a different signature, verification should fail. Cosign output now only informs the user that certificates were verified if a certificate was in fact verified. There is currently no known workaround.", "other": {"cve": {"id": "CVE-2022-23649", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-18T22:15:12.793", "lastModified": "2022-03-07T14:27:45.293", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cosign provides container signing, verification, and storage in an OCI registry for the sigstore project. Prior to version 1.5.2, Cosign can be manipulated to claim that an entry for a signature exists in the Rekor transparency log even if it doesn't. This requires the attacker to have pull and push permissions for the signature in OCI. This can happen with both standard signing with a keypair and \"keyless signing\" with Fulcio. If an attacker has access to the signature in OCI, they can manipulate cosign into believing the entry was stored in Rekor even though it wasn't. The vulnerability has been patched in v1.5.2 of Cosign. The `signature` in the `signedEntryTimestamp` provided by Rekor is now compared to the `signature` that is being verified. If these don't match, then an error is returned. If a valid bundle is copied to a different signature, verification should fail. Cosign output now only informs the user that certificates were verified if a certificate was in fact verified. There is currently no known workaround."}, {"lang": "es", "value": "Cosign proporciona firma de contenedores, verificaci\u00f3n y almacenamiento en un registro OCI para el proyecto sigstore. En versiones anteriores a 1.5.2, Cosign puede ser manipulado para afirmar que se presenta una entrada para una firma en el registro de transparencia de Rekor aunque no sea as\u00ed. Esto requiere que el atacante tenga permisos pull y push para la firma en OCI. Esto puede ocurrir tanto con la firma est\u00e1ndar con un par de claves como con \"keyless signing\" con Fulcio. Si un atacante presenta acceso a la firma en OCI, puede manipular la cosigna para que crea que la entrada fue almacenada en Rekor aunque no lo haya sido. La vulnerabilidad ha sido parcheada en versi\u00f3n v1.5.2 de Cosign. La \"signature\" en  \"signedEntryTimestamp\" proporcionado por Rekor es comparado ahora con el \"signature\" que esta siendo verificando. Si no coinciden, es devuelto un error. Si es copiado un paquete v\u00e1lido con una firma diferente, la verificaci\u00f3n deber\u00eda fallar. La salida de Cosign ahora s\u00f3lo informa al usuario de que los certificados han sido verificados si un certificado ha sido verificado realmente. Actualmente no es conocida ninguna medida de mitigaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sigstore:cosign:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.2", "matchCriteriaId": "00E39425-E401-4EC7-A900-3A6BB6961975"}]}]}], "references": [{"url": "https://github.com/sigstore/cosign/commit/96d410a6580e4e81d24d112a0855c70ca3fb5b49", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sigstore/cosign/security/advisories/GHSA-ccxc-vr6p-4858", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sigstore/cosign/commit/96d410a6580e4e81d24d112a0855c70ca3fb5b49"}}