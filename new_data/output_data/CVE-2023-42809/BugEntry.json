{"buggy_code": ["/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * \n * @author Nikita Koksharov\n *\n */\npublic class CustomObjectInputStream extends ObjectInputStream {\n\n    private final ClassLoader classLoader;\n    \n    public CustomObjectInputStream(ClassLoader classLoader, InputStream in) throws IOException {\n        super(in);\n        this.classLoader = classLoader;\n    }\n    \n    @Override\n    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n        try {\n            String name = desc.getName();\n            return Class.forName(name, false, classLoader);\n        } catch (ClassNotFoundException e) {\n            return super.resolveClass(desc);\n        }\n    }\n    \n    @Override\n    protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {\n        List<Class<?>> loadedClasses = new ArrayList<Class<?>>(interfaces.length);\n        \n        for (String name : interfaces) {\n            Class<?> clazz = Class.forName(name, false, classLoader);\n            loadedClasses.add(clazz);\n        }\n        \n        return Proxy.getProxyClass(classLoader, loadedClasses.toArray(new Class[loadedClasses.size()]));\n    }\n    \n}\n", "/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.redisson.client.codec.BaseCodec;\nimport org.redisson.client.handler.State;\nimport org.redisson.client.protocol.Decoder;\nimport org.redisson.client.protocol.Encoder;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\n\n/**\n * JDK's serialization codec.\n * <p>\n * Fully thread-safe.*\n *\n * @author Nikita Koksharov\n *\n */\npublic class SerializationCodec extends BaseCodec {\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n    \n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}\n"], "fixing_code": ["/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport java.io.*;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * \n * @author Nikita Koksharov\n *\n */\npublic class CustomObjectInputStream extends ObjectInputStream {\n\n    private final ClassLoader classLoader;\n    private Set<String> allowedClasses;\n\n    public CustomObjectInputStream(ClassLoader classLoader, InputStream in,Set<String> allowedClasses) throws IOException {\n        super(in);\n        this.classLoader = classLoader;\n        this.allowedClasses = allowedClasses;\n    }\n\n    public CustomObjectInputStream(ClassLoader classLoader, InputStream in) throws IOException {\n        super(in);\n        this.classLoader = classLoader;\n    }\n    \n    @Override\n    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n        try {\n            String name = desc.getName();\n            if (allowedClasses != null && !allowedClasses.contains(name)) {\n                throw new InvalidClassException(\"Class \" + name + \" isn't allowed\");\n            }\n            return Class.forName(name, false, classLoader);\n        } catch (ClassNotFoundException e) {\n            return super.resolveClass(desc);\n        }\n    }\n    \n    @Override\n    protected Class<?> resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {\n        List<Class<?>> loadedClasses = new ArrayList<Class<?>>(interfaces.length);\n        \n        for (String name : interfaces) {\n            Class<?> clazz = Class.forName(name, false, classLoader);\n            loadedClasses.add(clazz);\n        }\n        \n        return Proxy.getProxyClass(classLoader, loadedClasses.toArray(new Class[0]));\n    }\n    \n}\n", "/**\n * Copyright (c) 2013-2022 Nikita Koksharov\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.redisson.codec;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\nimport org.redisson.client.codec.BaseCodec;\nimport org.redisson.client.handler.State;\nimport org.redisson.client.protocol.Decoder;\nimport org.redisson.client.protocol.Encoder;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Set;\n\n/**\n * JDK's serialization codec.\n * <p>\n * Fully thread-safe.*\n *\n * @author Nikita Koksharov\n *\n */\npublic class SerializationCodec extends BaseCodec {\n\n    private final Decoder<Object> decoder = new Decoder<Object>() {\n        @Override\n        public Object decode(ByteBuf buf, State state) throws IOException {\n            try {\n                //set thread context class loader to be the classLoader variable as there could be reflection\n                //done while reading from input stream which reflection will use thread class loader to load classes on demand\n                ClassLoader currentThreadClassLoader = Thread.currentThread().getContextClassLoader();\n                try {\n                    ByteBufInputStream in = new ByteBufInputStream(buf);\n                    ObjectInputStream inputStream;\n                    if (classLoader != null) {\n                        Thread.currentThread().setContextClassLoader(classLoader);\n                        inputStream = new CustomObjectInputStream(classLoader, in, allowedClasses);\n                    } else {\n                        inputStream = new ObjectInputStream(in);\n                    }\n                    return inputStream.readObject();\n                } finally {\n                    Thread.currentThread().setContextClassLoader(currentThreadClassLoader);\n                }\n            } catch (IOException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IOException(e);\n            }\n        }\n    };\n\n    private final Encoder encoder = new Encoder() {\n\n        @Override\n        public ByteBuf encode(Object in) throws IOException {\n            ByteBuf out = ByteBufAllocator.DEFAULT.buffer();\n            try {\n                ByteBufOutputStream result = new ByteBufOutputStream(out);\n                ObjectOutputStream outputStream = new ObjectOutputStream(result);\n                outputStream.writeObject(in);\n                outputStream.close();\n                return result.buffer();\n            } catch (IOException e) {\n                out.release();\n                throw e;\n            }\n        }\n    };\n\n    private Set<String> allowedClasses;\n    private final ClassLoader classLoader;\n\n    public SerializationCodec() {\n        this(null);\n    }\n    \n    public SerializationCodec(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, SerializationCodec codec) {\n        this.classLoader = classLoader;\n        this.allowedClasses = codec.allowedClasses;\n    }\n\n    public SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses) {\n        this.classLoader = classLoader;\n        this.allowedClasses = allowedClasses;\n    }\n    \n    @Override\n    public Decoder<Object> getValueDecoder() {\n        return decoder;\n    }\n\n    @Override\n    public Encoder getValueEncoder() {\n        return encoder;\n    }\n    \n    @Override\n    public ClassLoader getClassLoader() {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        return getClass().getClassLoader();\n    }\n\n}\n"], "filenames": ["redisson/src/main/java/org/redisson/codec/CustomObjectInputStream.java", "redisson/src/main/java/org/redisson/codec/SerializationCodec.java"], "buggy_code_start_loc": [18, 18], "buggy_code_end_loc": [60, 99], "fixing_code_start_loc": [18, 18], "fixing_code_end_loc": [68, 107], "type": "CWE-502", "message": "Redisson is a Java Redis client that uses the Netty framework. Prior to version 3.22.0, some of the messages received from the Redis server contain Java objects that the client deserializes without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running in. Version 3.22.0 contains a patch for this issue.\n\nSome post-fix advice is available. Do NOT use `Kryo5Codec` as deserialization codec, as it is still vulnerable to arbitrary object deserialization due to the `setRegistrationRequired(false)` call. On the contrary, `KryoCodec` is safe to use. The fix applied to `SerializationCodec` only consists of adding an optional allowlist of class names, even though making this behavior the default is recommended. When instantiating `SerializationCodec` please use the `SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses)` constructor to restrict the allowed classes for deserialization.", "other": {"cve": {"id": "CVE-2023-42809", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-04T20:15:10.263", "lastModified": "2023-10-10T17:21:16.110", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redisson is a Java Redis client that uses the Netty framework. Prior to version 3.22.0, some of the messages received from the Redis server contain Java objects that the client deserializes without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running in. Version 3.22.0 contains a patch for this issue.\n\nSome post-fix advice is available. Do NOT use `Kryo5Codec` as deserialization codec, as it is still vulnerable to arbitrary object deserialization due to the `setRegistrationRequired(false)` call. On the contrary, `KryoCodec` is safe to use. The fix applied to `SerializationCodec` only consists of adding an optional allowlist of class names, even though making this behavior the default is recommended. When instantiating `SerializationCodec` please use the `SerializationCodec(ClassLoader classLoader, Set<String> allowedClasses)` constructor to restrict the allowed classes for deserialization."}, {"lang": "es", "value": "Redisson es un cliente Java Redis que utiliza el framework Netty. Antes de la versi\u00f3n 3.22.0, algunos de los mensajes recibidos del servidor Redis contienen objetos Java que el cliente deserializa sin mayor validaci\u00f3n. Los atacantes que logran enga\u00f1ar a los clientes para que se comuniquen con un servidor malicioso pueden incluir objetos especialmente manipulados en sus respuestas que, una vez deserializados por el cliente, lo obligan a ejecutar c\u00f3digo arbitrario. Se puede abusar de esto para tomar el control de la m\u00e1quina en la que se ejecuta el cliente. La versi\u00f3n 3.22.0 contiene un parche para este problema. Se encuentran disponibles algunos consejos posteriores a la reparaci\u00f3n. NO utilice `Kryo5Codec` como c\u00f3dec de deserializaci\u00f3n, ya que a\u00fan es vulnerable a la deserializaci\u00f3n arbitraria de objetos debido a la llamada `setRegistrationRequired(false)`. Por el contrario, \"KryoCodec\" es seguro de usar. La soluci\u00f3n aplicada a `SerializationCodec` solo consiste en agregar una lista opcional de nombres de clases de permitidos, aunque se recomienda que este comportamiento sea el predeterminado. Al crear una instancia de `SerializationCodec`, utilice el constructor `SerializationCodec(ClassLoader classLoader, Set AllowClasses)` para restringir las clases permitidas para la deserializaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redisson:redisson:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.22.0", "matchCriteriaId": "9E83B6EC-FF08-4044-9EAA-769C599F95BA"}]}]}], "references": [{"url": "https://github.com/redisson/redisson/commit/fe6a2571801656ff1599ef87bdee20f519a5d1fe", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2023-053_Redisson/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/redisson/redisson/commit/fe6a2571801656ff1599ef87bdee20f519a5d1fe"}}