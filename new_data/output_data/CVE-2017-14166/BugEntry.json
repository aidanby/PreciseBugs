{"buggy_code": ["/*-\n * Copyright (c) 2009 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD$\");\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_LIBXML_XMLREADER_H\n#include <libxml/xmlreader.h>\n#elif HAVE_BSDXML_H\n#include <bsdxml.h>\n#elif HAVE_EXPAT_H\n#include <expat.h>\n#endif\n#ifdef HAVE_BZLIB_H\n#include <bzlib.h>\n#endif\n#if HAVE_LZMA_H\n#include <lzma.h>\n#endif\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_digest_private.h\"\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n\n#if (!defined(HAVE_LIBXML_XMLREADER_H) && \\\n     !defined(HAVE_BSDXML_H) && !defined(HAVE_EXPAT_H)) ||\\\n\t!defined(HAVE_ZLIB_H) || \\\n\t!defined(ARCHIVE_HAS_MD5) || !defined(ARCHIVE_HAS_SHA1)\n/*\n * xar needs several external libraries.\n *   o libxml2 or expat --- XML parser\n *   o openssl or MD5/SHA1 hash function\n *   o zlib\n *   o bzlib2 (option)\n *   o liblzma (option)\n */\nint\narchive_read_support_format_xar(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_xar\");\n\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t    \"Xar not supported on this platform\");\n\treturn (ARCHIVE_WARN);\n}\n\n#else\t/* Support xar format */\n\n/* #define DEBUG 1 */\n/* #define DEBUG_PRINT_TOC 1 */\n#if DEBUG_PRINT_TOC\n#define PRINT_TOC(d, outbytes)\tdo {\t\t\t\t\\\n\tunsigned char *x = (unsigned char *)(uintptr_t)d;\t\\\n\tunsigned char c = x[outbytes-1];\t\t\t\\\n\tx[outbytes - 1] = 0;\t\t\t\t\t\\\n\tfprintf(stderr, \"%s\", x);\t\t\t\t\\\n\tfprintf(stderr, \"%c\", c);\t\t\t\t\\\n\tx[outbytes - 1] = c;\t\t\t\t\t\\\n} while (0)\n#else\n#define PRINT_TOC(d, outbytes)\n#endif\n\n#define HEADER_MAGIC\t0x78617221\n#define HEADER_SIZE\t28\n#define HEADER_VERSION\t1\n#define CKSUM_NONE\t0\n#define CKSUM_SHA1\t1\n#define CKSUM_MD5\t2\n\n#define MD5_SIZE\t16\n#define SHA1_SIZE\t20\n#define MAX_SUM_SIZE\t20\n\nenum enctype {\n\tNONE,\n\tGZIP,\n\tBZIP2,\n\tLZMA,\n\tXZ,\n};\n\nstruct chksumval {\n\tint\t\t\t alg;\n\tsize_t\t\t\t len;\n\tunsigned char\t\t val[MAX_SUM_SIZE];\n};\n\nstruct chksumwork {\n\tint\t\t\t alg;\n#ifdef ARCHIVE_HAS_MD5\n\tarchive_md5_ctx\t\t md5ctx;\n#endif\n#ifdef ARCHIVE_HAS_SHA1\n\tarchive_sha1_ctx\t sha1ctx;\n#endif\n};\n\nstruct xattr {\n\tstruct xattr\t\t*next;\n\tstruct archive_string\t name;\n\tuint64_t\t\t id;\n\tuint64_t\t\t length;\n\tuint64_t\t\t offset;\n\tuint64_t\t\t size;\n\tenum enctype\t\t encoding;\n\tstruct chksumval\t a_sum;\n\tstruct chksumval\t e_sum;\n\tstruct archive_string\t fstype;\n};\n\nstruct xar_file {\n\tstruct xar_file\t\t*next;\n\tstruct xar_file\t\t*hdnext;\n\tstruct xar_file\t\t*parent;\n\tint\t\t\t subdirs;\n\n\tunsigned int\t\t has;\n#define HAS_DATA\t\t0x00001\n#define HAS_PATHNAME\t\t0x00002\n#define HAS_SYMLINK\t\t0x00004\n#define HAS_TIME\t\t0x00008\n#define HAS_UID\t\t\t0x00010\n#define HAS_GID\t\t\t0x00020\n#define HAS_MODE\t\t0x00040\n#define HAS_TYPE\t\t0x00080\n#define HAS_DEV\t\t\t0x00100\n#define HAS_DEVMAJOR\t\t0x00200\n#define HAS_DEVMINOR\t\t0x00400\n#define HAS_INO\t\t\t0x00800\n#define HAS_FFLAGS\t\t0x01000\n#define HAS_XATTR\t\t0x02000\n#define HAS_ACL\t\t\t0x04000\n\n\tuint64_t\t\t id;\n\tuint64_t\t\t length;\n\tuint64_t\t\t offset;\n\tuint64_t\t\t size;\n\tenum enctype\t\t encoding;\n\tstruct chksumval\t a_sum;\n\tstruct chksumval\t e_sum;\n\tstruct archive_string\t pathname;\n\tstruct archive_string\t symlink;\n\ttime_t\t\t\t ctime;\n\ttime_t\t\t\t mtime;\n\ttime_t\t\t\t atime;\n\tstruct archive_string\t uname;\n\tint64_t\t\t\t uid;\n\tstruct archive_string\t gname;\n\tint64_t\t\t\t gid;\n\tmode_t\t\t\t mode;\n\tdev_t\t\t\t dev;\n\tdev_t\t\t\t devmajor;\n\tdev_t\t\t\t devminor;\n\tint64_t\t\t\t ino64;\n\tstruct archive_string\t fflags_text;\n\tunsigned int\t\t link;\n\tunsigned int\t\t nlink;\n\tstruct archive_string\t hardlink;\n\tstruct xattr\t\t*xattr_list;\n};\n\nstruct hdlink {\n\tstruct hdlink\t\t *next;\n\n\tunsigned int\t\t id;\n\tint\t\t\t cnt;\n\tstruct xar_file\t\t *files;\n};\n\nstruct heap_queue {\n\tstruct xar_file\t\t**files;\n\tint\t\t\t allocated;\n\tint\t\t\t used;\n};\n\nenum xmlstatus {\n\tINIT,\n\tXAR,\n\tTOC,\n\tTOC_CREATION_TIME,\n\tTOC_CHECKSUM,\n\tTOC_CHECKSUM_OFFSET,\n\tTOC_CHECKSUM_SIZE,\n\tTOC_FILE,\n\tFILE_DATA,\n\tFILE_DATA_LENGTH,\n\tFILE_DATA_OFFSET,\n\tFILE_DATA_SIZE,\n\tFILE_DATA_ENCODING,\n\tFILE_DATA_A_CHECKSUM,\n\tFILE_DATA_E_CHECKSUM,\n\tFILE_DATA_CONTENT,\n\tFILE_EA,\n\tFILE_EA_LENGTH,\n\tFILE_EA_OFFSET,\n\tFILE_EA_SIZE,\n\tFILE_EA_ENCODING,\n\tFILE_EA_A_CHECKSUM,\n\tFILE_EA_E_CHECKSUM,\n\tFILE_EA_NAME,\n\tFILE_EA_FSTYPE,\n\tFILE_CTIME,\n\tFILE_MTIME,\n\tFILE_ATIME,\n\tFILE_GROUP,\n\tFILE_GID,\n\tFILE_USER,\n\tFILE_UID,\n\tFILE_MODE,\n\tFILE_DEVICE,\n\tFILE_DEVICE_MAJOR,\n\tFILE_DEVICE_MINOR,\n\tFILE_DEVICENO,\n\tFILE_INODE,\n\tFILE_LINK,\n\tFILE_TYPE,\n\tFILE_NAME,\n\tFILE_ACL,\n\tFILE_ACL_DEFAULT,\n\tFILE_ACL_ACCESS,\n\tFILE_ACL_APPLEEXTENDED,\n\t/* BSD file flags. */\n\tFILE_FLAGS,\n\tFILE_FLAGS_USER_NODUMP,\n\tFILE_FLAGS_USER_IMMUTABLE,\n\tFILE_FLAGS_USER_APPEND,\n\tFILE_FLAGS_USER_OPAQUE,\n\tFILE_FLAGS_USER_NOUNLINK,\n\tFILE_FLAGS_SYS_ARCHIVED,\n\tFILE_FLAGS_SYS_IMMUTABLE,\n\tFILE_FLAGS_SYS_APPEND,\n\tFILE_FLAGS_SYS_NOUNLINK,\n\tFILE_FLAGS_SYS_SNAPSHOT,\n\t/* Linux file flags. */\n\tFILE_EXT2,\n\tFILE_EXT2_SecureDeletion,\n\tFILE_EXT2_Undelete,\n\tFILE_EXT2_Compress,\n\tFILE_EXT2_Synchronous,\n\tFILE_EXT2_Immutable,\n\tFILE_EXT2_AppendOnly,\n\tFILE_EXT2_NoDump,\n\tFILE_EXT2_NoAtime,\n\tFILE_EXT2_CompDirty,\n\tFILE_EXT2_CompBlock,\n\tFILE_EXT2_NoCompBlock,\n\tFILE_EXT2_CompError,\n\tFILE_EXT2_BTree,\n\tFILE_EXT2_HashIndexed,\n\tFILE_EXT2_iMagic,\n\tFILE_EXT2_Journaled,\n\tFILE_EXT2_NoTail,\n\tFILE_EXT2_DirSync,\n\tFILE_EXT2_TopDir,\n\tFILE_EXT2_Reserved,\n\tUNKNOWN,\n};\n\nstruct unknown_tag {\n\tstruct unknown_tag\t*next;\n\tstruct archive_string\t name;\n};\n\nstruct xar {\n\tuint64_t\t\t offset; /* Current position in the file. */\n\tint64_t\t\t\t total;\n\tuint64_t\t\t h_base;\n\tint\t\t\t end_of_file;\n#define OUTBUFF_SIZE\t(1024 * 64)\n\tunsigned char\t\t*outbuff;\n\n\tenum xmlstatus\t\t xmlsts;\n\tenum xmlstatus\t\t xmlsts_unknown;\n\tstruct unknown_tag\t*unknowntags;\n\tint\t\t\t base64text;\n\n\t/*\n\t * TOC\n\t */\n\tuint64_t\t\t toc_remaining;\n\tuint64_t\t\t toc_total;\n\tuint64_t\t\t toc_chksum_offset;\n\tuint64_t\t\t toc_chksum_size;\n\n\t/*\n\t * For Decoding data.\n\t */\n\tenum enctype \t\t rd_encoding;\n\tz_stream\t\t stream;\n\tint\t\t\t stream_valid;\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tbz_stream\t\t bzstream;\n\tint\t\t\t bzstream_valid;\n#endif\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n\tlzma_stream\t\t lzstream;\n\tint\t\t\t lzstream_valid;\n#endif\n\t/*\n\t * For Checksum data.\n\t */\n\tstruct chksumwork\t a_sumwrk;\n\tstruct chksumwork\t e_sumwrk;\n\n\tstruct xar_file\t\t*file;\t/* current reading file. */\n\tstruct xattr\t\t*xattr; /* current reading extended attribute. */\n\tstruct heap_queue\t file_queue;\n\tstruct xar_file\t\t*hdlink_orgs;\n\tstruct hdlink\t\t*hdlink_list;\n\n\tint\t \t\t entry_init;\n\tuint64_t\t\t entry_total;\n\tuint64_t\t\t entry_remaining;\n\tsize_t\t\t\t entry_unconsumed;\n\tuint64_t\t\t entry_size;\n\tenum enctype \t\t entry_encoding;\n\tstruct chksumval\t entry_a_sum;\n\tstruct chksumval\t entry_e_sum;\n\n\tstruct archive_string_conv *sconv;\n};\n\nstruct xmlattr {\n\tstruct xmlattr\t*next;\n\tchar\t\t*name;\n\tchar\t\t*value;\n};\n\nstruct xmlattr_list {\n\tstruct xmlattr\t*first;\n\tstruct xmlattr\t**last;\n};\n\nstatic int\txar_bid(struct archive_read *, int);\nstatic int\txar_read_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int\txar_read_data(struct archive_read *,\n\t\t    const void **, size_t *, int64_t *);\nstatic int\txar_read_data_skip(struct archive_read *);\nstatic int\txar_cleanup(struct archive_read *);\nstatic int\tmove_reading_point(struct archive_read *, uint64_t);\nstatic int\trd_contents_init(struct archive_read *,\n\t\t    enum enctype, int, int);\nstatic int\trd_contents(struct archive_read *, const void **,\n\t\t    size_t *, size_t *, uint64_t);\nstatic uint64_t\tatol10(const char *, size_t);\nstatic int64_t\tatol8(const char *, size_t);\nstatic size_t\tatohex(unsigned char *, size_t, const char *, size_t);\nstatic time_t\tparse_time(const char *p, size_t n);\nstatic int\theap_add_entry(struct archive_read *a,\n    struct heap_queue *, struct xar_file *);\nstatic struct xar_file *heap_get_entry(struct heap_queue *);\nstatic int\tadd_link(struct archive_read *,\n    struct xar *, struct xar_file *);\nstatic void\tchecksum_init(struct archive_read *, int, int);\nstatic void\tchecksum_update(struct archive_read *, const void *,\n\t\t    size_t, const void *, size_t);\nstatic int\tchecksum_final(struct archive_read *, const void *,\n\t\t    size_t, const void *, size_t);\nstatic void\tchecksum_cleanup(struct archive_read *);\nstatic int\tdecompression_init(struct archive_read *, enum enctype);\nstatic int\tdecompress(struct archive_read *, const void **,\n\t\t    size_t *, const void *, size_t *);\nstatic int\tdecompression_cleanup(struct archive_read *);\nstatic void\txmlattr_cleanup(struct xmlattr_list *);\nstatic int\tfile_new(struct archive_read *,\n    struct xar *, struct xmlattr_list *);\nstatic void\tfile_free(struct xar_file *);\nstatic int\txattr_new(struct archive_read *,\n    struct xar *, struct xmlattr_list *);\nstatic void\txattr_free(struct xattr *);\nstatic int\tgetencoding(struct xmlattr_list *);\nstatic int\tgetsumalgorithm(struct xmlattr_list *);\nstatic int\tunknowntag_start(struct archive_read *,\n    struct xar *, const char *);\nstatic void\tunknowntag_end(struct xar *, const char *);\nstatic int\txml_start(struct archive_read *,\n    const char *, struct xmlattr_list *);\nstatic void\txml_end(void *, const char *);\nstatic void\txml_data(void *, const char *, int);\nstatic int\txml_parse_file_flags(struct xar *, const char *);\nstatic int\txml_parse_file_ext2(struct xar *, const char *);\n#if defined(HAVE_LIBXML_XMLREADER_H)\nstatic int\txml2_xmlattr_setup(struct archive_read *,\n    struct xmlattr_list *, xmlTextReaderPtr);\nstatic int\txml2_read_cb(void *, char *, int);\nstatic int\txml2_close_cb(void *);\nstatic void\txml2_error_hdr(void *, const char *, xmlParserSeverities,\n\t\t    xmlTextReaderLocatorPtr);\nstatic int\txml2_read_toc(struct archive_read *);\n#elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\nstruct expat_userData {\n\tint state;\n\tstruct archive_read *archive;\n};\nstatic int\texpat_xmlattr_setup(struct archive_read *,\n    struct xmlattr_list *, const XML_Char **);\nstatic void\texpat_start_cb(void *, const XML_Char *, const XML_Char **);\nstatic void\texpat_end_cb(void *, const XML_Char *);\nstatic void\texpat_data_cb(void *, const XML_Char *, int);\nstatic int\texpat_read_toc(struct archive_read *);\n#endif\n\nint\narchive_read_support_format_xar(struct archive *_a)\n{\n\tstruct xar *xar;\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_xar\");\n\n\txar = (struct xar *)calloc(1, sizeof(*xar));\n\tif (xar == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate xar data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tr = __archive_read_register_format(a,\n\t    xar,\n\t    \"xar\",\n\t    xar_bid,\n\t    NULL,\n\t    xar_read_header,\n\t    xar_read_data,\n\t    xar_read_data_skip,\n\t    NULL,\n\t    xar_cleanup,\n\t    NULL,\n\t    NULL);\n\tif (r != ARCHIVE_OK)\n\t\tfree(xar);\n\treturn (r);\n}\n\nstatic int\nxar_bid(struct archive_read *a, int best_bid)\n{\n\tconst unsigned char *b;\n\tint bid;\n\n\t(void)best_bid; /* UNUSED */\n\n\tb = __archive_read_ahead(a, HEADER_SIZE, NULL);\n\tif (b == NULL)\n\t\treturn (-1);\n\n\tbid = 0;\n\t/*\n\t * Verify magic code\n\t */\n\tif (archive_be32dec(b) != HEADER_MAGIC)\n\t\treturn (0);\n\tbid += 32;\n\t/*\n\t * Verify header size\n\t */\n\tif (archive_be16dec(b+4) != HEADER_SIZE)\n\t\treturn (0);\n\tbid += 16;\n\t/*\n\t * Verify header version\n\t */\n\tif (archive_be16dec(b+6) != HEADER_VERSION)\n\t\treturn (0);\n\tbid += 16;\n\t/*\n\t * Verify type of checksum\n\t */\n\tswitch (archive_be32dec(b+24)) {\n\tcase CKSUM_NONE:\n\tcase CKSUM_SHA1:\n\tcase CKSUM_MD5:\n\t\tbid += 32;\n\t\tbreak;\n\tdefault:\n\t\treturn (0);\n\t}\n\n\treturn (bid);\n}\n\nstatic int\nread_toc(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tstruct xar_file *file;\n\tconst unsigned char *b;\n\tuint64_t toc_compressed_size;\n\tuint64_t toc_uncompressed_size;\n\tuint32_t toc_chksum_alg;\n\tssize_t bytes;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\n\t/*\n\t * Read xar header.\n\t */\n\tb = __archive_read_ahead(a, HEADER_SIZE, &bytes);\n\tif (bytes < 0)\n\t\treturn ((int)bytes);\n\tif (bytes < HEADER_SIZE) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated archive header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (archive_be32dec(b) != HEADER_MAGIC) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid header magic\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (archive_be16dec(b+6) != HEADER_VERSION) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported header version(%d)\",\n\t\t    archive_be16dec(b+6));\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\ttoc_compressed_size = archive_be64dec(b+8);\n\txar->toc_remaining = toc_compressed_size;\n\ttoc_uncompressed_size = archive_be64dec(b+16);\n\ttoc_chksum_alg = archive_be32dec(b+24);\n\t__archive_read_consume(a, HEADER_SIZE);\n\txar->offset += HEADER_SIZE;\n\txar->toc_total = 0;\n\n\t/*\n\t * Read TOC(Table of Contents).\n\t */\n\t/* Initialize reading contents. */\n\tr = move_reading_point(a, HEADER_SIZE);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\tr = rd_contents_init(a, GZIP, toc_chksum_alg, CKSUM_NONE);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n#ifdef HAVE_LIBXML_XMLREADER_H\n\tr = xml2_read_toc(a);\n#elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\n\tr = expat_read_toc(a);\n#endif\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\t/* Set 'The HEAP' base. */\n\txar->h_base = xar->offset;\n\tif (xar->toc_total != toc_uncompressed_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"TOC uncompressed size error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * Checksum TOC\n\t */\n\tif (toc_chksum_alg != CKSUM_NONE) {\n\t\tr = move_reading_point(a, xar->toc_chksum_offset);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tb = __archive_read_ahead(a,\n\t\t\t(size_t)xar->toc_chksum_size, &bytes);\n\t\tif (bytes < 0)\n\t\t\treturn ((int)bytes);\n\t\tif ((uint64_t)bytes < xar->toc_chksum_size) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated archive file\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tr = checksum_final(a, b,\n\t\t\t(size_t)xar->toc_chksum_size, NULL, 0);\n\t\t__archive_read_consume(a, xar->toc_chksum_size);\n\t\txar->offset += xar->toc_chksum_size;\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * Connect hardlinked files.\n\t */\n\tfor (file = xar->hdlink_orgs; file != NULL; file = file->hdnext) {\n\t\tstruct hdlink **hdlink;\n\n\t\tfor (hdlink = &(xar->hdlink_list); *hdlink != NULL;\n\t\t    hdlink = &((*hdlink)->next)) {\n\t\t\tif ((*hdlink)->id == file->id) {\n\t\t\t\tstruct hdlink *hltmp;\n\t\t\t\tstruct xar_file *f2;\n\t\t\t\tint nlink = (*hdlink)->cnt + 1;\n\n\t\t\t\tfile->nlink = nlink;\n\t\t\t\tfor (f2 = (*hdlink)->files; f2 != NULL;\n\t\t\t\t    f2 = f2->hdnext) {\n\t\t\t\t\tf2->nlink = nlink;\n\t\t\t\t\tarchive_string_copy(\n\t\t\t\t\t    &(f2->hardlink), &(file->pathname));\n\t\t\t\t}\n\t\t\t\t/* Remove resolved files from hdlist_list. */\n\t\t\t\thltmp = *hdlink;\n\t\t\t\t*hdlink = hltmp->next;\n\t\t\t\tfree(hltmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ta->archive.archive_format = ARCHIVE_FORMAT_XAR;\n\ta->archive.archive_format_name = \"xar\";\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nxar_read_header(struct archive_read *a, struct archive_entry *entry)\n{\n\tstruct xar *xar;\n\tstruct xar_file *file;\n\tstruct xattr *xattr;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tr = ARCHIVE_OK;\n\n\tif (xar->offset == 0) {\n\t\t/* Create a character conversion object. */\n\t\tif (xar->sconv == NULL) {\n\t\t\txar->sconv = archive_string_conversion_from_charset(\n\t\t\t    &(a->archive), \"UTF-8\", 1);\n\t\t\tif (xar->sconv == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Read TOC. */\n\t\tr = read_toc(a);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfor (;;) {\n\t\tfile = xar->file = heap_get_entry(&(xar->file_queue));\n\t\tif (file == NULL) {\n\t\t\txar->end_of_file = 1;\n\t\t\treturn (ARCHIVE_EOF);\n\t\t}\n\t\tif ((file->mode & AE_IFMT) != AE_IFDIR)\n\t\t\tbreak;\n\t\tif (file->has != (HAS_PATHNAME | HAS_TYPE))\n\t\t\tbreak;\n\t\t/*\n\t\t * If a file type is a directory and it does not have\n\t\t * any metadata, do not export.\n\t\t */\n\t\tfile_free(file);\n\t}\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_gid(entry, file->gid);\n\tif (file->gname.length > 0 &&\n\t    archive_entry_copy_gname_l(entry, file->gname.s,\n\t\tarchive_strlen(&(file->gname)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Gname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Gname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tarchive_entry_set_uid(entry, file->uid);\n\tif (file->uname.length > 0 &&\n\t    archive_entry_copy_uname_l(entry, file->uname.s,\n\t\tarchive_strlen(&(file->uname)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Uname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Uname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tarchive_entry_set_mode(entry, file->mode);\n\tif (archive_entry_copy_pathname_l(entry, file->pathname.s,\n\t    archive_strlen(&(file->pathname)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\n\n\tif (file->symlink.length > 0 &&\n\t    archive_entry_copy_symlink_l(entry, file->symlink.s,\n\t\tarchive_strlen(&(file->symlink)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Linkname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\t/* Set proper nlink. */\n\tif ((file->mode & AE_IFMT) == AE_IFDIR)\n\t\tarchive_entry_set_nlink(entry, file->subdirs + 2);\n\telse\n\t\tarchive_entry_set_nlink(entry, file->nlink);\n\tarchive_entry_set_size(entry, file->size);\n\tif (archive_strlen(&(file->hardlink)) > 0)\n\t\tarchive_entry_set_hardlink(entry, file->hardlink.s);\n\tarchive_entry_set_ino64(entry, file->ino64);\n\tif (file->has & HAS_DEV)\n\t\tarchive_entry_set_dev(entry, file->dev);\n\tif (file->has & HAS_DEVMAJOR)\n\t\tarchive_entry_set_devmajor(entry, file->devmajor);\n\tif (file->has & HAS_DEVMINOR)\n\t\tarchive_entry_set_devminor(entry, file->devminor);\n\tif (archive_strlen(&(file->fflags_text)) > 0)\n\t\tarchive_entry_copy_fflags_text(entry, file->fflags_text.s);\n\n\txar->entry_init = 1;\n\txar->entry_total = 0;\n\txar->entry_remaining = file->length;\n\txar->entry_size = file->size;\n\txar->entry_encoding = file->encoding;\n\txar->entry_a_sum = file->a_sum;\n\txar->entry_e_sum = file->e_sum;\n\t/*\n\t * Read extended attributes.\n\t */\n\txattr = file->xattr_list;\n\twhile (xattr != NULL) {\n\t\tconst void *d;\n\t\tsize_t outbytes, used;\n\n\t\tr = move_reading_point(a, xattr->offset);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\tr = rd_contents_init(a, xattr->encoding,\n\t\t    xattr->a_sum.alg, xattr->e_sum.alg);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\td = NULL;\n\t\tr = rd_contents(a, &d, &outbytes, &used, xattr->length);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\tif (outbytes != xattr->size) {\n\t\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decompressed size error\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t\tbreak;\n\t\t}\n\t\tr = checksum_final(a,\n\t\t    xattr->a_sum.val, xattr->a_sum.len,\n\t\t    xattr->e_sum.val, xattr->e_sum.len);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\tarchive_entry_xattr_add_entry(entry,\n\t\t    xattr->name.s, d, outbytes);\n\t\txattr = xattr->next;\n\t}\n\tif (r != ARCHIVE_OK) {\n\t\tfile_free(file);\n\t\treturn (r);\n\t}\n\n\tif (xar->entry_remaining > 0)\n\t\t/* Move reading point to the beginning of current\n\t\t * file contents. */\n\t\tr = move_reading_point(a, file->offset);\n\telse\n\t\tr = ARCHIVE_OK;\n\n\tfile_free(file);\n\treturn (r);\n}\n\nstatic int\nxar_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tstruct xar *xar;\n\tsize_t used;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\n\tif (xar->entry_unconsumed) {\n\t\t__archive_read_consume(a, xar->entry_unconsumed);\n\t\txar->entry_unconsumed = 0;\n\t}\n\n\tif (xar->end_of_file || xar->entry_remaining <= 0) {\n\t\tr = ARCHIVE_EOF;\n\t\tgoto abort_read_data;\n\t}\n\n\tif (xar->entry_init) {\n\t\tr = rd_contents_init(a, xar->entry_encoding,\n\t\t    xar->entry_a_sum.alg, xar->entry_e_sum.alg);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\txar->entry_remaining = 0;\n\t\t\treturn (r);\n\t\t}\n\t\txar->entry_init = 0;\n\t}\n\n\t*buff = NULL;\n\tr = rd_contents(a, buff, size, &used, xar->entry_remaining);\n\tif (r != ARCHIVE_OK)\n\t\tgoto abort_read_data;\n\n\t*offset = xar->entry_total;\n\txar->entry_total += *size;\n\txar->total += *size;\n\txar->offset += used;\n\txar->entry_remaining -= used;\n\txar->entry_unconsumed = used;\n\n\tif (xar->entry_remaining == 0) {\n\t\tif (xar->entry_total != xar->entry_size) {\n\t\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decompressed size error\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t\tgoto abort_read_data;\n\t\t}\n\t\tr = checksum_final(a,\n\t\t    xar->entry_a_sum.val, xar->entry_a_sum.len,\n\t\t    xar->entry_e_sum.val, xar->entry_e_sum.len);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tgoto abort_read_data;\n\t}\n\n\treturn (ARCHIVE_OK);\nabort_read_data:\n\t*buff = NULL;\n\t*size = 0;\n\t*offset = xar->total;\n\treturn (r);\n}\n\nstatic int\nxar_read_data_skip(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tint64_t bytes_skipped;\n\n\txar = (struct xar *)(a->format->data);\n\tif (xar->end_of_file)\n\t\treturn (ARCHIVE_EOF);\n\tbytes_skipped = __archive_read_consume(a, xar->entry_remaining +\n\t\txar->entry_unconsumed);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\txar->offset += bytes_skipped;\n\txar->entry_unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nxar_cleanup(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tstruct hdlink *hdlink;\n\tint i;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tchecksum_cleanup(a);\n\tr = decompression_cleanup(a);\n\thdlink = xar->hdlink_list;\n\twhile (hdlink != NULL) {\n\t\tstruct hdlink *next = hdlink->next;\n\n\t\tfree(hdlink);\n\t\thdlink = next;\n\t}\n\tfor (i = 0; i < xar->file_queue.used; i++)\n\t\tfile_free(xar->file_queue.files[i]);\n\tfree(xar->file_queue.files);\n\twhile (xar->unknowntags != NULL) {\n\t\tstruct unknown_tag *tag;\n\n\t\ttag = xar->unknowntags;\n\t\txar->unknowntags = tag->next;\n\t\tarchive_string_free(&(tag->name));\n\t\tfree(tag);\n\t}\n\tfree(xar->outbuff);\n\tfree(xar);\n\ta->format->data = NULL;\n\treturn (r);\n}\n\nstatic int\nmove_reading_point(struct archive_read *a, uint64_t offset)\n{\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\tif (xar->offset - xar->h_base != offset) {\n\t\t/* Seek forward to the start of file contents. */\n\t\tint64_t step;\n\n\t\tstep = offset - (xar->offset - xar->h_base);\n\t\tif (step > 0) {\n\t\t\tstep = __archive_read_consume(a, step);\n\t\t\tif (step < 0)\n\t\t\t\treturn ((int)step);\n\t\t\txar->offset += step;\n\t\t} else {\n\t\t\tint64_t pos = __archive_read_seek(a, offset, SEEK_SET);\n\t\t\tif (pos == ARCHIVE_FAILED) {\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Cannot seek.\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\txar->offset = pos;\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nrd_contents_init(struct archive_read *a, enum enctype encoding,\n    int a_sum_alg, int e_sum_alg)\n{\n\tint r;\n\n\t/* Init decompress library. */\n\tif ((r = decompression_init(a, encoding)) != ARCHIVE_OK)\n\t\treturn (r);\n\t/* Init checksum library. */\n\tchecksum_init(a, a_sum_alg, e_sum_alg);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nrd_contents(struct archive_read *a, const void **buff, size_t *size,\n    size_t *used, uint64_t remaining)\n{\n\tconst unsigned char *b;\n\tssize_t bytes;\n\n\t/* Get whatever bytes are immediately available. */\n\tb = __archive_read_ahead(a, 1, &bytes);\n\tif (bytes < 0)\n\t\treturn ((int)bytes);\n\tif (bytes == 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Truncated archive file\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif ((uint64_t)bytes > remaining)\n\t\tbytes = (ssize_t)remaining;\n\n\t/*\n\t * Decompress contents of file.\n\t */\n\t*used = bytes;\n\tif (decompress(a, buff, size, b, used) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/*\n\t * Update checksum of a compressed data and a extracted data.\n\t */\n\tchecksum_update(a, b, *used, *buff, *size);\n\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\n\nstatic uint64_t\natol10(const char *p, size_t char_cnt)\n{\n\tuint64_t l;\n\tint digit;\n\n\tl = 0;\n\tdigit = *p - '0';\n\twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}\n\nstatic int64_t\natol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n        \n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}\n\nstatic size_t\natohex(unsigned char *b, size_t bsize, const char *p, size_t psize)\n{\n\tsize_t fbsize = bsize;\n\n\twhile (bsize && psize > 1) {\n\t\tunsigned char x;\n\n\t\tif (p[0] >= 'a' && p[0] <= 'z')\n\t\t\tx = (p[0] - 'a' + 0x0a) << 4;\n\t\telse if (p[0] >= 'A' && p[0] <= 'Z')\n\t\t\tx = (p[0] - 'A' + 0x0a) << 4;\n\t\telse if (p[0] >= '0' && p[0] <= '9')\n\t\t\tx = (p[0] - '0') << 4;\n\t\telse\n\t\t\treturn (-1);\n\t\tif (p[1] >= 'a' && p[1] <= 'z')\n\t\t\tx |= p[1] - 'a' + 0x0a;\n\t\telse if (p[1] >= 'A' && p[1] <= 'Z')\n\t\t\tx |= p[1] - 'A' + 0x0a;\n\t\telse if (p[1] >= '0' && p[1] <= '9')\n\t\t\tx |= p[1] - '0';\n\t\telse\n\t\t\treturn (-1);\n\t\t\n\t\t*b++ = x;\n\t\tbsize--;\n\t\tp += 2;\n\t\tpsize -= 2;\n\t}\n\treturn (fbsize - bsize);\n}\n\nstatic time_t\ntime_from_tm(struct tm *t)\n{\n#if HAVE_TIMEGM\n        /* Use platform timegm() if available. */\n        return (timegm(t));\n#elif HAVE__MKGMTIME64\n        return (_mkgmtime64(t));\n#else\n        /* Else use direct calculation using POSIX assumptions. */\n        /* First, fix up tm_yday based on the year/month/day. */\n        mktime(t);\n        /* Then we can compute timegm() from first principles. */\n        return (t->tm_sec\n            + t->tm_min * 60\n            + t->tm_hour * 3600\n            + t->tm_yday * 86400\n            + (t->tm_year - 70) * 31536000\n            + ((t->tm_year - 69) / 4) * 86400\n            - ((t->tm_year - 1) / 100) * 86400\n            + ((t->tm_year + 299) / 400) * 86400);\n#endif\n}\n\nstatic time_t\nparse_time(const char *p, size_t n)\n{\n\tstruct tm tm;\n\ttime_t t = 0;\n\tint64_t data;\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif (n != 20)\n\t\treturn (t);\n\tdata = atol10(p, 4);\n\tif (data < 1900)\n\t\treturn (t);\n\ttm.tm_year = (int)data - 1900;\n\tp += 4;\n\tif (*p++ != '-')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 1 || data > 12)\n\t\treturn (t);\n\ttm.tm_mon = (int)data -1;\n\tp += 2;\n\tif (*p++ != '-')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 1 || data > 31)\n\t\treturn (t);\n\ttm.tm_mday = (int)data;\n\tp += 2;\n\tif (*p++ != 'T')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 0 || data > 23)\n\t\treturn (t);\n\ttm.tm_hour = (int)data;\n\tp += 2;\n\tif (*p++ != ':')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 0 || data > 59)\n\t\treturn (t);\n\ttm.tm_min = (int)data;\n\tp += 2;\n\tif (*p++ != ':')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 0 || data > 60)\n\t\treturn (t);\n\ttm.tm_sec = (int)data;\n#if 0\n\tp += 2;\n\tif (*p != 'Z')\n\t\treturn (t);\n#endif\n\n\tt = time_from_tm(&tm);\n\n\treturn (t);\n}\n\nstatic int\nheap_add_entry(struct archive_read *a,\n    struct heap_queue *heap, struct xar_file *file)\n{\n\tuint64_t file_id, parent_id;\n\tint hole, parent;\n\n\t/* Expand our pending files list as necessary. */\n\tif (heap->used >= heap->allocated) {\n\t\tstruct xar_file **new_pending_files;\n\t\tint new_size = heap->allocated * 2;\n\n\t\tif (heap->allocated < 1024)\n\t\t\tnew_size = 1024;\n\t\t/* Overflow might keep us from growing the list. */\n\t\tif (new_size <= heap->allocated) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tnew_pending_files = (struct xar_file **)\n\t\t    malloc(new_size * sizeof(new_pending_files[0]));\n\t\tif (new_pending_files == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tmemcpy(new_pending_files, heap->files,\n\t\t    heap->allocated * sizeof(new_pending_files[0]));\n\t\tif (heap->files != NULL)\n\t\t\tfree(heap->files);\n\t\theap->files = new_pending_files;\n\t\theap->allocated = new_size;\n\t}\n\n\tfile_id = file->id;\n\n\t/*\n\t * Start with hole at end, walk it up tree to find insertion point.\n\t */\n\thole = heap->used++;\n\twhile (hole > 0) {\n\t\tparent = (hole - 1)/2;\n\t\tparent_id = heap->files[parent]->id;\n\t\tif (file_id >= parent_id) {\n\t\t\theap->files[hole] = file;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\t/* Move parent into hole <==> move hole up tree. */\n\t\theap->files[hole] = heap->files[parent];\n\t\thole = parent;\n\t}\n\theap->files[0] = file;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic struct xar_file *\nheap_get_entry(struct heap_queue *heap)\n{\n\tuint64_t a_id, b_id, c_id;\n\tint a, b, c;\n\tstruct xar_file *r, *tmp;\n\n\tif (heap->used < 1)\n\t\treturn (NULL);\n\n\t/*\n\t * The first file in the list is the earliest; we'll return this.\n\t */\n\tr = heap->files[0];\n\n\t/*\n\t * Move the last item in the heap to the root of the tree\n\t */\n\theap->files[0] = heap->files[--(heap->used)];\n\n\t/*\n\t * Rebalance the heap.\n\t */\n\ta = 0; /* Starting element and its heap key */\n\ta_id = heap->files[a]->id;\n\tfor (;;) {\n\t\tb = a + a + 1; /* First child */\n\t\tif (b >= heap->used)\n\t\t\treturn (r);\n\t\tb_id = heap->files[b]->id;\n\t\tc = b + 1; /* Use second child if it is smaller. */\n\t\tif (c < heap->used) {\n\t\t\tc_id = heap->files[c]->id;\n\t\t\tif (c_id < b_id) {\n\t\t\t\tb = c;\n\t\t\t\tb_id = c_id;\n\t\t\t}\n\t\t}\n\t\tif (a_id <= b_id)\n\t\t\treturn (r);\n\t\ttmp = heap->files[a];\n\t\theap->files[a] = heap->files[b];\n\t\theap->files[b] = tmp;\n\t\ta = b;\n\t}\n}\n\nstatic int\nadd_link(struct archive_read *a, struct xar *xar, struct xar_file *file)\n{\n\tstruct hdlink *hdlink;\n\n\tfor (hdlink = xar->hdlink_list; hdlink != NULL; hdlink = hdlink->next) {\n\t\tif (hdlink->id == file->link) {\n\t\t\tfile->hdnext = hdlink->files;\n\t\t\thdlink->cnt++;\n\t\t\thdlink->files = file;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t}\n\thdlink = malloc(sizeof(*hdlink));\n\tif (hdlink == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tfile->hdnext = NULL;\n\thdlink->id = file->link;\n\thdlink->cnt = 1;\n\thdlink->files = file;\n\thdlink->next = xar->hdlink_list;\n\txar->hdlink_list = hdlink;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\n_checksum_init(struct chksumwork *sumwrk, int sum_alg)\n{\n\tsumwrk->alg = sum_alg;\n\tswitch (sum_alg) {\n\tcase CKSUM_NONE:\n\t\tbreak;\n\tcase CKSUM_SHA1:\n\t\tarchive_sha1_init(&(sumwrk->sha1ctx));\n\t\tbreak;\n\tcase CKSUM_MD5:\n\t\tarchive_md5_init(&(sumwrk->md5ctx));\n\t\tbreak;\n\t}\n}\n\nstatic void\n_checksum_update(struct chksumwork *sumwrk, const void *buff, size_t size)\n{\n\n\tswitch (sumwrk->alg) {\n\tcase CKSUM_NONE:\n\t\tbreak;\n\tcase CKSUM_SHA1:\n\t\tarchive_sha1_update(&(sumwrk->sha1ctx), buff, size);\n\t\tbreak;\n\tcase CKSUM_MD5:\n\t\tarchive_md5_update(&(sumwrk->md5ctx), buff, size);\n\t\tbreak;\n\t}\n}\n\nstatic int\n_checksum_final(struct chksumwork *sumwrk, const void *val, size_t len)\n{\n\tunsigned char sum[MAX_SUM_SIZE];\n\tint r = ARCHIVE_OK;\n\n\tswitch (sumwrk->alg) {\n\tcase CKSUM_NONE:\n\t\tbreak;\n\tcase CKSUM_SHA1:\n\t\tarchive_sha1_final(&(sumwrk->sha1ctx), sum);\n\t\tif (len != SHA1_SIZE ||\n\t\t    memcmp(val, sum, SHA1_SIZE) != 0)\n\t\t\tr = ARCHIVE_FAILED;\n\t\tbreak;\n\tcase CKSUM_MD5:\n\t\tarchive_md5_final(&(sumwrk->md5ctx), sum);\n\t\tif (len != MD5_SIZE ||\n\t\t    memcmp(val, sum, MD5_SIZE) != 0)\n\t\t\tr = ARCHIVE_FAILED;\n\t\tbreak;\n\t}\n\treturn (r);\n}\n\nstatic void\nchecksum_init(struct archive_read *a, int a_sum_alg, int e_sum_alg)\n{\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\t_checksum_init(&(xar->a_sumwrk), a_sum_alg);\n\t_checksum_init(&(xar->e_sumwrk), e_sum_alg);\n}\n\nstatic void\nchecksum_update(struct archive_read *a, const void *abuff, size_t asize,\n    const void *ebuff, size_t esize)\n{\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\t_checksum_update(&(xar->a_sumwrk), abuff, asize);\n\t_checksum_update(&(xar->e_sumwrk), ebuff, esize);\n}\n\nstatic int\nchecksum_final(struct archive_read *a, const void *a_sum_val,\n    size_t a_sum_len, const void *e_sum_val, size_t e_sum_len)\n{\n\tstruct xar *xar;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tr = _checksum_final(&(xar->a_sumwrk), a_sum_val, a_sum_len);\n\tif (r == ARCHIVE_OK)\n\t\tr = _checksum_final(&(xar->e_sumwrk), e_sum_val, e_sum_len);\n\tif (r != ARCHIVE_OK)\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"Sumcheck error\");\n\treturn (r);\n}\n\nstatic int\ndecompression_init(struct archive_read *a, enum enctype encoding)\n{\n\tstruct xar *xar;\n\tconst char *detail;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\txar->rd_encoding = encoding;\n\tswitch (encoding) {\n\tcase NONE:\n\t\tbreak;\n\tcase GZIP:\n\t\tif (xar->stream_valid)\n\t\t\tr = inflateReset(&(xar->stream));\n\t\telse\n\t\t\tr = inflateInit(&(xar->stream));\n\t\tif (r != Z_OK) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Couldn't initialize zlib stream.\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\txar->stream_valid = 1;\n\t\txar->stream.total_in = 0;\n\t\txar->stream.total_out = 0;\n\t\tbreak;\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n\t\tif (xar->bzstream_valid) {\n\t\t\tBZ2_bzDecompressEnd(&(xar->bzstream));\n\t\t\txar->bzstream_valid = 0;\n\t\t}\n\t\tr = BZ2_bzDecompressInit(&(xar->bzstream), 0, 0);\n\t\tif (r == BZ_MEM_ERROR)\n\t\t\tr = BZ2_bzDecompressInit(&(xar->bzstream), 0, 1);\n\t\tif (r != BZ_OK) {\n\t\t\tint err = ARCHIVE_ERRNO_MISC;\n\t\t\tdetail = NULL;\n\t\t\tswitch (r) {\n\t\t\tcase BZ_PARAM_ERROR:\n\t\t\t\tdetail = \"invalid setup parameter\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_MEM_ERROR:\n\t\t\t\terr = ENOMEM;\n\t\t\t\tdetail = \"out of memory\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_CONFIG_ERROR:\n\t\t\t\tdetail = \"mis-compiled library\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive, err,\n\t\t\t    \"Internal error initializing decompressor: %s\",\n\t\t\t    detail == NULL ? \"??\" : detail);\n\t\t\txar->bzstream_valid = 0;\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\txar->bzstream_valid = 1;\n\t\txar->bzstream.total_in_lo32 = 0;\n\t\txar->bzstream.total_in_hi32 = 0;\n\t\txar->bzstream.total_out_lo32 = 0;\n\t\txar->bzstream.total_out_hi32 = 0;\n\t\tbreak;\n#endif\n#if defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n#if LZMA_VERSION_MAJOR >= 5\n/* Effectively disable the limiter. */\n#define LZMA_MEMLIMIT   UINT64_MAX\n#else\n/* NOTE: This needs to check memory size which running system has. */\n#define LZMA_MEMLIMIT   (1U << 30)\n#endif\n\tcase XZ:\n\tcase LZMA:\n\t\tif (xar->lzstream_valid) {\n\t\t\tlzma_end(&(xar->lzstream));\n\t\t\txar->lzstream_valid = 0;\n\t\t}\n\t\tif (xar->entry_encoding == XZ)\n\t\t\tr = lzma_stream_decoder(&(xar->lzstream),\n\t\t\t    LZMA_MEMLIMIT,/* memlimit */\n\t\t\t    LZMA_CONCATENATED);\n\t\telse\n\t\t\tr = lzma_alone_decoder(&(xar->lzstream),\n\t\t\t    LZMA_MEMLIMIT);/* memlimit */\n\t\tif (r != LZMA_OK) {\n\t\t\tswitch (r) {\n\t\t\tcase LZMA_MEM_ERROR:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ENOMEM,\n\t\t\t\t    \"Internal error initializing \"\n\t\t\t\t    \"compression library: \"\n\t\t\t\t    \"Cannot allocate memory\");\n\t\t\t\tbreak;\n\t\t\tcase LZMA_OPTIONS_ERROR:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Internal error initializing \"\n\t\t\t\t    \"compression library: \"\n\t\t\t\t    \"Invalid or unsupported options\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Internal error initializing \"\n\t\t\t\t    \"lzma library\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\txar->lzstream_valid = 1;\n\t\txar->lzstream.total_in = 0;\n\t\txar->lzstream.total_out = 0;\n\t\tbreak;\n#endif\n\t/*\n\t * Unsupported compression.\n\t */\n\tdefault:\n#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n#endif\n#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)\n\tcase LZMA:\n\tcase XZ:\n#endif\n\t\tswitch (xar->entry_encoding) {\n\t\tcase BZIP2: detail = \"bzip2\"; break;\n\t\tcase LZMA: detail = \"lzma\"; break;\n\t\tcase XZ: detail = \"xz\"; break;\n\t\tdefault: detail = \"??\"; break;\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"%s compression not supported on this platform\",\n\t\t    detail);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ndecompress(struct archive_read *a, const void **buff, size_t *outbytes,\n    const void *b, size_t *used)\n{\n\tstruct xar *xar;\n\tvoid *outbuff;\n\tsize_t avail_in, avail_out;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tavail_in = *used;\n\toutbuff = (void *)(uintptr_t)*buff;\n\tif (outbuff == NULL) {\n\t\tif (xar->outbuff == NULL) {\n\t\t\txar->outbuff = malloc(OUTBUFF_SIZE);\n\t\t\tif (xar->outbuff == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Couldn't allocate memory for out buffer\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\toutbuff = xar->outbuff;\n\t\t*buff = outbuff;\n\t\tavail_out = OUTBUFF_SIZE;\n\t} else\n\t\tavail_out = *outbytes;\n\tswitch (xar->rd_encoding) {\n\tcase GZIP:\n\t\txar->stream.next_in = (Bytef *)(uintptr_t)b;\n\t\txar->stream.avail_in = avail_in;\n\t\txar->stream.next_out = (unsigned char *)outbuff;\n\t\txar->stream.avail_out = avail_out;\n\t\tr = inflate(&(xar->stream), 0);\n\t\tswitch (r) {\n\t\tcase Z_OK: /* Decompressor made some progress.*/\n\t\tcase Z_STREAM_END: /* Found end of stream. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"File decompression failed (%d)\", r);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t*used = avail_in - xar->stream.avail_in;\n\t\t*outbytes = avail_out - xar->stream.avail_out;\n\t\tbreak;\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n\t\txar->bzstream.next_in = (char *)(uintptr_t)b;\n\t\txar->bzstream.avail_in = avail_in;\n\t\txar->bzstream.next_out = (char *)outbuff;\n\t\txar->bzstream.avail_out = avail_out;\n\t\tr = BZ2_bzDecompress(&(xar->bzstream));\n\t\tswitch (r) {\n\t\tcase BZ_STREAM_END: /* Found end of stream. */\n\t\t\tswitch (BZ2_bzDecompressEnd(&(xar->bzstream))) {\n\t\t\tcase BZ_OK:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to clean up decompressor\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\txar->bzstream_valid = 0;\n\t\t\t/* FALLTHROUGH */\n\t\tcase BZ_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"bzip decompression failed\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t*used = avail_in - xar->bzstream.avail_in;\n\t\t*outbytes = avail_out - xar->bzstream.avail_out;\n\t\tbreak;\n#endif\n#if defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n\tcase LZMA:\n\tcase XZ:\n\t\txar->lzstream.next_in = b;\n\t\txar->lzstream.avail_in = avail_in;\n\t\txar->lzstream.next_out = (unsigned char *)outbuff;\n\t\txar->lzstream.avail_out = avail_out;\n\t\tr = lzma_code(&(xar->lzstream), LZMA_RUN);\n\t\tswitch (r) {\n\t\tcase LZMA_STREAM_END: /* Found end of stream. */\n\t\t\tlzma_end(&(xar->lzstream));\n\t\t\txar->lzstream_valid = 0;\n\t\t\t/* FALLTHROUGH */\n\t\tcase LZMA_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"%s decompression failed(%d)\",\n\t\t\t    (xar->entry_encoding == XZ)?\"xz\":\"lzma\",\n\t\t\t    r);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t*used = avail_in - xar->lzstream.avail_in;\n\t\t*outbytes = avail_out - xar->lzstream.avail_out;\n\t\tbreak;\n#endif\n#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n#endif\n#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)\n\tcase LZMA:\n\tcase XZ:\n#endif\n\tcase NONE:\n\tdefault:\n\t\tif (outbuff == xar->outbuff) {\n\t\t\t*buff = b;\n\t\t\t*used = avail_in;\n\t\t\t*outbytes = avail_in;\n\t\t} else {\n\t\t\tif (avail_out > avail_in)\n\t\t\t\tavail_out = avail_in;\n\t\t\tmemcpy(outbuff, b, avail_out);\n\t\t\t*used = avail_out;\n\t\t\t*outbytes = avail_out;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ndecompression_cleanup(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tr = ARCHIVE_OK;\n\tif (xar->stream_valid) {\n\t\tif (inflateEnd(&(xar->stream)) != Z_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up zlib decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t}\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tif (xar->bzstream_valid) {\n\t\tif (BZ2_bzDecompressEnd(&(xar->bzstream)) != BZ_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t}\n#endif\n#if defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n\tif (xar->lzstream_valid)\n\t\tlzma_end(&(xar->lzstream));\n#elif defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n\tif (xar->lzstream_valid) {\n\t\tif (lzmadec_end(&(xar->lzstream)) != LZMADEC_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up lzmadec decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t}\n#endif\n\treturn (r);\n}\n\nstatic void\nchecksum_cleanup(struct archive_read *a) {\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\n\t_checksum_final(&(xar->a_sumwrk), NULL, 0);\n\t_checksum_final(&(xar->e_sumwrk), NULL, 0);\n}\n\nstatic void\nxmlattr_cleanup(struct xmlattr_list *list)\n{\n\tstruct xmlattr *attr, *next;\n\n\tattr = list->first;\n\twhile (attr != NULL) {\n\t\tnext = attr->next;\n\t\tfree(attr->name);\n\t\tfree(attr->value);\n\t\tfree(attr);\n\t\tattr = next;\n\t}\n\tlist->first = NULL;\n\tlist->last = &(list->first);\n}\n\nstatic int\nfile_new(struct archive_read *a, struct xar *xar, struct xmlattr_list *list)\n{\n\tstruct xar_file *file;\n\tstruct xmlattr *attr;\n\n\tfile = calloc(1, sizeof(*file));\n\tif (file == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tfile->parent = xar->file;\n\tfile->mode = 0777 | AE_IFREG;\n\tfile->atime = time(NULL);\n\tfile->mtime = time(NULL);\n\txar->file = file;\n\txar->xattr = NULL;\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"id\") == 0)\n\t\t\tfile->id = atol10(attr->value, strlen(attr->value));\n\t}\n\tfile->nlink = 1;\n\tif (heap_add_entry(a, &(xar->file_queue), file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nfile_free(struct xar_file *file)\n{\n\tstruct xattr *xattr;\n\n\tarchive_string_free(&(file->pathname));\n\tarchive_string_free(&(file->symlink));\n\tarchive_string_free(&(file->uname));\n\tarchive_string_free(&(file->gname));\n\tarchive_string_free(&(file->hardlink));\n\txattr = file->xattr_list;\n\twhile (xattr != NULL) {\n\t\tstruct xattr *next;\n\n\t\tnext = xattr->next;\n\t\txattr_free(xattr);\n\t\txattr = next;\n\t}\n\n\tfree(file);\n}\n\nstatic int\nxattr_new(struct archive_read *a, struct xar *xar, struct xmlattr_list *list)\n{\n\tstruct xattr *xattr, **nx;\n\tstruct xmlattr *attr;\n\n\txattr = calloc(1, sizeof(*xattr));\n\tif (xattr == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\txar->xattr = xattr;\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"id\") == 0)\n\t\t\txattr->id = atol10(attr->value, strlen(attr->value));\n\t}\n\t/* Chain to xattr list. */\n\tfor (nx = &(xar->file->xattr_list);\n\t    *nx != NULL; nx = &((*nx)->next)) {\n\t\tif (xattr->id < (*nx)->id)\n\t\t\tbreak;\n\t}\n\txattr->next = *nx;\n\t*nx = xattr;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nxattr_free(struct xattr *xattr)\n{\n\tarchive_string_free(&(xattr->name));\n\tfree(xattr);\n}\n\nstatic int\ngetencoding(struct xmlattr_list *list)\n{\n\tstruct xmlattr *attr;\n\tenum enctype encoding = NONE;\n\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"style\") == 0) {\n\t\t\tif (strcmp(attr->value, \"application/octet-stream\") == 0)\n\t\t\t\tencoding = NONE;\n\t\t\telse if (strcmp(attr->value, \"application/x-gzip\") == 0)\n\t\t\t\tencoding = GZIP;\n\t\t\telse if (strcmp(attr->value, \"application/x-bzip2\") == 0)\n\t\t\t\tencoding = BZIP2;\n\t\t\telse if (strcmp(attr->value, \"application/x-lzma\") == 0)\n\t\t\t\tencoding = LZMA;\n\t\t\telse if (strcmp(attr->value, \"application/x-xz\") == 0)\n\t\t\t\tencoding = XZ;\n\t\t}\n\t}\n\treturn (encoding);\n}\n\nstatic int\ngetsumalgorithm(struct xmlattr_list *list)\n{\n\tstruct xmlattr *attr;\n\tint alg = CKSUM_NONE;\n\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"style\") == 0) {\n\t\t\tconst char *v = attr->value;\n\t\t\tif ((v[0] == 'S' || v[0] == 's') &&\n\t\t\t    (v[1] == 'H' || v[1] == 'h') &&\n\t\t\t    (v[2] == 'A' || v[2] == 'a') &&\n\t\t\t    v[3] == '1' && v[4] == '\\0')\n\t\t\t\talg = CKSUM_SHA1;\n\t\t\tif ((v[0] == 'M' || v[0] == 'm') &&\n\t\t\t    (v[1] == 'D' || v[1] == 'd') &&\n\t\t\t    v[2] == '5' && v[3] == '\\0')\n\t\t\t\talg = CKSUM_MD5;\n\t\t}\n\t}\n\treturn (alg);\n}\n\nstatic int\nunknowntag_start(struct archive_read *a, struct xar *xar, const char *name)\n{\n\tstruct unknown_tag *tag;\n\n\ttag = malloc(sizeof(*tag));\n\tif (tag == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\ttag->next = xar->unknowntags;\n\tarchive_string_init(&(tag->name));\n\tarchive_strcpy(&(tag->name), name);\n\tif (xar->unknowntags == NULL) {\n#if DEBUG\n\t\tfprintf(stderr, \"UNKNOWNTAG_START:%s\\n\", name);\n#endif\n\t\txar->xmlsts_unknown = xar->xmlsts;\n\t\txar->xmlsts = UNKNOWN;\n\t}\n\txar->unknowntags = tag;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nunknowntag_end(struct xar *xar, const char *name)\n{\n\tstruct unknown_tag *tag;\n\n\ttag = xar->unknowntags;\n\tif (tag == NULL || name == NULL)\n\t\treturn;\n\tif (strcmp(tag->name.s, name) == 0) {\n\t\txar->unknowntags = tag->next;\n\t\tarchive_string_free(&(tag->name));\n\t\tfree(tag);\n\t\tif (xar->unknowntags == NULL) {\n#if DEBUG\n\t\t\tfprintf(stderr, \"UNKNOWNTAG_END:%s\\n\", name);\n#endif\n\t\t\txar->xmlsts = xar->xmlsts_unknown;\n\t\t}\n\t}\n}\n\nstatic int\nxml_start(struct archive_read *a, const char *name, struct xmlattr_list *list)\n{\n\tstruct xar *xar;\n\tstruct xmlattr *attr;\n\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\tfprintf(stderr, \"xml_sta:[%s]\\n\", name);\n\tfor (attr = list->first; attr != NULL; attr = attr->next)\n\t\tfprintf(stderr, \"    attr:\\\"%s\\\"=\\\"%s\\\"\\n\",\n\t\t    attr->name, attr->value);\n#endif\n\txar->base64text = 0;\n\tswitch (xar->xmlsts) {\n\tcase INIT:\n\t\tif (strcmp(name, \"xar\") == 0)\n\t\t\txar->xmlsts = XAR;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase XAR:\n\t\tif (strcmp(name, \"toc\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC:\n\t\tif (strcmp(name, \"creation-time\") == 0)\n\t\t\txar->xmlsts = TOC_CREATION_TIME;\n\t\telse if (strcmp(name, \"checksum\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\telse if (strcmp(name, \"file\") == 0) {\n\t\t\tif (file_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\txar->xmlsts = TOC_FILE;\n\t\t}\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_CHECKSUM:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM_SIZE;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_FILE:\n\t\tif (strcmp(name, \"file\") == 0) {\n\t\t\tif (file_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\telse if (strcmp(name, \"data\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\telse if (strcmp(name, \"ea\") == 0) {\n\t\t\tif (xattr_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\txar->xmlsts = FILE_EA;\n\t\t}\n\t\telse if (strcmp(name, \"ctime\") == 0)\n\t\t\txar->xmlsts = FILE_CTIME;\n\t\telse if (strcmp(name, \"mtime\") == 0)\n\t\t\txar->xmlsts = FILE_MTIME;\n\t\telse if (strcmp(name, \"atime\") == 0)\n\t\t\txar->xmlsts = FILE_ATIME;\n\t\telse if (strcmp(name, \"group\") == 0)\n\t\t\txar->xmlsts = FILE_GROUP;\n\t\telse if (strcmp(name, \"gid\") == 0)\n\t\t\txar->xmlsts = FILE_GID;\n\t\telse if (strcmp(name, \"user\") == 0)\n\t\t\txar->xmlsts = FILE_USER;\n\t\telse if (strcmp(name, \"uid\") == 0)\n\t\t\txar->xmlsts = FILE_UID;\n\t\telse if (strcmp(name, \"mode\") == 0)\n\t\t\txar->xmlsts = FILE_MODE;\n\t\telse if (strcmp(name, \"device\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\telse if (strcmp(name, \"deviceno\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICENO;\n\t\telse if (strcmp(name, \"inode\") == 0)\n\t\t\txar->xmlsts = FILE_INODE;\n\t\telse if (strcmp(name, \"link\") == 0)\n\t\t\txar->xmlsts = FILE_LINK;\n\t\telse if (strcmp(name, \"type\") == 0) {\n\t\t\txar->xmlsts = FILE_TYPE;\n\t\t\tfor (attr = list->first; attr != NULL;\n\t\t\t    attr = attr->next) {\n\t\t\t\tif (strcmp(attr->name, \"link\") != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strcmp(attr->value, \"original\") == 0) {\n\t\t\t\t\txar->file->hdnext = xar->hdlink_orgs;\n\t\t\t\t\txar->hdlink_orgs = xar->file;\n\t\t\t\t} else {\n\t\t\t\t\txar->file->link = (unsigned)atol10(attr->value,\n\t\t\t\t\t    strlen(attr->value));\n\t\t\t\t\tif (xar->file->link > 0)\n\t\t\t\t\t\tif (add_link(a, xar, xar->file) != ARCHIVE_OK) {\n\t\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"name\") == 0) {\n\t\t\txar->xmlsts = FILE_NAME;\n\t\t\tfor (attr = list->first; attr != NULL;\n\t\t\t    attr = attr->next) {\n\t\t\t\tif (strcmp(attr->name, \"enctype\") == 0 &&\n\t\t\t\t    strcmp(attr->value, \"base64\") == 0)\n\t\t\t\t\txar->base64text = 1;\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"acl\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\telse if (strcmp(name, \"flags\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\telse if (strcmp(name, \"ext2\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DATA:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_LENGTH;\n\t\telse if (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_SIZE;\n\t\telse if (strcmp(name, \"encoding\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_ENCODING;\n\t\t\txar->file->encoding = getencoding(list);\n\t\t}\n\t\telse if (strcmp(name, \"archived-checksum\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_A_CHECKSUM;\n\t\t\txar->file->a_sum.alg = getsumalgorithm(list);\n\t\t}\n\t\telse if (strcmp(name, \"extracted-checksum\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_E_CHECKSUM;\n\t\t\txar->file->e_sum.alg = getsumalgorithm(list);\n\t\t}\n\t\telse if (strcmp(name, \"content\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_CONTENT;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DEVICE:\n\t\tif (strcmp(name, \"major\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE_MAJOR;\n\t\telse if (strcmp(name, \"minor\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE_MINOR;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DATA_CONTENT:\n\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_EA:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_EA_LENGTH;\n\t\telse if (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_EA_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_EA_SIZE;\n\t\telse if (strcmp(name, \"encoding\") == 0) {\n\t\t\txar->xmlsts = FILE_EA_ENCODING;\n\t\t\txar->xattr->encoding = getencoding(list);\n\t\t} else if (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA_A_CHECKSUM;\n\t\telse if (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA_E_CHECKSUM;\n\t\telse if (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = FILE_EA_NAME;\n\t\telse if (strcmp(name, \"fstype\") == 0)\n\t\t\txar->xmlsts = FILE_EA_FSTYPE;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_ACL:\n\t\tif (strcmp(name, \"appleextended\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_APPLEEXTENDED;\n\t\telse if (strcmp(name, \"default\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_DEFAULT;\n\t\telse if (strcmp(name, \"access\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_ACCESS;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_FLAGS:\n\t\tif (!xml_parse_file_flags(xar, name))\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_EXT2:\n\t\tif (!xml_parse_file_ext2(xar, name))\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_CREATION_TIME:\n\tcase TOC_CHECKSUM_OFFSET:\n\tcase TOC_CHECKSUM_SIZE:\n\tcase FILE_DATA_LENGTH:\n\tcase FILE_DATA_OFFSET:\n\tcase FILE_DATA_SIZE:\n\tcase FILE_DATA_ENCODING:\n\tcase FILE_DATA_A_CHECKSUM:\n\tcase FILE_DATA_E_CHECKSUM:\n\tcase FILE_EA_LENGTH:\n\tcase FILE_EA_OFFSET:\n\tcase FILE_EA_SIZE:\n\tcase FILE_EA_ENCODING:\n\tcase FILE_EA_A_CHECKSUM:\n\tcase FILE_EA_E_CHECKSUM:\n\tcase FILE_EA_NAME:\n\tcase FILE_EA_FSTYPE:\n\tcase FILE_CTIME:\n\tcase FILE_MTIME:\n\tcase FILE_ATIME:\n\tcase FILE_GROUP:\n\tcase FILE_GID:\n\tcase FILE_USER:\n\tcase FILE_UID:\n\tcase FILE_INODE:\n\tcase FILE_DEVICE_MAJOR:\n\tcase FILE_DEVICE_MINOR:\n\tcase FILE_DEVICENO:\n\tcase FILE_MODE:\n\tcase FILE_TYPE:\n\tcase FILE_LINK:\n\tcase FILE_NAME:\n\tcase FILE_ACL_DEFAULT:\n\tcase FILE_ACL_ACCESS:\n\tcase FILE_ACL_APPLEEXTENDED:\n\tcase FILE_FLAGS_USER_NODUMP:\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\tcase FILE_FLAGS_USER_APPEND:\n\tcase FILE_FLAGS_USER_OPAQUE:\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\tcase FILE_FLAGS_SYS_APPEND:\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\tcase FILE_EXT2_SecureDeletion:\n\tcase FILE_EXT2_Undelete:\n\tcase FILE_EXT2_Compress:\n\tcase FILE_EXT2_Synchronous:\n\tcase FILE_EXT2_Immutable:\n\tcase FILE_EXT2_AppendOnly:\n\tcase FILE_EXT2_NoDump:\n\tcase FILE_EXT2_NoAtime:\n\tcase FILE_EXT2_CompDirty:\n\tcase FILE_EXT2_CompBlock:\n\tcase FILE_EXT2_NoCompBlock:\n\tcase FILE_EXT2_CompError:\n\tcase FILE_EXT2_BTree:\n\tcase FILE_EXT2_HashIndexed:\n\tcase FILE_EXT2_iMagic:\n\tcase FILE_EXT2_Journaled:\n\tcase FILE_EXT2_NoTail:\n\tcase FILE_EXT2_DirSync:\n\tcase FILE_EXT2_TopDir:\n\tcase FILE_EXT2_Reserved:\n\tcase UNKNOWN:\n\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nxml_end(void *userData, const char *name)\n{\n\tstruct archive_read *a;\n\tstruct xar *xar;\n\n\ta = (struct archive_read *)userData;\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\tfprintf(stderr, \"xml_end:[%s]\\n\", name);\n#endif\n\tswitch (xar->xmlsts) {\n\tcase INIT:\n\t\tbreak;\n\tcase XAR:\n\t\tif (strcmp(name, \"xar\") == 0)\n\t\t\txar->xmlsts = INIT;\n\t\tbreak;\n\tcase TOC:\n\t\tif (strcmp(name, \"toc\") == 0)\n\t\t\txar->xmlsts = XAR;\n\t\tbreak;\n\tcase TOC_CREATION_TIME:\n\t\tif (strcmp(name, \"creation-time\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\tbreak;\n\tcase TOC_CHECKSUM:\n\t\tif (strcmp(name, \"checksum\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\tbreak;\n\tcase TOC_CHECKSUM_OFFSET:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\tbreak;\n\tcase TOC_CHECKSUM_SIZE:\n\t\tif (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\tbreak;\n\tcase TOC_FILE:\n\t\tif (strcmp(name, \"file\") == 0) {\n\t\t\tif (xar->file->parent != NULL &&\n\t\t\t    ((xar->file->mode & AE_IFMT) == AE_IFDIR))\n\t\t\t\txar->file->parent->subdirs++;\n\t\t\txar->file = xar->file->parent;\n\t\t\tif (xar->file == NULL)\n\t\t\t\txar->xmlsts = TOC;\n\t\t}\n\t\tbreak;\n\tcase FILE_DATA:\n\t\tif (strcmp(name, \"data\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_DATA_LENGTH:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_OFFSET:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_SIZE:\n\t\tif (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_ENCODING:\n\t\tif (strcmp(name, \"encoding\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_A_CHECKSUM:\n\t\tif (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_E_CHECKSUM:\n\t\tif (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_CONTENT:\n\t\tif (strcmp(name, \"content\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_EA:\n\t\tif (strcmp(name, \"ea\") == 0) {\n\t\t\txar->xmlsts = TOC_FILE;\n\t\t\txar->xattr = NULL;\n\t\t}\n\t\tbreak;\n\tcase FILE_EA_LENGTH:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_OFFSET:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_SIZE:\n\t\tif (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_ENCODING:\n\t\tif (strcmp(name, \"encoding\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_A_CHECKSUM:\n\t\tif (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_E_CHECKSUM:\n\t\tif (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_NAME:\n\t\tif (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_FSTYPE:\n\t\tif (strcmp(name, \"fstype\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_CTIME:\n\t\tif (strcmp(name, \"ctime\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_MTIME:\n\t\tif (strcmp(name, \"mtime\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_ATIME:\n\t\tif (strcmp(name, \"atime\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_GROUP:\n\t\tif (strcmp(name, \"group\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_GID:\n\t\tif (strcmp(name, \"gid\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_USER:\n\t\tif (strcmp(name, \"user\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_UID:\n\t\tif (strcmp(name, \"uid\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_MODE:\n\t\tif (strcmp(name, \"mode\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_DEVICE:\n\t\tif (strcmp(name, \"device\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_DEVICE_MAJOR:\n\t\tif (strcmp(name, \"major\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\tbreak;\n\tcase FILE_DEVICE_MINOR:\n\t\tif (strcmp(name, \"minor\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\tbreak;\n\tcase FILE_DEVICENO:\n\t\tif (strcmp(name, \"deviceno\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_INODE:\n\t\tif (strcmp(name, \"inode\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_LINK:\n\t\tif (strcmp(name, \"link\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_TYPE:\n\t\tif (strcmp(name, \"type\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_NAME:\n\t\tif (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_ACL:\n\t\tif (strcmp(name, \"acl\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_ACL_DEFAULT:\n\t\tif (strcmp(name, \"default\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\tbreak;\n\tcase FILE_ACL_ACCESS:\n\t\tif (strcmp(name, \"access\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\tbreak;\n\tcase FILE_ACL_APPLEEXTENDED:\n\t\tif (strcmp(name, \"appleextended\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\tbreak;\n\tcase FILE_FLAGS:\n\t\tif (strcmp(name, \"flags\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_NODUMP:\n\t\tif (strcmp(name, \"UserNoDump\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\t\tif (strcmp(name, \"UserImmutable\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_APPEND:\n\t\tif (strcmp(name, \"UserAppend\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_OPAQUE:\n\t\tif (strcmp(name, \"UserOpaque\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\t\tif (strcmp(name, \"UserNoUnlink\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\t\tif (strcmp(name, \"SystemArchived\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\t\tif (strcmp(name, \"SystemImmutable\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_APPEND:\n\t\tif (strcmp(name, \"SystemAppend\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\t\tif (strcmp(name, \"SystemNoUnlink\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\t\tif (strcmp(name, \"SystemSnapshot\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_EXT2:\n\t\tif (strcmp(name, \"ext2\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_EXT2_SecureDeletion:\n\t\tif (strcmp(name, \"SecureDeletion\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Undelete:\n\t\tif (strcmp(name, \"Undelete\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Compress:\n\t\tif (strcmp(name, \"Compress\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Synchronous:\n\t\tif (strcmp(name, \"Synchronous\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Immutable:\n\t\tif (strcmp(name, \"Immutable\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_AppendOnly:\n\t\tif (strcmp(name, \"AppendOnly\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoDump:\n\t\tif (strcmp(name, \"NoDump\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoAtime:\n\t\tif (strcmp(name, \"NoAtime\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_CompDirty:\n\t\tif (strcmp(name, \"CompDirty\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_CompBlock:\n\t\tif (strcmp(name, \"CompBlock\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoCompBlock:\n\t\tif (strcmp(name, \"NoCompBlock\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_CompError:\n\t\tif (strcmp(name, \"CompError\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_BTree:\n\t\tif (strcmp(name, \"BTree\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_HashIndexed:\n\t\tif (strcmp(name, \"HashIndexed\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_iMagic:\n\t\tif (strcmp(name, \"iMagic\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Journaled:\n\t\tif (strcmp(name, \"Journaled\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoTail:\n\t\tif (strcmp(name, \"NoTail\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_DirSync:\n\t\tif (strcmp(name, \"DirSync\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_TopDir:\n\t\tif (strcmp(name, \"TopDir\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Reserved:\n\t\tif (strcmp(name, \"Reserved\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase UNKNOWN:\n\t\tunknowntag_end(xar, name);\n\t\tbreak;\n\t}\n}\n\nstatic const int base64[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 00 - 0F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 10 - 1F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, 62, -1, -1, -1, 63, /* 20 - 2F */\n\t52, 53, 54, 55, 56, 57, 58, 59,\n\t60, 61, -1, -1, -1, -1, -1, -1, /* 30 - 3F */\n\t-1,  0,  1,  2,  3,  4,  5,  6,\n\t 7,  8,  9, 10, 11, 12, 13, 14, /* 40 - 4F */\n\t15, 16, 17, 18, 19, 20, 21, 22,\n\t23, 24, 25, -1, -1, -1, -1, -1, /* 50 - 5F */\n\t-1, 26, 27, 28, 29, 30, 31, 32,\n\t33, 34, 35, 36, 37, 38, 39, 40, /* 60 - 6F */\n\t41, 42, 43, 44, 45, 46, 47, 48,\n\t49, 50, 51, -1, -1, -1, -1, -1, /* 70 - 7F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 80 - 8F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 90 - 9F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* A0 - AF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* B0 - BF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* C0 - CF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* D0 - DF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* E0 - EF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* F0 - FF */\n};\n\nstatic void\nstrappend_base64(struct xar *xar,\n    struct archive_string *as, const char *s, size_t l)\n{\n\tunsigned char buff[256];\n\tunsigned char *out;\n\tconst unsigned char *b;\n\tsize_t len;\n\n\t(void)xar; /* UNUSED */\n\tlen = 0;\n\tout = buff;\n\tb = (const unsigned char *)s;\n\twhile (l > 0) {\n\t\tint n = 0;\n\n\t\tif (l > 0) {\n\t\t\tif (base64[b[0]] < 0 || base64[b[1]] < 0)\n\t\t\t\tbreak;\n\t\t\tn = base64[*b++] << 18;\n\t\t\tn |= base64[*b++] << 12;\n\t\t\t*out++ = n >> 16;\n\t\t\tlen++;\n\t\t\tl -= 2;\n\t\t}\n\t\tif (l > 0) {\n\t\t\tif (base64[*b] < 0)\n\t\t\t\tbreak;\n\t\t\tn |= base64[*b++] << 6;\n\t\t\t*out++ = (n >> 8) & 0xFF;\n\t\t\tlen++;\n\t\t\t--l;\n\t\t}\n\t\tif (l > 0) {\n\t\t\tif (base64[*b] < 0)\n\t\t\t\tbreak;\n\t\t\tn |= base64[*b++];\n\t\t\t*out++ = n & 0xFF;\n\t\t\tlen++;\n\t\t\t--l;\n\t\t}\n\t\tif (len+3 >= sizeof(buff)) {\n\t\t\tarchive_strncat(as, (const char *)buff, len);\n\t\t\tlen = 0;\n\t\t\tout = buff;\n\t\t}\n\t}\n\tif (len > 0)\n\t\tarchive_strncat(as, (const char *)buff, len);\n}\n\nstatic void\nxml_data(void *userData, const char *s, int len)\n{\n\tstruct archive_read *a;\n\tstruct xar *xar;\n\n\ta = (struct archive_read *)userData;\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\t{\n\t\tchar buff[1024];\n\t\tif (len > (int)(sizeof(buff)-1))\n\t\t\tlen = (int)(sizeof(buff)-1);\n\t\tstrncpy(buff, s, len);\n\t\tbuff[len] = 0;\n\t\tfprintf(stderr, \"\\tlen=%d:\\\"%s\\\"\\n\", len, buff);\n\t}\n#endif\n\tswitch (xar->xmlsts) {\n\tcase TOC_CHECKSUM_OFFSET:\n\t\txar->toc_chksum_offset = atol10(s, len);\n\t\tbreak;\n\tcase TOC_CHECKSUM_SIZE:\n\t\txar->toc_chksum_size = atol10(s, len);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (xar->file == NULL)\n\t\treturn;\n\n\tswitch (xar->xmlsts) {\n\tcase FILE_NAME:\n\t\tif (xar->file->parent != NULL) {\n\t\t\tarchive_string_concat(&(xar->file->pathname),\n\t\t\t    &(xar->file->parent->pathname));\n\t\t\tarchive_strappend_char(&(xar->file->pathname), '/');\n\t\t}\n\t\txar->file->has |= HAS_PATHNAME;\n\t\tif (xar->base64text) {\n\t\t\tstrappend_base64(xar,\n\t\t\t    &(xar->file->pathname), s, len);\n\t\t} else\n\t\t\tarchive_strncat(&(xar->file->pathname), s, len);\n\t\tbreak;\n\tcase FILE_LINK:\n\t\txar->file->has |= HAS_SYMLINK;\n\t\tarchive_strncpy(&(xar->file->symlink), s, len);\n\t\tbreak;\n\tcase FILE_TYPE:\n\t\tif (strncmp(\"file\", s, len) == 0 ||\n\t\t    strncmp(\"hardlink\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFREG;\n\t\tif (strncmp(\"directory\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFDIR;\n\t\tif (strncmp(\"symlink\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFLNK;\n\t\tif (strncmp(\"character special\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFCHR;\n\t\tif (strncmp(\"block special\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFBLK;\n\t\tif (strncmp(\"socket\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFSOCK;\n\t\tif (strncmp(\"fifo\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFIFO;\n\t\txar->file->has |= HAS_TYPE;\n\t\tbreak;\n\tcase FILE_INODE:\n\t\txar->file->has |= HAS_INO;\n\t\txar->file->ino64 = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DEVICE_MAJOR:\n\t\txar->file->has |= HAS_DEVMAJOR;\n\t\txar->file->devmajor = (dev_t)atol10(s, len);\n\t\tbreak;\n\tcase FILE_DEVICE_MINOR:\n\t\txar->file->has |= HAS_DEVMINOR;\n\t\txar->file->devminor = (dev_t)atol10(s, len);\n\t\tbreak;\n\tcase FILE_DEVICENO:\n\t\txar->file->has |= HAS_DEV;\n\t\txar->file->dev = (dev_t)atol10(s, len);\n\t\tbreak;\n\tcase FILE_MODE:\n\t\txar->file->has |= HAS_MODE;\n\t\txar->file->mode =\n\t\t    (xar->file->mode & AE_IFMT) |\n\t\t    ((mode_t)(atol8(s, len)) & ~AE_IFMT);\n\t\tbreak;\n\tcase FILE_GROUP:\n\t\txar->file->has |= HAS_GID;\n\t\tarchive_strncpy(&(xar->file->gname), s, len);\n\t\tbreak;\n\tcase FILE_GID:\n\t\txar->file->has |= HAS_GID;\n\t\txar->file->gid = atol10(s, len);\n\t\tbreak;\n\tcase FILE_USER:\n\t\txar->file->has |= HAS_UID;\n\t\tarchive_strncpy(&(xar->file->uname), s, len);\n\t\tbreak;\n\tcase FILE_UID:\n\t\txar->file->has |= HAS_UID;\n\t\txar->file->uid = atol10(s, len);\n\t\tbreak;\n\tcase FILE_CTIME:\n\t\txar->file->has |= HAS_TIME;\n\t\txar->file->ctime = parse_time(s, len);\n\t\tbreak;\n\tcase FILE_MTIME:\n\t\txar->file->has |= HAS_TIME;\n\t\txar->file->mtime = parse_time(s, len);\n\t\tbreak;\n\tcase FILE_ATIME:\n\t\txar->file->has |= HAS_TIME;\n\t\txar->file->atime = parse_time(s, len);\n\t\tbreak;\n\tcase FILE_DATA_LENGTH:\n\t\txar->file->has |= HAS_DATA;\n\t\txar->file->length = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DATA_OFFSET:\n\t\txar->file->has |= HAS_DATA;\n\t\txar->file->offset = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DATA_SIZE:\n\t\txar->file->has |= HAS_DATA;\n\t\txar->file->size = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DATA_A_CHECKSUM:\n\t\txar->file->a_sum.len = atohex(xar->file->a_sum.val,\n\t\t    sizeof(xar->file->a_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_DATA_E_CHECKSUM:\n\t\txar->file->e_sum.len = atohex(xar->file->e_sum.val,\n\t\t    sizeof(xar->file->e_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_EA_LENGTH:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->length = atol10(s, len);\n\t\tbreak;\n\tcase FILE_EA_OFFSET:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->offset = atol10(s, len);\n\t\tbreak;\n\tcase FILE_EA_SIZE:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->size = atol10(s, len);\n\t\tbreak;\n\tcase FILE_EA_A_CHECKSUM:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->a_sum.len = atohex(xar->xattr->a_sum.val,\n\t\t    sizeof(xar->xattr->a_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_EA_E_CHECKSUM:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->e_sum.len = atohex(xar->xattr->e_sum.val,\n\t\t    sizeof(xar->xattr->e_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_EA_NAME:\n\t\txar->file->has |= HAS_XATTR;\n\t\tarchive_strncpy(&(xar->xattr->name), s, len);\n\t\tbreak;\n\tcase FILE_EA_FSTYPE:\n\t\txar->file->has |= HAS_XATTR;\n\t\tarchive_strncpy(&(xar->xattr->fstype), s, len);\n\t\tbreak;\n\t\tbreak;\n\tcase FILE_ACL_DEFAULT:\n\tcase FILE_ACL_ACCESS:\n\tcase FILE_ACL_APPLEEXTENDED:\n\t\txar->file->has |= HAS_ACL;\n\t\t/* TODO */\n\t\tbreak;\n\tcase INIT:\n\tcase XAR:\n\tcase TOC:\n\tcase TOC_CREATION_TIME:\n\tcase TOC_CHECKSUM:\n\tcase TOC_CHECKSUM_OFFSET:\n\tcase TOC_CHECKSUM_SIZE:\n\tcase TOC_FILE:\n\tcase FILE_DATA:\n\tcase FILE_DATA_ENCODING:\n\tcase FILE_DATA_CONTENT:\n\tcase FILE_DEVICE:\n\tcase FILE_EA:\n\tcase FILE_EA_ENCODING:\n\tcase FILE_ACL:\n\tcase FILE_FLAGS:\n\tcase FILE_FLAGS_USER_NODUMP:\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\tcase FILE_FLAGS_USER_APPEND:\n\tcase FILE_FLAGS_USER_OPAQUE:\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\tcase FILE_FLAGS_SYS_APPEND:\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\tcase FILE_EXT2:\n\tcase FILE_EXT2_SecureDeletion:\n\tcase FILE_EXT2_Undelete:\n\tcase FILE_EXT2_Compress:\n\tcase FILE_EXT2_Synchronous:\n\tcase FILE_EXT2_Immutable:\n\tcase FILE_EXT2_AppendOnly:\n\tcase FILE_EXT2_NoDump:\n\tcase FILE_EXT2_NoAtime:\n\tcase FILE_EXT2_CompDirty:\n\tcase FILE_EXT2_CompBlock:\n\tcase FILE_EXT2_NoCompBlock:\n\tcase FILE_EXT2_CompError:\n\tcase FILE_EXT2_BTree:\n\tcase FILE_EXT2_HashIndexed:\n\tcase FILE_EXT2_iMagic:\n\tcase FILE_EXT2_Journaled:\n\tcase FILE_EXT2_NoTail:\n\tcase FILE_EXT2_DirSync:\n\tcase FILE_EXT2_TopDir:\n\tcase FILE_EXT2_Reserved:\n\tcase UNKNOWN:\n\t\tbreak;\n\t}\n}\n\n/*\n * BSD file flags.\n */\nstatic int\nxml_parse_file_flags(struct xar *xar, const char *name)\n{\n\tconst char *flag = NULL;\n\n\tif (strcmp(name, \"UserNoDump\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_NODUMP;\n\t\tflag = \"nodump\";\n\t}\n\telse if (strcmp(name, \"UserImmutable\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_IMMUTABLE;\n\t\tflag = \"uimmutable\";\n\t}\n\telse if (strcmp(name, \"UserAppend\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_APPEND;\n\t\tflag = \"uappend\";\n\t}\n\telse if (strcmp(name, \"UserOpaque\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_OPAQUE;\n\t\tflag = \"opaque\";\n\t}\n\telse if (strcmp(name, \"UserNoUnlink\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_NOUNLINK;\n\t\tflag = \"nouunlink\";\n\t}\n\telse if (strcmp(name, \"SystemArchived\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_ARCHIVED;\n\t\tflag = \"archived\";\n\t}\n\telse if (strcmp(name, \"SystemImmutable\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_IMMUTABLE;\n\t\tflag = \"simmutable\";\n\t}\n\telse if (strcmp(name, \"SystemAppend\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_APPEND;\n\t\tflag = \"sappend\";\n\t}\n\telse if (strcmp(name, \"SystemNoUnlink\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_NOUNLINK;\n\t\tflag = \"nosunlink\";\n\t}\n\telse if (strcmp(name, \"SystemSnapshot\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_SNAPSHOT;\n\t\tflag = \"snapshot\";\n\t}\n\n\tif (flag == NULL)\n\t\treturn (0);\n\txar->file->has |= HAS_FFLAGS;\n\tif (archive_strlen(&(xar->file->fflags_text)) > 0)\n\t\tarchive_strappend_char(&(xar->file->fflags_text), ',');\n\tarchive_strcat(&(xar->file->fflags_text), flag);\n\treturn (1);\n}\n\n/*\n * Linux file flags.\n */\nstatic int\nxml_parse_file_ext2(struct xar *xar, const char *name)\n{\n\tconst char *flag = NULL;\n\n\tif (strcmp(name, \"SecureDeletion\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_SecureDeletion;\n\t\tflag = \"securedeletion\";\n\t}\n\telse if (strcmp(name, \"Undelete\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Undelete;\n\t\tflag = \"nouunlink\";\n\t}\n\telse if (strcmp(name, \"Compress\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Compress;\n\t\tflag = \"compress\";\n\t}\n\telse if (strcmp(name, \"Synchronous\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Synchronous;\n\t\tflag = \"sync\";\n\t}\n\telse if (strcmp(name, \"Immutable\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Immutable;\n\t\tflag = \"simmutable\";\n\t}\n\telse if (strcmp(name, \"AppendOnly\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_AppendOnly;\n\t\tflag = \"sappend\";\n\t}\n\telse if (strcmp(name, \"NoDump\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoDump;\n\t\tflag = \"nodump\";\n\t}\n\telse if (strcmp(name, \"NoAtime\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoAtime;\n\t\tflag = \"noatime\";\n\t}\n\telse if (strcmp(name, \"CompDirty\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_CompDirty;\n\t\tflag = \"compdirty\";\n\t}\n\telse if (strcmp(name, \"CompBlock\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_CompBlock;\n\t\tflag = \"comprblk\";\n\t}\n\telse if (strcmp(name, \"NoCompBlock\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoCompBlock;\n\t\tflag = \"nocomprblk\";\n\t}\n\telse if (strcmp(name, \"CompError\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_CompError;\n\t\tflag = \"comperr\";\n\t}\n\telse if (strcmp(name, \"BTree\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_BTree;\n\t\tflag = \"btree\";\n\t}\n\telse if (strcmp(name, \"HashIndexed\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_HashIndexed;\n\t\tflag = \"hashidx\";\n\t}\n\telse if (strcmp(name, \"iMagic\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_iMagic;\n\t\tflag = \"imagic\";\n\t}\n\telse if (strcmp(name, \"Journaled\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Journaled;\n\t\tflag = \"journal\";\n\t}\n\telse if (strcmp(name, \"NoTail\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoTail;\n\t\tflag = \"notail\";\n\t}\n\telse if (strcmp(name, \"DirSync\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_DirSync;\n\t\tflag = \"dirsync\";\n\t}\n\telse if (strcmp(name, \"TopDir\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_TopDir;\n\t\tflag = \"topdir\";\n\t}\n\telse if (strcmp(name, \"Reserved\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Reserved;\n\t\tflag = \"reserved\";\n\t}\n\n\tif (flag == NULL)\n\t\treturn (0);\n\tif (archive_strlen(&(xar->file->fflags_text)) > 0)\n\t\tarchive_strappend_char(&(xar->file->fflags_text), ',');\n\tarchive_strcat(&(xar->file->fflags_text), flag);\n\treturn (1);\n}\n\n#ifdef HAVE_LIBXML_XMLREADER_H\n\nstatic int\nxml2_xmlattr_setup(struct archive_read *a,\n    struct xmlattr_list *list, xmlTextReaderPtr reader)\n{\n\tstruct xmlattr *attr;\n\tint r;\n\n\tlist->first = NULL;\n\tlist->last = &(list->first);\n\tr = xmlTextReaderMoveToFirstAttribute(reader);\n\twhile (r == 1) {\n\t\tattr = malloc(sizeof*(attr));\n\t\tif (attr == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->name = strdup(\n\t\t    (const char *)xmlTextReaderConstLocalName(reader));\n\t\tif (attr->name == NULL) {\n\t\t\tfree(attr);\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->value = strdup(\n\t\t    (const char *)xmlTextReaderConstValue(reader));\n\t\tif (attr->value == NULL) {\n\t\t\tfree(attr->name);\n\t\t\tfree(attr);\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->next = NULL;\n\t\t*list->last = attr;\n\t\tlist->last = &(attr->next);\n\t\tr = xmlTextReaderMoveToNextAttribute(reader);\n\t}\n\treturn (r);\n}\n\nstatic int\nxml2_read_cb(void *context, char *buffer, int len)\n{\n\tstruct archive_read *a;\n\tstruct xar *xar;\n\tconst void *d;\n\tsize_t outbytes;\n\tsize_t used = 0;\n\tint r;\n\n\ta = (struct archive_read *)context;\n\txar = (struct xar *)(a->format->data);\n\n\tif (xar->toc_remaining <= 0)\n\t\treturn (0);\n\td = buffer;\n\toutbytes = len;\n\tr = rd_contents(a, &d, &outbytes, &used, xar->toc_remaining);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\t__archive_read_consume(a, used);\n\txar->toc_remaining -= used;\n\txar->offset += used;\n\txar->toc_total += outbytes;\n\tPRINT_TOC(buffer, len);\n\n\treturn ((int)outbytes);\n}\n\nstatic int\nxml2_close_cb(void *context)\n{\n\n\t(void)context; /* UNUSED */\n\treturn (0);\n}\n\nstatic void\nxml2_error_hdr(void *arg, const char *msg, xmlParserSeverities severity,\n    xmlTextReaderLocatorPtr locator)\n{\n\tstruct archive_read *a;\n\n\t(void)locator; /* UNUSED */\n\ta = (struct archive_read *)arg;\n\tswitch (severity) {\n\tcase XML_PARSER_SEVERITY_VALIDITY_WARNING:\n\tcase XML_PARSER_SEVERITY_WARNING:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"XML Parsing error: %s\", msg);\n\t\tbreak;\n\tcase XML_PARSER_SEVERITY_VALIDITY_ERROR:\n\tcase XML_PARSER_SEVERITY_ERROR:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"XML Parsing error: %s\", msg);\n\t\tbreak;\n\t}\n}\n\nstatic int\nxml2_read_toc(struct archive_read *a)\n{\n\txmlTextReaderPtr reader;\n\tstruct xmlattr_list list;\n\tint r;\n\n\treader = xmlReaderForIO(xml2_read_cb, xml2_close_cb, a, NULL, NULL, 0);\n\tif (reader == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Couldn't allocate memory for xml parser\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\txmlTextReaderSetErrorHandler(reader, xml2_error_hdr, a);\n\n\twhile ((r = xmlTextReaderRead(reader)) == 1) {\n\t\tconst char *name, *value;\n\t\tint type, empty;\n\n\t\ttype = xmlTextReaderNodeType(reader);\n\t\tname = (const char *)xmlTextReaderConstLocalName(reader);\n\t\tswitch (type) {\n\t\tcase XML_READER_TYPE_ELEMENT:\n\t\t\tempty = xmlTextReaderIsEmptyElement(reader);\n\t\t\tr = xml2_xmlattr_setup(a, &list, reader);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tr = xml_start(a, name, &list);\n\t\t\txmlattr_cleanup(&list);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t\tif (empty)\n\t\t\t\txml_end(a, name);\n\t\t\tbreak;\n\t\tcase XML_READER_TYPE_END_ELEMENT:\n\t\t\txml_end(a, name);\n\t\t\tbreak;\n\t\tcase XML_READER_TYPE_TEXT:\n\t\t\tvalue = (const char *)xmlTextReaderConstValue(reader);\n\t\t\txml_data(a, value, strlen(value));\n\t\t\tbreak;\n\t\tcase XML_READER_TYPE_SIGNIFICANT_WHITESPACE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (r < 0)\n\t\t\tbreak;\n\t}\n\txmlFreeTextReader(reader);\n\txmlCleanupParser();\n\n\treturn ((r == 0)?ARCHIVE_OK:ARCHIVE_FATAL);\n}\n\n#elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\n\nstatic int\nexpat_xmlattr_setup(struct archive_read *a,\n    struct xmlattr_list *list, const XML_Char **atts)\n{\n\tstruct xmlattr *attr;\n\tchar *name, *value;\n\n\tlist->first = NULL;\n\tlist->last = &(list->first);\n\tif (atts == NULL)\n\t\treturn (ARCHIVE_OK);\n\twhile (atts[0] != NULL && atts[1] != NULL) {\n\t\tattr = malloc(sizeof*(attr));\n\t\tname = strdup(atts[0]);\n\t\tvalue = strdup(atts[1]);\n\t\tif (attr == NULL || name == NULL || value == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\tfree(attr);\n\t\t\tfree(name);\n\t\t\tfree(value);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->name = name;\n\t\tattr->value = value;\n\t\tattr->next = NULL;\n\t\t*list->last = attr;\n\t\tlist->last = &(attr->next);\n\t\tatts += 2;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nexpat_start_cb(void *userData, const XML_Char *name, const XML_Char **atts)\n{\n\tstruct expat_userData *ud = (struct expat_userData *)userData;\n\tstruct archive_read *a = ud->archive;\n\tstruct xmlattr_list list;\n\tint r;\n\n\tr = expat_xmlattr_setup(a, &list, atts);\n\tif (r == ARCHIVE_OK)\n\t\tr = xml_start(a, (const char *)name, &list);\n\txmlattr_cleanup(&list);\n\tud->state = r;\n}\n\nstatic void\nexpat_end_cb(void *userData, const XML_Char *name)\n{\n\tstruct expat_userData *ud = (struct expat_userData *)userData;\n\n\txml_end(ud->archive, (const char *)name);\n}\n\nstatic void\nexpat_data_cb(void *userData, const XML_Char *s, int len)\n{\n\tstruct expat_userData *ud = (struct expat_userData *)userData;\n\n\txml_data(ud->archive, s, len);\n}\n\nstatic int\nexpat_read_toc(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tXML_Parser parser;\n\tstruct expat_userData ud;\n\n\tud.state = ARCHIVE_OK;\n\tud.archive = a;\n\n\txar = (struct xar *)(a->format->data);\n\n\t/* Initialize XML Parser library. */\n\tparser = XML_ParserCreate(NULL);\n\tif (parser == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Couldn't allocate memory for xml parser\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tXML_SetUserData(parser, &ud);\n\tXML_SetElementHandler(parser, expat_start_cb, expat_end_cb);\n\tXML_SetCharacterDataHandler(parser, expat_data_cb);\n\txar->xmlsts = INIT;\n\n\twhile (xar->toc_remaining && ud.state == ARCHIVE_OK) {\n\t\tenum XML_Status xr;\n\t\tconst void *d;\n\t\tsize_t outbytes;\n\t\tsize_t used;\n\t\tint r;\n\n\t\td = NULL;\n\t\tr = rd_contents(a, &d, &outbytes, &used, xar->toc_remaining);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\txar->toc_remaining -= used;\n\t\txar->offset += used;\n\t\txar->toc_total += outbytes;\n\t\tPRINT_TOC(d, outbytes);\n\n\t\txr = XML_Parse(parser, d, outbytes, xar->toc_remaining == 0);\n\t\t__archive_read_consume(a, used);\n\t\tif (xr == XML_STATUS_ERROR) {\n\t\t\tXML_ParserFree(parser);\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"XML Parsing failed\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\tXML_ParserFree(parser);\n\treturn (ud.state);\n}\n#endif /* defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H) */\n\n#endif /* Support xar format */\n"], "fixing_code": ["/*-\n * Copyright (c) 2009 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD$\");\n\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_LIBXML_XMLREADER_H\n#include <libxml/xmlreader.h>\n#elif HAVE_BSDXML_H\n#include <bsdxml.h>\n#elif HAVE_EXPAT_H\n#include <expat.h>\n#endif\n#ifdef HAVE_BZLIB_H\n#include <bzlib.h>\n#endif\n#if HAVE_LZMA_H\n#include <lzma.h>\n#endif\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n\n#include \"archive.h\"\n#include \"archive_digest_private.h\"\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_entry_locale.h\"\n#include \"archive_private.h\"\n#include \"archive_read_private.h\"\n\n#if (!defined(HAVE_LIBXML_XMLREADER_H) && \\\n     !defined(HAVE_BSDXML_H) && !defined(HAVE_EXPAT_H)) ||\\\n\t!defined(HAVE_ZLIB_H) || \\\n\t!defined(ARCHIVE_HAS_MD5) || !defined(ARCHIVE_HAS_SHA1)\n/*\n * xar needs several external libraries.\n *   o libxml2 or expat --- XML parser\n *   o openssl or MD5/SHA1 hash function\n *   o zlib\n *   o bzlib2 (option)\n *   o liblzma (option)\n */\nint\narchive_read_support_format_xar(struct archive *_a)\n{\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_xar\");\n\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t    \"Xar not supported on this platform\");\n\treturn (ARCHIVE_WARN);\n}\n\n#else\t/* Support xar format */\n\n/* #define DEBUG 1 */\n/* #define DEBUG_PRINT_TOC 1 */\n#if DEBUG_PRINT_TOC\n#define PRINT_TOC(d, outbytes)\tdo {\t\t\t\t\\\n\tunsigned char *x = (unsigned char *)(uintptr_t)d;\t\\\n\tunsigned char c = x[outbytes-1];\t\t\t\\\n\tx[outbytes - 1] = 0;\t\t\t\t\t\\\n\tfprintf(stderr, \"%s\", x);\t\t\t\t\\\n\tfprintf(stderr, \"%c\", c);\t\t\t\t\\\n\tx[outbytes - 1] = c;\t\t\t\t\t\\\n} while (0)\n#else\n#define PRINT_TOC(d, outbytes)\n#endif\n\n#define HEADER_MAGIC\t0x78617221\n#define HEADER_SIZE\t28\n#define HEADER_VERSION\t1\n#define CKSUM_NONE\t0\n#define CKSUM_SHA1\t1\n#define CKSUM_MD5\t2\n\n#define MD5_SIZE\t16\n#define SHA1_SIZE\t20\n#define MAX_SUM_SIZE\t20\n\nenum enctype {\n\tNONE,\n\tGZIP,\n\tBZIP2,\n\tLZMA,\n\tXZ,\n};\n\nstruct chksumval {\n\tint\t\t\t alg;\n\tsize_t\t\t\t len;\n\tunsigned char\t\t val[MAX_SUM_SIZE];\n};\n\nstruct chksumwork {\n\tint\t\t\t alg;\n#ifdef ARCHIVE_HAS_MD5\n\tarchive_md5_ctx\t\t md5ctx;\n#endif\n#ifdef ARCHIVE_HAS_SHA1\n\tarchive_sha1_ctx\t sha1ctx;\n#endif\n};\n\nstruct xattr {\n\tstruct xattr\t\t*next;\n\tstruct archive_string\t name;\n\tuint64_t\t\t id;\n\tuint64_t\t\t length;\n\tuint64_t\t\t offset;\n\tuint64_t\t\t size;\n\tenum enctype\t\t encoding;\n\tstruct chksumval\t a_sum;\n\tstruct chksumval\t e_sum;\n\tstruct archive_string\t fstype;\n};\n\nstruct xar_file {\n\tstruct xar_file\t\t*next;\n\tstruct xar_file\t\t*hdnext;\n\tstruct xar_file\t\t*parent;\n\tint\t\t\t subdirs;\n\n\tunsigned int\t\t has;\n#define HAS_DATA\t\t0x00001\n#define HAS_PATHNAME\t\t0x00002\n#define HAS_SYMLINK\t\t0x00004\n#define HAS_TIME\t\t0x00008\n#define HAS_UID\t\t\t0x00010\n#define HAS_GID\t\t\t0x00020\n#define HAS_MODE\t\t0x00040\n#define HAS_TYPE\t\t0x00080\n#define HAS_DEV\t\t\t0x00100\n#define HAS_DEVMAJOR\t\t0x00200\n#define HAS_DEVMINOR\t\t0x00400\n#define HAS_INO\t\t\t0x00800\n#define HAS_FFLAGS\t\t0x01000\n#define HAS_XATTR\t\t0x02000\n#define HAS_ACL\t\t\t0x04000\n\n\tuint64_t\t\t id;\n\tuint64_t\t\t length;\n\tuint64_t\t\t offset;\n\tuint64_t\t\t size;\n\tenum enctype\t\t encoding;\n\tstruct chksumval\t a_sum;\n\tstruct chksumval\t e_sum;\n\tstruct archive_string\t pathname;\n\tstruct archive_string\t symlink;\n\ttime_t\t\t\t ctime;\n\ttime_t\t\t\t mtime;\n\ttime_t\t\t\t atime;\n\tstruct archive_string\t uname;\n\tint64_t\t\t\t uid;\n\tstruct archive_string\t gname;\n\tint64_t\t\t\t gid;\n\tmode_t\t\t\t mode;\n\tdev_t\t\t\t dev;\n\tdev_t\t\t\t devmajor;\n\tdev_t\t\t\t devminor;\n\tint64_t\t\t\t ino64;\n\tstruct archive_string\t fflags_text;\n\tunsigned int\t\t link;\n\tunsigned int\t\t nlink;\n\tstruct archive_string\t hardlink;\n\tstruct xattr\t\t*xattr_list;\n};\n\nstruct hdlink {\n\tstruct hdlink\t\t *next;\n\n\tunsigned int\t\t id;\n\tint\t\t\t cnt;\n\tstruct xar_file\t\t *files;\n};\n\nstruct heap_queue {\n\tstruct xar_file\t\t**files;\n\tint\t\t\t allocated;\n\tint\t\t\t used;\n};\n\nenum xmlstatus {\n\tINIT,\n\tXAR,\n\tTOC,\n\tTOC_CREATION_TIME,\n\tTOC_CHECKSUM,\n\tTOC_CHECKSUM_OFFSET,\n\tTOC_CHECKSUM_SIZE,\n\tTOC_FILE,\n\tFILE_DATA,\n\tFILE_DATA_LENGTH,\n\tFILE_DATA_OFFSET,\n\tFILE_DATA_SIZE,\n\tFILE_DATA_ENCODING,\n\tFILE_DATA_A_CHECKSUM,\n\tFILE_DATA_E_CHECKSUM,\n\tFILE_DATA_CONTENT,\n\tFILE_EA,\n\tFILE_EA_LENGTH,\n\tFILE_EA_OFFSET,\n\tFILE_EA_SIZE,\n\tFILE_EA_ENCODING,\n\tFILE_EA_A_CHECKSUM,\n\tFILE_EA_E_CHECKSUM,\n\tFILE_EA_NAME,\n\tFILE_EA_FSTYPE,\n\tFILE_CTIME,\n\tFILE_MTIME,\n\tFILE_ATIME,\n\tFILE_GROUP,\n\tFILE_GID,\n\tFILE_USER,\n\tFILE_UID,\n\tFILE_MODE,\n\tFILE_DEVICE,\n\tFILE_DEVICE_MAJOR,\n\tFILE_DEVICE_MINOR,\n\tFILE_DEVICENO,\n\tFILE_INODE,\n\tFILE_LINK,\n\tFILE_TYPE,\n\tFILE_NAME,\n\tFILE_ACL,\n\tFILE_ACL_DEFAULT,\n\tFILE_ACL_ACCESS,\n\tFILE_ACL_APPLEEXTENDED,\n\t/* BSD file flags. */\n\tFILE_FLAGS,\n\tFILE_FLAGS_USER_NODUMP,\n\tFILE_FLAGS_USER_IMMUTABLE,\n\tFILE_FLAGS_USER_APPEND,\n\tFILE_FLAGS_USER_OPAQUE,\n\tFILE_FLAGS_USER_NOUNLINK,\n\tFILE_FLAGS_SYS_ARCHIVED,\n\tFILE_FLAGS_SYS_IMMUTABLE,\n\tFILE_FLAGS_SYS_APPEND,\n\tFILE_FLAGS_SYS_NOUNLINK,\n\tFILE_FLAGS_SYS_SNAPSHOT,\n\t/* Linux file flags. */\n\tFILE_EXT2,\n\tFILE_EXT2_SecureDeletion,\n\tFILE_EXT2_Undelete,\n\tFILE_EXT2_Compress,\n\tFILE_EXT2_Synchronous,\n\tFILE_EXT2_Immutable,\n\tFILE_EXT2_AppendOnly,\n\tFILE_EXT2_NoDump,\n\tFILE_EXT2_NoAtime,\n\tFILE_EXT2_CompDirty,\n\tFILE_EXT2_CompBlock,\n\tFILE_EXT2_NoCompBlock,\n\tFILE_EXT2_CompError,\n\tFILE_EXT2_BTree,\n\tFILE_EXT2_HashIndexed,\n\tFILE_EXT2_iMagic,\n\tFILE_EXT2_Journaled,\n\tFILE_EXT2_NoTail,\n\tFILE_EXT2_DirSync,\n\tFILE_EXT2_TopDir,\n\tFILE_EXT2_Reserved,\n\tUNKNOWN,\n};\n\nstruct unknown_tag {\n\tstruct unknown_tag\t*next;\n\tstruct archive_string\t name;\n};\n\nstruct xar {\n\tuint64_t\t\t offset; /* Current position in the file. */\n\tint64_t\t\t\t total;\n\tuint64_t\t\t h_base;\n\tint\t\t\t end_of_file;\n#define OUTBUFF_SIZE\t(1024 * 64)\n\tunsigned char\t\t*outbuff;\n\n\tenum xmlstatus\t\t xmlsts;\n\tenum xmlstatus\t\t xmlsts_unknown;\n\tstruct unknown_tag\t*unknowntags;\n\tint\t\t\t base64text;\n\n\t/*\n\t * TOC\n\t */\n\tuint64_t\t\t toc_remaining;\n\tuint64_t\t\t toc_total;\n\tuint64_t\t\t toc_chksum_offset;\n\tuint64_t\t\t toc_chksum_size;\n\n\t/*\n\t * For Decoding data.\n\t */\n\tenum enctype \t\t rd_encoding;\n\tz_stream\t\t stream;\n\tint\t\t\t stream_valid;\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tbz_stream\t\t bzstream;\n\tint\t\t\t bzstream_valid;\n#endif\n#if HAVE_LZMA_H && HAVE_LIBLZMA\n\tlzma_stream\t\t lzstream;\n\tint\t\t\t lzstream_valid;\n#endif\n\t/*\n\t * For Checksum data.\n\t */\n\tstruct chksumwork\t a_sumwrk;\n\tstruct chksumwork\t e_sumwrk;\n\n\tstruct xar_file\t\t*file;\t/* current reading file. */\n\tstruct xattr\t\t*xattr; /* current reading extended attribute. */\n\tstruct heap_queue\t file_queue;\n\tstruct xar_file\t\t*hdlink_orgs;\n\tstruct hdlink\t\t*hdlink_list;\n\n\tint\t \t\t entry_init;\n\tuint64_t\t\t entry_total;\n\tuint64_t\t\t entry_remaining;\n\tsize_t\t\t\t entry_unconsumed;\n\tuint64_t\t\t entry_size;\n\tenum enctype \t\t entry_encoding;\n\tstruct chksumval\t entry_a_sum;\n\tstruct chksumval\t entry_e_sum;\n\n\tstruct archive_string_conv *sconv;\n};\n\nstruct xmlattr {\n\tstruct xmlattr\t*next;\n\tchar\t\t*name;\n\tchar\t\t*value;\n};\n\nstruct xmlattr_list {\n\tstruct xmlattr\t*first;\n\tstruct xmlattr\t**last;\n};\n\nstatic int\txar_bid(struct archive_read *, int);\nstatic int\txar_read_header(struct archive_read *,\n\t\t    struct archive_entry *);\nstatic int\txar_read_data(struct archive_read *,\n\t\t    const void **, size_t *, int64_t *);\nstatic int\txar_read_data_skip(struct archive_read *);\nstatic int\txar_cleanup(struct archive_read *);\nstatic int\tmove_reading_point(struct archive_read *, uint64_t);\nstatic int\trd_contents_init(struct archive_read *,\n\t\t    enum enctype, int, int);\nstatic int\trd_contents(struct archive_read *, const void **,\n\t\t    size_t *, size_t *, uint64_t);\nstatic uint64_t\tatol10(const char *, size_t);\nstatic int64_t\tatol8(const char *, size_t);\nstatic size_t\tatohex(unsigned char *, size_t, const char *, size_t);\nstatic time_t\tparse_time(const char *p, size_t n);\nstatic int\theap_add_entry(struct archive_read *a,\n    struct heap_queue *, struct xar_file *);\nstatic struct xar_file *heap_get_entry(struct heap_queue *);\nstatic int\tadd_link(struct archive_read *,\n    struct xar *, struct xar_file *);\nstatic void\tchecksum_init(struct archive_read *, int, int);\nstatic void\tchecksum_update(struct archive_read *, const void *,\n\t\t    size_t, const void *, size_t);\nstatic int\tchecksum_final(struct archive_read *, const void *,\n\t\t    size_t, const void *, size_t);\nstatic void\tchecksum_cleanup(struct archive_read *);\nstatic int\tdecompression_init(struct archive_read *, enum enctype);\nstatic int\tdecompress(struct archive_read *, const void **,\n\t\t    size_t *, const void *, size_t *);\nstatic int\tdecompression_cleanup(struct archive_read *);\nstatic void\txmlattr_cleanup(struct xmlattr_list *);\nstatic int\tfile_new(struct archive_read *,\n    struct xar *, struct xmlattr_list *);\nstatic void\tfile_free(struct xar_file *);\nstatic int\txattr_new(struct archive_read *,\n    struct xar *, struct xmlattr_list *);\nstatic void\txattr_free(struct xattr *);\nstatic int\tgetencoding(struct xmlattr_list *);\nstatic int\tgetsumalgorithm(struct xmlattr_list *);\nstatic int\tunknowntag_start(struct archive_read *,\n    struct xar *, const char *);\nstatic void\tunknowntag_end(struct xar *, const char *);\nstatic int\txml_start(struct archive_read *,\n    const char *, struct xmlattr_list *);\nstatic void\txml_end(void *, const char *);\nstatic void\txml_data(void *, const char *, int);\nstatic int\txml_parse_file_flags(struct xar *, const char *);\nstatic int\txml_parse_file_ext2(struct xar *, const char *);\n#if defined(HAVE_LIBXML_XMLREADER_H)\nstatic int\txml2_xmlattr_setup(struct archive_read *,\n    struct xmlattr_list *, xmlTextReaderPtr);\nstatic int\txml2_read_cb(void *, char *, int);\nstatic int\txml2_close_cb(void *);\nstatic void\txml2_error_hdr(void *, const char *, xmlParserSeverities,\n\t\t    xmlTextReaderLocatorPtr);\nstatic int\txml2_read_toc(struct archive_read *);\n#elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\nstruct expat_userData {\n\tint state;\n\tstruct archive_read *archive;\n};\nstatic int\texpat_xmlattr_setup(struct archive_read *,\n    struct xmlattr_list *, const XML_Char **);\nstatic void\texpat_start_cb(void *, const XML_Char *, const XML_Char **);\nstatic void\texpat_end_cb(void *, const XML_Char *);\nstatic void\texpat_data_cb(void *, const XML_Char *, int);\nstatic int\texpat_read_toc(struct archive_read *);\n#endif\n\nint\narchive_read_support_format_xar(struct archive *_a)\n{\n\tstruct xar *xar;\n\tstruct archive_read *a = (struct archive_read *)_a;\n\tint r;\n\n\tarchive_check_magic(_a, ARCHIVE_READ_MAGIC,\n\t    ARCHIVE_STATE_NEW, \"archive_read_support_format_xar\");\n\n\txar = (struct xar *)calloc(1, sizeof(*xar));\n\tif (xar == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate xar data\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tr = __archive_read_register_format(a,\n\t    xar,\n\t    \"xar\",\n\t    xar_bid,\n\t    NULL,\n\t    xar_read_header,\n\t    xar_read_data,\n\t    xar_read_data_skip,\n\t    NULL,\n\t    xar_cleanup,\n\t    NULL,\n\t    NULL);\n\tif (r != ARCHIVE_OK)\n\t\tfree(xar);\n\treturn (r);\n}\n\nstatic int\nxar_bid(struct archive_read *a, int best_bid)\n{\n\tconst unsigned char *b;\n\tint bid;\n\n\t(void)best_bid; /* UNUSED */\n\n\tb = __archive_read_ahead(a, HEADER_SIZE, NULL);\n\tif (b == NULL)\n\t\treturn (-1);\n\n\tbid = 0;\n\t/*\n\t * Verify magic code\n\t */\n\tif (archive_be32dec(b) != HEADER_MAGIC)\n\t\treturn (0);\n\tbid += 32;\n\t/*\n\t * Verify header size\n\t */\n\tif (archive_be16dec(b+4) != HEADER_SIZE)\n\t\treturn (0);\n\tbid += 16;\n\t/*\n\t * Verify header version\n\t */\n\tif (archive_be16dec(b+6) != HEADER_VERSION)\n\t\treturn (0);\n\tbid += 16;\n\t/*\n\t * Verify type of checksum\n\t */\n\tswitch (archive_be32dec(b+24)) {\n\tcase CKSUM_NONE:\n\tcase CKSUM_SHA1:\n\tcase CKSUM_MD5:\n\t\tbid += 32;\n\t\tbreak;\n\tdefault:\n\t\treturn (0);\n\t}\n\n\treturn (bid);\n}\n\nstatic int\nread_toc(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tstruct xar_file *file;\n\tconst unsigned char *b;\n\tuint64_t toc_compressed_size;\n\tuint64_t toc_uncompressed_size;\n\tuint32_t toc_chksum_alg;\n\tssize_t bytes;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\n\t/*\n\t * Read xar header.\n\t */\n\tb = __archive_read_ahead(a, HEADER_SIZE, &bytes);\n\tif (bytes < 0)\n\t\treturn ((int)bytes);\n\tif (bytes < HEADER_SIZE) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Truncated archive header\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\tif (archive_be32dec(b) != HEADER_MAGIC) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Invalid header magic\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif (archive_be16dec(b+6) != HEADER_VERSION) {\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Unsupported header version(%d)\",\n\t\t    archive_be16dec(b+6));\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\ttoc_compressed_size = archive_be64dec(b+8);\n\txar->toc_remaining = toc_compressed_size;\n\ttoc_uncompressed_size = archive_be64dec(b+16);\n\ttoc_chksum_alg = archive_be32dec(b+24);\n\t__archive_read_consume(a, HEADER_SIZE);\n\txar->offset += HEADER_SIZE;\n\txar->toc_total = 0;\n\n\t/*\n\t * Read TOC(Table of Contents).\n\t */\n\t/* Initialize reading contents. */\n\tr = move_reading_point(a, HEADER_SIZE);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\tr = rd_contents_init(a, GZIP, toc_chksum_alg, CKSUM_NONE);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n#ifdef HAVE_LIBXML_XMLREADER_H\n\tr = xml2_read_toc(a);\n#elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\n\tr = expat_read_toc(a);\n#endif\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\n\t/* Set 'The HEAP' base. */\n\txar->h_base = xar->offset;\n\tif (xar->toc_total != toc_uncompressed_size) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"TOC uncompressed size error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * Checksum TOC\n\t */\n\tif (toc_chksum_alg != CKSUM_NONE) {\n\t\tr = move_reading_point(a, xar->toc_chksum_offset);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tb = __archive_read_ahead(a,\n\t\t\t(size_t)xar->toc_chksum_size, &bytes);\n\t\tif (bytes < 0)\n\t\t\treturn ((int)bytes);\n\t\tif ((uint64_t)bytes < xar->toc_chksum_size) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated archive file\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tr = checksum_final(a, b,\n\t\t\t(size_t)xar->toc_chksum_size, NULL, 0);\n\t\t__archive_read_consume(a, xar->toc_chksum_size);\n\t\txar->offset += xar->toc_chksum_size;\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t}\n\n\t/*\n\t * Connect hardlinked files.\n\t */\n\tfor (file = xar->hdlink_orgs; file != NULL; file = file->hdnext) {\n\t\tstruct hdlink **hdlink;\n\n\t\tfor (hdlink = &(xar->hdlink_list); *hdlink != NULL;\n\t\t    hdlink = &((*hdlink)->next)) {\n\t\t\tif ((*hdlink)->id == file->id) {\n\t\t\t\tstruct hdlink *hltmp;\n\t\t\t\tstruct xar_file *f2;\n\t\t\t\tint nlink = (*hdlink)->cnt + 1;\n\n\t\t\t\tfile->nlink = nlink;\n\t\t\t\tfor (f2 = (*hdlink)->files; f2 != NULL;\n\t\t\t\t    f2 = f2->hdnext) {\n\t\t\t\t\tf2->nlink = nlink;\n\t\t\t\t\tarchive_string_copy(\n\t\t\t\t\t    &(f2->hardlink), &(file->pathname));\n\t\t\t\t}\n\t\t\t\t/* Remove resolved files from hdlist_list. */\n\t\t\t\thltmp = *hdlink;\n\t\t\t\t*hdlink = hltmp->next;\n\t\t\t\tfree(hltmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ta->archive.archive_format = ARCHIVE_FORMAT_XAR;\n\ta->archive.archive_format_name = \"xar\";\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nxar_read_header(struct archive_read *a, struct archive_entry *entry)\n{\n\tstruct xar *xar;\n\tstruct xar_file *file;\n\tstruct xattr *xattr;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tr = ARCHIVE_OK;\n\n\tif (xar->offset == 0) {\n\t\t/* Create a character conversion object. */\n\t\tif (xar->sconv == NULL) {\n\t\t\txar->sconv = archive_string_conversion_from_charset(\n\t\t\t    &(a->archive), \"UTF-8\", 1);\n\t\t\tif (xar->sconv == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\n\t\t/* Read TOC. */\n\t\tr = read_toc(a);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\tfor (;;) {\n\t\tfile = xar->file = heap_get_entry(&(xar->file_queue));\n\t\tif (file == NULL) {\n\t\t\txar->end_of_file = 1;\n\t\t\treturn (ARCHIVE_EOF);\n\t\t}\n\t\tif ((file->mode & AE_IFMT) != AE_IFDIR)\n\t\t\tbreak;\n\t\tif (file->has != (HAS_PATHNAME | HAS_TYPE))\n\t\t\tbreak;\n\t\t/*\n\t\t * If a file type is a directory and it does not have\n\t\t * any metadata, do not export.\n\t\t */\n\t\tfile_free(file);\n\t}\n\tarchive_entry_set_atime(entry, file->atime, 0);\n\tarchive_entry_set_ctime(entry, file->ctime, 0);\n\tarchive_entry_set_mtime(entry, file->mtime, 0);\n\tarchive_entry_set_gid(entry, file->gid);\n\tif (file->gname.length > 0 &&\n\t    archive_entry_copy_gname_l(entry, file->gname.s,\n\t\tarchive_strlen(&(file->gname)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Gname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Gname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tarchive_entry_set_uid(entry, file->uid);\n\tif (file->uname.length > 0 &&\n\t    archive_entry_copy_uname_l(entry, file->uname.s,\n\t\tarchive_strlen(&(file->uname)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Uname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Uname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\tarchive_entry_set_mode(entry, file->mode);\n\tif (archive_entry_copy_pathname_l(entry, file->pathname.s,\n\t    archive_strlen(&(file->pathname)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Pathname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Pathname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\n\n\tif (file->symlink.length > 0 &&\n\t    archive_entry_copy_symlink_l(entry, file->symlink.s,\n\t\tarchive_strlen(&(file->symlink)), xar->sconv) != 0) {\n\t\tif (errno == ENOMEM) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Linkname\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tarchive_set_error(&a->archive,\n\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Linkname cannot be converted from %s to current locale.\",\n\t\t    archive_string_conversion_charset_name(xar->sconv));\n\t\tr = ARCHIVE_WARN;\n\t}\n\t/* Set proper nlink. */\n\tif ((file->mode & AE_IFMT) == AE_IFDIR)\n\t\tarchive_entry_set_nlink(entry, file->subdirs + 2);\n\telse\n\t\tarchive_entry_set_nlink(entry, file->nlink);\n\tarchive_entry_set_size(entry, file->size);\n\tif (archive_strlen(&(file->hardlink)) > 0)\n\t\tarchive_entry_set_hardlink(entry, file->hardlink.s);\n\tarchive_entry_set_ino64(entry, file->ino64);\n\tif (file->has & HAS_DEV)\n\t\tarchive_entry_set_dev(entry, file->dev);\n\tif (file->has & HAS_DEVMAJOR)\n\t\tarchive_entry_set_devmajor(entry, file->devmajor);\n\tif (file->has & HAS_DEVMINOR)\n\t\tarchive_entry_set_devminor(entry, file->devminor);\n\tif (archive_strlen(&(file->fflags_text)) > 0)\n\t\tarchive_entry_copy_fflags_text(entry, file->fflags_text.s);\n\n\txar->entry_init = 1;\n\txar->entry_total = 0;\n\txar->entry_remaining = file->length;\n\txar->entry_size = file->size;\n\txar->entry_encoding = file->encoding;\n\txar->entry_a_sum = file->a_sum;\n\txar->entry_e_sum = file->e_sum;\n\t/*\n\t * Read extended attributes.\n\t */\n\txattr = file->xattr_list;\n\twhile (xattr != NULL) {\n\t\tconst void *d;\n\t\tsize_t outbytes, used;\n\n\t\tr = move_reading_point(a, xattr->offset);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\tr = rd_contents_init(a, xattr->encoding,\n\t\t    xattr->a_sum.alg, xattr->e_sum.alg);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\td = NULL;\n\t\tr = rd_contents(a, &d, &outbytes, &used, xattr->length);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\tif (outbytes != xattr->size) {\n\t\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decompressed size error\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t\tbreak;\n\t\t}\n\t\tr = checksum_final(a,\n\t\t    xattr->a_sum.val, xattr->a_sum.len,\n\t\t    xattr->e_sum.val, xattr->e_sum.len);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tbreak;\n\t\tarchive_entry_xattr_add_entry(entry,\n\t\t    xattr->name.s, d, outbytes);\n\t\txattr = xattr->next;\n\t}\n\tif (r != ARCHIVE_OK) {\n\t\tfile_free(file);\n\t\treturn (r);\n\t}\n\n\tif (xar->entry_remaining > 0)\n\t\t/* Move reading point to the beginning of current\n\t\t * file contents. */\n\t\tr = move_reading_point(a, file->offset);\n\telse\n\t\tr = ARCHIVE_OK;\n\n\tfile_free(file);\n\treturn (r);\n}\n\nstatic int\nxar_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tstruct xar *xar;\n\tsize_t used;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\n\tif (xar->entry_unconsumed) {\n\t\t__archive_read_consume(a, xar->entry_unconsumed);\n\t\txar->entry_unconsumed = 0;\n\t}\n\n\tif (xar->end_of_file || xar->entry_remaining <= 0) {\n\t\tr = ARCHIVE_EOF;\n\t\tgoto abort_read_data;\n\t}\n\n\tif (xar->entry_init) {\n\t\tr = rd_contents_init(a, xar->entry_encoding,\n\t\t    xar->entry_a_sum.alg, xar->entry_e_sum.alg);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\txar->entry_remaining = 0;\n\t\t\treturn (r);\n\t\t}\n\t\txar->entry_init = 0;\n\t}\n\n\t*buff = NULL;\n\tr = rd_contents(a, buff, size, &used, xar->entry_remaining);\n\tif (r != ARCHIVE_OK)\n\t\tgoto abort_read_data;\n\n\t*offset = xar->entry_total;\n\txar->entry_total += *size;\n\txar->total += *size;\n\txar->offset += used;\n\txar->entry_remaining -= used;\n\txar->entry_unconsumed = used;\n\n\tif (xar->entry_remaining == 0) {\n\t\tif (xar->entry_total != xar->entry_size) {\n\t\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Decompressed size error\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t\tgoto abort_read_data;\n\t\t}\n\t\tr = checksum_final(a,\n\t\t    xar->entry_a_sum.val, xar->entry_a_sum.len,\n\t\t    xar->entry_e_sum.val, xar->entry_e_sum.len);\n\t\tif (r != ARCHIVE_OK)\n\t\t\tgoto abort_read_data;\n\t}\n\n\treturn (ARCHIVE_OK);\nabort_read_data:\n\t*buff = NULL;\n\t*size = 0;\n\t*offset = xar->total;\n\treturn (r);\n}\n\nstatic int\nxar_read_data_skip(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tint64_t bytes_skipped;\n\n\txar = (struct xar *)(a->format->data);\n\tif (xar->end_of_file)\n\t\treturn (ARCHIVE_EOF);\n\tbytes_skipped = __archive_read_consume(a, xar->entry_remaining +\n\t\txar->entry_unconsumed);\n\tif (bytes_skipped < 0)\n\t\treturn (ARCHIVE_FATAL);\n\txar->offset += bytes_skipped;\n\txar->entry_unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nxar_cleanup(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tstruct hdlink *hdlink;\n\tint i;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tchecksum_cleanup(a);\n\tr = decompression_cleanup(a);\n\thdlink = xar->hdlink_list;\n\twhile (hdlink != NULL) {\n\t\tstruct hdlink *next = hdlink->next;\n\n\t\tfree(hdlink);\n\t\thdlink = next;\n\t}\n\tfor (i = 0; i < xar->file_queue.used; i++)\n\t\tfile_free(xar->file_queue.files[i]);\n\tfree(xar->file_queue.files);\n\twhile (xar->unknowntags != NULL) {\n\t\tstruct unknown_tag *tag;\n\n\t\ttag = xar->unknowntags;\n\t\txar->unknowntags = tag->next;\n\t\tarchive_string_free(&(tag->name));\n\t\tfree(tag);\n\t}\n\tfree(xar->outbuff);\n\tfree(xar);\n\ta->format->data = NULL;\n\treturn (r);\n}\n\nstatic int\nmove_reading_point(struct archive_read *a, uint64_t offset)\n{\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\tif (xar->offset - xar->h_base != offset) {\n\t\t/* Seek forward to the start of file contents. */\n\t\tint64_t step;\n\n\t\tstep = offset - (xar->offset - xar->h_base);\n\t\tif (step > 0) {\n\t\t\tstep = __archive_read_consume(a, step);\n\t\t\tif (step < 0)\n\t\t\t\treturn ((int)step);\n\t\t\txar->offset += step;\n\t\t} else {\n\t\t\tint64_t pos = __archive_read_seek(a, offset, SEEK_SET);\n\t\t\tif (pos == ARCHIVE_FAILED) {\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Cannot seek.\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\txar->offset = pos;\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nrd_contents_init(struct archive_read *a, enum enctype encoding,\n    int a_sum_alg, int e_sum_alg)\n{\n\tint r;\n\n\t/* Init decompress library. */\n\tif ((r = decompression_init(a, encoding)) != ARCHIVE_OK)\n\t\treturn (r);\n\t/* Init checksum library. */\n\tchecksum_init(a, a_sum_alg, e_sum_alg);\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nrd_contents(struct archive_read *a, const void **buff, size_t *size,\n    size_t *used, uint64_t remaining)\n{\n\tconst unsigned char *b;\n\tssize_t bytes;\n\n\t/* Get whatever bytes are immediately available. */\n\tb = __archive_read_ahead(a, 1, &bytes);\n\tif (bytes < 0)\n\t\treturn ((int)bytes);\n\tif (bytes == 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Truncated archive file\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tif ((uint64_t)bytes > remaining)\n\t\tbytes = (ssize_t)remaining;\n\n\t/*\n\t * Decompress contents of file.\n\t */\n\t*used = bytes;\n\tif (decompress(a, buff, size, b, used) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\n\t/*\n\t * Update checksum of a compressed data and a extracted data.\n\t */\n\tchecksum_update(a, b, *used, *buff, *size);\n\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Note that this implementation does not (and should not!) obey\n * locale settings; you cannot simply substitute strtol here, since\n * it does obey locale.\n */\n\nstatic uint64_t\natol10(const char *p, size_t char_cnt)\n{\n\tuint64_t l;\n\tint digit;\n\n\tif (char_cnt == 0)\n\t\treturn (0);\n\n\tl = 0;\n\tdigit = *p - '0';\n\twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}\n\nstatic int64_t\natol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\n\tif (char_cnt == 0)\n\t\treturn (0);\n\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}\n\nstatic size_t\natohex(unsigned char *b, size_t bsize, const char *p, size_t psize)\n{\n\tsize_t fbsize = bsize;\n\n\twhile (bsize && psize > 1) {\n\t\tunsigned char x;\n\n\t\tif (p[0] >= 'a' && p[0] <= 'z')\n\t\t\tx = (p[0] - 'a' + 0x0a) << 4;\n\t\telse if (p[0] >= 'A' && p[0] <= 'Z')\n\t\t\tx = (p[0] - 'A' + 0x0a) << 4;\n\t\telse if (p[0] >= '0' && p[0] <= '9')\n\t\t\tx = (p[0] - '0') << 4;\n\t\telse\n\t\t\treturn (-1);\n\t\tif (p[1] >= 'a' && p[1] <= 'z')\n\t\t\tx |= p[1] - 'a' + 0x0a;\n\t\telse if (p[1] >= 'A' && p[1] <= 'Z')\n\t\t\tx |= p[1] - 'A' + 0x0a;\n\t\telse if (p[1] >= '0' && p[1] <= '9')\n\t\t\tx |= p[1] - '0';\n\t\telse\n\t\t\treturn (-1);\n\t\t\n\t\t*b++ = x;\n\t\tbsize--;\n\t\tp += 2;\n\t\tpsize -= 2;\n\t}\n\treturn (fbsize - bsize);\n}\n\nstatic time_t\ntime_from_tm(struct tm *t)\n{\n#if HAVE_TIMEGM\n        /* Use platform timegm() if available. */\n        return (timegm(t));\n#elif HAVE__MKGMTIME64\n        return (_mkgmtime64(t));\n#else\n        /* Else use direct calculation using POSIX assumptions. */\n        /* First, fix up tm_yday based on the year/month/day. */\n        mktime(t);\n        /* Then we can compute timegm() from first principles. */\n        return (t->tm_sec\n            + t->tm_min * 60\n            + t->tm_hour * 3600\n            + t->tm_yday * 86400\n            + (t->tm_year - 70) * 31536000\n            + ((t->tm_year - 69) / 4) * 86400\n            - ((t->tm_year - 1) / 100) * 86400\n            + ((t->tm_year + 299) / 400) * 86400);\n#endif\n}\n\nstatic time_t\nparse_time(const char *p, size_t n)\n{\n\tstruct tm tm;\n\ttime_t t = 0;\n\tint64_t data;\n\n\tmemset(&tm, 0, sizeof(tm));\n\tif (n != 20)\n\t\treturn (t);\n\tdata = atol10(p, 4);\n\tif (data < 1900)\n\t\treturn (t);\n\ttm.tm_year = (int)data - 1900;\n\tp += 4;\n\tif (*p++ != '-')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 1 || data > 12)\n\t\treturn (t);\n\ttm.tm_mon = (int)data -1;\n\tp += 2;\n\tif (*p++ != '-')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 1 || data > 31)\n\t\treturn (t);\n\ttm.tm_mday = (int)data;\n\tp += 2;\n\tif (*p++ != 'T')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 0 || data > 23)\n\t\treturn (t);\n\ttm.tm_hour = (int)data;\n\tp += 2;\n\tif (*p++ != ':')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 0 || data > 59)\n\t\treturn (t);\n\ttm.tm_min = (int)data;\n\tp += 2;\n\tif (*p++ != ':')\n\t\treturn (t);\n\tdata = atol10(p, 2);\n\tif (data < 0 || data > 60)\n\t\treturn (t);\n\ttm.tm_sec = (int)data;\n#if 0\n\tp += 2;\n\tif (*p != 'Z')\n\t\treturn (t);\n#endif\n\n\tt = time_from_tm(&tm);\n\n\treturn (t);\n}\n\nstatic int\nheap_add_entry(struct archive_read *a,\n    struct heap_queue *heap, struct xar_file *file)\n{\n\tuint64_t file_id, parent_id;\n\tint hole, parent;\n\n\t/* Expand our pending files list as necessary. */\n\tif (heap->used >= heap->allocated) {\n\t\tstruct xar_file **new_pending_files;\n\t\tint new_size = heap->allocated * 2;\n\n\t\tif (heap->allocated < 1024)\n\t\t\tnew_size = 1024;\n\t\t/* Overflow might keep us from growing the list. */\n\t\tif (new_size <= heap->allocated) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tnew_pending_files = (struct xar_file **)\n\t\t    malloc(new_size * sizeof(new_pending_files[0]));\n\t\tif (new_pending_files == NULL) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tmemcpy(new_pending_files, heap->files,\n\t\t    heap->allocated * sizeof(new_pending_files[0]));\n\t\tif (heap->files != NULL)\n\t\t\tfree(heap->files);\n\t\theap->files = new_pending_files;\n\t\theap->allocated = new_size;\n\t}\n\n\tfile_id = file->id;\n\n\t/*\n\t * Start with hole at end, walk it up tree to find insertion point.\n\t */\n\thole = heap->used++;\n\twhile (hole > 0) {\n\t\tparent = (hole - 1)/2;\n\t\tparent_id = heap->files[parent]->id;\n\t\tif (file_id >= parent_id) {\n\t\t\theap->files[hole] = file;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\t/* Move parent into hole <==> move hole up tree. */\n\t\theap->files[hole] = heap->files[parent];\n\t\thole = parent;\n\t}\n\theap->files[0] = file;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic struct xar_file *\nheap_get_entry(struct heap_queue *heap)\n{\n\tuint64_t a_id, b_id, c_id;\n\tint a, b, c;\n\tstruct xar_file *r, *tmp;\n\n\tif (heap->used < 1)\n\t\treturn (NULL);\n\n\t/*\n\t * The first file in the list is the earliest; we'll return this.\n\t */\n\tr = heap->files[0];\n\n\t/*\n\t * Move the last item in the heap to the root of the tree\n\t */\n\theap->files[0] = heap->files[--(heap->used)];\n\n\t/*\n\t * Rebalance the heap.\n\t */\n\ta = 0; /* Starting element and its heap key */\n\ta_id = heap->files[a]->id;\n\tfor (;;) {\n\t\tb = a + a + 1; /* First child */\n\t\tif (b >= heap->used)\n\t\t\treturn (r);\n\t\tb_id = heap->files[b]->id;\n\t\tc = b + 1; /* Use second child if it is smaller. */\n\t\tif (c < heap->used) {\n\t\t\tc_id = heap->files[c]->id;\n\t\t\tif (c_id < b_id) {\n\t\t\t\tb = c;\n\t\t\t\tb_id = c_id;\n\t\t\t}\n\t\t}\n\t\tif (a_id <= b_id)\n\t\t\treturn (r);\n\t\ttmp = heap->files[a];\n\t\theap->files[a] = heap->files[b];\n\t\theap->files[b] = tmp;\n\t\ta = b;\n\t}\n}\n\nstatic int\nadd_link(struct archive_read *a, struct xar *xar, struct xar_file *file)\n{\n\tstruct hdlink *hdlink;\n\n\tfor (hdlink = xar->hdlink_list; hdlink != NULL; hdlink = hdlink->next) {\n\t\tif (hdlink->id == file->link) {\n\t\t\tfile->hdnext = hdlink->files;\n\t\t\thdlink->cnt++;\n\t\t\thdlink->files = file;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t}\n\thdlink = malloc(sizeof(*hdlink));\n\tif (hdlink == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tfile->hdnext = NULL;\n\thdlink->id = file->link;\n\thdlink->cnt = 1;\n\thdlink->files = file;\n\thdlink->next = xar->hdlink_list;\n\txar->hdlink_list = hdlink;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\n_checksum_init(struct chksumwork *sumwrk, int sum_alg)\n{\n\tsumwrk->alg = sum_alg;\n\tswitch (sum_alg) {\n\tcase CKSUM_NONE:\n\t\tbreak;\n\tcase CKSUM_SHA1:\n\t\tarchive_sha1_init(&(sumwrk->sha1ctx));\n\t\tbreak;\n\tcase CKSUM_MD5:\n\t\tarchive_md5_init(&(sumwrk->md5ctx));\n\t\tbreak;\n\t}\n}\n\nstatic void\n_checksum_update(struct chksumwork *sumwrk, const void *buff, size_t size)\n{\n\n\tswitch (sumwrk->alg) {\n\tcase CKSUM_NONE:\n\t\tbreak;\n\tcase CKSUM_SHA1:\n\t\tarchive_sha1_update(&(sumwrk->sha1ctx), buff, size);\n\t\tbreak;\n\tcase CKSUM_MD5:\n\t\tarchive_md5_update(&(sumwrk->md5ctx), buff, size);\n\t\tbreak;\n\t}\n}\n\nstatic int\n_checksum_final(struct chksumwork *sumwrk, const void *val, size_t len)\n{\n\tunsigned char sum[MAX_SUM_SIZE];\n\tint r = ARCHIVE_OK;\n\n\tswitch (sumwrk->alg) {\n\tcase CKSUM_NONE:\n\t\tbreak;\n\tcase CKSUM_SHA1:\n\t\tarchive_sha1_final(&(sumwrk->sha1ctx), sum);\n\t\tif (len != SHA1_SIZE ||\n\t\t    memcmp(val, sum, SHA1_SIZE) != 0)\n\t\t\tr = ARCHIVE_FAILED;\n\t\tbreak;\n\tcase CKSUM_MD5:\n\t\tarchive_md5_final(&(sumwrk->md5ctx), sum);\n\t\tif (len != MD5_SIZE ||\n\t\t    memcmp(val, sum, MD5_SIZE) != 0)\n\t\t\tr = ARCHIVE_FAILED;\n\t\tbreak;\n\t}\n\treturn (r);\n}\n\nstatic void\nchecksum_init(struct archive_read *a, int a_sum_alg, int e_sum_alg)\n{\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\t_checksum_init(&(xar->a_sumwrk), a_sum_alg);\n\t_checksum_init(&(xar->e_sumwrk), e_sum_alg);\n}\n\nstatic void\nchecksum_update(struct archive_read *a, const void *abuff, size_t asize,\n    const void *ebuff, size_t esize)\n{\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\t_checksum_update(&(xar->a_sumwrk), abuff, asize);\n\t_checksum_update(&(xar->e_sumwrk), ebuff, esize);\n}\n\nstatic int\nchecksum_final(struct archive_read *a, const void *a_sum_val,\n    size_t a_sum_len, const void *e_sum_val, size_t e_sum_len)\n{\n\tstruct xar *xar;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tr = _checksum_final(&(xar->a_sumwrk), a_sum_val, a_sum_len);\n\tif (r == ARCHIVE_OK)\n\t\tr = _checksum_final(&(xar->e_sumwrk), e_sum_val, e_sum_len);\n\tif (r != ARCHIVE_OK)\n\t\tarchive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,\n\t\t    \"Sumcheck error\");\n\treturn (r);\n}\n\nstatic int\ndecompression_init(struct archive_read *a, enum enctype encoding)\n{\n\tstruct xar *xar;\n\tconst char *detail;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\txar->rd_encoding = encoding;\n\tswitch (encoding) {\n\tcase NONE:\n\t\tbreak;\n\tcase GZIP:\n\t\tif (xar->stream_valid)\n\t\t\tr = inflateReset(&(xar->stream));\n\t\telse\n\t\t\tr = inflateInit(&(xar->stream));\n\t\tif (r != Z_OK) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Couldn't initialize zlib stream.\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\txar->stream_valid = 1;\n\t\txar->stream.total_in = 0;\n\t\txar->stream.total_out = 0;\n\t\tbreak;\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n\t\tif (xar->bzstream_valid) {\n\t\t\tBZ2_bzDecompressEnd(&(xar->bzstream));\n\t\t\txar->bzstream_valid = 0;\n\t\t}\n\t\tr = BZ2_bzDecompressInit(&(xar->bzstream), 0, 0);\n\t\tif (r == BZ_MEM_ERROR)\n\t\t\tr = BZ2_bzDecompressInit(&(xar->bzstream), 0, 1);\n\t\tif (r != BZ_OK) {\n\t\t\tint err = ARCHIVE_ERRNO_MISC;\n\t\t\tdetail = NULL;\n\t\t\tswitch (r) {\n\t\t\tcase BZ_PARAM_ERROR:\n\t\t\t\tdetail = \"invalid setup parameter\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_MEM_ERROR:\n\t\t\t\terr = ENOMEM;\n\t\t\t\tdetail = \"out of memory\";\n\t\t\t\tbreak;\n\t\t\tcase BZ_CONFIG_ERROR:\n\t\t\t\tdetail = \"mis-compiled library\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarchive_set_error(&a->archive, err,\n\t\t\t    \"Internal error initializing decompressor: %s\",\n\t\t\t    detail == NULL ? \"??\" : detail);\n\t\t\txar->bzstream_valid = 0;\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\txar->bzstream_valid = 1;\n\t\txar->bzstream.total_in_lo32 = 0;\n\t\txar->bzstream.total_in_hi32 = 0;\n\t\txar->bzstream.total_out_lo32 = 0;\n\t\txar->bzstream.total_out_hi32 = 0;\n\t\tbreak;\n#endif\n#if defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n#if LZMA_VERSION_MAJOR >= 5\n/* Effectively disable the limiter. */\n#define LZMA_MEMLIMIT   UINT64_MAX\n#else\n/* NOTE: This needs to check memory size which running system has. */\n#define LZMA_MEMLIMIT   (1U << 30)\n#endif\n\tcase XZ:\n\tcase LZMA:\n\t\tif (xar->lzstream_valid) {\n\t\t\tlzma_end(&(xar->lzstream));\n\t\t\txar->lzstream_valid = 0;\n\t\t}\n\t\tif (xar->entry_encoding == XZ)\n\t\t\tr = lzma_stream_decoder(&(xar->lzstream),\n\t\t\t    LZMA_MEMLIMIT,/* memlimit */\n\t\t\t    LZMA_CONCATENATED);\n\t\telse\n\t\t\tr = lzma_alone_decoder(&(xar->lzstream),\n\t\t\t    LZMA_MEMLIMIT);/* memlimit */\n\t\tif (r != LZMA_OK) {\n\t\t\tswitch (r) {\n\t\t\tcase LZMA_MEM_ERROR:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ENOMEM,\n\t\t\t\t    \"Internal error initializing \"\n\t\t\t\t    \"compression library: \"\n\t\t\t\t    \"Cannot allocate memory\");\n\t\t\t\tbreak;\n\t\t\tcase LZMA_OPTIONS_ERROR:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Internal error initializing \"\n\t\t\t\t    \"compression library: \"\n\t\t\t\t    \"Invalid or unsupported options\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Internal error initializing \"\n\t\t\t\t    \"lzma library\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\txar->lzstream_valid = 1;\n\t\txar->lzstream.total_in = 0;\n\t\txar->lzstream.total_out = 0;\n\t\tbreak;\n#endif\n\t/*\n\t * Unsupported compression.\n\t */\n\tdefault:\n#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n#endif\n#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)\n\tcase LZMA:\n\tcase XZ:\n#endif\n\t\tswitch (xar->entry_encoding) {\n\t\tcase BZIP2: detail = \"bzip2\"; break;\n\t\tcase LZMA: detail = \"lzma\"; break;\n\t\tcase XZ: detail = \"xz\"; break;\n\t\tdefault: detail = \"??\"; break;\n\t\t}\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"%s compression not supported on this platform\",\n\t\t    detail);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ndecompress(struct archive_read *a, const void **buff, size_t *outbytes,\n    const void *b, size_t *used)\n{\n\tstruct xar *xar;\n\tvoid *outbuff;\n\tsize_t avail_in, avail_out;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tavail_in = *used;\n\toutbuff = (void *)(uintptr_t)*buff;\n\tif (outbuff == NULL) {\n\t\tif (xar->outbuff == NULL) {\n\t\t\txar->outbuff = malloc(OUTBUFF_SIZE);\n\t\t\tif (xar->outbuff == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Couldn't allocate memory for out buffer\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t}\n\t\toutbuff = xar->outbuff;\n\t\t*buff = outbuff;\n\t\tavail_out = OUTBUFF_SIZE;\n\t} else\n\t\tavail_out = *outbytes;\n\tswitch (xar->rd_encoding) {\n\tcase GZIP:\n\t\txar->stream.next_in = (Bytef *)(uintptr_t)b;\n\t\txar->stream.avail_in = avail_in;\n\t\txar->stream.next_out = (unsigned char *)outbuff;\n\t\txar->stream.avail_out = avail_out;\n\t\tr = inflate(&(xar->stream), 0);\n\t\tswitch (r) {\n\t\tcase Z_OK: /* Decompressor made some progress.*/\n\t\tcase Z_STREAM_END: /* Found end of stream. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"File decompression failed (%d)\", r);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t*used = avail_in - xar->stream.avail_in;\n\t\t*outbytes = avail_out - xar->stream.avail_out;\n\t\tbreak;\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n\t\txar->bzstream.next_in = (char *)(uintptr_t)b;\n\t\txar->bzstream.avail_in = avail_in;\n\t\txar->bzstream.next_out = (char *)outbuff;\n\t\txar->bzstream.avail_out = avail_out;\n\t\tr = BZ2_bzDecompress(&(xar->bzstream));\n\t\tswitch (r) {\n\t\tcase BZ_STREAM_END: /* Found end of stream. */\n\t\t\tswitch (BZ2_bzDecompressEnd(&(xar->bzstream))) {\n\t\t\tcase BZ_OK:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&(a->archive),\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to clean up decompressor\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\txar->bzstream_valid = 0;\n\t\t\t/* FALLTHROUGH */\n\t\tcase BZ_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"bzip decompression failed\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t*used = avail_in - xar->bzstream.avail_in;\n\t\t*outbytes = avail_out - xar->bzstream.avail_out;\n\t\tbreak;\n#endif\n#if defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n\tcase LZMA:\n\tcase XZ:\n\t\txar->lzstream.next_in = b;\n\t\txar->lzstream.avail_in = avail_in;\n\t\txar->lzstream.next_out = (unsigned char *)outbuff;\n\t\txar->lzstream.avail_out = avail_out;\n\t\tr = lzma_code(&(xar->lzstream), LZMA_RUN);\n\t\tswitch (r) {\n\t\tcase LZMA_STREAM_END: /* Found end of stream. */\n\t\t\tlzma_end(&(xar->lzstream));\n\t\t\txar->lzstream_valid = 0;\n\t\t\t/* FALLTHROUGH */\n\t\tcase LZMA_OK: /* Decompressor made some progress. */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&(a->archive),\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"%s decompression failed(%d)\",\n\t\t\t    (xar->entry_encoding == XZ)?\"xz\":\"lzma\",\n\t\t\t    r);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\t*used = avail_in - xar->lzstream.avail_in;\n\t\t*outbytes = avail_out - xar->lzstream.avail_out;\n\t\tbreak;\n#endif\n#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)\n\tcase BZIP2:\n#endif\n#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)\n\tcase LZMA:\n\tcase XZ:\n#endif\n\tcase NONE:\n\tdefault:\n\t\tif (outbuff == xar->outbuff) {\n\t\t\t*buff = b;\n\t\t\t*used = avail_in;\n\t\t\t*outbytes = avail_in;\n\t\t} else {\n\t\t\tif (avail_out > avail_in)\n\t\t\t\tavail_out = avail_in;\n\t\t\tmemcpy(outbuff, b, avail_out);\n\t\t\t*used = avail_out;\n\t\t\t*outbytes = avail_out;\n\t\t}\n\t\tbreak;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ndecompression_cleanup(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tint r;\n\n\txar = (struct xar *)(a->format->data);\n\tr = ARCHIVE_OK;\n\tif (xar->stream_valid) {\n\t\tif (inflateEnd(&(xar->stream)) != Z_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up zlib decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t}\n#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)\n\tif (xar->bzstream_valid) {\n\t\tif (BZ2_bzDecompressEnd(&(xar->bzstream)) != BZ_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up bzip2 decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t}\n#endif\n#if defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n\tif (xar->lzstream_valid)\n\t\tlzma_end(&(xar->lzstream));\n#elif defined(HAVE_LZMA_H) && defined(HAVE_LIBLZMA)\n\tif (xar->lzstream_valid) {\n\t\tif (lzmadec_end(&(xar->lzstream)) != LZMADEC_OK) {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up lzmadec decompressor\");\n\t\t\tr = ARCHIVE_FATAL;\n\t\t}\n\t}\n#endif\n\treturn (r);\n}\n\nstatic void\nchecksum_cleanup(struct archive_read *a) {\n\tstruct xar *xar;\n\n\txar = (struct xar *)(a->format->data);\n\n\t_checksum_final(&(xar->a_sumwrk), NULL, 0);\n\t_checksum_final(&(xar->e_sumwrk), NULL, 0);\n}\n\nstatic void\nxmlattr_cleanup(struct xmlattr_list *list)\n{\n\tstruct xmlattr *attr, *next;\n\n\tattr = list->first;\n\twhile (attr != NULL) {\n\t\tnext = attr->next;\n\t\tfree(attr->name);\n\t\tfree(attr->value);\n\t\tfree(attr);\n\t\tattr = next;\n\t}\n\tlist->first = NULL;\n\tlist->last = &(list->first);\n}\n\nstatic int\nfile_new(struct archive_read *a, struct xar *xar, struct xmlattr_list *list)\n{\n\tstruct xar_file *file;\n\tstruct xmlattr *attr;\n\n\tfile = calloc(1, sizeof(*file));\n\tif (file == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tfile->parent = xar->file;\n\tfile->mode = 0777 | AE_IFREG;\n\tfile->atime = time(NULL);\n\tfile->mtime = time(NULL);\n\txar->file = file;\n\txar->xattr = NULL;\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"id\") == 0)\n\t\t\tfile->id = atol10(attr->value, strlen(attr->value));\n\t}\n\tfile->nlink = 1;\n\tif (heap_add_entry(a, &(xar->file_queue), file) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nfile_free(struct xar_file *file)\n{\n\tstruct xattr *xattr;\n\n\tarchive_string_free(&(file->pathname));\n\tarchive_string_free(&(file->symlink));\n\tarchive_string_free(&(file->uname));\n\tarchive_string_free(&(file->gname));\n\tarchive_string_free(&(file->hardlink));\n\txattr = file->xattr_list;\n\twhile (xattr != NULL) {\n\t\tstruct xattr *next;\n\n\t\tnext = xattr->next;\n\t\txattr_free(xattr);\n\t\txattr = next;\n\t}\n\n\tfree(file);\n}\n\nstatic int\nxattr_new(struct archive_read *a, struct xar *xar, struct xmlattr_list *list)\n{\n\tstruct xattr *xattr, **nx;\n\tstruct xmlattr *attr;\n\n\txattr = calloc(1, sizeof(*xattr));\n\tif (xattr == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\txar->xattr = xattr;\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"id\") == 0)\n\t\t\txattr->id = atol10(attr->value, strlen(attr->value));\n\t}\n\t/* Chain to xattr list. */\n\tfor (nx = &(xar->file->xattr_list);\n\t    *nx != NULL; nx = &((*nx)->next)) {\n\t\tif (xattr->id < (*nx)->id)\n\t\t\tbreak;\n\t}\n\txattr->next = *nx;\n\t*nx = xattr;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nxattr_free(struct xattr *xattr)\n{\n\tarchive_string_free(&(xattr->name));\n\tfree(xattr);\n}\n\nstatic int\ngetencoding(struct xmlattr_list *list)\n{\n\tstruct xmlattr *attr;\n\tenum enctype encoding = NONE;\n\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"style\") == 0) {\n\t\t\tif (strcmp(attr->value, \"application/octet-stream\") == 0)\n\t\t\t\tencoding = NONE;\n\t\t\telse if (strcmp(attr->value, \"application/x-gzip\") == 0)\n\t\t\t\tencoding = GZIP;\n\t\t\telse if (strcmp(attr->value, \"application/x-bzip2\") == 0)\n\t\t\t\tencoding = BZIP2;\n\t\t\telse if (strcmp(attr->value, \"application/x-lzma\") == 0)\n\t\t\t\tencoding = LZMA;\n\t\t\telse if (strcmp(attr->value, \"application/x-xz\") == 0)\n\t\t\t\tencoding = XZ;\n\t\t}\n\t}\n\treturn (encoding);\n}\n\nstatic int\ngetsumalgorithm(struct xmlattr_list *list)\n{\n\tstruct xmlattr *attr;\n\tint alg = CKSUM_NONE;\n\n\tfor (attr = list->first; attr != NULL; attr = attr->next) {\n\t\tif (strcmp(attr->name, \"style\") == 0) {\n\t\t\tconst char *v = attr->value;\n\t\t\tif ((v[0] == 'S' || v[0] == 's') &&\n\t\t\t    (v[1] == 'H' || v[1] == 'h') &&\n\t\t\t    (v[2] == 'A' || v[2] == 'a') &&\n\t\t\t    v[3] == '1' && v[4] == '\\0')\n\t\t\t\talg = CKSUM_SHA1;\n\t\t\tif ((v[0] == 'M' || v[0] == 'm') &&\n\t\t\t    (v[1] == 'D' || v[1] == 'd') &&\n\t\t\t    v[2] == '5' && v[3] == '\\0')\n\t\t\t\talg = CKSUM_MD5;\n\t\t}\n\t}\n\treturn (alg);\n}\n\nstatic int\nunknowntag_start(struct archive_read *a, struct xar *xar, const char *name)\n{\n\tstruct unknown_tag *tag;\n\n\ttag = malloc(sizeof(*tag));\n\tif (tag == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\ttag->next = xar->unknowntags;\n\tarchive_string_init(&(tag->name));\n\tarchive_strcpy(&(tag->name), name);\n\tif (xar->unknowntags == NULL) {\n#if DEBUG\n\t\tfprintf(stderr, \"UNKNOWNTAG_START:%s\\n\", name);\n#endif\n\t\txar->xmlsts_unknown = xar->xmlsts;\n\t\txar->xmlsts = UNKNOWN;\n\t}\n\txar->unknowntags = tag;\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nunknowntag_end(struct xar *xar, const char *name)\n{\n\tstruct unknown_tag *tag;\n\n\ttag = xar->unknowntags;\n\tif (tag == NULL || name == NULL)\n\t\treturn;\n\tif (strcmp(tag->name.s, name) == 0) {\n\t\txar->unknowntags = tag->next;\n\t\tarchive_string_free(&(tag->name));\n\t\tfree(tag);\n\t\tif (xar->unknowntags == NULL) {\n#if DEBUG\n\t\t\tfprintf(stderr, \"UNKNOWNTAG_END:%s\\n\", name);\n#endif\n\t\t\txar->xmlsts = xar->xmlsts_unknown;\n\t\t}\n\t}\n}\n\nstatic int\nxml_start(struct archive_read *a, const char *name, struct xmlattr_list *list)\n{\n\tstruct xar *xar;\n\tstruct xmlattr *attr;\n\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\tfprintf(stderr, \"xml_sta:[%s]\\n\", name);\n\tfor (attr = list->first; attr != NULL; attr = attr->next)\n\t\tfprintf(stderr, \"    attr:\\\"%s\\\"=\\\"%s\\\"\\n\",\n\t\t    attr->name, attr->value);\n#endif\n\txar->base64text = 0;\n\tswitch (xar->xmlsts) {\n\tcase INIT:\n\t\tif (strcmp(name, \"xar\") == 0)\n\t\t\txar->xmlsts = XAR;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase XAR:\n\t\tif (strcmp(name, \"toc\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC:\n\t\tif (strcmp(name, \"creation-time\") == 0)\n\t\t\txar->xmlsts = TOC_CREATION_TIME;\n\t\telse if (strcmp(name, \"checksum\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\telse if (strcmp(name, \"file\") == 0) {\n\t\t\tif (file_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\txar->xmlsts = TOC_FILE;\n\t\t}\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_CHECKSUM:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM_SIZE;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_FILE:\n\t\tif (strcmp(name, \"file\") == 0) {\n\t\t\tif (file_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\telse if (strcmp(name, \"data\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\telse if (strcmp(name, \"ea\") == 0) {\n\t\t\tif (xattr_new(a, xar, list) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\txar->xmlsts = FILE_EA;\n\t\t}\n\t\telse if (strcmp(name, \"ctime\") == 0)\n\t\t\txar->xmlsts = FILE_CTIME;\n\t\telse if (strcmp(name, \"mtime\") == 0)\n\t\t\txar->xmlsts = FILE_MTIME;\n\t\telse if (strcmp(name, \"atime\") == 0)\n\t\t\txar->xmlsts = FILE_ATIME;\n\t\telse if (strcmp(name, \"group\") == 0)\n\t\t\txar->xmlsts = FILE_GROUP;\n\t\telse if (strcmp(name, \"gid\") == 0)\n\t\t\txar->xmlsts = FILE_GID;\n\t\telse if (strcmp(name, \"user\") == 0)\n\t\t\txar->xmlsts = FILE_USER;\n\t\telse if (strcmp(name, \"uid\") == 0)\n\t\t\txar->xmlsts = FILE_UID;\n\t\telse if (strcmp(name, \"mode\") == 0)\n\t\t\txar->xmlsts = FILE_MODE;\n\t\telse if (strcmp(name, \"device\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\telse if (strcmp(name, \"deviceno\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICENO;\n\t\telse if (strcmp(name, \"inode\") == 0)\n\t\t\txar->xmlsts = FILE_INODE;\n\t\telse if (strcmp(name, \"link\") == 0)\n\t\t\txar->xmlsts = FILE_LINK;\n\t\telse if (strcmp(name, \"type\") == 0) {\n\t\t\txar->xmlsts = FILE_TYPE;\n\t\t\tfor (attr = list->first; attr != NULL;\n\t\t\t    attr = attr->next) {\n\t\t\t\tif (strcmp(attr->name, \"link\") != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (strcmp(attr->value, \"original\") == 0) {\n\t\t\t\t\txar->file->hdnext = xar->hdlink_orgs;\n\t\t\t\t\txar->hdlink_orgs = xar->file;\n\t\t\t\t} else {\n\t\t\t\t\txar->file->link = (unsigned)atol10(attr->value,\n\t\t\t\t\t    strlen(attr->value));\n\t\t\t\t\tif (xar->file->link > 0)\n\t\t\t\t\t\tif (add_link(a, xar, xar->file) != ARCHIVE_OK) {\n\t\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"name\") == 0) {\n\t\t\txar->xmlsts = FILE_NAME;\n\t\t\tfor (attr = list->first; attr != NULL;\n\t\t\t    attr = attr->next) {\n\t\t\t\tif (strcmp(attr->name, \"enctype\") == 0 &&\n\t\t\t\t    strcmp(attr->value, \"base64\") == 0)\n\t\t\t\t\txar->base64text = 1;\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(name, \"acl\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\telse if (strcmp(name, \"flags\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\telse if (strcmp(name, \"ext2\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DATA:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_LENGTH;\n\t\telse if (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_SIZE;\n\t\telse if (strcmp(name, \"encoding\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_ENCODING;\n\t\t\txar->file->encoding = getencoding(list);\n\t\t}\n\t\telse if (strcmp(name, \"archived-checksum\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_A_CHECKSUM;\n\t\t\txar->file->a_sum.alg = getsumalgorithm(list);\n\t\t}\n\t\telse if (strcmp(name, \"extracted-checksum\") == 0) {\n\t\t\txar->xmlsts = FILE_DATA_E_CHECKSUM;\n\t\t\txar->file->e_sum.alg = getsumalgorithm(list);\n\t\t}\n\t\telse if (strcmp(name, \"content\") == 0)\n\t\t\txar->xmlsts = FILE_DATA_CONTENT;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DEVICE:\n\t\tif (strcmp(name, \"major\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE_MAJOR;\n\t\telse if (strcmp(name, \"minor\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE_MINOR;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_DATA_CONTENT:\n\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_EA:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_EA_LENGTH;\n\t\telse if (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_EA_OFFSET;\n\t\telse if (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_EA_SIZE;\n\t\telse if (strcmp(name, \"encoding\") == 0) {\n\t\t\txar->xmlsts = FILE_EA_ENCODING;\n\t\t\txar->xattr->encoding = getencoding(list);\n\t\t} else if (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA_A_CHECKSUM;\n\t\telse if (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA_E_CHECKSUM;\n\t\telse if (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = FILE_EA_NAME;\n\t\telse if (strcmp(name, \"fstype\") == 0)\n\t\t\txar->xmlsts = FILE_EA_FSTYPE;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_ACL:\n\t\tif (strcmp(name, \"appleextended\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_APPLEEXTENDED;\n\t\telse if (strcmp(name, \"default\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_DEFAULT;\n\t\telse if (strcmp(name, \"access\") == 0)\n\t\t\txar->xmlsts = FILE_ACL_ACCESS;\n\t\telse\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_FLAGS:\n\t\tif (!xml_parse_file_flags(xar, name))\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase FILE_EXT2:\n\t\tif (!xml_parse_file_ext2(xar, name))\n\t\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\tcase TOC_CREATION_TIME:\n\tcase TOC_CHECKSUM_OFFSET:\n\tcase TOC_CHECKSUM_SIZE:\n\tcase FILE_DATA_LENGTH:\n\tcase FILE_DATA_OFFSET:\n\tcase FILE_DATA_SIZE:\n\tcase FILE_DATA_ENCODING:\n\tcase FILE_DATA_A_CHECKSUM:\n\tcase FILE_DATA_E_CHECKSUM:\n\tcase FILE_EA_LENGTH:\n\tcase FILE_EA_OFFSET:\n\tcase FILE_EA_SIZE:\n\tcase FILE_EA_ENCODING:\n\tcase FILE_EA_A_CHECKSUM:\n\tcase FILE_EA_E_CHECKSUM:\n\tcase FILE_EA_NAME:\n\tcase FILE_EA_FSTYPE:\n\tcase FILE_CTIME:\n\tcase FILE_MTIME:\n\tcase FILE_ATIME:\n\tcase FILE_GROUP:\n\tcase FILE_GID:\n\tcase FILE_USER:\n\tcase FILE_UID:\n\tcase FILE_INODE:\n\tcase FILE_DEVICE_MAJOR:\n\tcase FILE_DEVICE_MINOR:\n\tcase FILE_DEVICENO:\n\tcase FILE_MODE:\n\tcase FILE_TYPE:\n\tcase FILE_LINK:\n\tcase FILE_NAME:\n\tcase FILE_ACL_DEFAULT:\n\tcase FILE_ACL_ACCESS:\n\tcase FILE_ACL_APPLEEXTENDED:\n\tcase FILE_FLAGS_USER_NODUMP:\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\tcase FILE_FLAGS_USER_APPEND:\n\tcase FILE_FLAGS_USER_OPAQUE:\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\tcase FILE_FLAGS_SYS_APPEND:\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\tcase FILE_EXT2_SecureDeletion:\n\tcase FILE_EXT2_Undelete:\n\tcase FILE_EXT2_Compress:\n\tcase FILE_EXT2_Synchronous:\n\tcase FILE_EXT2_Immutable:\n\tcase FILE_EXT2_AppendOnly:\n\tcase FILE_EXT2_NoDump:\n\tcase FILE_EXT2_NoAtime:\n\tcase FILE_EXT2_CompDirty:\n\tcase FILE_EXT2_CompBlock:\n\tcase FILE_EXT2_NoCompBlock:\n\tcase FILE_EXT2_CompError:\n\tcase FILE_EXT2_BTree:\n\tcase FILE_EXT2_HashIndexed:\n\tcase FILE_EXT2_iMagic:\n\tcase FILE_EXT2_Journaled:\n\tcase FILE_EXT2_NoTail:\n\tcase FILE_EXT2_DirSync:\n\tcase FILE_EXT2_TopDir:\n\tcase FILE_EXT2_Reserved:\n\tcase UNKNOWN:\n\t\tif (unknowntag_start(a, xar, name) != ARCHIVE_OK)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tbreak;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nxml_end(void *userData, const char *name)\n{\n\tstruct archive_read *a;\n\tstruct xar *xar;\n\n\ta = (struct archive_read *)userData;\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\tfprintf(stderr, \"xml_end:[%s]\\n\", name);\n#endif\n\tswitch (xar->xmlsts) {\n\tcase INIT:\n\t\tbreak;\n\tcase XAR:\n\t\tif (strcmp(name, \"xar\") == 0)\n\t\t\txar->xmlsts = INIT;\n\t\tbreak;\n\tcase TOC:\n\t\tif (strcmp(name, \"toc\") == 0)\n\t\t\txar->xmlsts = XAR;\n\t\tbreak;\n\tcase TOC_CREATION_TIME:\n\t\tif (strcmp(name, \"creation-time\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\tbreak;\n\tcase TOC_CHECKSUM:\n\t\tif (strcmp(name, \"checksum\") == 0)\n\t\t\txar->xmlsts = TOC;\n\t\tbreak;\n\tcase TOC_CHECKSUM_OFFSET:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\tbreak;\n\tcase TOC_CHECKSUM_SIZE:\n\t\tif (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = TOC_CHECKSUM;\n\t\tbreak;\n\tcase TOC_FILE:\n\t\tif (strcmp(name, \"file\") == 0) {\n\t\t\tif (xar->file->parent != NULL &&\n\t\t\t    ((xar->file->mode & AE_IFMT) == AE_IFDIR))\n\t\t\t\txar->file->parent->subdirs++;\n\t\t\txar->file = xar->file->parent;\n\t\t\tif (xar->file == NULL)\n\t\t\t\txar->xmlsts = TOC;\n\t\t}\n\t\tbreak;\n\tcase FILE_DATA:\n\t\tif (strcmp(name, \"data\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_DATA_LENGTH:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_OFFSET:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_SIZE:\n\t\tif (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_ENCODING:\n\t\tif (strcmp(name, \"encoding\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_A_CHECKSUM:\n\t\tif (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_E_CHECKSUM:\n\t\tif (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_DATA_CONTENT:\n\t\tif (strcmp(name, \"content\") == 0)\n\t\t\txar->xmlsts = FILE_DATA;\n\t\tbreak;\n\tcase FILE_EA:\n\t\tif (strcmp(name, \"ea\") == 0) {\n\t\t\txar->xmlsts = TOC_FILE;\n\t\t\txar->xattr = NULL;\n\t\t}\n\t\tbreak;\n\tcase FILE_EA_LENGTH:\n\t\tif (strcmp(name, \"length\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_OFFSET:\n\t\tif (strcmp(name, \"offset\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_SIZE:\n\t\tif (strcmp(name, \"size\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_ENCODING:\n\t\tif (strcmp(name, \"encoding\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_A_CHECKSUM:\n\t\tif (strcmp(name, \"archived-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_E_CHECKSUM:\n\t\tif (strcmp(name, \"extracted-checksum\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_NAME:\n\t\tif (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_EA_FSTYPE:\n\t\tif (strcmp(name, \"fstype\") == 0)\n\t\t\txar->xmlsts = FILE_EA;\n\t\tbreak;\n\tcase FILE_CTIME:\n\t\tif (strcmp(name, \"ctime\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_MTIME:\n\t\tif (strcmp(name, \"mtime\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_ATIME:\n\t\tif (strcmp(name, \"atime\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_GROUP:\n\t\tif (strcmp(name, \"group\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_GID:\n\t\tif (strcmp(name, \"gid\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_USER:\n\t\tif (strcmp(name, \"user\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_UID:\n\t\tif (strcmp(name, \"uid\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_MODE:\n\t\tif (strcmp(name, \"mode\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_DEVICE:\n\t\tif (strcmp(name, \"device\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_DEVICE_MAJOR:\n\t\tif (strcmp(name, \"major\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\tbreak;\n\tcase FILE_DEVICE_MINOR:\n\t\tif (strcmp(name, \"minor\") == 0)\n\t\t\txar->xmlsts = FILE_DEVICE;\n\t\tbreak;\n\tcase FILE_DEVICENO:\n\t\tif (strcmp(name, \"deviceno\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_INODE:\n\t\tif (strcmp(name, \"inode\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_LINK:\n\t\tif (strcmp(name, \"link\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_TYPE:\n\t\tif (strcmp(name, \"type\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_NAME:\n\t\tif (strcmp(name, \"name\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_ACL:\n\t\tif (strcmp(name, \"acl\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_ACL_DEFAULT:\n\t\tif (strcmp(name, \"default\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\tbreak;\n\tcase FILE_ACL_ACCESS:\n\t\tif (strcmp(name, \"access\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\tbreak;\n\tcase FILE_ACL_APPLEEXTENDED:\n\t\tif (strcmp(name, \"appleextended\") == 0)\n\t\t\txar->xmlsts = FILE_ACL;\n\t\tbreak;\n\tcase FILE_FLAGS:\n\t\tif (strcmp(name, \"flags\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_NODUMP:\n\t\tif (strcmp(name, \"UserNoDump\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\t\tif (strcmp(name, \"UserImmutable\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_APPEND:\n\t\tif (strcmp(name, \"UserAppend\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_OPAQUE:\n\t\tif (strcmp(name, \"UserOpaque\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\t\tif (strcmp(name, \"UserNoUnlink\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\t\tif (strcmp(name, \"SystemArchived\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\t\tif (strcmp(name, \"SystemImmutable\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_APPEND:\n\t\tif (strcmp(name, \"SystemAppend\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\t\tif (strcmp(name, \"SystemNoUnlink\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\t\tif (strcmp(name, \"SystemSnapshot\") == 0)\n\t\t\txar->xmlsts = FILE_FLAGS;\n\t\tbreak;\n\tcase FILE_EXT2:\n\t\tif (strcmp(name, \"ext2\") == 0)\n\t\t\txar->xmlsts = TOC_FILE;\n\t\tbreak;\n\tcase FILE_EXT2_SecureDeletion:\n\t\tif (strcmp(name, \"SecureDeletion\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Undelete:\n\t\tif (strcmp(name, \"Undelete\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Compress:\n\t\tif (strcmp(name, \"Compress\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Synchronous:\n\t\tif (strcmp(name, \"Synchronous\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Immutable:\n\t\tif (strcmp(name, \"Immutable\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_AppendOnly:\n\t\tif (strcmp(name, \"AppendOnly\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoDump:\n\t\tif (strcmp(name, \"NoDump\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoAtime:\n\t\tif (strcmp(name, \"NoAtime\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_CompDirty:\n\t\tif (strcmp(name, \"CompDirty\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_CompBlock:\n\t\tif (strcmp(name, \"CompBlock\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoCompBlock:\n\t\tif (strcmp(name, \"NoCompBlock\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_CompError:\n\t\tif (strcmp(name, \"CompError\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_BTree:\n\t\tif (strcmp(name, \"BTree\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_HashIndexed:\n\t\tif (strcmp(name, \"HashIndexed\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_iMagic:\n\t\tif (strcmp(name, \"iMagic\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Journaled:\n\t\tif (strcmp(name, \"Journaled\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_NoTail:\n\t\tif (strcmp(name, \"NoTail\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_DirSync:\n\t\tif (strcmp(name, \"DirSync\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_TopDir:\n\t\tif (strcmp(name, \"TopDir\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase FILE_EXT2_Reserved:\n\t\tif (strcmp(name, \"Reserved\") == 0)\n\t\t\txar->xmlsts = FILE_EXT2;\n\t\tbreak;\n\tcase UNKNOWN:\n\t\tunknowntag_end(xar, name);\n\t\tbreak;\n\t}\n}\n\nstatic const int base64[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 00 - 0F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 10 - 1F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, 62, -1, -1, -1, 63, /* 20 - 2F */\n\t52, 53, 54, 55, 56, 57, 58, 59,\n\t60, 61, -1, -1, -1, -1, -1, -1, /* 30 - 3F */\n\t-1,  0,  1,  2,  3,  4,  5,  6,\n\t 7,  8,  9, 10, 11, 12, 13, 14, /* 40 - 4F */\n\t15, 16, 17, 18, 19, 20, 21, 22,\n\t23, 24, 25, -1, -1, -1, -1, -1, /* 50 - 5F */\n\t-1, 26, 27, 28, 29, 30, 31, 32,\n\t33, 34, 35, 36, 37, 38, 39, 40, /* 60 - 6F */\n\t41, 42, 43, 44, 45, 46, 47, 48,\n\t49, 50, 51, -1, -1, -1, -1, -1, /* 70 - 7F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 80 - 8F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* 90 - 9F */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* A0 - AF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* B0 - BF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* C0 - CF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* D0 - DF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* E0 - EF */\n\t-1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, /* F0 - FF */\n};\n\nstatic void\nstrappend_base64(struct xar *xar,\n    struct archive_string *as, const char *s, size_t l)\n{\n\tunsigned char buff[256];\n\tunsigned char *out;\n\tconst unsigned char *b;\n\tsize_t len;\n\n\t(void)xar; /* UNUSED */\n\tlen = 0;\n\tout = buff;\n\tb = (const unsigned char *)s;\n\twhile (l > 0) {\n\t\tint n = 0;\n\n\t\tif (l > 0) {\n\t\t\tif (base64[b[0]] < 0 || base64[b[1]] < 0)\n\t\t\t\tbreak;\n\t\t\tn = base64[*b++] << 18;\n\t\t\tn |= base64[*b++] << 12;\n\t\t\t*out++ = n >> 16;\n\t\t\tlen++;\n\t\t\tl -= 2;\n\t\t}\n\t\tif (l > 0) {\n\t\t\tif (base64[*b] < 0)\n\t\t\t\tbreak;\n\t\t\tn |= base64[*b++] << 6;\n\t\t\t*out++ = (n >> 8) & 0xFF;\n\t\t\tlen++;\n\t\t\t--l;\n\t\t}\n\t\tif (l > 0) {\n\t\t\tif (base64[*b] < 0)\n\t\t\t\tbreak;\n\t\t\tn |= base64[*b++];\n\t\t\t*out++ = n & 0xFF;\n\t\t\tlen++;\n\t\t\t--l;\n\t\t}\n\t\tif (len+3 >= sizeof(buff)) {\n\t\t\tarchive_strncat(as, (const char *)buff, len);\n\t\t\tlen = 0;\n\t\t\tout = buff;\n\t\t}\n\t}\n\tif (len > 0)\n\t\tarchive_strncat(as, (const char *)buff, len);\n}\n\nstatic void\nxml_data(void *userData, const char *s, int len)\n{\n\tstruct archive_read *a;\n\tstruct xar *xar;\n\n\ta = (struct archive_read *)userData;\n\txar = (struct xar *)(a->format->data);\n\n#if DEBUG\n\t{\n\t\tchar buff[1024];\n\t\tif (len > (int)(sizeof(buff)-1))\n\t\t\tlen = (int)(sizeof(buff)-1);\n\t\tstrncpy(buff, s, len);\n\t\tbuff[len] = 0;\n\t\tfprintf(stderr, \"\\tlen=%d:\\\"%s\\\"\\n\", len, buff);\n\t}\n#endif\n\tswitch (xar->xmlsts) {\n\tcase TOC_CHECKSUM_OFFSET:\n\t\txar->toc_chksum_offset = atol10(s, len);\n\t\tbreak;\n\tcase TOC_CHECKSUM_SIZE:\n\t\txar->toc_chksum_size = atol10(s, len);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (xar->file == NULL)\n\t\treturn;\n\n\tswitch (xar->xmlsts) {\n\tcase FILE_NAME:\n\t\tif (xar->file->parent != NULL) {\n\t\t\tarchive_string_concat(&(xar->file->pathname),\n\t\t\t    &(xar->file->parent->pathname));\n\t\t\tarchive_strappend_char(&(xar->file->pathname), '/');\n\t\t}\n\t\txar->file->has |= HAS_PATHNAME;\n\t\tif (xar->base64text) {\n\t\t\tstrappend_base64(xar,\n\t\t\t    &(xar->file->pathname), s, len);\n\t\t} else\n\t\t\tarchive_strncat(&(xar->file->pathname), s, len);\n\t\tbreak;\n\tcase FILE_LINK:\n\t\txar->file->has |= HAS_SYMLINK;\n\t\tarchive_strncpy(&(xar->file->symlink), s, len);\n\t\tbreak;\n\tcase FILE_TYPE:\n\t\tif (strncmp(\"file\", s, len) == 0 ||\n\t\t    strncmp(\"hardlink\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFREG;\n\t\tif (strncmp(\"directory\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFDIR;\n\t\tif (strncmp(\"symlink\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFLNK;\n\t\tif (strncmp(\"character special\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFCHR;\n\t\tif (strncmp(\"block special\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFBLK;\n\t\tif (strncmp(\"socket\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFSOCK;\n\t\tif (strncmp(\"fifo\", s, len) == 0)\n\t\t\txar->file->mode =\n\t\t\t    (xar->file->mode & ~AE_IFMT) | AE_IFIFO;\n\t\txar->file->has |= HAS_TYPE;\n\t\tbreak;\n\tcase FILE_INODE:\n\t\txar->file->has |= HAS_INO;\n\t\txar->file->ino64 = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DEVICE_MAJOR:\n\t\txar->file->has |= HAS_DEVMAJOR;\n\t\txar->file->devmajor = (dev_t)atol10(s, len);\n\t\tbreak;\n\tcase FILE_DEVICE_MINOR:\n\t\txar->file->has |= HAS_DEVMINOR;\n\t\txar->file->devminor = (dev_t)atol10(s, len);\n\t\tbreak;\n\tcase FILE_DEVICENO:\n\t\txar->file->has |= HAS_DEV;\n\t\txar->file->dev = (dev_t)atol10(s, len);\n\t\tbreak;\n\tcase FILE_MODE:\n\t\txar->file->has |= HAS_MODE;\n\t\txar->file->mode =\n\t\t    (xar->file->mode & AE_IFMT) |\n\t\t    ((mode_t)(atol8(s, len)) & ~AE_IFMT);\n\t\tbreak;\n\tcase FILE_GROUP:\n\t\txar->file->has |= HAS_GID;\n\t\tarchive_strncpy(&(xar->file->gname), s, len);\n\t\tbreak;\n\tcase FILE_GID:\n\t\txar->file->has |= HAS_GID;\n\t\txar->file->gid = atol10(s, len);\n\t\tbreak;\n\tcase FILE_USER:\n\t\txar->file->has |= HAS_UID;\n\t\tarchive_strncpy(&(xar->file->uname), s, len);\n\t\tbreak;\n\tcase FILE_UID:\n\t\txar->file->has |= HAS_UID;\n\t\txar->file->uid = atol10(s, len);\n\t\tbreak;\n\tcase FILE_CTIME:\n\t\txar->file->has |= HAS_TIME;\n\t\txar->file->ctime = parse_time(s, len);\n\t\tbreak;\n\tcase FILE_MTIME:\n\t\txar->file->has |= HAS_TIME;\n\t\txar->file->mtime = parse_time(s, len);\n\t\tbreak;\n\tcase FILE_ATIME:\n\t\txar->file->has |= HAS_TIME;\n\t\txar->file->atime = parse_time(s, len);\n\t\tbreak;\n\tcase FILE_DATA_LENGTH:\n\t\txar->file->has |= HAS_DATA;\n\t\txar->file->length = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DATA_OFFSET:\n\t\txar->file->has |= HAS_DATA;\n\t\txar->file->offset = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DATA_SIZE:\n\t\txar->file->has |= HAS_DATA;\n\t\txar->file->size = atol10(s, len);\n\t\tbreak;\n\tcase FILE_DATA_A_CHECKSUM:\n\t\txar->file->a_sum.len = atohex(xar->file->a_sum.val,\n\t\t    sizeof(xar->file->a_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_DATA_E_CHECKSUM:\n\t\txar->file->e_sum.len = atohex(xar->file->e_sum.val,\n\t\t    sizeof(xar->file->e_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_EA_LENGTH:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->length = atol10(s, len);\n\t\tbreak;\n\tcase FILE_EA_OFFSET:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->offset = atol10(s, len);\n\t\tbreak;\n\tcase FILE_EA_SIZE:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->size = atol10(s, len);\n\t\tbreak;\n\tcase FILE_EA_A_CHECKSUM:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->a_sum.len = atohex(xar->xattr->a_sum.val,\n\t\t    sizeof(xar->xattr->a_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_EA_E_CHECKSUM:\n\t\txar->file->has |= HAS_XATTR;\n\t\txar->xattr->e_sum.len = atohex(xar->xattr->e_sum.val,\n\t\t    sizeof(xar->xattr->e_sum.val), s, len);\n\t\tbreak;\n\tcase FILE_EA_NAME:\n\t\txar->file->has |= HAS_XATTR;\n\t\tarchive_strncpy(&(xar->xattr->name), s, len);\n\t\tbreak;\n\tcase FILE_EA_FSTYPE:\n\t\txar->file->has |= HAS_XATTR;\n\t\tarchive_strncpy(&(xar->xattr->fstype), s, len);\n\t\tbreak;\n\t\tbreak;\n\tcase FILE_ACL_DEFAULT:\n\tcase FILE_ACL_ACCESS:\n\tcase FILE_ACL_APPLEEXTENDED:\n\t\txar->file->has |= HAS_ACL;\n\t\t/* TODO */\n\t\tbreak;\n\tcase INIT:\n\tcase XAR:\n\tcase TOC:\n\tcase TOC_CREATION_TIME:\n\tcase TOC_CHECKSUM:\n\tcase TOC_CHECKSUM_OFFSET:\n\tcase TOC_CHECKSUM_SIZE:\n\tcase TOC_FILE:\n\tcase FILE_DATA:\n\tcase FILE_DATA_ENCODING:\n\tcase FILE_DATA_CONTENT:\n\tcase FILE_DEVICE:\n\tcase FILE_EA:\n\tcase FILE_EA_ENCODING:\n\tcase FILE_ACL:\n\tcase FILE_FLAGS:\n\tcase FILE_FLAGS_USER_NODUMP:\n\tcase FILE_FLAGS_USER_IMMUTABLE:\n\tcase FILE_FLAGS_USER_APPEND:\n\tcase FILE_FLAGS_USER_OPAQUE:\n\tcase FILE_FLAGS_USER_NOUNLINK:\n\tcase FILE_FLAGS_SYS_ARCHIVED:\n\tcase FILE_FLAGS_SYS_IMMUTABLE:\n\tcase FILE_FLAGS_SYS_APPEND:\n\tcase FILE_FLAGS_SYS_NOUNLINK:\n\tcase FILE_FLAGS_SYS_SNAPSHOT:\n\tcase FILE_EXT2:\n\tcase FILE_EXT2_SecureDeletion:\n\tcase FILE_EXT2_Undelete:\n\tcase FILE_EXT2_Compress:\n\tcase FILE_EXT2_Synchronous:\n\tcase FILE_EXT2_Immutable:\n\tcase FILE_EXT2_AppendOnly:\n\tcase FILE_EXT2_NoDump:\n\tcase FILE_EXT2_NoAtime:\n\tcase FILE_EXT2_CompDirty:\n\tcase FILE_EXT2_CompBlock:\n\tcase FILE_EXT2_NoCompBlock:\n\tcase FILE_EXT2_CompError:\n\tcase FILE_EXT2_BTree:\n\tcase FILE_EXT2_HashIndexed:\n\tcase FILE_EXT2_iMagic:\n\tcase FILE_EXT2_Journaled:\n\tcase FILE_EXT2_NoTail:\n\tcase FILE_EXT2_DirSync:\n\tcase FILE_EXT2_TopDir:\n\tcase FILE_EXT2_Reserved:\n\tcase UNKNOWN:\n\t\tbreak;\n\t}\n}\n\n/*\n * BSD file flags.\n */\nstatic int\nxml_parse_file_flags(struct xar *xar, const char *name)\n{\n\tconst char *flag = NULL;\n\n\tif (strcmp(name, \"UserNoDump\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_NODUMP;\n\t\tflag = \"nodump\";\n\t}\n\telse if (strcmp(name, \"UserImmutable\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_IMMUTABLE;\n\t\tflag = \"uimmutable\";\n\t}\n\telse if (strcmp(name, \"UserAppend\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_APPEND;\n\t\tflag = \"uappend\";\n\t}\n\telse if (strcmp(name, \"UserOpaque\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_OPAQUE;\n\t\tflag = \"opaque\";\n\t}\n\telse if (strcmp(name, \"UserNoUnlink\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_USER_NOUNLINK;\n\t\tflag = \"nouunlink\";\n\t}\n\telse if (strcmp(name, \"SystemArchived\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_ARCHIVED;\n\t\tflag = \"archived\";\n\t}\n\telse if (strcmp(name, \"SystemImmutable\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_IMMUTABLE;\n\t\tflag = \"simmutable\";\n\t}\n\telse if (strcmp(name, \"SystemAppend\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_APPEND;\n\t\tflag = \"sappend\";\n\t}\n\telse if (strcmp(name, \"SystemNoUnlink\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_NOUNLINK;\n\t\tflag = \"nosunlink\";\n\t}\n\telse if (strcmp(name, \"SystemSnapshot\") == 0) {\n\t\txar->xmlsts = FILE_FLAGS_SYS_SNAPSHOT;\n\t\tflag = \"snapshot\";\n\t}\n\n\tif (flag == NULL)\n\t\treturn (0);\n\txar->file->has |= HAS_FFLAGS;\n\tif (archive_strlen(&(xar->file->fflags_text)) > 0)\n\t\tarchive_strappend_char(&(xar->file->fflags_text), ',');\n\tarchive_strcat(&(xar->file->fflags_text), flag);\n\treturn (1);\n}\n\n/*\n * Linux file flags.\n */\nstatic int\nxml_parse_file_ext2(struct xar *xar, const char *name)\n{\n\tconst char *flag = NULL;\n\n\tif (strcmp(name, \"SecureDeletion\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_SecureDeletion;\n\t\tflag = \"securedeletion\";\n\t}\n\telse if (strcmp(name, \"Undelete\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Undelete;\n\t\tflag = \"nouunlink\";\n\t}\n\telse if (strcmp(name, \"Compress\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Compress;\n\t\tflag = \"compress\";\n\t}\n\telse if (strcmp(name, \"Synchronous\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Synchronous;\n\t\tflag = \"sync\";\n\t}\n\telse if (strcmp(name, \"Immutable\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Immutable;\n\t\tflag = \"simmutable\";\n\t}\n\telse if (strcmp(name, \"AppendOnly\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_AppendOnly;\n\t\tflag = \"sappend\";\n\t}\n\telse if (strcmp(name, \"NoDump\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoDump;\n\t\tflag = \"nodump\";\n\t}\n\telse if (strcmp(name, \"NoAtime\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoAtime;\n\t\tflag = \"noatime\";\n\t}\n\telse if (strcmp(name, \"CompDirty\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_CompDirty;\n\t\tflag = \"compdirty\";\n\t}\n\telse if (strcmp(name, \"CompBlock\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_CompBlock;\n\t\tflag = \"comprblk\";\n\t}\n\telse if (strcmp(name, \"NoCompBlock\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoCompBlock;\n\t\tflag = \"nocomprblk\";\n\t}\n\telse if (strcmp(name, \"CompError\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_CompError;\n\t\tflag = \"comperr\";\n\t}\n\telse if (strcmp(name, \"BTree\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_BTree;\n\t\tflag = \"btree\";\n\t}\n\telse if (strcmp(name, \"HashIndexed\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_HashIndexed;\n\t\tflag = \"hashidx\";\n\t}\n\telse if (strcmp(name, \"iMagic\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_iMagic;\n\t\tflag = \"imagic\";\n\t}\n\telse if (strcmp(name, \"Journaled\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Journaled;\n\t\tflag = \"journal\";\n\t}\n\telse if (strcmp(name, \"NoTail\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_NoTail;\n\t\tflag = \"notail\";\n\t}\n\telse if (strcmp(name, \"DirSync\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_DirSync;\n\t\tflag = \"dirsync\";\n\t}\n\telse if (strcmp(name, \"TopDir\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_TopDir;\n\t\tflag = \"topdir\";\n\t}\n\telse if (strcmp(name, \"Reserved\") == 0) {\n\t\txar->xmlsts = FILE_EXT2_Reserved;\n\t\tflag = \"reserved\";\n\t}\n\n\tif (flag == NULL)\n\t\treturn (0);\n\tif (archive_strlen(&(xar->file->fflags_text)) > 0)\n\t\tarchive_strappend_char(&(xar->file->fflags_text), ',');\n\tarchive_strcat(&(xar->file->fflags_text), flag);\n\treturn (1);\n}\n\n#ifdef HAVE_LIBXML_XMLREADER_H\n\nstatic int\nxml2_xmlattr_setup(struct archive_read *a,\n    struct xmlattr_list *list, xmlTextReaderPtr reader)\n{\n\tstruct xmlattr *attr;\n\tint r;\n\n\tlist->first = NULL;\n\tlist->last = &(list->first);\n\tr = xmlTextReaderMoveToFirstAttribute(reader);\n\twhile (r == 1) {\n\t\tattr = malloc(sizeof*(attr));\n\t\tif (attr == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->name = strdup(\n\t\t    (const char *)xmlTextReaderConstLocalName(reader));\n\t\tif (attr->name == NULL) {\n\t\t\tfree(attr);\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->value = strdup(\n\t\t    (const char *)xmlTextReaderConstValue(reader));\n\t\tif (attr->value == NULL) {\n\t\t\tfree(attr->name);\n\t\t\tfree(attr);\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->next = NULL;\n\t\t*list->last = attr;\n\t\tlist->last = &(attr->next);\n\t\tr = xmlTextReaderMoveToNextAttribute(reader);\n\t}\n\treturn (r);\n}\n\nstatic int\nxml2_read_cb(void *context, char *buffer, int len)\n{\n\tstruct archive_read *a;\n\tstruct xar *xar;\n\tconst void *d;\n\tsize_t outbytes;\n\tsize_t used = 0;\n\tint r;\n\n\ta = (struct archive_read *)context;\n\txar = (struct xar *)(a->format->data);\n\n\tif (xar->toc_remaining <= 0)\n\t\treturn (0);\n\td = buffer;\n\toutbytes = len;\n\tr = rd_contents(a, &d, &outbytes, &used, xar->toc_remaining);\n\tif (r != ARCHIVE_OK)\n\t\treturn (r);\n\t__archive_read_consume(a, used);\n\txar->toc_remaining -= used;\n\txar->offset += used;\n\txar->toc_total += outbytes;\n\tPRINT_TOC(buffer, len);\n\n\treturn ((int)outbytes);\n}\n\nstatic int\nxml2_close_cb(void *context)\n{\n\n\t(void)context; /* UNUSED */\n\treturn (0);\n}\n\nstatic void\nxml2_error_hdr(void *arg, const char *msg, xmlParserSeverities severity,\n    xmlTextReaderLocatorPtr locator)\n{\n\tstruct archive_read *a;\n\n\t(void)locator; /* UNUSED */\n\ta = (struct archive_read *)arg;\n\tswitch (severity) {\n\tcase XML_PARSER_SEVERITY_VALIDITY_WARNING:\n\tcase XML_PARSER_SEVERITY_WARNING:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"XML Parsing error: %s\", msg);\n\t\tbreak;\n\tcase XML_PARSER_SEVERITY_VALIDITY_ERROR:\n\tcase XML_PARSER_SEVERITY_ERROR:\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"XML Parsing error: %s\", msg);\n\t\tbreak;\n\t}\n}\n\nstatic int\nxml2_read_toc(struct archive_read *a)\n{\n\txmlTextReaderPtr reader;\n\tstruct xmlattr_list list;\n\tint r;\n\n\treader = xmlReaderForIO(xml2_read_cb, xml2_close_cb, a, NULL, NULL, 0);\n\tif (reader == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Couldn't allocate memory for xml parser\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\txmlTextReaderSetErrorHandler(reader, xml2_error_hdr, a);\n\n\twhile ((r = xmlTextReaderRead(reader)) == 1) {\n\t\tconst char *name, *value;\n\t\tint type, empty;\n\n\t\ttype = xmlTextReaderNodeType(reader);\n\t\tname = (const char *)xmlTextReaderConstLocalName(reader);\n\t\tswitch (type) {\n\t\tcase XML_READER_TYPE_ELEMENT:\n\t\t\tempty = xmlTextReaderIsEmptyElement(reader);\n\t\t\tr = xml2_xmlattr_setup(a, &list, reader);\n\t\t\tif (r == ARCHIVE_OK)\n\t\t\t\tr = xml_start(a, name, &list);\n\t\t\txmlattr_cleanup(&list);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t\tif (empty)\n\t\t\t\txml_end(a, name);\n\t\t\tbreak;\n\t\tcase XML_READER_TYPE_END_ELEMENT:\n\t\t\txml_end(a, name);\n\t\t\tbreak;\n\t\tcase XML_READER_TYPE_TEXT:\n\t\t\tvalue = (const char *)xmlTextReaderConstValue(reader);\n\t\t\txml_data(a, value, strlen(value));\n\t\t\tbreak;\n\t\tcase XML_READER_TYPE_SIGNIFICANT_WHITESPACE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (r < 0)\n\t\t\tbreak;\n\t}\n\txmlFreeTextReader(reader);\n\txmlCleanupParser();\n\n\treturn ((r == 0)?ARCHIVE_OK:ARCHIVE_FATAL);\n}\n\n#elif defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H)\n\nstatic int\nexpat_xmlattr_setup(struct archive_read *a,\n    struct xmlattr_list *list, const XML_Char **atts)\n{\n\tstruct xmlattr *attr;\n\tchar *name, *value;\n\n\tlist->first = NULL;\n\tlist->last = &(list->first);\n\tif (atts == NULL)\n\t\treturn (ARCHIVE_OK);\n\twhile (atts[0] != NULL && atts[1] != NULL) {\n\t\tattr = malloc(sizeof*(attr));\n\t\tname = strdup(atts[0]);\n\t\tvalue = strdup(atts[1]);\n\t\tif (attr == NULL || name == NULL || value == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM, \"Out of memory\");\n\t\t\tfree(attr);\n\t\t\tfree(name);\n\t\t\tfree(value);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tattr->name = name;\n\t\tattr->value = value;\n\t\tattr->next = NULL;\n\t\t*list->last = attr;\n\t\tlist->last = &(attr->next);\n\t\tatts += 2;\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic void\nexpat_start_cb(void *userData, const XML_Char *name, const XML_Char **atts)\n{\n\tstruct expat_userData *ud = (struct expat_userData *)userData;\n\tstruct archive_read *a = ud->archive;\n\tstruct xmlattr_list list;\n\tint r;\n\n\tr = expat_xmlattr_setup(a, &list, atts);\n\tif (r == ARCHIVE_OK)\n\t\tr = xml_start(a, (const char *)name, &list);\n\txmlattr_cleanup(&list);\n\tud->state = r;\n}\n\nstatic void\nexpat_end_cb(void *userData, const XML_Char *name)\n{\n\tstruct expat_userData *ud = (struct expat_userData *)userData;\n\n\txml_end(ud->archive, (const char *)name);\n}\n\nstatic void\nexpat_data_cb(void *userData, const XML_Char *s, int len)\n{\n\tstruct expat_userData *ud = (struct expat_userData *)userData;\n\n\txml_data(ud->archive, s, len);\n}\n\nstatic int\nexpat_read_toc(struct archive_read *a)\n{\n\tstruct xar *xar;\n\tXML_Parser parser;\n\tstruct expat_userData ud;\n\n\tud.state = ARCHIVE_OK;\n\tud.archive = a;\n\n\txar = (struct xar *)(a->format->data);\n\n\t/* Initialize XML Parser library. */\n\tparser = XML_ParserCreate(NULL);\n\tif (parser == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Couldn't allocate memory for xml parser\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tXML_SetUserData(parser, &ud);\n\tXML_SetElementHandler(parser, expat_start_cb, expat_end_cb);\n\tXML_SetCharacterDataHandler(parser, expat_data_cb);\n\txar->xmlsts = INIT;\n\n\twhile (xar->toc_remaining && ud.state == ARCHIVE_OK) {\n\t\tenum XML_Status xr;\n\t\tconst void *d;\n\t\tsize_t outbytes;\n\t\tsize_t used;\n\t\tint r;\n\n\t\td = NULL;\n\t\tr = rd_contents(a, &d, &outbytes, &used, xar->toc_remaining);\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\txar->toc_remaining -= used;\n\t\txar->offset += used;\n\t\txar->toc_total += outbytes;\n\t\tPRINT_TOC(d, outbytes);\n\n\t\txr = XML_Parse(parser, d, outbytes, xar->toc_remaining == 0);\n\t\t__archive_read_consume(a, used);\n\t\tif (xr == XML_STATUS_ERROR) {\n\t\t\tXML_ParserFree(parser);\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"XML Parsing failed\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n\tXML_ParserFree(parser);\n\treturn (ud.state);\n}\n#endif /* defined(HAVE_BSDXML_H) || defined(HAVE_EXPAT_H) */\n\n#endif /* Support xar format */\n"], "filenames": ["libarchive/archive_read_support_format_xar.c"], "buggy_code_start_loc": [1042], "buggy_code_end_loc": [1058], "fixing_code_start_loc": [1043], "fixing_code_end_loc": [1064], "type": "CWE-125", "message": "libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.", "other": {"cve": {"id": "CVE-2017-14166", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-06T18:29:00.273", "lastModified": "2019-08-15T18:15:12.787", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c."}, {"lang": "es", "value": "libarchive 3.3.2 permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer basada en mont\u00edculos xml_data y fallo de aplicaci\u00f3n) mediante un archivo xar manipulado. Esto est\u00e1 relacionado con la mala gesti\u00f3n de strings vac\u00edos en la funci\u00f3n atol8 en archive_read_support_format_xar.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "E3FF21B2-41AD-446B-9EE5-184F573973E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/09/06/libarchive-heap-based-buffer-overflow-in-xml_data-archive_read_support_format_xar-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libarchive/libarchive/commit/fa7438a0ff4033e4741c807394a9af6207940d71", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00037.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201908-11", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3736-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4360", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/fa7438a0ff4033e4741c807394a9af6207940d71"}}