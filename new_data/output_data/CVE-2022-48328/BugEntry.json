{"buggy_code": ["<?php\n\n/**\n * Get filter parameters from index searches\n */\n\nclass IndexFilterComponent extends Component\n{\n    /** @var Controller */\n    public $Controller;\n    public $isRest = null;\n\n    // Used for isApiFunction(), a check that returns true if the controller & action combo matches an action that is a non-xml and non-json automation method\n    // This is used to allow authentication via headers for methods not covered by _isRest() - as that only checks for JSON and XML formats\n    const AUTOMATION_ARRAY = array(\n        'events' => array('csv', 'nids', 'hids', 'xml', 'restSearch', 'stix', 'updateGraph', 'downloadOpenIOCEvent'),\n        'attributes' => array('text', 'downloadAttachment', 'returnAttributes', 'restSearch', 'rpz', 'bro'),\n        'objects' => array('restSearch'),\n    );\n\n    public function initialize(Controller $controller)\n    {\n        $this->Controller = $controller;\n    }\n\n    // generic function to standardise on the collection of parameters. Accepts posted request objects, url params, named url params\n    public function harvestParameters($paramArray, &$exception = [])\n    {\n        $request = $this->Controller->request;\n        $data = [];\n        if ($request->is('post')) {\n            if (empty($request->data)) {\n                $exception = $this->Controller->RestResponse->throwException(\n                    400,\n                    __('Either specify the search terms in the url, or POST a json with the filter parameters.'),\n                    '/' . $request->params['controller'] . '/' . $this->Controller->action\n                );\n                return false;\n            } else {\n                if (isset($request->data['request'])) {\n                    $data = $request->data['request'];\n                } else {\n                    $data = $request->data;\n                }\n            }\n        }\n        if (!empty($paramArray)) {\n            foreach ($paramArray as $p) {\n                if (\n                    isset($options['ordered_url_params'][$p]) &&\n                    (!in_array(strtolower((string)$options['ordered_url_params'][$p]), array('null', '0', false, 'false', null)))\n                ) {\n                    $data[$p] = $options['ordered_url_params'][$p];\n                    $data[$p] = str_replace(';', ':', $data[$p]);\n                }\n                if (isset($request->params['named'][$p])) {\n                    $data[$p] = str_replace(';', ':', $request->params['named'][$p]);\n                }\n            }\n        }\n        foreach ($data as &$v) {\n            if (is_string($v)) {\n                $v = trim($v);\n                if (strpos($v, '||')) {\n                    $v = explode('||', $v);\n                }\n            }\n        }\n        unset($v);\n        if (!empty($options['additional_delimiters'])) {\n            if (!is_array($options['additional_delimiters'])) {\n                $options['additional_delimiters'] = array($options['additional_delimiters']);\n            }\n            foreach ($data as $k => $v) {\n                $found = false;\n                foreach ($options['additional_delimiters'] as $delim) {\n                    if (strpos($v, $delim) !== false) {\n                        $found = true;\n                        break;\n                    }\n                }\n                if ($found) {\n                    $data[$k] = explode($options['additional_delimiters'][0], str_replace($options['additional_delimiters'], $options['additional_delimiters'][0], $v));\n                    foreach ($data[$k] as $k2 => $value) {\n                        $data[$k][$k2] = trim($data[$k][$k2]);\n                    }\n                }\n            }\n        }\n        $this->Controller->set('passedArgs', json_encode($this->Controller->passedArgs));\n        return $data;\n    }\n\n    public function isRest()\n    {\n        // This method is surprisingly slow and called many times for one request, so it make sense to cache the result.\n        if ($this->isRest !== null) {\n            return $this->isRest;\n        }\n        $api = $this->isApiFunction($this->Controller->request->params['controller'], $this->Controller->request->params['action']);\n        if (isset($this->Controller->RequestHandler) && ($api || $this->isJson() || $this->Controller->RequestHandler->isXml() || $this->isCsv())) {\n            $this->isRest = true;\n            return true;\n        } else {\n            $this->isRest = false;\n            return false;\n        }\n    }\n\n    public function isJson()\n    {\n        return $this->Controller->request->header('Accept') === 'application/json' || $this->Controller->RequestHandler->prefers() === 'json';\n    }\n\n    public function isCsv()\n    {\n        return $this->Controller->request->header('Accept') === 'text/csv' || $this->Controller->RequestHandler->prefers() === 'csv';\n    }\n\n    public function isXml()\n    {\n\n    }\n\n    /**\n     * @param string $controller\n     * @param string $action\n     * @return bool\n     */\n    public function isApiFunction($controller, $action)\n    {\n        return isset(self::AUTOMATION_ARRAY[$controller]) && in_array($action, self::AUTOMATION_ARRAY[$controller], true);\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Get filter parameters from index searches\n */\n\nclass IndexFilterComponent extends Component\n{\n    /** @var Controller */\n    public $Controller;\n    public $isRest = null;\n\n    // Used for isApiFunction(), a check that returns true if the controller & action combo matches an action that is a non-xml and non-json automation method\n    // This is used to allow authentication via headers for methods not covered by _isRest() - as that only checks for JSON and XML formats\n    const AUTOMATION_ARRAY = array(\n        'events' => array('csv', 'nids', 'hids', 'xml', 'restSearch', 'stix', 'updateGraph', 'downloadOpenIOCEvent'),\n        'attributes' => array('text', 'downloadAttachment', 'returnAttributes', 'restSearch', 'rpz', 'bro'),\n        'objects' => array('restSearch'),\n    );\n\n    public function initialize(Controller $controller)\n    {\n        $this->Controller = $controller;\n    }\n\n    // generic function to standardise on the collection of parameters. Accepts posted request objects, url params, named url params\n    public function harvestParameters($paramArray, &$exception = [])\n    {\n        $request = $this->Controller->request;\n        $data = [];\n        if ($request->is('post')) {\n            if (empty($request->data)) {\n                $exception = $this->Controller->RestResponse->throwException(\n                    400,\n                    __('Either specify the search terms in the url, or POST a json with the filter parameters.'),\n                    '/' . $request->params['controller'] . '/' . $this->Controller->action\n                );\n                return false;\n            } else {\n                if (isset($request->data['request'])) {\n                    $data = $request->data['request'];\n                } else {\n                    $data = $request->data;\n                }\n            }\n        }\n\n        if (!empty($paramArray)) {\n            foreach ($paramArray as $p) {\n                if (isset($request->params['named'][$p])) {\n                    $data[$p] = str_replace(';', ':', $request->params['named'][$p]);\n                }\n            }\n        }\n        foreach ($data as &$v) {\n            if (is_string($v)) {\n                $v = trim($v);\n                if (strpos($v, '||')) {\n                    $v = explode('||', $v);\n                }\n            }\n        }\n        unset($v);\n        \n        $data = array_filter($data, function($paramName) use ($paramArray) {\n            return !empty($paramArray[$paramName]);\n        }, ARRAY_FILTER_USE_KEY);\n\n        $this->Controller->set('passedArgs', json_encode($this->Controller->passedArgs));\n        return $data;\n    }\n\n    public function isRest()\n    {\n        // This method is surprisingly slow and called many times for one request, so it make sense to cache the result.\n        if ($this->isRest !== null) {\n            return $this->isRest;\n        }\n        $api = $this->isApiFunction($this->Controller->request->params['controller'], $this->Controller->request->params['action']);\n        if (isset($this->Controller->RequestHandler) && ($api || $this->isJson() || $this->Controller->RequestHandler->isXml() || $this->isCsv())) {\n            $this->isRest = true;\n            return true;\n        } else {\n            $this->isRest = false;\n            return false;\n        }\n    }\n\n    public function isJson()\n    {\n        return $this->Controller->request->header('Accept') === 'application/json' || $this->Controller->RequestHandler->prefers() === 'json';\n    }\n\n    public function isCsv()\n    {\n        return $this->Controller->request->header('Accept') === 'text/csv' || $this->Controller->RequestHandler->prefers() === 'csv';\n    }\n\n    public function isXml()\n    {\n\n    }\n\n    /**\n     * @param string $controller\n     * @param string $action\n     * @return bool\n     */\n    public function isApiFunction($controller, $action)\n    {\n        return isset(self::AUTOMATION_ARRAY[$controller]) && in_array($action, self::AUTOMATION_ARRAY[$controller], true);\n    }\n}\n"], "filenames": ["app/Controller/Component/IndexFilterComponent.php"], "buggy_code_start_loc": [46], "buggy_code_end_loc": [90], "fixing_code_start_loc": [47], "fixing_code_end_loc": [69], "type": "CWE-755", "message": "app/Controller/Component/IndexFilterComponent.php in MISP before 2.4.167 mishandles ordered_url_params and additional_delimiters.", "other": {"cve": {"id": "CVE-2022-48328", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-20T04:15:11.147", "lastModified": "2023-02-28T20:21:02.497", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "app/Controller/Component/IndexFilterComponent.php in MISP before 2.4.167 mishandles ordered_url_params and additional_delimiters."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.167", "matchCriteriaId": "28C474BE-2055-428A-A58B-D3D5A9B82FF8"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/1edbc2569989f844799261a5f90edfa433d7dbcc", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/MISP/MISP/commit/206f540f0275af2dd2a86275abc199df41e72a21", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/MISP/MISP/compare/v2.4.166...v2.4.167", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/1edbc2569989f844799261a5f90edfa433d7dbcc"}}