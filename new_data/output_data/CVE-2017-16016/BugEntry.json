{"buggy_code": ["# sanitize-html\n\n<a href=\"http://apostrophenow.org/\"><img src=\"https://raw.github.com/punkave/sanitize-html/master/logos/logo-box-madefor.png\" align=\"right\" /></a>\n\n`sanitize-html` provides a simple HTML sanitizer with a clear API.\n\n`sanitize-html` is tolerant. It is well suited for cleaning up HTML fragments such as those created by ckeditor and other rich text editors. It is especially handy for removing unwanted CSS when copying and pasting from Word.\n\n`sanitize-html` allows you to specify the tags you want to permit, and the permitted attributes for each of those tags.\n\nIf a tag is not permitted, the contents of the tag are still kept, except for script and style tags.\n\nThe syntax of poorly closed `p` and `img` elements is cleaned up.\n\n`href` attributes are validated to ensure they only contain `http`, `https`, `ftp` and `mailto` URLs. Relative URLs are also allowed. Ditto for `src` attributes.\n\nHTML comments are not preserved.\n\n## Requirements\n\n`sanitize-html` is intended for use with Node. That's pretty much it. All of its npm dependencies are pure JavaScript. `sanitize-html` is built on the excellent `htmlparser2` module.\n\n## How to use\n\nInstall module from console:\n\n```bash\nnpm install sanitize-html\n```\n\nUse it in your node app:\n\n```js\nvar sanitizeHtml = require('sanitize-html');\n\nvar dirty = 'some really tacky HTML';\nvar clean = sanitizeHtml(dirty);\n```\n\nThat will allow our default list of allowed tags and attributes through. It's a nice set, but probably not quite what you want. So:\n\n```js\n// Allow only a super restricted set of tags and attributes\nclean = sanitizeHtml(dirty, {\n  allowedTags: [ 'b', 'i', 'em', 'strong', 'a' ],\n  allowedAttributes: {\n    'a': [ 'href' ]\n  }\n});\n```\n\nBoom!\n\n#### \"I like your set but I want to add one more tag. Is there a convenient way?\" Sure:\n\n```js\nclean = sanitizeHtml(dirty, {\n  allowedTags: sanitizeHtml.defaults.allowedTags.concat([ 'img' ])\n});\n```\n\nIf you do not specify `allowedTags` or `allowedAttributes` our default list is applied. So if you really want an empty list, specify one.\n\n#### \"What are the default options?\"\n\n```js\nallowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol',\n  'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div',\n  'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\nallowedAttributes: {\n  a: [ 'href', 'name', 'target' ],\n  // We don't currently allow img itself by default, but this\n  // would make sense if we did\n  img: [ 'src' ]\n},\n// Lots of these won't come up by default because we don't allow them\nselfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n// URL schemes we permit\nallowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ],\nallowedSchemesByTag: {}\n```\n\n#### \"What if I want to allow all tags or all attributes?\"\n\nSimple! instead of leaving `allowedTags` or `allowedAttributes` out of the options, set either\none or both to `false`:\n\n```js\nallowedTags: false,\nallowedAttributes: false\n```\n\n#### \"What if I don't want to allow *any* tags?\"\n\nAlso simple!  Set your `allowedTag` and `allowedAttributes` to empty arrays (`[]`).\n\n```js\nallowedTags: [],\nallowedAttributes: []\n```\n\n### Wildcards for attributes\n\nYou can use the `*` wildcard to allow all attributes with a certain prefix:\n\n```javascript\nallowedAttributes: {\n  a: [ 'href', 'data-*' ]\n}\n```\n\nAlso you can use the `*` as name for a tag, to allow listed attributes to be valid for any tag:\n\n```javascript\nallowedAttributes: {\n  '*': [ 'href', 'align', 'alt', 'center', 'bgcolor' ]\n}\n```\n\n### htmlparser2 Options\n\n`santizeHtml` is built on `htmlparser2`. By default the only option passed down is `decodeEntities: true` You can set the options to pass by using the parser option.\n\n```javascript\nclean = sanitizeHtml(dirty, {\n  allowedTags: ['a'],\n  parser: {\n    lowerCaseTags: true\n  }\n});\n```\nSee the [htmlparser2 wiki] (https://github.com/fb55/htmlparser2/wiki/Parser-options) for the full list of possible options.\n\n### Transformations\n\nWhat if you want to add or change an attribute? What if you want to transform one tag to another? No problem, it's simple!\n\nThe easiest way (will change all `ol` tags to `ul` tags):\n\n```js\nclean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': 'ul',\n  }\n});\n```\n\nThe most advanced usage:\n\n```js\nclean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': function(tagName, attribs) {\n        // My own custom magic goes here\n\n        return {\n            tagName: 'ul',\n            attribs: {\n                class: 'foo'\n            }\n        };\n    }\n  }\n});\n```\n\nYou can specify the `*` wildcard instead of a tag name to transform all tags.\n\nThere is also a helper method which should be enough for simple cases in which you want to change the tag and/or add some attributes:\n\n```js\nclean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': sanitizeHtml.simpleTransform('ul', {class: 'foo'}),\n  }\n});\n```\n\nThe `simpleTransform` helper method has 3 parameters:\n\n```js\nsimpleTransform(newTag, newAttributes, shouldMerge)\n```\n\nThe last parameter (`shouldMerge`) is set to `true` by default. When `true`, `simpleTransform` will merge the current attributes with the new ones (`newAttributes`). When `false`, all existing attributes are discarded.\n\n### Filters\n\nYou can provide a filter function to remove unwanted tags. Let's suppose we need to remove empty `a` tags like:\n\n```html\n<a href=\"page.html\"></a>\n```\n\nWe can do that with the following filter:\n\n```javascript\nsanitizeHtml(\n  '<p>This is <a href=\"http://www.linux.org\"></a><br/>Linux</p>',\n  {\n    exclusiveFilter: function(frame) {\n        return frame.tag === 'a' && !frame.text.trim();\n    }\n  }\n);\n```\n\nThe `frame` object supplied to the callback provides the following attributes:\n\n - `tag`: The tag name, i.e. `'img'`.\n - `attribs`: The tag's attributes, i.e. `{ src: \"/path/to/tux.png\" }`.\n - `text`: The text content of the tag.\n - `tagPosition`: The index of the tag's position in the result string.\n\nYou can also process all text content with a provided filter function. Let's say we want an ellipsis instead of three dots.\n\n```html\n<p>some text...</p>\n```\n\nWe can do that with the following filter:\n\n```javascript\nsanitizeHtml(\n  '<p>some text...</p>',\n  {\n    textFilter: function(text) {\n      return text.replace(/\\.\\.\\./, '&hellip;');\n    }\n  }\n);\n```\n\nNote that the text passed to the `textFilter` method is already escaped for safe display as HTML. You may add markup and use entity escape sequences in your `textFilter`.\n\n### Allowed CSS Classes\n\nIf you wish to allow specific CSS classes on a particular element, you can do so with the `allowedClasses` option. Any other CSS classes are discarded.\n\nThis implies that the `class` attribute is allowed on that element.\n\n```javascript\n// Allow only a restricted set of CSS classes and only on the p tag\nclean = sanitizeHtml(dirty, {\n  allowedTags: [ 'p', 'em', 'strong' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ]\n  }\n});\n```\n\n### Allowed URL schemes\n\nBy default we allow the following URL schemes in cases where `href`, `src`, etc. are allowed:\n\n```js\n[ 'http', 'https', 'ftp', 'mailto' ]\n```\n\nYou can override this if you want to:\n\n```javascript\nsanitizeHtml(\n  // teeny-tiny valid transparent GIF in a data URL\n  '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n  {\n    allowedTags: [ 'img', 'p' ],\n    allowedSchemes: [ 'data', 'http' ]\n  }\n);\n```\n\nYou can also allow a scheme for a particular tag only:\n\n```javascript\nallowedSchemes: [ 'http', 'https' ],\nallowedSchemesByTag: {\n  img: [ 'data' ]\n}\n```\n\n### Discarding the entire contents of a disallowed tag\n\nNormally, with a few exceptions, if a tag is not allowed, all of the text within it is preserved, and so are any allowed tags within it.\n\nThe exceptions are:\n\n`style`, `script`, `textarea`\n\nIf you wish to expand this list, for instance to discard whatever is found inside a `noscript` tag, use the `nonTextTags` option:\n\n```javascript\nnonTextTags: [ 'style', 'script', 'textarea', 'noscript' ]\n```\n\nNote that if you use this option you are responsible for stating the entire list. This gives you the power to retain the content of `textarea`, if you want to.\n\n## Changelog\n\n1.11.4: fixed crash when `__proto__` is a tag name. Now using a safe check for the existence of properties in all cases. Thanks to Andrew Krasichkov.\n\n1.11.3: bumped `htmlparser2` version to address crashing bug in older version. Thanks to e-jigsaw.\n\n1.11.2: fixed README typo that interfered with readability due to markdown issues. No code changes. Thanks to Mikael Korpela. Also improved code block highlighting in README. Thanks to Alex Siman.\n\n1.11.1: fixed a regression introduced in 1.11.0 which caused the closing tag of the parent of a `textarea` tag to be lost. Thanks to Stefano Sala, who contributed the missing test.\n\n1.11.0: added the `nonTextTags` option, with tests.\n\n1.10.1: documentation cleanup. No code changes. Thanks to Rex Schrader.\n\n1.10.0: `allowedAttributes` now allows you to allow attributes for all tags by specifying `*` as the tag name. Thanks to Zdravko Georgiev.\n\n1.9.0: `parser` option allows options to be passed directly to `htmlparser`. Thanks to Danny Scott.\n\n1.8.0:\n\n* `transformTags` now accepts the `*` wildcard to transform all tags. Thanks to Jamy Timmermans.\n\n* Text that has been modified by `transformTags` is then passed through `textFilter`. Thanks to Pavlo Yurichuk.\n\n* Content inside `textarea` is discarded if `textarea` is not allowed. I don't know why it took me this long to see that this is just common sense. Thanks to David Frank.\n\n1.7.2: removed `array-includes` dependency in favor of `indexOf`, which is a little more verbose but slightly faster and doesn't require a shim. Thanks again to Joseph Dykstra.\n\n1.7.1: removed lodash dependency, adding lighter dependencies and polyfills in its place. Thanks to Joseph Dykstra.\n\n1.7.0: introduced `allowedSchemesByTag` option. Thanks to Cameron Will.\n\n1.6.1: the string `'undefined'` (as opposed to `undefined`) is perfectly valid text and shouldn't be expressly converted to the empty string.\n\n1.6.0: added `textFilter` option. Thanks to Csaba Palfi.\n\n1.5.3: do not escape special characters inside a script or style element, if they are allowed. This is consistent with the way browsers parse them; nothing closes them except the appropriate closing tag for the entire element. Of course, this only comes into play if you actually choose to allow those tags. Thanks to aletorrado.\n\n1.5.2: guard checks for allowed attributes correctly to avoid an undefined property error. Thanks to Zeke.\n\n1.5.1: updated to htmlparser2 1.8.x. Started using the `decodeEntities` option, which allows us to pass our filter evasion tests without the need to recursively invoke the filter.\n\n1.5.0: support for `*` wildcards in allowedAttributes. With tests. Thanks to Calvin Montgomery.\n\n1.4.3: invokes itself recursively until the markup stops changing to guard against [this issue](https://github.com/fb55/htmlparser2/issues/105). Bump to htmlparser2 version 3.7.x.\n\n1.4.1, 1.4.2: more tests.\n\n1.4.0: ability to  allow all attributes or tags through by setting `allowedAttributes` and/or `allowedTags` to false. Thanks to Anand Thakker.\n\n1.3.0: `attribs` now available on frames passed to exclusive filter.\n\n1.2.3: fixed another possible XSS attack vector; no definitive exploit was found but it looks possible. [See this issue.](https://github.com/punkave/sanitize-html/pull/20) Thanks to Jim O'Brien.\n\n1.2.2: reject `javascript:` URLs when disguised with an internal comment. This is probably not respected by browsers anyway except when inside an XML data island element, which you almost certainly are not allowing in your `allowedTags`, but we aim to be thorough. Thanks to Jim O'Brien.\n\n1.2.1: fixed crashing bug when presented with bad markup. The bug was in the `exclusiveFilter` mechanism. Unit test added. Thanks to Ilya Kantor for catching it.\n\n1.2.0:\n\n* The `allowedClasses` option now allows you to permit CSS classes in a fine-grained way.\n\n* Text passed to your `exclusiveFilter` function now includes the text of child elements, making it more useful for identifying elements that truly lack any inner text.\n\n1.1.7: use `he` for entity decoding, because it is more actively maintained.\n\n1.1.6: `allowedSchemes` option for those who want to permit `data` URLs and such.\n\n1.1.5: just a packaging thing.\n\n1.1.4: custom exclusion filter.\n\n1.1.3: moved to lodash. 1.1.2 pointed to the wrong version of lodash.\n\n1.1.0: the `transformTags` option was added. Thanks to [kl3ryk](https://github.com/kl3ryk).\n\n1.0.3: fixed several more javascript URL attack vectors after [studying the XSS filter evasion cheat sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) to better understand my enemy. Whitespace characters (codes from 0 to 32), which browsers ignore in URLs in certain cases allowing the \"javascript\" scheme to be snuck in, are now stripped out when checking for naughty URLs. Thanks again to [pinpickle](https://github.com/pinpickle).\n\n1.0.2: fixed a javascript URL attack vector. naughtyHref must entity-decode URLs and also check for mixed-case scheme names. Thanks to [pinpickle](https://github.com/pinpickle).\n\n1.0.1: Doc tweaks.\n\n1.0.0: If the style tag is disallowed, then its content should be dumped, so that it doesn't appear as text. We were already doing this for script tags, however in both cases the content is now preserved if the tag is explicitly allowed.\n\nWe're rocking our tests and have been working great in production for months, so: declared 1.0.0 stable.\n\n0.1.3: do not double-escape entities in attributes or text. Turns out the \"text\" provided by htmlparser2 is already escaped.\n\n0.1.2: packaging error meant it wouldn't install properly.\n\n0.1.1: discard the text of script tags.\n\n0.1.0: initial release.\n\n## About P'unk Avenue and Apostrophe\n\n`sanitize-html` was created at [P'unk Avenue](http://punkave.com) for use in Apostrophe, an open-source content management system built on node.js. If you like `sanitize-html` you should definitely [check out apostrophenow.org](http://apostrophenow.org). Also be sure to visit us on [github](http://github.com/punkave).\n\n## Support\n\nFeel free to open issues on [github](http://github.com/punkave/sanitize-html).\n\n<a href=\"http://punkave.com/\"><img src=\"https://raw.github.com/punkave/sanitize-html/master/logos/logo-box-builtby.png\" /></a>\n\n\n", "var htmlparser = require('htmlparser2');\nvar extend = require('xtend');\nvar quoteRegexp = require('regexp-quote');\n\nfunction each(obj, cb) {\n  if (obj) Object.keys(obj).forEach(function (key) {\n    cb(obj[key], key);\n  });\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\nmodule.exports = sanitizeHtml;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  var result = '';\n\n  function Frame(tag, attribs) {\n    var that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n          var parentFrame = stack[stack.length - 1];\n          parentFrame.text += that.text;\n      }\n    };\n  }\n\n  if (!options) {\n    options = sanitizeHtml.defaults;\n    options.parser = htmlParserDefaults;\n  } else {\n    options = extend(sanitizeHtml.defaults, options);\n    if (options.parser) {\n      options.parser = extend(htmlParserDefaults, options.parser);\n    } else {\n      options.parser = htmlParserDefaults;\n    }\n  }\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  var nonTextTagsArray = options.nonTextTags || [ 'script', 'style', 'textarea' ];\n  var allowedAttributesMap;\n  var allowedAttributesGlobMap;\n  if(options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      var globRegex = [];\n      attributes.forEach(function(name) {\n        if(name.indexOf('*') >= 0) {\n          globRegex.push(quoteRegexp(name).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(name);\n        }\n      });\n      allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    });\n  }\n  var allowedClassesMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if(allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = classes;\n  });\n\n  var transformTagsMap = {};\n  var transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    var transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === \"string\") {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  var depth = 0;\n  var stack = [];\n  var skipMap = {};\n  var transformMap = {};\n  var skipText = false;\n  var skipTextDepth = 0;\n\n  var parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      var frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      var skip = false;\n      var transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if (options.allowedTags && options.allowedTags.indexOf(name) === -1) {\n        skip = true;\n        if (nonTextTagsArray.indexOf(name) !== -1) {\n          skipText = true;\n          skipTextDepth = 1;\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        // We want the contents but not this tag\n        return;\n      }\n      result += '<' + name;\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!allowedAttributesMap ||\n              (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 ) ||\n              (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1 ) ||\n              (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n              (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            if ((a === 'href') || (a === 'src')) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              value = filterClasses(value, allowedClassesMap[name]);\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            result += ' ' + a;\n            if (value.length) {\n              result += '=\"' + escapeHtml(value) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += \" />\";\n      } else {\n        result += \">\";\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      var lastFrame = stack[stack.length-1];\n      var tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (nonTextTagsArray.indexOf(tag) !== -1) {\n        result += text;\n      } else {\n        var escaped = escapeHtml(text);\n        if (options.textFilter) {\n          result += options.textFilter(escaped);\n        } else {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n           var frame = stack[stack.length - 1];\n           frame.text += text;\n      }\n    },\n    onclosetag: function(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      var frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      skipText = false;\n      depth--;\n      if (skipMap[depth]) {\n        delete skipMap[depth];\n        frame.updateParentNodeText();\n        return;\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n         result = result.substr(0, frame.tagPosition);\n         return;\n      }\n\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n         // Already output />\n         return;\n      }\n\n      result += \"</\" + name + \">\";\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function escapeHtml(s) {\n    if (typeof(s) !== 'string') {\n      s = s + '';\n    }\n    return s.replace(/\\&/g, '&amp;').replace(/</g, '&lt;').replace(/\\>/g, '&gt;').replace(/\\\"/g, '&quot;');\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    href = href.replace(/<\\!\\-\\-.*?\\-\\-\\>/g, '');\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    var matches = href.match(/^([a-zA-Z]+)\\:/);\n    if (!matches) {\n      // No scheme = no way to inject js (right?)\n      return false;\n    }\n    var scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  function filterClasses(classes, allowed) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1;\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nvar htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol',\n    'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div',\n    'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but this\n    // would make sense if we did\n    img: [ 'src' ]\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ],\n  allowedSchemesByTag: {}\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    var attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n", "var assert = require(\"assert\");\ndescribe('sanitizeHtml', function() {\n  var sanitizeHtml;\n  it('should be successfully initialized', function() {\n    sanitizeHtml = require('../index.js');\n  });\n  it('should pass through simple well-formed whitelisted markup', function() {\n    assert.equal(sanitizeHtml('<div><p>Hello <b>there</b></p></div>'), '<div><p>Hello <b>there</b></p></div>');\n  });\n  it('should pass through all markup if allowedTags and allowedAttributes are set to false', function() {\n    assert.equal(sanitizeHtml('<div><wiggly worms=\"ewww\">hello</wiggly></div>', {\n      allowedTags: false,\n      allowedAttributes: false\n    }), '<div><wiggly worms=\"ewww\">hello</wiggly></div>');\n  });\n  it('should respect text nodes at top level', function() {\n    assert.equal(sanitizeHtml('Blah blah blah<p>Whee!</p>'), 'Blah blah blah<p>Whee!</p>');\n  });\n  it('should reject markup not whitelisted without destroying its text', function() {\n    assert.equal(sanitizeHtml('<div><wiggly>Hello</wiggly></div>'), '<div>Hello</div>');\n  });\n  it('should accept a custom list of allowed tags', function() {\n    assert.equal(sanitizeHtml('<blue><red><green>Cheese</green></red></blue>', { allowedTags: [ 'blue', 'green' ] }), '<blue><green>Cheese</green></blue>');\n  });\n  it('should reject attributes not whitelisted', function() {\n    assert.equal(sanitizeHtml('<a href=\"foo.html\" whizbang=\"whangle\">foo</a>'), '<a href=\"foo.html\">foo</a>');\n  });\n  it('should accept a custom list of allowed attributes per element', function() {\n    assert.equal(sanitizeHtml('<a href=\"foo.html\" whizbang=\"whangle\">foo</a>', { allowedAttributes: { a: [ 'href', 'whizbang' ] } } ), '<a href=\"foo.html\" whizbang=\"whangle\">foo</a>');\n  });\n  it('should clean up unclosed img tags and p tags', function() {\n    assert.equal(sanitizeHtml('<img src=\"foo.jpg\"><p>Whee<p>Again<p>Wow<b>cool</b>', { allowedTags: sanitizeHtml.defaults.allowedTags.concat([ 'img' ])}), '<img src=\"foo.jpg\" /><p>Whee</p><p>Again</p><p>Wow<b>cool</b></p>');\n  });\n  it('should reject hrefs that are not relative, ftp, http, https or mailto', function() {\n    assert.equal(sanitizeHtml('<a href=\"http://google.com\">google</a><a href=\"https://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a href=\"javascript:alert(0)\">javascript</a>'), '<a href=\"http://google.com\">google</a><a href=\"https://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a>javascript</a>');\n  });\n  it('should cope identically with capitalized attributes and tags and should tolerate capitalized schemes', function() {\n    assert.equal(sanitizeHtml('<A HREF=\"http://google.com\">google</a><a href=\"HTTPS://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a href=\"javascript:alert(0)\">javascript</a>'), '<a href=\"http://google.com\">google</a><a href=\"HTTPS://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a>javascript</a>');\n  });\n  it('should drop the content of script elements', function() {\n    assert.equal(sanitizeHtml('<script>alert(\"ruhroh!\");</script><p>Paragraph</p>'), '<p>Paragraph</p>');\n  });\n  it('should drop the content of style elements', function() {\n    assert.equal(sanitizeHtml('<style>.foo { color: blue; }</style><p>Paragraph</p>'), '<p>Paragraph</p>');\n  });\n  it('should drop the content of textarea elements', function() {\n    assert.equal(sanitizeHtml('<textarea>Nifty</textarea><p>Paragraph</p>'), '<p>Paragraph</p>');\n  });\n  it('should drop the content of textarea elements but keep the closing parent tag, when nested', function() {\n    assert.equal(sanitizeHtml('<p>Paragraph<textarea>Nifty</textarea></p>'), '<p>Paragraph</p>');\n  });\n  it('should retain the content of fibble elements by default', function() {\n    assert.equal(sanitizeHtml('<fibble>Nifty</fibble><p>Paragraph</p>'), 'Nifty<p>Paragraph</p>');\n  });\n  it('should discard the content of fibble elements if specified for nonTextTags', function() {\n    assert.equal(sanitizeHtml('<fibble>Nifty</fibble><p>Paragraph</p>', { nonTextTags: [ 'fibble' ] }), '<p>Paragraph</p>');\n  });\n  it('should retain allowed tags within a fibble element if fibble is not specified for nonTextTags', function() {\n    assert.equal(sanitizeHtml('<fibble>Ni<em>f</em>ty</fibble><p>Paragraph</p>', {}), 'Ni<em>f</em>ty<p>Paragraph</p>');\n  });\n  it('should discard allowed tags within a fibble element if fibble is specified for nonTextTags', function() {\n    assert.equal(sanitizeHtml('<fibble>Ni<em>f</em>ty</fibble><p>Paragraph</p>', { nonTextTags: [ 'fibble' ] }), '<p>Paragraph</p>');\n  });\n  it('should preserve textarea content if textareas are allowed', function() {\n    assert.equal(sanitizeHtml('<textarea>Nifty</textarea><p>Paragraph</p>', {\n      allowedTags: [ 'textarea', 'p' ]\n    }), '<textarea>Nifty</textarea><p>Paragraph</p>');\n  });\n  it('should preserve entities as such', function() {\n    assert.equal(sanitizeHtml('<a name=\"&lt;silly&gt;\">&lt;Kapow!&gt;</a>'), '<a name=\"&lt;silly&gt;\">&lt;Kapow!&gt;</a>');\n  });\n  it('should dump comments', function() {\n    assert.equal(sanitizeHtml('<p><!-- Blah blah -->Whee</p>'), '<p>Whee</p>');\n  });\n  it('should dump a sneaky encoded javascript url', function() {\n    assert.equal(sanitizeHtml('<a href=\"&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should dump an uppercase javascript url', function() {\n    assert.equal(sanitizeHtml('<a href=\"JAVASCRIPT:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should dump a javascript URL with a comment in the middle (probably only respected by browsers in XML data islands, but just in case someone enables those)', function() {\n    assert.equal(sanitizeHtml('<a href=\"java<!-- -->script:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should not mess up a hashcode with a : in it', function() {\n    assert.equal(sanitizeHtml('<a href=\"awesome.html#this:stuff\">Hi</a>'), '<a href=\"awesome.html#this:stuff\">Hi</a>');\n  });\n  it('should dump character codes 1-32 before testing scheme', function() {\n    assert.equal(sanitizeHtml('<a href=\"java\\0&#14;\\t\\r\\n script:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should dump character codes 1-32 even when escaped with padding rather than trailing ;', function() {\n    assert.equal(sanitizeHtml('<a href=\"java&#0000001script:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n    // This one is weird, but the browser does not interpret it\n    // as a scheme, so we're OK. That character is 65535, not null. I\n    // think it's a limitation of the entities module\n    assert.equal(sanitizeHtml('<a href=\"java&#0000000script:alert(\\'foo\\')\">Hax</a>'), '<a href=\"java\ufffdscript:alert(\\'foo\\')\">Hax</a>');\n  });\n  it('should still like nice schemes', function() {\n    assert.equal(sanitizeHtml('<a href=\"http://google.com/\">Hi</a>'), '<a href=\"http://google.com/\">Hi</a>');\n  });\n  it('should still like nice relative URLs', function() {\n    assert.equal(sanitizeHtml('<a href=\"hello.html\">Hi</a>'), '<a href=\"hello.html\">Hi</a>');\n  });\n  it('should replace ol to ul', function() {\n    assert.equal(sanitizeHtml('<ol><li>Hello world</li></ol>', { transformTags: {ol: 'ul'} }), '<ul><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul and add class attribute with foo value', function() {\n    assert.equal(sanitizeHtml('<ol><li>Hello world</li></ol>', { transformTags: {ol: sanitizeHtml.simpleTransform('ul', {class: 'foo'})}, allowedAttributes: { ul: ['class'] } }), '<ul class=\"foo\"><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul, left attributes foo and bar untouched, remove baz attribute and add class attributte with foo value', function() {\n    assert.equal(sanitizeHtml('<ol foo=\"foo\" bar=\"bar\" baz=\"baz\"><li>Hello world</li></ol>', { transformTags: {ol: sanitizeHtml.simpleTransform('ul', {class: 'foo'})}, allowedAttributes: { ul: ['foo', 'bar', 'class'] } }), '<ul foo=\"foo\" bar=\"bar\" class=\"foo\"><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul and replace all attributes to class attribute with foo value', function() {\n    assert.equal(sanitizeHtml('<ol foo=\"foo\" bar=\"bar\" baz=\"baz\"><li>Hello world</li></ol>', { transformTags: {ol: sanitizeHtml.simpleTransform('ul', {class: 'foo'}, false)}, allowedAttributes: { ul: ['foo', 'bar', 'class'] } }), '<ul class=\"foo\"><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul and add attribute class with foo value and attribute bar with bar value', function() {\n    assert.equal(sanitizeHtml('<ol><li>Hello world</li></ol>', { transformTags: {ol: function(tagName, attribs){\n      attribs.class = 'foo';\n      attribs.bar = 'bar';\n      return {\n        tagName: 'ul',\n        attribs: attribs\n      }\n    }}, allowedAttributes: { ul: ['bar', 'class'] } }), '<ul class=\"foo\" bar=\"bar\"><li>Hello world</li></ul>');\n  });\n\n  it('should replace text and attributes when they are changed by transforming function', function () {\n    assert.equal(sanitizeHtml('<a href=\"http://somelink\">some text</a>', { transformTags: {a: function (tagName, attribs) {\n      return {\n        tagName: tagName,\n        attribs: attribs,\n        text: ''\n      }\n    }}}), '<a href=\"http://somelink\"></a>');\n  });\n  it('should replace text and attributes when they are changed by transforming function and textFilter is set', function () {\n    assert.equal(sanitizeHtml('<a href=\"http://somelink\">some text</a>', { transformTags: {a: function (tagName, attribs) {\n      return {\n        tagName: tagName,\n        attribs: attribs,\n        text: 'some text need\"to<be>filtered'\n      }\n    }}, textFilter: function (text) {\n      return text.replace(/\\s/g, '_');\n    }}), '<a href=\"http://somelink\">some_text_need&quot;to&lt;be&gt;filtered</a>');\n  });\n\n  it('should skip an empty link', function() {\n     assert.strictEqual(\n     sanitizeHtml('<p>This is <a href=\"http://www.linux.org\"></a><br/>Linux</p>', {\n             exclusiveFilter: function (frame) {\n                 return frame.tag === 'a' && !frame.text.trim();\n             }\n         }),\n         '<p>This is <br />Linux</p>'\n        );\n    });\n\n    it(\"Should expose a node's inner text and inner HTML to the filter\", function() {\n        assert.strictEqual(\n            sanitizeHtml('<p>12<a href=\"http://www.linux.org\"><br/>3<br></a><span>4</span></p>', {\n                exclusiveFilter : function(frame) {\n                    if (frame.tag === 'p') {\n                        assert.strictEqual(frame.text, '124');\n                    } else if (frame.tag === 'a') {\n                        assert.strictEqual(frame.text, '3');\n                        return true;\n                    } else if (frame.tag === 'br') {\n                        assert.strictEqual(frame.text, '');\n                    } else {\n                        assert.fail('p, a, br', frame.tag);\n                    }\n                    return false;\n                }\n            }),\n            '<p>124</p>'\n        );\n    });\n\n  it('Should collapse nested empty elements', function() {\n        assert.strictEqual(\n            sanitizeHtml('<p><a href=\"http://www.linux.org\"><br/></a></p>', {\n                    exclusiveFilter : function(frame) {\n                        return (frame.tag === 'a' || frame.tag === 'p' ) && !frame.text.trim();\n                    }\n                }),\n            ''\n        );\n  });\n  it('Exclusive filter should not affect elements which do not match the filter condition', function () {\n      assert.strictEqual(\n          sanitizeHtml('I love <a href=\"www.linux.org\" target=\"_hplink\">Linux</a> OS',\n              {\n                  exclusiveFilter: function (frame) {\n                      return (frame.tag === 'a') && !frame.text.trim();\n                  }\n              }),\n          'I love <a href=\"www.linux.org\" target=\"_hplink\">Linux</a> OS'\n      );\n  });\n  it('should disallow data URLs with default allowedSchemes', function() {\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n        {\n          allowedTags: [ 'img' ]\n        }\n      ),\n      '<img />'\n    );\n  });\n  it('should allow data URLs with custom allowedSchemes', function() {\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n        {\n          allowedTags: [ 'img', 'p' ],\n          allowedSchemes: [ 'data', 'http' ]\n        }\n      ),\n      '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />'\n    );\n  });\n  it('should allow specific classes when whitelisted with allowedClasses', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<p class=\"nifty simple dippy\">whee</p>',\n        {\n          allowedTags: [ 'p' ],\n          allowedClasses: {\n            p: [ 'nifty' ]\n          }\n        }\n      ),\n      '<p class=\"nifty\">whee</p>'\n    );\n  });\n  it('should allow defining schemes on a per-tag basis', function() {\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" /><a href=\"https://www.example.com\"></a>',\n        {\n          allowedTags: ['img', 'a'],\n          allowedSchemes: ['http'],\n          allowedSchemesByTag: {\n            img: ['data'],\n            a: ['https']\n          }\n        }\n      ),\n      '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" /><a href=\"https://www.example.com\"></a>'\n    );\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" /><a href=\"https://www.example.com\"></a>',\n        {\n          allowedTags: ['img', 'a'],\n          allowedSchemes: ['http'],\n          allowedSchemesByTag: {\n            img: [],\n            a: ['https']\n          }\n        }\n      ),\n      '<img /><a href=\"https://www.example.com\"></a>'\n    );\n  });\n  it('should not act weird when the class attribute is empty', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<p class=\"\">whee</p>',\n        {\n          allowedTags: [ 'p' ],\n          allowedClasses: {\n            p: [ 'nifty' ]\n          }\n        }\n      ),\n      '<p>whee</p>'\n    );\n  });\n  it('should not crash on bad markup', function() {\n    assert.equal(\n      sanitizeHtml(\n        \"<p a\"\n      ),\n      ''\n    );\n  });\n  it('should not allow a naked = sign followed by an unrelated attribute to result in one merged attribute with unescaped double quote marks', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<IMG SRC= onmouseover=\"alert(\\'XSS\\');\">',\n        {\n          allowedTags: [ 'img' ],\n          allowedAttributes: {\n            img: [ 'src' ]\n          }\n        }\n      ),\n      // This is weird but not dangerous. Without the &quot there\n      // would probably be some way to make it come out as a\n      // separate attribute\n      '<img src=\"onmouseover=&quot;alert(\\'XSS\\');&quot;\" />'\n    );\n  });\n  it('should allow only whitelisted attributes, but to any tags, if tag is declared as  \"*\"', function() {\n    assert.equal(\n        sanitizeHtml(\n            '<table bgcolor=\"1\" align=\"left\" notlisted=\"0\"><img src=\"1.gif\" align=\"center\" alt=\"not listed too\"/></table>',\n            {\n              allowedTags: [ 'table', 'img' ],\n              allowedAttributes: {\n                '*': [ 'bgcolor', 'align', 'src' ]\n              }\n            }\n        ),\n        '<table bgcolor=\"1\" align=\"left\"><img src=\"1.gif\" align=\"center\" /></table>'\n    );\n  });\n  it('should not filter if exclusive filter does not match after transforming tags', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<a href=\"test.html\">test</a>',\n        {\n          allowedTags: [ 'a' ],\n          allowedAttributes: { a: ['href', 'target']},\n          transformTags: {\n            'a': function (tagName, attribs) {\n              if (!attribs.href)\n                return false;\n              return {\n                tagName: tagName,\n                attribs: {\n                  target: '_blank',\n                  href: attribs.href\n                }\n              };\n            }\n          },\n          exclusiveFilter: function(frame) {\n            return frame.tag === 'a' && frame.text.trim() == 'blah';\n          }\n        }\n      ),\n      '<a target=\"_blank\" href=\"test.html\">test</a>'\n    )\n  });\n  it('should filter if exclusive filter does match after transforming tags', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<a href=\"test.html\">blah</a>',\n        {\n          allowedTags: [ 'a' ],\n          allowedAttributes: {a: ['href', 'target']},\n          transformTags: {\n            'a': function (tagName, attribs) {\n              if (!attribs.href)\n                return false;\n              return {\n                tagName: tagName,\n                attribs: {\n                  target: '_blank',\n                  href: attribs.href\n                }\n              };\n            }\n          },\n          exclusiveFilter: function(frame) {\n            return frame.tag === 'a' && frame.text.trim() == 'blah';\n          }\n        }\n      ),\n      ''\n    );\n  });\n  it('should allow transform on all tags using \\'*\\'', function () {\n    assert.equal(\n      sanitizeHtml(\n        '<p>Text</p>',\n        {\n          allowedTags: [ 'p' ],\n          allowedAttributes: {p: ['style']},\n          transformTags: {\n            '*': function (tagName, attribs) {\n              return {\n                tagName: tagName,\n                attribs: {\n                  style: 'text-align: center;'\n                }\n              };\n            }\n          }\n        }\n      ),\n      '<p style=\"text-align: center;\">Text</p>'\n    );\n  });\n  it('should not be faked out by double <', function() {\n    assert.equal(\n      sanitizeHtml('<<img src=\"javascript:evil\"/>img src=\"javascript:evil\"/>'\n      ),\n      '&lt;img src=&quot;javascript:evil&quot;/&gt;'\n    );\n    assert.equal(\n      sanitizeHtml('<<a href=\"javascript:evil\"/>a href=\"javascript:evil\"/>'\n      ),\n      '&lt;<a>a href=&quot;javascript:evil&quot;/&gt;</a>'\n    );\n  });\n  it('should allow attributes to be specified as globs', function() {\n    assert.equal(\n      sanitizeHtml('<a data-target=\"#test\" data-foo=\"hello\">click me</a>', {\n        allowedTags: [ 'a' ],\n        allowedAttributes: { a: ['data-*'] }\n      }), '<a data-target=\"#test\" data-foo=\"hello\">click me</a>'\n    );\n    assert.equal(\n      sanitizeHtml('<a data-target=\"#test\" data-my-foo=\"hello\">click me</a>', {\n        allowedTags: [ 'a' ],\n        allowedAttributes: { a: ['data-*-foo'] }\n      }), '<a data-my-foo=\"hello\">click me</a>'\n    );\n  });\n  it('should quote regex chars in attributes specified as globs', function() {\n    assert.equal(\n      sanitizeHtml('<a data-b.c=\"#test\" data-bcc=\"remove this\">click me</a>', {\n        allowedTags: [ 'a' ],\n        allowedAttributes: { a: ['data-b.*'] }\n      }), '<a data-b.c=\"#test\">click me</a>'\n    );\n  });\n  it('should not escape inner content from non-text tags (when allowed)', function() {\n    assert.equal(\n      sanitizeHtml('<div>\"normal text\"</div><script>\"this is code\"</script>', {\n        allowedTags: [ 'script' ]\n      }), '&quot;normal text&quot;<script>\"this is code\"</script>'\n    );\n    assert.equal(\n      sanitizeHtml('<div>\"normal text\"</div><style>body { background-image: url(\"image.test\"); }</style>', {\n        allowedTags: [ 'style' ]\n      }), '&quot;normal text&quot;<style>body { background-image: url(\"image.test\"); }</style>'\n    );\n  });\n  it('should process text nodes with provided function', function() {\n    assert.equal(\n      sanitizeHtml('\"normal text this should be removed\"', {\n        textFilter: function(text) {\n          return text.replace(' this should be removed', '');\n        }\n      }), '&quot;normal text&quot;'\n    );\n  });\n  it('should respect htmlparser2 options when passed in', function() {\n    assert.equal(\n      sanitizeHtml(\"<Archer><Sterling>I am</Sterling></Archer>\", {\n        allowedTags: false,\n        allowedAttributes: false,\n      }),\n      \"<archer><sterling>I am</sterling></archer>\"\n    );\n    assert.equal(\n      sanitizeHtml(\"<Archer><Sterling>I am</Sterling></Archer>\", {\n        allowedTags: false,\n        allowedAttributes: false,\n        parser: {\n          lowerCaseTags: false\n        }\n      }),\n      \"<Archer><Sterling>I am</Sterling></Archer>\"\n    );\n  });\n  it('should not crash due to tag names that are properties of the universal Object prototype', function() {\n    assert.equal(\n      sanitizeHtml(\"!<__proto__>!\"),\n    \"!!\");\n  });\n});\n"], "fixing_code": ["# sanitize-html\n\n<a href=\"http://apostrophenow.org/\"><img src=\"https://raw.github.com/punkave/sanitize-html/master/logos/logo-box-madefor.png\" align=\"right\" /></a>\n\n`sanitize-html` provides a simple HTML sanitizer with a clear API.\n\n`sanitize-html` is tolerant. It is well suited for cleaning up HTML fragments such as those created by ckeditor and other rich text editors. It is especially handy for removing unwanted CSS when copying and pasting from Word.\n\n`sanitize-html` allows you to specify the tags you want to permit, and the permitted attributes for each of those tags.\n\nIf a tag is not permitted, the contents of the tag are still kept, except for `script`, `style` and `textarea` tags.\n\nThe syntax of poorly closed `p` and `img` elements is cleaned up.\n\n`href` attributes are validated to ensure they only contain `http`, `https`, `ftp` and `mailto` URLs. Relative URLs are also allowed. Ditto for `src` attributes.\n\nHTML comments are not preserved.\n\n## Requirements\n\n`sanitize-html` is intended for use with Node. That's pretty much it. All of its npm dependencies are pure JavaScript. `sanitize-html` is built on the excellent `htmlparser2` module.\n\n## How to use\n\nInstall module from console:\n\n```bash\nnpm install sanitize-html\n```\n\nUse it in your node app:\n\n```js\nvar sanitizeHtml = require('sanitize-html');\n\nvar dirty = 'some really tacky HTML';\nvar clean = sanitizeHtml(dirty);\n```\n\nThat will allow our default list of allowed tags and attributes through. It's a nice set, but probably not quite what you want. So:\n\n```js\n// Allow only a super restricted set of tags and attributes\nclean = sanitizeHtml(dirty, {\n  allowedTags: [ 'b', 'i', 'em', 'strong', 'a' ],\n  allowedAttributes: {\n    'a': [ 'href' ]\n  }\n});\n```\n\nBoom!\n\n#### \"I like your set but I want to add one more tag. Is there a convenient way?\" Sure:\n\n```js\nclean = sanitizeHtml(dirty, {\n  allowedTags: sanitizeHtml.defaults.allowedTags.concat([ 'img' ])\n});\n```\n\nIf you do not specify `allowedTags` or `allowedAttributes` our default list is applied. So if you really want an empty list, specify one.\n\n#### \"What are the default options?\"\n\n```js\nallowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol',\n  'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div',\n  'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\nallowedAttributes: {\n  a: [ 'href', 'name', 'target' ],\n  // We don't currently allow img itself by default, but this\n  // would make sense if we did\n  img: [ 'src' ]\n},\n// Lots of these won't come up by default because we don't allow them\nselfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n// URL schemes we permit\nallowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ],\nallowedSchemesByTag: {}\n```\n\n#### \"What if I want to allow all tags or all attributes?\"\n\nSimple! instead of leaving `allowedTags` or `allowedAttributes` out of the options, set either\none or both to `false`:\n\n```js\nallowedTags: false,\nallowedAttributes: false\n```\n\n#### \"What if I don't want to allow *any* tags?\"\n\nAlso simple!  Set your `allowedTag` and `allowedAttributes` to empty arrays (`[]`).\n\n```js\nallowedTags: [],\nallowedAttributes: []\n```\n\n### Wildcards for attributes\n\nYou can use the `*` wildcard to allow all attributes with a certain prefix:\n\n```javascript\nallowedAttributes: {\n  a: [ 'href', 'data-*' ]\n}\n```\n\nAlso you can use the `*` as name for a tag, to allow listed attributes to be valid for any tag:\n\n```javascript\nallowedAttributes: {\n  '*': [ 'href', 'align', 'alt', 'center', 'bgcolor' ]\n}\n```\n\n### htmlparser2 Options\n\n`santizeHtml` is built on `htmlparser2`. By default the only option passed down is `decodeEntities: true` You can set the options to pass by using the parser option.\n\n```javascript\nclean = sanitizeHtml(dirty, {\n  allowedTags: ['a'],\n  parser: {\n    lowerCaseTags: true\n  }\n});\n```\nSee the [htmlparser2 wiki] (https://github.com/fb55/htmlparser2/wiki/Parser-options) for the full list of possible options.\n\n### Transformations\n\nWhat if you want to add or change an attribute? What if you want to transform one tag to another? No problem, it's simple!\n\nThe easiest way (will change all `ol` tags to `ul` tags):\n\n```js\nclean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': 'ul',\n  }\n});\n```\n\nThe most advanced usage:\n\n```js\nclean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': function(tagName, attribs) {\n        // My own custom magic goes here\n\n        return {\n            tagName: 'ul',\n            attribs: {\n                class: 'foo'\n            }\n        };\n    }\n  }\n});\n```\n\nYou can specify the `*` wildcard instead of a tag name to transform all tags.\n\nThere is also a helper method which should be enough for simple cases in which you want to change the tag and/or add some attributes:\n\n```js\nclean = sanitizeHtml(dirty, {\n  transformTags: {\n    'ol': sanitizeHtml.simpleTransform('ul', {class: 'foo'}),\n  }\n});\n```\n\nThe `simpleTransform` helper method has 3 parameters:\n\n```js\nsimpleTransform(newTag, newAttributes, shouldMerge)\n```\n\nThe last parameter (`shouldMerge`) is set to `true` by default. When `true`, `simpleTransform` will merge the current attributes with the new ones (`newAttributes`). When `false`, all existing attributes are discarded.\n\n### Filters\n\nYou can provide a filter function to remove unwanted tags. Let's suppose we need to remove empty `a` tags like:\n\n```html\n<a href=\"page.html\"></a>\n```\n\nWe can do that with the following filter:\n\n```javascript\nsanitizeHtml(\n  '<p>This is <a href=\"http://www.linux.org\"></a><br/>Linux</p>',\n  {\n    exclusiveFilter: function(frame) {\n        return frame.tag === 'a' && !frame.text.trim();\n    }\n  }\n);\n```\n\nThe `frame` object supplied to the callback provides the following attributes:\n\n - `tag`: The tag name, i.e. `'img'`.\n - `attribs`: The tag's attributes, i.e. `{ src: \"/path/to/tux.png\" }`.\n - `text`: The text content of the tag.\n - `tagPosition`: The index of the tag's position in the result string.\n\nYou can also process all text content with a provided filter function. Let's say we want an ellipsis instead of three dots.\n\n```html\n<p>some text...</p>\n```\n\nWe can do that with the following filter:\n\n```javascript\nsanitizeHtml(\n  '<p>some text...</p>',\n  {\n    textFilter: function(text) {\n      return text.replace(/\\.\\.\\./, '&hellip;');\n    }\n  }\n);\n```\n\nNote that the text passed to the `textFilter` method is already escaped for safe display as HTML. You may add markup and use entity escape sequences in your `textFilter`.\n\n### Allowed CSS Classes\n\nIf you wish to allow specific CSS classes on a particular element, you can do so with the `allowedClasses` option. Any other CSS classes are discarded.\n\nThis implies that the `class` attribute is allowed on that element.\n\n```javascript\n// Allow only a restricted set of CSS classes and only on the p tag\nclean = sanitizeHtml(dirty, {\n  allowedTags: [ 'p', 'em', 'strong' ],\n  allowedClasses: {\n    'p': [ 'fancy', 'simple' ]\n  }\n});\n```\n\n### Allowed URL schemes\n\nBy default we allow the following URL schemes in cases where `href`, `src`, etc. are allowed:\n\n```js\n[ 'http', 'https', 'ftp', 'mailto' ]\n```\n\nYou can override this if you want to:\n\n```javascript\nsanitizeHtml(\n  // teeny-tiny valid transparent GIF in a data URL\n  '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n  {\n    allowedTags: [ 'img', 'p' ],\n    allowedSchemes: [ 'data', 'http' ]\n  }\n);\n```\n\nYou can also allow a scheme for a particular tag only:\n\n```javascript\nallowedSchemes: [ 'http', 'https' ],\nallowedSchemesByTag: {\n  img: [ 'data' ]\n}\n```\n\n### Discarding the entire contents of a disallowed tag\n\nNormally, with a few exceptions, if a tag is not allowed, all of the text within it is preserved, and so are any allowed tags within it.\n\nThe exceptions are:\n\n`style`, `script`, `textarea`\n\nIf you wish to expand this list, for instance to discard whatever is found inside a `noscript` tag, use the `nonTextTags` option:\n\n```javascript\nnonTextTags: [ 'style', 'script', 'textarea', 'noscript' ]\n```\n\nNote that if you use this option you are responsible for stating the entire list. This gives you the power to retain the content of `textarea`, if you want to.\n\nThe content still gets escaped properly, with the exception of the `script` and `style` tags. *Allowing either `script` or `style` leaves you open to XSS attacks. Don't do that* unless you have good reason to trust their origin.\n\n## Changelog\n\n1.11.4: fixed crash when `__proto__` is a tag name. Now using a safe check for the existence of properties in all cases. Thanks to Andrew Krasichkov.\n\nFixed XSS attack vector via `textarea` tags (when explicitly allowed). Decided that `script` (obviously) and `style` (due to its own XSS vectors) cannot realistically be afforded any XSS protection if allowed, unless we add a full CSS parser. Thanks again to Andrew Krasichkov.\n\n1.11.3: bumped `htmlparser2` version to address crashing bug in older version. Thanks to e-jigsaw.\n\n1.11.2: fixed README typo that interfered with readability due to markdown issues. No code changes. Thanks to Mikael Korpela. Also improved code block highlighting in README. Thanks to Alex Siman.\n\n1.11.1: fixed a regression introduced in 1.11.0 which caused the closing tag of the parent of a `textarea` tag to be lost. Thanks to Stefano Sala, who contributed the missing test.\n\n1.11.0: added the `nonTextTags` option, with tests.\n\n1.10.1: documentation cleanup. No code changes. Thanks to Rex Schrader.\n\n1.10.0: `allowedAttributes` now allows you to allow attributes for all tags by specifying `*` as the tag name. Thanks to Zdravko Georgiev.\n\n1.9.0: `parser` option allows options to be passed directly to `htmlparser`. Thanks to Danny Scott.\n\n1.8.0:\n\n* `transformTags` now accepts the `*` wildcard to transform all tags. Thanks to Jamy Timmermans.\n\n* Text that has been modified by `transformTags` is then passed through `textFilter`. Thanks to Pavlo Yurichuk.\n\n* Content inside `textarea` is discarded if `textarea` is not allowed. I don't know why it took me this long to see that this is just common sense. Thanks to David Frank.\n\n1.7.2: removed `array-includes` dependency in favor of `indexOf`, which is a little more verbose but slightly faster and doesn't require a shim. Thanks again to Joseph Dykstra.\n\n1.7.1: removed lodash dependency, adding lighter dependencies and polyfills in its place. Thanks to Joseph Dykstra.\n\n1.7.0: introduced `allowedSchemesByTag` option. Thanks to Cameron Will.\n\n1.6.1: the string `'undefined'` (as opposed to `undefined`) is perfectly valid text and shouldn't be expressly converted to the empty string.\n\n1.6.0: added `textFilter` option. Thanks to Csaba Palfi.\n\n1.5.3: do not escape special characters inside a script or style element, if they are allowed. This is consistent with the way browsers parse them; nothing closes them except the appropriate closing tag for the entire element. Of course, this only comes into play if you actually choose to allow those tags. Thanks to aletorrado.\n\n1.5.2: guard checks for allowed attributes correctly to avoid an undefined property error. Thanks to Zeke.\n\n1.5.1: updated to htmlparser2 1.8.x. Started using the `decodeEntities` option, which allows us to pass our filter evasion tests without the need to recursively invoke the filter.\n\n1.5.0: support for `*` wildcards in allowedAttributes. With tests. Thanks to Calvin Montgomery.\n\n1.4.3: invokes itself recursively until the markup stops changing to guard against [this issue](https://github.com/fb55/htmlparser2/issues/105). Bump to htmlparser2 version 3.7.x.\n\n1.4.1, 1.4.2: more tests.\n\n1.4.0: ability to  allow all attributes or tags through by setting `allowedAttributes` and/or `allowedTags` to false. Thanks to Anand Thakker.\n\n1.3.0: `attribs` now available on frames passed to exclusive filter.\n\n1.2.3: fixed another possible XSS attack vector; no definitive exploit was found but it looks possible. [See this issue.](https://github.com/punkave/sanitize-html/pull/20) Thanks to Jim O'Brien.\n\n1.2.2: reject `javascript:` URLs when disguised with an internal comment. This is probably not respected by browsers anyway except when inside an XML data island element, which you almost certainly are not allowing in your `allowedTags`, but we aim to be thorough. Thanks to Jim O'Brien.\n\n1.2.1: fixed crashing bug when presented with bad markup. The bug was in the `exclusiveFilter` mechanism. Unit test added. Thanks to Ilya Kantor for catching it.\n\n1.2.0:\n\n* The `allowedClasses` option now allows you to permit CSS classes in a fine-grained way.\n\n* Text passed to your `exclusiveFilter` function now includes the text of child elements, making it more useful for identifying elements that truly lack any inner text.\n\n1.1.7: use `he` for entity decoding, because it is more actively maintained.\n\n1.1.6: `allowedSchemes` option for those who want to permit `data` URLs and such.\n\n1.1.5: just a packaging thing.\n\n1.1.4: custom exclusion filter.\n\n1.1.3: moved to lodash. 1.1.2 pointed to the wrong version of lodash.\n\n1.1.0: the `transformTags` option was added. Thanks to [kl3ryk](https://github.com/kl3ryk).\n\n1.0.3: fixed several more javascript URL attack vectors after [studying the XSS filter evasion cheat sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) to better understand my enemy. Whitespace characters (codes from 0 to 32), which browsers ignore in URLs in certain cases allowing the \"javascript\" scheme to be snuck in, are now stripped out when checking for naughty URLs. Thanks again to [pinpickle](https://github.com/pinpickle).\n\n1.0.2: fixed a javascript URL attack vector. naughtyHref must entity-decode URLs and also check for mixed-case scheme names. Thanks to [pinpickle](https://github.com/pinpickle).\n\n1.0.1: Doc tweaks.\n\n1.0.0: If the style tag is disallowed, then its content should be dumped, so that it doesn't appear as text. We were already doing this for script tags, however in both cases the content is now preserved if the tag is explicitly allowed.\n\nWe're rocking our tests and have been working great in production for months, so: declared 1.0.0 stable.\n\n0.1.3: do not double-escape entities in attributes or text. Turns out the \"text\" provided by htmlparser2 is already escaped.\n\n0.1.2: packaging error meant it wouldn't install properly.\n\n0.1.1: discard the text of script tags.\n\n0.1.0: initial release.\n\n## About P'unk Avenue and Apostrophe\n\n`sanitize-html` was created at [P'unk Avenue](http://punkave.com) for use in Apostrophe, an open-source content management system built on node.js. If you like `sanitize-html` you should definitely [check out apostrophenow.org](http://apostrophenow.org). Also be sure to visit us on [github](http://github.com/punkave).\n\n## Support\n\nFeel free to open issues on [github](http://github.com/punkave/sanitize-html).\n\n<a href=\"http://punkave.com/\"><img src=\"https://raw.github.com/punkave/sanitize-html/master/logos/logo-box-builtby.png\" /></a>\n\n\n", "var htmlparser = require('htmlparser2');\nvar extend = require('xtend');\nvar quoteRegexp = require('regexp-quote');\n\nfunction each(obj, cb) {\n  if (obj) Object.keys(obj).forEach(function (key) {\n    cb(obj[key], key);\n  });\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\nmodule.exports = sanitizeHtml;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  var result = '';\n\n  function Frame(tag, attribs) {\n    var that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n          var parentFrame = stack[stack.length - 1];\n          parentFrame.text += that.text;\n      }\n    };\n  }\n\n  if (!options) {\n    options = sanitizeHtml.defaults;\n    options.parser = htmlParserDefaults;\n  } else {\n    options = extend(sanitizeHtml.defaults, options);\n    if (options.parser) {\n      options.parser = extend(htmlParserDefaults, options.parser);\n    } else {\n      options.parser = htmlParserDefaults;\n    }\n  }\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  var nonTextTagsArray = options.nonTextTags || [ 'script', 'style', 'textarea' ];\n  var allowedAttributesMap;\n  var allowedAttributesGlobMap;\n  if(options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      var globRegex = [];\n      attributes.forEach(function(name) {\n        if(name.indexOf('*') >= 0) {\n          globRegex.push(quoteRegexp(name).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(name);\n        }\n      });\n      allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    });\n  }\n  var allowedClassesMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if(allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = classes;\n  });\n\n  var transformTagsMap = {};\n  var transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    var transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === \"string\") {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  var depth = 0;\n  var stack = [];\n  var skipMap = {};\n  var transformMap = {};\n  var skipText = false;\n  var skipTextDepth = 0;\n\n  var parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      var frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      var skip = false;\n      var transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if (options.allowedTags && options.allowedTags.indexOf(name) === -1) {\n        skip = true;\n        if (nonTextTagsArray.indexOf(name) !== -1) {\n          skipText = true;\n          skipTextDepth = 1;\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        // We want the contents but not this tag\n        return;\n      }\n      result += '<' + name;\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!allowedAttributesMap ||\n              (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 ) ||\n              (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1 ) ||\n              (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n              (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            if ((a === 'href') || (a === 'src')) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              value = filterClasses(value, allowedClassesMap[name]);\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            result += ' ' + a;\n            if (value.length) {\n              result += '=\"' + escapeHtml(value) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += \" />\";\n      } else {\n        result += \">\";\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      var lastFrame = stack[stack.length-1];\n      var tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if ((tag === 'script') || (tag === 'style')) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        var escaped = escapeHtml(text);\n        if (options.textFilter) {\n          result += options.textFilter(escaped);\n        } else {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n           var frame = stack[stack.length - 1];\n           frame.text += text;\n      }\n    },\n    onclosetag: function(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      var frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      skipText = false;\n      depth--;\n      if (skipMap[depth]) {\n        delete skipMap[depth];\n        frame.updateParentNodeText();\n        return;\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n         result = result.substr(0, frame.tagPosition);\n         return;\n      }\n\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n         // Already output />\n         return;\n      }\n\n      result += \"</\" + name + \">\";\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function escapeHtml(s) {\n    if (typeof(s) !== 'string') {\n      s = s + '';\n    }\n    return s.replace(/\\&/g, '&amp;').replace(/</g, '&lt;').replace(/\\>/g, '&gt;').replace(/\\\"/g, '&quot;');\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    href = href.replace(/<\\!\\-\\-.*?\\-\\-\\>/g, '');\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    var matches = href.match(/^([a-zA-Z]+)\\:/);\n    if (!matches) {\n      // No scheme = no way to inject js (right?)\n      return false;\n    }\n    var scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  function filterClasses(classes, allowed) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1;\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nvar htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [ 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol',\n    'nl', 'li', 'b', 'i', 'strong', 'em', 'strike', 'code', 'hr', 'br', 'div',\n    'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td', 'pre' ],\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but this\n    // would make sense if we did\n    img: [ 'src' ]\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto' ],\n  allowedSchemesByTag: {}\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    var attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n", "var assert = require(\"assert\");\ndescribe('sanitizeHtml', function() {\n  var sanitizeHtml;\n  it('should be successfully initialized', function() {\n    sanitizeHtml = require('../index.js');\n  });\n  it('should pass through simple well-formed whitelisted markup', function() {\n    assert.equal(sanitizeHtml('<div><p>Hello <b>there</b></p></div>'), '<div><p>Hello <b>there</b></p></div>');\n  });\n  it('should pass through all markup if allowedTags and allowedAttributes are set to false', function() {\n    assert.equal(sanitizeHtml('<div><wiggly worms=\"ewww\">hello</wiggly></div>', {\n      allowedTags: false,\n      allowedAttributes: false\n    }), '<div><wiggly worms=\"ewww\">hello</wiggly></div>');\n  });\n  it('should respect text nodes at top level', function() {\n    assert.equal(sanitizeHtml('Blah blah blah<p>Whee!</p>'), 'Blah blah blah<p>Whee!</p>');\n  });\n  it('should reject markup not whitelisted without destroying its text', function() {\n    assert.equal(sanitizeHtml('<div><wiggly>Hello</wiggly></div>'), '<div>Hello</div>');\n  });\n  it('should accept a custom list of allowed tags', function() {\n    assert.equal(sanitizeHtml('<blue><red><green>Cheese</green></red></blue>', { allowedTags: [ 'blue', 'green' ] }), '<blue><green>Cheese</green></blue>');\n  });\n  it('should reject attributes not whitelisted', function() {\n    assert.equal(sanitizeHtml('<a href=\"foo.html\" whizbang=\"whangle\">foo</a>'), '<a href=\"foo.html\">foo</a>');\n  });\n  it('should accept a custom list of allowed attributes per element', function() {\n    assert.equal(sanitizeHtml('<a href=\"foo.html\" whizbang=\"whangle\">foo</a>', { allowedAttributes: { a: [ 'href', 'whizbang' ] } } ), '<a href=\"foo.html\" whizbang=\"whangle\">foo</a>');\n  });\n  it('should clean up unclosed img tags and p tags', function() {\n    assert.equal(sanitizeHtml('<img src=\"foo.jpg\"><p>Whee<p>Again<p>Wow<b>cool</b>', { allowedTags: sanitizeHtml.defaults.allowedTags.concat([ 'img' ])}), '<img src=\"foo.jpg\" /><p>Whee</p><p>Again</p><p>Wow<b>cool</b></p>');\n  });\n  it('should reject hrefs that are not relative, ftp, http, https or mailto', function() {\n    assert.equal(sanitizeHtml('<a href=\"http://google.com\">google</a><a href=\"https://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a href=\"javascript:alert(0)\">javascript</a>'), '<a href=\"http://google.com\">google</a><a href=\"https://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a>javascript</a>');\n  });\n  it('should cope identically with capitalized attributes and tags and should tolerate capitalized schemes', function() {\n    assert.equal(sanitizeHtml('<A HREF=\"http://google.com\">google</a><a href=\"HTTPS://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a href=\"javascript:alert(0)\">javascript</a>'), '<a href=\"http://google.com\">google</a><a href=\"HTTPS://google.com\">https google</a><a href=\"ftp://example.com\">ftp</a><a href=\"mailto:test@test.com\">mailto</a><a href=\"/relative.html\">relative</a><a>javascript</a>');\n  });\n  it('should drop the content of script elements', function() {\n    assert.equal(sanitizeHtml('<script>alert(\"ruhroh!\");</script><p>Paragraph</p>'), '<p>Paragraph</p>');\n  });\n  it('should drop the content of style elements', function() {\n    assert.equal(sanitizeHtml('<style>.foo { color: blue; }</style><p>Paragraph</p>'), '<p>Paragraph</p>');\n  });\n  it('should drop the content of textarea elements', function() {\n    assert.equal(sanitizeHtml('<textarea>Nifty</textarea><p>Paragraph</p>'), '<p>Paragraph</p>');\n  });\n  it('should drop the content of textarea elements but keep the closing parent tag, when nested', function() {\n    assert.equal(sanitizeHtml('<p>Paragraph<textarea>Nifty</textarea></p>'), '<p>Paragraph</p>');\n  });\n  it('should retain the content of fibble elements by default', function() {\n    assert.equal(sanitizeHtml('<fibble>Nifty</fibble><p>Paragraph</p>'), 'Nifty<p>Paragraph</p>');\n  });\n  it('should discard the content of fibble elements if specified for nonTextTags', function() {\n    assert.equal(sanitizeHtml('<fibble>Nifty</fibble><p>Paragraph</p>', { nonTextTags: [ 'fibble' ] }), '<p>Paragraph</p>');\n  });\n  it('should retain allowed tags within a fibble element if fibble is not specified for nonTextTags', function() {\n    assert.equal(sanitizeHtml('<fibble>Ni<em>f</em>ty</fibble><p>Paragraph</p>', {}), 'Ni<em>f</em>ty<p>Paragraph</p>');\n  });\n  it('should discard allowed tags within a fibble element if fibble is specified for nonTextTags', function() {\n    assert.equal(sanitizeHtml('<fibble>Ni<em>f</em>ty</fibble><p>Paragraph</p>', { nonTextTags: [ 'fibble' ] }), '<p>Paragraph</p>');\n  });\n  it('should preserve textarea content if textareas are allowed', function() {\n    assert.equal(sanitizeHtml('<textarea>Nifty</textarea><p>Paragraph</p>', {\n      allowedTags: [ 'textarea', 'p' ]\n    }), '<textarea>Nifty</textarea><p>Paragraph</p>');\n  });\n  it('should preserve entities as such', function() {\n    assert.equal(sanitizeHtml('<a name=\"&lt;silly&gt;\">&lt;Kapow!&gt;</a>'), '<a name=\"&lt;silly&gt;\">&lt;Kapow!&gt;</a>');\n  });\n  it('should dump comments', function() {\n    assert.equal(sanitizeHtml('<p><!-- Blah blah -->Whee</p>'), '<p>Whee</p>');\n  });\n  it('should dump a sneaky encoded javascript url', function() {\n    assert.equal(sanitizeHtml('<a href=\"&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should dump an uppercase javascript url', function() {\n    assert.equal(sanitizeHtml('<a href=\"JAVASCRIPT:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should dump a javascript URL with a comment in the middle (probably only respected by browsers in XML data islands, but just in case someone enables those)', function() {\n    assert.equal(sanitizeHtml('<a href=\"java<!-- -->script:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should not mess up a hashcode with a : in it', function() {\n    assert.equal(sanitizeHtml('<a href=\"awesome.html#this:stuff\">Hi</a>'), '<a href=\"awesome.html#this:stuff\">Hi</a>');\n  });\n  it('should dump character codes 1-32 before testing scheme', function() {\n    assert.equal(sanitizeHtml('<a href=\"java\\0&#14;\\t\\r\\n script:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n  });\n  it('should dump character codes 1-32 even when escaped with padding rather than trailing ;', function() {\n    assert.equal(sanitizeHtml('<a href=\"java&#0000001script:alert(\\'foo\\')\">Hax</a>'), '<a>Hax</a>');\n    // This one is weird, but the browser does not interpret it\n    // as a scheme, so we're OK. That character is 65535, not null. I\n    // think it's a limitation of the entities module\n    assert.equal(sanitizeHtml('<a href=\"java&#0000000script:alert(\\'foo\\')\">Hax</a>'), '<a href=\"java\ufffdscript:alert(\\'foo\\')\">Hax</a>');\n  });\n  it('should still like nice schemes', function() {\n    assert.equal(sanitizeHtml('<a href=\"http://google.com/\">Hi</a>'), '<a href=\"http://google.com/\">Hi</a>');\n  });\n  it('should still like nice relative URLs', function() {\n    assert.equal(sanitizeHtml('<a href=\"hello.html\">Hi</a>'), '<a href=\"hello.html\">Hi</a>');\n  });\n  it('should replace ol to ul', function() {\n    assert.equal(sanitizeHtml('<ol><li>Hello world</li></ol>', { transformTags: {ol: 'ul'} }), '<ul><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul and add class attribute with foo value', function() {\n    assert.equal(sanitizeHtml('<ol><li>Hello world</li></ol>', { transformTags: {ol: sanitizeHtml.simpleTransform('ul', {class: 'foo'})}, allowedAttributes: { ul: ['class'] } }), '<ul class=\"foo\"><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul, left attributes foo and bar untouched, remove baz attribute and add class attributte with foo value', function() {\n    assert.equal(sanitizeHtml('<ol foo=\"foo\" bar=\"bar\" baz=\"baz\"><li>Hello world</li></ol>', { transformTags: {ol: sanitizeHtml.simpleTransform('ul', {class: 'foo'})}, allowedAttributes: { ul: ['foo', 'bar', 'class'] } }), '<ul foo=\"foo\" bar=\"bar\" class=\"foo\"><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul and replace all attributes to class attribute with foo value', function() {\n    assert.equal(sanitizeHtml('<ol foo=\"foo\" bar=\"bar\" baz=\"baz\"><li>Hello world</li></ol>', { transformTags: {ol: sanitizeHtml.simpleTransform('ul', {class: 'foo'}, false)}, allowedAttributes: { ul: ['foo', 'bar', 'class'] } }), '<ul class=\"foo\"><li>Hello world</li></ul>');\n  });\n  it('should replace ol to ul and add attribute class with foo value and attribute bar with bar value', function() {\n    assert.equal(sanitizeHtml('<ol><li>Hello world</li></ol>', { transformTags: {ol: function(tagName, attribs){\n      attribs.class = 'foo';\n      attribs.bar = 'bar';\n      return {\n        tagName: 'ul',\n        attribs: attribs\n      }\n    }}, allowedAttributes: { ul: ['bar', 'class'] } }), '<ul class=\"foo\" bar=\"bar\"><li>Hello world</li></ul>');\n  });\n\n  it('should replace text and attributes when they are changed by transforming function', function () {\n    assert.equal(sanitizeHtml('<a href=\"http://somelink\">some text</a>', { transformTags: {a: function (tagName, attribs) {\n      return {\n        tagName: tagName,\n        attribs: attribs,\n        text: ''\n      }\n    }}}), '<a href=\"http://somelink\"></a>');\n  });\n  it('should replace text and attributes when they are changed by transforming function and textFilter is set', function () {\n    assert.equal(sanitizeHtml('<a href=\"http://somelink\">some text</a>', { transformTags: {a: function (tagName, attribs) {\n      return {\n        tagName: tagName,\n        attribs: attribs,\n        text: 'some text need\"to<be>filtered'\n      }\n    }}, textFilter: function (text) {\n      return text.replace(/\\s/g, '_');\n    }}), '<a href=\"http://somelink\">some_text_need&quot;to&lt;be&gt;filtered</a>');\n  });\n\n  it('should skip an empty link', function() {\n     assert.strictEqual(\n     sanitizeHtml('<p>This is <a href=\"http://www.linux.org\"></a><br/>Linux</p>', {\n             exclusiveFilter: function (frame) {\n                 return frame.tag === 'a' && !frame.text.trim();\n             }\n         }),\n         '<p>This is <br />Linux</p>'\n        );\n    });\n\n    it(\"Should expose a node's inner text and inner HTML to the filter\", function() {\n        assert.strictEqual(\n            sanitizeHtml('<p>12<a href=\"http://www.linux.org\"><br/>3<br></a><span>4</span></p>', {\n                exclusiveFilter : function(frame) {\n                    if (frame.tag === 'p') {\n                        assert.strictEqual(frame.text, '124');\n                    } else if (frame.tag === 'a') {\n                        assert.strictEqual(frame.text, '3');\n                        return true;\n                    } else if (frame.tag === 'br') {\n                        assert.strictEqual(frame.text, '');\n                    } else {\n                        assert.fail('p, a, br', frame.tag);\n                    }\n                    return false;\n                }\n            }),\n            '<p>124</p>'\n        );\n    });\n\n  it('Should collapse nested empty elements', function() {\n        assert.strictEqual(\n            sanitizeHtml('<p><a href=\"http://www.linux.org\"><br/></a></p>', {\n                    exclusiveFilter : function(frame) {\n                        return (frame.tag === 'a' || frame.tag === 'p' ) && !frame.text.trim();\n                    }\n                }),\n            ''\n        );\n  });\n  it('Exclusive filter should not affect elements which do not match the filter condition', function () {\n      assert.strictEqual(\n          sanitizeHtml('I love <a href=\"www.linux.org\" target=\"_hplink\">Linux</a> OS',\n              {\n                  exclusiveFilter: function (frame) {\n                      return (frame.tag === 'a') && !frame.text.trim();\n                  }\n              }),\n          'I love <a href=\"www.linux.org\" target=\"_hplink\">Linux</a> OS'\n      );\n  });\n  it('should disallow data URLs with default allowedSchemes', function() {\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n        {\n          allowedTags: [ 'img' ]\n        }\n      ),\n      '<img />'\n    );\n  });\n  it('should allow data URLs with custom allowedSchemes', function() {\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />',\n        {\n          allowedTags: [ 'img', 'p' ],\n          allowedSchemes: [ 'data', 'http' ]\n        }\n      ),\n      '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" />'\n    );\n  });\n  it('should allow specific classes when whitelisted with allowedClasses', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<p class=\"nifty simple dippy\">whee</p>',\n        {\n          allowedTags: [ 'p' ],\n          allowedClasses: {\n            p: [ 'nifty' ]\n          }\n        }\n      ),\n      '<p class=\"nifty\">whee</p>'\n    );\n  });\n  it('should allow defining schemes on a per-tag basis', function() {\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" /><a href=\"https://www.example.com\"></a>',\n        {\n          allowedTags: ['img', 'a'],\n          allowedSchemes: ['http'],\n          allowedSchemesByTag: {\n            img: ['data'],\n            a: ['https']\n          }\n        }\n      ),\n      '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" /><a href=\"https://www.example.com\"></a>'\n    );\n    assert.equal(\n      sanitizeHtml(\n        // teeny-tiny valid transparent GIF in a data URL\n        '<img src=\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" /><a href=\"https://www.example.com\"></a>',\n        {\n          allowedTags: ['img', 'a'],\n          allowedSchemes: ['http'],\n          allowedSchemesByTag: {\n            img: [],\n            a: ['https']\n          }\n        }\n      ),\n      '<img /><a href=\"https://www.example.com\"></a>'\n    );\n  });\n  it('should not act weird when the class attribute is empty', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<p class=\"\">whee</p>',\n        {\n          allowedTags: [ 'p' ],\n          allowedClasses: {\n            p: [ 'nifty' ]\n          }\n        }\n      ),\n      '<p>whee</p>'\n    );\n  });\n  it('should not crash on bad markup', function() {\n    assert.equal(\n      sanitizeHtml(\n        \"<p a\"\n      ),\n      ''\n    );\n  });\n  it('should not allow a naked = sign followed by an unrelated attribute to result in one merged attribute with unescaped double quote marks', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<IMG SRC= onmouseover=\"alert(\\'XSS\\');\">',\n        {\n          allowedTags: [ 'img' ],\n          allowedAttributes: {\n            img: [ 'src' ]\n          }\n        }\n      ),\n      // This is weird but not dangerous. Without the &quot there\n      // would probably be some way to make it come out as a\n      // separate attribute\n      '<img src=\"onmouseover=&quot;alert(\\'XSS\\');&quot;\" />'\n    );\n  });\n  it('should allow only whitelisted attributes, but to any tags, if tag is declared as  \"*\"', function() {\n    assert.equal(\n        sanitizeHtml(\n            '<table bgcolor=\"1\" align=\"left\" notlisted=\"0\"><img src=\"1.gif\" align=\"center\" alt=\"not listed too\"/></table>',\n            {\n              allowedTags: [ 'table', 'img' ],\n              allowedAttributes: {\n                '*': [ 'bgcolor', 'align', 'src' ]\n              }\n            }\n        ),\n        '<table bgcolor=\"1\" align=\"left\"><img src=\"1.gif\" align=\"center\" /></table>'\n    );\n  });\n  it('should not filter if exclusive filter does not match after transforming tags', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<a href=\"test.html\">test</a>',\n        {\n          allowedTags: [ 'a' ],\n          allowedAttributes: { a: ['href', 'target']},\n          transformTags: {\n            'a': function (tagName, attribs) {\n              if (!attribs.href)\n                return false;\n              return {\n                tagName: tagName,\n                attribs: {\n                  target: '_blank',\n                  href: attribs.href\n                }\n              };\n            }\n          },\n          exclusiveFilter: function(frame) {\n            return frame.tag === 'a' && frame.text.trim() == 'blah';\n          }\n        }\n      ),\n      '<a target=\"_blank\" href=\"test.html\">test</a>'\n    )\n  });\n  it('should filter if exclusive filter does match after transforming tags', function() {\n    assert.equal(\n      sanitizeHtml(\n        '<a href=\"test.html\">blah</a>',\n        {\n          allowedTags: [ 'a' ],\n          allowedAttributes: {a: ['href', 'target']},\n          transformTags: {\n            'a': function (tagName, attribs) {\n              if (!attribs.href)\n                return false;\n              return {\n                tagName: tagName,\n                attribs: {\n                  target: '_blank',\n                  href: attribs.href\n                }\n              };\n            }\n          },\n          exclusiveFilter: function(frame) {\n            return frame.tag === 'a' && frame.text.trim() == 'blah';\n          }\n        }\n      ),\n      ''\n    );\n  });\n  it('should allow transform on all tags using \\'*\\'', function () {\n    assert.equal(\n      sanitizeHtml(\n        '<p>Text</p>',\n        {\n          allowedTags: [ 'p' ],\n          allowedAttributes: {p: ['style']},\n          transformTags: {\n            '*': function (tagName, attribs) {\n              return {\n                tagName: tagName,\n                attribs: {\n                  style: 'text-align: center;'\n                }\n              };\n            }\n          }\n        }\n      ),\n      '<p style=\"text-align: center;\">Text</p>'\n    );\n  });\n  it('should not be faked out by double <', function() {\n    assert.equal(\n      sanitizeHtml('<<img src=\"javascript:evil\"/>img src=\"javascript:evil\"/>'\n      ),\n      '&lt;img src=&quot;javascript:evil&quot;/&gt;'\n    );\n    assert.equal(\n      sanitizeHtml('<<a href=\"javascript:evil\"/>a href=\"javascript:evil\"/>'\n      ),\n      '&lt;<a>a href=&quot;javascript:evil&quot;/&gt;</a>'\n    );\n  });\n  it('should allow attributes to be specified as globs', function() {\n    assert.equal(\n      sanitizeHtml('<a data-target=\"#test\" data-foo=\"hello\">click me</a>', {\n        allowedTags: [ 'a' ],\n        allowedAttributes: { a: ['data-*'] }\n      }), '<a data-target=\"#test\" data-foo=\"hello\">click me</a>'\n    );\n    assert.equal(\n      sanitizeHtml('<a data-target=\"#test\" data-my-foo=\"hello\">click me</a>', {\n        allowedTags: [ 'a' ],\n        allowedAttributes: { a: ['data-*-foo'] }\n      }), '<a data-my-foo=\"hello\">click me</a>'\n    );\n  });\n  it('should quote regex chars in attributes specified as globs', function() {\n    assert.equal(\n      sanitizeHtml('<a data-b.c=\"#test\" data-bcc=\"remove this\">click me</a>', {\n        allowedTags: [ 'a' ],\n        allowedAttributes: { a: ['data-b.*'] }\n      }), '<a data-b.c=\"#test\">click me</a>'\n    );\n  });\n  it('should not escape inner content of script and style tags (when allowed)', function() {\n    assert.equal(\n      sanitizeHtml('<div>\"normal text\"</div><script>\"this is code\"</script>', {\n        allowedTags: [ 'script' ]\n      }), '&quot;normal text&quot;<script>\"this is code\"</script>'\n    );\n    assert.equal(\n      sanitizeHtml('<div>\"normal text\"</div><style>body { background-image: url(\"image.test\"); }</style>', {\n        allowedTags: [ 'style' ]\n      }), '&quot;normal text&quot;<style>body { background-image: url(\"image.test\"); }</style>'\n    );\n  });\n  it('should not unescape escapes found inside script tags', function() {\n    assert.equal(\n      sanitizeHtml('<script>alert(\"&quot;This is cool but just ironically so I quoted it&quot;\")</script>',\n        {\n          allowedTags: [ 'script' ]\n        }\n      ),\n      '<script>alert(\"&quot;This is cool but just ironically so I quoted it&quot;\")</script>'\n    )\n  });\n  it('should process text nodes with provided function', function() {\n    assert.equal(\n      sanitizeHtml('\"normal text this should be removed\"', {\n        textFilter: function(text) {\n          return text.replace(' this should be removed', '');\n        }\n      }), '&quot;normal text&quot;'\n    );\n  });\n  it('should respect htmlparser2 options when passed in', function() {\n    assert.equal(\n      sanitizeHtml(\"<Archer><Sterling>I am</Sterling></Archer>\", {\n        allowedTags: false,\n        allowedAttributes: false,\n      }),\n      \"<archer><sterling>I am</sterling></archer>\"\n    );\n    assert.equal(\n      sanitizeHtml(\"<Archer><Sterling>I am</Sterling></Archer>\", {\n        allowedTags: false,\n        allowedAttributes: false,\n        parser: {\n          lowerCaseTags: false\n        }\n      }),\n      \"<Archer><Sterling>I am</Sterling></Archer>\"\n    );\n  });\n  it('should not crash due to tag names that are properties of the universal Object prototype', function() {\n    assert.equal(\n      sanitizeHtml(\"!<__proto__>!\"),\n    \"!!\");\n  });\n  it('should correctly maintain escaping when allowing a nonTextTags tag other than script or style', function() {\n    assert.equal(\n      sanitizeHtml('!<textarea>&lt;/textarea&gt;&lt;svg/onload=prompt`xs`&gt;</textarea>!',\n        { allowedTags: [ 'textarea' ] }\n      ), '!<textarea>&lt;/textarea&gt;&lt;svg/onload=prompt`xs`&gt;</textarea>!'\n    );\n  });\n});\n"], "filenames": ["README.md", "index.js", "test/test.js"], "buggy_code_start_loc": [11, 208, 436], "buggy_code_end_loc": [301, 209, 480], "fixing_code_start_loc": [11, 208, 436], "fixing_code_end_loc": [306, 213, 498], "type": "CWE-79", "message": "Sanitize-html is a library for scrubbing html input of malicious values. Versions 1.11.1 and below are vulnerable to cross site scripting (XSS) in certain scenarios: If allowed at least one nonTextTags, the result is a potential XSS vulnerability.", "other": {"cve": {"id": "CVE-2017-16016", "sourceIdentifier": "support@hackerone.com", "published": "2018-06-04T19:29:01.023", "lastModified": "2019-10-09T23:24:36.610", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sanitize-html is a library for scrubbing html input of malicious values. Versions 1.11.1 and below are vulnerable to cross site scripting (XSS) in certain scenarios: If allowed at least one nonTextTags, the result is a potential XSS vulnerability."}, {"lang": "es", "value": "Sanitize-html es una biblioteca para limpiar entradas html de valores maliciosos. Las versiones 1.11.1 y anteriores son vulnerables a Cross-Site Scripting (XSS) en ciertos escenarios: si se permite al menos un nonTextTags, el resultado es una vulnerabilidad potencial de XSS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:punkave:sanitize-html:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "1.11.1", "matchCriteriaId": "9C288C74-9CFE-4A0B-9526-D7ADE59D849E"}]}]}], "references": [{"url": "https://github.com/punkave/sanitize-html/commit/5d205a1005ba0df80e21d8c64a15bb3accdb2403", "source": "support@hackerone.com", "tags": ["Patch"]}, {"url": "https://github.com/punkave/sanitize-html/issues/100", "source": "support@hackerone.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/154", "source": "support@hackerone.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/punkave/sanitize-html/commit/5d205a1005ba0df80e21d8c64a15bb3accdb2403"}}