{"buggy_code": ["/*\n *   IRC - Internet Relay Chat, src/modules/m_sasl.c\n *   (C) 2012 The UnrealIRCd Team\n *\n *   See file AUTHORS in IRC package for additional names of\n *   the programmers.\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 1, or (at your option)\n *   any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include \"unrealircd.h\"\n\n#define MSG_AUTHENTICATE \"AUTHENTICATE\"\n\n#define MSG_SASL \"SASL\"\n\n#define MSG_SVSLOGIN \"SVSLOGIN\"\n\n/* returns a server identifier given agent_p */\n#define AGENT_SID(agent_p)\t(agent_p->user != NULL ? agent_p->user->server : agent_p->name)\n\nModuleHeader MOD_HEADER(m_sasl)\n  = {\n\t\"m_sasl\",\n\t\"4.0\",\n\t\"SASL\", \n\t\"3.2-b8-1\",\n\tNULL \n    };\n\n/*\n * This is a \"lightweight\" SASL implementation/stack which uses psuedo-identifiers\n * to identify connecting clients.  In Unreal 3.3, we should use real identifiers\n * so that SASL sessions can be correlated.\n *\n * The following people were involved in making the current iteration of SASL over\n * IRC which allowed psuedo-identifiers:\n *\n * danieldg, Daniel de Graff <danieldg@inspircd.org>\n * jilles, Jilles Tjoelker <jilles@stack.nl>\n * Jobe, Matthew Beeching <jobe@mdbnet.co.uk>\n * gxti, Michael Tharp <gxti@partiallystapled.com>\n * nenolod, William Pitcock <nenolod@dereferenced.org>\n *\n * Thanks also to all of the client authors which have implemented SASL in their\n * clients.  With the backwards-compatibility layer allowing \"lightweight\" SASL\n * implementations, we now truly have a universal authentication mechanism for\n * IRC.\n */\n\n/*\n * decode_puid\n *\n * Decode PUID sent from a SASL agent.  If the servername in the PUID doesn't match\n * ours, we reject the PUID (by returning NULL).\n */\nstatic aClient *decode_puid(char *puid)\n{\n\taClient *cptr;\n\tchar *it, *it2;\n\tint cookie = 0;\n\n\tif ((it = strrchr(puid, '!')) == NULL)\n\t\treturn NULL;\n\n\t*it++ = '\\0';\n\n\tif ((it2 = strrchr(it, '.')) != NULL)\n\t{\n\t\t*it2++ = '\\0';\n\t\tcookie = atoi(it2);\n\t}\n\n\tif (stricmp(me.name, puid))\n\t\treturn NULL;\n\n\tlist_for_each_entry(cptr, &unknown_list, lclient_node)\n\t\tif (cptr->local->sasl_cookie == cookie)\n\t\t\treturn cptr;\n\n\treturn NULL;\n}\n\n/*\n * encode_puid\n *\n * Encode PUID based on aClient.\n */\nstatic const char *encode_puid(aClient *client)\n{\n\tstatic char buf[HOSTLEN + 20];\n\n\t/* create a cookie if necessary (and in case getrandom16 returns 0, then run again) */\n\twhile (!client->local->sasl_cookie)\n\t\tclient->local->sasl_cookie = getrandom16();\n\n\tsnprintf(buf, sizeof buf, \"%s!0.%d\", me.name, client->local->sasl_cookie);\n\n\treturn buf;\n}\n\n/*\n * SVSLOGIN message\n *\n * parv[1]: propagation mask\n * parv[2]: target PUID\n * parv[3]: ESVID\n */\nCMD_FUNC(m_svslogin)\n{\n\tif (!SASL_SERVER || MyClient(sptr) || (parc < 3) || !parv[3])\n\t\treturn 0;\n\n\tif (!stricmp(parv[1], me.name))\n\t{\n\t\taClient *target_p;\n\n\t\t/* is the PUID valid? */\n\t\tif ((target_p = decode_puid(parv[2])) == NULL)\n\t\t\treturn 0;\n\n\t\tif (target_p->user == NULL)\n\t\t\tmake_user(target_p);\n\n\t\tstrlcpy(target_p->user->svid, parv[3], sizeof(target_p->user->svid));\n\n\t\tsendto_one(target_p, err_str(RPL_LOGGEDIN), me.name,\n\t\t\t   BadPtr(target_p->name) ? \"*\" : target_p->name,\n\t\t\t   BadPtr(target_p->name) ? \"*\" : target_p->name,\n\t\t\t   BadPtr(target_p->user->username) ? \"*\" : target_p->user->username,\n\t\t\t   BadPtr(target_p->user->realhost) ? \"*\" : target_p->user->realhost,\n\t\t\t   target_p->user->svid, target_p->user->svid);\n\n\t\treturn 0;\n\t}\n\n\t/* not for us; propagate. */\n\tsendto_server(cptr, 0, 0, \":%s SVSLOGIN %s %s %s\",\n\t    sptr->name, parv[1], parv[2], parv[3]);\n\n\treturn 0;\n}\n\n/*\n * SASL message\n *\n * parv[1]: distribution mask\n * parv[2]: target PUID\n * parv[3]: mode/state\n * parv[4]: data\n * parv[5]: out-of-bound data\n */\nCMD_FUNC(m_sasl)\n{\n\tif (!SASL_SERVER || MyClient(sptr) || (parc < 4) || !parv[4])\n\t\treturn 0;\n\n\tif (!stricmp(parv[1], me.name))\n\t{\n\t\taClient *target_p;\n\n\t\t/* is the PUID valid? */\n\t\tif ((target_p = decode_puid(parv[2])) == NULL)\n\t\t\treturn 0;\n\n\t\tif (target_p->user == NULL)\n\t\t\tmake_user(target_p);\n\n\t\t/* reject if another SASL agent is answering */\n\t\tif (*target_p->local->sasl_agent && stricmp(sptr->name, target_p->local->sasl_agent))\n\t\t\treturn 0;\n\t\telse\n\t\t\tstrlcpy(target_p->local->sasl_agent, sptr->name, sizeof(target_p->local->sasl_agent));\n\n\t\tif (*parv[3] == 'C')\n\t\t\tsendto_one(target_p, \"AUTHENTICATE %s\", parv[4]);\n\t\telse if (*parv[3] == 'D')\n\t\t{\n\t\t\tif (*parv[4] == 'F')\n\t\t\t\tsendto_one(target_p, err_str(ERR_SASLFAIL), me.name, BadPtr(target_p->name) ? \"*\" : target_p->name);\n\t\t\telse if (*parv[4] == 'S')\n\t\t\t{\n\t\t\t\ttarget_p->local->sasl_complete++;\n\t\t\t\tsendto_one(target_p, err_str(RPL_SASLSUCCESS), me.name, BadPtr(target_p->name) ? \"*\" : target_p->name);\n\t\t\t}\n\n\t\t\t*target_p->local->sasl_agent = '\\0';\n\t\t}\n\t\telse if (*parv[3] == 'M')\n\t\t\tsendto_one(target_p, err_str(RPL_SASLMECHS), me.name, BadPtr(target_p->name) ? \"*\" : target_p->name, parv[4]);\n\n\t\treturn 0;\n\t}\n\n\t/* not for us; propagate. */\n\tsendto_server(cptr, 0, 0, \":%s SASL %s %s %c %s %s\",\n\t    sptr->name, parv[1], parv[2], *parv[3], parv[4], parc > 5 ? parv[5] : \"\");\n\n\treturn 0;\n}\n\n/*\n * AUTHENTICATE message\n *\n * parv[1]: data\n */\nCMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\n\t/* Failing to use CAP REQ for sasl is a protocol violation. */\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\n\tsptr->local->sasl_out++;\n\n\treturn 0;\n}\n\nstatic int abort_sasl(aClient *cptr)\n{\n\tif (cptr->local->sasl_out == 0 || cptr->local->sasl_complete)\n\t\treturn 0;\n\n\tcptr->local->sasl_out = cptr->local->sasl_complete = 0;\n\tsendto_one(cptr, err_str(ERR_SASLABORTED), me.name, BadPtr(cptr->name) ? \"*\" : cptr->name);\n\n\tif (*cptr->local->sasl_agent)\n\t{\n\t\taClient *agent_p = find_client(cptr->local->sasl_agent, NULL);\n\n\t\tif (agent_p != NULL)\n\t\t{\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s D A\",\n\t\t\t    me.name, AGENT_SID(agent_p), encode_puid(cptr));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsendto_server(NULL, 0, 0, \":%s SASL * %s D A\", me.name, encode_puid(cptr));\n\treturn 0;\n}\n\nint sasl_capability_visible(void)\n{\n\tif (!SASL_SERVER || !find_server(SASL_SERVER, NULL))\n\t\treturn 0;\n\t\n\treturn 1;\n}\n\nint sasl_connect(aClient *sptr)\n{\n\treturn abort_sasl(sptr);\n}\n\nint sasl_quit(aClient *sptr, char *comment)\n{\n\treturn abort_sasl(sptr);\n}\n\nMOD_INIT(m_sasl)\n{\n\tClientCapability cap;\n\t\n\tMARK_AS_OFFICIAL_MODULE(modinfo);\n\n\tCommandAdd(modinfo->handle, MSG_SASL, m_sasl, MAXPARA, M_USER|M_SERVER);\n\tCommandAdd(modinfo->handle, MSG_SVSLOGIN, m_svslogin, MAXPARA, M_USER|M_SERVER);\n\tCommandAdd(modinfo->handle, MSG_AUTHENTICATE, m_authenticate, MAXPARA, M_UNREGISTERED);\n\n\tHookAdd(modinfo->handle, HOOKTYPE_LOCAL_CONNECT, 0, sasl_connect);\n\tHookAdd(modinfo->handle, HOOKTYPE_LOCAL_QUIT, 0, sasl_quit);\n\n\tmemset(&cap, 0, sizeof(cap));\n\tcap.name = \"sasl\";\n\tcap.cap = PROTO_SASL;\n\tcap.visible = sasl_capability_visible;\n\tClientCapabilityAdd(modinfo->handle, &cap);\n\n\treturn MOD_SUCCESS;\n}\n\nMOD_LOAD(m_sasl)\n{\n\treturn MOD_SUCCESS;\n}\n\nMOD_UNLOAD(m_sasl)\n{\n\treturn MOD_SUCCESS;\n}\n"], "fixing_code": ["/*\n *   IRC - Internet Relay Chat, src/modules/m_sasl.c\n *   (C) 2012 The UnrealIRCd Team\n *\n *   See file AUTHORS in IRC package for additional names of\n *   the programmers.\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 1, or (at your option)\n *   any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include \"unrealircd.h\"\n\n#define MSG_AUTHENTICATE \"AUTHENTICATE\"\n\n#define MSG_SASL \"SASL\"\n\n#define MSG_SVSLOGIN \"SVSLOGIN\"\n\n/* returns a server identifier given agent_p */\n#define AGENT_SID(agent_p)\t(agent_p->user != NULL ? agent_p->user->server : agent_p->name)\n\nModuleHeader MOD_HEADER(m_sasl)\n  = {\n\t\"m_sasl\",\n\t\"4.0\",\n\t\"SASL\", \n\t\"3.2-b8-1\",\n\tNULL \n    };\n\n/*\n * This is a \"lightweight\" SASL implementation/stack which uses psuedo-identifiers\n * to identify connecting clients.  In Unreal 3.3, we should use real identifiers\n * so that SASL sessions can be correlated.\n *\n * The following people were involved in making the current iteration of SASL over\n * IRC which allowed psuedo-identifiers:\n *\n * danieldg, Daniel de Graff <danieldg@inspircd.org>\n * jilles, Jilles Tjoelker <jilles@stack.nl>\n * Jobe, Matthew Beeching <jobe@mdbnet.co.uk>\n * gxti, Michael Tharp <gxti@partiallystapled.com>\n * nenolod, William Pitcock <nenolod@dereferenced.org>\n *\n * Thanks also to all of the client authors which have implemented SASL in their\n * clients.  With the backwards-compatibility layer allowing \"lightweight\" SASL\n * implementations, we now truly have a universal authentication mechanism for\n * IRC.\n */\n\n/*\n * decode_puid\n *\n * Decode PUID sent from a SASL agent.  If the servername in the PUID doesn't match\n * ours, we reject the PUID (by returning NULL).\n */\nstatic aClient *decode_puid(char *puid)\n{\n\taClient *cptr;\n\tchar *it, *it2;\n\tint cookie = 0;\n\n\tif ((it = strrchr(puid, '!')) == NULL)\n\t\treturn NULL;\n\n\t*it++ = '\\0';\n\n\tif ((it2 = strrchr(it, '.')) != NULL)\n\t{\n\t\t*it2++ = '\\0';\n\t\tcookie = atoi(it2);\n\t}\n\n\tif (stricmp(me.name, puid))\n\t\treturn NULL;\n\n\tlist_for_each_entry(cptr, &unknown_list, lclient_node)\n\t\tif (cptr->local->sasl_cookie == cookie)\n\t\t\treturn cptr;\n\n\treturn NULL;\n}\n\n/*\n * encode_puid\n *\n * Encode PUID based on aClient.\n */\nstatic const char *encode_puid(aClient *client)\n{\n\tstatic char buf[HOSTLEN + 20];\n\n\t/* create a cookie if necessary (and in case getrandom16 returns 0, then run again) */\n\twhile (!client->local->sasl_cookie)\n\t\tclient->local->sasl_cookie = getrandom16();\n\n\tsnprintf(buf, sizeof buf, \"%s!0.%d\", me.name, client->local->sasl_cookie);\n\n\treturn buf;\n}\n\n/*\n * SVSLOGIN message\n *\n * parv[1]: propagation mask\n * parv[2]: target PUID\n * parv[3]: ESVID\n */\nCMD_FUNC(m_svslogin)\n{\n\tif (!SASL_SERVER || MyClient(sptr) || (parc < 3) || !parv[3])\n\t\treturn 0;\n\n\tif (!stricmp(parv[1], me.name))\n\t{\n\t\taClient *target_p;\n\n\t\t/* is the PUID valid? */\n\t\tif ((target_p = decode_puid(parv[2])) == NULL)\n\t\t\treturn 0;\n\n\t\tif (target_p->user == NULL)\n\t\t\tmake_user(target_p);\n\n\t\tstrlcpy(target_p->user->svid, parv[3], sizeof(target_p->user->svid));\n\n\t\tsendto_one(target_p, err_str(RPL_LOGGEDIN), me.name,\n\t\t\t   BadPtr(target_p->name) ? \"*\" : target_p->name,\n\t\t\t   BadPtr(target_p->name) ? \"*\" : target_p->name,\n\t\t\t   BadPtr(target_p->user->username) ? \"*\" : target_p->user->username,\n\t\t\t   BadPtr(target_p->user->realhost) ? \"*\" : target_p->user->realhost,\n\t\t\t   target_p->user->svid, target_p->user->svid);\n\n\t\treturn 0;\n\t}\n\n\t/* not for us; propagate. */\n\tsendto_server(cptr, 0, 0, \":%s SVSLOGIN %s %s %s\",\n\t    sptr->name, parv[1], parv[2], parv[3]);\n\n\treturn 0;\n}\n\n/*\n * SASL message\n *\n * parv[1]: distribution mask\n * parv[2]: target PUID\n * parv[3]: mode/state\n * parv[4]: data\n * parv[5]: out-of-bound data\n */\nCMD_FUNC(m_sasl)\n{\n\tif (!SASL_SERVER || MyClient(sptr) || (parc < 4) || !parv[4])\n\t\treturn 0;\n\n\tif (!stricmp(parv[1], me.name))\n\t{\n\t\taClient *target_p;\n\n\t\t/* is the PUID valid? */\n\t\tif ((target_p = decode_puid(parv[2])) == NULL)\n\t\t\treturn 0;\n\n\t\tif (target_p->user == NULL)\n\t\t\tmake_user(target_p);\n\n\t\t/* reject if another SASL agent is answering */\n\t\tif (*target_p->local->sasl_agent && stricmp(sptr->name, target_p->local->sasl_agent))\n\t\t\treturn 0;\n\t\telse\n\t\t\tstrlcpy(target_p->local->sasl_agent, sptr->name, sizeof(target_p->local->sasl_agent));\n\n\t\tif (*parv[3] == 'C')\n\t\t\tsendto_one(target_p, \"AUTHENTICATE %s\", parv[4]);\n\t\telse if (*parv[3] == 'D')\n\t\t{\n\t\t\tif (*parv[4] == 'F')\n\t\t\t\tsendto_one(target_p, err_str(ERR_SASLFAIL), me.name, BadPtr(target_p->name) ? \"*\" : target_p->name);\n\t\t\telse if (*parv[4] == 'S')\n\t\t\t{\n\t\t\t\ttarget_p->local->sasl_complete++;\n\t\t\t\tsendto_one(target_p, err_str(RPL_SASLSUCCESS), me.name, BadPtr(target_p->name) ? \"*\" : target_p->name);\n\t\t\t}\n\n\t\t\t*target_p->local->sasl_agent = '\\0';\n\t\t}\n\t\telse if (*parv[3] == 'M')\n\t\t\tsendto_one(target_p, err_str(RPL_SASLMECHS), me.name, BadPtr(target_p->name) ? \"*\" : target_p->name, parv[4]);\n\n\t\treturn 0;\n\t}\n\n\t/* not for us; propagate. */\n\tsendto_server(cptr, 0, 0, \":%s SASL %s %s %c %s %s\",\n\t    sptr->name, parv[1], parv[2], *parv[3], parv[4], parc > 5 ? parv[5] : \"\");\n\n\treturn 0;\n}\n\n/*\n * AUTHENTICATE message\n *\n * parv[1]: data\n */\nCMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\n\t/* Failing to use CAP REQ for sasl is a protocol violation. */\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n\t{\n\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");\n\t\treturn 0;\n\t}\n\n\tif (strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\n\tsptr->local->sasl_out++;\n\n\treturn 0;\n}\n\nstatic int abort_sasl(aClient *cptr)\n{\n\tif (cptr->local->sasl_out == 0 || cptr->local->sasl_complete)\n\t\treturn 0;\n\n\tcptr->local->sasl_out = cptr->local->sasl_complete = 0;\n\tsendto_one(cptr, err_str(ERR_SASLABORTED), me.name, BadPtr(cptr->name) ? \"*\" : cptr->name);\n\n\tif (*cptr->local->sasl_agent)\n\t{\n\t\taClient *agent_p = find_client(cptr->local->sasl_agent, NULL);\n\n\t\tif (agent_p != NULL)\n\t\t{\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s D A\",\n\t\t\t    me.name, AGENT_SID(agent_p), encode_puid(cptr));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsendto_server(NULL, 0, 0, \":%s SASL * %s D A\", me.name, encode_puid(cptr));\n\treturn 0;\n}\n\nint sasl_capability_visible(void)\n{\n\tif (!SASL_SERVER || !find_server(SASL_SERVER, NULL))\n\t\treturn 0;\n\t\n\treturn 1;\n}\n\nint sasl_connect(aClient *sptr)\n{\n\treturn abort_sasl(sptr);\n}\n\nint sasl_quit(aClient *sptr, char *comment)\n{\n\treturn abort_sasl(sptr);\n}\n\nMOD_INIT(m_sasl)\n{\n\tClientCapability cap;\n\t\n\tMARK_AS_OFFICIAL_MODULE(modinfo);\n\n\tCommandAdd(modinfo->handle, MSG_SASL, m_sasl, MAXPARA, M_USER|M_SERVER);\n\tCommandAdd(modinfo->handle, MSG_SVSLOGIN, m_svslogin, MAXPARA, M_USER|M_SERVER);\n\tCommandAdd(modinfo->handle, MSG_AUTHENTICATE, m_authenticate, MAXPARA, M_UNREGISTERED);\n\n\tHookAdd(modinfo->handle, HOOKTYPE_LOCAL_CONNECT, 0, sasl_connect);\n\tHookAdd(modinfo->handle, HOOKTYPE_LOCAL_QUIT, 0, sasl_quit);\n\n\tmemset(&cap, 0, sizeof(cap));\n\tcap.name = \"sasl\";\n\tcap.cap = PROTO_SASL;\n\tcap.visible = sasl_capability_visible;\n\tClientCapabilityAdd(modinfo->handle, &cap);\n\n\treturn MOD_SUCCESS;\n}\n\nMOD_LOAD(m_sasl)\n{\n\treturn MOD_SUCCESS;\n}\n\nMOD_UNLOAD(m_sasl)\n{\n\treturn MOD_SUCCESS;\n}\n"], "filenames": ["src/modules/m_sasl.c"], "buggy_code_start_loc": [232], "buggy_code_end_loc": [232], "fixing_code_start_loc": [233], "fixing_code_end_loc": [239], "type": "CWE-287", "message": "The m_authenticate function in modules/m_sasl.c in UnrealIRCd before 3.2.10.7 and 4.x before 4.0.6 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.", "other": {"cve": {"id": "CVE-2016-7144", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-18T17:59:00.560", "lastModified": "2017-01-20T15:12:43.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The m_authenticate function in modules/m_sasl.c in UnrealIRCd before 3.2.10.7 and 4.x before 4.0.6 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter."}, {"lang": "es", "value": "La funci\u00f3n m_authenticate en modules/m_sasl.c en UnrealIRCd en versiones anteriores a 3.2.10.7 y 4.x en versiones anteriores a 4.0.6 permite a atacantes remotos suplantar huellas dactilares de certificados y consecuentemente iniciar sesi\u00f3n como otro usuario a trav\u00e9s de un par\u00e1metro AUTHENTICATE manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.10.5", "matchCriteriaId": "E36F4B9A-FE00-4254-AE01-988C5E3563DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "EEEACFAE-0672-465C-B36A-2511CD8F7D2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "78ABEC11-ACFD-49CD-BA6A-041EAE20FCCC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "7E776FF2-D9CC-468E-9505-8BAA042B070A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "C4C6CA34-F564-4F19-AADB-D54595BA3BE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "A89C6801-3E03-426E-A034-1DBC06998F9A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "C229E849-C99A-48C3-A00A-67A714904F1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:unrealircd:unrealircd:4.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "CB89D241-E224-45B9-8B77-B5FA3C955099"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/04/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/05/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92763", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://forums.unrealircd.org/viewtopic.php?f=1&t=8588", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/unrealircd/unrealircd/commit/f473e355e1dc422c4f019dbf86bc50ba1a34a766", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/unrealircd/unrealircd/commit/f473e355e1dc422c4f019dbf86bc50ba1a34a766"}}