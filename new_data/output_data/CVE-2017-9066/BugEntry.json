{"buggy_code": ["<?php\n/**\n * HTTP API: WP_Http class\n *\n * @package WordPress\n * @subpackage HTTP\n * @since 2.7.0\n */\n\nif ( ! class_exists( 'Requests' ) ) {\n\trequire( ABSPATH . WPINC . '/class-requests.php' );\n\n\tRequests::register_autoloader();\n\tRequests::set_certificate_path( ABSPATH . WPINC . '/certificates/ca-bundle.crt' );\n}\n\n/**\n * Core class used for managing HTTP transports and making HTTP requests.\n *\n * This class is used to consistently make outgoing HTTP requests easy for developers\n * while still being compatible with the many PHP configurations under which\n * WordPress runs.\n *\n * Debugging includes several actions, which pass different variables for debugging the HTTP API.\n *\n * @since 2.7.0\n */\nclass WP_Http {\n\n\t// Aliases for HTTP response codes.\n\tconst HTTP_CONTINUE                   = 100;\n\tconst SWITCHING_PROTOCOLS             = 101;\n\tconst PROCESSING                      = 102;\n\n\tconst OK                              = 200;\n\tconst CREATED                         = 201;\n\tconst ACCEPTED                        = 202;\n\tconst NON_AUTHORITATIVE_INFORMATION   = 203;\n\tconst NO_CONTENT                      = 204;\n\tconst RESET_CONTENT                   = 205;\n\tconst PARTIAL_CONTENT                 = 206;\n\tconst MULTI_STATUS                    = 207;\n\tconst IM_USED                         = 226;\n\n\tconst MULTIPLE_CHOICES                = 300;\n\tconst MOVED_PERMANENTLY               = 301;\n\tconst FOUND                           = 302;\n\tconst SEE_OTHER                       = 303;\n\tconst NOT_MODIFIED                    = 304;\n\tconst USE_PROXY                       = 305;\n\tconst RESERVED                        = 306;\n\tconst TEMPORARY_REDIRECT              = 307;\n\tconst PERMANENT_REDIRECT              = 308;\n\n\tconst BAD_REQUEST                     = 400;\n\tconst UNAUTHORIZED                    = 401;\n\tconst PAYMENT_REQUIRED                = 402;\n\tconst FORBIDDEN                       = 403;\n\tconst NOT_FOUND                       = 404;\n\tconst METHOD_NOT_ALLOWED              = 405;\n\tconst NOT_ACCEPTABLE                  = 406;\n\tconst PROXY_AUTHENTICATION_REQUIRED   = 407;\n\tconst REQUEST_TIMEOUT                 = 408;\n\tconst CONFLICT                        = 409;\n\tconst GONE                            = 410;\n\tconst LENGTH_REQUIRED                 = 411;\n\tconst PRECONDITION_FAILED             = 412;\n\tconst REQUEST_ENTITY_TOO_LARGE        = 413;\n\tconst REQUEST_URI_TOO_LONG            = 414;\n\tconst UNSUPPORTED_MEDIA_TYPE          = 415;\n\tconst REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n\tconst EXPECTATION_FAILED              = 417;\n\tconst IM_A_TEAPOT                     = 418;\n\tconst MISDIRECTED_REQUEST             = 421;\n\tconst UNPROCESSABLE_ENTITY            = 422;\n\tconst LOCKED                          = 423;\n\tconst FAILED_DEPENDENCY               = 424;\n\tconst UPGRADE_REQUIRED                = 426;\n\tconst PRECONDITION_REQUIRED           = 428;\n\tconst TOO_MANY_REQUESTS               = 429;\n\tconst REQUEST_HEADER_FIELDS_TOO_LARGE = 431;\n\tconst UNAVAILABLE_FOR_LEGAL_REASONS   = 451;\n\n\tconst INTERNAL_SERVER_ERROR           = 500;\n\tconst NOT_IMPLEMENTED                 = 501;\n\tconst BAD_GATEWAY                     = 502;\n\tconst SERVICE_UNAVAILABLE             = 503;\n\tconst GATEWAY_TIMEOUT                 = 504;\n\tconst HTTP_VERSION_NOT_SUPPORTED      = 505;\n\tconst VARIANT_ALSO_NEGOTIATES         = 506;\n\tconst INSUFFICIENT_STORAGE            = 507;\n\tconst NOT_EXTENDED                    = 510;\n\tconst NETWORK_AUTHENTICATION_REQUIRED = 511;\n\n\t/**\n\t * Send an HTTP request to a URI.\n\t *\n\t * Please note: The only URI that are supported in the HTTP Transport implementation\n\t * are the HTTP and HTTPS protocols.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string       $url  The request URL.\n\t * @param string|array $args {\n\t *     Optional. Array or string of HTTP request arguments.\n\t *\n\t *     @type string       $method              Request method. Accepts 'GET', 'POST', 'HEAD', or 'PUT'.\n\t *                                             Some transports technically allow others, but should not be\n\t *                                             assumed. Default 'GET'.\n\t *     @type int          $timeout             How long the connection should stay open in seconds. Default 5.\n\t *     @type int          $redirection         Number of allowed redirects. Not supported by all transports\n\t *                                             Default 5.\n\t *     @type string       $httpversion         Version of the HTTP protocol to use. Accepts '1.0' and '1.1'.\n\t *                                             Default '1.0'.\n\t *     @type string       $user-agent          User-agent value sent.\n\t *                                             Default WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ).\n\t *     @type bool         $reject_unsafe_urls  Whether to pass URLs through wp_http_validate_url().\n\t *                                             Default false.\n\t *     @type bool         $blocking            Whether the calling code requires the result of the request.\n\t *                                             If set to false, the request will be sent to the remote server,\n\t *                                             and processing returned to the calling code immediately, the caller\n\t *                                             will know if the request succeeded or failed, but will not receive\n\t *                                             any response from the remote server. Default true.\n\t *     @type string|array $headers             Array or string of headers to send with the request.\n\t *                                             Default empty array.\n\t *     @type array        $cookies             List of cookies to send with the request. Default empty array.\n\t *     @type string|array $body                Body to send with the request. Default null.\n\t *     @type bool         $compress            Whether to compress the $body when sending the request.\n\t *                                             Default false.\n\t *     @type bool         $decompress          Whether to decompress a compressed response. If set to false and\n\t *                                             compressed content is returned in the response anyway, it will\n\t *                                             need to be separately decompressed. Default true.\n\t *     @type bool         $sslverify           Whether to verify SSL for the request. Default true.\n\t *     @type string       sslcertificates      Absolute path to an SSL certificate .crt file.\n\t *                                             Default ABSPATH . WPINC . '/certificates/ca-bundle.crt'.\n\t *     @type bool         $stream              Whether to stream to a file. If set to true and no filename was\n\t *                                             given, it will be droped it in the WP temp dir and its name will\n\t *                                             be set using the basename of the URL. Default false.\n\t *     @type string       $filename            Filename of the file to write to when streaming. $stream must be\n\t *                                             set to true. Default null.\n\t *     @type int          $limit_response_size Size in bytes to limit the response to. Default null.\n\t *\n\t * }\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'.\n\t *                        A WP_Error instance upon error.\n\t */\n\tpublic function request( $url, $args = array() ) {\n\t\t$defaults = array(\n\t\t\t'method' => 'GET',\n\t\t\t/**\n\t\t\t * Filters the timeout value for an HTTP request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param int $timeout_value Time in seconds until a request times out.\n\t\t\t *                           Default 5.\n\t\t\t */\n\t\t\t'timeout' => apply_filters( 'http_request_timeout', 5 ),\n\t\t\t/**\n\t\t\t * Filters the number of redirects allowed during an HTTP request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param int $redirect_count Number of redirects allowed. Default 5.\n\t\t\t */\n\t\t\t'redirection' => apply_filters( 'http_request_redirection_count', 5 ),\n\t\t\t/**\n\t\t\t * Filters the version of the HTTP protocol used in a request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param string $version Version of HTTP used. Accepts '1.0' and '1.1'.\n\t\t\t *                        Default '1.0'.\n\t\t\t */\n\t\t\t'httpversion' => apply_filters( 'http_request_version', '1.0' ),\n\t\t\t/**\n\t\t\t * Filters the user agent value sent with an HTTP request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param string $user_agent WordPress user agent string.\n\t\t\t */\n\t\t\t'user-agent' => apply_filters( 'http_headers_useragent', 'WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ) ),\n\t\t\t/**\n\t\t\t * Filters whether to pass URLs through wp_http_validate_url() in an HTTP request.\n\t\t\t *\n\t\t\t * @since 3.6.0\n\t\t\t *\n\t\t\t * @param bool $pass_url Whether to pass URLs through wp_http_validate_url().\n\t\t\t *                       Default false.\n\t\t\t */\n\t\t\t'reject_unsafe_urls' => apply_filters( 'http_request_reject_unsafe_urls', false ),\n\t\t\t'blocking' => true,\n\t\t\t'headers' => array(),\n\t\t\t'cookies' => array(),\n\t\t\t'body' => null,\n\t\t\t'compress' => false,\n\t\t\t'decompress' => true,\n\t\t\t'sslverify' => true,\n\t\t\t'sslcertificates' => ABSPATH . WPINC . '/certificates/ca-bundle.crt',\n\t\t\t'stream' => false,\n\t\t\t'filename' => null,\n\t\t\t'limit_response_size' => null,\n\t\t);\n\n\t\t// Pre-parse for the HEAD checks.\n\t\t$args = wp_parse_args( $args );\n\n\t\t// By default, Head requests do not cause redirections.\n\t\tif ( isset($args['method']) && 'HEAD' == $args['method'] )\n\t\t\t$defaults['redirection'] = 0;\n\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\t/**\n\t\t * Filters the arguments used in an HTTP request.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param array  $r   An array of HTTP request arguments.\n\t\t * @param string $url The request URL.\n\t\t */\n\t\t$r = apply_filters( 'http_request_args', $r, $url );\n\n\t\t// The transports decrement this, store a copy of the original value for loop purposes.\n\t\tif ( ! isset( $r['_redirection'] ) )\n\t\t\t$r['_redirection'] = $r['redirection'];\n\n\t\t/**\n\t\t * Filters whether to preempt an HTTP request's return value.\n\t\t *\n\t\t * Returning a non-false value from the filter will short-circuit the HTTP request and return\n\t\t * early with that value. A filter should return either:\n\t\t *\n\t\t *  - An array containing 'headers', 'body', 'response', 'cookies', and 'filename' elements\n\t\t *  - A WP_Error instance\n\t\t *  - boolean false (to avoid short-circuiting the response)\n\t\t *\n\t\t * Returning any other value may result in unexpected behaviour.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param false|array|WP_Error $preempt Whether to preempt an HTTP request's return value. Default false.\n\t\t * @param array               $r        HTTP request arguments.\n\t\t * @param string              $url      The request URL.\n\t\t */\n\t\t$pre = apply_filters( 'pre_http_request', false, $r, $url );\n\n\t\tif ( false !== $pre )\n\t\t\treturn $pre;\n\n\t\tif ( function_exists( 'wp_kses_bad_protocol' ) ) {\n\t\t\tif ( $r['reject_unsafe_urls'] ) {\n\t\t\t\t$url = wp_http_validate_url( $url );\n\t\t\t}\n\t\t\tif ( $url ) {\n\t\t\t\t$url = wp_kses_bad_protocol( $url, array( 'http', 'https', 'ssl' ) );\n\t\t\t}\n\t\t}\n\n\t\t$arrURL = @parse_url( $url );\n\n\t\tif ( empty( $url ) || empty( $arrURL['scheme'] ) ) {\n\t\t\treturn new WP_Error('http_request_failed', __('A valid URL was not provided.'));\n\t\t}\n\n\t\tif ( $this->block_request( $url ) ) {\n\t\t\treturn new WP_Error( 'http_request_failed', __( 'User has blocked requests through HTTP.' ) );\n\t\t}\n\n\t\t// If we are streaming to a file but no filename was given drop it in the WP temp dir\n\t\t// and pick its name using the basename of the $url\n\t\tif ( $r['stream'] ) {\n\t\t\tif ( empty( $r['filename'] ) ) {\n\t\t\t\t$r['filename'] = get_temp_dir() . basename( $url );\n\t\t\t}\n\n\t\t\t// Force some settings if we are streaming to a file and check for existence and perms of destination directory\n\t\t\t$r['blocking'] = true;\n\t\t\tif ( ! wp_is_writable( dirname( $r['filename'] ) ) ) {\n\t\t\t\treturn new WP_Error( 'http_request_failed', __( 'Destination directory for file streaming does not exist or is not writable.' ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( is_null( $r['headers'] ) ) {\n\t\t\t$r['headers'] = array();\n\t\t}\n\n\t\t// WP allows passing in headers as a string, weirdly.\n\t\tif ( ! is_array( $r['headers'] ) ) {\n\t\t\t$processedHeaders = WP_Http::processHeaders( $r['headers'] );\n\t\t\t$r['headers'] = $processedHeaders['headers'];\n\t\t}\n\n\t\t// Setup arguments\n\t\t$headers = $r['headers'];\n\t\t$data = $r['body'];\n\t\t$type = $r['method'];\n\t\t$options = array(\n\t\t\t'timeout' => $r['timeout'],\n\t\t\t'useragent' => $r['user-agent'],\n\t\t\t'blocking' => $r['blocking'],\n\t\t\t'hooks' => new WP_HTTP_Requests_Hooks( $url, $r ),\n\t\t);\n\n\t\t// Ensure redirects follow browser behaviour.\n\t\t$options['hooks']->register( 'requests.before_redirect', array( get_class(), 'browser_redirect_compatibility' ) );\n\n\t\tif ( $r['stream'] ) {\n\t\t\t$options['filename'] = $r['filename'];\n\t\t}\n\t\tif ( empty( $r['redirection'] ) ) {\n\t\t\t$options['follow_redirects'] = false;\n\t\t} else {\n\t\t\t$options['redirects'] = $r['redirection'];\n\t\t}\n\n\t\t// Use byte limit, if we can\n\t\tif ( isset( $r['limit_response_size'] ) ) {\n\t\t\t$options['max_bytes'] = $r['limit_response_size'];\n\t\t}\n\n\t\t// If we've got cookies, use and convert them to Requests_Cookie.\n\t\tif ( ! empty( $r['cookies'] ) ) {\n\t\t\t$options['cookies'] = WP_Http::normalize_cookies( $r['cookies'] );\n\t\t}\n\n\t\t// SSL certificate handling\n\t\tif ( ! $r['sslverify'] ) {\n\t\t\t$options['verify'] = false;\n\t\t\t$options['verifyname'] = false;\n\t\t} else {\n\t\t\t$options['verify'] = $r['sslcertificates'];\n\t\t}\n\n\t\t// All non-GET/HEAD requests should put the arguments in the form body.\n\t\tif ( 'HEAD' !== $type && 'GET' !== $type ) {\n\t\t\t$options['data_format'] = 'body';\n\t\t}\n\n\t\t/**\n\t\t * Filters whether SSL should be verified for non-local requests.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param bool $ssl_verify Whether to verify the SSL connection. Default true.\n\t\t */\n\t\t$options['verify'] = apply_filters( 'https_ssl_verify', $options['verify'] );\n\n\t\t// Check for proxies.\n\t\t$proxy = new WP_HTTP_Proxy();\n\t\tif ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {\n\t\t\t$options['proxy'] = new Requests_Proxy_HTTP( $proxy->host() . ':' . $proxy->port() );\n\n\t\t\tif ( $proxy->use_authentication() ) {\n\t\t\t\t$options['proxy']->use_authentication = true;\n\t\t\t\t$options['proxy']->user = $proxy->username();\n\t\t\t\t$options['proxy']->pass = $proxy->password();\n\t\t\t}\n\t\t}\n\n\t\t// Avoid issues where mbstring.func_overload is enabled\n\t\tmbstring_binary_safe_encoding();\n\n\t\ttry {\n\t\t\t$requests_response = Requests::request( $url, $headers, $data, $type, $options );\n\n\t\t\t// Convert the response into an array\n\t\t\t$http_response = new WP_HTTP_Requests_Response( $requests_response, $r['filename'] );\n\t\t\t$response = $http_response->to_array();\n\n\t\t\t// Add the original object to the array.\n\t\t\t$response['http_response'] = $http_response;\n\t\t}\n\t\tcatch ( Requests_Exception $e ) {\n\t\t\t$response = new WP_Error( 'http_request_failed', $e->getMessage() );\n\t\t}\n\n\t\treset_mbstring_encoding();\n\n\t\t/**\n\t\t * Fires after an HTTP API response is received and before the response is returned.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param array|WP_Error $response HTTP response or WP_Error object.\n\t\t * @param string         $context  Context under which the hook is fired.\n\t\t * @param string         $class    HTTP transport used.\n\t\t * @param array          $args     HTTP request arguments.\n\t\t * @param string         $url      The request URL.\n\t\t */\n\t\tdo_action( 'http_api_debug', $response, 'response', 'Requests', $r, $url );\n\t\tif ( is_wp_error( $response ) ) {\n\t\t\treturn $response;\n\t\t}\n\n\t\tif ( ! $r['blocking'] ) {\n\t\t\treturn array(\n\t\t\t\t'headers' => array(),\n\t\t\t\t'body' => '',\n\t\t\t\t'response' => array(\n\t\t\t\t\t'code' => false,\n\t\t\t\t\t'message' => false,\n\t\t\t\t),\n\t\t\t\t'cookies' => array(),\n\t\t\t\t'http_response' => null,\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Filters the HTTP API response immediately before the response is returned.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param array  $response HTTP response.\n\t\t * @param array  $r        HTTP request arguments.\n\t\t * @param string $url      The request URL.\n\t\t */\n\t\treturn apply_filters( 'http_response', $response, $r, $url );\n\t}\n\n\t/**\n\t * Normalizes cookies for using in Requests.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param array $cookies List of cookies to send with the request.\n\t * @return Requests_Cookie_Jar Cookie holder object.\n\t */\n\tpublic static function normalize_cookies( $cookies ) {\n\t\t$cookie_jar = new Requests_Cookie_Jar();\n\n\t\tforeach ( $cookies as $name => $value ) {\n\t\t\tif ( $value instanceof WP_Http_Cookie ) {\n\t\t\t\t$cookie_jar[ $value->name ] = new Requests_Cookie( $value->name, $value->value, $value->get_attributes() );\n\t\t\t} elseif ( is_scalar( $value ) ) {\n\t\t\t\t$cookie_jar[ $name ] = new Requests_Cookie( $name, $value );\n\t\t\t}\n\t\t}\n\n\t\treturn $cookie_jar;\n\t}\n\n\t/**\n\t * Match redirect behaviour to browser handling.\n\t *\n\t * Changes 302 redirects from POST to GET to match browser handling. Per\n\t * RFC 7231, user agents can deviate from the strict reading of the\n\t * specification for compatibility purposes.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param string            $location URL to redirect to.\n\t * @param array             $headers  Headers for the redirect.\n\t * @param array             $options  Redirect request options.\n\t * @param Requests_Response $original Response object.\n\t */\n\tpublic static function browser_redirect_compatibility( $location, $headers, $data, &$options, $original ) {\n\t\t// Browser compat\n\t\tif ( $original->status_code === 302 ) {\n\t\t\t$options['type'] = Requests::GET;\n\t\t}\n\t}\n\n\t/**\n\t * Tests which transports are capable of supporting the request.\n\t *\n\t * @since 3.2.0\n\t * @access public\n\t *\n\t * @param array $args Request arguments\n\t * @param string $url URL to Request\n\t *\n\t * @return string|false Class name for the first transport that claims to support the request. False if no transport claims to support the request.\n\t */\n\tpublic function _get_first_available_transport( $args, $url = null ) {\n\t\t$transports = array( 'curl', 'streams' );\n\n\t\t/**\n\t\t * Filters which HTTP transports are available and in what order.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param array  $transports Array of HTTP transports to check. Default array contains\n\t\t *                           'curl', and 'streams', in that order.\n\t\t * @param array  $args       HTTP request arguments.\n\t\t * @param string $url        The URL to request.\n\t\t */\n\t\t$request_order = apply_filters( 'http_api_transports', $transports, $args, $url );\n\n\t\t// Loop over each transport on each HTTP request looking for one which will serve this request's needs.\n\t\tforeach ( $request_order as $transport ) {\n\t\t\tif ( in_array( $transport, $transports ) ) {\n\t\t\t\t$transport = ucfirst( $transport );\n\t\t\t}\n\t\t\t$class = 'WP_Http_' . $transport;\n\n\t\t\t// Check to see if this transport is a possibility, calls the transport statically.\n\t\t\tif ( !call_user_func( array( $class, 'test' ), $args, $url ) )\n\t\t\t\tcontinue;\n\n\t\t\treturn $class;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Dispatches a HTTP request to a supporting transport.\n\t *\n\t * Tests each transport in order to find a transport which matches the request arguments.\n\t * Also caches the transport instance to be used later.\n\t *\n\t * The order for requests is cURL, and then PHP Streams.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string $url URL to Request\n\t * @param array $args Request arguments\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tprivate function _dispatch_request( $url, $args ) {\n\t\tstatic $transports = array();\n\n\t\t$class = $this->_get_first_available_transport( $args, $url );\n\t\tif ( !$class )\n\t\t\treturn new WP_Error( 'http_failure', __( 'There are no HTTP transports available which can complete the requested request.' ) );\n\n\t\t// Transport claims to support request, instantiate it and give it a whirl.\n\t\tif ( empty( $transports[$class] ) )\n\t\t\t$transports[$class] = new $class;\n\n\t\t$response = $transports[$class]->request( $url, $args );\n\n\t\t/** This action is documented in wp-includes/class-http.php */\n\t\tdo_action( 'http_api_debug', $response, 'response', $class, $args, $url );\n\n\t\tif ( is_wp_error( $response ) )\n\t\t\treturn $response;\n\n\t\t/**\n\t\t * Filters the HTTP API response immediately before the response is returned.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param array  $response HTTP response.\n\t\t * @param array  $args     HTTP request arguments.\n\t\t * @param string $url      The request URL.\n\t\t */\n\t\treturn apply_filters( 'http_response', $response, $args, $url );\n\t}\n\n\t/**\n\t * Uses the POST HTTP method.\n\t *\n\t * Used for sending data that is expected to be in the body.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string       $url  The request URL.\n\t * @param string|array $args Optional. Override the defaults.\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tpublic function post($url, $args = array()) {\n\t\t$defaults = array('method' => 'POST');\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\treturn $this->request($url, $r);\n\t}\n\n\t/**\n\t * Uses the GET HTTP method.\n\t *\n\t * Used for sending data that is expected to be in the body.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string $url The request URL.\n\t * @param string|array $args Optional. Override the defaults.\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tpublic function get($url, $args = array()) {\n\t\t$defaults = array('method' => 'GET');\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\treturn $this->request($url, $r);\n\t}\n\n\t/**\n\t * Uses the HEAD HTTP method.\n\t *\n\t * Used for sending data that is expected to be in the body.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string $url The request URL.\n\t * @param string|array $args Optional. Override the defaults.\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tpublic function head($url, $args = array()) {\n\t\t$defaults = array('method' => 'HEAD');\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\treturn $this->request($url, $r);\n\t}\n\n\t/**\n\t * Parses the responses and splits the parts into headers and body.\n\t *\n\t * @access public\n\t * @static\n\t * @since 2.7.0\n\t *\n\t * @param string $strResponse The full response string\n\t * @return array Array with 'headers' and 'body' keys.\n\t */\n\tpublic static function processResponse($strResponse) {\n\t\t$res = explode(\"\\r\\n\\r\\n\", $strResponse, 2);\n\n\t\treturn array('headers' => $res[0], 'body' => isset($res[1]) ? $res[1] : '');\n\t}\n\n\t/**\n\t * Transform header string into an array.\n\t *\n\t * If an array is given then it is assumed to be raw header data with numeric keys with the\n\t * headers as the values. No headers must be passed that were already processed.\n\t *\n\t * @access public\n\t * @static\n\t * @since 2.7.0\n\t *\n\t * @param string|array $headers\n\t * @param string $url The URL that was requested\n\t * @return array Processed string headers. If duplicate headers are encountered,\n\t * \t\t\t\t\tThen a numbered array is returned as the value of that header-key.\n\t */\n\tpublic static function processHeaders( $headers, $url = '' ) {\n\t\t// Split headers, one per array element.\n\t\tif ( is_string($headers) ) {\n\t\t\t// Tolerate line terminator: CRLF = LF (RFC 2616 19.3).\n\t\t\t$headers = str_replace(\"\\r\\n\", \"\\n\", $headers);\n\t\t\t/*\n\t\t\t * Unfold folded header fields. LWS = [CRLF] 1*( SP | HT ) <US-ASCII SP, space (32)>,\n\t\t\t * <US-ASCII HT, horizontal-tab (9)> (RFC 2616 2.2).\n\t\t\t */\n\t\t\t$headers = preg_replace('/\\n[ \\t]/', ' ', $headers);\n\t\t\t// Create the headers array.\n\t\t\t$headers = explode(\"\\n\", $headers);\n\t\t}\n\n\t\t$response = array('code' => 0, 'message' => '');\n\n\t\t/*\n\t\t * If a redirection has taken place, The headers for each page request may have been passed.\n\t\t * In this case, determine the final HTTP header and parse from there.\n\t\t */\n\t\tfor ( $i = count($headers)-1; $i >= 0; $i-- ) {\n\t\t\tif ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) {\n\t\t\t\t$headers = array_splice($headers, $i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$cookies = array();\n\t\t$newheaders = array();\n\t\tforeach ( (array) $headers as $tempheader ) {\n\t\t\tif ( empty($tempheader) )\n\t\t\t\tcontinue;\n\n\t\t\tif ( false === strpos($tempheader, ':') ) {\n\t\t\t\t$stack = explode(' ', $tempheader, 3);\n\t\t\t\t$stack[] = '';\n\t\t\t\tlist( , $response['code'], $response['message']) = $stack;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist($key, $value) = explode(':', $tempheader, 2);\n\n\t\t\t$key = strtolower( $key );\n\t\t\t$value = trim( $value );\n\n\t\t\tif ( isset( $newheaders[ $key ] ) ) {\n\t\t\t\tif ( ! is_array( $newheaders[ $key ] ) )\n\t\t\t\t\t$newheaders[$key] = array( $newheaders[ $key ] );\n\t\t\t\t$newheaders[ $key ][] = $value;\n\t\t\t} else {\n\t\t\t\t$newheaders[ $key ] = $value;\n\t\t\t}\n\t\t\tif ( 'set-cookie' == $key )\n\t\t\t\t$cookies[] = new WP_Http_Cookie( $value, $url );\n\t\t}\n\n\t\t// Cast the Response Code to an int\n\t\t$response['code'] = intval( $response['code'] );\n\n\t\treturn array('response' => $response, 'headers' => $newheaders, 'cookies' => $cookies);\n\t}\n\n\t/**\n\t * Takes the arguments for a ::request() and checks for the cookie array.\n\t *\n\t * If it's found, then it upgrades any basic name => value pairs to WP_Http_Cookie instances,\n\t * which are each parsed into strings and added to the Cookie: header (within the arguments array).\n\t * Edits the array by reference.\n\t *\n\t * @access public\n\t * @version 2.8.0\n\t * @static\n\t *\n\t * @param array $r Full array of args passed into ::request()\n\t */\n\tpublic static function buildCookieHeader( &$r ) {\n\t\tif ( ! empty($r['cookies']) ) {\n\t\t\t// Upgrade any name => value cookie pairs to WP_HTTP_Cookie instances.\n\t\t\tforeach ( $r['cookies'] as $name => $value ) {\n\t\t\t\tif ( ! is_object( $value ) )\n\t\t\t\t\t$r['cookies'][ $name ] = new WP_Http_Cookie( array( 'name' => $name, 'value' => $value ) );\n\t\t\t}\n\n\t\t\t$cookies_header = '';\n\t\t\tforeach ( (array) $r['cookies'] as $cookie ) {\n\t\t\t\t$cookies_header .= $cookie->getHeaderValue() . '; ';\n\t\t\t}\n\n\t\t\t$cookies_header = substr( $cookies_header, 0, -2 );\n\t\t\t$r['headers']['cookie'] = $cookies_header;\n\t\t}\n\t}\n\n\t/**\n\t * Decodes chunk transfer-encoding, based off the HTTP 1.1 specification.\n\t *\n\t * Based off the HTTP http_encoding_dechunk function.\n\t *\n\t * @link https://tools.ietf.org/html/rfc2616#section-19.4.6 Process for chunked decoding.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t * @static\n\t *\n\t * @param string $body Body content\n\t * @return string Chunked decoded body on success or raw body on failure.\n\t */\n\tpublic static function chunkTransferDecode( $body ) {\n\t\t// The body is not chunked encoded or is malformed.\n\t\tif ( ! preg_match( '/^([0-9a-f]+)[^\\r\\n]*\\r\\n/i', trim( $body ) ) )\n\t\t\treturn $body;\n\n\t\t$parsed_body = '';\n\n\t\t// We'll be altering $body, so need a backup in case of error.\n\t\t$body_original = $body;\n\n\t\twhile ( true ) {\n\t\t\t$has_chunk = (bool) preg_match( '/^([0-9a-f]+)[^\\r\\n]*\\r\\n/i', $body, $match );\n\t\t\tif ( ! $has_chunk || empty( $match[1] ) )\n\t\t\t\treturn $body_original;\n\n\t\t\t$length = hexdec( $match[1] );\n\t\t\t$chunk_length = strlen( $match[0] );\n\n\t\t\t// Parse out the chunk of data.\n\t\t\t$parsed_body .= substr( $body, $chunk_length, $length );\n\n\t\t\t// Remove the chunk from the raw data.\n\t\t\t$body = substr( $body, $length + $chunk_length );\n\n\t\t\t// End of the document.\n\t\t\tif ( '0' === trim( $body ) )\n\t\t\t\treturn $parsed_body;\n\t\t}\n\t}\n\n\t/**\n\t * Block requests through the proxy.\n\t *\n\t * Those who are behind a proxy and want to prevent access to certain hosts may do so. This will\n\t * prevent plugins from working and core functionality, if you don't include api.wordpress.org.\n\t *\n\t * You block external URL requests by defining WP_HTTP_BLOCK_EXTERNAL as true in your wp-config.php\n\t * file and this will only allow localhost and your site to make requests. The constant\n\t * WP_ACCESSIBLE_HOSTS will allow additional hosts to go through for requests. The format of the\n\t * WP_ACCESSIBLE_HOSTS constant is a comma separated list of hostnames to allow, wildcard domains\n\t * are supported, eg *.wordpress.org will allow for all subdomains of wordpress.org to be contacted.\n\t *\n\t * @since 2.8.0\n\t * @link https://core.trac.wordpress.org/ticket/8927 Allow preventing external requests.\n\t * @link https://core.trac.wordpress.org/ticket/14636 Allow wildcard domains in WP_ACCESSIBLE_HOSTS\n\t *\n\t * @staticvar array|null $accessible_hosts\n\t * @staticvar array      $wildcard_regex\n\t *\n\t * @param string $uri URI of url.\n\t * @return bool True to block, false to allow.\n\t */\n\tpublic function block_request($uri) {\n\t\t// We don't need to block requests, because nothing is blocked.\n\t\tif ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL )\n\t\t\treturn false;\n\n\t\t$check = parse_url($uri);\n\t\tif ( ! $check )\n\t\t\treturn true;\n\n\t\t$home = parse_url( get_option('siteurl') );\n\n\t\t// Don't block requests back to ourselves by default.\n\t\tif ( 'localhost' == $check['host'] || ( isset( $home['host'] ) && $home['host'] == $check['host'] ) ) {\n\t\t\t/**\n\t\t\t * Filters whether to block local requests through the proxy.\n\t\t\t *\n\t\t\t * @since 2.8.0\n\t\t\t *\n\t\t\t * @param bool $block Whether to block local requests through proxy.\n\t\t\t *                    Default false.\n\t\t\t */\n\t\t\treturn apply_filters( 'block_local_requests', false );\n\t\t}\n\n\t\tif ( !defined('WP_ACCESSIBLE_HOSTS') )\n\t\t\treturn true;\n\n\t\tstatic $accessible_hosts = null;\n\t\tstatic $wildcard_regex = array();\n\t\tif ( null === $accessible_hosts ) {\n\t\t\t$accessible_hosts = preg_split('|,\\s*|', WP_ACCESSIBLE_HOSTS);\n\n\t\t\tif ( false !== strpos(WP_ACCESSIBLE_HOSTS, '*') ) {\n\t\t\t\t$wildcard_regex = array();\n\t\t\t\tforeach ( $accessible_hosts as $host )\n\t\t\t\t\t$wildcard_regex[] = str_replace( '\\*', '.+', preg_quote( $host, '/' ) );\n\t\t\t\t$wildcard_regex = '/^(' . implode('|', $wildcard_regex) . ')$/i';\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty($wildcard_regex) )\n\t\t\treturn !preg_match($wildcard_regex, $check['host']);\n\t\telse\n\t\t\treturn !in_array( $check['host'], $accessible_hosts ); //Inverse logic, If it's in the array, then we can't access it.\n\n\t}\n\n\t/**\n\t * Used as a wrapper for PHP's parse_url() function that handles edgecases in < PHP 5.4.7.\n\t *\n\t * @access protected\n\t * @deprecated 4.4.0 Use wp_parse_url()\n\t * @see wp_parse_url()\n\t *\n\t * @param string $url The URL to parse.\n\t * @return bool|array False on failure; Array of URL components on success;\n\t *                    See parse_url()'s return values.\n\t */\n\tprotected static function parse_url( $url ) {\n\t\t_deprecated_function( __METHOD__, '4.4.0', 'wp_parse_url()' );\n\t\treturn wp_parse_url( $url );\n\t}\n\n\t/**\n\t * Converts a relative URL to an absolute URL relative to a given URL.\n\t *\n\t * If an Absolute URL is provided, no processing of that URL is done.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @param string $maybe_relative_path The URL which might be relative\n\t * @param string $url                 The URL which $maybe_relative_path is relative to\n\t * @return string An Absolute URL, in a failure condition where the URL cannot be parsed, the relative URL will be returned.\n\t */\n\tpublic static function make_absolute_url( $maybe_relative_path, $url ) {\n\t\tif ( empty( $url ) )\n\t\t\treturn $maybe_relative_path;\n\n\t\tif ( ! $url_parts = wp_parse_url( $url ) ) {\n\t\t\treturn $maybe_relative_path;\n\t\t}\n\n\t\tif ( ! $relative_url_parts = wp_parse_url( $maybe_relative_path ) ) {\n\t\t\treturn $maybe_relative_path;\n\t\t}\n\n\t\t// Check for a scheme on the 'relative' url\n\t\tif ( ! empty( $relative_url_parts['scheme'] ) ) {\n\t\t\treturn $maybe_relative_path;\n\t\t}\n\n\t\t$absolute_path = $url_parts['scheme'] . '://';\n\n\t\t// Schemeless URL's will make it this far, so we check for a host in the relative url and convert it to a protocol-url\n\t\tif ( isset( $relative_url_parts['host'] ) ) {\n\t\t\t$absolute_path .= $relative_url_parts['host'];\n\t\t\tif ( isset( $relative_url_parts['port'] ) )\n\t\t\t\t$absolute_path .= ':' . $relative_url_parts['port'];\n\t\t} else {\n\t\t\t$absolute_path .= $url_parts['host'];\n\t\t\tif ( isset( $url_parts['port'] ) )\n\t\t\t\t$absolute_path .= ':' . $url_parts['port'];\n\t\t}\n\n\t\t// Start off with the Absolute URL path.\n\t\t$path = ! empty( $url_parts['path'] ) ? $url_parts['path'] : '/';\n\n\t\t// If it's a root-relative path, then great.\n\t\tif ( ! empty( $relative_url_parts['path'] ) && '/' == $relative_url_parts['path'][0] ) {\n\t\t\t$path = $relative_url_parts['path'];\n\n\t\t// Else it's a relative path.\n\t\t} elseif ( ! empty( $relative_url_parts['path'] ) ) {\n\t\t\t// Strip off any file components from the absolute path.\n\t\t\t$path = substr( $path, 0, strrpos( $path, '/' ) + 1 );\n\n\t\t\t// Build the new path.\n\t\t\t$path .= $relative_url_parts['path'];\n\n\t\t\t// Strip all /path/../ out of the path.\n\t\t\twhile ( strpos( $path, '../' ) > 1 ) {\n\t\t\t\t$path = preg_replace( '![^/]+/\\.\\./!', '', $path );\n\t\t\t}\n\n\t\t\t// Strip any final leading ../ from the path.\n\t\t\t$path = preg_replace( '!^/(\\.\\./)+!', '', $path );\n\t\t}\n\n\t\t// Add the Query string.\n\t\tif ( ! empty( $relative_url_parts['query'] ) )\n\t\t\t$path .= '?' . $relative_url_parts['query'];\n\n\t\treturn $absolute_path . '/' . ltrim( $path, '/' );\n\t}\n\n\t/**\n\t * Handles HTTP Redirects and follows them if appropriate.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @static\n\t *\n\t * @param string $url The URL which was requested.\n\t * @param array $args The Arguments which were used to make the request.\n\t * @param array $response The Response of the HTTP request.\n\t * @return false|object False if no redirect is present, a WP_HTTP or WP_Error result otherwise.\n\t */\n\tpublic static function handle_redirects( $url, $args, $response ) {\n\t\t// If no redirects are present, or, redirects were not requested, perform no action.\n\t\tif ( ! isset( $response['headers']['location'] ) || 0 === $args['_redirection'] )\n\t\t\treturn false;\n\n\t\t// Only perform redirections on redirection http codes.\n\t\tif ( $response['response']['code'] > 399 || $response['response']['code'] < 300 )\n\t\t\treturn false;\n\n\t\t// Don't redirect if we've run out of redirects.\n\t\tif ( $args['redirection']-- <= 0 )\n\t\t\treturn new WP_Error( 'http_request_failed', __('Too many redirects.') );\n\n\t\t$redirect_location = $response['headers']['location'];\n\n\t\t// If there were multiple Location headers, use the last header specified.\n\t\tif ( is_array( $redirect_location ) )\n\t\t\t$redirect_location = array_pop( $redirect_location );\n\n\t\t$redirect_location = WP_Http::make_absolute_url( $redirect_location, $url );\n\n\t\t// POST requests should not POST to a redirected location.\n\t\tif ( 'POST' == $args['method'] ) {\n\t\t\tif ( in_array( $response['response']['code'], array( 302, 303 ) ) )\n\t\t\t\t$args['method'] = 'GET';\n\t\t}\n\n\t\t// Include valid cookies in the redirect process.\n\t\tif ( ! empty( $response['cookies'] ) ) {\n\t\t\tforeach ( $response['cookies'] as $cookie ) {\n\t\t\t\tif ( $cookie->test( $redirect_location ) )\n\t\t\t\t\t$args['cookies'][] = $cookie;\n\t\t\t}\n\t\t}\n\n\t\treturn wp_remote_request( $redirect_location, $args );\n\t}\n\n\t/**\n\t * Determines if a specified string represents an IP address or not.\n\t *\n\t * This function also detects the type of the IP address, returning either\n\t * '4' or '6' to represent a IPv4 and IPv6 address respectively.\n\t * This does not verify if the IP is a valid IP, only that it appears to be\n\t * an IP address.\n\t *\n\t * @link http://home.deds.nl/~aeron/regex/ for IPv6 regex\n\t *\n\t * @since 3.7.0\n\t * @static\n\t *\n\t * @param string $maybe_ip A suspected IP address\n\t * @return integer|bool Upon success, '4' or '6' to represent a IPv4 or IPv6 address, false upon failure\n\t */\n\tpublic static function is_ip_address( $maybe_ip ) {\n\t\tif ( preg_match( '/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/', $maybe_ip ) )\n\t\t\treturn 4;\n\n\t\tif ( false !== strpos( $maybe_ip, ':' ) && preg_match( '/^(((?=.*(::))(?!.*\\3.+\\3))\\3?|([\\dA-F]{1,4}(\\3|:\\b|$)|\\2))(?4){5}((?4){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i', trim( $maybe_ip, ' []' ) ) )\n\t\t\treturn 6;\n\n\t\treturn false;\n\t}\n\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-beta1-40677';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4601-20170510';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * HTTP API: WP_Http class\n *\n * @package WordPress\n * @subpackage HTTP\n * @since 2.7.0\n */\n\nif ( ! class_exists( 'Requests' ) ) {\n\trequire( ABSPATH . WPINC . '/class-requests.php' );\n\n\tRequests::register_autoloader();\n\tRequests::set_certificate_path( ABSPATH . WPINC . '/certificates/ca-bundle.crt' );\n}\n\n/**\n * Core class used for managing HTTP transports and making HTTP requests.\n *\n * This class is used to consistently make outgoing HTTP requests easy for developers\n * while still being compatible with the many PHP configurations under which\n * WordPress runs.\n *\n * Debugging includes several actions, which pass different variables for debugging the HTTP API.\n *\n * @since 2.7.0\n */\nclass WP_Http {\n\n\t// Aliases for HTTP response codes.\n\tconst HTTP_CONTINUE                   = 100;\n\tconst SWITCHING_PROTOCOLS             = 101;\n\tconst PROCESSING                      = 102;\n\n\tconst OK                              = 200;\n\tconst CREATED                         = 201;\n\tconst ACCEPTED                        = 202;\n\tconst NON_AUTHORITATIVE_INFORMATION   = 203;\n\tconst NO_CONTENT                      = 204;\n\tconst RESET_CONTENT                   = 205;\n\tconst PARTIAL_CONTENT                 = 206;\n\tconst MULTI_STATUS                    = 207;\n\tconst IM_USED                         = 226;\n\n\tconst MULTIPLE_CHOICES                = 300;\n\tconst MOVED_PERMANENTLY               = 301;\n\tconst FOUND                           = 302;\n\tconst SEE_OTHER                       = 303;\n\tconst NOT_MODIFIED                    = 304;\n\tconst USE_PROXY                       = 305;\n\tconst RESERVED                        = 306;\n\tconst TEMPORARY_REDIRECT              = 307;\n\tconst PERMANENT_REDIRECT              = 308;\n\n\tconst BAD_REQUEST                     = 400;\n\tconst UNAUTHORIZED                    = 401;\n\tconst PAYMENT_REQUIRED                = 402;\n\tconst FORBIDDEN                       = 403;\n\tconst NOT_FOUND                       = 404;\n\tconst METHOD_NOT_ALLOWED              = 405;\n\tconst NOT_ACCEPTABLE                  = 406;\n\tconst PROXY_AUTHENTICATION_REQUIRED   = 407;\n\tconst REQUEST_TIMEOUT                 = 408;\n\tconst CONFLICT                        = 409;\n\tconst GONE                            = 410;\n\tconst LENGTH_REQUIRED                 = 411;\n\tconst PRECONDITION_FAILED             = 412;\n\tconst REQUEST_ENTITY_TOO_LARGE        = 413;\n\tconst REQUEST_URI_TOO_LONG            = 414;\n\tconst UNSUPPORTED_MEDIA_TYPE          = 415;\n\tconst REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n\tconst EXPECTATION_FAILED              = 417;\n\tconst IM_A_TEAPOT                     = 418;\n\tconst MISDIRECTED_REQUEST             = 421;\n\tconst UNPROCESSABLE_ENTITY            = 422;\n\tconst LOCKED                          = 423;\n\tconst FAILED_DEPENDENCY               = 424;\n\tconst UPGRADE_REQUIRED                = 426;\n\tconst PRECONDITION_REQUIRED           = 428;\n\tconst TOO_MANY_REQUESTS               = 429;\n\tconst REQUEST_HEADER_FIELDS_TOO_LARGE = 431;\n\tconst UNAVAILABLE_FOR_LEGAL_REASONS   = 451;\n\n\tconst INTERNAL_SERVER_ERROR           = 500;\n\tconst NOT_IMPLEMENTED                 = 501;\n\tconst BAD_GATEWAY                     = 502;\n\tconst SERVICE_UNAVAILABLE             = 503;\n\tconst GATEWAY_TIMEOUT                 = 504;\n\tconst HTTP_VERSION_NOT_SUPPORTED      = 505;\n\tconst VARIANT_ALSO_NEGOTIATES         = 506;\n\tconst INSUFFICIENT_STORAGE            = 507;\n\tconst NOT_EXTENDED                    = 510;\n\tconst NETWORK_AUTHENTICATION_REQUIRED = 511;\n\n\t/**\n\t * Send an HTTP request to a URI.\n\t *\n\t * Please note: The only URI that are supported in the HTTP Transport implementation\n\t * are the HTTP and HTTPS protocols.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string       $url  The request URL.\n\t * @param string|array $args {\n\t *     Optional. Array or string of HTTP request arguments.\n\t *\n\t *     @type string       $method              Request method. Accepts 'GET', 'POST', 'HEAD', or 'PUT'.\n\t *                                             Some transports technically allow others, but should not be\n\t *                                             assumed. Default 'GET'.\n\t *     @type int          $timeout             How long the connection should stay open in seconds. Default 5.\n\t *     @type int          $redirection         Number of allowed redirects. Not supported by all transports\n\t *                                             Default 5.\n\t *     @type string       $httpversion         Version of the HTTP protocol to use. Accepts '1.0' and '1.1'.\n\t *                                             Default '1.0'.\n\t *     @type string       $user-agent          User-agent value sent.\n\t *                                             Default WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ).\n\t *     @type bool         $reject_unsafe_urls  Whether to pass URLs through wp_http_validate_url().\n\t *                                             Default false.\n\t *     @type bool         $blocking            Whether the calling code requires the result of the request.\n\t *                                             If set to false, the request will be sent to the remote server,\n\t *                                             and processing returned to the calling code immediately, the caller\n\t *                                             will know if the request succeeded or failed, but will not receive\n\t *                                             any response from the remote server. Default true.\n\t *     @type string|array $headers             Array or string of headers to send with the request.\n\t *                                             Default empty array.\n\t *     @type array        $cookies             List of cookies to send with the request. Default empty array.\n\t *     @type string|array $body                Body to send with the request. Default null.\n\t *     @type bool         $compress            Whether to compress the $body when sending the request.\n\t *                                             Default false.\n\t *     @type bool         $decompress          Whether to decompress a compressed response. If set to false and\n\t *                                             compressed content is returned in the response anyway, it will\n\t *                                             need to be separately decompressed. Default true.\n\t *     @type bool         $sslverify           Whether to verify SSL for the request. Default true.\n\t *     @type string       sslcertificates      Absolute path to an SSL certificate .crt file.\n\t *                                             Default ABSPATH . WPINC . '/certificates/ca-bundle.crt'.\n\t *     @type bool         $stream              Whether to stream to a file. If set to true and no filename was\n\t *                                             given, it will be droped it in the WP temp dir and its name will\n\t *                                             be set using the basename of the URL. Default false.\n\t *     @type string       $filename            Filename of the file to write to when streaming. $stream must be\n\t *                                             set to true. Default null.\n\t *     @type int          $limit_response_size Size in bytes to limit the response to. Default null.\n\t *\n\t * }\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'.\n\t *                        A WP_Error instance upon error.\n\t */\n\tpublic function request( $url, $args = array() ) {\n\t\t$defaults = array(\n\t\t\t'method' => 'GET',\n\t\t\t/**\n\t\t\t * Filters the timeout value for an HTTP request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param int $timeout_value Time in seconds until a request times out.\n\t\t\t *                           Default 5.\n\t\t\t */\n\t\t\t'timeout' => apply_filters( 'http_request_timeout', 5 ),\n\t\t\t/**\n\t\t\t * Filters the number of redirects allowed during an HTTP request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param int $redirect_count Number of redirects allowed. Default 5.\n\t\t\t */\n\t\t\t'redirection' => apply_filters( 'http_request_redirection_count', 5 ),\n\t\t\t/**\n\t\t\t * Filters the version of the HTTP protocol used in a request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param string $version Version of HTTP used. Accepts '1.0' and '1.1'.\n\t\t\t *                        Default '1.0'.\n\t\t\t */\n\t\t\t'httpversion' => apply_filters( 'http_request_version', '1.0' ),\n\t\t\t/**\n\t\t\t * Filters the user agent value sent with an HTTP request.\n\t\t\t *\n\t\t\t * @since 2.7.0\n\t\t\t *\n\t\t\t * @param string $user_agent WordPress user agent string.\n\t\t\t */\n\t\t\t'user-agent' => apply_filters( 'http_headers_useragent', 'WordPress/' . get_bloginfo( 'version' ) . '; ' . get_bloginfo( 'url' ) ),\n\t\t\t/**\n\t\t\t * Filters whether to pass URLs through wp_http_validate_url() in an HTTP request.\n\t\t\t *\n\t\t\t * @since 3.6.0\n\t\t\t *\n\t\t\t * @param bool $pass_url Whether to pass URLs through wp_http_validate_url().\n\t\t\t *                       Default false.\n\t\t\t */\n\t\t\t'reject_unsafe_urls' => apply_filters( 'http_request_reject_unsafe_urls', false ),\n\t\t\t'blocking' => true,\n\t\t\t'headers' => array(),\n\t\t\t'cookies' => array(),\n\t\t\t'body' => null,\n\t\t\t'compress' => false,\n\t\t\t'decompress' => true,\n\t\t\t'sslverify' => true,\n\t\t\t'sslcertificates' => ABSPATH . WPINC . '/certificates/ca-bundle.crt',\n\t\t\t'stream' => false,\n\t\t\t'filename' => null,\n\t\t\t'limit_response_size' => null,\n\t\t);\n\n\t\t// Pre-parse for the HEAD checks.\n\t\t$args = wp_parse_args( $args );\n\n\t\t// By default, Head requests do not cause redirections.\n\t\tif ( isset($args['method']) && 'HEAD' == $args['method'] )\n\t\t\t$defaults['redirection'] = 0;\n\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\t/**\n\t\t * Filters the arguments used in an HTTP request.\n\t\t *\n\t\t * @since 2.7.0\n\t\t *\n\t\t * @param array  $r   An array of HTTP request arguments.\n\t\t * @param string $url The request URL.\n\t\t */\n\t\t$r = apply_filters( 'http_request_args', $r, $url );\n\n\t\t// The transports decrement this, store a copy of the original value for loop purposes.\n\t\tif ( ! isset( $r['_redirection'] ) )\n\t\t\t$r['_redirection'] = $r['redirection'];\n\n\t\t/**\n\t\t * Filters whether to preempt an HTTP request's return value.\n\t\t *\n\t\t * Returning a non-false value from the filter will short-circuit the HTTP request and return\n\t\t * early with that value. A filter should return either:\n\t\t *\n\t\t *  - An array containing 'headers', 'body', 'response', 'cookies', and 'filename' elements\n\t\t *  - A WP_Error instance\n\t\t *  - boolean false (to avoid short-circuiting the response)\n\t\t *\n\t\t * Returning any other value may result in unexpected behaviour.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param false|array|WP_Error $preempt Whether to preempt an HTTP request's return value. Default false.\n\t\t * @param array               $r        HTTP request arguments.\n\t\t * @param string              $url      The request URL.\n\t\t */\n\t\t$pre = apply_filters( 'pre_http_request', false, $r, $url );\n\n\t\tif ( false !== $pre )\n\t\t\treturn $pre;\n\n\t\tif ( function_exists( 'wp_kses_bad_protocol' ) ) {\n\t\t\tif ( $r['reject_unsafe_urls'] ) {\n\t\t\t\t$url = wp_http_validate_url( $url );\n\t\t\t}\n\t\t\tif ( $url ) {\n\t\t\t\t$url = wp_kses_bad_protocol( $url, array( 'http', 'https', 'ssl' ) );\n\t\t\t}\n\t\t}\n\n\t\t$arrURL = @parse_url( $url );\n\n\t\tif ( empty( $url ) || empty( $arrURL['scheme'] ) ) {\n\t\t\treturn new WP_Error('http_request_failed', __('A valid URL was not provided.'));\n\t\t}\n\n\t\tif ( $this->block_request( $url ) ) {\n\t\t\treturn new WP_Error( 'http_request_failed', __( 'User has blocked requests through HTTP.' ) );\n\t\t}\n\n\t\t// If we are streaming to a file but no filename was given drop it in the WP temp dir\n\t\t// and pick its name using the basename of the $url\n\t\tif ( $r['stream'] ) {\n\t\t\tif ( empty( $r['filename'] ) ) {\n\t\t\t\t$r['filename'] = get_temp_dir() . basename( $url );\n\t\t\t}\n\n\t\t\t// Force some settings if we are streaming to a file and check for existence and perms of destination directory\n\t\t\t$r['blocking'] = true;\n\t\t\tif ( ! wp_is_writable( dirname( $r['filename'] ) ) ) {\n\t\t\t\treturn new WP_Error( 'http_request_failed', __( 'Destination directory for file streaming does not exist or is not writable.' ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( is_null( $r['headers'] ) ) {\n\t\t\t$r['headers'] = array();\n\t\t}\n\n\t\t// WP allows passing in headers as a string, weirdly.\n\t\tif ( ! is_array( $r['headers'] ) ) {\n\t\t\t$processedHeaders = WP_Http::processHeaders( $r['headers'] );\n\t\t\t$r['headers'] = $processedHeaders['headers'];\n\t\t}\n\n\t\t// Setup arguments\n\t\t$headers = $r['headers'];\n\t\t$data = $r['body'];\n\t\t$type = $r['method'];\n\t\t$options = array(\n\t\t\t'timeout' => $r['timeout'],\n\t\t\t'useragent' => $r['user-agent'],\n\t\t\t'blocking' => $r['blocking'],\n\t\t\t'hooks' => new WP_HTTP_Requests_Hooks( $url, $r ),\n\t\t);\n\n\t\t// Ensure redirects follow browser behaviour.\n\t\t$options['hooks']->register( 'requests.before_redirect', array( get_class(), 'browser_redirect_compatibility' ) );\n\n\t\t// Validate redirected URLs.\n\t\tif ( function_exists( 'wp_kses_bad_protocol' ) && $r['reject_unsafe_urls'] ) {\n\t\t\t$options['hooks']->register( 'requests.before_redirect', array( get_class(), 'validate_redirects' ) );\n\t\t}\n\n\t\tif ( $r['stream'] ) {\n\t\t\t$options['filename'] = $r['filename'];\n\t\t}\n\t\tif ( empty( $r['redirection'] ) ) {\n\t\t\t$options['follow_redirects'] = false;\n\t\t} else {\n\t\t\t$options['redirects'] = $r['redirection'];\n\t\t}\n\n\t\t// Use byte limit, if we can\n\t\tif ( isset( $r['limit_response_size'] ) ) {\n\t\t\t$options['max_bytes'] = $r['limit_response_size'];\n\t\t}\n\n\t\t// If we've got cookies, use and convert them to Requests_Cookie.\n\t\tif ( ! empty( $r['cookies'] ) ) {\n\t\t\t$options['cookies'] = WP_Http::normalize_cookies( $r['cookies'] );\n\t\t}\n\n\t\t// SSL certificate handling\n\t\tif ( ! $r['sslverify'] ) {\n\t\t\t$options['verify'] = false;\n\t\t\t$options['verifyname'] = false;\n\t\t} else {\n\t\t\t$options['verify'] = $r['sslcertificates'];\n\t\t}\n\n\t\t// All non-GET/HEAD requests should put the arguments in the form body.\n\t\tif ( 'HEAD' !== $type && 'GET' !== $type ) {\n\t\t\t$options['data_format'] = 'body';\n\t\t}\n\n\t\t/**\n\t\t * Filters whether SSL should be verified for non-local requests.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param bool $ssl_verify Whether to verify the SSL connection. Default true.\n\t\t */\n\t\t$options['verify'] = apply_filters( 'https_ssl_verify', $options['verify'] );\n\n\t\t// Check for proxies.\n\t\t$proxy = new WP_HTTP_Proxy();\n\t\tif ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {\n\t\t\t$options['proxy'] = new Requests_Proxy_HTTP( $proxy->host() . ':' . $proxy->port() );\n\n\t\t\tif ( $proxy->use_authentication() ) {\n\t\t\t\t$options['proxy']->use_authentication = true;\n\t\t\t\t$options['proxy']->user = $proxy->username();\n\t\t\t\t$options['proxy']->pass = $proxy->password();\n\t\t\t}\n\t\t}\n\n\t\t// Avoid issues where mbstring.func_overload is enabled\n\t\tmbstring_binary_safe_encoding();\n\n\t\ttry {\n\t\t\t$requests_response = Requests::request( $url, $headers, $data, $type, $options );\n\n\t\t\t// Convert the response into an array\n\t\t\t$http_response = new WP_HTTP_Requests_Response( $requests_response, $r['filename'] );\n\t\t\t$response = $http_response->to_array();\n\n\t\t\t// Add the original object to the array.\n\t\t\t$response['http_response'] = $http_response;\n\t\t}\n\t\tcatch ( Requests_Exception $e ) {\n\t\t\t$response = new WP_Error( 'http_request_failed', $e->getMessage() );\n\t\t}\n\n\t\treset_mbstring_encoding();\n\n\t\t/**\n\t\t * Fires after an HTTP API response is received and before the response is returned.\n\t\t *\n\t\t * @since 2.8.0\n\t\t *\n\t\t * @param array|WP_Error $response HTTP response or WP_Error object.\n\t\t * @param string         $context  Context under which the hook is fired.\n\t\t * @param string         $class    HTTP transport used.\n\t\t * @param array          $args     HTTP request arguments.\n\t\t * @param string         $url      The request URL.\n\t\t */\n\t\tdo_action( 'http_api_debug', $response, 'response', 'Requests', $r, $url );\n\t\tif ( is_wp_error( $response ) ) {\n\t\t\treturn $response;\n\t\t}\n\n\t\tif ( ! $r['blocking'] ) {\n\t\t\treturn array(\n\t\t\t\t'headers' => array(),\n\t\t\t\t'body' => '',\n\t\t\t\t'response' => array(\n\t\t\t\t\t'code' => false,\n\t\t\t\t\t'message' => false,\n\t\t\t\t),\n\t\t\t\t'cookies' => array(),\n\t\t\t\t'http_response' => null,\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Filters the HTTP API response immediately before the response is returned.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param array  $response HTTP response.\n\t\t * @param array  $r        HTTP request arguments.\n\t\t * @param string $url      The request URL.\n\t\t */\n\t\treturn apply_filters( 'http_response', $response, $r, $url );\n\t}\n\n\t/**\n\t * Normalizes cookies for using in Requests.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param array $cookies List of cookies to send with the request.\n\t * @return Requests_Cookie_Jar Cookie holder object.\n\t */\n\tpublic static function normalize_cookies( $cookies ) {\n\t\t$cookie_jar = new Requests_Cookie_Jar();\n\n\t\tforeach ( $cookies as $name => $value ) {\n\t\t\tif ( $value instanceof WP_Http_Cookie ) {\n\t\t\t\t$cookie_jar[ $value->name ] = new Requests_Cookie( $value->name, $value->value, $value->get_attributes() );\n\t\t\t} elseif ( is_scalar( $value ) ) {\n\t\t\t\t$cookie_jar[ $name ] = new Requests_Cookie( $name, $value );\n\t\t\t}\n\t\t}\n\n\t\treturn $cookie_jar;\n\t}\n\n\t/**\n\t * Match redirect behaviour to browser handling.\n\t *\n\t * Changes 302 redirects from POST to GET to match browser handling. Per\n\t * RFC 7231, user agents can deviate from the strict reading of the\n\t * specification for compatibility purposes.\n\t *\n\t * @since 4.6.0\n\t * @access public\n\t * @static\n\t *\n\t * @param string            $location URL to redirect to.\n\t * @param array             $headers  Headers for the redirect.\n\t * @param array             $options  Redirect request options.\n\t * @param Requests_Response $original Response object.\n\t */\n\tpublic static function browser_redirect_compatibility( $location, $headers, $data, &$options, $original ) {\n\t\t// Browser compat\n\t\tif ( $original->status_code === 302 ) {\n\t\t\t$options['type'] = Requests::GET;\n\t\t}\n\t}\n\n\t/**\n\t * Validate redirected URLs.\n\t *\n\t * @since 4.7.5\n\t *\n\t * @throws Requests_Exception On unsuccessful URL validation\n\t * @param string $location URL to redirect to.\n\t */\n\tpublic static function validate_redirects( $location ) {\n\t\tif ( ! wp_http_validate_url( $location ) ) {\n\t\t\tthrow new Requests_Exception( __('A valid URL was not provided.'), 'wp_http.redirect_failed_validation' );\n\t\t}\n\t}\n\n\t/**\n\t * Tests which transports are capable of supporting the request.\n\t *\n\t * @since 3.2.0\n\t * @access public\n\t *\n\t * @param array $args Request arguments\n\t * @param string $url URL to Request\n\t *\n\t * @return string|false Class name for the first transport that claims to support the request. False if no transport claims to support the request.\n\t */\n\tpublic function _get_first_available_transport( $args, $url = null ) {\n\t\t$transports = array( 'curl', 'streams' );\n\n\t\t/**\n\t\t * Filters which HTTP transports are available and in what order.\n\t\t *\n\t\t * @since 3.7.0\n\t\t *\n\t\t * @param array  $transports Array of HTTP transports to check. Default array contains\n\t\t *                           'curl', and 'streams', in that order.\n\t\t * @param array  $args       HTTP request arguments.\n\t\t * @param string $url        The URL to request.\n\t\t */\n\t\t$request_order = apply_filters( 'http_api_transports', $transports, $args, $url );\n\n\t\t// Loop over each transport on each HTTP request looking for one which will serve this request's needs.\n\t\tforeach ( $request_order as $transport ) {\n\t\t\tif ( in_array( $transport, $transports ) ) {\n\t\t\t\t$transport = ucfirst( $transport );\n\t\t\t}\n\t\t\t$class = 'WP_Http_' . $transport;\n\n\t\t\t// Check to see if this transport is a possibility, calls the transport statically.\n\t\t\tif ( !call_user_func( array( $class, 'test' ), $args, $url ) )\n\t\t\t\tcontinue;\n\n\t\t\treturn $class;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Dispatches a HTTP request to a supporting transport.\n\t *\n\t * Tests each transport in order to find a transport which matches the request arguments.\n\t * Also caches the transport instance to be used later.\n\t *\n\t * The order for requests is cURL, and then PHP Streams.\n\t *\n\t * @since 3.2.0\n\t *\n\t * @static\n\t * @access private\n\t *\n\t * @param string $url URL to Request\n\t * @param array $args Request arguments\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tprivate function _dispatch_request( $url, $args ) {\n\t\tstatic $transports = array();\n\n\t\t$class = $this->_get_first_available_transport( $args, $url );\n\t\tif ( !$class )\n\t\t\treturn new WP_Error( 'http_failure', __( 'There are no HTTP transports available which can complete the requested request.' ) );\n\n\t\t// Transport claims to support request, instantiate it and give it a whirl.\n\t\tif ( empty( $transports[$class] ) )\n\t\t\t$transports[$class] = new $class;\n\n\t\t$response = $transports[$class]->request( $url, $args );\n\n\t\t/** This action is documented in wp-includes/class-http.php */\n\t\tdo_action( 'http_api_debug', $response, 'response', $class, $args, $url );\n\n\t\tif ( is_wp_error( $response ) )\n\t\t\treturn $response;\n\n\t\t/**\n\t\t * Filters the HTTP API response immediately before the response is returned.\n\t\t *\n\t\t * @since 2.9.0\n\t\t *\n\t\t * @param array  $response HTTP response.\n\t\t * @param array  $args     HTTP request arguments.\n\t\t * @param string $url      The request URL.\n\t\t */\n\t\treturn apply_filters( 'http_response', $response, $args, $url );\n\t}\n\n\t/**\n\t * Uses the POST HTTP method.\n\t *\n\t * Used for sending data that is expected to be in the body.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string       $url  The request URL.\n\t * @param string|array $args Optional. Override the defaults.\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tpublic function post($url, $args = array()) {\n\t\t$defaults = array('method' => 'POST');\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\treturn $this->request($url, $r);\n\t}\n\n\t/**\n\t * Uses the GET HTTP method.\n\t *\n\t * Used for sending data that is expected to be in the body.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string $url The request URL.\n\t * @param string|array $args Optional. Override the defaults.\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tpublic function get($url, $args = array()) {\n\t\t$defaults = array('method' => 'GET');\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\treturn $this->request($url, $r);\n\t}\n\n\t/**\n\t * Uses the HEAD HTTP method.\n\t *\n\t * Used for sending data that is expected to be in the body.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t *\n\t * @param string $url The request URL.\n\t * @param string|array $args Optional. Override the defaults.\n\t * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error\n\t */\n\tpublic function head($url, $args = array()) {\n\t\t$defaults = array('method' => 'HEAD');\n\t\t$r = wp_parse_args( $args, $defaults );\n\t\treturn $this->request($url, $r);\n\t}\n\n\t/**\n\t * Parses the responses and splits the parts into headers and body.\n\t *\n\t * @access public\n\t * @static\n\t * @since 2.7.0\n\t *\n\t * @param string $strResponse The full response string\n\t * @return array Array with 'headers' and 'body' keys.\n\t */\n\tpublic static function processResponse($strResponse) {\n\t\t$res = explode(\"\\r\\n\\r\\n\", $strResponse, 2);\n\n\t\treturn array('headers' => $res[0], 'body' => isset($res[1]) ? $res[1] : '');\n\t}\n\n\t/**\n\t * Transform header string into an array.\n\t *\n\t * If an array is given then it is assumed to be raw header data with numeric keys with the\n\t * headers as the values. No headers must be passed that were already processed.\n\t *\n\t * @access public\n\t * @static\n\t * @since 2.7.0\n\t *\n\t * @param string|array $headers\n\t * @param string $url The URL that was requested\n\t * @return array Processed string headers. If duplicate headers are encountered,\n\t * \t\t\t\t\tThen a numbered array is returned as the value of that header-key.\n\t */\n\tpublic static function processHeaders( $headers, $url = '' ) {\n\t\t// Split headers, one per array element.\n\t\tif ( is_string($headers) ) {\n\t\t\t// Tolerate line terminator: CRLF = LF (RFC 2616 19.3).\n\t\t\t$headers = str_replace(\"\\r\\n\", \"\\n\", $headers);\n\t\t\t/*\n\t\t\t * Unfold folded header fields. LWS = [CRLF] 1*( SP | HT ) <US-ASCII SP, space (32)>,\n\t\t\t * <US-ASCII HT, horizontal-tab (9)> (RFC 2616 2.2).\n\t\t\t */\n\t\t\t$headers = preg_replace('/\\n[ \\t]/', ' ', $headers);\n\t\t\t// Create the headers array.\n\t\t\t$headers = explode(\"\\n\", $headers);\n\t\t}\n\n\t\t$response = array('code' => 0, 'message' => '');\n\n\t\t/*\n\t\t * If a redirection has taken place, The headers for each page request may have been passed.\n\t\t * In this case, determine the final HTTP header and parse from there.\n\t\t */\n\t\tfor ( $i = count($headers)-1; $i >= 0; $i-- ) {\n\t\t\tif ( !empty($headers[$i]) && false === strpos($headers[$i], ':') ) {\n\t\t\t\t$headers = array_splice($headers, $i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t$cookies = array();\n\t\t$newheaders = array();\n\t\tforeach ( (array) $headers as $tempheader ) {\n\t\t\tif ( empty($tempheader) )\n\t\t\t\tcontinue;\n\n\t\t\tif ( false === strpos($tempheader, ':') ) {\n\t\t\t\t$stack = explode(' ', $tempheader, 3);\n\t\t\t\t$stack[] = '';\n\t\t\t\tlist( , $response['code'], $response['message']) = $stack;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist($key, $value) = explode(':', $tempheader, 2);\n\n\t\t\t$key = strtolower( $key );\n\t\t\t$value = trim( $value );\n\n\t\t\tif ( isset( $newheaders[ $key ] ) ) {\n\t\t\t\tif ( ! is_array( $newheaders[ $key ] ) )\n\t\t\t\t\t$newheaders[$key] = array( $newheaders[ $key ] );\n\t\t\t\t$newheaders[ $key ][] = $value;\n\t\t\t} else {\n\t\t\t\t$newheaders[ $key ] = $value;\n\t\t\t}\n\t\t\tif ( 'set-cookie' == $key )\n\t\t\t\t$cookies[] = new WP_Http_Cookie( $value, $url );\n\t\t}\n\n\t\t// Cast the Response Code to an int\n\t\t$response['code'] = intval( $response['code'] );\n\n\t\treturn array('response' => $response, 'headers' => $newheaders, 'cookies' => $cookies);\n\t}\n\n\t/**\n\t * Takes the arguments for a ::request() and checks for the cookie array.\n\t *\n\t * If it's found, then it upgrades any basic name => value pairs to WP_Http_Cookie instances,\n\t * which are each parsed into strings and added to the Cookie: header (within the arguments array).\n\t * Edits the array by reference.\n\t *\n\t * @access public\n\t * @version 2.8.0\n\t * @static\n\t *\n\t * @param array $r Full array of args passed into ::request()\n\t */\n\tpublic static function buildCookieHeader( &$r ) {\n\t\tif ( ! empty($r['cookies']) ) {\n\t\t\t// Upgrade any name => value cookie pairs to WP_HTTP_Cookie instances.\n\t\t\tforeach ( $r['cookies'] as $name => $value ) {\n\t\t\t\tif ( ! is_object( $value ) )\n\t\t\t\t\t$r['cookies'][ $name ] = new WP_Http_Cookie( array( 'name' => $name, 'value' => $value ) );\n\t\t\t}\n\n\t\t\t$cookies_header = '';\n\t\t\tforeach ( (array) $r['cookies'] as $cookie ) {\n\t\t\t\t$cookies_header .= $cookie->getHeaderValue() . '; ';\n\t\t\t}\n\n\t\t\t$cookies_header = substr( $cookies_header, 0, -2 );\n\t\t\t$r['headers']['cookie'] = $cookies_header;\n\t\t}\n\t}\n\n\t/**\n\t * Decodes chunk transfer-encoding, based off the HTTP 1.1 specification.\n\t *\n\t * Based off the HTTP http_encoding_dechunk function.\n\t *\n\t * @link https://tools.ietf.org/html/rfc2616#section-19.4.6 Process for chunked decoding.\n\t *\n\t * @access public\n\t * @since 2.7.0\n\t * @static\n\t *\n\t * @param string $body Body content\n\t * @return string Chunked decoded body on success or raw body on failure.\n\t */\n\tpublic static function chunkTransferDecode( $body ) {\n\t\t// The body is not chunked encoded or is malformed.\n\t\tif ( ! preg_match( '/^([0-9a-f]+)[^\\r\\n]*\\r\\n/i', trim( $body ) ) )\n\t\t\treturn $body;\n\n\t\t$parsed_body = '';\n\n\t\t// We'll be altering $body, so need a backup in case of error.\n\t\t$body_original = $body;\n\n\t\twhile ( true ) {\n\t\t\t$has_chunk = (bool) preg_match( '/^([0-9a-f]+)[^\\r\\n]*\\r\\n/i', $body, $match );\n\t\t\tif ( ! $has_chunk || empty( $match[1] ) )\n\t\t\t\treturn $body_original;\n\n\t\t\t$length = hexdec( $match[1] );\n\t\t\t$chunk_length = strlen( $match[0] );\n\n\t\t\t// Parse out the chunk of data.\n\t\t\t$parsed_body .= substr( $body, $chunk_length, $length );\n\n\t\t\t// Remove the chunk from the raw data.\n\t\t\t$body = substr( $body, $length + $chunk_length );\n\n\t\t\t// End of the document.\n\t\t\tif ( '0' === trim( $body ) )\n\t\t\t\treturn $parsed_body;\n\t\t}\n\t}\n\n\t/**\n\t * Block requests through the proxy.\n\t *\n\t * Those who are behind a proxy and want to prevent access to certain hosts may do so. This will\n\t * prevent plugins from working and core functionality, if you don't include api.wordpress.org.\n\t *\n\t * You block external URL requests by defining WP_HTTP_BLOCK_EXTERNAL as true in your wp-config.php\n\t * file and this will only allow localhost and your site to make requests. The constant\n\t * WP_ACCESSIBLE_HOSTS will allow additional hosts to go through for requests. The format of the\n\t * WP_ACCESSIBLE_HOSTS constant is a comma separated list of hostnames to allow, wildcard domains\n\t * are supported, eg *.wordpress.org will allow for all subdomains of wordpress.org to be contacted.\n\t *\n\t * @since 2.8.0\n\t * @link https://core.trac.wordpress.org/ticket/8927 Allow preventing external requests.\n\t * @link https://core.trac.wordpress.org/ticket/14636 Allow wildcard domains in WP_ACCESSIBLE_HOSTS\n\t *\n\t * @staticvar array|null $accessible_hosts\n\t * @staticvar array      $wildcard_regex\n\t *\n\t * @param string $uri URI of url.\n\t * @return bool True to block, false to allow.\n\t */\n\tpublic function block_request($uri) {\n\t\t// We don't need to block requests, because nothing is blocked.\n\t\tif ( ! defined( 'WP_HTTP_BLOCK_EXTERNAL' ) || ! WP_HTTP_BLOCK_EXTERNAL )\n\t\t\treturn false;\n\n\t\t$check = parse_url($uri);\n\t\tif ( ! $check )\n\t\t\treturn true;\n\n\t\t$home = parse_url( get_option('siteurl') );\n\n\t\t// Don't block requests back to ourselves by default.\n\t\tif ( 'localhost' == $check['host'] || ( isset( $home['host'] ) && $home['host'] == $check['host'] ) ) {\n\t\t\t/**\n\t\t\t * Filters whether to block local requests through the proxy.\n\t\t\t *\n\t\t\t * @since 2.8.0\n\t\t\t *\n\t\t\t * @param bool $block Whether to block local requests through proxy.\n\t\t\t *                    Default false.\n\t\t\t */\n\t\t\treturn apply_filters( 'block_local_requests', false );\n\t\t}\n\n\t\tif ( !defined('WP_ACCESSIBLE_HOSTS') )\n\t\t\treturn true;\n\n\t\tstatic $accessible_hosts = null;\n\t\tstatic $wildcard_regex = array();\n\t\tif ( null === $accessible_hosts ) {\n\t\t\t$accessible_hosts = preg_split('|,\\s*|', WP_ACCESSIBLE_HOSTS);\n\n\t\t\tif ( false !== strpos(WP_ACCESSIBLE_HOSTS, '*') ) {\n\t\t\t\t$wildcard_regex = array();\n\t\t\t\tforeach ( $accessible_hosts as $host )\n\t\t\t\t\t$wildcard_regex[] = str_replace( '\\*', '.+', preg_quote( $host, '/' ) );\n\t\t\t\t$wildcard_regex = '/^(' . implode('|', $wildcard_regex) . ')$/i';\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty($wildcard_regex) )\n\t\t\treturn !preg_match($wildcard_regex, $check['host']);\n\t\telse\n\t\t\treturn !in_array( $check['host'], $accessible_hosts ); //Inverse logic, If it's in the array, then we can't access it.\n\n\t}\n\n\t/**\n\t * Used as a wrapper for PHP's parse_url() function that handles edgecases in < PHP 5.4.7.\n\t *\n\t * @access protected\n\t * @deprecated 4.4.0 Use wp_parse_url()\n\t * @see wp_parse_url()\n\t *\n\t * @param string $url The URL to parse.\n\t * @return bool|array False on failure; Array of URL components on success;\n\t *                    See parse_url()'s return values.\n\t */\n\tprotected static function parse_url( $url ) {\n\t\t_deprecated_function( __METHOD__, '4.4.0', 'wp_parse_url()' );\n\t\treturn wp_parse_url( $url );\n\t}\n\n\t/**\n\t * Converts a relative URL to an absolute URL relative to a given URL.\n\t *\n\t * If an Absolute URL is provided, no processing of that URL is done.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @static\n\t * @access public\n\t *\n\t * @param string $maybe_relative_path The URL which might be relative\n\t * @param string $url                 The URL which $maybe_relative_path is relative to\n\t * @return string An Absolute URL, in a failure condition where the URL cannot be parsed, the relative URL will be returned.\n\t */\n\tpublic static function make_absolute_url( $maybe_relative_path, $url ) {\n\t\tif ( empty( $url ) )\n\t\t\treturn $maybe_relative_path;\n\n\t\tif ( ! $url_parts = wp_parse_url( $url ) ) {\n\t\t\treturn $maybe_relative_path;\n\t\t}\n\n\t\tif ( ! $relative_url_parts = wp_parse_url( $maybe_relative_path ) ) {\n\t\t\treturn $maybe_relative_path;\n\t\t}\n\n\t\t// Check for a scheme on the 'relative' url\n\t\tif ( ! empty( $relative_url_parts['scheme'] ) ) {\n\t\t\treturn $maybe_relative_path;\n\t\t}\n\n\t\t$absolute_path = $url_parts['scheme'] . '://';\n\n\t\t// Schemeless URL's will make it this far, so we check for a host in the relative url and convert it to a protocol-url\n\t\tif ( isset( $relative_url_parts['host'] ) ) {\n\t\t\t$absolute_path .= $relative_url_parts['host'];\n\t\t\tif ( isset( $relative_url_parts['port'] ) )\n\t\t\t\t$absolute_path .= ':' . $relative_url_parts['port'];\n\t\t} else {\n\t\t\t$absolute_path .= $url_parts['host'];\n\t\t\tif ( isset( $url_parts['port'] ) )\n\t\t\t\t$absolute_path .= ':' . $url_parts['port'];\n\t\t}\n\n\t\t// Start off with the Absolute URL path.\n\t\t$path = ! empty( $url_parts['path'] ) ? $url_parts['path'] : '/';\n\n\t\t// If it's a root-relative path, then great.\n\t\tif ( ! empty( $relative_url_parts['path'] ) && '/' == $relative_url_parts['path'][0] ) {\n\t\t\t$path = $relative_url_parts['path'];\n\n\t\t// Else it's a relative path.\n\t\t} elseif ( ! empty( $relative_url_parts['path'] ) ) {\n\t\t\t// Strip off any file components from the absolute path.\n\t\t\t$path = substr( $path, 0, strrpos( $path, '/' ) + 1 );\n\n\t\t\t// Build the new path.\n\t\t\t$path .= $relative_url_parts['path'];\n\n\t\t\t// Strip all /path/../ out of the path.\n\t\t\twhile ( strpos( $path, '../' ) > 1 ) {\n\t\t\t\t$path = preg_replace( '![^/]+/\\.\\./!', '', $path );\n\t\t\t}\n\n\t\t\t// Strip any final leading ../ from the path.\n\t\t\t$path = preg_replace( '!^/(\\.\\./)+!', '', $path );\n\t\t}\n\n\t\t// Add the Query string.\n\t\tif ( ! empty( $relative_url_parts['query'] ) )\n\t\t\t$path .= '?' . $relative_url_parts['query'];\n\n\t\treturn $absolute_path . '/' . ltrim( $path, '/' );\n\t}\n\n\t/**\n\t * Handles HTTP Redirects and follows them if appropriate.\n\t *\n\t * @since 3.7.0\n\t *\n\t * @static\n\t *\n\t * @param string $url The URL which was requested.\n\t * @param array $args The Arguments which were used to make the request.\n\t * @param array $response The Response of the HTTP request.\n\t * @return false|object False if no redirect is present, a WP_HTTP or WP_Error result otherwise.\n\t */\n\tpublic static function handle_redirects( $url, $args, $response ) {\n\t\t// If no redirects are present, or, redirects were not requested, perform no action.\n\t\tif ( ! isset( $response['headers']['location'] ) || 0 === $args['_redirection'] )\n\t\t\treturn false;\n\n\t\t// Only perform redirections on redirection http codes.\n\t\tif ( $response['response']['code'] > 399 || $response['response']['code'] < 300 )\n\t\t\treturn false;\n\n\t\t// Don't redirect if we've run out of redirects.\n\t\tif ( $args['redirection']-- <= 0 )\n\t\t\treturn new WP_Error( 'http_request_failed', __('Too many redirects.') );\n\n\t\t$redirect_location = $response['headers']['location'];\n\n\t\t// If there were multiple Location headers, use the last header specified.\n\t\tif ( is_array( $redirect_location ) )\n\t\t\t$redirect_location = array_pop( $redirect_location );\n\n\t\t$redirect_location = WP_Http::make_absolute_url( $redirect_location, $url );\n\n\t\t// POST requests should not POST to a redirected location.\n\t\tif ( 'POST' == $args['method'] ) {\n\t\t\tif ( in_array( $response['response']['code'], array( 302, 303 ) ) )\n\t\t\t\t$args['method'] = 'GET';\n\t\t}\n\n\t\t// Include valid cookies in the redirect process.\n\t\tif ( ! empty( $response['cookies'] ) ) {\n\t\t\tforeach ( $response['cookies'] as $cookie ) {\n\t\t\t\tif ( $cookie->test( $redirect_location ) )\n\t\t\t\t\t$args['cookies'][] = $cookie;\n\t\t\t}\n\t\t}\n\n\t\treturn wp_remote_request( $redirect_location, $args );\n\t}\n\n\t/**\n\t * Determines if a specified string represents an IP address or not.\n\t *\n\t * This function also detects the type of the IP address, returning either\n\t * '4' or '6' to represent a IPv4 and IPv6 address respectively.\n\t * This does not verify if the IP is a valid IP, only that it appears to be\n\t * an IP address.\n\t *\n\t * @link http://home.deds.nl/~aeron/regex/ for IPv6 regex\n\t *\n\t * @since 3.7.0\n\t * @static\n\t *\n\t * @param string $maybe_ip A suspected IP address\n\t * @return integer|bool Upon success, '4' or '6' to represent a IPv4 or IPv6 address, false upon failure\n\t */\n\tpublic static function is_ip_address( $maybe_ip ) {\n\t\tif ( preg_match( '/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/', $maybe_ip ) )\n\t\t\treturn 4;\n\n\t\tif ( false !== strpos( $maybe_ip, ':' ) && preg_match( '/^(((?=.*(::))(?!.*\\3.+\\3))\\3?|([\\dA-F]{1,4}(\\3|:\\b|$)|\\2))(?4){5}((?4){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/i', trim( $maybe_ip, ' []' ) ) )\n\t\t\treturn 6;\n\n\t\treturn false;\n\t}\n\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '4.8-beta1-40689';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 38590;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4601-20170510';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/class-http.php", "wp-includes/version.php"], "buggy_code_start_loc": [308, 7], "buggy_code_end_loc": [465, 8], "fixing_code_start_loc": [309, 7], "fixing_code_end_loc": [485, 8], "type": "CWE-918", "message": "In WordPress before 4.7.5, there is insufficient redirect validation in the HTTP class, leading to SSRF.", "other": {"cve": {"id": "CVE-2017-9066", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-18T14:29:00.387", "lastModified": "2019-03-15T11:52:24.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In WordPress before 4.7.5, there is insufficient redirect validation in the HTTP class, leading to SSRF."}, {"lang": "es", "value": "En WordPress anterior a versi\u00f3n 4.7.5, no hay suficiente validaci\u00f3n de redireccionamiento en la clase de HTTP, lo que conlleva a una vulnerabilidad de tipo SSRF."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7.4", "matchCriteriaId": "0F07CF70-A29C-490E-8728-C51AED224D76"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/98509", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038520", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://codex.wordpress.org/Version_4.7.5", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "https://github.com/WordPress/WordPress/commit/76d77e927bb4d0f87c7262a50e28d84e01fd2b11", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://twitter.com/skansing/status/865362551097393153", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://wordpress.org/news/2017/05/wordpress-4-7-5/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/8815", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4090", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/76d77e927bb4d0f87c7262a50e28d84e01fd2b11"}}