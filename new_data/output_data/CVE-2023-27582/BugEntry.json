{"buggy_code": ["maddy-auth(5) \"maddy mail server\" \"maddy authentication backends\"\n\n; TITLE Authentication backends\n\n# Introduction\n\nModules described in this man page can be used to provide functionality to\ncheck validity of username-password pairs in accordance with some database.\nThat is, they authenticate users.\n\nMost likely, you are going to use these modules with 'auth' directive of IMAP\n(*maddy-imap*(5)) or SMTP endpoint (*maddy-smtp*(5)).\n\n# SQL module (sql)\n\nsql module described in *maddy-storage*(5) can also be used as a authentication\nbackend.\n\nThe authorization identity is required to be a valid RFC 5321 e-mail address.\nIt is returned as the authorization identity.\n\n# External authentication module (extauth)\n\nModule for authentication using external helper binary. It looks for binary\nnamed maddy-auth-helper in $PATH and libexecdir and uses it for authentication\nusing username/password pair.\n\nThe protocol is very simple:\nProgram is launched for each authentication. Username and password are written\nto stdin, adding \\\\n to the end. If binary exits with 0 status code -\nauthentication is considered successful. If the status code is 1 -\nauthentication is failed. If the status code is 2 - another unrelated error has\nhappened. Additional information should be written to stderr.\n\nThe authorization identtity is the same as authorization identity.\n\n```\nextauth {\n    helper /usr/bin/ldap-helper\n    perdomain no\n    domains example.org\n}\n```\n\n## Configuration directives\n\n*Syntax*: helper _file_path_\n\nLocation of the helper binary. *Required.*\n\n*Syntax*: perdomain _boolean_ ++\n*Default*: no\n\nDon't remove domain part of username when authenticating and require it to be\npresent. Can be used if you want user@domain1 and user@domain2 to be different\naccounts.\n\n*Syntax*: domains _domains..._ ++\n*Default*: not specified\n\nDomains that should be allowed in username during authentication.\n\nFor example, if 'domains' is set to \"domain1 domain2\", then\nusername, username@domain1 and username@domain2 will be accepted as valid login\nname in addition to just username.\n\nIf used without 'perdomain', domain part will be removed from login before\ncheck with underlying auth. mechanism. If 'perdomain' is set, then\ndomains must be also set and domain part WILL NOT be removed before check.\n\n# PAM module (pam)\n\nImplements authentication using libpam. Alternatively it can be configured to\nuse helper binary like extauth module does.\n\nmaddy should be built with libpam build tag to use this module without\n'use_helper' directive.\n```\ngo get -tags 'libpam' ...\n```\n\nThe authorization identtity is the same as authorization identity.\n\n```\npam {\n    debug no\n    use_helper no\n\texpect_address yes\n}\n```\n\n## Configuration directives\n\n*Syntax*: debug _boolean_ ++\n*Default*: no\n\nEnable verbose logging for all modules. You don't need that unless you are\nreporting a bug.\n\n*Syntax*: use_helper _boolean_ ++\n*Default*: no\n\nUse LibexecDirectory/maddy-pam-helper instead of directly calling libpam.\nYou need to use that if:\n1. maddy is not compiled with libpam, but maddy-pam-helper is built separately.\n2. maddy is running as an unprivileged user and used PAM configuration requires additional\nprivileges (e.g. when using system accounts).\n\nFor 2, you need to make maddy-pam-helper binary setuid, see\nREADME.md in source tree for details.\n\nTL;DR (assuming you have maddy group):\n```\nchown root:maddy /usr/lib/maddy/maddy-pam-helper\nchmod u+xs,g+x,o-x /usr/lib/maddy/maddy-pam-helper\n```\n\n# Shadow database authentication module (shadow)\n\nImplements authentication by reading /etc/shadow. Alternatively it can be\nconfigured to use helper binary like extauth does.\n\nThe authorization identtity is the same as authorization identity.\n\n```\nshadow {\n    debug no\n    use_helper no\n}\n```\n\n## Configuration directives\n\n*Syntax*: debug _boolean_ ++\n*Default*: no\n\nEnable verbose logging for all modules. You don't need that unless you are\nreporting a bug.\n\n*Syntax*: use_helper _boolean_ ++\n*Default*: no\n\nUse LibexecDirectory/maddy-shadow-helper instead of directly reading /etc/shadow.\nYou need to use that if maddy is running as an unprivileged user\nprivileges (e.g. when using system accounts).\n\nYou need to make maddy-shadow-helper binary setuid, see\ncmd/maddy-shadow-helper/README.md in source tree for details.\n\nTL;DR (assuming you have maddy group):\n```\nchown root:maddy /usr/lib/maddy/maddy-shadow-helper\nchmod u+xs,g+x,o-x /usr/lib/maddy/maddy-shadow-helper\n```\n\n# Separate username and password lookup (plain_separate)\n\nThis modules implements authentication using username:password pairs but can\nuse zero or more \"table modules\" (maddy-tables(5)) and one or more\nauthentication providers to verify credentials.\n\n```\nplain_separate {\n\tuser ...\n\tuser ...\n\t...\n\tpass ...\n\tpass ...\n\t...\n}\n```\n\nHow it works:\n1. Initial username input is normalized using PRECIS UsernameCaseMapped profile.\n2. Each table specified with the 'user' directive looked up using normalized\n   username. If match is not found in any table, authentication fails.\n3. Each authentication provider specified with the 'pass' directive is tried.\n   First match wins same as in step 2.\n\nThe set of authorization identities estabilished by plain_separate is the list of\nstrings found in 'user' tables. If there are no 'user' tables (only 'pass'\ndirectives are specified), the list of authorization identities returned by\nauth. providers is used.\n*Note*: If a username table returns empty string, the authorization identity is\nassumed to be the same as authentication identity.\n\n## Configuration directives\n\n**Syntax:** user _table module_\n\nConfiguration block for any module from maddy-tables(5) can be used here.\n\nExample:\n```\nuser file_table /etc/maddy/allowed_users\n```\n\n**Syntax:** pass _auth provider_\n\nConfiguration block for any auth. provider module can be used here, even\n'plain_split' itself.\n\nThe used auth. provider must provide username:password pair-based\nauthentication.\n", "package external\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/foxcpp/maddy/internal/auth\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype ExternalAuth struct {\n\tmodName    string\n\tinstName   string\n\thelperPath string\n\n\tperDomain bool\n\tdomains   []string\n\n\tLog log.Logger\n}\n\nfunc NewExternalAuth(modName, instName string, _, inlineArgs []string) (module.Module, error) {\n\tea := &ExternalAuth{\n\t\tmodName:  modName,\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: modName},\n\t}\n\n\tif len(inlineArgs) != 0 {\n\t\treturn nil, errors.New(\"external: inline arguments are not used\")\n\t}\n\n\treturn ea, nil\n}\n\nfunc (ea *ExternalAuth) Name() string {\n\treturn ea.modName\n}\n\nfunc (ea *ExternalAuth) InstanceName() string {\n\treturn ea.instName\n}\n\nfunc (ea *ExternalAuth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", false, false, &ea.Log.Debug)\n\tcfg.Bool(\"perdomain\", false, false, &ea.perDomain)\n\tcfg.StringList(\"domains\", false, false, nil, &ea.domains)\n\tcfg.String(\"helper\", false, false, \"\", &ea.helperPath)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\tif ea.perDomain && ea.domains == nil {\n\t\treturn errors.New(\"auth_domains must be set if auth_perdomain is used\")\n\t}\n\n\tif ea.helperPath != \"\" {\n\t\tea.Log.Debugln(\"using helper:\", ea.helperPath)\n\t} else {\n\t\tea.helperPath = filepath.Join(config.LibexecDirectory, \"maddy-auth-helper\")\n\t}\n\tif _, err := os.Stat(ea.helperPath); err != nil {\n\t\treturn fmt.Errorf(\"%s doesn't exist\", ea.helperPath)\n\t}\n\n\tea.Log.Debugln(\"using helper:\", ea.helperPath)\n\n\treturn nil\n}\n\nfunc (ea *ExternalAuth) AuthPlain(username, password string) ([]string, error) {\n\taccountName, ok := auth.CheckDomainAuth(username, ea.perDomain, ea.domains)\n\tif !ok {\n\t\treturn nil, module.ErrUnknownCredentials\n\t}\n\n\t// TODO: Extend process protocol to support multiple authorization identities.\n\treturn []string{username}, AuthUsingHelper(ea.helperPath, accountName, password)\n}\n\nfunc init() {\n\tmodule.Register(\"extauth\", NewExternalAuth)\n}\n", "package pam\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/foxcpp/maddy/internal/auth/external\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype Auth struct {\n\tinstName   string\n\tuseHelper  bool\n\thelperPath string\n\n\tLog log.Logger\n}\n\nfunc New(modName, instName string, _, inlineArgs []string) (module.Module, error) {\n\tif len(inlineArgs) != 0 {\n\t\treturn nil, errors.New(\"pam: inline arguments are not used\")\n\t}\n\treturn &Auth{\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: modName},\n\t}, nil\n}\n\nfunc (a *Auth) Name() string {\n\treturn \"pam\"\n}\n\nfunc (a *Auth) InstanceName() string {\n\treturn a.instName\n}\n\nfunc (a *Auth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", true, false, &a.Log.Debug)\n\tcfg.Bool(\"use_helper\", false, false, &a.useHelper)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\tif !canCallDirectly && !a.useHelper {\n\t\treturn errors.New(\"pam: this build lacks support for direct libpam invocation, use helper binary\")\n\t}\n\n\tif a.useHelper {\n\t\ta.helperPath = filepath.Join(config.LibexecDirectory, \"maddy-pam-helper\")\n\t\tif _, err := os.Stat(a.helperPath); err != nil {\n\t\t\treturn fmt.Errorf(\"pam: no helper binary (maddy-pam-helper) found in %s\", config.LibexecDirectory)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) AuthPlain(username, password string) ([]string, error) {\n\tif a.useHelper {\n\t\tif err := external.AuthUsingHelper(a.helperPath, username, password); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\terr := runPAMAuth(username, password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn []string{username}, nil\n}\n\nfunc init() {\n\tmodule.Register(\"pam\", New)\n}\n", "package plain_separate\n\nimport (\n\t\"errors\"\n\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"golang.org/x/text/secure/precis\"\n)\n\ntype Auth struct {\n\tmodName  string\n\tinstName string\n\n\tuserTbls []module.Table\n\tpasswd   []module.PlainAuth\n\n\tonlyFirstID bool\n\n\tLog log.Logger\n}\n\nfunc NewAuth(modName, instName string, _, inlinargs []string) (module.Module, error) {\n\ta := &Auth{\n\t\tmodName:     modName,\n\t\tinstName:    instName,\n\t\tonlyFirstID: false,\n\t\tLog:         log.Logger{Name: modName},\n\t}\n\n\tif len(inlinargs) != 0 {\n\t\treturn nil, errors.New(\"plain_separate: inline arguments are not used\")\n\t}\n\n\treturn a, nil\n}\n\nfunc (a *Auth) Name() string {\n\treturn a.modName\n}\n\nfunc (a *Auth) InstanceName() string {\n\treturn a.instName\n}\n\nfunc (a *Auth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", false, false, &a.Log.Debug)\n\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) AuthPlain(username, password string) ([]string, error) {\n\tkey, err := precis.UsernameCaseMapped.CompareKey(username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tidentities := make([]string, 0, 1)\n\tif len(a.userTbls) != 0 {\n\t\tfor _, tbl := range a.userTbls {\n\t\t\trepl, ok, err := tbl.Lookup(key)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif repl != \"\" {\n\t\t\t\tidentities = append(identities, repl)\n\t\t\t} else {\n\t\t\t\tidentities = append(identities, key)\n\t\t\t}\n\t\t\tif a.onlyFirstID && len(identities) != 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif len(identities) == 0 {\n\t\t\treturn nil, errors.New(\"plain_separate: unknown credentials\")\n\t\t}\n\t}\n\n\tvar (\n\t\tlastErr error\n\t\tok      bool\n\t)\n\tfor _, pass := range a.passwd {\n\t\tpassIDs, err := pass.AuthPlain(username, password)\n\t\tif err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\t\tif len(a.userTbls) == 0 {\n\t\t\tidentities = append(identities, passIDs...)\n\t\t}\n\t\tok = true\n\t}\n\tif !ok {\n\t\treturn nil, lastErr\n\t}\n\n\treturn identities, nil\n}\n\nfunc init() {\n\tmodule.Register(\"plain_separate\", NewAuth)\n}\n", "package plain_separate\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype mockAuth struct {\n\tdb map[string][]string\n}\n\nfunc (mockAuth) SASLMechanisms() []string {\n\treturn []string{sasl.Plain, sasl.Login}\n}\n\nfunc (m mockAuth) AuthPlain(username, _ string) ([]string, error) {\n\tids, ok := m.db[username]\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid creds\")\n\t}\n\treturn ids, nil\n}\n\ntype mockTable struct {\n\tdb map[string]string\n}\n\nfunc (m mockTable) Lookup(a string) (string, bool, error) {\n\tb, ok := m.db[a]\n\treturn b, ok, nil\n}\n\nfunc TestPlainSplit_NoUser(t *testing.T) {\n\ta := Auth{\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user1\": []string{\"user1a\", \"user1b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tids, err := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n\tif !reflect.DeepEqual(ids, []string{\"user1a\", \"user1b\"}) {\n\t\tt.Fatal(\"Wrong ids returned:\", ids)\n\t}\n}\n\nfunc TestPlainSplit_NoUser_MultiPass(t *testing.T) {\n\ta := Auth{\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user2\": []string{\"user2a\", \"user2b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user1\": []string{\"user1a\", \"user1b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tids, err := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n\tif !reflect.DeepEqual(ids, []string{\"user1a\", \"user1b\"}) {\n\t\tt.Fatal(\"Wrong ids returned:\", ids)\n\t}\n}\n\nfunc TestPlainSplit_UserPass(t *testing.T) {\n\ta := Auth{\n\t\tuserTbls: []module.Table{\n\t\t\tmockTable{\n\t\t\t\tdb: map[string]string{\n\t\t\t\t\t\"user1\": \"user2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user2\": []string{\"user2a\", \"user2b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user1\": []string{\"user1a\", \"user1b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tids, err := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n\tif !reflect.DeepEqual(ids, []string{\"user2\"}) {\n\t\tt.Fatal(\"Wrong ids returned:\", ids)\n\t}\n}\n\nfunc TestPlainSplit_MultiUser_Pass(t *testing.T) {\n\ta := Auth{\n\t\tuserTbls: []module.Table{\n\t\t\tmockTable{\n\t\t\t\tdb: map[string]string{\n\t\t\t\t\t\"userWH\": \"user1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockTable{\n\t\t\t\tdb: map[string]string{\n\t\t\t\t\t\"user1\": \"user2\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user2\": []string{\"user2a\", \"user2b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user1\": []string{\"user1a\", \"user1b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tids, err := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n\tif !reflect.DeepEqual(ids, []string{\"user2\"}) {\n\t\tt.Fatal(\"Wrong ids returned:\", ids)\n\t}\n}\n", "package auth\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\tmodconfig \"github.com/foxcpp/maddy/internal/config/module\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"golang.org/x/text/secure/precis\"\n)\n\nvar (\n\tErrUnsupportedMech = errors.New(\"Unsupported SASL mechanism\")\n)\n\n// SASLAuth is a wrapper that initializes sasl.Server using authenticators that\n// call maddy module objects.\n//\n// It supports reporting of multiple authorization identities so multiple\n// accounts can be associated with a single set of credentials.\ntype SASLAuth struct {\n\tLog         log.Logger\n\tOnlyFirstID bool\n\n\tPlain []module.PlainAuth\n}\n\nfunc (s *SASLAuth) SASLMechanisms() []string {\n\tvar mechs []string\n\n\tif len(s.Plain) != 0 {\n\t\tmechs = append(mechs, sasl.Plain, sasl.Login)\n\t}\n\n\treturn mechs\n}\n\nfunc (s *SASLAuth) AuthPlain(username, password string) ([]string, error) {\n\tif len(s.Plain) == 0 {\n\t\treturn nil, ErrUnsupportedMech\n\t}\n\n\tvar lastErr error\n\taccounts := make([]string, 0, 1)\n\tfor _, p := range s.Plain {\n\t\tpAccs, err := p.AuthPlain(username, password)\n\t\tif err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\n\t\tif s.OnlyFirstID {\n\t\t\treturn pAccs, nil\n\t\t}\n\t\taccounts = append(accounts, pAccs...)\n\t}\n\n\tif len(accounts) == 0 {\n\t\treturn nil, fmt.Errorf(\"no auth. provider accepted creds, last err: %w\", lastErr)\n\t}\n\treturn accounts, nil\n}\n\nfunc filterIdentity(accounts []string, identity string) ([]string, error) {\n\tif identity == \"\" {\n\t\treturn accounts, nil\n\t}\n\n\tmatchFound := false\n\tfor _, acc := range accounts {\n\t\tif precis.UsernameCaseMapped.Compare(acc, identity) {\n\t\t\taccounts = []string{identity}\n\t\t\tmatchFound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !matchFound {\n\t\treturn nil, errors.New(\"auth: invalid credentials\")\n\t}\n\treturn accounts, nil\n}\n\n// CreateSASL creates the sasl.Server instance for the corresponding mechanism.\n//\n// successCb will be called with the slice of authorization identities\n// associated with credentials used.\n// If it fails - authentication will fail too.\nfunc (s *SASLAuth) CreateSASL(mech string, remoteAddr net.Addr, successCb func([]string) error) sasl.Server {\n\tswitch mech {\n\tcase sasl.Plain:\n\t\treturn sasl.NewPlainServer(func(identity, username, password string) error {\n\t\t\taccounts, err := s.AuthPlain(username, password)\n\t\t\tif err != nil {\n\t\t\t\ts.Log.Error(\"authentication failed\", err, \"username\", username, \"identity\", identity, \"src_ip\", remoteAddr)\n\t\t\t\treturn errors.New(\"auth: invalid credentials\")\n\t\t\t}\n\t\t\tif len(accounts) == 0 {\n\t\t\t\taccounts = []string{username}\n\t\t\t}\n\t\t\taccounts, err = filterIdentity(accounts, identity)\n\t\t\tif err != nil {\n\t\t\t\ts.Log.Error(\"not authorized\", err, \"username\", username, \"identity\", identity, \"src_ip\", remoteAddr)\n\t\t\t\treturn errors.New(\"auth: invalid credentials\")\n\t\t\t}\n\n\t\t\treturn successCb(accounts)\n\t\t})\n\tcase sasl.Login:\n\t\treturn sasl.NewLoginServer(func(username, password string) error {\n\t\t\taccounts, err := s.AuthPlain(username, password)\n\t\t\tif err != nil {\n\t\t\t\ts.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", remoteAddr)\n\t\t\t\treturn errors.New(\"auth: invalid credentials\")\n\t\t\t}\n\n\t\t\treturn successCb(accounts)\n\t\t})\n\t}\n\treturn FailingSASLServ{Err: ErrUnsupportedMech}\n}\n\n// AddProvider adds the SASL authentication provider to its mapping by parsing\n// the 'auth' configuration directive.\nfunc (s *SASLAuth) AddProvider(m *config.Map, node *config.Node) error {\n\tmod, err := modconfig.SASLAuthDirective(m, node)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsaslAuth := mod.(module.SASLProvider)\n\tfor _, mech := range saslAuth.SASLMechanisms() {\n\t\tswitch mech {\n\t\tcase sasl.Login, sasl.Plain:\n\t\t\tplainAuth, ok := saslAuth.(module.PlainAuth)\n\t\t\tif !ok {\n\t\t\t\treturn m.MatchErr(\"auth: provider does not implement PlainAuth even though it reports PLAIN/LOGIN mechanism\")\n\t\t\t}\n\t\t\ts.Plain = append(s.Plain, plainAuth)\n\t\tdefault:\n\t\t\treturn m.MatchErr(\"auth: unknown SASL mechanism\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype FailingSASLServ struct{ Err error }\n\nfunc (s FailingSASLServ) Next([]byte) ([]byte, bool, error) {\n\treturn nil, true, s.Err\n}\n", "package auth\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/testutils\"\n)\n\ntype mockAuth struct {\n\tdb map[string][]string\n}\n\nfunc (mockAuth) SASLMechanisms() []string {\n\treturn []string{sasl.Plain, sasl.Login}\n}\n\nfunc (m mockAuth) AuthPlain(username, _ string) ([]string, error) {\n\tids, ok := m.db[username]\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid creds\")\n\t}\n\treturn ids, nil\n}\n\nfunc TestCreateSASL(t *testing.T) {\n\ta := SASLAuth{\n\t\tLog: testutils.Logger(t, \"saslauth\"),\n\t\tPlain: []module.PlainAuth{\n\t\t\t&mockAuth{\n\t\t\t\tdb: map[string][]string{\n\t\t\t\t\t\"user1\": []string{\"user1a\", \"user1b\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tt.Run(\"XWHATEVER\", func(t *testing.T) {\n\t\tsrv := a.CreateSASL(\"XWHATEVER\", &net.TCPAddr{}, func([]string) error { return nil })\n\t\t_, _, err := srv.Next([]byte(\"\"))\n\t\tif err == nil {\n\t\t\tt.Error(\"No error for XWHATEVER use\")\n\t\t}\n\t})\n\n\tt.Run(\"PLAIN\", func(t *testing.T) {\n\t\tvar ids []string\n\t\tsrv := a.CreateSASL(\"PLAIN\", &net.TCPAddr{}, func(passed []string) error {\n\t\t\tids = passed\n\t\t\treturn nil\n\t\t})\n\n\t\t_, _, err := srv.Next([]byte(\"\\x00user1\\x00aa\"))\n\t\tif err != nil {\n\t\t\tt.Error(\"Unexpected error:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(ids, []string{\"user1a\", \"user1b\"}) {\n\t\t\tt.Error(\"Wrong auth. identities passed to callback:\", ids)\n\t\t}\n\t})\n\n\tt.Run(\"PLAIN with autorization identity\", func(t *testing.T) {\n\t\tvar ids []string\n\t\tsrv := a.CreateSASL(\"PLAIN\", &net.TCPAddr{}, func(passed []string) error {\n\t\t\tids = passed\n\t\t\treturn nil\n\t\t})\n\n\t\t_, _, err := srv.Next([]byte(\"user1a\\x00user1\\x00aa\"))\n\t\tif err != nil {\n\t\t\tt.Error(\"Unexpected error:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(ids, []string{\"user1a\"}) {\n\t\t\tt.Error(\"Wrong auth. identities passed to callback:\", ids)\n\t\t}\n\t})\n\n\tt.Run(\"PLAIN with wrong authorization identity\", func(t *testing.T) {\n\t\tsrv := a.CreateSASL(\"PLAIN\", &net.TCPAddr{}, func(passed []string) error {\n\t\t\treturn nil\n\t\t})\n\n\t\t_, _, err := srv.Next([]byte(\"user1c\\x00user1\\x00aa\"))\n\t\tif err == nil {\n\t\t\tt.Error(\"Next should fail\")\n\t\t}\n\t})\n\n\tt.Run(\"PLAIN with wrong authentication identity\", func(t *testing.T) {\n\t\tsrv := a.CreateSASL(\"PLAIN\", &net.TCPAddr{}, func(passed []string) error {\n\t\t\treturn nil\n\t\t})\n\n\t\t_, _, err := srv.Next([]byte(\"\\x00user2\\x00aa\"))\n\t\tif err == nil {\n\t\t\tt.Error(\"Next should fail\")\n\t\t}\n\t})\n}\n", "// +build !windows\n\npackage shadow\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/foxcpp/maddy/internal/auth/external\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype Auth struct {\n\tinstName   string\n\tuseHelper  bool\n\thelperPath string\n\n\tLog log.Logger\n}\n\nfunc New(modName, instName string, _, inlineArgs []string) (module.Module, error) {\n\tif len(inlineArgs) != 0 {\n\t\treturn nil, errors.New(\"shadow: inline arguments are not used\")\n\t}\n\treturn &Auth{\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: modName},\n\t}, nil\n}\n\nfunc (a *Auth) Name() string {\n\treturn \"shadow\"\n}\n\nfunc (a *Auth) InstanceName() string {\n\treturn a.instName\n}\n\nfunc (a *Auth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", true, false, &a.Log.Debug)\n\tcfg.Bool(\"use_helper\", false, false, &a.useHelper)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\tif a.useHelper {\n\t\ta.helperPath = filepath.Join(config.LibexecDirectory, \"maddy-shadow-helper\")\n\t\tif _, err := os.Stat(a.helperPath); err != nil {\n\t\t\treturn fmt.Errorf(\"shadow: no helper binary (maddy-shadow-helper) found in %s\", config.LibexecDirectory)\n\t\t}\n\t} else {\n\t\tf, err := os.Open(\"/etc/shadow\")\n\t\tif err != nil {\n\t\t\tif os.IsPermission(err) {\n\t\t\t\treturn fmt.Errorf(\"shadow: can't read /etc/shadow due to permission error, use helper binary or run maddy as a privileged user\")\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"shadow: can't read /etc/shadow: %v\", err)\n\t\t}\n\t\tf.Close()\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) AuthPlain(username, password string) ([]string, error) {\n\tif a.useHelper {\n\t\treturn []string{username}, external.AuthUsingHelper(a.helperPath, username, password)\n\t}\n\n\tent, err := Lookup(username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !ent.IsAccountValid() {\n\t\treturn nil, fmt.Errorf(\"shadow: account is expired\")\n\t}\n\n\tif !ent.IsPasswordValid() {\n\t\treturn nil, fmt.Errorf(\"shadow: password is expired\")\n\t}\n\n\tif err := ent.VerifyPassword(password); err != nil {\n\t\tif err == ErrWrongPassword {\n\t\t\treturn nil, module.ErrUnknownCredentials\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn []string{username}, nil\n}\n\nfunc init() {\n\tmodule.Register(\"shadow\", New)\n}\n", "package modconfig\n\nimport (\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\nfunc MessageCheck(globals map[string]interface{}, args []string, block *config.Node) (module.Check, error) {\n\tvar check module.Check\n\tif err := ModuleFromNode(args, block, globals, &check); err != nil {\n\t\treturn nil, err\n\t}\n\treturn check, nil\n}\n\n// deliveryDirective is a callback for use in config.Map.Custom.\n//\n// It does all work necessary to create a module instance from the config\n// directive with the following structure:\n// directive_name mod_name [inst_name] [{\n//   inline_mod_config\n// }]\n//\n// Note that if used configuration structure lacks directive_name before mod_name - this function\n// should not be used (call DeliveryTarget directly).\nfunc DeliveryDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\treturn DeliveryTarget(m.Globals, node.Args, node)\n}\n\nfunc DeliveryTarget(globals map[string]interface{}, args []string, block *config.Node) (module.DeliveryTarget, error) {\n\tvar target module.DeliveryTarget\n\tif err := ModuleFromNode(args, block, globals, &target); err != nil {\n\t\treturn nil, err\n\t}\n\treturn target, nil\n}\n\nfunc MsgModifier(globals map[string]interface{}, args []string, block *config.Node) (module.Modifier, error) {\n\tvar check module.Modifier\n\tif err := ModuleFromNode(args, block, globals, &check); err != nil {\n\t\treturn nil, err\n\t}\n\treturn check, nil\n}\n\nfunc StorageDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tvar backend module.Storage\n\tif err := ModuleFromNode(node.Args, node, m.Globals, &backend); err != nil {\n\t\treturn nil, err\n\t}\n\treturn backend, nil\n}\n\nfunc SASLAuthDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tvar provider module.SASLProvider\n\tif err := ModuleFromNode(node.Args, node, m.Globals, &provider); err != nil {\n\t\treturn nil, err\n\t}\n\treturn provider, nil\n}\n\nfunc TableDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tvar tbl module.Table\n\tif err := ModuleFromNode(node.Args, node, m.Globals, &tbl); err != nil {\n\t\treturn nil, err\n\t}\n\treturn tbl, nil\n}\n", "package imap\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/emersion/go-imap\"\n\tappendlimit \"github.com/emersion/go-imap-appendlimit\"\n\tcompress \"github.com/emersion/go-imap-compress\"\n\tidle \"github.com/emersion/go-imap-idle\"\n\tmove \"github.com/emersion/go-imap-move\"\n\tspecialuse \"github.com/emersion/go-imap-specialuse\"\n\tunselect \"github.com/emersion/go-imap-unselect\"\n\timapbackend \"github.com/emersion/go-imap/backend\"\n\timapserver \"github.com/emersion/go-imap/server\"\n\t\"github.com/emersion/go-message\"\n\t_ \"github.com/emersion/go-message/charset\"\n\t\"github.com/emersion/go-sasl\"\n\ti18nlevel \"github.com/foxcpp/go-imap-i18nlevel\"\n\t\"github.com/foxcpp/go-imap-sql/children\"\n\t\"github.com/foxcpp/maddy/internal/auth\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\tmodconfig \"github.com/foxcpp/maddy/internal/config/module\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/updatepipe\"\n)\n\ntype Endpoint struct {\n\taddrs     []string\n\tserv      *imapserver.Server\n\tlisteners []net.Listener\n\tStore     module.Storage\n\n\tupdater     imapbackend.BackendUpdater\n\ttlsConfig   *tls.Config\n\tlistenersWg sync.WaitGroup\n\n\tsaslAuth auth.SASLAuth\n\n\tLog log.Logger\n}\n\nfunc New(modName string, addrs []string) (module.Module, error) {\n\tendp := &Endpoint{\n\t\taddrs: addrs,\n\t\tLog:   log.Logger{Name: \"imap\"},\n\t\tsaslAuth: auth.SASLAuth{\n\t\t\tLog: log.Logger{Name: \"imap/saslauth\"},\n\t\t},\n\t}\n\n\treturn endp, nil\n}\n\nfunc (endp *Endpoint) Init(cfg *config.Map) error {\n\tvar (\n\t\tinsecureAuth bool\n\t\tioDebug      bool\n\t\tioErrors     bool\n\t)\n\n\tcfg.Callback(\"auth\", func(m *config.Map, node *config.Node) error {\n\t\treturn endp.saslAuth.AddProvider(m, node)\n\t})\n\tcfg.Custom(\"storage\", false, true, nil, modconfig.StorageDirective, &endp.Store)\n\tcfg.Custom(\"tls\", true, true, nil, config.TLSDirective, &endp.tlsConfig)\n\tcfg.Bool(\"insecure_auth\", false, false, &insecureAuth)\n\tcfg.Bool(\"io_debug\", false, false, &ioDebug)\n\tcfg.Bool(\"io_errors\", false, false, &ioErrors)\n\tcfg.Bool(\"debug\", true, false, &endp.Log.Debug)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\tvar ok bool\n\tendp.updater, ok = endp.Store.(imapbackend.BackendUpdater)\n\tif !ok {\n\t\treturn fmt.Errorf(\"imap: storage module %T does not implement imapbackend.BackendUpdater\", endp.Store)\n\t}\n\n\tif updBe, ok := endp.Store.(updatepipe.Backend); ok {\n\t\tif err := updBe.EnableUpdatePipe(updatepipe.ModeReplicate); err != nil {\n\t\t\tendp.Log.Error(\"failed to initialize updates pipe\", err)\n\t\t}\n\t}\n\n\t// Call Updates once at start, some storage backends initialize update\n\t// channel lazily and may not generate updates at all unless it is called.\n\tif endp.updater.Updates() == nil {\n\t\treturn fmt.Errorf(\"imap: failed to init backend: nil update channel\")\n\t}\n\n\taddresses := make([]config.Endpoint, 0, len(endp.addrs))\n\tfor _, addr := range endp.addrs {\n\t\tsaddr, err := config.ParseEndpoint(addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"imap: invalid address: %s\", addr)\n\t\t}\n\t\taddresses = append(addresses, saddr)\n\t}\n\n\tendp.serv = imapserver.New(endp)\n\tendp.serv.AllowInsecureAuth = insecureAuth\n\tendp.serv.TLSConfig = endp.tlsConfig\n\tif ioErrors {\n\t\tendp.serv.ErrorLog = &endp.Log\n\t} else {\n\t\tendp.serv.ErrorLog = log.Logger{Out: log.NopOutput{}}\n\t}\n\tif ioDebug {\n\t\tendp.serv.Debug = endp.Log.DebugWriter()\n\t\tendp.Log.Println(\"I/O debugging is on! It may leak passwords in logs, be careful!\")\n\t}\n\n\tif err := endp.enableExtensions(); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, mech := range endp.saslAuth.SASLMechanisms() {\n\t\tendp.serv.EnableAuth(mech, func(c imapserver.Conn) sasl.Server {\n\t\t\treturn endp.saslAuth.CreateSASL(mech, c.Info().RemoteAddr, func(ids []string) error {\n\t\t\t\treturn endp.openAccount(c, ids)\n\t\t\t})\n\t\t})\n\t}\n\n\tif err := endp.setupListeners(addresses); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) setupListeners(addresses []config.Endpoint) error {\n\tfor _, addr := range addresses {\n\t\tvar l net.Listener\n\t\tvar err error\n\t\tl, err = net.Listen(addr.Network(), addr.Address())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"imap: %v\", err)\n\t\t}\n\t\tendp.Log.Printf(\"listening on %v\", addr)\n\n\t\tif addr.IsTLS() {\n\t\t\tif endp.tlsConfig == nil {\n\t\t\t\treturn errors.New(\"imap: can't bind on IMAPS endpoint without TLS configuration\")\n\t\t\t}\n\t\t\tl = tls.NewListener(l, endp.tlsConfig)\n\t\t}\n\n\t\tendp.listeners = append(endp.listeners, l)\n\n\t\tendp.listenersWg.Add(1)\n\t\taddr := addr\n\t\tgo func() {\n\t\t\tif err := endp.serv.Serve(l); err != nil && !strings.HasSuffix(err.Error(), \"use of closed network connection\") {\n\t\t\t\tendp.Log.Printf(\"imap: failed to serve %s: %s\", addr, err)\n\t\t\t}\n\t\t\tendp.listenersWg.Done()\n\t\t}()\n\t}\n\n\tif endp.serv.AllowInsecureAuth {\n\t\tendp.Log.Println(\"authentication over unencrypted connections is allowed, this is insecure configuration and should be used only for testing!\")\n\t}\n\tif endp.serv.TLSConfig == nil {\n\t\tendp.Log.Println(\"TLS is disabled, this is insecure configuration and should be used only for testing!\")\n\t\tendp.serv.AllowInsecureAuth = true\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) Updates() <-chan imapbackend.Update {\n\treturn endp.updater.Updates()\n}\n\nfunc (endp *Endpoint) Name() string {\n\treturn \"imap\"\n}\n\nfunc (endp *Endpoint) InstanceName() string {\n\treturn \"imap\"\n}\n\nfunc (endp *Endpoint) Close() error {\n\tfor _, l := range endp.listeners {\n\t\tl.Close()\n\t}\n\tif err := endp.serv.Close(); err != nil {\n\t\treturn err\n\t}\n\tendp.listenersWg.Wait()\n\treturn nil\n}\n\nfunc (endp *Endpoint) openAccount(c imapserver.Conn, identities []string) error {\n\tu, err := endp.Store.GetOrCreateUser(identities[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := c.Context()\n\tctx.State = imap.AuthenticatedState\n\tctx.User = u\n\treturn nil\n}\n\nfunc (endp *Endpoint) Login(connInfo *imap.ConnInfo, username, password string) (imapbackend.User, error) {\n\t_, err := endp.saslAuth.AuthPlain(username, password)\n\tif err != nil {\n\t\tendp.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", connInfo.RemoteAddr)\n\t\treturn nil, imapbackend.ErrInvalidCredentials\n\t}\n\n\t// TODO: Wrap GetOrCreateUser and possibly implement INBOXES extension\n\t// (though it is draft 00 for quite some time so it likely has no future).\n\treturn endp.Store.GetOrCreateUser(username)\n}\n\nfunc (endp *Endpoint) EnableChildrenExt() bool {\n\treturn endp.Store.(children.Backend).EnableChildrenExt()\n}\n\nfunc (endp *Endpoint) I18NLevel() int {\n\tbe, ok := endp.Store.(i18nlevel.Backend)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn be.I18NLevel()\n}\n\nfunc (endp *Endpoint) enableExtensions() error {\n\texts := endp.Store.IMAPExtensions()\n\tfor _, ext := range exts {\n\t\tswitch ext {\n\t\tcase \"APPENDLIMIT\":\n\t\t\tendp.serv.Enable(appendlimit.NewExtension())\n\t\tcase \"CHILDREN\":\n\t\t\tendp.serv.Enable(children.NewExtension())\n\t\tcase \"MOVE\":\n\t\t\tendp.serv.Enable(move.NewExtension())\n\t\tcase \"SPECIAL-USE\":\n\t\t\tendp.serv.Enable(specialuse.NewExtension())\n\t\tcase \"I18NLEVEL=1\", \"I18NLEVEL=2\":\n\t\t\tendp.serv.Enable(i18nlevel.NewExtension())\n\t\t}\n\t}\n\n\tendp.serv.Enable(compress.NewExtension())\n\tendp.serv.Enable(unselect.NewExtension())\n\tendp.serv.Enable(idle.NewExtension())\n\n\treturn nil\n}\n\nfunc init() {\n\tmodule.RegisterEndpoint(\"imap\", New)\n\n\timap.CharsetReader = message.CharsetReader\n}\n", "package smtp\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/emersion/go-smtp\"\n\t\"github.com/foxcpp/maddy/internal/auth\"\n\t\"github.com/foxcpp/maddy/internal/buffer\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\tmodconfig \"github.com/foxcpp/maddy/internal/config/module\"\n\t\"github.com/foxcpp/maddy/internal/dns\"\n\t\"github.com/foxcpp/maddy/internal/future\"\n\t\"github.com/foxcpp/maddy/internal/limits\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/msgpipeline\"\n\t\"golang.org/x/net/idna\"\n)\n\ntype Endpoint struct {\n\thostname  string\n\tsaslAuth  auth.SASLAuth\n\tserv      *smtp.Server\n\tname      string\n\taddrs     []string\n\tlisteners []net.Listener\n\tpipeline  *msgpipeline.MsgPipeline\n\tresolver  dns.Resolver\n\tlimits    *limits.Group\n\n\tbuffer func(r io.Reader) (buffer.Buffer, error)\n\n\tauthAlwaysRequired  bool\n\tsubmission          bool\n\tlmtp                bool\n\tdeferServerReject   bool\n\tmaxLoggedRcptErrors int\n\tmaxReceived         int\n\n\tlistenersWg sync.WaitGroup\n\n\tLog log.Logger\n}\n\nfunc (endp *Endpoint) Name() string {\n\treturn endp.name\n}\n\nfunc (endp *Endpoint) InstanceName() string {\n\treturn endp.name\n}\n\nfunc New(modName string, addrs []string) (module.Module, error) {\n\tendp := &Endpoint{\n\t\tname:       modName,\n\t\taddrs:      addrs,\n\t\tsubmission: modName == \"submission\",\n\t\tlmtp:       modName == \"lmtp\",\n\t\tresolver:   dns.DefaultResolver(),\n\t\tbuffer:     buffer.BufferInMemory,\n\t\tLog:        log.Logger{Name: modName},\n\t}\n\treturn endp, nil\n}\n\nfunc (endp *Endpoint) Init(cfg *config.Map) error {\n\tendp.serv = smtp.NewServer(endp)\n\tendp.serv.ErrorLog = endp.Log\n\tendp.serv.LMTP = endp.lmtp\n\tendp.serv.EnableSMTPUTF8 = true\n\tif err := endp.setConfig(cfg); err != nil {\n\t\treturn err\n\t}\n\n\taddresses := make([]config.Endpoint, 0, len(endp.addrs))\n\tfor _, addr := range endp.addrs {\n\t\tsaddr, err := config.ParseEndpoint(addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: invalid address: %s\", addr, endp.name)\n\t\t}\n\n\t\taddresses = append(addresses, saddr)\n\t}\n\n\tif err := endp.setupListeners(addresses); err != nil {\n\t\tfor _, l := range endp.listeners {\n\t\t\tl.Close()\n\t\t}\n\t\treturn err\n\t}\n\n\tallLocal := true\n\tfor _, addr := range addresses {\n\t\tif addr.Scheme != \"unix\" && !strings.HasPrefix(addr.Host, \"127.0.0.\") {\n\t\t\tallLocal = false\n\t\t}\n\t}\n\n\tif endp.serv.AllowInsecureAuth && !allLocal {\n\t\tendp.Log.Println(\"authentication over unencrypted connections is allowed, this is insecure configuration and should be used only for testing!\")\n\t}\n\tif endp.serv.TLSConfig == nil {\n\t\tif !allLocal {\n\t\t\tendp.Log.Println(\"TLS is disabled, this is insecure configuration and should be used only for testing!\")\n\t\t}\n\n\t\tendp.serv.AllowInsecureAuth = true\n\t}\n\n\treturn nil\n}\n\nfunc autoBufferMode(maxSize int, dir string) func(io.Reader) (buffer.Buffer, error) {\n\treturn func(r io.Reader) (buffer.Buffer, error) {\n\t\t// First try to read up to N bytes.\n\t\tinitial := make([]byte, maxSize)\n\t\tactualSize, err := io.ReadFull(r, initial)\n\t\tif err != nil {\n\t\t\tif err == io.ErrUnexpectedEOF {\n\t\t\t\t// Ok, the message is smaller than N. Make a MemoryBuffer and\n\t\t\t\t// handle it in RAM.\n\t\t\t\tlog.Debugln(\"autobuffer: keeping the message in RAM\")\n\t\t\t\treturn buffer.MemoryBuffer{Slice: initial[:actualSize]}, nil\n\t\t\t}\n\t\t\t// Some I/O error happened, bail out.\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlog.Debugln(\"autobuffer: spilling the message to the FS\")\n\t\t// The message is big. Dump what we got to the disk and continue writing it there.\n\t\treturn buffer.BufferInFile(\n\t\t\tio.MultiReader(bytes.NewReader(initial[:actualSize]), r),\n\t\t\tdir)\n\t}\n}\n\nfunc bufferModeDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tif len(node.Args) < 1 {\n\t\treturn nil, m.MatchErr(\"at least one argument required\")\n\t}\n\tswitch node.Args[0] {\n\tcase \"ram\":\n\t\tif len(node.Args) > 1 {\n\t\t\treturn nil, m.MatchErr(\"no additional arguments for 'ram' mode\")\n\t\t}\n\t\treturn buffer.BufferInMemory, nil\n\tcase \"fs\":\n\t\tpath := filepath.Join(config.StateDirectory, \"buffer\")\n\t\tswitch len(node.Args) {\n\t\tcase 2:\n\t\t\tpath = node.Args[1]\n\t\t\tfallthrough\n\t\tcase 1:\n\t\t\treturn func(r io.Reader) (buffer.Buffer, error) {\n\t\t\t\treturn buffer.BufferInFile(r, path)\n\t\t\t}, nil\n\t\tdefault:\n\t\t\treturn nil, m.MatchErr(\"too many arguments for 'fs' mode\")\n\t\t}\n\tcase \"auto\":\n\t\tpath := filepath.Join(config.StateDirectory, \"buffer\")\n\t\tif err := os.MkdirAll(path, 0700); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tmaxSize := 1 * 1024 * 1024 // 1 MiB\n\t\tswitch len(node.Args) {\n\t\tcase 3:\n\t\t\tpath = node.Args[2]\n\t\t\tfallthrough\n\t\tcase 2:\n\t\t\tvar err error\n\t\t\tmaxSize, err = config.ParseDataSize(node.Args[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, m.MatchErr(\"%v\", err)\n\t\t\t}\n\t\t\tfallthrough\n\t\tcase 1:\n\t\t\treturn autoBufferMode(maxSize, path), nil\n\t\tdefault:\n\t\t\treturn nil, m.MatchErr(\"too many arguments for 'auto' mode\")\n\t\t}\n\tdefault:\n\t\treturn nil, m.MatchErr(\"unknown buffer mode: %v\", node.Args[0])\n\t}\n}\n\nfunc (endp *Endpoint) setConfig(cfg *config.Map) error {\n\tvar (\n\t\terr     error\n\t\tioDebug bool\n\t)\n\n\tcfg.Callback(\"auth\", func(m *config.Map, node *config.Node) error {\n\t\treturn endp.saslAuth.AddProvider(m, node)\n\t})\n\tcfg.String(\"hostname\", true, true, \"\", &endp.hostname)\n\tcfg.Duration(\"write_timeout\", false, false, 1*time.Minute, &endp.serv.WriteTimeout)\n\tcfg.Duration(\"read_timeout\", false, false, 10*time.Minute, &endp.serv.ReadTimeout)\n\tcfg.DataSize(\"max_message_size\", false, false, 32*1024*1024, &endp.serv.MaxMessageBytes)\n\tcfg.Int(\"max_recipients\", false, false, 20000, &endp.serv.MaxRecipients)\n\tcfg.Int(\"max_received\", false, false, 50, &endp.maxReceived)\n\tcfg.Custom(\"buffer\", false, false, func() (interface{}, error) {\n\t\tpath := filepath.Join(config.StateDirectory, \"buffer\")\n\t\tif err := os.MkdirAll(path, 0700); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn autoBufferMode(1*1024*1024 /* 1 MiB */, path), nil\n\t}, bufferModeDirective, &endp.buffer)\n\tcfg.Custom(\"tls\", true, true, nil, config.TLSDirective, &endp.serv.TLSConfig)\n\tcfg.Bool(\"insecure_auth\", false, false, &endp.serv.AllowInsecureAuth)\n\tcfg.Bool(\"io_debug\", false, false, &ioDebug)\n\tcfg.Bool(\"debug\", true, false, &endp.Log.Debug)\n\tcfg.Bool(\"defer_sender_reject\", false, true, &endp.deferServerReject)\n\tcfg.Int(\"max_logged_rcpt_errors\", false, false, 5, &endp.maxLoggedRcptErrors)\n\tcfg.Custom(\"limits\", false, false, func() (interface{}, error) {\n\t\treturn &limits.Group{}, nil\n\t}, func(cfg *config.Map, n *config.Node) (interface{}, error) {\n\t\tvar g *limits.Group\n\t\tif err := modconfig.GroupFromNode(\"limits\", n.Args, n, cfg.Globals, &g); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn g, nil\n\t}, &endp.limits)\n\tcfg.AllowUnknown()\n\tunknown, err := cfg.Process()\n\tif err != nil {\n\t\treturn err\n\t}\n\tendp.pipeline, err = msgpipeline.New(cfg.Globals, unknown)\n\tif err != nil {\n\t\treturn err\n\t}\n\tendp.pipeline.Hostname = endp.serv.Domain\n\tendp.pipeline.Resolver = endp.resolver\n\tendp.pipeline.Log = log.Logger{Name: \"smtp/pipeline\", Debug: endp.Log.Debug}\n\tendp.pipeline.FirstPipeline = true\n\n\tendp.serv.AuthDisabled = len(endp.saslAuth.SASLMechanisms()) == 0\n\tif endp.submission {\n\t\tendp.authAlwaysRequired = true\n\t\tif len(endp.saslAuth.SASLMechanisms()) == 0 {\n\t\t\treturn fmt.Errorf(\"%s: auth. provider must be set for submission endpoint\", endp.name)\n\t\t}\n\t}\n\tfor _, mech := range endp.saslAuth.SASLMechanisms() {\n\t\t// TODO: The code below lacks handling to set AuthPassword. Don't\n\t\t// override sasl.Plain handler so Login() will be called as usual.\n\t\tif mech == sasl.Plain {\n\t\t\tcontinue\n\t\t}\n\n\t\tendp.serv.EnableAuth(mech, func(c *smtp.Conn) sasl.Server {\n\t\t\tstate := c.State()\n\t\t\tif err := endp.pipeline.RunEarlyChecks(context.TODO(), &state); err != nil {\n\t\t\t\treturn auth.FailingSASLServ{Err: endp.wrapErr(\"\", true, err)}\n\t\t\t}\n\n\t\t\treturn endp.saslAuth.CreateSASL(mech, state.RemoteAddr, func(ids []string) error {\n\t\t\t\tc.SetSession(endp.newSession(false, ids[0], \"\", &state))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t}\n\n\t// INTERNATIONALIZATION: See RFC 6531 Section 3.3.\n\tendp.serv.Domain, err = idna.ToASCII(endp.hostname)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: cannot represent the hostname as an A-label name: %w\", endp.name, err)\n\t}\n\n\tif ioDebug {\n\t\tendp.serv.Debug = endp.Log.DebugWriter()\n\t\tendp.Log.Println(\"I/O debugging is on! It may leak passwords in logs, be careful!\")\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) setupListeners(addresses []config.Endpoint) error {\n\tfor _, addr := range addresses {\n\t\tvar l net.Listener\n\t\tvar err error\n\t\tl, err = net.Listen(addr.Network(), addr.Address())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: %w\", endp.name, err)\n\t\t}\n\t\tendp.Log.Printf(\"listening on %v\", addr)\n\n\t\tif addr.IsTLS() {\n\t\t\tif endp.serv.TLSConfig == nil {\n\t\t\t\treturn fmt.Errorf(\"%s: can't bind on SMTPS endpoint without TLS configuration\", endp.name)\n\t\t\t}\n\t\t\tl = tls.NewListener(l, endp.serv.TLSConfig)\n\t\t}\n\n\t\tendp.listeners = append(endp.listeners, l)\n\n\t\tendp.listenersWg.Add(1)\n\t\taddr := addr\n\t\tgo func() {\n\t\t\tif err := endp.serv.Serve(l); err != nil {\n\t\t\t\tendp.Log.Printf(\"failed to serve %s: %s\", addr, err)\n\t\t\t}\n\t\t\tendp.listenersWg.Done()\n\t\t}()\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) Login(state *smtp.ConnectionState, username, password string) (smtp.Session, error) {\n\tif endp.serv.AuthDisabled {\n\t\treturn nil, smtp.ErrAuthUnsupported\n\t}\n\n\t// Executed before authentication and session initialization.\n\tif err := endp.pipeline.RunEarlyChecks(context.TODO(), state); err != nil {\n\t\treturn nil, endp.wrapErr(\"\", true, err)\n\t}\n\n\t_, err := endp.saslAuth.AuthPlain(username, password)\n\tif err != nil {\n\t\t// TODO: Update fail2ban filters.\n\t\tendp.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", state.RemoteAddr)\n\t\treturn nil, errors.New(\"Invalid credentials\")\n\t}\n\n\t// TODO: Pass valid identifies to SMTP pipeline.\n\treturn endp.newSession(false, username, password, state), nil\n}\n\nfunc (endp *Endpoint) AnonymousLogin(state *smtp.ConnectionState) (smtp.Session, error) {\n\tif endp.authAlwaysRequired {\n\t\treturn nil, smtp.ErrAuthRequired\n\t}\n\n\t// Executed before authentication and session initialization.\n\tif err := endp.pipeline.RunEarlyChecks(context.TODO(), state); err != nil {\n\t\treturn nil, endp.wrapErr(\"\", true, err)\n\t}\n\n\treturn endp.newSession(true, \"\", \"\", state), nil\n}\n\nfunc (endp *Endpoint) newSession(anonymous bool, username, password string, state *smtp.ConnectionState) smtp.Session {\n\ts := &Session{\n\t\tendp: endp,\n\t\tlog:  endp.Log,\n\t\tconnState: module.ConnState{\n\t\t\tConnectionState: *state,\n\t\t\tAuthUser:        username,\n\t\t\tAuthPassword:    password,\n\t\t},\n\t\tsessionCtx: context.Background(),\n\t}\n\n\tif endp.serv.LMTP {\n\t\ts.connState.Proto = \"LMTP\"\n\t} else {\n\t\t// Check if TLS connection state struct is poplated.\n\t\t// If it is - we are ssing TLS.\n\t\tif state.TLS.HandshakeComplete {\n\t\t\ts.connState.Proto = \"ESMTPS\"\n\t\t} else {\n\t\t\ts.connState.Proto = \"ESMTP\"\n\t\t}\n\t}\n\n\tif endp.resolver != nil {\n\t\trdnsCtx, cancelRDNS := context.WithCancel(s.sessionCtx)\n\t\ts.connState.RDNSName = future.New()\n\t\ts.cancelRDNS = cancelRDNS\n\t\tgo s.fetchRDNSName(rdnsCtx)\n\t}\n\n\treturn s\n}\n\nfunc (endp *Endpoint) Close() error {\n\tendp.serv.Close()\n\tendp.listenersWg.Wait()\n\treturn nil\n}\n\nfunc init() {\n\tmodule.RegisterEndpoint(\"smtp\", New)\n\tmodule.RegisterEndpoint(\"submission\", New)\n\tmodule.RegisterEndpoint(\"lmtp\", New)\n\n\trand.Seed(time.Now().UnixNano())\n}\n", "package module\n\nimport \"errors\"\n\nvar (\n\t// ErrUnknownCredentials should be returned by auth. provider if supplied\n\t// credentials are valid for it but are not recognized (e.g. not found in\n\t// used DB).\n\tErrUnknownCredentials = errors.New(\"unknown credentials\")\n)\n\n// PlainAuth is the interface implemented by modules providing authentication using\n// username:password pairs.\ntype PlainAuth interface {\n\tAuthPlain(username, password string) ([]string, error)\n}\n\n// SASLProvider is the interface implemented by modules and used by protocol\n// endpoints that rely on SASL framework for user authentication.\n//\n// This actual interface is only used to indicate that the module is a\n// SASL-compatible auth. provider. For each unique value returned by\n// SASLMechanisms, the module object should also implement the coresponding\n// mechanism-specific interface.\n//\n// *Rationale*: There is no single generic interface that would handle any SASL\n// mechanism while permiting the use of a credentials set estabilished once with\n// multiple auth. providers at once.\n//\n// Per-mechanism interfaces:\n// - PLAIN => PlainAuth\ntype SASLProvider interface {\n\tSASLMechanisms() []string\n}\n", "package module\n\nimport (\n\t\"context\"\n\n\t\"github.com/emersion/go-message/textproto\"\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/foxcpp/maddy/internal/buffer\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n)\n\n// Dummy is a struct that implements PlainAuth and DeliveryTarget\n// interfaces but does nothing. Useful for testing.\n//\n// It is always registered under the 'dummy' name and can be used in both tests\n// and the actual server code (but the latter is kinda pointless).\ntype Dummy struct{ instName string }\n\nfunc (d *Dummy) SASLMechanisms() []string {\n\treturn []string{sasl.Plain, sasl.Login}\n}\n\nfunc (d *Dummy) AuthPlain(username, _ string) ([]string, error) {\n\treturn []string{username}, nil\n}\n\nfunc (d *Dummy) Name() string {\n\treturn \"dummy\"\n}\n\nfunc (d *Dummy) InstanceName() string {\n\treturn d.instName\n}\n\nfunc (d *Dummy) Init(_ *config.Map) error {\n\treturn nil\n}\n\nfunc (d *Dummy) Start(ctx context.Context, msgMeta *MsgMetadata, mailFrom string) (Delivery, error) {\n\treturn dummyDelivery{}, nil\n}\n\ntype dummyDelivery struct{}\n\nfunc (dd dummyDelivery) AddRcpt(ctx context.Context, to string) error {\n\treturn nil\n}\n\nfunc (dd dummyDelivery) Body(ctx context.Context, header textproto.Header, body buffer.Buffer) error {\n\treturn nil\n}\n\nfunc (dd dummyDelivery) Abort(ctx context.Context) error {\n\treturn nil\n}\n\nfunc (dd dummyDelivery) Commit(ctx context.Context) error {\n\treturn nil\n}\n\nfunc init() {\n\tRegister(\"dummy\", func(_, instName string, _, _ []string) (Module, error) {\n\t\treturn &Dummy{instName: instName}, nil\n\t})\n}\n", "// Package sql implements SQL-based storage module\n// using go-imap-sql library (github.com/foxcpp/go-imap-sql).\n//\n// Interfaces implemented:\n// - module.StorageBackend\n// - module.PlainAuth\n// - module.DeliveryTarget\npackage sql\n\nimport (\n\t\"context\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime/trace\"\n\t\"strconv\"\n\t\"strings\"\n\n\tspecialuse \"github.com/emersion/go-imap-specialuse\"\n\t\"github.com/emersion/go-imap/backend\"\n\t\"github.com/emersion/go-message/textproto\"\n\timapsql \"github.com/foxcpp/go-imap-sql\"\n\t\"github.com/foxcpp/maddy/internal/address\"\n\t\"github.com/foxcpp/maddy/internal/buffer\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/dns\"\n\t\"github.com/foxcpp/maddy/internal/exterrors\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/target\"\n\t\"github.com/foxcpp/maddy/internal/updatepipe\"\n\t\"golang.org/x/text/secure/precis\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype Storage struct {\n\tBack     *imapsql.Backend\n\tinstName string\n\tLog      log.Logger\n\n\tjunkMbox string\n\n\tdriver string\n\tdsn    []string\n\n\tresolver dns.Resolver\n\n\tupdates     <-chan backend.Update\n\tupdPipe     updatepipe.P\n\tupdPushStop chan struct{}\n}\n\ntype delivery struct {\n\tstore    *Storage\n\tmsgMeta  *module.MsgMetadata\n\td        imapsql.Delivery\n\tmailFrom string\n\n\taddedRcpts map[string]struct{}\n}\n\nfunc (d *delivery) String() string {\n\treturn d.store.Name() + \":\" + d.store.InstanceName()\n}\n\nfunc (d *delivery) AddRcpt(ctx context.Context, rcptTo string) error {\n\tdefer trace.StartRegion(ctx, \"sql/AddRcpt\").End()\n\n\taccountName, err := prepareUsername(rcptTo)\n\tif err != nil {\n\t\treturn &exterrors.SMTPError{\n\t\t\tCode:         501,\n\t\t\tEnhancedCode: exterrors.EnhancedCode{5, 1, 1},\n\t\t\tMessage:      \"User does not exist\",\n\t\t\tTargetName:   \"sql\",\n\t\t\tErr:          err,\n\t\t}\n\t}\n\n\taccountName = strings.ToLower(accountName)\n\tif _, ok := d.addedRcpts[accountName]; ok {\n\t\treturn nil\n\t}\n\n\t// This header is added to the message only for that recipient.\n\t// go-imap-sql does certain optimizations to store the message\n\t// with small amount of per-recipient data in a efficient way.\n\tuserHeader := textproto.Header{}\n\tuserHeader.Add(\"Delivered-To\", accountName)\n\n\tif err := d.d.AddRcpt(accountName, userHeader); err != nil {\n\t\tif err == imapsql.ErrUserDoesntExists || err == backend.ErrNoSuchMailbox {\n\t\t\treturn &exterrors.SMTPError{\n\t\t\t\tCode:         550,\n\t\t\t\tEnhancedCode: exterrors.EnhancedCode{5, 1, 1},\n\t\t\t\tMessage:      \"User does not exist\",\n\t\t\t\tTargetName:   \"sql\",\n\t\t\t\tErr:          err,\n\t\t\t}\n\t\t}\n\t\tif _, ok := err.(imapsql.SerializationError); ok {\n\t\t\treturn &exterrors.SMTPError{\n\t\t\t\tCode:         453,\n\t\t\t\tEnhancedCode: exterrors.EnhancedCode{4, 3, 2},\n\t\t\t\tMessage:      \"Storage access serialiation problem, try again later\",\n\t\t\t\tTargetName:   \"sql\",\n\t\t\t\tErr:          err,\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\td.addedRcpts[accountName] = struct{}{}\n\treturn nil\n}\n\nfunc (d *delivery) Body(ctx context.Context, header textproto.Header, body buffer.Buffer) error {\n\tdefer trace.StartRegion(ctx, \"sql/Body\").End()\n\n\tif d.msgMeta.Quarantine {\n\t\tif err := d.d.SpecialMailbox(specialuse.Junk, d.store.junkMbox); err != nil {\n\t\t\tif _, ok := err.(imapsql.SerializationError); ok {\n\t\t\t\treturn &exterrors.SMTPError{\n\t\t\t\t\tCode:         453,\n\t\t\t\t\tEnhancedCode: exterrors.EnhancedCode{4, 3, 2},\n\t\t\t\t\tMessage:      \"Storage access serialiation problem, try again later\",\n\t\t\t\t\tTargetName:   \"sql\",\n\t\t\t\t\tErr:          err,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\theader = header.Copy()\n\theader.Add(\"Return-Path\", \"<\"+target.SanitizeForHeader(d.mailFrom)+\">\")\n\terr := d.d.BodyParsed(header, body.Len(), body)\n\tif _, ok := err.(imapsql.SerializationError); ok {\n\t\treturn &exterrors.SMTPError{\n\t\t\tCode:         453,\n\t\t\tEnhancedCode: exterrors.EnhancedCode{4, 3, 2},\n\t\t\tMessage:      \"Storage access serialiation problem, try again later\",\n\t\t\tTargetName:   \"sql\",\n\t\t\tErr:          err,\n\t\t}\n\t}\n\treturn err\n}\n\nfunc (d *delivery) Abort(ctx context.Context) error {\n\tdefer trace.StartRegion(ctx, \"sql/Abort\").End()\n\n\treturn d.d.Abort()\n}\n\nfunc (d *delivery) Commit(ctx context.Context) error {\n\tdefer trace.StartRegion(ctx, \"sql/Commit\").End()\n\n\treturn d.d.Commit()\n}\n\nfunc (store *Storage) Start(ctx context.Context, msgMeta *module.MsgMetadata, mailFrom string) (module.Delivery, error) {\n\tdefer trace.StartRegion(ctx, \"sql/Start\").End()\n\n\treturn &delivery{\n\t\tstore:      store,\n\t\tmsgMeta:    msgMeta,\n\t\tmailFrom:   mailFrom,\n\t\td:          store.Back.NewDelivery(),\n\t\taddedRcpts: map[string]struct{}{},\n\t}, nil\n}\n\nfunc (store *Storage) Name() string {\n\treturn \"sql\"\n}\n\nfunc (store *Storage) InstanceName() string {\n\treturn store.instName\n}\n\nfunc New(_, instName string, _, inlineArgs []string) (module.Module, error) {\n\tstore := &Storage{\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: \"sql\"},\n\t\tresolver: dns.DefaultResolver(),\n\t}\n\tif len(inlineArgs) != 0 {\n\t\tif len(inlineArgs) == 1 {\n\t\t\treturn nil, errors.New(\"sql: expected at least 2 arguments\")\n\t\t}\n\n\t\tstore.driver = inlineArgs[0]\n\t\tstore.dsn = inlineArgs[1:]\n\t}\n\treturn store, nil\n}\n\nfunc (store *Storage) Init(cfg *config.Map) error {\n\tvar (\n\t\tdriver          string\n\t\tdsn             []string\n\t\tfsstoreLocation string\n\t\tappendlimitVal  = -1\n\t\tcompression     []string\n\t)\n\n\topts := imapsql.Opts{\n\t\t// Prevent deadlock if nobody is listening for updates (e.g. no IMAP\n\t\t// configured).\n\t\tLazyUpdatesInit: true,\n\t}\n\tcfg.String(\"driver\", false, false, store.driver, &driver)\n\tcfg.StringList(\"dsn\", false, false, store.dsn, &dsn)\n\tcfg.Custom(\"fsstore\", false, false, func() (interface{}, error) {\n\t\treturn \"messages\", nil\n\t}, func(m *config.Map, node *config.Node) (interface{}, error) {\n\t\tif len(node.Args) != 1 {\n\t\t\treturn nil, m.MatchErr(\"expected 0 or 1 arguments\")\n\t\t}\n\t\treturn node.Args[0], nil\n\t}, &fsstoreLocation)\n\tcfg.StringList(\"compression\", false, false, []string{\"off\"}, &compression)\n\tcfg.DataSize(\"appendlimit\", false, false, 32*1024*1024, &appendlimitVal)\n\tcfg.Bool(\"debug\", true, false, &store.Log.Debug)\n\tcfg.Int(\"sqlite3_cache_size\", false, false, 0, &opts.CacheSize)\n\tcfg.Int(\"sqlite3_busy_timeout\", false, false, 5000, &opts.BusyTimeout)\n\tcfg.Bool(\"sqlite3_exclusive_lock\", false, false, &opts.ExclusiveLock)\n\tcfg.String(\"junk_mailbox\", false, false, \"Junk\", &store.junkMbox)\n\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\tif dsn == nil {\n\t\treturn errors.New(\"sql: dsn is required\")\n\t}\n\tif driver == \"\" {\n\t\treturn errors.New(\"sql: driver is required\")\n\t}\n\n\topts.Log = &store.Log\n\n\tif appendlimitVal == -1 {\n\t\topts.MaxMsgBytes = nil\n\t} else {\n\t\t// int is 32-bit on some platforms, so cut off values we can't actually\n\t\t// use.\n\t\tif int(uint32(appendlimitVal)) != appendlimitVal {\n\t\t\treturn errors.New(\"sql: appendlimit value is too big\")\n\t\t}\n\t\topts.MaxMsgBytes = new(uint32)\n\t\t*opts.MaxMsgBytes = uint32(appendlimitVal)\n\t}\n\tvar err error\n\n\tdsnStr := strings.Join(dsn, \" \")\n\n\tif err := os.MkdirAll(fsstoreLocation, os.ModeDir|os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\textStore := &imapsql.FSStore{Root: fsstoreLocation}\n\n\tif len(compression) != 0 {\n\t\tswitch compression[0] {\n\t\tcase \"zstd\", \"lz4\":\n\t\t\topts.CompressAlgo = compression[0]\n\t\t\tif len(compression) == 2 {\n\t\t\t\topts.CompressAlgoParams = compression[1]\n\t\t\t\tif _, err := strconv.Atoi(compression[1]); err != nil {\n\t\t\t\t\treturn errors.New(\"sql: first argument for lz4 and zstd is compression level\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(compression) > 2 {\n\t\t\t\treturn errors.New(\"sql: expected at most 2 arguments\")\n\t\t\t}\n\t\tcase \"off\":\n\t\t\tif len(compression) > 1 {\n\t\t\t\treturn errors.New(\"sql: expected at most 1 arguments\")\n\t\t\t}\n\t\tdefault:\n\t\t\treturn errors.New(\"sql: unknown compression algorithm\")\n\t\t}\n\t}\n\n\tstore.Back, err = imapsql.New(driver, dsnStr, extStore, opts)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sql: %s\", err)\n\t}\n\n\tstore.Log.Debugln(\"go-imap-sql version\", imapsql.VersionStr)\n\n\tstore.driver = driver\n\tstore.dsn = dsn\n\n\treturn nil\n}\n\nfunc (store *Storage) EnableUpdatePipe(mode updatepipe.BackendMode) error {\n\tif store.updPipe != nil {\n\t\treturn nil\n\t}\n\tif store.updates != nil {\n\t\tpanic(\"sql: EnableUpdatePipe called after Updates\")\n\t}\n\n\tupds := store.Back.Updates()\n\n\tswitch store.driver {\n\tcase \"sqlite3\":\n\t\tdbId := sha1.Sum([]byte(strings.Join(store.dsn, \" \")))\n\t\tstore.updPipe = &updatepipe.UnixSockPipe{\n\t\t\tSockPath: filepath.Join(\n\t\t\t\tconfig.RuntimeDirectory,\n\t\t\t\tfmt.Sprintf(\"sql-%s.sock\", hex.EncodeToString(dbId[:]))),\n\t\t\tLog: log.Logger{Name: \"sql/updpipe\", Debug: store.Log.Debug},\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"sql: driver does not have an update pipe implementation\")\n\t}\n\n\twrapped := make(chan backend.Update, cap(upds)*2)\n\n\tif mode == updatepipe.ModeReplicate {\n\t\tif err := store.updPipe.Listen(wrapped); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := store.updPipe.InitPush(); err != nil {\n\t\treturn err\n\t}\n\n\tstore.updPushStop = make(chan struct{})\n\tgo func() {\n\t\tdefer func() {\n\t\t\tstore.updPushStop <- struct{}{}\n\t\t\tclose(wrapped)\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-store.updPushStop:\n\t\t\t\treturn\n\t\t\tcase u := <-upds:\n\t\t\t\tif u == nil {\n\t\t\t\t\t// The channel is closed. We must be stopping now.\n\t\t\t\t\t<-store.updPushStop\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif err := store.updPipe.Push(u); err != nil {\n\t\t\t\t\tstore.Log.Error(\"IMAP update pipe push failed\", err)\n\t\t\t\t}\n\n\t\t\t\tif mode != updatepipe.ModePush {\n\t\t\t\t\twrapped <- u\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tstore.updates = wrapped\n\treturn nil\n}\n\nfunc (store *Storage) I18NLevel() int {\n\treturn 1\n}\n\nfunc (store *Storage) IMAPExtensions() []string {\n\treturn []string{\"APPENDLIMIT\", \"MOVE\", \"CHILDREN\", \"SPECIAL-USE\", \"I18NLEVEL=1\"}\n}\n\nfunc (store *Storage) CreateMessageLimit() *uint32 {\n\treturn store.Back.CreateMessageLimit()\n}\n\nfunc (store *Storage) Updates() <-chan backend.Update {\n\tif store.updates != nil {\n\t\treturn store.updates\n\t}\n\n\tstore.updates = store.Back.Updates()\n\treturn store.updates\n}\n\nfunc (store *Storage) EnableChildrenExt() bool {\n\treturn store.Back.EnableChildrenExt()\n}\n\nfunc prepareUsername(username string) (string, error) {\n\tmbox, domain, err := address.Split(username)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"sql: username prepare: %w\", err)\n\t}\n\n\t// PRECIS is not included in the regular address.ForLookup since it reduces\n\t// the range of valid addresses to a subset of actually valid values.\n\t// PRECIS is a matter of our own local policy, not a general rule for all\n\t// email addresses.\n\n\t// Side note: For used profiles, there is no practical difference between\n\t// CompareKey and String.\n\tmbox, err = precis.UsernameCaseMapped.CompareKey(mbox)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"sql: username prepare: %w\", err)\n\t}\n\n\tdomain, err = dns.ForLookup(domain)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"sql: username prepare: %w\", err)\n\t}\n\n\treturn mbox + \"@\" + domain, nil\n}\n\nfunc (store *Storage) AuthPlain(username, password string) ([]string, error) {\n\t// TODO: Pass session context there.\n\tdefer trace.StartRegion(context.Background(), \"sql/AuthPlain\").End()\n\n\taccountName, err := prepareUsername(username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpassword, err = precis.OpaqueString.CompareKey(password)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// TODO: Make go-imap-sql CheckPlain return an actual error.\n\tif !store.Back.CheckPlain(accountName, password) {\n\t\treturn nil, module.ErrUnknownCredentials\n\t}\n\treturn []string{username}, nil\n}\n\nfunc (store *Storage) GetOrCreateUser(username string) (backend.User, error) {\n\taccountName, err := prepareUsername(username)\n\tif err != nil {\n\t\treturn nil, backend.ErrInvalidCredentials\n\t}\n\n\treturn store.Back.GetOrCreateUser(accountName)\n}\n\nfunc (store *Storage) Close() error {\n\t// Stop backend from generating new updates.\n\tstore.Back.Close()\n\n\t// Wait for 'updates replicate' goroutine to actually stop so we will send\n\t// all updates before shuting down (this is especially important for\n\t// maddyctl).\n\tif store.updPipe != nil {\n\t\tstore.updPushStop <- struct{}{}\n\t\t<-store.updPushStop\n\n\t\tstore.updPipe.Close()\n\t}\n\n\treturn nil\n}\n\nfunc init() {\n\tmodule.Register(\"sql\", New)\n}\n"], "fixing_code": ["maddy-auth(5) \"maddy mail server\" \"maddy authentication backends\"\n\n; TITLE Authentication backends\n\n# Introduction\n\nModules described in this man page can be used to provide functionality to\ncheck validity of username-password pairs in accordance with some database.\nThat is, they authenticate users.\n\nMost likely, you are going to use these modules with 'auth' directive of IMAP\n(*maddy-imap*(5)) or SMTP endpoint (*maddy-smtp*(5)).\n\n# SQL module (sql)\n\nsql module described in *maddy-storage*(5) can also be used as a authentication\nbackend.\n\nThe username is required to be a valid RFC 5321 e-mail address.\n\n# External authentication module (extauth)\n\nModule for authentication using external helper binary. It looks for binary\nnamed maddy-auth-helper in $PATH and libexecdir and uses it for authentication\nusing username/password pair.\n\nThe protocol is very simple:\nProgram is launched for each authentication. Username and password are written\nto stdin, adding \\\\n to the end. If binary exits with 0 status code -\nauthentication is considered successful. If the status code is 1 -\nauthentication is failed. If the status code is 2 - another unrelated error has\nhappened. Additional information should be written to stderr.\n\n```\nextauth {\n    helper /usr/bin/ldap-helper\n    perdomain no\n    domains example.org\n}\n```\n\n## Configuration directives\n\n*Syntax*: helper _file_path_\n\nLocation of the helper binary. *Required.*\n\n*Syntax*: perdomain _boolean_ ++\n*Default*: no\n\nDon't remove domain part of username when authenticating and require it to be\npresent. Can be used if you want user@domain1 and user@domain2 to be different\naccounts.\n\n*Syntax*: domains _domains..._ ++\n*Default*: not specified\n\nDomains that should be allowed in username during authentication.\n\nFor example, if 'domains' is set to \"domain1 domain2\", then\nusername, username@domain1 and username@domain2 will be accepted as valid login\nname in addition to just username.\n\nIf used without 'perdomain', domain part will be removed from login before\ncheck with underlying auth. mechanism. If 'perdomain' is set, then\ndomains must be also set and domain part WILL NOT be removed before check.\n\n# PAM module (pam)\n\nImplements authentication using libpam. Alternatively it can be configured to\nuse helper binary like extauth module does.\n\nmaddy should be built with libpam build tag to use this module without\n'use_helper' directive.\n```\ngo get -tags 'libpam' ...\n```\n\n```\npam {\n    debug no\n    use_helper no\n}\n```\n\n## Configuration directives\n\n*Syntax*: debug _boolean_ ++\n*Default*: no\n\nEnable verbose logging for all modules. You don't need that unless you are\nreporting a bug.\n\n*Syntax*: use_helper _boolean_ ++\n*Default*: no\n\nUse LibexecDirectory/maddy-pam-helper instead of directly calling libpam.\nYou need to use that if:\n1. maddy is not compiled with libpam, but maddy-pam-helper is built separately.\n2. maddy is running as an unprivileged user and used PAM configuration requires additional\nprivileges (e.g. when using system accounts).\n\nFor 2, you need to make maddy-pam-helper binary setuid, see\nREADME.md in source tree for details.\n\nTL;DR (assuming you have the maddy group):\n```\nchown root:maddy /usr/lib/maddy/maddy-pam-helper\nchmod u+xs,g+x,o-x /usr/lib/maddy/maddy-pam-helper\n```\n\n# Shadow database authentication module (shadow)\n\nImplements authentication by reading /etc/shadow. Alternatively it can be\nconfigured to use helper binary like extauth does.\n\n```\nshadow {\n    debug no\n    use_helper no\n}\n```\n\n## Configuration directives\n\n*Syntax*: debug _boolean_ ++\n*Default*: no\n\nEnable verbose logging for all modules. You don't need that unless you are\nreporting a bug.\n\n*Syntax*: use_helper _boolean_ ++\n*Default*: no\n\nUse LibexecDirectory/maddy-shadow-helper instead of directly reading /etc/shadow.\nYou need to use that if maddy is running as an unprivileged user\nprivileges (e.g. when using system accounts).\n\nYou need to make maddy-shadow-helper binary setuid, see\ncmd/maddy-shadow-helper/README.md in source tree for details.\n\nTL;DR (assuming you have maddy group):\n```\nchown root:maddy /usr/lib/maddy/maddy-shadow-helper\nchmod u+xs,g+x,o-x /usr/lib/maddy/maddy-shadow-helper\n```\n\n# Separate username and password lookup (plain_separate)\n\nThis modules implements authentication using username:password pairs but can\nuse zero or more \"table modules\" (maddy-tables(5)) and one or more\nauthentication providers to verify credentials.\n\n```\nplain_separate {\n\tuser ...\n\tuser ...\n\t...\n\tpass ...\n\tpass ...\n\t...\n}\n```\n\nHow it works:\n1. Initial username input is normalized using PRECIS UsernameCaseMapped profile.\n2. Each table specified with the 'user' directive looked up using normalized\n   username. If match is not found in any table, authentication fails.\n3. Each authentication provider specified with the 'pass' directive is tried.\n   If authentication with all providers fails - an error is returned.\n\n## Configuration directives\n\n**Syntax:** user _table module_\n\nConfiguration block for any module from maddy-tables(5) can be used here.\n\nExample:\n```\nuser file_table /etc/maddy/allowed_users\n```\n\n**Syntax:** pass _auth provider_\n\nConfiguration block for any auth. provider module can be used here, even\n'plain_split' itself.\n\nThe used auth. provider must provide username:password pair-based\nauthentication.\n", "package external\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/foxcpp/maddy/internal/auth\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype ExternalAuth struct {\n\tmodName    string\n\tinstName   string\n\thelperPath string\n\n\tperDomain bool\n\tdomains   []string\n\n\tLog log.Logger\n}\n\nfunc NewExternalAuth(modName, instName string, _, inlineArgs []string) (module.Module, error) {\n\tea := &ExternalAuth{\n\t\tmodName:  modName,\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: modName},\n\t}\n\n\tif len(inlineArgs) != 0 {\n\t\treturn nil, errors.New(\"external: inline arguments are not used\")\n\t}\n\n\treturn ea, nil\n}\n\nfunc (ea *ExternalAuth) Name() string {\n\treturn ea.modName\n}\n\nfunc (ea *ExternalAuth) InstanceName() string {\n\treturn ea.instName\n}\n\nfunc (ea *ExternalAuth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", false, false, &ea.Log.Debug)\n\tcfg.Bool(\"perdomain\", false, false, &ea.perDomain)\n\tcfg.StringList(\"domains\", false, false, nil, &ea.domains)\n\tcfg.String(\"helper\", false, false, \"\", &ea.helperPath)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\tif ea.perDomain && ea.domains == nil {\n\t\treturn errors.New(\"auth_domains must be set if auth_perdomain is used\")\n\t}\n\n\tif ea.helperPath != \"\" {\n\t\tea.Log.Debugln(\"using helper:\", ea.helperPath)\n\t} else {\n\t\tea.helperPath = filepath.Join(config.LibexecDirectory, \"maddy-auth-helper\")\n\t}\n\tif _, err := os.Stat(ea.helperPath); err != nil {\n\t\treturn fmt.Errorf(\"%s doesn't exist\", ea.helperPath)\n\t}\n\n\tea.Log.Debugln(\"using helper:\", ea.helperPath)\n\n\treturn nil\n}\n\nfunc (ea *ExternalAuth) AuthPlain(username, password string) error {\n\taccountName, ok := auth.CheckDomainAuth(username, ea.perDomain, ea.domains)\n\tif !ok {\n\t\treturn module.ErrUnknownCredentials\n\t}\n\n\treturn AuthUsingHelper(ea.helperPath, accountName, password)\n}\n\nfunc init() {\n\tmodule.Register(\"extauth\", NewExternalAuth)\n}\n", "package pam\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/foxcpp/maddy/internal/auth/external\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype Auth struct {\n\tinstName   string\n\tuseHelper  bool\n\thelperPath string\n\n\tLog log.Logger\n}\n\nfunc New(modName, instName string, _, inlineArgs []string) (module.Module, error) {\n\tif len(inlineArgs) != 0 {\n\t\treturn nil, errors.New(\"pam: inline arguments are not used\")\n\t}\n\treturn &Auth{\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: modName},\n\t}, nil\n}\n\nfunc (a *Auth) Name() string {\n\treturn \"pam\"\n}\n\nfunc (a *Auth) InstanceName() string {\n\treturn a.instName\n}\n\nfunc (a *Auth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", true, false, &a.Log.Debug)\n\tcfg.Bool(\"use_helper\", false, false, &a.useHelper)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\tif !canCallDirectly && !a.useHelper {\n\t\treturn errors.New(\"pam: this build lacks support for direct libpam invocation, use helper binary\")\n\t}\n\n\tif a.useHelper {\n\t\ta.helperPath = filepath.Join(config.LibexecDirectory, \"maddy-pam-helper\")\n\t\tif _, err := os.Stat(a.helperPath); err != nil {\n\t\t\treturn fmt.Errorf(\"pam: no helper binary (maddy-pam-helper) found in %s\", config.LibexecDirectory)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) AuthPlain(username, password string) error {\n\tif a.useHelper {\n\t\tif err := external.AuthUsingHelper(a.helperPath, username, password); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\terr := runPAMAuth(username, password)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc init() {\n\tmodule.Register(\"pam\", New)\n}\n", "package plain_separate\n\nimport (\n\t\"errors\"\n\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype Auth struct {\n\tmodName  string\n\tinstName string\n\n\tuserTbls []module.Table\n\tpasswd   []module.PlainAuth\n\n\tonlyFirstID bool\n\n\tLog log.Logger\n}\n\nfunc NewAuth(modName, instName string, _, inlinargs []string) (module.Module, error) {\n\ta := &Auth{\n\t\tmodName:     modName,\n\t\tinstName:    instName,\n\t\tonlyFirstID: false,\n\t\tLog:         log.Logger{Name: modName},\n\t}\n\n\tif len(inlinargs) != 0 {\n\t\treturn nil, errors.New(\"plain_separate: inline arguments are not used\")\n\t}\n\n\treturn a, nil\n}\n\nfunc (a *Auth) Name() string {\n\treturn a.modName\n}\n\nfunc (a *Auth) InstanceName() string {\n\treturn a.instName\n}\n\nfunc (a *Auth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", false, false, &a.Log.Debug)\n\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) AuthPlain(username, password string) error {\n\tok := len(a.userTbls) == 0\n\tfor _, tbl := range a.userTbls {\n\t\t_, tblOk, err := tbl.Lookup(username)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif tblOk {\n\t\t\tok = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !ok {\n\t\treturn errors.New(\"user not found in tables\")\n\t}\n\n\tvar lastErr error\n\tfor _, p := range a.passwd {\n\t\tif err := p.AuthPlain(username, password); err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\n\t\treturn nil\n\t}\n\treturn lastErr\n}\n\nfunc init() {\n\tmodule.Register(\"plain_separate\", NewAuth)\n}\n", "package plain_separate\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype mockAuth struct {\n\tdb map[string]bool\n}\n\nfunc (mockAuth) SASLMechanisms() []string {\n\treturn []string{sasl.Plain, sasl.Login}\n}\n\nfunc (m mockAuth) AuthPlain(username, _ string) error {\n\tok := m.db[username]\n\tif !ok {\n\t\treturn errors.New(\"invalid creds\")\n\t}\n\treturn nil\n}\n\ntype mockTable struct {\n\tdb map[string]string\n}\n\nfunc (m mockTable) Lookup(a string) (string, bool, error) {\n\tb, ok := m.db[a]\n\treturn b, ok, nil\n}\n\nfunc TestPlainSplit_NoUser(t *testing.T) {\n\ta := Auth{\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user1\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n}\n\nfunc TestPlainSplit_NoUser_MultiPass(t *testing.T) {\n\ta := Auth{\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user2\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user1\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n}\n\nfunc TestPlainSplit_UserPass(t *testing.T) {\n\ta := Auth{\n\t\tuserTbls: []module.Table{\n\t\t\tmockTable{\n\t\t\t\tdb: map[string]string{\n\t\t\t\t\t\"user1\": \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user2\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user1\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n}\n\nfunc TestPlainSplit_MultiUser_Pass(t *testing.T) {\n\ta := Auth{\n\t\tuserTbls: []module.Table{\n\t\t\tmockTable{\n\t\t\t\tdb: map[string]string{\n\t\t\t\t\t\"userWH\": \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockTable{\n\t\t\t\tdb: map[string]string{\n\t\t\t\t\t\"user1\": \"\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tpasswd: []module.PlainAuth{\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user2\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tmockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user1\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := a.AuthPlain(\"user1\", \"aaa\")\n\tif err != nil {\n\t\tt.Fatal(\"Unexpected error:\", err)\n\t}\n}\n", "package auth\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\tmodconfig \"github.com/foxcpp/maddy/internal/config/module\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\nvar (\n\tErrUnsupportedMech = errors.New(\"Unsupported SASL mechanism\")\n)\n\n// SASLAuth is a wrapper that initializes sasl.Server using authenticators that\n// call maddy module objects.\n//\n// It supports reporting of multiple authorization identities so multiple\n// accounts can be associated with a single set of credentials.\ntype SASLAuth struct {\n\tLog         log.Logger\n\tOnlyFirstID bool\n\n\tPlain []module.PlainAuth\n}\n\nfunc (s *SASLAuth) SASLMechanisms() []string {\n\tvar mechs []string\n\n\tif len(s.Plain) != 0 {\n\t\tmechs = append(mechs, sasl.Plain, sasl.Login)\n\t}\n\n\treturn mechs\n}\n\nfunc (s *SASLAuth) AuthPlain(username, password string) error {\n\tif len(s.Plain) == 0 {\n\t\treturn ErrUnsupportedMech\n\t}\n\n\tvar lastErr error\n\tfor _, p := range s.Plain {\n\t\terr := p.AuthPlain(username, password)\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif err != nil {\n\t\t\tlastErr = err\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"no auth. provider accepted creds, last err: %w\", lastErr)\n}\n\n// CreateSASL creates the sasl.Server instance for the corresponding mechanism.\nfunc (s *SASLAuth) CreateSASL(mech string, remoteAddr net.Addr, successCb func(identity string) error) sasl.Server {\n\tswitch mech {\n\tcase sasl.Plain:\n\t\treturn sasl.NewPlainServer(func(identity, username, password string) error {\n\t\t\tif identity == \"\" {\n\t\t\t\tidentity = username\n\t\t\t}\n\n\t\t\terr := s.AuthPlain(username, password)\n\t\t\tif err != nil {\n\t\t\t\ts.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", remoteAddr)\n\t\t\t\treturn errors.New(\"auth: invalid credentials\")\n\t\t\t}\n\n\t\t\treturn successCb(identity)\n\t\t})\n\tcase sasl.Login:\n\t\treturn sasl.NewLoginServer(func(username, password string) error {\n\t\t\terr := s.AuthPlain(username, password)\n\t\t\tif err != nil {\n\t\t\t\ts.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", remoteAddr)\n\t\t\t\treturn errors.New(\"auth: invalid credentials\")\n\t\t\t}\n\n\t\t\treturn successCb(username)\n\t\t})\n\t}\n\treturn FailingSASLServ{Err: ErrUnsupportedMech}\n}\n\n// AddProvider adds the SASL authentication provider to its mapping by parsing\n// the 'auth' configuration directive.\nfunc (s *SASLAuth) AddProvider(m *config.Map, node *config.Node) error {\n\tvar any interface{}\n\tif err := modconfig.ModuleFromNode(node.Args, node, m.Globals, &any); err != nil {\n\t\treturn err\n\t}\n\n\thasAny := false\n\tif plainAuth, ok := any.(module.PlainAuth); ok {\n\t\ts.Plain = append(s.Plain, plainAuth)\n\t\thasAny = true\n\t}\n\n\tif !hasAny {\n\t\treturn m.MatchErr(\"auth: specified module does not provide any SASL mechanism\")\n\t}\n\treturn nil\n}\n\ntype FailingSASLServ struct{ Err error }\n\nfunc (s FailingSASLServ) Next([]byte) ([]byte, bool, error) {\n\treturn nil, true, s.Err\n}\n", "package auth\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/testutils\"\n)\n\ntype mockAuth struct {\n\tdb map[string]bool\n}\n\nfunc (m mockAuth) AuthPlain(username, _ string) error {\n\tok := m.db[username]\n\tif !ok {\n\t\treturn errors.New(\"invalid creds\")\n\t}\n\treturn nil\n}\n\nfunc TestCreateSASL(t *testing.T) {\n\ta := SASLAuth{\n\t\tLog: testutils.Logger(t, \"saslauth\"),\n\t\tPlain: []module.PlainAuth{\n\t\t\t&mockAuth{\n\t\t\t\tdb: map[string]bool{\n\t\t\t\t\t\"user1\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tt.Run(\"XWHATEVER\", func(t *testing.T) {\n\t\tsrv := a.CreateSASL(\"XWHATEVER\", &net.TCPAddr{}, func(string) error { return nil })\n\t\t_, _, err := srv.Next([]byte(\"\"))\n\t\tif err == nil {\n\t\t\tt.Error(\"No error for XWHATEVER use\")\n\t\t}\n\t})\n\n\tt.Run(\"PLAIN\", func(t *testing.T) {\n\t\tsrv := a.CreateSASL(\"PLAIN\", &net.TCPAddr{}, func(id string) error {\n\t\t\tif id != \"user1\" {\n\t\t\t\tt.Fatal(\"Wrong auth. identities passed to callback:\", id)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\t_, _, err := srv.Next([]byte(\"\\x00user1\\x00aa\"))\n\t\tif err != nil {\n\t\t\tt.Error(\"Unexpected error:\", err)\n\t\t}\n\t})\n\n\tt.Run(\"PLAIN with authorization identity\", func(t *testing.T) {\n\t\tsrv := a.CreateSASL(\"PLAIN\", &net.TCPAddr{}, func(id string) error {\n\t\t\tif id != \"user1a\" {\n\t\t\t\tt.Fatal(\"Wrong authorization identity passed:\", id)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\n\t\t_, _, err := srv.Next([]byte(\"user1a\\x00user1\\x00aa\"))\n\t\tif err != nil {\n\t\t\tt.Error(\"Unexpected error:\", err)\n\t\t}\n\t})\n}\n", "// +build !windows\n\npackage shadow\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/foxcpp/maddy/internal/auth/external\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\ntype Auth struct {\n\tinstName   string\n\tuseHelper  bool\n\thelperPath string\n\n\tLog log.Logger\n}\n\nfunc New(modName, instName string, _, inlineArgs []string) (module.Module, error) {\n\tif len(inlineArgs) != 0 {\n\t\treturn nil, errors.New(\"shadow: inline arguments are not used\")\n\t}\n\treturn &Auth{\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: modName},\n\t}, nil\n}\n\nfunc (a *Auth) Name() string {\n\treturn \"shadow\"\n}\n\nfunc (a *Auth) InstanceName() string {\n\treturn a.instName\n}\n\nfunc (a *Auth) Init(cfg *config.Map) error {\n\tcfg.Bool(\"debug\", true, false, &a.Log.Debug)\n\tcfg.Bool(\"use_helper\", false, false, &a.useHelper)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\tif a.useHelper {\n\t\ta.helperPath = filepath.Join(config.LibexecDirectory, \"maddy-shadow-helper\")\n\t\tif _, err := os.Stat(a.helperPath); err != nil {\n\t\t\treturn fmt.Errorf(\"shadow: no helper binary (maddy-shadow-helper) found in %s\", config.LibexecDirectory)\n\t\t}\n\t} else {\n\t\tf, err := os.Open(\"/etc/shadow\")\n\t\tif err != nil {\n\t\t\tif os.IsPermission(err) {\n\t\t\t\treturn fmt.Errorf(\"shadow: can't read /etc/shadow due to permission error, use helper binary or run maddy as a privileged user\")\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"shadow: can't read /etc/shadow: %v\", err)\n\t\t}\n\t\tf.Close()\n\t}\n\n\treturn nil\n}\n\nfunc (a *Auth) AuthPlain(username, password string) error {\n\tif a.useHelper {\n\t\treturn external.AuthUsingHelper(a.helperPath, username, password)\n\t}\n\n\tent, err := Lookup(username)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !ent.IsAccountValid() {\n\t\treturn fmt.Errorf(\"shadow: account is expired\")\n\t}\n\n\tif !ent.IsPasswordValid() {\n\t\treturn fmt.Errorf(\"shadow: password is expired\")\n\t}\n\n\tif err := ent.VerifyPassword(password); err != nil {\n\t\tif err == ErrWrongPassword {\n\t\t\treturn module.ErrUnknownCredentials\n\t\t}\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc init() {\n\tmodule.Register(\"shadow\", New)\n}\n", "package modconfig\n\nimport (\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n)\n\nfunc MessageCheck(globals map[string]interface{}, args []string, block *config.Node) (module.Check, error) {\n\tvar check module.Check\n\tif err := ModuleFromNode(args, block, globals, &check); err != nil {\n\t\treturn nil, err\n\t}\n\treturn check, nil\n}\n\n// deliveryDirective is a callback for use in config.Map.Custom.\n//\n// It does all work necessary to create a module instance from the config\n// directive with the following structure:\n// directive_name mod_name [inst_name] [{\n//   inline_mod_config\n// }]\n//\n// Note that if used configuration structure lacks directive_name before mod_name - this function\n// should not be used (call DeliveryTarget directly).\nfunc DeliveryDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\treturn DeliveryTarget(m.Globals, node.Args, node)\n}\n\nfunc DeliveryTarget(globals map[string]interface{}, args []string, block *config.Node) (module.DeliveryTarget, error) {\n\tvar target module.DeliveryTarget\n\tif err := ModuleFromNode(args, block, globals, &target); err != nil {\n\t\treturn nil, err\n\t}\n\treturn target, nil\n}\n\nfunc MsgModifier(globals map[string]interface{}, args []string, block *config.Node) (module.Modifier, error) {\n\tvar check module.Modifier\n\tif err := ModuleFromNode(args, block, globals, &check); err != nil {\n\t\treturn nil, err\n\t}\n\treturn check, nil\n}\n\nfunc StorageDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tvar backend module.Storage\n\tif err := ModuleFromNode(node.Args, node, m.Globals, &backend); err != nil {\n\t\treturn nil, err\n\t}\n\treturn backend, nil\n}\n\nfunc TableDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tvar tbl module.Table\n\tif err := ModuleFromNode(node.Args, node, m.Globals, &tbl); err != nil {\n\t\treturn nil, err\n\t}\n\treturn tbl, nil\n}\n", "package imap\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/emersion/go-imap\"\n\tappendlimit \"github.com/emersion/go-imap-appendlimit\"\n\tcompress \"github.com/emersion/go-imap-compress\"\n\tidle \"github.com/emersion/go-imap-idle\"\n\tmove \"github.com/emersion/go-imap-move\"\n\tspecialuse \"github.com/emersion/go-imap-specialuse\"\n\tunselect \"github.com/emersion/go-imap-unselect\"\n\timapbackend \"github.com/emersion/go-imap/backend\"\n\timapserver \"github.com/emersion/go-imap/server\"\n\t\"github.com/emersion/go-message\"\n\t_ \"github.com/emersion/go-message/charset\"\n\t\"github.com/emersion/go-sasl\"\n\ti18nlevel \"github.com/foxcpp/go-imap-i18nlevel\"\n\t\"github.com/foxcpp/go-imap-sql/children\"\n\t\"github.com/foxcpp/maddy/internal/auth\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\tmodconfig \"github.com/foxcpp/maddy/internal/config/module\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/updatepipe\"\n)\n\ntype Endpoint struct {\n\taddrs     []string\n\tserv      *imapserver.Server\n\tlisteners []net.Listener\n\tStore     module.Storage\n\n\tupdater     imapbackend.BackendUpdater\n\ttlsConfig   *tls.Config\n\tlistenersWg sync.WaitGroup\n\n\tsaslAuth auth.SASLAuth\n\n\tLog log.Logger\n}\n\nfunc New(modName string, addrs []string) (module.Module, error) {\n\tendp := &Endpoint{\n\t\taddrs: addrs,\n\t\tLog:   log.Logger{Name: \"imap\"},\n\t\tsaslAuth: auth.SASLAuth{\n\t\t\tLog: log.Logger{Name: \"imap/saslauth\"},\n\t\t},\n\t}\n\n\treturn endp, nil\n}\n\nfunc (endp *Endpoint) Init(cfg *config.Map) error {\n\tvar (\n\t\tinsecureAuth bool\n\t\tioDebug      bool\n\t\tioErrors     bool\n\t)\n\n\tcfg.Callback(\"auth\", func(m *config.Map, node *config.Node) error {\n\t\treturn endp.saslAuth.AddProvider(m, node)\n\t})\n\tcfg.Custom(\"storage\", false, true, nil, modconfig.StorageDirective, &endp.Store)\n\tcfg.Custom(\"tls\", true, true, nil, config.TLSDirective, &endp.tlsConfig)\n\tcfg.Bool(\"insecure_auth\", false, false, &insecureAuth)\n\tcfg.Bool(\"io_debug\", false, false, &ioDebug)\n\tcfg.Bool(\"io_errors\", false, false, &ioErrors)\n\tcfg.Bool(\"debug\", true, false, &endp.Log.Debug)\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\tvar ok bool\n\tendp.updater, ok = endp.Store.(imapbackend.BackendUpdater)\n\tif !ok {\n\t\treturn fmt.Errorf(\"imap: storage module %T does not implement imapbackend.BackendUpdater\", endp.Store)\n\t}\n\n\tif updBe, ok := endp.Store.(updatepipe.Backend); ok {\n\t\tif err := updBe.EnableUpdatePipe(updatepipe.ModeReplicate); err != nil {\n\t\t\tendp.Log.Error(\"failed to initialize updates pipe\", err)\n\t\t}\n\t}\n\n\t// Call Updates once at start, some storage backends initialize update\n\t// channel lazily and may not generate updates at all unless it is called.\n\tif endp.updater.Updates() == nil {\n\t\treturn fmt.Errorf(\"imap: failed to init backend: nil update channel\")\n\t}\n\n\taddresses := make([]config.Endpoint, 0, len(endp.addrs))\n\tfor _, addr := range endp.addrs {\n\t\tsaddr, err := config.ParseEndpoint(addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"imap: invalid address: %s\", addr)\n\t\t}\n\t\taddresses = append(addresses, saddr)\n\t}\n\n\tendp.serv = imapserver.New(endp)\n\tendp.serv.AllowInsecureAuth = insecureAuth\n\tendp.serv.TLSConfig = endp.tlsConfig\n\tif ioErrors {\n\t\tendp.serv.ErrorLog = &endp.Log\n\t} else {\n\t\tendp.serv.ErrorLog = log.Logger{Out: log.NopOutput{}}\n\t}\n\tif ioDebug {\n\t\tendp.serv.Debug = endp.Log.DebugWriter()\n\t\tendp.Log.Println(\"I/O debugging is on! It may leak passwords in logs, be careful!\")\n\t}\n\n\tif err := endp.enableExtensions(); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, mech := range endp.saslAuth.SASLMechanisms() {\n\t\tendp.serv.EnableAuth(mech, func(c imapserver.Conn) sasl.Server {\n\t\t\treturn endp.saslAuth.CreateSASL(mech, c.Info().RemoteAddr, func(identity string) error {\n\t\t\t\treturn endp.openAccount(c, identity)\n\t\t\t})\n\t\t})\n\t}\n\n\tif err := endp.setupListeners(addresses); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) setupListeners(addresses []config.Endpoint) error {\n\tfor _, addr := range addresses {\n\t\tvar l net.Listener\n\t\tvar err error\n\t\tl, err = net.Listen(addr.Network(), addr.Address())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"imap: %v\", err)\n\t\t}\n\t\tendp.Log.Printf(\"listening on %v\", addr)\n\n\t\tif addr.IsTLS() {\n\t\t\tif endp.tlsConfig == nil {\n\t\t\t\treturn errors.New(\"imap: can't bind on IMAPS endpoint without TLS configuration\")\n\t\t\t}\n\t\t\tl = tls.NewListener(l, endp.tlsConfig)\n\t\t}\n\n\t\tendp.listeners = append(endp.listeners, l)\n\n\t\tendp.listenersWg.Add(1)\n\t\taddr := addr\n\t\tgo func() {\n\t\t\tif err := endp.serv.Serve(l); err != nil && !strings.HasSuffix(err.Error(), \"use of closed network connection\") {\n\t\t\t\tendp.Log.Printf(\"imap: failed to serve %s: %s\", addr, err)\n\t\t\t}\n\t\t\tendp.listenersWg.Done()\n\t\t}()\n\t}\n\n\tif endp.serv.AllowInsecureAuth {\n\t\tendp.Log.Println(\"authentication over unencrypted connections is allowed, this is insecure configuration and should be used only for testing!\")\n\t}\n\tif endp.serv.TLSConfig == nil {\n\t\tendp.Log.Println(\"TLS is disabled, this is insecure configuration and should be used only for testing!\")\n\t\tendp.serv.AllowInsecureAuth = true\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) Updates() <-chan imapbackend.Update {\n\treturn endp.updater.Updates()\n}\n\nfunc (endp *Endpoint) Name() string {\n\treturn \"imap\"\n}\n\nfunc (endp *Endpoint) InstanceName() string {\n\treturn \"imap\"\n}\n\nfunc (endp *Endpoint) Close() error {\n\tfor _, l := range endp.listeners {\n\t\tl.Close()\n\t}\n\tif err := endp.serv.Close(); err != nil {\n\t\treturn err\n\t}\n\tendp.listenersWg.Wait()\n\treturn nil\n}\n\nfunc (endp *Endpoint) openAccount(c imapserver.Conn, identity string) error {\n\tu, err := endp.Store.GetOrCreateUser(identity)\n\tif err != nil {\n\t\treturn err\n\t}\n\tctx := c.Context()\n\tctx.State = imap.AuthenticatedState\n\tctx.User = u\n\treturn nil\n}\n\nfunc (endp *Endpoint) Login(connInfo *imap.ConnInfo, username, password string) (imapbackend.User, error) {\n\terr := endp.saslAuth.AuthPlain(username, password)\n\tif err != nil {\n\t\tendp.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", connInfo.RemoteAddr)\n\t\treturn nil, imapbackend.ErrInvalidCredentials\n\t}\n\n\treturn endp.Store.GetOrCreateUser(username)\n}\n\nfunc (endp *Endpoint) EnableChildrenExt() bool {\n\treturn endp.Store.(children.Backend).EnableChildrenExt()\n}\n\nfunc (endp *Endpoint) I18NLevel() int {\n\tbe, ok := endp.Store.(i18nlevel.Backend)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn be.I18NLevel()\n}\n\nfunc (endp *Endpoint) enableExtensions() error {\n\texts := endp.Store.IMAPExtensions()\n\tfor _, ext := range exts {\n\t\tswitch ext {\n\t\tcase \"APPENDLIMIT\":\n\t\t\tendp.serv.Enable(appendlimit.NewExtension())\n\t\tcase \"CHILDREN\":\n\t\t\tendp.serv.Enable(children.NewExtension())\n\t\tcase \"MOVE\":\n\t\t\tendp.serv.Enable(move.NewExtension())\n\t\tcase \"SPECIAL-USE\":\n\t\t\tendp.serv.Enable(specialuse.NewExtension())\n\t\tcase \"I18NLEVEL=1\", \"I18NLEVEL=2\":\n\t\t\tendp.serv.Enable(i18nlevel.NewExtension())\n\t\t}\n\t}\n\n\tendp.serv.Enable(compress.NewExtension())\n\tendp.serv.Enable(unselect.NewExtension())\n\tendp.serv.Enable(idle.NewExtension())\n\n\treturn nil\n}\n\nfunc init() {\n\tmodule.RegisterEndpoint(\"imap\", New)\n\n\timap.CharsetReader = message.CharsetReader\n}\n", "package smtp\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/emersion/go-sasl\"\n\t\"github.com/emersion/go-smtp\"\n\t\"github.com/foxcpp/maddy/internal/auth\"\n\t\"github.com/foxcpp/maddy/internal/buffer\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\tmodconfig \"github.com/foxcpp/maddy/internal/config/module\"\n\t\"github.com/foxcpp/maddy/internal/dns\"\n\t\"github.com/foxcpp/maddy/internal/future\"\n\t\"github.com/foxcpp/maddy/internal/limits\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/msgpipeline\"\n\t\"golang.org/x/net/idna\"\n)\n\ntype Endpoint struct {\n\thostname  string\n\tsaslAuth  auth.SASLAuth\n\tserv      *smtp.Server\n\tname      string\n\taddrs     []string\n\tlisteners []net.Listener\n\tpipeline  *msgpipeline.MsgPipeline\n\tresolver  dns.Resolver\n\tlimits    *limits.Group\n\n\tbuffer func(r io.Reader) (buffer.Buffer, error)\n\n\tauthAlwaysRequired  bool\n\tsubmission          bool\n\tlmtp                bool\n\tdeferServerReject   bool\n\tmaxLoggedRcptErrors int\n\tmaxReceived         int\n\n\tlistenersWg sync.WaitGroup\n\n\tLog log.Logger\n}\n\nfunc (endp *Endpoint) Name() string {\n\treturn endp.name\n}\n\nfunc (endp *Endpoint) InstanceName() string {\n\treturn endp.name\n}\n\nfunc New(modName string, addrs []string) (module.Module, error) {\n\tendp := &Endpoint{\n\t\tname:       modName,\n\t\taddrs:      addrs,\n\t\tsubmission: modName == \"submission\",\n\t\tlmtp:       modName == \"lmtp\",\n\t\tresolver:   dns.DefaultResolver(),\n\t\tbuffer:     buffer.BufferInMemory,\n\t\tLog:        log.Logger{Name: modName},\n\t}\n\treturn endp, nil\n}\n\nfunc (endp *Endpoint) Init(cfg *config.Map) error {\n\tendp.serv = smtp.NewServer(endp)\n\tendp.serv.ErrorLog = endp.Log\n\tendp.serv.LMTP = endp.lmtp\n\tendp.serv.EnableSMTPUTF8 = true\n\tif err := endp.setConfig(cfg); err != nil {\n\t\treturn err\n\t}\n\n\taddresses := make([]config.Endpoint, 0, len(endp.addrs))\n\tfor _, addr := range endp.addrs {\n\t\tsaddr, err := config.ParseEndpoint(addr)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: invalid address: %s\", addr, endp.name)\n\t\t}\n\n\t\taddresses = append(addresses, saddr)\n\t}\n\n\tif err := endp.setupListeners(addresses); err != nil {\n\t\tfor _, l := range endp.listeners {\n\t\t\tl.Close()\n\t\t}\n\t\treturn err\n\t}\n\n\tallLocal := true\n\tfor _, addr := range addresses {\n\t\tif addr.Scheme != \"unix\" && !strings.HasPrefix(addr.Host, \"127.0.0.\") {\n\t\t\tallLocal = false\n\t\t}\n\t}\n\n\tif endp.serv.AllowInsecureAuth && !allLocal {\n\t\tendp.Log.Println(\"authentication over unencrypted connections is allowed, this is insecure configuration and should be used only for testing!\")\n\t}\n\tif endp.serv.TLSConfig == nil {\n\t\tif !allLocal {\n\t\t\tendp.Log.Println(\"TLS is disabled, this is insecure configuration and should be used only for testing!\")\n\t\t}\n\n\t\tendp.serv.AllowInsecureAuth = true\n\t}\n\n\treturn nil\n}\n\nfunc autoBufferMode(maxSize int, dir string) func(io.Reader) (buffer.Buffer, error) {\n\treturn func(r io.Reader) (buffer.Buffer, error) {\n\t\t// First try to read up to N bytes.\n\t\tinitial := make([]byte, maxSize)\n\t\tactualSize, err := io.ReadFull(r, initial)\n\t\tif err != nil {\n\t\t\tif err == io.ErrUnexpectedEOF {\n\t\t\t\t// Ok, the message is smaller than N. Make a MemoryBuffer and\n\t\t\t\t// handle it in RAM.\n\t\t\t\tlog.Debugln(\"autobuffer: keeping the message in RAM\")\n\t\t\t\treturn buffer.MemoryBuffer{Slice: initial[:actualSize]}, nil\n\t\t\t}\n\t\t\t// Some I/O error happened, bail out.\n\t\t\treturn nil, err\n\t\t}\n\n\t\tlog.Debugln(\"autobuffer: spilling the message to the FS\")\n\t\t// The message is big. Dump what we got to the disk and continue writing it there.\n\t\treturn buffer.BufferInFile(\n\t\t\tio.MultiReader(bytes.NewReader(initial[:actualSize]), r),\n\t\t\tdir)\n\t}\n}\n\nfunc bufferModeDirective(m *config.Map, node *config.Node) (interface{}, error) {\n\tif len(node.Args) < 1 {\n\t\treturn nil, m.MatchErr(\"at least one argument required\")\n\t}\n\tswitch node.Args[0] {\n\tcase \"ram\":\n\t\tif len(node.Args) > 1 {\n\t\t\treturn nil, m.MatchErr(\"no additional arguments for 'ram' mode\")\n\t\t}\n\t\treturn buffer.BufferInMemory, nil\n\tcase \"fs\":\n\t\tpath := filepath.Join(config.StateDirectory, \"buffer\")\n\t\tswitch len(node.Args) {\n\t\tcase 2:\n\t\t\tpath = node.Args[1]\n\t\t\tfallthrough\n\t\tcase 1:\n\t\t\treturn func(r io.Reader) (buffer.Buffer, error) {\n\t\t\t\treturn buffer.BufferInFile(r, path)\n\t\t\t}, nil\n\t\tdefault:\n\t\t\treturn nil, m.MatchErr(\"too many arguments for 'fs' mode\")\n\t\t}\n\tcase \"auto\":\n\t\tpath := filepath.Join(config.StateDirectory, \"buffer\")\n\t\tif err := os.MkdirAll(path, 0700); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tmaxSize := 1 * 1024 * 1024 // 1 MiB\n\t\tswitch len(node.Args) {\n\t\tcase 3:\n\t\t\tpath = node.Args[2]\n\t\t\tfallthrough\n\t\tcase 2:\n\t\t\tvar err error\n\t\t\tmaxSize, err = config.ParseDataSize(node.Args[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, m.MatchErr(\"%v\", err)\n\t\t\t}\n\t\t\tfallthrough\n\t\tcase 1:\n\t\t\treturn autoBufferMode(maxSize, path), nil\n\t\tdefault:\n\t\t\treturn nil, m.MatchErr(\"too many arguments for 'auto' mode\")\n\t\t}\n\tdefault:\n\t\treturn nil, m.MatchErr(\"unknown buffer mode: %v\", node.Args[0])\n\t}\n}\n\nfunc (endp *Endpoint) setConfig(cfg *config.Map) error {\n\tvar (\n\t\terr     error\n\t\tioDebug bool\n\t)\n\n\tcfg.Callback(\"auth\", func(m *config.Map, node *config.Node) error {\n\t\treturn endp.saslAuth.AddProvider(m, node)\n\t})\n\tcfg.String(\"hostname\", true, true, \"\", &endp.hostname)\n\tcfg.Duration(\"write_timeout\", false, false, 1*time.Minute, &endp.serv.WriteTimeout)\n\tcfg.Duration(\"read_timeout\", false, false, 10*time.Minute, &endp.serv.ReadTimeout)\n\tcfg.DataSize(\"max_message_size\", false, false, 32*1024*1024, &endp.serv.MaxMessageBytes)\n\tcfg.Int(\"max_recipients\", false, false, 20000, &endp.serv.MaxRecipients)\n\tcfg.Int(\"max_received\", false, false, 50, &endp.maxReceived)\n\tcfg.Custom(\"buffer\", false, false, func() (interface{}, error) {\n\t\tpath := filepath.Join(config.StateDirectory, \"buffer\")\n\t\tif err := os.MkdirAll(path, 0700); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn autoBufferMode(1*1024*1024 /* 1 MiB */, path), nil\n\t}, bufferModeDirective, &endp.buffer)\n\tcfg.Custom(\"tls\", true, true, nil, config.TLSDirective, &endp.serv.TLSConfig)\n\tcfg.Bool(\"insecure_auth\", false, false, &endp.serv.AllowInsecureAuth)\n\tcfg.Bool(\"io_debug\", false, false, &ioDebug)\n\tcfg.Bool(\"debug\", true, false, &endp.Log.Debug)\n\tcfg.Bool(\"defer_sender_reject\", false, true, &endp.deferServerReject)\n\tcfg.Int(\"max_logged_rcpt_errors\", false, false, 5, &endp.maxLoggedRcptErrors)\n\tcfg.Custom(\"limits\", false, false, func() (interface{}, error) {\n\t\treturn &limits.Group{}, nil\n\t}, func(cfg *config.Map, n *config.Node) (interface{}, error) {\n\t\tvar g *limits.Group\n\t\tif err := modconfig.GroupFromNode(\"limits\", n.Args, n, cfg.Globals, &g); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn g, nil\n\t}, &endp.limits)\n\tcfg.AllowUnknown()\n\tunknown, err := cfg.Process()\n\tif err != nil {\n\t\treturn err\n\t}\n\tendp.pipeline, err = msgpipeline.New(cfg.Globals, unknown)\n\tif err != nil {\n\t\treturn err\n\t}\n\tendp.pipeline.Hostname = endp.serv.Domain\n\tendp.pipeline.Resolver = endp.resolver\n\tendp.pipeline.Log = log.Logger{Name: \"smtp/pipeline\", Debug: endp.Log.Debug}\n\tendp.pipeline.FirstPipeline = true\n\n\tendp.serv.AuthDisabled = len(endp.saslAuth.SASLMechanisms()) == 0\n\tif endp.submission {\n\t\tendp.authAlwaysRequired = true\n\t\tif len(endp.saslAuth.SASLMechanisms()) == 0 {\n\t\t\treturn fmt.Errorf(\"%s: auth. provider must be set for submission endpoint\", endp.name)\n\t\t}\n\t}\n\tfor _, mech := range endp.saslAuth.SASLMechanisms() {\n\t\t// TODO: The code below lacks handling to set AuthPassword. Don't\n\t\t// override sasl.Plain handler so Login() will be called as usual.\n\t\tif mech == sasl.Plain {\n\t\t\tcontinue\n\t\t}\n\n\t\tendp.serv.EnableAuth(mech, func(c *smtp.Conn) sasl.Server {\n\t\t\tstate := c.State()\n\t\t\tif err := endp.pipeline.RunEarlyChecks(context.TODO(), &state); err != nil {\n\t\t\t\treturn auth.FailingSASLServ{Err: endp.wrapErr(\"\", true, err)}\n\t\t\t}\n\n\t\t\treturn endp.saslAuth.CreateSASL(mech, state.RemoteAddr, func(id string) error {\n\t\t\t\tc.SetSession(endp.newSession(false, id, \"\", &state))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t}\n\n\t// INTERNATIONALIZATION: See RFC 6531 Section 3.3.\n\tendp.serv.Domain, err = idna.ToASCII(endp.hostname)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: cannot represent the hostname as an A-label name: %w\", endp.name, err)\n\t}\n\n\tif ioDebug {\n\t\tendp.serv.Debug = endp.Log.DebugWriter()\n\t\tendp.Log.Println(\"I/O debugging is on! It may leak passwords in logs, be careful!\")\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) setupListeners(addresses []config.Endpoint) error {\n\tfor _, addr := range addresses {\n\t\tvar l net.Listener\n\t\tvar err error\n\t\tl, err = net.Listen(addr.Network(), addr.Address())\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%s: %w\", endp.name, err)\n\t\t}\n\t\tendp.Log.Printf(\"listening on %v\", addr)\n\n\t\tif addr.IsTLS() {\n\t\t\tif endp.serv.TLSConfig == nil {\n\t\t\t\treturn fmt.Errorf(\"%s: can't bind on SMTPS endpoint without TLS configuration\", endp.name)\n\t\t\t}\n\t\t\tl = tls.NewListener(l, endp.serv.TLSConfig)\n\t\t}\n\n\t\tendp.listeners = append(endp.listeners, l)\n\n\t\tendp.listenersWg.Add(1)\n\t\taddr := addr\n\t\tgo func() {\n\t\t\tif err := endp.serv.Serve(l); err != nil {\n\t\t\t\tendp.Log.Printf(\"failed to serve %s: %s\", addr, err)\n\t\t\t}\n\t\t\tendp.listenersWg.Done()\n\t\t}()\n\t}\n\n\treturn nil\n}\n\nfunc (endp *Endpoint) Login(state *smtp.ConnectionState, username, password string) (smtp.Session, error) {\n\tif endp.serv.AuthDisabled {\n\t\treturn nil, smtp.ErrAuthUnsupported\n\t}\n\n\t// Executed before authentication and session initialization.\n\tif err := endp.pipeline.RunEarlyChecks(context.TODO(), state); err != nil {\n\t\treturn nil, endp.wrapErr(\"\", true, err)\n\t}\n\n\terr := endp.saslAuth.AuthPlain(username, password)\n\tif err != nil {\n\t\t// TODO: Update fail2ban filters.\n\t\tendp.Log.Error(\"authentication failed\", err, \"username\", username, \"src_ip\", state.RemoteAddr)\n\t\treturn nil, errors.New(\"Invalid credentials\")\n\t}\n\n\treturn endp.newSession(false, username, password, state), nil\n}\n\nfunc (endp *Endpoint) AnonymousLogin(state *smtp.ConnectionState) (smtp.Session, error) {\n\tif endp.authAlwaysRequired {\n\t\treturn nil, smtp.ErrAuthRequired\n\t}\n\n\t// Executed before authentication and session initialization.\n\tif err := endp.pipeline.RunEarlyChecks(context.TODO(), state); err != nil {\n\t\treturn nil, endp.wrapErr(\"\", true, err)\n\t}\n\n\treturn endp.newSession(true, \"\", \"\", state), nil\n}\n\nfunc (endp *Endpoint) newSession(anonymous bool, username, password string, state *smtp.ConnectionState) smtp.Session {\n\ts := &Session{\n\t\tendp: endp,\n\t\tlog:  endp.Log,\n\t\tconnState: module.ConnState{\n\t\t\tConnectionState: *state,\n\t\t\tAuthUser:        username,\n\t\t\tAuthPassword:    password,\n\t\t},\n\t\tsessionCtx: context.Background(),\n\t}\n\n\tif endp.serv.LMTP {\n\t\ts.connState.Proto = \"LMTP\"\n\t} else {\n\t\t// Check if TLS connection state struct is poplated.\n\t\t// If it is - we are ssing TLS.\n\t\tif state.TLS.HandshakeComplete {\n\t\t\ts.connState.Proto = \"ESMTPS\"\n\t\t} else {\n\t\t\ts.connState.Proto = \"ESMTP\"\n\t\t}\n\t}\n\n\tif endp.resolver != nil {\n\t\trdnsCtx, cancelRDNS := context.WithCancel(s.sessionCtx)\n\t\ts.connState.RDNSName = future.New()\n\t\ts.cancelRDNS = cancelRDNS\n\t\tgo s.fetchRDNSName(rdnsCtx)\n\t}\n\n\treturn s\n}\n\nfunc (endp *Endpoint) Close() error {\n\tendp.serv.Close()\n\tendp.listenersWg.Wait()\n\treturn nil\n}\n\nfunc init() {\n\tmodule.RegisterEndpoint(\"smtp\", New)\n\tmodule.RegisterEndpoint(\"submission\", New)\n\tmodule.RegisterEndpoint(\"lmtp\", New)\n\n\trand.Seed(time.Now().UnixNano())\n}\n", "package module\n\nimport \"errors\"\n\nvar (\n\t// ErrUnknownCredentials should be returned by auth. provider if supplied\n\t// credentials are valid for it but are not recognized (e.g. not found in\n\t// used DB).\n\tErrUnknownCredentials = errors.New(\"unknown credentials\")\n)\n\n// PlainAuth is the interface implemented by modules providing authentication using\n// username:password pairs.\ntype PlainAuth interface {\n\tAuthPlain(username, password string) error\n}\n", "package module\n\nimport (\n\t\"context\"\n\n\t\"github.com/emersion/go-message/textproto\"\n\t\"github.com/foxcpp/maddy/internal/buffer\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n)\n\n// Dummy is a struct that implements PlainAuth and DeliveryTarget\n// interfaces but does nothing. Useful for testing.\n//\n// It is always registered under the 'dummy' name and can be used in both tests\n// and the actual server code (but the latter is kinda pointless).\ntype Dummy struct{ instName string }\n\nfunc (d *Dummy) AuthPlain(username, _ string) error {\n\treturn nil\n}\n\nfunc (d *Dummy) Name() string {\n\treturn \"dummy\"\n}\n\nfunc (d *Dummy) InstanceName() string {\n\treturn d.instName\n}\n\nfunc (d *Dummy) Init(_ *config.Map) error {\n\treturn nil\n}\n\nfunc (d *Dummy) Start(ctx context.Context, msgMeta *MsgMetadata, mailFrom string) (Delivery, error) {\n\treturn dummyDelivery{}, nil\n}\n\ntype dummyDelivery struct{}\n\nfunc (dd dummyDelivery) AddRcpt(ctx context.Context, to string) error {\n\treturn nil\n}\n\nfunc (dd dummyDelivery) Body(ctx context.Context, header textproto.Header, body buffer.Buffer) error {\n\treturn nil\n}\n\nfunc (dd dummyDelivery) Abort(ctx context.Context) error {\n\treturn nil\n}\n\nfunc (dd dummyDelivery) Commit(ctx context.Context) error {\n\treturn nil\n}\n\nfunc init() {\n\tRegister(\"dummy\", func(_, instName string, _, _ []string) (Module, error) {\n\t\treturn &Dummy{instName: instName}, nil\n\t})\n}\n", "// Package sql implements SQL-based storage module\n// using go-imap-sql library (github.com/foxcpp/go-imap-sql).\n//\n// Interfaces implemented:\n// - module.StorageBackend\n// - module.PlainAuth\n// - module.DeliveryTarget\npackage sql\n\nimport (\n\t\"context\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime/trace\"\n\t\"strconv\"\n\t\"strings\"\n\n\tspecialuse \"github.com/emersion/go-imap-specialuse\"\n\t\"github.com/emersion/go-imap/backend\"\n\t\"github.com/emersion/go-message/textproto\"\n\timapsql \"github.com/foxcpp/go-imap-sql\"\n\t\"github.com/foxcpp/maddy/internal/address\"\n\t\"github.com/foxcpp/maddy/internal/buffer\"\n\t\"github.com/foxcpp/maddy/internal/config\"\n\t\"github.com/foxcpp/maddy/internal/dns\"\n\t\"github.com/foxcpp/maddy/internal/exterrors\"\n\t\"github.com/foxcpp/maddy/internal/log\"\n\t\"github.com/foxcpp/maddy/internal/module\"\n\t\"github.com/foxcpp/maddy/internal/target\"\n\t\"github.com/foxcpp/maddy/internal/updatepipe\"\n\t\"golang.org/x/text/secure/precis\"\n\n\t_ \"github.com/go-sql-driver/mysql\"\n\t_ \"github.com/lib/pq\"\n)\n\ntype Storage struct {\n\tBack     *imapsql.Backend\n\tinstName string\n\tLog      log.Logger\n\n\tjunkMbox string\n\n\tdriver string\n\tdsn    []string\n\n\tresolver dns.Resolver\n\n\tupdates     <-chan backend.Update\n\tupdPipe     updatepipe.P\n\tupdPushStop chan struct{}\n}\n\ntype delivery struct {\n\tstore    *Storage\n\tmsgMeta  *module.MsgMetadata\n\td        imapsql.Delivery\n\tmailFrom string\n\n\taddedRcpts map[string]struct{}\n}\n\nfunc (d *delivery) String() string {\n\treturn d.store.Name() + \":\" + d.store.InstanceName()\n}\n\nfunc (d *delivery) AddRcpt(ctx context.Context, rcptTo string) error {\n\tdefer trace.StartRegion(ctx, \"sql/AddRcpt\").End()\n\n\taccountName, err := prepareUsername(rcptTo)\n\tif err != nil {\n\t\treturn &exterrors.SMTPError{\n\t\t\tCode:         501,\n\t\t\tEnhancedCode: exterrors.EnhancedCode{5, 1, 1},\n\t\t\tMessage:      \"User does not exist\",\n\t\t\tTargetName:   \"sql\",\n\t\t\tErr:          err,\n\t\t}\n\t}\n\n\taccountName = strings.ToLower(accountName)\n\tif _, ok := d.addedRcpts[accountName]; ok {\n\t\treturn nil\n\t}\n\n\t// This header is added to the message only for that recipient.\n\t// go-imap-sql does certain optimizations to store the message\n\t// with small amount of per-recipient data in a efficient way.\n\tuserHeader := textproto.Header{}\n\tuserHeader.Add(\"Delivered-To\", accountName)\n\n\tif err := d.d.AddRcpt(accountName, userHeader); err != nil {\n\t\tif err == imapsql.ErrUserDoesntExists || err == backend.ErrNoSuchMailbox {\n\t\t\treturn &exterrors.SMTPError{\n\t\t\t\tCode:         550,\n\t\t\t\tEnhancedCode: exterrors.EnhancedCode{5, 1, 1},\n\t\t\t\tMessage:      \"User does not exist\",\n\t\t\t\tTargetName:   \"sql\",\n\t\t\t\tErr:          err,\n\t\t\t}\n\t\t}\n\t\tif _, ok := err.(imapsql.SerializationError); ok {\n\t\t\treturn &exterrors.SMTPError{\n\t\t\t\tCode:         453,\n\t\t\t\tEnhancedCode: exterrors.EnhancedCode{4, 3, 2},\n\t\t\t\tMessage:      \"Storage access serialiation problem, try again later\",\n\t\t\t\tTargetName:   \"sql\",\n\t\t\t\tErr:          err,\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\td.addedRcpts[accountName] = struct{}{}\n\treturn nil\n}\n\nfunc (d *delivery) Body(ctx context.Context, header textproto.Header, body buffer.Buffer) error {\n\tdefer trace.StartRegion(ctx, \"sql/Body\").End()\n\n\tif d.msgMeta.Quarantine {\n\t\tif err := d.d.SpecialMailbox(specialuse.Junk, d.store.junkMbox); err != nil {\n\t\t\tif _, ok := err.(imapsql.SerializationError); ok {\n\t\t\t\treturn &exterrors.SMTPError{\n\t\t\t\t\tCode:         453,\n\t\t\t\t\tEnhancedCode: exterrors.EnhancedCode{4, 3, 2},\n\t\t\t\t\tMessage:      \"Storage access serialiation problem, try again later\",\n\t\t\t\t\tTargetName:   \"sql\",\n\t\t\t\t\tErr:          err,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\n\theader = header.Copy()\n\theader.Add(\"Return-Path\", \"<\"+target.SanitizeForHeader(d.mailFrom)+\">\")\n\terr := d.d.BodyParsed(header, body.Len(), body)\n\tif _, ok := err.(imapsql.SerializationError); ok {\n\t\treturn &exterrors.SMTPError{\n\t\t\tCode:         453,\n\t\t\tEnhancedCode: exterrors.EnhancedCode{4, 3, 2},\n\t\t\tMessage:      \"Storage access serialiation problem, try again later\",\n\t\t\tTargetName:   \"sql\",\n\t\t\tErr:          err,\n\t\t}\n\t}\n\treturn err\n}\n\nfunc (d *delivery) Abort(ctx context.Context) error {\n\tdefer trace.StartRegion(ctx, \"sql/Abort\").End()\n\n\treturn d.d.Abort()\n}\n\nfunc (d *delivery) Commit(ctx context.Context) error {\n\tdefer trace.StartRegion(ctx, \"sql/Commit\").End()\n\n\treturn d.d.Commit()\n}\n\nfunc (store *Storage) Start(ctx context.Context, msgMeta *module.MsgMetadata, mailFrom string) (module.Delivery, error) {\n\tdefer trace.StartRegion(ctx, \"sql/Start\").End()\n\n\treturn &delivery{\n\t\tstore:      store,\n\t\tmsgMeta:    msgMeta,\n\t\tmailFrom:   mailFrom,\n\t\td:          store.Back.NewDelivery(),\n\t\taddedRcpts: map[string]struct{}{},\n\t}, nil\n}\n\nfunc (store *Storage) Name() string {\n\treturn \"sql\"\n}\n\nfunc (store *Storage) InstanceName() string {\n\treturn store.instName\n}\n\nfunc New(_, instName string, _, inlineArgs []string) (module.Module, error) {\n\tstore := &Storage{\n\t\tinstName: instName,\n\t\tLog:      log.Logger{Name: \"sql\"},\n\t\tresolver: dns.DefaultResolver(),\n\t}\n\tif len(inlineArgs) != 0 {\n\t\tif len(inlineArgs) == 1 {\n\t\t\treturn nil, errors.New(\"sql: expected at least 2 arguments\")\n\t\t}\n\n\t\tstore.driver = inlineArgs[0]\n\t\tstore.dsn = inlineArgs[1:]\n\t}\n\treturn store, nil\n}\n\nfunc (store *Storage) Init(cfg *config.Map) error {\n\tvar (\n\t\tdriver          string\n\t\tdsn             []string\n\t\tfsstoreLocation string\n\t\tappendlimitVal  = -1\n\t\tcompression     []string\n\t)\n\n\topts := imapsql.Opts{\n\t\t// Prevent deadlock if nobody is listening for updates (e.g. no IMAP\n\t\t// configured).\n\t\tLazyUpdatesInit: true,\n\t}\n\tcfg.String(\"driver\", false, false, store.driver, &driver)\n\tcfg.StringList(\"dsn\", false, false, store.dsn, &dsn)\n\tcfg.Custom(\"fsstore\", false, false, func() (interface{}, error) {\n\t\treturn \"messages\", nil\n\t}, func(m *config.Map, node *config.Node) (interface{}, error) {\n\t\tif len(node.Args) != 1 {\n\t\t\treturn nil, m.MatchErr(\"expected 0 or 1 arguments\")\n\t\t}\n\t\treturn node.Args[0], nil\n\t}, &fsstoreLocation)\n\tcfg.StringList(\"compression\", false, false, []string{\"off\"}, &compression)\n\tcfg.DataSize(\"appendlimit\", false, false, 32*1024*1024, &appendlimitVal)\n\tcfg.Bool(\"debug\", true, false, &store.Log.Debug)\n\tcfg.Int(\"sqlite3_cache_size\", false, false, 0, &opts.CacheSize)\n\tcfg.Int(\"sqlite3_busy_timeout\", false, false, 5000, &opts.BusyTimeout)\n\tcfg.Bool(\"sqlite3_exclusive_lock\", false, false, &opts.ExclusiveLock)\n\tcfg.String(\"junk_mailbox\", false, false, \"Junk\", &store.junkMbox)\n\n\tif _, err := cfg.Process(); err != nil {\n\t\treturn err\n\t}\n\n\tif dsn == nil {\n\t\treturn errors.New(\"sql: dsn is required\")\n\t}\n\tif driver == \"\" {\n\t\treturn errors.New(\"sql: driver is required\")\n\t}\n\n\topts.Log = &store.Log\n\n\tif appendlimitVal == -1 {\n\t\topts.MaxMsgBytes = nil\n\t} else {\n\t\t// int is 32-bit on some platforms, so cut off values we can't actually\n\t\t// use.\n\t\tif int(uint32(appendlimitVal)) != appendlimitVal {\n\t\t\treturn errors.New(\"sql: appendlimit value is too big\")\n\t\t}\n\t\topts.MaxMsgBytes = new(uint32)\n\t\t*opts.MaxMsgBytes = uint32(appendlimitVal)\n\t}\n\tvar err error\n\n\tdsnStr := strings.Join(dsn, \" \")\n\n\tif err := os.MkdirAll(fsstoreLocation, os.ModeDir|os.ModePerm); err != nil {\n\t\treturn err\n\t}\n\textStore := &imapsql.FSStore{Root: fsstoreLocation}\n\n\tif len(compression) != 0 {\n\t\tswitch compression[0] {\n\t\tcase \"zstd\", \"lz4\":\n\t\t\topts.CompressAlgo = compression[0]\n\t\t\tif len(compression) == 2 {\n\t\t\t\topts.CompressAlgoParams = compression[1]\n\t\t\t\tif _, err := strconv.Atoi(compression[1]); err != nil {\n\t\t\t\t\treturn errors.New(\"sql: first argument for lz4 and zstd is compression level\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(compression) > 2 {\n\t\t\t\treturn errors.New(\"sql: expected at most 2 arguments\")\n\t\t\t}\n\t\tcase \"off\":\n\t\t\tif len(compression) > 1 {\n\t\t\t\treturn errors.New(\"sql: expected at most 1 arguments\")\n\t\t\t}\n\t\tdefault:\n\t\t\treturn errors.New(\"sql: unknown compression algorithm\")\n\t\t}\n\t}\n\n\tstore.Back, err = imapsql.New(driver, dsnStr, extStore, opts)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"sql: %s\", err)\n\t}\n\n\tstore.Log.Debugln(\"go-imap-sql version\", imapsql.VersionStr)\n\n\tstore.driver = driver\n\tstore.dsn = dsn\n\n\treturn nil\n}\n\nfunc (store *Storage) EnableUpdatePipe(mode updatepipe.BackendMode) error {\n\tif store.updPipe != nil {\n\t\treturn nil\n\t}\n\tif store.updates != nil {\n\t\tpanic(\"sql: EnableUpdatePipe called after Updates\")\n\t}\n\n\tupds := store.Back.Updates()\n\n\tswitch store.driver {\n\tcase \"sqlite3\":\n\t\tdbId := sha1.Sum([]byte(strings.Join(store.dsn, \" \")))\n\t\tstore.updPipe = &updatepipe.UnixSockPipe{\n\t\t\tSockPath: filepath.Join(\n\t\t\t\tconfig.RuntimeDirectory,\n\t\t\t\tfmt.Sprintf(\"sql-%s.sock\", hex.EncodeToString(dbId[:]))),\n\t\t\tLog: log.Logger{Name: \"sql/updpipe\", Debug: store.Log.Debug},\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"sql: driver does not have an update pipe implementation\")\n\t}\n\n\twrapped := make(chan backend.Update, cap(upds)*2)\n\n\tif mode == updatepipe.ModeReplicate {\n\t\tif err := store.updPipe.Listen(wrapped); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := store.updPipe.InitPush(); err != nil {\n\t\treturn err\n\t}\n\n\tstore.updPushStop = make(chan struct{})\n\tgo func() {\n\t\tdefer func() {\n\t\t\tstore.updPushStop <- struct{}{}\n\t\t\tclose(wrapped)\n\t\t}()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-store.updPushStop:\n\t\t\t\treturn\n\t\t\tcase u := <-upds:\n\t\t\t\tif u == nil {\n\t\t\t\t\t// The channel is closed. We must be stopping now.\n\t\t\t\t\t<-store.updPushStop\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif err := store.updPipe.Push(u); err != nil {\n\t\t\t\t\tstore.Log.Error(\"IMAP update pipe push failed\", err)\n\t\t\t\t}\n\n\t\t\t\tif mode != updatepipe.ModePush {\n\t\t\t\t\twrapped <- u\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tstore.updates = wrapped\n\treturn nil\n}\n\nfunc (store *Storage) I18NLevel() int {\n\treturn 1\n}\n\nfunc (store *Storage) IMAPExtensions() []string {\n\treturn []string{\"APPENDLIMIT\", \"MOVE\", \"CHILDREN\", \"SPECIAL-USE\", \"I18NLEVEL=1\"}\n}\n\nfunc (store *Storage) CreateMessageLimit() *uint32 {\n\treturn store.Back.CreateMessageLimit()\n}\n\nfunc (store *Storage) Updates() <-chan backend.Update {\n\tif store.updates != nil {\n\t\treturn store.updates\n\t}\n\n\tstore.updates = store.Back.Updates()\n\treturn store.updates\n}\n\nfunc (store *Storage) EnableChildrenExt() bool {\n\treturn store.Back.EnableChildrenExt()\n}\n\nfunc prepareUsername(username string) (string, error) {\n\tmbox, domain, err := address.Split(username)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"sql: username prepare: %w\", err)\n\t}\n\n\t// PRECIS is not included in the regular address.ForLookup since it reduces\n\t// the range of valid addresses to a subset of actually valid values.\n\t// PRECIS is a matter of our own local policy, not a general rule for all\n\t// email addresses.\n\n\t// Side note: For used profiles, there is no practical difference between\n\t// CompareKey and String.\n\tmbox, err = precis.UsernameCaseMapped.CompareKey(mbox)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"sql: username prepare: %w\", err)\n\t}\n\n\tdomain, err = dns.ForLookup(domain)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"sql: username prepare: %w\", err)\n\t}\n\n\treturn mbox + \"@\" + domain, nil\n}\n\nfunc (store *Storage) AuthPlain(username, password string) error {\n\t// TODO: Pass session context there.\n\tdefer trace.StartRegion(context.Background(), \"sql/AuthPlain\").End()\n\n\taccountName, err := prepareUsername(username)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpassword, err = precis.OpaqueString.CompareKey(password)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// TODO: Make go-imap-sql CheckPlain return an actual error.\n\tif !store.Back.CheckPlain(accountName, password) {\n\t\treturn module.ErrUnknownCredentials\n\t}\n\treturn nil\n}\n\nfunc (store *Storage) GetOrCreateUser(username string) (backend.User, error) {\n\taccountName, err := prepareUsername(username)\n\tif err != nil {\n\t\treturn nil, backend.ErrInvalidCredentials\n\t}\n\n\treturn store.Back.GetOrCreateUser(accountName)\n}\n\nfunc (store *Storage) Close() error {\n\t// Stop backend from generating new updates.\n\tstore.Back.Close()\n\n\t// Wait for 'updates replicate' goroutine to actually stop so we will send\n\t// all updates before shuting down (this is especially important for\n\t// maddyctl).\n\tif store.updPipe != nil {\n\t\tstore.updPushStop <- struct{}{}\n\t\t<-store.updPushStop\n\n\t\tstore.updPipe.Close()\n\t}\n\n\treturn nil\n}\n\nfunc init() {\n\tmodule.Register(\"sql\", New)\n}\n"], "filenames": ["docs/man/maddy-auth.5.scd", "internal/auth/external/externalauth.go", "internal/auth/pam/module.go", "internal/auth/plain_separate/plain_separate.go", "internal/auth/plain_separate/plain_separate_test.go", "internal/auth/sasl.go", "internal/auth/sasl_test.go", "internal/auth/shadow/module.go", "internal/config/module/interfaces.go", "internal/endpoint/imap/imap.go", "internal/endpoint/smtp/smtp.go", "internal/module/auth.go", "internal/module/dummy.go", "internal/storage/sql/sql.go"], "buggy_code_start_loc": [19, 74, 61, 9, 5, 13, 6, 69, 54, 126, 272, 15, 7, 423], "buggy_code_end_loc": [186, 82, 72, 107, 149, 146, 102, 95, 62, 222, 343, 35, 25, 442], "fixing_code_start_loc": [19, 74, 61, 8, 4, 12, 5, 69, 53, 126, 272, 15, 6, 423], "fixing_code_end_loc": [171, 81, 72, 82, 135, 109, 69, 95, 53, 219, 341, 16, 20, 442], "type": "CWE-287", "message": "maddy is a composable, all-in-one mail server. Starting with version 0.2.0 and prior to version 0.6.3, maddy allows a full authentication bypass if SASL authorization username is specified when using the PLAIN authentication mechanisms. Instead of validating the specified username, it is accepted as is after checking the credentials for the authentication username. maddy 0.6.3 includes the fix for the bug. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-27582", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-13T22:15:12.387", "lastModified": "2023-03-17T16:20:47.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "maddy is a composable, all-in-one mail server. Starting with version 0.2.0 and prior to version 0.6.3, maddy allows a full authentication bypass if SASL authorization username is specified when using the PLAIN authentication mechanisms. Instead of validating the specified username, it is accepted as is after checking the credentials for the authentication username. maddy 0.6.3 includes the fix for the bug. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}, {"lang": "en", "value": "CWE-305"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:maddy_project:maddy:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.2.0", "versionEndExcluding": "0.6.3", "matchCriteriaId": "D2F03EBF-CA84-4DFE-B16F-A5C32741D9EC"}]}]}], "references": [{"url": "https://github.com/foxcpp/maddy/commit/55a91a37b71210f34f98f4d327c30308fe24399a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/foxcpp/maddy/commit/9f58cb64b39cdc01928ec463bdb198c4c2313a9c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/foxcpp/maddy/releases/tag/v0.6.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/foxcpp/maddy/security/advisories/GHSA-4g76-w3xw-2x6w", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/foxcpp/maddy/commit/55a91a37b71210f34f98f4d327c30308fe24399a"}}