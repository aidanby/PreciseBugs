{"buggy_code": ["\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an encoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    if (this.reconstructor) {\n      throw new Error(\"got plaintext data when reconstructing a packet\");\n    }\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  } else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  } else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var start = i + 1;\n    while (str.charAt(++i) !== '-' && i != str.length) {}\n    var buf = str.substring(start, i);\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      if (i === str.length) break;\n    }\n    p.nsp = str.substring(start, i);\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      if (i === str.length) break;\n    }\n    p.id = Number(str.substring(start, i + 1));\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n", "var parser = require('../index.js');\nvar expect = require('expect.js');\nvar helpers = require('./helpers.js');\nvar encoder = new parser.Encoder();\n\ndescribe('parser', function() {\n  it('encodes an ArrayBuffer', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', new ArrayBuffer(2)],\n      id: 0,\n      nsp: '/'\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('encodes a TypedArray', function() {\n    var array = new Uint8Array(5);\n    for (var i = 0; i < array.length; i++) array[i] = i;\n\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', array],\n      id: 0,\n      nsp: '/'\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('encodes ArrayBuffers deep in JSON', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', {a: 'hi', b: {why: new ArrayBuffer(3)}, c: {a: 'bye', b: { a: new ArrayBuffer(6)}}}],\n      id: 999,\n      nsp: '/deep'\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('encodes deep binary JSON with null values', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', {a: 'b', c: 4, e: {g: null}, h: new ArrayBuffer(9)}],\n      nsp: '/',\n      id: 600\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('cleans itself up on close', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: [new ArrayBuffer(2), new ArrayBuffer(3)],\n      id: 0,\n      nsp: '/'\n    };\n\n    encoder.encode(packet, function(encodedPackets) {\n      var decoder = new parser.Decoder();\n      decoder.on('decoded', function(packet) {\n        throw new Error(\"received a packet when not all binary data was sent.\");\n      });\n\n      decoder.add(encodedPackets[0]); // add metadata\n      decoder.add(encodedPackets[1]); // add first attachment\n      decoder.destroy(); // destroy before all data added\n      expect(decoder.reconstructor.buffers.length).to.be(0); // expect that buffer is clean\n    });\n  });\n});\n", "var parser = require('../index.js');\nvar expect = require('expect.js');\nvar helpers = require('./helpers.js');\n\ndescribe('parser', function(){\n\n  it('exposes types', function(){\n    expect(parser.CONNECT).to.be.a('number');\n    expect(parser.DISCONNECT).to.be.a('number');\n    expect(parser.EVENT).to.be.a('number');\n    expect(parser.ACK).to.be.a('number');\n    expect(parser.ERROR).to.be.a('number');\n    expect(parser.BINARY_EVENT).to.be.a('number');\n    expect(parser.BINARY_ACK).to.be.a('number');\n  });\n\n  it('encodes connection', function(){\n    helpers.test({\n      type: parser.CONNECT,\n      nsp: '/woot'\n    });\n  });\n\n  it('encodes disconnection', function(){\n    helpers.test({\n      type: parser.DISCONNECT,\n      nsp: '/woot'\n    });\n  });\n\n  it('encodes an event', function(){\n    helpers.test({\n      type: parser.EVENT,\n      data: ['a', 1, {}],\n      nsp: '/'\n    });\n    helpers.test({\n      type: parser.EVENT,\n      data: ['a', 1, {}],\n      id: 1,\n      nsp: '/test'\n    });\n  });\n\n  it('encodes an ack', function(){\n    helpers.test({\n      type: parser.ACK,\n      data: ['a', 1, {}],\n      id: 123,\n      nsp: '/'\n    });\n  });\n\n  it('encodes an error', function(){\n    helpers.test({\n      type: parser.ERROR,\n      data: 'Unauthorized',\n      nsp: '/'\n    });\n  });\n\n  it('properly handles circular objects', function() {\n    var a = {};\n    a.b = a;\n\n    var data = {\n      type: parser.EVENT,\n      data: a,\n      id: 1,\n      nsp: '/'\n    }\n\n    var encoder = new parser.Encoder();\n\n    encoder.encode(data, function(encodedPackets) {\n      expect(encodedPackets[0]).to.be('4\"encode error\"');\n    });\n  });\n\n  it('decodes a bad binary packet', function(){\n    try {\n      var decoder = new parser.Decoder();\n      decoder.add('5');\n    } catch(e){\n      expect(e.message).to.match(/Illegal/);\n    }\n  });\n\n  it('returns an error packet on parsing error', function(done){\n    var decoder = new parser.Decoder();\n    decoder.on('decoded', function(packet) {\n      expect(packet).to.eql({ type: 4, data: 'parser error: invalid payload' });\n      done();\n    });\n    decoder.add('442[\"some\",\"data\"');\n  });\n});\n"], "fixing_code": ["\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an encoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    if (this.reconstructor) {\n      throw new Error(\"got plaintext data when reconstructing a packet\");\n    }\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  } else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  } else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var start = i + 1;\n    while (str.charAt(++i) !== '-' && i != str.length) {}\n    var buf = str.substring(start, i);\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      if (i === str.length) break;\n    }\n    p.nsp = str.substring(start, i);\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      if (i === str.length) break;\n    }\n    p.id = Number(str.substring(start, i + 1));\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    if (isPayloadValid(p.type, payload)) {\n      p.data = payload;\n    } else {\n      throw new Error(\"invalid payload\");\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\nfunction isPayloadValid(type, payload) {\n  switch (type) {\n    case 0: // CONNECT\n      return typeof payload === \"object\";\n    case 1: // DISCONNECT\n      return payload === undefined;\n    case 4: // ERROR\n      return typeof payload === \"string\" || typeof payload === \"object\";\n    case 2: // EVENT\n    case 5: // BINARY_EVENT\n      return (\n        isArray(payload) &&\n        (typeof payload[0] === \"string\" || typeof payload[0] === \"number\")\n      );\n    case 3: // ACK\n    case 6: // BINARY_ACK\n      return isArray(payload);\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n", "var parser = require('../index.js');\nvar expect = require('expect.js');\nvar helpers = require('./helpers.js');\nvar encoder = new parser.Encoder();\n\ndescribe('parser', function() {\n  it('encodes an ArrayBuffer', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', new ArrayBuffer(2)],\n      id: 0,\n      nsp: '/'\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('encodes a TypedArray', function() {\n    var array = new Uint8Array(5);\n    for (var i = 0; i < array.length; i++) array[i] = i;\n\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', array],\n      id: 0,\n      nsp: '/'\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('encodes ArrayBuffers deep in JSON', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', {a: 'hi', b: {why: new ArrayBuffer(3)}, c: {a: 'bye', b: { a: new ArrayBuffer(6)}}}],\n      id: 999,\n      nsp: '/deep'\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('encodes deep binary JSON with null values', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: ['a', {a: 'b', c: 4, e: {g: null}, h: new ArrayBuffer(9)}],\n      nsp: '/',\n      id: 600\n    };\n    helpers.test_bin(packet);\n  });\n\n  it('cleans itself up on close', function() {\n    var packet = {\n      type: parser.BINARY_EVENT,\n      data: [\"foo\", new ArrayBuffer(2), new ArrayBuffer(3)],\n      id: 0,\n      nsp: '/'\n    };\n\n    encoder.encode(packet, function(encodedPackets) {\n      var decoder = new parser.Decoder();\n      decoder.on('decoded', function(packet) {\n        throw new Error(\"received a packet when not all binary data was sent.\");\n      });\n\n      decoder.add(encodedPackets[0]); // add metadata\n      decoder.add(encodedPackets[1]); // add first attachment\n      decoder.destroy(); // destroy before all data added\n      expect(decoder.reconstructor.buffers.length).to.be(0); // expect that buffer is clean\n    });\n  });\n});\n", "var parser = require('../index.js');\nvar expect = require('expect.js');\nvar helpers = require('./helpers.js');\n\ndescribe('parser', function(){\n\n  it('exposes types', function(){\n    expect(parser.CONNECT).to.be.a('number');\n    expect(parser.DISCONNECT).to.be.a('number');\n    expect(parser.EVENT).to.be.a('number');\n    expect(parser.ACK).to.be.a('number');\n    expect(parser.ERROR).to.be.a('number');\n    expect(parser.BINARY_EVENT).to.be.a('number');\n    expect(parser.BINARY_ACK).to.be.a('number');\n  });\n\n  it('encodes connection', function(){\n    helpers.test({\n      type: parser.CONNECT,\n      nsp: '/woot'\n    });\n  });\n\n  it('encodes disconnection', function(){\n    helpers.test({\n      type: parser.DISCONNECT,\n      nsp: '/woot'\n    });\n  });\n\n  it('encodes an event', function(){\n    helpers.test({\n      type: parser.EVENT,\n      data: ['a', 1, {}],\n      nsp: '/'\n    });\n    helpers.test({\n      type: parser.EVENT,\n      data: ['a', 1, {}],\n      id: 1,\n      nsp: '/test'\n    });\n  });\n\n  it('encodes an ack', function(){\n    helpers.test({\n      type: parser.ACK,\n      data: ['a', 1, {}],\n      id: 123,\n      nsp: '/'\n    });\n  });\n\n  it('encodes an error', function(){\n    helpers.test({\n      type: parser.ERROR,\n      data: 'Unauthorized',\n      nsp: '/'\n    });\n  });\n\n  it('properly handles circular objects', function() {\n    var a = {};\n    a.b = a;\n\n    var data = {\n      type: parser.EVENT,\n      data: a,\n      id: 1,\n      nsp: '/'\n    }\n\n    var encoder = new parser.Encoder();\n\n    encoder.encode(data, function(encodedPackets) {\n      expect(encodedPackets[0]).to.be('4\"encode error\"');\n    });\n  });\n\n  it('decodes a bad binary packet', function(){\n    try {\n      var decoder = new parser.Decoder();\n      decoder.add('5');\n    } catch(e){\n      expect(e.message).to.match(/Illegal/);\n    }\n  });\n\n  it('returns an error packet on parsing error', function(){\n    function isInvalidPayload (str) {\n      expect(function () {\n        new parser.Decoder().add(str)\n      }).to.throwException(/^invalid payload$/);\n    }\n\n    isInvalidPayload('442[\"some\",\"data\"');\n    isInvalidPayload('0/admin,\"invalid\"');\n    isInvalidPayload(\"1/admin,{}\");\n    isInvalidPayload('2/admin,\"invalid');\n    isInvalidPayload(\"2/admin,{}\");\n    isInvalidPayload('2[{\"toString\":\"foo\"}]');\n    isInvalidPayload('2[true,\"foo\"]');\n    isInvalidPayload('2[null,\"bar\"]');\n  });\n});\n"], "filenames": ["index.js", "test/arraybuffer.js", "test/parser.js"], "buggy_code_start_loc": [332, 53, 89], "buggy_code_end_loc": [348, 54, 96], "fixing_code_start_loc": [332, 53, 89], "fixing_code_end_loc": [368, 54, 104], "type": "CWE-754", "message": "socket.io parser is a socket.io encoder and decoder written in JavaScript complying with version 5 of socket.io-protocol. A specially crafted Socket.IO packet can trigger an uncaught exception on the Socket.IO server, thus killing the Node.js process. A patch has been released in version 4.2.3.\n\n", "other": {"cve": {"id": "CVE-2023-32695", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-27T16:15:09.433", "lastModified": "2023-06-05T15:54:48.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "socket.io parser is a socket.io encoder and decoder written in JavaScript complying with version 5 of socket.io-protocol. A specially crafted Socket.IO packet can trigger an uncaught exception on the Socket.IO server, thus killing the Node.js process. A patch has been released in version 4.2.3.\n\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:socket:socket.io-parser:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.3", "matchCriteriaId": "1DC31C5F-524B-478D-A85F-0D4F4DCCFF28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:socket:socket.io-parser:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.4", "versionEndExcluding": "4.2.3", "matchCriteriaId": "994E08C3-8408-4FA3-AA7A-A2C13CD20AC9"}]}]}], "references": [{"url": "https://github.com/socketio/socket.io-parser/commit/2dc3c92622dad113b8676be06f23b1ed46b02ced", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/socketio/socket.io-parser/commit/3b78117bf6ba7e99d7a5cfc1ba54d0477554a7f3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/socketio/socket.io-parser/releases/tag/4.2.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/socketio/socket.io-parser/security/advisories/GHSA-cqmj-92xf-r6r9", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/socketio/socket.io-parser/commit/2dc3c92622dad113b8676be06f23b1ed46b02ced"}}