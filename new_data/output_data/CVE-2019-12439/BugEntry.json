{"buggy_code": ["/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"config.h\"\n\n#include <poll.h>\n#include <sched.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/mount.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/eventfd.h>\n#include <sys/fsuid.h>\n#include <sys/signalfd.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <linux/sched.h>\n#include <linux/seccomp.h>\n#include <linux/filter.h>\n\n#include \"utils.h\"\n#include \"network.h\"\n#include \"bind-mount.h\"\n\n#ifndef CLONE_NEWCGROUP\n#define CLONE_NEWCGROUP 0x02000000 /* New cgroup namespace */\n#endif\n\n/* Globals to avoid having to use getuid(), since the uid/gid changes during runtime */\nstatic uid_t real_uid;\nstatic gid_t real_gid;\nstatic uid_t overflow_uid;\nstatic gid_t overflow_gid;\nstatic bool is_privileged; /* See acquire_privs() */\nstatic const char *argv0;\nstatic const char *host_tty_dev;\nstatic int proc_fd = -1;\nstatic const char *opt_exec_label = NULL;\nstatic const char *opt_file_label = NULL;\nstatic bool opt_as_pid_1;\n\nconst char *opt_chdir_path = NULL;\nbool opt_unshare_user = FALSE;\nbool opt_unshare_user_try = FALSE;\nbool opt_unshare_pid = FALSE;\nbool opt_unshare_ipc = FALSE;\nbool opt_unshare_net = FALSE;\nbool opt_unshare_uts = FALSE;\nbool opt_unshare_cgroup = FALSE;\nbool opt_unshare_cgroup_try = FALSE;\nbool opt_needs_devpts = FALSE;\nbool opt_new_session = FALSE;\nbool opt_die_with_parent = FALSE;\nuid_t opt_sandbox_uid = -1;\ngid_t opt_sandbox_gid = -1;\nint opt_sync_fd = -1;\nint opt_block_fd = -1;\nint opt_userns_block_fd = -1;\nint opt_info_fd = -1;\nint opt_json_status_fd = -1;\nint opt_seccomp_fd = -1;\nconst char *opt_sandbox_hostname = NULL;\nchar *opt_args_data = NULL;  /* owned */\n\n#define CAP_TO_MASK_0(x) (1L << ((x) & 31))\n#define CAP_TO_MASK_1(x) CAP_TO_MASK_0(x - 32)\n\ntypedef enum {\n  SETUP_BIND_MOUNT,\n  SETUP_RO_BIND_MOUNT,\n  SETUP_DEV_BIND_MOUNT,\n  SETUP_MOUNT_PROC,\n  SETUP_MOUNT_DEV,\n  SETUP_MOUNT_TMPFS,\n  SETUP_MOUNT_MQUEUE,\n  SETUP_MAKE_DIR,\n  SETUP_MAKE_FILE,\n  SETUP_MAKE_BIND_FILE,\n  SETUP_MAKE_RO_BIND_FILE,\n  SETUP_MAKE_SYMLINK,\n  SETUP_REMOUNT_RO_NO_RECURSIVE,\n  SETUP_SET_HOSTNAME,\n} SetupOpType;\n\ntypedef enum {\n  NO_CREATE_DEST = (1 << 0),\n  ALLOW_NOTEXIST = (2 << 0),\n} SetupOpFlag;\n\ntypedef struct _SetupOp SetupOp;\n\nstruct _SetupOp\n{\n  SetupOpType type;\n  const char *source;\n  const char *dest;\n  int         fd;\n  SetupOpFlag flags;\n  SetupOp    *next;\n};\n\ntypedef struct _LockFile LockFile;\n\nstruct _LockFile\n{\n  const char *path;\n  int         fd;\n  LockFile   *next;\n};\n\nstatic SetupOp *ops = NULL;\nstatic SetupOp *last_op = NULL;\nstatic LockFile *lock_files = NULL;\nstatic LockFile *last_lock_file = NULL;\n\nenum {\n  PRIV_SEP_OP_DONE,\n  PRIV_SEP_OP_BIND_MOUNT,\n  PRIV_SEP_OP_PROC_MOUNT,\n  PRIV_SEP_OP_TMPFS_MOUNT,\n  PRIV_SEP_OP_DEVPTS_MOUNT,\n  PRIV_SEP_OP_MQUEUE_MOUNT,\n  PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE,\n  PRIV_SEP_OP_SET_HOSTNAME,\n};\n\ntypedef struct\n{\n  uint32_t op;\n  uint32_t flags;\n  uint32_t arg1_offset;\n  uint32_t arg2_offset;\n} PrivSepOp;\n\nstatic SetupOp *\nsetup_op_new (SetupOpType type)\n{\n  SetupOp *op = xcalloc (sizeof (SetupOp));\n\n  op->type = type;\n  op->fd = -1;\n  op->flags = 0;\n  if (last_op != NULL)\n    last_op->next = op;\n  else\n    ops = op;\n\n  last_op = op;\n  return op;\n}\n\nstatic LockFile *\nlock_file_new (const char *path)\n{\n  LockFile *lock = xcalloc (sizeof (LockFile));\n\n  lock->path = path;\n  if (last_lock_file != NULL)\n    last_lock_file->next = lock;\n  else\n    lock_files = lock;\n\n  last_lock_file = lock;\n  return lock;\n}\n\n\nstatic void\nusage (int ecode, FILE *out)\n{\n  fprintf (out, \"usage: %s [OPTIONS...] [--] COMMAND [ARGS...]\\n\\n\", argv0);\n\n  fprintf (out,\n           \"    --help                       Print this help\\n\"\n           \"    --version                    Print version\\n\"\n           \"    --args FD                    Parse NUL-separated args from FD\\n\"\n           \"    --unshare-all                Unshare every namespace we support by default\\n\"\n           \"    --share-net                  Retain the network namespace (can only combine with --unshare-all)\\n\"\n           \"    --unshare-user               Create new user namespace (may be automatically implied if not setuid)\\n\"\n           \"    --unshare-user-try           Create new user namespace if possible else continue by skipping it\\n\"\n           \"    --unshare-ipc                Create new ipc namespace\\n\"\n           \"    --unshare-pid                Create new pid namespace\\n\"\n           \"    --unshare-net                Create new network namespace\\n\"\n           \"    --unshare-uts                Create new uts namespace\\n\"\n           \"    --unshare-cgroup             Create new cgroup namespace\\n\"\n           \"    --unshare-cgroup-try         Create new cgroup namespace if possible else continue by skipping it\\n\"\n           \"    --uid UID                    Custom uid in the sandbox (requires --unshare-user)\\n\"\n           \"    --gid GID                    Custom gid in the sandbox (requires --unshare-user)\\n\"\n           \"    --hostname NAME              Custom hostname in the sandbox (requires --unshare-uts)\\n\"\n           \"    --chdir DIR                  Change directory to DIR\\n\"\n           \"    --setenv VAR VALUE           Set an environment variable\\n\"\n           \"    --unsetenv VAR               Unset an environment variable\\n\"\n           \"    --lock-file DEST             Take a lock on DEST while sandbox is running\\n\"\n           \"    --sync-fd FD                 Keep this fd open while sandbox is running\\n\"\n           \"    --bind SRC DEST              Bind mount the host path SRC on DEST\\n\"\n           \"    --bind-try SRC DEST          Equal to --bind but ignores non-existent SRC\\n\"\n           \"    --dev-bind SRC DEST          Bind mount the host path SRC on DEST, allowing device access\\n\"\n           \"    --dev-bind-try SRC DEST      Equal to --dev-bind but ignores non-existent SRC\\n\"\n           \"    --ro-bind SRC DEST           Bind mount the host path SRC readonly on DEST\\n\"\n           \"    --ro-bind-try SRC DEST       Equal to --ro-bind but ignores non-existent SRC\\n\"\n           \"    --remount-ro DEST            Remount DEST as readonly; does not recursively remount\\n\"\n           \"    --exec-label LABEL           Exec label for the sandbox\\n\"\n           \"    --file-label LABEL           File label for temporary sandbox content\\n\"\n           \"    --proc DEST                  Mount new procfs on DEST\\n\"\n           \"    --dev DEST                   Mount new dev on DEST\\n\"\n           \"    --tmpfs DEST                 Mount new tmpfs on DEST\\n\"\n           \"    --mqueue DEST                Mount new mqueue on DEST\\n\"\n           \"    --dir DEST                   Create dir at DEST\\n\"\n           \"    --file FD DEST               Copy from FD to destination DEST\\n\"\n           \"    --bind-data FD DEST          Copy from FD to file which is bind-mounted on DEST\\n\"\n           \"    --ro-bind-data FD DEST       Copy from FD to file which is readonly bind-mounted on DEST\\n\"\n           \"    --symlink SRC DEST           Create symlink at DEST with target SRC\\n\"\n           \"    --seccomp FD                 Load and use seccomp rules from FD\\n\"\n           \"    --block-fd FD                Block on FD until some data to read is available\\n\"\n           \"    --userns-block-fd FD         Block on FD until the user namespace is ready\\n\"\n           \"    --info-fd FD                 Write information about the running container to FD\\n\"\n           \"    --json-status-fd FD          Write container status to FD as multiple JSON documents\\n\"\n           \"    --new-session                Create a new terminal session\\n\"\n           \"    --die-with-parent            Kills with SIGKILL child process (COMMAND) when bwrap or bwrap's parent dies.\\n\"\n           \"    --as-pid-1                   Do not install a reaper process with PID=1\\n\"\n           \"    --cap-add CAP                Add cap CAP when running as privileged user\\n\"\n           \"    --cap-drop CAP               Drop cap CAP when running as privileged user\\n\"\n          );\n  exit (ecode);\n}\n\n/* If --die-with-parent was specified, use PDEATHSIG to ensure SIGKILL\n * is sent to the current process when our parent dies.\n */\nstatic void\nhandle_die_with_parent (void)\n{\n  if (opt_die_with_parent && prctl (PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0) != 0)\n    die_with_error (\"prctl\");\n}\n\nstatic void\nblock_sigchild (void)\n{\n  sigset_t mask;\n  int status;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_BLOCK, &mask, NULL) == -1)\n    die_with_error (\"sigprocmask\");\n\n  /* Reap any outstanding zombies that we may have inherited */\n  while (waitpid (-1, &status, WNOHANG) > 0)\n    ;\n}\n\nstatic void\nunblock_sigchild (void)\n{\n  sigset_t mask;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_UNBLOCK, &mask, NULL) == -1)\n    die_with_error (\"sigprocmask\");\n}\n\n/* Closes all fd:s except 0,1,2 and the passed in array of extra fds */\nstatic int\nclose_extra_fds (void *data, int fd)\n{\n  int *extra_fds = (int *) data;\n  int i;\n\n  for (i = 0; extra_fds[i] != -1; i++)\n    if (fd == extra_fds[i])\n      return 0;\n\n  if (fd <= 2)\n    return 0;\n\n  close (fd);\n  return 0;\n}\n\nstatic int\npropagate_exit_status (int status)\n{\n  if (WIFEXITED (status))\n    return WEXITSTATUS (status);\n\n  /* The process died of a signal, we can't really report that, but we\n   * can at least be bash-compatible. The bash manpage says:\n   *   The return value of a simple command is its\n   *   exit status, or 128+n if the command is\n   *   terminated by signal n.\n   */\n  if (WIFSIGNALED (status))\n    return 128 + WTERMSIG (status);\n\n  /* Weird? */\n  return 255;\n}\n\nstatic void\ndump_info (int fd, const char *output, bool exit_on_error)\n{\n  size_t len = strlen (output);\n  if (write_to_fd (fd, output, len))\n    {\n      if (exit_on_error)\n        die_with_error (\"Write to info_fd\");\n    }\n}\n\nstatic void\nreport_child_exit_status (int exitc, int setup_finished_fd)\n{\n  ssize_t s;\n  char data[2];\n  cleanup_free char *output = NULL;\n  if (opt_json_status_fd == -1 || setup_finished_fd == -1)\n    return;\n\n  s = TEMP_FAILURE_RETRY (read (setup_finished_fd, data, sizeof data));\n  if (s == -1 && errno != EAGAIN)\n    die_with_error (\"read eventfd\");\n  if (s != 1) // Is 0 if pipe closed before exec, is 2 if closed after exec.\n    return;\n\n  output = xasprintf (\"{ \\\"exit-code\\\": %i }\\n\", exitc);\n  dump_info (opt_json_status_fd, output, FALSE);\n  close (opt_json_status_fd);\n  opt_json_status_fd = -1;\n  close (setup_finished_fd);\n}\n\n/* This stays around for as long as the initial process in the app does\n * and when that exits it exits, propagating the exit status. We do this\n * by having pid 1 in the sandbox detect this exit and tell the monitor\n * the exit status via a eventfd. We also track the exit of the sandbox\n * pid 1 via a signalfd for SIGCHLD, and exit with an error in this case.\n * This is to catch e.g. problems during setup. */\nstatic int\nmonitor_child (int event_fd, pid_t child_pid, int setup_finished_fd)\n{\n  int res;\n  uint64_t val;\n  ssize_t s;\n  int signal_fd;\n  sigset_t mask;\n  struct pollfd fds[2];\n  int num_fds;\n  struct signalfd_siginfo fdsi;\n  int dont_close[] = {-1, -1, -1, -1};\n  int j = 0;\n  int exitc;\n  pid_t died_pid;\n  int died_status;\n\n  /* Close all extra fds in the monitoring process.\n     Any passed in fds have been passed on to the child anyway. */\n  if (event_fd != -1)\n    dont_close[j++] = event_fd;\n  if (opt_json_status_fd != -1)\n    dont_close[j++] = opt_json_status_fd;\n  if (setup_finished_fd != -1)\n    dont_close[j++] = setup_finished_fd;\n  assert (j < sizeof(dont_close)/sizeof(*dont_close));\n  fdwalk (proc_fd, close_extra_fds, dont_close);\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  signal_fd = signalfd (-1, &mask, SFD_CLOEXEC | SFD_NONBLOCK);\n  if (signal_fd == -1)\n    die_with_error (\"Can't create signalfd\");\n\n  num_fds = 1;\n  fds[0].fd = signal_fd;\n  fds[0].events = POLLIN;\n  if (event_fd != -1)\n    {\n      fds[1].fd = event_fd;\n      fds[1].events = POLLIN;\n      num_fds++;\n    }\n\n  while (1)\n    {\n      fds[0].revents = fds[1].revents = 0;\n      res = poll (fds, num_fds, -1);\n      if (res == -1 && errno != EINTR)\n        die_with_error (\"poll\");\n\n      /* Always read from the eventfd first, if pid 2 died then pid 1 often\n       * dies too, and we could race, reporting that first and we'd lose\n       * the real exit status. */\n      if (event_fd != -1)\n        {\n          s = read (event_fd, &val, 8);\n          if (s == -1 && errno != EINTR && errno != EAGAIN)\n            die_with_error (\"read eventfd\");\n          else if (s == 8)\n            {\n              exitc = (int) val - 1;\n              report_child_exit_status (exitc, setup_finished_fd);\n              return exitc;\n            }\n        }\n\n      /* We need to read the signal_fd, or it will keep polling as read,\n       * however we ignore the details as we get them from waitpid\n       * below anyway */\n      s = read (signal_fd, &fdsi, sizeof (struct signalfd_siginfo));\n      if (s == -1 && errno != EINTR && errno != EAGAIN)\n        die_with_error (\"read signalfd\");\n\n      /* We may actually get several sigchld compressed into one\n         SIGCHLD, so we have to handle all of them. */\n      while ((died_pid = waitpid (-1, &died_status, WNOHANG)) > 0)\n        {\n          /* We may be getting sigchild from other children too. For instance if\n             someone created a child process, and then exec:ed bubblewrap. Ignore them */\n          if (died_pid == child_pid)\n            {\n              exitc = propagate_exit_status (died_status);\n              report_child_exit_status (exitc, setup_finished_fd);\n              return exitc;\n            }\n        }\n    }\n\n  die (\"Should not be reached\");\n\n  return 0;\n}\n\n/* This is pid 1 in the app sandbox. It is needed because we're using\n * pid namespaces, and someone has to reap zombies in it. We also detect\n * when the initial process (pid 2) dies and report its exit status to\n * the monitor so that it can return it to the original spawner.\n *\n * When there are no other processes in the sandbox the wait will return\n * ECHILD, and we then exit pid 1 to clean up the sandbox. */\nstatic int\ndo_init (int event_fd, pid_t initial_pid, struct sock_fprog *seccomp_prog)\n{\n  int initial_exit_status = 1;\n  LockFile *lock;\n\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      int fd = open (lock->path, O_RDONLY | O_CLOEXEC);\n      if (fd == -1)\n        die_with_error (\"Unable to open lock file %s\", lock->path);\n\n      struct flock l = {\n        .l_type = F_RDLCK,\n        .l_whence = SEEK_SET,\n        .l_start = 0,\n        .l_len = 0\n      };\n\n      if (fcntl (fd, F_SETLK, &l) < 0)\n        die_with_error (\"Unable to lock file %s\", lock->path);\n\n      /* Keep fd open to hang on to lock */\n      lock->fd = fd;\n    }\n\n  /* Optionally bind our lifecycle to that of the caller */\n  handle_die_with_parent ();\n\n  if (seccomp_prog != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  while (TRUE)\n    {\n      pid_t child;\n      int status;\n\n      child = wait (&status);\n      if (child == initial_pid && event_fd != -1)\n        {\n          uint64_t val;\n          int res UNUSED;\n\n          initial_exit_status = propagate_exit_status (status);\n\n          val = initial_exit_status + 1;\n          res = write (event_fd, &val, 8);\n          /* Ignore res, if e.g. the parent died and closed event_fd\n             we don't want to error out here */\n        }\n\n      if (child == -1 && errno != EINTR)\n        {\n          if (errno != ECHILD)\n            die_with_error (\"init wait()\");\n          break;\n        }\n    }\n\n  /* Close FDs. */\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      if (lock->fd >= 0)\n        {\n          close (lock->fd);\n          lock->fd = -1;\n        }\n    }\n\n  return initial_exit_status;\n}\n\n#define CAP_TO_MASK_0(x) (1L << ((x) & 31))\n#define CAP_TO_MASK_1(x) CAP_TO_MASK_0(x - 32)\n\n/* Set if --cap-add or --cap-drop were used */\nstatic bool opt_cap_add_or_drop_used;\n/* The capability set we'll target, used if above is true */\nstatic uint32_t requested_caps[2] = {0, 0};\n\n/* low 32bit caps needed */\n#define REQUIRED_CAPS_0 (CAP_TO_MASK_0 (CAP_SYS_ADMIN) | CAP_TO_MASK_0 (CAP_SYS_CHROOT) | CAP_TO_MASK_0 (CAP_NET_ADMIN) | CAP_TO_MASK_0 (CAP_SETUID) | CAP_TO_MASK_0 (CAP_SETGID))\n/* high 32bit caps needed */\n#define REQUIRED_CAPS_1 0\n\nstatic void\nset_required_caps (void)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  /* Drop all non-require capabilities */\n  data[0].effective = REQUIRED_CAPS_0;\n  data[0].permitted = REQUIRED_CAPS_0;\n  data[0].inheritable = 0;\n  data[1].effective = REQUIRED_CAPS_1;\n  data[1].permitted = REQUIRED_CAPS_1;\n  data[1].inheritable = 0;\n  if (capset (&hdr, data) < 0)\n    die_with_error (\"capset failed\");\n}\n\nstatic void\ndrop_all_caps (bool keep_requested_caps)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  if (keep_requested_caps)\n    {\n      /* Avoid calling capset() unless we need to; currently\n       * systemd-nspawn at least is known to install a seccomp\n       * policy denying capset() for dubious reasons.\n       * <https://github.com/projectatomic/bubblewrap/pull/122>\n       */\n      if (!opt_cap_add_or_drop_used && real_uid == 0)\n        {\n          assert (!is_privileged);\n          return;\n        }\n      data[0].effective = requested_caps[0];\n      data[0].permitted = requested_caps[0];\n      data[0].inheritable = requested_caps[0];\n      data[1].effective = requested_caps[1];\n      data[1].permitted = requested_caps[1];\n      data[1].inheritable = requested_caps[1];\n    }\n\n  if (capset (&hdr, data) < 0)\n    {\n      /* While the above logic ensures we don't call capset() for the primary\n       * process unless configured to do so, we still try to drop privileges for\n       * the init process unconditionally. Since due to the systemd seccomp\n       * filter that will fail, let's just ignore it.\n       */\n      if (errno == EPERM && real_uid == 0 && !is_privileged)\n        return;\n      else\n        die_with_error (\"capset failed\");\n    }\n}\n\nstatic bool\nhas_caps (void)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  if (capget (&hdr, data)  < 0)\n    die_with_error (\"capget failed\");\n\n  return data[0].permitted != 0 || data[1].permitted != 0;\n}\n\n/* Most of the code here is used both to add caps to the ambient capabilities\n * and drop caps from the bounding set.  Handle both cases here and add\n * drop_cap_bounding_set/set_ambient_capabilities wrappers to facilitate its usage.\n */\nstatic void\nprctl_caps (uint32_t *caps, bool do_cap_bounding, bool do_set_ambient)\n{\n  unsigned long cap;\n\n  /* We ignore both EINVAL and EPERM, as we are actually relying\n   * on PR_SET_NO_NEW_PRIVS to ensure the right capabilities are\n   * available.  EPERM in particular can happen with old, buggy\n   * kernels.  See:\n   *  https://github.com/projectatomic/bubblewrap/pull/175#issuecomment-278051373\n   *  https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/security/commoncap.c?id=160da84dbb39443fdade7151bc63a88f8e953077\n   */\n  for (cap = 0; cap <= CAP_LAST_CAP; cap++)\n    {\n      bool keep = FALSE;\n      if (cap < 32)\n        {\n          if (CAP_TO_MASK_0 (cap) & caps[0])\n            keep = TRUE;\n        }\n      else\n        {\n          if (CAP_TO_MASK_1 (cap) & caps[1])\n            keep = TRUE;\n        }\n\n      if (keep && do_set_ambient)\n        {\n#ifdef PR_CAP_AMBIENT\n          int res = prctl (PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, cap, 0, 0);\n          if (res == -1 && !(errno == EINVAL || errno == EPERM))\n            die_with_error (\"Adding ambient capability %ld\", cap);\n#else\n          /* We ignore the EINVAL that results from not having PR_CAP_AMBIENT\n           * in the current kernel at runtime, so also ignore not having it\n           * in the current kernel headers at compile-time */\n#endif\n        }\n\n      if (!keep && do_cap_bounding)\n        {\n          int res = prctl (PR_CAPBSET_DROP, cap, 0, 0, 0);\n          if (res == -1 && !(errno == EINVAL || errno == EPERM))\n            die_with_error (\"Dropping capability %ld from bounds\", cap);\n        }\n    }\n}\n\nstatic void\ndrop_cap_bounding_set (bool drop_all)\n{\n  if (!drop_all)\n    prctl_caps (requested_caps, TRUE, FALSE);\n  else\n    {\n      uint32_t no_caps[2] = {0, 0};\n      prctl_caps (no_caps, TRUE, FALSE);\n    }\n}\n\nstatic void\nset_ambient_capabilities (void)\n{\n  if (is_privileged)\n    return;\n  prctl_caps (requested_caps, FALSE, TRUE);\n}\n\n/* This acquires the privileges that the bwrap will need it to work.\n * If bwrap is not setuid, then this does nothing, and it relies on\n * unprivileged user namespaces to be used. This case is\n * \"is_privileged = FALSE\".\n *\n * If bwrap is setuid, then we do things in phases.\n * The first part is run as euid 0, but with fsuid as the real user.\n * The second part, inside the child, is run as the real user but with\n * capabilities.\n * And finally we drop all capabilities.\n * The reason for the above dance is to avoid having the setup phase\n * being able to read files the user can't, while at the same time\n * working around various kernel issues. See below for details.\n */\nstatic void\nacquire_privs (void)\n{\n  uid_t euid, new_fsuid;\n\n  euid = geteuid ();\n\n  /* Are we setuid ? */\n  if (real_uid != euid)\n    {\n      if (euid != 0)\n        die (\"Unexpected setuid user %d, should be 0\", euid);\n\n      is_privileged = TRUE;\n      /* We want to keep running as euid=0 until at the clone()\n       * operation because doing so will make the user namespace be\n       * owned by root, which makes it not ptrace:able by the user as\n       * it otherwise would be. After that we will run fully as the\n       * user, which is necessary e.g. to be able to read from a fuse\n       * mount from the user.\n       *\n       * However, we don't want to accidentally mis-use euid=0 for\n       * escalated filesystem access before the clone(), so we set\n       * fsuid to the uid.\n       */\n      if (setfsuid (real_uid) < 0)\n        die_with_error (\"Unable to set fsuid\");\n\n      /* setfsuid can't properly report errors, check that it worked (as per manpage) */\n      new_fsuid = setfsuid (-1);\n      if (new_fsuid != real_uid)\n        die (\"Unable to set fsuid (was %d)\", (int)new_fsuid);\n\n      /* We never need capabilities after execve(), so lets drop everything from the bounding set */\n      drop_cap_bounding_set (TRUE);\n\n      /* Keep only the required capabilities for setup */\n      set_required_caps ();\n    }\n  else if (real_uid != 0 && has_caps ())\n    {\n      /* We have some capabilities in the non-setuid case, which should not happen.\n         Probably caused by the binary being setcap instead of setuid which we\n         don't support anymore */\n      die (\"Unexpected capabilities but not setuid, old file caps config?\");\n    }\n  else if (real_uid == 0)\n    {\n      /* If our uid is 0, default to inheriting all caps; the caller\n       * can drop them via --cap-drop.  This is used by at least rpm-ostree.\n       * Note this needs to happen before the argument parsing of --cap-drop.\n       */\n      struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n      struct __user_cap_data_struct data[2] = { { 0 } };\n\n      if (capget (&hdr, data) < 0)\n        die_with_error (\"capget (for uid == 0) failed\");\n\n      requested_caps[0] = data[0].effective;\n      requested_caps[1] = data[1].effective;\n    }\n\n  /* Else, we try unprivileged user namespaces */\n}\n\n/* This is called once we're inside the namespace */\nstatic void\nswitch_to_user_with_privs (void)\n{\n  /* If we're in a new user namespace, we got back the bounding set, clear it again */\n  if (opt_unshare_user)\n    drop_cap_bounding_set (FALSE);\n\n  if (!is_privileged)\n    return;\n\n  /* Tell kernel not clear capabilities when later dropping root uid */\n  if (prctl (PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_KEEPCAPS) failed\");\n\n  if (setuid (opt_sandbox_uid) < 0)\n    die_with_error (\"unable to drop root uid\");\n\n  /* Regain effective required capabilities from permitted */\n  set_required_caps ();\n}\n\n/* Call setuid() and use capset() to adjust capabilities */\nstatic void\ndrop_privs (bool keep_requested_caps)\n{\n  assert (!keep_requested_caps || !is_privileged);\n  /* Drop root uid */\n  if (getuid () == 0 && setuid (opt_sandbox_uid) < 0)\n    die_with_error (\"unable to drop root uid\");\n\n  drop_all_caps (keep_requested_caps);\n}\n\nstatic char *\nget_newroot_path (const char *path)\n{\n  while (*path == '/')\n    path++;\n  return strconcat (\"/newroot/\", path);\n}\n\nstatic char *\nget_oldroot_path (const char *path)\n{\n  while (*path == '/')\n    path++;\n  return strconcat (\"/oldroot/\", path);\n}\n\nstatic void\nwrite_uid_gid_map (uid_t sandbox_uid,\n                   uid_t parent_uid,\n                   uid_t sandbox_gid,\n                   uid_t parent_gid,\n                   pid_t pid,\n                   bool  deny_groups,\n                   bool  map_root)\n{\n  cleanup_free char *uid_map = NULL;\n  cleanup_free char *gid_map = NULL;\n  cleanup_free char *dir = NULL;\n  cleanup_fd int dir_fd = -1;\n  uid_t old_fsuid = -1;\n\n  if (pid == -1)\n    dir = xstrdup (\"self\");\n  else\n    dir = xasprintf (\"%d\", pid);\n\n  dir_fd = openat (proc_fd, dir, O_PATH);\n  if (dir_fd < 0)\n    die_with_error (\"open /proc/%s failed\", dir);\n\n  if (map_root && parent_uid != 0 && sandbox_uid != 0)\n    uid_map = xasprintf (\"0 %d 1\\n\"\n                         \"%d %d 1\\n\", overflow_uid, sandbox_uid, parent_uid);\n  else\n    uid_map = xasprintf (\"%d %d 1\\n\", sandbox_uid, parent_uid);\n\n  if (map_root && parent_gid != 0 && sandbox_gid != 0)\n    gid_map = xasprintf (\"0 %d 1\\n\"\n                         \"%d %d 1\\n\", overflow_gid, sandbox_gid, parent_gid);\n  else\n    gid_map = xasprintf (\"%d %d 1\\n\", sandbox_gid, parent_gid);\n\n  /* We have to be root to be allowed to write to the uid map\n   * for setuid apps, so temporary set fsuid to 0 */\n  if (is_privileged)\n    old_fsuid = setfsuid (0);\n\n  if (write_file_at (dir_fd, \"uid_map\", uid_map) != 0)\n    die_with_error (\"setting up uid map\");\n\n  if (deny_groups &&\n      write_file_at (dir_fd, \"setgroups\", \"deny\\n\") != 0)\n    {\n      /* If /proc/[pid]/setgroups does not exist, assume we are\n       * running a linux kernel < 3.19, i.e. we live with the\n       * vulnerability known as CVE-2014-8989 in older kernels\n       * where setgroups does not exist.\n       */\n      if (errno != ENOENT)\n        die_with_error (\"error writing to setgroups\");\n    }\n\n  if (write_file_at (dir_fd, \"gid_map\", gid_map) != 0)\n    die_with_error (\"setting up gid map\");\n\n  if (is_privileged)\n    {\n      setfsuid (old_fsuid);\n      if (setfsuid (-1) != real_uid)\n        die (\"Unable to re-set fsuid\");\n    }\n}\n\nstatic void\nprivileged_op (int         privileged_op_socket,\n               uint32_t    op,\n               uint32_t    flags,\n               const char *arg1,\n               const char *arg2)\n{\n  if (privileged_op_socket != -1)\n    {\n      uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n      PrivSepOp *op_buffer = (PrivSepOp *) buffer;\n      size_t buffer_size = sizeof (PrivSepOp);\n      uint32_t arg1_offset = 0, arg2_offset = 0;\n\n      /* We're unprivileged, send this request to the privileged part */\n\n      if (arg1 != NULL)\n        {\n          arg1_offset = buffer_size;\n          buffer_size += strlen (arg1) + 1;\n        }\n      if (arg2 != NULL)\n        {\n          arg2_offset = buffer_size;\n          buffer_size += strlen (arg2) + 1;\n        }\n\n      if (buffer_size >= sizeof (buffer))\n        die (\"privilege separation operation to large\");\n\n      op_buffer->op = op;\n      op_buffer->flags = flags;\n      op_buffer->arg1_offset = arg1_offset;\n      op_buffer->arg2_offset = arg2_offset;\n      if (arg1 != NULL)\n        strcpy ((char *) buffer + arg1_offset, arg1);\n      if (arg2 != NULL)\n        strcpy ((char *) buffer + arg2_offset, arg2);\n\n      if (write (privileged_op_socket, buffer, buffer_size) != buffer_size)\n        die (\"Can't write to privileged_op_socket\");\n\n      if (read (privileged_op_socket, buffer, 1) != 1)\n        die (\"Can't read from privileged_op_socket\");\n\n      return;\n    }\n\n  /*\n   * This runs a privileged request for the unprivileged setup\n   * code. Note that since the setup code is unprivileged it is not as\n   * trusted, so we need to verify that all requests only affect the\n   * child namespace as set up by the privileged parts of the setup,\n   * and that all the code is very careful about handling input.\n   *\n   * This means:\n   *  * Bind mounts are safe, since we always use filesystem namespace. They\n   *     must be recursive though, as otherwise you can use a non-recursive bind\n   *     mount to access an otherwise over-mounted mountpoint.\n   *  * Mounting proc, tmpfs, mqueue, devpts in the child namespace is assumed to\n   *    be safe.\n   *  * Remounting RO (even non-recursive) is safe because it decreases privileges.\n   *  * sethostname() is safe only if we set up a UTS namespace\n   */\n  switch (op)\n    {\n    case PRIV_SEP_OP_DONE:\n      break;\n\n    case PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE:\n      if (bind_mount (proc_fd, NULL, arg2, BIND_READONLY) != 0)\n        die_with_error (\"Can't remount readonly on %s\", arg2);\n      break;\n\n    case PRIV_SEP_OP_BIND_MOUNT:\n      /* We always bind directories recursively, otherwise this would let us\n         access files that are otherwise covered on the host */\n      if (bind_mount (proc_fd, arg1, arg2, BIND_RECURSIVE | flags) != 0)\n        die_with_error (\"Can't bind mount %s on %s\", arg1, arg2);\n      break;\n\n    case PRIV_SEP_OP_PROC_MOUNT:\n      if (mount (\"proc\", arg1, \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL) != 0)\n        die_with_error (\"Can't mount proc on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_TMPFS_MOUNT:\n      {\n        cleanup_free char *opt = label_mount (\"mode=0755\", opt_file_label);\n        if (mount (\"tmpfs\", arg1, \"tmpfs\", MS_NOSUID | MS_NODEV, opt) != 0)\n          die_with_error (\"Can't mount tmpfs on %s\", arg1);\n        break;\n      }\n\n    case PRIV_SEP_OP_DEVPTS_MOUNT:\n      if (mount (\"devpts\", arg1, \"devpts\", MS_NOSUID | MS_NOEXEC,\n                 \"newinstance,ptmxmode=0666,mode=620\") != 0)\n        die_with_error (\"Can't mount devpts on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_MQUEUE_MOUNT:\n      if (mount (\"mqueue\", arg1, \"mqueue\", 0, NULL) != 0)\n        die_with_error (\"Can't mount mqueue on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_SET_HOSTNAME:\n      /* This is checked at the start, but lets verify it here in case\n         something manages to send hacked priv-sep operation requests. */\n      if (!opt_unshare_uts)\n        die (\"Refusing to set hostname in original namespace\");\n      if (sethostname (arg1, strlen(arg1)) != 0)\n        die_with_error (\"Can't set hostname to %s\", arg1);\n      break;\n\n    default:\n      die (\"Unexpected privileged op %d\", op);\n    }\n}\n\n/* This is run unprivileged in the child namespace but can request\n * some privileged operations (also in the child namespace) via the\n * privileged_op_socket.\n */\nstatic void\nsetup_newroot (bool unshare_pid,\n               int  privileged_op_socket)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      cleanup_free char *source = NULL;\n      cleanup_free char *dest = NULL;\n      int source_mode = 0;\n      int i;\n\n      if (op->source &&\n          op->type != SETUP_MAKE_SYMLINK)\n        {\n          source = get_oldroot_path (op->source);\n          source_mode = get_file_mode (source);\n          if (source_mode < 0)\n            {\n              if (op->flags & ALLOW_NOTEXIST && errno == ENOENT)\n                continue; /* Ignore and move on */\n              die_with_error(\"Can't get type of source %s\", op->source);\n            }\n        }\n\n      if (op->dest &&\n          (op->flags & NO_CREATE_DEST) == 0)\n        {\n          dest = get_newroot_path (op->dest);\n          if (mkdir_with_parents (dest, 0755, FALSE) != 0)\n            die_with_error (\"Can't mkdir parents for %s\", op->dest);\n        }\n\n      switch (op->type)\n        {\n        case SETUP_RO_BIND_MOUNT:\n        case SETUP_DEV_BIND_MOUNT:\n        case SETUP_BIND_MOUNT:\n          if (source_mode == S_IFDIR)\n            {\n              if (ensure_dir (dest, 0755) != 0)\n                die_with_error (\"Can't mkdir %s\", op->dest);\n            }\n          else if (ensure_file (dest, 0666) != 0)\n            die_with_error (\"Can't create file at %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_BIND_MOUNT,\n                         (op->type == SETUP_RO_BIND_MOUNT ? BIND_READONLY : 0) |\n                         (op->type == SETUP_DEV_BIND_MOUNT ? BIND_DEVICES : 0),\n                         source, dest);\n          break;\n\n        case SETUP_REMOUNT_RO_NO_RECURSIVE:\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE, 0, NULL, dest);\n          break;\n\n        case SETUP_MOUNT_PROC:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          if (unshare_pid)\n            {\n              /* Our own procfs */\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_PROC_MOUNT, 0,\n                             dest, NULL);\n            }\n          else\n            {\n              /* Use system procfs, as we share pid namespace anyway */\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, 0,\n                             \"oldroot/proc\", dest);\n            }\n\n          /* There are a bunch of weird old subdirs of /proc that could potentially be\n             problematic (for instance /proc/sysrq-trigger lets you shut down the machine\n             if you have write access). We should not have access to these as a non-privileged\n             user, but lets cover them anyway just to make sure */\n          const char *cover_proc_dirs[] = { \"sys\", \"sysrq-trigger\", \"irq\", \"bus\" };\n          for (i = 0; i < N_ELEMENTS (cover_proc_dirs); i++)\n            {\n              cleanup_free char *subdir = strconcat3 (dest, \"/\", cover_proc_dirs[i]);\n              if (access (subdir, W_OK) < 0)\n                {\n                  /* The file is already read-only or doesn't exist.  */\n                  if (errno == EACCES || errno == ENOENT)\n                    continue;\n\n                  die_with_error (\"Can't access %s\", subdir);\n                }\n\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_READONLY,\n                             subdir, subdir);\n            }\n\n          break;\n\n        case SETUP_MOUNT_DEV:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_TMPFS_MOUNT, 0,\n                         dest, NULL);\n\n          static const char *const devnodes[] = { \"null\", \"zero\", \"full\", \"random\", \"urandom\", \"tty\" };\n          for (i = 0; i < N_ELEMENTS (devnodes); i++)\n            {\n              cleanup_free char *node_dest = strconcat3 (dest, \"/\", devnodes[i]);\n              cleanup_free char *node_src = strconcat (\"/oldroot/dev/\", devnodes[i]);\n              if (create_file (node_dest, 0666, NULL) != 0)\n                die_with_error (\"Can't create file %s/%s\", op->dest, devnodes[i]);\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_DEVICES,\n                             node_src, node_dest);\n            }\n\n          static const char *const stdionodes[] = { \"stdin\", \"stdout\", \"stderr\" };\n          for (i = 0; i < N_ELEMENTS (stdionodes); i++)\n            {\n              cleanup_free char *target = xasprintf (\"/proc/self/fd/%d\", i);\n              cleanup_free char *node_dest = strconcat3 (dest, \"/\", stdionodes[i]);\n              if (symlink (target, node_dest) < 0)\n                die_with_error (\"Can't create symlink %s/%s\", op->dest, stdionodes[i]);\n            }\n\n          /* /dev/fd and /dev/core - legacy, but both nspawn and docker do these */\n          { cleanup_free char *dev_fd = strconcat (dest, \"/fd\");\n            if (symlink (\"/proc/self/fd\", dev_fd) < 0)\n              die_with_error (\"Can't create symlink %s\", dev_fd);\n          }\n          { cleanup_free char *dev_core = strconcat (dest, \"/core\");\n            if (symlink (\"/proc/kcore\", dev_core) < 0)\n              die_with_error (\"Can't create symlink %s\", dev_core);\n          }\n\n          {\n            cleanup_free char *pts = strconcat (dest, \"/pts\");\n            cleanup_free char *ptmx = strconcat (dest, \"/ptmx\");\n            cleanup_free char *shm = strconcat (dest, \"/shm\");\n\n            if (mkdir (shm, 0755) == -1)\n              die_with_error (\"Can't create %s/shm\", op->dest);\n\n            if (mkdir (pts, 0755) == -1)\n              die_with_error (\"Can't create %s/devpts\", op->dest);\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_DEVPTS_MOUNT, 0, pts, NULL);\n\n            if (symlink (\"pts/ptmx\", ptmx) != 0)\n              die_with_error (\"Can't make symlink at %s/ptmx\", op->dest);\n          }\n\n          /* If stdout is a tty, that means the sandbox can write to the\n             outside-sandbox tty. In that case we also create a /dev/console\n             that points to this tty device. This should not cause any more\n             access than we already have, and it makes ttyname() work in the\n             sandbox. */\n          if (host_tty_dev != NULL && *host_tty_dev != 0)\n            {\n              cleanup_free char *src_tty_dev = strconcat (\"/oldroot\", host_tty_dev);\n              cleanup_free char *dest_console = strconcat (dest, \"/console\");\n\n              if (create_file (dest_console, 0666, NULL) != 0)\n                die_with_error (\"creating %s/console\", op->dest);\n\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_DEVICES,\n                             src_tty_dev, dest_console);\n            }\n\n          break;\n\n        case SETUP_MOUNT_TMPFS:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_TMPFS_MOUNT, 0,\n                         dest, NULL);\n          break;\n\n        case SETUP_MOUNT_MQUEUE:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_MQUEUE_MOUNT, 0,\n                         dest, NULL);\n          break;\n\n        case SETUP_MAKE_DIR:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          break;\n\n        case SETUP_MAKE_FILE:\n          {\n            cleanup_fd int dest_fd = -1;\n\n            dest_fd = creat (dest, 0666);\n            if (dest_fd == -1)\n              die_with_error (\"Can't create file %s\", op->dest);\n\n            if (copy_file_data (op->fd, dest_fd) != 0)\n              die_with_error (\"Can't write data to file %s\", op->dest);\n\n            close (op->fd);\n            op->fd = -1;\n          }\n          break;\n\n        case SETUP_MAKE_BIND_FILE:\n        case SETUP_MAKE_RO_BIND_FILE:\n          {\n            cleanup_fd int dest_fd = -1;\n            char tempfile[] = \"/bindfileXXXXXX\";\n\n            dest_fd = mkstemp (tempfile);\n            if (dest_fd == -1)\n              die_with_error (\"Can't create tmpfile for %s\", op->dest);\n\n            if (copy_file_data (op->fd, dest_fd) != 0)\n              die_with_error (\"Can't write data to file %s\", op->dest);\n\n            close (op->fd);\n            op->fd = -1;\n\n            assert (dest != NULL);\n\n            if (ensure_file (dest, 0666) != 0)\n              die_with_error (\"Can't create file at %s\", op->dest);\n\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_BIND_MOUNT,\n                           (op->type == SETUP_MAKE_RO_BIND_FILE ? BIND_READONLY : 0),\n                           tempfile, dest);\n\n            /* Remove the file so we're sure the app can't get to it in any other way.\n               Its outside the container chroot, so it shouldn't be possible, but lets\n               make it really sure. */\n            unlink (tempfile);\n          }\n          break;\n\n        case SETUP_MAKE_SYMLINK:\n          assert (op->source != NULL);  /* guaranteed by the constructor */\n          if (symlink (op->source, dest) != 0)\n            die_with_error (\"Can't make symlink at %s\", op->dest);\n          break;\n\n        case SETUP_SET_HOSTNAME:\n          assert (op->dest != NULL);  /* guaranteed by the constructor */\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_SET_HOSTNAME, 0,\n                         op->dest, NULL);\n          break;\n\n        default:\n          die (\"Unexpected type %d\", op->type);\n        }\n    }\n  privileged_op (privileged_op_socket,\n                 PRIV_SEP_OP_DONE, 0, NULL, NULL);\n}\n\n/* Do not leak file descriptors already used by setup_newroot () */\nstatic void\nclose_ops_fd (void)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      if (op->fd != -1)\n        {\n          (void) close (op->fd);\n          op->fd = -1;\n        }\n    }\n}\n\n/* We need to resolve relative symlinks in the sandbox before we\n   chroot so that absolute symlinks are handled correctly. We also\n   need to do this after we've switched to the real uid so that\n   e.g. paths on fuse mounts work */\nstatic void\nresolve_symlinks_in_ops (void)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      const char *old_source;\n\n      switch (op->type)\n        {\n        case SETUP_RO_BIND_MOUNT:\n        case SETUP_DEV_BIND_MOUNT:\n        case SETUP_BIND_MOUNT:\n          old_source = op->source;\n          op->source = realpath (old_source, NULL);\n          if (op->source == NULL)\n            {\n              if (op->flags & ALLOW_NOTEXIST && errno == ENOENT)\n                op->source = old_source;\n              else\n                die_with_error(\"Can't find source path %s\", old_source);\n            }\n          break;\n        default:\n          break;\n        }\n    }\n}\n\n\nstatic const char *\nresolve_string_offset (void    *buffer,\n                       size_t   buffer_size,\n                       uint32_t offset)\n{\n  if (offset == 0)\n    return NULL;\n\n  if (offset > buffer_size)\n    die (\"Invalid string offset %d (buffer size %zd)\", offset, buffer_size);\n\n  return (const char *) buffer + offset;\n}\n\nstatic uint32_t\nread_priv_sec_op (int          read_socket,\n                  void        *buffer,\n                  size_t       buffer_size,\n                  uint32_t    *flags,\n                  const char **arg1,\n                  const char **arg2)\n{\n  const PrivSepOp *op = (const PrivSepOp *) buffer;\n  ssize_t rec_len;\n\n  do\n    rec_len = read (read_socket, buffer, buffer_size - 1);\n  while (rec_len == -1 && errno == EINTR);\n\n  if (rec_len < 0)\n    die_with_error (\"Can't read from unprivileged helper\");\n\n  if (rec_len == 0)\n    exit (1); /* Privileged helper died and printed error, so exit silently */\n\n  if (rec_len < sizeof (PrivSepOp))\n    die (\"Invalid size %zd from unprivileged helper\", rec_len);\n\n  /* Guarantee zero termination of any strings */\n  ((char *) buffer)[rec_len] = 0;\n\n  *flags = op->flags;\n  *arg1 = resolve_string_offset (buffer, rec_len, op->arg1_offset);\n  *arg2 = resolve_string_offset (buffer, rec_len, op->arg2_offset);\n\n  return op->op;\n}\n\nstatic void __attribute__ ((noreturn))\nprint_version_and_exit (void)\n{\n  printf (\"%s\\n\", PACKAGE_STRING);\n  exit (0);\n}\n\nstatic void\nparse_args_recurse (int          *argcp,\n                    const char ***argvp,\n                    bool          in_file,\n                    int          *total_parsed_argc_p)\n{\n  SetupOp *op;\n  int argc = *argcp;\n  const char **argv = *argvp;\n  /* I can't imagine a case where someone wants more than this.\n   * If you do...you should be able to pass multiple files\n   * via a single tmpfs and linking them there, etc.\n   *\n   * We're adding this hardening due to precedent from\n   * http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html\n   *\n   * I picked 9000 because the Internet told me to and it was hard to\n   * resist.\n   */\n  static const uint32_t MAX_ARGS = 9000;\n\n  if (*total_parsed_argc_p > MAX_ARGS)\n    die (\"Exceeded maximum number of arguments %u\", MAX_ARGS);\n\n  while (argc > 0)\n    {\n      const char *arg = argv[0];\n\n      if (strcmp (arg, \"--help\") == 0)\n        {\n          usage (EXIT_SUCCESS, stdout);\n        }\n      else if (strcmp (arg, \"--version\") == 0)\n        {\n          print_version_and_exit ();\n        }\n      else if (strcmp (arg, \"--args\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n          const char *p, *data_end;\n          size_t data_len;\n          cleanup_free const char **data_argv = NULL;\n          const char **data_argv_copy;\n          int data_argc;\n          int i;\n\n          if (in_file)\n            die (\"--args not supported in arguments file\");\n\n          if (argc < 2)\n            die (\"--args takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          /* opt_args_data is essentially a recursive argv array, which we must\n           * keep allocated until exit time, since its argv entries get used\n           * by the other cases in parse_args_recurse() when we recurse. */\n          opt_args_data = load_file_data (the_fd, &data_len);\n          if (opt_args_data == NULL)\n            die_with_error (\"Can't read --args data\");\n          (void) close (the_fd);\n\n          data_end = opt_args_data + data_len;\n          data_argc = 0;\n\n          p = opt_args_data;\n          while (p != NULL && p < data_end)\n            {\n              data_argc++;\n              (*total_parsed_argc_p)++;\n              if (*total_parsed_argc_p > MAX_ARGS)\n                die (\"Exceeded maximum number of arguments %u\", MAX_ARGS);\n              p = memchr (p, 0, data_end - p);\n              if (p != NULL)\n                p++;\n            }\n\n          data_argv = xcalloc (sizeof (char *) * (data_argc + 1));\n\n          i = 0;\n          p = opt_args_data;\n          while (p != NULL && p < data_end)\n            {\n              /* Note: load_file_data always adds a nul terminator, so this is safe\n               * even for the last string. */\n              data_argv[i++] = p;\n              p = memchr (p, 0, data_end - p);\n              if (p != NULL)\n                p++;\n            }\n\n          data_argv_copy = data_argv; /* Don't change data_argv, we need to free it */\n          parse_args_recurse (&data_argc, &data_argv_copy, TRUE, total_parsed_argc_p);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--unshare-all\") == 0)\n        {\n          /* Keep this in order with the older (legacy) --unshare arguments,\n           * we use the --try variants of user and cgroup, since we want\n           * to support systems/kernels without support for those.\n           */\n          opt_unshare_user_try = opt_unshare_ipc = opt_unshare_pid =\n            opt_unshare_uts = opt_unshare_cgroup_try =\n            opt_unshare_net = TRUE;\n        }\n      /* Begin here the older individual --unshare variants */\n      else if (strcmp (arg, \"--unshare-user\") == 0)\n        {\n          opt_unshare_user = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-user-try\") == 0)\n        {\n          opt_unshare_user_try = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-ipc\") == 0)\n        {\n          opt_unshare_ipc = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-pid\") == 0)\n        {\n          opt_unshare_pid = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-net\") == 0)\n        {\n          opt_unshare_net = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-uts\") == 0)\n        {\n          opt_unshare_uts = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-cgroup\") == 0)\n        {\n          opt_unshare_cgroup = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-cgroup-try\") == 0)\n        {\n          opt_unshare_cgroup_try = TRUE;\n        }\n      /* Begin here the newer --share variants */\n      else if (strcmp (arg, \"--share-net\") == 0)\n        {\n          opt_unshare_net = FALSE;\n        }\n      /* End --share variants, other arguments begin */\n      else if (strcmp (arg, \"--chdir\") == 0)\n        {\n          if (argc < 2)\n            die (\"--chdir takes one argument\");\n\n          opt_chdir_path = argv[1];\n          argv++;\n          argc--;\n        }\n      else if (strcmp (arg, \"--remount-ro\") == 0)\n        {\n          if (argc < 2)\n            die (\"--remount-ro takes one argument\");\n\n          SetupOp *op = setup_op_new (SETUP_REMOUNT_RO_NO_RECURSIVE);\n          op->dest = argv[1];\n\n          argv++;\n          argc--;\n        }\n      else if (strcmp(arg, \"--bind\") == 0 ||\n               strcmp(arg, \"--bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp(arg, \"--ro-bind\") == 0 ||\n               strcmp(arg, \"--ro-bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_RO_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--ro-bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--dev-bind\") == 0 ||\n               strcmp (arg, \"--dev-bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_DEV_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--dev-bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--proc\") == 0)\n        {\n          if (argc < 2)\n            die (\"--proc takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_PROC);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--exec-label\") == 0)\n        {\n          if (argc < 2)\n            die (\"--exec-label takes an argument\");\n          opt_exec_label = argv[1];\n          die_unless_label_valid (opt_exec_label);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--file-label\") == 0)\n        {\n          if (argc < 2)\n            die (\"--file-label takes an argument\");\n          opt_file_label = argv[1];\n          die_unless_label_valid (opt_file_label);\n          if (label_create_file (opt_file_label))\n            die_with_error (\"--file-label setup failed\");\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--dev\") == 0)\n        {\n          if (argc < 2)\n            die (\"--dev takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_DEV);\n          op->dest = argv[1];\n          opt_needs_devpts = TRUE;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--tmpfs\") == 0)\n        {\n          if (argc < 2)\n            die (\"--tmpfs takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_TMPFS);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--mqueue\") == 0)\n        {\n          if (argc < 2)\n            die (\"--mqueue takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_MQUEUE);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--dir\") == 0)\n        {\n          if (argc < 2)\n            die (\"--dir takes an argument\");\n\n          op = setup_op_new (SETUP_MAKE_DIR);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--file\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--file takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--bind-data\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--bind-data takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_BIND_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--ro-bind-data\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--ro-bind-data takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_RO_BIND_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--symlink\") == 0)\n        {\n          if (argc < 3)\n            die (\"--symlink takes two arguments\");\n\n          op = setup_op_new (SETUP_MAKE_SYMLINK);\n          op->source = argv[1];\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--lock-file\") == 0)\n        {\n          if (argc < 2)\n            die (\"--lock-file takes an argument\");\n\n          (void) lock_file_new (argv[1]);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--sync-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--sync-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_sync_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--block-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--block-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_block_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--userns-block-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--userns-block-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_userns_block_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--info-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--info-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_info_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--json-status-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--json-status-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_json_status_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--seccomp\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--seccomp takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_seccomp_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--setenv\") == 0)\n        {\n          if (argc < 3)\n            die (\"--setenv takes two arguments\");\n\n          xsetenv (argv[1], argv[2], 1);\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--unsetenv\") == 0)\n        {\n          if (argc < 2)\n            die (\"--unsetenv takes an argument\");\n\n          xunsetenv (argv[1]);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--uid\") == 0)\n        {\n          int the_uid;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--uid takes an argument\");\n\n          the_uid = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_uid < 0)\n            die (\"Invalid uid: %s\", argv[1]);\n\n          opt_sandbox_uid = the_uid;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--gid\") == 0)\n        {\n          int the_gid;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--gid takes an argument\");\n\n          the_gid = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_gid < 0)\n            die (\"Invalid gid: %s\", argv[1]);\n\n          opt_sandbox_gid = the_gid;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--hostname\") == 0)\n        {\n          if (argc < 2)\n            die (\"--hostname takes an argument\");\n\n          op = setup_op_new (SETUP_SET_HOSTNAME);\n          op->dest = argv[1];\n          op->flags = NO_CREATE_DEST;\n\n          opt_sandbox_hostname = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--new-session\") == 0)\n        {\n          opt_new_session = TRUE;\n        }\n      else if (strcmp (arg, \"--die-with-parent\") == 0)\n        {\n          opt_die_with_parent = TRUE;\n        }\n      else if (strcmp (arg, \"--as-pid-1\") == 0)\n        {\n          opt_as_pid_1 = TRUE;\n        }\n      else if (strcmp (arg, \"--cap-add\") == 0)\n        {\n          cap_value_t cap;\n          if (argc < 2)\n            die (\"--cap-add takes an argument\");\n\n          opt_cap_add_or_drop_used = TRUE;\n\n          if (strcasecmp (argv[1], \"ALL\") == 0)\n            {\n              requested_caps[0] = requested_caps[1] = 0xFFFFFFFF;\n            }\n          else\n            {\n              if (cap_from_name (argv[1], &cap) < 0)\n                die (\"unknown cap: %s\", argv[1]);\n\n              if (cap < 32)\n                requested_caps[0] |= CAP_TO_MASK_0 (cap);\n              else\n                requested_caps[1] |= CAP_TO_MASK_1 (cap - 32);\n            }\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--cap-drop\") == 0)\n        {\n          cap_value_t cap;\n          if (argc < 2)\n            die (\"--cap-drop takes an argument\");\n\n          opt_cap_add_or_drop_used = TRUE;\n\n          if (strcasecmp (argv[1], \"ALL\") == 0)\n            {\n              requested_caps[0] = requested_caps[1] = 0;\n            }\n          else\n            {\n              if (cap_from_name (argv[1], &cap) < 0)\n                die (\"unknown cap: %s\", argv[1]);\n\n              if (cap < 32)\n                requested_caps[0] &= ~CAP_TO_MASK_0 (cap);\n              else\n                requested_caps[1] &= ~CAP_TO_MASK_1 (cap - 32);\n            }\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--\") == 0)\n        {\n          argv += 1;\n          argc -= 1;\n          break;\n        }\n      else if (*arg == '-')\n        {\n          die (\"Unknown option %s\", arg);\n        }\n      else\n        {\n          break;\n        }\n\n      argv++;\n      argc--;\n    }\n\n  *argcp = argc;\n  *argvp = argv;\n}\n\nstatic void\nparse_args (int          *argcp,\n            const char ***argvp)\n{\n  int total_parsed_argc = *argcp;\n\n  parse_args_recurse (argcp, argvp, FALSE, &total_parsed_argc);\n}\n\nstatic void\nread_overflowids (void)\n{\n  cleanup_free char *uid_data = NULL;\n  cleanup_free char *gid_data = NULL;\n\n  uid_data = load_file_at (AT_FDCWD, \"/proc/sys/kernel/overflowuid\");\n  if (uid_data == NULL)\n    die_with_error (\"Can't read /proc/sys/kernel/overflowuid\");\n\n  overflow_uid = strtol (uid_data, NULL, 10);\n  if (overflow_uid == 0)\n    die (\"Can't parse /proc/sys/kernel/overflowuid\");\n\n  gid_data = load_file_at (AT_FDCWD, \"/proc/sys/kernel/overflowgid\");\n  if (gid_data == NULL)\n    die_with_error (\"Can't read /proc/sys/kernel/overflowgid\");\n\n  overflow_gid = strtol (gid_data, NULL, 10);\n  if (overflow_gid == 0)\n    die (\"Can't parse /proc/sys/kernel/overflowgid\");\n}\n\nint\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  cleanup_free char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\"--cap-add in setuid mode can be used only by root\");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\"--userns-block-fd requires --unshare-user\");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\"--userns-block-fd requires --info-fd\");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\"Specifying --as-pid-1 requires --unshare-pid\");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\"Specifying --as-pid-1 and --lock-file is not permitted\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n     We first try in /run, and if that fails, try in /tmp. */\n  base_path = xasprintf (\"/run/user/%d/.bubblewrap\", real_uid);\n  if (ensure_dir (base_path, 0755))\n    {\n      free (base_path);\n      base_path = xasprintf (\"/tmp/.bubblewrap-%d\", real_uid);\n      if (ensure_dir (base_path, 0755))\n        die_with_error (\"Creating root mountpoint failed\");\n    }\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\"pipe2()\");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\"setting up newroot bind\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\"can't open /\");\n    if (chdir (\"/newroot\") != 0)\n      die_with_error (\"chdir /newroot\");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \"alternative\" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\".\", \".\") != 0)\n      die_with_error (\"pivot_root(/newroot)\");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\"fchdir to oldroot\");\n    if (umount2 (\".\", MNT_DETACH) < 0)\n      die_with_error (\"umount old root\");\n    if (chdir (\"/\") != 0)\n      die_with_error (\"chdir /\");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\"execvp %s\", argv[0]);\n    }\n\n  return 0;\n}\n"], "fixing_code": ["/* bubblewrap\n * Copyright (C) 2016 Alexander Larsson\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include \"config.h\"\n\n#include <poll.h>\n#include <sched.h>\n#include <pwd.h>\n#include <grp.h>\n#include <sys/mount.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <sys/eventfd.h>\n#include <sys/fsuid.h>\n#include <sys/signalfd.h>\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <linux/sched.h>\n#include <linux/seccomp.h>\n#include <linux/filter.h>\n\n#include \"utils.h\"\n#include \"network.h\"\n#include \"bind-mount.h\"\n\n#ifndef CLONE_NEWCGROUP\n#define CLONE_NEWCGROUP 0x02000000 /* New cgroup namespace */\n#endif\n\n/* Globals to avoid having to use getuid(), since the uid/gid changes during runtime */\nstatic uid_t real_uid;\nstatic gid_t real_gid;\nstatic uid_t overflow_uid;\nstatic gid_t overflow_gid;\nstatic bool is_privileged; /* See acquire_privs() */\nstatic const char *argv0;\nstatic const char *host_tty_dev;\nstatic int proc_fd = -1;\nstatic const char *opt_exec_label = NULL;\nstatic const char *opt_file_label = NULL;\nstatic bool opt_as_pid_1;\n\nconst char *opt_chdir_path = NULL;\nbool opt_unshare_user = FALSE;\nbool opt_unshare_user_try = FALSE;\nbool opt_unshare_pid = FALSE;\nbool opt_unshare_ipc = FALSE;\nbool opt_unshare_net = FALSE;\nbool opt_unshare_uts = FALSE;\nbool opt_unshare_cgroup = FALSE;\nbool opt_unshare_cgroup_try = FALSE;\nbool opt_needs_devpts = FALSE;\nbool opt_new_session = FALSE;\nbool opt_die_with_parent = FALSE;\nuid_t opt_sandbox_uid = -1;\ngid_t opt_sandbox_gid = -1;\nint opt_sync_fd = -1;\nint opt_block_fd = -1;\nint opt_userns_block_fd = -1;\nint opt_info_fd = -1;\nint opt_json_status_fd = -1;\nint opt_seccomp_fd = -1;\nconst char *opt_sandbox_hostname = NULL;\nchar *opt_args_data = NULL;  /* owned */\n\n#define CAP_TO_MASK_0(x) (1L << ((x) & 31))\n#define CAP_TO_MASK_1(x) CAP_TO_MASK_0(x - 32)\n\ntypedef enum {\n  SETUP_BIND_MOUNT,\n  SETUP_RO_BIND_MOUNT,\n  SETUP_DEV_BIND_MOUNT,\n  SETUP_MOUNT_PROC,\n  SETUP_MOUNT_DEV,\n  SETUP_MOUNT_TMPFS,\n  SETUP_MOUNT_MQUEUE,\n  SETUP_MAKE_DIR,\n  SETUP_MAKE_FILE,\n  SETUP_MAKE_BIND_FILE,\n  SETUP_MAKE_RO_BIND_FILE,\n  SETUP_MAKE_SYMLINK,\n  SETUP_REMOUNT_RO_NO_RECURSIVE,\n  SETUP_SET_HOSTNAME,\n} SetupOpType;\n\ntypedef enum {\n  NO_CREATE_DEST = (1 << 0),\n  ALLOW_NOTEXIST = (2 << 0),\n} SetupOpFlag;\n\ntypedef struct _SetupOp SetupOp;\n\nstruct _SetupOp\n{\n  SetupOpType type;\n  const char *source;\n  const char *dest;\n  int         fd;\n  SetupOpFlag flags;\n  SetupOp    *next;\n};\n\ntypedef struct _LockFile LockFile;\n\nstruct _LockFile\n{\n  const char *path;\n  int         fd;\n  LockFile   *next;\n};\n\nstatic SetupOp *ops = NULL;\nstatic SetupOp *last_op = NULL;\nstatic LockFile *lock_files = NULL;\nstatic LockFile *last_lock_file = NULL;\n\nenum {\n  PRIV_SEP_OP_DONE,\n  PRIV_SEP_OP_BIND_MOUNT,\n  PRIV_SEP_OP_PROC_MOUNT,\n  PRIV_SEP_OP_TMPFS_MOUNT,\n  PRIV_SEP_OP_DEVPTS_MOUNT,\n  PRIV_SEP_OP_MQUEUE_MOUNT,\n  PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE,\n  PRIV_SEP_OP_SET_HOSTNAME,\n};\n\ntypedef struct\n{\n  uint32_t op;\n  uint32_t flags;\n  uint32_t arg1_offset;\n  uint32_t arg2_offset;\n} PrivSepOp;\n\nstatic SetupOp *\nsetup_op_new (SetupOpType type)\n{\n  SetupOp *op = xcalloc (sizeof (SetupOp));\n\n  op->type = type;\n  op->fd = -1;\n  op->flags = 0;\n  if (last_op != NULL)\n    last_op->next = op;\n  else\n    ops = op;\n\n  last_op = op;\n  return op;\n}\n\nstatic LockFile *\nlock_file_new (const char *path)\n{\n  LockFile *lock = xcalloc (sizeof (LockFile));\n\n  lock->path = path;\n  if (last_lock_file != NULL)\n    last_lock_file->next = lock;\n  else\n    lock_files = lock;\n\n  last_lock_file = lock;\n  return lock;\n}\n\n\nstatic void\nusage (int ecode, FILE *out)\n{\n  fprintf (out, \"usage: %s [OPTIONS...] [--] COMMAND [ARGS...]\\n\\n\", argv0);\n\n  fprintf (out,\n           \"    --help                       Print this help\\n\"\n           \"    --version                    Print version\\n\"\n           \"    --args FD                    Parse NUL-separated args from FD\\n\"\n           \"    --unshare-all                Unshare every namespace we support by default\\n\"\n           \"    --share-net                  Retain the network namespace (can only combine with --unshare-all)\\n\"\n           \"    --unshare-user               Create new user namespace (may be automatically implied if not setuid)\\n\"\n           \"    --unshare-user-try           Create new user namespace if possible else continue by skipping it\\n\"\n           \"    --unshare-ipc                Create new ipc namespace\\n\"\n           \"    --unshare-pid                Create new pid namespace\\n\"\n           \"    --unshare-net                Create new network namespace\\n\"\n           \"    --unshare-uts                Create new uts namespace\\n\"\n           \"    --unshare-cgroup             Create new cgroup namespace\\n\"\n           \"    --unshare-cgroup-try         Create new cgroup namespace if possible else continue by skipping it\\n\"\n           \"    --uid UID                    Custom uid in the sandbox (requires --unshare-user)\\n\"\n           \"    --gid GID                    Custom gid in the sandbox (requires --unshare-user)\\n\"\n           \"    --hostname NAME              Custom hostname in the sandbox (requires --unshare-uts)\\n\"\n           \"    --chdir DIR                  Change directory to DIR\\n\"\n           \"    --setenv VAR VALUE           Set an environment variable\\n\"\n           \"    --unsetenv VAR               Unset an environment variable\\n\"\n           \"    --lock-file DEST             Take a lock on DEST while sandbox is running\\n\"\n           \"    --sync-fd FD                 Keep this fd open while sandbox is running\\n\"\n           \"    --bind SRC DEST              Bind mount the host path SRC on DEST\\n\"\n           \"    --bind-try SRC DEST          Equal to --bind but ignores non-existent SRC\\n\"\n           \"    --dev-bind SRC DEST          Bind mount the host path SRC on DEST, allowing device access\\n\"\n           \"    --dev-bind-try SRC DEST      Equal to --dev-bind but ignores non-existent SRC\\n\"\n           \"    --ro-bind SRC DEST           Bind mount the host path SRC readonly on DEST\\n\"\n           \"    --ro-bind-try SRC DEST       Equal to --ro-bind but ignores non-existent SRC\\n\"\n           \"    --remount-ro DEST            Remount DEST as readonly; does not recursively remount\\n\"\n           \"    --exec-label LABEL           Exec label for the sandbox\\n\"\n           \"    --file-label LABEL           File label for temporary sandbox content\\n\"\n           \"    --proc DEST                  Mount new procfs on DEST\\n\"\n           \"    --dev DEST                   Mount new dev on DEST\\n\"\n           \"    --tmpfs DEST                 Mount new tmpfs on DEST\\n\"\n           \"    --mqueue DEST                Mount new mqueue on DEST\\n\"\n           \"    --dir DEST                   Create dir at DEST\\n\"\n           \"    --file FD DEST               Copy from FD to destination DEST\\n\"\n           \"    --bind-data FD DEST          Copy from FD to file which is bind-mounted on DEST\\n\"\n           \"    --ro-bind-data FD DEST       Copy from FD to file which is readonly bind-mounted on DEST\\n\"\n           \"    --symlink SRC DEST           Create symlink at DEST with target SRC\\n\"\n           \"    --seccomp FD                 Load and use seccomp rules from FD\\n\"\n           \"    --block-fd FD                Block on FD until some data to read is available\\n\"\n           \"    --userns-block-fd FD         Block on FD until the user namespace is ready\\n\"\n           \"    --info-fd FD                 Write information about the running container to FD\\n\"\n           \"    --json-status-fd FD          Write container status to FD as multiple JSON documents\\n\"\n           \"    --new-session                Create a new terminal session\\n\"\n           \"    --die-with-parent            Kills with SIGKILL child process (COMMAND) when bwrap or bwrap's parent dies.\\n\"\n           \"    --as-pid-1                   Do not install a reaper process with PID=1\\n\"\n           \"    --cap-add CAP                Add cap CAP when running as privileged user\\n\"\n           \"    --cap-drop CAP               Drop cap CAP when running as privileged user\\n\"\n          );\n  exit (ecode);\n}\n\n/* If --die-with-parent was specified, use PDEATHSIG to ensure SIGKILL\n * is sent to the current process when our parent dies.\n */\nstatic void\nhandle_die_with_parent (void)\n{\n  if (opt_die_with_parent && prctl (PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0) != 0)\n    die_with_error (\"prctl\");\n}\n\nstatic void\nblock_sigchild (void)\n{\n  sigset_t mask;\n  int status;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_BLOCK, &mask, NULL) == -1)\n    die_with_error (\"sigprocmask\");\n\n  /* Reap any outstanding zombies that we may have inherited */\n  while (waitpid (-1, &status, WNOHANG) > 0)\n    ;\n}\n\nstatic void\nunblock_sigchild (void)\n{\n  sigset_t mask;\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  if (sigprocmask (SIG_UNBLOCK, &mask, NULL) == -1)\n    die_with_error (\"sigprocmask\");\n}\n\n/* Closes all fd:s except 0,1,2 and the passed in array of extra fds */\nstatic int\nclose_extra_fds (void *data, int fd)\n{\n  int *extra_fds = (int *) data;\n  int i;\n\n  for (i = 0; extra_fds[i] != -1; i++)\n    if (fd == extra_fds[i])\n      return 0;\n\n  if (fd <= 2)\n    return 0;\n\n  close (fd);\n  return 0;\n}\n\nstatic int\npropagate_exit_status (int status)\n{\n  if (WIFEXITED (status))\n    return WEXITSTATUS (status);\n\n  /* The process died of a signal, we can't really report that, but we\n   * can at least be bash-compatible. The bash manpage says:\n   *   The return value of a simple command is its\n   *   exit status, or 128+n if the command is\n   *   terminated by signal n.\n   */\n  if (WIFSIGNALED (status))\n    return 128 + WTERMSIG (status);\n\n  /* Weird? */\n  return 255;\n}\n\nstatic void\ndump_info (int fd, const char *output, bool exit_on_error)\n{\n  size_t len = strlen (output);\n  if (write_to_fd (fd, output, len))\n    {\n      if (exit_on_error)\n        die_with_error (\"Write to info_fd\");\n    }\n}\n\nstatic void\nreport_child_exit_status (int exitc, int setup_finished_fd)\n{\n  ssize_t s;\n  char data[2];\n  cleanup_free char *output = NULL;\n  if (opt_json_status_fd == -1 || setup_finished_fd == -1)\n    return;\n\n  s = TEMP_FAILURE_RETRY (read (setup_finished_fd, data, sizeof data));\n  if (s == -1 && errno != EAGAIN)\n    die_with_error (\"read eventfd\");\n  if (s != 1) // Is 0 if pipe closed before exec, is 2 if closed after exec.\n    return;\n\n  output = xasprintf (\"{ \\\"exit-code\\\": %i }\\n\", exitc);\n  dump_info (opt_json_status_fd, output, FALSE);\n  close (opt_json_status_fd);\n  opt_json_status_fd = -1;\n  close (setup_finished_fd);\n}\n\n/* This stays around for as long as the initial process in the app does\n * and when that exits it exits, propagating the exit status. We do this\n * by having pid 1 in the sandbox detect this exit and tell the monitor\n * the exit status via a eventfd. We also track the exit of the sandbox\n * pid 1 via a signalfd for SIGCHLD, and exit with an error in this case.\n * This is to catch e.g. problems during setup. */\nstatic int\nmonitor_child (int event_fd, pid_t child_pid, int setup_finished_fd)\n{\n  int res;\n  uint64_t val;\n  ssize_t s;\n  int signal_fd;\n  sigset_t mask;\n  struct pollfd fds[2];\n  int num_fds;\n  struct signalfd_siginfo fdsi;\n  int dont_close[] = {-1, -1, -1, -1};\n  int j = 0;\n  int exitc;\n  pid_t died_pid;\n  int died_status;\n\n  /* Close all extra fds in the monitoring process.\n     Any passed in fds have been passed on to the child anyway. */\n  if (event_fd != -1)\n    dont_close[j++] = event_fd;\n  if (opt_json_status_fd != -1)\n    dont_close[j++] = opt_json_status_fd;\n  if (setup_finished_fd != -1)\n    dont_close[j++] = setup_finished_fd;\n  assert (j < sizeof(dont_close)/sizeof(*dont_close));\n  fdwalk (proc_fd, close_extra_fds, dont_close);\n\n  sigemptyset (&mask);\n  sigaddset (&mask, SIGCHLD);\n\n  signal_fd = signalfd (-1, &mask, SFD_CLOEXEC | SFD_NONBLOCK);\n  if (signal_fd == -1)\n    die_with_error (\"Can't create signalfd\");\n\n  num_fds = 1;\n  fds[0].fd = signal_fd;\n  fds[0].events = POLLIN;\n  if (event_fd != -1)\n    {\n      fds[1].fd = event_fd;\n      fds[1].events = POLLIN;\n      num_fds++;\n    }\n\n  while (1)\n    {\n      fds[0].revents = fds[1].revents = 0;\n      res = poll (fds, num_fds, -1);\n      if (res == -1 && errno != EINTR)\n        die_with_error (\"poll\");\n\n      /* Always read from the eventfd first, if pid 2 died then pid 1 often\n       * dies too, and we could race, reporting that first and we'd lose\n       * the real exit status. */\n      if (event_fd != -1)\n        {\n          s = read (event_fd, &val, 8);\n          if (s == -1 && errno != EINTR && errno != EAGAIN)\n            die_with_error (\"read eventfd\");\n          else if (s == 8)\n            {\n              exitc = (int) val - 1;\n              report_child_exit_status (exitc, setup_finished_fd);\n              return exitc;\n            }\n        }\n\n      /* We need to read the signal_fd, or it will keep polling as read,\n       * however we ignore the details as we get them from waitpid\n       * below anyway */\n      s = read (signal_fd, &fdsi, sizeof (struct signalfd_siginfo));\n      if (s == -1 && errno != EINTR && errno != EAGAIN)\n        die_with_error (\"read signalfd\");\n\n      /* We may actually get several sigchld compressed into one\n         SIGCHLD, so we have to handle all of them. */\n      while ((died_pid = waitpid (-1, &died_status, WNOHANG)) > 0)\n        {\n          /* We may be getting sigchild from other children too. For instance if\n             someone created a child process, and then exec:ed bubblewrap. Ignore them */\n          if (died_pid == child_pid)\n            {\n              exitc = propagate_exit_status (died_status);\n              report_child_exit_status (exitc, setup_finished_fd);\n              return exitc;\n            }\n        }\n    }\n\n  die (\"Should not be reached\");\n\n  return 0;\n}\n\n/* This is pid 1 in the app sandbox. It is needed because we're using\n * pid namespaces, and someone has to reap zombies in it. We also detect\n * when the initial process (pid 2) dies and report its exit status to\n * the monitor so that it can return it to the original spawner.\n *\n * When there are no other processes in the sandbox the wait will return\n * ECHILD, and we then exit pid 1 to clean up the sandbox. */\nstatic int\ndo_init (int event_fd, pid_t initial_pid, struct sock_fprog *seccomp_prog)\n{\n  int initial_exit_status = 1;\n  LockFile *lock;\n\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      int fd = open (lock->path, O_RDONLY | O_CLOEXEC);\n      if (fd == -1)\n        die_with_error (\"Unable to open lock file %s\", lock->path);\n\n      struct flock l = {\n        .l_type = F_RDLCK,\n        .l_whence = SEEK_SET,\n        .l_start = 0,\n        .l_len = 0\n      };\n\n      if (fcntl (fd, F_SETLK, &l) < 0)\n        die_with_error (\"Unable to lock file %s\", lock->path);\n\n      /* Keep fd open to hang on to lock */\n      lock->fd = fd;\n    }\n\n  /* Optionally bind our lifecycle to that of the caller */\n  handle_die_with_parent ();\n\n  if (seccomp_prog != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  while (TRUE)\n    {\n      pid_t child;\n      int status;\n\n      child = wait (&status);\n      if (child == initial_pid && event_fd != -1)\n        {\n          uint64_t val;\n          int res UNUSED;\n\n          initial_exit_status = propagate_exit_status (status);\n\n          val = initial_exit_status + 1;\n          res = write (event_fd, &val, 8);\n          /* Ignore res, if e.g. the parent died and closed event_fd\n             we don't want to error out here */\n        }\n\n      if (child == -1 && errno != EINTR)\n        {\n          if (errno != ECHILD)\n            die_with_error (\"init wait()\");\n          break;\n        }\n    }\n\n  /* Close FDs. */\n  for (lock = lock_files; lock != NULL; lock = lock->next)\n    {\n      if (lock->fd >= 0)\n        {\n          close (lock->fd);\n          lock->fd = -1;\n        }\n    }\n\n  return initial_exit_status;\n}\n\n#define CAP_TO_MASK_0(x) (1L << ((x) & 31))\n#define CAP_TO_MASK_1(x) CAP_TO_MASK_0(x - 32)\n\n/* Set if --cap-add or --cap-drop were used */\nstatic bool opt_cap_add_or_drop_used;\n/* The capability set we'll target, used if above is true */\nstatic uint32_t requested_caps[2] = {0, 0};\n\n/* low 32bit caps needed */\n#define REQUIRED_CAPS_0 (CAP_TO_MASK_0 (CAP_SYS_ADMIN) | CAP_TO_MASK_0 (CAP_SYS_CHROOT) | CAP_TO_MASK_0 (CAP_NET_ADMIN) | CAP_TO_MASK_0 (CAP_SETUID) | CAP_TO_MASK_0 (CAP_SETGID))\n/* high 32bit caps needed */\n#define REQUIRED_CAPS_1 0\n\nstatic void\nset_required_caps (void)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  /* Drop all non-require capabilities */\n  data[0].effective = REQUIRED_CAPS_0;\n  data[0].permitted = REQUIRED_CAPS_0;\n  data[0].inheritable = 0;\n  data[1].effective = REQUIRED_CAPS_1;\n  data[1].permitted = REQUIRED_CAPS_1;\n  data[1].inheritable = 0;\n  if (capset (&hdr, data) < 0)\n    die_with_error (\"capset failed\");\n}\n\nstatic void\ndrop_all_caps (bool keep_requested_caps)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  if (keep_requested_caps)\n    {\n      /* Avoid calling capset() unless we need to; currently\n       * systemd-nspawn at least is known to install a seccomp\n       * policy denying capset() for dubious reasons.\n       * <https://github.com/projectatomic/bubblewrap/pull/122>\n       */\n      if (!opt_cap_add_or_drop_used && real_uid == 0)\n        {\n          assert (!is_privileged);\n          return;\n        }\n      data[0].effective = requested_caps[0];\n      data[0].permitted = requested_caps[0];\n      data[0].inheritable = requested_caps[0];\n      data[1].effective = requested_caps[1];\n      data[1].permitted = requested_caps[1];\n      data[1].inheritable = requested_caps[1];\n    }\n\n  if (capset (&hdr, data) < 0)\n    {\n      /* While the above logic ensures we don't call capset() for the primary\n       * process unless configured to do so, we still try to drop privileges for\n       * the init process unconditionally. Since due to the systemd seccomp\n       * filter that will fail, let's just ignore it.\n       */\n      if (errno == EPERM && real_uid == 0 && !is_privileged)\n        return;\n      else\n        die_with_error (\"capset failed\");\n    }\n}\n\nstatic bool\nhas_caps (void)\n{\n  struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n  struct __user_cap_data_struct data[2] = { { 0 } };\n\n  if (capget (&hdr, data)  < 0)\n    die_with_error (\"capget failed\");\n\n  return data[0].permitted != 0 || data[1].permitted != 0;\n}\n\n/* Most of the code here is used both to add caps to the ambient capabilities\n * and drop caps from the bounding set.  Handle both cases here and add\n * drop_cap_bounding_set/set_ambient_capabilities wrappers to facilitate its usage.\n */\nstatic void\nprctl_caps (uint32_t *caps, bool do_cap_bounding, bool do_set_ambient)\n{\n  unsigned long cap;\n\n  /* We ignore both EINVAL and EPERM, as we are actually relying\n   * on PR_SET_NO_NEW_PRIVS to ensure the right capabilities are\n   * available.  EPERM in particular can happen with old, buggy\n   * kernels.  See:\n   *  https://github.com/projectatomic/bubblewrap/pull/175#issuecomment-278051373\n   *  https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/security/commoncap.c?id=160da84dbb39443fdade7151bc63a88f8e953077\n   */\n  for (cap = 0; cap <= CAP_LAST_CAP; cap++)\n    {\n      bool keep = FALSE;\n      if (cap < 32)\n        {\n          if (CAP_TO_MASK_0 (cap) & caps[0])\n            keep = TRUE;\n        }\n      else\n        {\n          if (CAP_TO_MASK_1 (cap) & caps[1])\n            keep = TRUE;\n        }\n\n      if (keep && do_set_ambient)\n        {\n#ifdef PR_CAP_AMBIENT\n          int res = prctl (PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, cap, 0, 0);\n          if (res == -1 && !(errno == EINVAL || errno == EPERM))\n            die_with_error (\"Adding ambient capability %ld\", cap);\n#else\n          /* We ignore the EINVAL that results from not having PR_CAP_AMBIENT\n           * in the current kernel at runtime, so also ignore not having it\n           * in the current kernel headers at compile-time */\n#endif\n        }\n\n      if (!keep && do_cap_bounding)\n        {\n          int res = prctl (PR_CAPBSET_DROP, cap, 0, 0, 0);\n          if (res == -1 && !(errno == EINVAL || errno == EPERM))\n            die_with_error (\"Dropping capability %ld from bounds\", cap);\n        }\n    }\n}\n\nstatic void\ndrop_cap_bounding_set (bool drop_all)\n{\n  if (!drop_all)\n    prctl_caps (requested_caps, TRUE, FALSE);\n  else\n    {\n      uint32_t no_caps[2] = {0, 0};\n      prctl_caps (no_caps, TRUE, FALSE);\n    }\n}\n\nstatic void\nset_ambient_capabilities (void)\n{\n  if (is_privileged)\n    return;\n  prctl_caps (requested_caps, FALSE, TRUE);\n}\n\n/* This acquires the privileges that the bwrap will need it to work.\n * If bwrap is not setuid, then this does nothing, and it relies on\n * unprivileged user namespaces to be used. This case is\n * \"is_privileged = FALSE\".\n *\n * If bwrap is setuid, then we do things in phases.\n * The first part is run as euid 0, but with fsuid as the real user.\n * The second part, inside the child, is run as the real user but with\n * capabilities.\n * And finally we drop all capabilities.\n * The reason for the above dance is to avoid having the setup phase\n * being able to read files the user can't, while at the same time\n * working around various kernel issues. See below for details.\n */\nstatic void\nacquire_privs (void)\n{\n  uid_t euid, new_fsuid;\n\n  euid = geteuid ();\n\n  /* Are we setuid ? */\n  if (real_uid != euid)\n    {\n      if (euid != 0)\n        die (\"Unexpected setuid user %d, should be 0\", euid);\n\n      is_privileged = TRUE;\n      /* We want to keep running as euid=0 until at the clone()\n       * operation because doing so will make the user namespace be\n       * owned by root, which makes it not ptrace:able by the user as\n       * it otherwise would be. After that we will run fully as the\n       * user, which is necessary e.g. to be able to read from a fuse\n       * mount from the user.\n       *\n       * However, we don't want to accidentally mis-use euid=0 for\n       * escalated filesystem access before the clone(), so we set\n       * fsuid to the uid.\n       */\n      if (setfsuid (real_uid) < 0)\n        die_with_error (\"Unable to set fsuid\");\n\n      /* setfsuid can't properly report errors, check that it worked (as per manpage) */\n      new_fsuid = setfsuid (-1);\n      if (new_fsuid != real_uid)\n        die (\"Unable to set fsuid (was %d)\", (int)new_fsuid);\n\n      /* We never need capabilities after execve(), so lets drop everything from the bounding set */\n      drop_cap_bounding_set (TRUE);\n\n      /* Keep only the required capabilities for setup */\n      set_required_caps ();\n    }\n  else if (real_uid != 0 && has_caps ())\n    {\n      /* We have some capabilities in the non-setuid case, which should not happen.\n         Probably caused by the binary being setcap instead of setuid which we\n         don't support anymore */\n      die (\"Unexpected capabilities but not setuid, old file caps config?\");\n    }\n  else if (real_uid == 0)\n    {\n      /* If our uid is 0, default to inheriting all caps; the caller\n       * can drop them via --cap-drop.  This is used by at least rpm-ostree.\n       * Note this needs to happen before the argument parsing of --cap-drop.\n       */\n      struct __user_cap_header_struct hdr = { _LINUX_CAPABILITY_VERSION_3, 0 };\n      struct __user_cap_data_struct data[2] = { { 0 } };\n\n      if (capget (&hdr, data) < 0)\n        die_with_error (\"capget (for uid == 0) failed\");\n\n      requested_caps[0] = data[0].effective;\n      requested_caps[1] = data[1].effective;\n    }\n\n  /* Else, we try unprivileged user namespaces */\n}\n\n/* This is called once we're inside the namespace */\nstatic void\nswitch_to_user_with_privs (void)\n{\n  /* If we're in a new user namespace, we got back the bounding set, clear it again */\n  if (opt_unshare_user)\n    drop_cap_bounding_set (FALSE);\n\n  if (!is_privileged)\n    return;\n\n  /* Tell kernel not clear capabilities when later dropping root uid */\n  if (prctl (PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_KEEPCAPS) failed\");\n\n  if (setuid (opt_sandbox_uid) < 0)\n    die_with_error (\"unable to drop root uid\");\n\n  /* Regain effective required capabilities from permitted */\n  set_required_caps ();\n}\n\n/* Call setuid() and use capset() to adjust capabilities */\nstatic void\ndrop_privs (bool keep_requested_caps)\n{\n  assert (!keep_requested_caps || !is_privileged);\n  /* Drop root uid */\n  if (getuid () == 0 && setuid (opt_sandbox_uid) < 0)\n    die_with_error (\"unable to drop root uid\");\n\n  drop_all_caps (keep_requested_caps);\n}\n\nstatic char *\nget_newroot_path (const char *path)\n{\n  while (*path == '/')\n    path++;\n  return strconcat (\"/newroot/\", path);\n}\n\nstatic char *\nget_oldroot_path (const char *path)\n{\n  while (*path == '/')\n    path++;\n  return strconcat (\"/oldroot/\", path);\n}\n\nstatic void\nwrite_uid_gid_map (uid_t sandbox_uid,\n                   uid_t parent_uid,\n                   uid_t sandbox_gid,\n                   uid_t parent_gid,\n                   pid_t pid,\n                   bool  deny_groups,\n                   bool  map_root)\n{\n  cleanup_free char *uid_map = NULL;\n  cleanup_free char *gid_map = NULL;\n  cleanup_free char *dir = NULL;\n  cleanup_fd int dir_fd = -1;\n  uid_t old_fsuid = -1;\n\n  if (pid == -1)\n    dir = xstrdup (\"self\");\n  else\n    dir = xasprintf (\"%d\", pid);\n\n  dir_fd = openat (proc_fd, dir, O_PATH);\n  if (dir_fd < 0)\n    die_with_error (\"open /proc/%s failed\", dir);\n\n  if (map_root && parent_uid != 0 && sandbox_uid != 0)\n    uid_map = xasprintf (\"0 %d 1\\n\"\n                         \"%d %d 1\\n\", overflow_uid, sandbox_uid, parent_uid);\n  else\n    uid_map = xasprintf (\"%d %d 1\\n\", sandbox_uid, parent_uid);\n\n  if (map_root && parent_gid != 0 && sandbox_gid != 0)\n    gid_map = xasprintf (\"0 %d 1\\n\"\n                         \"%d %d 1\\n\", overflow_gid, sandbox_gid, parent_gid);\n  else\n    gid_map = xasprintf (\"%d %d 1\\n\", sandbox_gid, parent_gid);\n\n  /* We have to be root to be allowed to write to the uid map\n   * for setuid apps, so temporary set fsuid to 0 */\n  if (is_privileged)\n    old_fsuid = setfsuid (0);\n\n  if (write_file_at (dir_fd, \"uid_map\", uid_map) != 0)\n    die_with_error (\"setting up uid map\");\n\n  if (deny_groups &&\n      write_file_at (dir_fd, \"setgroups\", \"deny\\n\") != 0)\n    {\n      /* If /proc/[pid]/setgroups does not exist, assume we are\n       * running a linux kernel < 3.19, i.e. we live with the\n       * vulnerability known as CVE-2014-8989 in older kernels\n       * where setgroups does not exist.\n       */\n      if (errno != ENOENT)\n        die_with_error (\"error writing to setgroups\");\n    }\n\n  if (write_file_at (dir_fd, \"gid_map\", gid_map) != 0)\n    die_with_error (\"setting up gid map\");\n\n  if (is_privileged)\n    {\n      setfsuid (old_fsuid);\n      if (setfsuid (-1) != real_uid)\n        die (\"Unable to re-set fsuid\");\n    }\n}\n\nstatic void\nprivileged_op (int         privileged_op_socket,\n               uint32_t    op,\n               uint32_t    flags,\n               const char *arg1,\n               const char *arg2)\n{\n  if (privileged_op_socket != -1)\n    {\n      uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n      PrivSepOp *op_buffer = (PrivSepOp *) buffer;\n      size_t buffer_size = sizeof (PrivSepOp);\n      uint32_t arg1_offset = 0, arg2_offset = 0;\n\n      /* We're unprivileged, send this request to the privileged part */\n\n      if (arg1 != NULL)\n        {\n          arg1_offset = buffer_size;\n          buffer_size += strlen (arg1) + 1;\n        }\n      if (arg2 != NULL)\n        {\n          arg2_offset = buffer_size;\n          buffer_size += strlen (arg2) + 1;\n        }\n\n      if (buffer_size >= sizeof (buffer))\n        die (\"privilege separation operation to large\");\n\n      op_buffer->op = op;\n      op_buffer->flags = flags;\n      op_buffer->arg1_offset = arg1_offset;\n      op_buffer->arg2_offset = arg2_offset;\n      if (arg1 != NULL)\n        strcpy ((char *) buffer + arg1_offset, arg1);\n      if (arg2 != NULL)\n        strcpy ((char *) buffer + arg2_offset, arg2);\n\n      if (write (privileged_op_socket, buffer, buffer_size) != buffer_size)\n        die (\"Can't write to privileged_op_socket\");\n\n      if (read (privileged_op_socket, buffer, 1) != 1)\n        die (\"Can't read from privileged_op_socket\");\n\n      return;\n    }\n\n  /*\n   * This runs a privileged request for the unprivileged setup\n   * code. Note that since the setup code is unprivileged it is not as\n   * trusted, so we need to verify that all requests only affect the\n   * child namespace as set up by the privileged parts of the setup,\n   * and that all the code is very careful about handling input.\n   *\n   * This means:\n   *  * Bind mounts are safe, since we always use filesystem namespace. They\n   *     must be recursive though, as otherwise you can use a non-recursive bind\n   *     mount to access an otherwise over-mounted mountpoint.\n   *  * Mounting proc, tmpfs, mqueue, devpts in the child namespace is assumed to\n   *    be safe.\n   *  * Remounting RO (even non-recursive) is safe because it decreases privileges.\n   *  * sethostname() is safe only if we set up a UTS namespace\n   */\n  switch (op)\n    {\n    case PRIV_SEP_OP_DONE:\n      break;\n\n    case PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE:\n      if (bind_mount (proc_fd, NULL, arg2, BIND_READONLY) != 0)\n        die_with_error (\"Can't remount readonly on %s\", arg2);\n      break;\n\n    case PRIV_SEP_OP_BIND_MOUNT:\n      /* We always bind directories recursively, otherwise this would let us\n         access files that are otherwise covered on the host */\n      if (bind_mount (proc_fd, arg1, arg2, BIND_RECURSIVE | flags) != 0)\n        die_with_error (\"Can't bind mount %s on %s\", arg1, arg2);\n      break;\n\n    case PRIV_SEP_OP_PROC_MOUNT:\n      if (mount (\"proc\", arg1, \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV, NULL) != 0)\n        die_with_error (\"Can't mount proc on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_TMPFS_MOUNT:\n      {\n        cleanup_free char *opt = label_mount (\"mode=0755\", opt_file_label);\n        if (mount (\"tmpfs\", arg1, \"tmpfs\", MS_NOSUID | MS_NODEV, opt) != 0)\n          die_with_error (\"Can't mount tmpfs on %s\", arg1);\n        break;\n      }\n\n    case PRIV_SEP_OP_DEVPTS_MOUNT:\n      if (mount (\"devpts\", arg1, \"devpts\", MS_NOSUID | MS_NOEXEC,\n                 \"newinstance,ptmxmode=0666,mode=620\") != 0)\n        die_with_error (\"Can't mount devpts on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_MQUEUE_MOUNT:\n      if (mount (\"mqueue\", arg1, \"mqueue\", 0, NULL) != 0)\n        die_with_error (\"Can't mount mqueue on %s\", arg1);\n      break;\n\n    case PRIV_SEP_OP_SET_HOSTNAME:\n      /* This is checked at the start, but lets verify it here in case\n         something manages to send hacked priv-sep operation requests. */\n      if (!opt_unshare_uts)\n        die (\"Refusing to set hostname in original namespace\");\n      if (sethostname (arg1, strlen(arg1)) != 0)\n        die_with_error (\"Can't set hostname to %s\", arg1);\n      break;\n\n    default:\n      die (\"Unexpected privileged op %d\", op);\n    }\n}\n\n/* This is run unprivileged in the child namespace but can request\n * some privileged operations (also in the child namespace) via the\n * privileged_op_socket.\n */\nstatic void\nsetup_newroot (bool unshare_pid,\n               int  privileged_op_socket)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      cleanup_free char *source = NULL;\n      cleanup_free char *dest = NULL;\n      int source_mode = 0;\n      int i;\n\n      if (op->source &&\n          op->type != SETUP_MAKE_SYMLINK)\n        {\n          source = get_oldroot_path (op->source);\n          source_mode = get_file_mode (source);\n          if (source_mode < 0)\n            {\n              if (op->flags & ALLOW_NOTEXIST && errno == ENOENT)\n                continue; /* Ignore and move on */\n              die_with_error(\"Can't get type of source %s\", op->source);\n            }\n        }\n\n      if (op->dest &&\n          (op->flags & NO_CREATE_DEST) == 0)\n        {\n          dest = get_newroot_path (op->dest);\n          if (mkdir_with_parents (dest, 0755, FALSE) != 0)\n            die_with_error (\"Can't mkdir parents for %s\", op->dest);\n        }\n\n      switch (op->type)\n        {\n        case SETUP_RO_BIND_MOUNT:\n        case SETUP_DEV_BIND_MOUNT:\n        case SETUP_BIND_MOUNT:\n          if (source_mode == S_IFDIR)\n            {\n              if (ensure_dir (dest, 0755) != 0)\n                die_with_error (\"Can't mkdir %s\", op->dest);\n            }\n          else if (ensure_file (dest, 0666) != 0)\n            die_with_error (\"Can't create file at %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_BIND_MOUNT,\n                         (op->type == SETUP_RO_BIND_MOUNT ? BIND_READONLY : 0) |\n                         (op->type == SETUP_DEV_BIND_MOUNT ? BIND_DEVICES : 0),\n                         source, dest);\n          break;\n\n        case SETUP_REMOUNT_RO_NO_RECURSIVE:\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_REMOUNT_RO_NO_RECURSIVE, 0, NULL, dest);\n          break;\n\n        case SETUP_MOUNT_PROC:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          if (unshare_pid)\n            {\n              /* Our own procfs */\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_PROC_MOUNT, 0,\n                             dest, NULL);\n            }\n          else\n            {\n              /* Use system procfs, as we share pid namespace anyway */\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, 0,\n                             \"oldroot/proc\", dest);\n            }\n\n          /* There are a bunch of weird old subdirs of /proc that could potentially be\n             problematic (for instance /proc/sysrq-trigger lets you shut down the machine\n             if you have write access). We should not have access to these as a non-privileged\n             user, but lets cover them anyway just to make sure */\n          const char *cover_proc_dirs[] = { \"sys\", \"sysrq-trigger\", \"irq\", \"bus\" };\n          for (i = 0; i < N_ELEMENTS (cover_proc_dirs); i++)\n            {\n              cleanup_free char *subdir = strconcat3 (dest, \"/\", cover_proc_dirs[i]);\n              if (access (subdir, W_OK) < 0)\n                {\n                  /* The file is already read-only or doesn't exist.  */\n                  if (errno == EACCES || errno == ENOENT)\n                    continue;\n\n                  die_with_error (\"Can't access %s\", subdir);\n                }\n\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_READONLY,\n                             subdir, subdir);\n            }\n\n          break;\n\n        case SETUP_MOUNT_DEV:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_TMPFS_MOUNT, 0,\n                         dest, NULL);\n\n          static const char *const devnodes[] = { \"null\", \"zero\", \"full\", \"random\", \"urandom\", \"tty\" };\n          for (i = 0; i < N_ELEMENTS (devnodes); i++)\n            {\n              cleanup_free char *node_dest = strconcat3 (dest, \"/\", devnodes[i]);\n              cleanup_free char *node_src = strconcat (\"/oldroot/dev/\", devnodes[i]);\n              if (create_file (node_dest, 0666, NULL) != 0)\n                die_with_error (\"Can't create file %s/%s\", op->dest, devnodes[i]);\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_DEVICES,\n                             node_src, node_dest);\n            }\n\n          static const char *const stdionodes[] = { \"stdin\", \"stdout\", \"stderr\" };\n          for (i = 0; i < N_ELEMENTS (stdionodes); i++)\n            {\n              cleanup_free char *target = xasprintf (\"/proc/self/fd/%d\", i);\n              cleanup_free char *node_dest = strconcat3 (dest, \"/\", stdionodes[i]);\n              if (symlink (target, node_dest) < 0)\n                die_with_error (\"Can't create symlink %s/%s\", op->dest, stdionodes[i]);\n            }\n\n          /* /dev/fd and /dev/core - legacy, but both nspawn and docker do these */\n          { cleanup_free char *dev_fd = strconcat (dest, \"/fd\");\n            if (symlink (\"/proc/self/fd\", dev_fd) < 0)\n              die_with_error (\"Can't create symlink %s\", dev_fd);\n          }\n          { cleanup_free char *dev_core = strconcat (dest, \"/core\");\n            if (symlink (\"/proc/kcore\", dev_core) < 0)\n              die_with_error (\"Can't create symlink %s\", dev_core);\n          }\n\n          {\n            cleanup_free char *pts = strconcat (dest, \"/pts\");\n            cleanup_free char *ptmx = strconcat (dest, \"/ptmx\");\n            cleanup_free char *shm = strconcat (dest, \"/shm\");\n\n            if (mkdir (shm, 0755) == -1)\n              die_with_error (\"Can't create %s/shm\", op->dest);\n\n            if (mkdir (pts, 0755) == -1)\n              die_with_error (\"Can't create %s/devpts\", op->dest);\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_DEVPTS_MOUNT, 0, pts, NULL);\n\n            if (symlink (\"pts/ptmx\", ptmx) != 0)\n              die_with_error (\"Can't make symlink at %s/ptmx\", op->dest);\n          }\n\n          /* If stdout is a tty, that means the sandbox can write to the\n             outside-sandbox tty. In that case we also create a /dev/console\n             that points to this tty device. This should not cause any more\n             access than we already have, and it makes ttyname() work in the\n             sandbox. */\n          if (host_tty_dev != NULL && *host_tty_dev != 0)\n            {\n              cleanup_free char *src_tty_dev = strconcat (\"/oldroot\", host_tty_dev);\n              cleanup_free char *dest_console = strconcat (dest, \"/console\");\n\n              if (create_file (dest_console, 0666, NULL) != 0)\n                die_with_error (\"creating %s/console\", op->dest);\n\n              privileged_op (privileged_op_socket,\n                             PRIV_SEP_OP_BIND_MOUNT, BIND_DEVICES,\n                             src_tty_dev, dest_console);\n            }\n\n          break;\n\n        case SETUP_MOUNT_TMPFS:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_TMPFS_MOUNT, 0,\n                         dest, NULL);\n          break;\n\n        case SETUP_MOUNT_MQUEUE:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_MQUEUE_MOUNT, 0,\n                         dest, NULL);\n          break;\n\n        case SETUP_MAKE_DIR:\n          if (ensure_dir (dest, 0755) != 0)\n            die_with_error (\"Can't mkdir %s\", op->dest);\n\n          break;\n\n        case SETUP_MAKE_FILE:\n          {\n            cleanup_fd int dest_fd = -1;\n\n            dest_fd = creat (dest, 0666);\n            if (dest_fd == -1)\n              die_with_error (\"Can't create file %s\", op->dest);\n\n            if (copy_file_data (op->fd, dest_fd) != 0)\n              die_with_error (\"Can't write data to file %s\", op->dest);\n\n            close (op->fd);\n            op->fd = -1;\n          }\n          break;\n\n        case SETUP_MAKE_BIND_FILE:\n        case SETUP_MAKE_RO_BIND_FILE:\n          {\n            cleanup_fd int dest_fd = -1;\n            char tempfile[] = \"/bindfileXXXXXX\";\n\n            dest_fd = mkstemp (tempfile);\n            if (dest_fd == -1)\n              die_with_error (\"Can't create tmpfile for %s\", op->dest);\n\n            if (copy_file_data (op->fd, dest_fd) != 0)\n              die_with_error (\"Can't write data to file %s\", op->dest);\n\n            close (op->fd);\n            op->fd = -1;\n\n            assert (dest != NULL);\n\n            if (ensure_file (dest, 0666) != 0)\n              die_with_error (\"Can't create file at %s\", op->dest);\n\n            privileged_op (privileged_op_socket,\n                           PRIV_SEP_OP_BIND_MOUNT,\n                           (op->type == SETUP_MAKE_RO_BIND_FILE ? BIND_READONLY : 0),\n                           tempfile, dest);\n\n            /* Remove the file so we're sure the app can't get to it in any other way.\n               Its outside the container chroot, so it shouldn't be possible, but lets\n               make it really sure. */\n            unlink (tempfile);\n          }\n          break;\n\n        case SETUP_MAKE_SYMLINK:\n          assert (op->source != NULL);  /* guaranteed by the constructor */\n          if (symlink (op->source, dest) != 0)\n            die_with_error (\"Can't make symlink at %s\", op->dest);\n          break;\n\n        case SETUP_SET_HOSTNAME:\n          assert (op->dest != NULL);  /* guaranteed by the constructor */\n          privileged_op (privileged_op_socket,\n                         PRIV_SEP_OP_SET_HOSTNAME, 0,\n                         op->dest, NULL);\n          break;\n\n        default:\n          die (\"Unexpected type %d\", op->type);\n        }\n    }\n  privileged_op (privileged_op_socket,\n                 PRIV_SEP_OP_DONE, 0, NULL, NULL);\n}\n\n/* Do not leak file descriptors already used by setup_newroot () */\nstatic void\nclose_ops_fd (void)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      if (op->fd != -1)\n        {\n          (void) close (op->fd);\n          op->fd = -1;\n        }\n    }\n}\n\n/* We need to resolve relative symlinks in the sandbox before we\n   chroot so that absolute symlinks are handled correctly. We also\n   need to do this after we've switched to the real uid so that\n   e.g. paths on fuse mounts work */\nstatic void\nresolve_symlinks_in_ops (void)\n{\n  SetupOp *op;\n\n  for (op = ops; op != NULL; op = op->next)\n    {\n      const char *old_source;\n\n      switch (op->type)\n        {\n        case SETUP_RO_BIND_MOUNT:\n        case SETUP_DEV_BIND_MOUNT:\n        case SETUP_BIND_MOUNT:\n          old_source = op->source;\n          op->source = realpath (old_source, NULL);\n          if (op->source == NULL)\n            {\n              if (op->flags & ALLOW_NOTEXIST && errno == ENOENT)\n                op->source = old_source;\n              else\n                die_with_error(\"Can't find source path %s\", old_source);\n            }\n          break;\n        default:\n          break;\n        }\n    }\n}\n\n\nstatic const char *\nresolve_string_offset (void    *buffer,\n                       size_t   buffer_size,\n                       uint32_t offset)\n{\n  if (offset == 0)\n    return NULL;\n\n  if (offset > buffer_size)\n    die (\"Invalid string offset %d (buffer size %zd)\", offset, buffer_size);\n\n  return (const char *) buffer + offset;\n}\n\nstatic uint32_t\nread_priv_sec_op (int          read_socket,\n                  void        *buffer,\n                  size_t       buffer_size,\n                  uint32_t    *flags,\n                  const char **arg1,\n                  const char **arg2)\n{\n  const PrivSepOp *op = (const PrivSepOp *) buffer;\n  ssize_t rec_len;\n\n  do\n    rec_len = read (read_socket, buffer, buffer_size - 1);\n  while (rec_len == -1 && errno == EINTR);\n\n  if (rec_len < 0)\n    die_with_error (\"Can't read from unprivileged helper\");\n\n  if (rec_len == 0)\n    exit (1); /* Privileged helper died and printed error, so exit silently */\n\n  if (rec_len < sizeof (PrivSepOp))\n    die (\"Invalid size %zd from unprivileged helper\", rec_len);\n\n  /* Guarantee zero termination of any strings */\n  ((char *) buffer)[rec_len] = 0;\n\n  *flags = op->flags;\n  *arg1 = resolve_string_offset (buffer, rec_len, op->arg1_offset);\n  *arg2 = resolve_string_offset (buffer, rec_len, op->arg2_offset);\n\n  return op->op;\n}\n\nstatic void __attribute__ ((noreturn))\nprint_version_and_exit (void)\n{\n  printf (\"%s\\n\", PACKAGE_STRING);\n  exit (0);\n}\n\nstatic void\nparse_args_recurse (int          *argcp,\n                    const char ***argvp,\n                    bool          in_file,\n                    int          *total_parsed_argc_p)\n{\n  SetupOp *op;\n  int argc = *argcp;\n  const char **argv = *argvp;\n  /* I can't imagine a case where someone wants more than this.\n   * If you do...you should be able to pass multiple files\n   * via a single tmpfs and linking them there, etc.\n   *\n   * We're adding this hardening due to precedent from\n   * http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html\n   *\n   * I picked 9000 because the Internet told me to and it was hard to\n   * resist.\n   */\n  static const uint32_t MAX_ARGS = 9000;\n\n  if (*total_parsed_argc_p > MAX_ARGS)\n    die (\"Exceeded maximum number of arguments %u\", MAX_ARGS);\n\n  while (argc > 0)\n    {\n      const char *arg = argv[0];\n\n      if (strcmp (arg, \"--help\") == 0)\n        {\n          usage (EXIT_SUCCESS, stdout);\n        }\n      else if (strcmp (arg, \"--version\") == 0)\n        {\n          print_version_and_exit ();\n        }\n      else if (strcmp (arg, \"--args\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n          const char *p, *data_end;\n          size_t data_len;\n          cleanup_free const char **data_argv = NULL;\n          const char **data_argv_copy;\n          int data_argc;\n          int i;\n\n          if (in_file)\n            die (\"--args not supported in arguments file\");\n\n          if (argc < 2)\n            die (\"--args takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          /* opt_args_data is essentially a recursive argv array, which we must\n           * keep allocated until exit time, since its argv entries get used\n           * by the other cases in parse_args_recurse() when we recurse. */\n          opt_args_data = load_file_data (the_fd, &data_len);\n          if (opt_args_data == NULL)\n            die_with_error (\"Can't read --args data\");\n          (void) close (the_fd);\n\n          data_end = opt_args_data + data_len;\n          data_argc = 0;\n\n          p = opt_args_data;\n          while (p != NULL && p < data_end)\n            {\n              data_argc++;\n              (*total_parsed_argc_p)++;\n              if (*total_parsed_argc_p > MAX_ARGS)\n                die (\"Exceeded maximum number of arguments %u\", MAX_ARGS);\n              p = memchr (p, 0, data_end - p);\n              if (p != NULL)\n                p++;\n            }\n\n          data_argv = xcalloc (sizeof (char *) * (data_argc + 1));\n\n          i = 0;\n          p = opt_args_data;\n          while (p != NULL && p < data_end)\n            {\n              /* Note: load_file_data always adds a nul terminator, so this is safe\n               * even for the last string. */\n              data_argv[i++] = p;\n              p = memchr (p, 0, data_end - p);\n              if (p != NULL)\n                p++;\n            }\n\n          data_argv_copy = data_argv; /* Don't change data_argv, we need to free it */\n          parse_args_recurse (&data_argc, &data_argv_copy, TRUE, total_parsed_argc_p);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--unshare-all\") == 0)\n        {\n          /* Keep this in order with the older (legacy) --unshare arguments,\n           * we use the --try variants of user and cgroup, since we want\n           * to support systems/kernels without support for those.\n           */\n          opt_unshare_user_try = opt_unshare_ipc = opt_unshare_pid =\n            opt_unshare_uts = opt_unshare_cgroup_try =\n            opt_unshare_net = TRUE;\n        }\n      /* Begin here the older individual --unshare variants */\n      else if (strcmp (arg, \"--unshare-user\") == 0)\n        {\n          opt_unshare_user = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-user-try\") == 0)\n        {\n          opt_unshare_user_try = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-ipc\") == 0)\n        {\n          opt_unshare_ipc = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-pid\") == 0)\n        {\n          opt_unshare_pid = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-net\") == 0)\n        {\n          opt_unshare_net = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-uts\") == 0)\n        {\n          opt_unshare_uts = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-cgroup\") == 0)\n        {\n          opt_unshare_cgroup = TRUE;\n        }\n      else if (strcmp (arg, \"--unshare-cgroup-try\") == 0)\n        {\n          opt_unshare_cgroup_try = TRUE;\n        }\n      /* Begin here the newer --share variants */\n      else if (strcmp (arg, \"--share-net\") == 0)\n        {\n          opt_unshare_net = FALSE;\n        }\n      /* End --share variants, other arguments begin */\n      else if (strcmp (arg, \"--chdir\") == 0)\n        {\n          if (argc < 2)\n            die (\"--chdir takes one argument\");\n\n          opt_chdir_path = argv[1];\n          argv++;\n          argc--;\n        }\n      else if (strcmp (arg, \"--remount-ro\") == 0)\n        {\n          if (argc < 2)\n            die (\"--remount-ro takes one argument\");\n\n          SetupOp *op = setup_op_new (SETUP_REMOUNT_RO_NO_RECURSIVE);\n          op->dest = argv[1];\n\n          argv++;\n          argc--;\n        }\n      else if (strcmp(arg, \"--bind\") == 0 ||\n               strcmp(arg, \"--bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp(arg, \"--ro-bind\") == 0 ||\n               strcmp(arg, \"--ro-bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_RO_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--ro-bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--dev-bind\") == 0 ||\n               strcmp (arg, \"--dev-bind-try\") == 0)\n        {\n          if (argc < 3)\n            die (\"%s takes two arguments\", arg);\n\n          op = setup_op_new (SETUP_DEV_BIND_MOUNT);\n          op->source = argv[1];\n          op->dest = argv[2];\n          if (strcmp(arg, \"--dev-bind-try\") == 0)\n            op->flags = ALLOW_NOTEXIST;\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--proc\") == 0)\n        {\n          if (argc < 2)\n            die (\"--proc takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_PROC);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--exec-label\") == 0)\n        {\n          if (argc < 2)\n            die (\"--exec-label takes an argument\");\n          opt_exec_label = argv[1];\n          die_unless_label_valid (opt_exec_label);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--file-label\") == 0)\n        {\n          if (argc < 2)\n            die (\"--file-label takes an argument\");\n          opt_file_label = argv[1];\n          die_unless_label_valid (opt_file_label);\n          if (label_create_file (opt_file_label))\n            die_with_error (\"--file-label setup failed\");\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--dev\") == 0)\n        {\n          if (argc < 2)\n            die (\"--dev takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_DEV);\n          op->dest = argv[1];\n          opt_needs_devpts = TRUE;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--tmpfs\") == 0)\n        {\n          if (argc < 2)\n            die (\"--tmpfs takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_TMPFS);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--mqueue\") == 0)\n        {\n          if (argc < 2)\n            die (\"--mqueue takes an argument\");\n\n          op = setup_op_new (SETUP_MOUNT_MQUEUE);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--dir\") == 0)\n        {\n          if (argc < 2)\n            die (\"--dir takes an argument\");\n\n          op = setup_op_new (SETUP_MAKE_DIR);\n          op->dest = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--file\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--file takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--bind-data\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--bind-data takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_BIND_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--ro-bind-data\") == 0)\n        {\n          int file_fd;\n          char *endptr;\n\n          if (argc < 3)\n            die (\"--ro-bind-data takes two arguments\");\n\n          file_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || file_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          op = setup_op_new (SETUP_MAKE_RO_BIND_FILE);\n          op->fd = file_fd;\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--symlink\") == 0)\n        {\n          if (argc < 3)\n            die (\"--symlink takes two arguments\");\n\n          op = setup_op_new (SETUP_MAKE_SYMLINK);\n          op->source = argv[1];\n          op->dest = argv[2];\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--lock-file\") == 0)\n        {\n          if (argc < 2)\n            die (\"--lock-file takes an argument\");\n\n          (void) lock_file_new (argv[1]);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--sync-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--sync-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_sync_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--block-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--block-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_block_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--userns-block-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--userns-block-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_userns_block_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--info-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--info-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_info_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--json-status-fd\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--json-status-fd takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_json_status_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--seccomp\") == 0)\n        {\n          int the_fd;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--seccomp takes an argument\");\n\n          the_fd = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_fd < 0)\n            die (\"Invalid fd: %s\", argv[1]);\n\n          opt_seccomp_fd = the_fd;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--setenv\") == 0)\n        {\n          if (argc < 3)\n            die (\"--setenv takes two arguments\");\n\n          xsetenv (argv[1], argv[2], 1);\n\n          argv += 2;\n          argc -= 2;\n        }\n      else if (strcmp (arg, \"--unsetenv\") == 0)\n        {\n          if (argc < 2)\n            die (\"--unsetenv takes an argument\");\n\n          xunsetenv (argv[1]);\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--uid\") == 0)\n        {\n          int the_uid;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--uid takes an argument\");\n\n          the_uid = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_uid < 0)\n            die (\"Invalid uid: %s\", argv[1]);\n\n          opt_sandbox_uid = the_uid;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--gid\") == 0)\n        {\n          int the_gid;\n          char *endptr;\n\n          if (argc < 2)\n            die (\"--gid takes an argument\");\n\n          the_gid = strtol (argv[1], &endptr, 10);\n          if (argv[1][0] == 0 || endptr[0] != 0 || the_gid < 0)\n            die (\"Invalid gid: %s\", argv[1]);\n\n          opt_sandbox_gid = the_gid;\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--hostname\") == 0)\n        {\n          if (argc < 2)\n            die (\"--hostname takes an argument\");\n\n          op = setup_op_new (SETUP_SET_HOSTNAME);\n          op->dest = argv[1];\n          op->flags = NO_CREATE_DEST;\n\n          opt_sandbox_hostname = argv[1];\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--new-session\") == 0)\n        {\n          opt_new_session = TRUE;\n        }\n      else if (strcmp (arg, \"--die-with-parent\") == 0)\n        {\n          opt_die_with_parent = TRUE;\n        }\n      else if (strcmp (arg, \"--as-pid-1\") == 0)\n        {\n          opt_as_pid_1 = TRUE;\n        }\n      else if (strcmp (arg, \"--cap-add\") == 0)\n        {\n          cap_value_t cap;\n          if (argc < 2)\n            die (\"--cap-add takes an argument\");\n\n          opt_cap_add_or_drop_used = TRUE;\n\n          if (strcasecmp (argv[1], \"ALL\") == 0)\n            {\n              requested_caps[0] = requested_caps[1] = 0xFFFFFFFF;\n            }\n          else\n            {\n              if (cap_from_name (argv[1], &cap) < 0)\n                die (\"unknown cap: %s\", argv[1]);\n\n              if (cap < 32)\n                requested_caps[0] |= CAP_TO_MASK_0 (cap);\n              else\n                requested_caps[1] |= CAP_TO_MASK_1 (cap - 32);\n            }\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--cap-drop\") == 0)\n        {\n          cap_value_t cap;\n          if (argc < 2)\n            die (\"--cap-drop takes an argument\");\n\n          opt_cap_add_or_drop_used = TRUE;\n\n          if (strcasecmp (argv[1], \"ALL\") == 0)\n            {\n              requested_caps[0] = requested_caps[1] = 0;\n            }\n          else\n            {\n              if (cap_from_name (argv[1], &cap) < 0)\n                die (\"unknown cap: %s\", argv[1]);\n\n              if (cap < 32)\n                requested_caps[0] &= ~CAP_TO_MASK_0 (cap);\n              else\n                requested_caps[1] &= ~CAP_TO_MASK_1 (cap - 32);\n            }\n\n          argv += 1;\n          argc -= 1;\n        }\n      else if (strcmp (arg, \"--\") == 0)\n        {\n          argv += 1;\n          argc -= 1;\n          break;\n        }\n      else if (*arg == '-')\n        {\n          die (\"Unknown option %s\", arg);\n        }\n      else\n        {\n          break;\n        }\n\n      argv++;\n      argc--;\n    }\n\n  *argcp = argc;\n  *argvp = argv;\n}\n\nstatic void\nparse_args (int          *argcp,\n            const char ***argvp)\n{\n  int total_parsed_argc = *argcp;\n\n  parse_args_recurse (argcp, argvp, FALSE, &total_parsed_argc);\n}\n\nstatic void\nread_overflowids (void)\n{\n  cleanup_free char *uid_data = NULL;\n  cleanup_free char *gid_data = NULL;\n\n  uid_data = load_file_at (AT_FDCWD, \"/proc/sys/kernel/overflowuid\");\n  if (uid_data == NULL)\n    die_with_error (\"Can't read /proc/sys/kernel/overflowuid\");\n\n  overflow_uid = strtol (uid_data, NULL, 10);\n  if (overflow_uid == 0)\n    die (\"Can't parse /proc/sys/kernel/overflowuid\");\n\n  gid_data = load_file_at (AT_FDCWD, \"/proc/sys/kernel/overflowgid\");\n  if (gid_data == NULL)\n    die_with_error (\"Can't read /proc/sys/kernel/overflowgid\");\n\n  overflow_gid = strtol (gid_data, NULL, 10);\n  if (overflow_gid == 0)\n    die (\"Can't parse /proc/sys/kernel/overflowgid\");\n}\n\nint\nmain (int    argc,\n      char **argv)\n{\n  mode_t old_umask;\n  const char *base_path = NULL;\n  int clone_flags;\n  char *old_cwd = NULL;\n  pid_t pid;\n  int event_fd = -1;\n  int child_wait_fd = -1;\n  int setup_finished_pipe[] = {-1, -1};\n  const char *new_cwd;\n  uid_t ns_uid;\n  gid_t ns_gid;\n  struct stat sbuf;\n  uint64_t val;\n  int res UNUSED;\n  cleanup_free char *seccomp_data = NULL;\n  size_t seccomp_len;\n  struct sock_fprog seccomp_prog;\n  cleanup_free char *args_data = NULL;\n\n  /* Handle --version early on before we try to acquire/drop\n   * any capabilities so it works in a build environment;\n   * right now flatpak's build runs bubblewrap --version.\n   * https://github.com/projectatomic/bubblewrap/issues/185\n   */\n  if (argc == 2 && (strcmp (argv[1], \"--version\") == 0))\n    print_version_and_exit ();\n\n  real_uid = getuid ();\n  real_gid = getgid ();\n\n  /* Get the (optional) privileges we need */\n  acquire_privs ();\n\n  /* Never gain any more privs during exec */\n  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)\n    die_with_error (\"prctl(PR_SET_NO_NEW_CAPS) failed\");\n\n  /* The initial code is run with high permissions\n     (i.e. CAP_SYS_ADMIN), so take lots of care. */\n\n  read_overflowids ();\n\n  argv0 = argv[0];\n\n  if (isatty (1))\n    host_tty_dev = ttyname (1);\n\n  argv++;\n  argc--;\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  parse_args (&argc, (const char ***) &argv);\n\n  /* suck the args into a cleanup_free variable to control their lifecycle */\n  args_data = opt_args_data;\n  opt_args_data = NULL;\n\n  if ((requested_caps[0] || requested_caps[1]) && is_privileged)\n    die (\"--cap-add in setuid mode can be used only by root\");\n\n  if (opt_userns_block_fd != -1 && !opt_unshare_user)\n    die (\"--userns-block-fd requires --unshare-user\");\n\n  if (opt_userns_block_fd != -1 && opt_info_fd == -1)\n    die (\"--userns-block-fd requires --info-fd\");\n\n  /* We have to do this if we weren't installed setuid (and we're not\n   * root), so let's just DWIM */\n  if (!is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n\n#ifdef ENABLE_REQUIRE_USERNS\n  /* In this build option, we require userns. */\n  if (is_privileged && getuid () != 0)\n    opt_unshare_user = TRUE;\n#endif\n\n  if (opt_unshare_user_try &&\n      stat (\"/proc/self/ns/user\", &sbuf) == 0)\n    {\n      bool disabled = FALSE;\n\n      /* RHEL7 has a kernel module parameter that lets you enable user namespaces */\n      if (stat (\"/sys/module/user_namespace/parameters/enable\", &sbuf) == 0)\n        {\n          cleanup_free char *enable = NULL;\n          enable = load_file_at (AT_FDCWD, \"/sys/module/user_namespace/parameters/enable\");\n          if (enable != NULL && enable[0] == 'N')\n            disabled = TRUE;\n        }\n\n      /* Check for max_user_namespaces */\n      if (stat (\"/proc/sys/user/max_user_namespaces\", &sbuf) == 0)\n        {\n          cleanup_free char *max_user_ns = NULL;\n          max_user_ns = load_file_at (AT_FDCWD, \"/proc/sys/user/max_user_namespaces\");\n          if (max_user_ns != NULL && strcmp(max_user_ns, \"0\\n\") == 0)\n            disabled = TRUE;\n        }\n\n      /* Debian lets you disable *unprivileged* user namespaces. However this is not\n         a problem if we're privileged, and if we're not opt_unshare_user is TRUE\n         already, and there is not much we can do, its just a non-working setup. */\n\n      if (!disabled)\n        opt_unshare_user = TRUE;\n    }\n\n  if (argc == 0)\n    usage (EXIT_FAILURE, stderr);\n\n  __debug__ ((\"Creating root mount point\\n\"));\n\n  if (opt_sandbox_uid == -1)\n    opt_sandbox_uid = real_uid;\n  if (opt_sandbox_gid == -1)\n    opt_sandbox_gid = real_gid;\n\n  if (!opt_unshare_user && opt_sandbox_uid != real_uid)\n    die (\"Specifying --uid requires --unshare-user\");\n\n  if (!opt_unshare_user && opt_sandbox_gid != real_gid)\n    die (\"Specifying --gid requires --unshare-user\");\n\n  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)\n    die (\"Specifying --hostname requires --unshare-uts\");\n\n  if (opt_as_pid_1 && !opt_unshare_pid)\n    die (\"Specifying --as-pid-1 requires --unshare-pid\");\n\n  if (opt_as_pid_1 && lock_files != NULL)\n    die (\"Specifying --as-pid-1 and --lock-file is not permitted\");\n\n  /* We need to read stuff from proc during the pivot_root dance, etc.\n     Lets keep a fd to it open */\n  proc_fd = open (\"/proc\", O_PATH);\n  if (proc_fd == -1)\n    die_with_error (\"Can't open /proc\");\n\n  /* We need *some* mountpoint where we can mount the root tmpfs.\n   * Because we use pivot_root, it won't appear to be mounted from\n   * the perspective of the sandboxed process, so we can use anywhere\n   * that is sure to exist, that is sure to not be a symlink controlled\n   * by someone malicious, and that we won't immediately need to\n   * access ourselves. */\n  base_path = \"/tmp\";\n\n  __debug__ ((\"creating new namespace\\n\"));\n\n  if (opt_unshare_pid && !opt_as_pid_1)\n    {\n      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);\n      if (event_fd == -1)\n        die_with_error (\"eventfd()\");\n    }\n\n  /* We block sigchild here so that we can use signalfd in the monitor. */\n  block_sigchild ();\n\n  clone_flags = SIGCHLD | CLONE_NEWNS;\n  if (opt_unshare_user)\n    clone_flags |= CLONE_NEWUSER;\n  if (opt_unshare_pid)\n    clone_flags |= CLONE_NEWPID;\n  if (opt_unshare_net)\n    clone_flags |= CLONE_NEWNET;\n  if (opt_unshare_ipc)\n    clone_flags |= CLONE_NEWIPC;\n  if (opt_unshare_uts)\n    clone_flags |= CLONE_NEWUTS;\n  if (opt_unshare_cgroup)\n    {\n      if (stat (\"/proc/self/ns/cgroup\", &sbuf))\n        {\n          if (errno == ENOENT)\n            die (\"Cannot create new cgroup namespace because the kernel does not support it\");\n          else\n            die_with_error (\"stat on /proc/self/ns/cgroup failed\");\n        }\n      clone_flags |= CLONE_NEWCGROUP;\n    }\n  if (opt_unshare_cgroup_try)\n    if (!stat (\"/proc/self/ns/cgroup\", &sbuf))\n      clone_flags |= CLONE_NEWCGROUP;\n\n  child_wait_fd = eventfd (0, EFD_CLOEXEC);\n  if (child_wait_fd == -1)\n    die_with_error (\"eventfd()\");\n\n  /* Track whether pre-exec setup finished if we're reporting process exit */\n  if (opt_json_status_fd != -1)\n    {\n      int ret;\n      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);\n      if (ret == -1)\n        die_with_error (\"pipe2()\");\n    }\n\n  pid = raw_clone (clone_flags, NULL);\n  if (pid == -1)\n    {\n      if (opt_unshare_user)\n        {\n          if (errno == EINVAL)\n            die (\"Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.\");\n          else if (errno == EPERM && !is_privileged)\n            die (\"No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.\");\n        }\n\n      die_with_error (\"Creating new namespace failed\");\n    }\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n\n  if (pid != 0)\n    {\n      /* Parent, outside sandbox, privileged (initially) */\n\n      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n        {\n          /* We're running as euid 0, but the uid we want to map is\n           * not 0. This means we're not allowed to write this from\n           * the child user namespace, so we do it from the parent.\n           *\n           * Also, we map uid/gid 0 in the namespace (to overflowuid)\n           * if opt_needs_devpts is true, because otherwise the mount\n           * of devpts fails due to root not being mapped.\n           */\n          write_uid_gid_map (ns_uid, real_uid,\n                             ns_gid, real_gid,\n                             pid, TRUE, opt_needs_devpts);\n        }\n\n      /* Initial launched process, wait for exec:ed command to exit */\n\n      /* We don't need any privileges in the launcher, drop them immediately. */\n      drop_privs (FALSE);\n\n      /* Optionally bind our lifecycle to that of the parent */\n      handle_die_with_parent ();\n\n      if (opt_info_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{\\n    \\\"child-pid\\\": %i\\n}\\n\", pid);\n          dump_info (opt_info_fd, output, TRUE);\n          close (opt_info_fd);\n        }\n      if (opt_json_status_fd != -1)\n        {\n          cleanup_free char *output = xasprintf (\"{ \\\"child-pid\\\": %i }\\n\", pid);\n          dump_info (opt_json_status_fd, output, TRUE);\n        }\n\n      if (opt_userns_block_fd != -1)\n        {\n          char b[1];\n          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));\n          close (opt_userns_block_fd);\n        }\n\n      /* Let child run now that the uid maps are set up */\n      val = 1;\n      res = write (child_wait_fd, &val, 8);\n      /* Ignore res, if e.g. the child died and closed child_wait_fd we don't want to error out here */\n      close (child_wait_fd);\n\n      return monitor_child (event_fd, pid, setup_finished_pipe[0]);\n    }\n\n  /* Child, in sandbox, privileged in the parent or in the user namespace (if --unshare-user).\n   *\n   * Note that for user namespaces we run as euid 0 during clone(), so\n   * the child user namespace is owned by euid 0., This means that the\n   * regular user namespace parent (with uid != 0) doesn't have any\n   * capabilities in it, which is nice as we can't exploit those. In\n   * particular the parent user namespace doesn't have CAP_PTRACE\n   * which would otherwise allow the parent to hijack of the child\n   * after this point.\n   *\n   * Unfortunately this also means you can't ptrace the final\n   * sandboxed process from outside the sandbox either.\n   */\n\n  if (opt_info_fd != -1)\n    close (opt_info_fd);\n\n  if (opt_json_status_fd != -1)\n    close (opt_json_status_fd);\n\n  /* Wait for the parent to init uid/gid maps and drop caps */\n  res = read (child_wait_fd, &val, 8);\n  close (child_wait_fd);\n\n  /* At this point we can completely drop root uid, but retain the\n   * required permitted caps. This allow us to do full setup as\n   * the user uid, which makes e.g. fuse access work.\n   */\n  switch_to_user_with_privs ();\n\n  if (opt_unshare_net)\n    loopback_setup (); /* Will exit if unsuccessful */\n\n  ns_uid = opt_sandbox_uid;\n  ns_gid = opt_sandbox_gid;\n  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)\n    {\n      /* In the unprivileged case we have to write the uid/gid maps in\n       * the child, because we have no caps in the parent */\n\n      if (opt_needs_devpts)\n        {\n          /* This is a bit hacky, but we need to first map the real uid/gid to\n             0, otherwise we can't mount the devpts filesystem because root is\n             not mapped. Later we will create another child user namespace and\n             map back to the real uid */\n          ns_uid = 0;\n          ns_gid = 0;\n        }\n\n      write_uid_gid_map (ns_uid, real_uid,\n                         ns_gid, real_gid,\n                         -1, TRUE, FALSE);\n    }\n\n  old_umask = umask (0);\n\n  /* Need to do this before the chroot, but after we're the real uid */\n  resolve_symlinks_in_ops ();\n\n  /* Mark everything as slave, so that we still\n   * receive mounts from the real root, but don't\n   * propagate mounts to the real root. */\n  if (mount (NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0)\n    die_with_error (\"Failed to make / slave\");\n\n  /* Create a tmpfs which we will use as / in the namespace */\n  if (mount (\"tmpfs\", base_path, \"tmpfs\", MS_NODEV | MS_NOSUID, NULL) != 0)\n    die_with_error (\"Failed to mount tmpfs\");\n\n  old_cwd = get_current_dir_name ();\n\n  /* Chdir to the new root tmpfs mount. This will be the CWD during\n     the entire setup. Access old or new root via \"oldroot\" and \"newroot\". */\n  if (chdir (base_path) != 0)\n    die_with_error (\"chdir base_path\");\n\n  /* We create a subdir \"$base_path/newroot\" for the new root, that\n   * way we can pivot_root to base_path, and put the old root at\n   * \"$base_path/oldroot\". This avoids problems accessing the oldroot\n   * dir if the user requested to bind mount something over / (or\n   * over /tmp, now that we use that for base_path). */\n\n  if (mkdir (\"newroot\", 0755))\n    die_with_error (\"Creating newroot failed\");\n\n  if (mount (\"newroot\", \"newroot\", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)\n    die_with_error (\"setting up newroot bind\");\n\n  if (mkdir (\"oldroot\", 0755))\n    die_with_error (\"Creating oldroot failed\");\n\n  if (pivot_root (base_path, \"oldroot\"))\n    die_with_error (\"pivot_root\");\n\n  if (chdir (\"/\") != 0)\n    die_with_error (\"chdir / (base path)\");\n\n  if (is_privileged)\n    {\n      pid_t child;\n      int privsep_sockets[2];\n\n      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)\n        die_with_error (\"Can't create privsep socket\");\n\n      child = fork ();\n      if (child == -1)\n        die_with_error (\"Can't fork unprivileged helper\");\n\n      if (child == 0)\n        {\n          /* Unprivileged setup process */\n          drop_privs (FALSE);\n          close (privsep_sockets[0]);\n          setup_newroot (opt_unshare_pid, privsep_sockets[1]);\n          exit (0);\n        }\n      else\n        {\n          int status;\n          uint32_t buffer[2048];  /* 8k, but is int32 to guarantee nice alignment */\n          uint32_t op, flags;\n          const char *arg1, *arg2;\n          cleanup_fd int unpriv_socket = -1;\n\n          unpriv_socket = privsep_sockets[0];\n          close (privsep_sockets[1]);\n\n          do\n            {\n              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),\n                                     &flags, &arg1, &arg2);\n              privileged_op (-1, op, flags, arg1, arg2);\n              if (write (unpriv_socket, buffer, 1) != 1)\n                die (\"Can't write to op_socket\");\n            }\n          while (op != PRIV_SEP_OP_DONE);\n\n          waitpid (child, &status, 0);\n          /* Continue post setup */\n        }\n    }\n  else\n    {\n      setup_newroot (opt_unshare_pid, -1);\n    }\n\n  close_ops_fd ();\n\n  /* The old root better be rprivate or we will send unmount events to the parent namespace */\n  if (mount (\"oldroot\", \"oldroot\", NULL, MS_REC | MS_PRIVATE, NULL) != 0)\n    die_with_error (\"Failed to make old root rprivate\");\n\n  if (umount2 (\"oldroot\", MNT_DETACH))\n    die_with_error (\"unmount old root\");\n\n  /* This is our second pivot. It's like we're a Silicon Valley startup flush\n   * with cash but short on ideas!\n   *\n   * We're aiming to make /newroot the real root, and get rid of /oldroot. To do\n   * that we need a temporary place to store it before we can unmount it.\n   */\n  { cleanup_fd int oldrootfd = open (\"/\", O_DIRECTORY | O_RDONLY);\n    if (oldrootfd < 0)\n      die_with_error (\"can't open /\");\n    if (chdir (\"/newroot\") != 0)\n      die_with_error (\"chdir /newroot\");\n    /* While the documentation claims that put_old must be underneath\n     * new_root, it is perfectly fine to use the same directory as the\n     * kernel checks only if old_root is accessible from new_root.\n     *\n     * Both runc and LXC are using this \"alternative\" method for\n     * setting up the root of the container:\n     *\n     * https://github.com/opencontainers/runc/blob/master/libcontainer/rootfs_linux.go#L671\n     * https://github.com/lxc/lxc/blob/master/src/lxc/conf.c#L1121\n     */\n    if (pivot_root (\".\", \".\") != 0)\n      die_with_error (\"pivot_root(/newroot)\");\n    if (fchdir (oldrootfd) < 0)\n      die_with_error (\"fchdir to oldroot\");\n    if (umount2 (\".\", MNT_DETACH) < 0)\n      die_with_error (\"umount old root\");\n    if (chdir (\"/\") != 0)\n      die_with_error (\"chdir /\");\n  }\n\n  if (opt_unshare_user &&\n      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&\n      opt_userns_block_fd == -1)\n    {\n      /* Now that devpts is mounted and we've no need for mount\n         permissions we can create a new userspace and map our uid\n         1:1 */\n\n      if (unshare (CLONE_NEWUSER))\n        die_with_error (\"unshare user ns\");\n\n      write_uid_gid_map (opt_sandbox_uid, ns_uid,\n                         opt_sandbox_gid, ns_gid,\n                         -1, FALSE, FALSE);\n    }\n\n  /* All privileged ops are done now, so drop caps we don't need */\n  drop_privs (!is_privileged);\n\n  if (opt_block_fd != -1)\n    {\n      char b[1];\n      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));\n      close (opt_block_fd);\n    }\n\n  if (opt_seccomp_fd != -1)\n    {\n      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);\n      if (seccomp_data == NULL)\n        die_with_error (\"Can't read seccomp data\");\n\n      if (seccomp_len % 8 != 0)\n        die (\"Invalid seccomp data, must be multiple of 8\");\n\n      seccomp_prog.len = seccomp_len / 8;\n      seccomp_prog.filter = (struct sock_filter *) seccomp_data;\n\n      close (opt_seccomp_fd);\n    }\n\n  umask (old_umask);\n\n  new_cwd = \"/\";\n  if (opt_chdir_path)\n    {\n      if (chdir (opt_chdir_path))\n        die_with_error (\"Can't chdir to %s\", opt_chdir_path);\n      new_cwd = opt_chdir_path;\n    }\n  else if (chdir (old_cwd) == 0)\n    {\n      /* If the old cwd is mapped in the sandbox, go there */\n      new_cwd = old_cwd;\n    }\n  else\n    {\n      /* If the old cwd is not mapped, go to home */\n      const char *home = getenv (\"HOME\");\n      if (home != NULL &&\n          chdir (home) == 0)\n        new_cwd = home;\n    }\n  xsetenv (\"PWD\", new_cwd, 1);\n  free (old_cwd);\n\n  if (opt_new_session &&\n      setsid () == (pid_t) -1)\n    die_with_error (\"setsid\");\n\n  if (label_exec (opt_exec_label) == -1)\n    die_with_error (\"label_exec %s\", argv[0]);\n\n  __debug__ ((\"forking for child\\n\"));\n\n  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))\n    {\n      /* We have to have a pid 1 in the pid namespace, because\n       * otherwise we'll get a bunch of zombies as nothing reaps\n       * them. Alternatively if we're using sync_fd or lock_files we\n       * need some process to own these.\n       */\n\n      pid = fork ();\n      if (pid == -1)\n        die_with_error (\"Can't fork for pid 1\");\n\n      if (pid != 0)\n        {\n          drop_all_caps (FALSE);\n\n          /* Close fds in pid 1, except stdio and optionally event_fd\n             (for syncing pid 2 lifetime with monitor_child) and\n             opt_sync_fd (for syncing sandbox lifetime with outside\n             process).\n             Any other fds will been passed on to the child though. */\n          {\n            int dont_close[3];\n            int j = 0;\n            if (event_fd != -1)\n              dont_close[j++] = event_fd;\n            if (opt_sync_fd != -1)\n              dont_close[j++] = opt_sync_fd;\n            dont_close[j++] = -1;\n            fdwalk (proc_fd, close_extra_fds, dont_close);\n          }\n\n          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);\n        }\n    }\n\n  __debug__ ((\"launch executable %s\\n\", argv[0]));\n\n  if (proc_fd != -1)\n    close (proc_fd);\n\n  /* If we are using --as-pid-1 leak the sync fd into the sandbox.\n     --sync-fd will still work unless the container process doesn't close this file.  */\n  if (!opt_as_pid_1)\n    {\n      if (opt_sync_fd != -1)\n        close (opt_sync_fd);\n    }\n\n  /* We want sigchild in the child */\n  unblock_sigchild ();\n\n  /* Optionally bind our lifecycle */\n  handle_die_with_parent ();\n\n  if (!is_privileged)\n    set_ambient_capabilities ();\n\n  /* Should be the last thing before execve() so that filters don't\n   * need to handle anything above */\n  if (seccomp_data != NULL &&\n      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)\n    die_with_error (\"prctl(PR_SET_SECCOMP)\");\n\n  if (setup_finished_pipe[1] != -1)\n    {\n      char data = 0;\n      res = write_to_fd (setup_finished_pipe[1], &data, 1);\n      /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n         we don't want to error out here */\n    }\n\n  if (execvp (argv[0], argv) == -1)\n    {\n      if (setup_finished_pipe[1] != -1)\n        {\n          int saved_errno = errno;\n          char data = 0;\n          res = write_to_fd (setup_finished_pipe[1], &data, 1);\n          errno = saved_errno;\n          /* Ignore res, if e.g. the parent died and closed setup_finished_pipe[0]\n             we don't want to error out here */\n        }\n      die_with_error (\"execvp %s\", argv[0]);\n    }\n\n  return 0;\n}\n"], "filenames": ["bubblewrap.c"], "buggy_code_start_loc": [2049], "buggy_code_end_loc": [2404], "fixing_code_start_loc": [2049], "fixing_code_end_loc": [2402], "type": "CWE-20", "message": "bubblewrap.c in Bubblewrap before 0.3.3 misuses temporary directories in /tmp as a mount point. In some particular configurations (related to XDG_RUNTIME_DIR), a local attacker may abuse this flaw to prevent other users from executing bubblewrap or potentially execute code.", "other": {"cve": {"id": "CVE-2019-12439", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-29T15:29:00.377", "lastModified": "2020-06-15T18:15:13.287", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "bubblewrap.c in Bubblewrap before 0.3.3 misuses temporary directories in /tmp as a mount point. In some particular configurations (related to XDG_RUNTIME_DIR), a local attacker may abuse this flaw to prevent other users from executing bubblewrap or potentially execute code."}, {"lang": "es", "value": "El archivo bubblewrap.c en Bubblewrap anterior de versi\u00f3n 0.3.3, utiliza de manera incorrecta directorios temporales en /tmp como un punto de montaje. En algunas configuraciones particulares (relacionadas con XDG_RUNTIME_DIR), un atacante local puede abusar de este defecto  para prevenir que otros usuarios ejecuten bubblewrap o potencialmente ejecute c\u00f3digo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve@mitre.org", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:projectatomic:bubblewrap:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.3", "matchCriteriaId": "D39BE3CC-42B1-4008-A900-798FA1445831"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-06/msg00028.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00015.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1833", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1695963", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/projectatomic/bubblewrap/commit/efc89e3b939b4bde42c10f065f6b7b02958ed50e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/projectatomic/bubblewrap/issues/304", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/projectatomic/bubblewrap/releases/tag/v0.3.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202006-18", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/projectatomic/bubblewrap/commit/efc89e3b939b4bde42c10f065f6b7b02958ed50e"}}