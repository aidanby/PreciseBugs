{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"CarbonProtocolReader.h\"\n\nnamespace carbon {\nvoid CarbonProtocolReader::skipLinearContainer() {\n  const auto pr = readLinearContainerFieldSizeAndInnerType();\n  skipLinearContainerItems(pr);\n}\n\nvoid CarbonProtocolReader::skipLinearContainerItems(\n    std::pair<FieldType, uint32_t> pr) {\n  const auto fieldType = pr.first;\n  const auto len = pr.second;\n  for (uint32_t i = 0; i < len; ++i) {\n    skip(fieldType);\n  }\n}\n\nvoid CarbonProtocolReader::skipKVContainer() {\n  const auto pr = readKVContainerFieldSizeAndInnerTypes();\n  skipKVContainerItems(pr);\n}\n\nvoid CarbonProtocolReader::skipKVContainerItems(\n    std::pair<std::pair<FieldType, FieldType>, uint32_t> pr) {\n  const auto len = pr.second;\n  const auto keyType = pr.first.first;\n  const auto valType = pr.first.second;\n  for (uint32_t i = 0; i < len; ++i) {\n    skip(keyType);\n    skip(valType);\n  }\n}\n\nvoid CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}\n\n} // carbon\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#pragma once\n\n#include <stdint.h>\n#include <algorithm>\n#include <cstring>\n#include <limits>\n#include <string>\n#include <type_traits>\n#include <utility>\n\n#include <folly/Optional.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/IOBuf.h>\n#include <folly/small_vector.h>\n#include <thrift/lib/cpp2/FieldRef.h>\n\n#include \"mcrouter/lib/carbon/CarbonProtocolCommon.h\"\n#include \"mcrouter/lib/carbon/CarbonProtocolWriter.h\"\n#include \"mcrouter/lib/carbon/CommonSerializationTraits.h\"\n#include \"mcrouter/lib/carbon/Fields.h\"\n#include \"mcrouter/lib/carbon/Result.h\"\n#include \"mcrouter/lib/carbon/Util.h\"\n#include \"mcrouter/lib/fbi/cpp/util.h\"\n\nnamespace carbon {\n\nusing CarbonCursor = folly::io::Cursor;\n\nclass CarbonProtocolReader {\n public:\n  explicit CarbonProtocolReader(const CarbonCursor& c) : cursor_(c) {}\n\n  void setCursor(const CarbonCursor& c) {\n    cursor_ = c;\n  }\n\n  CarbonCursor& cursor() {\n    return cursor_;\n  }\n\n  void readField(bool& b, FieldType fieldType) {\n    readRawInto(b, fieldType);\n  }\n\n  void readField(folly::Optional<bool>& data, FieldType fieldType) {\n    data = folly::Optional<bool>(fieldType == FieldType::True);\n  }\n\n  template <class T>\n  void readField(folly::Optional<T>& data, FieldType /* fieldType */) {\n    data = folly::Optional<T>(readRaw<T>());\n  }\n\n  void readField(\n      apache::thrift::optional_field_ref<bool&> data,\n      FieldType fieldType) {\n    data = fieldType == FieldType::True;\n  }\n\n  template <class T>\n  void readField(\n      apache::thrift::optional_field_ref<T&> data,\n      FieldType /* fieldType */) {\n    data = readRaw<T>();\n  }\n\n  template <class T>\n  void readField(T& t, FieldType /* fieldType */) {\n    readRawInto(t);\n  }\n\n  void readRawInto(bool& b, FieldType fieldType) {\n    DCHECK(fieldType == FieldType::True || fieldType == FieldType::False)\n        << \"Invalid fieldType: \" << static_cast<uint8_t>(fieldType);\n    b = fieldType == FieldType::True;\n  }\n\n  template <class T>\n  typename std::enable_if<detail::IsLinearContainer<T>::value, void>::type\n  readRawInto(T& c) {\n    SerializationTraits<T>::clear(c);\n    const auto pr = readLinearContainerFieldSizeAndInnerType();\n    if (pr.first !=\n        detail::TypeToField<\n            typename SerializationTraits<T>::inner_type>::fieldType) {\n      LOG_FIRST_N(ERROR, 100) << \"Type mismatch between Linear Container\"\n                              << \" inner type and wire type. Skipping.\";\n      skipLinearContainerItems(pr);\n      return;\n    }\n    const auto len = pr.second;\n    SerializationTraits<T>::reserve(c, len);\n    for (size_t i = 0; i < len; ++i) {\n      auto inserted = SerializationTraits<T>::emplace(\n          c, readRaw<typename SerializationTraits<T>::inner_type>());\n      if (!inserted) {\n        LOG_FIRST_N(ERROR, 100) << \"Item not inserted into container, possibly \"\n                                << \"due to a uniqueness constraint.\";\n      }\n    }\n  }\n\n  template <class T>\n  typename std::enable_if<detail::IsKVContainer<T>::value, void>::type\n  readRawInto(T& m) {\n    SerializationTraits<T>::clear(m);\n    const auto pr = readKVContainerFieldSizeAndInnerTypes();\n    bool mismatch = false;\n    if (pr.first.first !=\n        detail::TypeToField<\n            typename SerializationTraits<T>::key_type>::fieldType) {\n      mismatch = true;\n      LOG_FIRST_N(ERROR, 100) << \"Type mismatch between Map key type and\"\n                              << \" wire type. Skipping.\";\n    }\n    if (pr.first.second !=\n        detail::TypeToField<\n            typename SerializationTraits<T>::mapped_type>::fieldType) {\n      mismatch = true;\n      LOG_FIRST_N(ERROR, 100) << \"Type mismatch between Map value type \"\n                              << \"and wire type. Skipping.\";\n    }\n    if (mismatch) {\n      skipKVContainerItems(pr);\n      return;\n    }\n    const auto size = pr.second;\n    SerializationTraits<T>::reserve(m, size);\n    for (size_t i = 0; i < size; ++i) {\n      auto keyValue = readRaw<typename SerializationTraits<T>::key_type>();\n      auto mappedValue =\n          readRaw<typename SerializationTraits<T>::mapped_type>();\n      SerializationTraits<T>::emplace(\n          m, std::move(keyValue), std::move(mappedValue));\n    }\n  }\n\n  template <\n      class T,\n      decltype(std::declval<CarbonProtocolWriter>().writeRaw(\n          std::declval<T>()))* = nullptr>\n  T readRaw() {\n    T t = T();\n    readRawInto(t);\n    return t;\n  }\n\n  template <class T>\n  typename std::enable_if<std::is_enum<T>::value, void>::type readRawInto(\n      T& t) {\n    using UnderlyingType = typename std::underlying_type<T>::type;\n    t = static_cast<T>(readRaw<UnderlyingType>());\n  }\n\n  template <class T>\n  typename std::enable_if<IsCarbonStruct<T>::value, void>::type readRawInto(\n      T& data) {\n    data.deserialize(*this);\n  }\n\n  template <class T>\n  typename std::enable_if<detail::IsUserReadWriteDefined<T>::value, void>::type\n  readRawInto(T& data) {\n    static_assert(\n        (SerializationTraits<T>::kWireType != FieldType::True) &&\n            (SerializationTraits<T>::kWireType != FieldType::False),\n        \"Usertypes cannot have a boolean wiretype.\");\n    data = SerializationTraits<T>::read(*this);\n  }\n\n  void readRawInto(bool& b) {\n    const auto fieldType = static_cast<FieldType>(readByte());\n    DCHECK(fieldType == FieldType::True || fieldType == FieldType::False);\n    b = fieldType == FieldType::True;\n  }\n\n  template <class T>\n  typename std::\n      enable_if<folly::IsOneOf<T, char, int8_t, uint8_t>::value, void>::type\n      readRawInto(T& t) {\n    t = readByte();\n  }\n\n  template <class T>\n  typename std::enable_if<\n      folly::\n          IsOneOf<T, int16_t, int32_t, int64_t, uint16_t, uint32_t, uint64_t>::\n              value,\n      void>::type\n  readRawInto(T& t) {\n    t = readZigzagVarint<T>();\n  }\n\n  void readRawInto(float& f) {\n    static_assert(\n        sizeof(float) == sizeof(uint32_t),\n        \"Carbon doubles can only be used on platforms where sizeof(float)\"\n        \" == sizeof(uint32_t)\");\n    static_assert(\n        std::numeric_limits<float>::is_iec559,\n        \"Carbon floats may only be used on platforms using IEC 559 floats\");\n\n    const auto bits = cursor_.template readBE<uint32_t>();\n    std::memcpy(std::addressof(f), std::addressof(bits), sizeof(f));\n  }\n\n  void readRawInto(double& d) {\n    static_assert(\n        sizeof(double) == sizeof(uint64_t),\n        \"Carbon doubles can only be used on platforms where sizeof(double)\"\n        \" == sizeof(uint64_t)\");\n    static_assert(\n        std::numeric_limits<double>::is_iec559,\n        \"Carbon doubles may only be used on platforms using IEC 559 doubles\");\n\n    const auto bits = cursor_.template readBE<uint64_t>();\n    std::memcpy(std::addressof(d), std::addressof(bits), sizeof(d));\n  }\n\n  void readRawInto(Result& r) {\n    static_assert(\n        sizeof(Result) == sizeof(carbon::Result),\n        \"Carbon currently assumes sizeof(Result) == sizeof(int16_t)\");\n    r = static_cast<Result>(readRaw<int16_t>());\n  }\n\n  void readRawInto(std::string& s) {\n    s = cursor_.readFixedString(readVarint<uint32_t>());\n  }\n\n  void readRawInto(folly::IOBuf& buf) {\n    cursor_.clone(buf, readVarint<uint32_t>());\n  }\n\n  void readStructBegin() {\n    nestedStructFieldIds_.push_back(lastFieldId_);\n    lastFieldId_ = 0;\n  }\n\n  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }\n\n  std::pair<std::pair<FieldType, FieldType>, uint32_t>\n  readKVContainerFieldSizeAndInnerTypes() {\n    std::pair<std::pair<FieldType, FieldType>, uint32_t> pr;\n    const auto len = readVarint<uint32_t>();\n    pr.second = len;\n    uint8_t byte = 0;\n    if (len > 0) {\n      byte = readByte();\n    }\n    pr.first.first = static_cast<FieldType>((byte & 0xf0) >> 4); // key-type\n    pr.first.second = static_cast<FieldType>(byte & 0x0f); // value-type\n    return pr;\n  }\n\n  std::pair<FieldType, uint32_t> readLinearContainerFieldSizeAndInnerType() {\n    std::pair<FieldType, uint32_t> pr;\n    const uint8_t byte = readByte();\n    pr.first = static_cast<FieldType>(byte & 0x0f);\n    if ((byte & 0xf0) == 0xf0) {\n      pr.second = readVarint<uint32_t>();\n    } else {\n      pr.second = static_cast<uint32_t>(byte >> 4);\n    }\n    return pr;\n  }\n\n  std::pair<FieldType, int16_t> readFieldHeader() {\n    std::pair<FieldType, int16_t> rv;\n    const uint8_t byte = readByte();\n    if (byte & 0xf0) {\n      rv.first = static_cast<FieldType>(byte & 0x0f);\n      rv.second = static_cast<int16_t>(byte >> 4) + lastFieldId_;\n    } else {\n      rv.first = static_cast<FieldType>(byte);\n      if (rv.first != FieldType::Stop) {\n        rv.second = cursor_.read<int16_t>();\n      }\n    }\n    lastFieldId_ = rv.second;\n    return rv;\n  }\n\n  void skip(const FieldType fieldType);\n\n private:\n  void skipLinearContainer();\n  void skipLinearContainerItems(std::pair<FieldType, uint32_t> pr);\n  void skipKVContainer();\n  void skipKVContainerItems(\n      std::pair<std::pair<FieldType, FieldType>, uint32_t> pr);\n\n  uint8_t readByte() {\n    return cursor_.template read<uint8_t>();\n  }\n\n  template <class T>\n  typename std::enable_if<std::numeric_limits<T>::is_integer, T>::type\n  readZigzagVarint() {\n    static_assert(\n        sizeof(T) <= sizeof(uint64_t),\n        \"argument to readZigzagVarint() can be no larger than uint64_t\");\n    using UnsignedT = typename std::make_unsigned<T>::type;\n\n    return util::unzigzag(readVarint<UnsignedT>());\n  }\n\n  template <class T>\n  typename std::enable_if<std::numeric_limits<T>::is_integer, T>::type\n  readVarint() {\n    using UnsignedT = typename std::make_unsigned<T>::type;\n    constexpr uint8_t kShift = 7;\n    constexpr uint8_t kMaxIters = (sizeof(T) * 8 + 6) / 7;\n\n    static_assert(\n        sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8,\n        \"readVarint() may only be used with 16-, 32-, or 64-bit integers\");\n\n    UnsignedT urv = 0;\n    uint8_t iter = 0;\n    uint8_t byte;\n    do {\n      byte = readByte();\n      urv |= static_cast<UnsignedT>(byte & 0x7f) << (kShift * iter++);\n    } while (byte & 0x80 && iter <= kMaxIters);\n\n    return static_cast<T>(urv);\n  }\n\n  CarbonCursor cursor_;\n  folly::small_vector<int16_t, detail::kDefaultStackSize> nestedStructFieldIds_;\n  int16_t lastFieldId_{0};\n  FieldType boolFieldType_;\n};\n\n} // namespace carbon\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"CarbonProtocolReader.h\"\n\nnamespace carbon {\nvoid CarbonProtocolReader::skipLinearContainer() {\n  const auto pr = readLinearContainerFieldSizeAndInnerType();\n  skipLinearContainerItems(pr);\n}\n\nvoid CarbonProtocolReader::skipLinearContainerItems(\n    std::pair<FieldType, uint32_t> pr) {\n  const auto fieldType = pr.first;\n  const auto len = pr.second;\n  for (uint32_t i = 0; i < len; ++i) {\n    skip(fieldType);\n  }\n}\n\nvoid CarbonProtocolReader::skipKVContainer() {\n  const auto pr = readKVContainerFieldSizeAndInnerTypes();\n  skipKVContainerItems(pr);\n}\n\nvoid CarbonProtocolReader::skipKVContainerItems(\n    std::pair<std::pair<FieldType, FieldType>, uint32_t> pr) {\n  const auto len = pr.second;\n  const auto keyType = pr.first.first;\n  const auto valType = pr.first.second;\n  for (uint32_t i = 0; i < len; ++i) {\n    skip(keyType);\n    skip(valType);\n  }\n}\n\nvoid CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      const auto next = readFieldHeader().first;\n      skip(next);\n      break;\n    }\n    case FieldType::Stop: {\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n}\n\n} // namespace carbon\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#pragma once\n\n#include <stdint.h>\n#include <algorithm>\n#include <cstring>\n#include <limits>\n#include <string>\n#include <type_traits>\n#include <utility>\n\n#include <folly/Optional.h>\n#include <folly/io/Cursor.h>\n#include <folly/io/IOBuf.h>\n#include <folly/small_vector.h>\n#include <thrift/lib/cpp2/FieldRef.h>\n\n#include \"mcrouter/lib/carbon/CarbonProtocolCommon.h\"\n#include \"mcrouter/lib/carbon/CarbonProtocolWriter.h\"\n#include \"mcrouter/lib/carbon/CommonSerializationTraits.h\"\n#include \"mcrouter/lib/carbon/Fields.h\"\n#include \"mcrouter/lib/carbon/Result.h\"\n#include \"mcrouter/lib/carbon/Util.h\"\n#include \"mcrouter/lib/fbi/cpp/util.h\"\n\nnamespace carbon {\n\nusing CarbonCursor = folly::io::Cursor;\n\nclass CarbonProtocolReader {\n public:\n  explicit CarbonProtocolReader(const CarbonCursor& c) : cursor_(c) {}\n\n  void setCursor(const CarbonCursor& c) {\n    cursor_ = c;\n  }\n\n  CarbonCursor& cursor() {\n    return cursor_;\n  }\n\n  void readField(bool& b, FieldType fieldType) {\n    readRawInto(b, fieldType);\n  }\n\n  void readField(folly::Optional<bool>& data, FieldType fieldType) {\n    data = folly::Optional<bool>(fieldType == FieldType::True);\n  }\n\n  template <class T>\n  void readField(folly::Optional<T>& data, FieldType /* fieldType */) {\n    data = folly::Optional<T>(readRaw<T>());\n  }\n\n  void readField(\n      apache::thrift::optional_field_ref<bool&> data,\n      FieldType fieldType) {\n    data = fieldType == FieldType::True;\n  }\n\n  template <class T>\n  void readField(\n      apache::thrift::optional_field_ref<T&> data,\n      FieldType /* fieldType */) {\n    data = readRaw<T>();\n  }\n\n  template <class T>\n  void readField(T& t, FieldType /* fieldType */) {\n    readRawInto(t);\n  }\n\n  void readRawInto(bool& b, FieldType fieldType) {\n    DCHECK(fieldType == FieldType::True || fieldType == FieldType::False)\n        << \"Invalid fieldType: \" << static_cast<uint8_t>(fieldType);\n    b = fieldType == FieldType::True;\n  }\n\n  template <class T>\n  typename std::enable_if<detail::IsLinearContainer<T>::value, void>::type\n  readRawInto(T& c) {\n    SerializationTraits<T>::clear(c);\n    const auto pr = readLinearContainerFieldSizeAndInnerType();\n    if (pr.first !=\n        detail::TypeToField<\n            typename SerializationTraits<T>::inner_type>::fieldType) {\n      LOG_FIRST_N(ERROR, 100) << \"Type mismatch between Linear Container\"\n                              << \" inner type and wire type. Skipping.\";\n      skipLinearContainerItems(pr);\n      return;\n    }\n    const auto len = pr.second;\n    SerializationTraits<T>::reserve(c, len);\n    for (size_t i = 0; i < len; ++i) {\n      auto inserted = SerializationTraits<T>::emplace(\n          c, readRaw<typename SerializationTraits<T>::inner_type>());\n      if (!inserted) {\n        LOG_FIRST_N(ERROR, 100) << \"Item not inserted into container, possibly \"\n                                << \"due to a uniqueness constraint.\";\n      }\n    }\n  }\n\n  template <class T>\n  typename std::enable_if<detail::IsKVContainer<T>::value, void>::type\n  readRawInto(T& m) {\n    SerializationTraits<T>::clear(m);\n    const auto pr = readKVContainerFieldSizeAndInnerTypes();\n    bool mismatch = false;\n    if (pr.first.first !=\n        detail::TypeToField<\n            typename SerializationTraits<T>::key_type>::fieldType) {\n      mismatch = true;\n      LOG_FIRST_N(ERROR, 100) << \"Type mismatch between Map key type and\"\n                              << \" wire type. Skipping.\";\n    }\n    if (pr.first.second !=\n        detail::TypeToField<\n            typename SerializationTraits<T>::mapped_type>::fieldType) {\n      mismatch = true;\n      LOG_FIRST_N(ERROR, 100) << \"Type mismatch between Map value type \"\n                              << \"and wire type. Skipping.\";\n    }\n    if (mismatch) {\n      skipKVContainerItems(pr);\n      return;\n    }\n    const auto size = pr.second;\n    SerializationTraits<T>::reserve(m, size);\n    for (size_t i = 0; i < size; ++i) {\n      auto keyValue = readRaw<typename SerializationTraits<T>::key_type>();\n      auto mappedValue =\n          readRaw<typename SerializationTraits<T>::mapped_type>();\n      SerializationTraits<T>::emplace(\n          m, std::move(keyValue), std::move(mappedValue));\n    }\n  }\n\n  template <\n      class T,\n      decltype(std::declval<CarbonProtocolWriter>().writeRaw(\n          std::declval<T>()))* = nullptr>\n  T readRaw() {\n    T t = T();\n    readRawInto(t);\n    return t;\n  }\n\n  template <class T>\n  typename std::enable_if<std::is_enum<T>::value, void>::type readRawInto(\n      T& t) {\n    using UnderlyingType = typename std::underlying_type<T>::type;\n    t = static_cast<T>(readRaw<UnderlyingType>());\n  }\n\n  template <class T>\n  typename std::enable_if<IsCarbonStruct<T>::value, void>::type readRawInto(\n      T& data) {\n    data.deserialize(*this);\n  }\n\n  template <class T>\n  typename std::enable_if<detail::IsUserReadWriteDefined<T>::value, void>::type\n  readRawInto(T& data) {\n    static_assert(\n        (SerializationTraits<T>::kWireType != FieldType::True) &&\n            (SerializationTraits<T>::kWireType != FieldType::False),\n        \"Usertypes cannot have a boolean wiretype.\");\n    data = SerializationTraits<T>::read(*this);\n  }\n\n  void readRawInto(bool& b) {\n    const auto fieldType = static_cast<FieldType>(readByte());\n    DCHECK(fieldType == FieldType::True || fieldType == FieldType::False);\n    b = fieldType == FieldType::True;\n  }\n\n  template <class T>\n  typename std::\n      enable_if<folly::IsOneOf<T, char, int8_t, uint8_t>::value, void>::type\n      readRawInto(T& t) {\n    t = readByte();\n  }\n\n  template <class T>\n  typename std::enable_if<\n      folly::\n          IsOneOf<T, int16_t, int32_t, int64_t, uint16_t, uint32_t, uint64_t>::\n              value,\n      void>::type\n  readRawInto(T& t) {\n    t = readZigzagVarint<T>();\n  }\n\n  void readRawInto(float& f) {\n    static_assert(\n        sizeof(float) == sizeof(uint32_t),\n        \"Carbon doubles can only be used on platforms where sizeof(float)\"\n        \" == sizeof(uint32_t)\");\n    static_assert(\n        std::numeric_limits<float>::is_iec559,\n        \"Carbon floats may only be used on platforms using IEC 559 floats\");\n\n    const auto bits = cursor_.template readBE<uint32_t>();\n    std::memcpy(std::addressof(f), std::addressof(bits), sizeof(f));\n  }\n\n  void readRawInto(double& d) {\n    static_assert(\n        sizeof(double) == sizeof(uint64_t),\n        \"Carbon doubles can only be used on platforms where sizeof(double)\"\n        \" == sizeof(uint64_t)\");\n    static_assert(\n        std::numeric_limits<double>::is_iec559,\n        \"Carbon doubles may only be used on platforms using IEC 559 doubles\");\n\n    const auto bits = cursor_.template readBE<uint64_t>();\n    std::memcpy(std::addressof(d), std::addressof(bits), sizeof(d));\n  }\n\n  void readRawInto(Result& r) {\n    static_assert(\n        sizeof(Result) == sizeof(carbon::Result),\n        \"Carbon currently assumes sizeof(Result) == sizeof(int16_t)\");\n    r = static_cast<Result>(readRaw<int16_t>());\n  }\n\n  void readRawInto(std::string& s) {\n    s = cursor_.readFixedString(readVarint<uint32_t>());\n  }\n\n  void readRawInto(folly::IOBuf& buf) {\n    cursor_.clone(buf, readVarint<uint32_t>());\n  }\n\n  void readStructBegin() {\n    nestedStructFieldIds_.push_back(lastFieldId_);\n    lastFieldId_ = 0;\n  }\n\n  void readStructEnd() {\n    if (!nestedStructFieldIds_.empty()) {\n      lastFieldId_ = nestedStructFieldIds_.back();\n      nestedStructFieldIds_.pop_back();\n    }\n  }\n\n  std::pair<std::pair<FieldType, FieldType>, uint32_t>\n  readKVContainerFieldSizeAndInnerTypes() {\n    std::pair<std::pair<FieldType, FieldType>, uint32_t> pr;\n    const auto len = readVarint<uint32_t>();\n    pr.second = len;\n    uint8_t byte = 0;\n    if (len > 0) {\n      byte = readByte();\n    }\n    pr.first.first = static_cast<FieldType>((byte & 0xf0) >> 4); // key-type\n    pr.first.second = static_cast<FieldType>(byte & 0x0f); // value-type\n    return pr;\n  }\n\n  std::pair<FieldType, uint32_t> readLinearContainerFieldSizeAndInnerType() {\n    std::pair<FieldType, uint32_t> pr;\n    const uint8_t byte = readByte();\n    pr.first = static_cast<FieldType>(byte & 0x0f);\n    if ((byte & 0xf0) == 0xf0) {\n      pr.second = readVarint<uint32_t>();\n    } else {\n      pr.second = static_cast<uint32_t>(byte >> 4);\n    }\n    return pr;\n  }\n\n  std::pair<FieldType, int16_t> readFieldHeader() {\n    std::pair<FieldType, int16_t> rv;\n    const uint8_t byte = readByte();\n    if (byte & 0xf0) {\n      rv.first = static_cast<FieldType>(byte & 0x0f);\n      rv.second = static_cast<int16_t>(byte >> 4) + lastFieldId_;\n    } else {\n      rv.first = static_cast<FieldType>(byte);\n      if (rv.first != FieldType::Stop) {\n        rv.second = cursor_.read<int16_t>();\n      }\n    }\n    lastFieldId_ = rv.second;\n    return rv;\n  }\n\n  void skip(const FieldType fieldType);\n\n private:\n  void skipLinearContainer();\n  void skipLinearContainerItems(std::pair<FieldType, uint32_t> pr);\n  void skipKVContainer();\n  void skipKVContainerItems(\n      std::pair<std::pair<FieldType, FieldType>, uint32_t> pr);\n\n  uint8_t readByte() {\n    return cursor_.template read<uint8_t>();\n  }\n\n  template <class T>\n  typename std::enable_if<std::numeric_limits<T>::is_integer, T>::type\n  readZigzagVarint() {\n    static_assert(\n        sizeof(T) <= sizeof(uint64_t),\n        \"argument to readZigzagVarint() can be no larger than uint64_t\");\n    using UnsignedT = typename std::make_unsigned<T>::type;\n\n    return util::unzigzag(readVarint<UnsignedT>());\n  }\n\n  template <class T>\n  typename std::enable_if<std::numeric_limits<T>::is_integer, T>::type\n  readVarint() {\n    using UnsignedT = typename std::make_unsigned<T>::type;\n    constexpr uint8_t kShift = 7;\n    constexpr uint8_t kMaxIters = (sizeof(T) * 8 + 6) / 7;\n\n    static_assert(\n        sizeof(T) == 2 || sizeof(T) == 4 || sizeof(T) == 8,\n        \"readVarint() may only be used with 16-, 32-, or 64-bit integers\");\n\n    UnsignedT urv = 0;\n    uint8_t iter = 0;\n    uint8_t byte;\n    do {\n      byte = readByte();\n      urv |= static_cast<UnsignedT>(byte & 0x7f) << (kShift * iter++);\n    } while (byte & 0x80 && iter <= kMaxIters);\n\n    return static_cast<T>(urv);\n  }\n\n  CarbonCursor cursor_;\n  folly::small_vector<int16_t, detail::kDefaultStackSize> nestedStructFieldIds_;\n  int16_t lastFieldId_{0};\n  FieldType boolFieldType_;\n};\n\n} // namespace carbon\n"], "filenames": ["mcrouter/lib/carbon/CarbonProtocolReader.cpp", "mcrouter/lib/carbon/CarbonProtocolReader.h"], "buggy_code_start_loc": [81, 248], "buggy_code_end_loc": [104, 250], "fixing_code_start_loc": [81, 248], "fixing_code_end_loc": [104, 252], "type": "CWE-674", "message": "In Mcrouter prior to v0.41.0, a large struct input provided to the Carbon protocol reader could result in stack exhaustion and denial of service.", "other": {"cve": {"id": "CVE-2019-11937", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-12-04T16:15:11.730", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Mcrouter prior to v0.41.0, a large struct input provided to the Carbon protocol reader could result in stack exhaustion and denial of service."}, {"lang": "es", "value": "En Mcrouter versiones anteriores a la versi\u00f3n v0.41.0, una entrada de estructura larga proporcionada al lector de protocolo Carbon podr\u00eda resultar en un agotamiento de la pila y una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:mcrouter:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.41.0", "matchCriteriaId": "66C7C178-B7FF-4E86-A9CE-1D6BBFF1783F"}]}]}], "references": [{"url": "https://github.com/facebook/mcrouter/commit/97e033b3bb0cb16b61bf49f0dc7f311a3e0edd1b", "source": "cve-assign@fb.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/facebook/mcrouter/releases/tag/v0.41.0-release", "source": "cve-assign@fb.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11937", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/mcrouter/commit/97e033b3bb0cb16b61bf49f0dc7f311a3e0edd1b"}}