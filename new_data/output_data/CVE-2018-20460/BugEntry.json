{"buggy_code": ["/* radare - LGPL - Copyright 2015-2018 - pancake */\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <r_util.h>\n\ntypedef enum optype_t {\n\tARM_NOTYPE = -1,\n\tARM_GPR = 1,\n\tARM_CONSTANT = 2,\n\tARM_FP = 4,\n\tARM_MEM_OPT = 8\n} OpType;\n\ntypedef enum regtype_t {\n\tARM_UNDEFINED = -1,\n\tARM_REG64 = 1,\n\tARM_REG32 = 2,\n\tARM_SP = 4,\n\tARM_PC = 8,\n\tARM_SIMD = 16\n} RegType;\n\ntypedef enum shifttype_t {\n\tARM_NO_SHIFT = -1,\n\tARM_LSL = 0,\n\tARM_LSR = 1,\n\tARM_ASR = 2\n} ShiftType;\n\ntypedef struct operand_t {\n\tOpType type;\n\tunion {\n\t\tstruct {\n\t\t\tint reg;\n\t\t\tRegType reg_type;\n\t\t\tut16 sp_val;\n\t\t};\n\t\tstruct {\n\t\t\tut64 immediate;\n\t\t\tint sign;\n\t\t};\n\t\tstruct {\n\t\t\tut64 shift_amount;\n\t\t\tShiftType shift;\n\t\t};\n\t\tstruct {\n\t\t\tut32 mem_option;\n\t\t};\n\t};\n} Operand;\n\n#define MAX_OPERANDS 7\n\ntypedef struct Opcode_t {\n\tchar *mnemonic;\n\tut32 op[3];\n\tsize_t op_len;\n\tut8 opcode[3];\n\tint operands_count;\n\tOperand operands[MAX_OPERANDS];\n} ArmOp;\n\nstatic int get_mem_option(char *token) {\n\t// values 4, 8, 12, are unused. XXX to adjust\n\tconst char *options[] = {\"sy\", \"st\", \"ld\", \"xxx\", \"ish\", \"ishst\",\n\t                         \"ishld\", \"xxx\", \"nsh\", \"nshst\", \"nshld\",\n\t                         \"xxx\", \"osh\", \"oshst\", \"oshld\", NULL};\n\tint i = 0;\n\twhile (options[i]) {\n\t\tif (!r_str_casecmp (token, options[i])) {\n\t\t\treturn 15 - i;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nstatic int countLeadingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x) {\n\t\tx >>= 1;\n\t\t--count;\n\t}\n\treturn count;\n}\n\nstatic int countTrailingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x > 0) {\n\t\tif ((x & 1) == 1) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcount ++;\n\t\t\tx = x >> 1;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int calcNegOffset(int n, int shift) {\n\tint a = n >> shift;\n\tif (a == 0) {\n\t\treturn 0xff;\n\t}\n\t// find first set bit then invert it and all\n\t// bits below it\n\tint t = 0x400;\n\twhile (!(t & a) && a != 0 && t != 0) {\n\t\tt = t >> 1;\n\t}\n\tt = t & (t - 1);\n\ta = a ^ t;\n\t// If bits below 32 are set\n\tif (countTrailingZeros(n) > shift) {\n\t\ta--;\n\t}\n\treturn 0xff & (0xff - a);\n}\n\nstatic int countLeadingOnes(ut32 x) {\n\treturn countLeadingZeros (~x);\n}\n\nstatic int countTrailingOnes(ut32 x) {\n\treturn countTrailingZeros (~x);\n}\n\nstatic bool isMask(ut32 value) {\n  return value && ((value + 1) & value) == 0;\n}\n\nstatic bool isShiftedMask (ut32 value) {\n  return value && isMask ((value - 1) | value);\n}\n\nstatic ut32 decodeBitMasks(ut32 imm) {\n\t// get element size\n\tint size = 32;\n\t// determine rot to make element be 0^m 1^n\n\tut32 cto, i;\n\tut32 mask = ((ut64) - 1LL) >> (64 - size);\n\n\tif (isShiftedMask (imm)) {\n\t\ti = countTrailingZeros (imm);\n\t\tcto = countTrailingOnes (imm >> i);\n\t} else {\n\t\timm |= ~mask;\n\t\tif (!isShiftedMask (imm)) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tut32 clo = countLeadingOnes (imm);\n\t\ti = 64 - clo;\n\t\tcto = clo + countTrailingOnes (imm) - (64 - size);\n\t}\n\n\t// Encode in Immr the number of RORs it would take to get *from* 0^m 1^n\n\t// to our target value, where I is the number of RORs to go the opposite\n\t// direction\n\tut32 immr = (size - i) & (size - 1);\n\t// If size has a 1 in the n'th bit, create a value that has zeroes in\n\t// bits [0, n] and ones above that.\n\tut64 nimms = ~(size - 1) << 1;\n\t// Or the cto value into the low bits, which must be below the Nth bit\n\t// bit mentioned above.\n\tnimms |= (cto - 1);\n\t// Extract and toggle seventh bit to make N field.\n\tut32 n = ((nimms >> 6) & 1) ^ 1;\n\tut64 encoding = (n << 12) | (immr << 6) | (nimms & 0x3f);\n\treturn encoding;\n}\n\nstatic ut32 mov(ArmOp *op) {\n\tint k = 0;\n\tut32 data = UT32_MAX;\n\tif (!strncmp (op->mnemonic, \"movz\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80d2;\n\t\t} else if (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8052;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movk\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8072;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80f2;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movn\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8012;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x8092;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"mov\", 3)) {\n\t\t//printf (\"%d - %d [%d]\\n\", op->operands[0].type, op->operands[1].type, ARM_GPR);\n\t\tif (op->operands[0].type & ARM_GPR) {\n\t\t\tif (op->operands[1].type & ARM_GPR) {\n\t\t\t\tif (op->operands[1].reg_type & ARM_REG64) {\n\t\t\t\t\tk = 0xe00300aa;\n\t\t\t\t} else {\n\t\t\t\t\tk = 0xe003002a;\n\t\t\t\t}\n\t\t\t\tdata = k | op->operands[1].reg << 8;\n\t\t\t} else if (op->operands[1].type & ARM_CONSTANT) {\n\t\t\t\tk = 0x80d2;\n\t\t\t\tdata = k | op->operands[1].immediate << 29;\n\t\t\t}\n\t\t\tdata |=  op->operands[0].reg << 24;\n\t\t}\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata |= (op->operands[0].reg << 24); // arg(0)\n\tdata |= ((op->operands[1].immediate & 7) << 29); // arg(1)\n\tdata |= (((op->operands[1].immediate >> 3) & 0xff) << 16); // arg(1)\n\tdata |= ((op->operands[1].immediate >> 10) << 7); // arg(1)\n\treturn data;\n}\n\nstatic ut32 cmp(ArmOp *op) {\n\tut32 data = UT32_MAX;\n\tint k = 0;\n\tif (op->operands[0].reg_type & ARM_REG64 && op->operands[1].reg_type & ARM_REG64) {\n\t\tk =  0x1f0000eb;\n\t} else if (op->operands[0].reg_type & ARM_REG32 && op->operands[1].reg_type & ARM_REG32) {\n\t\tif (op->operands[2].shift_amount > 31) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t\tk =  0x1f00006b;\n\t} else {\n\t\treturn UT32_MAX;\n\t}\n\n\tdata = k | (op->operands[0].reg & 0x18) << 13 | op->operands[0].reg << 29 | op->operands[1].reg << 8;\n\n\tif (op->operands[2].shift != ARM_NO_SHIFT) {\n\t\tdata |= op->operands[2].shift_amount << 18 | op->operands[2].shift << 14;\n\t}\n\treturn data;\n}\n\n\nstatic ut32 regsluop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xff || n < -0x100) {\n\t\treturn data;\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tif (n < 0) {\n\t\tn *= -1;\n\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\n\t\tif (countTrailingZeros(n) > 3) {\n\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t} else {\n\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t}\n\t} else {\n\t\tdata |= (0xf & (n & 63)) << 20;\n\t\tif (countTrailingZeros(n) < 4) {\n\t\t\tdata |= (n >> 4) << 8;\n\t\t} else {\n\t\t\tdata |= (0xff & n) << 4;\n\t\t}\n\t\tdata |= (n >> 8) << 8;\n\t}\n\n\treturn data;\n}\n\n// Register Load/store ops\nstatic ut32 reglsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t} else {\n\t\tint n = op->operands[2].immediate;\n\t\tif (n > 0x100 || n < -0x100) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tif (n == 0 || (n > 0 && countTrailingZeros(n) >= 4)) {\n\t\t\tk ++;\n\t\t}\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\t\t\tif (countTrailingZeros(n) > 3) {\n\t\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t\t}\n\t\t} else {\n\t\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\t\tif (countTrailingZeros(n) < 2) {\n\t\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\t\tdata++;\n\t\t\t\t\t\tdata |= (0xff & n) << 16;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\tif (countTrailingZeros(n) < 4) {\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\tdata |= (0xff & n) << 15;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 23;\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n\n// Byte load/store ops\nstatic ut32 bytelsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\treturn data;\n\t}\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tif ((k & 0xf) != 8) {\n\t\t\tk--;\n\t\t}\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xfff || n < -0x100) {\n\t\treturn UT32_MAX;\n\t}\n\t// Half ops\n\tint halfop = false;\n\tif ((k & 0xf) == 8) {\n\t\thalfop = true;\n\t\tif (n == 0 || (countTrailingZeros(n) && n > 0)) {\n\t\t\tk++;\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tk--;\n\t\t}\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tint imm = n;\n\tint low_shift = 20;\n\tint high_shift = 8;\n\tint top_shift = 10;\n\tif (n < 0) {\n\t\timm = 0xfff + (n + 1);\n\t}\n\tif (halfop) {\n\t\tif (imm & 0x1 || n < 0) {\n\t\t\tdata |= (0xf & imm) << low_shift ;\n\t\t\tdata |= (0x7 & (imm >> 4)) << high_shift;\n\t\t\tdata |= (0x7 & (imm >> 6)) << top_shift;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << (low_shift - 3);\n\t\t\tdata |= (0x7 & (imm >> 4)) << (high_shift + 13);\n\t\t\tdata |= (0x7 & (imm >> 7)) << (top_shift  - 2);\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tdata |= (0xf & imm) << 20;\n\t\t\tdata |= (0x1f & (imm >> 4)) << 8;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << 18;\n\t\t\tdata |= (0x3 & (imm >> 4)) << 22;\n\t\t\tdata |= (0x7 & (imm >> 6)) << 8;\n\t\t}\n\t}\n\treturn data;\n}\n\nstatic ut32 branch(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tif (op->operands[0].type & ARM_CONSTANT) {\n\t\tn = op->operands[0].immediate;\n\t\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\t\tn -= addr;\n\t\t\tn = n >> 2;\n\t\t\tint t = n >> 24;\n\t\t\tint h = n >> 16;\n\t\t\tint m = (n & 0xff00) >> 8;\n\t\t\tn &= 0xff;\n\t\t\tdata = k;\n\t\t\tdata |= n << 24;\n\t\t\tdata |= m << 16;\n\t\t\tdata |= h << 8;\n\t\t\tdata |= t;\n\t\t}\n\t} else {\n\t\tn = op->operands[0].reg;\n\t\tif (n < 0 || n > 31) {\n\t\t\treturn -1;\n\t\t}\n\t\tn = n << 5;\n\t\tint h = n >> 8;\n\t\tn &= 0xff;\n\t\tdata = k;\n\t\tdata |= n << 24;\n\t\tdata |= h << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 bdot(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tint a = 0;\n\tn = op->operands[0].immediate;\n\t// I am sure there's a logical way to do negative offsets,\n\t// but I was unable to find any sensible docs so I did my best\n\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\tn -= addr;\n\t\tdata = k;\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\ta = (n << 3) - 1;\n\t\t\tdata |= (0xff - a) << 24;\n\n\t\t\ta = calcNegOffset(n, 5);\n\t\t\tdata |= a << 16;\n\n\t\t\ta = calcNegOffset(n, 13);\n\t\t\tdata |= a << 8;\n\t\t} else {\n\t\t\tdata |= (n & 31) << 27;\n\t\t\tdata |= (0xff & (n >> 5)) << 16;\n\t\t\tdata |= (0xff & (n >> 13)) << 8;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nstatic ut32 mem_barrier (ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tdata = k;\n\tif (!strncmp (op->mnemonic, \"isb\", 3)) {\n\t\tif (op->operands[0].mem_option == 15 || op->operands[0].type == ARM_NOTYPE) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t}\n\tif (op->operands[0].type == ARM_MEM_OPT) {\n\t\tdata |= op->operands[0].mem_option << 16;\n\t} else if (op->operands_count == 1 && op->operands[0].type == ARM_CONSTANT) {\n\t\tdata |= (op->operands[0].immediate << 16);\n\t}\n\treturn data;\n}\n\n#include \"armass64_const.h\"\n\nstatic ut32 msrk(ut16 v) {\n\tut32 r = 0;\n\tut32 a = ((v >> 12) & 0xf) << 1;\n\tut32 b = ((v & 0xfff) >> 3) & 0xff;\n\tr |= a << 8;\n\tr |= b << 16;\n\treturn r;\n}\n\nstatic ut32 msr(ArmOp *op, int w) {\n\tut32 data = UT32_MAX;\n\tint i;\n\tut32 r, b;\n\t/* handle swapped args */\n\tif (w) {\n\t\tif (op->operands[1].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[1].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[1].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[1].reg = op->operands[1].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t} else {\n\t\tif (op->operands[0].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[0].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[0].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[0].reg = op->operands[0].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t}\n\tdata = (r << 24) | b | 0xd5;\n\tif (w) {\n\t\t/* mrs */\n\t\tdata |= 0x413000;\n\t}\n\tif (op->operands[1].reg_type == ARM_REG64) {\n\t\tdata |= op->operands[1].reg << 24;\n\t}\n\n\treturn data;\n}\n\nstatic ut32 orr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[2].type & ARM_GPR) {\n\t\t// All operands need to be the same\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type &&\n\t \t    op->operands[1].reg_type == op->operands[2].reg_type)) {\n\t\t \t   return data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000000aa;\n\t\t} else {\n\t\t\tdata = 0x0000002a;\n\t\t}\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\t\tdata += op->operands[2].reg << 8;\n\t} else if (op->operands[2].type & ARM_CONSTANT) {\n\t\t// Reg types need to match\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type)) {\n\t\t\treturn data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000040b2;\n\t\t} else {\n\t\t\tdata = 0x00000032;\n\t\t}\n\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\n\t\tut32 imm = decodeBitMasks (op->operands[2].immediate);\n\t\tif (imm == -1) {\n\t\t\treturn imm;\n\t\t}\n\t\tint low = imm & 0xF;\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\timm = ((imm >> 6) | 0x78);\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 8;\n\t\t\t}\n\t\t} else {\n\t\t\timm = ((imm >> 2));\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 4;\n\t\t\t}\n\t\t}\n\t\tdata |= (4 * low) << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 adrp(ArmOp *op, ut64 addr, ut32 k) { //, int reg, ut64 dst) {\n\tut64 at = 0LL;\n\tut32 data = k;\n\tif (op->operands[0].type == ARM_GPR) {\n\t\tdata += ((op->operands[0].reg & 0xff) << 24);\n\t} else {\n\t\teprintf (\"Usage: adrp x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t} else {\n\t\teprintf (\"Usage: adrp, x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\n#if 0\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n#endif\n\tdata += b0 << 16;\n\tdata += b1 << 8;\n\treturn data;\n}\n\nstatic ut32 adr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\tut64 at = 0LL;\n\n\tif (op->operands[1].type & ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t}\n\tdata = 0x00000030;\n\tdata += 0x01000000 * op->operands[0].reg;\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n\treturn data;\n}\n\nstatic ut32 stp(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[3].immediate & 0x7) {\n\t\treturn data;\n\t}\n\tif (k == 0x000040a9 && (op->operands[0].reg == op->operands[1].reg)) {\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += op->operands[1].reg << 18;\n\tdata += (op->operands[2].reg & 0x7) << 29;\n\tdata += (op->operands[2].reg >> 3) << 16;\n\tdata += (op->operands[3].immediate & 0x8) << 20;\n\tdata += (op->operands[3].immediate >> 4) << 8;\n\treturn data;\n}\n\nstatic ut32 exception(ArmOp *op, ut32 k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\tint n = op->operands[0].immediate;\n\t\tdata = k;\n\t\tdata += (((n / 8) & 0xff) << 16);\n\t\tdata += n << 29;//((n >> 8) << 8);\n\t}\n\treturn data;\n}\n\nstatic ut32 arithmetic (ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\tif (op->operands_count < 3) {\n\t\treturn data;\n\t}\n\n\tif (!(op->operands[0].type & ARM_GPR &&\n\t      op->operands[1].type & ARM_GPR)) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk -= 6;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += (op->operands[1].reg & 7) << (24 + 5);\n\tdata += (op->operands[1].reg >> 3) << 16;\n\tif (op->operands[2].reg_type & ARM_REG64) {\n\t\tdata += op->operands[2].reg << 8;\n\t} else {\n\t\tdata += (op->operands[2].reg & 0x3f) << 18;\n\t\tdata += (op->operands[2].reg >> 6) << 8;\n\t}\n\treturn data;\n}\n\nstatic bool parseOperands(char* str, ArmOp *op) {\n\tchar *t = strdup (str);\n\tint operand = 0;\n\tchar *token = t;\n\tchar *x;\n\tint imm_count = 0;\n\tint mem_opt = 0;\n\tif (!token) {\n\t\treturn false;\n\t}\n\n\twhile (token) {\n\t\tchar *next = strchr (token, ',');\n\t\tif (next) {\n\t\t\t*next++ = 0;\n\t\t}\n\t\twhile (token[0] == ' ') {\n\t\t\ttoken++;\n\t\t}\n\t\top->operands[operand].type = ARM_NOTYPE;\n\t\top->operands[operand].reg_type = ARM_UNDEFINED;\n\t\top->operands[operand].shift = ARM_NO_SHIFT;\n\n\t\twhile (token[0] == ' ' || token[0] == '[' || token[0] == ']') {\n\t\t\ttoken ++;\n\t\t}\n\n\t\tif (!strncmp (token, \"lsl\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSL;\n\t\t} else if (!strncmp (token, \"lsr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSR;\n\t\t} else if (!strncmp (token, \"asr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_ASR;\n\t\t}\n\t\tif (op->operands[operand].shift != ARM_NO_SHIFT) {\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n\t\t\tif (op->operands[operand].shift_amount > 63) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\toperand ++;\n\t\t\ttoken = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (token[0]) {\n\t\tcase 'x':\n\t\t\tx = strchr (token, ',');\n\t\t\tif (x) {\n\t\t\t\tx[0] = '\\0';\n\t\t\t}\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG64;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG32;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_FP;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (token[1] == 'P' || token [1] == 'p') {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {\n\t\t\t\t\t\top->operands[operand].sp_val = msr_const[i].val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\t\top->operands[operand].reg_type = ARM_SP | ARM_REG64;\n\t\t\t\top->operands[operand].reg = 31;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\tcase 'l':\n\t\tcase 'I':\n\t\tcase 'i':\n\t\tcase 'N':\n\t\tcase 'n':\n\t\tcase 'O':\n\t\tcase 'o':\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\top->operands[operand].sign = -1;\n\t\t\t// falthru\n\t\tdefault:\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_CONSTANT;\n\t\t\top->operands[operand].immediate = r_num_math (NULL, token);\n\t\t\timm_count++;\n\t\t\tbreak;\n\t\t}\n\t\ttoken = next;\n\n\t\toperand ++;\n\t\tif (operand > MAX_OPERANDS) {\n\t\t\tfree (t);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic bool parseOpcode(const char *str, ArmOp *op) {\n\tchar *in = strdup (str);\n\tchar *space = strchr (in, ' ');\n\tif (!space) {\n\t\top->operands[0].type = ARM_NOTYPE;\n\t\top->mnemonic = in;\n \t\treturn true;\n\t}\n\tspace[0] = '\\0';\n\top->mnemonic = in;\n\tspace ++;\n\treturn parseOperands (space, op);\n}\n\nbool arm64ass(const char *str, ut64 addr, ut32 *op) {\n\tArmOp ops = {0};\n\tif (!parseOpcode (str, &ops)) {\n\t\treturn false;\n\t}\n\t/* TODO: write tests for this and move out the regsize logic into the mov */\n\tif (!strncmp (str, \"mov\", 3)) {\n\t\t*op = mov (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"cmp\", 3)) {\n\t\t*op = cmp (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsh\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsw\", 5)) {\n\t\t*op = bytelsop (&ops, 0x000080b8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsb\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldr\", 3)) {\n\t\t*op = reglsop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"str\", 3)) {\n\t\t*op = reglsop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stp\", 3)) {\n\t\t*op = stp (&ops, 0x000000a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldp\", 3)) {\n\t\t*op = stp (&ops, 0x000040a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"sub\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0xd1);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"add\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0x91);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adr x\", 5)) { // w\n\t\t*op = adr (&ops, addr);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adrp x\", 6)) {\n\t\t*op = adrp (&ops, addr, 0x00000090);\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"isb\")) {\n\t\t*op = 0xdf3f03d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"nop\")) {\n\t\t*op = 0x1f2003d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"ret\")) {\n\t\t*op = 0xc0035fd6;\n\t\treturn true;\n\t}\n\tif (!strncmp (str, \"msr \", 4)) {\n\t\t*op = msr (&ops, 0);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"mrs \", 4)) {\n\t\t*op = msr (&ops, 1);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"orr \", 4)) {\n\t\t*op = orr (&ops, addr);\n\t\treturn *op != UT32_MAX;\n\t}\n\tif (!strncmp (str, \"svc \", 4)) { // system level exception\n\t\t*op = exception (&ops, 0x010000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hvc \", 4)) { // hypervisor level exception\n\t\t*op = exception (&ops, 0x020000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"smc \", 4)) { // secure monitor exception\n\t\t*op = exception (&ops, 0x030000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"brk \", 4)) { // breakpoint\n\t\t*op = exception (&ops, 0x000020d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hlt \", 4)) { // halt\n\t\t*op = exception (&ops, 0x000040d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b \", 2)) {\n\t\t*op = branch (&ops, addr, 0x14);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.eq \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x00000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.hs \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x02000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"bl \", 3)) {\n\t\t*op = branch (&ops, addr, 0x94);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"br x\", 4)) {\n\t\t*op = branch (&ops, addr, 0x1fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"blr x\", 5)) {\n\t\t*op = branch (&ops, addr, 0x3fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dmb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0xbf3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dsb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0x9f3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"isb\", 3)) {\n\t\t*op = mem_barrier (&ops, addr, 0xdf3f03d5);\n\t\treturn *op != -1;\n\t}\n\treturn false;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2015-2018 - pancake */\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <r_util.h>\n\ntypedef enum optype_t {\n\tARM_NOTYPE = -1,\n\tARM_GPR = 1,\n\tARM_CONSTANT = 2,\n\tARM_FP = 4,\n\tARM_MEM_OPT = 8\n} OpType;\n\ntypedef enum regtype_t {\n\tARM_UNDEFINED = -1,\n\tARM_REG64 = 1,\n\tARM_REG32 = 2,\n\tARM_SP = 4,\n\tARM_PC = 8,\n\tARM_SIMD = 16\n} RegType;\n\ntypedef enum shifttype_t {\n\tARM_NO_SHIFT = -1,\n\tARM_LSL = 0,\n\tARM_LSR = 1,\n\tARM_ASR = 2\n} ShiftType;\n\ntypedef struct operand_t {\n\tOpType type;\n\tunion {\n\t\tstruct {\n\t\t\tint reg;\n\t\t\tRegType reg_type;\n\t\t\tut16 sp_val;\n\t\t};\n\t\tstruct {\n\t\t\tut64 immediate;\n\t\t\tint sign;\n\t\t};\n\t\tstruct {\n\t\t\tut64 shift_amount;\n\t\t\tShiftType shift;\n\t\t};\n\t\tstruct {\n\t\t\tut32 mem_option;\n\t\t};\n\t};\n} Operand;\n\n#define MAX_OPERANDS 7\n\ntypedef struct Opcode_t {\n\tchar *mnemonic;\n\tut32 op[3];\n\tsize_t op_len;\n\tut8 opcode[3];\n\tint operands_count;\n\tOperand operands[MAX_OPERANDS];\n} ArmOp;\n\nstatic int get_mem_option(char *token) {\n\t// values 4, 8, 12, are unused. XXX to adjust\n\tconst char *options[] = {\"sy\", \"st\", \"ld\", \"xxx\", \"ish\", \"ishst\",\n\t                         \"ishld\", \"xxx\", \"nsh\", \"nshst\", \"nshld\",\n\t                         \"xxx\", \"osh\", \"oshst\", \"oshld\", NULL};\n\tint i = 0;\n\twhile (options[i]) {\n\t\tif (!r_str_casecmp (token, options[i])) {\n\t\t\treturn 15 - i;\n\t\t}\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nstatic int countLeadingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x) {\n\t\tx >>= 1;\n\t\t--count;\n\t}\n\treturn count;\n}\n\nstatic int countTrailingZeros(ut32 x) {\n\tint count = 0;\n\twhile (x > 0) {\n\t\tif ((x & 1) == 1) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcount ++;\n\t\t\tx = x >> 1;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic int calcNegOffset(int n, int shift) {\n\tint a = n >> shift;\n\tif (a == 0) {\n\t\treturn 0xff;\n\t}\n\t// find first set bit then invert it and all\n\t// bits below it\n\tint t = 0x400;\n\twhile (!(t & a) && a != 0 && t != 0) {\n\t\tt = t >> 1;\n\t}\n\tt = t & (t - 1);\n\ta = a ^ t;\n\t// If bits below 32 are set\n\tif (countTrailingZeros(n) > shift) {\n\t\ta--;\n\t}\n\treturn 0xff & (0xff - a);\n}\n\nstatic int countLeadingOnes(ut32 x) {\n\treturn countLeadingZeros (~x);\n}\n\nstatic int countTrailingOnes(ut32 x) {\n\treturn countTrailingZeros (~x);\n}\n\nstatic bool isMask(ut32 value) {\n  return value && ((value + 1) & value) == 0;\n}\n\nstatic bool isShiftedMask (ut32 value) {\n  return value && isMask ((value - 1) | value);\n}\n\nstatic ut32 decodeBitMasks(ut32 imm) {\n\t// get element size\n\tint size = 32;\n\t// determine rot to make element be 0^m 1^n\n\tut32 cto, i;\n\tut32 mask = ((ut64) - 1LL) >> (64 - size);\n\n\tif (isShiftedMask (imm)) {\n\t\ti = countTrailingZeros (imm);\n\t\tcto = countTrailingOnes (imm >> i);\n\t} else {\n\t\timm |= ~mask;\n\t\tif (!isShiftedMask (imm)) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tut32 clo = countLeadingOnes (imm);\n\t\ti = 64 - clo;\n\t\tcto = clo + countTrailingOnes (imm) - (64 - size);\n\t}\n\n\t// Encode in Immr the number of RORs it would take to get *from* 0^m 1^n\n\t// to our target value, where I is the number of RORs to go the opposite\n\t// direction\n\tut32 immr = (size - i) & (size - 1);\n\t// If size has a 1 in the n'th bit, create a value that has zeroes in\n\t// bits [0, n] and ones above that.\n\tut64 nimms = ~(size - 1) << 1;\n\t// Or the cto value into the low bits, which must be below the Nth bit\n\t// bit mentioned above.\n\tnimms |= (cto - 1);\n\t// Extract and toggle seventh bit to make N field.\n\tut32 n = ((nimms >> 6) & 1) ^ 1;\n\tut64 encoding = (n << 12) | (immr << 6) | (nimms & 0x3f);\n\treturn encoding;\n}\n\nstatic ut32 mov(ArmOp *op) {\n\tint k = 0;\n\tut32 data = UT32_MAX;\n\tif (!strncmp (op->mnemonic, \"movz\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80d2;\n\t\t} else if (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8052;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movk\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8072;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x80f2;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"movn\", 4)) {\n\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\tk = 0x8012;\n\t\t} else if (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tk = 0x8092;\n\t\t}\n\t} else if (!strncmp (op->mnemonic, \"mov\", 3)) {\n\t\t//printf (\"%d - %d [%d]\\n\", op->operands[0].type, op->operands[1].type, ARM_GPR);\n\t\tif (op->operands[0].type & ARM_GPR) {\n\t\t\tif (op->operands[1].type & ARM_GPR) {\n\t\t\t\tif (op->operands[1].reg_type & ARM_REG64) {\n\t\t\t\t\tk = 0xe00300aa;\n\t\t\t\t} else {\n\t\t\t\t\tk = 0xe003002a;\n\t\t\t\t}\n\t\t\t\tdata = k | op->operands[1].reg << 8;\n\t\t\t} else if (op->operands[1].type & ARM_CONSTANT) {\n\t\t\t\tk = 0x80d2;\n\t\t\t\tdata = k | op->operands[1].immediate << 29;\n\t\t\t}\n\t\t\tdata |=  op->operands[0].reg << 24;\n\t\t}\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata |= (op->operands[0].reg << 24); // arg(0)\n\tdata |= ((op->operands[1].immediate & 7) << 29); // arg(1)\n\tdata |= (((op->operands[1].immediate >> 3) & 0xff) << 16); // arg(1)\n\tdata |= ((op->operands[1].immediate >> 10) << 7); // arg(1)\n\treturn data;\n}\n\nstatic ut32 cmp(ArmOp *op) {\n\tut32 data = UT32_MAX;\n\tint k = 0;\n\tif (op->operands[0].reg_type & ARM_REG64 && op->operands[1].reg_type & ARM_REG64) {\n\t\tk =  0x1f0000eb;\n\t} else if (op->operands[0].reg_type & ARM_REG32 && op->operands[1].reg_type & ARM_REG32) {\n\t\tif (op->operands[2].shift_amount > 31) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t\tk =  0x1f00006b;\n\t} else {\n\t\treturn UT32_MAX;\n\t}\n\n\tdata = k | (op->operands[0].reg & 0x18) << 13 | op->operands[0].reg << 29 | op->operands[1].reg << 8;\n\n\tif (op->operands[2].shift != ARM_NO_SHIFT) {\n\t\tdata |= op->operands[2].shift_amount << 18 | op->operands[2].shift << 14;\n\t}\n\treturn data;\n}\n\n\nstatic ut32 regsluop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xff || n < -0x100) {\n\t\treturn data;\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tif (n < 0) {\n\t\tn *= -1;\n\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\n\t\tif (countTrailingZeros(n) > 3) {\n\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t} else {\n\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t}\n\t} else {\n\t\tdata |= (0xf & (n & 63)) << 20;\n\t\tif (countTrailingZeros(n) < 4) {\n\t\t\tdata |= (n >> 4) << 8;\n\t\t} else {\n\t\t\tdata |= (0xff & n) << 4;\n\t\t}\n\t\tdata |= (n >> 8) << 8;\n\t}\n\n\treturn data;\n}\n\n// Register Load/store ops\nstatic ut32 reglsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\tk -= 0x40;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t} else {\n\t\tint n = op->operands[2].immediate;\n\t\tif (n > 0x100 || n < -0x100) {\n\t\t\treturn UT32_MAX;\n\t\t}\n\n\t\tif (n == 0 || (n > 0 && countTrailingZeros(n) >= 4)) {\n\t\t\tk ++;\n\t\t}\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\tdata |= ( 0xf & (0xf - (n - 1)) ) << 20;\n\t\t\tif (countTrailingZeros(n) > 3) {\n\t\t\t\tdata |= (0x1f - ((n >> 4) - 1)) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0x1f - (n >> 4)) << 8;\n\t\t\t}\n\t\t} else {\n\t\t\tif (op->operands[0].reg_type & ARM_REG32) {\n\t\t\t\tif (countTrailingZeros(n) < 2) {\n\t\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\t\tdata++;\n\t\t\t\t\t\tdata |= (0xff & n) << 16;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 8;\n\t\t\t} else {\n\t\t\t\tdata |= (0xf & (n & 63)) << 20;\n\t\t\t\tif (countTrailingZeros(n) < 4) {\n\t\t\t\t\tdata |= (n >> 4) << 8;\n\t\t\t\t} else {\n\t\t\t\t\tdata |= (0xff & n) << 15;\n\t\t\t\t}\n\t\t\t\tdata |= (n >> 8) << 23;\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n\n// Byte load/store ops\nstatic ut32 bytelsop(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\treturn data;\n\t}\n\tif (op->operands[1].reg_type & ARM_REG32) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tif ((k & 0xf) != 8) {\n\t\t\tk--;\n\t\t}\n\t\tk += 0x00682000;\n\t\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\t\tdata |= op->operands[2].reg << 8;\n\t\treturn data;\n\t}\n\n\tint n = op->operands[2].immediate;\n\tif (n > 0xfff || n < -0x100) {\n\t\treturn UT32_MAX;\n\t}\n\t// Half ops\n\tint halfop = false;\n\tif ((k & 0xf) == 8) {\n\t\thalfop = true;\n\t\tif (n == 0 || (countTrailingZeros(n) && n > 0)) {\n\t\t\tk++;\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tk--;\n\t\t}\n\t}\n\n\tdata = k | op->operands[0].reg << 24 | op->operands[1].reg << 29 | (op->operands[1].reg & 56) << 13;\n\n\tint imm = n;\n\tint low_shift = 20;\n\tint high_shift = 8;\n\tint top_shift = 10;\n\tif (n < 0) {\n\t\timm = 0xfff + (n + 1);\n\t}\n\tif (halfop) {\n\t\tif (imm & 0x1 || n < 0) {\n\t\t\tdata |= (0xf & imm) << low_shift ;\n\t\t\tdata |= (0x7 & (imm >> 4)) << high_shift;\n\t\t\tdata |= (0x7 & (imm >> 6)) << top_shift;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << (low_shift - 3);\n\t\t\tdata |= (0x7 & (imm >> 4)) << (high_shift + 13);\n\t\t\tdata |= (0x7 & (imm >> 7)) << (top_shift  - 2);\n\t\t}\n\t} else {\n\t\tif (n < 0) {\n\t\t\tdata |= (0xf & imm) << 20;\n\t\t\tdata |= (0x1f & (imm >> 4)) << 8;\n\t\t} else {\n\t\t\tdata |= (0xf & imm) << 18;\n\t\t\tdata |= (0x3 & (imm >> 4)) << 22;\n\t\t\tdata |= (0x7 & (imm >> 6)) << 8;\n\t\t}\n\t}\n\treturn data;\n}\n\nstatic ut32 branch(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tif (op->operands[0].type & ARM_CONSTANT) {\n\t\tn = op->operands[0].immediate;\n\t\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\t\tn -= addr;\n\t\t\tn = n >> 2;\n\t\t\tint t = n >> 24;\n\t\t\tint h = n >> 16;\n\t\t\tint m = (n & 0xff00) >> 8;\n\t\t\tn &= 0xff;\n\t\t\tdata = k;\n\t\t\tdata |= n << 24;\n\t\t\tdata |= m << 16;\n\t\t\tdata |= h << 8;\n\t\t\tdata |= t;\n\t\t}\n\t} else {\n\t\tn = op->operands[0].reg;\n\t\tif (n < 0 || n > 31) {\n\t\t\treturn -1;\n\t\t}\n\t\tn = n << 5;\n\t\tint h = n >> 8;\n\t\tn &= 0xff;\n\t\tdata = k;\n\t\tdata |= n << 24;\n\t\tdata |= h << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 bdot(ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tint n = 0;\n\tint a = 0;\n\tn = op->operands[0].immediate;\n\t// I am sure there's a logical way to do negative offsets,\n\t// but I was unable to find any sensible docs so I did my best\n\tif (!(n & 0x3 || n > 0x7ffffff)) {\n\t\tn -= addr;\n\t\tdata = k;\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\ta = (n << 3) - 1;\n\t\t\tdata |= (0xff - a) << 24;\n\n\t\t\ta = calcNegOffset(n, 5);\n\t\t\tdata |= a << 16;\n\n\t\t\ta = calcNegOffset(n, 13);\n\t\t\tdata |= a << 8;\n\t\t} else {\n\t\t\tdata |= (n & 31) << 27;\n\t\t\tdata |= (0xff & (n >> 5)) << 16;\n\t\t\tdata |= (0xff & (n >> 13)) << 8;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nstatic ut32 mem_barrier (ArmOp *op, ut64 addr, int k) {\n\tut32 data = UT32_MAX;\n\tdata = k;\n\tif (!strncmp (op->mnemonic, \"isb\", 3)) {\n\t\tif (op->operands[0].mem_option == 15 || op->operands[0].type == ARM_NOTYPE) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\treturn UT32_MAX;\n\t\t}\n\t}\n\tif (op->operands[0].type == ARM_MEM_OPT) {\n\t\tdata |= op->operands[0].mem_option << 16;\n\t} else if (op->operands_count == 1 && op->operands[0].type == ARM_CONSTANT) {\n\t\tdata |= (op->operands[0].immediate << 16);\n\t}\n\treturn data;\n}\n\n#include \"armass64_const.h\"\n\nstatic ut32 msrk(ut16 v) {\n\tut32 r = 0;\n\tut32 a = ((v >> 12) & 0xf) << 1;\n\tut32 b = ((v & 0xfff) >> 3) & 0xff;\n\tr |= a << 8;\n\tr |= b << 16;\n\treturn r;\n}\n\nstatic ut32 msr(ArmOp *op, int w) {\n\tut32 data = UT32_MAX;\n\tint i;\n\tut32 r, b;\n\t/* handle swapped args */\n\tif (w) {\n\t\tif (op->operands[1].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[1].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[1].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[1].reg = op->operands[1].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t} else {\n\t\tif (op->operands[0].reg_type != (ARM_REG64 | ARM_SP)) {\n\t\t\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (op->operands[0].immediate == msr_const[i].val) {\n\t\t\t\t\t\top->operands[0].sp_val = msr_const[i].val;\n\t\t\t\t\t\top->operands[0].reg = op->operands[0].immediate;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t\tr = op->operands[0].reg;\n\t\tb = msrk (op->operands[0].sp_val);\n\t}\n\tdata = (r << 24) | b | 0xd5;\n\tif (w) {\n\t\t/* mrs */\n\t\tdata |= 0x413000;\n\t}\n\tif (op->operands[1].reg_type == ARM_REG64) {\n\t\tdata |= op->operands[1].reg << 24;\n\t}\n\n\treturn data;\n}\n\nstatic ut32 orr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[2].type & ARM_GPR) {\n\t\t// All operands need to be the same\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type &&\n\t \t    op->operands[1].reg_type == op->operands[2].reg_type)) {\n\t\t \t   return data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000000aa;\n\t\t} else {\n\t\t\tdata = 0x0000002a;\n\t\t}\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\t\tdata += op->operands[2].reg << 8;\n\t} else if (op->operands[2].type & ARM_CONSTANT) {\n\t\t// Reg types need to match\n\t\tif (!(op->operands[0].reg_type == op->operands[1].reg_type)) {\n\t\t\treturn data;\n\t\t}\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\tdata = 0x000040b2;\n\t\t} else {\n\t\t\tdata = 0x00000032;\n\t\t}\n\n\t\tdata += op->operands[0].reg << 24;\n\t\tdata += op->operands[1].reg << 29;\n\t\tdata += (op->operands[1].reg >> 3)  << 16;\n\n\t\tut32 imm = decodeBitMasks (op->operands[2].immediate);\n\t\tif (imm == -1) {\n\t\t\treturn imm;\n\t\t}\n\t\tint low = imm & 0xF;\n\t\tif (op->operands[0].reg_type & ARM_REG64) {\n\t\t\timm = ((imm >> 6) | 0x78);\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 8;\n\t\t\t}\n\t\t} else {\n\t\t\timm = ((imm >> 2));\n\t\t\tif (imm > 120) {\n\t\t\t\tdata |= imm << 4;\n\t\t\t}\n\t\t}\n\t\tdata |= (4 * low) << 16;\n\t}\n\treturn data;\n}\n\nstatic ut32 adrp(ArmOp *op, ut64 addr, ut32 k) { //, int reg, ut64 dst) {\n\tut64 at = 0LL;\n\tut32 data = k;\n\tif (op->operands[0].type == ARM_GPR) {\n\t\tdata += ((op->operands[0].reg & 0xff) << 24);\n\t} else {\n\t\teprintf (\"Usage: adrp x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tif (op->operands[1].type == ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t} else {\n\t\teprintf (\"Usage: adrp, x0, addr\\n\");\n\t\treturn UT32_MAX;\n\t}\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\n#if 0\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n#endif\n\tdata += b0 << 16;\n\tdata += b1 << 8;\n\treturn data;\n}\n\nstatic ut32 adr(ArmOp *op, int addr) {\n\tut32 data = UT32_MAX;\n\tut64 at = 0LL;\n\n\tif (op->operands[1].type & ARM_CONSTANT) {\n\t\t// XXX what about negative values?\n\t\tat = op->operands[1].immediate - addr;\n\t\tat /= 4;\n\t}\n\tdata = 0x00000030;\n\tdata += 0x01000000 * op->operands[0].reg;\n\tut8 b0 = at;\n\tut8 b1 = (at >> 3) & 0xff;\n\tut8 b2 = (at >> (8 + 7)) & 0xff;\n\tdata += b0 << 29;\n\tdata += b1 << 16;\n\tdata += b2 << 24;\n\treturn data;\n}\n\nstatic ut32 stp(ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[3].immediate & 0x7) {\n\t\treturn data;\n\t}\n\tif (k == 0x000040a9 && (op->operands[0].reg == op->operands[1].reg)) {\n\t\treturn data;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += op->operands[1].reg << 18;\n\tdata += (op->operands[2].reg & 0x7) << 29;\n\tdata += (op->operands[2].reg >> 3) << 16;\n\tdata += (op->operands[3].immediate & 0x8) << 20;\n\tdata += (op->operands[3].immediate >> 4) << 8;\n\treturn data;\n}\n\nstatic ut32 exception(ArmOp *op, ut32 k) {\n\tut32 data = UT32_MAX;\n\n\tif (op->operands[0].type == ARM_CONSTANT) {\n\t\tint n = op->operands[0].immediate;\n\t\tdata = k;\n\t\tdata += (((n / 8) & 0xff) << 16);\n\t\tdata += n << 29;//((n >> 8) << 8);\n\t}\n\treturn data;\n}\n\nstatic ut32 arithmetic (ArmOp *op, int k) {\n\tut32 data = UT32_MAX;\n\tif (op->operands_count < 3) {\n\t\treturn data;\n\t}\n\n\tif (!(op->operands[0].type & ARM_GPR &&\n\t      op->operands[1].type & ARM_GPR)) {\n\t\treturn data;\n\t}\n\tif (op->operands[2].type & ARM_GPR) {\n\t\tk -= 6;\n\t}\n\n\tdata = k;\n\tdata += op->operands[0].reg << 24;\n\tdata += (op->operands[1].reg & 7) << (24 + 5);\n\tdata += (op->operands[1].reg >> 3) << 16;\n\tif (op->operands[2].reg_type & ARM_REG64) {\n\t\tdata += op->operands[2].reg << 8;\n\t} else {\n\t\tdata += (op->operands[2].reg & 0x3f) << 18;\n\t\tdata += (op->operands[2].reg >> 6) << 8;\n\t}\n\treturn data;\n}\n\nstatic bool parseOperands(char* str, ArmOp *op) {\n\tchar *t = strdup (str);\n\tint operand = 0;\n\tchar *token = t;\n\tchar *x;\n\tint imm_count = 0;\n\tint mem_opt = 0;\n\tif (!token) {\n\t\treturn false;\n\t}\n\n\twhile (token) {\n\t\tchar *next = strchr (token, ',');\n\t\tif (next) {\n\t\t\t*next++ = 0;\n\t\t}\n\t\twhile (token[0] == ' ') {\n\t\t\ttoken++;\n\t\t}\n\t\tif (operand >= MAX_OPERANDS) {\n\t\t\teprintf (\"Too many operands\\n\");\n\t\t\treturn false;\n\t\t}\n\t\top->operands[operand].type = ARM_NOTYPE;\n\t\top->operands[operand].reg_type = ARM_UNDEFINED;\n\t\top->operands[operand].shift = ARM_NO_SHIFT;\n\n\t\twhile (token[0] == ' ' || token[0] == '[' || token[0] == ']') {\n\t\t\ttoken ++;\n\t\t}\n\n\t\tif (!strncmp (token, \"lsl\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSL;\n\t\t} else if (!strncmp (token, \"lsr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_LSR;\n\t\t} else if (!strncmp (token, \"asr\", 3)) {\n\t\t\top->operands[operand].shift = ARM_ASR;\n\t\t}\n\t\tif (op->operands[operand].shift != ARM_NO_SHIFT) {\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n\t\t\tif (op->operands[operand].shift_amount > 63) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\toperand ++;\n\t\t\ttoken = next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (token[0]) {\n\t\tcase 'x':\n\t\t\tx = strchr (token, ',');\n\t\t\tif (x) {\n\t\t\t\tx[0] = '\\0';\n\t\t\t}\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG64;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\top->operands[operand].reg_type = ARM_REG32;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tif (op->operands[operand].reg > 31) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_FP;\n\t\t\top->operands[operand].reg = r_num_math (NULL, token + 1);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tif (token[1] == 'P' || token [1] == 'p') {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; msr_const[i].name; i++) {\n\t\t\t\t\tif (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {\n\t\t\t\t\t\top->operands[operand].sp_val = msr_const[i].val;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_GPR;\n\t\t\t\top->operands[operand].reg_type = ARM_SP | ARM_REG64;\n\t\t\t\top->operands[operand].reg = 31;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'L':\n\t\tcase 'l':\n\t\tcase 'I':\n\t\tcase 'i':\n\t\tcase 'N':\n\t\tcase 'n':\n\t\tcase 'O':\n\t\tcase 'o':\n\t\tcase 'p':\n\t\tcase 'P':\n\t\t\tmem_opt = get_mem_option (token);\n\t\t\tif (mem_opt != -1) {\n\t\t\t\top->operands_count ++;\n\t\t\t\top->operands[operand].type = ARM_MEM_OPT;\n\t\t\t\top->operands[operand].mem_option = mem_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\top->operands[operand].sign = -1;\n\t\t\t// falthru\n\t\tdefault:\n\t\t\top->operands_count ++;\n\t\t\top->operands[operand].type = ARM_CONSTANT;\n\t\t\top->operands[operand].immediate = r_num_math (NULL, token);\n\t\t\timm_count++;\n\t\t\tbreak;\n\t\t}\n\t\ttoken = next;\n\n\t\toperand ++;\n\t\tif (operand > MAX_OPERANDS) {\n\t\t\tfree (t);\n\t\t\treturn false;\n\t\t}\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic bool parseOpcode(const char *str, ArmOp *op) {\n\tchar *in = strdup (str);\n\tchar *space = strchr (in, ' ');\n\tif (!space) {\n\t\top->operands[0].type = ARM_NOTYPE;\n\t\top->mnemonic = in;\n \t\treturn true;\n\t}\n\tspace[0] = '\\0';\n\top->mnemonic = in;\n\tspace ++;\n\treturn parseOperands (space, op);\n}\n\nbool arm64ass(const char *str, ut64 addr, ut32 *op) {\n\tArmOp ops = {0};\n\tif (!parseOpcode (str, &ops)) {\n\t\treturn false;\n\t}\n\t/* TODO: write tests for this and move out the regsize logic into the mov */\n\tif (!strncmp (str, \"mov\", 3)) {\n\t\t*op = mov (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"cmp\", 3)) {\n\t\t*op = cmp (&ops);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00004078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsh\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsw\", 5)) {\n\t\t*op = bytelsop (&ops, 0x000080b8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldrsb\", 5)) {\n\t\t*op = bytelsop (&ops, 0x0000c039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strb\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000039);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"strh\", 4)) {\n\t\t*op = bytelsop (&ops, 0x00000078);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldr\", 3)) {\n\t\t*op = reglsop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldur\", 4)) {\n\t\t*op = regsluop (&ops, 0x000040f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"str\", 3)) {\n\t\t*op = reglsop (&ops, 0x000000f8);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"stp\", 3)) {\n\t\t*op = stp (&ops, 0x000000a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"ldp\", 3)) {\n\t\t*op = stp (&ops, 0x000040a9);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"sub\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0xd1);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"add\", 3)) { // w\n\t\t*op = arithmetic (&ops, 0x91);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adr x\", 5)) { // w\n\t\t*op = adr (&ops, addr);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"adrp x\", 6)) {\n\t\t*op = adrp (&ops, addr, 0x00000090);\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"isb\")) {\n\t\t*op = 0xdf3f03d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"nop\")) {\n\t\t*op = 0x1f2003d5;\n\t\treturn *op != -1;\n\t}\n\tif (!strcmp (str, \"ret\")) {\n\t\t*op = 0xc0035fd6;\n\t\treturn true;\n\t}\n\tif (!strncmp (str, \"msr \", 4)) {\n\t\t*op = msr (&ops, 0);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"mrs \", 4)) {\n\t\t*op = msr (&ops, 1);\n\t\tif (*op != UT32_MAX) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (!strncmp (str, \"orr \", 4)) {\n\t\t*op = orr (&ops, addr);\n\t\treturn *op != UT32_MAX;\n\t}\n\tif (!strncmp (str, \"svc \", 4)) { // system level exception\n\t\t*op = exception (&ops, 0x010000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hvc \", 4)) { // hypervisor level exception\n\t\t*op = exception (&ops, 0x020000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"smc \", 4)) { // secure monitor exception\n\t\t*op = exception (&ops, 0x030000d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"brk \", 4)) { // breakpoint\n\t\t*op = exception (&ops, 0x000020d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"hlt \", 4)) { // halt\n\t\t*op = exception (&ops, 0x000040d4);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b \", 2)) {\n\t\t*op = branch (&ops, addr, 0x14);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.eq \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x00000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"b.hs \", 5)) {\n\t\t*op = bdot (&ops, addr, 0x02000054);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"bl \", 3)) {\n\t\t*op = branch (&ops, addr, 0x94);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"br x\", 4)) {\n\t\t*op = branch (&ops, addr, 0x1fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"blr x\", 5)) {\n\t\t*op = branch (&ops, addr, 0x3fd6);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dmb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0xbf3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"dsb \", 4)) {\n\t\t*op = mem_barrier (&ops, addr, 0x9f3003d5);\n\t\treturn *op != -1;\n\t}\n\tif (!strncmp (str, \"isb\", 3)) {\n\t\t*op = mem_barrier (&ops, addr, 0xdf3f03d5);\n\t\treturn *op != -1;\n\t}\n\treturn false;\n}\n"], "filenames": ["libr/asm/arch/arm/armass64.c"], "buggy_code_start_loc": [739], "buggy_code_end_loc": [739], "fixing_code_start_loc": [740], "fixing_code_end_loc": [744], "type": "CWE-787", "message": "In radare2 prior to 3.1.2, the parseOperands function in libr/asm/arch/arm/armass64.c allows attackers to cause a denial-of-service (application crash caused by stack-based buffer overflow) by crafting an input file.", "other": {"cve": {"id": "CVE-2018-20460", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-25T19:29:00.540", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In radare2 prior to 3.1.2, the parseOperands function in libr/asm/arch/arm/armass64.c allows attackers to cause a denial-of-service (application crash caused by stack-based buffer overflow) by crafting an input file."}, {"lang": "es", "value": "En radare2, en versiones anteriores a la 3.1.2, la funci\u00f3n parseOperands en libr/asm/arch/arm/armass64.c podr\u00eda permitir que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n mediante un desbordamiento de b\u00fafer basado en pila) manipulando un archivo de entradas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.2", "matchCriteriaId": "9A7BA3FB-12D3-473B-B9ED-11408DA4974C"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/12376", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf"}}