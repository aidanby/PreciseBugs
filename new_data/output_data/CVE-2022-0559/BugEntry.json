{"buggy_code": ["/* radare2 - LGPL - Copyright 2021 - condret */\n\n#include <r_io.h>\n#include <r_util.h>\n\nR_API RIOBank *r_io_bank_new(const char *name) {\n\tr_return_val_if_fail (name, NULL);\n\tRIOBank *bank = R_NEW0 (RIOBank);\n\tif (!bank) {\n\t\treturn NULL;\n\t}\n\tbank->name = strdup (name);\n\tbank->submaps = r_crbtree_new (free);\n\tif (!bank->submaps) {\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->maprefs = r_list_newf (free);\n\tif (!bank->maprefs) {\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->todo = r_queue_new (8);\n\tif (!bank->todo) {\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\treturn bank;\n}\n\nR_API void r_io_bank_clear(RIOBank *bank) {\n\tr_return_if_fail (bank);\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\tfree (r_queue_dequeue (bank->todo));\n\t}\n\tbank->last_used = NULL;\n\tr_crbtree_clear (bank->submaps);\n\tr_list_purge (bank->maprefs);\n}\n\nR_API void r_io_bank_free(RIOBank *bank) {\n\tif (bank) {\n\t\tr_queue_free (bank->todo);\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank->name);\n\t\tfree (bank);\n\t}\n}\n\nR_API void r_io_bank_init(RIO *io) {\n\tr_return_if_fail (io);\n\tr_io_bank_fini (io);\n\tio->banks = r_id_storage_new (0, UT32_MAX);\n}\n\n\nstatic bool _bank_free_cb(void *user, void *data, ut32 id) {\n\tr_io_bank_free ((RIOBank *)data);\n\treturn true;\n}\n\nR_API void r_io_bank_fini(RIO *io) {\n\tr_return_if_fail (io);\n\tif (io->banks) {\n\t\tr_id_storage_foreach (io->banks, _bank_free_cb, NULL);\n\t\tr_id_storage_free (io->banks);\n\t\tio->banks = NULL;\n\t}\n}\n\nR_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}\n\nR_API ut32 r_io_bank_first(RIO *io) {\n\tut32 bankid = -1;\n\tr_id_storage_get_lowest (io->banks, &bankid);\n\treturn bankid;\n}\n\nR_API bool r_io_bank_use(RIO *io, ut32 bankid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (bank) {\n\t\tio->bank = bankid;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API bool r_io_bank_add(RIO *io, RIOBank *bank) {\n\tr_return_val_if_fail (io && io->banks && bank, false);\n\treturn r_id_storage_add (io->banks, bank, &bank->id);\n}\n\nstatic RIOMapRef *_mapref_from_map(RIOMap *map) {\n\tRIOMapRef *mapref = R_NEW (RIOMapRef);\n\tif (mapref) {\n\t\tmapref->id = map->id;\n\t\tmapref->ts = map->ts;\n\t}\n\treturn mapref;\n}\n\n// incoming - in\n// cb for finding sm by lower boundary vaddr\nstatic int _find_sm_by_from_vaddr_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int _find_sm_by_vaddr_cb(void *incoming, void *in, void *user) {\n\tconst ut64 addr = ((ut64 *)incoming)[0];\n\tRIOSubMap *sm = (RIOSubMap *)in;\n\tif (r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tif (addr < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nstatic int _find_lowest_intersection_sm_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_overlap (bd, sm)) {\n\t\treturn 0;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n// returns the node containing the submap with lowest itv.addr, that intersects with sm\nstatic RRBNode *_find_entry_submap_node(RIOBank *bank, RIOSubMap *sm) {\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, sm, _find_lowest_intersection_sm_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRRBNode *prev = r_rbnode_prev (node);\n\twhile (prev && r_io_submap_overlap (((RIOSubMap *)prev->data), sm)) {\n\t\tnode = prev;\n\t\tprev = r_rbnode_prev (node);\n\t}\n\treturn node;\n}\n\nR_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tif (!a) {\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_add_bottom(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_prepend (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\twhile (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\tr_list_prepend (bank->maprefs, mapref);\n\t\t\tfree (sm);\n\t\t\treturn true;\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\tr_list_prepend (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_priorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->tail) {\t//tail is top\n\t\treturn r_io_map_get_by_ref (io, mapref) ? true : false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// if this happens, something is really fucked up\n\t\tfree (sm);\n\t\treturn false;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_itv_eq (bd->itv, sm->itv)) {\n\t\t// no need to insert new sm, if boundaries match perfectly\n\t\t// instead override mapref of existing node/submap\n\t\tbd->mapref = *mapref;\n\t\tfree (sm);\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// bd completly overlaps sm on both ends,\n\t\t// therefor split bd into 2 maps => bd and bdsm\n\t\t// |---bd---||--sm--|-bdsm-|\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL) &\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t//delete all submaps that are completly included in sm\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tr_list_iter_to_top (bank->maprefs, iter);\n\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n}\n\n// deletes submaps that belong to a mapref with a specified priority from the submap tree of a bank.\n// the mapref is accessed by it's iter from the priority list in the bank,\n// so that the function can insert new submaps that fill the gaps. The iter represents the priority of the mapref.\n// this function DOES NOT delete the iter from the list. (that way it can be used for delete and relocate)\nstatic void _delete_submaps_from_bank_tree(RIO *io, RIOBank *bank, RListIter *prio, RIOMap *map) {\n\tRIOSubMap fake_sm;\n\tfake_sm.itv = map->itv;\n\tfake_sm.mapref.id = map->id;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\treturn;\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\twhile (bd && r_io_submap_overlap (bd, (&fake_sm))) {\n\t\t// this loop deletes all affected submaps from the rbtree\n\t\t// and also enqueues them in bank->todo\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\tif (bd->mapref.id == fake_sm.mapref.id) {\n\t\t\tr_queue_enqueue (bank->todo, R_NEWCOPY (RIOSubMap, bd));\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tentry = next;\n\t\tbd = entry ? (RIOSubMap *)entry->data : NULL;\n\t}\n\tRListIter *iter = prio;\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\t// now check for each deleted submap if a lower map intersects with it\n\t\t// and create new submaps accordingly, and fill the gaps\n\t\tRIOSubMap *sm = r_queue_dequeue (bank->todo);\n\t\tRListIter *ator = r_list_iter_get_prev (iter);\n\t\twhile (ator) {\n\t\t\tmap = r_io_map_get_by_ref (io, (RIOMapRef *)ator->data);\n\t\t\tator = r_list_iter_get_prev (ator);\n\t\t\tif (!map) {\n\t\t\t\t// if this happens, something is fucked up, and no submap should be inserted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if the map and sm intersect, the intersecting submap needs to be inserted in the tree\n\t\t\t// there are 5 cases to consider here\n\t\t\t// 1. no intersection: just continue to the next iteration\n\t\t\t// 2. map overlaps sm on both ends: insert submap for map with boundaries of sm\n\t\t\t// 3. map overlaps sm on the upper end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 4. map overlaps sm on the lower end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 5. sm overlaps sm on both ends: split sm into 2 submaps and enqueue new one in banks->todo; insert submap for map; adjust sm boundaries\n\t\t\tif (r_io_submap_to (sm) < r_io_map_from (map) || r_io_submap_from (sm) > r_io_map_to (map)) {\n\t\t\t\t// case 1\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRIOMapRef *mapref = _mapref_from_map (map);\n\t\t\tbd = r_io_submap_new (io, mapref);\n\t\t\tfree (mapref);\n\t\t\tif (!bd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_from (sm) >= r_io_map_from (map)) {\n\t\t\t\t// case 4 and 2\n\t\t\t\tr_io_submap_set_from (bd, r_io_submap_from (sm));\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t\t// case 2\n\t\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case 4\n\t\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t// case 3\n\t\t\t\t// adjust bd upper boundary to avoid overlap with existing submaps\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t// adjust sm upper boundary to avoid hitting again on sm in further iterations\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// case 5 because all other cases are already handled\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (bd) + 1);\n\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_queue_enqueue (bank->todo, bdsm);\n\t\t}\n\t\tfree (sm);\n\t}\n}\n\nR_API bool r_io_bank_map_depriorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (bank && map, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this bank\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->head) {\n\t\t// map is already lowest priority\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\tr_list_delete (bank->maprefs, iter);\n\treturn r_io_bank_map_add_bottom (io, bankid, mapid);\n}\n\n// compared 2 maprefs of the same bank by their priority (position in  the mapref list)\n// returns 0, if both have the same priority\n// returns 1, if mr0 has higher priority than mr1\n// returns -1, if mr1 has higher priority tham mr0\n// returns 0, if neither mr0 nor mr1 are an element of the bank\nstatic int _mapref_priority_cmp(RIOBank *bank, RIOMapRef *mr0, RIOMapRef *mr1) {\n\tif (mr0->id == mr1->id) {\n\t\t// mapref have the same priority, if their mapid matches\n\t\treturn 0;\n\t}\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mr0->id) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (mapref->id == mr1->id) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\t// should never happen\n}\n\nR_API bool r_io_bank_update_map_boundaries(RIO *io, const ut32 bankid, const ut32 mapid, ut64 ofrom, ut64 oto) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this map\n\treturn false;\nfound:\n\t;RIOMap *map = r_io_map_get_by_ref (io, mapref);\n\tif (!map) {\n\t\t// inconsistent mapref\n\t\t// mapref should be deleted from bank here\n\t\treturn false;\n\t}\n\tif (r_io_map_from (map) == ofrom && r_io_map_to (map) == oto) {\n\t\t// nothing todo here\n\t\treturn true;\n\t}\n\t// allocate sm here to avoid deleting things without ensuring\n\t// that this code could at least insert 1 submap\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\n\tbank->last_used = NULL;\n\t// this problem can be divided in 2 steps:\n\t// 1. delete corresponding submaps and insert intersecting submaps with lower priority\n\t// 2. adjust addr and insert submaps at new addr respecting priority\n\tRIOMap fake_map;\n\tmemcpy (&fake_map, map, sizeof (RIOMap));\n\tfake_map.itv.addr = ofrom;\n\tfake_map.itv.size = oto - ofrom + 1;\n\t_delete_submaps_from_bank_tree (io, bank, iter, &fake_map);\n\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection here, so just insert sm into the tree and we're done\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t// assumption here is that there is no need to check for return value of r_crbtree_insert,\n\t\t// since it only fails, if allocation fails and a delete was performed before, so it should just be fine\n\t\treturn true;\n\t}\n\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t// check if sm has higher priority than bd by comparing their maprefs\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t// sm has higher priority that bd => adjust bd\n\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\tif (r_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\t// bc of _find_entry_submap_node, we can be sure, that there is no\n\t\t\t\t// lower submap that intersects with sm\n\t\t\t\t//\n\t\t\t\t// instead of deleting and inserting, just replace the mapref,\n\t\t\t\t// similar to r_io_bank_map_priorize\n\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\t\t\tfree (sm);\n\t\t\t} else {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\t\t// allocating bdsm here is fine, bc bd is already in the tree\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t// What do if this fails?\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t} else {\n\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t// bd has higher priority than sm => adjust sm\n\t\tif (r_io_submap_from (bd) <= r_io_submap_from (sm)) {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\t// bd completly overlaps sm => nothing to do\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t} // else\n\t\t\t// adjust sm\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t} else {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\t\tfree (sm);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tif (!bdsm) {\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\tfree (bdsm);\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t}\n\t// entry = r_rbnode_next (entry);\n\t// it is given that entry->data->from >= sm->from on every iteration\n\t// so only check for upper boundary of sm for intersection with entry->data\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t// iterate forwards starting at entry, while entry->data and sm overlap\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tentry = r_rbnode_next (entry);\n\t\t// check if sm has higher priority than bd by comparing their maprefs\n\t\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t\t// delete bd\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t\t// bd has higher priority than sm => adjust sm\n\t\t\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\t\t// in this case the size of sm would be 0,\n\t\t\t\t// but since empty maps are not allowed free sm and return\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t}\n\t}\n\tif (!entry) {\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\tbd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t\t}\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t} else {\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t}\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// can this happen?\n\t\t\tfree (sm);\n\t\t}\n\t}\n\treturn true;\n}\n\n// locates next available address for a map with given size and alignment starting at *addr\nR_API bool r_io_bank_locate(RIO *io, const ut32 bankid, ut64 *addr, const ut64 size, ut64 load_align) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank && bank->submaps && addr && size, false);\n\tif (load_align == 0LL) {\n\t\tload_align = 1;\n\t}\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = *addr + (load_align - *addr % load_align) % load_align;\n\tfake_sm.itv.size = size;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\t// no submaps in this bank\n\t\t*addr = fake_sm.itv.addr;\n\t\treturn true;\n\t}\n\t// this is a bit meh: first iteration can never be successful,\n\t// bc entry->sm will always intersect with fake_sm, if\n\t// _find_entry_submap_node suceeded previously\n\tut64 next_location = fake_sm.itv.addr;\n\twhile (entry) {\n\t\tRIOSubMap *sm = (RIOSubMap *)entry->data;\n\t\tif (size <= r_io_submap_from (sm) - next_location) {\n\t\t\t*addr = next_location;\n\t\t\treturn true;\n\t\t}\n\t\tnext_location = (r_io_submap_to (sm) + 1) +\n\t\t\t(load_align - ((r_io_submap_to (sm) + 1) % load_align)) % load_align;\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tif (next_location == 0LL) {\n\t\t// overflow from last submap in the tree => no location\n\t\treturn false;\n\t}\n\tif (UT64_MAX - size + 1 < next_location) {\n\t\treturn false;\n\t}\n\t*addr = next_location;\n\treturn true;\n}\n\nR_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\nR_API bool r_io_bank_write_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof (RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_W)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int write_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_write_at (io, map->fd, paddr, &buf[buf_off], write_len) == write_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\n// reads only from single submap at addr and returns amount of bytes read.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}\n\n// writes only to single submap at addr and returns amount of bytes written.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}\n\nR_API RIOMap *r_io_bank_get_map_at(RIO *io, const ut32 bankid, ut64 addr) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, NULL);\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn NULL;\n\t}\n\treturn r_io_map_get_by_ref (io, &sm->mapref);\n}\n\n// deletes map with mapid from bank with bankid\nR_API void r_io_bank_del_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\t// no need to check for mapref here, since this is \"just\" deleting\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\t//is this needed?\n\tr_return_if_fail (bank && map);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == map->id) {\n\t\t\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\t\t\tr_list_delete (bank->maprefs, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbank->last_used = NULL;\n\t// map is not referenced by this bank; nothing to do\n}\n\nR_API void r_io_bank_del(RIO *io, const ut32 bankid) {\n\tr_id_storage_delete (io->banks, bankid);\n\tif (io->bank == bankid) {\n\t\tio->bank = r_io_bank_first (io);\n\t}\n}\n\n// merges nearby submaps, that have a map ref to the same map, and free unneeded tree nodes\nR_API void r_io_bank_drain(RIO *io, const ut32 bankid) {\n\tr_return_if_fail (io);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn;\n\t}\n\tbank->last_used = NULL;\n\tRRBNode *node = r_crbtree_first_node (bank->submaps);\n\tRRBNode *next = NULL;\n\twhile (node) {\n\t\tnext = r_rbnode_next (node);\n\t\tif (next) {\n\t\t\tRIOSubMap *bd = (RIOSubMap *)node->data;\n\t\t\tRIOSubMap *sm = (RIOSubMap *)next->data;\n\t\t\tif (!memcmp (&bd->mapref, &sm->mapref, sizeof (RIOMapRef))) {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tnode = next;\n\t}\n}\n\nR_IPI bool io_bank_has_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "/*\nBSD 2-Clause License\n\nCopyright (c) 2018, lynnl\n\nCleaned up and refactored for r2 in 2021: condret\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <r_util.h>\n\nstatic void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}\n\nR_API RRBTree *r_crbtree_new(RRBFree freefn) {\n\tRRBTree *tree = R_NEW0 (RRBTree);\n\tif (tree) {\n\t\ttree->free = freefn;\n\t}\n\treturn tree;\n}\n\nR_API void r_crbtree_clear(RRBTree *tree) {\n\tr_return_if_fail (tree);\n\tRRBNode *iter = tree->root, *save = NULL;\n\n\t// Rotate away the left links into a linked list so that\n\t// we can perform iterative destruction of the rbtree\n\twhile (iter) {\n\t\tif (!iter->link[0]) {\n\t\t\tsave = iter->link[1];\n\t\t\tif (tree->free) {\n\t\t\t\ttree->free (iter->data);\n\t\t\t}\n\t\t\tfree (iter);\n\t\t\ttree->size--;\n\t\t} else {\n\t\t\tsave = iter->link[0];\n\t\t\t_set_link (iter, save->link[1], 0);\n\t\t\t_set_link (save, iter, 1);\n\t\t}\n\t\titer = save;\n\t}\n\ttree->root = NULL;\n}\n\nR_API void r_crbtree_free(RRBTree *tree) {\n\tif (!tree) {\n\t\treturn;\n\t}\n\tr_crbtree_clear (tree);\n\tfree (tree);\n}\n\nR_API RRBNode *r_crbtree_find_node(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\n\tRRBNode *iter = tree->root;\n\twhile (iter) {\n\t\tconst int dir = cmp (data, iter->data, user);\n\t\tif (!dir) {\n\t\t\treturn iter;\n\t\t}\n\t\titer = iter->link[dir > 0];\n\t}\n\treturn NULL;\n}\n\nR_API void *r_crbtree_find(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\tRRBNode *node = r_crbtree_find_node (tree, data, cmp, user);\n\treturn node ? node->data : NULL;\n}\n\nstatic RRBNode *_node_new(void *data, RRBNode *parent) {\n\tRRBNode *node = R_NEW0 (RRBNode);\n\tr_return_val_if_fail (node, NULL);\n\n\tnode->red = 1;\n\tnode->data = data;\n\tnode->parent = parent;\n\n\treturn node;\n}\n\n#define IS_RED(n) ((n) != NULL && (n)->red == 1)\n\nstatic RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t// save is new parent of root and root is parent of save's previous child\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\n\troot->red = 1;\n\tsave->red = 0;\n\n\treturn save;\n}\n\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\n}\n\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}\n\nstatic void _exchange_nodes(RRBNode *node_a, RRBNode *node_b) {\n\tif (!node_a || !node_b) {\n\t\treturn;\n\t}\n\tRRBNode node_a_tmp, node_b_tmp;\n\tmemcpy (&node_a_tmp, node_a, sizeof (RRBNode));\n\tmemcpy (&node_b_tmp, node_b, sizeof (RRBNode));\n\tnode_a->link[0] = node_b_tmp.link[0];\n\tnode_a->link[1] = node_b_tmp.link[1];\n\tnode_a->red = node_b_tmp.red;\n\tnode_b->link[0] = node_a_tmp.link[0];\n\tnode_b->link[1] = node_a_tmp.link[1];\n\tnode_b->red = node_a_tmp.red;\n\tif (node_a->parent == node_b->parent) {\n\t\tif (node_a->parent) {\n\t\t\tif (node_a->parent->link[0] == node_a) {\n\t\t\t\tnode_a->parent->link[0] = node_b;\n\t\t\t\tnode_a->parent->link[1] = node_a;\n\t\t\t} else {\n\t\t\t\tnode_a->parent->link[1] = node_b;\n\t\t\t\tnode_a->parent->link[0] = node_a;\n\t\t\t}\n\t\t}\n\t\tif (node_a->link[0]) {\n\t\t\tnode_a->link[0]->parent = node_a;\n\t\t}\n\t\tif (node_a->link[1]) {\n\t\t\tnode_a->link[1]->parent = node_a;\n\t\t}\n\t\tif (node_b->link[0]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\tif (node_b->link[1]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\treturn;\n\t}\n\tRRBNode *parent_a = node_a->parent;\n\tRRBNode *parent_b = node_b->parent;\n\tif (parent_a) {\n\t\tif (parent_a->link[0] == node_a) {\n\t\t\tparent_a->link[0] = node_b;\n\t\t} else {\n\t\t\tparent_a->link[1] = node_b;\n\t\t}\n\t}\n\tnode_b->parent = parent_a;\n\tif (parent_b) {\n\t\tif (parent_b->link[0] == node_b) {\n\t\t\tparent_b->link[0] = node_a;\n\t\t} else {\n\t\t\tparent_b->link[1] = node_a;\n\t\t}\n\t}\n\tnode_a->parent = parent_b;\n\tif (node_a->link[0]) {\n\t\tnode_a->link[0]->parent = node_a;\n\t}\n\tif (node_a->link[1]) {\n\t\tnode_a->link[1]->parent = node_a;\n\t}\n\tif (node_b->link[0]) {\n\t\tnode_b->link[0]->parent = node_b;\n\t}\n\tif (node_b->link[1]) {\n\t\tnode_b->link[1]->parent = node_b;\n\t}\n}\n\n// remove data from the tree, without freeing it\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tRRBNode *found = NULL;\n\tint dir = 1, last;\n\n\t_set_link (q, tree->root, 1);\n\n\t/* Find in-order predecessor */\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0) {\n\t\t\tfound = q;\n\t\t}\n\n\t\tdir = (bool)(dir > 0);\n\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t\tp = p->link[last];\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\t/* Color flip */\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tsibling->red = 1;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ensure correct coloring */\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t\tg->link[dir2]->link[0]->red = 0;\n\t\t\t\t\tg->link[dir2]->link[1]->red = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid *ret = NULL;\n\t/* Replace and remove if found */\n\tif (found) {\n\t\t_set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);\n\t\tif (q != found) {\n\t\t\tq->link[0] = NULL;\n\t\t\tq->link[1] = NULL;\n\t\t\tq->parent = NULL;\n\t\t\t_exchange_nodes (found, q);\n\t\t}\n\t\tret = found->data;\n\t\tfree (found);\n\t\ttree->size--;\n\t}\n\n\t/* Update root node */\n\ttree->root = head.link[1];\n\tif (tree->root) {\n\t\ttree->root->red = 0;\n\t\ttree->root->parent = NULL;\n\t} else {\n\t\tr_return_val_if_fail (tree->size == 0, NULL);\n\t}\n\treturn ret;\n}\n\nR_API bool r_crbtree_delete(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, false);\n\tdata = r_crbtree_take (tree, data, cmp, user);\n\tif (tree->free) {\n\t\ttree->free (data);\n\t}\n\treturn !!data;\n}\n\nR_API RRBNode *r_crbtree_first_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[0]) {\n\t\tnode = node->link[0];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_crbtree_last_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[1]) {\n\t\tnode = node->link[1];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_rbnode_next(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[1]) {\n\t\tnode = node->link[1];\n\t\twhile (node->link[0]) {\n\t\t\tnode = node->link[0];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[1] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n\nR_API RRBNode *r_rbnode_prev(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[0]) {\n\t\tnode = node->link[0];\n\t\twhile (node->link[1]) {\n\t\t\tnode = node->link[1];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[0] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2021 - condret */\n\n#include <r_io.h>\n#include <r_util.h>\n\nR_API RIOBank *r_io_bank_new(const char *name) {\n\tr_return_val_if_fail (name, NULL);\n\tRIOBank *bank = R_NEW0 (RIOBank);\n\tif (!bank) {\n\t\treturn NULL;\n\t}\n\tbank->name = strdup (name);\n\tbank->submaps = r_crbtree_new (free);\n\tif (!bank->submaps) {\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->maprefs = r_list_newf (free);\n\tif (!bank->maprefs) {\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->todo = r_queue_new (8);\n\tif (!bank->todo) {\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\treturn bank;\n}\n\nR_API void r_io_bank_clear(RIOBank *bank) {\n\tr_return_if_fail (bank);\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\tfree (r_queue_dequeue (bank->todo));\n\t}\n\tbank->last_used = NULL;\n\tr_crbtree_clear (bank->submaps);\n\tr_list_purge (bank->maprefs);\n}\n\nR_API void r_io_bank_free(RIOBank *bank) {\n\tif (bank) {\n\t\tr_queue_free (bank->todo);\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank->name);\n\t\tfree (bank);\n\t}\n}\n\nR_API void r_io_bank_init(RIO *io) {\n\tr_return_if_fail (io);\n\tr_io_bank_fini (io);\n\tio->banks = r_id_storage_new (0, UT32_MAX);\n}\n\n\nstatic bool _bank_free_cb(void *user, void *data, ut32 id) {\n\tr_io_bank_free ((RIOBank *)data);\n\treturn true;\n}\n\nR_API void r_io_bank_fini(RIO *io) {\n\tr_return_if_fail (io);\n\tif (io->banks) {\n\t\tr_id_storage_foreach (io->banks, _bank_free_cb, NULL);\n\t\tr_id_storage_free (io->banks);\n\t\tio->banks = NULL;\n\t}\n}\n\nR_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}\n\nR_API ut32 r_io_bank_first(RIO *io) {\n\tut32 bankid = -1;\n\tr_id_storage_get_lowest (io->banks, &bankid);\n\treturn bankid;\n}\n\nR_API bool r_io_bank_use(RIO *io, ut32 bankid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (bank) {\n\t\tio->bank = bankid;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API bool r_io_bank_add(RIO *io, RIOBank *bank) {\n\tr_return_val_if_fail (io && io->banks && bank, false);\n\treturn r_id_storage_add (io->banks, bank, &bank->id);\n}\n\nstatic RIOMapRef *_mapref_from_map(RIOMap *map) {\n\tRIOMapRef *mapref = R_NEW (RIOMapRef);\n\tif (mapref) {\n\t\tmapref->id = map->id;\n\t\tmapref->ts = map->ts;\n\t}\n\treturn mapref;\n}\n\n// incoming - in\n// cb for finding sm by lower boundary vaddr\nstatic int _find_sm_by_from_vaddr_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int _find_sm_by_vaddr_cb(void *incoming, void *in, void *user) {\n\tconst ut64 addr = ((ut64 *)incoming)[0];\n\tRIOSubMap *sm = (RIOSubMap *)in;\n\tif (r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tif (addr < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\nstatic int _find_lowest_intersection_sm_cb(void *incoming, void *in, void *user) {\n\tRIOSubMap *bd = (RIOSubMap *)incoming, *sm = (RIOSubMap *)in;\n\tif (r_io_submap_overlap (bd, sm)) {\n\t\treturn 0;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n// returns the node containing the submap with lowest itv.addr, that intersects with sm\nstatic RRBNode *_find_entry_submap_node(RIOBank *bank, RIOSubMap *sm) {\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, sm, _find_lowest_intersection_sm_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRRBNode *prev = r_rbnode_prev (node);\n\twhile (prev && r_io_submap_overlap (((RIOSubMap *)prev->data), sm)) {\n\t\tnode = prev;\n\t\tprev = r_rbnode_prev (node);\n\t}\n\treturn node;\n}\n\nR_API bool r_io_bank_map_add_top(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_io_submap_to (bd) == r_io_submap_to (sm) &&\n\t\tr_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t// _find_entry_submap_node guarantees, that there is no submap\n\t\t// prior to bd in the range of sm, so instead of deleting and inserting\n\t\t// we can just memcpy\n\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\tfree (sm);\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// split bd into 2 maps => bd and bdsm\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tfree (sm);\n\t\t\tfree (bdsm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_append (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\n\t// guaranteed intersection\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tut64 smto = r_io_submap_to (sm);\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= smto) {\n\t\t//delete all submaps that are completly included in sm\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t// this can be optimized, there is no need to do search here\n\t\t// XXX this is a workaround to avoid an UAF in Reproducer: iobank-crash\n\t\tvoid *smfree = bank->submaps->free;\n\t\tbank->submaps->free = NULL;\n\t\tbool a = r_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tbank->submaps->free = smfree;\n\t\tif (!a) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\tfree (sm);\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tr_list_append (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_add_bottom(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (io && bank && map, false);\n\tRIOMapRef *mapref = _mapref_from_map (map);\n\tif (!mapref) {\n\t\treturn false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\tfree (mapref);\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection with any submap, so just insert\n\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\tfree (sm);\n\t\t\tfree (mapref);\n\t\t\treturn false;\n\t\t}\n\t\tr_list_prepend (bank->maprefs, mapref);\n\t\treturn true;\n\t}\n\twhile (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\tr_list_prepend (bank->maprefs, mapref);\n\t\t\tfree (sm);\n\t\t\treturn true;\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\tr_list_prepend (bank->maprefs, mapref);\n\treturn true;\n}\n\nR_API bool r_io_bank_map_priorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->tail) {\t//tail is top\n\t\treturn r_io_map_get_by_ref (io, mapref) ? true : false;\n\t}\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// if this happens, something is really fucked up\n\t\tfree (sm);\n\t\treturn false;\n\t}\n\tbank->last_used = NULL;\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\tif (r_itv_eq (bd->itv, sm->itv)) {\n\t\t// no need to insert new sm, if boundaries match perfectly\n\t\t// instead override mapref of existing node/submap\n\t\tbd->mapref = *mapref;\n\t\tfree (sm);\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn true;\n\t}\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t// bd completly overlaps sm on both ends,\n\t\t// therefor split bd into 2 maps => bd and bdsm\n\t\t// |---bd---||--sm--|-bdsm-|\n\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\tif (!bdsm) {\n\t\t\tfree (sm);\n\t\t\treturn false;\n\t\t}\n\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t// TODO: insert and check return value, before adjusting sm size\n\t\tr_list_iter_to_top (bank->maprefs, iter);\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL) &\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\n\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\tentry = r_rbnode_next (entry);\n\t}\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\t//delete all submaps that are completly included in sm\n\t\t// this can be optimized, there is no need to do search here\n\t\tr_crbtree_delete (bank->submaps, entry->data, _find_sm_by_from_vaddr_cb, NULL);\n\t\tentry = next;\n\t}\n\tif (entry && r_io_submap_from (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t}\n\tr_list_iter_to_top (bank->maprefs, iter);\n\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n}\n\n// deletes submaps that belong to a mapref with a specified priority from the submap tree of a bank.\n// the mapref is accessed by it's iter from the priority list in the bank,\n// so that the function can insert new submaps that fill the gaps. The iter represents the priority of the mapref.\n// this function DOES NOT delete the iter from the list. (that way it can be used for delete and relocate)\nstatic void _delete_submaps_from_bank_tree(RIO *io, RIOBank *bank, RListIter *prio, RIOMap *map) {\n\tRIOSubMap fake_sm;\n\tfake_sm.itv = map->itv;\n\tfake_sm.mapref.id = map->id;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\treturn;\n\t}\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\twhile (bd && r_io_submap_overlap (bd, (&fake_sm))) {\n\t\t// this loop deletes all affected submaps from the rbtree\n\t\t// and also enqueues them in bank->todo\n\t\tRRBNode *next = r_rbnode_next (entry);\n\t\tif (bd->mapref.id == fake_sm.mapref.id) {\n\t\t\tr_queue_enqueue (bank->todo, R_NEWCOPY (RIOSubMap, bd));\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t}\n\t\tentry = next;\n\t\tbd = entry ? (RIOSubMap *)entry->data : NULL;\n\t}\n\tRListIter *iter = prio;\n\twhile (!r_queue_is_empty (bank->todo)) {\n\t\t// now check for each deleted submap if a lower map intersects with it\n\t\t// and create new submaps accordingly, and fill the gaps\n\t\tRIOSubMap *sm = r_queue_dequeue (bank->todo);\n\t\tRListIter *ator = r_list_iter_get_prev (iter);\n\t\twhile (ator) {\n\t\t\tmap = r_io_map_get_by_ref (io, (RIOMapRef *)ator->data);\n\t\t\tator = r_list_iter_get_prev (ator);\n\t\t\tif (!map) {\n\t\t\t\t// if this happens, something is fucked up, and no submap should be inserted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if the map and sm intersect, the intersecting submap needs to be inserted in the tree\n\t\t\t// there are 5 cases to consider here\n\t\t\t// 1. no intersection: just continue to the next iteration\n\t\t\t// 2. map overlaps sm on both ends: insert submap for map with boundaries of sm\n\t\t\t// 3. map overlaps sm on the upper end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 4. map overlaps sm on the lower end: insert submap for map accordingly and adjust sm boundaries\n\t\t\t// 5. sm overlaps sm on both ends: split sm into 2 submaps and enqueue new one in banks->todo; insert submap for map; adjust sm boundaries\n\t\t\tif (r_io_submap_to (sm) < r_io_map_from (map) || r_io_submap_from (sm) > r_io_map_to (map)) {\n\t\t\t\t// case 1\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRIOMapRef *mapref = _mapref_from_map (map);\n\t\t\tbd = r_io_submap_new (io, mapref);\n\t\t\tfree (mapref);\n\t\t\tif (!bd) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_from (sm) >= r_io_map_from (map)) {\n\t\t\t\t// case 4 and 2\n\t\t\t\tr_io_submap_set_from (bd, r_io_submap_from (sm));\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t\t// case 2\n\t\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// case 4\n\t\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (r_io_submap_to (sm) <= r_io_map_to (map)) {\n\t\t\t\t// case 3\n\t\t\t\t// adjust bd upper boundary to avoid overlap with existing submaps\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\t// adjust sm upper boundary to avoid hitting again on sm in further iterations\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// case 5 because all other cases are already handled\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (bd) + 1);\n\t\t\tr_crbtree_insert (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_queue_enqueue (bank->todo, bdsm);\n\t\t}\n\t\tfree (sm);\n\t}\n}\n\nR_API bool r_io_bank_map_depriorize(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\n\tr_return_val_if_fail (bank && map, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this bank\n\treturn false;\nfound:\n\tif (iter == bank->maprefs->head) {\n\t\t// map is already lowest priority\n\t\treturn true;\n\t}\n\tbank->last_used = NULL;\n\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\tr_list_delete (bank->maprefs, iter);\n\treturn r_io_bank_map_add_bottom (io, bankid, mapid);\n}\n\n// compared 2 maprefs of the same bank by their priority (position in  the mapref list)\n// returns 0, if both have the same priority\n// returns 1, if mr0 has higher priority than mr1\n// returns -1, if mr1 has higher priority tham mr0\n// returns 0, if neither mr0 nor mr1 are an element of the bank\nstatic int _mapref_priority_cmp(RIOBank *bank, RIOMapRef *mr0, RIOMapRef *mr1) {\n\tif (mr0->id == mr1->id) {\n\t\t// mapref have the same priority, if their mapid matches\n\t\treturn 0;\n\t}\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mr0->id) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (mapref->id == mr1->id) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\t// should never happen\n}\n\nR_API bool r_io_bank_update_map_boundaries(RIO *io, const ut32 bankid, const ut32 mapid, ut64 ofrom, ut64 oto) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\tgoto found;\n\t\t}\n\t}\n\t// map is not referenced by this map\n\treturn false;\nfound:\n\t;RIOMap *map = r_io_map_get_by_ref (io, mapref);\n\tif (!map) {\n\t\t// inconsistent mapref\n\t\t// mapref should be deleted from bank here\n\t\treturn false;\n\t}\n\tif (r_io_map_from (map) == ofrom && r_io_map_to (map) == oto) {\n\t\t// nothing todo here\n\t\treturn true;\n\t}\n\t// allocate sm here to avoid deleting things without ensuring\n\t// that this code could at least insert 1 submap\n\tRIOSubMap *sm = r_io_submap_new (io, mapref);\n\tif (!sm) {\n\t\treturn false;\n\t}\n\n\tbank->last_used = NULL;\n\t// this problem can be divided in 2 steps:\n\t// 1. delete corresponding submaps and insert intersecting submaps with lower priority\n\t// 2. adjust addr and insert submaps at new addr respecting priority\n\tRIOMap fake_map;\n\tmemcpy (&fake_map, map, sizeof (RIOMap));\n\tfake_map.itv.addr = ofrom;\n\tfake_map.itv.size = oto - ofrom + 1;\n\t_delete_submaps_from_bank_tree (io, bank, iter, &fake_map);\n\n\tRRBNode *entry = _find_entry_submap_node (bank, sm);\n\tif (!entry) {\n\t\t// no intersection here, so just insert sm into the tree and we're done\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t// assumption here is that there is no need to check for return value of r_crbtree_insert,\n\t\t// since it only fails, if allocation fails and a delete was performed before, so it should just be fine\n\t\treturn true;\n\t}\n\n\tRIOSubMap *bd = (RIOSubMap *)entry->data;\n\t// check if sm has higher priority than bd by comparing their maprefs\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t// sm has higher priority that bd => adjust bd\n\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\tif (r_io_submap_from (bd) >= r_io_submap_from (sm)) {\n\t\t\t\t// bc of _find_entry_submap_node, we can be sure, that there is no\n\t\t\t\t// lower submap that intersects with sm\n\t\t\t\t//\n\t\t\t\t// instead of deleting and inserting, just replace the mapref,\n\t\t\t\t// similar to r_io_bank_map_priorize\n\t\t\t\tmemcpy (bd, sm, sizeof (RIOSubMap));\n\t\t\t\tfree (sm);\n\t\t\t} else {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm) &&\n\t\t\tr_io_submap_to (sm) < r_io_submap_to (bd)) {\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, bd);\n\t\t\t// allocating bdsm here is fine, bc bd is already in the tree\n\t\t\tr_io_submap_set_from (bdsm, r_io_submap_to (sm) + 1);\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\t// What do if this fails?\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\treturn true;\n\t\t}\n\t\tif (r_io_submap_from (bd) < r_io_submap_from (sm)) {\n\t\t\tr_io_submap_set_to (bd, r_io_submap_from (sm) - 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t} else {\n\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t// bd has higher priority than sm => adjust sm\n\t\tif (r_io_submap_from (bd) <= r_io_submap_from (sm)) {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\t// bd completly overlaps sm => nothing to do\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t} // else\n\t\t\t// adjust sm\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t} else {\n\t\t\tif (r_io_submap_to (sm) <= r_io_submap_to (bd)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t\tif (!r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\t\tfree (sm);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\tif (!bdsm) {\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tif (!r_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL)) {\n\t\t\t\tfree (bdsm);\n\t\t\t\tfree (sm);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// r_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t\tentry = r_rbnode_next (entry);\n\t\t}\n\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t}\n\t// entry = r_rbnode_next (entry);\n\t// it is given that entry->data->from >= sm->from on every iteration\n\t// so only check for upper boundary of sm for intersection with entry->data\n\twhile (entry && r_io_submap_to (((RIOSubMap *)entry->data)) <= r_io_submap_to (sm)) {\n\t\t// iterate forwards starting at entry, while entry->data and sm overlap\n\t\tbd = (RIOSubMap *)entry->data;\n\t\tentry = r_rbnode_next (entry);\n\t\t// check if sm has higher priority than bd by comparing their maprefs\n\t\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\t\t// delete bd\n\t\t\tr_crbtree_delete (bank->submaps, bd, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// _mapref_priority_cmp cannot return 0 in this scenario,\n\t\t\t// since all submaps with the same mapref as sm were deleted from\n\t\t\t// the submap tree previously. so _mapref_priority_cmp can only return 1 or -1\n\t\t\t// bd has higher priority than sm => adjust sm\n\t\t\tif (r_io_submap_from (bd) > r_io_submap_from (sm)) {\n\t\t\t\tRIOSubMap *bdsm = R_NEWCOPY (RIOSubMap, sm);\n\t\t\t\tr_io_submap_set_to (bdsm, r_io_submap_from (bd) - 1);\n\t\t\t\tr_crbtree_insert (bank->submaps, bdsm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t}\n\t\t\tif (r_io_submap_to (bd) == r_io_submap_to (sm)) {\n\t\t\t\t// in this case the size of sm would be 0,\n\t\t\t\t// but since empty maps are not allowed free sm and return\n\t\t\t\tfree (sm);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_io_submap_set_from (sm, r_io_submap_to (bd) + 1);\n\t\t}\n\t}\n\tif (!entry) {\n\t\treturn r_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t}\n\tbd = (RIOSubMap *)entry->data;\n\tif (_mapref_priority_cmp (bank, &sm->mapref, &bd->mapref) == 1) {\n\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\tr_io_submap_set_from (bd, r_io_submap_to (sm) + 1);\n\t\t}\n\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t} else {\n\t\tif (r_io_submap_from (sm) < r_io_submap_from (bd)) {\n\t\t\tif (r_io_submap_from (bd) <= r_io_submap_to (sm)) {\n\t\t\t\tr_io_submap_set_to (sm, r_io_submap_from (bd) - 1);\n\t\t\t}\n\t\t\tr_crbtree_insert (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t} else {\n\t\t\t// can this happen?\n\t\t\tfree (sm);\n\t\t}\n\t}\n\treturn true;\n}\n\n// locates next available address for a map with given size and alignment starting at *addr\nR_API bool r_io_bank_locate(RIO *io, const ut32 bankid, ut64 *addr, const ut64 size, ut64 load_align) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank && bank->submaps && addr && size, false);\n\tif (load_align == 0LL) {\n\t\tload_align = 1;\n\t}\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = *addr + (load_align - *addr % load_align) % load_align;\n\tfake_sm.itv.size = size;\n\tRRBNode *entry = _find_entry_submap_node (bank, &fake_sm);\n\tif (!entry) {\n\t\t// no submaps in this bank\n\t\t*addr = fake_sm.itv.addr;\n\t\treturn true;\n\t}\n\t// this is a bit meh: first iteration can never be successful,\n\t// bc entry->sm will always intersect with fake_sm, if\n\t// _find_entry_submap_node suceeded previously\n\tut64 next_location = fake_sm.itv.addr;\n\twhile (entry) {\n\t\tRIOSubMap *sm = (RIOSubMap *)entry->data;\n\t\tif (size <= r_io_submap_from (sm) - next_location) {\n\t\t\t*addr = next_location;\n\t\t\treturn true;\n\t\t}\n\t\tnext_location = (r_io_submap_to (sm) + 1) +\n\t\t\t(load_align - ((r_io_submap_to (sm) + 1) % load_align)) % load_align;\n\t\tentry = r_rbnode_next (entry);\n\t}\n\tif (next_location == 0LL) {\n\t\t// overflow from last submap in the tree => no location\n\t\treturn false;\n\t}\n\tif (UT64_MAX - size + 1 < next_location) {\n\t\treturn false;\n\t}\n\t*addr = next_location;\n\treturn true;\n}\n\nR_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof(RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\nR_API bool r_io_bank_write_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRIOSubMap fake_sm;\n\tmemset (&fake_sm, 0x00, sizeof (RIOSubMap));\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\t// mapref doesn't belong to map\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_W)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tret = false;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int write_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\tret &= (r_io_fd_write_at (io, map->fd, paddr, &buf[buf_off], write_len) == write_len);\n\t\t// check return value here?\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}\n\n// reads only from single submap at addr and returns amount of bytes read.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}\n\n// writes only to single submap at addr and returns amount of bytes written.\n// if no submap is mapped at addr, fcn returns 0. returns -1 on error\nR_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}\n\nR_API RIOMap *r_io_bank_get_map_at(RIO *io, const ut32 bankid, ut64 addr) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, NULL);\n\tRRBNode *node = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\tif (!node) {\n\t\treturn NULL;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn NULL;\n\t}\n\treturn r_io_map_get_by_ref (io, &sm->mapref);\n}\n\n// deletes map with mapid from bank with bankid\nR_API void r_io_bank_del_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\t// no need to check for mapref here, since this is \"just\" deleting\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tRIOMap *map = r_io_map_get (io, mapid);\t//is this needed?\n\tr_return_if_fail (bank && map);\n\tRListIter *iter;\n\tRIOMapRef *mapref = NULL;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == map->id) {\n\t\t\t_delete_submaps_from_bank_tree (io, bank, iter, map);\n\t\t\tr_list_delete (bank->maprefs, iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbank->last_used = NULL;\n\t// map is not referenced by this bank; nothing to do\n}\n\nR_API void r_io_bank_del(RIO *io, const ut32 bankid) {\n\tr_id_storage_delete (io->banks, bankid);\n\tif (io->bank == bankid) {\n\t\tio->bank = r_io_bank_first (io);\n\t}\n}\n\n// merges nearby submaps, that have a map ref to the same map, and free unneeded tree nodes\nR_API void r_io_bank_drain(RIO *io, const ut32 bankid) {\n\tr_return_if_fail (io);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn;\n\t}\n\tbank->last_used = NULL;\n\tRRBNode *node = r_crbtree_first_node (bank->submaps);\n\tRRBNode *next = NULL;\n\twhile (node) {\n\t\tnext = r_rbnode_next (node);\n\t\tif (next) {\n\t\t\tRIOSubMap *bd = (RIOSubMap *)node->data;\n\t\t\tRIOSubMap *sm = (RIOSubMap *)next->data;\n\t\t\tif (!memcmp (&bd->mapref, &sm->mapref, sizeof (RIOMapRef))) {\n\t\t\t\tr_io_submap_set_to (bd, r_io_submap_to (sm));\n\t\t\t\tr_crbtree_delete (bank->submaps, sm, _find_sm_by_from_vaddr_cb, NULL);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tnode = next;\n\t}\n}\n\nR_IPI bool io_bank_has_map(RIO *io, const ut32 bankid, const ut32 mapid) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, false);\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mapid) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n", "/*\nBSD 2-Clause License\n\nCopyright (c) 2018, lynnl\n\nCleaned up and refactored for r2 in 2021: condret\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <r_util.h>\n\nstatic void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}\n\nR_API RRBTree *r_crbtree_new(RRBFree freefn) {\n\tRRBTree *tree = R_NEW0 (RRBTree);\n\tif (tree) {\n\t\ttree->free = freefn;\n\t}\n\treturn tree;\n}\n\nR_API void r_crbtree_clear(RRBTree *tree) {\n\tr_return_if_fail (tree);\n\tRRBNode *iter = tree->root, *save = NULL;\n\n\t// Rotate away the left links into a linked list so that\n\t// we can perform iterative destruction of the rbtree\n\twhile (iter) {\n\t\tif (!iter->link[0]) {\n\t\t\tsave = iter->link[1];\n\t\t\tif (tree->free) {\n\t\t\t\ttree->free (iter->data);\n\t\t\t}\n\t\t\tfree (iter);\n\t\t\ttree->size--;\n\t\t} else {\n\t\t\tsave = iter->link[0];\n\t\t\t_set_link (iter, save->link[1], 0);\n\t\t\t_set_link (save, iter, 1);\n\t\t}\n\t\titer = save;\n\t}\n\ttree->root = NULL;\n}\n\nR_API void r_crbtree_free(RRBTree *tree) {\n\tif (!tree) {\n\t\treturn;\n\t}\n\tr_crbtree_clear (tree);\n\tfree (tree);\n}\n\nR_API RRBNode *r_crbtree_find_node(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\n\tRRBNode *iter = tree->root;\n\twhile (iter) {\n\t\tconst int dir = cmp (data, iter->data, user);\n\t\tif (!dir) {\n\t\t\treturn iter;\n\t\t}\n\t\titer = iter->link[dir > 0];\n\t}\n\treturn NULL;\n}\n\nR_API void *r_crbtree_find(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\tRRBNode *node = r_crbtree_find_node (tree, data, cmp, user);\n\treturn node ? node->data : NULL;\n}\n\nstatic RRBNode *_node_new(void *data, RRBNode *parent) {\n\tRRBNode *node = R_NEW0 (RRBNode);\n\tr_return_val_if_fail (node, NULL);\n\n\tnode->red = 1;\n\tnode->data = data;\n\tnode->parent = parent;\n\n\treturn node;\n}\n\n#define IS_RED(n) ((n) != NULL && (n)->red == 1)\n\nstatic RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t// save is new parent of root and root is parent of save's previous child\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\n\troot->red = 1;\n\tsave->red = 0;\n\n\treturn save;\n}\n\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\n}\n\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (!tree->root) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (!tree->root) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}\n\nstatic void _exchange_nodes(RRBNode *node_a, RRBNode *node_b) {\n\tif (!node_a || !node_b) {\n\t\treturn;\n\t}\n\tRRBNode node_a_tmp, node_b_tmp;\n\tmemcpy (&node_a_tmp, node_a, sizeof (RRBNode));\n\tmemcpy (&node_b_tmp, node_b, sizeof (RRBNode));\n\tnode_a->link[0] = node_b_tmp.link[0];\n\tnode_a->link[1] = node_b_tmp.link[1];\n\tnode_a->red = node_b_tmp.red;\n\tnode_b->link[0] = node_a_tmp.link[0];\n\tnode_b->link[1] = node_a_tmp.link[1];\n\tnode_b->red = node_a_tmp.red;\n\tif (node_a->parent == node_b->parent) {\n\t\tif (node_a->parent) {\n\t\t\tif (node_a->parent->link[0] == node_a) {\n\t\t\t\tnode_a->parent->link[0] = node_b;\n\t\t\t\tnode_a->parent->link[1] = node_a;\n\t\t\t} else {\n\t\t\t\tnode_a->parent->link[1] = node_b;\n\t\t\t\tnode_a->parent->link[0] = node_a;\n\t\t\t}\n\t\t}\n\t\tif (node_a->link[0]) {\n\t\t\tnode_a->link[0]->parent = node_a;\n\t\t}\n\t\tif (node_a->link[1]) {\n\t\t\tnode_a->link[1]->parent = node_a;\n\t\t}\n\t\tif (node_b->link[0]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\tif (node_b->link[1]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\treturn;\n\t}\n\tRRBNode *parent_a = node_a->parent;\n\tRRBNode *parent_b = node_b->parent;\n\tif (parent_a) {\n\t\tif (parent_a->link[0] == node_a) {\n\t\t\tparent_a->link[0] = node_b;\n\t\t} else {\n\t\t\tparent_a->link[1] = node_b;\n\t\t}\n\t}\n\tnode_b->parent = parent_a;\n\tif (parent_b) {\n\t\tif (parent_b->link[0] == node_b) {\n\t\t\tparent_b->link[0] = node_a;\n\t\t} else {\n\t\t\tparent_b->link[1] = node_a;\n\t\t}\n\t}\n\tnode_a->parent = parent_b;\n\tif (node_a->link[0]) {\n\t\tnode_a->link[0]->parent = node_a;\n\t}\n\tif (node_a->link[1]) {\n\t\tnode_a->link[1]->parent = node_a;\n\t}\n\tif (node_b->link[0]) {\n\t\tnode_b->link[0]->parent = node_b;\n\t}\n\tif (node_b->link[1]) {\n\t\tnode_b->link[1]->parent = node_b;\n\t}\n}\n\n// remove data from the tree, without freeing it\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tRRBNode *found = NULL;\n\tint dir = 1, last;\n\n\t_set_link (q, tree->root, 1);\n\n\t/* Find in-order predecessor */\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0) {\n\t\t\tfound = q;\n\t\t}\n\n\t\tdir = (bool)(dir > 0);\n\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t\tp = p->link[last];\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\t/* Color flip */\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tsibling->red = 1;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ensure correct coloring */\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t\tg->link[dir2]->link[0]->red = 0;\n\t\t\t\t\tg->link[dir2]->link[1]->red = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid *ret = NULL;\n\t/* Replace and remove if found */\n\tif (found) {\n\t\t_set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);\n\t\tif (q != found) {\n\t\t\tq->link[0] = NULL;\n\t\t\tq->link[1] = NULL;\n\t\t\tq->parent = NULL;\n\t\t\t_exchange_nodes (found, q);\n\t\t}\n\t\tret = found->data;\n\t\tfree (found);\n\t\ttree->size--;\n\t}\n\n\t/* Update root node */\n\ttree->root = head.link[1];\n\tif (tree->root) {\n\t\ttree->root->red = 0;\n\t\ttree->root->parent = NULL;\n\t} else {\n\t\tr_return_val_if_fail (tree->size == 0, NULL);\n\t}\n\treturn ret;\n}\n\nR_API bool r_crbtree_delete(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, false);\n\tdata = r_crbtree_take (tree, data, cmp, user);\n\tif (tree->free) {\n\t\ttree->free (data);\n\t}\n\treturn !!data;\n}\n\nR_API RRBNode *r_crbtree_first_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[0]) {\n\t\tnode = node->link[0];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_crbtree_last_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[1]) {\n\t\tnode = node->link[1];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_rbnode_next(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[1]) {\n\t\tnode = node->link[1];\n\t\twhile (node->link[0]) {\n\t\t\tnode = node->link[0];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[1] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n\nR_API RRBNode *r_rbnode_prev(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[0]) {\n\t\tnode = node->link[0];\n\t\twhile (node->link[1]) {\n\t\t\tnode = node->link[1];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[0] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n"], "filenames": ["libr/io/io_bank.c", "libr/util/new_rbtree.c"], "buggy_code_start_loc": [229, 141], "buggy_code_end_loc": [234, 144], "fixing_code_start_loc": [229, 141], "fixing_code_end_loc": [241, 144], "type": "CWE-416", "message": "Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2.", "other": {"cve": {"id": "CVE-2022-0559", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-16T11:15:07.773", "lastModified": "2022-04-08T13:46:19.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository radareorg/radare2 prior to 5.6.2."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en NPM radare2.js versiones anteriores a 5.6.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.2", "matchCriteriaId": "B0653877-95C4-4D74-A0EA-9C5EFA579627"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/aa80adb7-e900-44a5-ad05-91f3ccdfc81e", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/b5cb90b28ec71fda3504da04e3cc94a362807f5e"}}