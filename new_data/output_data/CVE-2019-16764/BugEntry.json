{"buggy_code": ["# Changelog\n\n## v0.4.3 (2019-11-20)\n\n* Removed `:phoenix_html` dependency requirement\n* Added Pow minimum requirement `~> 1.0.15`\n* Use `Pow.Extension.Base` macro for new extension setup\n\n## v0.4.2 (2019-11-13)\n\n* Added support for POST callback from provider:\n  * Added `pow_assent_authorization_post_callback_routes/0` macro to `PowAssent.Phoenix.Router`\n  * Added `:skip_csrf_protection` pipeline example and scope with `pow_assent_authorization_post_callback_routes/0` call to the docs\n  * Use `Pow.Phoenix.Router` macros to dynamically filter duplicate routes\n\n## v0.4.1 (2019-10-08)\n\n* Use Assent `v0.1.2` and set `:redirect_uri` in config for OAuth 2.0 callback phase\n\n## v0.4.0 (2019-10-06)\n\n**This release consists of major breaking changes.**\n\nYou'll have to change the `:strategy` setting in your provider configurations. For the most part it would just consists of renaming `PowAssent.Strategy.STRATEGY` to `Assent.Strategy.STRATEGY`.\n\nIf you have custom built strategies, you should can use `Assent.Strategy.normalize_userinfo/2` to conform the userinfo response from the API. `sub` is now expected instead of `uid`.\n\n### Changes\n\n* Use [`:assent` package](https://github.com/pow-auth/assent) for strategies. The following modules has been removed in favor of `Assent` modules:\n\n  * `PowAssent.CallbackError`\n  * `PowAssent.CallbackCSRFError`\n  * `PowAssent.RequestError`\n  * `PowAssent.ConfigurationError`\n  * `PowAssent.HTTPAdapter`\n  * `PowAssent.HTTPAdapter.Httpc`\n  * `PowAssent.HTTPAdapter.Mint`\n  * `PowAssent.Strategy.Auth0`\n  * `PowAssent.Strategy.AzureOAuth2`\n  * `PowAssent.Strategy.Basecamp`\n  * `PowAssent.Strategy.Discord`\n  * `PowAssent.Strategy.Facebook`\n  * `PowAssent.Strategy.Github`\n  * `PowAssent.Strategy.Gitlab`\n  * `PowAssent.Strategy.Google`\n  * `PowAssent.Strategy.Instagram`\n  * `PowAssent.Strategy.OAuth`\n  * `PowAssent.Strategy.OAuth.Base`\n  * `PowAssent.Strategy.OAuth2`\n  * `PowAssent.Strategy.OAuth2.Base`\n  * `PowAssent.Strategy.Slack`\n  * `PowAssent.Strategy.Twitter`\n  * `PowAssent.Strategy.VK`\n  * `PowAssent.Strategy`\n\n* Callback params now conforms to [OpenID Connect Core 1.0 Standard Claims spec](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.5.1). During the callback phase, the following param keys will be renamed:\n\n  * `sub` to `uid`\n  * `preferred_username` to `username`\n\n* The e-mail is no longer considered confirmed unless the callback params has an `email_verified` key set to true\n\n* `PowAssent.Plug.authorize_url/3` generates a random nonce if `nonce: true` is set in the provider configuration\n\n* Support for OpenID Connect and Apple Sign In through Assent\n\n## v0.3.2 (2019-08-25)\n\n* All links in docs generated with `mix docs` and on [hexdocs.pm](http://hexdocs.pm/pow/) now works\n* Generated docs now uses lower case file name except for `README` and `CHANGELOG`\n* Added Auth0 strategy\n* Added Gitlab strategy\n\n## v0.3.1 (2019-06-05)\n\n* Added Pow minimum requirement `~> 1.0.9`\n* Added repo `:prefix` support\n* User identities are now upserted on authorization so additional params can be updated on authorization request. Following methods has been deprecated:\n  * `PowAssent.Ecto.UserIdentities.Context.create/3` in favor of `PowAssent.Ecto.UserIdentities.Context.upsert/3`\n  * `MyApp.UserIdentities.create/2` in favor of `MyApp.UserIdentities.upsert/2`\n  * `MyApp.UserIdentities.pow_assent_create/2` in favor of `MyApp.UserIdentities.upsert/2`\n  * `PowAssent.Operations.create/3` in favor of `PowAssent.Operations.upsert/3`\n  * `PowAssent.Plug.create_identity/2` in favor of `PowAssent.Plug.upsert_identity/2`\n* Use `Pow.Plug.get_plug/1` instead of pulling `:mod` from the config\n* Fixed so `uid` can be an integer value in `PowAssent.Ecto.UserIdentities.Context`. Strategies are no longer expected to convert the `uid` value to binary. The following methods will accepts integer `uid`:\n  * `PowAssent.Ecto.UserIdentities.Context.get_user_by_provider_uid/3`\n  * `PowAssent.Ecto.UserIdentities.Context.upsert/3`\n  * `PowAssent.Ecto.UserIdentities.Context.create_user/4`\n* Fixed bug where invited user was not signed in after succesful authorization\n* Fixed bug where releases with Elixir 1.9.0 didn't have `:httpc` available\n\n## v0.3.0 (2019-05-19)\n\n* Added `PowAssent.Phoenix.ViewHelpers.authorization_link/2` and  `PowAssent.Phoenix.ViewHelpers.deauthorization_link/2`\n* Removed `PowAssent.Phoenix.ViewHelpers.provider_link/3`\n* Rewritten plug methods and controller handling so they now pass through additional params such as access token. This makes it possible to e.g. capture access tokens. Now there is a clear distinction between user identity params and user params, and most methods now accepts or returns two separate params. Following methods updated:\n  * `MyApp.UserIdentities.create/3` changed to `MyApp.UserIdentities.create/2`\n  * `MyApp.UserIdentities.pow_assent_create/3` changed to `MyApp.UserIdentities.pow_assent_create/2`\n  * `PowAssent.Ecto.UserIdentities.Context.create/4` changed to `PowAssent.Ecto.UserIdentities.Context.create/3`\n  * `MyApp.UserIdentities.create_user/4` changed to `MyApp.UserIdentities.create_user/3`\n  * `MyApp.UserIdentities.pow_assent_create_user/4` changed to `MyApp.UserIdentities.pow_assent_create_user/3`\n  * `PowAssent.Ecto.UserIdentities.Context.create_user/5` changed to `PowAssent.Ecto.UserIdentities.Context.create_user/4`\n  * `PowAssent.Operations.create/4` changed to `PowAssent.Operations.create/3`\n  * `PowAssent.Operations.create_user/5` changed to `PowAssent.Operations.create_user/4`\n  * `PowAssent.Plug.callback/4` now returns a tuple with `{:ok, user_identity_params, user_params, conn}`\n  * `PowAssent.Plug.authenticate/3` changed to `PowAssent.Plug.authenticate/2`\n  * `PowAssent.Plug.create_identity/3` changed to `PowAssent.Plug.create_identity/2`\n  * `PowAssent.Plug.create_user/4` now accepts `user_identity_params` instead of `provider` as second argument\n  * `PowAssent.Plug.create_user/4` now expects `user_identity_params` rather than `provider` as second argument\n\n## v0.2.4 (2019-04-25)\n\n* Fixed so OAuth 2.0 access token request params are in the POST body in accordance with RFC 6749\n\n## v0.2.3 (2019-04-09)\n\n* Added `:authorization_params` config option to `PowAssent.Strategy.OAuth`\n* Plug and Phoenix controller now handles `:session_params` rather than `:state` for any params that needs to be stored temporarily during authorization\n* Added handling of `oauth_token_secret` to OAuth strategies\n* Support any `:plug` version below `2.0.0`\n* Fixed bug in `mix pow_assent.ecto.gen.migration` task where `--binary-id` flag didn't generate correct migration\n* Support `:pow` version `1.0.5`\n\n## v0.2.2 (2019-03-25)\n\n* Fixed issue where user couldn't be created when PowEmailConfirmation was enabled\n\n## v0.2.1 (2019-03-16)\n\n* Improve mix task instructions\n\n## v0.2.0 (2019-03-09)\n\n### Changes\n\n* Detached `Plug` from strategies\n* Moved callback registration/session logic from plug to controllers\n* Allow for disabling registration by setting just `pow_assent_authorize_routes/0` macro in router\n* Ensure only `:pow_assent_params` session value only can be read with the same provider param used for the callback\n* `token` now included in `PowAssent.Strategy.OAuth.callback/2` response\n* Use `account_already_bound_to_other_user/1` message for already taken user identity in `PowAssent.Phoenix.RegistrationController`\n\n### Update your custom strategies\n\nStrategies no longer has access to a `Plug.Conn` struct. If you use a custom strategy, please update it so it reflects this setup:\n\n```elixir\ndefmodule TestProvider do\n  @behaviour PowAssent.Strategy\n\n  @spec authorize_url(Keyword.t()) :: {:ok, %{url: binary()}} | {:error, term()}\n  def authorize_url(config) do\n    # Generate authorization url\n  end\n\n  @spec callback(Keyword.t(), map()) :: {:ok, %{user: map()}} | {:error, term()}\n  def callback(config, params) do\n    # Handle callback response\n  end\nend\n```\n\n## v0.1.0 (2019-02-28)\n\n* Initial release\n", "defmodule PowAssent.Config do\n  @moduledoc \"\"\"\n  Methods to parse and modify configurations.\n  \"\"\"\n\n  defmodule ConfigError do\n    defexception [:message]\n  end\n\n  @type t :: Keyword.t()\n\n  @doc \"\"\"\n  Gets the key value from the configuration.\n\n  If not found, it'll fall back to environment config, and lastly to the\n  default value which is `nil` if not specified.\n  \"\"\"\n  @spec get(t(), atom(), any()) :: any()\n  def get(config, key, default \\\\ nil) do\n    case Keyword.get(config, key, :not_found) do\n      :not_found -> get_env_config(config, key, default)\n      value      -> value\n    end\n  end\n\n  @doc \"\"\"\n  Puts a new key value to the configuration.\n  \"\"\"\n  @spec put(t(), atom(), any()) :: t()\n  def put(config, key, value) do\n    Keyword.put(config, key, value)\n  end\n\n  defp get_env_config(config, key, default, env_key \\\\ :pow_assent) do\n    config\n    |> Keyword.get(:otp_app)\n    |> case do\n      nil     -> Application.get_all_env(env_key)\n      otp_app -> Application.get_env(otp_app, env_key, [])\n    end\n    |> Keyword.get(key, default)\n  end\n\n  @doc \"\"\"\n  Gets the providers for the configuration.\n  \"\"\"\n  @spec get_providers(t()) :: t()\n  def get_providers(config), do: get(config, :providers, [])\n\n  @doc \"\"\"\n  Gets the provider configuration from the provided configuration.\n  \"\"\"\n  @spec get_provider_config(t(), atom()) :: t() | no_return\n  def get_provider_config(config, provider) do\n    config\n    |> get_providers()\n    |> get(provider)\n    |> Kernel.||(raise_error(\"No provider configuration available for #{provider}.\"))\n    |> add_global_config(config)\n  end\n\n  defp add_global_config(provider_config, config) do\n    [\n      :http_adapter,\n      :json_adapter,\n      :jwt_adapter\n    ]\n    |> Enum.map(&{&1, get(config, &1)})\n    |> Enum.reject(&is_nil(elem(&1, 1)))\n    |> Keyword.merge(provider_config)\n  end\n\n  @doc \"\"\"\n  Raise a ConfigError exception.\n  \"\"\"\n  @spec raise_error(binary()) :: no_return\n  def raise_error(message) do\n    raise ConfigError, message: message\n  end\nend\n", "defmodule PowAssent.Plug do\n  @moduledoc \"\"\"\n  Plug helper methods.\n\n  If you wish to configure PowAssent through the Pow plug interface rather than\n  environment config, please add PowAssent config with `:pow_assent` config:\n\n      plug Pow.Plug.Session,\n        repo: MyApp.Repo,\n        user: MyApp.User,\n        pow_assent: [\n          http_adapter: PowAssent.HTTPAdapter.Mint,\n          json_library: Poison,\n          user_identities_context: MyApp.UserIdentities\n        ]\n  \"\"\"\n  alias Plug.Conn\n  alias PowAssent.{Config, Operations}\n  alias Pow.Plug\n\n  @doc \"\"\"\n  Calls the authorize_url method for the provider strategy.\n\n  A generated authorization URL will be returned. If `:session_params` is\n  returned from the provider, it'll be added to the connection as private key\n  `:pow_assent_session_params`.\n\n  If `:nonce` is set to `true` in the provider configuration, a randomly\n  generated nonce will be added to the configuration.\n  \"\"\"\n  @spec authorize_url(Conn.t(), binary(), binary()) :: {:ok, binary(), Conn.t()} | {:error, any(), Conn.t()}\n  def authorize_url(conn, provider, redirect_uri) do\n    {strategy, provider_config} = get_provider_config(conn, provider, redirect_uri)\n\n    provider_config\n    |> maybe_gen_nonce()\n    |> strategy.authorize_url()\n    |> maybe_put_session_params(conn)\n  end\n\n  defp maybe_gen_nonce(config) do\n    case Config.get(config, :nonce, nil) do\n      true -> Config.put(config, :nonce, gen_nonce())\n      _any -> config\n    end\n  end\n\n  defp gen_nonce() do\n    16\n    |> :crypto.strong_rand_bytes()\n    |> Base.encode64(padding: false)\n  end\n\n  defp maybe_put_session_params({:ok, %{url: url, session_params: params}}, conn) do\n    {:ok, url, Conn.put_private(conn, :pow_assent_session_params, params)}\n  end\n  defp maybe_put_session_params({:ok, %{url: url}}, conn), do: {:ok, url, conn}\n  defp maybe_put_session_params({:error, error}, conn), do: {:error, error, conn}\n\n  @doc \"\"\"\n  Calls the callback method for the provider strategy.\n\n  Returns the user identity params and user params fetched from the provider.\n\n  `:session_params` will be added to the provider config if\n  `:pow_assent_session_params` is present as a private key in the connection.\n  \"\"\"\n  @spec callback(Conn.t(), binary(), map(), binary()) :: {:ok, map(), map(), Conn.t()} | {:error, any(), Conn.t()}\n  def callback(conn, provider, params, redirect_uri) do\n    {strategy, provider_config} = get_provider_config(conn, provider, redirect_uri)\n\n    provider_config\n    |> maybe_set_session_params_config(conn)\n    |> strategy.callback(params)\n    |> parse_callback_response(provider, conn)\n  end\n\n  defp maybe_set_session_params_config(config, %{private: %{pow_assent_session_params: params}}), do: Config.put(config, :session_params, params)\n  defp maybe_set_session_params_config(config, _conn), do: config\n\n  defp parse_callback_response({:ok, %{user: user} = response}, provider, conn) do\n    other_params = Map.drop(response, [:user])\n\n    user\n    |> normalize_username()\n    |> split_user_identity_params()\n    |> handle_user_identity_params(other_params, provider, conn)\n  end\n  defp parse_callback_response({:error, error}, _provider, conn), do: {:error, error, conn}\n\n  defp normalize_username(%{\"preferred_username\" => username} = params) do\n    params\n    |> Map.delete(\"preferred_username\")\n    |> Map.put(\"username\", username)\n  end\n  defp normalize_username(params), do: params\n\n  defp split_user_identity_params(%{\"sub\" => uid} = params) do\n    user_params = Map.delete(params, \"sub\")\n\n    {%{\"uid\" => uid}, user_params}\n  end\n\n  defp handle_user_identity_params({user_identity_params, user_params}, other_params, provider, conn) do\n    user_identity_params = Map.put(user_identity_params, \"provider\", provider)\n    other_params         = for {key, value} <- other_params, into: %{}, do: {Atom.to_string(key), value}\n\n    user_identity_params =\n      user_identity_params\n      |> Map.put(\"provider\", provider)\n      |> Map.merge(other_params)\n\n    {:ok, user_identity_params, user_params, conn}\n  end\n\n  @doc \"\"\"\n  Authenticates a user with provider and provider user params.\n\n  If successful, a new session will be created.\n  \"\"\"\n  @spec authenticate(Conn.t(), map()) :: {:ok, Conn.t()} | {:error, Conn.t()}\n  def authenticate(conn, %{\"provider\" => provider, \"uid\" => uid}) do\n    config = fetch_config(conn)\n\n    provider\n    |> Operations.get_user_by_provider_uid(uid, config)\n    |> case do\n      nil  -> {:error, conn}\n      user -> {:ok, Plug.get_plug(config).do_create(conn, user, config)}\n    end\n  end\n\n  # TODO: Remove by 0.4.0\n  @doc false\n  @deprecated \"Use `upsert_identity/2` instead\"\n  @spec create_identity(Conn.t(), map()) :: {:ok, map(), Conn.t()} | {:error, {:bound_to_different_user, map()} | map(), Conn.t()}\n  def create_identity(conn, user_identity_params), do: upsert_identity(conn, user_identity_params)\n\n  @doc \"\"\"\n  Will upsert identity for the current user.\n\n  If successful, a new session will be created.\n  \"\"\"\n  @spec upsert_identity(Conn.t(), map()) :: {:ok, map(), Conn.t()} | {:error, {:bound_to_different_user, map()} | map(), Conn.t()}\n  def upsert_identity(conn, user_identity_params) do\n    config = fetch_config(conn)\n    user   = Pow.Plug.current_user(conn)\n\n    user\n    |> Operations.upsert(user_identity_params, config)\n    |> case do\n      {:ok, user_identity} -> {:ok, user_identity, Plug.get_plug(config).do_create(conn, user, config)}\n      {:error, error}      -> {:error, error, conn}\n    end\n  end\n\n  @doc \"\"\"\n  Create a user with the provider and provider user params.\n\n  If successful, a new session will be created.\n  \"\"\"\n  @spec create_user(Conn.t(), map(), map(), map() | nil) :: {:ok, map(), Conn.t()} | {:error, {:bound_to_different_user | :invalid_user_id_field, map()} | map(), Conn.t()}\n  def create_user(conn, user_identity_params, user_params, user_id_params \\\\ nil) do\n    config = fetch_config(conn)\n\n    user_identity_params\n    |> Operations.create_user(user_params, user_id_params, config)\n    |> case do\n      {:ok, user}     -> {:ok, user, Plug.get_plug(config).do_create(conn, user, config)}\n      {:error, error} -> {:error, error, conn}\n    end\n  end\n\n  @doc \"\"\"\n  Deletes the associated user identity for the current user and provider.\n  \"\"\"\n  @spec delete_identity(Conn.t(), binary()) :: {:ok, map(), Conn.t()} | {:error, {:no_password, map()}, Conn.t()}\n  def delete_identity(conn, provider) do\n    config = fetch_config(conn)\n\n    conn\n    |> Pow.Plug.current_user()\n    |> Operations.delete(provider, config)\n    |> case do\n      {:ok, results}  -> {:ok, results, conn}\n      {:error, error} -> {:error, error, conn}\n    end\n  end\n\n  @doc \"\"\"\n  Lists associated providers for the user.\n  \"\"\"\n  @spec providers_for_current_user(Conn.t()) :: [atom()]\n  def providers_for_current_user(conn) do\n    config = fetch_config(conn)\n\n    conn\n    |> Pow.Plug.current_user()\n    |> get_all_providers_for_user(config)\n    |> Enum.map(&String.to_atom(&1.provider))\n  end\n\n  defp get_all_providers_for_user(nil, _config), do: []\n  defp get_all_providers_for_user(user, config), do: Operations.all(user, config)\n\n  @doc \"\"\"\n  Lists available providers for connection.\n  \"\"\"\n  @spec available_providers(Conn.t() | Config.t()) :: [atom()]\n  def available_providers(%Conn{} = conn) do\n    conn\n    |> fetch_config()\n    |> available_providers()\n  end\n  def available_providers(config) do\n    config\n    |> Config.get_providers()\n    |> Keyword.keys()\n  end\n\n  defp fetch_config(conn) do\n    config = Pow.Plug.fetch_config(conn)\n\n    config\n    |> Keyword.take([:otp_app, :plug, :repo, :user])\n    |> Keyword.merge(Keyword.get(config, :pow_assent, []))\n  end\n\n  defp get_provider_config(%Conn{} = conn, provider, redirect_uri) do\n    conn\n    |> fetch_config()\n    |> get_provider_config(provider, redirect_uri)\n  end\n  defp get_provider_config(config, provider, redirect_uri) do\n    provider        = String.to_atom(provider)\n    config          = Config.get_provider_config(config, provider)\n    strategy        = config[:strategy]\n    provider_config =\n      config\n      |> Keyword.delete(:strategy)\n      |> Config.put(:redirect_uri, redirect_uri)\n\n    {strategy, provider_config}\n  end\nend\n", "defmodule PowAssent.ConfigTest do\n  use ExUnit.Case\n  doctest PowAssent.Config\n\n  alias PowAssent.Config\n\n  test \"get/3\" do\n    Application.put_env(:pow_assent, :key, 1)\n    assert Config.get([], :key) == 1\n\n    Application.put_env(:test, :pow_assent, key: 2)\n    assert Config.get([otp_app: :test], :key) == 2\n  end\n\n  test \"get_providers/1\" do\n    Application.put_env(:pow_assent, :providers, [provider1: [], provider2: []])\n    assert Config.get_providers([]) == [provider1: [], provider2: []]\n  end\n\n  test \"get_provider_config/2\" do\n    Application.put_env(:pow_assent, :providers, [provider1: [a: 1], provider2: [b: 2]])\n    assert Config.get_provider_config([], :provider2) == [b: 2]\n\n    assert_raise PowAssent.Config.ConfigError, \"No provider configuration available for non_existent.\", fn ->\n      Config.get_provider_config([], :non_existent)\n    end\n\n    assert Config.get_provider_config([http_adapter: HTTPAdapater, json_adapter: JSONAdapter, jwt_adapter: JWTAdapter], :provider1) ==\n      [http_adapter: HTTPAdapater, json_adapter: JSONAdapter, jwt_adapter: JWTAdapter, a: 1]\n  end\nend\n"], "fixing_code": ["# Changelog\n\n## v0.4.4 (TBA)\n\n* [`PowAssent.Plug`] Now uses `String.to_existing_atom/1` in `PowAssent.Plug.providers_for_current_user/1`\n* [`PowAssent.Plug`] Fixed security issue by removing `String.to_atom/1` for user provided binary in `PowAssent.Plug.authorize_url/3` and `PowAssent.Plug.callback/4`\n* [`PowAssent.Config`] `PowAssent.Config.get_provider_config/2` now accepts binary provider\n\n## v0.4.3 (2019-11-20)\n\n* Removed `:phoenix_html` dependency requirement\n* Added Pow minimum requirement `~> 1.0.15`\n* Use `Pow.Extension.Base` macro for new extension setup\n\n## v0.4.2 (2019-11-13)\n\n* Added support for POST callback from provider:\n  * Added `pow_assent_authorization_post_callback_routes/0` macro to `PowAssent.Phoenix.Router`\n  * Added `:skip_csrf_protection` pipeline example and scope with `pow_assent_authorization_post_callback_routes/0` call to the docs\n  * Use `Pow.Phoenix.Router` macros to dynamically filter duplicate routes\n\n## v0.4.1 (2019-10-08)\n\n* Use Assent `v0.1.2` and set `:redirect_uri` in config for OAuth 2.0 callback phase\n\n## v0.4.0 (2019-10-06)\n\n**This release consists of major breaking changes.**\n\nYou'll have to change the `:strategy` setting in your provider configurations. For the most part it would just consists of renaming `PowAssent.Strategy.STRATEGY` to `Assent.Strategy.STRATEGY`.\n\nIf you have custom built strategies, you should can use `Assent.Strategy.normalize_userinfo/2` to conform the userinfo response from the API. `sub` is now expected instead of `uid`.\n\n### Changes\n\n* Use [`:assent` package](https://github.com/pow-auth/assent) for strategies. The following modules has been removed in favor of `Assent` modules:\n\n  * `PowAssent.CallbackError`\n  * `PowAssent.CallbackCSRFError`\n  * `PowAssent.RequestError`\n  * `PowAssent.ConfigurationError`\n  * `PowAssent.HTTPAdapter`\n  * `PowAssent.HTTPAdapter.Httpc`\n  * `PowAssent.HTTPAdapter.Mint`\n  * `PowAssent.Strategy.Auth0`\n  * `PowAssent.Strategy.AzureOAuth2`\n  * `PowAssent.Strategy.Basecamp`\n  * `PowAssent.Strategy.Discord`\n  * `PowAssent.Strategy.Facebook`\n  * `PowAssent.Strategy.Github`\n  * `PowAssent.Strategy.Gitlab`\n  * `PowAssent.Strategy.Google`\n  * `PowAssent.Strategy.Instagram`\n  * `PowAssent.Strategy.OAuth`\n  * `PowAssent.Strategy.OAuth.Base`\n  * `PowAssent.Strategy.OAuth2`\n  * `PowAssent.Strategy.OAuth2.Base`\n  * `PowAssent.Strategy.Slack`\n  * `PowAssent.Strategy.Twitter`\n  * `PowAssent.Strategy.VK`\n  * `PowAssent.Strategy`\n\n* Callback params now conforms to [OpenID Connect Core 1.0 Standard Claims spec](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.5.1). During the callback phase, the following param keys will be renamed:\n\n  * `sub` to `uid`\n  * `preferred_username` to `username`\n\n* The e-mail is no longer considered confirmed unless the callback params has an `email_verified` key set to true\n\n* `PowAssent.Plug.authorize_url/3` generates a random nonce if `nonce: true` is set in the provider configuration\n\n* Support for OpenID Connect and Apple Sign In through Assent\n\n## v0.3.2 (2019-08-25)\n\n* All links in docs generated with `mix docs` and on [hexdocs.pm](http://hexdocs.pm/pow/) now works\n* Generated docs now uses lower case file name except for `README` and `CHANGELOG`\n* Added Auth0 strategy\n* Added Gitlab strategy\n\n## v0.3.1 (2019-06-05)\n\n* Added Pow minimum requirement `~> 1.0.9`\n* Added repo `:prefix` support\n* User identities are now upserted on authorization so additional params can be updated on authorization request. Following methods has been deprecated:\n  * `PowAssent.Ecto.UserIdentities.Context.create/3` in favor of `PowAssent.Ecto.UserIdentities.Context.upsert/3`\n  * `MyApp.UserIdentities.create/2` in favor of `MyApp.UserIdentities.upsert/2`\n  * `MyApp.UserIdentities.pow_assent_create/2` in favor of `MyApp.UserIdentities.upsert/2`\n  * `PowAssent.Operations.create/3` in favor of `PowAssent.Operations.upsert/3`\n  * `PowAssent.Plug.create_identity/2` in favor of `PowAssent.Plug.upsert_identity/2`\n* Use `Pow.Plug.get_plug/1` instead of pulling `:mod` from the config\n* Fixed so `uid` can be an integer value in `PowAssent.Ecto.UserIdentities.Context`. Strategies are no longer expected to convert the `uid` value to binary. The following methods will accepts integer `uid`:\n  * `PowAssent.Ecto.UserIdentities.Context.get_user_by_provider_uid/3`\n  * `PowAssent.Ecto.UserIdentities.Context.upsert/3`\n  * `PowAssent.Ecto.UserIdentities.Context.create_user/4`\n* Fixed bug where invited user was not signed in after succesful authorization\n* Fixed bug where releases with Elixir 1.9.0 didn't have `:httpc` available\n\n## v0.3.0 (2019-05-19)\n\n* Added `PowAssent.Phoenix.ViewHelpers.authorization_link/2` and  `PowAssent.Phoenix.ViewHelpers.deauthorization_link/2`\n* Removed `PowAssent.Phoenix.ViewHelpers.provider_link/3`\n* Rewritten plug methods and controller handling so they now pass through additional params such as access token. This makes it possible to e.g. capture access tokens. Now there is a clear distinction between user identity params and user params, and most methods now accepts or returns two separate params. Following methods updated:\n  * `MyApp.UserIdentities.create/3` changed to `MyApp.UserIdentities.create/2`\n  * `MyApp.UserIdentities.pow_assent_create/3` changed to `MyApp.UserIdentities.pow_assent_create/2`\n  * `PowAssent.Ecto.UserIdentities.Context.create/4` changed to `PowAssent.Ecto.UserIdentities.Context.create/3`\n  * `MyApp.UserIdentities.create_user/4` changed to `MyApp.UserIdentities.create_user/3`\n  * `MyApp.UserIdentities.pow_assent_create_user/4` changed to `MyApp.UserIdentities.pow_assent_create_user/3`\n  * `PowAssent.Ecto.UserIdentities.Context.create_user/5` changed to `PowAssent.Ecto.UserIdentities.Context.create_user/4`\n  * `PowAssent.Operations.create/4` changed to `PowAssent.Operations.create/3`\n  * `PowAssent.Operations.create_user/5` changed to `PowAssent.Operations.create_user/4`\n  * `PowAssent.Plug.callback/4` now returns a tuple with `{:ok, user_identity_params, user_params, conn}`\n  * `PowAssent.Plug.authenticate/3` changed to `PowAssent.Plug.authenticate/2`\n  * `PowAssent.Plug.create_identity/3` changed to `PowAssent.Plug.create_identity/2`\n  * `PowAssent.Plug.create_user/4` now accepts `user_identity_params` instead of `provider` as second argument\n  * `PowAssent.Plug.create_user/4` now expects `user_identity_params` rather than `provider` as second argument\n\n## v0.2.4 (2019-04-25)\n\n* Fixed so OAuth 2.0 access token request params are in the POST body in accordance with RFC 6749\n\n## v0.2.3 (2019-04-09)\n\n* Added `:authorization_params` config option to `PowAssent.Strategy.OAuth`\n* Plug and Phoenix controller now handles `:session_params` rather than `:state` for any params that needs to be stored temporarily during authorization\n* Added handling of `oauth_token_secret` to OAuth strategies\n* Support any `:plug` version below `2.0.0`\n* Fixed bug in `mix pow_assent.ecto.gen.migration` task where `--binary-id` flag didn't generate correct migration\n* Support `:pow` version `1.0.5`\n\n## v0.2.2 (2019-03-25)\n\n* Fixed issue where user couldn't be created when PowEmailConfirmation was enabled\n\n## v0.2.1 (2019-03-16)\n\n* Improve mix task instructions\n\n## v0.2.0 (2019-03-09)\n\n### Changes\n\n* Detached `Plug` from strategies\n* Moved callback registration/session logic from plug to controllers\n* Allow for disabling registration by setting just `pow_assent_authorize_routes/0` macro in router\n* Ensure only `:pow_assent_params` session value only can be read with the same provider param used for the callback\n* `token` now included in `PowAssent.Strategy.OAuth.callback/2` response\n* Use `account_already_bound_to_other_user/1` message for already taken user identity in `PowAssent.Phoenix.RegistrationController`\n\n### Update your custom strategies\n\nStrategies no longer has access to a `Plug.Conn` struct. If you use a custom strategy, please update it so it reflects this setup:\n\n```elixir\ndefmodule TestProvider do\n  @behaviour PowAssent.Strategy\n\n  @spec authorize_url(Keyword.t()) :: {:ok, %{url: binary()}} | {:error, term()}\n  def authorize_url(config) do\n    # Generate authorization url\n  end\n\n  @spec callback(Keyword.t(), map()) :: {:ok, %{user: map()}} | {:error, term()}\n  def callback(config, params) do\n    # Handle callback response\n  end\nend\n```\n\n## v0.1.0 (2019-02-28)\n\n* Initial release\n", "defmodule PowAssent.Config do\n  @moduledoc \"\"\"\n  Methods to parse and modify configurations.\n  \"\"\"\n\n  defmodule ConfigError do\n    defexception [:message]\n  end\n\n  @type t :: Keyword.t()\n\n  @doc \"\"\"\n  Gets the key value from the configuration.\n\n  If not found, it'll fall back to environment config, and lastly to the\n  default value which is `nil` if not specified.\n  \"\"\"\n  @spec get(t(), atom(), any()) :: any()\n  def get(config, key, default \\\\ nil) do\n    case Keyword.get(config, key, :not_found) do\n      :not_found -> get_env_config(config, key, default)\n      value      -> value\n    end\n  end\n\n  @doc \"\"\"\n  Puts a new key value to the configuration.\n  \"\"\"\n  @spec put(t(), atom(), any()) :: t()\n  def put(config, key, value) do\n    Keyword.put(config, key, value)\n  end\n\n  defp get_env_config(config, key, default, env_key \\\\ :pow_assent) do\n    config\n    |> Keyword.get(:otp_app)\n    |> case do\n      nil     -> Application.get_all_env(env_key)\n      otp_app -> Application.get_env(otp_app, env_key, [])\n    end\n    |> Keyword.get(key, default)\n  end\n\n  @doc \"\"\"\n  Gets the providers for the configuration.\n  \"\"\"\n  @spec get_providers(t()) :: t()\n  def get_providers(config), do: get(config, :providers, [])\n\n  @doc \"\"\"\n  Gets the provider configuration from the provided configuration.\n  \"\"\"\n  @spec get_provider_config(t(), atom() | binary()) :: t() | no_return\n  def get_provider_config(config, provider) do\n    config\n    |> get_providers()\n    |> get_for_provider(provider)\n    |> Kernel.||(raise_error(\"No provider configuration available for #{provider}.\"))\n    |> add_global_config(config)\n  end\n\n  defp get_for_provider(providers_config, provider) when is_atom(provider) do\n    get(providers_config, provider)\n  end\n  defp get_for_provider(providers_config, provider) when is_binary(provider) do\n    Enum.find_value(providers_config, fn {key, value} ->\n      case Atom.to_string(key) do\n        ^provider -> value\n        _any      -> false\n      end\n    end)\n  end\n\n  defp add_global_config(provider_config, config) do\n    [\n      :http_adapter,\n      :json_adapter,\n      :jwt_adapter\n    ]\n    |> Enum.map(&{&1, get(config, &1)})\n    |> Enum.reject(&is_nil(elem(&1, 1)))\n    |> Keyword.merge(provider_config)\n  end\n\n  @doc \"\"\"\n  Raise a ConfigError exception.\n  \"\"\"\n  @spec raise_error(binary()) :: no_return\n  def raise_error(message) do\n    raise ConfigError, message: message\n  end\nend\n", "defmodule PowAssent.Plug do\n  @moduledoc \"\"\"\n  Plug helper methods.\n\n  If you wish to configure PowAssent through the Pow plug interface rather than\n  environment config, please add PowAssent config with `:pow_assent` config:\n\n      plug Pow.Plug.Session,\n        repo: MyApp.Repo,\n        user: MyApp.User,\n        pow_assent: [\n          http_adapter: PowAssent.HTTPAdapter.Mint,\n          json_library: Poison,\n          user_identities_context: MyApp.UserIdentities\n        ]\n  \"\"\"\n  alias Plug.Conn\n  alias PowAssent.{Config, Operations}\n  alias Pow.Plug\n\n  @doc \"\"\"\n  Calls the authorize_url method for the provider strategy.\n\n  A generated authorization URL will be returned. If `:session_params` is\n  returned from the provider, it'll be added to the connection as private key\n  `:pow_assent_session_params`.\n\n  If `:nonce` is set to `true` in the provider configuration, a randomly\n  generated nonce will be added to the configuration.\n  \"\"\"\n  @spec authorize_url(Conn.t(), binary(), binary()) :: {:ok, binary(), Conn.t()} | {:error, any(), Conn.t()}\n  def authorize_url(conn, provider, redirect_uri) do\n    {strategy, provider_config} = get_provider_config(conn, provider, redirect_uri)\n\n    provider_config\n    |> maybe_gen_nonce()\n    |> strategy.authorize_url()\n    |> maybe_put_session_params(conn)\n  end\n\n  defp maybe_gen_nonce(config) do\n    case Config.get(config, :nonce, nil) do\n      true -> Config.put(config, :nonce, gen_nonce())\n      _any -> config\n    end\n  end\n\n  defp gen_nonce() do\n    16\n    |> :crypto.strong_rand_bytes()\n    |> Base.encode64(padding: false)\n  end\n\n  defp maybe_put_session_params({:ok, %{url: url, session_params: params}}, conn) do\n    {:ok, url, Conn.put_private(conn, :pow_assent_session_params, params)}\n  end\n  defp maybe_put_session_params({:ok, %{url: url}}, conn), do: {:ok, url, conn}\n  defp maybe_put_session_params({:error, error}, conn), do: {:error, error, conn}\n\n  @doc \"\"\"\n  Calls the callback method for the provider strategy.\n\n  Returns the user identity params and user params fetched from the provider.\n\n  `:session_params` will be added to the provider config if\n  `:pow_assent_session_params` is present as a private key in the connection.\n  \"\"\"\n  @spec callback(Conn.t(), binary(), map(), binary()) :: {:ok, map(), map(), Conn.t()} | {:error, any(), Conn.t()}\n  def callback(conn, provider, params, redirect_uri) do\n    {strategy, provider_config} = get_provider_config(conn, provider, redirect_uri)\n\n    provider_config\n    |> maybe_set_session_params_config(conn)\n    |> strategy.callback(params)\n    |> parse_callback_response(provider, conn)\n  end\n\n  defp maybe_set_session_params_config(config, %{private: %{pow_assent_session_params: params}}), do: Config.put(config, :session_params, params)\n  defp maybe_set_session_params_config(config, _conn), do: config\n\n  defp parse_callback_response({:ok, %{user: user} = response}, provider, conn) do\n    other_params = Map.drop(response, [:user])\n\n    user\n    |> normalize_username()\n    |> split_user_identity_params()\n    |> handle_user_identity_params(other_params, provider, conn)\n  end\n  defp parse_callback_response({:error, error}, _provider, conn), do: {:error, error, conn}\n\n  defp normalize_username(%{\"preferred_username\" => username} = params) do\n    params\n    |> Map.delete(\"preferred_username\")\n    |> Map.put(\"username\", username)\n  end\n  defp normalize_username(params), do: params\n\n  defp split_user_identity_params(%{\"sub\" => uid} = params) do\n    user_params = Map.delete(params, \"sub\")\n\n    {%{\"uid\" => uid}, user_params}\n  end\n\n  defp handle_user_identity_params({user_identity_params, user_params}, other_params, provider, conn) do\n    user_identity_params = Map.put(user_identity_params, \"provider\", provider)\n    other_params         = for {key, value} <- other_params, into: %{}, do: {Atom.to_string(key), value}\n\n    user_identity_params =\n      user_identity_params\n      |> Map.put(\"provider\", provider)\n      |> Map.merge(other_params)\n\n    {:ok, user_identity_params, user_params, conn}\n  end\n\n  @doc \"\"\"\n  Authenticates a user with provider and provider user params.\n\n  If successful, a new session will be created.\n  \"\"\"\n  @spec authenticate(Conn.t(), map()) :: {:ok, Conn.t()} | {:error, Conn.t()}\n  def authenticate(conn, %{\"provider\" => provider, \"uid\" => uid}) do\n    config = fetch_config(conn)\n\n    provider\n    |> Operations.get_user_by_provider_uid(uid, config)\n    |> case do\n      nil  -> {:error, conn}\n      user -> {:ok, Plug.get_plug(config).do_create(conn, user, config)}\n    end\n  end\n\n  # TODO: Remove by 0.4.0\n  @doc false\n  @deprecated \"Use `upsert_identity/2` instead\"\n  @spec create_identity(Conn.t(), map()) :: {:ok, map(), Conn.t()} | {:error, {:bound_to_different_user, map()} | map(), Conn.t()}\n  def create_identity(conn, user_identity_params), do: upsert_identity(conn, user_identity_params)\n\n  @doc \"\"\"\n  Will upsert identity for the current user.\n\n  If successful, a new session will be created.\n  \"\"\"\n  @spec upsert_identity(Conn.t(), map()) :: {:ok, map(), Conn.t()} | {:error, {:bound_to_different_user, map()} | map(), Conn.t()}\n  def upsert_identity(conn, user_identity_params) do\n    config = fetch_config(conn)\n    user   = Pow.Plug.current_user(conn)\n\n    user\n    |> Operations.upsert(user_identity_params, config)\n    |> case do\n      {:ok, user_identity} -> {:ok, user_identity, Plug.get_plug(config).do_create(conn, user, config)}\n      {:error, error}      -> {:error, error, conn}\n    end\n  end\n\n  @doc \"\"\"\n  Create a user with the provider and provider user params.\n\n  If successful, a new session will be created.\n  \"\"\"\n  @spec create_user(Conn.t(), map(), map(), map() | nil) :: {:ok, map(), Conn.t()} | {:error, {:bound_to_different_user | :invalid_user_id_field, map()} | map(), Conn.t()}\n  def create_user(conn, user_identity_params, user_params, user_id_params \\\\ nil) do\n    config = fetch_config(conn)\n\n    user_identity_params\n    |> Operations.create_user(user_params, user_id_params, config)\n    |> case do\n      {:ok, user}     -> {:ok, user, Plug.get_plug(config).do_create(conn, user, config)}\n      {:error, error} -> {:error, error, conn}\n    end\n  end\n\n  @doc \"\"\"\n  Deletes the associated user identity for the current user and provider.\n  \"\"\"\n  @spec delete_identity(Conn.t(), binary()) :: {:ok, map(), Conn.t()} | {:error, {:no_password, map()}, Conn.t()}\n  def delete_identity(conn, provider) do\n    config = fetch_config(conn)\n\n    conn\n    |> Pow.Plug.current_user()\n    |> Operations.delete(provider, config)\n    |> case do\n      {:ok, results}  -> {:ok, results, conn}\n      {:error, error} -> {:error, error, conn}\n    end\n  end\n\n  @doc \"\"\"\n  Lists associated providers for the user.\n  \"\"\"\n  @spec providers_for_current_user(Conn.t()) :: [atom()]\n  def providers_for_current_user(conn) do\n    config = fetch_config(conn)\n\n    conn\n    |> Pow.Plug.current_user()\n    |> get_all_providers_for_user(config)\n    |> Enum.map(&String.to_existing_atom(&1.provider))\n  end\n\n  defp get_all_providers_for_user(nil, _config), do: []\n  defp get_all_providers_for_user(user, config), do: Operations.all(user, config)\n\n  @doc \"\"\"\n  Lists available providers for connection.\n  \"\"\"\n  @spec available_providers(Conn.t() | Config.t()) :: [atom()]\n  def available_providers(%Conn{} = conn) do\n    conn\n    |> fetch_config()\n    |> available_providers()\n  end\n  def available_providers(config) do\n    config\n    |> Config.get_providers()\n    |> Keyword.keys()\n  end\n\n  defp fetch_config(conn) do\n    config = Pow.Plug.fetch_config(conn)\n\n    config\n    |> Keyword.take([:otp_app, :plug, :repo, :user])\n    |> Keyword.merge(Keyword.get(config, :pow_assent, []))\n  end\n\n  defp get_provider_config(%Conn{} = conn, provider, redirect_uri) do\n    conn\n    |> fetch_config()\n    |> get_provider_config(provider, redirect_uri)\n  end\n  defp get_provider_config(config, provider, redirect_uri) do\n    config          = Config.get_provider_config(config, provider)\n    strategy        = config[:strategy]\n    provider_config =\n      config\n      |> Keyword.delete(:strategy)\n      |> Config.put(:redirect_uri, redirect_uri)\n\n    {strategy, provider_config}\n  end\nend\n", "defmodule PowAssent.ConfigTest do\n  use ExUnit.Case\n  doctest PowAssent.Config\n\n  alias PowAssent.Config\n\n  test \"get/3\" do\n    Application.put_env(:pow_assent, :key, 1)\n    assert Config.get([], :key) == 1\n\n    Application.put_env(:test, :pow_assent, key: 2)\n    assert Config.get([otp_app: :test], :key) == 2\n  end\n\n  test \"get_providers/1\" do\n    Application.put_env(:pow_assent, :providers, [provider1: [], provider2: []])\n    assert Config.get_providers([]) == [provider1: [], provider2: []]\n  end\n\n  test \"get_provider_config/2\" do\n    Application.put_env(:pow_assent, :providers, [provider1: [a: 1], provider2: [b: 2]])\n    assert Config.get_provider_config([], :provider2) == [b: 2]\n\n    assert_raise PowAssent.Config.ConfigError, \"No provider configuration available for non_existent.\", fn ->\n      Config.get_provider_config([], :non_existent)\n    end\n\n    assert Config.get_provider_config([http_adapter: HTTPAdapater, json_adapter: JSONAdapter, jwt_adapter: JWTAdapter], :provider1) ==\n      [http_adapter: HTTPAdapater, json_adapter: JSONAdapter, jwt_adapter: JWTAdapter, a: 1]\n  end\n\n  test \"get_provider_config/2 with binary provider\" do\n    config = [providers: [provider1: [a: 1], provider2: [b: 2]]]\n\n    assert Config.get_provider_config(config, \"provider1\") == [a: 1]\n\n    assert_raise PowAssent.Config.ConfigError, \"No provider configuration available for non_existent.\", fn ->\n      refute Config.get_provider_config(config, \"non_existent\")\n    end\n  end\nend\n"], "filenames": ["CHANGELOG.md", "lib/pow_assent/config.ex", "lib/pow_assent/plug.ex", "test/pow_assent/config_test.exs"], "buggy_code_start_loc": [1, 53, 200, 30], "buggy_code_end_loc": [1, 59, 236, 30], "fixing_code_start_loc": [2, 53, 200, 31], "fixing_code_end_loc": [8, 72, 234, 41], "type": "NVD-CWE-noinfo", "message": "The use of `String.to_atom/1` in PowAssent is susceptible to denial of service attacks. In `PowAssent.Phoenix.AuthorizationController` a value is fetched from the user provided params, and `String.to_atom/1` is used to convert the binary value to an atom so it can be used to fetch the provider configuration value. This is unsafe as it is user provided data, and can be used to fill up the whole atom table of ~1M which will cause the app to crash.", "other": {"cve": {"id": "CVE-2019-16764", "sourceIdentifier": "security-advisories@github.com", "published": "2019-11-25T17:15:11.713", "lastModified": "2021-10-28T13:21:40.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The use of `String.to_atom/1` in PowAssent is susceptible to denial of service attacks. In `PowAssent.Phoenix.AuthorizationController` a value is fetched from the user provided params, and `String.to_atom/1` is used to convert the binary value to an atom so it can be used to fetch the provider configuration value. This is unsafe as it is user provided data, and can be used to fill up the whole atom table of ~1M which will cause the app to crash."}, {"lang": "es", "value": "El uso de \"String.to_atom/1\" en PowAssent es susceptible a ataques de denegaci\u00f3n de servicio. En \"PowAssent.Phoenix.AuthorizationController\" se obtiene un valor de los par\u00e1metros proporcionados por parte el usuario, y \"String.to_atom/1\" es usado para convertir el valor binario en un \u00e1tomo para que pueda usarse para obtener el valor de configuraci\u00f3n del proveedor. Esto no es seguro, ya que son datos suministrados por parte el usuario, y se pueden ser usados para llenar toda la tabla de \u00e1tomos de ~1M, lo que causar\u00e1 que la aplicaci\u00f3n se bloque\u00e9"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:powauth:powassent:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.4", "matchCriteriaId": "A7675EB0-7582-4883-A50F-889C5DC77B95"}]}]}], "references": [{"url": "http://erlang.org/doc/efficiency_guide/commoncaveats.html#list_to_atom-1", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/pow-auth/pow_assent/commit/026105eeecc0e3c2f807e7109e745ea93c0fd9cf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pow-auth/pow_assent/security/advisories/GHSA-368c-xvrv-x986", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://hex.pm/packages/pow_assent", "source": "security-advisories@github.com", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/pow-auth/pow_assent/commit/026105eeecc0e3c2f807e7109e745ea93c0fd9cf"}}