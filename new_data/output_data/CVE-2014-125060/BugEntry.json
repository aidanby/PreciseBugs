{"buggy_code": ["#include \"calenderServer.h\"\n#include \"serverActions.h\"\n#include \"persistentState.h\"\n#include \"renderPage.h\"\n#include \"objectCache.h\"\n#include <iostream>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <thread>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <unistd.h>\n#include <vector>\n#include <map>\n#include <boost/algorithm/string.hpp>\n  \nusing namespace std;\n\nint main(int argc, char** argv){\n  // Grab the port number from the command line, handling bad inputs.\n  int portNum;\n  if (argc != 2)\n    printUsageAndExit();\n\n  try{\n    portNum = stoi(argv[1]);\n  } catch(invalid_argument e){\n    cerr << \"Not a valid number!\" << endl;\n    printUsageAndExit();\n  } catch(out_of_range e){\n    cerr << \"Port must be between 1 and 65535!\" << endl;\n    printUsageAndExit();\n  }\n  if (portNum < 1 || portNum > 65535){\n    cerr << \"Port must be between 1 and 65535!\" << endl;\n    printUsageAndExit();\n  }\n\n  // Load persistent server state.\n  init();\n\n  // Listen for and handle incoming connections.\n  serverListen(portNum);\n\n  // Save persistent state. This particular call will actually never\n  // happen, since we loop until the user forcefully quits us at\n  // present, but luckily we also call shutdown() when we get\n  // interrupted with a ctrl-C.\n  shutdown();\n}\n\nvoid printUsageAndExit(){\n  cerr << \"Usage: ./calenderServer portNum, where portNum is the number of the port to listen on. \" << endl;\n  exit(1);\n}\n\nvoid serverListen(int portNum){\n  // Lots of structure set up.\n  struct addrinfo hints;\n  struct addrinfo* serverInfo;\n  char portBuf[6];\n  int listenSocket;\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE;\n\n  // Convert the int port to a string.\n  sprintf(portBuf, \"%d\", portNum);\n\n  // Set up sockets\n  if (getaddrinfo(NULL, portBuf, &hints, &serverInfo) != 0){\n    cerr << \"Problem getting address info!\" << endl;\n    exit(1);\n  }\n\n  if((listenSocket = socket(serverInfo->ai_family, serverInfo->ai_socktype, serverInfo->ai_protocol)) == -1){\n    cerr << \"Couldn't get a system socket!\" << endl;\n    exit(1);\n  }\n  openSockets.push_front(listenSocket);\n  int yes = 1;\n  setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n\n  if(bind(listenSocket, serverInfo->ai_addr, serverInfo->ai_addrlen) == -1){\n    cerr << \"Couldn't bind the socket!\" << endl;\n    exit(1);\n  }\n\n  freeaddrinfo(serverInfo);\n\n  if(listen(listenSocket, 10) == -1){\n    cerr << \"Couldn't listen on socket!\" << endl;\n    exit(1);\n  }\n\n  // Loop listening for clients until someone stops us.\n  listenLoop(listenSocket);\n}\n\nvoid listenLoop(int listenSocket){\n  struct sockaddr_storage clientAddr;\n  socklen_t cAddrSize = sizeof(clientAddr);\n  list<thread> clientThreads;\n  thread ttlThread(expireSessionIDs);\n  int clientSocket;\n\n  while(true){\n    if((clientSocket = accept(listenSocket, (struct sockaddr *)&clientAddr, &cAddrSize)) == -1){\n      cerr << \"Failed to accept client.\" << endl;\n      continue;\n    }\n    openSockets.push_front(clientSocket);\n    clientThreads.push_front(thread(handleClient, clientSocket));\n  }\n}\nvoid expireSessionIDs(){\n  while(true){\n    for(auto sessionTTLMapping : sessionTTLs){\n      if(sessionTTLMapping.second-- <= 0){\n\tsessionMap.erase(sessionTTLMapping.first);\n\tsessionTTLs.erase(sessionTTLMapping.first);\n      }\n    }\n    sleep(1);\n  }\n}\n\nconst int BUFFERSIZE = 513;\nvoid handleClient(int clientSocket){\n  // Buffer to hold part of the request.\n  char requestBuffer[BUFFERSIZE];\n  // c++ strings for the request and response.\n  string request;\n  string response;\n  // How many bytes we received this call.\n  int bytesReceived;\n  // How many bytes we've sent total.\n  unsigned bytesSent;\n  // How many bytes we've sent this call.\n  int sending;\n\n  //while(true){\n    // Recieve a single request.\n    bytesReceived = recv(clientSocket, requestBuffer, BUFFERSIZE, 0);\n    while(bytesReceived == BUFFERSIZE){\n      request.append(requestBuffer, bytesReceived);\n      bytesReceived = recv(clientSocket, requestBuffer, BUFFERSIZE, MSG_DONTWAIT);\n    }\n    if (bytesReceived != -1) {\n      request.append(requestBuffer, bytesReceived);\n    }\n    if (bytesReceived == 0) return;\n    // Get the response.\n    try{\n      response = handleRequest(request);\n    } catch (exception e){\n      cerr << \"got an exception, killing client thread...\" << endl;\n      return;\n    }\n\n    // Reply\n    bytesSent = 0;\n    while(bytesSent < response.length()){\n      sending = send(clientSocket, response.c_str(), response.length(), 0);\n      if (sending == -1){\n\tcerr << \"Failed to respond to client. \" << endl;\n\tbreak;\n      }\n      bytesSent += sending;\n    }\n\n    // If the client didn't close the connection, we'll reply\n    // again. Otherwise, we'll just try to receive andf then break.\n    //}\n  close(clientSocket);\n  openSockets.remove(clientSocket);\n}\n\nstring handleRequest(const string& request){\n  map<string, string>* reqHeaders = parseRequest(request);\n  if ((*reqHeaders)[\"method\"].compare(\"GET\") == 0) {\n    string response = handleGet(reqHeaders);\n    delete reqHeaders;\n    return response;\n  } else if ((*reqHeaders)[\"method\"].compare(\"POST\") == 0) {\n    string response = handlePost(reqHeaders);\n    delete reqHeaders;\n    return response;\n  } else {\n    // should make 404\n    string message = \"404 Page Not Found\";\n    cout << \"returning error, method is '\" << (*reqHeaders)[\"method\"] << \"'\" << endl;\n    string result = getResponseHeader(\"HTTP/1.1 404 Not Found\", reqHeaders, message.size()) + \"\\r\\n\" + message;\n    delete reqHeaders;\n    return result;\n  }\n}\n\nmap<string, string>* parseRequest(const string& request) {\n  map<string, string>* headers = new map<string, string>();\n  string delim = \"\\r\\n\";\n  vector<string> lines;\n  boost::iter_split(lines, request,\n                    boost::first_finder(delim, boost::is_iequal()));\n  string method = lines[0].substr(0, lines[0].find(\" \"));\n  (*headers)[\"method\"] = method;\n  lines[0] = lines[0].substr(lines[0].find(\" \") + 1);\n  (*headers)[\"uri\"] = lines[0].substr(0, lines[0].find(\" \"));\n  for (size_t i = 1; i < lines.size(); i++) {\n    if (method.compare(\"POST\") == 0 && i == lines.size() - 1) {\n      //cout << \"params is \" << lines[i] << endl;\n      (*headers)[\"params\"] = lines[i];\n      break;\n    } else if (method.compare(\"GET\") == 0 && lines[i].compare(\"\") == 0) {\n      break;\n    } else if (method.compare(\"POST\") == 0 && lines[i].compare(\"\") == 0) {\n      i = lines.size() - 2;\n    } else if (method.compare(\"POST\") != 0 || lines[i].compare(\"\") != 0) {\n      int mid = lines[i].find(\": \");\n      string name = lines[i].substr(0, mid);\n      string val = lines[i].substr(mid+2, string::npos);\n      transform(val.begin(), val.end(), val.begin(), ::tolower);\n      (*headers)[name] = val;\n    }\n  }\n\n  return headers;\n}\n\nstring handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    // cal page\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    //cout << \"getevents\" << endl;\n    // getEvents, has uid\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}\n\nstring handlePost(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  cout << \"handling post\" << endl;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  //cout << \"uri is \" << uri << \", uid is \" << uid << endl;\n\n  string body;\n  if (uri.compare(\"/createUser\") == 0) {\n    cout << \"create user\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long newId = makeUser(username, password);\n    stringstream bodyStream;\n\n    if (newId == -1) {\n      bodyStream << \"Error: Could not create user '\" << username << \"'\" << endl;\n    } else {\n      bodyStream << \"Successfully created user '\" << username << \"'! Please log in.\" << endl;\n    }\n\n    body = bodyStream.str();\n  } else if (uri.compare(\"/login\") == 0) {\n    if (uid != -1)\n      logout(uid);\n    cout << \"login\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long long sess = login(username, password);\n\n    stringstream bodyStream;\n    if (sess == -1) {\n      bodyStream << getLogin();\n    } else {\n      stringstream cookie;\n      cookie << \"sessionId=\" << sess;\n      resHeaders[\"Set-Cookie\"] = cookie.str();\n\n      bodyStream << getHeader(username);\n      bodyStream << getEmptyCalendar();\n      bodyStream << getFooter();\n    }\n\n\n    body = bodyStream.str();\n    \n\n  } else if (uri.compare(\"/createGroup\") == 0 && uid != -1) {\n    cout << \"createGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11);\n    replace(groupName.begin(), groupName.end(), '+', ' ');\n\n    stringstream bodyStream;\n    long groupId = makeGroup(uid, groupName);\n    if (groupId != -1) {\n      cout << \"made group!\" << endl;\n      bodyStream << \"Successfully created group '\" << groupName << \"'\";\n    } else {\n      cout << \"makeGroup was -1.\" << endl;\n      bodyStream << \"Error: could not create group '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/addToGroup\") == 0 && uid != -1) {\n    cout << \"addToGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    string addedName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    bool admin = params.find(\"admin\") != string::npos;\n    long groupId = groupIdByName(groupName);\n    long addedId = userIdByName(addedName);\n\n    stringstream bodyStream;\n    bool added = addToGroup(uid, addedId, groupId, admin);\n\n    if (added) {\n      cout << \"added to group!\" << endl;\n      bodyStream << \"Successfully added '\" << addedName << \"' to '\" << groupName << \"'\";\n    } else {\n      cout << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n      bodyStream << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/createEvent\") == 0 && uid != -1) {\n    cout << \"createEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    replace(eventName.begin(), eventName.end(), '+', ' ');\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n    params = params.substr(params.find(\"&\") + 1);\n    bool withGroup = params.size() > 11;\n\n    cout << \"eName: \" << eventName << \" tS: \" << timeString << \" wG: \" << withGroup << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    long eventId;\n    if (withGroup) {\n      string groupName = params.substr(11);\n      long groupId = groupIdByName(groupName);\n      cout << \"gName: \" << groupName << \" gID: \" << groupId << endl;\n\n      eventId = makeEvent(uid, eventName, eventTime, groupId, true);\n    } else {\n      eventId = makeEvent(uid, eventName, eventTime);\n    }\n\n    stringstream bodyStream;\n    if (eventId != -1) {\n      cout << \"made event!\" << endl;\n      bodyStream << \"Successfully created event '\" << eventName << \"'\";\n    } else {\n      cout << \"couldn't make event.\" << endl;\n      bodyStream << \"Error: could not create event '\" << eventName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/editEvent\") == 0 && uid != -1) {\n    cout << \"editEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    long eventId = stol(params.substr(3, params.find(\"&\") - 3), nullptr);\n    params = params.substr(params.find(\"&\") + 1);\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n\n    cout << \"eID: \" << eventId << \" eName: \" << eventName << \" dt: \" << timeString << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    renameEvent(uid, eventId, eventName);\n    rescheduleEvent(uid, eventId, eventTime);\n\n    stringstream bodyStream;\n    cout << \"edited event!\" << endl;\n    bodyStream << \"Successfully edited event.\";\n\n    body = bodyStream.str();\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "fixing_code": ["#include \"calenderServer.h\"\n#include \"serverActions.h\"\n#include \"persistentState.h\"\n#include \"renderPage.h\"\n#include \"objectCache.h\"\n#include <iostream>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <thread>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <unistd.h>\n#include <vector>\n#include <map>\n#include <boost/algorithm/string.hpp>\n  \nusing namespace std;\n\nint main(int argc, char** argv){\n  // Grab the port number from the command line, handling bad inputs.\n  int portNum;\n  if (argc != 2)\n    printUsageAndExit();\n\n  try{\n    portNum = stoi(argv[1]);\n  } catch(invalid_argument e){\n    cerr << \"Not a valid number!\" << endl;\n    printUsageAndExit();\n  } catch(out_of_range e){\n    cerr << \"Port must be between 1 and 65535!\" << endl;\n    printUsageAndExit();\n  }\n  if (portNum < 1 || portNum > 65535){\n    cerr << \"Port must be between 1 and 65535!\" << endl;\n    printUsageAndExit();\n  }\n\n  // Load persistent server state.\n  init();\n\n  // Listen for and handle incoming connections.\n  serverListen(portNum);\n\n  // Save persistent state. This particular call will actually never\n  // happen, since we loop until the user forcefully quits us at\n  // present, but luckily we also call shutdown() when we get\n  // interrupted with a ctrl-C.\n  shutdown();\n}\n\nvoid printUsageAndExit(){\n  cerr << \"Usage: ./calenderServer portNum, where portNum is the number of the port to listen on. \" << endl;\n  exit(1);\n}\n\nvoid serverListen(int portNum){\n  // Lots of structure set up.\n  struct addrinfo hints;\n  struct addrinfo* serverInfo;\n  char portBuf[6];\n  int listenSocket;\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE;\n\n  // Convert the int port to a string.\n  sprintf(portBuf, \"%d\", portNum);\n\n  // Set up sockets\n  if (getaddrinfo(NULL, portBuf, &hints, &serverInfo) != 0){\n    cerr << \"Problem getting address info!\" << endl;\n    exit(1);\n  }\n\n  if((listenSocket = socket(serverInfo->ai_family, serverInfo->ai_socktype, serverInfo->ai_protocol)) == -1){\n    cerr << \"Couldn't get a system socket!\" << endl;\n    exit(1);\n  }\n  openSockets.push_front(listenSocket);\n  int yes = 1;\n  setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n\n  if(bind(listenSocket, serverInfo->ai_addr, serverInfo->ai_addrlen) == -1){\n    cerr << \"Couldn't bind the socket!\" << endl;\n    exit(1);\n  }\n\n  freeaddrinfo(serverInfo);\n\n  if(listen(listenSocket, 10) == -1){\n    cerr << \"Couldn't listen on socket!\" << endl;\n    exit(1);\n  }\n\n  // Loop listening for clients until someone stops us.\n  listenLoop(listenSocket);\n}\n\nvoid listenLoop(int listenSocket){\n  struct sockaddr_storage clientAddr;\n  socklen_t cAddrSize = sizeof(clientAddr);\n  list<thread> clientThreads;\n  thread ttlThread(expireSessionIDs);\n  int clientSocket;\n\n  while(true){\n    if((clientSocket = accept(listenSocket, (struct sockaddr *)&clientAddr, &cAddrSize)) == -1){\n      cerr << \"Failed to accept client.\" << endl;\n      continue;\n    }\n    openSockets.push_front(clientSocket);\n    clientThreads.push_front(thread(handleClient, clientSocket));\n  }\n}\nvoid expireSessionIDs(){\n  while(true){\n    for(auto sessionTTLMapping : sessionTTLs){\n      if(sessionTTLMapping.second-- <= 0){\n\tsessionMap.erase(sessionTTLMapping.first);\n\tsessionTTLs.erase(sessionTTLMapping.first);\n      }\n    }\n    sleep(1);\n  }\n}\n\nconst int BUFFERSIZE = 513;\nvoid handleClient(int clientSocket){\n  // Buffer to hold part of the request.\n  char requestBuffer[BUFFERSIZE];\n  // c++ strings for the request and response.\n  string request;\n  string response;\n  // How many bytes we received this call.\n  int bytesReceived;\n  // How many bytes we've sent total.\n  unsigned bytesSent;\n  // How many bytes we've sent this call.\n  int sending;\n\n  //while(true){\n    // Recieve a single request.\n    bytesReceived = recv(clientSocket, requestBuffer, BUFFERSIZE, 0);\n    while(bytesReceived == BUFFERSIZE){\n      request.append(requestBuffer, bytesReceived);\n      bytesReceived = recv(clientSocket, requestBuffer, BUFFERSIZE, MSG_DONTWAIT);\n    }\n    if (bytesReceived != -1) {\n      request.append(requestBuffer, bytesReceived);\n    }\n    if (bytesReceived == 0) return;\n    // Get the response.\n    try{\n      response = handleRequest(request);\n    } catch (exception e){\n      cerr << \"got an exception, killing client thread...\" << endl;\n      return;\n    }\n\n    // Reply\n    bytesSent = 0;\n    while(bytesSent < response.length()){\n      sending = send(clientSocket, response.c_str(), response.length(), 0);\n      if (sending == -1){\n\tcerr << \"Failed to respond to client. \" << endl;\n\tbreak;\n      }\n      bytesSent += sending;\n    }\n\n    // If the client didn't close the connection, we'll reply\n    // again. Otherwise, we'll just try to receive andf then break.\n    //}\n  close(clientSocket);\n  openSockets.remove(clientSocket);\n}\n\nstring handleRequest(const string& request){\n  map<string, string>* reqHeaders = parseRequest(request);\n  if ((*reqHeaders)[\"method\"].compare(\"GET\") == 0) {\n    string response = handleGet(reqHeaders);\n    delete reqHeaders;\n    return response;\n  } else if ((*reqHeaders)[\"method\"].compare(\"POST\") == 0) {\n    string response = handlePost(reqHeaders);\n    delete reqHeaders;\n    return response;\n  } else {\n    // should make 404\n    string message = \"404 Page Not Found\";\n    cout << \"returning error, method is '\" << (*reqHeaders)[\"method\"] << \"'\" << endl;\n    string result = getResponseHeader(\"HTTP/1.1 404 Not Found\", reqHeaders, message.size()) + \"\\r\\n\" + message;\n    delete reqHeaders;\n    return result;\n  }\n}\n\nmap<string, string>* parseRequest(const string& request) {\n  map<string, string>* headers = new map<string, string>();\n  string delim = \"\\r\\n\";\n  vector<string> lines;\n  boost::iter_split(lines, request,\n                    boost::first_finder(delim, boost::is_iequal()));\n  string method = lines[0].substr(0, lines[0].find(\" \"));\n  (*headers)[\"method\"] = method;\n  lines[0] = lines[0].substr(lines[0].find(\" \") + 1);\n  (*headers)[\"uri\"] = lines[0].substr(0, lines[0].find(\" \"));\n  for (size_t i = 1; i < lines.size(); i++) {\n    if (method.compare(\"POST\") == 0 && i == lines.size() - 1) {\n      //cout << \"params is \" << lines[i] << endl;\n      (*headers)[\"params\"] = lines[i];\n      break;\n    } else if (method.compare(\"GET\") == 0 && lines[i].compare(\"\") == 0) {\n      break;\n    } else if (method.compare(\"POST\") == 0 && lines[i].compare(\"\") == 0) {\n      i = lines.size() - 2;\n    } else if (method.compare(\"POST\") != 0 || lines[i].compare(\"\") != 0) {\n      int mid = lines[i].find(\": \");\n      string name = lines[i].substr(0, mid);\n      string val = lines[i].substr(mid+2, string::npos);\n      transform(val.begin(), val.end(), val.begin(), ::tolower);\n      (*headers)[name] = val;\n    }\n  }\n\n  return headers;\n}\n\nstring handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = usersessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    // cal page\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    //cout << \"getevents\" << endl;\n    // getEvents, has uid\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}\n\nstring handlePost(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  cout << \"handling post\" << endl;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto sessionIt = sessionMap.find(sessionId);\n    if(sessionIt != sessionMap.end())\n      uid = sessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  //cout << \"uri is \" << uri << \", uid is \" << uid << endl;\n\n  string body;\n  if (uri.compare(\"/createUser\") == 0) {\n    cout << \"create user\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long newId = makeUser(username, password);\n    stringstream bodyStream;\n\n    if (newId == -1) {\n      bodyStream << \"Error: Could not create user '\" << username << \"'\" << endl;\n    } else {\n      bodyStream << \"Successfully created user '\" << username << \"'! Please log in.\" << endl;\n    }\n\n    body = bodyStream.str();\n  } else if (uri.compare(\"/login\") == 0) {\n    if (uid != -1)\n      logout(uid);\n    cout << \"login\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long long sess = login(username, password);\n\n    stringstream bodyStream;\n    if (sess == -1) {\n      bodyStream << getLogin();\n    } else {\n      stringstream cookie;\n      cookie << \"sessionId=\" << sess;\n      resHeaders[\"Set-Cookie\"] = cookie.str();\n\n      bodyStream << getHeader(username);\n      bodyStream << getEmptyCalendar();\n      bodyStream << getFooter();\n    }\n\n\n    body = bodyStream.str();\n    \n\n  } else if (uri.compare(\"/createGroup\") == 0 && uid != -1) {\n    cout << \"createGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11);\n    replace(groupName.begin(), groupName.end(), '+', ' ');\n\n    stringstream bodyStream;\n    long groupId = makeGroup(uid, groupName);\n    if (groupId != -1) {\n      cout << \"made group!\" << endl;\n      bodyStream << \"Successfully created group '\" << groupName << \"'\";\n    } else {\n      cout << \"makeGroup was -1.\" << endl;\n      bodyStream << \"Error: could not create group '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/addToGroup\") == 0 && uid != -1) {\n    cout << \"addToGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    string addedName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    bool admin = params.find(\"admin\") != string::npos;\n    long groupId = groupIdByName(groupName);\n    long addedId = userIdByName(addedName);\n\n    stringstream bodyStream;\n    bool added = addToGroup(uid, addedId, groupId, admin);\n\n    if (added) {\n      cout << \"added to group!\" << endl;\n      bodyStream << \"Successfully added '\" << addedName << \"' to '\" << groupName << \"'\";\n    } else {\n      cout << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n      bodyStream << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/createEvent\") == 0 && uid != -1) {\n    cout << \"createEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    replace(eventName.begin(), eventName.end(), '+', ' ');\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n    params = params.substr(params.find(\"&\") + 1);\n    bool withGroup = params.size() > 11;\n\n    cout << \"eName: \" << eventName << \" tS: \" << timeString << \" wG: \" << withGroup << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    long eventId;\n    if (withGroup) {\n      string groupName = params.substr(11);\n      long groupId = groupIdByName(groupName);\n      cout << \"gName: \" << groupName << \" gID: \" << groupId << endl;\n\n      eventId = makeEvent(uid, eventName, eventTime, groupId, true);\n    } else {\n      eventId = makeEvent(uid, eventName, eventTime);\n    }\n\n    stringstream bodyStream;\n    if (eventId != -1) {\n      cout << \"made event!\" << endl;\n      bodyStream << \"Successfully created event '\" << eventName << \"'\";\n    } else {\n      cout << \"couldn't make event.\" << endl;\n      bodyStream << \"Error: could not create event '\" << eventName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/editEvent\") == 0 && uid != -1) {\n    cout << \"editEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    long eventId = stol(params.substr(3, params.find(\"&\") - 3), nullptr);\n    params = params.substr(params.find(\"&\") + 1);\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n\n    cout << \"eID: \" << eventId << \" eName: \" << eventName << \" dt: \" << timeString << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    renameEvent(uid, eventId, eventName);\n    rescheduleEvent(uid, eventId, eventTime);\n\n    stringstream bodyStream;\n    cout << \"edited event!\" << endl;\n    bodyStream << \"Successfully edited event.\";\n\n    body = bodyStream.str();\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "filenames": ["calenderServer.cpp"], "buggy_code_start_loc": [248], "buggy_code_end_loc": [293], "fixing_code_start_loc": [248], "fixing_code_end_loc": [295], "type": "CWE-287", "message": "A vulnerability, which was classified as critical, was found in holdennb CollabCal. Affected is the function handleGet of the file calenderServer.cpp. The manipulation leads to improper authentication. It is possible to launch the attack remotely. The name of the patch is b80f6d1893607c99e5113967592417d0fe310ce6. It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2014-125060", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T13:15:09.127", "lastModified": "2023-01-12T17:52:00.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in holdennb CollabCal. Affected is the function handleGet of the file calenderServer.cpp. The manipulation leads to improper authentication. It is possible to launch the attack remotely. The name of the patch is b80f6d1893607c99e5113967592417d0fe310ce6. It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:collabcal_project:collabcal:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-12-09", "matchCriteriaId": "AE48541E-400E-4795-819E-284FD7F00EB3"}]}]}], "references": [{"url": "https://github.com/holdennb/CollabCal/commit/b80f6d1893607c99e5113967592417d0fe310ce6", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217614", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217614", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/holdennb/CollabCal/commit/b80f6d1893607c99e5113967592417d0fe310ce6"}}