{"buggy_code": ["/*\nWritten by Peter O.\nAny copyright to this work is released to the Public Domain.\nIn case this is not possible, this work is also\nlicensed under Creative Commons Zero (CC0):\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\n */\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing PeterO;\nusing PeterO.Numbers;\n\n// TODO: In next major version, make .Keys and .Values read-only\n// TODO: Add ReadObject that combines Read and ToObject; similarly\n// for ReadJSON, FromJSONString, FromJSONBytes\n// TODO: In Java version add overloads for Class<T> in overloads\n// that take java.lang.reflect.Type\nnamespace PeterO.Cbor {\n  /// <summary>\n  /// <para>Represents an object in Concise Binary Object Representation\n  /// (CBOR) and contains methods for reading and writing CBOR data. CBOR\n  /// is an Internet Standard and defined in RFC 8949.</para></summary>\n  /// <remarks>\n  /// <para><b>Converting CBOR objects</b></para>\n  /// <para>There are many ways to get a CBOR object, including from\n  /// bytes, objects, streams and JSON, as described below.</para>\n  /// <para><b>To and from byte arrays:</b> The\n  /// CBORObject.DecodeFromBytes method converts a byte array in CBOR\n  /// format to a CBOR object. The EncodeToBytes method converts a CBOR\n  /// object to its corresponding byte array in CBOR format.</para>\n  /// <para><b>To and from data streams:</b> The CBORObject.Write methods\n  /// write many kinds of objects to a data stream, including numbers,\n  /// CBOR objects, strings, and arrays of numbers and strings. The\n  /// CBORObject.Read method reads a CBOR object from a data\n  /// stream.</para>\n  /// <para><b>To and from other objects:</b> The\n  /// <c>CBORObject.FromObject</c> method converts many kinds of objects\n  /// to a CBOR object, including numbers, strings, and arrays and maps\n  /// of numbers and strings. Methods like AsNumber and AsString convert\n  /// a CBOR object to different types of object. The\n  /// <c>CBORObject.ToObject</c> method converts a CBOR object to an\n  /// object of a given type; for example, a CBOR array to a native\n  /// <c>List</c> (or <c>ArrayList</c> in Java), or a CBOR integer to an\n  /// <c>int</c> or <c>long</c>.</para>\n  /// <para><b>To and from JSON:</b> This class also doubles as a reader\n  /// and writer of JavaScript Object Notation (JSON). The\n  /// CBORObject.FromJSONString method converts JSON in text string form\n  /// to a CBOR object, and the ToJSONString method converts a CBOR\n  /// object to a JSON string. (Note that the conversion from CBOR to\n  /// JSON is not always without loss and may make it impossible to\n  /// recover the original object when converting the JSON back to CBOR.\n  /// See the ToJSONString documentation.) Likewise, ToJSONBytes and\n  /// FromJSONBytes work with JSON in the form of byte arrays rather than\n  /// text strings.</para>\n  /// <para>In addition, the CBORObject.WriteJSON method writes many\n  /// kinds of objects as JSON to a data stream, including numbers, CBOR\n  /// objects, strings, and arrays of numbers and strings. The\n  /// CBORObject.Read method reads a CBOR object from a JSON data\n  /// stream.</para>\n  /// <para><b>Comparison Considerations:</b></para>\n  /// <para>Instances of CBORObject should not be compared for equality\n  /// using the \"==\" operator; it's possible to create two CBOR objects\n  /// with the same value but not the same reference. (The \"==\" operator\n  /// might only check if each side of the operator is the same\n  /// instance.)</para>\n  /// <para>This class's natural ordering (under the CompareTo method) is\n  /// consistent with the Equals method, meaning that two values that\n  /// compare as equal under the CompareTo method are also equal under\n  /// the Equals method; this is a change in version 4.0. Two otherwise\n  /// equal objects with different tags are not treated as equal by both\n  /// CompareTo and Equals. To strip the tags from a CBOR object before\n  /// comparing, use the <c>Untag</c> method.</para>\n  /// <para><b>Thread Safety:</b></para>\n  /// <para>Certain CBOR objects are immutable (their values can't be\n  /// changed), so they are inherently safe for use by multiple\n  /// threads.</para>\n  /// <para>CBOR objects that are arrays, maps, and byte strings (whether\n  /// or not they are tagged) are mutable, but this class doesn't attempt\n  /// to synchronize reads and writes to those objects by multiple\n  /// threads, so those objects are not thread safe without such\n  /// synchronization.</para>\n  /// <para>One kind of CBOR object is called a map, or a list of\n  /// key-value pairs. Keys can be any kind of CBOR object, including\n  /// numbers, strings, arrays, and maps. However, untagged text strings\n  /// (which means GetTags returns an empty array and the Type property,\n  /// or \"getType()\" in Java, returns TextString) are the most suitable\n  /// to use as keys; other kinds of CBOR object are much better used as\n  /// map values instead, keeping in mind that some of them are not\n  /// thread safe without synchronizing reads and writes to them.</para>\n  /// <para>To find the type of a CBOR object, call its Type property (or\n  /// \"getType()\" in Java). The return value can be Integer,\n  /// FloatingPoint, Boolean, SimpleValue, or TextString for immutable\n  /// CBOR objects, and Array, Map, or ByteString for mutable CBOR\n  /// objects.</para>\n  /// <para><b>Nesting Depth:</b></para>\n  /// <para>The DecodeFromBytes and Read methods can only read objects\n  /// with a limited maximum depth of arrays and maps nested within other\n  /// arrays and maps. The code sets this maximum depth to 500 (allowing\n  /// more than enough nesting for most purposes), but it's possible that\n  /// stack overflows in some runtimes might lower the effective maximum\n  /// nesting depth. When the nesting depth goes above 500, the\n  /// DecodeFromBytes and Read methods throw a CBORException.</para>\n  /// <para>The ReadJSON and FromJSONString methods currently have\n  /// nesting depths of 1000.</para></remarks>\n  [System.Diagnostics.CodeAnalysis.SuppressMessage(\n      \"Microsoft.Design\",\n      \"CA1036\",\n      Justification = \"Mutable in some cases, and arbitrary size.\")]\n  public sealed partial class CBORObject : IComparable<CBORObject>,\n    IEquatable<CBORObject> {\n    private static CBORObject ConstructSimpleValue(int v) {\n      return new CBORObject(CBORObjectTypeSimpleValue, v);\n    }\n\n    private static CBORObject ConstructIntegerValue(int v) {\n      return new CBORObject(CBORObjectTypeInteger, (long)v);\n    }\n\n    /// <summary>Represents the value false.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject False =\n      CBORObject.ConstructSimpleValue(20);\n\n    /// <summary>A not-a-number value.</summary>\n    public static readonly CBORObject NaN = CBORObject.FromObject(Double.NaN);\n\n    /// <summary>The value negative infinity.</summary>\n    public static readonly CBORObject NegativeInfinity =\n      CBORObject.FromObject(Double.NegativeInfinity);\n\n    /// <summary>Represents the value null.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject Null =\n      CBORObject.ConstructSimpleValue(22);\n\n    /// <summary>The value positive infinity.</summary>\n    public static readonly CBORObject PositiveInfinity =\n      CBORObject.FromObject(Double.PositiveInfinity);\n\n    /// <summary>Represents the value true.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject True =\n      CBORObject.ConstructSimpleValue(21);\n\n    /// <summary>Represents the value undefined.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject Undefined =\n      CBORObject.ConstructSimpleValue(23);\n\n    /// <summary>Gets a CBOR object for the number zero.</summary>\n    public static readonly CBORObject Zero =\n      CBORObject.ConstructIntegerValue(0);\n\n    private const int CBORObjectTypeInteger = 0; // -(2^63).. (2^63-1)\n    private const int CBORObjectTypeEInteger = 1; // all other integers\n    private const int CBORObjectTypeByteString = 2;\n    private const int CBORObjectTypeTextString = 3;\n    private const int CBORObjectTypeArray = 4;\n    private const int CBORObjectTypeMap = 5;\n    private const int CBORObjectTypeTagged = 6;\n    private const int CBORObjectTypeSimpleValue = 7;\n    private const int CBORObjectTypeDouble = 8;\n    private const int CBORObjectTypeTextStringUtf8 = 9;\n    private const int CBORObjectTypeTextStringAscii = 10;\n\n    private const int StreamedStringBufferLength = 4096;\n\n    private static readonly EInteger UInt64MaxValue =\n      (EInteger.One << 64) - EInteger.One;\n\n    private static readonly EInteger[] ValueEmptyTags = new EInteger[0];\n    // Expected lengths for each head byte.\n    // 0 means length varies. -1 means invalid.\n    private static readonly int[] ValueExpectedLengths = {\n      1, 1, 1, 1, 1, 1,\n      1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, // major type 0\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 9, -1, -1, -1, -1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // major type 1\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 9, -1, -1, -1, -1,\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, // major type 2\n      17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, -1, -1, -1, 0,\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, // major type 3\n      17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, -1, -1, -1, 0,\n      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // major type 4\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0,\n      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // major type 5\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // major type 6\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // major type 7\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 9, -1, -1, -1, -1,\n    };\n\n    private static readonly byte[] ValueFalseBytes = {\n      0x66, 0x61, 0x6c,\n      0x73, 0x65,\n    };\n\n    private static readonly byte[] ValueNullBytes = { 0x6e, 0x75, 0x6c, 0x6c };\n\n    private static readonly byte[] ValueTrueBytes = { 0x74, 0x72, 0x75, 0x65 };\n\n    private static readonly CBORObject[] FixedObjects =\n      InitializeFixedObjects();\n\n    private readonly int itemtypeValue;\n    private readonly object itemValue;\n    private readonly int tagHigh;\n    private readonly int tagLow;\n\n    internal CBORObject(CBORObject obj, int tagLow, int tagHigh) {\n      this.itemtypeValue = CBORObjectTypeTagged;\n      this.itemValue = obj;\n      this.tagLow = tagLow;\n      this.tagHigh = tagHigh;\n    }\n\n    internal CBORObject(int type, object item) {\n      #if DEBUG\n      if (type == CBORObjectTypeDouble) {\n        if (!(item is long)) {\n          throw new ArgumentException(\"expected long for item type\");\n        }\n      }\n      // Check range in debug mode to ensure that Integer and EInteger\n      // are unambiguous\n      if ((type == CBORObjectTypeEInteger) &&\n        ((EInteger)item).CanFitInInt64()) {\n        throw new ArgumentException(\"arbitrary-precision integer is within\" +\n          \"\\u0020range for Integer\");\n      }\n      if ((type == CBORObjectTypeEInteger) &&\n        ((EInteger)item).GetSignedBitLengthAsInt64() > 64) {\n        throw new ArgumentException(\"arbitrary-precision integer does not \" +\n          \"fit major type 0 or 1\");\n      }\n      if (type == CBORObjectTypeArray && !(item is IList<CBORObject>)) {\n        throw new InvalidOperationException();\n      }\n      #endif\n      this.itemtypeValue = type;\n      this.itemValue = item;\n      this.tagLow = 0;\n      this.tagHigh = 0;\n    }\n\n    /// <summary>Gets the number of keys in this map, or the number of\n    /// items in this array, or 0 if this item is neither an array nor a\n    /// map.</summary>\n    /// <value>The number of keys in this map, or the number of items in\n    /// this array, or 0 if this item is neither an array nor a\n    /// map.</value>\n    public int Count {\n      get {\n        return (this.Type == CBORType.Array) ? this.AsList().Count :\n          ((this.Type == CBORType.Map) ? this.AsMap().Count : 0);\n      }\n    }\n\n    /// <summary>Gets the last defined tag for this CBOR data item, or -1\n    /// if the item is untagged.</summary>\n    /// <value>The last defined tag for this CBOR data item, or -1 if the\n    /// item is untagged.</value>\n    public EInteger MostInnerTag {\n      get {\n        if (!this.IsTagged) {\n          return EInteger.FromInt32(-1);\n        }\n        CBORObject previtem = this;\n        var curitem = (CBORObject)this.itemValue;\n        while (curitem.IsTagged) {\n          previtem = curitem;\n          curitem = (CBORObject)curitem.itemValue;\n        }\n        if (previtem.tagHigh == 0 && previtem.tagLow >= 0 &&\n          previtem.tagLow < 0x10000) {\n          return (EInteger)previtem.tagLow;\n        }\n        return LowHighToEInteger(\n            previtem.tagLow,\n            previtem.tagHigh);\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this value is a CBOR false\n    /// value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR false value; otherwise,\n    /// <c>false</c>.</value>\n    public bool IsFalse {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 20;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents a finite number.</summary>\n    /// <value><c>true</c> if this CBOR object represents a finite number;\n    /// otherwise, <c>false</c>.</value>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsFinite()).\")]\n    public bool IsFinite {\n      get {\n        if (this.IsNumber) {\n          CBORNumber cn = this.AsNumber();\n          return !cn.IsInfinity() && !cn.IsNaN();\n        } else {\n          return false;\n        }\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this object represents an\n    /// integer number, that is, a number without a fractional part.\n    /// Infinity and not-a-number are not considered integers.</summary>\n    /// <value><c>true</c> if this object represents an integer number,\n    /// that is, a number without a fractional part; otherwise,\n    /// <c>false</c>.</value>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsInteger()).\")]\n    public bool IsIntegral {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        return (cn != null) &&\n          cn.GetNumberInterface().IsIntegral(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object is a CBOR\n    /// null value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR null value; otherwise,\n    /// <c>false</c>.</value>\n    public bool IsNull {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 22;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this data item has at\n    /// least one tag.</summary>\n    /// <value><c>true</c> if this data item has at least one tag;\n    /// otherwise, <c>false</c>.</value>\n    public bool IsTagged {\n      get {\n        return this.itemtypeValue == CBORObjectTypeTagged;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this value is a CBOR true\n    /// value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR true value; otherwise,\n    /// <c>false</c>.</value>\n    public bool IsTrue {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 21;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this value is a CBOR\n    /// undefined value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR undefined value;\n    /// otherwise, <c>false</c>.</value>\n    public bool IsUndefined {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 23;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this object's value equals\n    /// 0.</summary>\n    /// <value><c>true</c> if this object's value equals 0; otherwise,\n    /// <c>false</c>.</value>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsZero()).\")]\n    public bool IsZero {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        return cn != null &&\n          cn.GetNumberInterface().IsNumberZero(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets a collection of the keys of this CBOR object. In\n    /// general, the order in which those keys occur is undefined unless\n    /// this is a map created using the NewOrderedMap method.</summary>\n    /// <value>A collection of the keys of this CBOR object. To avoid\n    /// potential problems, the calling code should not modify the CBOR map\n    /// or the returned collection while iterating over the returned\n    /// collection.</value>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    public ICollection<CBORObject> Keys {\n      get {\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n          return dict.Keys;\n        }\n        throw new InvalidOperationException(\"Not a map\");\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this object is a negative\n    /// number.</summary>\n    /// <value><c>true</c> if this object is a negative number; otherwise,\n    /// <c>false</c>.</value>\n    [Obsolete(\"Instead, use \\u0028cbor.IsNumber() &&\" +\n        \"\\u0020cbor.AsNumber().IsNegative()).\")]\n    public bool IsNegative {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        return (cn != null) &&\n          cn.GetNumberInterface().IsNegative(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets the outermost tag for this CBOR data item, or -1 if\n    /// the item is untagged.</summary>\n    /// <value>The outermost tag for this CBOR data item, or -1 if the item\n    /// is untagged.</value>\n    public EInteger MostOuterTag {\n      get {\n        if (!this.IsTagged) {\n          return EInteger.FromInt32(-1);\n        }\n        if (this.tagHigh == 0 &&\n          this.tagLow >= 0 && this.tagLow < 0x10000) {\n          return (EInteger)this.tagLow;\n        }\n        return LowHighToEInteger(\n            this.tagLow,\n            this.tagHigh);\n      }\n    }\n\n    /// <summary>Gets this value's sign: -1 if negative; 1 if positive; 0\n    /// if zero. Throws an exception if this is a not-a-number\n    /// value.</summary>\n    /// <value>This value's sign: -1 if negative; 1 if positive; 0 if\n    /// zero.</value>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number, or this object is a not-a-number (NaN)\n    /// value.</exception>\n    [Obsolete(\"Instead, convert this object to a number with .AsNumber(),\" +\n        \"\\u0020 and use the Sign property in .NET or the signum method in\" +\n        \"\\u0020Java.\" +\n        \" Either will treat not-a-number (NaN) values differently than here.\")]\n    public int Sign {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null || cn.IsNaN()) {\n          throw new InvalidOperationException(\n            \"This object is not a number.\");\n        }\n        return cn.GetNumberInterface().Sign(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets the simple value ID of this CBOR object, or -1 if the\n    /// object is not a simple value. In this method, objects with a CBOR\n    /// type of Boolean or SimpleValue are simple values, whether they are\n    /// tagged or not.</summary>\n    /// <value>The simple value ID of this object if it's a simple value,\n    /// or -1 if this object is not a simple value.</value>\n    public int SimpleValue {\n      get {\n        return (this.ItemType == CBORObjectTypeSimpleValue) ?\n          ((int)this.ThisItem) : -1;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object stores a\n    /// number (including infinity or a not-a-number or NaN value).\n    /// Currently, this is true if this item is untagged and has a CBORType\n    /// of Integer or FloatingPoint, or if this item has only one tag and\n    /// that tag is 2, 3, 4, 5, 30, 264, 265, 268, 269, or 270 with the\n    /// right data type.</summary>\n    /// <value>A value indicating whether this CBOR object stores a\n    /// number.</value>\n    public bool IsNumber {\n      get {\n        return CBORNumber.IsNumber(this);\n      }\n    }\n\n    /// <summary>Gets the general data type of this CBOR object. This\n    /// method disregards the tags this object has, if any.</summary>\n    /// <value>The general data type of this CBOR object.</value>\n    public CBORType Type {\n      get {\n        switch (this.ItemType) {\n          case CBORObjectTypeInteger:\n          case CBORObjectTypeEInteger:\n            return CBORType.Integer;\n          case CBORObjectTypeDouble:\n            return CBORType.FloatingPoint;\n          case CBORObjectTypeSimpleValue:\n            return ((int)this.ThisItem == 21 || (int)this.ThisItem == 20) ?\n              CBORType.Boolean : CBORType.SimpleValue;\n          case CBORObjectTypeArray:\n            return CBORType.Array;\n          case CBORObjectTypeMap:\n            return CBORType.Map;\n          case CBORObjectTypeByteString:\n            return CBORType.ByteString;\n          case CBORObjectTypeTextString:\n          case CBORObjectTypeTextStringUtf8:\n          case CBORObjectTypeTextStringAscii:\n            return CBORType.TextString;\n          default: throw new InvalidOperationException(\"Unexpected data type\");\n        }\n      }\n    }\n\n    /// <summary>Gets a collection of the key/value pairs stored in this\n    /// CBOR object, if it's a map. Returns one entry for each key/value\n    /// pair in the map. In general, the order in which those entries occur\n    /// is undefined unless this is a map created using the NewOrderedMap\n    /// method.</summary>\n    /// <value>A collection of the key/value pairs stored in this CBOR map,\n    /// as a read-only view of those pairs. To avoid potential problems,\n    /// the calling code should not modify the CBOR map while iterating\n    /// over the returned collection.</value>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    public ICollection<KeyValuePair<CBORObject, CBORObject>> Entries {\n      get {\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n          return PropertyMap.GetEntries(dict);\n        }\n        throw new InvalidOperationException(\"Not a map\");\n      }\n    }\n\n    /// <summary>Gets a collection of the values of this CBOR object, if\n    /// it's a map or an array. If this object is a map, returns one value\n    /// for each key in the map; in general, the order in which those keys\n    /// occur is undefined unless this is a map created using the\n    /// NewOrderedMap method. If this is an array, returns all the values\n    /// of the array in the order they are listed. (This method can't be\n    /// used to get the bytes in a CBOR byte string; for that, use the\n    /// GetByteString method instead.).</summary>\n    /// <value>A collection of the values of this CBOR map or array. To\n    /// avoid potential problems, the calling code should not modify the\n    /// CBOR map or array or the returned collection while iterating over\n    /// the returned collection.</value>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map or an array.</exception>\n    public ICollection<CBORObject> Values {\n      get {\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n          return dict.Values;\n        }\n        if (this.Type == CBORType.Array) {\n          IList<CBORObject> list = this.AsList();\n          return new\n            System.Collections.ObjectModel.ReadOnlyCollection<CBORObject>(\n              list);\n        }\n        throw new InvalidOperationException(\"Not a map or array\");\n      }\n    }\n\n    private int ItemType {\n      get {\n        CBORObject curobject = this;\n        while (curobject.itemtypeValue == CBORObjectTypeTagged) {\n          curobject = (CBORObject)curobject.itemValue;\n        }\n        return curobject.itemtypeValue;\n      }\n    }\n\n    private object ThisItem {\n      get {\n        CBORObject curobject = this;\n        while (curobject.itemtypeValue == CBORObjectTypeTagged) {\n          curobject = (CBORObject)curobject.itemValue;\n        }\n        return curobject.itemValue;\n      }\n    }\n\n    /// <summary>Gets the value of a CBOR object by integer index in this\n    /// array or by integer key in this map.</summary>\n    /// <param name='index'>Index starting at 0 of the element, or the\n    /// integer key to this map. (If this is a map, the given index can be\n    /// any 32-bit signed integer, even a negative one.).</param>\n    /// <returns>The CBOR object referred to by index or key in this array\n    /// or map. If this is a CBOR map, returns <c>null</c> (not\n    /// <c>CBORObject.Null</c> ) if an item with the given key doesn't\n    /// exist (but this behavior may change to throwing an exception in\n    /// version 5.0 or later).</returns>\n    /// <exception cref='InvalidOperationException'>This object is not an\n    /// array or map.</exception>\n    /// <exception cref='ArgumentException'>This object is an array and the\n    /// index is less than 0 or at least the size of the array.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter \"value\" is\n    /// null (as opposed to CBORObject.Null).</exception>\n    public CBORObject this[int index] {\n      get {\n        if (this.Type == CBORType.Array) {\n          IList<CBORObject> list = this.AsList();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(index));\n          }\n          return list[index];\n        }\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          CBORObject key = CBORObject.FromObject(index);\n          // TODO: In next major version, consider throwing an exception\n          // instead if key does not exist.\n          return (!map.ContainsKey(key)) ? null : map[key];\n        }\n        throw new InvalidOperationException(\"Not an array or map\");\n      }\n\n      set {\n        if (this.Type == CBORType.Array) {\n          if (value == null) {\n            throw new ArgumentNullException(nameof(value));\n          }\n          IList<CBORObject> list = this.AsList();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(index));\n          }\n          list[index] = value;\n        } else if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          CBORObject key = CBORObject.FromObject(index);\n          map[key] = value;\n        } else {\n          throw new InvalidOperationException(\"Not an array or map\");\n        }\n      }\n    }\n\n    /// <summary>Gets the value of a CBOR object by integer index in this\n    /// array or by CBOR object key in this map, or a default value if that\n    /// value is not found.</summary>\n    /// <param name='key'>An arbitrary object. If this is a CBOR map, this\n    /// parameter is converted to a CBOR object serving as the key to the\n    /// map or index to the array, and can be null. If this is a CBOR\n    /// array, the key must be an integer 0 or greater and less than the\n    /// size of the array, and may be any object convertible to a CBOR\n    /// integer.</param>\n    /// <param name='defaultValue'>A value to return if an item with the\n    /// given key doesn't exist, or if the CBOR object is an array and the\n    /// key is not an integer 0 or greater and less than the size of the\n    /// array.</param>\n    /// <returns>The CBOR object referred to by index or key in this array\n    /// or map. If this is a CBOR map, returns <c>null</c> (not\n    /// <c>CBORObject.Null</c> ) if an item with the given key doesn't\n    /// exist.</returns>\n    public CBORObject GetOrDefault(object key, CBORObject defaultValue) {\n      if (this.Type == CBORType.Array) {\n        var index = 0;\n        if (key is int) {\n          index = (int)key;\n        } else {\n          CBORObject cborkey = CBORObject.FromObject(key);\n          if (!cborkey.IsNumber || !cborkey.AsNumber().CanFitInInt32()) {\n            return defaultValue;\n          }\n          index = cborkey.AsNumber().ToInt32Checked();\n        }\n        IList<CBORObject> list = this.AsList();\n        return (index < 0 || index >= list.Count) ? defaultValue :\n          list[index];\n      }\n      if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        CBORObject ckey = CBORObject.FromObject(key);\n        return PropertyMap.GetOrDefault(map, ckey, defaultValue);\n      }\n      return defaultValue;\n    }\n\n    /// <summary>Gets the value of a CBOR object by integer index in this\n    /// array or by CBOR object key in this map.</summary>\n    /// <param name='key'>A CBOR object serving as the key to the map or\n    /// index to the array. If this is a CBOR array, the key must be an\n    /// integer 0 or greater and less than the size of the array.</param>\n    /// <returns>The CBOR object referred to by index or key in this array\n    /// or map. If this is a CBOR map, returns <c>null</c> (not\n    /// <c>CBORObject.Null</c> ) if an item with the given key doesn't\n    /// exist.</returns>\n    /// <exception cref='ArgumentNullException'>The key is null (as opposed\n    /// to CBORObject.Null); or the set method is called and the value is\n    /// null.</exception>\n    /// <exception cref='ArgumentException'>This CBOR object is an array\n    /// and the key is not an integer 0 or greater and less than the size\n    /// of the array.</exception>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map or an array.</exception>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Design\",\n        \"CA1043\",\n        Justification = \"Represents a logical data store\")]\n    public CBORObject this[CBORObject key] {\n      get {\n        /* \"The CBORObject class represents a logical data store.\" +\n        \" Also, an Object indexer is not included here because it's unusual\n        for \" +\n        \"CBOR map keys to be anything other than text strings or integers; \" +\n        \"including an Object indexer would introduce the security issues\n        present in the FromObject method because of the need to convert to\n        CBORObject;\" +\n        \" and this CBORObject indexer is included here because any CBOR\n        object \" +\n        \"can serve as a map key, not just integers or text strings.\" */\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          return (!map.ContainsKey(key)) ? null : map[key];\n        }\n        if (this.Type == CBORType.Array) {\n          if (!key.IsNumber || !key.AsNumber().IsInteger()) {\n            throw new ArgumentException(\"Not an integer\");\n          }\n          if (!key.AsNumber().CanFitInInt32()) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          IList<CBORObject> list = this.AsList();\n          int index = key.AsNumber().ToInt32Checked();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          return list[index];\n        }\n        throw new InvalidOperationException(\"Not an array or map\");\n      }\n\n      set {\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        if (value == null) {\n          throw new ArgumentNullException(nameof(value));\n        }\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          map[key] = value;\n          return;\n        }\n        if (this.Type == CBORType.Array) {\n          if (!key.IsNumber || !key.AsNumber().IsInteger()) {\n            throw new ArgumentException(\"Not an integer\");\n          }\n          if (!key.AsNumber().CanFitInInt32()) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          IList<CBORObject> list = this.AsList();\n          int index = key.AsNumber().ToInt32Checked();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          list[index] = value;\n          return;\n        }\n        throw new InvalidOperationException(\"Not an array or map\");\n      }\n    }\n\n    /// <summary>Gets the value of a CBOR object in this map, using a\n    /// string as the key.</summary>\n    /// <param name='key'>A key that points to the desired value.</param>\n    /// <returns>The CBOR object referred to by key in this map. Returns\n    /// <c>null</c> if an item with the given key doesn't exist.</returns>\n    /// <exception cref='ArgumentNullException'>The key is\n    /// null.</exception>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    public CBORObject this[string key] {\n      get {\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        CBORObject objkey = CBORObject.FromObject(key);\n        return this[objkey];\n      }\n\n      set {\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        if (value == null) {\n          throw new ArgumentNullException(nameof(value));\n        }\n        CBORObject objkey = CBORObject.FromObject(key);\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          map[objkey] = value;\n        } else {\n          throw new InvalidOperationException(\"Not a map\");\n        }\n      }\n    }\n\n    /// <summary>Finds the sum of two CBOR numbers.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentException'>Either or both operands are not\n    /// numbers (as opposed to Not-a-Number, NaN).</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n\n        \"\\u0020.AsNumber()), and use the first number's .Add() method.\")]\n    public static CBORObject Addition(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber numberA = CBORNumber.FromCBORObject(first);\n      if (numberA == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return numberA.Add(b).ToCBORObject();\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from an array of CBOR-encoded\n    /// bytes.</para></summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <returns>A CBOR object decoded from the given byte array.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is\n    /// empty.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null.</exception>\n    public static CBORObject DecodeFromBytes(byte[] data) {\n      return DecodeFromBytes(data, CBOREncodeOptions.Default);\n    }\n\n    private static readonly CBOREncodeOptions AllowEmptyOptions =\n      new CBOREncodeOptions(\"allowempty=1\");\n\n    /// <summary>\n    /// <para>Generates a sequence of CBOR objects from an array of\n    /// CBOR-encoded bytes.</para></summary>\n    /// <param name='data'>A byte array in which any number of CBOR objects\n    /// (including zero) are encoded, one after the other. Can be empty,\n    /// but cannot be null.</param>\n    /// <returns>An array of CBOR objects decoded from the given byte\n    /// array. Returns an empty array if <paramref name='data'/> is\n    /// empty.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where the last\n    /// CBOR object in the data was read only partly.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null.</exception>\n    public static CBORObject[] DecodeSequenceFromBytes(byte[] data) {\n      return DecodeSequenceFromBytes(data, AllowEmptyOptions);\n    }\n\n    /// <summary>\n    /// <para>Generates a sequence of CBOR objects from an array of\n    /// CBOR-encoded bytes.</para></summary>\n    /// <param name='data'>A byte array in which any number of CBOR objects\n    /// (including zero) are encoded, one after the other. Can be empty,\n    /// but cannot be null.</param>\n    /// <param name='options'>Specifies options to control how the CBOR\n    /// object is decoded. See\n    /// <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more information.\n    /// In this method, the AllowEmpty property is treated as always set\n    /// regardless of that value as specified in this parameter.</param>\n    /// <returns>An array of CBOR objects decoded from the given byte\n    /// array. Returns an empty array if <paramref name='data'/> is\n    /// empty.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where the last\n    /// CBOR object in the data was read only partly.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='options'/>\n    /// is null.</exception>\n    public static CBORObject[] DecodeSequenceFromBytes(byte[] data,\n      CBOREncodeOptions options) {\n      if (data == null) {\n        throw new ArgumentNullException(nameof(data));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (data.Length == 0) {\n        return new CBORObject[0];\n      }\n      CBOREncodeOptions opt = options;\n      if (!opt.AllowEmpty) {\n        opt = new CBOREncodeOptions(opt.ToString() + \";allowempty=1\");\n      }\n      var cborList = new List<CBORObject>();\n      using (var ms = new MemoryStream(data)) {\n        while (true) {\n          CBORObject obj = Read(ms, opt);\n          if (obj == null) {\n            break;\n          }\n          cborList.Add(obj);\n        }\n      }\n      return (CBORObject[])cborList.ToArray();\n    }\n\n    /// <summary>Generates a list of CBOR objects from an array of bytes in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464).\n    /// The byte array must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='bytes'>A byte array in which a JSON text sequence is\n    /// encoded.</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array is not\n    /// empty and does not begin with a record separator byte (0x1e), or an\n    /// I/O error occurred.</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] FromJSONSequenceBytes(byte[] bytes) {\n      return FromJSONSequenceBytes(bytes, JSONOptions.Default);\n    }\n\n    /// <summary>Converts this object to a byte array in JavaScript Object\n    /// Notation (JSON) format. The JSON text will be written out in UTF-8\n    /// encoding, without a byte order mark, to the byte array. See the\n    /// overload to ToJSONString taking a JSONOptions argument for further\n    /// information.</summary>\n    /// <returns>A byte array containing the converted in JSON\n    /// format.</returns>\n    public byte[] ToJSONBytes() {\n      return this.ToJSONBytes(JSONOptions.Default);\n    }\n\n    /// <summary>Converts this object to a byte array in JavaScript Object\n    /// Notation (JSON) format. The JSON text will be written out in UTF-8\n    /// encoding, without a byte order mark, to the byte array. See the\n    /// overload to ToJSONString taking a JSONOptions argument for further\n    /// information.</summary>\n    /// <param name='jsonoptions'>Specifies options to control writing the\n    /// CBOR object to JSON.</param>\n    /// <returns>A byte array containing the converted object in JSON\n    /// format.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='jsonoptions'/> is null.</exception>\n    public byte[] ToJSONBytes(JSONOptions jsonoptions) {\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      try {\n        using (var ms = new MemoryStream()) {\n          this.WriteJSONTo(ms);\n          return ms.ToArray();\n        }\n      } catch (IOException ex) {\n        throw new CBORException(ex.Message, ex);\n      }\n    }\n\n    /// <summary>Generates a list of CBOR objects from an array of bytes in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464),\n    /// using the specified options to control the decoding process. The\n    /// byte array must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='data'>A byte array in which a JSON text sequence is\n    /// encoded.</param>\n    /// <param name='options'>Specifies options to control the JSON\n    /// decoding process.</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array is not\n    /// empty and does not begin with a record separator byte (0x1e), or an\n    /// I/O error occurred.</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] FromJSONSequenceBytes(byte[] data,\n      JSONOptions options) {\n      if (data == null) {\n        throw new ArgumentNullException(nameof(data));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      try {\n        using (var ms = new MemoryStream(data)) {\n          return ReadJSONSequence(ms, options);\n        }\n      } catch (IOException ex) {\n        throw new CBORException(ex.Message, ex);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an array of CBOR-encoded\n    /// bytes, using the given <c>CBOREncodeOptions</c>\n    ///  object to control\n    /// the decoding process.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='options'>Specifies options to control how the CBOR\n    /// object is decoded. See <see cref='PeterO.Cbor.CBOREncodeOptions'/>\n    /// for more information.</param>\n    /// <returns>A CBOR object decoded from the given byte array. Returns\n    /// null (as opposed to CBORObject.Null) if <paramref name='data'/> is\n    /// empty and the AllowEmpty property is set on the given options\n    /// object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='options'/>\n    /// is null.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) implements a method that decodes a text string from a CBOR\n    /// byte array. It's successful only if the CBOR object contains an\n    /// untagged text string.</para>\n    /// <code>private static String DecodeTextString(byte[] bytes) { if (bytes ==\n    /// null) { throw new ArgumentNullException(nameof(mapObj));}\n    /// if\n    /// (bytes.Length == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f) {throw new\n    /// CBORException();} return CBORObject.DecodeFromBytes(bytes,\n    /// CBOREncodeOptions.Default).AsString(); }</code>\n    ///  .\n    /// </example>\n    public static CBORObject DecodeFromBytes(\n      byte[] data,\n      CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (data == null) {\n        throw new ArgumentNullException(nameof(data));\n      }\n      if (data.Length == 0) {\n        if (options.AllowEmpty) {\n          return null;\n        }\n        throw new CBORException(\"data is empty.\");\n      }\n      var firstbyte = (int)(data[0] & (int)0xff);\n      int expectedLength = ValueExpectedLengths[firstbyte];\n      // if invalid\n      if (expectedLength == -1) {\n        throw new CBORException(\"Unexpected data encountered\");\n      }\n      if (expectedLength != 0) {\n        // if fixed length\n        CheckCBORLength(expectedLength, data.Length);\n        if (!options.Ctap2Canonical ||\n          (firstbyte >= 0x00 && firstbyte < 0x18) ||\n          (firstbyte >= 0x20 && firstbyte < 0x38)) {\n          return GetFixedLengthObject(firstbyte, data);\n        }\n      }\n      if (firstbyte == 0xc0 && !options.Ctap2Canonical) {\n        // value with tag 0\n        string s = GetOptimizedStringIfShortAscii(data, 1);\n        if (s != null) {\n          return new CBORObject(FromObject(s), 0, 0);\n        }\n      }\n      // For objects with variable length,\n      // read the object as though\n      // the byte array were a stream\n      using (var ms = new MemoryStream(data)) {\n        CBORObject o = Read(ms, options);\n        CheckCBORLength(\n          (long)data.Length,\n          (long)ms.Position);\n        return o;\n      }\n    }\n\n    /// <summary>Divides a CBORObject object by the value of a CBORObject\n    /// object.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The quotient of the two objects.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n\n        \"\\u0020.AsNumber()), and use the first number's .Divide() method.\")]\n    public static CBORObject Divide(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Divide(b).ToCBORObject();\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown. This is a change in version 4.0.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='str'/> begins.</param>\n    /// <param name='count'>The length, in code units, of the desired\n    /// portion of <paramref name='str'/> (but not more than <paramref\n    /// name='str'/> 's length).</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='str'/> 's length, or <paramref\n    /// name='str'/> 's length minus <paramref name='offset'/> is less than\n    /// <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONString(string str, int offset, int count) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      return FromJSONString(str, offset, count, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <param name='jsonoptions'>Specifies options to control the JSON\n    /// decoding process.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> or <paramref name='jsonoptions'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    public static CBORObject FromJSONString(\n      string str,\n      JSONOptions jsonoptions) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      return FromJSONString(str, 0, str.Length, jsonoptions);\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown. This is a change in version 4.0.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    public static CBORObject FromJSONString(string str) {\n      return FromJSONString(str, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <param name='options'>Specifies options to control the decoding\n    /// process. This method uses only the AllowDuplicateKeys property of\n    /// this object.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> or <paramref name='options'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    [Obsolete(\"Instead, use .FromJSONString\\u0028str, new\" +\n        \"\\u0020JSONOptions\\u0028\\\"allowduplicatekeys=true\\\")) or\" +\n        \"\\u0020.FromJSONString\\u0028str,\" +\n        \"\\u0020 new JSONOptions\\u0028\\\"allowduplicatekeys=false\\\")), as\" +\n        \"\\u0020appropriate.\")]\n    public static CBORObject FromJSONString(\n      string str,\n      CBOREncodeOptions options) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      var jsonoptions = new JSONOptions(options.AllowDuplicateKeys ?\n        \"allowduplicatekeys=1\" : \"allowduplicatekeys=0\");\n      return FromJSONString(str, jsonoptions);\n    }\n\n    /// <summary>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>The parameter <paramref name='str'/> is a text\n    /// string.</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='str'/> begins.</param>\n    /// <param name='count'>The length, in code units, of the desired\n    /// portion of <paramref name='str'/> (but not more than <paramref\n    /// name='str'/> 's length).</param>\n    /// <param name='jsonoptions'>The parameter <paramref\n    /// name='jsonoptions'/> is a Cbor.JSONOptions object.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> or <paramref name='jsonoptions'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='str'/> 's length, or <paramref\n    /// name='str'/> 's length minus <paramref name='offset'/> is less than\n    /// <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONString(\n      string str,\n      int offset,\n      int count,\n      JSONOptions jsonoptions) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      if (count > 0 && str[offset] == 0xfeff) {\n        throw new CBORException(\n          \"JSON object began with a byte order mark (U+FEFF) (offset 0)\");\n      }\n      if (count == 0) {\n        throw new CBORException(\"String is empty\");\n      }\n      return CBORJson3.ParseJSONValue(str, offset, offset + count, jsonoptions);\n    }\n\n    /// <summary>Converts this CBOR object to an object of an arbitrary\n    /// type. See the documentation for the overload of this method taking\n    /// a CBORTypeMapper parameter for more information. This method\n    /// doesn't use a CBORTypeMapper parameter to restrict which data types\n    /// are eligible for Plain-Old-Data serialization.</summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b>\n    ///  For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method (such as <c>int</c>\n    ///  or\n    /// <c>String</c>\n    ///  ) or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given type\n    /// <paramref name='t'/> , or this object's CBOR type, is not\n    /// supported, or the given object's nesting is too deep, or another\n    /// error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> is null.</exception>\n    /// <example>\n    /// <para>Java offers no easy way to express a generic type, at least\n    /// none as easy as C#'s <c>typeof</c>\n    ///  operator. The following example,\n    /// written in Java, is a way to specify that the return value will be\n    /// an ArrayList of String objects.</para>\n    /// <code>Type arrayListString = new ParameterizedType() { public Type[]\n    /// getActualTypeArguments() { &#x2f;&#x2a; Contains one type parameter,\n    /// String&#x2a;&#x2f;\n    /// return new Type[] { String.class }; }\n    /// public Type getRawType() { /* Raw type is\n    /// ArrayList */ return ArrayList.class; }\n    /// public Type getOwnerType() {\n    /// return null; } };\n    /// ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;)\n    /// cborArray.ToObject(arrayListString);</code>\n    /// <para>By comparison, the C# version is much shorter.</para>\n    /// <code>var array = (List&lt;String&gt;)cborArray.ToObject(\n    /// typeof(List&lt;String&gt;));</code>\n    ///  .\n    /// </example>\n    public object ToObject(Type t) {\n      return this.ToObject(t, null, null, 0);\n    }\n\n    /// <summary>Converts this CBOR object to an object of an arbitrary\n    /// type. See the documentation for the overload of this method taking\n    /// a CBORTypeMapper and PODOptions parameters parameters for more\n    /// information.</summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method (such as <c>int</c> or\n    /// <c>String</c> ) or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given type\n    /// <paramref name='t'/>, or this object's CBOR type, is not\n    /// supported, or the given object's nesting is too deep, or another\n    /// error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> is null.</exception>\n    public object ToObject(Type t, CBORTypeMapper mapper) {\n      if (mapper == null) {\n        throw new ArgumentNullException(nameof(mapper));\n      }\n      return this.ToObject(t, mapper, null, 0);\n    }\n\n    /// <summary>Converts this CBOR object to an object of an arbitrary\n    /// type. See the documentation for the overload of this method taking\n    /// a CBORTypeMapper and PODOptions parameters for more information.\n    /// This method (without a CBORTypeMapper parameter) allows all data\n    /// types not otherwise handled to be eligible for Plain-Old-Data\n    /// serialization.</summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method (such as <c>int</c> or\n    /// <c>String</c> ) or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='options'>Specifies options for controlling\n    /// deserialization of CBOR objects.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='NotSupportedException'>The given type <paramref\n    /// name='t'/>, or this object's CBOR type, is not\n    /// supported.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given object's\n    /// nesting is too deep, or another error occurred when serializing the\n    /// object.</exception>\n    public object ToObject(Type t, PODOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      return this.ToObject(t, null, options, 0);\n    }\n\n    /// <summary><para>Converts this CBOR object to an object of an\n    /// arbitrary type. The following cases are checked in the logical\n    /// order given (rather than the strict order in which they are\n    /// implemented by this library):</para>\n    ///  <list><item>If the type is\n    /// <c>CBORObject</c>\n    ///  , return this object.</item>\n    ///  <item>If the given\n    /// object is <c>CBORObject.Null</c>\n    ///  (with or without tags), returns\n    /// <c>null</c>\n    ///  .</item>\n    ///  <item>If the object is of a type corresponding\n    /// to a type converter mentioned in the <paramref name='mapper'/>\n    /// parameter, that converter will be used to convert the CBOR object\n    /// to an object of the given type. Type converters can be used to\n    /// override the default conversion behavior of almost any\n    /// object.</item>\n    ///  <item>If the type is <c>object</c>\n    ///  , return this\n    /// object.</item>\n    ///  <item>If the type is <c>char</c>\n    ///  , converts\n    /// single-character CBOR text strings and CBOR integers from 0 through\n    /// 65535 to a <c>char</c>\n    ///  object and returns that <c>char</c>\n    /// object.</item>\n    ///  <item>If the type is <c>bool</c>\n    ///  ( <c>boolean</c>\n    ///  in\n    /// Java), returns the result of AsBoolean.</item>\n    ///  <item>If the type is\n    /// <c>short</c>\n    ///  , returns this number as a 16-bit signed integer after\n    /// converting its value to an integer by discarding its fractional\n    /// part, and throws an exception if this object's value is infinity or\n    /// a not-a-number value, or does not represent a number (currently\n    /// InvalidOperationException, but may change in the next major\n    /// version), or if the value, once converted to an integer by\n    /// discarding its fractional part, is less than -32768 or greater than\n    /// 32767 (currently OverflowException, but may change in the next\n    /// major version).</item>\n    ///  <item>If the type is <c>long</c>\n    ///  , returns\n    /// this number as a 64-bit signed integer after converting its value\n    /// to an integer by discarding its fractional part, and throws an\n    /// exception if this object's value is infinity or a not-a-number\n    /// value, or does not represent a number (currently\n    /// InvalidOperationException, but may change in the next major\n    /// version), or if the value, once converted to an integer by\n    /// discarding its fractional part, is less than -2^63 or greater than\n    /// 2^63-1 (currently OverflowException, but may change in the next\n    /// major version).</item>\n    ///  <item>If the type is <c>short</c>\n    ///  , the same\n    /// rules as for <c>long</c>\n    ///  are used, but the range is from -32768\n    /// through 32767 and the return type is <c>short</c>\n    ///  .</item>\n    ///  <item>If\n    /// the type is <c>byte</c>\n    ///  , the same rules as for <c>long</c>\n    ///  are\n    /// used, but the range is from 0 through 255 and the return type is\n    /// <c>byte</c>\n    ///  .</item>\n    ///  <item>If the type is <c>sbyte</c>\n    ///  , the same\n    /// rules as for <c>long</c>\n    ///  are used, but the range is from -128\n    /// through 127 and the return type is <c>sbyte</c>\n    ///  .</item>\n    ///  <item>If\n    /// the type is <c>ushort</c>\n    ///  , the same rules as for <c>long</c>\n    ///  are\n    /// used, but the range is from 0 through 65535 and the return type is\n    /// <c>ushort</c>\n    ///  .</item>\n    ///  <item>If the type is <c>uint</c>\n    ///  , the same\n    /// rules as for <c>long</c>\n    ///  are used, but the range is from 0 through\n    /// 2^31-1 and the return type is <c>uint</c>\n    ///  .</item>\n    ///  <item>If the\n    /// type is <c>ulong</c>\n    ///  , the same rules as for <c>long</c>\n    ///  are used,\n    /// but the range is from 0 through 2^63-1 and the return type is\n    /// <c>ulong</c>\n    ///  .</item>\n    ///  <item>If the type is <c>int</c>\n    ///  or a\n    /// primitive floating-point type ( <c>float</c>\n    ///  , <c>double</c>\n    ///  , as\n    /// well as <c>decimal</c>\n    ///  in.NET), returns the result of the\n    /// corresponding As* method.</item>\n    ///  <item>If the type is <c>String</c>\n    /// , returns the result of AsString.</item>\n    ///  <item>If the type is\n    /// <c>EFloat</c>\n    ///  , <c>EDecimal</c>\n    ///  , <c>EInteger</c>\n    ///  , or\n    /// <c>ERational</c>\n    ///  in the <a\n    /// href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c>\n    /// </a>\n    ///  library (in .NET) or the <a\n    /// href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c>\n    /// </a>\n    ///  artifact (in Java), or if the type is <c>BigInteger</c>\n    ///  or\n    /// <c>BigDecimal</c>\n    ///  in the Java version, converts the given object to\n    /// a number of the corresponding type and throws an exception\n    /// (currently InvalidOperationException) if the object does not\n    /// represent a number (for this purpose, infinity and not-a-number\n    /// values, but not <c>CBORObject.Null</c>\n    ///  , are considered numbers).\n    /// Currently, this is equivalent to the result of <c>AsEFloat()</c>\n    ///  ,\n    /// <c>AsEDecimal()</c>\n    ///  , <c>AsEInteger</c>\n    ///  , or <c>AsERational()</c>\n    ///  ,\n    /// respectively, but may change slightly in the next major version.\n    /// Note that in the case of <c>EFloat</c>\n    ///  , if this object represents\n    /// a decimal number with a fractional part, the conversion may lose\n    /// information depending on the number, and if the object is a\n    /// rational number with a nonterminating binary expansion, the number\n    /// returned is a binary floating-point number rounded to a high but\n    /// limited precision. In the case of <c>EDecimal</c>\n    ///  , if this object\n    /// expresses a rational number with a nonterminating decimal\n    /// expansion, returns a decimal number rounded to 34 digits of\n    /// precision. In the case of <c>EInteger</c>\n    ///  , if this CBOR object\n    /// expresses a floating-point number, it is converted to an integer by\n    /// discarding its fractional part, and if this CBOR object expresses a\n    /// rational number, it is converted to an integer by dividing the\n    /// numerator by the denominator and discarding the fractional part of\n    /// the result, and this method throws an exception (currently\n    /// OverflowException, but may change in the next major version) if\n    /// this object expresses infinity or a not-a-number value.</item>\n    /// <item>In the.NET version, if the type is a nullable (e.g.,\n    /// <c>Nullable&lt;int&gt;</c>\n    ///  or <c>int?</c>\n    ///  , returns <c>null</c>\n    ///  if\n    /// this CBOR object is null, or this object's value converted to the\n    /// nullable's underlying type, e.g., <c>int</c>\n    ///  .</item>\n    ///  <item>If the\n    /// type is an enumeration ( <c>Enum</c>\n    ///  ) type and this CBOR object is\n    /// a text string or an integer, returns the appropriate enumerated\n    /// constant. (For example, if <c>MyEnum</c>\n    ///  includes an entry for\n    /// <c>MyValue</c>\n    ///  , this method will return <c>MyEnum.MyValue</c>\n    ///  if\n    /// the CBOR object represents <c>\"MyValue\"</c>\n    ///  or the underlying value\n    /// for <c>MyEnum.MyValue</c>\n    ///  .) <b>Note:</b>\n    ///  If an integer is\n    /// converted to a.NET Enum constant, and that integer is shared by\n    /// more than one constant of the same type, it is undefined which\n    /// constant from among them is returned. (For example, if\n    /// <c>MyEnum.Zero=0</c>\n    ///  and <c>MyEnum.Null=0</c>\n    ///  , converting 0 to\n    /// <c>MyEnum</c>\n    ///  may return either <c>MyEnum.Zero</c>\n    ///  or\n    /// <c>MyEnum.Null</c>\n    ///  .) As a result, .NET Enum types with constants\n    /// that share an underlying value should not be passed to this\n    /// method.</item>\n    ///  <item>If the type is <c>byte[]</c>\n    ///  (a\n    /// one-dimensional byte array) and this CBOR object is a byte string,\n    /// returns a byte array which this CBOR byte string's data will be\n    /// copied to. (This method can't be used to encode CBOR data to a byte\n    /// array; for that, use the EncodeToBytes method instead.)</item>\n    /// <item>If the type is a one-dimensional or multidimensional array\n    /// type and this CBOR object is an array, returns an array containing\n    /// the items in this CBOR object.</item>\n    ///  <item>If the type is List,\n    /// ReadOnlyCollection or the generic or non-generic IList,\n    /// ICollection, IEnumerable, IReadOnlyCollection, or IReadOnlyList (or\n    /// ArrayList, List, Collection, or Iterable in Java), and if this CBOR\n    /// object is an array, returns an object conforming to the type,\n    /// class, or interface passed to this method, where the object will\n    /// contain all items in this CBOR array.</item>\n    ///  <item>If the type is\n    /// Dictionary, ReadOnlyDictionary or the generic or non-generic\n    /// IDictionary or IReadOnlyDictionary (or HashMap or Map in Java), and\n    /// if this CBOR object is a map, returns an object conforming to the\n    /// type, class, or interface passed to this method, where the object\n    /// will contain all keys and values in this CBOR map.</item>\n    ///  <item>If\n    /// the type is an enumeration constant (\"enum\"), and this CBOR object\n    /// is an integer or text string, returns the enumeration constant with\n    /// the given number or name, respectively. (Enumeration constants made\n    /// up of multiple enumeration constants, as allowed by .NET, can only\n    /// be matched by number this way.)</item>\n    ///  <item>If the type is\n    /// <c>DateTime</c>\n    ///  (or <c>Date</c>\n    ///  in Java) , returns a date/time\n    /// object if the CBOR object's outermost tag is 0 or 1. For tag 1,\n    /// this method treats the CBOR object as a number of seconds since the\n    /// start of 1970, which is based on the POSIX definition of \"seconds\n    /// since the Epoch\", a definition that does not count leap seconds. In\n    /// this method, this number of seconds assumes the use of a proleptic\n    /// Gregorian calendar, in which the rules regarding the number of days\n    /// in each month and which years are leap years are the same for all\n    /// years as they were in 1970 (including without regard to time zone\n    /// differences or transitions from other calendars to the Gregorian).\n    /// The string format used in tag 0 supports only years up to 4 decimal\n    /// digits long. For tag 1, CBOR objects that express infinity or\n    /// not-a-number (NaN) are treated as invalid by this method. This\n    /// default behavior for <c>DateTime</c>\n    ///  and <c>Date</c>\n    ///  can be changed\n    /// by passing a suitable CBORTypeMapper to this method, such as a\n    /// CBORTypeMapper that registers a CBORDateConverter for\n    /// <c>DateTime</c>\n    ///  or <c>Date</c>\n    ///  objects. See the examples.</item>\n    /// <item>If the type is <c>Uri</c>\n    ///  (or <c>URI</c>\n    ///  in Java), returns a\n    /// URI object if possible.</item>\n    ///  <item>If the type is <c>Guid</c>\n    ///  (or\n    /// <c>UUID</c>\n    ///  in Java), returns a UUID object if possible.</item>\n    /// <item>Plain-Old-Data deserialization: If the object is a type not\n    /// specially handled above, the type includes a zero-parameter\n    /// constructor (default or not), this CBOR object is a CBOR map, and\n    /// the \"mapper\" parameter (if any) allows this type to be eligible for\n    /// Plain-Old-Data deserialization, then this method checks the given\n    /// type for eligible setters as follows:</item>\n    ///  <item>(*) In the .NET\n    /// version, eligible setters are the public, nonstatic setters of\n    /// properties with a public, nonstatic getter. Eligible setters also\n    /// include public, nonstatic, non- <c>const</c>\n    ///  , non- <c>readonly</c>\n    /// fields. If a class has two properties and/or fields of the form \"X\"\n    /// and \"IsX\", where \"X\" is any name, or has multiple properties and/or\n    /// fields with the same name, those properties and fields are\n    /// ignored.</item>\n    ///  <item>(*) In the Java version, eligible setters are\n    /// public, nonstatic methods starting with \"set\" followed by a\n    /// character other than a basic digit or lower-case letter, that is,\n    /// other than \"a\" to \"z\" or \"0\" to \"9\", that take one parameter. The\n    /// class containing an eligible setter must have a public, nonstatic\n    /// method with the same name, but starting with \"get\" or \"is\" rather\n    /// than \"set\", that takes no parameters and does not return void. (For\n    /// example, if a class has \"public setValue(String)\" and \"public\n    /// getValue()\", \"setValue\" is an eligible setter. However,\n    /// \"setValue()\" and \"setValue(String, int)\" are not eligible setters.)\n    /// In addition, public, nonstatic, nonfinal fields are also eligible\n    /// setters. If a class has two or more otherwise eligible setters\n    /// (methods and/or fields) with the same name, but different parameter\n    /// type, they are not eligible setters.</item>\n    ///  <item>Then, the method\n    /// creates an object of the given type and invokes each eligible\n    /// setter with the corresponding value in the CBOR map, if any. Key\n    /// names in the map are matched to eligible setters according to the\n    /// rules described in the <see cref='PeterO.Cbor.PODOptions'/>\n    /// documentation. Note that for security reasons, certain types are\n    /// not supported even if they contain eligible setters. For the Java\n    /// version, the object creation may fail in the case of a nested\n    /// nonstatic class.</item>\n    ///  </list>\n    ///  </summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b>\n    ///  For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c>\n    ///  or\n    /// <c>String</c>\n    ///  , or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types. Can be\n    /// null.</param>\n    /// <param name='options'>Specifies options for controlling\n    /// deserialization of CBOR objects.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given type\n    /// <paramref name='t'/> , or this object's CBOR type, is not\n    /// supported, or the given object's nesting is too deep, or another\n    /// error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> or <paramref name='options'/> is null.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the\n    /// DotNet version) uses a CBORTypeMapper to change how CBOR objects\n    /// are converted to DateTime objects. In this case, the ToObject\n    /// method assumes the CBOR object is an untagged number giving the\n    /// number of seconds since the start of 1970.</para>\n    /// <code>var conv = new CBORTypeMapper().AddConverter(typeof(DateTime),\n    /// CBORDateConverter.UntaggedNumber);\n    /// var obj = CBORObject.FromObject().ToObject&lt;DateTime&gt;(conv);</code>\n    /// <para>Java offers no easy way to express a generic type, at least\n    /// none as easy as C#'s <c>typeof</c>\n    ///  operator. The following example,\n    /// written in Java, is a way to specify that the return value will be\n    /// an ArrayList of String objects.</para>\n    /// <code>Type arrayListString = new ParameterizedType() { public Type[]\n    /// getActualTypeArguments() { &#x2f;&#x2a; Contains one type parameter,\n    /// String&#x2a;&#x2f;\n    /// return new Type[] { String.class }; }\n    /// public Type getRawType() { /* Raw type is\n    /// ArrayList */ return ArrayList.class; } public Type getOwnerType() {\n    /// return null; } }; ArrayList&lt;String&gt; array =\n    /// (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code>\n    /// <para>By comparison, the C# version is much shorter.</para>\n    /// <code>var array = (List&lt;String&gt;)cborArray.ToObject(\n    /// typeof(List&lt;String&gt;));</code>\n    ///  .\n    /// </example>\n    public object ToObject(Type t, CBORTypeMapper mapper, PODOptions\n      options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      return this.ToObject(t, mapper, options, 0);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object\n    /// to control the decoding process. It is equivalent to\n    /// DecodeFromBytes followed by ToObject. See the documentation for\n    /// those methods for more information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='enc'>Specifies options to control how the CBOR object\n    /// is decoded. See\n    /// <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more\n    /// information.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types. Can be\n    /// null.</param>\n    /// <param name='pod'>Specifies options for controlling deserialization\n    /// of CBOR objects.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='enc'/> is\n    /// null, or the parameter <paramref name='t'/> or <paramref\n    /// name='pod'/> is null.</exception>\n    public static object DecodeObjectFromBytes(\n      byte[] data,\n      CBOREncodeOptions enc,\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions pod) {\n      if (pod == null) {\n        throw new ArgumentNullException(nameof(pod));\n      }\n      if (enc == null) {\n        throw new ArgumentNullException(nameof(enc));\n      }\n      return DecodeFromBytes(data, enc).ToObject(t, mapper, pod);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object\n    /// to control the decoding process. It is equivalent to\n    /// DecodeFromBytes followed by ToObject. See the documentation for\n    /// those methods for more information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='enc'>Specifies options to control how the CBOR object\n    /// is decoded. See\n    /// <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more\n    /// information.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='enc'/> is\n    /// null, or the parameter <paramref name='t'/> is null.</exception>\n    public static object DecodeObjectFromBytes(\n      byte[] data,\n      CBOREncodeOptions enc,\n      Type t) {\n       return DecodeFromBytes(data, enc).ToObject(t);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by\n    /// ToObject. See the documentation for those methods for more\n    /// information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types. Can be\n    /// null.</param>\n    /// <param name='pod'>Specifies options for controlling deserialization\n    /// of CBOR objects.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='t'/> or\n    /// <paramref name='pod'/> is null.</exception>\n    public static object DecodeObjectFromBytes(\n      byte[] data,\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions pod) {\n       return\nDecodeObjectFromBytes(data, CBOREncodeOptions.Default, t, mapper, pod);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by\n    /// ToObject. See the documentation for those methods for more\n    /// information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='t'/> is\n    /// null.</exception>\n    public static object DecodeObjectFromBytes(byte[] data, Type t) {\n       return DecodeObjectFromBytes(data, CBOREncodeOptions.Default, t);\n    }\n\n    internal object ToObject(\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      ++depth;\n      if (depth > 100) {\n        throw new CBORException(\"Depth level too high\");\n      }\n      if (t == null) {\n        throw new ArgumentNullException(nameof(t));\n      }\n      if (t.Equals(typeof(CBORObject))) {\n        return this;\n      }\n      if (this.IsNull) {\n        // TODO: In next major version, consider returning null\n        // here only if this object is untagged, to allow behavior\n        // to be customizable by CBORTypeMapper\n        return null;\n      }\n      if (mapper != null) {\n        object obj = mapper.ConvertBackWithConverter(this, t);\n        if (obj != null) {\n          return obj;\n        }\n      }\n      if (t.Equals(typeof(object))) {\n        return this;\n      }\n      // TODO: In next major version, address inconsistent\n      // implementations for EDecimal, EInteger, EFloat,\n      // and ERational (perhaps\n      // by using EDecimal implementation). Also, these operations\n      // might throw InvalidOperationException rather than CBORException.\n      // Make them throw CBORException in next major version.\n      if (t.Equals(typeof(EDecimal))) {\n        CBORNumber cn = this.AsNumber();\n        return cn.GetNumberInterface().AsEDecimal(cn.GetValue());\n      }\n      if (t.Equals(typeof(EFloat))) {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null) {\n          throw new InvalidOperationException(\"Not a number type\");\n        }\n        return cn.GetNumberInterface().AsEFloat(cn.GetValue());\n      }\n      if (t.Equals(typeof(EInteger))) {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null) {\n          throw new InvalidOperationException(\"Not a number type\");\n        }\n        return cn.GetNumberInterface().AsEInteger(cn.GetValue());\n      }\n      if (t.Equals(typeof(ERational))) {\n        // NOTE: Will likely be simplified in version 5.0 and later\n        if (this.HasMostInnerTag(30) && this.Count != 2) {\n          EInteger num, den;\n          num = (EInteger)this[0].ToObject(typeof(EInteger));\n          den = (EInteger)this[1].ToObject(typeof(EInteger));\n          return ERational.Create(num, den);\n        }\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null) {\n          throw new InvalidOperationException(\"Not a number type\");\n        }\n        return cn.GetNumberInterface().AsERational(cn.GetValue());\n      }\n      return t.Equals(typeof(string)) ? this.AsString() :\n        PropertyMap.TypeToObject(this, t, mapper, options, depth);\n    }\n\n    /// <summary>Generates a CBOR object from a 64-bit signed\n    /// integer.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 64-bit signed integer.</param>\n    /// <returns>A CBOR object.</returns>\n    public static CBORObject FromObject(long value) {\n      if (value >= 0L && value < 24L) {\n        return FixedObjects[(int)value];\n      } else {\n        return (value >= -24L && value < 0L) ? FixedObjects[0x20 - (int)(value +\n              1L)] : new CBORObject(CBORObjectTypeInteger, value);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a CBOR object.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// CBOR object.</param>\n    /// <returns>Same as <paramref name='value'/>, or \"CBORObject.Null\" is\n    /// <paramref name='value'/> is null.</returns>\n    public static CBORObject FromObject(CBORObject value) {\n      return value ?? CBORObject.Null;\n    }\n\n    private static int IntegerByteLength(int intValue) {\n      if (intValue < 0) {\n        intValue = -(intValue + 1);\n      }\n      if (intValue > 0xffff) {\n        return 5;\n      } else if (intValue > 0xff) {\n        return 3;\n      } else {\n        return (intValue > 23) ? 2 : 1;\n      }\n    }\n\n    private static int IntegerByteLength(long longValue) {\n      if (longValue < 0) {\n        longValue = -(longValue + 1);\n      }\n      if (longValue > 0xffffffffL) {\n        return 9;\n      } else if (longValue > 0xffffL) {\n        return 5;\n      } else if (longValue > 0xffL) {\n        return 3;\n      } else {\n        return (longValue > 23L) ? 2 : 1;\n      }\n    }\n\n    /// <summary>Calculates the number of bytes this CBOR object takes when\n    /// serialized as a byte array using the <c>EncodeToBytes()</c> method.\n    /// This calculation assumes that integers, lengths of maps and arrays,\n    /// lengths of text and byte strings, and tag numbers are encoded in\n    /// their shortest form; that floating-point numbers are encoded in\n    /// their shortest value-preserving form; and that no indefinite-length\n    /// encodings are used.</summary>\n    /// <returns>The number of bytes this CBOR object takes when serialized\n    /// as a byte array using the <c>EncodeToBytes()</c> method.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The CBOR object has an\n    /// extremely deep level of nesting, including if the CBOR object is or\n    /// has an array or map that includes itself.</exception>\n    public long CalcEncodedSize() {\n      return this.CalcEncodedSize(0);\n    }\n\n    private long CalcEncodedSize(int depth) {\n      if (depth > 1000) {\n        throw new CBORException(\"Too deeply nested\");\n      }\n      // DebugUtility.Log(\"type=\"+this.Type+\" depth=\"+depth);\n      long size = 0L;\n      CBORObject cbor = this;\n      while (cbor.IsTagged) {\n        EInteger etag = cbor.MostOuterTag;\n        if (etag.CanFitInInt64()) {\n          long tag = etag.ToInt64Checked();\n          size = checked(size + IntegerByteLength(tag));\n        } else {\n          size = checked(size + 9);\n        }\n        cbor = cbor.UntagOne();\n      }\n      if (cbor.ItemType == CBORObjectTypeTextStringUtf8) {\n        byte[] bytes = (byte[])this.ThisItem;\n        size = checked(size + IntegerByteLength(bytes.Length));\n        return checked(size + bytes.Length);\n      }\n      if (cbor.ItemType == CBORObjectTypeTextStringAscii) {\n        var str = (string)this.ThisItem;\n        size = checked(size + IntegerByteLength(str.Length));\n        return checked(size + str.Length);\n      }\n      switch (cbor.Type) {\n        case CBORType.Integer: {\n          if (cbor.CanValueFitInInt64()) {\n            long tag = cbor.AsInt64Value();\n            size = checked(size + IntegerByteLength(tag));\n            return size;\n          } else {\n            return checked(size + 9);\n          }\n        }\n        case CBORType.FloatingPoint: {\n          long valueBits = cbor.AsDoubleBits();\n          int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);\n          if (bits != -1) {\n            return checked(size + 3);\n          }\n          return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ?\n            checked(size + 5) : checked(size + 9);\n        }\n        case CBORType.Array:\n          size = checked(size + IntegerByteLength(cbor.Count));\n          for (var i = 0; i < cbor.Count; ++i) {\n            long newsize = cbor[i].CalcEncodedSize(depth + 1);\n            size = checked(size + newsize);\n          }\n          return size;\n        case CBORType.Map: {\n          ICollection<KeyValuePair<CBORObject, CBORObject>> entries =\n            this.Entries;\n          size = checked(size + IntegerByteLength(entries.Count));\n          try {\n            foreach (KeyValuePair<CBORObject, CBORObject> entry in entries) {\n              CBORObject key = entry.Key;\n              CBORObject value = entry.Value;\n              size = checked(size + key.CalcEncodedSize(depth + 1));\n              size = checked(size + value.CalcEncodedSize(depth + 1));\n            }\n          } catch (InvalidOperationException ex) {\n            // Additional error that may occur in iteration\n            throw new CBORException(ex.Message, ex);\n          } catch (ArgumentException ex) {\n            // Additional error that may occur in iteration\n            throw new CBORException(ex.Message, ex);\n          }\n          return size;\n        }\n        case CBORType.TextString: {\n          long ulength = DataUtilities.GetUtf8Length(this.AsString(), false);\n          size = checked(size + IntegerByteLength(ulength));\n          return checked(size + ulength);\n        }\n        case CBORType.ByteString: {\n          byte[] bytes = cbor.GetByteString();\n          size = checked(size + IntegerByteLength(bytes.Length));\n          return checked(size + bytes.Length);\n        }\n        case CBORType.Boolean:\n          return checked(size + 1);\n        case CBORType.SimpleValue:\n          return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));\n        default: throw new InvalidOperationException();\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary-precision\n    /// integer. The CBOR object is generated as follows:\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number is greater than or equal to -(2^64)\n    /// and less than 2^64, the CBOR object will have the object type\n    /// Integer and the appropriate value.</item>\n    /// <item>Otherwise, the CBOR object will have tag 2 (zero or positive)\n    /// or 3 (negative) and the appropriate value.</item></list></summary>\n    /// <param name='bigintValue'>An arbitrary-precision integer. Can be\n    /// null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigintValue'/> is\n    /// null.</returns>\n    public static CBORObject FromObject(EInteger bigintValue) {\n      if ((object)bigintValue == (object)null) {\n        return CBORObject.Null;\n      }\n      if (bigintValue.CanFitInInt64()) {\n        return CBORObject.FromObject(bigintValue.ToInt64Checked());\n      } else {\n        EInteger bitLength = bigintValue.GetSignedBitLengthAsEInteger();\n        if (bitLength.CompareTo(64) <= 0) {\n          // Fits in major type 0 or 1\n          return new CBORObject(CBORObjectTypeEInteger, bigintValue);\n        } else {\n          int tag = (bigintValue.Sign < 0) ? 3 : 2;\n          return CBORObject.FromObjectAndTag(\n              EIntegerBytes(bigintValue),\n              tag);\n        }\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary-precision binary\n    /// floating-point number. The CBOR object is generated as follows\n    /// (this is a change in version 4.0):\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number expresses infinity, not-a-number, or\n    /// negative zero, the CBOR object will have tag 269 and the\n    /// appropriate format.</item>\n    /// <item>Otherwise, if the number's exponent is at least 2^64 or less\n    /// than -(2^64), the CBOR object will have tag 265 and the appropriate\n    /// format.</item>\n    /// <item>Otherwise, the CBOR object will have tag 5 and the\n    /// appropriate format.</item></list></summary>\n    /// <param name='bigValue'>An arbitrary-precision binary floating-point\n    /// number. Can be null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigValue'/> is null.</returns>\n    public static CBORObject FromObject(EFloat bigValue) {\n      if ((object)bigValue == (object)null) {\n        return CBORObject.Null;\n      }\n      CBORObject cbor;\n      int tag;\n      if (bigValue.IsInfinity() || bigValue.IsNaN() ||\n        (bigValue.IsNegative && bigValue.IsZero)) {\n        int options = bigValue.IsNegative ? 1 : 0;\n        if (bigValue.IsInfinity()) {\n          options += 2;\n        }\n        if (bigValue.IsQuietNaN()) {\n          options += 4;\n        }\n        if (bigValue.IsSignalingNaN()) {\n          options += 6;\n        }\n        cbor = CBORObject.NewArray(\n            CBORObject.FromObject(bigValue.Exponent),\n            CBORObject.FromObject(bigValue.UnsignedMantissa),\n            CBORObject.FromObject(options));\n        tag = 269;\n      } else {\n        EInteger exponent = bigValue.Exponent;\n        if (exponent.CanFitInInt64()) {\n          tag = 5;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent.ToInt64Checked()),\n              CBORObject.FromObject(bigValue.Mantissa));\n        } else {\n          tag = (exponent.GetSignedBitLengthAsInt64() > 64) ?\n            265 : 5;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent),\n              CBORObject.FromObject(bigValue.Mantissa));\n        }\n      }\n      return cbor.WithTag(tag);\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary-precision\n    /// rational number. The CBOR object is generated as follows (this is a\n    /// change in version 4.0):\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number expresses infinity, not-a-number, or\n    /// negative zero, the CBOR object will have tag 270 and the\n    /// appropriate format.</item>\n    /// <item>Otherwise, the CBOR object will have tag 30 and the\n    /// appropriate format.</item></list></summary>\n    /// <param name='bigValue'>An arbitrary-precision rational number. Can\n    /// be null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigValue'/> is null.</returns>\n    public static CBORObject FromObject(ERational bigValue) {\n      if ((object)bigValue == (object)null) {\n        return CBORObject.Null;\n      }\n      CBORObject cbor;\n      int tag;\n      if (bigValue.IsInfinity() || bigValue.IsNaN() ||\n        (bigValue.IsNegative && bigValue.IsZero)) {\n        int options = bigValue.IsNegative ? 1 : 0;\n        if (bigValue.IsInfinity()) {\n          options += 2;\n        }\n        if (bigValue.IsQuietNaN()) {\n          options += 4;\n        }\n        if (bigValue.IsSignalingNaN()) {\n          options += 6;\n        }\n        #if DEBUG\n        if (!(!bigValue.IsInfinity() || bigValue.UnsignedNumerator.IsZero)) {\n          throw new InvalidOperationException(\"doesn't satisfy\" +\n            \"\\u0020!bigValue.IsInfinity() ||\" +\n            \"\\u0020bigValue.UnsignedNumerator.IsZero\");\n        }\n        if (!(!bigValue.IsInfinity() || bigValue.Denominator.CompareTo(1) ==\n            0)) {\n          throw new InvalidOperationException(\"doesn't satisfy\" +\n            \"\\u0020!bigValue.IsInfinity() ||\" +\n            \"\\u0020bigValue.Denominator.CompareTo(1)==0\");\n        }\n        if (!(!bigValue.IsNaN() || bigValue.Denominator.CompareTo(1) == 0)) {\n          throw new InvalidOperationException(\"doesn't satisfy\" +\n            \"\\u0020!bigValue.IsNaN() ||\" +\n            \"\\u0020bigValue.Denominator.CompareTo(1)==0\");\n        }\n        #endif\n\n        cbor = CBORObject.NewArray(\n            FromObject(bigValue.UnsignedNumerator),\n            FromObject(bigValue.Denominator),\n            FromObject(options));\n        tag = 270;\n      } else {\n        tag = 30;\n        cbor = CBORObject.NewArray(\n            CBORObject.FromObject(bigValue.Numerator),\n            CBORObject.FromObject(bigValue.Denominator));\n      }\n      return cbor.WithTag(tag);\n    }\n\n    /// <summary>Generates a CBOR object from a decimal number. The CBOR\n    /// object is generated as follows (this is a change in version 4.0):\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number expresses infinity, not-a-number, or\n    /// negative zero, the CBOR object will have tag 268 and the\n    /// appropriate format.</item>\n    /// <item>If the number's exponent is at least 2^64 or less than\n    /// -(2^64), the CBOR object will have tag 264 and the appropriate\n    /// format.</item>\n    /// <item>Otherwise, the CBOR object will have tag 4 and the\n    /// appropriate format.</item></list></summary>\n    /// <param name='bigValue'>An arbitrary-precision decimal number. Can\n    /// be null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigValue'/> is null.</returns>\n    public static CBORObject FromObject(EDecimal bigValue) {\n      if ((object)bigValue == (object)null) {\n        return CBORObject.Null;\n      }\n      CBORObject cbor;\n      int tag;\n      if (bigValue.IsInfinity() || bigValue.IsNaN() ||\n        (bigValue.IsNegative && bigValue.IsZero)) {\n        int options = bigValue.IsNegative ? 1 : 0;\n        if (bigValue.IsInfinity()) {\n          options += 2;\n        }\n        if (bigValue.IsQuietNaN()) {\n          options += 4;\n        }\n        if (bigValue.IsSignalingNaN()) {\n          options += 6;\n        }\n        cbor = CBORObject.NewArray(\n            FromObject(bigValue.Exponent),\n            FromObject(bigValue.UnsignedMantissa),\n            FromObject(options));\n        tag = 268;\n      } else {\n        EInteger exponent = bigValue.Exponent;\n        if (exponent.CanFitInInt64()) {\n          tag = 4;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent.ToInt64Checked()),\n              CBORObject.FromObject(bigValue.Mantissa));\n        } else {\n          tag = (exponent.GetSignedBitLengthAsInt64() > 64) ?\n            264 : 4;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent),\n              CBORObject.FromObject(bigValue.Mantissa));\n        }\n      }\n      return cbor.WithTag(tag);\n    }\n\n    /// <summary>Generates a CBOR object from a text string.</summary>\n    /// <param name='strValue'>A text string value. Can be null.</param>\n    /// <returns>A CBOR object representing the string, or CBORObject.Null\n    /// if stringValue is null.</returns>\n    /// <exception cref='ArgumentException'>The string contains an unpaired\n    /// surrogate code point.</exception>\n    public static CBORObject FromObject(string strValue) {\n      if (strValue == null) {\n        return CBORObject.Null;\n      }\n      if (strValue.Length == 0) {\n        return GetFixedObject(0x60);\n      }\n      long utf8Length = DataUtilities.GetUtf8Length(strValue, false);\n      if (utf8Length < 0) {\n        throw new ArgumentException(\"String contains an unpaired \" +\n          \"surrogate code point.\");\n      }\n      return new CBORObject(\n        strValue.Length == utf8Length ? CBORObjectTypeTextStringAscii : CBORObjectTypeTextString,\n        strValue);\n    }\n\n    /// <summary>Generates a CBOR object from a 32-bit signed\n    /// integer.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 32-bit signed integer.</param>\n    /// <returns>A CBOR object.</returns>\n    public static CBORObject FromObject(int value) {\n      if (value >= 0 && value < 24) {\n        return FixedObjects[value];\n      } else {\n        return (value >= -24 && value < 0) ? FixedObjects[0x20 - (value + 1)] :\n          FromObject((long)value);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a 16-bit signed\n    /// integer.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 16-bit signed integer.</param>\n    /// <returns>A CBOR object generated from the given integer.</returns>\n    public static CBORObject FromObject(short value) {\n      if (value >= 0 && value < 24) {\n        return FixedObjects[value];\n      } else {\n        return (value >= -24 && value < 0) ? FixedObjects[0x20 - (value + 1)] :\n          FromObject((long)value);\n      }\n    }\n\n    /// <summary>Returns the CBOR true value or false value, depending on\n    /// \"value\".</summary>\n    /// <param name='value'>Either <c>true</c> or <c>false</c>.</param>\n    /// <returns>CBORObject.True if value is true; otherwise\n    /// CBORObject.False.</returns>\n    public static CBORObject FromObject(bool value) {\n      return value ? CBORObject.True : CBORObject.False;\n    }\n\n    /// <summary>Generates a CBOR object from a byte (0 to 255).</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// byte (from 0 to 255).</param>\n    /// <returns>A CBOR object generated from the given integer.</returns>\n    public static CBORObject FromObject(byte value) {\n      return FromObject(((int)value) & 0xff);\n    }\n\n    /// <summary>Generates a CBOR object from a 32-bit floating-point\n    /// number. The input value can be a not-a-number (NaN) value (such as\n    /// <c>Single.NaN</c> in DotNet or Float.NaN in Java); however, NaN\n    /// values have multiple forms that are equivalent for many\n    /// applications' purposes, and <c>Single.NaN</c> / <c>Float.NaN</c> is\n    /// only one of these equivalent forms. In fact,\n    /// <c>CBORObject.FromObject(Single.NaN)</c> or\n    /// <c>CBORObject.FromObject(Float.NaN)</c> could produce a\n    /// CBOR-encoded object that differs between DotNet and Java, because\n    /// <c>Single.NaN</c> / <c>Float.NaN</c> may have a different form in\n    /// DotNet and Java (for example, the NaN value's sign may be negative\n    /// in DotNet, but positive in Java).</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 32-bit floating-point number.</param>\n    /// <returns>A CBOR object generated from the given number.</returns>\n    public static CBORObject FromObject(float value) {\n      long doubleBits = CBORUtilities.SingleToDoublePrecision(\n          CBORUtilities.SingleToInt32Bits(value));\n      return new CBORObject(CBORObjectTypeDouble, doubleBits);\n    }\n\n    /// <summary>Generates a CBOR object from a 64-bit floating-point\n    /// number. The input value can be a not-a-number (NaN) value (such as\n    /// <c>Double.NaN</c> ); however, NaN values have multiple forms that\n    /// are equivalent for many applications' purposes, and\n    /// <c>Double.NaN</c> is only one of these equivalent forms. In fact,\n    /// <c>CBORObject.FromObject(Double.NaN)</c> could produce a\n    /// CBOR-encoded object that differs between DotNet and Java, because\n    /// <c>Double.NaN</c> may have a different form in DotNet and Java (for\n    /// example, the NaN value's sign may be negative in DotNet, but\n    /// positive in Java).</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 64-bit floating-point number.</param>\n    /// <returns>A CBOR object generated from the given number.</returns>\n    public static CBORObject FromObject(double value) {\n      long doubleBits = CBORUtilities.DoubleToInt64Bits(value);\n      return new CBORObject(CBORObjectTypeDouble, doubleBits);\n    }\n\n    /// <summary>Generates a CBOR object from an array of 8-bit bytes; the\n    /// byte array is copied to a new byte array in this process. (This\n    /// method can't be used to decode CBOR data from a byte array; for\n    /// that, use the <b>DecodeFromBytes</b> method instead.).</summary>\n    /// <param name='bytes'>An array of 8-bit bytes; can be null.</param>\n    /// <returns>A CBOR object where each element of the given byte array\n    /// is copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(byte[] bytes) {\n      if (bytes == null) {\n        return CBORObject.Null;\n      }\n      var newvalue = new byte[bytes.Length];\n      Array.Copy(bytes, 0, newvalue, 0, bytes.Length);\n      return new CBORObject(CBORObjectTypeByteString, bytes);\n    }\n\n    /// <summary>Generates a CBOR object from an array of CBOR\n    /// objects.</summary>\n    /// <param name='array'>An array of CBOR objects.</param>\n    /// <returns>A CBOR object where each element of the given array is\n    /// copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(CBORObject[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = new List<CBORObject>();\n      foreach (CBORObject cbor in array) {\n        list.Add(cbor);\n      }\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    internal static CBORObject FromArrayBackedObject(CBORObject[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = PropertyMap.ListFromArray(array);\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Generates a CBOR object from an array of 32-bit\n    /// integers.</summary>\n    /// <param name='array'>An array of 32-bit integers.</param>\n    /// <returns>A CBOR array object where each element of the given array\n    /// is copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(int[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = new List<CBORObject>(array.Length ==\n        Int32.MaxValue ? array.Length : (array.Length + 1));\n      foreach (int i in array) {\n        list.Add(FromObject(i));\n      }\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Generates a CBOR object from an array of 64-bit\n    /// integers.</summary>\n    /// <param name='array'>An array of 64-bit integers.</param>\n    /// <returns>A CBOR array object where each element of the given array\n    /// is copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(long[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = new List<CBORObject>(array.Length ==\n        Int32.MaxValue ? array.Length : (array.Length + 1));\n      foreach (long i in array) {\n        list.Add(FromObject(i));\n      }\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Generates a CBORObject from an arbitrary object. See the\n    /// overload of this method that takes CBORTypeMapper and PODOptions\n    /// arguments.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object, which can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    public static CBORObject FromObject(object obj) {\n      return FromObject(obj, PODOptions.Default);\n    }\n\n    /// <summary>Generates a CBORObject from an arbitrary object. See the\n    /// overload of this method that takes CBORTypeMapper and PODOptions\n    /// arguments.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='options'>An object containing options to control how\n    /// certain objects are converted to CBOR objects.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    public static CBORObject FromObject(\n      object obj,\n      PODOptions options) {\n      return FromObject(obj, options, null, 0);\n    }\n\n    /// <summary>Generates a CBORObject from an arbitrary object. See the\n    /// overload of this method that takes CBORTypeMapper and PODOptions\n    /// arguments.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='mapper'>An object containing optional converters to\n    /// convert objects of certain types to CBOR objects.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='mapper'/> is null.</exception>\n    public static CBORObject FromObject(\n      object obj,\n      CBORTypeMapper mapper) {\n      if (mapper == null) {\n        throw new ArgumentNullException(nameof(mapper));\n      }\n      return FromObject(obj, PODOptions.Default, mapper, 0);\n    }\n\n    /// <summary><para>Generates a CBORObject from an arbitrary object,\n    /// using the given options to control how certain objects are\n    /// converted to CBOR objects. The following cases are checked in the\n    /// logical order given (rather than the strict order in which they are\n    /// implemented by this library):</para>\n    ///  <list><item><c>null</c>\n    ///  is\n    /// converted to <c>CBORObject.Null</c>\n    ///  .</item>\n    ///  <item>A\n    /// <c>CBORObject</c>\n    ///  is returned as itself.</item>\n    ///  <item>If the object\n    /// is of a type corresponding to a type converter mentioned in the\n    /// <paramref name='mapper'/> parameter, that converter will be used to\n    /// convert the object to a CBOR object. Type converters can be used to\n    /// override the default conversion behavior of almost any\n    /// object.</item>\n    ///  <item>A <c>char</c>\n    ///  is converted to an integer (from\n    /// 0 through 65535), and returns a CBOR object of that integer. (This\n    /// is a change in version 4.0 from previous versions, which converted\n    /// <c>char</c>\n    ///  , except surrogate code points from 0xd800 through\n    /// 0xdfff, into single-character text strings.)</item>\n    ///  <item>A\n    /// <c>bool</c>\n    ///  ( <c>boolean</c>\n    ///  in Java) is converted to\n    /// <c>CBORObject.True</c>\n    ///  or <c>CBORObject.False</c>\n    ///  .</item>\n    ///  <item>A\n    /// <c>byte</c>\n    ///  is converted to a CBOR integer from 0 through\n    /// 255.</item>\n    ///  <item>A primitive integer type ( <c>int</c>\n    ///  ,\n    /// <c>short</c>\n    ///  , <c>long</c>\n    ///  , as well as <c>sbyte</c>\n    ///  ,\n    /// <c>ushort</c>\n    ///  , <c>uint</c>\n    ///  , and <c>ulong</c>\n    ///  in.NET) is converted\n    /// to the corresponding CBOR integer.</item>\n    ///  <item>A primitive\n    /// floating-point type ( <c>float</c>\n    ///  , <c>double</c>\n    ///  , as well as\n    /// <c>decimal</c>\n    ///  in.NET) is converted to the corresponding CBOR\n    /// number.</item>\n    ///  <item>A <c>String</c>\n    ///  is converted to a CBOR text\n    /// string. To create a CBOR byte string object from <c>String</c>\n    ///  ,\n    /// see the example given in <see\n    /// cref='PeterO.Cbor.CBORObject.FromObject(System.Byte[])'/>.</item>\n    /// <item>In the.NET version, a nullable is converted to\n    /// <c>CBORObject.Null</c>\n    ///  if the nullable's value is <c>null</c>\n    ///  , or\n    /// converted according to the nullable's underlying type, if that type\n    /// is supported by this method.</item>\n    ///  <item>In the Java version, a\n    /// number of type <c>BigInteger</c>\n    ///  or <c>BigDecimal</c>\n    ///  is converted\n    /// to the corresponding CBOR number.</item>\n    ///  <item>A number of type\n    /// <c>EDecimal</c>\n    ///  , <c>EFloat</c>\n    ///  , <c>EInteger</c>\n    ///  , and\n    /// <c>ERational</c>\n    ///  in the <a\n    /// href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c>\n    /// </a>\n    ///  library (in .NET) or the <a\n    /// href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c>\n    /// </a>\n    ///  artifact (in Java) is converted to the corresponding CBOR\n    /// number.</item>\n    ///  <item>An array other than <c>byte[]</c>\n    ///  is converted\n    /// to a CBOR array. In the.NET version, a multidimensional array is\n    /// converted to an array of arrays.</item>\n    ///  <item>A <c>byte[]</c>\n    /// (1-dimensional byte array) is converted to a CBOR byte string; the\n    /// byte array is copied to a new byte array in this process. (This\n    /// method can't be used to decode CBOR data from a byte array; for\n    /// that, use the <b>DecodeFromBytes</b>\n    ///  method instead.)</item>\n    /// <item>An object implementing IDictionary (Map in Java) is converted\n    /// to a CBOR map containing the keys and values enumerated.</item>\n    /// <item>An object implementing IEnumerable (Iterable in Java) is\n    /// converted to a CBOR array containing the items enumerated.</item>\n    /// <item>An enumeration ( <c>Enum</c>\n    ///  ) object is converted to its\n    /// <i>underlying value</i>\n    ///  in the.NET version, or the result of its\n    /// <c>ordinal()</c>\n    ///  method in the Java version.</item>\n    ///  <item>An object\n    /// of type <c>DateTime</c>\n    ///  , <c>Uri</c>\n    ///  , or <c>Guid</c>\n    ///  ( <c>Date</c>\n    /// , <c>URI</c>\n    ///  , or <c>UUID</c>\n    ///  , respectively, in Java) will be\n    /// converted to a tagged CBOR object of the appropriate kind. By\n    /// default, <c>DateTime</c>\n    ///  / <c>Date</c>\n    ///  will be converted to a tag-0\n    /// string following the date format used in the Atom syndication\n    /// format, but this behavior can be changed by passing a suitable\n    /// CBORTypeMapper to this method, such as a CBORTypeMapper that\n    /// registers a CBORDateConverter for <c>DateTime</c>\n    ///  or <c>Date</c>\n    /// objects. See the examples.</item>\n    ///  <item>If the object is a type not\n    /// specially handled above, this method checks the <paramref\n    /// name='obj'/> parameter for eligible getters as follows:</item>\n    /// <item>(*) In the .NET version, eligible getters are the public,\n    /// nonstatic getters of read/write properties (and also those of\n    /// read-only properties in the case of a compiler-generated type or an\n    /// F# type). Eligible getters also include public, nonstatic, non-\n    /// <c>const</c>\n    ///  , non- <c>readonly</c>\n    ///  fields. If a class has two\n    /// properties and/or fields of the form \"X\" and \"IsX\", where \"X\" is\n    /// any name, or has multiple properties and/or fields with the same\n    /// name, those properties and fields are ignored.</item>\n    ///  <item>(*) In\n    /// the Java version, eligible getters are public, nonstatic methods\n    /// starting with \"get\" or \"is\" (either word followed by a character\n    /// other than a basic digit or lower-case letter, that is, other than\n    /// \"a\" to \"z\" or \"0\" to \"9\"), that take no parameters and do not\n    /// return void, except that methods named \"getClass\" are not eligible\n    /// getters. In addition, public, nonstatic, nonfinal fields are also\n    /// eligible getters. If a class has two otherwise eligible getters\n    /// (methods and/or fields) of the form \"isX\" and \"getX\", where \"X\" is\n    /// the same in both, or two such getters with the same name but\n    /// different return type, they are not eligible getters.</item>\n    /// <item>Then, the method returns a CBOR map with each eligible\n    /// getter's name or property name as each key, and with the\n    /// corresponding value returned by that getter as that key's value.\n    /// Before adding a key-value pair to the map, the key's name is\n    /// adjusted according to the rules described in the <see\n    /// cref='PeterO.Cbor.PODOptions'/> documentation. Note that for\n    /// security reasons, certain types are not supported even if they\n    /// contain eligible getters.</item>\n    ///  </list>\n    ///  <para><b>REMARK:</b>\n    ///  .NET\n    /// enumeration ( <c>Enum</c>\n    ///  ) constants could also have been\n    /// converted to text strings with <c>ToString()</c>\n    ///  , but that method\n    /// will return multiple names if the given Enum object is a\n    /// combination of Enum objects (e.g. if the object is\n    /// <c>FileAccess.Read | FileAccess.Write</c>\n    ///  ). More generally, if\n    /// Enums are converted to text strings, constants from Enum types with\n    /// the <c>Flags</c>\n    ///  attribute, and constants from the same Enum type\n    /// that share an underlying value, should not be passed to this\n    /// method.</para>\n    ///  </summary>\n    /// <param name='obj'>An arbitrary object to convert to a CBOR object.\n    /// <para><b>NOTE:</b>\n    ///  For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c>\n    ///  or <c>String</c>\n    ///  ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>\n    /// .</param>\n    /// <param name='mapper'>An object containing optional converters to\n    /// convert objects of certain types to CBOR objects. Can be\n    /// null.</param>\n    /// <param name='options'>An object containing options to control how\n    /// certain objects are converted to CBOR objects.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>An error occurred while\n    /// converting the given object to a CBOR object.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the\n    /// DotNet version) uses a CBORTypeMapper to change how DateTime\n    /// objects are converted to CBOR. In this case, such objects are\n    /// converted to CBOR objects with tag 1 that store numbers giving the\n    /// number of seconds since the start of 1970.</para>\n    /// <code>var conv = new CBORTypeMapper().AddConverter(typeof(DateTime),\n    /// CBORDateConverter.TaggedNumber);\n    /// CBORObject obj = CBORObject.FromObject(DateTime.Now, conv);</code>\n    /// <para>The following example generates a CBOR object from a 64-bit\n    /// signed integer that is treated as a 64-bit unsigned integer (such\n    /// as DotNet's UInt64, which has no direct equivalent in the Java\n    /// language), in the sense that the value is treated as 2^64 plus the\n    /// original value if it's negative.</para>\n    /// <code>long x = -40L; &#x2f;&#x2a; Example 64-bit value treated as 2^64-40.&#x2a;&#x2f;\n    /// CBORObject obj = CBORObject.FromObject(\n    /// v &lt; 0 ? EInteger.FromInt32(1).ShiftLeft(64).Add(v) :\n    /// EInteger.FromInt64(v));</code>\n    /// <para>In the Java version, which has java.math.BigInteger, the\n    /// following can be used instead:</para>\n    /// <code>long x = -40L; &#x2f;&#x2a; Example 64-bit value treated as 2^64-40.&#x2a;&#x2f;\n    /// CBORObject obj = CBORObject.FromObject(\n    /// v &lt; 0 ? BigInteger.valueOf(1).shiftLeft(64).add(BigInteger.valueOf(v)) :\n    /// BigInteger.valueOf(v));</code>\n    /// </example>\n    public static CBORObject FromObject(\n      object obj,\n      CBORTypeMapper mapper,\n      PODOptions options) {\n      if (mapper == null) {\n        throw new ArgumentNullException(nameof(mapper));\n      }\n      return FromObject(obj, options, mapper, 0);\n    }\n\n    internal static CBORObject FromObject(\n      object obj,\n      PODOptions options,\n      CBORTypeMapper mapper,\n      int depth) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (depth >= 100) {\n        throw new CBORException(\"Nesting depth too high\");\n      }\n      if (obj == null) {\n        return CBORObject.Null;\n      }\n      if (obj is CBORObject) {\n        return FromObject((CBORObject)obj);\n      }\n      CBORObject objret;\n      if (mapper != null) {\n        objret = mapper.ConvertWithConverter(obj);\n        if (objret != null) {\n          return objret;\n        }\n      }\n      if (obj is string) {\n        return FromObject((string)obj);\n      }\n      if (obj is int) {\n        return FromObject((int)obj);\n      }\n      if (obj is long) {\n        return FromObject((long)obj);\n      }\n      var eif = obj as EInteger;\n      if (eif != null) {\n        return FromObject(eif);\n      }\n      var edf = obj as EDecimal;\n      if (edf != null) {\n        return FromObject(edf);\n      }\n      var eff = obj as EFloat;\n      if (eff != null) {\n        return FromObject(eff);\n      }\n      var erf = obj as ERational;\n      if (erf != null) {\n        return FromObject(erf);\n      }\n      if (obj is short) {\n        return FromObject((short)obj);\n      }\n      if (obj is char) {\n        return FromObject((int)(char)obj);\n      }\n      if (obj is bool) {\n        return FromObject((bool)obj);\n      }\n      if (obj is byte) {\n        return FromObject((byte)obj);\n      }\n      if (obj is float) {\n        return FromObject((float)obj);\n      }\n      if (obj is sbyte) {\n        return FromObject((sbyte)obj);\n      }\n      if (obj is ulong) {\n        return FromObject((ulong)obj);\n      }\n      if (obj is uint) {\n        return FromObject((uint)obj);\n      }\n      if (obj is ushort) {\n        return FromObject((ushort)obj);\n      }\n      if (obj is decimal) {\n        return FromObject((decimal)obj);\n      }\n      if (obj is double) {\n        return FromObject((double)obj);\n      }\n      byte[] bytearr = obj as byte[];\n      if (bytearr != null) {\n        return FromObject(bytearr);\n      }\n      if (obj is System.Collections.IDictionary) {\n        // IDictionary appears first because IDictionary includes IEnumerable\n        objret = CBORObject.NewMap();\n        System.Collections.IDictionary objdic =\n          (System.Collections.IDictionary)obj;\n        foreach (object keyPair in (System.Collections.IDictionary)objdic) {\n          System.Collections.DictionaryEntry\n          kvp = (System.Collections.DictionaryEntry)keyPair;\n          CBORObject objKey = CBORObject.FromObject(\n              kvp.Key,\n              options,\n              mapper,\n              depth + 1);\n          objret[objKey] = CBORObject.FromObject(\n              kvp.Value,\n              options,\n              mapper,\n              depth + 1);\n        }\n        return objret;\n      }\n      if (obj is Array) {\n        return PropertyMap.FromArray(obj, options, mapper, depth);\n      }\n      if (obj is System.Collections.IEnumerable) {\n        objret = CBORObject.NewArray();\n        foreach (object element in (System.Collections.IEnumerable)obj) {\n          objret.Add(\n            CBORObject.FromObject(\n              element,\n              options,\n              mapper,\n              depth + 1));\n        }\n        return objret;\n      }\n      if (obj is Enum) {\n        return FromObject(PropertyMap.EnumToObjectAsInteger((Enum)obj));\n      }\n      if (obj is DateTime) {\n        return new CBORDateConverter().ToCBORObject((DateTime)obj);\n      }\n      if (obj is Uri) {\n        return new CBORUriConverter().ToCBORObject((Uri)obj);\n      }\n      if (obj is Guid) {\n        return new CBORUuidConverter().ToCBORObject((Guid)obj);\n      }\n      objret = PropertyMap.FromObjectOther(obj);\n      if (objret != null) {\n        return objret;\n      }\n      objret = CBORObject.NewMap();\n      foreach (KeyValuePair<string, object> key in\n        PropertyMap.GetProperties(\n          obj,\n          options.UseCamelCase)) {\n        objret[key.Key] = CBORObject.FromObject(\n            key.Value,\n            options,\n            mapper,\n            depth + 1);\n      }\n      return objret;\n    }\n\n    /// <summary>Generates a CBOR object from this one, but gives the\n    /// resulting object a tag in addition to its existing tags (the new\n    /// tag is made the outermost tag).</summary>\n    /// <param name='bigintTag'>Tag number. The tag number 55799 can be\n    /// used to mark a \"self-described CBOR\" object. This document does not\n    /// attempt to list all CBOR tags and their meanings. An up-to-date\n    /// list can be found at the CBOR Tags registry maintained by the\n    /// Internet Assigned Numbers Authority(\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object with the same value as this one but given\n    /// the tag <paramref name='bigintTag'/> in addition to its existing\n    /// tags (the new tag is made the outermost tag).</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigintTag'/> is less than 0 or greater than\n    /// 2^64-1.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigintTag'/> is null.</exception>\n    public CBORObject WithTag(EInteger bigintTag) {\n      if (bigintTag == null) {\n        throw new ArgumentNullException(nameof(bigintTag));\n      }\n      if (bigintTag.Sign < 0) {\n        throw new ArgumentException(\"tagEInt's sign(\" + bigintTag.Sign +\n          \") is less than 0\");\n      }\n      if (bigintTag.CanFitInInt32()) {\n        // Low-numbered, commonly used tags\n        return this.WithTag(bigintTag.ToInt32Checked());\n      } else {\n        if (bigintTag.CompareTo(UInt64MaxValue) > 0) {\n          throw new ArgumentException(\n            \"tag more than 18446744073709551615 (\" + bigintTag + \")\");\n        }\n        var tagLow = 0;\n        var tagHigh = 0;\n        byte[] bytes = bigintTag.ToBytes(true);\n        for (var i = 0; i < Math.Min(4, bytes.Length); ++i) {\n          int b = ((int)bytes[i]) & 0xff;\n          tagLow = unchecked(tagLow | (((int)b) << (i * 8)));\n        }\n        for (int i = 4; i < Math.Min(8, bytes.Length); ++i) {\n          int b = ((int)bytes[i]) & 0xff;\n          tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));\n        }\n        return new CBORObject(this, tagLow, tagHigh);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary object and gives\n    /// the resulting object a tag in addition to its existing tags (the\n    /// new tag is made the outermost tag).</summary>\n    /// <param name='valueOb'>The parameter <paramref name='valueOb'/> is\n    /// an arbitrary object, which can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='bigintTag'>Tag number. The tag number 55799 can be\n    /// used to mark a \"self-described CBOR\" object. This document does not\n    /// attempt to list all CBOR tags and their meanings. An up-to-date\n    /// list can be found at the CBOR Tags registry maintained by the\n    /// Internet Assigned Numbers Authority(\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object where the object <paramref name='valueOb'/>\n    /// is converted to a CBOR object and given the tag <paramref\n    /// name='bigintTag'/>. If <paramref name='valueOb'/> is null, returns\n    /// a version of CBORObject.Null with the given tag.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigintTag'/> is less than 0 or greater than\n    /// 2^64-1.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigintTag'/> is null.</exception>\n    public static CBORObject FromObjectAndTag(\n      object valueOb,\n      EInteger bigintTag) {\n      if (bigintTag == null) {\n        throw new ArgumentNullException(nameof(bigintTag));\n      }\n      if (bigintTag.Sign < 0) {\n        throw new ArgumentException(\"tagEInt's sign(\" + bigintTag.Sign +\n          \") is less than 0\");\n      }\n      if (bigintTag.CompareTo(UInt64MaxValue) > 0) {\n        throw new ArgumentException(\n          \"tag more than 18446744073709551615 (\" + bigintTag + \")\");\n      }\n      return FromObject(valueOb).WithTag(bigintTag);\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary object and gives\n    /// the resulting object a tag in addition to its existing tags (the\n    /// new tag is made the outermost tag).</summary>\n    /// <param name='smallTag'>A 32-bit integer that specifies a tag\n    /// number. The tag number 55799 can be used to mark a \"self-described\n    /// CBOR\" object. This document does not attempt to list all CBOR tags\n    /// and their meanings. An up-to-date list can be found at the CBOR\n    /// Tags registry maintained by the Internet Assigned Numbers Authority\n    /// (\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object with the same value as this one but given\n    /// the tag <paramref name='smallTag'/> in addition to its existing\n    /// tags (the new tag is made the outermost tag).</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='smallTag'/> is less than 0.</exception>\n    public CBORObject WithTag(int smallTag) {\n      if (smallTag < 0) {\n        throw new ArgumentException(\"smallTag(\" + smallTag +\n          \") is less than 0\");\n      }\n      return new CBORObject(this, smallTag, 0);\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary object and gives\n    /// the resulting object a tag in addition to its existing tags (the\n    /// new tag is made the outermost tag).</summary>\n    /// <param name='valueObValue'>The parameter <paramref\n    /// name='valueObValue'/> is an arbitrary object, which can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='smallTag'>A 32-bit integer that specifies a tag\n    /// number. The tag number 55799 can be used to mark a \"self-described\n    /// CBOR\" object. This document does not attempt to list all CBOR tags\n    /// and their meanings. An up-to-date list can be found at the CBOR\n    /// Tags registry maintained by the Internet Assigned Numbers Authority\n    /// (\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object where the object <paramref\n    /// name='valueObValue'/> is converted to a CBOR object and given the\n    /// tag <paramref name='smallTag'/>. If \"valueOb\" is null, returns a\n    /// version of CBORObject.Null with the given tag.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='smallTag'/> is less than 0.</exception>\n    public static CBORObject FromObjectAndTag(\n      object valueObValue,\n      int smallTag) {\n      if (smallTag < 0) {\n        throw new ArgumentException(\"smallTag(\" + smallTag +\n          \") is less than 0\");\n      }\n      return FromObject(valueObValue).WithTag(smallTag);\n    }\n\n    /// <summary>Creates a CBOR object from a simple value\n    /// number.</summary>\n    /// <param name='simpleValue'>The parameter <paramref\n    /// name='simpleValue'/> is a 32-bit signed integer.</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='simpleValue'/> is less than 0, greater than 255, or from 24\n    /// through 31.</exception>\n    public static CBORObject FromSimpleValue(int simpleValue) {\n      if (simpleValue < 0) {\n        throw new ArgumentException(\"simpleValue(\" + simpleValue +\n          \") is less than 0\");\n      }\n      if (simpleValue > 255) {\n        throw new ArgumentException(\"simpleValue(\" + simpleValue +\n          \") is more than \" + \"255\");\n      }\n      if (simpleValue >= 24 && simpleValue < 32) {\n        throw new ArgumentException(\"Simple value is from 24 to 31: \" +\n          simpleValue);\n      }\n      if (simpleValue < 32) {\n        return FixedObjects[0xe0 + simpleValue];\n      }\n      return new CBORObject(\n          CBORObjectTypeSimpleValue,\n          simpleValue);\n    }\n\n    /// <summary>Multiplies two CBOR numbers.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The product of the two numbers.</returns>\n    /// <exception cref='ArgumentException'>Either or both operands are not\n    /// numbers (as opposed to Not-a-Number, NaN).</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n        \"\\u0020.AsNumber()), and use the first number's .Multiply() method.\")]\n    public static CBORObject Multiply(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Multiply(b).ToCBORObject();\n    }\n\n    /// <summary>Creates a new empty CBOR array.</summary>\n    /// <returns>A new CBOR array.</returns>\n    public static CBORObject NewArray() {\n      return new CBORObject(CBORObjectTypeArray, new List<CBORObject>());\n    }\n\n    internal static CBORObject NewArray(CBORObject o1, CBORObject o2) {\n      var list = new List<CBORObject>(2);\n      list.Add(o1);\n      list.Add(o2);\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    internal static CBORObject NewArray(\n      CBORObject o1,\n      CBORObject o2,\n      CBORObject o3) {\n      var list = new List<CBORObject>(2);\n      list.Add(o1);\n      list.Add(o2);\n      list.Add(o3);\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Creates a new empty CBOR map that stores its keys in an\n    /// undefined order.</summary>\n    /// <returns>A new CBOR map.</returns>\n    public static CBORObject NewMap() {\n      return new CBORObject(\n          CBORObjectTypeMap,\n          new SortedDictionary<CBORObject, CBORObject>());\n    }\n\n    /// <summary>Creates a new empty CBOR map that ensures that keys are\n    /// stored in the order in which they are first inserted.</summary>\n    /// <returns>A new CBOR map.</returns>\n    public static CBORObject NewOrderedMap() {\n      return new CBORObject(\n          CBORObjectTypeMap,\n          PropertyMap.NewOrderedDict());\n    }\n\n    /// <summary>\n    /// <para>Reads a sequence of objects in CBOR format from a data\n    /// stream. This method will read CBOR objects from the stream until\n    /// the end of the stream is reached or an error occurs, whichever\n    /// happens first.</para></summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <returns>An array containing the CBOR objects that were read from\n    /// the data stream. Returns an empty array if there is no unread data\n    /// in the stream.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null, or the parameter \"options\" is\n    /// null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data, including if the last CBOR object was\n    /// read only partially.</exception>\n    public static CBORObject[] ReadSequence(Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      var cborList = new List<CBORObject>();\n      while (true) {\n        CBORObject obj = Read(stream, AllowEmptyOptions);\n        if (obj == null) {\n          break;\n        }\n        cborList.Add(obj);\n      }\n      return (CBORObject[])cborList.ToArray();\n    }\n\n    /// <summary>\n    /// <para>Reads a sequence of objects in CBOR format from a data\n    /// stream. This method will read CBOR objects from the stream until\n    /// the end of the stream is reached or an error occurs, whichever\n    /// happens first.</para></summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <param name='options'>Specifies the options to use when decoding\n    /// the CBOR data stream. See CBOREncodeOptions for more information.\n    /// In this method, the AllowEmpty property is treated as set\n    /// regardless of the value of that property specified in this\n    /// parameter.</param>\n    /// <returns>An array containing the CBOR objects that were read from\n    /// the data stream. Returns an empty array if there is no unread data\n    /// in the stream.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null, or the parameter <paramref\n    /// name='options'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data, including if the last CBOR object was\n    /// read only partially.</exception>\n    public static CBORObject[] ReadSequence(Stream stream, CBOREncodeOptions\n      options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      CBOREncodeOptions opt = options;\n      if (!opt.AllowEmpty) {\n        opt = new CBOREncodeOptions(opt.ToString() + \";allowempty=1\");\n      }\n      var cborList = new List<CBORObject>();\n      while (true) {\n        CBORObject obj = Read(stream, opt);\n        if (obj == null) {\n          break;\n        }\n        cborList.Add(obj);\n      }\n      return (CBORObject[])cborList.ToArray();\n    }\n\n    /// <summary>\n    /// <para>Reads an object in CBOR format from a data stream. This\n    /// method will read from the stream until the end of the CBOR object\n    /// is reached or an error occurs, whichever happens\n    /// first.</para></summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <returns>A CBOR object that was read.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data.</exception>\n    public static CBORObject Read(Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      try {\n        var reader = new CBORReader(stream);\n        return reader.Read();\n      } catch (IOException ex) {\n        throw new CBORException(\"I/O error occurred.\", ex);\n      }\n    }\n\n    /// <summary>Reads an object in CBOR format from a data stream, using\n    /// the specified options to control the decoding process. This method\n    /// will read from the stream until the end of the CBOR object is\n    /// reached or an error occurs, whichever happens first.</summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <param name='options'>Specifies the options to use when decoding\n    /// the CBOR data stream. See CBOREncodeOptions for more\n    /// information.</param>\n    /// <returns>A CBOR object that was read.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data.</exception>\n    public static CBORObject Read(Stream stream, CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      try {\n        var reader = new CBORReader(stream, options);\n        return reader.Read();\n      } catch (IOException ex) {\n        throw new CBORException(\"I/O error occurred.\", ex);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a data stream in JavaScript\n    /// Object Notation (JSON) format. The JSON stream may begin with a\n    /// byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be\n    /// in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (In previous\n    /// versions, only UTF-8 was allowed.). (This behavior may change to\n    /// supporting only UTF-8, with or without a byte order mark, in\n    /// version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must contain a single JSON object and not\n    /// multiple objects.</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream\n    /// contains invalid encoding or is not in JSON format.</exception>\n    public static CBORObject ReadJSON(Stream stream) {\n      return ReadJSON(stream, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a list of CBOR objects from a data stream in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464).\n    /// The data stream must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must either be empty or begin with a\n    /// record separator byte (0x1e).</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream is not\n    /// empty and does not begin with a record separator byte\n    /// (0x1e).</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] ReadJSONSequence(Stream stream) {\n      return ReadJSONSequence(stream, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a data stream in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process. The JSON stream may begin with a\n    /// byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be\n    /// in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (In previous\n    /// versions, only UTF-8 was allowed.).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must contain a single JSON object and not\n    /// multiple objects.</param>\n    /// <param name='options'>Contains options to control the JSON decoding\n    /// process. This method uses only the AllowDuplicateKeys property of\n    /// this object.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream\n    /// contains invalid encoding or is not in JSON format.</exception>\n    [Obsolete(\"Instead, use .ReadJSON\\u0028stream, new\" +\n        \"\\u0020JSONOptions\\u0028\\\"allowduplicatekeys=true\\\")) or\" +\n        \"\\u0020.ReadJSON\\u0028stream, new\" +\n        \"\\u0020JSONOptions\\u0028\\\"allowduplicatekeys=false\\\")), as\" +\n        \"\\u0020appropriate.\")]\n    public static CBORObject ReadJSON(\n      Stream stream,\n      CBOREncodeOptions options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      var jsonoptions = new JSONOptions(options.AllowDuplicateKeys ?\n        \"allowduplicatekeys=1\" : \"allowduplicatekeys=0\");\n      return ReadJSON(stream, jsonoptions);\n    }\n\n    /// <summary>Generates a list of CBOR objects from a data stream in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464).\n    /// The data stream must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must either be empty or begin with a\n    /// record separator byte (0x1e).</param>\n    /// <param name='jsonoptions'>Specifies options to control how JSON\n    /// texts in the stream are decoded to CBOR. See the JSONOptions\n    /// class.</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream is not\n    /// empty and does not begin with a record separator byte\n    /// (0x1e).</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] ReadJSONSequence(Stream stream, JSONOptions\n      jsonoptions) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      CharacterInputWithCount reader;\n      reader = new CharacterInputWithCount(\n        new CharacterReader(stream, 0, true, true));\n      try {\n        var nextchar = new int[1];\n        CBORObject[] objlist = CBORJson.ParseJSONSequence(\n            reader,\n            jsonoptions,\n            nextchar);\n        if (nextchar[0] != -1) {\n          reader.RaiseError(\"End of data stream not reached\");\n        }\n        return objlist;\n      } catch (CBORException ex) {\n        var ioex = ex.InnerException as IOException;\n        if (ioex != null) {\n          throw ioex;\n        }\n        throw;\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a data stream in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process. The JSON stream may begin with a\n    /// byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be\n    /// in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (In previous\n    /// versions, only UTF-8 was allowed.). (This behavior may change to\n    /// supporting only UTF-8, with or without a byte order mark, in\n    /// version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must contain a single JSON object and not\n    /// multiple objects.</param>\n    /// <param name='jsonoptions'>Specifies options to control how the JSON\n    /// stream is decoded to CBOR. See the JSONOptions class.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream\n    /// contains invalid encoding or is not in JSON format.</exception>\n    public static CBORObject ReadJSON(\n      Stream stream,\n      JSONOptions jsonoptions) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      CharacterInputWithCount reader;\n      reader = new CharacterInputWithCount(\n        new CharacterReader(stream, 2, true));\n      try {\n        var nextchar = new int[1];\n        CBORObject obj = CBORJson.ParseJSONValue(\n            reader,\n            jsonoptions,\n            nextchar);\n        if (nextchar[0] != -1) {\n          reader.RaiseError(\"End of data stream not reached\");\n        }\n        return obj;\n      } catch (CBORException ex) {\n        var ioex = ex.InnerException as IOException;\n        if (ioex != null) {\n          throw ioex;\n        }\n        throw;\n      }\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array in JSON format. The entire byte\n    /// array must contain a single JSON object and not multiple objects.\n    /// The byte array may begin with a byte-order mark (U+FEFF). The byte\n    /// array can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is\n    /// detected by assuming that the first character read must be a\n    /// byte-order mark or a nonzero basic character (U+0001 to U+007F).\n    /// (This behavior may change to supporting only UTF-8, with or without\n    /// a byte order mark, in version 5.0 or later, perhaps with an option\n    /// to restore the previous behavior of also supporting UTF-16 and\n    /// UTF-32.).</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    public static CBORObject FromJSONBytes(byte[] bytes) {\n      // TODO: In next major version, consider supporting UTF-8 only\n      return FromJSONBytes(bytes, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array in JSON format. The entire byte\n    /// array must contain a single JSON object and not multiple objects.\n    /// The byte array may begin with a byte-order mark (U+FEFF). The byte\n    /// array can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is\n    /// detected by assuming that the first character read must be a\n    /// byte-order mark or a nonzero basic character (U+0001 to U+007F).\n    /// (This behavior may change to supporting only UTF-8, with or without\n    /// a byte order mark, in version 5.0 or later, perhaps with an option\n    /// to restore the previous behavior of also supporting UTF-16 and\n    /// UTF-32.).</param>\n    /// <param name='jsonoptions'>Specifies options to control how the JSON\n    /// data is decoded to CBOR. See the JSONOptions class.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> or <paramref name='jsonoptions'/> is\n    /// null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    public static CBORObject FromJSONBytes(\n      byte[] bytes,\n      JSONOptions jsonoptions) {\n      // TODO: In next major version, consider supporting UTF-8 only\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      if (bytes.Length == 0) {\n        throw new CBORException(\"Byte array is empty\");\n      }\n      return FromJSONBytes(bytes, 0, bytes.Length, jsonoptions);\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array, the specified portion of which is\n    /// in JSON format. The specified portion of the byte array must\n    /// contain a single JSON object and not multiple objects. The portion\n    /// may begin with a byte-order mark (U+FEFF). The portion can be in\n    /// UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (This behavior may\n    /// change to supporting only UTF-8, with or without a byte order mark,\n    /// in version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='bytes'/> begins.</param>\n    /// <param name='count'>The length, in bytes, of the desired portion of\n    /// <paramref name='bytes'/> (but not more than <paramref\n    /// name='bytes'/> 's length).</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='bytes'/> 's length, or <paramref\n    /// name='bytes'/> 's length minus <paramref name='offset'/> is less\n    /// than <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONBytes(byte[] bytes, int offset, int\n      count) {\n      return FromJSONBytes(bytes, offset, count, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array, the specified portion of which is\n    /// in JSON format. The specified portion of the byte array must\n    /// contain a single JSON object and not multiple objects. The portion\n    /// may begin with a byte-order mark (U+FEFF). The portion can be in\n    /// UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (This behavior may\n    /// change to supporting only UTF-8, with or without a byte order mark,\n    /// in version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='bytes'/> begins.</param>\n    /// <param name='count'>The length, in bytes, of the desired portion of\n    /// <paramref name='bytes'/> (but not more than <paramref\n    /// name='bytes'/> 's length).</param>\n    /// <param name='jsonoptions'>Specifies options to control how the JSON\n    /// data is decoded to CBOR. See the JSONOptions class.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> or <paramref name='jsonoptions'/> is\n    /// null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='bytes'/> 's length, or <paramref\n    /// name='bytes'/> 's length minus <paramref name='offset'/> is less\n    /// than <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONBytes(\n      byte[] bytes,\n      int offset,\n      int count,\n      JSONOptions jsonoptions) {\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (offset < 0) {\n        throw new ArgumentException(\"offset (\" + offset + \") is not greater\" +\n          \"\\u0020or equal to 0\");\n      }\n      if (offset > bytes.Length) {\n        throw new ArgumentException(\"offset (\" + offset + \") is not less or\" +\n          \"\\u0020equal to \" + bytes.Length);\n      }\n      if (count < 0) {\n        throw new ArgumentException(\"count (\" + count + \") is not greater or\" +\n          \"\\u0020equal to 0\");\n      }\n      if (count > bytes.Length) {\n        throw new ArgumentException(\"count (\" + count + \") is not less or\" +\n          \"\\u0020equal to \" + bytes.Length);\n      }\n      if (bytes.Length - offset < count) {\n        throw new ArgumentException(\"bytes's length minus \" + offset + \" (\" +\n          (bytes.Length - offset) + \") is not greater or equal to \" + count);\n      }\n      if (count == 0) {\n        throw new CBORException(\"Byte array is empty\");\n      }\n      if (bytes[offset] >= 0x01 && bytes[offset] <= 0x7f && count >= 2 &&\n        bytes[offset + 1] != 0) {\n        // UTF-8 JSON bytes\n        return CBORJson2.ParseJSONValue(\n            bytes,\n            offset,\n            offset + count,\n            jsonoptions);\n      } else {\n        // Other than UTF-8 without byte order mark\n        try {\n          using (var ms = new MemoryStream(bytes, offset, count)) {\n            return ReadJSON(ms, jsonoptions);\n          }\n        } catch (IOException ex) {\n          throw new CBORException(ex.Message, ex);\n        }\n      }\n    }\n\n    /// <summary>Finds the remainder that results when a CBORObject object\n    /// is divided by the value of a CBOR object.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The remainder of the two numbers.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n        \"\\u0020.AsNumber()), and use the first number's .Remainder() method.\")]\n    public static CBORObject Remainder(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Remainder(b).ToCBORObject();\n    }\n\n    /// <summary>Finds the difference between two CBOR number\n    /// objects.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The difference of the two objects.</returns>\n    /// <exception cref='ArgumentException'>Either or both operands are not\n    /// numbers (as opposed to Not-a-Number, NaN).</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n\n        \"\\u0020.AsNumber()), and use the first number's .Subtract() method.\")]\n    public static CBORObject Subtract(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Subtract(b).ToCBORObject();\n    }\n\n    /// <summary>\n    /// <para>Writes a text string in CBOR format to a data stream. The\n    /// string will be encoded using definite-length encoding regardless of\n    /// its length.</para></summary>\n    /// <param name='str'>The string to write. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(string str, Stream stream) {\n      Write(str, stream, CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes a text string in CBOR format to a data stream,\n    /// using the given options to control the encoding process.</summary>\n    /// <param name='str'>The string to write. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <param name='options'>Options for encoding the data to\n    /// CBOR.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(\n      string str,\n      Stream stream,\n      CBOREncodeOptions options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (str == null) {\n        stream.WriteByte(0xf6); // Write null instead of string\n      } else {\n        if (!options.UseIndefLengthStrings || options.Ctap2Canonical) {\n          // NOTE: Length of a String object won't be higher than the maximum\n          // allowed for definite-length strings\n          long codePointLength = DataUtilities.GetUtf8Length(str, true);\n          WritePositiveInt64(3, codePointLength, stream);\n          DataUtilities.WriteUtf8(str, stream, true);\n        } else {\n          WriteStreamedString(str, stream);\n        }\n      }\n    }\n\n    /// <summary>Writes a binary floating-point number in CBOR format to a\n    /// data stream, as though it were converted to a CBOR object via\n    /// CBORObject.FromObject(EFloat) and then written out.</summary>\n    /// <param name='bignum'>An arbitrary-precision binary floating-point\n    /// number. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(EFloat bignum, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (bignum == null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      if ((bignum.IsZero && bignum.IsNegative) || bignum.IsInfinity() ||\n        bignum.IsNaN()) {\n        Write(CBORObject.FromObject(bignum), stream);\n        return;\n      }\n      EInteger exponent = bignum.Exponent;\n      if (exponent.CanFitInInt64()) {\n        stream.WriteByte(0xc5); // tag 5\n        stream.WriteByte(0x82); // array, length 2\n      } else if (exponent.GetSignedBitLengthAsInt64() > 64) {\n        stream.WriteByte(0xd9); // tag 265\n        stream.WriteByte(0x01);\n        stream.WriteByte(0x09);\n        stream.WriteByte(0x82); // array, length 2\n      } else {\n        stream.WriteByte(0xc5); // tag 5\n        stream.WriteByte(0x82); // array, length 2\n      }\n      Write(\n        bignum.Exponent,\n        stream);\n      Write(bignum.Mantissa, stream);\n    }\n\n    /// <summary>Writes a rational number in CBOR format to a data stream,\n    /// as though it were converted to a CBOR object via\n    /// CBORObject.FromObject(ERational) and then written out.</summary>\n    /// <param name='rational'>An arbitrary-precision rational number. Can\n    /// be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(ERational rational, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (rational == null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      if (!rational.IsFinite || (rational.IsNegative && rational.IsZero)) {\n        Write(CBORObject.FromObject(rational), stream);\n        return;\n      }\n      stream.WriteByte(0xd8); // tag 30\n      stream.WriteByte(0x1e);\n      stream.WriteByte(0x82); // array, length 2\n      Write(rational.Numerator, stream);\n      Write(\n        rational.Denominator,\n        stream);\n    }\n\n    /// <summary>Writes a decimal floating-point number in CBOR format to a\n    /// data stream, as though it were converted to a CBOR object via\n    /// CBORObject.FromObject(EDecimal) and then written out.</summary>\n    /// <param name='bignum'>The arbitrary-precision decimal number to\n    /// write. Can be null.</param>\n    /// <param name='stream'>Stream to write to.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(EDecimal bignum, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (bignum == null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      if (!bignum.IsFinite || (bignum.IsNegative && bignum.IsZero)) {\n        Write(CBORObject.FromObject(bignum), stream);\n        return;\n      }\n      EInteger exponent = bignum.Exponent;\n      if (exponent.CanFitInInt64()) {\n        stream.WriteByte(0xc4); // tag 4\n        stream.WriteByte(0x82); // array, length 2\n      } else if (exponent.GetSignedBitLengthAsInt64() > 64) {\n        stream.WriteByte(0xd9); // tag 264\n        stream.WriteByte(0x01);\n        stream.WriteByte(0x08);\n        stream.WriteByte(0x82); // array, length 2\n      } else {\n        stream.WriteByte(0xc4); // tag 4\n        stream.WriteByte(0x82); // array, length 2\n      }\n      Write(exponent, stream);\n      Write(bignum.Mantissa, stream);\n    }\n\n    private static byte[] EIntegerBytes(EInteger ei) {\n      if (ei.IsZero) {\n        return new byte[] { 0 };\n      }\n      if (ei.Sign < 0) {\n        ei = ei.Add(1).Negate();\n      }\n      byte[] bytes = ei.ToBytes(false);\n      var index = 0;\n      while (index < bytes.Length && bytes[index] == 0) {\n        ++index;\n      }\n      if (index > 0) {\n        var newBytes = new byte[bytes.Length - index];\n        Array.Copy(bytes, index, newBytes, 0, newBytes.Length);\n        return newBytes;\n      }\n      return bytes;\n    }\n\n    /// <summary>Writes a arbitrary-precision integer in CBOR format to a\n    /// data stream.</summary>\n    /// <param name='bigint'>Arbitrary-precision integer to write. Can be\n    /// null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(EInteger bigint, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if ((object)bigint == (object)null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      var datatype = 0;\n      if (bigint.Sign < 0) {\n        datatype = 1;\n        bigint = bigint.Add(EInteger.One);\n        bigint = -(EInteger)bigint;\n      }\n      if (bigint.CanFitInInt64()) {\n        // If the arbitrary-precision integer is representable as a long and in\n        // major type 0 or 1, write that major type\n        // instead of as a bignum\n        WritePositiveInt64(datatype, bigint.ToInt64Checked(), stream);\n      } else {\n        // Get a byte array of the arbitrary-precision integer's value,\n        // since shifting and doing AND operations is\n        // slow with large EIntegers\n        byte[] bytes = bigint.ToBytes(true);\n        int byteCount = bytes.Length;\n        while (byteCount > 0 && bytes[byteCount - 1] == 0) {\n          // Ignore trailing zero bytes\n          --byteCount;\n        }\n        if (byteCount != 0) {\n          int half = byteCount >> 1;\n          int right = byteCount - 1;\n          for (var i = 0; i < half; ++i, --right) {\n            byte value = bytes[i];\n            bytes[i] = bytes[right];\n            bytes[right] = value;\n          }\n        }\n        switch (byteCount) {\n          case 0:\n            stream.WriteByte((byte)(datatype << 5));\n            return;\n          case 1:\n            WritePositiveInt(datatype, ((int)bytes[0]) & 0xff, stream);\n            break;\n          case 2:\n            stream.WriteByte((byte)((datatype << 5) | 25));\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 3:\n            stream.WriteByte((byte)((datatype << 5) | 26));\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 4:\n            stream.WriteByte((byte)((datatype << 5) | 26));\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 5:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.WriteByte((byte)0);\n            stream.WriteByte((byte)0);\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 6:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.WriteByte((byte)0);\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 7:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 8:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.Write(bytes, 0, byteCount);\n            break;\n          default: stream.WriteByte((datatype == 0) ?\n              (byte)0xc2 : (byte)0xc3);\n            WritePositiveInt(2, byteCount, stream);\n            stream.Write(bytes, 0, byteCount);\n            break;\n        }\n      }\n    }\n\n    /// <summary>Writes a 64-bit signed integer in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(long value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (value >= 0) {\n        WritePositiveInt64(0, value, stream);\n      } else {\n        ++value;\n        value = -value; // Will never overflow\n        WritePositiveInt64(1, value, stream);\n      }\n    }\n\n    /// <summary>Writes a 32-bit signed integer in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(int value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      var type = 0;\n      if (value < 0) {\n        ++value;\n        value = -value;\n        type = 0x20;\n      }\n      if (value < 24) {\n        stream.WriteByte((byte)(value | type));\n      } else if (value <= 0xff) {\n        byte[] bytes = { (byte)(24 | type), (byte)(value & 0xff) };\n        stream.Write(bytes, 0, 2);\n      } else if (value <= 0xffff) {\n        byte[] bytes = {\n          (byte)(25 | type), (byte)((value >> 8) & 0xff),\n          (byte)(value & 0xff),\n        };\n        stream.Write(bytes, 0, 3);\n      } else {\n        byte[] bytes = {\n          (byte)(26 | type), (byte)((value >> 24) & 0xff),\n          (byte)((value >> 16) & 0xff), (byte)((value >> 8) & 0xff),\n          (byte)(value & 0xff),\n        };\n        stream.Write(bytes, 0, 5);\n      }\n    }\n\n    /// <summary>Writes a 16-bit signed integer in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(short value, Stream stream) {\n      Write((long)value, stream);\n    }\n\n    /// <summary>Writes a Boolean value in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(bool value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      stream.WriteByte(value ? (byte)0xf5 : (byte)0xf4);\n    }\n\n    /// <summary>Writes a byte (0 to 255) in CBOR format to a data stream.\n    /// If the value is less than 24, writes that byte. If the value is 25\n    /// to 255, writes the byte 24, then this byte's value.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(byte value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if ((((int)value) & 0xff) < 24) {\n        stream.WriteByte(value);\n      } else {\n        stream.WriteByte((byte)24);\n        stream.WriteByte(value);\n      }\n    }\n\n    /// <summary>Writes a 32-bit floating-point number in CBOR format to a\n    /// data stream. The number is written using the shortest\n    /// floating-point encoding possible; this is a change from previous\n    /// versions.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(float value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      WriteFloatingPointBits(\n        stream,\n        CBORUtilities.SingleToInt32Bits(value),\n        4,\n        true);\n    }\n\n    /// <summary>Writes a 64-bit floating-point number in CBOR format to a\n    /// data stream. The number is written using the shortest\n    /// floating-point encoding possible; this is a change from previous\n    /// versions.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(double value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      WriteFloatingPointBits(\n        stream,\n        CBORUtilities.DoubleToInt64Bits(value),\n        8,\n        true);\n    }\n\n    /// <summary>Writes a CBOR object to a CBOR data stream.</summary>\n    /// <param name='value'>The value to write. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    public static void Write(CBORObject value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (value == null) {\n        stream.WriteByte(0xf6);\n      } else {\n        value.WriteTo(stream);\n      }\n    }\n\n    /// <summary>\n    /// <para>Writes a CBOR object to a CBOR data stream. See the\n    /// three-parameter Write method that takes a\n    /// CBOREncodeOptions.</para></summary>\n    /// <param name='objValue'>The arbitrary object to be serialized. Can\n    /// be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    public static void Write(object objValue, Stream stream) {\n      Write(objValue, stream, CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes an arbitrary object to a CBOR data stream, using\n    /// the specified options for controlling how the object is encoded to\n    /// CBOR data format. If the object is convertible to a CBOR map or a\n    /// CBOR object that contains CBOR maps, the order in which the keys to\n    /// those maps are written out to the data stream is undefined unless\n    /// the map was created using the NewOrderedMap method. The example\n    /// code given in\n    /// <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can\n    /// be used to write out certain keys of a CBOR map in a given order.\n    /// Currently, the following objects are supported:\n    /// <list type=''>\n    /// <item>Lists of CBORObject.</item>\n    /// <item>Maps of CBORObject. The order in which the keys to the map\n    /// are written out to the data stream is undefined unless the map was\n    /// created using the NewOrderedMap method.</item>\n    /// <item>Null.</item>\n    /// <item>Byte arrays, which will always be written as definite-length\n    /// byte strings.</item>\n    /// <item>String objects. The strings will be encoded using\n    /// definite-length encoding regardless of their length.</item>\n    /// <item>Any object accepted by the FromObject static\n    /// methods.</item></list></summary>\n    /// <param name='objValue'>The arbitrary object to be serialized. Can\n    /// be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='output'>A writable data stream.</param>\n    /// <param name='options'>CBOR options for encoding the CBOR object to\n    /// bytes.</param>\n    /// <exception cref='ArgumentException'>The object's type is not\n    /// supported.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> or <paramref name='output'/> is null.</exception>\n    public static void Write(\n      object objValue,\n      Stream output,\n      CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (output == null) {\n        throw new ArgumentNullException(nameof(output));\n      }\n      if (objValue == null) {\n        output.WriteByte(0xf6);\n        return;\n      }\n      if (options.Ctap2Canonical) {\n        FromObject(objValue).WriteTo(output, options);\n        return;\n      }\n      byte[] data = objValue as byte[];\n      if (data != null) {\n        WritePositiveInt(3, data.Length, output);\n        output.Write(data, 0, data.Length);\n        return;\n      }\n      if (objValue is IList<CBORObject>) {\n        WriteObjectArray(\n          (IList<CBORObject>)objValue,\n          output,\n          options);\n        return;\n      }\n      if (objValue is IDictionary<CBORObject, CBORObject>) {\n        WriteObjectMap(\n          (IDictionary<CBORObject, CBORObject>)objValue,\n          output,\n          options);\n        return;\n      }\n      FromObject(objValue).WriteTo(output, options);\n    }\n\n    /// <summary>Converts an arbitrary object to a text string in\n    /// JavaScript Object Notation (JSON) format, as in the ToJSONString\n    /// method, and writes that string to a data stream in UTF-8. If the\n    /// object is convertible to a CBOR map, or to a CBOR object that\n    /// contains CBOR maps, the order in which the keys to those maps are\n    /// written out to the JSON string is undefined unless the map was\n    /// created using the NewOrderedMap method. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object. Can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static void WriteJSON(object obj, Stream outputStream) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (obj == null) {\n        outputStream.Write(ValueNullBytes, 0, ValueNullBytes.Length);\n        return;\n      }\n      if (obj is bool) {\n        if ((bool)obj) {\n          outputStream.Write(ValueTrueBytes, 0, ValueTrueBytes.Length);\n          return;\n        }\n        outputStream.Write(ValueFalseBytes, 0, ValueFalseBytes.Length);\n        return;\n      }\n      CBORObject.FromObject(obj).WriteJSONTo(outputStream);\n    }\n\n    /// <summary>Gets this object's absolute value.</summary>\n    /// <returns>This object's absolute without its negative\n    /// sign.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    [Obsolete(\"Instead, convert this object to a number \\u0028with\" +\n        \"\\u0020.AsNumber\\u0028)), and use that number's .Abs\\u0028) method.\")]\n    public CBORObject Abs() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"This object is not a number.\");\n      }\n      object oldItem = cn.GetValue();\n      object newItem = cn.GetNumberInterface().Abs(oldItem);\n      if (oldItem == newItem) {\n        return this;\n      }\n      if (newItem is EDecimal) {\n        return CBORObject.FromObject((EDecimal)newItem);\n      }\n      if (newItem is EInteger) {\n        return CBORObject.FromObject((EInteger)newItem);\n      }\n      if (newItem is EFloat) {\n        return CBORObject.FromObject((EFloat)newItem);\n      }\n      var rat = newItem as ERational;\n      return (rat != null) ? CBORObject.FromObject(rat) : ((oldItem ==\n            newItem) ? this : CBORObject.FromObject(newItem));\n    }\n\n    /// <summary>\n    /// <para>Adds a new key and its value to this CBOR map, or adds the\n    /// value if the key doesn't exist.</para>\n    /// <para>NOTE: This method can't be used to add a tag to an existing\n    /// CBOR object. To create a CBOR object with a given tag, call the\n    /// <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object\n    /// and the desired tag number to that method.</para></summary>\n    /// <param name='key'>An object representing the key, which will be\n    /// converted to a CBORObject. Can be null, in which case this value is\n    /// converted to CBORObject.Null.</param>\n    /// <param name='valueOb'>An object representing the value, which will\n    /// be converted to a CBORObject. Can be null, in which case this value\n    /// is converted to CBORObject.Null.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='key'/> already exists in this map.</exception>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='key'/> or <paramref name='valueOb'/> has an unsupported\n    /// type.</exception>\n    public CBORObject Add(object key, object valueOb) {\n      if (this.Type == CBORType.Map) {\n        CBORObject mapKey;\n        CBORObject mapValue;\n        if (key == null) {\n          mapKey = CBORObject.Null;\n        } else {\n          mapKey = key as CBORObject;\n          mapKey = mapKey ?? CBORObject.FromObject(key);\n        }\n        if (valueOb == null) {\n          mapValue = CBORObject.Null;\n        } else {\n          mapValue = valueOb as CBORObject;\n          mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n        }\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        if (map.ContainsKey(mapKey)) {\n          throw new ArgumentException(\"Key already exists\");\n        }\n        map.Add(\n          mapKey,\n          mapValue);\n      } else {\n        throw new InvalidOperationException(\"Not a map\");\n      }\n      return this;\n    }\n\n    /// <summary><para>Adds a new object to the end of this array. (Used to\n    /// throw ArgumentNullException on a null reference, but now converts\n    /// the null reference to CBORObject.Null, for convenience with the\n    /// Object overload of this method).</para>\n    ///  <para>NOTE: This method\n    /// can't be used to add a tag to an existing CBOR object. To create a\n    /// CBOR object with a given tag, call the\n    /// <c>CBORObject.FromObjectAndTag</c>\n    ///  method and pass the CBOR object\n    /// and the desired tag number to that method.</para>\n    ///  </summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is a CBOR\n    /// object.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not an\n    /// array.</exception>\n    /// <example>\n    /// <para>The following example creates a CBOR array and adds several\n    /// CBOR objects, one of which has a custom CBOR tag, to that array.\n    /// Note the chaining behavior made possible by this method.</para>\n    /// <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False)\n    /// .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject(\"text\n    /// string\")) .Add(CBORObject.FromObjectAndTag(9999, 1));</code>\n    ///  .\n    /// </example>\n    public CBORObject Add(CBORObject obj) {\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        list.Add(obj);\n        return this;\n      }\n      throw new InvalidOperationException(\"Not an array\");\n    }\n\n    /// <summary><para>Converts an object to a CBOR object and adds it to\n    /// the end of this array.</para>\n    ///  <para>NOTE: This method can't be used\n    /// to add a tag to an existing CBOR object. To create a CBOR object\n    /// with a given tag, call the <c>CBORObject.FromObjectAndTag</c>\n    /// method and pass the CBOR object and the desired tag number to that\n    /// method.</para>\n    ///  </summary>\n    /// <param name='obj'>A CBOR object (or an object convertible to a CBOR\n    /// object) to add to this CBOR array.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This instance is not an\n    /// array.</exception>\n    /// <exception cref='ArgumentException'>The type of <paramref\n    /// name='obj'/> is not supported.</exception>\n    /// <example>\n    /// <para>The following example creates a CBOR array and adds several\n    /// CBOR objects, one of which has a custom CBOR tag, to that array.\n    /// Note the chaining behavior made possible by this method.</para>\n    /// <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5)\n    /// .Add(\"text string\") .Add(CBORObject.FromObjectAndTag(9999, 1));</code>\n    ///  .\n    /// </example>\n    public CBORObject Add(object obj) {\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        list.Add(CBORObject.FromObject(obj));\n        return this;\n      }\n      throw new InvalidOperationException(\"Not an array\");\n    }\n\n    /// <summary>Converts this object to an arbitrary-precision integer.\n    /// See the ToObject overload taking a type for more\n    /// information.</summary>\n    /// <returns>The closest arbitrary-precision integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value is infinity\n    /// or not-a-number (NaN).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<PeterO.Numbers.EInteger>\\u0028) in\" +\n        \"\\u0020.NET\" +\n        \" or \\u0020.ToObject\\u0028com.upokecenter.numbers.EInteger.class) in\" +\n        \"\\u0020Java.\")]\n    public EInteger AsEInteger() {\n      return (EInteger)this.ToObject(typeof(EInteger));\n    }\n\n    /// <summary>Returns false if this object is a CBOR false, null, or\n    /// undefined value (whether or not the object has tags); otherwise,\n    /// true.</summary>\n    /// <returns>False if this object is a CBOR false, null, or undefined\n    /// value; otherwise, true.</returns>\n    public bool AsBoolean() {\n      return !this.IsFalse && !this.IsNull && !this.IsUndefined;\n    }\n\n    /// <summary>Converts this object to a byte (0 to 255). Floating point\n    /// values are converted to integers by discarding their fractional\n    /// parts.</summary>\n    /// <returns>The closest byte-sized integer to this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a byte (would be less than 0 or greater than 255 when\n    /// converted to an integer by discarding its fractional\n    /// part).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<byte>\\u0028) in\" +\n        \"\\u0020.NET\" + \" or \\u0020.ToObject\\u0028Byte.class) in\" +\n        \"\\u0020Java.\")]\n    public byte AsByte() {\n      return (byte)this.AsInt32(0, 255);\n    }\n\n    internal byte AsByteLegacy() {\n      return (byte)this.AsInt32(0, 255);\n    }\n\n    /// <summary>Converts this object to a 64-bit floating point\n    /// number.</summary>\n    /// <returns>The closest 64-bit floating point number to this object.\n    /// The return value can be positive infinity or negative infinity if\n    /// this value exceeds the range of a 64-bit floating point\n    /// number.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    public double AsDouble() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"Not a number type\");\n      }\n      return cn.GetNumberInterface().AsDouble(cn.GetValue());\n    }\n\n    /// <summary>Converts this object to a decimal number.</summary>\n    /// <returns>A decimal number for this object's value.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<PeterO.Numbers.EDecimal>\\u0028) in\" +\n\n        \"\\u0020.NET\" +\n        \" or \\u0020.ToObject\\u0028com.upokecenter.numbers.EDecimal.class) in\" +\n        \"\\u0020Java.\")]\n    public EDecimal AsEDecimal() {\n      return (EDecimal)this.ToObject(typeof(EDecimal));\n    }\n\n    /// <summary>Converts this object to an arbitrary-precision binary\n    /// floating point number. See the ToObject overload taking a type for\n    /// more information.</summary>\n    /// <returns>An arbitrary-precision binary floating-point number for\n    /// this object's value.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    [Obsolete(\"Instead, use \" +\n        \".ToObject<PeterO.Numbers.EFloat>\\u0028) in .NET\" +\n\n        \" or \\u0020.ToObject\\u0028com.upokecenter.numbers.EFloat.class) in\" +\n        \"\\u0020Java.\")]\n    public EFloat AsEFloat() {\n      return (EFloat)this.ToObject(typeof(EFloat));\n    }\n\n    /// <summary>Converts this object to a rational number. See the\n    /// ToObject overload taking a type for more information.</summary>\n    /// <returns>A rational number for this object's value.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<PeterO.Numbers.ERational>\" +\n        \"\\u0028) in .NET\" +\n        \"\\u0020or .ToObject\\u0028com.upokecenter.numbers.ERational.class) in\" +\n        \"\\u0020Java.\")]\n    public ERational AsERational() {\n      return (ERational)this.ToObject(typeof(ERational));\n    }\n\n    /// <summary>Converts this object to a 16-bit signed integer. Floating\n    /// point values are converted to integers by discarding their\n    /// fractional parts.</summary>\n    /// <returns>The closest 16-bit signed integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 16-bit signed integer.</exception>\n    [Obsolete(\"Instead, use the following:\" +\n        \"\\u0020\\u0028cbor.AsNumber().ToInt16Checked()), or\" +\n        \"\\u0020.ToObject<short>() in\" + \"\\u0020.NET.\")]\n    public short AsInt16() {\n      return (short)this.AsInt32(Int16.MinValue, Int16.MaxValue);\n    }\n\n    /// <summary>Converts this object to a 32-bit signed integer if this\n    /// CBOR object's type is Integer. This method disregards the tags this\n    /// object has, if any.</summary>\n    /// <returns>The 32-bit signed integer stored by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.Integer</c>\n    /// .</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 32-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 32-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt32(99999);\n    /// if (obj.CanValueFitInInt32()) { /* Not an Int32;\n    /// handle the error */ Console.WriteLine(\"Not a 32-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt32Value()); }</code>\n    ///  .\n    /// </example>\n    public int AsInt32Value() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger: {\n          var longValue = (long)this.ThisItem;\n          if (longValue < Int32.MinValue || longValue > Int32.MaxValue) {\n            throw new OverflowException();\n          }\n          return checked((int)longValue);\n        }\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.ToInt32Checked();\n        }\n        default: throw new InvalidOperationException(\"Not an integer type\");\n      }\n    }\n\n    /// <summary>Converts this object to a 64-bit signed integer if this\n    /// CBOR object's type is Integer. This method disregards the tags this\n    /// object has, if any.</summary>\n    /// <returns>The 64-bit signed integer stored by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.Integer</c>\n    /// .</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 64-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 64-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt64(99999);\n    /// if (obj.CanValueFitInInt64()) {\n    /// &#x2f;&#x2a; Not an Int64; handle the error&#x2a;&#x2f;\n    /// Console.WriteLine(\"Not a 64-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt64Value()); }</code>\n    ///  .\n    /// </example>\n    public long AsInt64Value() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger:\n          return (long)this.ThisItem;\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.ToInt64Checked();\n        }\n        default: throw new InvalidOperationException(\"Not an integer type\");\n      }\n    }\n\n    /// <summary>Returns whether this CBOR object stores an integer\n    /// (CBORType.Integer) within the range of a 64-bit signed integer.\n    /// This method disregards the tags this object has, if any.</summary>\n    /// <returns><c>true</c> if this CBOR object stores an integer\n    /// (CBORType.Integer) whose value is at least -(2^63) and less than\n    /// 2^63; otherwise, <c>false</c>.</returns>\n    public bool CanValueFitInInt64() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger:\n          return true;\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.CanFitInInt64();\n        }\n        default: return false;\n      }\n    }\n\n    /// <summary>Returns whether this CBOR object stores an integer\n    /// (CBORType.Integer) within the range of a 32-bit signed integer.\n    /// This method disregards the tags this object has, if any.</summary>\n    /// <returns><c>true</c> if this CBOR object stores an integer\n    /// (CBORType.Integer) whose value is at least -(2^31) and less than\n    /// 2^31; otherwise, <c>false</c>.</returns>\n    public bool CanValueFitInInt32() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger: {\n          var elong = (long)this.ThisItem;\n          return elong >= Int32.MinValue && elong <= Int32.MaxValue;\n        }\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.CanFitInInt32();\n        }\n        default:\n          return false;\n      }\n    }\n\n    /// <summary>Converts this object to an arbitrary-precision integer if\n    /// this CBOR object's type is Integer. This method disregards the tags\n    /// this object has, if any. (Note that CBOR stores untagged integers\n    /// at least -(2^64) and less than 2^64.).</summary>\n    /// <returns>The integer stored by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.Integer</c>.</exception>\n    public EInteger AsEIntegerValue() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger:\n          return EInteger.FromInt64((long)this.ThisItem);\n        case CBORObjectTypeEInteger:\n          return (EInteger)this.ThisItem;\n        default: throw new InvalidOperationException(\"Not an integer type\");\n      }\n    }\n\n    /// <summary>Converts this object to the bits of a 64-bit\n    /// floating-point number if this CBOR object's type is FloatingPoint.\n    /// This method disregards the tags this object has, if any.</summary>\n    /// <returns>The bits of a 64-bit floating-point number stored by this\n    /// object. The most significant bit is the sign (set means negative,\n    /// clear means nonnegative); the next most significant 11 bits are the\n    /// exponent area; and the remaining bits are the significand area. If\n    /// all the bits of the exponent area are set and the significand area\n    /// is 0, this indicates infinity. If all the bits of the exponent area\n    /// are set and the significand area is other than 0, this indicates\n    /// not-a-number (NaN).</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.FloatingPoint</c>.</exception>\n    public long AsDoubleBits() {\n      switch (this.Type) {\n        case CBORType.FloatingPoint:\n          return (long)this.ThisItem;\n        default: throw new InvalidOperationException(\"Not a floating-point\" +\n            \"\\u0020type\");\n      }\n    }\n\n    /// <summary>Converts this object to a 64-bit floating-point number if\n    /// this CBOR object's type is FloatingPoint. This method disregards\n    /// the tags this object has, if any.</summary>\n    /// <returns>The 64-bit floating-point number stored by this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.FloatingPoint</c>.</exception>\n    public double AsDoubleValue() {\n      switch (this.Type) {\n        case CBORType.FloatingPoint:\n          return CBORUtilities.Int64BitsToDouble((long)this.ThisItem);\n        default: throw new InvalidOperationException(\"Not a floating-point\" +\n            \"\\u0020type\");\n      }\n    }\n\n    /// <summary>Converts this object to a CBOR number. (NOTE: To determine\n    /// whether this method call can succeed, call the <b>IsNumber</b>\n    /// property (isNumber() method in Java) before calling this\n    /// method.).</summary>\n    /// <returns>The number represented by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    public CBORNumber AsNumber() {\n      CBORNumber num = CBORNumber.FromCBORObject(this);\n      if (num == null) {\n        throw new InvalidOperationException(\"Not a number type\");\n      }\n      return num;\n    }\n\n    /// <summary>Converts this object to a 32-bit signed integer.\n    /// Non-integer number values are converted to integers by discarding\n    /// their fractional parts. (NOTE: To determine whether this method\n    /// call can succeed, call <b>AsNumber().CanTruncatedIntFitInInt32</b>\n    /// before calling this method. See the example.).</summary>\n    /// <returns>The closest 32-bit signed integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 32-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 32-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt32(99999);\n    /// if (obj.AsNumber().CanTruncatedIntFitInInt32()) {\n    /// &#x2f;&#x2a; Not an Int32; handle the error &#x2a;&#x2f;\n    /// Console.WriteLine(\"Not a 32-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt32()); }</code>\n    ///  .\n    /// </example>\n    public int AsInt32() {\n      return this.AsInt32(Int32.MinValue, Int32.MaxValue);\n    }\n\n    /// <summary>Converts this object to a 64-bit signed integer.\n    /// Non-integer numbers are converted to integers by discarding their\n    /// fractional parts. (NOTE: To determine whether this method call can\n    /// succeed, call <b>AsNumber().CanTruncatedIntFitInInt64</b>\n    ///  before\n    /// calling this method. See the example.).</summary>\n    /// <returns>The closest 64-bit signed integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 64-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 64-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt64(99999);\n    /// if (obj.IsIntegral &amp;&amp; obj.AsNumber().CanFitInInt64()) {\n    /// &#x2f;&#x2a; Not an Int64; handle the error &#x2a;&#x2f;\n    /// Console.WriteLine(\"Not a 64-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt64()); }</code>\n    ///  .\n    /// </example>\n    [Obsolete(\"Instead, use the following:\" +\n        \"\\u0020\\u0028cbor.AsNumber().ToInt64Checked()), or .ToObject<long>()\" +\n        \"\\u0020in .NET.\")]\n    public long AsInt64() {\n      CBORNumber cn = this.AsNumber();\n      return cn.GetNumberInterface().AsInt64(cn.GetValue());\n    }\n\n    /// <summary>Converts this object to a 32-bit floating point\n    /// number.</summary>\n    /// <returns>The closest 32-bit floating point number to this object.\n    /// The return value can be positive infinity or negative infinity if\n    /// this object's value exceeds the range of a 32-bit floating point\n    /// number.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    public float AsSingle() {\n      CBORNumber cn = this.AsNumber();\n      return cn.GetNumberInterface().AsSingle(cn.GetValue());\n    }\n\n    /// <summary>Gets the value of this object as a text string.</summary>\n    /// <returns>Gets this object's string.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not a text string (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers). To check the CBOR object for null before\n    /// conversion, use the following idiom (originally written in C# for\n    /// the.NET version): <c>(cbor == null || cbor.IsNull) ? null :\n    /// cbor.AsString()</c>.</exception>\n    /// <remarks>This method is not the \"reverse\" of the <c>FromObject</c>\n    /// method in the sense that FromObject can take either a text string\n    /// or <c>null</c>, but this method can accept only text strings. The\n    /// <c>ToObject</c> method is closer to a \"reverse\" version to\n    /// <c>FromObject</c> than the <c>AsString</c> method:\n    /// <c>ToObject&lt;String&gt;(cbor)</c> in DotNet, or\n    /// <c>ToObject(String.class)</c> in Java, will convert a CBOR object\n    /// to a DotNet or Java String if it represents a text string, or to\n    /// <c>null</c> if <c>IsNull</c> returns <c>true</c> for the CBOR\n    /// object, and will fail in other cases.</remarks>\n    public string AsString() {\n      int type = this.ItemType;\n      switch (type) {\n        case CBORObjectTypeTextString:\n        case CBORObjectTypeTextStringAscii: {\n          return (string)this.ThisItem;\n        }\n        case CBORObjectTypeTextStringUtf8: {\n          return DataUtilities.GetUtf8String((byte[])this.ThisItem, false);\n        }\n        default:\n          throw new InvalidOperationException(\"Not a text string type\");\n      }\n    }\n\n    /// <summary>Returns whether this object's value can be converted to a\n    /// 64-bit floating point number without its value being rounded to\n    /// another numerical value.</summary>\n    /// <returns><c>true</c> if this object's value can be converted to a\n    /// 64-bit floating point number without its value being rounded to\n    /// another numerical value, or if this is a not-a-number value, even\n    /// if the value's diagnostic information can't fit in a 64-bit\n    /// floating point number; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanFitInDouble()).\")]\n    public bool CanFitInDouble() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanFitInDouble(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's numerical value is an\n    /// integer, is -(2^31) or greater, and is less than 2^31.</summary>\n    /// <returns><c>true</c> if this object's numerical value is an\n    /// integer, is -(2^31) or greater, and is less than 2^31; otherwise,\n    /// <c>false</c>.</returns>\n    [Obsolete(\"Instead, use \" +\n        \".CanValueFitInInt32(), if the application allows\" +\n\n        \"\\u0020only CBOR integers, or \\u0028cbor.IsNumber &&\" +\n        \"cbor.AsNumber().CanFitInInt32()),\" +\n        \"\\u0020 if the application allows any CBOR object convertible to an \" +\n        \"integer.\")]\n    public bool CanFitInInt32() {\n      if (!this.CanFitInInt64()) {\n        return false;\n      }\n      long v = this.AsInt64();\n      return v >= Int32.MinValue && v <= Int32.MaxValue;\n    }\n\n    /// <summary>Returns whether this object's numerical value is an\n    /// integer, is -(2^63) or greater, and is less than 2^63.</summary>\n    /// <returns><c>true</c> if this object's numerical value is an\n    /// integer, is -(2^63) or greater, and is less than 2^63; otherwise,\n    /// <c>false</c>.</returns>\n    [Obsolete(\"Instead, use \" +\n        \"CanValueFitInInt64(), if the application allows\" +\n\n        \"\\u0020only CBOR integers, or \\u0028cbor.IsNumber &&\" +\n        \"cbor.AsNumber().CanFitInInt64()),\" +\n        \"\\u0020 if the application allows any CBOR object convertible to an \" +\n        \"integer.\")]\n    public bool CanFitInInt64() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanFitInInt64(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's value can be converted to a\n    /// 32-bit floating point number without its value being rounded to\n    /// another numerical value.</summary>\n    /// <returns><c>true</c> if this object's value can be converted to a\n    /// 32-bit floating point number without its value being rounded to\n    /// another numerical value, or if this is a not-a-number value, even\n    /// if the value's diagnostic information can' t fit in a 32-bit\n    /// floating point number; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanFitInSingle()).\")]\n    public bool CanFitInSingle() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanFitInSingle(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^31) or\n    /// greater, and less than 2^31.</summary>\n    /// <returns><c>true</c> if this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^31) or\n    /// greater, and less than 2^31; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.CanValueFitInInt32()\" +\n        \"\\u0020if only integers of any tag are allowed, or\" +\n        \"\\u0020\\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanTruncatedIntFitInInt32()).\")]\n    public bool CanTruncatedIntFitInInt32() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanTruncatedIntFitInInt32(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^63) or\n    /// greater, and less than 2^63.</summary>\n    /// <returns><c>true</c> if this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^63) or\n    /// greater, and less than 2^63; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.CanValueFitInInt64()\" +\n        \"\\u0020if only integers of any tag are allowed, or\" +\n        \"\\u0020\\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanTruncatedIntFitInInt64()).\")]\n    public bool CanTruncatedIntFitInInt64() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return cn != null &&\n        cn.GetNumberInterface().CanTruncatedIntFitInInt64(cn.GetValue());\n    }\n\n    private static string Chop(string str) {\n      return str.Substring(0, Math.Min(100, str.Length));\n    }\n\n    /// <summary>Compares two CBOR objects. This implementation was changed\n    /// in version 4.0.\n    /// <para>In this implementation:</para>\n    /// <list type=''>\n    /// <item>The null pointer (null reference) is considered less than any\n    /// other object.</item>\n    /// <item>If the two objects are both integers (CBORType.Integer) both\n    /// floating-point values, both byte strings, both simple values\n    /// (including True and False), or both text strings, their CBOR\n    /// encodings (as though EncodeToBytes were called on each integer) are\n    /// compared as though by a byte-by-byte comparison. (This means, for\n    /// example, that positive integers sort before negative\n    /// integers).</item>\n    /// <item>If both objects have a tag, they are compared first by the\n    /// tag's value then by the associated item (which itself can have a\n    /// tag).</item>\n    /// <item>If both objects are arrays, they are compared item by item.\n    /// In this case, if the arrays have different numbers of items, the\n    /// array with more items is treated as greater than the other\n    /// array.</item>\n    /// <item>If both objects are maps, their key-value pairs, sorted by\n    /// key in accordance with this method, are compared, where each pair\n    /// is compared first by key and then by value. In this case, if the\n    /// maps have different numbers of key-value pairs, the map with more\n    /// pairs is treated as greater than the other map.</item>\n    /// <item>If the two objects have different types, the object whose\n    /// type comes first in the order of untagged integers, untagged byte\n    /// strings, untagged text strings, untagged arrays, untagged maps,\n    /// tagged objects, untagged simple values (including True and False)\n    /// and untagged floating point values sorts before the other\n    /// object.</item></list>\n    /// <para>This method is consistent with the Equals\n    /// method.</para></summary>\n    /// <param name='other'>A value to compare with.</param>\n    /// <returns>A negative number, if this value is less than the other\n    /// object; or 0, if both values are equal; or a positive number, if\n    /// this value is less than the other object or if the other object is\n    /// null.\n    /// <para>This implementation returns a positive number if <paramref\n    /// name='other'/> is null, to conform to the.NET definition of\n    /// CompareTo. This is the case even in the Java version of this\n    /// library, for consistency's sake, even though implementations of\n    /// <c>Comparable.compareTo()</c> in Java ought to throw an exception\n    /// if they receive a null argument rather than treating null as less\n    /// or greater than any object.</para>.</returns>\n    public int CompareTo(CBORObject other) {\n      if (other == null) {\n        return 1;\n      }\n      if (this == other) {\n        return 0;\n      }\n      int typeA = this.itemtypeValue;\n      int typeB = other.itemtypeValue;\n      object objA = this.itemValue;\n      object objB = other.itemValue;\n      // DebugUtility.Log(\"typeA=\" + typeA);\n      // DebugUtility.Log(\"typeB=\" + typeB);\n      // DebugUtility.Log(\"objA=\" + Chop(this.ItemType ==\n      // CBORObjectTypeMap ? \"(map)\" :\n      // this.ToString()));\n      // DebugUtility.Log(\"objB=\" + Chop(other.ItemType ==\n      // CBORObjectTypeMap ? \"(map)\" :\n      // other.ToString()));\n      int cmp;\n      if (typeA == typeB) {\n        switch (typeA) {\n          case CBORObjectTypeInteger: {\n            var a = (long)objA;\n            var b = (long)objB;\n            if (a >= 0 && b >= 0) {\n              cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);\n            } else if (a <= 0 && b <= 0) {\n              cmp = (a == b) ? 0 : ((a < b) ? 1 : -1);\n            } else if (a < 0 && b >= 0) {\n              // NOTE: Negative integers sort after\n              // nonnegative integers in the bytewise\n              // ordering of CBOR encodings\n              cmp = 1;\n            } else {\n              #if DEBUG\n              if (!(a >= 0 && b < 0)) {\n                throw new InvalidOperationException(\n                  \"doesn't satisfy a>= 0\" +\n                  \"\\u0020b<0\");\n              }\n              #endif\n              cmp = -1;\n            }\n            break;\n          }\n          case CBORObjectTypeEInteger: {\n            cmp = CBORUtilities.ByteArrayCompare(\n                this.EncodeToBytes(),\n                other.EncodeToBytes());\n            break;\n          }\n          case CBORObjectTypeByteString:\n          case CBORObjectTypeTextStringUtf8: {\n            cmp = CBORUtilities.ByteArrayCompareLengthFirst((byte[])objA,\n                (byte[])objB);\n            break;\n          }\n          case CBORObjectTypeTextStringAscii: {\n            var strA = (string)objA;\n            var strB = (string)objB;\n            int alen = strA.Length;\n            int blen = strB.Length;\n            cmp = (alen < blen) ? (-1) : ((alen > blen) ? 1 :\nString.CompareOrdinal(strA, strB));\n            break;\n          }\n          case CBORObjectTypeTextString: {\n            var strA = (string)objA;\n            var strB = (string)objB;\n            cmp = CBORUtilities.CompareStringsAsUtf8LengthFirst(\n                strA,\n                strB);\n            break;\n          }\n          case CBORObjectTypeArray: {\n            cmp = ListCompare(\n                (List<CBORObject>)objA,\n                (List<CBORObject>)objB);\n            break;\n          }\n          case CBORObjectTypeMap:\n            cmp = MapCompare(\n                (IDictionary<CBORObject, CBORObject>)objA,\n                (IDictionary<CBORObject, CBORObject>)objB);\n            break;\n          case CBORObjectTypeTagged:\n            cmp = this.MostOuterTag.CompareTo(other.MostOuterTag);\n            if (cmp == 0) {\n              cmp = ((CBORObject)objA).CompareTo((CBORObject)objB);\n            }\n            break;\n          case CBORObjectTypeSimpleValue: {\n            var valueA = (int)objA;\n            var valueB = (int)objB;\n            cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);\n            break;\n          }\n          case CBORObjectTypeDouble: {\n            cmp = CBORUtilities.ByteArrayCompare(\n                GetDoubleBytes(this.AsDoubleBits(), 0),\n                GetDoubleBytes(other.AsDoubleBits(), 0));\n            break;\n          }\n          default: throw new InvalidOperationException(\"Unexpected data \" +\n              \"type\");\n        }\n      } else if ((typeB == CBORObjectTypeInteger && typeA ==\n          CBORObjectTypeEInteger) || (typeA == CBORObjectTypeInteger && typeB ==\n          CBORObjectTypeEInteger)) {\n        cmp = CBORUtilities.ByteArrayCompare(\n            this.EncodeToBytes(),\n            other.EncodeToBytes());\n      } else if ((typeB == CBORObjectTypeTextString || typeB ==\nCBORObjectTypeTextStringAscii) && typeA ==\n        CBORObjectTypeTextStringUtf8) {\n        cmp = -CBORUtilities.CompareUtf16Utf8LengthFirst(\n            (string)objB,\n            (byte[])objA);\n      } else if ((typeA == CBORObjectTypeTextString || typeA ==\nCBORObjectTypeTextStringAscii) && typeB ==\n        CBORObjectTypeTextStringUtf8) {\n        cmp = CBORUtilities.CompareUtf16Utf8LengthFirst(\n            (string)objA,\n            (byte[])objB);\n      } else if ((typeA == CBORObjectTypeTextString && typeB ==\nCBORObjectTypeTextStringAscii) ||\n         (typeB == CBORObjectTypeTextString && typeA ==\nCBORObjectTypeTextStringAscii)) {\n        cmp = -CBORUtilities.CompareStringsAsUtf8LengthFirst(\n            (string)objB,\n            (string)objA);\n      } else if ((typeA == CBORObjectTypeTextString || typeA ==\nCBORObjectTypeTextStringAscii) && typeB ==\n        CBORObjectTypeTextStringUtf8) {\n        cmp = CBORUtilities.CompareUtf16Utf8LengthFirst(\n            (string)objA,\n            (byte[])objB);\n      } else {\n        int ta = (typeA == CBORObjectTypeTextStringUtf8 || typeA ==\nCBORObjectTypeTextStringAscii) ?\n          CBORObjectTypeTextString : typeA;\n        int tb = (typeB == CBORObjectTypeTextStringUtf8 || typeB ==\nCBORObjectTypeTextStringAscii) ?\n          CBORObjectTypeTextString : typeB;\n        /* NOTE: itemtypeValue numbers are ordered such that they\n        // correspond to the lexicographical order of their CBOR encodings\n        // (with the exception of Integer and EInteger together,\n        // and TextString/TextStringUtf8) */\n        cmp = (ta < tb) ? -1 : 1;\n      }\n      // DebugUtility.Log(\" -> \" + (cmp));\n      return cmp;\n    }\n\n    /// <summary>Compares this object and another CBOR object, ignoring the\n    /// tags they have, if any. See the CompareTo method for more\n    /// information on the comparison function.</summary>\n    /// <param name='other'>A value to compare with.</param>\n    /// <returns>Less than 0, if this value is less than the other object;\n    /// or 0, if both values are equal; or greater than 0, if this value is\n    /// less than the other object or if the other object is\n    /// null.</returns>\n    public int CompareToIgnoreTags(CBORObject other) {\n      return (other == null) ? 1 : ((this == other) ? 0 :\n          this.Untag().CompareTo(other.Untag()));\n    }\n\n    /// <summary>Determines whether a value of the given key exists in this\n    /// object.</summary>\n    /// <param name='objKey'>The parameter <paramref name='objKey'/> is an\n    /// arbitrary object.</param>\n    /// <returns><c>true</c> if the given key is found, or <c>false</c> if\n    /// the given key is not found or this object is not a map.</returns>\n    public bool ContainsKey(object objKey) {\n      return (this.Type == CBORType.Map) ?\n        this.ContainsKey(CBORObject.FromObject(objKey)) : false;\n    }\n\n    /// <summary>Determines whether a value of the given key exists in this\n    /// object.</summary>\n    /// <param name='key'>An object that serves as the key. If this is\n    /// <c>null</c>, checks for <c>CBORObject.Null</c>.</param>\n    /// <returns><c>true</c> if the given key is found, or <c>false</c> if\n    /// the given key is not found or this object is not a map.</returns>\n    public bool ContainsKey(CBORObject key) {\n      key = key ?? CBORObject.Null;\n      if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        return map.ContainsKey(key);\n      }\n      return false;\n    }\n\n    /// <summary>Determines whether a value of the given key exists in this\n    /// object.</summary>\n    /// <param name='key'>A text string that serves as the key. If this is\n    /// <c>null</c>, checks for <c>CBORObject.Null</c>.</param>\n    /// <returns><c>true</c> if the given key (as a CBOR object) is found,\n    /// or <c>false</c> if the given key is not found or this object is not\n    /// a map.</returns>\n    public bool ContainsKey(string key) {\n      if (this.Type == CBORType.Map) {\n        CBORObject ckey = key == null ? CBORObject.Null :\n          CBORObject.FromObject(key);\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        return map.ContainsKey(ckey);\n      }\n      return false;\n    }\n\n    private static byte[] GetDoubleBytes64(long valueBits, int tagbyte) {\n      // Encode as double precision\n      return tagbyte != 0 ? new[] {\n        (byte)tagbyte, (byte)0xfb,\n        (byte)((valueBits >> 56) & 0xff), (byte)((valueBits >> 48) & 0xff),\n        (byte)((valueBits >> 40) & 0xff), (byte)((valueBits >> 32) & 0xff),\n        (byte)((valueBits >> 24) & 0xff), (byte)((valueBits >> 16) & 0xff),\n        (byte)((valueBits >> 8) & 0xff), (byte)(valueBits & 0xff),\n      } : new[] {\n   (byte)0xfb, (byte)((valueBits >> 56) & 0xff),\n   (byte)((valueBits >> 48) & 0xff), (byte)((valueBits >> 40) & 0xff),\n   (byte)((valueBits >> 32) & 0xff), (byte)((valueBits >> 24) & 0xff),\n   (byte)((valueBits >> 16) & 0xff), (byte)((valueBits >> 8) & 0xff),\n   (byte)(valueBits & 0xff),\n };\n    }\n\n    private static byte[] GetDoubleBytes(long valueBits, int tagbyte) {\n      int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);\n      if (bits != -1) {\n        return tagbyte != 0 ? new[] {\n          (byte)tagbyte, (byte)0xf9,\n          (byte)((bits >> 8) & 0xff), (byte)(bits & 0xff),\n        } : new[] {\n   (byte)0xf9, (byte)((bits >> 8) & 0xff),\n   (byte)(bits & 0xff),\n };\n      }\n      if (CBORUtilities.DoubleRetainsSameValueInSingle(valueBits)) {\n        bits = CBORUtilities.DoubleToRoundedSinglePrecision(valueBits);\n        return tagbyte != 0 ? new[] {\n          (byte)tagbyte, (byte)0xfa,\n          (byte)((bits >> 24) & 0xff), (byte)((bits >> 16) & 0xff),\n          (byte)((bits >> 8) & 0xff), (byte)(bits & 0xff),\n        } : new[] {\n   (byte)0xfa, (byte)((bits >> 24) & 0xff),\n   (byte)((bits >> 16) & 0xff), (byte)((bits >> 8) & 0xff),\n   (byte)(bits & 0xff),\n };\n      }\n      return GetDoubleBytes64(valueBits, tagbyte);\n    }\n\n    /// <summary>\n    /// <para>Writes the binary representation of this CBOR object and\n    /// returns a byte array of that representation. If the CBOR object\n    /// contains CBOR maps, or is a CBOR map itself, the order in which the\n    /// keys to the map are written out to the byte array is undefined\n    /// unless the map was created using the NewOrderedMap method. The\n    /// example code given in\n    /// <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can\n    /// be used to write out certain keys of a CBOR map in a given order.\n    /// For the CTAP2 (FIDO Client-to-Authenticator Protocol 2) canonical\n    /// ordering, which is useful for implementing Web Authentication, call\n    /// <c>EncodeToBytes(new CBOREncodeOptions(\"ctap2canonical=true\"))</c>\n    /// rather than this method.</para></summary>\n    /// <returns>A byte array in CBOR format.</returns>\n    public byte[] EncodeToBytes() {\n      return this.EncodeToBytes(CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes the binary representation of this CBOR object and\n    /// returns a byte array of that representation, using the specified\n    /// options for encoding the object to CBOR format. For the CTAP2 (FIDO\n    /// Client-to-Authenticator Protocol 2) canonical ordering, which is\n    /// useful for implementing Web Authentication, call this method as\n    /// follows: <c>EncodeToBytes(new\n    /// CBOREncodeOptions(\"ctap2canonical=true\"))</c>.</summary>\n    /// <param name='options'>Options for encoding the data to\n    /// CBOR.</param>\n    /// <returns>A byte array in CBOR format.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    public byte[] EncodeToBytes(CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (options.Ctap2Canonical) {\n        return CBORCanonical.CtapCanonicalEncode(this);\n      }\n      // For some types, a memory stream is a lot of\n      // overhead since the amount of memory the types\n      // use is fixed and small\n      var hasComplexTag = false;\n      byte tagbyte = 0;\n      bool tagged = this.IsTagged;\n      if (this.IsTagged) {\n        var taggedItem = (CBORObject)this.itemValue;\n        if (taggedItem.IsTagged || this.tagHigh != 0 ||\n          (this.tagLow >> 16) != 0 || this.tagLow >= 24) {\n          hasComplexTag = true;\n        } else {\n          tagbyte = (byte)(0xc0 + (int)this.tagLow);\n        }\n      }\n      if (!hasComplexTag) {\n        switch (this.ItemType) {\n          case CBORObjectTypeTextString:\n          case CBORObjectTypeTextStringAscii: {\n            byte[] ret = GetOptimizedBytesIfShortAscii(\n                this.AsString(), tagged ? (((int)tagbyte) & 0xff) : -1);\n            if (ret != null) {\n              return ret;\n            }\n            break;\n          }\n          case CBORObjectTypeTextStringUtf8: {\n            if (!tagged && !options.UseIndefLengthStrings) {\n              byte[] bytes = (byte[])this.ThisItem;\n              return SerializeUtf8(bytes);\n            }\n            break;\n          }\n          case CBORObjectTypeSimpleValue: {\n            if (tagged) {\n              var simpleBytes = new byte[] { tagbyte, (byte)0xf4 };\n              if (this.IsFalse) {\n                simpleBytes[1] = (byte)0xf4;\n                return simpleBytes;\n              }\n              if (this.IsTrue) {\n                simpleBytes[1] = (byte)0xf5;\n                return simpleBytes;\n              }\n              if (this.IsNull) {\n                simpleBytes[1] = (byte)0xf6;\n                return simpleBytes;\n              }\n              if (this.IsUndefined) {\n                simpleBytes[1] = (byte)0xf7;\n                return simpleBytes;\n              }\n            } else {\n              if (this.IsFalse) {\n                return new[] { (byte)0xf4 };\n              }\n              if (this.IsTrue) {\n                return new[] { (byte)0xf5 };\n              }\n              if (this.IsNull) {\n                return new[] { (byte)0xf6 };\n              }\n              if (this.IsUndefined) {\n                return new[] { (byte)0xf7 };\n              }\n            }\n            break;\n          }\n          case CBORObjectTypeInteger: {\n            var value = (long)this.ThisItem;\n            byte[] intBytes = null;\n            if (value >= 0) {\n              intBytes = GetPositiveInt64Bytes(0, value);\n            } else {\n              ++value;\n              value = -value; // Will never overflow\n              intBytes = GetPositiveInt64Bytes(1, value);\n            }\n            if (!tagged) {\n              return intBytes;\n            }\n            var ret2 = new byte[intBytes.Length + 1];\n            Array.Copy(intBytes, 0, ret2, 1, intBytes.Length);\n            ret2[0] = tagbyte;\n            return ret2;\n          }\n          case CBORObjectTypeDouble: {\n            if (options.Float64) {\n            return GetDoubleBytes64(\n                this.AsDoubleBits(),\n                ((int)tagbyte) & 0xff);\n            } else {\n            return GetDoubleBytes(\n                this.AsDoubleBits(),\n                ((int)tagbyte) & 0xff);\n            }\n          }\n        }\n      }\n      try {\n        using (var ms = new MemoryStream(16)) {\n          this.WriteTo(ms, options);\n          return ms.ToArray();\n        }\n      } catch (IOException ex) {\n        throw new CBORException(\"I/O Error occurred\", ex);\n      }\n    }\n\n    /// <summary>Gets the CBOR object referred to by a JSON Pointer\n    /// according to RFC6901. For more information, see the overload taking\n    /// a default value parameter.</summary>\n    /// <param name='pointer'>A JSON pointer according to RFC 6901.</param>\n    /// <returns>An object within this CBOR object. Returns this object if\n    /// pointer is the empty string (even if this object has a CBOR type\n    /// other than array or map).</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>Thrown if the pointer\n    /// is null, or if the pointer is invalid, or if there is no object at\n    /// the given pointer, or the special key \"-\" appears in the pointer in\n    /// the context of an array (not a map), or if the pointer is non-empty\n    /// and this object has a CBOR type other than array or\n    /// map.</exception>\n    public CBORObject AtJSONPointer(string pointer) {\n      CBORObject ret = this.AtJSONPointer(pointer, null);\n      if (ret == null) {\n         throw new CBORException(\"Invalid JSON pointer\");\n      }\n      return ret;\n    }\n\n    /// <summary>Gets the CBOR object referred to by a JSON Pointer\n    /// according to RFC6901, or a default value if the operation fails.\n    /// The syntax for a JSON Pointer is:\n    /// <pre>'/' KEY '/' KEY [...]</pre> where KEY represents a key into\n    /// the JSON object or its sub-objects in the hierarchy. For example,\n    /// <pre>/foo/2/bar</pre> means the same as\n    /// <pre>obj['foo'][2]['bar']</pre> in JavaScript. If \"~\" and/or \"/\"\n    /// occurs in a key, it must be escaped with \"~0\" or \"~1\",\n    /// respectively, in a JSON pointer. JSON pointers also support the\n    /// special key \"-\" (as in \"/foo/-\") to indicate the end of an array,\n    /// but this method treats this key as an error since it refers to a\n    /// nonexistent item. Indices to arrays (such as 2 in the example) must\n    /// contain only basic digits 0 to 9 and no leading zeros. (Note that\n    /// RFC 6901 was published before JSON was extended to support\n    /// top-level values other than arrays and key-value\n    /// dictionaries.).</summary>\n    /// <param name='pointer'>A JSON pointer according to RFC 6901.</param>\n    /// <param name='defaultValue'>The parameter <paramref\n    /// name='defaultValue'/> is a Cbor.CBORObject object.</param>\n    /// <returns>An object within the specified JSON object. Returns this\n    /// object if pointer is the empty string (even if this object has a\n    /// CBOR type other than array or map). Returns <paramref\n    /// name='defaultValue'/> if the pointer is null, or if the pointer is\n    /// invalid, or if there is no object at the given pointer, or the\n    /// special key \"-\" appears in the pointer in the context of an array\n    /// (not a map), or if the pointer is non-empty and this object has a\n    /// CBOR type other than array or map.</returns>\n    public CBORObject AtJSONPointer(string pointer, CBORObject defaultValue) {\n      return JSONPointer.GetObject(this, pointer, null);\n    }\n\n  /// <summary>Returns a copy of this object after applying the\n  /// operations in a JSON patch, in the form of a CBOR object. JSON\n  /// patches are specified in RFC 6902 and their format is summarized in\n  /// the remarks below.</summary>\n  /// <param name='patch'>A JSON patch in the form of a CBOR object; it\n  /// has the form summarized in the remarks.</param>\n  /// <returns>The result of the patch operation.</returns>\n  /// <exception cref='PeterO.Cbor.CBORException'>The parameter <paramref\n  /// name='patch'/> is null or the patch operation failed.</exception>\n  /// <remarks><b>Remarks:</b> A JSON patch is an array with one or more\n  /// maps. Each map has the following keys:\n  /// <list>\n  /// <item>\"op\" - Required. This key's value is the patch operation and\n  /// must be \"add\", \"remove\", \"move\", \"copy\", \"test\", or \"replace\", in\n  /// basic lower case letters and no other case combination.</item>\n  /// <item>\"value\" - Required if the operation is \"add\", \"replace\", or\n  /// \"test\" and specifies the item to add (insert), or that will replace\n  /// the existing item, or to check an existing item for equality,\n  /// respectively. (For \"test\", the operation fails if the existing item\n  /// doesn't match the specified value.)</item>\n  /// <item>\"path\" - Required for all operations. A JSON Pointer (RFC\n  /// 6901) specifying the destination path in the CBOR object for the\n  /// operation. For more information, see RFC 6901 or the documentation\n  /// for AtJSONPointer(pointer, defaultValue).</item>\n  /// <item>\"from\" - Required if the operation is \"move\" or \"copy\". A\n  /// JSON Pointer (RFC 6901) specifying the path in the CBOR object\n  /// where the source value is located.</item></list></remarks>\n    public CBORObject ApplyJSONPatch(CBORObject patch) {\n      return JSONPatch.Patch(this, patch);\n    }\n\n    /// <summary>Determines whether this object and another object are\n    /// equal and have the same type. Not-a-number values can be considered\n    /// equal by this method.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object.</param>\n    /// <returns><c>true</c> if the objects are equal; otherwise,\n    /// <c>false</c>. In this method, two objects are not equal if they\n    /// don't have the same type or if one is null and the other\n    /// isn't.</returns>\n    public override bool Equals(object obj) {\n      return this.Equals(obj as CBORObject);\n    }\n\n    /// <summary>Compares the equality of two CBOR objects. Not-a-number\n    /// values can be considered equal by this method.</summary>\n    /// <param name='other'>The object to compare.</param>\n    /// <returns><c>true</c> if the objects are equal; otherwise,\n    /// <c>false</c>. In this method, two objects are not equal if they\n    /// don't have the same type or if one is null and the other\n    /// isn't.</returns>\n    public bool Equals(CBORObject other) {\n      var otherValue = other as CBORObject;\n      if (otherValue == null) {\n        return false;\n      }\n      if (this == otherValue) {\n        return true;\n      }\n      if ((this.itemtypeValue == CBORObjectTypeTextString ||\nthis.itemtypeValue == CBORObjectTypeTextStringAscii) &&\n        otherValue.itemtypeValue == CBORObjectTypeTextStringUtf8) {\n        return CBORUtilities.StringEqualsUtf8(\n            (string)this.itemValue,\n            (byte[])otherValue.itemValue);\n      }\n      if ((otherValue.itemtypeValue == CBORObjectTypeTextString ||\notherValue.itemtypeValue == CBORObjectTypeTextStringAscii) &&\n        this.itemtypeValue == CBORObjectTypeTextStringUtf8) {\n        return CBORUtilities.StringEqualsUtf8(\n            (string)otherValue.itemValue,\n            (byte[])this.itemValue);\n      }\n      if ((otherValue.itemtypeValue == CBORObjectTypeTextString &&\nthis.itemtypeValue == CBORObjectTypeTextStringAscii) || (this.itemtypeValue\n== CBORObjectTypeTextString && otherValue.itemtypeValue ==\nCBORObjectTypeTextStringAscii)) {\n        return Object.Equals(this.itemValue, otherValue.itemValue);\n      }\n      if (this.itemtypeValue != otherValue.itemtypeValue) {\n        return false;\n      }\n      switch (this.itemtypeValue) {\n        case CBORObjectTypeByteString:\n        case CBORObjectTypeTextStringUtf8:\n          return CBORUtilities.ByteArrayEquals(\n              (byte[])this.itemValue,\n              otherValue.itemValue as byte[]);\n        case CBORObjectTypeMap: {\n          IDictionary<CBORObject, CBORObject> cbordict =\n            otherValue.itemValue as IDictionary<CBORObject, CBORObject>;\n          return CBORMapEquals(this.AsMap(), cbordict);\n        }\n        case CBORObjectTypeArray:\n          return CBORArrayEquals(\n              this.AsList(),\n              otherValue.itemValue as IList<CBORObject>);\n        case CBORObjectTypeTagged:\n          return this.tagLow == otherValue.tagLow &&\n            this.tagHigh == otherValue.tagHigh &&\n            Object.Equals(this.itemValue, otherValue.itemValue);\n        case CBORObjectTypeDouble:\n          return this.AsDoubleBits() == otherValue.AsDoubleBits();\n        default: return Object.Equals(this.itemValue, otherValue.itemValue);\n      }\n    }\n\n    /// <summary>Gets the backing byte array used in this CBOR object, if\n    /// this object is a byte string, without copying the data to a new\n    /// byte array. Any changes in the returned array's contents will be\n    /// reflected in this CBOR object. Note, though, that the array's\n    /// length can't be changed.</summary>\n    /// <returns>The byte array held by this CBOR object.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// byte string.</exception>\n    public byte[] GetByteString() {\n      if (this.ItemType == CBORObjectTypeByteString) {\n        return (byte[])this.ThisItem;\n      }\n      throw new InvalidOperationException(\"Not a byte string\");\n    }\n\n    /// <summary>Calculates the hash code of this object. The hash code for\n    /// a given instance of this class is not guaranteed to be the same\n    /// across versions of this class, and no application or process IDs\n    /// are used in the hash code calculation.</summary>\n    /// <returns>A 32-bit hash code.</returns>\n    public override int GetHashCode() {\n      var hashCode = 651869431;\n      unchecked {\n        if (this.itemValue != null) {\n          var itemHashCode = 0;\n          long longValue = 0L;\n          switch (this.itemtypeValue) {\n            case CBORObjectTypeByteString:\n              itemHashCode =\n                CBORUtilities.ByteArrayHashCode(this.GetByteString());\n              break;\n            case CBORObjectTypeTextStringUtf8:\n              itemHashCode = CBORUtilities.Utf8HashCode(\n                  (byte[])this.itemValue);\n              break;\n            case CBORObjectTypeMap:\n              itemHashCode = CBORMapHashCode(this.AsMap());\n              break;\n            case CBORObjectTypeArray:\n              itemHashCode = CBORArrayHashCode(this.AsList());\n              break;\n            case CBORObjectTypeTextString:\n            case CBORObjectTypeTextStringAscii:\n              itemHashCode = CBORUtilities.StringHashCode(\n                  (string)this.itemValue);\n              break;\n            case CBORObjectTypeSimpleValue:\n              itemHashCode = (int)this.itemValue;\n              break;\n            case CBORObjectTypeDouble:\n              longValue = this.AsDoubleBits();\n              longValue |= longValue >> 32;\n              itemHashCode = unchecked((int)longValue);\n              break;\n            case CBORObjectTypeInteger:\n              longValue = (long)this.itemValue;\n              longValue |= longValue >> 32;\n              itemHashCode = unchecked((int)longValue);\n              break;\n            case CBORObjectTypeTagged:\n              itemHashCode = unchecked(this.tagLow + this.tagHigh);\n              itemHashCode += 651869483 * this.itemValue.GetHashCode();\n              break;\n            default:\n              // EInteger, CBORObject\n              itemHashCode = this.itemValue.GetHashCode();\n              break;\n          }\n          hashCode += 651869479 * itemHashCode;\n        }\n      }\n      return hashCode;\n    }\n\n    /// <summary>Gets a list of all tags, from outermost to\n    /// innermost.</summary>\n    /// <returns>An array of tags, or the empty string if this object is\n    /// untagged.</returns>\n    public EInteger[] GetAllTags() {\n      if (!this.IsTagged) {\n        return ValueEmptyTags;\n      }\n      CBORObject curitem = this;\n      if (curitem.IsTagged) {\n        var list = new List<EInteger>();\n        while (curitem.IsTagged) {\n          list.Add(\n            LowHighToEInteger(\n              curitem.tagLow,\n              curitem.tagHigh));\n          curitem = (CBORObject)curitem.itemValue;\n        }\n        return (EInteger[])list.ToArray();\n      }\n      return new[] { LowHighToEInteger(this.tagLow, this.tagHigh) };\n    }\n\n    /// <summary>Returns whether this object has only one tag.</summary>\n    /// <returns><c>true</c> if this object has only one tag; otherwise,\n    /// <c>false</c>.</returns>\n    public bool HasOneTag() {\n      return this.IsTagged && !((CBORObject)this.itemValue).IsTagged;\n    }\n\n    /// <summary>Returns whether this object has only one tag and that tag\n    /// is the given number.</summary>\n    /// <param name='tagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has only one tag and that tag\n    /// is the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    public bool HasOneTag(int tagValue) {\n      return this.HasOneTag() && this.HasMostOuterTag(tagValue);\n    }\n\n    /// <summary>Returns whether this object has only one tag and that tag\n    /// is the given number, expressed as an arbitrary-precision\n    /// integer.</summary>\n    /// <param name='bigTagValue'>An arbitrary-precision integer.</param>\n    /// <returns><c>true</c> if this object has only one tag and that tag\n    /// is the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasOneTag(EInteger bigTagValue) {\n      return this.HasOneTag() && this.HasMostOuterTag(bigTagValue);\n    }\n\n    /// <summary>Gets the number of tags this object has.</summary>\n    /// <value>The number of tags this object has.</value>\n    public int TagCount {\n      get {\n        var count = 0;\n        CBORObject curitem = this;\n        while (curitem.IsTagged) {\n          count = checked(count + 1);\n          curitem = (CBORObject)curitem.itemValue;\n        }\n        return count;\n      }\n    }\n\n    /// <summary>Returns whether this object has an innermost tag and that\n    /// tag is of the given number.</summary>\n    /// <param name='tagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an innermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    public bool HasMostInnerTag(int tagValue) {\n      if (tagValue < 0) {\n        throw new ArgumentException(\"tagValue(\" + tagValue +\n          \") is less than 0\");\n      }\n      return this.IsTagged && this.HasMostInnerTag(\n          EInteger.FromInt32(tagValue));\n    }\n\n    /// <summary>Returns whether this object has an innermost tag and that\n    /// tag is of the given number, expressed as an arbitrary-precision\n    /// number.</summary>\n    /// <param name='bigTagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an innermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasMostInnerTag(EInteger bigTagValue) {\n      if (bigTagValue == null) {\n        throw new ArgumentNullException(nameof(bigTagValue));\n      }\n      if (bigTagValue.Sign < 0) {\n        throw new ArgumentException(\"bigTagValue(\" + bigTagValue +\n          \") is less than 0\");\n      }\n      return (!this.IsTagged) ? false : this.MostInnerTag.Equals(bigTagValue);\n    }\n\n    /// <summary>Returns whether this object has an outermost tag and that\n    /// tag is of the given number.</summary>\n    /// <param name='tagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an outermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    public bool HasMostOuterTag(int tagValue) {\n      if (tagValue < 0) {\n        throw new ArgumentException(\"tagValue(\" + tagValue +\n          \") is less than 0\");\n      }\n      return this.IsTagged && this.tagHigh == 0 && this.tagLow == tagValue;\n    }\n\n    /// <summary>Returns whether this object has an outermost tag and that\n    /// tag is of the given number.</summary>\n    /// <param name='bigTagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an outermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasMostOuterTag(EInteger bigTagValue) {\n      if (bigTagValue == null) {\n        throw new ArgumentNullException(nameof(bigTagValue));\n      }\n      if (bigTagValue.Sign < 0) {\n        throw new ArgumentException(\"bigTagValue(\" + bigTagValue +\n          \") is less than 0\");\n      }\n      return (!this.IsTagged) ? false : this.MostOuterTag.Equals(bigTagValue);\n    }\n\n    /// <summary>Returns whether this object has a tag of the given\n    /// number.</summary>\n    /// <param name='tagValue'>The tag value to search for.</param>\n    /// <returns><c>true</c> if this object has a tag of the given number;\n    /// otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='tagValue'/> is null.</exception>\n    public bool HasTag(int tagValue) {\n      if (tagValue < 0) {\n        throw new ArgumentException(\"tagValue(\" + tagValue +\n          \") is less than 0\");\n      }\n      CBORObject obj = this;\n      while (true) {\n        if (!obj.IsTagged) {\n          return false;\n        }\n        if (obj.tagHigh == 0 && tagValue == obj.tagLow) {\n          return true;\n        }\n        obj = (CBORObject)obj.itemValue;\n        #if DEBUG\n        if (obj == null) {\n          throw new ArgumentNullException(nameof(tagValue));\n        }\n        #endif\n      }\n    }\n\n    /// <summary>Returns whether this object has a tag of the given\n    /// number.</summary>\n    /// <param name='bigTagValue'>The tag value to search for.</param>\n    /// <returns><c>true</c> if this object has a tag of the given number;\n    /// otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasTag(EInteger bigTagValue) {\n      if (bigTagValue == null) {\n        throw new ArgumentNullException(nameof(bigTagValue));\n      }\n      if (bigTagValue.Sign < 0) {\n        throw new ArgumentException(\"doesn't satisfy bigTagValue.Sign>= 0\");\n      }\n      EInteger[] bigTags = this.GetAllTags();\n      foreach (EInteger bigTag in bigTags) {\n        if (bigTagValue.Equals(bigTag)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /// <summary>Inserts an object at the specified position in this CBOR\n    /// array.</summary>\n    /// <param name='index'>Index starting at 0 to insert at.</param>\n    /// <param name='valueOb'>An object representing the value, which will\n    /// be converted to a CBORObject. Can be null, in which case this value\n    /// is converted to CBORObject.Null.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not an\n    /// array.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='valueOb'/> has an unsupported type; or <paramref\n    /// name='index'/> is not a valid index into this array.</exception>\n    public CBORObject Insert(int index, object valueOb) {\n      if (this.Type == CBORType.Array) {\n        CBORObject mapValue;\n        IList<CBORObject> list = this.AsList();\n        if (index < 0 || index > list.Count) {\n          throw new ArgumentOutOfRangeException(nameof(index));\n        }\n        if (valueOb == null) {\n          mapValue = CBORObject.Null;\n        } else {\n          mapValue = valueOb as CBORObject;\n          mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n        }\n        list.Insert(\n          index,\n          mapValue);\n      } else {\n        throw new InvalidOperationException(\"Not an array\");\n      }\n      return this;\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents infinity.</summary>\n    /// <returns><c>true</c> if this CBOR object represents infinity;\n    /// otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsInfinity()).\")]\n    public bool IsInfinity() {\n      return this.IsNumber && this.AsNumber().IsInfinity();\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents a not-a-number value (as opposed to whether this object\n    /// does not express a number).</summary>\n    /// <returns><c>true</c> if this CBOR object represents a not-a-number\n    /// value (as opposed to whether this object does not represent a\n    /// number as defined by the IsNumber property or <c>isNumber()</c>\n    /// method in Java); otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n\n        \"\\u0020cbor.AsNumber().IsNaN()).\")]\n    public bool IsNaN() {\n      return this.IsNumber && this.AsNumber().IsNaN();\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents negative infinity.</summary>\n    /// <returns><c>true</c> if this CBOR object represents negative\n    /// infinity; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n\n        \"\\u0020cbor.AsNumber().IsNegativeInfinity()).\")]\n    public bool IsNegativeInfinity() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return cn != null &&\n        cn.GetNumberInterface().IsNegativeInfinity(cn.GetValue());\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents positive infinity.</summary>\n    /// <returns><c>true</c> if this CBOR object represents positive\n    /// infinity; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n\n        \"\\u0020cbor.AsNumber().IsPositiveInfinity()).\")]\n    public bool IsPositiveInfinity() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return cn != null &&\n        cn.GetNumberInterface().IsPositiveInfinity(cn.GetValue());\n    }\n\n    /// <summary>Gets this object's value with the sign reversed.</summary>\n    /// <returns>The reversed-sign form of this number.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    [Obsolete(\"Instead, convert this object to a number \\u0028with\" +\n\n        \"\\u0020.AsNumber()), and use that number's .Negate() method.\")]\n    public CBORObject Negate() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"This object is not a number.\");\n      }\n      object newItem = cn.GetNumberInterface().Negate(cn.GetValue());\n      if (newItem is EDecimal) {\n        return CBORObject.FromObject((EDecimal)newItem);\n      }\n      if (newItem is EInteger) {\n        return CBORObject.FromObject((EInteger)newItem);\n      }\n      if (newItem is EFloat) {\n        return CBORObject.FromObject((EFloat)newItem);\n      }\n      var rat = newItem as ERational;\n      return (rat != null) ? CBORObject.FromObject(rat) :\n        CBORObject.FromObject(newItem);\n    }\n\n    /// <summary>Removes all items from this CBOR array or all keys and\n    /// values from this CBOR map.</summary>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// CBOR array or CBOR map.</exception>\n    public void Clear() {\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        list.Clear();\n      } else if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n        dict.Clear();\n      } else {\n        throw new InvalidOperationException(\"Not a map or array\");\n      }\n    }\n\n    /// <summary>If this object is an array, removes the first instance of\n    /// the specified item (once converted to a CBOR object) from the\n    /// array. If this object is a map, removes the item with the given key\n    /// (once converted to a CBOR object) from the map.</summary>\n    /// <param name='obj'>The item or key (once converted to a CBOR object)\n    /// to remove.</param>\n    /// <returns><c>true</c> if the item was removed; otherwise,\n    /// <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='obj'/> is null (as opposed to CBORObject.Null).</exception>\n    /// <exception cref='InvalidOperationException'>The object is not an\n    /// array or map.</exception>\n    public bool Remove(object obj) {\n      return this.Remove(CBORObject.FromObject(obj));\n    }\n\n    /// <summary>Removes the item at the given index of this CBOR\n    /// array.</summary>\n    /// <param name='index'>The index, starting at 0, of the item to\n    /// remove.</param>\n    /// <returns>Returns \"true\" if the object was removed. Returns \"false\"\n    /// if the given index is less than 0, or is at least as high as the\n    /// number of items in the array.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// CBOR array.</exception>\n    public bool RemoveAt(int index) {\n      if (this.ItemType != CBORObjectTypeArray) {\n        throw new InvalidOperationException(\"Not an array\");\n      }\n      if (index < 0 || index >= this.Count) {\n        return false;\n      }\n      IList<CBORObject> list = this.AsList();\n      list.RemoveAt(index);\n      return true;\n    }\n\n    /// <summary>If this object is an array, removes the first instance of\n    /// the specified item from the array. If this object is a map, removes\n    /// the item with the given key from the map.</summary>\n    /// <param name='obj'>The item or key to remove.</param>\n    /// <returns><c>true</c> if the item was removed; otherwise,\n    /// <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='obj'/> is null (as opposed to CBORObject.Null).</exception>\n    /// <exception cref='InvalidOperationException'>The object is not an\n    /// array or map.</exception>\n    public bool Remove(CBORObject obj) {\n      if (obj == null) {\n        throw new ArgumentNullException(nameof(obj));\n      }\n      if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n        bool hasKey = dict.ContainsKey(obj);\n        if (hasKey) {\n          dict.Remove(obj);\n          return true;\n        }\n        return false;\n      }\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        return list.Remove(obj);\n      }\n      throw new InvalidOperationException(\"Not a map or array\");\n    }\n\n    /// <summary>Maps an object to a key in this CBOR map, or adds the\n    /// value if the key doesn't exist. If this is a CBOR array, instead\n    /// sets the value at the given index to the given value.</summary>\n    /// <param name='key'>If this instance is a CBOR map, this parameter is\n    /// an object representing the key, which will be converted to a\n    /// CBORObject; in this case, this parameter can be null, in which case\n    /// this value is converted to CBORObject.Null. If this instance is a\n    /// CBOR array, this parameter must be a 32-bit signed integer(\n    /// <c>int</c> ) identifying the index (starting from 0) of the item to\n    /// set in the array.</param>\n    /// <param name='valueOb'>An object representing the value, which will\n    /// be converted to a CBORObject. Can be null, in which case this value\n    /// is converted to CBORObject.Null.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map or an array.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='key'/> or <paramref name='valueOb'/> has an unsupported type,\n    /// or this instance is a CBOR array and <paramref name='key'/> is less\n    /// than 0, is the size of this array or greater, or is not a 32-bit\n    /// signed integer ( <c>int</c> ).</exception>\n    public CBORObject Set(object key, object valueOb) {\n      if (this.Type == CBORType.Map) {\n        CBORObject mapKey;\n        CBORObject mapValue;\n        if (key == null) {\n          mapKey = CBORObject.Null;\n        } else {\n          mapKey = key as CBORObject;\n          mapKey = mapKey ?? CBORObject.FromObject(key);\n        }\n        if (valueOb == null) {\n          mapValue = CBORObject.Null;\n        } else {\n          mapValue = valueOb as CBORObject;\n          mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n        }\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        if (map.ContainsKey(mapKey)) {\n          map[mapKey] = mapValue;\n        } else {\n          map.Add(mapKey, mapValue);\n        }\n      } else if (this.Type == CBORType.Array) {\n        if (key is int) {\n          IList<CBORObject> list = this.AsList();\n          var index = (int)key;\n          if (index < 0 || index >= this.Count) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          CBORObject mapValue;\n          if (valueOb == null) {\n            mapValue = CBORObject.Null;\n          } else {\n            mapValue = valueOb as CBORObject;\n            mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n          }\n          list[index] = mapValue;\n        } else {\n          throw new ArgumentException(\"Is an array, but key is not int\");\n        }\n      } else {\n        throw new InvalidOperationException(\"Not a map or array\");\n      }\n      return this;\n    }\n\n    /// <summary>Converts this object to a text string in JavaScript Object\n    /// Notation (JSON) format. See the overload to ToJSONString taking a\n    /// JSONOptions argument for further information.\n    /// <para>If the CBOR object contains CBOR maps, or is a CBOR map\n    /// itself, the order in which the keys to the map are written out to\n    /// the JSON string is undefined unless the map was created using the\n    /// NewOrderedMap method. Map keys other than untagged text strings are\n    /// converted to JSON strings before writing them out (for example,\n    /// <c>22(\"Test\")</c> is converted to <c>\"Test\"</c> and <c>true</c> is\n    /// converted to <c>\"true\"</c> ). After such conversion, if two or more\n    /// keys for the same map are identical, this method throws a\n    /// CBORException. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string, or to write out a CBOR object as part of a\n    /// JSON text sequence.</para>\n    /// <para><b>Warning:</b> In general, if this CBOR object contains\n    /// integer map keys or uses other features not supported in JSON, and\n    /// the application converts this CBOR object to JSON and back to CBOR,\n    /// the application\n    /// <i>should not</i> expect the new CBOR object to be exactly the same\n    /// as the original. This is because the conversion in many cases may\n    /// have to convert unsupported features in JSON to supported features\n    /// which correspond to a different feature in CBOR (such as converting\n    /// integer map keys, which are supported in CBOR but not JSON, to text\n    /// strings, which are supported in both).</para></summary>\n    /// <returns>A text string containing the converted object in JSON\n    /// format.</returns>\n    public string ToJSONString() {\n      return this.ToJSONString(JSONOptions.Default);\n    }\n\n    /// <summary>\n    ///  Converts this object to a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified\n    /// options to control the encoding process. This function\n    /// works not only with arrays and maps, but also integers,\n    /// strings, byte arrays, and other JSON data types. Notes:\n    ///\n    /// <list type=''><item>If this object contains maps with non-string\n    /// keys, the keys are converted to JSON strings before writing the map\n    /// as a JSON string.</item>\n    ///  <item>If this object represents a number\n    /// (the IsNumber property, or isNumber() method in Java, returns\n    /// true), then it is written out as a number.</item>\n    ///  <item>If the CBOR\n    /// object contains CBOR maps, or is a CBOR map itself, the order in\n    /// which the keys to the map are written out to the JSON string is\n    /// undefined unless the map was created using the NewOrderedMap\n    /// method. Map keys other than untagged text strings are converted to\n    /// JSON strings before writing them out (for example,\n    /// <c>22(\"Test\")</c>\n    ///  is converted to <c>\"Test\"</c>\n    ///  and <c>true</c>\n    ///  is\n    /// converted to <c>\"true\"</c>\n    ///  ). After such conversion, if two or more\n    /// keys for the same map are identical, this method throws a\n    /// CBORException.</item>\n    ///  <item>If a number in the form of an\n    /// arbitrary-precision binary floating-point number has a very high\n    /// binary exponent, it will be converted to a double before being\n    /// converted to a JSON string. (The resulting double could overflow to\n    /// infinity, in which case the arbitrary-precision binary\n    /// floating-point number is converted to null.)</item>\n    ///  <item>The\n    /// string will not begin with a byte-order mark (U+FEFF); RFC 8259\n    /// (the JSON specification) forbids placing a byte-order mark at the\n    /// beginning of a JSON string.</item>\n    ///  <item>Byte strings are converted\n    /// to Base64 URL without whitespace or padding by default (see section\n    /// 3.4.5.3 of RFC 8949). A byte string will instead be converted to\n    /// traditional base64 without whitespace and with padding if it has\n    /// tag 22, or base16 for tag 23. (To create a CBOR object with a given\n    /// tag, call the <c>CBORObject.FromObjectAndTag</c>\n    ///  method and pass\n    /// the CBOR object and the desired tag number to that method.)</item>\n    /// <item>Rational numbers will be converted to their exact form, if\n    /// possible, otherwise to a high-precision approximation. (The\n    /// resulting approximation could overflow to infinity, in which case\n    /// the rational number is converted to null.)</item>\n    ///  <item>Simple\n    /// values other than true and false will be converted to null. (This\n    /// doesn't include floating-point numbers.)</item>\n    ///  <item>Infinity and\n    /// not-a-number will be converted to null.</item>\n    ///  </list>\n    /// <para><b>Warning:</b>\n    ///  In general, if this CBOR object contains\n    /// integer map keys or uses other features not supported in JSON, and\n    /// the application converts this CBOR object to JSON and back to CBOR,\n    /// the application <i>should not</i>\n    ///  expect the new CBOR object to be\n    /// exactly the same as the original. This is because the conversion in\n    /// many cases may have to convert unsupported features in JSON to\n    /// supported features which correspond to a different feature in CBOR\n    /// (such as converting integer map keys, which are supported in CBOR\n    /// but not JSON, to text strings, which are supported in both).</para>\n    /// <para>The example code given below (originally written in C# for\n    /// the.NET version) can be used to write out certain keys of a CBOR\n    /// map in a given order to a JSON string.</para>\n    /// <code>/* Generates a JSON string of 'mapObj' whose keys are in the order\n    /// given\n    /// in 'keys' . Only keys found in 'keys' will be written if they exist in\n    /// 'mapObj'. */ private static string KeysToJSONMap(CBORObject mapObj,\n    /// IList&lt;CBORObject&gt; keys) { if (mapObj == null) { throw new\n    /// ArgumentNullException)nameof(mapObj));}\n    /// if (keys == null) { throw new\n    /// ArgumentNullException)nameof(keys));}\n    /// if (obj.Type != CBORType.Map) {\n    /// throw new ArgumentException(\"'obj' is not a map.\"); } StringBuilder\n    /// builder = new StringBuilder(); var first = true; builder.Append(\"{\");\n    /// for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { if\n    /// (!first) {builder.Append(\", \");} var keyString=(key.CBORType ==\n    /// CBORType.String) ? key.AsString() : key.ToJSONString();\n    /// builder.Append(CBORObject.FromObject(keyString) .ToJSONString())\n    /// .Append(\":\").Append(mapObj[key].ToJSONString()); first=false; } } return\n    /// builder.Append(\"}\").ToString(); }</code>\n    ///  .\n    /// </summary>\n    /// <param name='options'>Specifies options to control writing the CBOR\n    /// object to JSON.</param>\n    /// <returns>A text string containing the converted object in JSON\n    /// format.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    public string ToJSONString(JSONOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      CBORType type = this.Type;\n      switch (type) {\n        case CBORType.Boolean:\n        case CBORType.SimpleValue: {\n          return this.IsTrue ? \"true\" : (this.IsFalse ? \"false\" : \"null\");\n        }\n        case CBORType.Integer: {\n          return this.AsEIntegerValue().ToString();\n        }\n        case CBORType.FloatingPoint: {\n          long dblbits = this.AsDoubleBits();\n          return CBORUtilities.DoubleBitsFinite(dblbits) ?\n               CBORUtilities.DoubleBitsToString(dblbits) : \"null\";\n        }\n        default: {\n          var sb = new StringBuilder();\n          try {\n            CBORJsonWriter.WriteJSONToInternal(\n              this,\n              new StringOutput(sb),\n              options);\n          } catch (IOException ex) {\n            // This is truly exceptional\n            throw new InvalidOperationException(\"Internal error\", ex);\n          }\n          return sb.ToString();\n        }\n      }\n    }\n\n    /// <summary>Returns this CBOR object in a text form intended to be\n    /// read by humans. The value returned by this method is not intended\n    /// to be parsed by computer programs, and the exact text of the value\n    /// may change at any time between versions of this library.\n    /// <para>The returned string is not necessarily in JavaScript Object\n    /// Notation (JSON); to convert CBOR objects to JSON strings, use the\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// method instead.</para></summary>\n    /// <returns>A text representation of this object.</returns>\n    public override string ToString() {\n      return CBORDataUtilities.ToStringHelper(this, 0);\n    }\n\n    /// <summary>Gets an object with the same value as this one but without\n    /// the tags it has, if any. If this object is an array, map, or byte\n    /// string, the data will not be copied to the returned object, so\n    /// changes to the returned object will be reflected in this\n    /// one.</summary>\n    /// <returns>A CBOR object.</returns>\n    public CBORObject Untag() {\n      CBORObject curobject = this;\n      while (curobject.itemtypeValue == CBORObjectTypeTagged) {\n        curobject = (CBORObject)curobject.itemValue;\n      }\n      return curobject;\n    }\n\n    /// <summary>Gets an object with the same value as this one but without\n    /// this object's outermost tag, if any. If this object is an array,\n    /// map, or byte string, the data will not be copied to the returned\n    /// object, so changes to the returned object will be reflected in this\n    /// one.</summary>\n    /// <returns>A CBOR object.</returns>\n    public CBORObject UntagOne() {\n      return (this.itemtypeValue == CBORObjectTypeTagged) ?\n        ((CBORObject)this.itemValue) : this;\n    }\n\n    /// <summary>Converts this object to a text string in JavaScript Object\n    /// Notation (JSON) format, as in the ToJSONString method, and writes\n    /// that string to a data stream in UTF-8. If the CBOR object contains\n    /// CBOR maps, or is a CBOR map, the order in which the keys to the map\n    /// are written out to the JSON string is undefined unless the map was\n    /// created using the NewOrderedMap method. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) writes out a CBOR object as part of a JSON text sequence\n    /// (RFC 7464).</para>\n    /// <code>\n    /// stream.WriteByte(0x1e); &#x2f;&#x2a; RS &#x2a;&#x2f;\n    /// cborObject.WriteJSONTo(stream); &#x2f;&#x2a; JSON &#x2a;&#x2f;\n    /// stream.WriteByte(0x0a); &#x2f;&#x2a; LF &#x2a;&#x2f;\n    /// </code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use the <c>LimitedMemoryStream</c>\n    ///  class\n    /// (implemented in <i>LimitedMemoryStream.cs</i>\n    ///  in the peteroupc/CBOR\n    /// open-source repository) to limit the size of supported JSON\n    /// serializations of CBOR objects.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;\n    /// var maxSize = 20000;\n    /// using (var ms = new LimitedMemoryStream(maxSize)) {\n    /// cborObject.WriteJSONTo(ms);\n    /// var bytes = ms.ToArray();\n    /// }\n    /// </code>\n    /// <para>The following example (written in Java for the Java version)\n    /// shows how to use a subclassed <c>OutputStream</c>\n    ///  together with a\n    /// <c>ByteArrayOutputStream</c>\n    ///  to limit the size of supported JSON\n    /// serializations of CBOR objects.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;\n    /// final int maxSize = 20000;\n    /// ByteArrayOutputStream ba = new ByteArrayOutputStream();\n    /// &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;\n    /// cborObject.WriteJSONTo(new FilterOutputStream(ba) {\n    /// private int size = 0;\n    /// public void write(byte[] b, int off, int len) throws IOException {\n    /// if (len&gt;(maxSize-size)) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size+=len; out.write(b, off, len);\n    /// }\n    /// public void write(byte b) throws IOException {\n    /// if (size &gt;= maxSize) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size++; out.write(b);\n    /// }\n    /// });\n    /// byte[] bytes = ba.toByteArray();\n    /// </code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use a.NET MemoryStream to limit the size of\n    /// supported JSON serializations of CBOR objects. The disadvantage is\n    /// that the extra memory needed to do so can be wasteful, especially\n    /// if the average serialized object is much smaller than the maximum\n    /// size given (for example, if the maximum size is 20000 bytes, but\n    /// the average serialized object has a size of 50 bytes).</para>\n    /// <code>\n    /// var backing = new byte[20000]; &#x2f;&#x2a; maximum supported JSON size in\n    /// bytes&#x2a;&#x2f;\n    /// byte[] bytes1, bytes2;\n    /// using (var ms = new MemoryStream(backing)) {\n    /// &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;\n    /// cborObject.WriteJSONTo(ms);\n    /// bytes1 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);\n    /// &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;\n    /// ms.Position = 0;\n    /// cborObject2.WriteJSONTo(ms);\n    /// bytes2 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);\n    /// }\n    /// </code>\n    /// </example>\n    public void WriteJSONTo(Stream outputStream) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      CBORJsonWriter.WriteJSONToInternal(\n        this,\n        new StringOutput(outputStream),\n        JSONOptions.Default);\n    }\n\n    /// <summary>Converts this object to a text string in JavaScript Object\n    /// Notation (JSON) format, as in the ToJSONString method, and writes\n    /// that string to a data stream in UTF-8, using the given JSON options\n    /// to control the encoding process. If the CBOR object contains CBOR\n    /// maps, or is a CBOR map, the order in which the keys to the map are\n    /// written out to the JSON string is undefined unless the map was\n    /// created using the NewOrderedMap method. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='options'>An object containing the options to control\n    /// writing the CBOR object to JSON.</param>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public void WriteJSONTo(Stream outputStream, JSONOptions options) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      CBORJsonWriter.WriteJSONToInternal(\n        this,\n        new StringOutput(outputStream),\n        options);\n    }\n\n    /// <summary>Generates a CBOR object from a floating-point number\n    /// represented by its bits.</summary>\n    /// <param name='floatingBits'>The bits of a floating-point number\n    /// number to write.</param>\n    /// <param name='byteCount'>The number of bytes of the stored\n    /// floating-point number; this also specifies the format of the\n    /// \"floatingBits\" parameter. This value can be 2 if \"floatingBits\"'s\n    /// lowest (least significant) 16 bits identify the floating-point\n    /// number in IEEE 754r binary16 format; or 4 if \"floatingBits\"'s\n    /// lowest (least significant) 32 bits identify the floating-point\n    /// number in IEEE 754r binary32 format; or 8 if \"floatingBits\"\n    /// identifies the floating point number in IEEE 754r binary64 format.\n    /// Any other values for this parameter are invalid.</param>\n    /// <returns>A CBOR object storing the given floating-point\n    /// number.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    public static CBORObject FromFloatingPointBits(\n      long floatingBits,\n      int byteCount) {\n      long value;\n      switch (byteCount) {\n        case 2:\n          value = CBORUtilities.HalfToDoublePrecision(\n              unchecked((int)(floatingBits & 0xffffL)));\n          return new CBORObject(CBORObjectTypeDouble, value);\n        case 4:\n\n          value = CBORUtilities.SingleToDoublePrecision(\n              unchecked((int)(floatingBits & 0xffffffffL)));\n          return new CBORObject(CBORObjectTypeDouble, value);\n        case 8:\n          return new CBORObject(CBORObjectTypeDouble, floatingBits);\n        default: throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes the bits of a floating-point number in CBOR format\n    /// to a data stream.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='floatingBits'>The bits of a floating-point number\n    /// number to write.</param>\n    /// <param name='byteCount'>The number of bytes of the stored\n    /// floating-point number; this also specifies the format of the\n    /// \"floatingBits\" parameter. This value can be 2 if \"floatingBits\"'s\n    /// lowest (least significant) 16 bits identify the floating-point\n    /// number in IEEE 754r binary16 format; or 4 if \"floatingBits\"'s\n    /// lowest (least significant) 32 bits identify the floating-point\n    /// number in IEEE 754r binary32 format; or 8 if \"floatingBits\"\n    /// identifies the floating point number in IEEE 754r binary64 format.\n    /// Any other values for this parameter are invalid. This method will\n    /// write one plus this many bytes to the data stream.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointBits(\n      Stream outputStream,\n      long floatingBits,\n      int byteCount) {\n      return WriteFloatingPointBits(\n          outputStream,\n          floatingBits,\n          byteCount,\n          false);\n    }\n\n    /// <summary>Writes the bits of a floating-point number in CBOR format\n    /// to a data stream.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='floatingBits'>The bits of a floating-point number\n    /// number to write.</param>\n    /// <param name='byteCount'>The number of bytes of the stored\n    /// floating-point number; this also specifies the format of the\n    /// \"floatingBits\" parameter. This value can be 2 if \"floatingBits\"'s\n    /// lowest (least significant) 16 bits identify the floating-point\n    /// number in IEEE 754r binary16 format; or 4 if \"floatingBits\"'s\n    /// lowest (least significant) 32 bits identify the floating-point\n    /// number in IEEE 754r binary32 format; or 8 if \"floatingBits\"\n    /// identifies the floating point number in IEEE 754r binary64 format.\n    /// Any other values for this parameter are invalid.</param>\n    /// <param name='shortestForm'>If true, writes the shortest form of the\n    /// floating-point number that preserves its value. If false, this\n    /// method will write the number in the form given by 'floatingBits' by\n    /// writing one plus the number of bytes given by 'byteCount' to the\n    /// data stream.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointBits(\n      Stream outputStream,\n      long floatingBits,\n      int byteCount,\n      bool shortestForm) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (shortestForm) {\n        if (byteCount == 8) {\n          int bits =\n            CBORUtilities.DoubleToHalfPrecisionIfSameValue(floatingBits);\n          if (bits != -1) {\n            return WriteFloatingPointBits(outputStream, (long)bits, 2, false);\n          }\n          if (CBORUtilities.DoubleRetainsSameValueInSingle(floatingBits)) {\n            bits = CBORUtilities.DoubleToRoundedSinglePrecision(floatingBits);\n            return WriteFloatingPointBits(outputStream, (long)bits, 4, false);\n          }\n        } else if (byteCount == 4) {\n          int bits =\n            CBORUtilities.SingleToHalfPrecisionIfSameValue(floatingBits);\n          if (bits != -1) {\n            return WriteFloatingPointBits(outputStream, (long)bits, 2, false);\n          }\n        }\n      }\n      byte[] bytes;\n      switch (byteCount) {\n        case 2:\n          bytes = new byte[] {\n            (byte)0xf9,\n            (byte)((floatingBits >> 8) & 0xffL),\n            (byte)(floatingBits & 0xffL),\n          };\n          outputStream.Write(bytes, 0, 3);\n          return 3;\n        case 4:\n          bytes = new byte[] {\n            (byte)0xfa,\n            (byte)((floatingBits >> 24) & 0xffL),\n            (byte)((floatingBits >> 16) & 0xffL),\n            (byte)((floatingBits >> 8) & 0xffL),\n            (byte)(floatingBits & 0xffL),\n          };\n          outputStream.Write(bytes, 0, 5);\n          return 5;\n        case 8:\n          bytes = new byte[] {\n            (byte)0xfb,\n            (byte)((floatingBits >> 56) & 0xffL),\n            (byte)((floatingBits >> 48) & 0xffL),\n            (byte)((floatingBits >> 40) & 0xffL),\n            (byte)((floatingBits >> 32) & 0xffL),\n            (byte)((floatingBits >> 24) & 0xffL),\n            (byte)((floatingBits >> 16) & 0xffL),\n            (byte)((floatingBits >> 8) & 0xffL),\n            (byte)(floatingBits & 0xffL),\n          };\n          outputStream.Write(bytes, 0, 9);\n          return 9;\n        default:\n          throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes a 64-bit binary floating-point number in CBOR\n    /// format to a data stream, either in its 64-bit form, or its rounded\n    /// 32-bit or 16-bit equivalent.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='doubleVal'>The double-precision floating-point number\n    /// to write.</param>\n    /// <param name='byteCount'>The number of 8-bit bytes of the stored\n    /// number. This value can be 2 to store the number in IEEE 754r\n    /// binary16, rounded to nearest, ties to even; or 4 to store the\n    /// number in IEEE 754r binary32, rounded to nearest, ties to even; or\n    /// 8 to store the number in IEEE 754r binary64. Any other values for\n    /// this parameter are invalid.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointValue(\n      Stream outputStream,\n      double doubleVal,\n      int byteCount) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      long bits = 0;\n      switch (byteCount) {\n        case 2:\n          bits = CBORUtilities.DoubleToInt64Bits(doubleVal);\n          bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);\n          bits &= 0xffffL;\n          return WriteFloatingPointBits(outputStream, bits, 2);\n        case 4:\n          bits = CBORUtilities.DoubleToInt64Bits(doubleVal);\n          bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);\n          bits &= 0xffffffffL;\n          return WriteFloatingPointBits(outputStream, bits, 4);\n        case 8:\n          bits = CBORUtilities.DoubleToInt64Bits(doubleVal);\n          return WriteFloatingPointBits(outputStream, bits, 8);\n        default: throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes a 32-bit binary floating-point number in CBOR\n    /// format to a data stream, either in its 64- or 32-bit form, or its\n    /// rounded 16-bit equivalent.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='singleVal'>The single-precision floating-point number\n    /// to write.</param>\n    /// <param name='byteCount'>The number of 8-bit bytes of the stored\n    /// number. This value can be 2 to store the number in IEEE 754r\n    /// binary16, rounded to nearest, ties to even; or 4 to store the\n    /// number in IEEE 754r binary32; or 8 to store the number in IEEE 754r\n    /// binary64. Any other values for this parameter are invalid.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointValue(\n      Stream outputStream,\n      float singleVal,\n      int byteCount) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      var bits = 0;\n      long longbits = 0L;\n      switch (byteCount) {\n        case 2:\n          bits = BitConverter.ToInt32(\n              BitConverter.GetBytes((float)singleVal),\n              0);\n          bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);\n          bits &= 0xffff;\n          return WriteFloatingPointBits(outputStream, bits, 2);\n        case 4:\n          bits = BitConverter.ToInt32(\n              BitConverter.GetBytes((float)singleVal),\n              0);\n          longbits = ((long)bits) & 0xffffffffL;\n          return WriteFloatingPointBits(outputStream, longbits, 4);\n        case 8:\n          bits = BitConverter.ToInt32(\n              BitConverter.GetBytes((float)singleVal),\n              0);\n          longbits = CBORUtilities.SingleToDoublePrecision(bits);\n          return WriteFloatingPointBits(outputStream, longbits, 8);\n        default: throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes a CBOR major type number and an integer 0 or\n    /// greater associated with it to a data stream, where that integer is\n    /// passed to this method as a 64-bit signed integer. This is a\n    /// low-level method that is useful for implementing custom CBOR\n    /// encoding methodologies. This method encodes the given major type\n    /// and value in the shortest form allowed for the major\n    /// type.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='majorType'>The CBOR major type to write. This is a\n    /// number from 0 through 7 as follows. 0: integer 0 or greater; 1:\n    /// negative integer; 2: byte string; 3: UTF-8 text string; 4: array;\n    /// 5: map; 6: tag; 7: simple value. See RFC 8949 for details on these\n    /// major types.</param>\n    /// <param name='value'>An integer 0 or greater associated with the\n    /// major type, as follows. 0: integer 0 or greater; 1: the negative\n    /// integer's absolute value is 1 plus this number; 2: length in bytes\n    /// of the byte string; 3: length in bytes of the UTF-8 text string; 4:\n    /// number of items in the array; 5: number of key-value pairs in the\n    /// map; 6: tag number; 7: simple value number, which must be in the\n    /// interval [0, 23] or [32, 255].</param>\n    /// <returns>The number of bytes ordered to be written to the data\n    /// stream.</returns>\n    /// <exception cref='ArgumentException'>Value is from 24 to 31 and\n    /// major type is 7.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    /// <remarks>There are other useful things to note when encoding CBOR\n    /// that are not covered by this WriteValue method. To mark the start\n    /// of an indefinite-length array, write the 8-bit byte 0x9f to the\n    /// output stream. To mark the start of an indefinite-length map, write\n    /// the 8-bit byte 0xbf to the output stream. To mark the end of an\n    /// indefinite-length array or map, write the 8-bit byte 0xff to the\n    /// output stream. For examples, see the WriteValue(Stream, int, int)\n    /// overload.</remarks>\n    public static int WriteValue(\n      Stream outputStream,\n      int majorType,\n      long value) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (majorType < 0) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is less than 0\");\n      }\n      if (majorType > 7) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is more than 7\");\n      }\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value +\n          \") is less than 0\");\n      }\n      if (majorType == 7) {\n        if (value > 255) {\n          throw new ArgumentException(\"value(\" + value +\n            \") is more than 255\");\n        }\n        if (value <= 23) {\n          outputStream.WriteByte((byte)(0xe0 + (int)value));\n          return 1;\n        } else if (value < 32) {\n          throw new ArgumentException(\"value is from 24 to 31 and major\" +\n            \" type is 7\");\n        } else {\n          outputStream.WriteByte((byte)0xf8);\n          outputStream.WriteByte((byte)value);\n          return 2;\n        }\n      } else {\n        return WritePositiveInt64(majorType, value, outputStream);\n      }\n    }\n\n    /// <summary>Writes a CBOR major type number and an integer 0 or\n    /// greater associated with it to a data stream, where that integer is\n    /// passed to this method as a 32-bit signed integer. This is a\n    /// low-level method that is useful for implementing custom CBOR\n    /// encoding methodologies. This method encodes the given major type\n    /// and value in the shortest form allowed for the major\n    /// type.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='majorType'>The CBOR major type to write. This is a\n    /// number from 0 through 7 as follows. 0: integer 0 or greater; 1:\n    /// negative integer; 2: byte string; 3: UTF-8 text string; 4: array;\n    /// 5: map; 6: tag; 7: simple value. See RFC 8949 for details on these\n    /// major types.</param>\n    /// <param name='value'>An integer 0 or greater associated with the\n    /// major type, as follows. 0: integer 0 or greater; 1: the negative\n    /// integer's absolute value is 1 plus this number; 2: length in bytes\n    /// of the byte string; 3: length in bytes of the UTF-8 text string; 4:\n    /// number of items in the array; 5: number of key-value pairs in the\n    /// map; 6: tag number; 7: simple value number, which must be in the\n    /// interval [0, 23] or [32, 255].</param>\n    /// <returns>The number of bytes ordered to be written to the data\n    /// stream.</returns>\n    /// <exception cref='ArgumentException'>Value is from 24 to 31 and\n    /// major type is 7.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    /// <remarks>There are other useful things to note when encoding CBOR\n    /// that are not covered by this WriteValue method. To mark the start\n    /// of an indefinite-length array, write the 8-bit byte 0x9f to the\n    /// output stream. To mark the start of an indefinite-length map, write\n    /// the 8-bit byte 0xbf to the output stream. To mark the end of an\n    /// indefinite-length array or map, write the 8-bit byte 0xff to the\n    /// output stream.</remarks>\n    /// <example>\n    /// <para>In the following example, an array of three objects is\n    /// written as CBOR to a data stream.</para>\n    /// <code>&#x2f;&#x2a; array, length 3&#x2a;&#x2f;\n    /// CBORObject.WriteValue(stream, 4, 3);\n    /// &#x2f;&#x2a; item 1 */\n    /// CBORObject.Write(\"hello world\", stream);\n    /// CBORObject.Write(25, stream); &#x2f;&#x2a; item 2&#x2a;&#x2f;\n    /// CBORObject.Write(false, stream); &#x2f;&#x2a; item 3&#x2a;&#x2f;</code>\n    /// <para>In the following example, a map consisting of two key-value\n    /// pairs is written as CBOR to a data stream.</para>\n    /// <code>CBORObject.WriteValue(stream, 5, 2); &#x2f;&#x2a; map, 2\n    /// pairs&#x2a;&#x2f;\n    /// CBORObject.Write(\"number\", stream); &#x2f;&#x2a; key 1 */\n    /// CBORObject.Write(25, stream); &#x2f;&#x2a; value 1 */\n    /// CBORObject.Write(\"string\", stream); &#x2f;&#x2a; key 2&#x2a;&#x2f;\n    /// CBORObject.Write(\"hello\", stream); &#x2f;&#x2a; value 2&#x2a;&#x2f;</code>\n    /// <para>In the following example (originally written in C# for\n    /// the.NET Framework version), a text string is written as CBOR to a\n    /// data stream.</para>\n    /// <code>string str = \"hello world\"; byte[] bytes =\n    /// DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4,\n    /// bytes.Length); stream.Write(bytes, 0, bytes.Length);</code>\n    ///  .\n    /// </example>\n    public static int WriteValue(\n      Stream outputStream,\n      int majorType,\n      int value) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (majorType < 0) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is less than 0\");\n      }\n      if (majorType > 7) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is more than 7\");\n      }\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value +\n          \") is less than 0\");\n      }\n      if (majorType == 7) {\n        if (value > 255) {\n          throw new ArgumentException(\"value(\" + value +\n            \") is more than 255\");\n        }\n        if (value <= 23) {\n          outputStream.WriteByte((byte)(0xe0 + value));\n          return 1;\n        } else if (value < 32) {\n          throw new ArgumentException(\"value is from 24 to 31 and major\" +\n            \"\\u0020type\" + \"\\u0020is 7\");\n        } else {\n          outputStream.WriteByte((byte)0xf8);\n          outputStream.WriteByte((byte)value);\n          return 2;\n        }\n      } else {\n        return WritePositiveInt(majorType, value, outputStream);\n      }\n    }\n\n    /// <summary>Writes a CBOR major type number and an integer 0 or\n    /// greater associated with it to a data stream, where that integer is\n    /// passed to this method as an arbitrary-precision integer. This is a\n    /// low-level method that is useful for implementing custom CBOR\n    /// encoding methodologies. This method encodes the given major type\n    /// and value in the shortest form allowed for the major\n    /// type.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='majorType'>The CBOR major type to write. This is a\n    /// number from 0 through 7 as follows. 0: integer 0 or greater; 1:\n    /// negative integer; 2: byte string; 3: UTF-8 text string; 4: array;\n    /// 5: map; 6: tag; 7: simple value. See RFC 8949 for details on these\n    /// major types.</param>\n    /// <param name='bigintValue'>An integer 0 or greater associated with\n    /// the major type, as follows. 0: integer 0 or greater; 1: the\n    /// negative integer's absolute value is 1 plus this number; 2: length\n    /// in bytes of the byte string; 3: length in bytes of the UTF-8 text\n    /// string; 4: number of items in the array; 5: number of key-value\n    /// pairs in the map; 6: tag number; 7: simple value number, which must\n    /// be in the interval [0, 23] or [32, 255]. For major types 0 to 6,\n    /// this number may not be greater than 2^64 - 1.</param>\n    /// <returns>The number of bytes ordered to be written to the data\n    /// stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='majorType'/> is 7 and value is greater than 255.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> or <paramref name='bigintValue'/> is\n    /// null.</exception>\n    /// <remarks>There are other useful things to note when encoding CBOR\n    /// that are not covered by this WriteValue method. To mark the start\n    /// of an indefinite-length array, write the 8-bit byte 0x9f to the\n    /// output stream. To mark the start of an indefinite-length map, write\n    /// the 8-bit byte 0xbf to the output stream. To mark the end of an\n    /// indefinite-length array or map, write the 8-bit byte 0xff to the\n    /// output stream.</remarks>\n    public static int WriteValue(\n      Stream outputStream,\n      int majorType,\n      EInteger bigintValue) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (bigintValue == null) {\n        throw new ArgumentNullException(nameof(bigintValue));\n      }\n      if (bigintValue.Sign < 0) {\n        throw new ArgumentException(\"tagEInt's sign(\" + bigintValue.Sign +\n          \") is less than 0\");\n      }\n      if (bigintValue.CompareTo(UInt64MaxValue) > 0) {\n        throw new ArgumentException(\n          \"tag more than 18446744073709551615 (\" + bigintValue + \")\");\n      }\n      if (bigintValue.CanFitInInt64()) {\n        return WriteValue(\n            outputStream,\n            majorType,\n            bigintValue.ToInt64Checked());\n      }\n      long longVal = bigintValue.ToInt64Unchecked();\n      var highbyte = (int)((longVal >> 56) & 0xff);\n      if (majorType < 0) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is less than 0\");\n      }\n      if (majorType > 7) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is more than 7\");\n      }\n      if (majorType == 7) {\n        throw new ArgumentException(\n          \"majorType is 7 and value is greater\" + \"\\u0020than 255\");\n      }\n      byte[] bytes = new[] {\n        (byte)(27 | (majorType << 5)), (byte)highbyte,\n        (byte)((longVal >> 48) & 0xff), (byte)((longVal >> 40) & 0xff),\n        (byte)((longVal >> 32) & 0xff), (byte)((longVal >> 24) & 0xff),\n        (byte)((longVal >> 16) & 0xff), (byte)((longVal >> 8) & 0xff),\n        (byte)(longVal & 0xff),\n      };\n      outputStream.Write(bytes, 0, bytes.Length);\n      return bytes.Length;\n    }\n\n    /// <summary><para>Writes this CBOR object to a data stream. If the\n    /// CBOR object contains CBOR maps, or is a CBOR map, the order in\n    /// which the keys to the map are written out to the data stream is\n    /// undefined unless the map was created using the NewOrderedMap\n    /// method. See the examples (originally written in C# for the.NET\n    /// version) for ways to write out certain keys of a CBOR map in a\n    /// given order. In the case of CBOR objects of type FloatingPoint, the\n    /// number is written using the shortest floating-point encoding\n    /// possible; this is a change from previous versions.</para>\n    /// </summary>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <example>\n    /// <para>The following example shows a method that writes each key of\n    /// 'mapObj' to 'outputStream', in the order given in 'keys', where\n    /// 'mapObj' is written out in the form of a CBOR <b>definite-length\n    /// map</b>\n    /// . Only keys found in 'keys' will be written if they exist\n    /// in 'mapObj'.</para>\n    /// <code>private static void WriteKeysToMap(CBORObject mapObj,\n    /// IList&lt;CBORObject&gt; keys, Stream outputStream) {\n    /// if (mapObj == null) {\n    /// throw new ArgumentNullException(nameof(mapObj));}\n    /// if (keys == null)\n    /// {throw new ArgumentNullException(nameof(keys));}\n    /// if (outputStream ==\n    /// null) {throw new ArgumentNullException(nameof(outputStream));}\n    /// if\n    /// (obj.Type!=CBORType.Map) { throw new ArgumentException(\"'obj' is not a\n    /// map.\"); } int keyCount = 0; for (CBORObject key in keys) { if\n    /// (mapObj.ContainsKey(key)) { keyCount++; } }\n    /// CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in\n    /// keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);\n    /// mapObj[key].WriteTo(outputStream); } } }</code>\n    /// <para>The following example shows a method that writes each key of\n    /// 'mapObj' to 'outputStream', in the order given in 'keys', where\n    /// 'mapObj' is written out in the form of a CBOR <b>indefinite-length\n    /// map</b>\n    /// . Only keys found in 'keys' will be written if they exist\n    /// in 'mapObj'.</para>\n    /// <code>private static void WriteKeysToIndefMap(CBORObject mapObj,\n    /// IList&lt;CBORObject&gt; keys, Stream outputStream) { if (mapObj == null)\n    /// { throw new ArgumentNullException(nameof(mapObj));}\n    /// if (keys == null)\n    /// {throw new ArgumentNullException(nameof(keys));}\n    /// if (outputStream ==\n    /// null) {throw new ArgumentNullException(nameof(outputStream));}\n    /// if\n    /// (obj.Type!=CBORType.Map) { throw new ArgumentException(\"'obj' is not a\n    /// map.\"); } outputStream.WriteByte((byte)0xBF); for (CBORObject key in\n    /// keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);\n    /// mapObj[key].WriteTo(outputStream); } }\n    /// outputStream.WriteByte((byte)0xff); }</code>\n    /// <para>The following example shows a method that writes out a list\n    /// of objects to 'outputStream' as an <b>indefinite-length CBOR\n    /// array</b>\n    /// .</para>\n    /// <code>private static void WriteToIndefArray(IList&lt;object&gt; list,\n    /// Stream\n    /// outputStream) { if (list == null) { throw new\n    /// ArgumentNullException(nameof(list));}\n    /// if (outputStream == null) {throw\n    /// new ArgumentNullException(nameof(outputStream));}\n    /// outputStream.WriteByte((byte)0x9f); for (object item in list) { new\n    /// CBORObject(item).WriteTo(outputStream); }\n    /// outputStream.WriteByte((byte)0xff); }</code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use the <c>LimitedMemoryStream</c>\n    ///  class\n    /// (implemented in <i>LimitedMemoryStream.cs</i>\n    ///  in the peteroupc/CBOR\n    /// open-source repository) to limit the size of supported CBOR\n    /// serializations.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;\n    /// var maxSize = 20000;\n    /// using (var ms = new LimitedMemoryStream(maxSize)) {\n    /// cborObject.WriteTo(ms);\n    /// var bytes = ms.ToArray();\n    /// }\n    /// </code>\n    /// <para>The following example (written in Java for the Java version)\n    /// shows how to use a subclassed <c>OutputStream</c>\n    ///  together with a\n    /// <c>ByteArrayOutputStream</c>\n    ///  to limit the size of supported CBOR\n    /// serializations.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;\n    /// final int maxSize = 20000;\n    /// ByteArrayOutputStream ba = new ByteArrayOutputStream();\n    /// &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;\n    /// cborObject.WriteTo(new FilterOutputStream(ba) {\n    /// private int size = 0;\n    /// public void write(byte[] b, int off, int len) throws IOException {\n    /// if (len&gt;(maxSize-size)) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size+=len; out.write(b, off, len);\n    /// }\n    /// public void write(byte b) throws IOException {\n    /// if (size &gt;= maxSize) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size++; out.write(b);\n    /// }\n    /// });\n    /// byte[] bytes = ba.toByteArray();\n    /// </code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use a.NET MemoryStream to limit the size of\n    /// supported CBOR serializations. The disadvantage is that the extra\n    /// memory needed to do so can be wasteful, especially if the average\n    /// serialized object is much smaller than the maximum size given (for\n    /// example, if the maximum size is 20000 bytes, but the average\n    /// serialized object has a size of 50 bytes).</para>\n    /// <code>\n    /// var backing = new byte[20000]; &#x2f;&#x2a; maximum supported CBOR size in\n    /// bytes&#x2a;&#x2f;\n    /// byte[] bytes1, bytes2;\n    /// using (var ms = new MemoryStream(backing)) {\n    /// &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;\n    /// cborObject.WriteTo(ms);\n    /// bytes1 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);\n    /// &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;\n    /// ms.Position = 0;\n    /// cborObject2.WriteTo(ms);\n    /// bytes2 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);\n    /// }\n    /// </code>\n    /// </example>\n    public void WriteTo(Stream stream) {\n      this.WriteTo(stream, CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes this CBOR object to a data stream, using the\n    /// specified options for encoding the data to CBOR format. If the CBOR\n    /// object contains CBOR maps, or is a CBOR map, the order in which the\n    /// keys to the map are written out to the data stream is undefined\n    /// unless the map was created using the NewOrderedMap method. The\n    /// example code given in\n    /// <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can\n    /// be used to write out certain keys of a CBOR map in a given order.\n    /// In the case of CBOR objects of type FloatingPoint, the number is\n    /// written using the shortest floating-point encoding possible; this\n    /// is a change from previous versions.</summary>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <param name='options'>Options for encoding the data to\n    /// CBOR.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='ArgumentException'>Unexpected data\n    /// type\".</exception>\n    public void WriteTo(Stream stream, CBOREncodeOptions options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (options.Ctap2Canonical) {\n        byte[] bytes = CBORCanonical.CtapCanonicalEncode(this);\n        stream.Write(bytes, 0, bytes.Length);\n        return;\n      }\n      this.WriteTags(stream);\n      int type = this.ItemType;\n      switch (type) {\n        case CBORObjectTypeInteger: {\n          Write((long)this.ThisItem, stream);\n          break;\n        }\n        case CBORObjectTypeEInteger: {\n          Write((EInteger)this.ThisItem, stream);\n          break;\n        }\n        case CBORObjectTypeByteString:\n        case CBORObjectTypeTextStringUtf8: {\n          byte[] arr = (byte[])this.ThisItem;\n          WritePositiveInt(\n            (this.Type == CBORType.ByteString) ? 2 : 3,\n            arr.Length,\n            stream);\n          stream.Write(arr, 0, arr.Length);\n          break;\n        }\n        case CBORObjectTypeTextString:\n        case CBORObjectTypeTextStringAscii: {\n          Write((string)this.ThisItem, stream, options);\n          break;\n        }\n        case CBORObjectTypeArray: {\n          WriteObjectArray(this.AsList(), stream, options);\n          break;\n        }\n        case CBORObjectTypeMap: {\n          WriteObjectMap(this.AsMap(), stream, options);\n          break;\n        }\n        case CBORObjectTypeSimpleValue: {\n          int value = this.SimpleValue;\n          if (value < 24) {\n            stream.WriteByte((byte)(0xe0 + value));\n          } else {\n            #if DEBUG\n            if (value < 32) {\n              throw new ArgumentException(\"value(\" + value +\n                \") is less than \" + \"32\");\n            }\n            #endif\n\n            stream.WriteByte(0xf8);\n            stream.WriteByte((byte)value);\n          }\n\n          break;\n        }\n        case CBORObjectTypeDouble: {\n          WriteFloatingPointBits(\n             stream,\n             this.AsDoubleBits(),\n             8,\n             !options.Float64);\n          break;\n        }\n        default: {\n          throw new ArgumentException(\"Unexpected data type\");\n        }\n      }\n    }\n\n    internal static CBORObject FromRaw(byte[] bytes) {\n      return new CBORObject(CBORObjectTypeByteString, bytes);\n    }\n\n    internal static CBORObject FromRawUtf8(byte[] bytes) {\n      return new CBORObject(CBORObjectTypeTextStringUtf8, bytes);\n    }\n\n    internal static CBORObject FromRaw(string str) {\n      #if DEBUG\n      if (!CBORUtilities.CheckUtf16(str)) {\n        throw new InvalidOperationException();\n      }\n      #endif\n      return new CBORObject(CBORObjectTypeTextString, str);\n    }\n\n    internal static CBORObject FromRaw(IList<CBORObject> list) {\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    internal static CBORObject FromRaw(IDictionary<CBORObject, CBORObject>\n      map) {\n      return new CBORObject(CBORObjectTypeMap, map);\n    }\n\n    internal static int GetExpectedLength(int value) {\n      return ValueExpectedLengths[value];\n    }\n\n    // Generate a CBOR object for head bytes with fixed length.\n    // Note that this function assumes that the length of the data\n    // was already checked.\n    internal static CBORObject GetFixedLengthObject(\n      int firstbyte,\n      byte[] data) {\n      CBORObject fixedObj = FixedObjects[firstbyte];\n      if (fixedObj != null) {\n        return fixedObj;\n      }\n      int majortype = firstbyte >> 5;\n      if ((firstbyte & 0x1c) == 0x18) {\n        // contains 1 to 8 extra bytes of additional information\n        long uadditional = 0;\n        switch (firstbyte & 0x1f) {\n          case 24:\n            uadditional = (int)(data[1] & (int)0xff);\n            break;\n          case 25:\n            uadditional = (data[1] & 0xffL) << 8;\n            uadditional |= (long)(data[2] & 0xffL);\n            break;\n          case 26:\n            uadditional = (data[1] & 0xffL) << 24;\n            uadditional |= (data[2] & 0xffL) << 16;\n            uadditional |= (data[3] & 0xffL) << 8;\n            uadditional |= (long)(data[4] & 0xffL);\n            break;\n          case 27:\n            uadditional = (data[1] & 0xffL) << 56;\n            uadditional |= (data[2] & 0xffL) << 48;\n            uadditional |= (data[3] & 0xffL) << 40;\n            uadditional |= (data[4] & 0xffL) << 32;\n            uadditional |= (data[5] & 0xffL) << 24;\n            uadditional |= (data[6] & 0xffL) << 16;\n            uadditional |= (data[7] & 0xffL) << 8;\n            uadditional |= (long)(data[8] & 0xffL);\n            break;\n          default:\n            throw new CBORException(\"Unexpected data encountered\");\n        }\n        switch (majortype) {\n          case 0:\n            if ((uadditional >> 63) == 0) {\n              // use only if additional's top bit isn't set\n              // (additional is a signed long)\n              return new CBORObject(CBORObjectTypeInteger, uadditional);\n            } else {\n              int low = unchecked((int)(uadditional & 0xffffffffL));\n              int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));\n              return FromObject(LowHighToEInteger(low, high));\n            }\n          case 1:\n            if ((uadditional >> 63) == 0) {\n              // use only if additional's top bit isn't set\n              // (additional is a signed long)\n              return new CBORObject(\n                  CBORObjectTypeInteger,\n                  -1 - uadditional);\n            } else {\n              int low = unchecked((int)(uadditional & 0xffffffffL));\n              int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));\n              EInteger bigintAdditional = LowHighToEInteger(low, high);\n              EInteger minusOne = -EInteger.One;\n              bigintAdditional = minusOne - (EInteger)bigintAdditional;\n              return FromObject(bigintAdditional);\n            }\n          case 7:\n            if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {\n              var dblbits = (long)uadditional;\n              if (firstbyte == 0xf9) {\n                dblbits = CBORUtilities.HalfToDoublePrecision(\n                    unchecked((int)uadditional));\n              } else if (firstbyte == 0xfa) {\n                dblbits = CBORUtilities.SingleToDoublePrecision(\n                    unchecked((int)uadditional));\n              }\n              return new CBORObject(\n                  CBORObjectTypeDouble,\n                  dblbits);\n            }\n            if (firstbyte == 0xf8) {\n              if ((int)uadditional < 32) {\n                throw new CBORException(\"Invalid overlong simple value\");\n              }\n              return new CBORObject(\n                  CBORObjectTypeSimpleValue,\n                  (int)uadditional);\n            }\n            throw new CBORException(\"Unexpected data encountered\");\n          default: throw new CBORException(\"Unexpected data encountered\");\n        }\n      }\n      if (majortype == 2) { // short byte string\n        var ret = new byte[firstbyte - 0x40];\n        Array.Copy(data, 1, ret, 0, firstbyte - 0x40);\n        return new CBORObject(CBORObjectTypeByteString, ret);\n      }\n      if (majortype == 3) { // short text string\n        var ret = new byte[firstbyte - 0x60];\n        Array.Copy(data, 1, ret, 0, firstbyte - 0x60);\n        if (!CBORUtilities.CheckUtf8(ret)) {\n          throw new CBORException(\"Invalid encoding\");\n        }\n        return new CBORObject(CBORObjectTypeTextStringUtf8, ret);\n      }\n      if (firstbyte == 0x80) {\n        // empty array\n        return CBORObject.NewArray();\n      }\n      if (firstbyte == 0xa0) {\n        // empty map\n        return CBORObject.NewOrderedMap();\n      }\n      throw new CBORException(\"Unexpected data encountered\");\n    }\n\n    internal static CBORObject GetFixedObject(int value) {\n      return FixedObjects[value];\n    }\n\n    private IList<CBORObject> AsList() {\n      return (IList<CBORObject>)this.ThisItem;\n    }\n\n    private IDictionary<CBORObject, CBORObject> AsMap() {\n      return (IDictionary<CBORObject, CBORObject>)this.ThisItem;\n    }\n\n    private static bool CBORArrayEquals(\n      IList<CBORObject> listA,\n      IList<CBORObject> listB) {\n      if (listA == null) {\n        return listB == null;\n      }\n      if (listB == null) {\n        return false;\n      }\n      int listACount = listA.Count;\n      int listBCount = listB.Count;\n      if (listACount != listBCount) {\n        return false;\n      }\n      for (var i = 0; i < listACount; ++i) {\n        CBORObject itemA = listA[i];\n        CBORObject itemB = listB[i];\n        if (!(itemA == null ? itemB == null : itemA.Equals(itemB))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static int CBORArrayHashCode(IList<CBORObject> list) {\n      if (list == null) {\n        return 0;\n      }\n      var ret = 19;\n      int count = list.Count;\n      unchecked {\n        ret = (ret * 31) + count;\n        for (var i = 0; i < count; ++i) {\n          ret = (ret * 31) + list[i].GetHashCode();\n        }\n      }\n      return ret;\n    }\n\n    private static bool StringEquals(string str, string str2) {\n      if (str == str2) {\n        return true;\n      }\n      if (str.Length != str2.Length) {\n        return false;\n      }\n      int count = str.Length;\n      for (var i = 0; i < count; ++i) {\n        if (str[i] != str2[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static bool CBORMapEquals(\n      IDictionary<CBORObject, CBORObject> mapA,\n      IDictionary<CBORObject, CBORObject> mapB) {\n      if (mapA == null) {\n        return mapB == null;\n      }\n      if (mapB == null) {\n        return false;\n      }\n      if (mapA.Count != mapB.Count) {\n        return false;\n      }\n      foreach (KeyValuePair<CBORObject, CBORObject> kvp in mapA) {\n        CBORObject valueB = null;\n        bool hasKey = mapB.TryGetValue(kvp.Key, out valueB);\n        if (hasKey) {\n          CBORObject valueA = kvp.Value;\n          if (!(valueA == null ? valueB == null : valueA.Equals(valueB))) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static int CBORMapHashCode(IDictionary<CBORObject, CBORObject>\n      a) {\n      // To simplify matters, we use just the count of\n      // the map as the basis for the hash code. More complicated\n      // hash code calculation would involve the sum of the hash codes of\n      // the map's key-value pairs (an approach that works regardless of the order\n      // in which map keys are iterated, because wraparound addition\n      // is commutative and associative), but this could take much more time\n      // to calculate, especially if the keys and values are very big.\n      return unchecked(a.Count.GetHashCode() * 19);\n    }\n\n    private static void CheckCBORLength(\n      long expectedLength,\n      long actualLength) {\n      if (actualLength < expectedLength) {\n        throw new CBORException(\"Premature end of data\");\n      }\n      if (actualLength > expectedLength) {\n        throw new CBORException(\n            \"Too many bytes. There is data beyond the decoded CBOR object.\");\n      }\n    }\n\n    private static void CheckCBORLength(int expectedLength, int\n      actualLength) {\n      if (actualLength < expectedLength) {\n        throw new CBORException(\"Premature end of data\");\n      }\n      if (actualLength > expectedLength) {\n        throw new CBORException(\n            \"Too many bytes. There is data beyond the decoded CBOR object.\");\n      }\n    }\n\n    private static string ExtendedToString(EFloat ef) {\n      if (ef.IsFinite && (ef.Exponent.CompareTo((EInteger)2500) > 0 ||\n          ef.Exponent.CompareTo((EInteger)(-2500)) < 0)) {\n        // It can take very long to convert a number with a very high\n        // or very low exponent to a decimal string, so do this instead\n        return ef.Mantissa + \"p\" + ef.Exponent;\n      }\n      return ef.ToString();\n    }\n\n    private static byte[] GetOptimizedBytesIfShortAscii(\n      string str,\n      int tagbyteInt) {\n      byte[] bytes;\n      if (str.Length <= 255) {\n        // The strings will usually be short ASCII strings, so\n        // use this optimization\n        var offset = 0;\n        int length = str.Length;\n        int extra = (length < 24) ? 1 : 2;\n        if (tagbyteInt >= 0) {\n          ++extra;\n        }\n        bytes = new byte[length + extra];\n        if (tagbyteInt >= 0) {\n          bytes[offset] = (byte)tagbyteInt;\n          ++offset;\n        }\n        if (length < 24) {\n          bytes[offset] = (byte)(0x60 + str.Length);\n          ++offset;\n        } else {\n          bytes[offset] = (byte)0x78;\n          bytes[offset + 1] = (byte)str.Length;\n          offset += 2;\n        }\n        var issimple = true;\n        for (var i = 0; i < str.Length; ++i) {\n          char c = str[i];\n          if (c >= 0x80) {\n            issimple = false;\n            break;\n          }\n          bytes[i + offset] = unchecked((byte)c);\n        }\n        if (issimple) {\n          return bytes;\n        }\n      }\n      return null;\n    }\n\n    private static string GetOptimizedStringIfShortAscii(\n      byte[] data,\n      int offset) {\n      int length = data.Length;\n      if (length > offset) {\n        var nextbyte = (int)(data[offset] & (int)0xff);\n        if (nextbyte >= 0x60 && nextbyte < 0x78) {\n          int offsetp1 = 1 + offset;\n          // Check for type 3 string of short length\n          int rightLength = offsetp1 + (nextbyte - 0x60);\n          CheckCBORLength(\n            rightLength,\n            length);\n          // Check for all ASCII text\n          for (int i = offsetp1; i < length; ++i) {\n            if ((data[i] & ((byte)0x80)) != 0) {\n              return null;\n            }\n          }\n          // All ASCII text, so convert to a text string\n          // from a char array without having to\n          // convert from UTF-8 first\n          var c = new char[length - offsetp1];\n          for (int i = offsetp1; i < length; ++i) {\n            c[i - offsetp1] = (char)(data[i] & (int)0xff);\n          }\n          return new String(c);\n        }\n      }\n      return null;\n    }\n\n    private static byte[] SerializeUtf8(byte[] utf8) {\n      byte[] bytes;\n      if (utf8.Length < 24) {\n        bytes = new byte[utf8.Length + 1];\n        bytes[0] = (byte)(utf8.Length | 0x60);\n        Array.Copy(utf8, 0, bytes, 1, utf8.Length);\n        return bytes;\n      }\n      if (utf8.Length <= 0xffL) {\n        bytes = new byte[utf8.Length + 2];\n        bytes[0] = (byte)0x78;\n        bytes[1] = (byte)utf8.Length;\n        Array.Copy(utf8, 0, bytes, 2, utf8.Length);\n        return bytes;\n      }\n      if (utf8.Length <= 0xffffL) {\n        bytes = new byte[utf8.Length + 3];\n        bytes[0] = (byte)0x79;\n        bytes[1] = (byte)((utf8.Length >> 8) & 0xff);\n        bytes[2] = (byte)(utf8.Length & 0xff);\n        Array.Copy(utf8, 0, bytes, 3, utf8.Length);\n        return bytes;\n      }\n      byte[] posbytes = GetPositiveInt64Bytes(3, utf8.Length);\n      bytes = new byte[utf8.Length + posbytes.Length];\n      Array.Copy(posbytes, 0, bytes, 0, posbytes.Length);\n      Array.Copy(utf8, 0, bytes, posbytes.Length, utf8.Length);\n      return bytes;\n    }\n\n    private static byte[] GetPositiveInt64Bytes(int type, long value) {\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value + \") is less than \" +\n          \"0\");\n      }\n      if (value < 24) {\n        return new[] { (byte)((byte)value | (byte)(type << 5)) };\n      }\n      if (value <= 0xffL) {\n        return new[] {\n          (byte)(24 | (type << 5)), (byte)(value & 0xff),\n        };\n      }\n      if (value <= 0xffffL) {\n        return new[] {\n          (byte)(25 | (type << 5)),\n          (byte)((value >> 8) & 0xff), (byte)(value & 0xff),\n        };\n      }\n      if (value <= 0xffffffffL) {\n        return new[] {\n          (byte)(26 | (type << 5)),\n          (byte)((value >> 24) & 0xff), (byte)((value >> 16) & 0xff),\n          (byte)((value >> 8) & 0xff), (byte)(value & 0xff),\n        };\n      }\n      return new[] {\n        (byte)(27 | (type << 5)), (byte)((value >> 56) & 0xff),\n        (byte)((value >> 48) & 0xff), (byte)((value >> 40) & 0xff),\n        (byte)((value >> 32) & 0xff), (byte)((value >> 24) & 0xff),\n        (byte)((value >> 16) & 0xff), (byte)((value >> 8) & 0xff),\n        (byte)(value & 0xff),\n      };\n    }\n\n    private static byte[] GetPositiveIntBytes(int type, int value) {\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value + \") is less than \" +\n          \"0\");\n      }\n      if (value < 24) {\n        return new[] { (byte)((byte)value | (byte)(type << 5)) };\n      }\n      if (value <= 0xff) {\n        return new[] {\n          (byte)(24 | (type << 5)), (byte)(value & 0xff),\n        };\n      }\n      if (value <= 0xffff) {\n        return new[] {\n          (byte)(25 | (type << 5)),\n          (byte)((value >> 8) & 0xff), (byte)(value & 0xff),\n        };\n      }\n      return new[] {\n        (byte)(26 | (type << 5)), (byte)((value >> 24) & 0xff),\n        (byte)((value >> 16) & 0xff), (byte)((value >> 8) & 0xff),\n        (byte)(value & 0xff),\n      };\n    }\n\n    // Initialize fixed values for certain\n    // head bytes\n    private static CBORObject[] InitializeFixedObjects() {\n      var fixedObjects = new CBORObject[256];\n      for (var i = 0; i < 0x18; ++i) {\n        fixedObjects[i] = new CBORObject(CBORObjectTypeInteger, (long)i);\n      }\n      for (int i = 0x20; i < 0x38; ++i) {\n        fixedObjects[i] = new CBORObject(\n          CBORObjectTypeInteger,\n          (long)(-1 - (i - 0x20)));\n      }\n      fixedObjects[0x60] = new CBORObject(\n        CBORObjectTypeTextString,\n        String.Empty);\n      for (int i = 0xe0; i < 0xf8; ++i) {\n        fixedObjects[i] = new CBORObject(\n          CBORObjectTypeSimpleValue,\n          (int)(i - 0xe0));\n      }\n      return fixedObjects;\n    }\n\n    private static int ListCompare(\n      IList<CBORObject> listA,\n      IList<CBORObject> listB) {\n      if (listA == null) {\n        return (listB == null) ? 0 : -1;\n      }\n      if (listB == null) {\n        return 1;\n      }\n      int listACount = listA.Count;\n      int listBCount = listB.Count;\n      // NOTE: Compare list counts to conform\n      // to bytewise lexicographical ordering\n      if (listACount != listBCount) {\n        return listACount < listBCount ? -1 : 1;\n      }\n      for (var i = 0; i < listACount; ++i) {\n        int cmp = listA[i].CompareTo(listB[i]);\n        if (cmp != 0) {\n          return cmp;\n        }\n      }\n      return 0;\n    }\n\n    private static EInteger LowHighToEInteger(int tagLow, int tagHigh) {\n      byte[] uabytes = null;\n      if (tagHigh != 0) {\n        uabytes = new byte[9];\n        uabytes[7] = (byte)((tagHigh >> 24) & 0xff);\n        uabytes[6] = (byte)((tagHigh >> 16) & 0xff);\n        uabytes[5] = (byte)((tagHigh >> 8) & 0xff);\n        uabytes[4] = (byte)(tagHigh & 0xff);\n        uabytes[3] = (byte)((tagLow >> 24) & 0xff);\n        uabytes[2] = (byte)((tagLow >> 16) & 0xff);\n        uabytes[1] = (byte)((tagLow >> 8) & 0xff);\n        uabytes[0] = (byte)(tagLow & 0xff);\n        uabytes[8] = 0;\n        return EInteger.FromBytes(uabytes, true);\n      }\n      if (tagLow != 0) {\n        uabytes = new byte[5];\n        uabytes[3] = (byte)((tagLow >> 24) & 0xff);\n        uabytes[2] = (byte)((tagLow >> 16) & 0xff);\n        uabytes[1] = (byte)((tagLow >> 8) & 0xff);\n        uabytes[0] = (byte)(tagLow & 0xff);\n        uabytes[4] = 0;\n        return EInteger.FromBytes(uabytes, true);\n      }\n      return EInteger.Zero;\n    }\n\n    private static int MapCompare(\n      IDictionary<CBORObject, CBORObject> mapA,\n      IDictionary<CBORObject, CBORObject> mapB) {\n      if (mapA == null) {\n        return (mapB == null) ? 0 : -1;\n      }\n      if (mapB == null) {\n        return 1;\n      }\n      if (mapA == mapB) {\n        return 0;\n      }\n      int listACount = mapA.Count;\n      int listBCount = mapB.Count;\n      if (listACount == 0 && listBCount == 0) {\n        return 0;\n      }\n      if (listACount == 0) {\n        return -1;\n      }\n      if (listBCount == 0) {\n        return 1;\n      }\n      // NOTE: Compare map key counts to conform\n      // to bytewise lexicographical ordering\n      if (listACount != listBCount) {\n        return listACount < listBCount ? -1 : 1;\n      }\n      var sortedASet = new List<CBORObject>(mapA.Keys);\n      var sortedBSet = new List<CBORObject>(mapB.Keys);\n      // DebugUtility.Log(\"---sorting mapA's keys\");\n      sortedASet.Sort();\n      // DebugUtility.Log(\"---sorting mapB's keys\");\n      sortedBSet.Sort();\n      // DebugUtility.Log(\"---done sorting\");\n      listACount = sortedASet.Count;\n      listBCount = sortedBSet.Count;\n      // Compare the keys\n      /* for (var i = 0; i < listACount; ++i) {\n        string str = sortedASet[i].ToString();\n        str = str.Substring(0, Math.Min(100, str.Length));\n        DebugUtility.Log(\"A \" + i + \"=\" + str);\n      }\n      for (var i = 0; i < listBCount; ++i) {\n        string str = sortedBSet[i].ToString();\n        str = str.Substring(0, Math.Min(100, str.Length));\n        DebugUtility.Log(\"B \" + i + \"=\" + str);\n      }*/\n      for (var i = 0; i < listACount; ++i) {\n        CBORObject itemA = sortedASet[i];\n        CBORObject itemB = sortedBSet[i];\n        if (itemA == null) {\n          return -1;\n        }\n        int cmp = itemA.CompareTo(itemB);\n        // string ot = itemA + \"/\" +\n        // (cmp != 0 ? itemB.ToString() : \"~\") +\n        // \" -> cmp=\" + (cmp);\n        // DebugUtility.Log(ot);\n        if (cmp != 0) {\n          return cmp;\n        }\n        // Both maps have the same key, so compare\n        // the value under that key\n        cmp = mapA[itemA].CompareTo(mapB[itemB]);\n        // DebugUtility.Log(itemA + \"/~\" +\n        // \" -> \"+mapA[itemA]+\", \"+(cmp != 0 ? mapB[itemB].ToString() :\n        // \"~\") + \" -> cmp=\" + cmp);\n        if (cmp != 0) {\n          return cmp;\n        }\n      }\n      return 0;\n    }\n\n    private static IList<object> PushObject(\n      IList<object> stack,\n      object parent,\n      object child) {\n      if (stack == null) {\n        stack = new List<object>(4);\n        stack.Add(parent);\n      }\n      foreach (object o in stack) {\n        if (o == child) {\n          throw new ArgumentException(\"Circular reference in data\" +\n            \"\\u0020structure\");\n        }\n      }\n      stack.Add(child);\n      return stack;\n    }\n\n    private static int TagsCompare(EInteger[] tagsA, EInteger[] tagsB) {\n      if (tagsA == null) {\n        return (tagsB == null) ? 0 : -1;\n      }\n      if (tagsB == null) {\n        return 1;\n      }\n      int listACount = tagsA.Length;\n      int listBCount = tagsB.Length;\n      int c = Math.Min(listACount, listBCount);\n      for (var i = 0; i < c; ++i) {\n        int cmp = tagsA[i].CompareTo(tagsB[i]);\n        if (cmp != 0) {\n          return cmp;\n        }\n      }\n      return (listACount != listBCount) ? ((listACount < listBCount) ? -1 : 1) :\n        0;\n    }\n\n    private static IList<object> WriteChildObject(\n      object parentThisItem,\n      CBORObject child,\n      Stream outputStream,\n      IList<object> stack,\n      CBOREncodeOptions options) {\n      if (child == null) {\n        outputStream.WriteByte(0xf6);\n      } else {\n        int type = child.ItemType;\n        if (type == CBORObjectTypeArray) {\n          stack = PushObject(stack, parentThisItem, child.ThisItem);\n          child.WriteTags(outputStream);\n          WriteObjectArray(child.AsList(), outputStream, stack, options);\n          stack.RemoveAt(stack.Count - 1);\n        } else if (type == CBORObjectTypeMap) {\n          stack = PushObject(stack, parentThisItem, child.ThisItem);\n          child.WriteTags(outputStream);\n          WriteObjectMap(child.AsMap(), outputStream, stack, options);\n          stack.RemoveAt(stack.Count - 1);\n        } else {\n          child.WriteTo(outputStream, options);\n        }\n      }\n      return stack;\n    }\n\n    private static void WriteObjectArray(\n      IList<CBORObject> list,\n      Stream outputStream,\n      CBOREncodeOptions options) {\n      WriteObjectArray(list, outputStream, null, options);\n    }\n\n    private static void WriteObjectArray(\n      IList<CBORObject> list,\n      Stream outputStream,\n      IList<object> stack,\n      CBOREncodeOptions options) {\n      object thisObj = list;\n      WritePositiveInt(4, list.Count, outputStream);\n      foreach (CBORObject i in list) {\n        stack = WriteChildObject(thisObj, i, outputStream, stack, options);\n      }\n    }\n\n    private static void WriteObjectMap(\n      IDictionary<CBORObject, CBORObject> map,\n      Stream outputStream,\n      CBOREncodeOptions options) {\n      WriteObjectMap(map, outputStream, null, options);\n    }\n\n    private static void WriteObjectMap(\n      IDictionary<CBORObject, CBORObject> map,\n      Stream outputStream,\n      IList<object> stack,\n      CBOREncodeOptions options) {\n      object thisObj = map;\n      WritePositiveInt(5, map.Count, outputStream);\n      foreach (KeyValuePair<CBORObject, CBORObject> entry in map) {\n        CBORObject key = entry.Key;\n        CBORObject value = entry.Value;\n        stack = WriteChildObject(\n            thisObj,\n            key,\n            outputStream,\n            stack,\n            options);\n        stack = WriteChildObject(\n            thisObj,\n            value,\n            outputStream,\n            stack,\n            options);\n      }\n    }\n\n    private static int WritePositiveInt(int type, int value, Stream s) {\n      byte[] bytes = GetPositiveIntBytes(type, value);\n      s.Write(bytes, 0, bytes.Length);\n      return bytes.Length;\n    }\n\n    private static int WritePositiveInt64(int type, long value, Stream s) {\n      byte[] bytes = GetPositiveInt64Bytes(type, value);\n      s.Write(bytes, 0, bytes.Length);\n      return bytes.Length;\n    }\n\n    private static void WriteStreamedString(string str, Stream stream) {\n      byte[] bytes;\n      bytes = GetOptimizedBytesIfShortAscii(str, -1);\n      if (bytes != null) {\n        stream.Write(bytes, 0, bytes.Length);\n        return;\n      }\n      // Take string's length into account when allocating\n      // stream buffer, in case it's much smaller than the usual stream\n      // string buffer length and to improve performance on small strings\n      int bufferLength = Math.Min(StreamedStringBufferLength, str.Length);\n      if (bufferLength < StreamedStringBufferLength) {\n        bufferLength = Math.Min(\n            StreamedStringBufferLength,\n            bufferLength * 3);\n      }\n      bytes = new byte[bufferLength];\n      var byteIndex = 0;\n      var streaming = false;\n      for (int index = 0; index < str.Length; ++index) {\n        int c = str[index];\n        if (c <= 0x7f) {\n          if (byteIndex >= StreamedStringBufferLength) {\n            // Write bytes retrieved so far\n            if (!streaming) {\n              stream.WriteByte((byte)0x7f);\n            }\n            WritePositiveInt(3, byteIndex, stream);\n            stream.Write(bytes, 0, byteIndex);\n            byteIndex = 0;\n            streaming = true;\n          }\n          bytes[byteIndex++] = (byte)c;\n        } else if (c <= 0x7ff) {\n          if (byteIndex + 2 > StreamedStringBufferLength) {\n            // Write bytes retrieved so far - the next two bytes\n            // would exceed the length, and the CBOR spec forbids\n            // splitting characters when generating text strings\n            if (!streaming) {\n              stream.WriteByte((byte)0x7f);\n            }\n            WritePositiveInt(3, byteIndex, stream);\n            stream.Write(bytes, 0, byteIndex);\n            byteIndex = 0;\n            streaming = true;\n          }\n          bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));\n          bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));\n        } else {\n          if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&\n            (str[index + 1] & 0xfc00) == 0xdc00) {\n            // Get the Unicode code point for the surrogate pair\n            c = 0x10000 + ((c & 0x3ff) << 10) + (str[index + 1] & 0x3ff);\n            ++index;\n          } else if ((c & 0xf800) == 0xd800) {\n            // unpaired surrogate, write U+FFFD instead\n            c = 0xfffd;\n          }\n          if (c <= 0xffff) {\n            if (byteIndex + 3 > StreamedStringBufferLength) {\n              // Write bytes retrieved so far - the next three bytes\n              // would exceed the length, and the CBOR spec forbids\n              // splitting characters when generating text strings\n              if (!streaming) {\n                stream.WriteByte((byte)0x7f);\n              }\n              WritePositiveInt(3, byteIndex, stream);\n              stream.Write(bytes, 0, byteIndex);\n              byteIndex = 0;\n              streaming = true;\n            }\n            bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));\n            bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));\n            bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));\n          } else {\n            if (byteIndex + 4 > StreamedStringBufferLength) {\n              // Write bytes retrieved so far - the next four bytes\n              // would exceed the length, and the CBOR spec forbids\n              // splitting characters when generating text strings\n              if (!streaming) {\n                stream.WriteByte((byte)0x7f);\n              }\n              WritePositiveInt(3, byteIndex, stream);\n              stream.Write(bytes, 0, byteIndex);\n              byteIndex = 0;\n              streaming = true;\n            }\n            bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));\n            bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));\n            bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));\n            bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));\n          }\n        }\n      }\n      WritePositiveInt(3, byteIndex, stream);\n      stream.Write(bytes, 0, byteIndex);\n      if (streaming) {\n        stream.WriteByte((byte)0xff);\n      }\n    }\n\n    private int AsInt32(int minValue, int maxValue) {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"not a number type\");\n      }\n      return cn.GetNumberInterface().AsInt32(\n          cn.GetValue(),\n          minValue,\n          maxValue);\n    }\n\n    private void WriteTags(Stream s) {\n      CBORObject curobject = this;\n      while (curobject.IsTagged) {\n        int low = curobject.tagLow;\n        int high = curobject.tagHigh;\n        if (high == 0 && (low >> 16) == 0) {\n          WritePositiveInt(6, low, s);\n        } else if (high == 0) {\n          long value = ((long)low) & 0xffffffffL;\n          WritePositiveInt64(6, value, s);\n        } else if ((high >> 16) == 0) {\n          long value = ((long)low) & 0xffffffffL;\n          long highValue = ((long)high) & 0xffffffffL;\n          value |= highValue << 32;\n          WritePositiveInt64(6, value, s);\n        } else {\n          byte[] arrayToWrite = {\n            (byte)0xdb,\n            (byte)((high >> 24) & 0xff), (byte)((high >> 16) & 0xff),\n            (byte)((high >> 8) & 0xff), (byte)(high & 0xff),\n            (byte)((low >> 24) & 0xff), (byte)((low >> 16) & 0xff),\n            (byte)((low >> 8) & 0xff), (byte)(low & 0xff),\n          };\n          s.Write(arrayToWrite, 0, 9);\n        }\n        curobject = (CBORObject)curobject.itemValue;\n      }\n    }\n  }\n}\n", "/*\nWritten by Peter O.\nAny copyright to this work is released to the Public Domain.\nIn case this is not possible, this work is also\nlicensed under Creative Commons Zero (CC0):\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\n */\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Reflection;\nusing PeterO;\nusing PeterO.Numbers;\n\nnamespace PeterO.Cbor {\n  internal static class PropertyMap {\n    private const int TicksDivFracSeconds =\n      CBORUtilities.FractionalSeconds / 10000000;\n\n    private sealed class OrderedDictionary<TKey, TValue> :\n      IDictionary<TKey, TValue> {\n      // NOTE: Note that this class will be used with CBORObjects, some of which are\n      // mutable. Storing mutable keys in an ordinary Dictionary can cause problems;\n      // for example:\n      // - 'Add'ing a key, then changing it, then calling CompareTo on the changed\n      // key can fail to find the key in the Dictionary, even though the old and new\n      // versions\n      // of the key have the same reference.\n      // - The same can happen if an object that contains a Dictionary is 'Add'ed to\n      // that\n      // Dictionary.\n      private readonly IDictionary<TKey, TValue> dict;\n      private readonly LinkedList<TKey> list;\n      public OrderedDictionary() {\n        this.dict = new Dictionary<TKey, TValue>();\n        this.list = new LinkedList<TKey>();\n      }\n      public void Add(KeyValuePair<TKey, TValue> kvp) {\n        this.Add(kvp.Key, kvp.Value);\n      }\n      public void Add(TKey k, TValue v) {\n        if (this.dict.ContainsKey(k)) {\n          throw new ArgumentException(\"duplicate key\");\n        } else {\n          // CheckKeyDoesNotExist(k);\n          // DebugUtility.Log(\"Adding: \" + (k.GetHashCode()) + \" [Type=\" + (CS(k)) +\n          // \"]\");\n          int keycnt = this.dict.Count;\n          this.dict.Add(k, v);\n          // if (keycnt == this.dict.Count) {\n          // throw new InvalidOperationException();\n          // }\n          this.list.AddLast(k);\n          // CheckKeyExists(k);\n        }\n      }\n      public TValue this[TKey key] {\n        get {\n          TValue v = default(TValue);\n          // NOTE: Don't use dict[key], since if it fails it could\n          // print the key in the exception's message, which could\n          // cause an infinite loop\n          if (!this.dict.TryGetValue(key, out v)) {\n            throw new ArgumentException(\"key not found\");\n          }\n          return v;\n        }\n        set {\n          if (this.dict.ContainsKey(key)) {\n            // DebugUtility.Log(\"Set existing: \" + (key.GetHashCode()) + \" [Type=\" +\n            // (CS(key)) + \"]\");\n            this.dict[key] = value;\n            // CheckKeyExists(key);\n          } else {\n            // DebugUtility.Log(\"Set new: \" + (key.GetHashCode()) + \" [Type=\" + (CS(key))\n            // +\n            // \"]\");\n            this.dict.Add(key, value);\n            this.list.AddLast(key);\n            // CheckKeyExists(key);\n          }\n        }\n      }\n      public void Clear() {\n        this.dict.Clear();\n        this.list.Clear();\n      }\n      public void CopyTo(KeyValuePair<TKey, TValue>[] a, int off) {\n        foreach (var kv in this) {\n          a[off++] = kv;\n        }\n      }\n      public bool Remove(KeyValuePair<TKey, TValue> kvp) {\n        if (this.Contains(kvp)) {\n          // CheckKeyExists(kvp.Key);\n          this.dict.Remove(kvp.Key);\n          this.list.Remove(kvp.Key);\n          return true;\n        }\n        return false;\n      }\n      public bool Remove(TKey key) {\n        if (this.dict.ContainsKey(key)) {\n          // CheckKeyExists(key);\n          this.dict.Remove(key);\n          this.list.Remove(key);\n          return true;\n        }\n        return false;\n      }\n      public bool Contains(KeyValuePair<TKey, TValue> kvp) {\n        if (this.dict.ContainsKey(kvp.Key)) {\n          if (this.dict[kvp.Key].Equals(kvp.Value)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      public bool ContainsKey(TKey key) {\n        return this.dict.ContainsKey(key);\n      }\n      public bool TryGetValue(TKey key, out TValue val) {\n        return this.dict.TryGetValue(key, out val);\n      }\n      public int Count {\n        get {\n          return this.dict.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return false;\n        }\n      }\n\n      [System.Diagnostics.Conditional(\"DEBUG\")]\n      private void CheckKeyExists(TKey key) {\n        TValue v = default(TValue);\n        if (!this.dict.ContainsKey(key)) {\n          /* DebugUtility.Log(\"hash \" + (key.GetHashCode()) + \" [\" +\n          (CS(key)) + \"]\");\n          foreach (var k in this.dict.Keys) {\n            DebugUtility.Log(\n            \"key {0} {1}\" + \"\\u0020\" + \"\\u0020 [{2}]\",\n                k.Equals(key), k.GetHashCode(), CS(k), CS(key),\n              this.dict.ContainsKey(k));\n          } */\n          throw new ArgumentException(\"key not found (ContainsKey)\");\n        }\n        // NOTE: Don't use dict[k], since if it fails it could\n        // print the key in the exception's message, which could\n        // cause an infinite loop\n        if (!this.dict.TryGetValue(key, out v)) {\n          throw new ArgumentException(\"key not found (TryGetValue)\");\n        }\n        if (this.dict.Count != this.list.Count) {\n          throw new InvalidOperationException();\n        }\n      }\n\n      [System.Diagnostics.Conditional(\"DEBUG\")]\n      private void CheckKeyDoesNotExist(TKey key) {\n        TValue v = default(TValue);\n        // NOTE: Don't use dict[k], since if it fails it could\n        // print the key in the exception's message, which could\n        // cause an infinite loop\n        if (!this.dict.TryGetValue(key, out v)) {\n          return;\n        }\n        throw new ArgumentException(\"key found\");\n      }\n\n      public ICollection<TKey> Keys {\n        get {\n          return new KeyWrapper<TKey, TValue>(this.dict, this.list);\n        }\n      }\n\n      public ICollection<TValue> Values {\n        get {\n          return new ValueWrapper<TKey, TValue>(this.dict, this.list);\n        }\n      }\n\n      private IEnumerable<KeyValuePair<TKey, TValue>> Iterate() {\n        foreach (var k in this.list) {\n          TValue v = default(TValue);\n          // DebugUtility.Log(\"Enumerating: \" + (k.GetHashCode()) + \" [Type=\" + ((k as\n          // CBORObject).Type) + \"]\");\n          // NOTE: Don't use dict[k], since if it fails it could\n          // print the key in the exception's message, which could\n          // cause an infinite loop\n          if (!this.dict.TryGetValue(k, out v)) {\n            throw new ArgumentException(\"key not found\");\n          }\n          yield return new KeyValuePair<TKey, TValue>(k, v);\n        }\n      }\n\n      public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() {\n        return this.Iterate().GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.Iterate()).GetEnumerator();\n      }\n    }\n\n    private sealed class ValueWrapper<TKey, TValue> : ICollection<TValue> {\n      private readonly IDictionary<TKey, TValue> dict;\n      private readonly LinkedList<TKey> list;\n      public ValueWrapper(IDictionary<TKey, TValue> dict, LinkedList<TKey>\n        list) {\n        this.dict = dict;\n        this.list = list;\n      }\n      public void Add(TValue v) {\n        throw new NotSupportedException();\n      }\n      public void Clear() {\n        throw new NotSupportedException();\n      }\n      public void CopyTo(TValue[] a, int off) {\n        foreach (var k in this.list) {\n          a[off++] = this.dict[k];\n        }\n      }\n      public bool Remove(TValue v) {\n        throw new NotSupportedException();\n      }\n      public bool Contains(TValue v) {\n        foreach (var k in this.list) {\n          if (this.dict[k].Equals(v)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      public int Count {\n        get {\n          return this.dict.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return true;\n        }\n      }\n\n      private IEnumerable<TValue> Iterate() {\n        foreach (var k in this.list) {\n          yield return this.dict[k];\n        }\n      }\n\n      public IEnumerator<TValue> GetEnumerator() {\n        return this.Iterate().GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.Iterate()).GetEnumerator();\n      }\n    }\n\n    private sealed class KeyWrapper<TKey, TValue> : ICollection<TKey> {\n      private readonly IDictionary<TKey, TValue> dict;\n      private readonly LinkedList<TKey> list;\n      public KeyWrapper(IDictionary<TKey, TValue> dict, LinkedList<TKey> list) {\n        this.dict = dict;\n        this.list = list;\n      }\n      public void Add(TKey v) {\n        throw new NotSupportedException();\n      }\n      public void Clear() {\n        throw new NotSupportedException();\n      }\n      public void CopyTo(TKey[] a, int off) {\n        this.list.CopyTo(a, off);\n      }\n      public bool Remove(TKey v) {\n        throw new NotSupportedException();\n      }\n      public bool Contains(TKey v) {\n        return this.dict.ContainsKey(v);\n      }\n      public int Count {\n        get {\n          return this.dict.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return true;\n        }\n      }\n      public IEnumerator<TKey> GetEnumerator() {\n        return this.list.GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.list).GetEnumerator();\n      }\n    }\n\n    private sealed class ReadOnlyWrapper<T> : ICollection<T> {\n      private readonly ICollection<T> o;\n      public ReadOnlyWrapper(ICollection<T> o) {\n        this.o = o;\n      }\n      public void Add(T v) {\n        throw new NotSupportedException();\n      }\n      public void Clear() {\n        throw new NotSupportedException();\n      }\n      public void CopyTo(T[] a, int off) {\n        this.o.CopyTo(a, off);\n      }\n      public bool Remove(T v) {\n        throw new NotSupportedException();\n      }\n      public bool Contains(T v) {\n        return this.o.Contains(v);\n      }\n      public int Count {\n        get {\n          return this.o.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return true;\n        }\n      }\n      public IEnumerator<T> GetEnumerator() {\n        return this.o.GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.o).GetEnumerator();\n      }\n    }\n\n    private sealed class PropertyData {\n      private readonly string name;\n      private readonly MemberInfo prop;\n      private readonly string adjustedName;\n      private readonly string adjustedNameCamelCase;\n      public string Name {\n        get {\n          return this.name;\n        }\n      }\n\n      public PropertyData(string name, MemberInfo prop) {\n        this.name = name;\n        this.prop = prop;\n        this.adjustedNameCamelCase = this.GetAdjustedNameInternal(true);\n        this.adjustedName = this.GetAdjustedNameInternal(false);\n      }\n\n      public Type PropertyType {\n        get {\n          var pr = this.prop as PropertyInfo;\n          if (pr != null) {\n            return pr.PropertyType;\n          }\n          var fi = this.prop as FieldInfo;\n          return (fi != null) ? fi.FieldType : null;\n        }\n      }\n\n      public object GetValue(object obj) {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          return pr.GetValue(obj, null);\n        }\n        var fi = this.prop as FieldInfo;\n        return (fi != null) ? fi.GetValue(obj) : null;\n      }\n\n      public void SetValue(object obj, object value) {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          pr.SetValue(obj, value, null);\n        }\n        var fi = this.prop as FieldInfo;\n        if (fi != null) {\n          fi.SetValue(obj, value);\n        }\n      }\n\n      #if NET20 || NET40\n      public static bool HasUsableGetter(PropertyInfo pi) {\n        return pi != null && pi.CanRead && !pi.GetGetMethod().IsStatic &&\n          pi.GetGetMethod().IsPublic;\n      }\n\n      public static bool HasUsableSetter(PropertyInfo pi) {\n        return pi != null && pi.CanWrite && !pi.GetSetMethod().IsStatic &&\n          pi.GetSetMethod().IsPublic;\n      }\n      #else\n      public static bool HasUsableGetter(PropertyInfo pi) {\n        return pi != null && pi.CanRead && !pi.GetMethod.IsStatic &&\n          pi.GetMethod.IsPublic;\n      }\n\n      public static bool HasUsableSetter(PropertyInfo pi) {\n        return pi != null && pi.CanWrite && !pi.SetMethod.IsStatic &&\n          pi.SetMethod.IsPublic;\n      }\n      #endif\n      public bool HasUsableGetter() {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          return HasUsableGetter(pr);\n        }\n        var fi = this.prop as FieldInfo;\n        return fi != null && fi.IsPublic && !fi.IsStatic &&\n          !fi.IsInitOnly && !fi.IsLiteral;\n      }\n\n      public bool HasUsableSetter() {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          return HasUsableSetter(pr);\n        }\n        var fi = this.prop as FieldInfo;\n        return fi != null && fi.IsPublic && !fi.IsStatic &&\n          !fi.IsInitOnly && !fi.IsLiteral;\n      }\n\n      public string GetAdjustedName(bool useCamelCase) {\n        return useCamelCase ? this.adjustedNameCamelCase :\n          this.adjustedName;\n      }\n\n      public string GetAdjustedNameInternal(bool useCamelCase) {\n        string thisName = this.Name;\n        if (useCamelCase) {\n          if (CBORUtilities.NameStartsWithWord(thisName, \"Is\")) {\n            thisName = thisName.Substring(2);\n          }\n          thisName = CBORUtilities.FirstCharLower(thisName);\n        } else {\n          thisName = CBORUtilities.FirstCharUpper(thisName);\n        }\n        return thisName;\n      }\n\n      public MemberInfo Prop {\n        get {\n          return this.prop;\n        }\n      }\n    }\n\n    #if NET40 || NET20\n    private static bool IsGenericType(Type type) {\n      return type.IsGenericType;\n    }\n\n    private static bool IsClassOrValueType(Type type) {\n      return type.IsClass || type.IsValueType;\n    }\n\n    private static Type FirstGenericArgument(Type type) {\n      return type.GetGenericArguments()[0];\n    }\n\n    private static IEnumerable<PropertyInfo> GetTypeProperties(Type t) {\n      return t.GetProperties(BindingFlags.Public |\n          BindingFlags.Instance);\n    }\n\n    private static IEnumerable<FieldInfo> GetTypeFields(Type t) {\n      return t.GetFields(BindingFlags.Public | BindingFlags.Instance);\n    }\n\n    private static IEnumerable<Type> GetTypeInterfaces(Type t) {\n      return t.GetInterfaces();\n    }\n\n    private static bool IsAssignableFrom(Type superType, Type subType) {\n      return superType.IsAssignableFrom(subType);\n    }\n\n    private static MethodInfo GetTypeMethod(\n      Type t,\n      string name,\n      Type[] parameters) {\n      return t.GetMethod(name, parameters);\n    }\n\n    private static bool HasCustomAttribute(\n      Type t,\n      string name) {\n      foreach (var attr in t.GetCustomAttributes(false)) {\n        if (attr.GetType().FullName.Equals(name,\n            StringComparison.Ordinal)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    #else\n    private static bool IsGenericType(Type type) {\n      return type.GetTypeInfo().IsGenericType;\n    }\n\n    private static bool IsClassOrValueType(Type type) {\n      return type.GetTypeInfo().IsClass || type.GetTypeInfo().IsValueType;\n    }\n\n    private static Type FirstGenericArgument(Type type) {\n      return type.GenericTypeArguments[0];\n    }\n\n    private static bool IsAssignableFrom(Type superType, Type subType) {\n      return superType.GetTypeInfo().IsAssignableFrom(subType.GetTypeInfo());\n    }\n\n    private static IEnumerable<PropertyInfo> GetTypeProperties(Type t) {\n      return t.GetRuntimeProperties();\n    }\n\n    private static IEnumerable<FieldInfo> GetTypeFields(Type t) {\n      return t.GetRuntimeFields();\n    }\n\n    private static IEnumerable<Type> GetTypeInterfaces(Type t) {\n      return t.GetTypeInfo().ImplementedInterfaces;\n    }\n\n    private static MethodInfo GetTypeMethod(\n      Type t,\n      string name,\n      Type[] parameters) {\n      return t.GetRuntimeMethod(name, parameters);\n    }\n\n    private static bool HasCustomAttribute(\n      Type t,\n      string name) {\n      foreach (var attr in t.GetTypeInfo().GetCustomAttributes()) {\n        if (attr.GetType().FullName.Equals(name, StringComparison.Ordinal)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    #endif\n\n    // Give each thread its own version of propertyLists using ThreadStatic\n    [ThreadStatic]\n    private static IDictionary<Type, IList<PropertyData>>\n    propertyLists;\n\n    private static string RemoveIsPrefix(string pn) {\n      return CBORUtilities.NameStartsWithWord(pn, \"Is\") ? pn.Substring(2) :\n        pn;\n    }\n\n    private static IList<PropertyData> GetPropertyList(Type t) {\n      {\n        IList<PropertyData> ret = new List<PropertyData>();\n        propertyLists = propertyLists ?? new Dictionary<Type, IList<PropertyData>>();\n        if (propertyLists.ContainsKey(t)) {\n          return propertyLists[t];\n        }\n        bool anonymous = HasCustomAttribute(\n            t,\n            \"System.Runtime.CompilerServices.CompilerGeneratedAttribute\") ||\n          HasCustomAttribute(\n            t,\n            \"Microsoft.FSharp.Core.CompilationMappingAttribute\");\n        var names = new SortedDictionary<string, int>();\n        foreach (PropertyInfo pi in GetTypeProperties(t)) {\n          var pn = RemoveIsPrefix(pi.Name);\n          if (names.ContainsKey(pn)) {\n            ++names[pn];\n          } else {\n            names[pn] = 1;\n          }\n        }\n        foreach (FieldInfo pi in GetTypeFields(t)) {\n          var pn = RemoveIsPrefix(pi.Name);\n          if (names.ContainsKey(pn)) {\n            ++names[pn];\n          } else {\n            names[pn] = 1;\n          }\n        }\n        foreach (FieldInfo fi in GetTypeFields(t)) {\n          PropertyData pd = new PropertyMap.PropertyData(fi.Name, fi);\n          if (pd.HasUsableGetter() || pd.HasUsableSetter()) {\n            var pn = RemoveIsPrefix(pd.Name);\n            // Ignore ambiguous properties\n            if (names.ContainsKey(pn) && names[pn] > 1) {\n              continue;\n            }\n            ret.Add(pd);\n          }\n        }\n        foreach (PropertyInfo pi in GetTypeProperties(t)) {\n          if (pi.CanRead && (pi.CanWrite || anonymous) &&\n            pi.GetIndexParameters().Length == 0) {\n            if (PropertyData.HasUsableGetter(pi) ||\n              PropertyData.HasUsableSetter(pi)) {\n              var pn = RemoveIsPrefix(pi.Name);\n              // Ignore ambiguous properties\n              if (names.ContainsKey(pn) && names[pn] > 1) {\n                continue;\n              }\n              PropertyData pd = new PropertyMap.PropertyData(pi.Name, pi);\n              ret.Add(pd);\n            }\n          }\n        }\n        propertyLists.Add(\n          t,\n          ret);\n        return ret;\n      }\n    }\n\n    public static IList<CBORObject> ListFromArray(CBORObject[] array) {\n      return new List<CBORObject>(array);\n    }\n\n    public static bool ExceedsKnownLength(Stream inStream, long size) {\n      return (inStream is MemoryStream) && (size > (inStream.Length -\n            inStream.Position));\n    }\n\n    public static void SkipStreamToEnd(Stream inStream) {\n      if (inStream is MemoryStream) {\n        inStream.Position = inStream.Length;\n      }\n    }\n\n    public static bool FirstElement(int[] dimensions) {\n      foreach (var d in dimensions) {\n        if (d == 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    public static bool NextElement(int[] index, int[] dimensions) {\n      for (var i = dimensions.Length - 1; i >= 0; --i) {\n        if (dimensions[i] > 0) {\n          ++index[i];\n          if (index[i] >= dimensions[i]) {\n            index[i] = 0;\n          } else {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    public static CBORObject BuildCBORArray(int[] dimensions) {\n      int zeroPos = dimensions.Length;\n      for (var i = 0; i < dimensions.Length; ++i) {\n        if (dimensions[i] == 0) {\n          {\n            zeroPos = i;\n          }\n          break;\n        }\n      }\n      int arraydims = zeroPos - 1;\n      if (arraydims <= 0) {\n        return CBORObject.NewArray();\n      }\n      var stack = new CBORObject[zeroPos];\n      var index = new int[zeroPos];\n      var stackpos = 0;\n      CBORObject ret = CBORObject.NewArray();\n      stack[0] = ret;\n      index[0] = 0;\n      for (var i = 0; i < dimensions[0]; ++i) {\n        ret.Add(CBORObject.NewArray());\n      }\n      ++stackpos;\n      while (stackpos > 0) {\n        int curindex = index[stackpos - 1];\n        if (curindex < stack[stackpos - 1].Count) {\n          CBORObject subobj = stack[stackpos - 1][curindex];\n          if (stackpos < zeroPos) {\n            stack[stackpos] = subobj;\n            index[stackpos] = 0;\n            for (var i = 0; i < dimensions[stackpos]; ++i) {\n              subobj.Add(CBORObject.NewArray());\n            }\n            ++index[stackpos - 1];\n            ++stackpos;\n          } else {\n            ++index[stackpos - 1];\n          }\n        } else {\n          --stackpos;\n        }\n      }\n      return ret;\n    }\n\n    public static CBORObject FromArray(\n      Object arrObj,\n      PODOptions options,\n      CBORTypeMapper mapper,\n      int depth) {\n      var arr = (Array)arrObj;\n      int rank = arr.Rank;\n      if (rank == 0) {\n        return CBORObject.NewArray();\n      }\n      CBORObject obj = null;\n      if (rank == 1) {\n        // Most common case: the array is one-dimensional\n        obj = CBORObject.NewArray();\n        int len = arr.GetLength(0);\n        for (var i = 0; i < len; ++i) {\n          obj.Add(\n            CBORObject.FromObject(\n              arr.GetValue(i),\n              options,\n              mapper,\n              depth + 1));\n        }\n        return obj;\n      }\n      var index = new int[rank];\n      var dimensions = new int[rank];\n      for (var i = 0; i < rank; ++i) {\n        dimensions[i] = arr.GetLength(i);\n      }\n      if (!FirstElement(dimensions)) {\n        return obj;\n      }\n      obj = BuildCBORArray(dimensions);\n      do {\n        CBORObject o = CBORObject.FromObject(\n            arr.GetValue(index),\n            options,\n            mapper,\n            depth + 1);\n        SetCBORObject(obj, index, o);\n      } while (NextElement(index, dimensions));\n      return obj;\n    }\n\n    private static CBORObject GetCBORObject(CBORObject cbor, int[] index) {\n      CBORObject ret = cbor;\n      foreach (var i in index) {\n        ret = ret[i];\n      }\n      return ret;\n    }\n\n    private static void SetCBORObject(\n      CBORObject cbor,\n      int[] index,\n      CBORObject obj) {\n      CBORObject ret = cbor;\n      for (var i = 0; i < index.Length - 1; ++i) {\n        ret = ret[index[i]];\n      }\n      int ilen = index[index.Length - 1];\n      while (ilen >= ret.Count) {\n        {\n          ret.Add(CBORObject.Null);\n        }\n      }\n      ret[ilen] = obj;\n    }\n\n    public static Array FillArray(\n      Array arr,\n      Type elementType,\n      CBORObject cbor,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      int rank = arr.Rank;\n      if (rank == 0) {\n        return arr;\n      }\n      if (rank == 1) {\n        int len = arr.GetLength(0);\n        for (var i = 0; i < len; ++i) {\n          object item = cbor[i].ToObject(\n              elementType,\n              mapper,\n              options,\n              depth + 1);\n          arr.SetValue(\n            item,\n            i);\n        }\n        return arr;\n      }\n      var index = new int[rank];\n      var dimensions = new int[rank];\n      for (var i = 0; i < rank; ++i) {\n        dimensions[i] = arr.GetLength(i);\n      }\n      if (!FirstElement(dimensions)) {\n        return arr;\n      }\n      do {\n        object item = GetCBORObject(\n            cbor,\n            index).ToObject(\n            elementType,\n            mapper,\n            options,\n            depth + 1);\n        arr.SetValue(\n          item,\n          index);\n      } while (NextElement(index, dimensions));\n      return arr;\n    }\n\n    public static int[] GetDimensions(CBORObject obj) {\n      if (obj.Type != CBORType.Array) {\n        throw new CBORException();\n      }\n      // Common cases\n      if (obj.Count == 0) {\n        return new int[] { 0 };\n      }\n      if (obj[0].Type != CBORType.Array) {\n        return new int[] { obj.Count };\n      }\n      // Complex cases\n      var list = new List<int>();\n      list.Add(obj.Count);\n      while (obj.Type == CBORType.Array &&\n        obj.Count > 0 && obj[0].Type == CBORType.Array) {\n        list.Add(obj[0].Count);\n        obj = obj[0];\n      }\n      return list.ToArray();\n    }\n\n    public static object ObjectToEnum(CBORObject obj, Type enumType) {\n      Type utype = Enum.GetUnderlyingType(enumType);\n      object ret = null;\n      if (obj.IsNumber && obj.AsNumber().IsInteger()) {\n        ret = Enum.ToObject(enumType, TypeToIntegerObject(obj, utype));\n        if (!Enum.IsDefined(enumType, ret)) {\n          string estr = ret.ToString();\n          if (estr == null || estr.Length == 0 || estr[0] == '-' ||\n            (estr[0] >= '0' && estr[0] <= '9')) {\n            throw new CBORException(\"Unrecognized enum value: \" +\n              obj.ToString());\n          }\n        }\n        return ret;\n      } else if (obj.Type == CBORType.TextString) {\n        var nameString = obj.AsString();\n        foreach (var name in Enum.GetNames(enumType)) {\n          if (nameString.Equals(name, StringComparison.Ordinal)) {\n            return Enum.Parse(enumType, name);\n          }\n        }\n        throw new CBORException(\"Not found: \" + obj.ToString());\n      } else {\n        throw new CBORException(\"Unrecognized enum value: \" +\n          obj.ToString());\n      }\n    }\n\n    public static object EnumToObject(Enum value) {\n      return value.ToString();\n    }\n\n    public static object EnumToObjectAsInteger(Enum value) {\n      Type t = Enum.GetUnderlyingType(value.GetType());\n      if (t.Equals(typeof(ulong))) {\n        ulong uvalue = Convert.ToUInt64(value,\n            CultureInfo.InvariantCulture);\n        return EInteger.FromUInt64(uvalue);\n      }\n      return t.Equals(typeof(long)) ? Convert.ToInt64(value,\n          CultureInfo.InvariantCulture) : (t.Equals(typeof(uint)) ?\n          Convert.ToInt64(value,\n            CultureInfo.InvariantCulture) :\n          Convert.ToInt32(value, CultureInfo.InvariantCulture));\n    }\n\n    public static ICollection<KeyValuePair<TKey, TValue>>\n    GetEntries<TKey, TValue>(\n      IDictionary<TKey, TValue> dict) {\n      var c = (ICollection<KeyValuePair<TKey, TValue>>)dict;\n      return new ReadOnlyWrapper<KeyValuePair<TKey, TValue>>(c);\n    }\n\n    public static IDictionary<CBORObject, CBORObject> NewOrderedDict() {\n      return new OrderedDictionary<CBORObject, CBORObject>();\n    }\n\n    public static object FindOneArgumentMethod(\n      object obj,\n      string name,\n      Type argtype) {\n      return GetTypeMethod(obj.GetType(), name, new[] { argtype });\n    }\n\n    public static object InvokeOneArgumentMethod(\n      object methodInfo,\n      object obj,\n      object argument) {\n      var mi = (MethodInfo)methodInfo;\n      return mi.Invoke(obj, new[] { argument });\n    }\n\n    public static byte[] UUIDToBytes(Guid guid) {\n      var bytes2 = new byte[16];\n      var bytes = guid.ToByteArray();\n      Array.Copy(bytes, bytes2, 16);\n      // Swap the bytes to conform with the UUID RFC\n      bytes2[0] = bytes[3];\n      bytes2[1] = bytes[2];\n      bytes2[2] = bytes[1];\n      bytes2[3] = bytes[0];\n      bytes2[4] = bytes[5];\n      bytes2[5] = bytes[4];\n      bytes2[6] = bytes[7];\n      bytes2[7] = bytes[6];\n      return bytes2;\n    }\n\n    private static bool StartsWith(string str, string pfx) {\n      return str != null && str.Length >= pfx.Length &&\n        str.Substring(0, pfx.Length).Equals(pfx, StringComparison.Ordinal);\n    }\n\n    // TODO: Replace* Legacy with AsNumber methods\n    // in next major version\n    private static object TypeToIntegerObject(CBORObject objThis, Type t) {\n      if (t.Equals(typeof(int))) {\n        return objThis.AsInt32();\n      }\n      if (t.Equals(typeof(short))) {\n        return objThis.AsNumber().ToInt16Checked();\n      }\n      if (t.Equals(typeof(ushort))) {\n        return objThis.AsUInt16Legacy();\n      }\n      if (t.Equals(typeof(byte))) {\n        return objThis.AsByteLegacy();\n      }\n      if (t.Equals(typeof(sbyte))) {\n        return objThis.AsSByteLegacy();\n      }\n      if (t.Equals(typeof(long))) {\n        return objThis.AsNumber().ToInt64Checked();\n      }\n      if (t.Equals(typeof(uint))) {\n        return objThis.AsUInt32Legacy();\n      }\n      if (t.Equals(typeof(ulong))) {\n        return objThis.AsUInt64Legacy();\n      }\n      throw new CBORException(\"Type not supported\");\n    }\n\n    public static object TypeToObject(\n      CBORObject objThis,\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      if (t.Equals(typeof(int))) {\n        return objThis.AsInt32();\n      }\n      if (t.Equals(typeof(short))) {\n        return objThis.AsNumber().ToInt16Checked();\n      }\n      if (t.Equals(typeof(ushort))) {\n        return objThis.AsUInt16Legacy();\n      }\n      if (t.Equals(typeof(byte))) {\n        return objThis.AsByteLegacy();\n      }\n      if (t.Equals(typeof(sbyte))) {\n        return objThis.AsSByteLegacy();\n      }\n      if (t.Equals(typeof(long))) {\n        return objThis.AsNumber().ToInt64Checked();\n      }\n      if (t.Equals(typeof(uint))) {\n        return objThis.AsUInt32Legacy();\n      }\n      if (t.Equals(typeof(ulong))) {\n        return objThis.AsUInt64Legacy();\n      }\n      if (t.Equals(typeof(double))) {\n        return objThis.AsDouble();\n      }\n      if (t.Equals(typeof(decimal))) {\n        return objThis.AsDecimalLegacy();\n      }\n      if (t.Equals(typeof(float))) {\n        return objThis.AsSingle();\n      }\n      if (t.Equals(typeof(bool))) {\n        return objThis.AsBoolean();\n      }\n      if (t.Equals(typeof(char))) {\n        if (objThis.Type == CBORType.TextString) {\n          string s = objThis.AsString();\n          if (s.Length != 1) {\n            throw new CBORException(\"Can't convert to char\");\n          }\n          return s[0];\n        }\n        if (objThis.IsNumber && objThis.AsNumber().CanFitInInt32()) {\n          int c = objThis.AsNumber().ToInt32IfExact();\n          if (c < 0 || c >= 0x10000) {\n            throw new CBORException(\"Can't convert to char\");\n          }\n          return (char)c;\n        }\n        throw new CBORException(\"Can't convert to char\");\n      }\n      if (t.Equals(typeof(DateTime))) {\n        return new CBORDateConverter().FromCBORObject(objThis);\n      }\n      if (t.Equals(typeof(Guid))) {\n        return new CBORUuidConverter().FromCBORObject(objThis);\n      }\n      if (t.Equals(typeof(Uri))) {\n        return new CBORUriConverter().FromCBORObject(objThis);\n      }\n      if (IsAssignableFrom(typeof(Enum), t)) {\n        return ObjectToEnum(objThis, t);\n      }\n      if (IsGenericType(t)) {\n        Type td = t.GetGenericTypeDefinition();\n        // Nullable types\n        if (td.Equals(typeof(Nullable<>))) {\n          Type nullableType = Nullable.GetUnderlyingType(t);\n          if (objThis.IsNull) {\n            return Activator.CreateInstance(t);\n          } else {\n            object wrappedObj = objThis.ToObject(\n                nullableType,\n                mapper,\n                options,\n                depth + 1);\n            return Activator.CreateInstance(\n                t,\n                wrappedObj);\n          }\n        }\n      }\n      if (objThis.Type == CBORType.ByteString) {\n        // TODO: Consider converting base64 strings\n        if (t.Equals(typeof(byte[]))) {\n          byte[] bytes = objThis.GetByteString();\n          var byteret = new byte[bytes.Length];\n          Array.Copy(bytes, 0, byteret, 0, byteret.Length);\n          return byteret;\n        }\n      }\n      if (objThis.Type == CBORType.Array) {\n        Type objectType = typeof(object);\n        var isList = false;\n        var isReadOnlyCollection = false;\n        object listObject = null;\n        object genericListObject = null;\n        if (IsAssignableFrom(typeof(Array), t)) {\n          Type elementType = t.GetElementType();\n          Array array = Array.CreateInstance(\n              elementType,\n              GetDimensions(objThis));\n          return FillArray(\n              array,\n              elementType,\n              objThis,\n              mapper,\n              options,\n              depth);\n        }\n        #if NET40 || NET20\n        if (t.IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isList = td.Equals(typeof(List<>)) || td.Equals(typeof(IList<>)) ||\n            td.Equals(typeof(ICollection<>)) ||\n            td.Equals(typeof(IEnumerable<>));\n          #if NET20 || NET40\n          isReadOnlyCollection = false;\n          #else\n          isReadOnlyCollection = (td.Equals(typeof(IReadOnlyCollection<>)) ||\n             td.Equals(typeof(IReadOnlyList<>)) ||\n\n             td.Equals(\n               typeof(System.Collections.ObjectModel.ReadOnlyCollection<>)))\n&&\n             t.GetGenericArguments().Length == 1;\n         #endif\n        }\n        isList = isList && t.GetGenericArguments().Length == 1;\n        if (isReadOnlyCollection) {\n          objectType = t.GetGenericArguments()[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        } else if (isList) {\n          objectType = t.GetGenericArguments()[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        }\n        #else\n        // TODO: Support IReadOnlyDictionary\n        if (t.GetTypeInfo().IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isList = td.Equals(typeof(List<>)) || td.Equals(typeof(IList<>)) ||\n            td.Equals(typeof(ICollection<>)) ||\n            td.Equals(typeof(IEnumerable<>));\n          isReadOnlyCollection = (td.Equals(typeof(IReadOnlyCollection<>)) ||\n             td.Equals(typeof(IReadOnlyList<>)) ||\n\n             td.Equals(\n               typeof(System.Collections.ObjectModel.ReadOnlyCollection<>)))\n&&\n             t.GenericTypeArguments.Length == 1;\n        }\n        isList = isList && t.GenericTypeArguments.Length == 1;\n        if (isReadOnlyCollection) {\n          objectType = t.GenericTypeArguments[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        } else if (isList) {\n          objectType = t.GenericTypeArguments[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        }\n        #endif\n        if (listObject == null) {\n          if (t.Equals(typeof(IList)) ||\n            t.Equals(typeof(ICollection)) || t.Equals(typeof(IEnumerable))) {\n            listObject = new List<object>();\n            objectType = typeof(object);\n          } else if (IsClassOrValueType(t)) {\n            var implementsList = false;\n            foreach (var interf in GetTypeInterfaces(t)) {\n              if (IsGenericType(interf) &&\n                interf.GetGenericTypeDefinition().Equals(typeof(IList<>))) {\n                if (implementsList) {\n                  implementsList = false;\n                  break;\n                } else {\n                  implementsList = true;\n                  objectType = FirstGenericArgument(interf);\n                }\n              }\n            }\n            if (implementsList) {\n              // DebugUtility.Log(\"assignable from ilist<>\");\n              genericListObject = Activator.CreateInstance(t);\n            } else {\n              // DebugUtility.Log(\"not assignable from ilist<> \" + t);\n            }\n          }\n        }\n        if (genericListObject != null) {\n          object addMethod = FindOneArgumentMethod(\n              genericListObject,\n              \"Add\",\n              objectType);\n          if (addMethod == null) {\n            throw new CBORException(\"no add method\");\n          }\n          foreach (CBORObject value in objThis.Values) {\n            PropertyMap.InvokeOneArgumentMethod(\n              addMethod,\n              genericListObject,\n              value.ToObject(objectType, mapper, options, depth + 1));\n          }\n          return genericListObject;\n        }\n        if (listObject != null) {\n          System.Collections.IList ie = (System.Collections.IList)listObject;\n          foreach (CBORObject value in objThis.Values) {\n            ie.Add(value.ToObject(objectType, mapper, options, depth + 1));\n          }\n          if (isReadOnlyCollection) {\n            objectType = FirstGenericArgument(t);\n            Type rocType =\ntypeof(System.Collections.ObjectModel.ReadOnlyCollection<>)\n               .MakeGenericType(objectType);\n            listObject = Activator.CreateInstance(rocType, listObject);\n          }\n          return listObject;\n        }\n      }\n      if (objThis.Type == CBORType.Map) {\n        var isDict = false;\n        var isReadOnlyDict = false;\n        Type keyType = null;\n        Type valueType = null;\n        object dictObject = null;\n        #if NET40 || NET20\n        isDict = t.IsGenericType;\n        if (t.IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isDict = td.Equals(typeof(Dictionary<,>)) ||\n            td.Equals(typeof(IDictionary<,>));\n          #if NET20 || NET40\n          isReadOnlyDict = false;\n          #else\n          isReadOnlyDict =\n(td.Equals(typeof(System.Collections.ObjectModel.ReadOnlyDictionary<,>)) ||\n            td.Equals(typeof(IReadOnlyDictionary<,>))) &&\n            t.GetGenericArguments().Length == 2;\n          #endif\n        }\n        // DebugUtility.Log(\"list=\" + isDict);\n        isDict = isDict && t.GetGenericArguments().Length == 2;\n        // DebugUtility.Log(\"list=\" + isDict);\n        if (isDict || isReadOnlyDict) {\n          keyType = t.GetGenericArguments()[0];\n          valueType = t.GetGenericArguments()[1];\n          Type listType = typeof(Dictionary<,>).MakeGenericType(\n              keyType,\n              valueType);\n          dictObject = Activator.CreateInstance(listType);\n        }\n        #else\n        isDict = t.GetTypeInfo().IsGenericType;\n        if (t.GetTypeInfo().IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isDict = td.Equals(typeof(Dictionary<,>)) ||\n            td.Equals(typeof(IDictionary<,>));\n          isReadOnlyDict =\n(td.Equals(typeof(System.Collections.ObjectModel.ReadOnlyDictionary<,>)) ||\n            td.Equals(typeof(IReadOnlyDictionary<,>))) &&\n            t.GenericTypeArguments.Length == 2;\n        }\n        // DebugUtility.Log(\"list=\" + isDict);\n        isDict = isDict && t.GenericTypeArguments.Length == 2;\n        // DebugUtility.Log(\"list=\" + isDict);\n        if (isDict || isReadOnlyDict) {\n          keyType = t.GenericTypeArguments[0];\n          valueType = t.GenericTypeArguments[1];\n          Type listType = typeof(Dictionary<,>).MakeGenericType(\n              keyType,\n              valueType);\n          dictObject = Activator.CreateInstance(listType);\n        }\n        #endif\n        if (dictObject == null) {\n          if (t.Equals(typeof(IDictionary))) {\n            dictObject = new Dictionary<object, object>();\n            keyType = typeof(object);\n            valueType = typeof(object);\n          }\n        }\n        if (dictObject != null) {\n          System.Collections.IDictionary idic =\n            (System.Collections.IDictionary)dictObject;\n          foreach (CBORObject key in objThis.Keys) {\n            CBORObject value = objThis[key];\n            idic.Add(\n              key.ToObject(keyType, mapper, options, depth + 1),\n              value.ToObject(valueType, mapper, options, depth + 1));\n          }\n          #if !NET20 && !NET40\n          if (isReadOnlyDict) {\n            Type listType =\ntypeof(\n  System.Collections.ObjectModel.ReadOnlyDictionary<,>)\n           .MakeGenericType(keyType,\n              valueType);\n            dictObject = Activator.CreateInstance(listType, dictObject);\n          }\n          #endif\n          return dictObject;\n        }\n        if (mapper != null) {\n          if (!mapper.FilterTypeName(t.FullName)) {\n            throw new CBORException(\"Type \" + t.FullName +\n              \" not supported\");\n          }\n        } else {\n          if (t.FullName != null && (\n              StartsWith(t.FullName, \"Microsoft.Win32.\") ||\n              StartsWith(t.FullName, \"System.IO.\"))) {\n            throw new CBORException(\"Type \" + t.FullName +\n              \" not supported\");\n          }\n          if (StartsWith(t.FullName, \"System.\") &&\n            !HasCustomAttribute(t, \"System.SerializableAttribute\")) {\n            throw new CBORException(\"Type \" + t.FullName +\n              \" not supported\");\n          }\n        }\n        var values = new List<KeyValuePair<string, CBORObject>>();\n        var propNames = PropertyMap.GetPropertyNames(\n            t,\n            options == null || options.UseCamelCase);\n        foreach (string key in propNames) {\n          if (objThis.ContainsKey(key)) {\n            CBORObject cborValue = objThis[key];\n            var dict = new KeyValuePair<string, CBORObject>(\n              key,\n              cborValue);\n            values.Add(dict);\n          }\n        }\n        return PropertyMap.ObjectWithProperties(\n            t,\n            values,\n            mapper,\n            options,\n            depth);\n      } else {\n        throw new CBORException();\n      }\n    }\n\n    public static CBORObject GetOrDefault(IDictionary<CBORObject, CBORObject> map,\n      CBORObject key,\n      CBORObject defaultValue) {\n      CBORObject ret = null;\n      return (!map.TryGetValue(key, out ret)) ? defaultValue : ret;\n    }\n\n#pragma warning disable CA1801\n    public static CBORObject FromObjectOther(object obj) {\n      return null;\n    }\n#pragma warning restore CA1801\n\n    public static object ObjectWithProperties(\n      Type t,\n      IEnumerable<KeyValuePair<string, CBORObject>> keysValues,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      try {\n        object o = Activator.CreateInstance(t);\n        var dict = new SortedDictionary<string, CBORObject>();\n        foreach (var kv in keysValues) {\n          var name = kv.Key;\n          dict[name] = kv.Value;\n        }\n        foreach (PropertyData key in GetPropertyList(o.GetType())) {\n          if (!key.HasUsableSetter() || !key.HasUsableGetter()) {\n            // Require properties to have both a setter and\n            // a getter to be eligible for setting\n            continue;\n          }\n          var name = key.GetAdjustedName(options != null ?\n              options.UseCamelCase : true);\n          if (dict.ContainsKey(name)) {\n            object dobj = dict[name].ToObject(\n                key.PropertyType,\n                mapper,\n                options,\n                depth + 1);\n            key.SetValue(\n              o,\n              dobj);\n          }\n        }\n        return o;\n      } catch (Exception ex) {\n        throw new CBORException(ex.Message, ex);\n      }\n    }\n\n    public static CBORObject CallToObject(\n      CBORTypeMapper.ConverterInfo convinfo,\n      object obj) {\n      return (CBORObject)PropertyMap.InvokeOneArgumentMethod(\n          convinfo.ToObject,\n          convinfo.Converter,\n          obj);\n    }\n\n    public static object CallFromObject(\n      CBORTypeMapper.ConverterInfo convinfo,\n      CBORObject obj) {\n      return (object)PropertyMap.InvokeOneArgumentMethod(\n          convinfo.FromObject,\n          convinfo.Converter,\n          obj);\n    }\n\n    public static IEnumerable<KeyValuePair<string, object>> GetProperties(\n      Object o) {\n      return GetProperties(o, true);\n    }\n\n    public static IEnumerable<string> GetPropertyNames(Type t, bool\n      useCamelCase) {\n      foreach (PropertyData key in GetPropertyList(t)) {\n        yield return key.GetAdjustedName(useCamelCase);\n      }\n    }\n\n    public static IEnumerable<KeyValuePair<string, object>> GetProperties(\n      Object o,\n      bool useCamelCase) {\n      foreach (PropertyData key in GetPropertyList(o.GetType())) {\n        if (!key.HasUsableGetter()) {\n          continue;\n        }\n        yield return new KeyValuePair<string, object>(\n            key.GetAdjustedName(useCamelCase),\n            key.GetValue(o));\n      }\n    }\n\n    public static void BreakDownDateTime(\n      DateTime bi,\n      EInteger[] year,\n      int[] lf) {\n      if (TicksDivFracSeconds == 0) {\n        throw new InvalidOperationException();\n      }\n      #if NET20\n      DateTime dt = bi.ToUniversalTime();\n      #else\n      DateTime dt = TimeZoneInfo.ConvertTime(bi, TimeZoneInfo.Utc);\n      #endif\n      year[0] = EInteger.FromInt32(dt.Year);\n      lf[0] = dt.Month;\n      lf[1] = dt.Day;\n      lf[2] = dt.Hour;\n      lf[3] = dt.Minute;\n      lf[4] = dt.Second;\n      // lf[5] is the number of nanoseconds\n      lf[5] = (int)(dt.Ticks % 10000000L) * TicksDivFracSeconds;\n    }\n\n    public static DateTime BuildUpDateTime(EInteger year, int[] dt) {\n      if (TicksDivFracSeconds == 0) {\n        throw new InvalidOperationException();\n      }\n      if (year.CompareTo(9999) > 0 || year.CompareTo(0) <= 0) {\n        throw new CBORException(\"Year is too big or too small for DateTime.\");\n      }\n      return new DateTime(\n          year.ToInt32Checked(),\n          dt[0],\n          dt[1],\n          dt[2],\n          dt[3],\n          dt[4],\n          DateTimeKind.Utc).AddMinutes(-dt[6]).AddTicks((long)(dt[5] /\n            TicksDivFracSeconds));\n    }\n  }\n}\n", "using System;\nusing System.Collections.Generic;\nusing PeterO;\n\nnamespace Test {\n  public sealed class CBORGenerator {\n    private sealed class ByteWriter {\n      private byte[] bytes = new byte[64];\n      private int pos;\n\n      public ByteWriter Write(int b) {\n        if (this.pos < this.bytes.Length) {\n          this.bytes[this.pos++] = (byte)b;\n        } else {\n          var newbytes = new byte[this.bytes.Length * 2];\n          Array.Copy(this.bytes, 0, newbytes, 0, this.bytes.Length);\n          this.bytes = newbytes;\n          this.bytes[this.pos++] = (byte)b;\n        }\n        return this;\n      }\n\n      public int ByteLength {\n        get {\n          return this.pos;\n        }\n      }\n\n      public byte[] ToBytes() {\n        var newbytes = new byte[this.pos];\n        Array.Copy(this.bytes, 0, newbytes, 0, this.pos);\n        return newbytes;\n      }\n    }\n\n    private static void GenerateArgument(\n      IRandomGenExtended r,\n      int majorType,\n      int len,\n      ByteWriter bs) {\n      var maxArg = 4;\n      var sh = 0;\n      int minArg = (len < 0x18) ? 0 : ((len <= 0xff) ? 1 :\n          ((len <= 0xffff) ? 2 : 3));\n      int arg = minArg + r.GetInt32(maxArg - minArg + 1);\n      switch (arg) {\n        case 0:\n          bs.Write((majorType * 0x20) + len);\n          break;\n        case 1:\n          bs.Write((majorType * 0x20) + 0x18);\n          bs.Write(len & 0xff);\n          break;\n        case 2:\n          bs.Write((majorType * 0x20) + 0x19);\n          sh = 8;\n          for (int i = 0; i < 2; ++i) {\n            bs.Write((len >> sh) & 0xff);\n            sh -= 8;\n          }\n          break;\n        case 3:\n          bs.Write((majorType * 0x20) + 0x1a);\n          sh = 24;\n          for (int i = 0; i < 4; ++i) {\n            bs.Write((len >> sh) & 0xff);\n            sh -= 8;\n          }\n          break;\n        case 4:\n          bs.Write((majorType * 0x20) + 0x1b);\n          for (int i = 0; i < 4; ++i) {\n            bs.Write(0);\n          }\n          sh = 24;\n          for (int i = 0; i < 4; ++i) {\n            bs.Write((len >> sh) & 0xff);\n            sh -= 8;\n          }\n          break;\n      }\n    }\n\n    private static int[]\n    valueMajorTypes = {\n      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4,\n      4, 5, 6, 6, 7, 7, 7, 7, 7, 7,\n    };\n\n    private static int[] valueMajorTypesHighLength = {\n      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 6,\n      6, 7, 7, 7, 7, 7, 7,\n    };\n\n    private static void GenerateUtf8(IRandomGenExtended ra, ByteWriter bs, int\n      length) {\n      for (int i = 0; i < length;) {\n        int r = ra.GetInt32(10);\n        if (r > 0) {\n          bs.Write(ra.GetInt32(128));\n          ++i;\n        } else {\n          r = ra.GetInt32(3);\n          if (r == 0 && length - i >= 2) {\n            r = 0xc2 + ra.GetInt32((0xdf - 0xc2) + 1);\n            bs.Write(r);\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            i += 2;\n          } else if (r == 1 && length - i >= 3) {\n            r = 0xe0 + ra.GetInt32(16);\n            bs.Write(r);\n            int lower = (r == 0xe0) ? 0xa0 : 0x80;\n            int upper = (r == 0xed) ? 0x9f : 0xbf;\n            r = lower + ra.GetInt32((upper - lower) + 1);\n            bs.Write(r);\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            i += 3;\n          } else if (r == 2 && length - i >= 4) {\n            r = 0xf0 + ra.GetInt32(5);\n            bs.Write(r);\n            int lower = (r == 0xf0) ? 0x90 : 0x80;\n            int upper = (r == 0xf4) ? 0x8f : 0xbf;\n            r = lower + ra.GetInt32((upper - lower) + 1);\n            bs.Write(r);\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            i += 4;\n          }\n        }\n      }\n    }\n\n    private void Generate(IRandomGenExtended r, int depth, ByteWriter bs) {\n      int majorType = valueMajorTypes[r.GetInt32(valueMajorTypes.Length)];\n      if (bs.ByteLength > 2000000) {\n        majorType = valueMajorTypesHighLength[r.GetInt32(\n              valueMajorTypesHighLength.Length)];\n      }\n      if (majorType == 3 || majorType == 2) {\n        int len = r.GetInt32(1000);\n        if (r.GetInt32(50) == 0 && depth < 2) {\n          var v = (long)r.GetInt32(100000) * r.GetInt32(100000);\n          len = (int)(v / 100000);\n        }\n        if (depth > 6) {\n          len = r.GetInt32(100) == 0 ? 1 : 0;\n        }\n        // TODO: Ensure key uniqueness\n        if (r.GetInt32(2) == 0) {\n          // Indefinite length\n          bs.Write(0x1f + (majorType * 0x20));\n          while (len > 0) {\n            int sublen = r.GetInt32(len + 1);\n            GenerateArgument(r, majorType, sublen, bs);\n            if (majorType == 3) {\n              GenerateUtf8(r, bs, sublen);\n            } else {\n              for (int i = 0; i < sublen; ++i) {\n                bs.Write(r.GetInt32(256));\n              }\n            }\n            len -= sublen;\n          }\n          bs.Write(0xff);\n        } else {\n          // Definite length\n          GenerateArgument(r, majorType, len, bs);\n          if (majorType == 3) {\n            GenerateUtf8(r, bs, len);\n          } else {\n            for (int i = 0; i < len; ++i) {\n              bs.Write(r.GetInt32(256));\n            }\n          }\n        }\n        return;\n      } else if (majorType == 4 || majorType == 5) {\n        int len = r.GetInt32(8);\n        if (r.GetInt32(50) == 0 && depth < 2) {\n          var v = (long)r.GetInt32(1000) * r.GetInt32(1000);\n          len = (int)(v / 1000);\n        }\n        bool indefiniteLength = r.GetInt32(2) == 0;\n        if (indefiniteLength) {\n          bs.Write(0x1f + (majorType * 0x20));\n        } else {\n          GenerateArgument(r, majorType, len, bs);\n        }\n        for (int i = 0; i < len; ++i) {\n          this.Generate(r, depth + 1, bs);\n          if (majorType == 5) {\n            this.Generate(r, depth + 1, bs);\n          }\n        }\n        if (indefiniteLength) {\n          bs.Write(0xff);\n        }\n        return;\n      }\n      int arg = r.GetInt32(5);\n      switch (arg) {\n        case 0:\n          bs.Write((majorType * 0x20) + r.GetInt32(0x18));\n          break;\n        case 1:\n          bs.Write((majorType * 0x20) + 0x18);\n          if (majorType == 7) {\n            bs.Write(32 + r.GetInt32(224));\n          } else {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n        case 2:\n          bs.Write((majorType * 0x20) + 0x19);\n          for (int i = 0; i < 2; ++i) {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n        case 3:\n          bs.Write((majorType * 0x20) + 0x1a);\n          for (int i = 0; i < 4; ++i) {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n        case 4:\n          bs.Write((majorType * 0x20) + 0x1b);\n          for (int i = 0; i < 8; ++i) {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n      }\n      if (majorType == 6) {\n        this.Generate(r, depth + 1, bs);\n      }\n    }\n\n    public byte[] Generate(IRandomGenExtended random) {\n      var bs = new ByteWriter();\n      if (random == null) {\n        throw new ArgumentNullException(nameof(random));\n      }\n      this.Generate(random, 0, bs);\n      byte[] ret = bs.ToBytes();\n      return ret;\n    }\n  }\n}\n", "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing NUnit.Framework;\nusing PeterO;\nusing PeterO.Cbor;\nusing PeterO.Numbers;\n\nnamespace Test {\n  [TestFixture]\n#pragma warning disable CS0618\n  public class CBORObjectTest {\n    private static readonly string[] ValueJsonFails = {\n      \"\\\"\\\\uxxxx\\\"\",\n      \"\\\"\\\\ud800\\udc00\\\"\",\n      \"\\\"\\ud800\\\\udc00\\\"\", \"\\\"\\\\U0023\\\"\", \"\\\"\\\\u002x\\\"\", \"\\\"\\\\u00xx\\\"\",\n      \"\\\"\\\\u0xxx\\\"\", \"\\\"\\\\u0\\\"\", \"\\\"\\\\u00\\\"\", \"\\\"\\\\u000\\\"\", \"trbb\",\n      \"trub\", \"falsb\", \"nulb\", \"[true\", \"[true,\", \"[true]!\", \"tr\\u0020\",\n      \"tr\", \"fa\", \"nu\", \"True\", \"False\", \"Null\", \"TRUE\", \"FALSE\", \"NULL\",\n      \"truE\", \"falsE\", \"nulL\", \"tRUE\", \"fALSE\", \"nULL\", \"tRuE\", \"fAlSe\", \"nUlL\",\n      \"[tr]\", \"[fa]\",\n      \"[nu]\", \"[True]\", \"[False]\", \"[Null]\", \"[TRUE]\", \"[FALSE]\", \"[NULL]\",\n      \"[truE]\", \"[falsE]\",\n      \"[nulL]\", \"[tRUE]\", \"[fALSE]\", \"[nULL]\", \"[tRuE]\", \"[fAlSe]\", \"[nUlL]\",\n      \"fa \", \"nu \", \"fa lse\", \"nu ll\", \"tr ue\",\n      \"[\\\"\\ud800\\\\udc00\\\"]\", \"[\\\"\\\\ud800\\udc00\\\"]\",\n      \"[\\\"\\\\udc00\\ud800\\udc00\\\"]\", \"[\\\"\\\\ud800\\ud800\\udc00\\\"]\",\n      \"[\\\"\\\\ud800\\\"]\", \"[1,2,\", \"[1,2,3\", \"{,\\\"0\\\":0,\\\"1\\\":1}\",\n      \"{\\\"0\\\"::0}\", \"{\\\"0\\\":0,,\\\"1\\\":1}\",\n      \"{\\\"0\\\":0,\\\"1\\\":1,}\", \"[,0,1,2]\", \"[0,,1,2]\", \"[0:1]\", \"[0:1:2]\",\n      \"[0,1,,2]\", \"[0,1,2,]\", \"[0001]\", \"{a:true}\",\n      \"{\\\"a\\\":#comment\\ntrue}\",\n      \"{\\\"a\\\"://comment\\ntrue}\", \"{\\\"a\\\":/*comment*/true}\", \"{'a':true}\",\n      \"{\\\"a\\\":'b'}\", \"{\\\"a\\t\\\":true}\", \"{\\\"a\\r\\\":true}\", \"{\\\"a\\n\\\":true}\",\n      \"['a']\", \"{\\\"a\\\":\\\"a\\t\\\"}\", \"[\\\"a\\\\'\\\"]\", \"[NaN]\", \"[+Infinity]\",\n      \"[-Infinity]\", \"[Infinity]\", \"{\\\"a\\\":\\\"a\\r\\\"}\", \"{\\\"a\\\":\\\"a\\n\\\"}\",\n      \"[\\\"a\\t\\\"]\", \"\\\"test\\\"\\\"\", \"\\\"test\\\"x\", \"\\\"test\\\"\\u0300\",\n      \"\\\"test\\\"\\u0005\", \"[5]\\\"\", \"[5]x\", \"[5]\\u0300\", \"[5]\\u0005\",\n      \"{\\\"test\\\":5}\\\"\", \"{\\\"test\\\":5}x\", \"{\\\"test\\\":5}\\u0300\",\n      \"{\\\"test\\\":5}\\u0005\", \"true\\\"\", \"truex\", \"true}\", \"true\\u0300\",\n      \"true\\u0005\", \"8024\\\"\", \"8024x\", \"8024}\", \"8024\\u0300\",\n      \"8024\\u0005\", \"{\\\"test\\\":5}}\", \"{\\\"test\\\":5}{\", \"[5]]\", \"[5][\",\n      \"00\", \"000\", \"001\", \"0001\", \"00.0\", \"001.0\", \"0001.0\", \"01E-4\", \"01.1E-4\",\n      \"01E4\", \"01.1E4\", \"01e-4\", \"01.1e-4\",\n      \"01e4\", \"01.1e4\",\n      \"+0\", \"+1\", \"+0.0\", \"+1e4\", \"+1e-4\", \"+1.0\", \"+1.0e4\",\n      \"+1.0e+4\", \"+1.0e-4\",\n      \"0000\", \"0x1\", \"0xf\", \"0x20\", \"0x01\",\n      \"-3x\", \"-3e89x\", \"\\u0005true\", \"x\\\\u0005z\",\n      \"0,2\", \"0,05\", \"-0,2\", \"-0,05\", \"\\u007F0.0\", \"\\u00010.0\", \"0.0\\u007F\",\n      \"0.0\\u0001\", \"-1.D\\r\\n\", \"-1.D\\u0020\", \"-1.5L\", \"-0.0L\", \"0L\", \"1L\",\n      \"1.5L\",\n      \"0.0L\",\n      \"0X1\", \"0Xf\", \"0X20\", \"0X01\", \".2\", \".05\", \"-.2\",\n      \"-.05\", \"23.\", \"23.e0\", \"23.e1\", \"0.\", \"-0.\", \"[0000]\", \"[0x1]\",\n      \"[0xf]\", \"[0x20]\", \"[0x01]\", \"[.2]\", \"[.05]\", \"[-.2]\", \"[-.05]\",\n      \"[23.]\", \"[23.e0]\", \"[23.e1]\", \"[0.]\", \"\\\"abc\", \"\\\"ab\\u0004c\\\"\",\n      \"\\u0004\\\"abc\\\"\",\n      \"{\\\"x\\\":true \\\"y\\\":true}\",\n      \"{\\\"x\\\":true\\n\\\"y\\\":true}\",\n      \"0,1,2,3\", \"\\\"x\\\",true\",\n      \"\\\"x\\\",true\",\n      \"\\\"x\\\":true\",\n      \"\\\"x\\\":true,\\\"y\\\":true\",\n      \"\\\"x\\\":true\\n\\\"y\\\":true\",\n      \"\\\"x\\\":true \\\"y\\\":true\",\n      \"{\\\"x\\\":true,\\\"y\\\"}\",\n      \"{\\\"x\\\",\\\"y\\\":true}\",\n      \"{\\\"x\\\":true, \\\"y\\\"}\",\n      \"{\\\"x\\\", \\\"y\\\":true}\",\n      \"{[\\\"x\\\"]:true}\",\n      \"{null:true}\", \"{true:true}\", \"{false:true}\",\n      \"{[0]:true}\", \"{1:true}\", \"{{\\\"a\\\":true}:true}\",\n      \"[1,\\u0004\" + \"2]\",\n    };\n\n    private static readonly string[] ValueJsonSucceeds = {\n      \"[0]\",\n      \"[0.1]\",\n      \"[0.1001]\",\n      \"[0.0]\", \"true\\n\\r\\t\\u0020\",\n      \"[-3 \" + \",-5]\", \"\\n\\r\\t\\u0020true\", \"\\\"x\\\\u0005z\\\"\",\n      \"[0.00]\", \"[0.000]\", \"[0.01]\", \"[0.001]\", \"[0.5]\", \"[0E5]\", \"[0e5]\",\n      \"[0E+6]\", \"[\\\"\\ud800\\udc00\\\"]\", \"[\\\"\\\\ud800\\\\udc00\\\"]\",\n      \"[\\\"\\\\ud800\\\\udc00\\ud800\\udc00\\\"]\", \"23.0e01\", \"23.0e00\", \"[23.0e01]\",\n      \"[23.0e00]\", \"0\", \"1\", \"0.2\", \"0.05\", \"-0.2\", \"-0.05\",\n    };\n\n    private static readonly JSONOptions ValueNoDuplicateKeys = new\n    JSONOptions(\"allowduplicatekeys=false\");\n\n    internal static void CheckPropertyNames(\n      object ao,\n      PODOptions cc,\n      string p1,\n      string p2,\n      string p3) {\n      CBORObjectTest.CheckPropertyNames(\n        CBORObject.FromObject(ao, cc),\n        p1,\n        p2,\n        p3);\n    }\n\n    internal static void CheckArrayPropertyNames(\n      CBORObject co,\n      int expectedCount,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.AreEqual(CBORType.Array, co.Type);\n      Assert.AreEqual(expectedCount, co.Count);\n      for (var i = 0; i < co.Count; ++i) {\n        CBORObjectTest.CheckPropertyNames(co[i], p1, p2, p3);\n      }\n      CBORTestCommon.AssertRoundTrip(co);\n    }\n\n    internal static void CheckPODPropertyNames(\n      CBORObject co,\n      PODOptions cc,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.AreEqual(CBORType.Map, co.Type);\n      string keyName = cc.UseCamelCase ? \"propValue\" : \"PropValue\";\n      if (!co.ContainsKey(keyName)) {\n        Assert.Fail(\"Expected \" + keyName + \" to exist: \" + co.ToString());\n      }\n      CBORObjectTest.CheckPropertyNames(co[keyName], p1, p2, p3);\n    }\n\n    internal static void CheckPODInDictPropertyNames(\n      CBORObject co,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.AreEqual(CBORType.Map, co.Type);\n      if (!co.ContainsKey(\"PropValue\")) {\n        Assert.Fail(\"Expected PropValue to exist: \" + co.ToString());\n      }\n      CBORObjectTest.CheckPropertyNames(co[\"PropValue\"], p1, p2, p3);\n    }\n\n    internal static void CheckPropertyNames(\n      CBORObject o,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.IsFalse(o.ContainsKey(\"PrivatePropA\"));\n      Assert.IsFalse(o.ContainsKey(\"privatePropA\"));\n      Assert.IsFalse(o.ContainsKey(\"StaticPropA\"));\n      Assert.IsFalse(o.ContainsKey(\"staticPropA\"));\n      Assert.AreEqual(CBORType.Map, o.Type);\n      if (!o.ContainsKey(p1)) {\n        Assert.Fail(\"Expected \" + p1 + \" to exist: \" + o.ToString());\n      }\n      if (!o.ContainsKey(p2)) {\n        Assert.Fail(\"Expected \" + p2 + \" to exist: \" + o.ToString());\n      }\n      if (!o.ContainsKey(p3)) {\n        Assert.Fail(\"Expected \" + p3 + \" to exist: \" + o.ToString());\n      }\n      CBORTestCommon.AssertRoundTrip(o);\n    }\n\n    internal static void CheckPropertyNames(object ao) {\n      var valueCcTF = new PODOptions(true, false);\n      var valueCcFF = new PODOptions(false, false);\n      var valueCcFT = new PODOptions(false, true);\n      var valueCcTT = new PODOptions(true, true);\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcTF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      //--\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcFF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcFT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcTT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n    }\n\n    public static CBORObject GetNumberData() {\n      return new AppResources(\"Resources\").GetJSON(\"numbers\");\n    }\n\n    public static void TestFailingJSON(string str) {\n      TestFailingJSON(str, new JSONOptions(\"allowduplicatekeys=true\"));\n    }\n\n    public static void TestFailingJSON(string str, JSONOptions opt) {\n      byte[] bytes = null;\n      try {\n        bytes = DataUtilities.GetUtf8Bytes(str, false);\n      } catch (ArgumentException ex2) {\n        Console.WriteLine(ex2.Message);\n        // Check only FromJSONString\n        try {\n          CBORObject.FromJSONString(str, opt);\n          Assert.Fail(\"Should have failed: str = \" + str);\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        return;\n      }\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadJSON(ms, opt);\n          Assert.Fail(\"Should have failed: str = \" + str);\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(str + \"\\r\\n\" + ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      try {\n        CBORObject.FromJSONString(str, opt);\n        Assert.Fail(\"Should have failed: str = \" + str);\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static CBORObject TestSucceedingJSON(string str) {\n      return TestSucceedingJSON(str, null);\n    }\n\n    public static CBORObject TestSucceedingJSON(\n      string str,\n      JSONOptions options) {\n      byte[] bytes = DataUtilities.GetUtf8Bytes(str, false);\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          CBORObject obj = options == null ? CBORObject.ReadJSON(ms) :\n            CBORObject.ReadJSON(ms, options);\n          CBORObject obj2 = options == null ? CBORObject.FromJSONString(str) :\n            CBORObject.FromJSONString(str, options);\n          if (!obj.Equals(obj2)) {\n            TestCommon.CompareTestEqualAndConsistent(\n              obj,\n              obj2);\n          }\n          if (str == null) {\n            throw new ArgumentNullException(nameof(str));\n          }\n          CBORObject obj3 = options == null ? CBORObject.FromJSONString(\n              str,\n              0,\n              str.Length) :\n            CBORObject.FromJSONString(str, 0, str.Length, options);\n          if (!obj.Equals(obj3)) {\n            Assert.AreEqual(obj, obj3);\n          }\n          obj3 = options == null ? CBORObject.FromJSONString(\n              \"xyzxyz\" + str,\n              6,\n              str.Length) :\n            CBORObject.FromJSONString(\"xyzxyz\" + str, 6, str.Length, options);\n          if (!obj.Equals(obj3)) {\n            Assert.AreEqual(obj, obj3);\n          }\n          obj3 = options == null ? CBORObject.FromJSONString(\n              \"xyzxyz\" + str + \"xyzxyz\",\n              6,\n              str.Length) : CBORObject.FromJSONString(\n              \"xyzxyz\" + str + \"xyzxyz\",\n              6,\n              str.Length,\n              options);\n          if (!obj.Equals(obj3)) {\n            Assert.AreEqual(obj, obj3);\n          }\n          return obj;\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString() + \"\\n\" + str);\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static string CharString(int cp, bool quoted, char[] charbuf) {\n      var index = 0;\n      if (quoted) {\n        if (charbuf == null) {\n          throw new ArgumentNullException(nameof(charbuf));\n        }\n        charbuf[index++] = (char)0x22;\n      }\n      if (cp < 0x10000) {\n        if (cp >= 0xd800 && cp < 0xe000) {\n          return null;\n        }\n        if (charbuf == null) {\n          throw new ArgumentNullException(nameof(charbuf));\n        }\n        charbuf[index++] = (char)cp;\n        if (quoted) {\n          charbuf[index++] = (char)0x22;\n        }\n        return new String(charbuf, 0, index);\n      } else {\n        cp -= 0x10000;\n        if (charbuf == null) {\n          throw new ArgumentNullException(nameof(charbuf));\n        }\n        charbuf[index++] = (char)((cp >> 10) + 0xd800);\n        charbuf[index++] = (char)((cp & 0x3ff) | 0xdc00);\n        if (quoted) {\n          charbuf[index++] = (char)0x22;\n        }\n        return new String(charbuf, 0, index);\n      }\n    }\n\n    [Test]\n    public void TestAdd() {\n      CBORObject cbor = CBORObject.NewMap();\n      CBORObject cborNull = CBORObject.Null;\n      cbor.Add(null, true);\n      Assert.AreEqual(CBORObject.True, cbor[cborNull]);\n      cbor.Add(\"key\", null);\n      Assert.AreEqual(CBORObject.Null, cbor[\"key\"]);\n    }\n\n    [Test]\n    public void TestAddConverter() {\n      // not implemented yet\n    }\n\n    private static EDecimal AsED(CBORObject obj) {\n      return (EDecimal)obj.ToObject(typeof(EDecimal));\n    }\n\n    [Test]\n    [Timeout(5000)]\n    public void TestAsNumberAdd() {\n      var r = new RandomGenerator();\n      for (var i = 0; i < 1000; ++i) {\n        // NOTE: Avoid generating high-exponent numbers for this test\n        CBORObject o1 = CBORTestCommon.RandomNumber(r, true);\n        CBORObject o2 = CBORTestCommon.RandomNumber(r, true);\n        EDecimal cmpCobj = null;\n        try {\n          cmpCobj = o1.AsNumber().Add(o2.AsNumber()).ToEDecimal();\n        } catch (OutOfMemoryException) {\n          continue;\n        }\n        EDecimal cmpDecFrac = AsED(o1).Add(AsED(o2));\n        TestCommon.CompareTestEqual(cmpDecFrac, cmpCobj);\n        CBORTestCommon.AssertRoundTrip(o1);\n        CBORTestCommon.AssertRoundTrip(o2);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber().Add(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestAsBoolean() {\n      Assert.IsTrue(CBORObject.True.AsBoolean());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).AsBoolean());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .AsBoolean());\n      Assert.IsFalse(CBORObject.False.AsBoolean());\n      Assert.IsFalse(CBORObject.Null.AsBoolean());\n      Assert.IsFalse(CBORObject.Undefined.AsBoolean());\n      Assert.IsTrue(CBORObject.NewArray().AsBoolean());\n      Assert.IsTrue(CBORObject.NewMap().AsBoolean());\n    }\n\n    [Test]\n    public void TestAsByte() {\n      try {\n        CBORObject.NewArray().AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"byte\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n            ((int)cbornumber.AsByte()) & 0xff);\n        } else {\n          try {\n            cbornumber.AsByte();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n      for (var i = 0; i < 255; ++i) {\n        Assert.AreEqual(\n          (byte)i,\n          ToObjectTest.TestToFromObjectRoundTrip(i).AsByte());\n      }\n      for (int i = -200; i < 0; ++i) {\n        try {\n          ToObjectTest.TestToFromObjectRoundTrip(i).AsByte();\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      for (int i = 256; i < 512; ++i) {\n        try {\n          ToObjectTest.TestToFromObjectRoundTrip(i).AsByte();\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsDouble() {\n      try {\n        CBORObject.NewArray().AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        {\n          var dtemp = (double)EDecimal.FromString(\n              numberinfo[\"number\"].AsString()).ToDouble();\n          double dtemp2 = cbornumber.AsDouble();\n          AreEqualExact(dtemp, dtemp2);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsInt16() {\n      try {\n        CBORObject.NewArray().AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(\n            EDecimal.FromString(numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"int16\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n            cbornumber.AsInt16());\n        } else {\n          try {\n            cbornumber.AsInt16();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsInt32() {\n      try {\n        CBORObject.NewArray().AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        EDecimal edec =\n          EDecimal.FromString(numberinfo[\"number\"].AsString());\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(edec);\n        bool isdouble = numberinfo[\"double\"].AsBoolean();\n        CBORObject cbornumberdouble =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToDouble());\n        bool issingle = numberinfo[\"single\"].AsBoolean();\n        CBORObject cbornumbersingle =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToSingle());\n        if (numberinfo[\"int32\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n            cbornumber.AsInt32());\n          if (isdouble) {\n            Assert.AreEqual(\n              TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n              cbornumberdouble.AsInt32());\n          }\n          if (issingle) {\n            Assert.AreEqual(\n              TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n              cbornumbersingle.AsInt32());\n          }\n        } else {\n          try {\n            cbornumber.AsInt32();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          if (isdouble) {\n            try {\n              cbornumberdouble.AsInt32();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          if (issingle) {\n            try {\n              cbornumbersingle.AsInt32();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsInt64() {\n      try {\n        CBORObject.NewArray().AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        EDecimal edec =\n          EDecimal.FromString(numberinfo[\"number\"].AsString());\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(edec);\n        bool isdouble = numberinfo[\"double\"].AsBoolean();\n        CBORObject cbornumberdouble =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToDouble());\n        bool issingle = numberinfo[\"single\"].AsBoolean();\n        CBORObject cbornumbersingle =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToSingle());\n        if (numberinfo[\"int64\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToLong(numberinfo[\"integer\"].AsString()),\n            cbornumber.AsInt64());\n          if (isdouble) {\n            Assert.AreEqual(\n              TestCommon.StringToLong(numberinfo[\"integer\"].AsString()),\n              cbornumberdouble.AsInt64());\n          }\n          if (issingle) {\n            Assert.AreEqual(\n              TestCommon.StringToLong(numberinfo[\"integer\"].AsString()),\n              cbornumbersingle.AsInt64());\n          }\n        } else {\n          try {\n            cbornumber.AsInt64();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          if (isdouble) {\n            try {\n              cbornumberdouble.AsInt64();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          if (issingle) {\n            try {\n              cbornumbersingle.AsInt64();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsSByte() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestAsSingle() {\n      try {\n        CBORObject.NewArray().AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        {\n          var ftemp = (float)EDecimal.FromString(\n              numberinfo[\"number\"].AsString()).ToSingle();\n          float ftemp2 = cbornumber.AsSingle();\n          AreEqualExact(ftemp, ftemp2);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsString() {\n      {\n        string stringTemp = ToObjectTest.TestToFromObjectRoundTrip(\"test\")\n          .AsString();\n        Assert.AreEqual(\n          \"test\",\n          stringTemp);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(CBORObject.Null).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(true).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(false).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(5).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewArray().AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestAsUInt16() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestAsUInt32() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestAsUInt64() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestCanFitInDouble() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(\n          0).CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleA() {\n      Assert.IsFalse(CBORObject.True.CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleB() {\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleC() {\n      Assert.IsFalse(CBORObject.NewArray().CanFitInDouble());\n      Assert.IsFalse(CBORObject.NewMap().CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleD() {\n      Assert.IsFalse(CBORObject.False.CanFitInDouble());\n      Assert.IsFalse(CBORObject.Null.CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleE() {\n      Assert.IsFalse(CBORObject.Undefined.CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleF() {\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (cbornumber == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"double\"].AsBoolean()) {\n          if (!cbornumber.CanFitInDouble()) {\n            Assert.Fail(cbornumber.ToString());\n          }\n        } else {\n          if (cbornumber.CanFitInDouble()) {\n            Assert.Fail(cbornumber.ToString());\n          }\n        }\n      }\n      var rand = new RandomGenerator();\n      for (var i = 0; i < 2047; ++i) {\n        // Try a random double with a given\n        // exponent\n        object o = RandomObjects.RandomDouble(rand, i);\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(o);\n        if (cbornumber == null) {\n          Assert.Fail();\n        }\n        Assert.IsTrue(cbornumber.CanFitInDouble());\n      }\n    }\n\n    [Test]\n    public void TestCanFitInInt32() {\n      Assert.IsTrue(CInt32(ToObjectTest.TestToFromObjectRoundTrip(0)));\n      Assert.IsFalse(CInt32(CBORObject.True));\n      Assert.IsFalse(CInt32(ToObjectTest.TestToFromObjectRoundTrip(\n            String.Empty)));\n      Assert.IsFalse(CInt32(CBORObject.NewArray()));\n      Assert.IsFalse(CInt32(CBORObject.NewMap()));\n      Assert.IsFalse(CInt32(CBORObject.False));\n      Assert.IsFalse(CInt32(CBORObject.Null));\n      Assert.IsFalse(CInt32(CBORObject.Undefined));\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int32\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"isintegral\"] == null) {\n          Assert.Fail();\n        }\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (cbornumber == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int32\"].AsBoolean() &&\n          numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(CInt32(cbornumber));\n          Assert.IsTrue(\n            CInt32(ToObjectTest.TestToFromObjectRoundTrip(\n                cbornumber.AsInt32())));\n        } else {\n          Assert.IsFalse(CInt32(cbornumber));\n        }\n      }\n    }\n\n    private static bool CInt64(CBORObject cbor) {\n      return cbor != null && cbor.IsNumber && cbor.AsNumber().CanFitInInt64();\n    }\n\n    private static bool CInt32(CBORObject cbor) {\n      return cbor != null && cbor.IsNumber && cbor.AsNumber().CanFitInInt32();\n    }\n\n    [Test]\n    public void TestCanFitInInt64() {\n      Assert.IsTrue(CInt64(ToObjectTest.TestToFromObjectRoundTrip(0)));\n      Assert.IsFalse(CInt64(CBORObject.True));\n      Assert.IsFalse(CInt64(ToObjectTest.TestToFromObjectRoundTrip(\n            String.Empty)));\n      Assert.IsFalse(CInt64(CBORObject.NewArray()));\n      Assert.IsFalse(CInt64(CBORObject.NewMap()));\n      Assert.IsFalse(CInt64(CBORObject.False));\n      Assert.IsFalse(CInt64(CBORObject.Null));\n      Assert.IsFalse(CInt64(CBORObject.Undefined));\n\n      EInteger ei;\n      ei = EInteger.FromString(\"9223372036854775807\");\n      Assert.IsTrue(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"9223372036854775808\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775807\");\n      Assert.IsTrue(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775808\");\n      Assert.IsTrue(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775809\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223373136366403584\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"9223373136366403584\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      var strings = new string[] {\n        \"8000FFFFFFFF0000\",\n        \"8000AAAAAAAA0000\",\n        \"8000800080000000\",\n        \"8000000100010000\",\n        \"8000FFFF00000000\",\n        \"80000000FFFF0000\",\n        \"8000800000000000\",\n        \"8000000080000000\",\n        \"8000AAAA00000000\",\n        \"80000000AAAA0000\",\n        \"8000000100000000\",\n        \"8000000000010000\",\n      };\n      foreach (var str in strings) {\n        ei = EInteger.FromRadixString(str, 16);\n        Assert.IsFalse(CInt64(CBORObject.FromObject(ei)));\n        ei = ei.Negate();\n        Assert.IsFalse(CInt64(CBORObject.FromObject(ei)));\n      }\n\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int64\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"isintegral\"] == null) {\n          Assert.Fail();\n        }\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"int64\"].AsBoolean() &&\n          numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(CInt64(cbornumber));\n\n          Assert.IsTrue(\n            CInt64(ToObjectTest.TestToFromObjectRoundTrip(\n                cbornumber.AsInt64())));\n        } else {\n          Assert.IsFalse(CInt64(cbornumber));\n        }\n      }\n    }\n\n    [Test]\n    public void TestCanFitInSingle() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(\n          0).CanFitInSingle());\n      Assert.IsFalse(CBORObject.True.CanFitInSingle());\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanFitInSingle());\n      Assert.IsFalse(CBORObject.NewArray().CanFitInSingle());\n      Assert.IsFalse(CBORObject.NewMap().CanFitInSingle());\n      Assert.IsFalse(CBORObject.False.CanFitInSingle());\n      Assert.IsFalse(CBORObject.Null.CanFitInSingle());\n      Assert.IsFalse(CBORObject.Undefined.CanFitInSingle());\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"single\"] == null) {\n          Assert.Fail();\n        }\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"single\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.CanFitInSingle());\n        } else {\n          Assert.IsFalse(cbornumber.CanFitInSingle());\n        }\n      }\n\n      var rand = new RandomGenerator();\n      for (var i = 0; i < 255; ++i) {\n        // Try a random float with a given\n        // exponent\n        Assert.IsTrue(\n          ToObjectTest.TestToFromObjectRoundTrip(\n            RandomObjects.RandomSingle(\n              rand,\n              i)).CanFitInSingle());\n      }\n    }\n\n    [Test]\n    public void TestCanTruncatedIntFitInInt32() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            11)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            12)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            13)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            14)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            15)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            16)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            17)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            18)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            19)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.True.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewArray().CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewMap().CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.False.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.Null.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.Undefined.CanTruncatedIntFitInInt32());\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int32\"] == null) {\n          Assert.Fail();\n        }\n        string numberString = numberinfo[\"number\"].AsString();\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(\n            EDecimal.FromString(numberString));\n        if (numberinfo[\"int32\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.CanTruncatedIntFitInInt32(), numberString);\n        } else {\n          Assert.IsFalse(cbornumber.CanTruncatedIntFitInInt32(), numberString);\n        }\n      }\n\n      Assert.IsFalse(CBORObject.True.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.False.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewArray().CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewMap().CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(2.5)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(Int32.MinValue)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(Int32.MaxValue)\n        .CanTruncatedIntFitInInt32());\n      var negint32 = new object[] {\n        Double.PositiveInfinity,\n        Double.NegativeInfinity,\n        Double.NaN,\n        CBORTestCommon.DecPosInf,\n        CBORTestCommon.DecNegInf,\n        EDecimal.NaN,\n      };\n      foreach (var obj in negint32) {\n        bool bval = ToObjectTest.TestToFromObjectRoundTrip(obj)\n          .CanTruncatedIntFitInInt32();\n        Assert.IsFalse(bval, obj.ToString());\n      }\n    }\n\n    [Test]\n    public void TestCanTruncatedIntFitInInt64() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            11)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            12)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            13)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            14)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            15)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            16)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            17)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            18)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            19)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0)\n        .CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.True.CanTruncatedIntFitInInt64());\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.NewArray().CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.NewMap().CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.False.CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.Null.CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.Undefined.CanTruncatedIntFitInInt64());\n\n      EInteger ei;\n      ei = EInteger.FromString(\"9223372036854775807\");\n      {\n        bool btemp = CBORObject.FromObject(ei)\n          .CanTruncatedIntFitInInt64();\n        Assert.IsTrue(btemp, ei.ToString());\n      }\n      ei = EInteger.FromString(\"9223372036854775808\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775807\");\n      Assert.IsTrue(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775808\");\n      Assert.IsTrue(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775809\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223373136366403584\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"9223373136366403584\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      var strings = new string[] {\n        \"8000FFFFFFFF0000\",\n        \"8000AAAAAAAA0000\",\n        \"8000800080000000\",\n        \"8000000100010000\",\n        \"8000FFFF00000000\",\n        \"80000000FFFF0000\",\n        \"8000800000000000\",\n        \"8000000080000000\",\n        \"8000AAAA00000000\",\n        \"80000000AAAA0000\",\n        \"8000000100000000\",\n        \"8000000000010000\",\n      };\n      foreach (var str in strings) {\n        ei = EInteger.FromRadixString(str, 16);\n        Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64());\n        ei = ei.Negate();\n        Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64());\n      }\n\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        string numberString = numberinfo[\"number\"].AsString();\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberString));\n        if (numberinfo[\"int64\"].AsBoolean()) {\n          Assert.IsTrue(\n            cbornumber.CanTruncatedIntFitInInt64(),\n            numberString);\n        } else {\n          Assert.IsFalse(\n            cbornumber.CanTruncatedIntFitInInt64(),\n            numberString);\n        }\n      }\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo2() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x00, 0x00, 0x00, (byte)0xd3, (byte)0xe1, 0x26,\n        (byte)0xf9, 0x3b, (byte)0xc2, 0x4c, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01,\n        0x01, 0x00, 0x00, 0x01, 0x00, 0x00,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x3b, 0x00, 0x00, 0x00, 0x56, (byte)0xe9, 0x21, (byte)0xda,\n        (byte)0xe9, (byte)0xc2, 0x58, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,\n        0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01,\n        0x00,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestGreater(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo6() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x1b, 0x00, 0x00, 0x00, 0x7a, 0x50, (byte)0xe0, 0x1f,\n        (byte)0xc6, (byte)0xc2, 0x4c, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01,\n        0x00, 0x00, 0x00, 0x01, 0x01,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x19, 0x01, 0x60, (byte)0xc2, 0x58, (byte)0x87, (byte)0xbb,\n        (byte)0xf8, 0x74, (byte)0xbe, (byte)0xcc, 0x46, 0x6b, 0x02, 0x3c,\n        (byte)0x84, (byte)0xe9, (byte)0xd1, (byte)0xe9, 0x3c, (byte)0xd3,\n        (byte)0xd5, 0x20, (byte)0xc1, 0x7e, 0x17, 0x09, 0x0f, (byte)0xdd, 0x73,\n        0x5d, (byte)0xe4, 0x51, (byte)0xd6, 0x10, 0x52, 0x2e, 0x6c, 0x77,\n        (byte)0x9f, 0x5e, 0x4f, 0x58, 0x72, 0x38, 0x43, (byte)0xb0, 0x28, 0x5a,\n        0x6c, (byte)0xe5, (byte)0xd2, 0x36, (byte)0x9e, 0x69, 0x50, (byte)0xf9,\n        0x62, 0x7f, (byte)0xcb, (byte)0xf5, 0x12, (byte)0x8c, 0x37, 0x2d,\n        (byte)0x8e, 0x4f, (byte)0x83, 0x5c, (byte)0xd6, 0x6d, 0x5e, (byte)0xf0,\n        0x65, 0x12, 0x4a, 0x0a, (byte)0x81, (byte)0x89, (byte)0xed, 0x20, 0x50,\n        (byte)0xca, 0x0e, (byte)0x81, (byte)0xbc, (byte)0x9e, (byte)0x83, 0x66,\n        (byte)0xb1, (byte)0xcd, 0x23, (byte)0xee, 0x24, 0x2e, (byte)0xec, 0x77,\n        0x13, (byte)0x89, (byte)0xbd, (byte)0xfb, 0x47, (byte)0xd1, 0x02, 0x1c,\n        0x4e, (byte)0xf5, 0x30, 0x59, 0x75, (byte)0xce, (byte)0xa8, (byte)0xaf,\n        0x23, 0x51, 0x7e, 0x26, (byte)0xaa, (byte)0xed, (byte)0xe9, 0x34, 0x02,\n        0x31, 0x70, (byte)0xe3, 0x3f, 0x71, (byte)0x9a, (byte)0x9a, (byte)0xe9,\n        (byte)0xf3, 0x6d, (byte)0xd7, 0x28, 0x18, (byte)0xa2, (byte)0xb5,\n        (byte)0x8b, (byte)0xca, 0x11, (byte)0x99,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestReciprocal(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo5() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x1b, 0x00, 0x00, 0x10, 0x57, (byte)0xa5, (byte)0x96,\n        (byte)0xbe, 0x7b, (byte)0xc2, 0x53, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,\n        0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,\n        0x00,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x19, 0x01, (byte)0x84, (byte)0xc2, 0x53, 0x20, 0x44, 0x52,\n        0x64, (byte)0x9d, (byte)0xea, (byte)0xe8, 0x57, 0x13, (byte)0xa3, 0x7c,\n        (byte)0xeb, 0x5e, 0x0e, 0x54, (byte)0xc8, (byte)0xf0, (byte)0xb2,\n        0x58,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestReciprocal(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x00, 0x00, 0x00, 0x15, (byte)0xfc, (byte)0xa0,\n        (byte)0xd9, (byte)0xf9, (byte)0xc3, 0x58, 0x36, 0x02, (byte)0x83, 0x3b,\n        0x3c, (byte)0x99, (byte)0xdb, (byte)0xe4, (byte)0xfc, 0x2a, 0x69, 0x69,\n        (byte)0xe7, 0x63, (byte)0xb7, 0x5d, 0x48, (byte)0xcf, 0x51, 0x33,\n        (byte)0xd7, (byte)0xc3, 0x59, 0x4d, 0x63, 0x3c, (byte)0xbb, (byte)0x9d,\n        0x43, 0x2d, (byte)0xd1, 0x51, 0x39, 0x1f, 0x03, 0x22, 0x5c, 0x13,\n        (byte)0xed, 0x02, (byte)0xca, (byte)0xda, 0x09, 0x22, 0x07, (byte)0x9f,\n        0x34, (byte)0x84, (byte)0xb4, 0x22, (byte)0xa8, 0x26, (byte)0x9f, 0x35,\n        (byte)0x8d,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x24, 0x26,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestGreater(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo3() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x04, 0x55, 0x0a, 0x12, (byte)0x94, (byte)0xf8, 0x1f,\n        (byte)0x9b, (byte)0xc2, 0x58, 0x1f, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,\n        0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01,\n        0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01,\n        0x00,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x39, 0x02, 0x03, (byte)0xc2, 0x58, 0x2d, 0x01, 0x00, 0x00,\n        0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,\n        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n        0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,\n        0x01, 0x01, 0x00, 0x01, 0x00, 0x01,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestLess(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo4() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x2f, 0x3b, 0x00, 0x1e, (byte)0xdc, 0x5d, 0x51, 0x5d, 0x26,\n        (byte)0xb7,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x00, 0x18, 0x72, 0x44, 0x49, (byte)0xd0, 0x0c,\n        (byte)0xb6, (byte)0xc3, 0x58, (byte)0x88, 0x0a, (byte)0xd0, 0x12,\n        (byte)0x93, (byte)0xcb, 0x0a, 0x30, 0x2d, 0x11, 0x36, 0x59, 0x5a,\n        (byte)0xfe, (byte)0x81, 0x79, (byte)0x80, (byte)0x86, (byte)0xb8, 0x2f,\n        0x26, 0x4b, (byte)0xf4, 0x70, (byte)0xb4, 0x37, 0x3b, 0x7a, 0x1d,\n        (byte)0x89, 0x4b, (byte)0xd4, 0x75, 0x07, (byte)0xad, 0x0c, (byte)0x90,\n        0x6b, 0x1f, 0x53, (byte)0xf7, (byte)0xc3, (byte)0xde, 0x61, (byte)0xf2,\n        0x62, 0x78, (byte)0x8a, 0x29, 0x31, 0x44, (byte)0xdd, 0x20, (byte)0xa4,\n        0x79, 0x76, 0x59, (byte)0xb7, (byte)0xf7, 0x7c, 0x37, (byte)0xb8, 0x47,\n        (byte)0xcf, (byte)0x96, (byte)0xf8, (byte)0x85, (byte)0xae, (byte)0xee,\n        (byte)0xb4, 0x06, 0x13, (byte)0xef, (byte)0xd1, (byte)0xe6, 0x36,\n        (byte)0xa5, (byte)0xfe, (byte)0xec, (byte)0x8f, (byte)0x8e, 0x00,\n        (byte)0xaa, (byte)0xc2, (byte)0xd4, 0x77, (byte)0xcf, (byte)0xea,\n        (byte)0xff, 0x4d, 0x12, 0x0b, (byte)0xf5, 0x08, (byte)0xc4, 0x0f, 0x08,\n        (byte)0xa7, 0x07, (byte)0xb6, 0x45, 0x47, (byte)0x89, (byte)0xba, 0x5a,\n        (byte)0xde, 0x6c, 0x69, 0x6a, 0x49, (byte)0xba, (byte)0xb2, (byte)0xd9,\n        0x0f, (byte)0x9c, (byte)0xa4, (byte)0xec, 0x48, (byte)0xd2, 0x71, 0x50,\n        (byte)0xde, (byte)0x96, (byte)0x99, (byte)0x9e, (byte)0x89, 0x33,\n        (byte)0x8f, 0x6f, (byte)0xa8, 0x30, (byte)0xa1, 0x0a, 0x0f, (byte)0xab,\n        (byte)0xfe, (byte)0xbe,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestLess(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    private static string TrimStr(string str, int len) {\n      return str.Substring(0, Math.Min(len, str.Length));\n    }\n\n    [Test]\n    public void CompareLongDouble() {\n      CBORObject cbor1 = CBORObject.FromObject(3.5E-15);\n      CBORObject cbor2 = CBORObject.FromObject(281479271677953L);\n      TestCommon.CompareTestLess(cbor1.AsDouble(), cbor2.AsDouble());\n    }\n\n    [Test]\n    [Timeout(300000)]\n    public void TestCompareTo() {\n      var r = new RandomGenerator();\n      const int CompareCount = 3000;\n      var list = new List<CBORObject>();\n      for (var i = 0; i < CompareCount; ++i) {\n        CBORObject o1 = CBORTestCommon.RandomCBORObject(r);\n        CBORObject o2 = CBORTestCommon.RandomCBORObject(r);\n        CBORObject o3 = CBORTestCommon.RandomCBORObject(r);\n        TestCommon.CompareTestRelations(o1, o2, o3);\n      }\n      Console.WriteLine(\"Check compare\");\n      for (var i = 0; i < list.Count; ++i) {\n        int j;\n        j = i + 1;\n        for (; j < list.Count; ++j) {\n          CBORObject o1 = list[i];\n          CBORObject o2 = list[j];\n          TestCommon.CompareTestReciprocal(o1, o2);\n        }\n      }\n      Console.WriteLine(\"Sorting\");\n      list.Sort();\n      Console.WriteLine(\"Check compare 2\");\n      for (var i = 0; i < list.Count - 1; ++i) {\n        CBORObject o1 = list[i];\n        CBORObject o2 = list[i + 1];\n        TestCommon.CompareTestLessEqual(o1, o2);\n      }\n      for (var i = 0; i < 5000; ++i) {\n        CBORObject o1 = CBORTestCommon.RandomNumber(r);\n        CBORObject o2 = CBORTestCommon.RandomNumber(r);\n        CompareDecimals(o1, o2);\n      }\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(0.1),\n        ToObjectTest.TestToFromObjectRoundTrip(0.1));\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(0.1f),\n        ToObjectTest.TestToFromObjectRoundTrip(0.1f));\n      for (var i = 0; i < 50; ++i) {\n        CBORObject o1 =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.NegativeInfinity);\n        CBORObject o2 = CBORTestCommon.RandomNumberOrRational(r);\n        if (o2.AsNumber().IsInfinity() || o2.AsNumber().IsNaN()) {\n          continue;\n        }\n        TestCommon.CompareTestLess(o1.AsNumber(), o2.AsNumber());\n        o1 = ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        TestCommon.CompareTestLess(o1.AsNumber(), o2.AsNumber());\n        o1 = ToObjectTest.TestToFromObjectRoundTrip(Single.PositiveInfinity);\n        TestCommon.CompareTestGreater(o1.AsNumber(), o2.AsNumber());\n        o1 = ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        TestCommon.CompareTestGreater(o1.AsNumber(), o2.AsNumber());\n      }\n      byte[] bytes1 = { 0, 1 };\n      byte[] bytes2 = { 0, 2 };\n      byte[] bytes3 = { 1, 1 };\n      byte[] bytes4 = { 1, 2 };\n      byte[] bytes5 = { 0, 2, 0 };\n      byte[] bytes6 = { 1, 1, 4 };\n      byte[] bytes7 = { 1, 2, 6 };\n      CBORObject[] sortedObjects = {\n        ToObjectTest.TestToFromObjectRoundTrip(bytes1),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes2),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes3),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes4),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes5),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes6),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes7),\n        ToObjectTest.TestToFromObjectRoundTrip(\"aa\"),\n        ToObjectTest.TestToFromObjectRoundTrip(\"ab\"),\n        ToObjectTest.TestToFromObjectRoundTrip(\"ba\"),\n        ToObjectTest.TestToFromObjectRoundTrip(\"abc\"),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORObject.NewArray()),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORObject.NewMap()),\n        CBORObject.FromSimpleValue(0),\n        CBORObject.FromSimpleValue(1),\n        CBORObject.FromSimpleValue(19), CBORObject.FromSimpleValue(32),\n        CBORObject.FromSimpleValue(255),\n        ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity),\n      };\n      for (var i = 0; i < sortedObjects.Length; ++i) {\n        for (int j = i; j < sortedObjects.Length; ++j) {\n          if (i == j) {\n            TestCommon.CompareTestEqual(sortedObjects[i], sortedObjects[j]);\n          } else {\n            TestCommon.CompareTestLess(sortedObjects[i], sortedObjects[j]);\n          }\n        }\n        Assert.AreEqual(1, sortedObjects[i].CompareTo(null));\n      }\n      CBORNumber sp =\n        CBORObject.FromObject(Single.PositiveInfinity).AsNumber();\n      CBORNumber sn = CBORObject.FromObject(\n          Single.NegativeInfinity).AsNumber();\n      CBORNumber snan = CBORObject.FromObject(Single.NaN).AsNumber();\n      CBORNumber dp = CBORObject.FromObject(\n          Double.PositiveInfinity).AsNumber();\n      CBORNumber dn = CBORObject.FromObject(\n          Double.NegativeInfinity).AsNumber();\n      CBORNumber dnan = CBORObject.FromObject(Double.NaN).AsNumber();\n      TestCommon.CompareTestEqual(sp, sp);\n      TestCommon.CompareTestEqual(sp, dp);\n      TestCommon.CompareTestEqual(dp, dp);\n      TestCommon.CompareTestEqual(sn, sn);\n      TestCommon.CompareTestEqual(sn, dn);\n      TestCommon.CompareTestEqual(dn, dn);\n      TestCommon.CompareTestEqual(snan, snan);\n      TestCommon.CompareTestEqual(snan, dnan);\n      TestCommon.CompareTestEqual(dnan, dnan);\n      TestCommon.CompareTestLess(sn, sp);\n      TestCommon.CompareTestLess(sn, dp);\n      TestCommon.CompareTestLess(sn, snan);\n      TestCommon.CompareTestLess(sn, dnan);\n      TestCommon.CompareTestLess(sp, snan);\n      TestCommon.CompareTestLess(sp, dnan);\n      TestCommon.CompareTestLess(dn, dp);\n      TestCommon.CompareTestLess(dp, dnan);\n      TestCommon.CompareTestLess(dn, dnan);\n      Assert.AreEqual(1, CBORObject.True.CompareTo(null));\n      Assert.AreEqual(1, CBORObject.False.CompareTo(null));\n      Assert.AreEqual(1, CBORObject.Null.CompareTo(null));\n      Assert.AreEqual(1, CBORObject.NewArray().CompareTo(null));\n      Assert.AreEqual(1, CBORObject.NewMap().CompareTo(null));\n      {\n        long numberTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(100).CompareTo(null);\n        Assert.AreEqual(1, numberTemp);\n      }\n      {\n        long numberTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NaN).CompareTo(null);\n        Assert.AreEqual(1, numberTemp);\n      }\n      TestCommon.CompareTestLess(\n        ToObjectTest.TestToFromObjectRoundTrip(0).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(1).AsNumber());\n      TestCommon.CompareTestLess(\n        ToObjectTest.TestToFromObjectRoundTrip(0.0f).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(1.0f).AsNumber());\n      TestCommon.CompareTestLess(\n        ToObjectTest.TestToFromObjectRoundTrip(0.0).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(1.0).AsNumber());\n      TestCommon.CompareTestEqual(\n        CBORObject.FromObject(10).AsNumber(),\n        CBORObject.FromObject(ERational.Create(10, 1)).AsNumber());\n    }\n\n    [Test]\n    public void TestContainsKey() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestCount() {\n      Assert.AreEqual(0, CBORObject.True.Count);\n      Assert.AreEqual(0, CBORObject.False.Count);\n      Assert.AreEqual(0, CBORObject.NewArray().Count);\n      Assert.AreEqual(0, CBORObject.NewMap().Count);\n    }\n\n    [Test]\n    public void TestDecodeFromBytes() {\n      try {\n        CBORObject.DecodeFromBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0 }, null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0x1c });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0x1e });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0xfe });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0xff });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestDecodeFromBytesNoDuplicateKeys() {\n      byte[] bytes;\n      bytes = new byte[] { 0xa2, 0x01, 0x00, 0x02, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x01, 0x00, 0x01, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x01, 0x00, 0x01, 0x03 };\n      try {\n        string opts = \"allowduplicatekeys=1;useindeflengthstrings=1\";\n        CBORObject.DecodeFromBytes(bytes,\n          new CBOREncodeOptions(opts));\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x60, 0x00, 0x60, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] {\n        0xa3, 0x60, 0x00, 0x62, 0x41, 0x41, 0x00, 0x60,\n        0x03,\n      };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x61, 0x41, 0x00, 0x61, 0x41, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestDecodeSequenceFromBytes() {\n      CBORObject[] objs;\n      byte[] bytes;\n      bytes = new byte[] { 0 };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(1, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      bytes = new byte[] { 0, 1, 2 };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(2), objs[2]);\n      bytes = new byte[] { 0, 1, 0x61 };\n      try {\n        CBORObject.DecodeSequenceFromBytes(bytes);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0x61 };\n      try {\n        CBORObject.DecodeSequenceFromBytes(bytes);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0, 1, 0x61, 0x41 };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"A\"), objs[2]);\n      bytes = new byte[] { };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(0, objs.Length);\n      try {\n        CBORObject.DecodeSequenceFromBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeSequenceFromBytes(bytes, null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestReadSequence() {\n      CBORObject[] objs;\n      byte[] bytes;\n      bytes = new byte[] { 0 };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(1, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      bytes = new byte[] { 0, 1, 2 };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(2), objs[2]);\n      bytes = new byte[] { 0, 1, 0x61 };\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadSequence(ms);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      bytes = new byte[] { 0x61 };\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadSequence(ms);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      bytes = new byte[] { 0, 1, 0x61, 0x41 };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"A\"), objs[2]);\n      bytes = new byte[] { };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(0, objs.Length);\n      try {\n        CBORObject.ReadSequence(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadSequence(ms, null);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    [Test]\n    public void TestEncodeFloat64() {\n      try {\n        var rg = new RandomGenerator();\n        var options = new CBOREncodeOptions(\"float64=true\");\n        for (var i = 0; i < 10000; ++i) {\n          double dbl = 0.0;\n          dbl = (i == 0) ? Double.PositiveInfinity : ((i == 1) ?\n              Double.NegativeInfinity : RandomObjects.RandomDouble(rg));\n          CBORObject cbor = CBORObject.FromObject(dbl);\n          byte[] bytes = cbor.EncodeToBytes(options);\n          Assert.AreEqual(9, bytes.Length);\n          TestCommon.AssertEqualsHashCode(\n            cbor,\n            CBORObject.DecodeFromBytes(bytes));\n          using (var ms = new MemoryStream()) {\n            cbor.WriteTo(ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(9, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(dbl, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(9, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(9, bytes.Length);\n          }\n          CBORObject cbor2 = CBORObject.NewArray().Add(cbor);\n          bytes = cbor2.EncodeToBytes(options);\n          TestCommon.AssertEqualsHashCode(\n            cbor2,\n            CBORObject.DecodeFromBytes(bytes));\n          Assert.AreEqual(10, bytes.Length);\n          using (var ms = new MemoryStream()) {\n            cbor2.WriteTo(ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor2, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n          cbor2 = cbor.WithTag(1);\n          bytes = cbor2.EncodeToBytes(options);\n          Assert.AreEqual(10, bytes.Length);\n          TestCommon.AssertEqualsHashCode(\n            cbor2,\n            CBORObject.DecodeFromBytes(bytes));\n          using (var ms = new MemoryStream()) {\n            cbor2.WriteTo(ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor2, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static readonly int[] EtbRanges = {\n      -24, 23, 1,\n      -256, -25, 2,\n      24, 255, 2,\n      256, 266, 3,\n      -266, -257, 3,\n      65525, 65535, 3,\n      -65536, -65525, 3,\n      65536, 65546, 5,\n      -65547, -65537, 5,\n    };\n\n    [Test]\n    public void TestEncodeToBytes() {\n      // Test minimum data length\n      int[] ranges = EtbRanges;\n      string[] bigRanges = {\n        \"4294967285\", \"4294967295\",\n        \"4294967296\", \"4294967306\",\n        \"18446744073709551604\", \"18446744073709551615\",\n        \"-4294967296\", \"-4294967286\",\n        \"-4294967306\", \"-4294967297\",\n        \"-18446744073709551616\", \"-18446744073709551604\",\n      };\n      int[] bigSizes = { 5, 9, 9, 5, 9, 9 };\n      for (int i = 0; i < ranges.Length; i += 3) {\n        for (int j = ranges[i]; j <= ranges[i + 1]; ++j) {\n          CBORObject bcbor = ToObjectTest.TestToFromObjectRoundTrip(j);\n          byte[] bytes = CBORTestCommon.CheckEncodeToBytes(bcbor);\n          if (bytes.Length != ranges[i + 2]) {\n            string i2s = TestCommon.IntToString(j);\n            Assert.AreEqual(\n              ranges[i + 2],\n              bytes.Length,\n              i2s);\n          }\n          bytes =\n            ToObjectTest.TestToFromObjectRoundTrip(j).EncodeToBytes(new\n              CBOREncodeOptions(false, false, true));\n          if (bytes.Length != ranges[i + 2]) {\n            string i2s = TestCommon.IntToString(j);\n            Assert.AreEqual(\n              ranges[i + 2],\n              bytes.Length,\n              i2s);\n          }\n        }\n      }\n      string veryLongString = TestCommon.Repeat(\"x\", 10000);\n      byte[] stringBytes =\n        ToObjectTest.TestToFromObjectRoundTrip(veryLongString)\n        .EncodeToBytes(new CBOREncodeOptions(false, false, true));\n      Assert.AreEqual(10003, stringBytes.Length);\n      stringBytes = ToObjectTest.TestToFromObjectRoundTrip(veryLongString)\n        .EncodeToBytes(new CBOREncodeOptions(false, true));\n      Assert.AreEqual(10003, stringBytes.Length);\n      for (int i = 0; i < bigRanges.Length; i += 2) {\n        EInteger bj = EInteger.FromString(bigRanges[i]);\n        EInteger valueBjEnd = EInteger.FromString(bigRanges[i + 1]);\n        while (bj < valueBjEnd) {\n          CBORObject cbor = ToObjectTest.TestToFromObjectRoundTrip(bj);\n          byte[] bytes = CBORTestCommon.CheckEncodeToBytes(cbor);\n          if (bytes.Length != bigSizes[i / 2]) {\n            Assert.Fail(bj.ToString() + \"\\n\" +\n              TestCommon.ToByteArrayString(bytes));\n          }\n          bytes = ToObjectTest.TestToFromObjectRoundTrip(bj)\n            .EncodeToBytes(new CBOREncodeOptions(false, false, true));\n          if (bytes.Length != bigSizes[i / 2]) {\n            Assert.Fail(bj.ToString() + \"\\n\" +\n              TestCommon.ToByteArrayString(bytes));\n          }\n          bj += EInteger.One;\n        }\n      }\n      try {\n        CBORObject.True.EncodeToBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestItem() {\n      CBORObject cbor;\n      CBORObject dummy = CBORObject.True;\n      cbor = CBORObject.NewArray().Add(1).Add(2);\n      Assert.AreEqual(1, cbor[0].AsInt32());\n      Assert.AreEqual(2, cbor[1].AsInt32());\n      Assert.AreEqual(1, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(2, cbor[CBORObject.FromObject(1)].AsInt32());\n      try {\n        dummy = cbor[-1];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        dummy = cbor[2];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        dummy = cbor[CBORObject.FromObject(-1)];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        dummy = cbor[CBORObject.FromObject(2)];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor[0] = CBORObject.FromObject(3);\n      cbor[1] = CBORObject.FromObject(4);\n      Assert.AreEqual(3, cbor[0].AsInt32());\n      Assert.AreEqual(4, cbor[1].AsInt32());\n      Assert.AreEqual(3, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(4, cbor[CBORObject.FromObject(1)].AsInt32());\n      try {\n        cbor[-1] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[2] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(-1)] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(2)] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      var bytes = new byte[] { 1, 2, 3, 4 };\n      var othercbor = new CBORObject[] {\n        CBORObject.FromObject(9), CBORObject.True,\n        CBORObject.FromObject(bytes),\n        CBORObject.False, CBORObject.Null, CBORObject.FromObject(\"test\"),\n        CBORObject.FromObject(99999), CBORObject.FromObject(-1),\n      };\n      foreach (CBORObject c2 in othercbor) {\n        try {\n          dummy = c2[0];\n          Assert.Fail(\"Should have failed\");\n        } catch (InvalidOperationException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          dummy = c2[CBORObject.FromObject(0)];\n          Assert.Fail(\"Should have failed\");\n        } catch (InvalidOperationException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      cbor = CBORObject.NewMap().Add(0, 1).Add(-1, 2);\n      Assert.AreEqual(1, cbor[0].AsInt32());\n      Assert.AreEqual(2, cbor[-1].AsInt32());\n      Assert.AreEqual(1, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(2, cbor[CBORObject.FromObject(-1)].AsInt32());\n      if (cbor[-2] != null) {\n        Assert.Fail();\n      }\n      if (cbor[2] != null) {\n        Assert.Fail();\n      }\n      if (cbor[\"test\"] != null) {\n        Assert.Fail();\n      }\n      if (cbor[CBORObject.FromObject(-2)] != null) {\n        Assert.Fail();\n      }\n      if (cbor[CBORObject.FromObject(2)] != null) {\n        Assert.Fail();\n      }\n      if (cbor[CBORObject.FromObject(\"test\")] != null) {\n        Assert.Fail();\n      }\n      cbor[0] = CBORObject.FromObject(3);\n      cbor[-1] = CBORObject.FromObject(4);\n      Assert.AreEqual(3, cbor[0].AsInt32());\n      Assert.AreEqual(4, cbor[-1].AsInt32());\n      Assert.AreEqual(3, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(4, cbor[CBORObject.FromObject(-1)].AsInt32());\n      try {\n        cbor[-2] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[-2]);\n      try {\n        cbor[2] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(-2)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(2)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[2]);\n      try {\n        cbor[CBORObject.FromObject(-5)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[-5]);\n      try {\n        cbor[CBORObject.FromObject(5)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[-5]);\n    }\n\n    [Test]\n    public void TestEquals() {\n      var cborbytes = new byte[] {\n        (byte)0xd8, 0x1e, (byte)0x82, 0x00, 0x19,\n        0x0f, 0x50,\n      };\n      CBORObject cbor = CBORObject.DecodeFromBytes(cborbytes);\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(cborbytes);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      ERational erat = ERational.Create(0, 3920);\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(erat);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(cbor2);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      TestWriteObj(erat, erat);\n      erat = ERational.Create(\n          EInteger.Zero,\n          EInteger.FromString(\"84170882933504200501581262010093\"));\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(erat);\n      ERational erat2 = ERational.Create(\n          EInteger.Zero,\n          EInteger.FromString(\"84170882933504200501581262010093\"));\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(erat2);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(cbor2);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      TestWriteObj(cbor, cbor2);\n      TestWriteObj(erat, erat2);\n    }\n\n    private static void CompareTestNumber(CBORObject o1, CBORObject o2) {\n      TestCommon.CompareTestEqual(o1.AsNumber(), o2.AsNumber());\n    }\n\n    [Test]\n    public void TestEquivalentNegativeInfinity() {\n      CompareTestNumber(\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecNegInf),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf));\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n    }\n\n    [Test]\n    public void TestEquivalentPositiveInfinity() {\n      CompareTestNumber(\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecPosInf),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatPosInf));\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.RatPosInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.RatPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.RatPosInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n    }\n\n    [Test]\n    public void TestFalse() {\n      CBORTestCommon.AssertJSONSer(CBORObject.False, \"false\");\n      Assert.AreEqual(\n        CBORObject.False,\n        ToObjectTest.TestToFromObjectRoundTrip(false));\n    }\n\n    [Test]\n    [Timeout(100000)]\n    public void TestFromJSONString() {\n      var charbuf = new char[4];\n      CBORObject cbor;\n      // Test single-character strings\n      for (var i = 0; i < 0x110000; ++i) {\n        if (i >= 0xd800 && i < 0xe000) {\n          continue;\n        }\n        string str = CharString(i, true, charbuf);\n        if (i < 0x20 || i == 0x22 || i == 0x5c) {\n          TestFailingJSON(str);\n        } else {\n          cbor = TestSucceedingJSON(str);\n          string exp = CharString(i, false, charbuf);\n          if (!exp.Equals(cbor.AsString(), StringComparison.Ordinal)) {\n            Assert.AreEqual(exp, cbor.AsString());\n          }\n        }\n      }\n      foreach (string str in ValueJsonFails) {\n        TestFailingJSON(str);\n      }\n      foreach (string str in ValueJsonSucceeds) {\n        TestSucceedingJSON(str);\n      }\n      try {\n        CBORObject.FromJSONString(\"\\ufeff\\u0020 {}\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromJSONString(\"[]\", (CBOREncodeOptions)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromJSONString(\"[]\", (JSONOptions)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      TestFailingJSON(\"{\\\"a\\\":1,\\\"a\\\":2}\", ValueNoDuplicateKeys);\n      string aba = \"{\\\"a\\\":1,\\\"b\\\":3,\\\"a\\\":2}\";\n      TestFailingJSON(aba, ValueNoDuplicateKeys);\n      cbor = TestSucceedingJSON(aba, new JSONOptions(\"allowduplicatekeys=1\"));\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(2), cbor[\"a\"]);\n      aba = \"{\\\"a\\\":1,\\\"a\\\":4}\";\n      cbor = TestSucceedingJSON(aba, new JSONOptions(\"allowduplicatekeys=1\"));\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(4), cbor[\"a\"]);\n      aba = \"{\\\"a\\\" :1}\";\n      cbor = TestSucceedingJSON(aba);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(1), cbor[\"a\"]);\n      aba = \"{\\\"a\\\" : 1}\";\n      cbor = TestSucceedingJSON(aba);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(1), cbor[\"a\"]);\n      cbor = TestSucceedingJSON(\"\\\"\\\\t\\\"\");\n      {\n        string stringTemp = cbor.AsString();\n        Assert.AreEqual(\n          \"\\t\",\n          stringTemp);\n      }\n      Assert.AreEqual(CBORObject.True, TestSucceedingJSON(\"true\"));\n      Assert.AreEqual(CBORObject.False, TestSucceedingJSON(\"false\"));\n      Assert.AreEqual(CBORObject.Null, TestSucceedingJSON(\"null\"));\n      Assert.AreEqual(5, TestSucceedingJSON(\" 5 \").AsInt32());\n      {\n        string stringTemp = TestSucceedingJSON(\"\\\"\\\\/\\\\b\\\"\").AsString();\n        Assert.AreEqual(\n          \"/\\b\",\n          stringTemp);\n      }\n      {\n        string stringTemp = TestSucceedingJSON(\"\\\"\\\\/\\\\f\\\"\").AsString();\n        Assert.AreEqual(\n          \"/\\f\",\n          stringTemp);\n      }\n      string jsonTemp = TestCommon.Repeat(\n          \"[\",\n          2000) + TestCommon.Repeat(\n          \"]\",\n          2000);\n      TestFailingJSON(jsonTemp);\n    }\n\n    [Test]\n    public void TestTagArray() {\n      CBORObject obj = CBORObject.FromObjectAndTag(\"test\", 999);\n      EInteger[] etags = obj.GetAllTags();\n      Assert.AreEqual(1, etags.Length);\n      Assert.AreEqual(999, etags[0].ToInt32Checked());\n      obj = ToObjectTest.TestToFromObjectRoundTrip(\"test\");\n      etags = obj.GetAllTags();\n      Assert.AreEqual(0, etags.Length);\n    }\n\n    [Test]\n    public void TestEI() {\n      CBORObject cbor =\n        ToObjectTest.TestToFromObjectRoundTrip(EInteger.FromString(\"100\"));\n      Assert.IsTrue(cbor.IsNumber);\n      {\n        string stringTemp = cbor.ToJSONString();\n        Assert.AreEqual(\n          \"100\",\n          stringTemp);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n            \"200\"));\n      Assert.IsTrue(cbor.IsNumber);\n      {\n        string stringTemp = cbor.ToJSONString();\n        Assert.AreEqual(\n          \"200\",\n          stringTemp);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EFloat.FromString(\"300\"));\n      Assert.IsTrue(cbor.IsNumber);\n      {\n        string stringTemp = cbor.ToJSONString();\n        Assert.AreEqual(\n          \"300\",\n          stringTemp);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(ERational.Create(1, 2));\n      Assert.IsTrue(cbor.IsNumber);\n    }\n\n    [Test]\n    public void TestFromObject() {\n      var cborarray = new CBORObject[2];\n      cborarray[0] = CBORObject.False;\n      cborarray[1] = CBORObject.True;\n      CBORObject cbor = CBORObject.FromObject(cborarray);\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(CBORObject.False, cbor[0]);\n      Assert.AreEqual(CBORObject.True, cbor[1]);\n      CBORTestCommon.AssertRoundTrip(cbor);\n      Assert.AreEqual(\n        CBORObject.Null,\n        CBORObject.FromObject((int[])null));\n      long[] longarray = { 2, 3 };\n      cbor = CBORObject.FromObject(longarray);\n      Assert.AreEqual(2, cbor.Count);\n      Assert.IsTrue(CBORObject.FromObject(2).CompareTo(cbor[0])\n        == 0);\n      Assert.IsTrue(CBORObject.FromObject(3).CompareTo(cbor[1])\n        == 0);\n      CBORTestCommon.AssertRoundTrip(cbor);\n      Assert.AreEqual(\n        CBORObject.Null,\n        CBORObject.FromObject((ERational)null));\n      Assert.AreEqual(\n        CBORObject.Null,\n        CBORObject.FromObject((EDecimal)null));\n      try {\n        CBORObject.FromObject(ERational.Create(10, 2));\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n\n      try {\n        CBORObject.FromObject(CBORObject.FromObject(Double.NaN)\n          .Sign);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.True;\n      try {\n        CBORObject.FromObject(cbor[0]);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[0] = CBORObject.False;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor = CBORObject.False;\n        CBORObject.FromObject(cbor.Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip('\\udddd');\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.NewArray().Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.NewArray().Sign);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.NewMap().Sign);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private static void CheckKeyValue(CBORObject o, string key, object value) {\n      if (!o.ContainsKey(key)) {\n        Assert.Fail(\"Expected \" + key + \" to exist: \" + o.ToString());\n      }\n      TestCommon.AssertEqualsHashCode(o[key], value);\n    }\n\n    public enum EnumClass {\n      /// <summary>Internal API.</summary>\n      Value1,\n\n      /// <summary>Internal API.</summary>\n      Value2,\n\n      /// <summary>Internal API.</summary>\n      Value3,\n    }\n\n    [Test]\n    public void TestFromObject_Enum() {\n      CBORObject cbor;\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EnumClass.Value1);\n      Assert.AreEqual(0, cbor.AsInt32());\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EnumClass.Value2);\n      Assert.AreEqual(1, cbor.AsInt32());\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EnumClass.Value3);\n      Assert.AreEqual(2, cbor.AsInt32());\n    }\n\n    [Test]\n    public void TestToObject_Enum() {\n      CBORObject cbor;\n      EnumClass ec;\n      cbor = CBORObject.FromObject(\"Value1\");\n      ec = (EnumClass)cbor.ToObject(typeof(EnumClass));\n      Assert.AreEqual(EnumClass.Value1, ec);\n      cbor = CBORObject.FromObject(\"Value2\");\n      ec = (EnumClass)cbor.ToObject(typeof(EnumClass));\n      Assert.AreEqual(EnumClass.Value2, ec);\n      cbor = CBORObject.FromObject(\"Value3\");\n      ec = (EnumClass)cbor.ToObject(typeof(EnumClass));\n      Assert.AreEqual(EnumClass.Value3, ec);\n      cbor = CBORObject.FromObject(\"ValueXYZ\");\n      try {\n        cbor.ToObject(typeof(EnumClass));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.FromObject(true);\n      try {\n        cbor.ToObject(typeof(EnumClass));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToObject_UnknownEnum() {\n      CBORObject cbor;\n      cbor = CBORObject.FromObject(999);\n      try {\n        cbor.ToObject(typeof(EnumClass));\n        Assert.Fail(\"Should have failed -- \" +\n          cbor.ToObject(typeof(EnumClass)));\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private sealed class TestConverter : ICBORToFromConverter<string> {\n      public CBORObject ToCBORObject(string strValue) {\n        return CBORObject.FromObject(\n            DataUtilities.ToLowerCaseAscii(strValue));\n      }\n\n      public string FromCBORObject(CBORObject cbor) {\n        if (cbor == null) {\n          throw new ArgumentNullException(nameof(cbor));\n        }\n        if (cbor.Type == CBORType.TextString) {\n          return DataUtilities.ToLowerCaseAscii(cbor.AsString());\n        }\n        throw new CBORException();\n      }\n    }\n\n    [Test]\n    public void TestFromObject_TypeMapper() {\n      var mapper = new CBORTypeMapper()\n      .AddConverter(typeof(string), new TestConverter());\n      CBORObject cbor = CBORObject.FromObject(\"UPPER\", mapper);\n      Assert.AreEqual(CBORType.TextString, cbor.Type);\n      {\n        string stringTemp = cbor.AsString();\n        Assert.AreEqual(\n          \"upper\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"LoWeR\", mapper);\n      Assert.AreEqual(CBORType.TextString, cbor.Type);\n      {\n        string stringTemp = cbor.AsString();\n        Assert.AreEqual(\n          \"lower\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestFromObject_Dictionary() {\n      IDictionary<string, string> dict = new Dictionary<string, string>();\n      dict[\"TestKey\"] = \"TestValue\";\n      dict[\"TestKey2\"] = \"TestValue2\";\n      CBORObject c = CBORObject.FromObject(dict);\n      CheckKeyValue(c, \"TestKey\", \"TestValue\");\n      CheckKeyValue(c, \"TestKey2\", \"TestValue2\");\n      dict = (IDictionary<string, string>)c.ToObject(\n          typeof(IDictionary<string, string>));\n      Assert.AreEqual(2, dict.Keys.Count);\n      Assert.IsTrue(dict.ContainsKey(\"TestKey\"));\n      Assert.IsTrue(dict.ContainsKey(\"TestKey2\"));\n      Assert.AreEqual(\"TestValue\", dict[\"TestKey\"]);\n      Assert.AreEqual(\"TestValue2\", dict[\"TestKey2\"]);\n    }\n\n#pragma warning disable CA1034\n    // nesting a public type is needed\n    // here for testing purposes\n    public sealed class NestedPODClass {\n      public NestedPODClass() {\n        this.PropValue = new PODClass();\n      }\n\n      public PODClass PropValue {\n        get;\n        private set;\n      }\n    }\n#pragma warning restore CA1034\n\n    [Test]\n    public void TestBase64Extras() {\n      // Base64 tests\n      CBORObject o;\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xf0, 0xe8 },\n          23);\n      {\n        string stringTemp = o.ToJSONString();\n        Assert.AreEqual(\n          \"\\\"9AD6F0E8\\\"\",\n          stringTemp);\n      }\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xff, 0xe8,\n      });\n      // Encode with Base64URL by default\n      {\n        string stringTemp = o.ToJSONString();\n        Assert.AreEqual(\n          \"\\\"mtb_6A\\\"\",\n          stringTemp);\n      }\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xff, 0xe8 },\n          22);\n      // Encode with Base64\n      {\n        string stringTemp = o.ToJSONString();\n        Assert.AreEqual(\n          \"\\\"mtb/6A==\\\"\",\n          stringTemp);\n      }\n      var options = new JSONOptions(\"base64padding=1\");\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xff, 0xe8,\n      });\n      // Encode with Base64URL by default\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtb_6A\\\"\",\n          stringTemp);\n      }\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xff, 0xe8 },\n          22);\n      // Encode with Base64\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtb/6A==\\\"\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestFromObject_PODOptions() {\n      var ao = new PODClass();\n      var valueCcTF = new PODOptions(true, false);\n      var valueCcFF = new PODOptions(false, false);\n      var valueCcFT = new PODOptions(false, true);\n      var valueCcTT = new PODOptions(true, true);\n      CBORObject co;\n      CBORObjectTest.CheckPropertyNames(ao);\n      var arrao = new PODClass[] { ao, ao };\n      co = CBORObject.FromObject(arrao, valueCcTF);\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcTF),\n        2,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcFT),\n        2,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcTT),\n        2,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      var ao2 = new NestedPODClass();\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcTF),\n        valueCcTF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcFT),\n        valueCcFT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcTT),\n        valueCcTT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      var aodict = new Dictionary<string, object>();\n      aodict[\"PropValue\"] = new PODClass();\n\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcTF),\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcFT),\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcTT),\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcFF),\n        2,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcFF),\n        valueCcFF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcFF),\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n    }\n\n    [Test]\n    public void TestFromObjectAndTag() {\n      EInteger bigvalue = EInteger.FromString(\"99999999999999999999999999999\");\n      try {\n        CBORObject.FromObjectAndTag(2, bigvalue);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(2, -1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(CBORObject.Null, -1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(CBORObject.Null, 999999);\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      EInteger eintNull = null;\n      try {\n        CBORObject.FromObjectAndTag(2, eintNull);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(2, EInteger.FromString(\"-1\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestFromSimpleValue() {\n      try {\n        CBORObject.FromSimpleValue(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromSimpleValue(256);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      for (int i = 0; i < 256; ++i) {\n        if (i >= 24 && i < 32) {\n          try {\n            CBORObject.FromSimpleValue(i);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          CBORObject cbor = CBORObject.FromSimpleValue(i);\n          Assert.AreEqual(i, cbor.SimpleValue);\n        }\n      }\n    }\n\n    [Test]\n    public void TestWithTag() {\n      EInteger bigvalue = EInteger.FromString(\"99999999999999999999999999999\");\n      try {\n        CBORObject.FromObject(2).WithTag(bigvalue);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(2).WithTag(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.Null).WithTag(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.Null).WithTag(999999);\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      EInteger eintNull = null;\n      try {\n        CBORObject.FromObject(2).WithTag(eintNull);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(2).WithTag(EInteger.FromString(\"-1\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestGetByteString() {\n      try {\n        CBORObject.True.GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(0).GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(\"test\").GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewArray().GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestGetHashCode() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestGetTags() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestHasTag() {\n      try {\n        CBORObject.True.HasTag(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        const EInteger ValueBigintNull = null;\n        CBORObject.True.HasTag(ValueBigintNull);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.HasTag(EInteger.FromString(\"-1\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.IsFalse(CBORObject.True.HasTag(0));\n      Assert.IsFalse(CBORObject.True.HasTag(EInteger.Zero));\n    }\n\n    [Test]\n    public void TestMostInnerTag() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestInsert() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsFalse() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsFinite() {\n      CBORObject cbor;\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .IsFinite);\n      Assert.IsFalse(CBORObject.NewArray().IsFinite);\n      Assert.IsFalse(CBORObject.NewMap().IsFinite);\n      cbor = CBORObject.True;\n      Assert.IsFalse(cbor.IsFinite);\n      cbor = CBORObject.False;\n      Assert.IsFalse(cbor.IsFinite);\n      cbor = CBORObject.Null;\n      Assert.IsFalse(cbor.IsFinite);\n      cbor = CBORObject.Undefined;\n      Assert.IsFalse(cbor.IsFinite);\n      Assert.IsFalse(CBORObject.NewMap().IsFinite);\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).IsFinite);\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(2.5).IsFinite);\n      Assert.IsFalse(\n        ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity)\n        .IsFinite);\n\n      Assert.IsFalse(\n        ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity)\n        .IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(Double.NaN)\n        .IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecPosInf).IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecNegInf).IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(EDecimal.NaN)\n        .IsFinite);\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        EDecimal ed = EDecimal.FromString(numberinfo[\"number\"].AsString());\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(ed);\n        if (numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.IsFinite, numberinfo[\"number\"].AsString());\n        }\n        // NOTE: A nonintegral number is not necessarily non-finite\n      }\n    }\n\n    [Test]\n    public void TestIsInfinity() {\n      Assert.IsTrue(CBORObject.PositiveInfinity.AsNumber().IsInfinity());\n      Assert.IsTrue(CBORObject.NegativeInfinity.AsNumber().IsInfinity());\n      Assert.IsTrue(CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, 0x7f,\n        (byte)0x80, 0x00, 0x00,\n      }).AsNumber().IsInfinity());\n    }\n\n    [Test]\n    public void TestIsIntegral() {\n      CBORObject cbor;\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(String.Empty);\n      Assert.IsFalse(cbor.IsIntegral);\n      Assert.IsFalse(CBORObject.NewArray().IsIntegral);\n      Assert.IsFalse(CBORObject.NewMap().IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(\n          EInteger.FromRadixString(\n            \"8000000000000000\",\n            16));\n      Assert.IsTrue(cbor.IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(\n          EInteger.FromRadixString(\n            \"80000000000000000000\",\n            16));\n      Assert.IsTrue(cbor.IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(\n          EInteger.FromRadixString(\n            \"8000000000000000000000000\",\n            16));\n      Assert.IsTrue(cbor.IsIntegral);\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(\n          EDecimal.FromString(\"4444e+800\")).IsIntegral);\n\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          EDecimal.FromString(\"4444e-800\")).IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(2.5).IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          999.99).IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n\n      Assert.IsFalse(cbor.IsIntegral);\n\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(Double.NaN);\n\n      Assert.IsFalse(cbor.IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecPosInf).IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecNegInf).IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EDecimal.NaN);\n\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.True;\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.False;\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.Null;\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.Undefined;\n      Assert.IsFalse(cbor.IsIntegral);\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.IsIntegral);\n          Assert.IsFalse(cbornumber.AsNumber().IsPositiveInfinity());\n          Assert.IsFalse(cbornumber.AsNumber().IsNegativeInfinity());\n          Assert.IsFalse(cbornumber.AsNumber().IsNaN());\n          Assert.IsFalse(cbornumber.IsNull);\n        } else {\n          Assert.IsFalse(cbornumber.IsIntegral);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsNumber() {\n      try {\n        CBORObject.True.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewArray().AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestAsNumberIsNegativeInfinity() {\n      Assert.IsFalse(CBORObject.FromObject(\n          0).AsNumber().IsNegativeInfinity());\n\n      Assert.IsFalse(\n        CBORObject.PositiveInfinity.AsNumber().IsNegativeInfinity());\n\n      Assert.IsTrue(\n        CBORObject.NegativeInfinity.AsNumber().IsNegativeInfinity());\n      Assert.IsFalse(CBORObject.NaN.AsNumber().IsNegativeInfinity());\n    }\n\n    [Test]\n    public void TestIsNull() {\n      Assert.IsFalse(CBORObject.True.IsNull);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .IsNull);\n      Assert.IsFalse(CBORObject.NewArray().IsNull);\n      Assert.IsFalse(CBORObject.NewMap().IsNull);\n      Assert.IsFalse(CBORObject.False.IsNull);\n      Assert.IsTrue(CBORObject.Null.IsNull);\n      Assert.IsFalse(CBORObject.Undefined.IsNull);\n      Assert.IsFalse(CBORObject.PositiveInfinity.IsNull);\n      Assert.IsFalse(CBORObject.NegativeInfinity.IsNull);\n      Assert.IsFalse(CBORObject.NaN.IsNull);\n    }\n\n    [Test]\n    public void TestAsNumberIsPositiveInfinity() {\n      Assert.IsFalse(CBORObject.FromObject(\n          0).AsNumber().IsPositiveInfinity());\n\n      Assert.IsTrue(\n        CBORObject.PositiveInfinity.AsNumber().IsPositiveInfinity());\n\n      Assert.IsFalse(\n        CBORObject.NegativeInfinity.AsNumber().IsPositiveInfinity());\n      Assert.IsFalse(CBORObject.NaN.AsNumber().IsPositiveInfinity());\n    }\n\n    [Test]\n    public void TestIsTagged() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsTrue() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsUndefined() {\n      Assert.IsFalse(CBORObject.True.IsUndefined);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .IsUndefined);\n      Assert.IsFalse(CBORObject.NewArray().IsUndefined);\n      Assert.IsFalse(CBORObject.NewMap().IsUndefined);\n      Assert.IsFalse(CBORObject.False.IsUndefined);\n      Assert.IsFalse(CBORObject.Null.IsUndefined);\n      Assert.IsTrue(CBORObject.Undefined.IsUndefined);\n      Assert.IsFalse(CBORObject.PositiveInfinity.IsUndefined);\n      Assert.IsFalse(CBORObject.NegativeInfinity.IsUndefined);\n      Assert.IsFalse(CBORObject.NaN.IsUndefined);\n    }\n\n    [Test]\n    public void TestIsZero() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestItem2() {\n      CBORObject cbor = CBORObject.True;\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.False;\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(0);\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(2);\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestGetOrDefault() {\n      CBORObject cbor = CBORObject.NewArray().Add(2).Add(3).Add(7);\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(-1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = CBORObject.FromObject(2);\n        object objectTemp2 = cbor.GetOrDefault(\n            0,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(\n        CBORObject.FromObject(2),\n        cbor.GetOrDefault(CBORObject.FromObject(0), CBORObject.Null));\n      {\n        object objectTemp = CBORObject.FromObject(3);\n        object objectTemp2 = cbor.GetOrDefault(\n            1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = CBORObject.FromObject(7);\n        object objectTemp2 = cbor.GetOrDefault(\n            2,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(3, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(\"key\", \"value\");\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(-1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(0, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.FromObject(2);\n        object objectTemp2 = cbor.GetOrDefault(\n            1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(2, CBORObject.Null));\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(3, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.FromObject(\"value\");\n        object objectTemp2 = cbor.GetOrDefault(\n            \"key\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(\n        CBORObject.FromObject(\"value\"),\n        cbor.GetOrDefault(CBORObject.FromObject(\"key\"), CBORObject.Null));\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key2\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      cbor = CBORObject.False;\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(-1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(0, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key2\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n    }\n\n    private static void Sink(object obj) {\n      Console.WriteLine(\"Sink for \" + obj);\n      Assert.Fail();\n    }\n\n    [Test]\n    public void TestKeys() {\n      CBORObject co;\n      try {\n        co = CBORObject.True;\n        Sink(co.Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(ToObjectTest.TestToFromObjectRoundTrip(0).Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(ToObjectTest.TestToFromObjectRoundTrip(\"string\").Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(CBORObject.NewArray().Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(ToObjectTest.TestToFromObjectRoundTrip(\n            new byte[] { 0 }).Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      if (CBORObject.NewMap().Keys == null) {\n        Assert.Fail();\n      }\n    }\n\n    [Test]\n    [Timeout(200000)]\n    public void TestAsNumberMultiply() {\n      var r = new RandomGenerator();\n      for (var i = 0; i < 3000; ++i) {\n        CBORObject o1 = CBORTestCommon.RandomNumber(r);\n        CBORObject o2 = CBORTestCommon.RandomNumber(r);\n        EDecimal cmpDecFrac = AsED(o1).Multiply(AsED(o2));\n        EDecimal cmpCobj = o1.AsNumber().Multiply(o2.AsNumber()).ToEDecimal();\n        if (!cmpDecFrac.Equals(cmpCobj)) {\n          TestCommon.CompareTestEqual(\n            cmpDecFrac,\n            cmpCobj,\n            o1.ToString() + \"\\n\" + o2.ToString());\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsNumberNegate() {\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(-2).AsNumber().Negate());\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(-2).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber().Negate());\n    }\n\n    [Test]\n    public void TestNegativeTenDigitLong() {\n      CBORObject obj = CBORObject.FromJSONString(\"-1000000000\");\n      {\n        string stringTemp = obj.ToJSONString();\n        Assert.AreEqual(\n          \"-1000000000\",\n          stringTemp);\n      }\n      {\n        string stringTemp = obj.ToString();\n        Assert.AreEqual(\n          \"-1000000000\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestNegativeZero() {\n      CBORObject negzero = ToObjectTest.TestToFromObjectRoundTrip(\n          EDecimal.FromString(\"-0\"));\n      CBORTestCommon.AssertRoundTrip(negzero);\n    }\n\n    [Test]\n    public void TestNewArray() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestNewMap() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorAddition() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorDivision() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorModulus() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorMultiply() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorSubtraction() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestMostOuterTag() {\n      CBORObject cbor = CBORObject.FromObjectAndTag(CBORObject.True, 999);\n      cbor = CBORObject.FromObjectAndTag(CBORObject.True, 1000);\n      Assert.AreEqual(EInteger.FromString(\"1000\"), cbor.MostOuterTag);\n      cbor = CBORObject.True;\n      Assert.AreEqual(EInteger.FromString(\"-1\"), cbor.MostOuterTag);\n    }\n\n    [Test]\n    public void TestRead() {\n      try {\n        CBORObject.Read(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        using (var ms2 = new MemoryStream(new byte[] { 0 })) {\n          try {\n            CBORObject.Read(ms2, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static void ExpectJsonSequenceError(byte[] bytes) {\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadJSONSequence(ms);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    public static void ExpectJsonSequenceZero(byte[] bytes) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          string ss = TestCommon.ToByteArrayString(bytes);\n          CBORObject[] array = CBORObject.ReadJSONSequence(ms);\n          Assert.AreEqual(0, array.Length, ss);\n        }\n      } catch (IOException ioe) {\n        throw new InvalidOperationException(ioe.Message, ioe);\n      }\n    }\n\n    public static void ExpectJsonSequenceOne(byte[] bytes, CBORObject o1) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          string ss = TestCommon.ToByteArrayString(bytes);\n          CBORObject[] array = CBORObject.ReadJSONSequence(ms);\n          Assert.AreEqual(1, array.Length, ss);\n          Assert.AreEqual(o1, array[0], ss);\n        }\n      } catch (IOException ioe) {\n        throw new InvalidOperationException(ioe.Message, ioe);\n      }\n    }\n\n    public static void ExpectJsonSequenceTwo(\n      byte[] bytes,\n      CBORObject o1,\n      CBORObject o2) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          string ss = TestCommon.ToByteArrayString(bytes);\n          CBORObject[] array = CBORObject.ReadJSONSequence(ms);\n          Assert.AreEqual(2, array.Length, ss);\n          Assert.AreEqual(o1, array[0], ss);\n          Assert.AreEqual(o2, array[1], ss);\n        }\n      } catch (IOException ioe) {\n        throw new InvalidOperationException(ioe.Message, ioe);\n      }\n    }\n\n    [Test]\n    public void TestJsonSequence() {\n      byte[] bytes;\n      bytes = new byte[] { };\n      ExpectJsonSequenceZero(bytes);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x20 };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x09 };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0d };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] {\n        0x1e, (byte)0x66, (byte)0x61, (byte)0x6c, (byte)0x73,\n        (byte)0x65, 0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, CBORObject.False);\n      bytes = new byte[] {\n        0x1e, (byte)0x66, (byte)0x61, (byte)0x6c, (byte)0x73,\n        (byte)0x65,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, (byte)0x66, (byte)0x61, (byte)0x6c, (byte)0x73,\n        (byte)0x65, (byte)0x74, (byte)0x72, (byte)0x75, (byte)0x65, 0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, (byte)0x74, (byte)0x72, (byte)0x75, (byte)0x65,\n        0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, CBORObject.True);\n      bytes = new byte[] {\n        0x1e, (byte)0x74, (byte)0x72, (byte)0x75,\n        (byte)0x65,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, (byte)0x6e, (byte)0x75, (byte)0x6c, (byte)0x6c,\n        0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, CBORObject.Null);\n      bytes = new byte[] {\n        0x1e, (byte)0x6e, (byte)0x75, (byte)0x6c,\n        (byte)0x6c,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x1e, (byte)'[', (byte)']' };\n      ExpectJsonSequenceTwo(\n        bytes,\n        CBORObject.FromObject(\"A\"),\n        CBORObject.NewArray());\n      bytes = new byte[] {\n        0x1e, 0x22, 0x41, 0x22, 0x0a, 0x1e, (byte)'[',\n        (byte)']',\n      };\n      ExpectJsonSequenceTwo(\n        bytes,\n        CBORObject.FromObject(\"A\"),\n        CBORObject.NewArray());\n      bytes = new byte[] {\n        0x1e, 0x22, 0x41, 0x22, 0x41, 0x1e, (byte)'[',\n        (byte)']',\n      };\n      ExpectJsonSequenceTwo(bytes, null, CBORObject.NewArray());\n      bytes = new byte[] { 0x1e, 0x1e, 0x22, 0x41, 0x22, 0x0a };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x1e, 0x30, 0x0a };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(0));\n      bytes = new byte[] { 0x1e, 0x1e, 0xef, 0xbb, 0xbf, 0x30, 0x0a };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, 0x1e, 0xef, 0xbb, 0xbf, 0x30, 0x0a, 0x1e, 0x30,\n        0x0a,\n      };\n      ExpectJsonSequenceTwo(bytes, null, CBORObject.FromObject(0));\n      bytes = new byte[] { 0x22, 0x41, 0x22, 0x0a };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0xef, 0xbb, 0xbf, 0x1e, 0x30, 0x0a };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0xfe, 0xff, 0x00, 0x1e, 0, 0x30, 0, 0x0a };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0xff, 0xfe, 0x1e, 0, 0x30, 0, 0x0a, 0 };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a, 0x31, 0x31 };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a, 0x1e };\n      ExpectJsonSequenceTwo(bytes, CBORObject.FromObject(\"A\"), null);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a, 0x31, 0x31, 0x1e };\n      ExpectJsonSequenceTwo(bytes, null, null);\n      bytes = new byte[] { 0x1e };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] { 0x1e, 0x1e };\n      ExpectJsonSequenceOne(bytes, null);\n    }\n\n    [Test]\n    public void TestNonUtf8FromJSONBytes() {\n      byte[] bytes;\n      CBORObject cbor;\n      bytes = new byte[] { 0x31, 0, 0x31, 0 };\n      cbor = CBORObject.FromJSONBytes(bytes);\n      Assert.AreEqual(CBORObject.FromObject(11), cbor);\n      bytes = new byte[] { 0x31, 0, 0, 0, 0x31, 0, 0, 0 };\n      cbor = CBORObject.FromJSONBytes(bytes);\n      Assert.AreEqual(CBORObject.FromObject(11), cbor);\n    }\n\n    [Test]\n    public void TestReadJSON() {\n      try {\n        using (var ms2 = new MemoryStream(new byte[] { 0x30 })) {\n          try {\n            CBORObject.ReadJSON(ms2, (CBOREncodeOptions)null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.ReadJSON(ms2, (JSONOptions)null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var ms = new MemoryStream(new byte[] {\n          0xef, 0xbb, 0xbf,\n          0x7b, 0x7d,\n        })) {\n          try {\n            CBORObject.ReadJSON(ms);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // whitespace followed by BOM\n        using (var ms2 = new MemoryStream(new byte[] {\n          0x20, 0xef, 0xbb,\n          0xbf, 0x7b, 0x7d,\n        })) {\n          try {\n            CBORObject.ReadJSON(ms2);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var ms2a = new MemoryStream(new byte[] { 0x7b, 0x05, 0x7d })) {\n          try {\n            CBORObject.ReadJSON(ms2a);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var ms2b = new MemoryStream(new byte[] { 0x05, 0x7b, 0x7d })) {\n          try {\n            CBORObject.ReadJSON(ms2b);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // two BOMs\n        using (var ms3 = new MemoryStream(new byte[] {\n          0xef, 0xbb, 0xbf,\n          0xef, 0xbb, 0xbf, 0x7b, 0x7d,\n        })) {\n          try {\n            CBORObject.ReadJSON(ms3);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0,\n          0,\n          0x74, 0, 0, 0, 0x72, 0, 0, 0, 0x75, 0, 0, 0,\n          0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x74, 0, 0,\n          0, 0x72, 0,\n          0, 0, 0x75, 0, 0, 0, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0, 0,\n          0x74, 0, 0, 0,\n          0x72, 0, 0, 0, 0x75, 0, 0, 0, 0x65, 0, 0, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x74, 0, 0, 0, 0x72,\n          0,\n          0,\n          0,\n          0x75, 0, 0, 0, 0x65, 0, 0, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0, 0x74,\n          0, 0x72, 0,\n          0x75, 0, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0x74, 0, 0x72, 0,\n          0x75, 0, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x74, 0,\n          0x72,\n          0,\n          0x75,\n          0, 0x65, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x74, 0, 0x72, 0,\n          0x75, 0, 0x65, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xef, 0xbb, 0xbf,\n          0x74, 0x72, 0x75, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x74, 0x72, 0x75,\n          0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0, 0x22,\n          0, 1, 0, 0, 0, 0, 0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x22, 0, 1,\n          0, 0, 0, 0,\n          0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0, 0,\n          0x22, 0, 0, 0,\n          0, 0, 1, 0, 0x22, 0, 0, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0, 0, 0,\n          1, 0, 0x22,\n          0,\n          0, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0,\n          0x22, 0xd8,\n          0,\n          0xdc, 0, 0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0x22, 0xd8, 0,\n          0xdc, 0, 0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x22, 0,\n          0, 0xd8, 0,\n          0xdc, 0x22, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0xd8, 0,\n          0xdc, 0x22, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0, 0x22,\n          0, 0, 0xd8, 0, 0, 0, 0, 0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x22, 0, 0,\n          0xd8, 0, 0,\n          0,\n          0, 0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0, 0,\n          0x22, 0, 0, 0,\n          0, 0xd8, 0, 0, 0x22, 0, 0, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0, 0,\n          0xd8,\n          0,\n          0,\n          0x22, 0, 0, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0, 0x22,\n          0, 0xdc, 0,\n          0xdc, 0, 0, 0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0x22, 0, 0xdc, 0,\n          0xdc, 0, 0,\n          0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x22, 0,\n          0, 0xdc, 0,\n          0xdc, 0x22, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0xdc, 0,\n          0xdc, 0x22, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] { 0xfc })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] { 0, 0 })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // Illegal UTF-16\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0x20,\n          0x20, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x20,\n          0x20, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xd8,\n          0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xd8,\n          0x00, 0x20, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0x20, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xd8,\n          0x00, 0xd8, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0xd8, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0xd8, 0x00, 0xdc, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0xdc, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xd8,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xd8, 0x00, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xd8, 0x00, 0xd8,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0xd8,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0xd8, 0x00, 0xdc,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0xdc,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n\n        // Illegal UTF-32\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x20, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        var msbytes = new byte[] { 0, 0, 0, 0x20, 0, 0, };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0, 0x20, 0, 0, 0 };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0, 0,\n          0xd8, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0, 0,\n          0xdc, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0,\n          0x11, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0,\n          0xff, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0x1,\n          0, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0xfe, 0xff, 0, };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0xfe, 0xff, 0, 0, };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0xd8, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0xdc, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0x11, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0xff, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0xfe, 0xff, 0x1, 0, 0x00, 0, };\n        ReadJsonFail(msbytes);\n      } catch (IOException ex) {\n        Assert.Fail(ex.Message);\n      }\n    }\n\n    private static void ReadJsonFail(byte[] msbytes) {\n      using (var msjson = new MemoryStream(msbytes)) {\n        try {\n          CBORObject.ReadJSON(msjson);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    // TODO: In next major version, consider using CBORException\n    // for circular refs in EncodeToBytes\n    [Test]\n    public void TestEncodeToBytesCircularRefs() {\n      CBORObject cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(cbor);\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(cbor, \"test\");\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(CBORObject.NewArray().Add(cbor), \"test\");\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs1() {\n      CBORObject cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs4() {\n      CBORObject cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs2() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(cbor, \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs5() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(CBORObject.NewArray().Add(cbor), \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs6() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3b() {\n      CBORObject cbor;\n      cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3ba() {\n      CBORObject cbor;\n\n      cbor = CBORObject.NewOrderedMap().Add(\"abc\", 2).Add(\"def\", 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3bb() {\n      CBORObject cbor;\n\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3bc() {\n      CBORObject cbor;\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(CBORObject.NewOrderedMap().Add(\"jkl\", cbor), \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap().Add(\"jkl\", cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(CBORObject.NewOrderedMap().Add(cbor, \"jkl\"), \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap().Add(cbor, \"jkl\"));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = CBORObject.NewOrderedMap().Add(cbor,\n            \"jkl\").Add(\"mno\",\n            1);\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap().Add(cbor,\n            \"jkl\").Add(\"mno\", 1);\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap().Add(\"mno\",\n            1).Add(cbor, \"jkl\");\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = CBORObject.NewOrderedMap().Add(\"mno\", 1).Add(cbor,\n            \"jkl\");\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      // No circular refs\n      cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap());\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"abc\", 2).Add(\"def\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap());\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap());\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = CBORObject.NewOrderedMap().Add(\"jkl\",\n            CBORObject.NewOrderedMap());\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap().Add(\"jkl\",\n            CBORObject.NewOrderedMap());\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp =\n          CBORObject.NewOrderedMap().Add(CBORObject.NewOrderedMap(),\n            \"jkl\");\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap()\n          .Add(CBORObject.NewOrderedMap(),\n            \"jkl\");\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        CBORObject.NewOrderedMap().Add(CBORObject.NewOrderedMap(),\n          \"jkl\").Add(\"mno\",\n            1);\n        object objectTemp2 = \"test\";\n        cbor.Add(\"test\", objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp2 =\n          CBORObject.NewOrderedMap().Add(CBORObject.NewOrderedMap(),\n            \"jkl\").Add(\"mno\",\n            1);\n        cbor.Add(\"test\", objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp2 =\n          CBORObject.NewOrderedMap().Add(\"mno\", 1).Add(\n            CBORObject.NewOrderedMap(),\n            \"jkl\");\n        cbor.Add(\"test\", objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp =\n          CBORObject.NewOrderedMap().Add(\"mno\", 1).Add(\n            CBORObject.NewOrderedMap(),\n            \"jkl\");\n        cbor.Add(objectTemp, \"test\");\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs2a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(cbor, \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs5a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      CBORObject cbor2 = CBORObject.NewArray().Add(cbor);\n      cbor.Add(cbor2, \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs6a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestClear() {\n      CBORObject cbor;\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.AreEqual(3, cbor.Count);\n      cbor.Clear();\n      Assert.AreEqual(0, cbor.Count);\n      cbor = CBORObject.NewMap()\n        .Add(\"a\", 0).Add(\"b\", 1).Add(\"c\", 2);\n      Assert.AreEqual(3, cbor.Count);\n      cbor.Clear();\n      Assert.AreEqual(0, cbor.Count);\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1).Clear();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.Clear();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.Clear();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestRemove() {\n      CBORObject cbor;\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.AreEqual(3, cbor.Count);\n      Assert.IsTrue(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"b\")));\n      Assert.IsFalse(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"x\")));\n      try {\n        cbor.Remove((CBORObject)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"a\"), cbor[0]);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"c\"), cbor[1]);\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.AreEqual(3, cbor.Count);\n\n      Assert.IsTrue(cbor.Remove(\"b\"));\n      Assert.IsFalse(cbor.Remove(\"x\"));\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"a\"), cbor[0]);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"c\"), cbor[1]);\n      cbor = CBORObject.NewMap().Add(\"a\", 0).Add(\"b\", 1).Add(\"c\", 2);\n      Assert.AreEqual(3, cbor.Count);\n\n      Assert.IsTrue(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"b\")));\n      Assert.IsFalse(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"x\")));\n      try {\n        cbor.Remove((CBORObject)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(2, cbor.Count);\n      Assert.IsTrue(cbor.ContainsKey(\"a\"));\n      Assert.IsTrue(cbor.ContainsKey(\"c\"));\n      cbor = CBORObject.NewMap().Add(\"a\", 0).Add(\"b\", 1).Add(\"c\", 2);\n      Assert.AreEqual(3, cbor.Count);\n\n      Assert.IsTrue(cbor.Remove(\"b\"));\n      Assert.IsFalse(cbor.Remove(\"x\"));\n      Assert.AreEqual(2, cbor.Count);\n      Assert.IsTrue(cbor.ContainsKey(\"a\"));\n      Assert.IsTrue(cbor.ContainsKey(\"c\"));\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1).Remove(\"x\");\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.Remove(\"x\");\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.Remove(\"x\");\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1)\n        .Remove(ToObjectTest.TestToFromObjectRoundTrip(\"b\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.Remove(ToObjectTest.TestToFromObjectRoundTrip(\"b\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.Remove(ToObjectTest.TestToFromObjectRoundTrip(\"b\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestRemoveAt() {\n      CBORObject cbor;\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.IsTrue(cbor.RemoveAt(1));\n      Assert.IsFalse(cbor.RemoveAt(2));\n      Assert.IsFalse(cbor.RemoveAt(-1));\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"a\"), cbor[0]);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"c\"), cbor[1]);\n      try {\n        CBORObject.NewMap().RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1).RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestSet() {\n      CBORObject cbor = CBORObject.NewMap().Add(\"x\", 0).Add(\"y\", 1);\n      Assert.AreEqual(0, cbor[\"x\"].AsInt32());\n      Assert.AreEqual(1, cbor[\"y\"].AsInt32());\n      cbor.Set(\"x\", 5).Set(\"z\", 6);\n      Assert.AreEqual(5, cbor[\"x\"].AsInt32());\n      Assert.AreEqual(6, cbor[\"z\"].AsInt32());\n      cbor = CBORObject.NewArray().Add(1).Add(2).Add(3).Add(4);\n      Assert.AreEqual(1, cbor[0].AsInt32());\n      Assert.AreEqual(2, cbor[1].AsInt32());\n      Assert.AreEqual(3, cbor[2].AsInt32());\n      try {\n        cbor.Set(-1, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.Set(4, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.Set(999, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject cbor2 = CBORObject.True;\n      try {\n        cbor2.Set(0, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor.Set(0, 99);\n      Assert.AreEqual(99, cbor[0].AsInt32());\n      cbor.Set(3, 199);\n      Assert.AreEqual(199, cbor[3].AsInt32());\n    }\n\n    [Test]\n    public void TestSign() {\n      try {\n        int sign = CBORObject.True.Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        int sign = CBORObject.False.Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        int sign = CBORObject.NewArray().Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        int sign = CBORObject.NewMap().Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        string numberString = numberinfo[\"number\"].AsString();\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberString));\n        if (cbornumber.AsNumber().IsNaN()) {\n          try {\n            Assert.Fail(String.Empty + cbornumber.Sign);\n            Assert.Fail(\"Should have failed\");\n          } catch (InvalidOperationException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else if (numberString.Length > 0 && numberString[0] == '-') {\n          Assert.AreEqual(-1, cbornumber.Sign);\n        } else if (numberinfo[\"number\"].AsString().Equals(\"0\",\n            StringComparison.Ordinal)) {\n          Assert.AreEqual(0, cbornumber.Sign);\n        } else {\n          Assert.AreEqual(1, cbornumber.Sign);\n        }\n      }\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestAsNumberSubtract() {\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber().Subtract(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCompareToUnicodeString() {\n      CBORObject cbora;\n      CBORObject cborb;\n      cbora = CBORObject.FromObject(\"aa\\ud200\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud200\\ue001\");\n      TestCommon.CompareTestLess(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud200\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud201\\ue000\");\n      TestCommon.CompareTestLess(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud800\\udc00\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ue001\\ue000\");\n      TestCommon.CompareTestGreater(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud800\\udc00\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud800\\udc01\\ue000\");\n      TestCommon.CompareTestLess(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud800\\udc00\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud801\\udc00\\ue000\");\n      TestCommon.CompareTestLess(cbora, cborb);\n    }\n\n    [Test]\n    public void TestToJSONString() {\n      {\n        string stringTemp = ToObjectTest.TestToFromObjectRoundTrip(\n            \"\\u2027\\u2028\\u2029\\u202a\\u0008\\u000c\").ToJSONString();\n        Assert.AreEqual(\n          \"\\\"\\u2027\\\\u2028\\\\u2029\\u202a\\\\b\\\\f\\\"\",\n          stringTemp);\n      }\n      {\n        string stringTemp = ToObjectTest.TestToFromObjectRoundTrip(\n            \"\\u0085\\ufeff\\ufffe\\uffff\").ToJSONString();\n        Assert.AreEqual(\n          \"\\\"\\\\u0085\\\\uFEFF\\\\uFFFE\\\\uFFFF\\\"\",\n          stringTemp);\n      }\n      {\n        string stringTemp = CBORObject.True.ToJSONString();\n        Assert.AreEqual(\n          \"true\",\n          stringTemp);\n      }\n      {\n        string stringTemp = CBORObject.False.ToJSONString();\n        Assert.AreEqual(\n          \"false\",\n          stringTemp);\n      }\n      {\n        string stringTemp = CBORObject.Null.ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.PositiveInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.NegativeInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.NaN).ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NaN).ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n\n      CBORObject cbor = CBORObject.NewArray();\n      var b64bytes = new byte[] {\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xff, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xff, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n      };\n      cbor.Add(b64bytes);\n      TestSucceedingJSON(cbor.ToJSONString());\n      cbor = CBORObject.NewMap();\n      cbor.Add(\"key\", \"\\ud800\\udc00\");\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\udc00\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\ud800\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\udc00\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      cbor.Add(\"\\ud800\\udc00\", \"value\");\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\ud800\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\udc00\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\ud800\\udc00\\ud800\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\udc00\\udc00\\ud800\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      cbor.Add(\"\\ud800\\udc00\");\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\udc00\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\ud800\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\udc00\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToJSONString_DuplicateKeys() {\n      CBORObject cbor;\n      cbor = CBORObject.NewMap().Add(\"true\", 1).Add(true, 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"true\", 1).Add(false, 1);\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"9999-01-01T00:00:00Z\", 1)\n        .Add(CBORObject.FromObjectAndTag(\"9999-01-01T00:00:00Z\", 0), 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"34\", 1).Add(34, 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"-34\", 1).Add(-34, 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"-34\", 1).Add(-35, 1);\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToFloatingPointBits() {\n      try {\n        CBORObject.FromFloatingPointBits(0, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 3);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 5);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 6);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 7);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 9);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToFloatingPointBitsSingle() {\n      // Regression test\n      CBORObject o;\n      o = CBORObject.FromFloatingPointBits(2140148306L, 4);\n      Assert.IsTrue(Double.IsNaN(o.AsDoubleValue()));\n      o = CBORObject.FromFloatingPointBits(1651724151L, 4);\n      Assert.IsTrue(o.AsDoubleValue() == 1.1220712138406615E21);\n      o = CBORObject.FromFloatingPointBits(-1566356128L, 4);\n      Assert.IsTrue(o.AsDoubleValue() == -4.426316249665156E-18);\n    }\n\n    [Test]\n    public void TestToJSONString_ByteArray_Padding() {\n      CBORObject o;\n      var options = new JSONOptions(String.Empty);\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xf0, 0xe8 }, 22);\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtbw6A==\\\"\",\n          stringTemp);\n      }\n      // untagged, so base64url without padding\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xf0, 0xe8,\n      });\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtbw6A\\\"\",\n          stringTemp);\n      }\n      // tagged 23, so base16\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xf0, 0xe8 },\n          23);\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"9AD6F0E8\\\"\",\n          stringTemp);\n      }\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xff, 0xe8,\n      });\n    }\n\n    [Test]\n    public void TestToString() {\n      {\n        string stringTemp = CBORObject.Undefined.ToString();\n        Assert.AreEqual(\n          \"undefined\",\n          stringTemp);\n      }\n      CBORObject cbor = CBORObject.True;\n      string cborString;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"21\", cborString);\n      TestCommon.AssertNotEqual(\"simple(21)\", cborString);\n      cbor = CBORObject.False;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"20\", cborString);\n      TestCommon.AssertNotEqual(\"simple(20)\", cborString);\n      cbor = CBORObject.Null;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"22\", cborString);\n      TestCommon.AssertNotEqual(\"simple(22)\", cborString);\n      cbor = CBORObject.Undefined;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"23\", cborString);\n      TestCommon.AssertNotEqual(\"simple(23)\", cborString);\n      {\n        string stringTemp = CBORObject.FromSimpleValue(50).ToString();\n        Assert.AreEqual(\n          \"simple(50)\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestSimpleValuesNotIntegers() {\n      CBORObject cbor = CBORObject.True;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(21), cbor);\n      cbor = CBORObject.False;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(20), cbor);\n      cbor = CBORObject.Null;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(22), cbor);\n      cbor = CBORObject.Undefined;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(23), cbor);\n    }\n\n    [Test]\n    public void TestTrue() {\n      CBORTestCommon.AssertJSONSer(CBORObject.True, \"true\");\n      Assert.AreEqual(\n        CBORObject.True,\n        ToObjectTest.TestToFromObjectRoundTrip(true));\n    }\n\n    [Test]\n    public void TestCalcEncodedBytesSpecific() {\n      CBORObject cbor;\n\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xda, 0x00, 0x1d,\n        (byte)0xdb, 0x03, (byte)0xd9, 0x01, 0x0d, (byte)0x83, 0x00, 0x00,\n        0x03,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xda, 0x00, 0x14,\n        0x57,\n        (byte)0xce,\n        (byte)0xc5,\n        (byte)0x82, 0x1a, 0x46, 0x5a, 0x37,\n        (byte)0x87,\n        (byte)0xc3, 0x50, 0x5e,\n        (byte)0xec,\n        (byte)0xfd, 0x73, 0x50, 0x64,\n        (byte)0xa1, 0x1f, 0x10,\n        (byte)0xc4, (byte)0xff, (byte)0xf2, (byte)0xc4, (byte)0xc9, 0x65,\n        0x12,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, 0x56, 0x00,\n        0x69, 0x2a,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xf9, (byte)0xfc,\n        0x00,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xa2,\n        (byte)0x82,\n        (byte)0xf6,\n        (byte)0x82,\n        (byte)0xfb, 0x3c,\n        (byte)0xf0, 0x03, 0x42,\n        (byte)0xcb, 0x54, 0x6c,\n        (byte)0x85,\n        (byte)0x82,\n        (byte)0xc5,\n        (byte)0x82, 0x18,\n        (byte)0xba, 0x0a,\n        (byte)0xfa,\n        (byte)0x84,\n        (byte)0xa0, 0x57,\n        (byte)0x97, 0x42, 0x00, 0x01, 0x65, 0x62, 0x7d, 0x45, 0x20, 0x6c, 0x41,\n        0x00,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0x82,\n        (byte)0xfa,\n        (byte)0xe0,\n        (byte)0xa0,\n        (byte)0x9d,\n        (byte)0xba,\n        (byte)0x82,\n        (byte)0x82,\n        (byte)0xf7, (byte)0xa2, (byte)0xa0, (byte)0xf7, 0x60, 0x41, 0x00,\n        (byte)0xf4,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, (byte)0xc7,\n        (byte)0x80, 0x01, (byte)0x80,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xa5, 0x64, 0x69,\n        0x74, 0x65, 0x6d, 0x6a, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x72, 0x69,\n        0x6e, 0x67, 0x66, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x2a, 0x63,\n        0x6d, 0x61, 0x70,\n        (byte)0xa1, 0x66, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x2a, 0x65,\n        0x61, 0x72, 0x72, 0x61, 0x79,\n        (byte)0x82,\n        (byte)0xf9, 0x63,\n        (byte)0xce, 0x63, 0x78, 0x79, 0x7a, 0x65, 0x62, 0x79, 0x74, 0x65, 0x73,\n        0x43, 0x00, 0x01, 0x02,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xda, 0x00, 0x14,\n        0x57,\n        (byte)0xce,\n        (byte)0xc5,\n        (byte)0x82, 0x1a, 0x46, 0x5a, 0x37,\n        (byte)0x87,\n        (byte)0xc3, 0x50, 0x5e,\n        (byte)0xec,\n        (byte)0xfd, 0x73, 0x50, 0x64,\n        (byte)0xa1, 0x1f, 0x10,\n        (byte)0xc4, (byte)0xff, (byte)0xf2, (byte)0xc4, (byte)0xc9, 0x65,\n        0x12,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, (byte)0xc7,\n        (byte)0x80, 0x01, (byte)0x80,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0x82,\n        (byte)0xda, 0x00, 0x0a,\n        (byte)0xe8,\n        (byte)0xb6,\n        (byte)0xfb, 0x43,\n        (byte)0xc0, 0x00, 0x00,\n        (byte)0xd5, 0x42, 0x7f,\n        (byte)0xdc, (byte)0xfa, 0x71, (byte)0x80, (byte)0xd7, (byte)0xc8,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, 0x29, 0x0a,\n        0x4c, (byte)0x9e,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n    }\n\n    [Test]\n    public void TestType() {\n      CBORObject cbor = CBORObject.True;\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      // Simple value for true\n      cbor = CBORObject.FromSimpleValue(21);\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      cbor = CBORObject.FromObjectAndTag(CBORObject.True, 999);\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      cbor = CBORObject.False;\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      cbor = CBORObject.Null;\n      Assert.AreEqual(\n        CBORType.SimpleValue,\n        cbor.Type);\n      cbor = CBORObject.Undefined;\n      Assert.AreEqual(\n        CBORType.SimpleValue,\n        cbor.Type);\n      cbor = CBORObject.FromSimpleValue(99);\n      Assert.AreEqual(\n        CBORType.SimpleValue,\n        cbor.Type);\n    }\n\n    [Test]\n    public void TestUntag() {\n      CBORObject o = CBORObject.FromObjectAndTag(\"test\", 999);\n      Assert.AreEqual(EInteger.FromString(\"999\"), o.MostInnerTag);\n      o = o.Untag();\n      Assert.AreEqual(EInteger.FromString(\"-1\"), o.MostInnerTag);\n    }\n\n    [Test]\n    public void TestUntagOne() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestValues() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestWrite() {\n      for (var i = 0; i < 2000; ++i) {\n        this.TestWrite2();\n      }\n      for (var i = 0; i < 40; ++i) {\n        TestWrite3();\n      }\n    }\n\n    public static void TestWriteExtraOne(long longValue) {\n      try {\n        {\n          CBORObject cborTemp1 =\n            ToObjectTest.TestToFromObjectRoundTrip(longValue);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)longValue);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(longValue, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(longValue, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(longValue));\n          }\n          TestWriteObj((object)longValue, longValue);\n        }\n\n        EInteger bigintVal = EInteger.FromInt64(longValue);\n        {\n          CBORObject cborTemp1 =\n            ToObjectTest.TestToFromObjectRoundTrip(bigintVal);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)bigintVal);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(bigintVal, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(bigintVal, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(bigintVal));\n          }\n          TestWriteObj((object)bigintVal, bigintVal);\n        }\n\n        if (longValue >= (long)Int32.MinValue && longValue <=\n          (long)Int32.MaxValue) {\n          var intval = (int)longValue;\n          {\n            CBORObject cborTemp1 =\n              ToObjectTest.TestToFromObjectRoundTrip(intval);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)intval);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(intval, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(intval, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(intval));\n            }\n            TestWriteObj((object)intval, intval);\n          }\n        }\n        if (longValue >= -32768L && longValue <= 32767) {\n          var shortval = (short)longValue;\n          CBORObject cborTemp1 = ToObjectTest\n            .TestToFromObjectRoundTrip(shortval);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)shortval);\n          TestCommon.CompareTestEqualAndConsistent(\n            cborTemp1,\n            cborTemp2);\n          try {\n            CBORObject.Write(shortval, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(shortval, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(shortval));\n          }\n          TestWriteObj((object)shortval, shortval);\n        }\n        if (longValue >= 0L && longValue <= 255) {\n          var byteval = (byte)longValue;\n          {\n            CBORObject cborTemp1 =\n              ToObjectTest.TestToFromObjectRoundTrip(byteval);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)byteval);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1,\n              cborTemp2);\n            try {\n              CBORObject.Write(byteval, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(byteval, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(byteval));\n            }\n            TestWriteObj((object)byteval, byteval);\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteExtra() {\n      try {\n        string str = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(str);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)str);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(str, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(str, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)str, null);\n        }\n\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(\n              \"test\");\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)\"test\");\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(\"test\", null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(\"test\", ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            {\n              CBORObject objectTemp2 = ToObjectTest.TestToFromObjectRoundTrip(\n                  \"test\");\n              AssertReadThree(ms.ToArray(), objectTemp2);\n            }\n          }\n          TestWriteObj((object)\"test\", \"test\");\n        }\n\n        str = TestCommon.Repeat(\"test\", 4000);\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(str);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)str);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(str, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(str, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(str));\n          }\n          TestWriteObj((object)str, str);\n        }\n\n        long[] values = {\n          0, 1, 23, 24, -1, -23, -24, -25,\n          0x7f, -128, 255, 256, 0x7fff, -32768, 0x7fff,\n          -32768, -65536, -32769, -65537,\n          0x7fffff, 0x7fff7f, 0x7fff7fff, 0x7fff7fff7fL, 0x7fff7fff7fffL,\n          0x7fff7fff7fff7fL, 0x7fff7fff7fff7fffL,\n          Int64.MaxValue, Int64.MinValue, Int32.MinValue,\n          Int32.MaxValue,\n        };\n        for (var i = 0; i < values.Length; ++i) {\n          TestWriteExtraOne(values[i]);\n        }\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(0.0f);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)0.0f);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(0.0f, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(0.0f, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(0.0f));\n          }\n          TestWriteObj((object)0.0f, 0.0f);\n        }\n\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(2.6);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)2.6);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(2.6, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(2.6, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(2.6));\n          }\n          TestWriteObj((object)2.6, 2.6);\n        }\n\n        CBORObject cbor = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(cbor);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)cbor);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(cbor, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)cbor, null);\n        }\n\n        object aobj = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(aobj);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)aobj);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(aobj, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(aobj, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)aobj, null);\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    public static void TestWrite3() {\n      EFloat ef = null;\n      EDecimal ed = null;\n      var fr = new RandomGenerator();\n      try {\n        for (var i = 0; i < 256; ++i) {\n          var b = (byte)(i & 0xff);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write((byte)b, ms);\n            CBORObject cobj = CBORObject.DecodeFromBytes(ms.ToArray());\n            Assert.AreEqual(i, cobj.AsInt32());\n          }\n        }\n\n        for (var i = 0; i < 50; ++i) {\n          ef = RandomObjects.RandomEFloat(fr);\n          if (!ef.IsNaN()) {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ef, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ef, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(ef));\n            }\n            TestWriteObj((object)ef, ef);\n          }\n\n          ef = EFloat.Create(\n              RandomObjects.RandomEInteger(fr),\n              RandomObjects.RandomEInteger(fr));\n          {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ef, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ef, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              if (cborTemp1.IsNegative && cborTemp1.IsZero) {\n                AssertReadThree(ms.ToArray());\n              } else {\n                AssertReadThree(\n                  ms.ToArray(),\n                  ToObjectTest.TestToFromObjectRoundTrip(ef));\n              }\n            }\n            TestWriteObj((object)ef, ef);\n          }\n        }\n        for (var i = 0; i < 50; ++i) {\n          ed = RandomObjects.RandomEDecimal(fr);\n          if (!ed.IsNaN()) {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ed);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ed);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ed, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ed, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              if (cborTemp1.IsNegative && cborTemp1.IsZero) {\n                AssertReadThree(ms.ToArray());\n              } else {\n                AssertReadThree(\n                  ms.ToArray(),\n                  ToObjectTest.TestToFromObjectRoundTrip(ed));\n              }\n            }\n            if (!(cborTemp1.IsNegative && cborTemp1.IsZero)) {\n              TestWriteObj((object)ed, ed);\n            }\n          }\n\n          ed = EDecimal.Create(\n              RandomObjects.RandomEInteger(fr),\n              RandomObjects.RandomEInteger(fr));\n          {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ed);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ed);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ed, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ed, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(ed));\n            }\n            TestWriteObj((object)ed, ed);\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWrite2() {\n      try {\n        var fr = new RandomGenerator();\n\n        EFloat ef = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(ef, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(ef, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)ef, null);\n        }\n\n        ef = EFloat.FromString(\"20\");\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(ef, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(ef, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(ef));\n          }\n          TestWriteObj((object)ef, ef);\n        }\n\n        ERational er = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(er);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)er);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(er, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(er, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)er, null);\n        }\n        do {\n          er = RandomObjects.RandomERational(fr);\n        } while (er.IsNegative && er.IsZero);\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(er);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)er);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(er, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(er, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            if (cborTemp1.IsNegative && cborTemp1.IsZero) {\n              AssertReadThree(ms.ToArray());\n            } else {\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(er));\n            }\n          }\n          TestWriteObj((object)er, er);\n        }\n\n        EDecimal ed = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ed);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)ed);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(ed, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(ed, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)ed, null);\n        }\n\n        EInteger bigint = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(\n              bigint);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)bigint);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(bigint, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(bigint, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)bigint, null);\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteJSON() {\n      // not implemented yet\n      try {\n        using (var ms = new MemoryStream()) {\n          CBORObject.WriteJSON(CBORObject.True, ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"true\", str);\n        }\n        using (var ms = new MemoryStream()) {\n          CBORObject.True.WriteJSONTo(ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"true\", str);\n        }\n        using (var ms = new MemoryStream()) {\n          CBORObject.WriteJSON(CBORObject.False, ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"false\", str);\n        }\n        using (var ms = new MemoryStream()) {\n          CBORObject.False.WriteJSONTo(ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"false\", str);\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteJSONTo() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestWriteTo() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestZero() {\n      {\n        string stringTemp = CBORObject.Zero.ToString();\n        Assert.AreEqual(\n          \"0\",\n          stringTemp);\n      }\n      Assert.AreEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(0),\n        CBORObject.Zero);\n    }\n\n    internal static void CompareDecimals(CBORObject o1, CBORObject o2) {\n      int cmpDecFrac = TestCommon.CompareTestReciprocal(\n          AsED(o1),\n          AsED(o2));\n      int cmpCobj = TestCommon.CompareTestReciprocal(o1.AsNumber(),\n          o2.AsNumber());\n      if (cmpDecFrac != cmpCobj) {\n        Assert.Fail(TestCommon.ObjectMessages(\n            o1,\n            o2,\n            \"Compare: Results\\u0020don't match\"));\n      }\n      CBORTestCommon.AssertRoundTrip(o1);\n      CBORTestCommon.AssertRoundTrip(o2);\n    }\n\n    internal static void AreEqualExact(double a, double b) {\n      if (Double.IsNaN(a)) {\n        Assert.IsTrue(Double.IsNaN(b));\n      } else if (a != b) {\n        Assert.Fail(\"expected \" + a + \", got \" + b);\n      }\n    }\n\n    internal static void AreEqualExact(float a, float b) {\n      if (Single.IsNaN(a)) {\n        Assert.IsTrue(Single.IsNaN(b));\n      } else if (a != b) {\n        Assert.Fail(\"expected \" + a + \", got \" + b);\n      }\n    }\n\n    private static string Chop(string str) {\n      return (str.Length < 100) ? str : (str.Substring(0, 100) + \"...\");\n    }\n\n    private static void AssertReadThree(byte[] bytes) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          CBORObject cbor1, cbor2, cbor3;\n          cbor1 = CBORObject.Read(ms);\n          cbor2 = CBORObject.Read(ms);\n          cbor3 = CBORObject.Read(ms);\n          TestCommon.CompareTestRelations(cbor1, cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor1, cbor2);\n          TestCommon.CompareTestEqualAndConsistent(cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor3, cbor1);\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString() + \"\\r\\n\" +\n          TestCommon.ToByteArrayString(bytes));\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    private static void AssertReadThree(byte[] bytes, CBORObject cbor) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          CBORObject cbor1, cbor2, cbor3;\n          cbor1 = CBORObject.Read(ms);\n          cbor2 = CBORObject.Read(ms);\n          cbor3 = CBORObject.Read(ms);\n          TestCommon.CompareTestEqualAndConsistent(cbor1, cbor);\n          TestCommon.CompareTestRelations(cbor1, cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor1, cbor2);\n          TestCommon.CompareTestEqualAndConsistent(cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor3, cbor1);\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString() + \"\\r\\n\" +\n          Chop(TestCommon.ToByteArrayString(bytes)) + \"\\r\\n\" +\n          \"cbor = \" + Chop(cbor.ToString()) + \"\\r\\n\");\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    private static void AssertWriteThrow(CBORObject cbor) {\n      try {\n        cbor.WriteTo(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Write(cbor, null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteBigExponentNumber() {\n      var exponents = new string[] {\n        \"15368525994429920286\",\n        \"18446744073709551615\",\n        \"-18446744073709551616\",\n        \"18446744073709551616\",\n        \"-18446744073709551617\",\n        \"18446744073709551615\",\n        \"-18446744073709551614\",\n      };\n      foreach (string strexp in exponents) {\n        EInteger bigexp = EInteger.FromString(strexp);\n        EDecimal ed = EDecimal.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ed);\n        EFloat ef = EFloat.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ef);\n        bigexp = bigexp.Negate();\n        ed = EDecimal.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ed);\n        ef = EFloat.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ef);\n      }\n    }\n\n    private static void TestWriteObj(object obj) {\n      try {\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(obj);\n          try {\n            CBORObject.Write(obj, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(obj, ms);\n            CBORObject.Write(ToObjectTest.TestToFromObjectRoundTrip(obj), ms);\n            ToObjectTest.TestToFromObjectRoundTrip(obj).WriteTo(ms);\n            AssertReadThree(ms.ToArray());\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestEMap() {\n      CBORObject cbor = CBORObject.NewMap()\n        .Add(\"name\", \"Example\");\n      byte[] bytes = CBORTestCommon.CheckEncodeToBytes(cbor);\n    }\n\n    private static void TestWriteObj(object obj, object objTest) {\n      try {\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(obj);\n          try {\n            CBORObject.Write(obj, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(obj, ms);\n            CBORObject.Write(ToObjectTest.TestToFromObjectRoundTrip(obj), ms);\n            ToObjectTest.TestToFromObjectRoundTrip(obj).WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(objTest));\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteValue() {\n      try {\n        try {\n          CBORObject.WriteValue(null, 0, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 1, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 2, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 3, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 4, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        using (var ms = new MemoryStream()) {\n          try {\n            CBORObject.WriteValue(ms, -1, 0);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 8, 0);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 7, 256);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 7, Int32.MaxValue);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 7, Int64.MaxValue);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          for (var i = 0; i <= 7; ++i) {\n            try {\n              CBORObject.WriteValue(ms, i, -1);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, Int32.MinValue);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, -1L);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, Int64.MinValue);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          for (var i = 0; i <= 6; ++i) {\n            try {\n              CBORObject.WriteValue(ms, i, Int32.MaxValue);\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, Int64.MaxValue);\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          // Test minimum data length\n          int[] ranges = {\n            0, 23, 1,\n            24, 255, 2,\n            256, 266, 3,\n            65525, 65535, 3,\n            65536, 65546, 5,\n          };\n          string[] bigRanges = {\n            \"4294967285\", \"4294967295\",\n            \"4294967296\", \"4294967306\",\n            \"18446744073709551604\", \"18446744073709551615\",\n          };\n          int[] bigSizes = { 5, 9, 9, 5, 9, 9 };\n          for (int i = 0; i < ranges.Length; i += 3) {\n            for (int j = ranges[i]; j <= ranges[i + 1]; ++j) {\n              for (var k = 0; k <= 6; ++k) {\n                int count;\n                count = CBORObject.WriteValue(ms, k, j);\n                Assert.AreEqual(ranges[i + 2], count);\n                count = CBORObject.WriteValue(ms, k, (long)j);\n                Assert.AreEqual(ranges[i + 2], count);\n                count = CBORObject.WriteValue(ms, k, EInteger.FromInt32(j));\n                Assert.AreEqual(ranges[i + 2], count);\n              }\n            }\n          }\n          for (int i = 0; i < bigRanges.Length; i += 2) {\n            EInteger bj = EInteger.FromString(bigRanges[i]);\n            EInteger valueBjEnd = EInteger.FromString(bigRanges[i + 1]);\n            while (bj < valueBjEnd) {\n              for (var k = 0; k <= 6; ++k) {\n                int count;\n                count = CBORObject.WriteValue(ms, k, bj);\n                Assert.AreEqual(bigSizes[i / 2], count);\n              }\n              bj += EInteger.One;\n            }\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestKeepKeyOrder() {\n      byte[] bytes;\n      byte[] bytes2;\n      CBORObject cbor;\n      var list = new List<CBORObject>();\n      var options = new CBOREncodeOptions(\"keepkeyorder=true\");\n      Assert.IsTrue(options.KeepKeyOrder);\n      bytes = new byte[] { (byte)0xa3, 0x01, 0, 0x02, 0, 0x03, 0 };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(1), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(3), list[2]);\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n      list = new List<CBORObject>();\n      bytes = new byte[] { (byte)0xbf, 0x01, 0, 0x02, 0, 0x03, 0, 0xff };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(1), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(3), list[2]);\n      bytes = new byte[] { (byte)0xa3, 0x01, 0, 0x02, 0, 0x03, 0 };\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n      list = new List<CBORObject>();\n      bytes = new byte[] { (byte)0xa3, 0x03, 0, 0x02, 0, 0x01, 0 };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(3), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(1), list[2]);\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n      list = new List<CBORObject>();\n      bytes = new byte[] { (byte)0xbf, 0x03, 0, 0x02, 0, 0x01, 0, 0xff };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(3), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(1), list[2]);\n      bytes = new byte[] { (byte)0xa3, 0x03, 0, 0x02, 0, 0x01, 0 };\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n\n      // JSON\n      var joptions = new JSONOptions(\"keepkeyorder=true\");\n      Assert.IsTrue(joptions.KeepKeyOrder);\n      string jsonstring;\n      jsonstring = \"{\\\"1\\\":0,\\\"2\\\":0,\\\"3\\\":0}\";\n      cbor = CBORObject.FromJSONString(jsonstring, joptions);\n      list = new List<CBORObject>();\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(\"1\"), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(\"2\"), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"3\"), list[2]);\n\n      jsonstring = \"{\\\"3\\\":0,\\\"2\\\":0,\\\"1\\\":0}\";\n      cbor = CBORObject.FromJSONString(jsonstring, joptions);\n      list = new List<CBORObject>();\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(\"3\"), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(\"2\"), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"1\"), list[2]);\n\n      jsonstring = \"{\\\"3\\\":0,\\\"2\\\":0,\\\"1\\\":0}\";\n      bytes = DataUtilities.GetUtf8Bytes(jsonstring, false);\n      cbor = CBORObject.FromJSONBytes(bytes, joptions);\n      list = new List<CBORObject>();\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(\"3\"), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(\"2\"), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"1\"), list[2]);\n    }\n\n    [Test]\n    public void TestWriteFloatingPointValue() {\n      var r = new RandomGenerator();\n      var bytes = new byte[] { 0, 0, 0 };\n      try {\n        for (var i = 0; i < 0x10000; ++i) {\n          bytes[0] = (byte)0xf9;\n          bytes[1] = (byte)((i >> 8) & 0xff);\n          bytes[2] = (byte)(i & 0xff);\n          CBORObject cbor = CBORObject.DecodeFromBytes(bytes);\n          if (!cbor.AsNumber().IsNaN()) {\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsDouble(),\n                2);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsSingle(),\n                2);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n          }\n        }\n        // 32-bit values\n        bytes = new byte[5];\n        for (var i = 0; i < 100000; ++i) {\n          bytes[0] = (byte)0xfa;\n          for (var j = 1; j <= 4; ++j) {\n            bytes[j] = (byte)r.UniformInt(256);\n          }\n\n          CBORObject cbor = CBORObject.DecodeFromBytes(bytes);\n          if (!cbor.AsNumber().IsNaN()) {\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsDouble(),\n                4);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsSingle(),\n                4);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n          }\n        }\n        // 64-bit values\n        bytes = new byte[9];\n        for (var i = 0; i < 100000; ++i) {\n          bytes[0] = (byte)0xfb;\n          for (var j = 1; j <= 8; ++j) {\n            bytes[j] = (byte)r.UniformInt(256);\n          }\n          CBORObject cbor = CBORObject.DecodeFromBytes(bytes);\n          if (!cbor.AsNumber().IsNaN()) {\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsDouble(),\n                8);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n            CBORObject c2 = null;\n            byte[] c2bytes = null;\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsSingle(),\n                8);\n              c2bytes = ms.ToArray();\n              c2 = CBORObject.DecodeFromBytes(\n                  c2bytes);\n            }\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                c2.AsSingle(),\n                8);\n              TestCommon.AssertByteArraysEqual(c2bytes, ms.ToArray());\n            }\n            if (i == 0) {\n              using (var ms = new MemoryStream()) {\n                try {\n                  CBORObject.WriteFloatingPointValue(ms, cbor.AsSingle(), 5);\n                  Assert.Fail(\"Should have failed\");\n                } catch (ArgumentException) {\n                  // NOTE: Intentionally empty\n                } catch (Exception ex) {\n                  Assert.Fail(ex.ToString());\n                  throw new InvalidOperationException(String.Empty, ex);\n                }\n                try {\n                  CBORObject.WriteFloatingPointValue(null, cbor.AsSingle(), 4);\n                  Assert.Fail(\"Should have failed\");\n                } catch (ArgumentNullException) {\n                  // NOTE: Intentionally empty\n                } catch (Exception ex) {\n                  Assert.Fail(ex.ToString());\n                  throw new InvalidOperationException(String.Empty, ex);\n                }\n              }\n            }\n          }\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private static string DateTimeToString(\n      int year,\n      int month,\n      int day,\n      int hour,\n      int minute,\n      int second,\n      int millisecond) {\n      var charbuf = new char[millisecond > 0 ? 24 : 20];\n      charbuf[0] = (char)('0' + ((year / 1000) % 10));\n      charbuf[1] = (char)('0' + ((year / 100) % 10));\n      charbuf[2] = (char)('0' + ((year / 10) % 10));\n      charbuf[3] = (char)('0' + (year % 10));\n      charbuf[4] = '-';\n      charbuf[5] = (char)('0' + ((month / 10) % 10));\n      charbuf[6] = (char)('0' + (month % 10));\n      charbuf[7] = '-';\n      charbuf[8] = (char)('0' + ((day / 10) % 10));\n      charbuf[9] = (char)('0' + (day % 10));\n      charbuf[10] = 'T';\n      charbuf[11] = (char)('0' + ((hour / 10) % 10));\n      charbuf[12] = (char)('0' + (hour % 10));\n      charbuf[13] = ':';\n      charbuf[14] = (char)('0' + ((minute / 10) % 10));\n      charbuf[15] = (char)('0' + (minute % 10));\n      charbuf[16] = ':';\n      charbuf[17] = (char)('0' + ((second / 10) % 10));\n      charbuf[18] = (char)('0' + (second % 10));\n      if (millisecond > 0) {\n        charbuf[19] = '.';\n        charbuf[20] = (char)('0' + ((millisecond / 100) % 10));\n        charbuf[21] = (char)('0' + ((millisecond / 10) % 10));\n        charbuf[22] = (char)('0' + (millisecond % 10));\n        charbuf[23] = 'Z';\n      } else {\n        charbuf[19] = 'Z';\n      }\n      return new String(charbuf);\n    }\n\n    private static void TestDateTimeStringNumberOne(string str, long num) {\n      CBORObject dtstring = CBORObject.FromObject(str).WithTag(0);\n      CBORObject dtnum = CBORObject.FromObject(num).WithTag(1);\n      TestDateTimeStringNumberOne(dtstring, dtnum);\n    }\n    private static void TestDateTimeStringNumberOne(string str, double num) {\n      CBORObject dtstring = CBORObject.FromObject(str).WithTag(0);\n      CBORObject dtnum = CBORObject.FromObject(num).WithTag(1);\n      TestDateTimeStringNumberOne(dtstring, dtnum);\n    }\n    private static void TestDateTimeStringNumberOne(CBORObject dtstring,\n      CBORObject dtnum) {\n      CBORDateConverter convNumber = CBORDateConverter.TaggedNumber;\n      CBORDateConverter convString = CBORDateConverter.TaggedString;\n      CBORObject cbor;\n      var eiYear = new EInteger[1];\n      var lesserFields = new int[7];\n      string strnum = dtstring + \", \" + dtnum;\n      cbor = convNumber.ToCBORObject(convNumber.FromCBORObject(dtstring));\n      Assert.AreEqual(dtnum, cbor, strnum);\n      if (!convNumber.TryGetDateTimeFields(dtstring, eiYear, lesserFields)) {\n        Assert.Fail(strnum);\n      }\n      cbor = convNumber.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtnum, cbor, strnum);\n      cbor = convString.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtstring, cbor, strnum);\n      cbor = convString.ToCBORObject(convString.FromCBORObject(dtnum));\n      Assert.AreEqual(dtstring, cbor, strnum);\n      if (!convString.TryGetDateTimeFields(dtnum, eiYear, lesserFields)) {\n        Assert.Fail(strnum);\n      }\n      cbor = convNumber.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtnum, cbor, strnum);\n      cbor = convString.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtstring, cbor, strnum);\n    }\n\n    [Test]\n    public void TestDateTimeStringNumber() {\n      TestDateTimeStringNumberOne(\"1970-01-01T00:00:00.25Z\", 0.25);\n      TestDateTimeStringNumberOne(\"1970-01-01T00:00:00.75Z\", 0.75);\n      TestDateTimeStringNumberOne(\"1969-12-31T23:59:59.75Z\", -0.25);\n      TestDateTimeStringNumberOne(\"1969-12-31T23:59:59.25Z\", -0.75);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:00Z\", 172800);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:00Z\", 172800);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:00Z\", 172800);\n      TestDateTimeStringNumberOne(\"2001-01-03T00:00:00Z\", 978480000);\n      TestDateTimeStringNumberOne(\"2001-01-03T00:00:00.25Z\", 978480000.25);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:00Z\", -315446400);\n      TestDateTimeStringNumberOne(\"1400-01-03T00:00:00Z\", -17987270400L);\n      TestDateTimeStringNumberOne(\"2100-01-03T00:00:00Z\", 4102617600L);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:01Z\", 172801);\n      TestDateTimeStringNumberOne(\"2001-01-03T00:00:01Z\", 978480001);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:01Z\", -315446399);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:00.25Z\", -315446399.75);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:00.75Z\", -315446399.25);\n      TestDateTimeStringNumberOne(\"1400-01-03T00:00:01Z\", -17987270399L);\n      TestDateTimeStringNumberOne(\"2100-01-03T00:00:01Z\", 4102617601L);\n    }\n\n    public static void TestApplyJSONPatchOpAdd(\n      CBORObject expected,\n      CBORObject src,\n      string path,\n      object obj) {\n      CBORObject patch = CBORObject.NewMap().Add(\"op\", \"add\")\n        .Add(\"path\", path).Add(\"value\", CBORObject.FromObject(obj));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(expected, src, patch);\n    }\n\n    public void TestApplyJSONPatchOpReplace(\n      CBORObject expected,\n      CBORObject src,\n      string path,\n      object obj) {\n      CBORObject patch = CBORObject.NewMap().Add(\"op\", \"replace\")\n        .Add(\"path\", path).Add(\"value\", CBORObject.FromObject(obj));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(expected, src, patch);\n    }\n\n    public static void TestApplyJSONPatchOpRemove(\n      CBORObject expected,\n      CBORObject src,\n      string path) {\n      CBORObject patch = CBORObject.NewMap().Add(\"op\", \"remove\")\n        .Add(\"path\", path);\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(expected, src, patch);\n    }\n\n    public static void TestApplyJSONPatchOp(\n      CBORObject expected,\n      CBORObject src,\n      CBORObject patch) {\n      CBORObject actual = CBORObject.DecodeFromBytes(src.EncodeToBytes());\n      if (expected == null) {\n        try {\n          actual.ApplyJSONPatch(patch);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          throw new InvalidOperationException(ex.ToString() + \"\\n\" + patch);\n        }\n      } else {\n        try {\n          byte[] oldactualbytes = actual.EncodeToBytes();\n          CBORObject oldactual = actual;\n          actual = actual.ApplyJSONPatch(patch);\n          byte[] newactualbytes = oldactual.EncodeToBytes();\n          // Check whether the patch didn't change the existing object\n          TestCommon.AssertByteArraysEqual(oldactualbytes, newactualbytes);\n        } catch (Exception ex) {\n          throw new InvalidOperationException(ex.ToString() + \"\\n\" + patch);\n        }\n        Assert.AreEqual(expected, actual);\n      }\n    }\n\n    public static void TestApplyJSONPatchJSONTestsCore(string patchTests) {\n      CBORObject tests = CBORObject.FromJSONString(patchTests,\n          new JSONOptions(\"allowduplicatekeys=1\"));\n      foreach (CBORObject testcbor in tests.Values) {\n        if (testcbor.GetOrDefault(\"disabled\", CBORObject.False).AsBoolean()) {\n          continue;\n        }\n        string err = testcbor.GetOrDefault(\"error\",\n            CBORObject.FromObject(String.Empty)).AsString();\n        string comment = testcbor.GetOrDefault(\"comment\",\n            CBORObject.FromObject(String.Empty)).AsString();\n        try {\n          if (testcbor.ContainsKey(\"error\")) {\n            TestApplyJSONPatchOp(null, testcbor[\"doc\"], testcbor[\"patch\"]);\n          } else {\n            TestApplyJSONPatchOp(\n              testcbor[\"expected\"],\n              testcbor[\"doc\"],\n              testcbor[\"patch\"]);\n          }\n        } catch (Exception ex) {\n          string exmsg = ex.GetType() + \"\\n\" + comment + \"\\n\" + err;\n          throw new InvalidOperationException(exmsg, ex);\n        }\n      }\n    }\n\n    [Test]\n    public void TestApplyJSONPatchTest() {\n      CBORObject patch;\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\",\n          CBORObject.NewArray().Add(1).Add(2));\n      patch = CBORObject.NewArray().Add(patch);\n      CBORObject exp;\n      exp = CBORObject.NewArray().Add(1).Add(2);\n      TestApplyJSONPatchOp(exp, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\",\n          CBORObject.NewArray().Add(1).Add(3));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\",\n          CBORObject.NewArray().Add(2).Add(2));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\", CBORObject.NewMap().Add(2,\n            2));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\", CBORObject.True);\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\", CBORObject.Null);\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n    }\n\n    [Test]\n    public void TestApplyJSONPatch() {\n      // TODO: Finish tests for ApplyJSONPatch\n      CBORObject patch;\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"ADD\").Add(\"path\", \"/0\").Add(\"value\",\n            3));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"RePlAcE\").Add(\"path\",\n            \"/0\").Add(\"value\", 3));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"unknown\").Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", String.Empty)\n          .Add(\"value\", CBORObject.True));\n      TestApplyJSONPatchOp(\n        CBORObject.True,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", String.Empty)\n          .Add(\"value\", CBORObject.NewMap()));\n      TestApplyJSONPatchOp(\n        CBORObject.NewMap(),\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", null).Add(\"value\",\n            2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"value\", 2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"remove\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"remove\").Add(\"value\", 2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"replace\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"replace\").Add(\"valuuuuu\", 2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"replace\").Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewArray().Add(1).Add(3),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/1\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewArray().Add(3).Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/0\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/00\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/00000\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", 3),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f3\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewMap().Add(\"f1\", 3).Add(\"f3\", \"f4\"),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/foo\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/xyz\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/0\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/-\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/-\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/foo\",\n        3);\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewArray().Add(1),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/1\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/01\");\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewArray().Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/0\");\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewMap().Add(\"f1\", \"f2\"),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f3\");\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewMap().Add(\"f3\", \"f4\"),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/foo\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/xyz\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/0\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/-\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/-\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/foo\");\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1),\n        CBORObject.NewArray(),\n        \"/-\",\n        1);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1),\n        CBORObject.NewArray(),\n        \"/0\",\n        1);\n      TestApplyJSONPatchOpAdd(\n        null,\n        CBORObject.NewArray(),\n        \"/1\",\n        1);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1).Add(2),\n        CBORObject.NewArray().Add(1),\n        \"/-\",\n        2);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(0).Add(1).Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/0\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1).Add(0).Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/1\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1).Add(2).Add(0),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/2\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/3\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/foo\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewMap().Add(\"foo\", \"bar\"),\n        CBORObject.NewMap(),\n        \"/foo\",\n        \"bar\");\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewMap().Add(\"foo\", \"baz\"),\n        CBORObject.NewMap().Add(\"foo\", \"bar\"),\n        \"/foo\",\n        \"baz\");\n    }\n\n    [Test]\n    public void TestAtJSONPointer() {\n      CBORObject cbor;\n      cbor = CBORObject.FromObject(\"xyz\");\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.FromObject(0);\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.FromObject(0.5);\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor.Add(3);\n      Assert.AreEqual(cbor[0], cbor.AtJSONPointer(\"/0\"));\n      try {\n        cbor.AtJSONPointer(\"/1\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/-\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"foo\", 0);\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(cbor[\"foo\"], cbor.AtJSONPointer(\"/foo\"));\n      try {\n        cbor.AtJSONPointer(\"/bar\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"f~o\", 0);\n      Assert.AreEqual(cbor[\"f~o\"], cbor.AtJSONPointer(\"/f~0o\"));\n      cbor = CBORObject.NewMap().Add(\"f~0o\", 0);\n      Assert.AreEqual(cbor[\"f~0o\"], cbor.AtJSONPointer(\"/f~00o\"));\n      cbor = CBORObject.NewMap().Add(\"f~1o\", 0);\n      Assert.AreEqual(cbor[\"f~1o\"], cbor.AtJSONPointer(\"/f~01o\"));\n      cbor = CBORObject.NewMap().Add(\"f/o\", 0);\n      Assert.AreEqual(cbor[\"f/o\"], cbor.AtJSONPointer(\"/f~1o\"));\n      cbor = CBORObject.NewMap().Add(\"foo\", CBORObject.NewMap().Add(\"bar\",\n            345));\n\n      Assert.AreEqual(\n        CBORObject.FromObject(345),\n        cbor.AtJSONPointer(\"/foo/bar\"));\n      cbor = CBORObject.NewMap().Add(\"foo\", CBORObject.NewArray().Add(678));\n      Assert.AreEqual(CBORObject.FromObject(678), cbor.AtJSONPointer(\"/foo/0\"));\n      try {\n        cbor.AtJSONPointer(\"/foo/1\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo/-\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo/-1\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"-\", 0);\n      Assert.AreEqual(cbor[\"-\"], cbor.AtJSONPointer(\"/-\"));\n      cbor = CBORObject.NewMap().Add(String.Empty, 0);\n      Assert.AreEqual(cbor[String.Empty], cbor.AtJSONPointer(\"/\"));\n    }\n\n    [Test]\n    public void TestDateTime() {\n      var dateList = new List<string>();\n      dateList.Add(\"0783-08-19T03:10:29.406Z\");\n      dateList.Add(\"1954-03-07T16:20:38.256Z\");\n      var rng = new RandomGenerator();\n      for (var i = 0; i < 2000; ++i) {\n        string dtstr = DateTimeToString(\n            rng.UniformInt(9999) + 1,\n            rng.UniformInt(12) + 1,\n            rng.UniformInt(28) + 1,\n            rng.UniformInt(24),\n            rng.UniformInt(60),\n            rng.UniformInt(60),\n            rng.UniformInt(1000));\n        dateList.Add(dtstr);\n      }\n      foreach (string dtstr in dateList) {\n        CBORObject cbor = CBORObject.FromObjectAndTag(dtstr, 0);\n        var dt = (DateTime)cbor.ToObject(typeof(DateTime));\n        ToObjectTest.TestToFromObjectRoundTrip(dt);\n      }\n    }\n\n    public static void TestDateTimeTag1One(string str, long timeValue) {\n      TestDateTimeTag1One(str, EInteger.FromInt64(timeValue));\n    }\n\n    public static void TestDateTimeTag1One(string str, EInteger ei) {\n      CBORObject cbornum;\n      cbornum = CBORObject.FromObjectAndTag(str, 0);\n      var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx);\n      cbornum = CBORObject.FromObjectAndTag(ei, 1);\n      var dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      TestCommon.AssertEqualsHashCode(dtx, dtx2);\n      if (ei == null) {\n        throw new ArgumentNullException(nameof(ei));\n      }\n      if (ei.CanFitInInt64()) {\n        cbornum = CBORObject.FromObjectAndTag(ei.ToInt64Checked(), 1);\n        dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n        TestCommon.AssertEqualsHashCode(dtx, dtx2);\n        ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      }\n      EFloat ef1 = EFloat.FromEInteger(ei).Plus(EContext.Binary64);\n      EFloat ef2 = EFloat.FromEInteger(ei);\n      if (ef1.CompareTo(ef2) == 0) {\n        cbornum = CBORObject.FromObjectAndTag(ef1, 1);\n        dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n        TestCommon.AssertEqualsHashCode(dtx, dtx2);\n        ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n        cbornum = CBORObject.FromObjectAndTag(ef1.ToDouble(), 1);\n        dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n        TestCommon.AssertEqualsHashCode(dtx, dtx2);\n        ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      }\n    }\n\n    public static void TestDateTimeTag1One(string str, double dbl) {\n      CBORObject cbornum;\n      cbornum = CBORObject.FromObjectAndTag(str, 0);\n      var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx);\n      cbornum = CBORObject.FromObjectAndTag(dbl, 1);\n      var dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      TestCommon.AssertEqualsHashCode(dtx, dtx2);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestDateTimeTag1Specific1() {\n      // Test speed\n      EInteger ei = EInteger.FromString(\"-14261178672295354872\");\n      CBORObject cbornum = CBORObject.FromObjectAndTag(ei, 1);\n      try {\n        var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n        ToObjectTest.TestToFromObjectRoundTrip(dtx);\n      } catch (CBORException) {\n        Console.WriteLine(\"Not supported: \" + ei);\n      }\n    }\n\n    [Test]\n    public void TestDateTimeSpecific2() {\n      TestDateTimeTag1One(\"1758-09-28T23:25:24Z\", -6666626076L);\n      TestDateTimeTag1One(\"1758-09-28T23:25:24.000Z\", -6666626076L);\n      TestDateTimeTag1One(\"1758-09-28T23:25:24.500Z\", -6666626075.5);\n      TestDateTimeTag1One(\"2325-11-08T01:47:40Z\", 11229587260L);\n      TestDateTimeTag1One(\"2325-11-08T01:47:40.000Z\", 11229587260L);\n      TestDateTimeTag1One(\"2325-11-08T01:47:40.500Z\", 11229587260.5);\n      TestDateTimeTag1One(\"1787-03-04T10:21:24Z\", -5769495516L);\n      TestDateTimeTag1One(\"1787-03-04T10:21:24.000Z\", -5769495516L);\n      TestDateTimeTag1One(\"1787-03-04T10:21:24.500Z\", -5769495515.5);\n      TestDateTimeTag1One(\"1828-11-17T11:59:01Z\", -4453358459L);\n      TestDateTimeTag1One(\"1828-11-17T11:59:01.000Z\", -4453358459L);\n      TestDateTimeTag1One(\"1828-11-17T11:59:01.500Z\", -4453358458.5);\n      TestDateTimeTag1One(\"2379-01-22T01:20:02Z\", 12908596802L);\n      TestDateTimeTag1One(\"2379-01-22T01:20:02.000Z\", 12908596802L);\n      TestDateTimeTag1One(\"1699-05-31T22:37:24Z\", -8538830556L);\n      TestDateTimeTag1One(\"1699-05-31T22:37:24.000Z\", -8538830556L);\n      TestDateTimeTag1One(\"1699-05-31T22:37:24.500Z\", -8538830555.5);\n      TestDateTimeTag1One(\"2248-02-13T03:16:17Z\", 8776523777L);\n      TestDateTimeTag1One(\"2248-02-13T03:16:17.000Z\", 8776523777L);\n      TestDateTimeTag1One(\"2248-02-13T03:16:17.500Z\", 8776523777.5);\n      TestDateTimeTag1One(\"2136-04-15T16:45:29Z\", 5247564329L);\n      TestDateTimeTag1One(\"2136-04-15T16:45:29.000Z\", 5247564329L);\n      TestDateTimeTag1One(\"1889-09-05T00:23:45Z\", -2534715375L);\n      TestDateTimeTag1One(\"1889-09-05T00:23:45.000Z\", -2534715375L);\n      TestDateTimeTag1One(\"1889-09-05T00:23:45.500Z\", -2534715374.5);\n      TestDateTimeTag1One(\"2095-08-13T20:04:08Z\", 3964104248L);\n      TestDateTimeTag1One(\"2095-08-13T20:04:08.000Z\", 3964104248L);\n      TestDateTimeTag1One(\"2095-08-13T20:04:08.500Z\", 3964104248.5);\n      TestDateTimeTag1One(\"2475-03-27T17:41:48Z\", 15943714908L);\n      TestDateTimeTag1One(\"2475-03-27T17:41:48.000Z\", 15943714908L);\n      TestDateTimeTag1One(\"2475-03-27T17:41:48.500Z\", 15943714908.5);\n      TestDateTimeTag1One(\"1525-11-18T07:47:54Z\", -14015088726L);\n      TestDateTimeTag1One(\"1525-11-18T07:47:54.000Z\", -14015088726L);\n      TestDateTimeTag1One(\"2353-01-12T09:36:32Z\", 12087308192L);\n      TestDateTimeTag1One(\"2353-01-12T09:36:32.000Z\", 12087308192L);\n      TestDateTimeTag1One(\"2353-01-12T09:36:32.500Z\", 12087308192.5);\n      TestDateTimeTag1One(\"2218-11-29T08:23:31Z\", 7854827011L);\n      TestDateTimeTag1One(\"2218-11-29T08:23:31.000Z\", 7854827011L);\n      TestDateTimeTag1One(\"2377-08-21T09:44:12Z\", 12863785452L);\n      TestDateTimeTag1One(\"2377-08-21T09:44:12.000Z\", 12863785452L);\n      TestDateTimeTag1One(\"2377-08-21T09:44:12.500Z\", 12863785452.5);\n      TestDateTimeTag1One(\"1530-09-02T02:13:52Z\", -13863995168L);\n      TestDateTimeTag1One(\"1530-09-02T02:13:52.000Z\", -13863995168L);\n      TestDateTimeTag1One(\"1530-09-02T02:13:52.500Z\", -13863995167.5);\n      TestDateTimeTag1One(\"2319-03-11T18:18:48Z\", 11019349128L);\n      TestDateTimeTag1One(\"2319-03-11T18:18:48.000Z\", 11019349128L);\n      TestDateTimeTag1One(\"2319-03-11T18:18:48.500Z\", 11019349128.5);\n      TestDateTimeTag1One(\"1602-12-05T09:36:58Z\", -11583699782L);\n      TestDateTimeTag1One(\"1602-12-05T09:36:58.000Z\", -11583699782L);\n      TestDateTimeTag1One(\"1874-01-25T21:14:10Z\", -3027293150L);\n      TestDateTimeTag1One(\"1874-01-25T21:14:10.000Z\", -3027293150L);\n      TestDateTimeTag1One(\"1874-01-25T21:14:10.500Z\", -3027293149.5);\n      TestDateTimeTag1One(\"1996-02-26T04:09:49Z\", 825307789L);\n      TestDateTimeTag1One(\"1996-02-26T04:09:49.000Z\", 825307789L);\n      TestDateTimeTag1One(\"1996-02-26T04:09:49.500Z\", 825307789.5);\n      TestDateTimeTag1One(\"2113-11-27T22:16:09Z\", 4541264169L);\n      TestDateTimeTag1One(\"2113-11-27T22:16:09.000Z\", 4541264169L);\n      TestDateTimeTag1One(\"2113-11-27T22:16:09.500Z\", 4541264169.5);\n      TestDateTimeTag1One(\"1612-01-07T16:25:51Z\", -11296827249L);\n      TestDateTimeTag1One(\"1612-01-07T16:25:51.000Z\", -11296827249L);\n      TestDateTimeTag1One(\"1612-01-07T16:25:51.500Z\", -11296827248.5);\n      TestDateTimeTag1One(\"2077-12-08T22:15:00Z\", 3406227300L);\n      TestDateTimeTag1One(\"2077-12-08T22:15:00.000Z\", 3406227300L);\n      TestDateTimeTag1One(\"2077-12-08T22:15:00.500Z\", 3406227300.5);\n      TestDateTimeTag1One(\"1820-07-06T12:06:08Z\", -4717396432L);\n      TestDateTimeTag1One(\"1820-07-06T12:06:08.000Z\", -4717396432L);\n      TestDateTimeTag1One(\"1820-07-06T12:06:08.500Z\", -4717396431.5);\n      TestDateTimeTag1One(\"1724-01-17T16:42:20Z\", -7761597460L);\n      TestDateTimeTag1One(\"1724-01-17T16:42:20.000Z\", -7761597460L);\n      TestDateTimeTag1One(\"1724-01-17T16:42:20.500Z\", -7761597459.5);\n      TestDateTimeTag1One(\"2316-03-11T00:46:54Z\", 10924678014L);\n      TestDateTimeTag1One(\"2316-03-11T00:46:54.000Z\", 10924678014L);\n      TestDateTimeTag1One(\"2495-07-18T22:11:29Z\", 16584646289L);\n      TestDateTimeTag1One(\"2495-07-18T22:11:29.000Z\", 16584646289L);\n      TestDateTimeTag1One(\"2495-07-18T22:11:29.500Z\", 16584646289.5);\n      TestDateTimeTag1One(\"1874-04-25T08:52:46Z\", -3019561634L);\n      TestDateTimeTag1One(\"1874-04-25T08:52:46.000Z\", -3019561634L);\n      TestDateTimeTag1One(\"1874-04-25T08:52:46.500Z\", -3019561633.5);\n      TestDateTimeTag1One(\"2226-05-18T19:38:50Z\", 8090480330L);\n      TestDateTimeTag1One(\"2226-05-18T19:38:50.000Z\", 8090480330L);\n      TestDateTimeTag1One(\"2226-05-18T19:38:50.500Z\", 8090480330.5);\n      TestDateTimeTag1One(\"2108-06-26T09:01:48Z\", 4370144508L);\n      TestDateTimeTag1One(\"2108-06-26T09:01:48.000Z\", 4370144508L);\n      TestDateTimeTag1One(\"2108-06-26T09:01:48.500Z\", 4370144508.5);\n      TestDateTimeTag1One(\"1955-10-03T06:06:55Z\", -449603585L);\n      TestDateTimeTag1One(\"1955-10-03T06:06:55.000Z\", -449603585L);\n      TestDateTimeTag1One(\"1955-10-03T06:06:55.500Z\", -449603584.5);\n      TestDateTimeTag1One(\"1906-03-26T17:32:58Z\", -2012365622L);\n      TestDateTimeTag1One(\"1906-03-26T17:32:58.000Z\", -2012365622L);\n      TestDateTimeTag1One(\"1906-03-26T17:32:58.500Z\", -2012365621.5);\n      TestDateTimeTag1One(\"1592-03-10T03:46:03Z\", -11922581637L);\n      TestDateTimeTag1One(\"1592-03-10T03:46:03.000Z\", -11922581637L);\n      TestDateTimeTag1One(\"1592-03-10T03:46:03.500Z\", -11922581636.5);\n      TestDateTimeTag1One(\"2433-12-19T01:24:19Z\", 14641349059L);\n      TestDateTimeTag1One(\"2433-12-19T01:24:19.000Z\", 14641349059L);\n      TestDateTimeTag1One(\"2433-12-19T01:24:19.500Z\", 14641349059.5);\n      TestDateTimeTag1One(\"1802-02-07T09:43:23Z\", -5298358597L);\n      TestDateTimeTag1One(\"1802-02-07T09:43:23.000Z\", -5298358597L);\n      TestDateTimeTag1One(\"2318-04-11T20:11:23Z\", 10990498283L);\n      TestDateTimeTag1One(\"2318-04-11T20:11:23.000Z\", 10990498283L);\n      TestDateTimeTag1One(\"2318-04-11T20:11:23.500Z\", 10990498283.5);\n      TestDateTimeTag1One(\"2083-01-06T11:06:22Z\", 3566459182L);\n      TestDateTimeTag1One(\"2083-01-06T11:06:22.000Z\", 3566459182L);\n      TestDateTimeTag1One(\"2083-01-06T11:06:22.500Z\", 3566459182.5);\n      TestDateTimeTag1One(\"1561-08-16T19:31:48Z\", -12887094492L);\n      TestDateTimeTag1One(\"1561-08-16T19:31:48.000Z\", -12887094492L);\n      TestDateTimeTag1One(\"1561-08-16T19:31:48.500Z\", -12887094491.5);\n      TestDateTimeTag1One(\"2475-11-05T21:20:03Z\", 15962995203L);\n      TestDateTimeTag1One(\"2475-11-05T21:20:03.000Z\", 15962995203L);\n      TestDateTimeTag1One(\"2475-11-05T21:20:03.500Z\", 15962995203.5);\n      TestDateTimeTag1One(\"2209-05-13T09:31:56Z\", 7553554316L);\n      TestDateTimeTag1One(\"2209-05-13T09:31:56.000Z\", 7553554316L);\n      TestDateTimeTag1One(\"2209-05-13T09:31:56.500Z\", 7553554316.5);\n      TestDateTimeTag1One(\"1943-06-25T19:09:49Z\", -836887811L);\n      TestDateTimeTag1One(\"1943-06-25T19:09:49.000Z\", -836887811L);\n      TestDateTimeTag1One(\"1943-06-25T19:09:49.500Z\", -836887810.5);\n      TestDateTimeTag1One(\"1751-09-18T07:31:00Z\", -6888472140L);\n      TestDateTimeTag1One(\"1751-09-18T07:31:00.000Z\", -6888472140L);\n      TestDateTimeTag1One(\"1751-09-18T07:31:00.500Z\", -6888472139.5);\n      TestDateTimeTag1One(\"1538-05-07T23:40:25Z\", -13621652375L);\n      TestDateTimeTag1One(\"1538-05-07T23:40:25.000Z\", -13621652375L);\n      TestDateTimeTag1One(\"1538-05-07T23:40:25.500Z\", -13621652374.5);\n      TestDateTimeTag1One(\"1628-02-10T00:07:33Z\", -10789026747L);\n      TestDateTimeTag1One(\"1628-02-10T00:07:33.000Z\", -10789026747L);\n      TestDateTimeTag1One(\"1628-02-10T00:07:33.500Z\", -10789026746.5);\n      TestDateTimeTag1One(\"1584-08-23T09:30:49Z\", -12160679351L);\n      TestDateTimeTag1One(\"1584-08-23T09:30:49.000Z\", -12160679351L);\n      TestDateTimeTag1One(\"1584-08-23T09:30:49.500Z\", -12160679350.5);\n      TestDateTimeTag1One(\"2230-08-28T23:13:43Z\", 8225536423L);\n      TestDateTimeTag1One(\"2230-08-28T23:13:43.000Z\", 8225536423L);\n      TestDateTimeTag1One(\"1846-02-19T20:02:33Z\", -3908750247L);\n      TestDateTimeTag1One(\"1846-02-19T20:02:33.000Z\", -3908750247L);\n      TestDateTimeTag1One(\"1846-02-19T20:02:33.500Z\", -3908750246.5);\n      TestDateTimeTag1One(\"2114-07-28T00:06:13Z\", 4562179573L);\n      TestDateTimeTag1One(\"2114-07-28T00:06:13.000Z\", 4562179573L);\n      TestDateTimeTag1One(\"2114-07-28T00:06:13.500Z\", 4562179573.5);\n      TestDateTimeTag1One(\"1855-04-03T15:29:33Z\", -3621054627L);\n      TestDateTimeTag1One(\"1855-04-03T15:29:33.000Z\", -3621054627L);\n      TestDateTimeTag1One(\"1855-04-03T15:29:33.500Z\", -3621054626.5);\n      TestDateTimeTag1One(\"1532-02-04T13:08:22Z\", -13819027898L);\n      TestDateTimeTag1One(\"1532-02-04T13:08:22.000Z\", -13819027898L);\n      TestDateTimeTag1One(\"2285-12-28T16:35:29Z\", 9971742929L);\n      TestDateTimeTag1One(\"2285-12-28T16:35:29.000Z\", 9971742929L);\n      TestDateTimeTag1One(\"2285-12-28T16:35:29.500Z\", 9971742929.5);\n      TestDateTimeTag1One(\"1784-08-08T15:25:01Z\", -5850520499L);\n      TestDateTimeTag1One(\"1784-08-08T15:25:01.000Z\", -5850520499L);\n      TestDateTimeTag1One(\"2190-06-25T10:55:10Z\", 6957744910L);\n      TestDateTimeTag1One(\"2190-06-25T10:55:10.000Z\", 6957744910L);\n      TestDateTimeTag1One(\"2190-06-25T10:55:10.500Z\", 6957744910.5);\n      TestDateTimeTag1One(\"2263-10-08T20:28:28Z\", 9270448108L);\n      TestDateTimeTag1One(\"2263-10-08T20:28:28.000Z\", 9270448108L);\n      TestDateTimeTag1One(\"2263-10-08T20:28:28.500Z\", 9270448108.5);\n      TestDateTimeTag1One(\"2036-05-12T10:02:45Z\", 2094199365L);\n      TestDateTimeTag1One(\"2036-05-12T10:02:45.000Z\", 2094199365L);\n      TestDateTimeTag1One(\"2036-05-12T10:02:45.500Z\", 2094199365.5);\n      TestDateTimeTag1One(\"2166-09-08T09:25:14Z\", 6206837114L);\n      TestDateTimeTag1One(\"2166-09-08T09:25:14.000Z\", 6206837114L);\n      TestDateTimeTag1One(\"2166-09-08T09:25:14.500Z\", 6206837114.5);\n      TestDateTimeTag1One(\"1698-12-30T18:31:11Z\", -8551978129L);\n      TestDateTimeTag1One(\"1698-12-30T18:31:11.000Z\", -8551978129L);\n      TestDateTimeTag1One(\"1780-10-16T15:02:56Z\", -5970790624L);\n      TestDateTimeTag1One(\"1780-10-16T15:02:56.000Z\", -5970790624L);\n      TestDateTimeTag1One(\"1780-10-16T15:02:56.500Z\", -5970790623.5);\n      TestDateTimeTag1One(\"1710-10-12T20:07:58Z\", -8180193122L);\n      TestDateTimeTag1One(\"1710-10-12T20:07:58.000Z\", -8180193122L);\n      TestDateTimeTag1One(\"1710-10-12T20:07:58.500Z\", -8180193121.5);\n      TestDateTimeTag1One(\"2034-09-28T04:45:04Z\", 2043031504L);\n      TestDateTimeTag1One(\"2034-09-28T04:45:04.000Z\", 2043031504L);\n      TestDateTimeTag1One(\"2034-09-28T04:45:04.500Z\", 2043031504.5);\n      TestDateTimeTag1One(\"1801-12-10T15:45:47Z\", -5303434453L);\n      TestDateTimeTag1One(\"1801-12-10T15:45:47.000Z\", -5303434453L);\n      TestDateTimeTag1One(\"1537-08-24T13:13:09Z\", -13643808411L);\n      TestDateTimeTag1One(\"1537-08-24T13:13:09.000Z\", -13643808411L);\n      TestDateTimeTag1One(\"1537-08-24T13:13:09.500Z\", -13643808410.5);\n      TestDateTimeTag1One(\"2249-09-24T21:07:14Z\", 8827477634L);\n      TestDateTimeTag1One(\"2249-09-24T21:07:14.000Z\", 8827477634L);\n      TestDateTimeTag1One(\"2249-09-24T21:07:14.500Z\", 8827477634.5);\n      TestDateTimeTag1One(\"2137-11-27T05:22:38Z\", 5298585758L);\n      TestDateTimeTag1One(\"2137-11-27T05:22:38.000Z\", 5298585758L);\n      TestDateTimeTag1One(\"2137-11-27T05:22:38.500Z\", 5298585758.5);\n      TestDateTimeTag1One(\"2123-07-31T13:09:34Z\", 4846482574L);\n      TestDateTimeTag1One(\"2123-07-31T13:09:34.000Z\", 4846482574L);\n      TestDateTimeTag1One(\"2123-07-31T13:09:34.500Z\", 4846482574.5);\n      TestDateTimeTag1One(\"2242-01-31T12:14:20Z\", 8586130460L);\n      TestDateTimeTag1One(\"2242-01-31T12:14:20.000Z\", 8586130460L);\n      TestDateTimeTag1One(\"2242-01-31T12:14:20.500Z\", 8586130460.5);\n      TestDateTimeTag1One(\"2232-11-04T21:12:33Z\", 8294562753L);\n      TestDateTimeTag1One(\"2232-11-04T21:12:33.000Z\", 8294562753L);\n      TestDateTimeTag1One(\"1590-12-06T04:30:48Z\", -11962322952L);\n      TestDateTimeTag1One(\"1590-12-06T04:30:48.000Z\", -11962322952L);\n      TestDateTimeTag1One(\"1590-12-06T04:30:48.500Z\", -11962322951.5);\n      TestDateTimeTag1One(\"1910-05-16T17:54:04Z\", -1881727556L);\n      TestDateTimeTag1One(\"1910-05-16T17:54:04.000Z\", -1881727556L);\n      TestDateTimeTag1One(\"1910-05-16T17:54:04.500Z\", -1881727555.5);\n      TestDateTimeTag1One(\"2482-06-15T23:28:00Z\", 16171572480L);\n      TestDateTimeTag1One(\"2482-06-15T23:28:00.000Z\", 16171572480L);\n      TestDateTimeTag1One(\"2482-06-15T23:28:00.500Z\", 16171572480.5);\n      TestDateTimeTag1One(\"1808-01-17T13:11:23Z\", -5110858117L);\n      TestDateTimeTag1One(\"1808-01-17T13:11:23.000Z\", -5110858117L);\n      TestDateTimeTag1One(\"1872-05-04T12:15:05Z\", -3081843895L);\n      TestDateTimeTag1One(\"1872-05-04T12:15:05.000Z\", -3081843895L);\n      TestDateTimeTag1One(\"1872-05-04T12:15:05.500Z\", -3081843894.5);\n      TestDateTimeTag1One(\"1719-05-18T16:44:33Z\", -7908909327L);\n      TestDateTimeTag1One(\"1719-05-18T16:44:33.000Z\", -7908909327L);\n      TestDateTimeTag1One(\"2137-05-26T02:17:32Z\", 5282590652L);\n      TestDateTimeTag1One(\"2137-05-26T02:17:32.000Z\", 5282590652L);\n      TestDateTimeTag1One(\"2137-05-26T02:17:32.500Z\", 5282590652.5);\n      TestDateTimeTag1One(\"1714-06-15T13:41:14Z\", -8064267526L);\n      TestDateTimeTag1One(\"1714-06-15T13:41:14.000Z\", -8064267526L);\n      TestDateTimeTag1One(\"1714-06-15T13:41:14.500Z\", -8064267525.5);\n      TestDateTimeTag1One(\"1878-12-03T20:14:03Z\", -2874109557L);\n      TestDateTimeTag1One(\"1878-12-03T20:14:03.000Z\", -2874109557L);\n      TestDateTimeTag1One(\"1878-12-03T20:14:03.500Z\", -2874109556.5);\n      TestDateTimeTag1One(\"2190-11-26T23:45:55Z\", 6971096755L);\n      TestDateTimeTag1One(\"2190-11-26T23:45:55.000Z\", 6971096755L);\n      TestDateTimeTag1One(\"2020-01-22T15:58:52Z\", 1579708732L);\n      TestDateTimeTag1One(\"2020-01-22T15:58:52.000Z\", 1579708732L);\n      TestDateTimeTag1One(\"2020-01-22T15:58:52.500Z\", 1579708732.5);\n      TestDateTimeTag1One(\"2245-10-06T15:40:51Z\", 8702264451L);\n      TestDateTimeTag1One(\"2245-10-06T15:40:51.000Z\", 8702264451L);\n      TestDateTimeTag1One(\"2245-10-06T15:40:51.500Z\", 8702264451.5);\n      TestDateTimeTag1One(\"1647-08-10T21:26:16Z\", -10173695624L);\n      TestDateTimeTag1One(\"1647-08-10T21:26:16.000Z\", -10173695624L);\n      TestDateTimeTag1One(\"1647-08-10T21:26:16.500Z\", -10173695623.5);\n      TestDateTimeTag1One(\"1628-11-10T01:03:36Z\", -10765349784L);\n      TestDateTimeTag1One(\"1628-11-10T01:03:36.000Z\", -10765349784L);\n      TestDateTimeTag1One(\"1628-11-10T01:03:36.500Z\", -10765349783.5);\n      TestDateTimeTag1One(\"2359-11-30T16:24:04Z\", 12304455844L);\n      TestDateTimeTag1One(\"2359-11-30T16:24:04.000Z\", 12304455844L);\n      TestDateTimeTag1One(\"2359-11-30T16:24:04.500Z\", 12304455844.5);\n      TestDateTimeTag1One(\"1833-10-12T18:44:22Z\", -4298678138L);\n      TestDateTimeTag1One(\"1833-10-12T18:44:22.000Z\", -4298678138L);\n      TestDateTimeTag1One(\"1833-10-12T18:44:22.500Z\", -4298678137.5);\n      TestDateTimeTag1One(\"1550-07-27T20:11:15Z\", -13235975325L);\n      TestDateTimeTag1One(\"1550-07-27T20:11:15.000Z\", -13235975325L);\n      TestDateTimeTag1One(\"1550-07-27T20:11:15.500Z\", -13235975324.5);\n      TestDateTimeTag1One(\"2376-11-23T23:17:49Z\", 12840419869L);\n      TestDateTimeTag1One(\"2376-11-23T23:17:49.000Z\", 12840419869L);\n      TestDateTimeTag1One(\"2376-11-23T23:17:49.500Z\", 12840419869.5);\n      TestDateTimeTag1One(\"2291-11-16T10:53:45Z\", 10157396025L);\n      TestDateTimeTag1One(\"2291-11-16T10:53:45.000Z\", 10157396025L);\n      TestDateTimeTag1One(\"2291-11-16T10:53:45.500Z\", 10157396025.5);\n      TestDateTimeTag1One(\"2349-11-15T11:45:50Z\", 11987610350L);\n      TestDateTimeTag1One(\"2349-11-15T11:45:50.000Z\", 11987610350L);\n      TestDateTimeTag1One(\"2059-05-22T21:03:13Z\", 2820862993L);\n      TestDateTimeTag1One(\"2059-05-22T21:03:13.000Z\", 2820862993L);\n      TestDateTimeTag1One(\"2059-05-22T21:03:13.500Z\", 2820862993.5);\n      TestDateTimeTag1One(\"1601-04-03T01:34:37Z\", -11636519123L);\n      TestDateTimeTag1One(\"1601-04-03T01:34:37.000Z\", -11636519123L);\n      TestDateTimeTag1One(\"1601-04-03T01:34:37.500Z\", -11636519122.5);\n      TestDateTimeTag1One(\"1853-11-01T19:05:56Z\", -3665796844L);\n      TestDateTimeTag1One(\"1853-11-01T19:05:56.000Z\", -3665796844L);\n      TestDateTimeTag1One(\"1853-11-01T19:05:56.500Z\", -3665796843.5);\n      TestDateTimeTag1One(\"2465-03-10T00:10:34Z\", 15626650234L);\n      TestDateTimeTag1One(\"2465-03-10T00:10:34.000Z\", 15626650234L);\n      TestDateTimeTag1One(\"1961-06-28T14:59:41Z\", -268563619L);\n      TestDateTimeTag1One(\"1961-06-28T14:59:41.000Z\", -268563619L);\n      TestDateTimeTag1One(\"1961-06-28T14:59:41.500Z\", -268563618.5);\n      TestDateTimeTag1One(\"2078-02-03T01:57:23Z\", 3411079043L);\n      TestDateTimeTag1One(\"2078-02-03T01:57:23.000Z\", 3411079043L);\n      TestDateTimeTag1One(\"2078-02-03T01:57:23.500Z\", 3411079043.5);\n      TestDateTimeTag1One(\"2325-11-05T11:53:57Z\", 11229364437L);\n      TestDateTimeTag1One(\"2325-11-05T11:53:57.000Z\", 11229364437L);\n      TestDateTimeTag1One(\"2325-11-05T11:53:57.500Z\", 11229364437.5);\n      TestDateTimeTag1One(\"2189-02-10T04:55:14Z\", 6914523314L);\n      TestDateTimeTag1One(\"2189-02-10T04:55:14.000Z\", 6914523314L);\n      TestDateTimeTag1One(\"2189-02-10T04:55:14.500Z\", 6914523314.5);\n      TestDateTimeTag1One(\"2416-04-20T21:48:33Z\", 14083969713L);\n      TestDateTimeTag1One(\"2416-04-20T21:48:33.000Z\", 14083969713L);\n      TestDateTimeTag1One(\"2416-04-20T21:48:33.500Z\", 14083969713.5);\n      TestDateTimeTag1One(\"2009-06-24T20:06:34Z\", 1245873994L);\n      TestDateTimeTag1One(\"2009-06-24T20:06:34.000Z\", 1245873994L);\n      TestDateTimeTag1One(\"2009-06-24T20:06:34.500Z\", 1245873994.5);\n      TestDateTimeTag1One(\"2488-05-20T22:56:10Z\", 16358712970L);\n      TestDateTimeTag1One(\"2488-05-20T22:56:10.000Z\", 16358712970L);\n      TestDateTimeTag1One(\"1519-07-05T21:55:20Z\", -14216177080L);\n      TestDateTimeTag1One(\"1519-07-05T21:55:20.000Z\", -14216177080L);\n      TestDateTimeTag1One(\"1519-07-05T21:55:20.500Z\", -14216177079.5);\n      TestDateTimeTag1One(\"2349-05-25T11:44:14Z\", 11972576654L);\n      TestDateTimeTag1One(\"2349-05-25T11:44:14.000Z\", 11972576654L);\n    }\n\n    [Test]\n    [Timeout(100000)]\n    public void TestDateTimeTag1() {\n      CBORObject cbornum;\n      var rg = new RandomGenerator();\n      DateTime dt, dt2;\n      for (var i = 0; i < 1000; ++i) {\n        EInteger ei = CBORTestCommon.RandomEIntegerMajorType0Or1(rg);\n        cbornum = CBORObject.FromObjectAndTag(ei, 1);\n        try {\n          var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n          ToObjectTest.TestToFromObjectRoundTrip(dtx);\n        } catch (CBORException) {\n          // Console.WriteLine(\"Not supported: \"+ei);\n        }\n      }\n      for (var i = 0; i < 1000; ++i) {\n        double dbl = RandomObjects.RandomFiniteDouble(rg);\n        cbornum = CBORObject.FromObjectAndTag(dbl, 1);\n        try {\n          var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n          ToObjectTest.TestToFromObjectRoundTrip(dtx);\n        } catch (CBORException) {\n          // Console.WriteLine(\"Not supported: \"+dbl);\n        }\n      }\n      string dateStr = \"1970-01-01T00:00:00.000Z\";\n      CBORObject cbor = CBORObject.FromObjectAndTag(dateStr, 0);\n      dt = (DateTime)cbor.ToObject(typeof(DateTime));\n      CBORObject cbor2 = CBORObject.FromObjectAndTag(0, 1);\n      dt2 = (DateTime)cbor.ToObject(typeof(DateTime));\n      Assert.AreEqual(dt2, dt);\n    }\n\n    private static string RandomQueryStringLike(IRandomGenExtended irg) {\n      var sb = new StringBuilder();\n      while (true) {\n        int x = irg.GetInt32(100);\n        if (x == 0) {\n          break;\n        } else if (x < 10) {\n          sb.Append('&');\n        } else if (x < 20) {\n          sb.Append('=');\n        } else if (x < 25) {\n          string hex = \"0123456789ABCDEF\";\n          sb.Append('%');\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n        } else if (x < 30) {\n          string hex = \"0123456789abcdef\";\n          sb.Append('%');\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n        } else if (x < 95) {\n          sb.Append((char)(irg.GetInt32(0x5e) + 0x21));\n        } else {\n          sb.Append((char)irg.GetInt32(0x80));\n        }\n      }\n      return sb.ToString();\n    }\n\n    [Test]\n    public void TestQueryStrings() {\n      // TODO: Add utility to create query strings\n      String test = \"a=b&c=d&e=f&g\\u005b0]=h&g\\u005b1]=j&g\\u005b2]\\u005b\";\n      test += \"a]=k&g\\u005b2]\\u005bb]=m\";\n      CBORObject cbor =\n        CBORObject.FromObject(QueryStringHelper.QueryStringToDict(test));\n      Console.WriteLine(cbor.ToJSONString());\n      cbor = CBORObject.FromObject(QueryStringHelper.QueryStringToCBOR(test));\n      Console.WriteLine(cbor.ToJSONString());\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 100000; ++i) {\n        string str = RandomQueryStringLike(rg);\n        try {\n          cbor = QueryStringHelper.QueryStringToCBOR(str);\n          // Console.WriteLine(\"succ: \" + str);\n          // Console.WriteLine(cbor.ToJSONString());\n        } catch (InvalidOperationException) {\n          // Console.WriteLine(\"throws: \"+str);\n        }\n      }\n    }\n\n    private static CBORObject FromJSON(string json, JSONOptions jsonop) {\n      // var sw = new System.Diagnostics.Stopwatch();\n      // sw.Start();\n      CBORObject cbor = CBORObject.FromJSONString(json, jsonop);\n      // sw.Stop();\n      // Console.WriteLine(String.Empty + sw.ElapsedMilliseconds + \" ms\");\n      return cbor;\n    }\n\n    private static CBORObject FromJSON(string json, string numconv) {\n      return FromJSON(json, new JSONOptions(\"numberconversion=\" + numconv));\n    }\n\n    public static void AssertJSONDouble(\n      string json,\n      string numconv,\n      double dbl) {\n      var opt = new JSONOptions(\"numberconversion=\" + numconv);\n      CBORObject[] cbors = {\n        FromJSON(json, numconv),\n        CBORDataUtilities.ParseJSONNumber(json, opt),\n      };\n      foreach (CBORObject cbor in cbors) {\n        if (cbor.Type != CBORType.FloatingPoint) {\n          Assert.AreEqual(\n            CBORType.FloatingPoint,\n            cbor.Type,\n            json + \" \" + numconv + \" \" + dbl);\n        }\n        double cbordbl = cbor.AsDoubleValue();\n        if (dbl != cbordbl) {\n          Assert.Fail(\"dbl = \" + dbl + \", cbordbl = \" + cbordbl + \", \" +\n            json + \" \" + numconv + \" \" + dbl);\n        }\n      }\n    }\n\n    public static void AssertJSONInteger(\n      string json,\n      string numconv,\n      long longval) {\n      var opt = new JSONOptions(\"numberconversion=\" + numconv);\n      CBORObject[] cbors = {\n        FromJSON(json, numconv),\n        CBORDataUtilities.ParseJSONNumber(json, opt),\n      };\n      foreach (CBORObject cbor in cbors) {\n        if (cbor.Type != CBORType.Integer) {\n          string msg = json + \" \" + numconv + \" \" + longval;\n          msg = msg.Substring(0, Math.Min(100, msg.Length));\n          if (msg.Length > 100) {\n            msg += \"...\";\n          }\n          Assert.AreEqual(CBORType.Integer, cbor.Type, msg);\n        }\n        Assert.AreEqual(longval, cbor.AsInt64Value());\n      }\n    }\n\n    public static void AssertJSONInteger(\n      string json,\n      string numconv,\n      int intval) {\n      var opt = new JSONOptions(\"numberconversion=\" + numconv);\n      CBORObject[] cbors = {\n        FromJSON(json, numconv),\n        CBORDataUtilities.ParseJSONNumber(json, opt),\n      };\n      foreach (CBORObject cbor in cbors) {\n        if (cbor.Type != CBORType.Integer) {\n          string msg = json + \" \" + numconv + \" \" + intval;\n          msg = msg.Substring(0, Math.Min(100, msg.Length));\n          if (msg.Length > 100) {\n            msg += \"...\";\n          }\n          Assert.AreEqual(CBORType.Integer, cbor.Type, msg);\n        }\n        Assert.AreEqual(intval, cbor.AsInt32Value());\n      }\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongSpecific1() {\n      JSONOptions jsonop = JSONOptions.Default;\n      string json = \"{\\\"x\\\":-9.2574033594381E-7962\\u002c\\\"1\\\":\" +\n        \"-2.8131427974929237E+240}\";\n      try {\n        FromJSON(json, jsonop);\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private static readonly JSONOptions JSONOptionsDouble = new JSONOptions(\n      \"numberconversion=double\");\n    private static readonly JSONOptions JSONOptionsFull = new JSONOptions(\n      \"numberconversion=full\");\n\n    public static void TestParseNumberFxxLine(string line) {\n      // Parse test case format used in:\n      // https://github.com/nigeltao/parse-number-fxx-test-data\n      string f16 = line.Substring(0, 4);\n      if (line[4] != ' ') {\n        Assert.Fail(line);\n      }\n      string f32 = line.Substring(4 + 1, 8);\n      if (line[4 + 9] != ' ') {\n        Assert.Fail(line);\n      }\n      string f64 = line.Substring(4 + 1 + 8 + 1, 16);\n      if (line[4 + 26] != ' ') {\n        Assert.Fail(line);\n      }\n      string str = line.Substring(4 + 1 + 8 + 1 + 16 + 1);\n      short sf16 = EInteger.FromRadixString(f16, 16).ToInt16Unchecked();\n      int sf32 = EInteger.FromRadixString(f32, 16).ToInt32Unchecked();\n      long sf64 = EInteger.FromRadixString(f64, 16).ToInt64Unchecked();\n      TestParseNumberFxx(str, sf16, sf32, sf64, line);\n    }\n\n    public static void TestParseNumberFxx(\n      string str,\n      short f16,\n      int f32,\n      long f64,\n      string line) {\n      if (str[0] == '.' || str[str.Length - 1] == '.' ||\n        str.Contains(\".e\") || str.Contains(\".E\")) {\n        // Not a valid JSON number, so skip\n        // Console.WriteLine(str);\n        return;\n      }\n      if (CBORObject.FromObject(f16) == null) {\n        Assert.Fail();\n      }\n      CBORObject cbor = CBORDataUtilities.ParseJSONNumber(str,\n          JSONOptionsDouble);\n      if (cbor == null) {\n        Console.WriteLine(str);\n        return;\n      }\n      Assert.AreEqual(f64, cbor.AsDoubleBits(), line);\n      cbor = CBORObject.FromJSONString(str, JSONOptionsDouble);\n      Assert.AreEqual(f64, cbor.AsDoubleBits(), line);\n      cbor = CBORObject.FromJSONBytes(\n          DataUtilities.GetUtf8Bytes(str, false),\n          JSONOptionsDouble);\n      Assert.AreEqual(f64, cbor.AsDoubleBits(), line);\n      float sing = CBORObject.FromFloatingPointBits(f32, 4).AsSingle();\n      cbor = CBORDataUtilities.ParseJSONNumber(str, JSONOptionsFull);\n      if (cbor == null) {\n        Assert.Fail();\n      }\n      Assert.AreEqual(sing, cbor.AsSingle(), line);\n      cbor = CBORObject.FromJSONString(str, JSONOptionsFull);\n      Assert.AreEqual(sing, cbor.AsSingle(), line);\n      cbor = CBORObject.FromJSONBytes(\n          DataUtilities.GetUtf8Bytes(str, false),\n          JSONOptionsFull);\n      Assert.AreEqual(sing, cbor.AsSingle(), line);\n      // TODO: Test f16\n    }\n\n    [Test]\n    public void TestCloseToPowerOfTwo() {\n      for (var i = 31; i < 129; ++i) {\n        EInteger ei = EInteger.FromInt32(1).ShiftLeft(i);\n        {\n          AssertJSONDouble(\n            ei.ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei).ToDouble());\n          AssertJSONDouble(\n            ei.Add(1).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Add(1)).ToDouble());\n          AssertJSONDouble(\n            ei.Subtract(2).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Subtract(2)).ToDouble());\n          AssertJSONDouble(\n            ei.Add(2).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Add(2)).ToDouble());\n          AssertJSONDouble(\n            ei.Subtract(2).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Subtract(2)).ToDouble());\n        }\n      }\n    }\n\n    [Test]\n    public void TestFromJsonStringFastCases() {\n      var op = new JSONOptions(\"numberconversion=double\");\n      Assert.AreEqual(\n        JSONOptions.ConversionMode.Double,\n        op.NumberConversion);\n      op = new JSONOptions(\"numberconversion=intorfloat\");\n      Assert.AreEqual(\n        JSONOptions.ConversionMode.IntOrFloat,\n        op.NumberConversion);\n      string manyzeros = TestCommon.Repeat(\"0\", 1000000);\n      string manythrees = TestCommon.Repeat(\"3\", 1000000);\n      AssertJSONDouble(\n        \"0e-\" + manyzeros,\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        \"0.\" + manyzeros,\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        \"0.\" + manyzeros + \"e-9999999999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-9999999999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-9999999999999\",\n        \"intorfloat\",\n        0.0);\n\n      AssertJSONInteger(\n        manythrees + \"e-9999999999999\",\n        \"intorfloatfromdouble\",\n        0);\n\n      AssertJSONDouble(\n        \"0.\" + manyzeros + \"e-99999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-99999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-99999999\",\n        \"intorfloat\",\n        0.0);\n      AssertJSONInteger(\n        manythrees + \"e-99999999\",\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"0e-\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"0e-\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"-0e-\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"-0e-\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"0.\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"0.\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"-0.\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"-0.\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n    }\n\n    [Test]\n    public void TestFromJsonStringFiniteDoubleSpec() {\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 10000; ++i) {\n        double dbl = RandomObjects.RandomFiniteDouble(rg);\n        EFloat efd = EFloat.FromDouble(dbl);\n        AssertJSONDouble(\n          efd.ToShortestString(EContext.Binary64),\n          \"double\",\n          dbl);\n        AssertJSONDouble(\n          efd.ToString(),\n          \"double\",\n          dbl);\n      }\n    }\n\n    [Test]\n    public void TestEDecimalEFloatWithHighExponent() {\n      string decstr = \"0E100441809235791722330759976\";\n      Assert.AreEqual(0L, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(0L, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      decstr = \"0E-100441809235791722330759976\";\n      Assert.AreEqual(0L, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(0L, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      decstr = \"-0E100441809235791722330759976\";\n      long negzero = 1L << 63;\n      Assert.AreEqual(negzero, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(negzero, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      decstr = \"-0E-100441809235791722330759976\";\n      Assert.AreEqual(negzero, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(negzero, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n    }\n\n    [Test]\n    public void TestFromJsonStringZeroWithHighExponent() {\n      string decstr = \"0E100441809235791722330759976\";\n      EDecimal ed = EDecimal.FromString(decstr);\n      double dbl = ed.ToDouble();\n      Assert.AreEqual(0.0d, dbl);\n      AssertJSONDouble(decstr, \"double\", dbl);\n      AssertJSONInteger(decstr, \"intorfloat\", 0);\n      decstr = \"0E1321909565013040040586\";\n      ed = EDecimal.FromString(decstr);\n      dbl = ed.ToDouble();\n      Assert.AreEqual(0.0d, dbl);\n      AssertJSONDouble(decstr, \"double\", dbl);\n      AssertJSONInteger(decstr, \"intorfloat\", 0);\n      double dblnegzero = EFloat.FromString(\"-0\").ToDouble();\n      AssertJSONDouble(\"0E-1321909565013040040586\", \"double\", 0.0);\n      AssertJSONInteger(\"0E-1321909565013040040586\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E1321909565013040040586\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E1321909565013040040586\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E-1321909565013040040586\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E-1321909565013040040586\", \"intorfloat\", 0);\n\n      AssertJSONDouble(\"0E-100441809235791722330759976\", \"double\", 0.0);\n      AssertJSONInteger(\"0E-100441809235791722330759976\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E100441809235791722330759976\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E100441809235791722330759976\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E-100441809235791722330759976\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E-100441809235791722330759976\", \"intorfloat\", 0);\n    }\n\n    [Test]\n    public void TestFromJsonStringEDecimalSpec() {\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 2000; ++i) {\n        var decstring = new string[1];\n        EDecimal ed = RandomObjects.RandomEDecimal(rg, decstring);\n        if (decstring[0] == null) {\n          Assert.Fail();\n        }\n        double dbl = ed.ToDouble();\n        if (Double.IsPositiveInfinity(dbl) ||\n                 Double.IsNegativeInfinity(dbl) ||\n                 Double.IsNaN(dbl)) {\n          continue;\n        }\n        AssertJSONDouble(\n          decstring[0],\n          \"double\",\n          dbl);\n      }\n    }\n\n    [Test]\n    public void TestFromJsonCTLInString() {\n      for (var i = 0; i <= 0x20; ++i) {\n        byte[] bytes = { 0x22, (byte)i, 0x22 };\n        char[] chars = { (char)0x22, (char)i, (char)0x22 };\n        string str = new String(chars, 0, chars.Length);\n        if (i == 0x20) {\n          try {\n            CBORObject.FromJSONString(str);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.FromJSONBytes(bytes);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONString(str);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.FromJSONBytes(bytes);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    // [Test]\n    public void TestFromJsonLeadingTrailingCTLBytes() {\n      // TODO: Reenable eventually, once UTF-8 only support\n      // for CBORObject.FromJSONBytes is implemented\n      for (var i = 0; i <= 0x20; ++i) {\n        // Leading CTL\n        byte[] bytes = { (byte)i, 0x31 };\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"bytes \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n            Assert.Fail(\"Should have failed bytes \" + i);\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // Trailing CTL\n        bytes = new byte[] { 0x31, (byte)i };\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"bytes \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"bytes \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestFromJsonLeadingTrailingCTL() {\n      for (var i = 0; i <= 0x20; ++i) {\n        // Leading CTL\n        char[] chars = { (char)i, (char)0x31 };\n        string str = new String(chars, 0, chars.Length);\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONString(str);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"string \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONString(str);\n            Assert.Fail(\"Should have failed string \" + i);\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // Trailing CTL\n        chars = new char[] { (char)0x31, (char)i };\n        str = new String(chars, 0, chars.Length);\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONString(str);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"string \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONString(str);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"string \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestFromJsonStringSmallDoubleSpec() {\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 10000; ++i) {\n        int rv = rg.GetInt32(Int32.MaxValue) * ((rg.GetInt32(2) * 2) - 1);\n        string rvstring = TestCommon.IntToString(rv);\n        AssertJSONDouble(\n          rvstring,\n          \"double\",\n          (double)rv);\n        AssertJSONInteger(\n          rvstring,\n          \"intorfloat\",\n          rv);\n      }\n      AssertJSONDouble(\"511\", \"double\", 511);\n      AssertJSONDouble(\"-511\", \"double\", -511);\n      AssertJSONDouble(\n        TestCommon.IntToString(Int32.MaxValue),\n        \"double\",\n        (double)Int32.MaxValue);\n      AssertJSONDouble(\n        TestCommon.IntToString(Int32.MaxValue),\n        \"double\",\n        (double)Int32.MaxValue);\n      AssertJSONDouble(\n        TestCommon.IntToString(Int32.MinValue),\n        \"double\",\n        (double)Int32.MinValue);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringSmallDouble() {\n      CBORObject cbor;\n      AssertJSONDouble(\"0\", \"double\", 0.0);\n      cbor = FromJSON(\"[0, 1, 2, 3]\", \"double\");\n      Assert.AreEqual(4, cbor.Count);\n      Assert.AreEqual((double)0.0, cbor[0].AsDouble());\n      Assert.AreEqual((double)1.0, cbor[1].AsDouble());\n      Assert.AreEqual((double)2.0, cbor[2].AsDouble());\n      Assert.AreEqual((double)3.0, cbor[3].AsDouble());\n      cbor = FromJSON(\"[0]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      Assert.AreEqual((double)0.0, cbor[0].AsDouble());\n      cbor = FromJSON(\"[-0]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      cbor = FromJSON(\"[1]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      Assert.AreEqual((double)1.0, cbor[0].AsDouble());\n      cbor = FromJSON(\"[-1]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      Assert.AreEqual((double)-1.0, cbor[0].AsDouble());\n      cbor = FromJSON(\"[-1022,-1023,-1024,-1025,1022,1023,1024,1025]\",\n          \"double\");\n      Assert.AreEqual(8, cbor.Count);\n      Assert.AreEqual((double)-1022.0, cbor[0].AsDouble());\n      Assert.AreEqual((double)-1023.0, cbor[1].AsDouble());\n      Assert.AreEqual((double)-1024.0, cbor[2].AsDouble());\n      Assert.AreEqual((double)-1025.0, cbor[3].AsDouble());\n      Assert.AreEqual((double)1022.0, cbor[4].AsDouble());\n      Assert.AreEqual((double)1023.0, cbor[5].AsDouble());\n      Assert.AreEqual((double)1024.0, cbor[6].AsDouble());\n      Assert.AreEqual((double)1025.0, cbor[7].AsDouble());\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindFull() {\n      var jsonop = new JSONOptions(\"numberconversion=full\");\n      string json = TestCommon.Repeat(\"7\", 100000);\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.IsTrue(cbor.IsTagged);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindFull2() {\n      var jsonop = new JSONOptions(\"numberconversion=full\");\n      string json = TestCommon.Repeat(\"7\", 100000) + \".0\";\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.IsTrue(cbor.IsTagged);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindFullBad() {\n      Console.WriteLine(\"FullBad 1\");\n      var jsonop = new JSONOptions(\"numberconversion=full\");\n      string manysevens = TestCommon.Repeat(\"7\", 1000000);\n      string[] badjson = {\n        manysevens + \"x\",\n        \"7x\" + manysevens,\n        manysevens + \"e0x\",\n        \"-\" + manysevens + \"x\",\n        \"-7x\" + manysevens,\n        \"-\" + manysevens + \"e0x\",\n      };\n      foreach (string str in badjson) {\n        try {\n          FromJSON(str, jsonop);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Console.WriteLine(\"FullBad 2\");\n      string json = TestCommon.Repeat(\"0\", 1000000);\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindsBad() {\n      JSONOptions jsonop;\n      string json = TestCommon.Repeat(\"7\", 1000000) + \"x\";\n      jsonop = new JSONOptions(\"numberconversion=double\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloatfromdouble\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      json = TestCommon.Repeat(\"0\", 1000000);\n      jsonop = new JSONOptions(\"numberconversion=double\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloatfromdouble\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindIntOrFloatFromDouble() {\n      var jsonop = new JSONOptions(\"numberconversion=intorfloatfromdouble\");\n      string manysevens = TestCommon.Repeat(\"7\", 1000000);\n      string json = manysevens;\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n      json = manysevens + \"e+0\";\n      cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n      json = manysevens + \"e0\";\n      cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindIntOrFloat() {\n      var jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      string json = TestCommon.Repeat(\"7\", 1000000);\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindIntOrFloat2() {\n      var jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      string json = \"-\" + TestCommon.Repeat(\"7\", 1000000);\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.NegativeInfinity);\n    }\n\n    [Test]\n    public void TestToObject_TypeMapper() {\n      var mapper = new CBORTypeMapper()\n      .AddConverter(typeof(string), new TestConverter());\n      CBORObject cbor = CBORObject.FromObject(\"UpPeR\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"upper\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"TRUE\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"true\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"false\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"false\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"FALSE\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"false\",\n          stringTemp);\n      }\n    }\n  }\n}\n", "<Project Sdk='Microsoft.NET.Sdk'>\n  <PropertyGroup>\n    <TargetFramework>netcoreapp2.1</TargetFramework>\n  </PropertyGroup>\n  <PropertyGroup Condition=' &apos;$(Configuration)&apos;==&apos;Debug&apos; '>\n    <DebugType>full</DebugType>\n    <CodeAnalysisRuleSet>rules.ruleset</CodeAnalysisRuleSet></PropertyGroup>\n  <PropertyGroup Condition=' &apos;$(Configuration)&apos;==&apos;Release&apos; '>\n    <DebugType>none</DebugType>\n    <CodeAnalysisRuleSet>rules.ruleset</CodeAnalysisRuleSet></PropertyGroup>\n  <ItemGroup>\n    <ProjectReference Include='..\\CBOR\\CBOR.csproj'/>\n  <AdditionalFiles Include='stylecop.json'/><AdditionalFiles Include='rules.ruleset'/></ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include='Resources.restext'>\n      <LogicalName>Resources.resources</LogicalName>\n    </EmbeddedResource></ItemGroup>\n      <ItemGroup>\n        <PackageReference Include='Microsoft.NET.Test.Sdk' Version='15.9.0'/>\n        <PackageReference Include='NUnit' Version='3.13.2'/>\n        <PackageReference Include='Microsoft.CodeAnalysis.NetAnalyzers' PrivateAssets='All' Version='5.0.3'/>\n        <PackageReference Include='NUnit3TestAdapter' Version='3.16.1'>\n          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n          <PrivateAssets>all</PrivateAssets>\n        </PackageReference>\n        <PackageReference Include='StyleCop.Analyzers' PrivateAssets='All' Version='1.2.0-beta.354'/>\n        <PackageReference Include='PeterO.Numbers' Version='1.8.2'/>\n      </ItemGroup>\n   </Project>\n", "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing NUnit.Framework;\nusing PeterO;\nusing PeterO.Cbor;\nusing PeterO.Numbers;\n\nnamespace Test {\n  internal static class CBORTestCommon {\n    internal static readonly EDecimal DecPosInf =\n      EDecimal.PositiveInfinity;\n\n    internal static readonly EDecimal DecNegInf =\n      EDecimal.NegativeInfinity;\n\n    internal static readonly EFloat FloatPosInf =\n      EFloat.PositiveInfinity;\n\n    internal static readonly EFloat FloatNegInf =\n      EFloat.NegativeInfinity;\n\n    internal static readonly ERational RatPosInf =\n      ERational.PositiveInfinity;\n\n    internal static readonly ERational RatNegInf =\n      ERational.NegativeInfinity;\n\n    private static EFloat RandomEFloatLowExponent(IRandomGenExtended rand) {\n      while (true) {\n         EFloat ef = RandomObjects.RandomEFloat(rand);\n         if (\n           ef.Exponent.CompareTo(-20000) >= 0 &&\nef.Exponent.CompareTo(20000) <= 0) {\n           return ef;\n         }\n       }\n    }\n\n    private static EDecimal RandomEDecimalLowExponent(IRandomGenExtended rand) {\n      while (true) {\n         EDecimal ef = RandomObjects.RandomEDecimal(rand);\n         if (\n           ef.Exponent.CompareTo(-20000) >= 0 &&\nef.Exponent.CompareTo(20000) <= 0) {\n           return ef;\n         }\n       }\n    }\n\n    public static CBORObject RandomNumber(IRandomGenExtended rand) {\n      return RandomNumber(rand, false);\n    }\n\n    public static CBORObject RandomNumber(IRandomGenExtended rand, bool\nlowExponent) {\n      object o = null;\n      switch (rand.GetInt32(6)) {\n        case 0:\n          o = RandomObjects.RandomDouble(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 1:\n          o = RandomObjects.RandomSingle(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 2:\n          return CBORObject.FromObject(\n              RandomObjects.RandomEInteger(rand));\n        case 3:\n          o = lowExponent ? RandomEFloatLowExponent(rand) :\n               RandomObjects.RandomEFloat(rand);\n          return CBORObject.FromObject(o);\n        case 4:\n          o = lowExponent ? RandomEDecimalLowExponent(rand) :\n               RandomObjects.RandomEDecimal(rand);\n          return CBORObject.FromObject(o);\n        case 5:\n          o = RandomObjects.RandomInt64(rand);\n          return CBORObject.FromObject(o);\n        default: throw new InvalidOperationException();\n      }\n    }\n\n    public static CBORObject RandomNumberOrRational(IRandomGenExtended rand) {\n      object o = null;\n      switch (rand.GetInt32(7)) {\n        case 0:\n          o = RandomObjects.RandomDouble(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 1:\n          o = RandomObjects.RandomSingle(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 2:\n          return CBORObject.FromObject(\n              RandomObjects.RandomEInteger(rand));\n        case 3:\n          return CBORObject.FromObject(\n              RandomObjects.RandomEFloat(rand));\n        case 4:\n          o = RandomObjects.RandomEDecimal(rand);\n          return CBORObject.FromObject(o);\n        case 5:\n          o = RandomObjects.RandomInt64(rand);\n          return CBORObject.FromObject(o);\n        case 6:\n          o = RandomObjects.RandomERational(rand);\n          return CBORObject.FromObject(o);\n        default: throw new InvalidOperationException();\n      }\n    }\n\n    public static CBORObject RandomCBORMap(IRandomGenExtended rand, int depth) {\n      int x = rand.GetInt32(100);\n      int count = (x < 80) ? 2 : ((x < 93) ? 1 : ((x < 98) ? 0 : 10));\n      CBORObject cborRet = CBORObject.NewMap();\n      for (var i = 0; i < count; ++i) {\n        CBORObject key = RandomCBORObject(rand, depth + 1);\n        CBORObject value = RandomCBORObject(rand, depth + 1);\n        cborRet[key] = value;\n      }\n      return cborRet;\n    }\n\n    public static EInteger RandomEIntegerMajorType0(IRandomGenExtended rand) {\n      int v = rand.GetInt32(0x10000);\n      EInteger ei = EInteger.FromInt32(v);\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      return ei;\n    }\n\n    public static EInteger RandomEIntegerMajorType0Or1(IRandomGenExtended\nrand) {\n      int v = rand.GetInt32(0x10000);\n      EInteger ei = EInteger.FromInt32(v);\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      if (rand.GetInt32(2) == 0) {\n        ei = ei.Add(1).Negate();\n      }\n      return ei;\n    }\n\n    public static CBORObject RandomCBORTaggedObject(\n      IRandomGenExtended rand,\n      int depth) {\n      var tag = 0;\n      if (rand.GetInt32(2) == 0) {\n        int[] tagselection = {\n          2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 30, 30,\n          30, 0, 1, 25, 26, 27,\n        };\n        tag = tagselection[rand.GetInt32(tagselection.Length)];\n      } else if (rand.GetInt32(100) < 90) {\n        return CBORObject.FromObjectAndTag(\n            RandomCBORObject(rand, depth + 1),\n            rand.GetInt32(0x100000));\n      } else {\n        return CBORObject.FromObjectAndTag(\n            RandomCBORObject(rand, depth + 1),\n            RandomEIntegerMajorType0(rand));\n      }\n      if (tag == 25) {\n        tag = 0;\n      }\n      if (tag == 30) {\n        object o = RandomObjects.RandomByteString(rand);\n        return CBORObject.FromObject(o);\n      }\n      {\n        CBORObject cbor;\n        // Console.WriteLine(\"tag \"+tag+\" \"+i);\n        if (tag == 0 || tag == 1 || tag == 28 || tag == 29) {\n          tag = 999;\n        }\n        if (tag == 2 || tag == 3) {\n          object o = RandomObjects.RandomByteStringShort(rand);\n          cbor = CBORObject.FromObject(o);\n        } else if (tag == 4 || tag == 5) {\n          cbor = CBORObject.NewArray();\n          object o = RandomObjects.RandomSmallIntegral(rand);\n          cbor.Add(o);\n          o = RandomObjects.RandomEInteger(rand);\n          cbor.Add(o);\n        } else if (tag == 30) {\n          cbor = CBORObject.NewArray();\n          object o = RandomObjects.RandomSmallIntegral(rand);\n          cbor.Add(o);\n          o = RandomObjects.RandomEInteger(rand);\n          cbor.Add(o);\n        } else {\n          cbor = RandomCBORObject(rand, depth + 1);\n        }\n        return CBORObject.FromObjectAndTag(cbor, tag);\n      }\n    }\n\n    public static CBORObject RandomCBORArray(IRandomGenExtended rand, int\ndepth) {\n      int x = rand.GetInt32(100);\n      int count = (x < 80) ? 2 : ((x < 93) ? 1 : ((x < 98) ? 0 : 10));\n      CBORObject cborRet = CBORObject.NewArray();\n      for (var i = 0; i < count; ++i) {\n        cborRet.Add(RandomCBORObject(rand, depth + 1));\n      }\n      return cborRet;\n    }\n\n    public static CBORObject RandomCBORObject(IRandomGenExtended rand) {\n      return RandomCBORObject(rand, 0);\n    }\n\n    public static CBORObject RandomCBORObject(IRandomGenExtended rand, int\n      depth) {\n      int nextval = rand.GetInt32(11);\n      switch (nextval) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n          return RandomNumberOrRational(rand);\n        case 4:\n          return rand.GetInt32(2) == 0 ? CBORObject.True : CBORObject.False;\n        case 5:\n          return rand.GetInt32(2) == 0 ? CBORObject.Null :\n            CBORObject.Undefined;\n        case 6:\n          return CBORObject.FromObject(\n              RandomObjects.RandomTextString(rand));\n        case 7:\n          return CBORObject.FromObject(\n              RandomObjects.RandomByteString(rand));\n        case 8:\n          return RandomCBORArray(rand, depth);\n        case 9:\n          return RandomCBORMap(rand, depth);\n        case 10:\n          return RandomCBORTaggedObject(rand, depth);\n        default: return RandomNumber(rand);\n      }\n    }\n\n#pragma warning disable CS0618\n    public static void TestNumber(CBORObject o) {\n      if (o.Type != CBORType.Number) {\n        return;\n      }\n      if (o.IsPositiveInfinity() || o.IsNegativeInfinity() ||\n        o.IsNaN()) {\n        try {\n          o.AsByte();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsInt16();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsInt32();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsInt64();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsSingle();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsDouble();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsEInteger();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        return;\n      }\n      try {\n        o.AsSingle();\n      } catch (Exception ex) {\n        Assert.Fail(\"Object: \" + o + \", \" + ex);\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        o.AsDouble();\n      } catch (Exception ex) {\n        Assert.Fail(\"Object: \" + o + \", \" + ex);\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n#pragma warning restore CS0618\n\n    public static byte[] CheckEncodeToBytes(CBORObject o) {\n      byte[] bytes = o.EncodeToBytes();\n      if (bytes.Length != o.CalcEncodedSize()) {\n        string msg = \"encoded size doesn't match:\\no = \" +\n          TestCommon.ToByteArrayString(bytes) + \"\\nostring = \" + o.ToString();\n        Assert.AreEqual(bytes.Length, o.CalcEncodedSize(), msg);\n      }\n      return bytes;\n    }\n\n    public static void AssertRoundTrip(CBORObject o) {\n      CBORObject o2 = FromBytesTestAB(CheckEncodeToBytes(o));\n      TestCommon.CompareTestEqual(o, o2);\n      TestNumber(o);\n      TestCommon.AssertEqualsHashCode(o, o2);\n    }\n\n    public static void AssertJSONSer(CBORObject o, String s) {\n      if (!s.Equals(o.ToJSONString(), StringComparison.Ordinal)) {\n        Assert.AreEqual(s, o.ToJSONString(), \"o is not equal to s\");\n      }\n      byte[] bytes = CheckEncodeToBytes(o);\n      // Test round-tripping\n      CBORObject o2 = FromBytesTestAB(bytes);\n      if (!s.Equals(o2.ToJSONString(), StringComparison.Ordinal)) {\n        string msg = \"o2 is not equal to s:\\no = \" +\n          TestCommon.ToByteArrayString(bytes) +\n          \"\\no2 = \" + TestCommon.ToByteArrayString(o2.EncodeToBytes()) +\n          \"\\no2string = \" + o2.ToString();\n        Assert.AreEqual(s, o2.ToJSONString(), msg);\n      }\n      TestNumber(o);\n      TestCommon.AssertEqualsHashCode(o, o2);\n    }\n\n    // Tests the equivalence of the DecodeFromBytes and Read methods.\n    public static CBORObject FromBytesTestAB(byte[] b, CBOREncodeOptions\noptions) {\n      CBORObject oa = FromBytesA(b, options);\n      CBORObject ob = FromBytesB(b, options);\n      if (!oa.Equals(ob)) {\n        Assert.AreEqual(oa, ob);\n      }\n      return oa;\n    }\n\n    private static CBORObject FromBytesA(byte[] b, CBOREncodeOptions options) {\n      return CBORObject.DecodeFromBytes(b, options);\n    }\n\n    private static CBORObject FromBytesB(byte[] b, CBOREncodeOptions options) {\n      using (var ms = new System.IO.MemoryStream(b)) {\n        CBORObject o = CBORObject.Read(ms, options);\n        if (ms.Position != ms.Length) {\n          throw new CBORException(\"not at EOF\");\n        }\n        return o;\n      }\n    }\n\n    // Tests the equivalence of the DecodeFromBytes and Read methods.\n    public static CBORObject FromBytesTestAB(byte[] b) {\n      CBORObject oa = FromBytesA(b);\n      CBORObject ob = FromBytesB(b);\n      if (!oa.Equals(ob)) {\n        Assert.AreEqual(oa, ob);\n      }\n      return oa;\n    }\n\n    private static CBORObject FromBytesA(byte[] b) {\n      return CBORObject.DecodeFromBytes(b);\n    }\n\n    private static CBORObject FromBytesB(byte[] b) {\n      using (var ms = new System.IO.MemoryStream(b)) {\n        CBORObject o = CBORObject.Read(ms);\n        if (ms.Position != ms.Length) {\n          throw new CBORException(\"not at EOF\");\n        }\n        return o;\n      }\n    }\n  }\n}\n", "/*\nWritten in 2013-2018 by Peter O.\nAny copyright to this work is released to the Public Domain.\nIn case this is not possible, this work is also\nlicensed under Creative Commons Zero (CC0):\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\n */\nusing System;\nusing System.Text;\nusing NUnit.Framework;\n\nnamespace Test {\n  public static class TestCommon {\n    private const string Digits = \"0123456789\";\n\n    public static int StringToInt(string str) {\n      var neg = false;\n      var i = 0;\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (str.Length > 0 && str[0] == '-') {\n        neg = true;\n        ++i;\n      }\n      if (i == str.Length) {\n        throw new FormatException();\n      }\n      var ret = 0;\n      while (i < str.Length) {\n        int c = str[i];\n        ++i;\n        if (c >= '0' && c <= '9') {\n          int x = c - '0';\n          if (ret > 214748364) {\n            throw new FormatException();\n          }\n          ret *= 10;\n          if (ret == 2147483640) {\n            if (neg && x == 8) {\n              if (i != str.Length) {\n                throw new FormatException();\n              }\n              return Int32.MinValue;\n            }\n            if (x > 7) {\n              throw new FormatException();\n            }\n          }\n          ret += x;\n        } else {\n          throw new FormatException();\n        }\n      }\n      return neg ? -ret : ret;\n    }\n\n    public static long StringToLong(string str) {\n      var neg = false;\n      var i = 0;\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (str.Length > 0 && str[0] == '-') {\n        neg = true;\n        ++i;\n      }\n      if (i == str.Length) {\n        throw new FormatException();\n      }\n      long ret = 0;\n      while (i < str.Length) {\n        int c = str[i];\n        ++i;\n        if (c >= '0' && c <= '9') {\n          int x = c - '0';\n          if ((long)ret > 922337203685477580L) {\n            throw new FormatException();\n          }\n          ret *= 10;\n          if ((long)ret == 9223372036854775800L) {\n            if (neg && x == 8) {\n              if (i != str.Length) {\n                throw new FormatException();\n              }\n              return Int64.MinValue;\n            }\n            if (x > 7) {\n              throw new FormatException();\n            }\n          }\n          ret += x;\n        } else {\n          throw new FormatException();\n        }\n      }\n      return neg ? -ret : ret;\n    }\n\n    public static void AssertByteArraysEqual(byte[] arr1, byte[] arr2) {\n      if (!ByteArraysEqual(arr1, arr2)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertByteArraysEqual(\n      byte[] arr1,\n      int offset,\n      int length,\n      byte[] arr2) {\n      if (!ByteArraysEqual(\n         arr1,\n         offset,\n         length,\n         arr2,\n         0,\n         arr2 == null ? 0 : arr2.Length)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertByteArraysEqual(\n      byte[] arr1,\n      byte[] arr2,\n      int offset2,\n      int length2) {\n      if (!ByteArraysEqual(\n        arr1,\n        0,\n        arr1 == null ? 0 : arr1.Length,\n        arr2,\n        offset2,\n        length2)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertByteArraysEqual(\n      byte[] arr1,\n      int offset,\n      int length,\n      byte[] arr2,\n      int offset2,\n      int length2) {\n      if (!ByteArraysEqual(arr1, offset, length, arr2, offset2, length2)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertNotEqual(object o, object o2, string msg) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (o.Equals(o2)) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o,\n          o2,\n          \"Unexpectedly equal\");\n        Assert.Fail(str);\n      }\n    }\n\n    public static void AssertEquals(object o, object o2, string msg) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (!o.Equals(o2)) {\n        Assert.AreEqual(o, o2, msg);\n      }\n    }\n\n    public static void AssertNotEqual(Object o, Object o2) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (o.Equals(o2)) {\n        string str = ObjectMessages(\n          o,\n          o2,\n          \"Unexpectedly equal\");\n        Assert.Fail(str);\n      }\n    }\n\n    public static void AssertEquals(Object o, Object o2) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (!o.Equals(o2)) {\n        Assert.AreEqual(o, o2);\n      }\n    }\n\n    public static void AssertEqualsHashCode(Object o, Object o2) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (o.Equals(o2)) {\n        if (o2 == null) {\n          throw new ArgumentNullException(nameof(o2));\n        }\n        if (!o2.Equals(o)) {\n          Assert.Fail(\n            String.Empty + o + \" equals \" + o2 + \" but not vice versa\");\n        }\n        // Test for the guarantee that equal objects\n        // must have equal hash codes\n        if (o2.GetHashCode() != o.GetHashCode()) {\n          // Don't use Assert.AreEqual directly because it has\n          // quite a lot of overhead\n          Assert.Fail(\n            String.Empty + o + \" and \" + o2 + \" don't have equal hash codes\");\n        }\n      } else {\n        if (o2 == null) {\n          throw new ArgumentNullException(nameof(o2));\n        }\n        if (o2.Equals(o)) {\n          Assert.Fail(String.Empty + o + \" does not equal \" + o2 +\n            \" but not vice versa\");\n        }\n        // At least check that GetHashCode doesn't throw\n        try {\n          o.GetHashCode();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o2.GetHashCode();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    public static void CompareTestConsistency<T>(T o1, T o2, T o3) where T :\n      IComparable<T> {\n      if (o1 == null) {\n        throw new ArgumentNullException(nameof(o1));\n      }\n      if (o2 == null) {\n        throw new ArgumentNullException(nameof(o2));\n      }\n      if (o3 == null) {\n        throw new ArgumentNullException(nameof(o3));\n      }\n      int cmp = CompareTestReciprocal(o1, o2);\n      int cmp2 = CompareTestReciprocal(o2, o3);\n      int cmp3 = CompareTestReciprocal(o1, o3);\n      Assert.AreEqual(cmp == 0, o1.Equals(o2));\n      Assert.AreEqual(cmp == 0, o2.Equals(o1));\n      Assert.AreEqual(cmp2 == 0, o2.Equals(o3));\n      Assert.AreEqual(cmp2 == 0, o3.Equals(o2));\n      Assert.AreEqual(cmp3 == 0, o1.Equals(o3));\n      Assert.AreEqual(cmp3 == 0, o3.Equals(o1));\n    }\n\n    public static void CompareTestNotEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) == 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Unexpectedly equal: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestNotEqual<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) == 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Unexpectedly equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) != 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Not equal: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestEqual<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) != 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestEqualAndConsistent<T>(T o1, T o2) where T :\n      IComparable<T> {\n      CompareTestEqualAndConsistent(o1, o2, null);\n    }\n\n    public static void CompareTestEqualAndConsistent<T>(\n      T o1,\n      T o2,\n      string msg) where T : IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) != 0) {\n        msg = (msg == null ? String.Empty : (msg + \"\\r\\n\")) +\n        \"Not equal: \" + CompareTestReciprocal(o1, o2);\n        Assert.Fail(ObjectMessages(\n          o1,\n          o2,\n          msg));\n      }\n      if (!o1.Equals(o2)) {\n        msg = (msg == null ? String.Empty : (msg + \"\\r\\n\")) +\n        \"Not equal: \" + CompareTestReciprocal(o1, o2);\n        Assert.Fail(ObjectMessages(\n          o1,\n          o2,\n          msg));\n      }\n    }\n\n    public static void CompareTestGreater<T>(T o1, T o2) where T :\n      IComparable<T> {\n      CompareTestLess(o2, o1);\n    }\n\n    public static void CompareTestLess<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) >= 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Not less: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestGreaterEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      CompareTestLessEqual(o2, o1);\n    }\n\n    public static void CompareTestLessEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) > 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Not less or equal: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestLess<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) >= 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not less: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestLessEqual<T>(T o1, T o2, string msg)\n    where T : IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) > 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not less or equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestGreater<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) <= 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not greater: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestGreaterEqual<T>(T o1, T o2, string msg) where\n    T : IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) < 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not greater or equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static int CompareTestReciprocal<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (o1 == null) {\n        throw new ArgumentNullException(nameof(o1));\n      }\n      if (o2 == null) {\n        throw new ArgumentNullException(nameof(o2));\n      }\n      int cmp, cmp2;\n      cmp = Math.Sign(o1.CompareTo(o2));\n      cmp2 = Math.Sign(o2.CompareTo(o1));\n      if (-cmp2 != cmp) {\n        Assert.AreEqual(cmp, -cmp2, ObjectMessages(o1, o2, \"Not reciprocal\"));\n      }\n      return cmp;\n    }\n\n    public static void CompareTestRelations<T>(T o1, T o2, T o3) where T :\n      IComparable<T> {\n      if (o1 == null) {\n        throw new ArgumentNullException(nameof(o1));\n      }\n      if (o2 == null) {\n        throw new ArgumentNullException(nameof(o2));\n      }\n      if (o3 == null) {\n        throw new ArgumentNullException(nameof(o3));\n      }\n      if (o1.CompareTo(o1) != 0) {\n        Assert.Fail(o1.ToString());\n      }\n      if (o2.CompareTo(o2) != 0) {\n        Assert.Fail(o2.ToString());\n      }\n      if (o3.CompareTo(o3) != 0) {\n        Assert.Fail(o3.ToString());\n      }\n      int cmp12 = CompareTestReciprocal(o1, o2);\n      int cmp23 = CompareTestReciprocal(o2, o3);\n      int cmp13 = CompareTestReciprocal(o1, o3);\n      // CompareTestReciprocal tests CompareTo both\n      // ways, so shortcutting by negating the values\n      // is allowed here\n      int cmp21 = -cmp12;\n      int cmp32 = -cmp23;\n      int cmp31 = -cmp13;\n      // Transitivity checks\n      for (int i = -1; i <= 1; ++i) {\n        if (cmp12 == i) {\n          if (cmp23 == i && cmp13 != i) {\n            Assert.Fail(ObjectMessages(o1, o2, o3, \"Not transitive\"));\n          }\n        }\n        if (cmp23 == i) {\n          if (cmp31 == i && cmp21 != i) {\n            Assert.Fail(ObjectMessages(o1, o2, o3, \"Not transitive\"));\n          }\n        }\n        if (cmp31 == i) {\n          if (cmp12 == i && cmp32 != i) {\n            Assert.Fail(ObjectMessages(o1, o2, o3, \"Not transitive\"));\n          }\n        }\n      }\n    }\n\n    public static string IntToString(int value) {\n      if (value == 0) {\n        return \"0\";\n      }\n      if (value == Int32.MinValue) {\n        return \"-2147483648\";\n      }\n      bool neg = value < 0;\n      if (neg) {\n        value = -value;\n      }\n      char[] chars;\n      int count;\n      if (value < 100000) {\n        if (neg) {\n         chars = new char[6];\n         count = 5;\n        } else {\n         chars = new char[5];\n         count = 4;\n        }\n        while (value > 9) {\n          int intdivvalue = unchecked((((value >> 1) * 52429) >> 18) & 16383);\n          char digit = Digits[(int)(value - (intdivvalue * 10))];\n          chars[count--] = digit;\n          value = intdivvalue;\n        }\n        if (value != 0) {\n          chars[count--] = Digits[(int)value];\n        }\n        if (neg) {\n          chars[count] = '-';\n        } else {\n          ++count;\n        }\n        return new String(chars, count, chars.Length - count);\n      }\n      chars = new char[12];\n      count = 11;\n      while (value >= 163840) {\n        int intdivvalue = value / 10;\n        char digit = Digits[(int)(value - (intdivvalue * 10))];\n        chars[count--] = digit;\n        value = intdivvalue;\n      }\n      while (value > 9) {\n        int intdivvalue = unchecked((((value >> 1) * 52429) >> 18) & 16383);\n        char digit = Digits[(int)(value - (intdivvalue * 10))];\n        chars[count--] = digit;\n        value = intdivvalue;\n      }\n      if (value != 0) {\n        chars[count--] = Digits[(int)value];\n      }\n      if (neg) {\n        chars[count] = '-';\n      } else {\n        ++count;\n      }\n      return new String(chars, count, 12 - count);\n    }\n\n    public static string LongToString(long longValue) {\n      if (longValue == Int64.MinValue) {\n        return \"-9223372036854775808\";\n      }\n      if (longValue == 0L) {\n        return \"0\";\n      }\n      bool neg = longValue < 0;\n      var count = 0;\n      char[] chars;\n      int intlongValue = unchecked((int)longValue);\n      if ((long)intlongValue == longValue) {\n        return IntToString(intlongValue);\n      } else {\n        chars = new char[24];\n        count = 23;\n        if (neg) {\n          longValue = -longValue;\n        }\n        while (longValue >= 163840) {\n          long divValue = longValue / 10;\n          char digit = Digits[(int)(longValue - (divValue * 10))];\n          chars[count--] = digit;\n          longValue = divValue;\n        }\n        while (longValue > 9) {\n          long divValue = unchecked((((longValue >> 1) * 52429) >> 18) & 16383);\n          char digit = Digits[(int)(longValue - (divValue * 10))];\n          chars[count--] = digit;\n          longValue = divValue;\n        }\n        if (longValue != 0) {\n          chars[count--] = Digits[(int)longValue];\n        }\n        if (neg) {\n          chars[count] = '-';\n        } else {\n          ++count;\n        }\n        return new String(chars, count, 24 - count);\n      }\n    }\n\n    public static string ObjectMessages(\n      object o1,\n      object o2,\n      String s) {\n      return s + \":\\n\" + o1 + \" and\\n\" + o2;\n    }\n\n    public static string ObjectMessages(\n      object o1,\n      object o2,\n      object o3,\n      String s) {\n      return s + \":\\n\" + o1 + \" and\\n\" + o2 + \" and\\n\" + o3;\n    }\n\n    private const int RepeatDivideThreshold = 10000;\n\n    public static string Repeat(char c, int num) {\n      if (num < 0) {\n        throw new ArgumentException(\"num (\" + num +\n           \") is not greater or equal to 0\");\n      }\n      var sb = new StringBuilder(num);\n      if (num > RepeatDivideThreshold) {\n        string sb2 = Repeat(c, RepeatDivideThreshold);\n        int count = num / RepeatDivideThreshold;\n        int rem = num % RepeatDivideThreshold;\n        for (var i = 0; i < count; ++i) {\n          sb.Append(sb2);\n        }\n        for (var i = 0; i < rem; ++i) {\n          sb.Append(c);\n        }\n      } else {\n        for (var i = 0; i < num; ++i) {\n          sb.Append(c);\n        }\n      }\n      return sb.ToString();\n    }\n\n    public static string Repeat(String str, int num) {\n      if (num < 0) {\n        throw new ArgumentException(\"num (\" + num +\n           \") is not greater or equal to 0\");\n      }\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (str.Length == 1) {\n        return Repeat(str[0], num);\n      }\n      var sb = new StringBuilder(num * str.Length);\n      for (var i = 0; i < num; ++i) {\n        sb.Append(str);\n      }\n      return sb.ToString();\n    }\n\n    public static string ToByteArrayString(byte[] bytes) {\n      return (bytes == null) ? \"null\" : ToByteArrayString(\n         bytes,\n         0,\n         bytes.Length);\n    }\n\n    public static string ToByteArrayString(\n       byte[] bytes,\n       int offset,\n       int length) {\n      if (bytes == null) {\n        return \"null\";\n      }\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (offset < 0) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not\" +\n\"\\u0020greater or equal to 0\");\n      }\n      if (offset > bytes.Length) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not less\" +\n\"\\u0020or equal to \" + bytes.Length);\n      }\n      if (length < 0) {\n        throw new ArgumentException(\" (\" + length + \") is not greater or\" +\n\"\\u0020equal to 0\");\n      }\n      if (length > bytes.Length) {\n        throw new ArgumentException(\" (\" + length + \") is not less or equal\" +\n\"\\u0020to \" + bytes.Length);\n      }\n      if (bytes.Length - offset < length) {\n        throw new ArgumentException(\"\\\"bytes\\\" + \\\"'s length minus \\\" +\" +\n\"\\u0020offset (\" + (bytes.Length - offset) + \") is not greater or equal to \" +\nlength);\n      }\n      var sb = new System.Text.StringBuilder();\n      const string ValueHex = \"0123456789ABCDEF\";\n      sb.Append(\"new byte[] { \");\n      for (var i = 0; i < length; ++i) {\n        if (i > 0) {\n          sb.Append(',');\n        }\n        if ((bytes[offset + i] & 0x80) != 0) {\n          sb.Append(\"(byte)0x\");\n        } else {\n          sb.Append(\"0x\");\n        }\n        sb.Append(ValueHex[(bytes[offset + i] >> 4) & 0xf]);\n        sb.Append(ValueHex[bytes[offset + i] & 0xf]);\n      }\n      sb.Append('}');\n      return sb.ToString();\n    }\n\n    private static bool ByteArraysEqual(\n      byte[] arr1,\n      int offset,\n      int length,\n      byte[] arr2,\n      int offset2,\n      int length2) {\n      if (arr1 == null) {\n        return arr2 == null;\n      }\n      if (arr2 == null) {\n        return false;\n      }\n      if (offset < 0) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not\" +\n\"\\u0020greater or equal to 0\");\n      }\n      if (offset > arr1.Length) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not less\" +\n\"\\u0020or equal to \" + arr1.Length);\n      }\n      if (length < 0) {\n        throw new ArgumentException(\" (\" + length + \") is not greater or\" +\n\"\\u0020equal to 0\");\n      }\n      if (length > arr1.Length) {\n        throw new ArgumentException(\" (\" + length + \") is not less or equal\" +\n\"\\u0020to \" + arr1.Length);\n      }\n      if (arr1.Length - offset < length) {\n        throw new ArgumentException(\"\\\"arr1\\\" + \\\"'s length minus \\\" +\" +\n\"\\u0020offset (\" + (arr1.Length - offset) + \") is not greater or equal to \" +\nlength);\n      }\n      if (arr2 == null) {\n        throw new ArgumentNullException(nameof(arr2));\n      }\n      if (offset2 < 0) {\n        throw new ArgumentException(\"\\\"offset2\\\" (\" + offset2 + \") is not\" +\n\"\\u0020greater or equal to 0\");\n      }\n      if (offset2 > arr2.Length) {\n        throw new ArgumentException(\"\\\"offset2\\\" (\" + offset2 + \") is not\" +\n\"\\u0020less or equal to \" + arr2.Length);\n      }\n      if (length2 < 0) {\n        throw new ArgumentException(\" (\" + length2 + \") is not greater or\" +\n\"\\u0020equal to 0\");\n      }\n      if (length2 > arr2.Length) {\n        throw new ArgumentException(\" (\" + length2 + \") is not less or equal\" +\n\"\\u0020to \" + arr2.Length);\n      }\n      if (arr2.Length - offset2 < length2) {\n        throw new ArgumentException(\"\\\"arr2\\\"'s length minus \" +\n\"\\u0020offset2 (\" + (arr2.Length - offset2) + \") is not greater or equal to \" +\nlength2);\n      }\n      if (length != length2) {\n        return false;\n      }\n      for (var i = 0; i < length; ++i) {\n        if (arr1[offset + i] != arr2[offset2 + i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static bool ByteArraysEqual(byte[] arr1, byte[] arr2) {\n      if (arr1 == null) {\n        return arr2 == null;\n      }\n      if (arr2 == null) {\n        return false;\n      }\n      if (arr1.Length != arr2.Length) {\n        return false;\n      }\n      for (var i = 0; i < arr1.Length; ++i) {\n        if (arr1[i] != arr2[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n"], "fixing_code": ["/*\nWritten by Peter O.\nAny copyright to this work is released to the Public Domain.\nIn case this is not possible, this work is also\nlicensed under Creative Commons Zero (CC0):\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\n */\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing PeterO;\nusing PeterO.Numbers;\n\n// TODO: In next major version, make .Keys and .Values read-only\n// TODO: Add ReadObject that combines Read and ToObject; similarly\n// for ReadJSON, FromJSONString, FromJSONBytes\n// TODO: In Java version add overloads for Class<T> in overloads\n// that take java.lang.reflect.Type\nnamespace PeterO.Cbor {\n  /// <summary>\n  /// <para>Represents an object in Concise Binary Object Representation\n  /// (CBOR) and contains methods for reading and writing CBOR data. CBOR\n  /// is an Internet Standard and defined in RFC 8949.</para></summary>\n  /// <remarks>\n  /// <para><b>Converting CBOR objects</b></para>\n  /// <para>There are many ways to get a CBOR object, including from\n  /// bytes, objects, streams and JSON, as described below.</para>\n  /// <para><b>To and from byte arrays:</b> The\n  /// CBORObject.DecodeFromBytes method converts a byte array in CBOR\n  /// format to a CBOR object. The EncodeToBytes method converts a CBOR\n  /// object to its corresponding byte array in CBOR format.</para>\n  /// <para><b>To and from data streams:</b> The CBORObject.Write methods\n  /// write many kinds of objects to a data stream, including numbers,\n  /// CBOR objects, strings, and arrays of numbers and strings. The\n  /// CBORObject.Read method reads a CBOR object from a data\n  /// stream.</para>\n  /// <para><b>To and from other objects:</b> The\n  /// <c>CBORObject.FromObject</c> method converts many kinds of objects\n  /// to a CBOR object, including numbers, strings, and arrays and maps\n  /// of numbers and strings. Methods like AsNumber and AsString convert\n  /// a CBOR object to different types of object. The\n  /// <c>CBORObject.ToObject</c> method converts a CBOR object to an\n  /// object of a given type; for example, a CBOR array to a native\n  /// <c>List</c> (or <c>ArrayList</c> in Java), or a CBOR integer to an\n  /// <c>int</c> or <c>long</c>.</para>\n  /// <para><b>To and from JSON:</b> This class also doubles as a reader\n  /// and writer of JavaScript Object Notation (JSON). The\n  /// CBORObject.FromJSONString method converts JSON in text string form\n  /// to a CBOR object, and the ToJSONString method converts a CBOR\n  /// object to a JSON string. (Note that the conversion from CBOR to\n  /// JSON is not always without loss and may make it impossible to\n  /// recover the original object when converting the JSON back to CBOR.\n  /// See the ToJSONString documentation.) Likewise, ToJSONBytes and\n  /// FromJSONBytes work with JSON in the form of byte arrays rather than\n  /// text strings.</para>\n  /// <para>In addition, the CBORObject.WriteJSON method writes many\n  /// kinds of objects as JSON to a data stream, including numbers, CBOR\n  /// objects, strings, and arrays of numbers and strings. The\n  /// CBORObject.Read method reads a CBOR object from a JSON data\n  /// stream.</para>\n  /// <para><b>Comparison Considerations:</b></para>\n  /// <para>Instances of CBORObject should not be compared for equality\n  /// using the \"==\" operator; it's possible to create two CBOR objects\n  /// with the same value but not the same reference. (The \"==\" operator\n  /// might only check if each side of the operator is the same\n  /// instance.)</para>\n  /// <para>This class's natural ordering (under the CompareTo method) is\n  /// consistent with the Equals method, meaning that two values that\n  /// compare as equal under the CompareTo method are also equal under\n  /// the Equals method; this is a change in version 4.0. Two otherwise\n  /// equal objects with different tags are not treated as equal by both\n  /// CompareTo and Equals. To strip the tags from a CBOR object before\n  /// comparing, use the <c>Untag</c> method.</para>\n  /// <para><b>Thread Safety:</b></para>\n  /// <para>Certain CBOR objects are immutable (their values can't be\n  /// changed), so they are inherently safe for use by multiple\n  /// threads.</para>\n  /// <para>CBOR objects that are arrays, maps, and byte strings (whether\n  /// or not they are tagged) are mutable, but this class doesn't attempt\n  /// to synchronize reads and writes to those objects by multiple\n  /// threads, so those objects are not thread safe without such\n  /// synchronization.</para>\n  /// <para>One kind of CBOR object is called a map, or a list of\n  /// key-value pairs. Keys can be any kind of CBOR object, including\n  /// numbers, strings, arrays, and maps. However, untagged text strings\n  /// (which means GetTags returns an empty array and the Type property,\n  /// or \"getType()\" in Java, returns TextString) are the most suitable\n  /// to use as keys; other kinds of CBOR object are much better used as\n  /// map values instead, keeping in mind that some of them are not\n  /// thread safe without synchronizing reads and writes to them.</para>\n  /// <para>To find the type of a CBOR object, call its Type property (or\n  /// \"getType()\" in Java). The return value can be Integer,\n  /// FloatingPoint, Boolean, SimpleValue, or TextString for immutable\n  /// CBOR objects, and Array, Map, or ByteString for mutable CBOR\n  /// objects.</para>\n  /// <para><b>Nesting Depth:</b></para>\n  /// <para>The DecodeFromBytes and Read methods can only read objects\n  /// with a limited maximum depth of arrays and maps nested within other\n  /// arrays and maps. The code sets this maximum depth to 500 (allowing\n  /// more than enough nesting for most purposes), but it's possible that\n  /// stack overflows in some runtimes might lower the effective maximum\n  /// nesting depth. When the nesting depth goes above 500, the\n  /// DecodeFromBytes and Read methods throw a CBORException.</para>\n  /// <para>The ReadJSON and FromJSONString methods currently have\n  /// nesting depths of 1000.</para></remarks>\n  [System.Diagnostics.CodeAnalysis.SuppressMessage(\n      \"Microsoft.Design\",\n      \"CA1036\",\n      Justification = \"Mutable in some cases, and arbitrary size.\")]\n  public sealed partial class CBORObject : IComparable<CBORObject>,\n    IEquatable<CBORObject> {\n    private static CBORObject ConstructSimpleValue(int v) {\n      return new CBORObject(CBORObjectTypeSimpleValue, v);\n    }\n\n    private static CBORObject ConstructIntegerValue(int v) {\n      return new CBORObject(CBORObjectTypeInteger, (long)v);\n    }\n\n    /// <summary>Represents the value false.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject False =\n      CBORObject.ConstructSimpleValue(20);\n\n    /// <summary>A not-a-number value.</summary>\n    public static readonly CBORObject NaN = CBORObject.FromObject(Double.NaN);\n\n    /// <summary>The value negative infinity.</summary>\n    public static readonly CBORObject NegativeInfinity =\n      CBORObject.FromObject(Double.NegativeInfinity);\n\n    /// <summary>Represents the value null.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject Null =\n      CBORObject.ConstructSimpleValue(22);\n\n    /// <summary>The value positive infinity.</summary>\n    public static readonly CBORObject PositiveInfinity =\n      CBORObject.FromObject(Double.PositiveInfinity);\n\n    /// <summary>Represents the value true.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject True =\n      CBORObject.ConstructSimpleValue(21);\n\n    /// <summary>Represents the value undefined.</summary>\n    #if CODE_ANALYSIS\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Security\",\n        \"CA2104\",\n        Justification = \"This CBORObject is immutable\")]\n    #endif\n    public static readonly CBORObject Undefined =\n      CBORObject.ConstructSimpleValue(23);\n\n    /// <summary>Gets a CBOR object for the number zero.</summary>\n    public static readonly CBORObject Zero =\n      CBORObject.ConstructIntegerValue(0);\n\n    private const int CBORObjectTypeInteger = 0; // -(2^63).. (2^63-1)\n    private const int CBORObjectTypeEInteger = 1; // all other integers\n    private const int CBORObjectTypeByteString = 2;\n    private const int CBORObjectTypeTextString = 3;\n    private const int CBORObjectTypeArray = 4;\n    private const int CBORObjectTypeMap = 5;\n    private const int CBORObjectTypeTagged = 6;\n    private const int CBORObjectTypeSimpleValue = 7;\n    private const int CBORObjectTypeDouble = 8;\n    private const int CBORObjectTypeTextStringUtf8 = 9;\n    private const int CBORObjectTypeTextStringAscii = 10;\n\n    private const int StreamedStringBufferLength = 4096;\n\n    private static readonly EInteger UInt64MaxValue =\n      (EInteger.One << 64) - EInteger.One;\n\n    private static readonly EInteger[] ValueEmptyTags = new EInteger[0];\n    // Expected lengths for each head byte.\n    // 0 means length varies. -1 means invalid.\n    private static readonly int[] ValueExpectedLengths = {\n      1, 1, 1, 1, 1, 1,\n      1, 1, 1,\n      1, 1, 1, 1, 1, 1, 1, // major type 0\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 9, -1, -1, -1, -1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // major type 1\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 9, -1, -1, -1, -1,\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, // major type 2\n      17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, -1, -1, -1, 0,\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, // major type 3\n      17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, -1, -1, -1, 0,\n      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // major type 4\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0,\n      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // major type 5\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // major type 6\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1,\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // major type 7\n      1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5, 9, -1, -1, -1, -1,\n    };\n\n    private static readonly byte[] ValueFalseBytes = {\n      0x66, 0x61, 0x6c,\n      0x73, 0x65,\n    };\n\n    private static readonly byte[] ValueNullBytes = { 0x6e, 0x75, 0x6c, 0x6c };\n\n    private static readonly byte[] ValueTrueBytes = { 0x74, 0x72, 0x75, 0x65 };\n\n    private static readonly CBORObject[] FixedObjects =\n      InitializeFixedObjects();\n\n    private readonly int itemtypeValue;\n    private readonly object itemValue;\n    private readonly int tagHigh;\n    private readonly int tagLow;\n\n    internal CBORObject(CBORObject obj, int tagLow, int tagHigh) {\n      this.itemtypeValue = CBORObjectTypeTagged;\n      this.itemValue = obj;\n      this.tagLow = tagLow;\n      this.tagHigh = tagHigh;\n    }\n\n    internal CBORObject(int type, object item) {\n      #if DEBUG\n      if (type == CBORObjectTypeDouble) {\n        if (!(item is long)) {\n          throw new ArgumentException(\"expected long for item type\");\n        }\n      }\n      // Check range in debug mode to ensure that Integer and EInteger\n      // are unambiguous\n      if ((type == CBORObjectTypeEInteger) &&\n        ((EInteger)item).CanFitInInt64()) {\n        throw new ArgumentException(\"arbitrary-precision integer is within\" +\n          \"\\u0020range for Integer\");\n      }\n      if ((type == CBORObjectTypeEInteger) &&\n        ((EInteger)item).GetSignedBitLengthAsInt64() > 64) {\n        throw new ArgumentException(\"arbitrary-precision integer does not \" +\n          \"fit major type 0 or 1\");\n      }\n      if (type == CBORObjectTypeArray && !(item is IList<CBORObject>)) {\n        throw new InvalidOperationException();\n      }\n      #endif\n      this.itemtypeValue = type;\n      this.itemValue = item;\n      this.tagLow = 0;\n      this.tagHigh = 0;\n    }\n\n    /// <summary>Gets the number of keys in this map, or the number of\n    /// items in this array, or 0 if this item is neither an array nor a\n    /// map.</summary>\n    /// <value>The number of keys in this map, or the number of items in\n    /// this array, or 0 if this item is neither an array nor a\n    /// map.</value>\n    public int Count {\n      get {\n        return (this.Type == CBORType.Array) ? this.AsList().Count :\n          ((this.Type == CBORType.Map) ? this.AsMap().Count : 0);\n      }\n    }\n\n    /// <summary>Gets the last defined tag for this CBOR data item, or -1\n    /// if the item is untagged.</summary>\n    /// <value>The last defined tag for this CBOR data item, or -1 if the\n    /// item is untagged.</value>\n    public EInteger MostInnerTag {\n      get {\n        if (!this.IsTagged) {\n          return EInteger.FromInt32(-1);\n        }\n        CBORObject previtem = this;\n        var curitem = (CBORObject)this.itemValue;\n        while (curitem.IsTagged) {\n          previtem = curitem;\n          curitem = (CBORObject)curitem.itemValue;\n        }\n        if (previtem.tagHigh == 0 && previtem.tagLow >= 0 &&\n          previtem.tagLow < 0x10000) {\n          return (EInteger)previtem.tagLow;\n        }\n        return LowHighToEInteger(\n            previtem.tagLow,\n            previtem.tagHigh);\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this value is a CBOR false\n    /// value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR false value; otherwise,\n    /// <c>false</c>.</value>\n    public bool IsFalse {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 20;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents a finite number.</summary>\n    /// <value><c>true</c> if this CBOR object represents a finite number;\n    /// otherwise, <c>false</c>.</value>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsFinite()).\")]\n    public bool IsFinite {\n      get {\n        if (this.IsNumber) {\n          CBORNumber cn = this.AsNumber();\n          return !cn.IsInfinity() && !cn.IsNaN();\n        } else {\n          return false;\n        }\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this object represents an\n    /// integer number, that is, a number without a fractional part.\n    /// Infinity and not-a-number are not considered integers.</summary>\n    /// <value><c>true</c> if this object represents an integer number,\n    /// that is, a number without a fractional part; otherwise,\n    /// <c>false</c>.</value>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsInteger()).\")]\n    public bool IsIntegral {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        return (cn != null) &&\n          cn.GetNumberInterface().IsIntegral(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object is a CBOR\n    /// null value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR null value; otherwise,\n    /// <c>false</c>.</value>\n    public bool IsNull {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 22;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this data item has at\n    /// least one tag.</summary>\n    /// <value><c>true</c> if this data item has at least one tag;\n    /// otherwise, <c>false</c>.</value>\n    public bool IsTagged {\n      get {\n        return this.itemtypeValue == CBORObjectTypeTagged;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this value is a CBOR true\n    /// value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR true value; otherwise,\n    /// <c>false</c>.</value>\n    public bool IsTrue {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 21;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this value is a CBOR\n    /// undefined value, whether tagged or not.</summary>\n    /// <value><c>true</c> if this value is a CBOR undefined value;\n    /// otherwise, <c>false</c>.</value>\n    public bool IsUndefined {\n      get {\n        return this.ItemType == CBORObjectTypeSimpleValue && (int)this.ThisItem\n          == 23;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this object's value equals\n    /// 0.</summary>\n    /// <value><c>true</c> if this object's value equals 0; otherwise,\n    /// <c>false</c>.</value>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsZero()).\")]\n    public bool IsZero {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        return cn != null &&\n          cn.GetNumberInterface().IsNumberZero(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets a collection of the keys of this CBOR object. In\n    /// general, the order in which those keys occur is undefined unless\n    /// this is a map created using the NewOrderedMap method.</summary>\n    /// <value>A collection of the keys of this CBOR object. To avoid\n    /// potential problems, the calling code should not modify the CBOR map\n    /// or the returned collection while iterating over the returned\n    /// collection.</value>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    public ICollection<CBORObject> Keys {\n      get {\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n          return dict.Keys;\n        }\n        throw new InvalidOperationException(\"Not a map\");\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this object is a negative\n    /// number.</summary>\n    /// <value><c>true</c> if this object is a negative number; otherwise,\n    /// <c>false</c>.</value>\n    [Obsolete(\"Instead, use \\u0028cbor.IsNumber() &&\" +\n        \"\\u0020cbor.AsNumber().IsNegative()).\")]\n    public bool IsNegative {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        return (cn != null) &&\n          cn.GetNumberInterface().IsNegative(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets the outermost tag for this CBOR data item, or -1 if\n    /// the item is untagged.</summary>\n    /// <value>The outermost tag for this CBOR data item, or -1 if the item\n    /// is untagged.</value>\n    public EInteger MostOuterTag {\n      get {\n        if (!this.IsTagged) {\n          return EInteger.FromInt32(-1);\n        }\n        if (this.tagHigh == 0 &&\n          this.tagLow >= 0 && this.tagLow < 0x10000) {\n          return (EInteger)this.tagLow;\n        }\n        return LowHighToEInteger(\n            this.tagLow,\n            this.tagHigh);\n      }\n    }\n\n    /// <summary>Gets this value's sign: -1 if negative; 1 if positive; 0\n    /// if zero. Throws an exception if this is a not-a-number\n    /// value.</summary>\n    /// <value>This value's sign: -1 if negative; 1 if positive; 0 if\n    /// zero.</value>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number, or this object is a not-a-number (NaN)\n    /// value.</exception>\n    [Obsolete(\"Instead, convert this object to a number with .AsNumber(),\" +\n        \"\\u0020 and use the Sign property in .NET or the signum method in\" +\n        \"\\u0020Java.\" +\n        \" Either will treat not-a-number (NaN) values differently than here.\")]\n    public int Sign {\n      get {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null || cn.IsNaN()) {\n          throw new InvalidOperationException(\n            \"This object is not a number.\");\n        }\n        return cn.GetNumberInterface().Sign(cn.GetValue());\n      }\n    }\n\n    /// <summary>Gets the simple value ID of this CBOR object, or -1 if the\n    /// object is not a simple value. In this method, objects with a CBOR\n    /// type of Boolean or SimpleValue are simple values, whether they are\n    /// tagged or not.</summary>\n    /// <value>The simple value ID of this object if it's a simple value,\n    /// or -1 if this object is not a simple value.</value>\n    public int SimpleValue {\n      get {\n        return (this.ItemType == CBORObjectTypeSimpleValue) ?\n          ((int)this.ThisItem) : -1;\n      }\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object stores a\n    /// number (including infinity or a not-a-number or NaN value).\n    /// Currently, this is true if this item is untagged and has a CBORType\n    /// of Integer or FloatingPoint, or if this item has only one tag and\n    /// that tag is 2, 3, 4, 5, 30, 264, 265, 268, 269, or 270 with the\n    /// right data type.</summary>\n    /// <value>A value indicating whether this CBOR object stores a\n    /// number.</value>\n    public bool IsNumber {\n      get {\n        return CBORNumber.IsNumber(this);\n      }\n    }\n\n    /// <summary>Gets the general data type of this CBOR object. This\n    /// method disregards the tags this object has, if any.</summary>\n    /// <value>The general data type of this CBOR object.</value>\n    public CBORType Type {\n      get {\n        switch (this.ItemType) {\n          case CBORObjectTypeInteger:\n          case CBORObjectTypeEInteger:\n            return CBORType.Integer;\n          case CBORObjectTypeDouble:\n            return CBORType.FloatingPoint;\n          case CBORObjectTypeSimpleValue:\n            return ((int)this.ThisItem == 21 || (int)this.ThisItem == 20) ?\n              CBORType.Boolean : CBORType.SimpleValue;\n          case CBORObjectTypeArray:\n            return CBORType.Array;\n          case CBORObjectTypeMap:\n            return CBORType.Map;\n          case CBORObjectTypeByteString:\n            return CBORType.ByteString;\n          case CBORObjectTypeTextString:\n          case CBORObjectTypeTextStringUtf8:\n          case CBORObjectTypeTextStringAscii:\n            return CBORType.TextString;\n          default: throw new InvalidOperationException(\"Unexpected data type\");\n        }\n      }\n    }\n\n    /// <summary>Gets a collection of the key/value pairs stored in this\n    /// CBOR object, if it's a map. Returns one entry for each key/value\n    /// pair in the map. In general, the order in which those entries occur\n    /// is undefined unless this is a map created using the NewOrderedMap\n    /// method.</summary>\n    /// <value>A collection of the key/value pairs stored in this CBOR map,\n    /// as a read-only view of those pairs. To avoid potential problems,\n    /// the calling code should not modify the CBOR map while iterating\n    /// over the returned collection.</value>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    public ICollection<KeyValuePair<CBORObject, CBORObject>> Entries {\n      get {\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n          return PropertyMap.GetEntries(dict);\n        }\n        throw new InvalidOperationException(\"Not a map\");\n      }\n    }\n\n    /// <summary>Gets a collection of the values of this CBOR object, if\n    /// it's a map or an array. If this object is a map, returns one value\n    /// for each key in the map; in general, the order in which those keys\n    /// occur is undefined unless this is a map created using the\n    /// NewOrderedMap method. If this is an array, returns all the values\n    /// of the array in the order they are listed. (This method can't be\n    /// used to get the bytes in a CBOR byte string; for that, use the\n    /// GetByteString method instead.).</summary>\n    /// <value>A collection of the values of this CBOR map or array. To\n    /// avoid potential problems, the calling code should not modify the\n    /// CBOR map or array or the returned collection while iterating over\n    /// the returned collection.</value>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map or an array.</exception>\n    public ICollection<CBORObject> Values {\n      get {\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n          return dict.Values;\n        }\n        if (this.Type == CBORType.Array) {\n          IList<CBORObject> list = this.AsList();\n          return new\n            System.Collections.ObjectModel.ReadOnlyCollection<CBORObject>(\n              list);\n        }\n        throw new InvalidOperationException(\"Not a map or array\");\n      }\n    }\n\n    private int ItemType {\n      get {\n        CBORObject curobject = this;\n        while (curobject.itemtypeValue == CBORObjectTypeTagged) {\n          curobject = (CBORObject)curobject.itemValue;\n        }\n        return curobject.itemtypeValue;\n      }\n    }\n\n    private object ThisItem {\n      get {\n        CBORObject curobject = this;\n        while (curobject.itemtypeValue == CBORObjectTypeTagged) {\n          curobject = (CBORObject)curobject.itemValue;\n        }\n        return curobject.itemValue;\n      }\n    }\n\n    /// <summary>Gets the value of a CBOR object by integer index in this\n    /// array or by integer key in this map.</summary>\n    /// <param name='index'>Index starting at 0 of the element, or the\n    /// integer key to this map. (If this is a map, the given index can be\n    /// any 32-bit signed integer, even a negative one.).</param>\n    /// <returns>The CBOR object referred to by index or key in this array\n    /// or map. If this is a CBOR map, returns <c>null</c> (not\n    /// <c>CBORObject.Null</c> ) if an item with the given key doesn't\n    /// exist (but this behavior may change to throwing an exception in\n    /// version 5.0 or later).</returns>\n    /// <exception cref='InvalidOperationException'>This object is not an\n    /// array or map.</exception>\n    /// <exception cref='ArgumentException'>This object is an array and the\n    /// index is less than 0 or at least the size of the array.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter \"value\" is\n    /// null (as opposed to CBORObject.Null).</exception>\n    public CBORObject this[int index] {\n      get {\n        if (this.Type == CBORType.Array) {\n          IList<CBORObject> list = this.AsList();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(index));\n          }\n          return list[index];\n        }\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          CBORObject key = CBORObject.FromObject(index);\n          // TODO: In next major version, consider throwing an exception\n          // instead if key does not exist.\n          return (!map.ContainsKey(key)) ? null : map[key];\n        }\n        throw new InvalidOperationException(\"Not an array or map\");\n      }\n\n      set {\n        if (this.Type == CBORType.Array) {\n          if (value == null) {\n            throw new ArgumentNullException(nameof(value));\n          }\n          IList<CBORObject> list = this.AsList();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(index));\n          }\n          list[index] = value;\n        } else if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          CBORObject key = CBORObject.FromObject(index);\n          map[key] = value;\n        } else {\n          throw new InvalidOperationException(\"Not an array or map\");\n        }\n      }\n    }\n\n    /// <summary>Gets the value of a CBOR object by integer index in this\n    /// array or by CBOR object key in this map, or a default value if that\n    /// value is not found.</summary>\n    /// <param name='key'>An arbitrary object. If this is a CBOR map, this\n    /// parameter is converted to a CBOR object serving as the key to the\n    /// map or index to the array, and can be null. If this is a CBOR\n    /// array, the key must be an integer 0 or greater and less than the\n    /// size of the array, and may be any object convertible to a CBOR\n    /// integer.</param>\n    /// <param name='defaultValue'>A value to return if an item with the\n    /// given key doesn't exist, or if the CBOR object is an array and the\n    /// key is not an integer 0 or greater and less than the size of the\n    /// array.</param>\n    /// <returns>The CBOR object referred to by index or key in this array\n    /// or map. If this is a CBOR map, returns <c>null</c> (not\n    /// <c>CBORObject.Null</c> ) if an item with the given key doesn't\n    /// exist.</returns>\n    public CBORObject GetOrDefault(object key, CBORObject defaultValue) {\n      if (this.Type == CBORType.Array) {\n        var index = 0;\n        if (key is int) {\n          index = (int)key;\n        } else {\n          CBORObject cborkey = CBORObject.FromObject(key);\n          if (!cborkey.IsNumber || !cborkey.AsNumber().CanFitInInt32()) {\n            return defaultValue;\n          }\n          index = cborkey.AsNumber().ToInt32Checked();\n        }\n        IList<CBORObject> list = this.AsList();\n        return (index < 0 || index >= list.Count) ? defaultValue :\n          list[index];\n      }\n      if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        CBORObject ckey = CBORObject.FromObject(key);\n        return PropertyMap.GetOrDefault(map, ckey, defaultValue);\n      }\n      return defaultValue;\n    }\n\n    /// <summary>Gets the value of a CBOR object by integer index in this\n    /// array or by CBOR object key in this map.</summary>\n    /// <param name='key'>A CBOR object serving as the key to the map or\n    /// index to the array. If this is a CBOR array, the key must be an\n    /// integer 0 or greater and less than the size of the array.</param>\n    /// <returns>The CBOR object referred to by index or key in this array\n    /// or map. If this is a CBOR map, returns <c>null</c> (not\n    /// <c>CBORObject.Null</c> ) if an item with the given key doesn't\n    /// exist.</returns>\n    /// <exception cref='ArgumentNullException'>The key is null (as opposed\n    /// to CBORObject.Null); or the set method is called and the value is\n    /// null.</exception>\n    /// <exception cref='ArgumentException'>This CBOR object is an array\n    /// and the key is not an integer 0 or greater and less than the size\n    /// of the array.</exception>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map or an array.</exception>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\n        \"Microsoft.Design\",\n        \"CA1043\",\n        Justification = \"Represents a logical data store\")]\n    public CBORObject this[CBORObject key] {\n      get {\n        /* \"The CBORObject class represents a logical data store.\" +\n        \" Also, an Object indexer is not included here because it's unusual\n        for \" +\n        \"CBOR map keys to be anything other than text strings or integers; \" +\n        \"including an Object indexer would introduce the security issues\n        present in the FromObject method because of the need to convert to\n        CBORObject;\" +\n        \" and this CBORObject indexer is included here because any CBOR\n        object \" +\n        \"can serve as a map key, not just integers or text strings.\" */\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          return (!map.ContainsKey(key)) ? null : map[key];\n        }\n        if (this.Type == CBORType.Array) {\n          if (!key.IsNumber || !key.AsNumber().IsInteger()) {\n            throw new ArgumentException(\"Not an integer\");\n          }\n          if (!key.AsNumber().CanFitInInt32()) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          IList<CBORObject> list = this.AsList();\n          int index = key.AsNumber().ToInt32Checked();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          return list[index];\n        }\n        throw new InvalidOperationException(\"Not an array or map\");\n      }\n\n      set {\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        if (value == null) {\n          throw new ArgumentNullException(nameof(value));\n        }\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          map[key] = value;\n          return;\n        }\n        if (this.Type == CBORType.Array) {\n          if (!key.IsNumber || !key.AsNumber().IsInteger()) {\n            throw new ArgumentException(\"Not an integer\");\n          }\n          if (!key.AsNumber().CanFitInInt32()) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          IList<CBORObject> list = this.AsList();\n          int index = key.AsNumber().ToInt32Checked();\n          if (index < 0 || index >= list.Count) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          list[index] = value;\n          return;\n        }\n        throw new InvalidOperationException(\"Not an array or map\");\n      }\n    }\n\n    /// <summary>Gets the value of a CBOR object in this map, using a\n    /// string as the key.</summary>\n    /// <param name='key'>A key that points to the desired value.</param>\n    /// <returns>The CBOR object referred to by key in this map. Returns\n    /// <c>null</c> if an item with the given key doesn't exist.</returns>\n    /// <exception cref='ArgumentNullException'>The key is\n    /// null.</exception>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    public CBORObject this[string key] {\n      get {\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        CBORObject objkey = CBORObject.FromObject(key);\n        return this[objkey];\n      }\n\n      set {\n        if (key == null) {\n          throw new ArgumentNullException(nameof(key));\n        }\n        if (value == null) {\n          throw new ArgumentNullException(nameof(value));\n        }\n        CBORObject objkey = CBORObject.FromObject(key);\n        if (this.Type == CBORType.Map) {\n          IDictionary<CBORObject, CBORObject> map = this.AsMap();\n          map[objkey] = value;\n        } else {\n          throw new InvalidOperationException(\"Not a map\");\n        }\n      }\n    }\n\n    /// <summary>Finds the sum of two CBOR numbers.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentException'>Either or both operands are not\n    /// numbers (as opposed to Not-a-Number, NaN).</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n\n        \"\\u0020.AsNumber()), and use the first number's .Add() method.\")]\n    public static CBORObject Addition(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber numberA = CBORNumber.FromCBORObject(first);\n      if (numberA == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return numberA.Add(b).ToCBORObject();\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from an array of CBOR-encoded\n    /// bytes.</para></summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <returns>A CBOR object decoded from the given byte array.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is\n    /// empty.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null.</exception>\n    public static CBORObject DecodeFromBytes(byte[] data) {\n      return DecodeFromBytes(data, CBOREncodeOptions.Default);\n    }\n\n    private static readonly CBOREncodeOptions AllowEmptyOptions =\n      new CBOREncodeOptions(\"allowempty=1\");\n\n    /// <summary>\n    /// <para>Generates a sequence of CBOR objects from an array of\n    /// CBOR-encoded bytes.</para></summary>\n    /// <param name='data'>A byte array in which any number of CBOR objects\n    /// (including zero) are encoded, one after the other. Can be empty,\n    /// but cannot be null.</param>\n    /// <returns>An array of CBOR objects decoded from the given byte\n    /// array. Returns an empty array if <paramref name='data'/> is\n    /// empty.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where the last\n    /// CBOR object in the data was read only partly.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null.</exception>\n    public static CBORObject[] DecodeSequenceFromBytes(byte[] data) {\n      return DecodeSequenceFromBytes(data, AllowEmptyOptions);\n    }\n\n    /// <summary>\n    /// <para>Generates a sequence of CBOR objects from an array of\n    /// CBOR-encoded bytes.</para></summary>\n    /// <param name='data'>A byte array in which any number of CBOR objects\n    /// (including zero) are encoded, one after the other. Can be empty,\n    /// but cannot be null.</param>\n    /// <param name='options'>Specifies options to control how the CBOR\n    /// object is decoded. See\n    /// <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more information.\n    /// In this method, the AllowEmpty property is treated as always set\n    /// regardless of that value as specified in this parameter.</param>\n    /// <returns>An array of CBOR objects decoded from the given byte\n    /// array. Returns an empty array if <paramref name='data'/> is\n    /// empty.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where the last\n    /// CBOR object in the data was read only partly.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='options'/>\n    /// is null.</exception>\n    public static CBORObject[] DecodeSequenceFromBytes(byte[] data,\n      CBOREncodeOptions options) {\n      if (data == null) {\n        throw new ArgumentNullException(nameof(data));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (data.Length == 0) {\n        return new CBORObject[0];\n      }\n      CBOREncodeOptions opt = options;\n      if (!opt.AllowEmpty) {\n        opt = new CBOREncodeOptions(opt.ToString() + \";allowempty=1\");\n      }\n      var cborList = new List<CBORObject>();\n      using (var ms = new MemoryStream(data)) {\n        while (true) {\n          CBORObject obj = Read(ms, opt);\n          if (obj == null) {\n            break;\n          }\n          cborList.Add(obj);\n        }\n      }\n      return (CBORObject[])cborList.ToArray();\n    }\n\n    /// <summary>Generates a list of CBOR objects from an array of bytes in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464).\n    /// The byte array must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='bytes'>A byte array in which a JSON text sequence is\n    /// encoded.</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array is not\n    /// empty and does not begin with a record separator byte (0x1e), or an\n    /// I/O error occurred.</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] FromJSONSequenceBytes(byte[] bytes) {\n      return FromJSONSequenceBytes(bytes, JSONOptions.Default);\n    }\n\n    /// <summary>Converts this object to a byte array in JavaScript Object\n    /// Notation (JSON) format. The JSON text will be written out in UTF-8\n    /// encoding, without a byte order mark, to the byte array. See the\n    /// overload to ToJSONString taking a JSONOptions argument for further\n    /// information.</summary>\n    /// <returns>A byte array containing the converted in JSON\n    /// format.</returns>\n    public byte[] ToJSONBytes() {\n      return this.ToJSONBytes(JSONOptions.Default);\n    }\n\n    /// <summary>Converts this object to a byte array in JavaScript Object\n    /// Notation (JSON) format. The JSON text will be written out in UTF-8\n    /// encoding, without a byte order mark, to the byte array. See the\n    /// overload to ToJSONString taking a JSONOptions argument for further\n    /// information.</summary>\n    /// <param name='jsonoptions'>Specifies options to control writing the\n    /// CBOR object to JSON.</param>\n    /// <returns>A byte array containing the converted object in JSON\n    /// format.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='jsonoptions'/> is null.</exception>\n    public byte[] ToJSONBytes(JSONOptions jsonoptions) {\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      try {\n        using (var ms = new MemoryStream()) {\n          this.WriteJSONTo(ms);\n          return ms.ToArray();\n        }\n      } catch (IOException ex) {\n        throw new CBORException(ex.Message, ex);\n      }\n    }\n\n    /// <summary>Generates a list of CBOR objects from an array of bytes in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464),\n    /// using the specified options to control the decoding process. The\n    /// byte array must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='data'>A byte array in which a JSON text sequence is\n    /// encoded.</param>\n    /// <param name='options'>Specifies options to control the JSON\n    /// decoding process.</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array is not\n    /// empty and does not begin with a record separator byte (0x1e), or an\n    /// I/O error occurred.</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] FromJSONSequenceBytes(byte[] data,\n      JSONOptions options) {\n      if (data == null) {\n        throw new ArgumentNullException(nameof(data));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      try {\n        using (var ms = new MemoryStream(data)) {\n          return ReadJSONSequence(ms, options);\n        }\n      } catch (IOException ex) {\n        throw new CBORException(ex.Message, ex);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an array of CBOR-encoded\n    /// bytes, using the given <c>CBOREncodeOptions</c>\n    ///  object to control\n    /// the decoding process.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='options'>Specifies options to control how the CBOR\n    /// object is decoded. See <see cref='PeterO.Cbor.CBOREncodeOptions'/>\n    /// for more information.</param>\n    /// <returns>A CBOR object decoded from the given byte array. Returns\n    /// null (as opposed to CBORObject.Null) if <paramref name='data'/> is\n    /// empty and the AllowEmpty property is set on the given options\n    /// object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='options'/>\n    /// is null.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) implements a method that decodes a text string from a CBOR\n    /// byte array. It's successful only if the CBOR object contains an\n    /// untagged text string.</para>\n    /// <code>private static String DecodeTextString(byte[] bytes) { if (bytes ==\n    /// null) { throw new ArgumentNullException(nameof(mapObj));}\n    /// if\n    /// (bytes.Length == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f) {throw new\n    /// CBORException();} return CBORObject.DecodeFromBytes(bytes,\n    /// CBOREncodeOptions.Default).AsString(); }</code>\n    ///  .\n    /// </example>\n    public static CBORObject DecodeFromBytes(\n      byte[] data,\n      CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (data == null) {\n        throw new ArgumentNullException(nameof(data));\n      }\n      if (data.Length == 0) {\n        if (options.AllowEmpty) {\n          return null;\n        }\n        throw new CBORException(\"data is empty.\");\n      }\n      var firstbyte = (int)(data[0] & (int)0xff);\n      int expectedLength = ValueExpectedLengths[firstbyte];\n      // if invalid\n      if (expectedLength == -1) {\n        throw new CBORException(\"Unexpected data encountered\");\n      }\n      if (expectedLength != 0) {\n        // if fixed length\n        CheckCBORLength(expectedLength, data.Length);\n        if (!options.Ctap2Canonical ||\n          (firstbyte >= 0x00 && firstbyte < 0x18) ||\n          (firstbyte >= 0x20 && firstbyte < 0x38)) {\n          return GetFixedLengthObject(firstbyte, data);\n        }\n      }\n      if (firstbyte == 0xc0 && !options.Ctap2Canonical) {\n        // value with tag 0\n        string s = GetOptimizedStringIfShortAscii(data, 1);\n        if (s != null) {\n          return new CBORObject(FromObject(s), 0, 0);\n        }\n      }\n      // For objects with variable length,\n      // read the object as though\n      // the byte array were a stream\n      using (var ms = new MemoryStream(data)) {\n        CBORObject o = Read(ms, options);\n        CheckCBORLength(\n          (long)data.Length,\n          (long)ms.Position);\n        return o;\n      }\n    }\n\n    /// <summary>Divides a CBORObject object by the value of a CBORObject\n    /// object.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The quotient of the two objects.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n\n        \"\\u0020.AsNumber()), and use the first number's .Divide() method.\")]\n    public static CBORObject Divide(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Divide(b).ToCBORObject();\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown. This is a change in version 4.0.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='str'/> begins.</param>\n    /// <param name='count'>The length, in code units, of the desired\n    /// portion of <paramref name='str'/> (but not more than <paramref\n    /// name='str'/> 's length).</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='str'/> 's length, or <paramref\n    /// name='str'/> 's length minus <paramref name='offset'/> is less than\n    /// <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONString(string str, int offset, int count) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      return FromJSONString(str, offset, count, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <param name='jsonoptions'>Specifies options to control the JSON\n    /// decoding process.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> or <paramref name='jsonoptions'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    public static CBORObject FromJSONString(\n      string str,\n      JSONOptions jsonoptions) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      return FromJSONString(str, 0, str.Length, jsonoptions);\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown. This is a change in version 4.0.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    public static CBORObject FromJSONString(string str) {\n      return FromJSONString(str, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>A text string in JSON format. The entire string\n    /// must contain a single JSON object and not multiple objects. The\n    /// string may not begin with a byte-order mark (U+FEFF).</param>\n    /// <param name='options'>Specifies options to control the decoding\n    /// process. This method uses only the AllowDuplicateKeys property of\n    /// this object.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> or <paramref name='options'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    [Obsolete(\"Instead, use .FromJSONString\\u0028str, new\" +\n        \"\\u0020JSONOptions\\u0028\\\"allowduplicatekeys=true\\\")) or\" +\n        \"\\u0020.FromJSONString\\u0028str,\" +\n        \"\\u0020 new JSONOptions\\u0028\\\"allowduplicatekeys=false\\\")), as\" +\n        \"\\u0020appropriate.\")]\n    public static CBORObject FromJSONString(\n      string str,\n      CBOREncodeOptions options) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      var jsonoptions = new JSONOptions(options.AllowDuplicateKeys ?\n        \"allowduplicatekeys=1\" : \"allowduplicatekeys=0\");\n      return FromJSONString(str, jsonoptions);\n    }\n\n    /// <summary>Generates a CBOR object from a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONString</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='str'>The parameter <paramref name='str'/> is a text\n    /// string.</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='str'/> begins.</param>\n    /// <param name='count'>The length, in code units, of the desired\n    /// portion of <paramref name='str'/> (but not more than <paramref\n    /// name='str'/> 's length).</param>\n    /// <param name='jsonoptions'>The parameter <paramref\n    /// name='jsonoptions'/> is a Cbor.JSONOptions object.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='str'/> or <paramref name='jsonoptions'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The string is not in\n    /// JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='str'/> 's length, or <paramref\n    /// name='str'/> 's length minus <paramref name='offset'/> is less than\n    /// <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONString(\n      string str,\n      int offset,\n      int count,\n      JSONOptions jsonoptions) {\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      if (count > 0 && str[offset] == 0xfeff) {\n        throw new CBORException(\n          \"JSON object began with a byte order mark (U+FEFF) (offset 0)\");\n      }\n      if (count == 0) {\n        throw new CBORException(\"String is empty\");\n      }\n      return CBORJson3.ParseJSONValue(str, offset, offset + count, jsonoptions);\n    }\n\n    /// <summary>Converts this CBOR object to an object of an arbitrary\n    /// type. See the documentation for the overload of this method taking\n    /// a CBORTypeMapper parameter for more information. This method\n    /// doesn't use a CBORTypeMapper parameter to restrict which data types\n    /// are eligible for Plain-Old-Data serialization.</summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b>\n    ///  For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method (such as <c>int</c>\n    ///  or\n    /// <c>String</c>\n    ///  ) or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given type\n    /// <paramref name='t'/> , or this object's CBOR type, is not\n    /// supported, or the given object's nesting is too deep, or another\n    /// error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> is null.</exception>\n    /// <example>\n    /// <para>Java offers no easy way to express a generic type, at least\n    /// none as easy as C#'s <c>typeof</c>\n    ///  operator. The following example,\n    /// written in Java, is a way to specify that the return value will be\n    /// an ArrayList of String objects.</para>\n    /// <code>Type arrayListString = new ParameterizedType() { public Type[]\n    /// getActualTypeArguments() { &#x2f;&#x2a; Contains one type parameter,\n    /// String&#x2a;&#x2f;\n    /// return new Type[] { String.class }; }\n    /// public Type getRawType() { /* Raw type is\n    /// ArrayList */ return ArrayList.class; }\n    /// public Type getOwnerType() {\n    /// return null; } };\n    /// ArrayList&lt;String&gt; array = (ArrayList&lt;String&gt;)\n    /// cborArray.ToObject(arrayListString);</code>\n    /// <para>By comparison, the C# version is much shorter.</para>\n    /// <code>var array = (List&lt;String&gt;)cborArray.ToObject(\n    /// typeof(List&lt;String&gt;));</code>\n    ///  .\n    /// </example>\n    public object ToObject(Type t) {\n      return this.ToObject(t, null, null, 0);\n    }\n\n    /// <summary>Converts this CBOR object to an object of an arbitrary\n    /// type. See the documentation for the overload of this method taking\n    /// a CBORTypeMapper and PODOptions parameters parameters for more\n    /// information.</summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method (such as <c>int</c> or\n    /// <c>String</c> ) or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given type\n    /// <paramref name='t'/>, or this object's CBOR type, is not\n    /// supported, or the given object's nesting is too deep, or another\n    /// error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> is null.</exception>\n    public object ToObject(Type t, CBORTypeMapper mapper) {\n      if (mapper == null) {\n        throw new ArgumentNullException(nameof(mapper));\n      }\n      return this.ToObject(t, mapper, null, 0);\n    }\n\n    /// <summary>Converts this CBOR object to an object of an arbitrary\n    /// type. See the documentation for the overload of this method taking\n    /// a CBORTypeMapper and PODOptions parameters for more information.\n    /// This method (without a CBORTypeMapper parameter) allows all data\n    /// types not otherwise handled to be eligible for Plain-Old-Data\n    /// serialization.</summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method (such as <c>int</c> or\n    /// <c>String</c> ) or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='options'>Specifies options for controlling\n    /// deserialization of CBOR objects.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='NotSupportedException'>The given type <paramref\n    /// name='t'/>, or this object's CBOR type, is not\n    /// supported.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given object's\n    /// nesting is too deep, or another error occurred when serializing the\n    /// object.</exception>\n    public object ToObject(Type t, PODOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      return this.ToObject(t, null, options, 0);\n    }\n\n    /// <summary><para>Converts this CBOR object to an object of an\n    /// arbitrary type. The following cases are checked in the logical\n    /// order given (rather than the strict order in which they are\n    /// implemented by this library):</para>\n    ///  <list><item>If the type is\n    /// <c>CBORObject</c>\n    ///  , return this object.</item>\n    ///  <item>If the given\n    /// object is <c>CBORObject.Null</c>\n    ///  (with or without tags), returns\n    /// <c>null</c>\n    ///  .</item>\n    ///  <item>If the object is of a type corresponding\n    /// to a type converter mentioned in the <paramref name='mapper'/>\n    /// parameter, that converter will be used to convert the CBOR object\n    /// to an object of the given type. Type converters can be used to\n    /// override the default conversion behavior of almost any\n    /// object.</item>\n    ///  <item>If the type is <c>object</c>\n    ///  , return this\n    /// object.</item>\n    ///  <item>If the type is <c>char</c>\n    ///  , converts\n    /// single-character CBOR text strings and CBOR integers from 0 through\n    /// 65535 to a <c>char</c>\n    ///  object and returns that <c>char</c>\n    /// object.</item>\n    ///  <item>If the type is <c>bool</c>\n    ///  ( <c>boolean</c>\n    ///  in\n    /// Java), returns the result of AsBoolean.</item>\n    ///  <item>If the type is\n    /// <c>short</c>\n    ///  , returns this number as a 16-bit signed integer after\n    /// converting its value to an integer by discarding its fractional\n    /// part, and throws an exception if this object's value is infinity or\n    /// a not-a-number value, or does not represent a number (currently\n    /// InvalidOperationException, but may change in the next major\n    /// version), or if the value, once converted to an integer by\n    /// discarding its fractional part, is less than -32768 or greater than\n    /// 32767 (currently OverflowException, but may change in the next\n    /// major version).</item>\n    ///  <item>If the type is <c>long</c>\n    ///  , returns\n    /// this number as a 64-bit signed integer after converting its value\n    /// to an integer by discarding its fractional part, and throws an\n    /// exception if this object's value is infinity or a not-a-number\n    /// value, or does not represent a number (currently\n    /// InvalidOperationException, but may change in the next major\n    /// version), or if the value, once converted to an integer by\n    /// discarding its fractional part, is less than -2^63 or greater than\n    /// 2^63-1 (currently OverflowException, but may change in the next\n    /// major version).</item>\n    ///  <item>If the type is <c>short</c>\n    ///  , the same\n    /// rules as for <c>long</c>\n    ///  are used, but the range is from -32768\n    /// through 32767 and the return type is <c>short</c>\n    ///  .</item>\n    ///  <item>If\n    /// the type is <c>byte</c>\n    ///  , the same rules as for <c>long</c>\n    ///  are\n    /// used, but the range is from 0 through 255 and the return type is\n    /// <c>byte</c>\n    ///  .</item>\n    ///  <item>If the type is <c>sbyte</c>\n    ///  , the same\n    /// rules as for <c>long</c>\n    ///  are used, but the range is from -128\n    /// through 127 and the return type is <c>sbyte</c>\n    ///  .</item>\n    ///  <item>If\n    /// the type is <c>ushort</c>\n    ///  , the same rules as for <c>long</c>\n    ///  are\n    /// used, but the range is from 0 through 65535 and the return type is\n    /// <c>ushort</c>\n    ///  .</item>\n    ///  <item>If the type is <c>uint</c>\n    ///  , the same\n    /// rules as for <c>long</c>\n    ///  are used, but the range is from 0 through\n    /// 2^31-1 and the return type is <c>uint</c>\n    ///  .</item>\n    ///  <item>If the\n    /// type is <c>ulong</c>\n    ///  , the same rules as for <c>long</c>\n    ///  are used,\n    /// but the range is from 0 through 2^63-1 and the return type is\n    /// <c>ulong</c>\n    ///  .</item>\n    ///  <item>If the type is <c>int</c>\n    ///  or a\n    /// primitive floating-point type ( <c>float</c>\n    ///  , <c>double</c>\n    ///  , as\n    /// well as <c>decimal</c>\n    ///  in.NET), returns the result of the\n    /// corresponding As* method.</item>\n    ///  <item>If the type is <c>String</c>\n    /// , returns the result of AsString.</item>\n    ///  <item>If the type is\n    /// <c>EFloat</c>\n    ///  , <c>EDecimal</c>\n    ///  , <c>EInteger</c>\n    ///  , or\n    /// <c>ERational</c>\n    ///  in the <a\n    /// href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c>\n    /// </a>\n    ///  library (in .NET) or the <a\n    /// href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c>\n    /// </a>\n    ///  artifact (in Java), or if the type is <c>BigInteger</c>\n    ///  or\n    /// <c>BigDecimal</c>\n    ///  in the Java version, converts the given object to\n    /// a number of the corresponding type and throws an exception\n    /// (currently InvalidOperationException) if the object does not\n    /// represent a number (for this purpose, infinity and not-a-number\n    /// values, but not <c>CBORObject.Null</c>\n    ///  , are considered numbers).\n    /// Currently, this is equivalent to the result of <c>AsEFloat()</c>\n    ///  ,\n    /// <c>AsEDecimal()</c>\n    ///  , <c>AsEInteger</c>\n    ///  , or <c>AsERational()</c>\n    ///  ,\n    /// respectively, but may change slightly in the next major version.\n    /// Note that in the case of <c>EFloat</c>\n    ///  , if this object represents\n    /// a decimal number with a fractional part, the conversion may lose\n    /// information depending on the number, and if the object is a\n    /// rational number with a nonterminating binary expansion, the number\n    /// returned is a binary floating-point number rounded to a high but\n    /// limited precision. In the case of <c>EDecimal</c>\n    ///  , if this object\n    /// expresses a rational number with a nonterminating decimal\n    /// expansion, returns a decimal number rounded to 34 digits of\n    /// precision. In the case of <c>EInteger</c>\n    ///  , if this CBOR object\n    /// expresses a floating-point number, it is converted to an integer by\n    /// discarding its fractional part, and if this CBOR object expresses a\n    /// rational number, it is converted to an integer by dividing the\n    /// numerator by the denominator and discarding the fractional part of\n    /// the result, and this method throws an exception (currently\n    /// OverflowException, but may change in the next major version) if\n    /// this object expresses infinity or a not-a-number value.</item>\n    /// <item>In the.NET version, if the type is a nullable (e.g.,\n    /// <c>Nullable&lt;int&gt;</c>\n    ///  or <c>int?</c>\n    ///  , returns <c>null</c>\n    ///  if\n    /// this CBOR object is null, or this object's value converted to the\n    /// nullable's underlying type, e.g., <c>int</c>\n    ///  .</item>\n    ///  <item>If the\n    /// type is an enumeration ( <c>Enum</c>\n    ///  ) type and this CBOR object is\n    /// a text string or an integer, returns the appropriate enumerated\n    /// constant. (For example, if <c>MyEnum</c>\n    ///  includes an entry for\n    /// <c>MyValue</c>\n    ///  , this method will return <c>MyEnum.MyValue</c>\n    ///  if\n    /// the CBOR object represents <c>\"MyValue\"</c>\n    ///  or the underlying value\n    /// for <c>MyEnum.MyValue</c>\n    ///  .) <b>Note:</b>\n    ///  If an integer is\n    /// converted to a.NET Enum constant, and that integer is shared by\n    /// more than one constant of the same type, it is undefined which\n    /// constant from among them is returned. (For example, if\n    /// <c>MyEnum.Zero=0</c>\n    ///  and <c>MyEnum.Null=0</c>\n    ///  , converting 0 to\n    /// <c>MyEnum</c>\n    ///  may return either <c>MyEnum.Zero</c>\n    ///  or\n    /// <c>MyEnum.Null</c>\n    ///  .) As a result, .NET Enum types with constants\n    /// that share an underlying value should not be passed to this\n    /// method.</item>\n    ///  <item>If the type is <c>byte[]</c>\n    ///  (a\n    /// one-dimensional byte array) and this CBOR object is a byte string,\n    /// returns a byte array which this CBOR byte string's data will be\n    /// copied to. (This method can't be used to encode CBOR data to a byte\n    /// array; for that, use the EncodeToBytes method instead.)</item>\n    /// <item>If the type is a one-dimensional or multidimensional array\n    /// type and this CBOR object is an array, returns an array containing\n    /// the items in this CBOR object.</item>\n    ///  <item>If the type is List,\n    /// ReadOnlyCollection or the generic or non-generic IList,\n    /// ICollection, IEnumerable, IReadOnlyCollection, or IReadOnlyList (or\n    /// ArrayList, List, Collection, or Iterable in Java), and if this CBOR\n    /// object is an array, returns an object conforming to the type,\n    /// class, or interface passed to this method, where the object will\n    /// contain all items in this CBOR array.</item>\n    ///  <item>If the type is\n    /// Dictionary, ReadOnlyDictionary or the generic or non-generic\n    /// IDictionary or IReadOnlyDictionary (or HashMap or Map in Java), and\n    /// if this CBOR object is a map, returns an object conforming to the\n    /// type, class, or interface passed to this method, where the object\n    /// will contain all keys and values in this CBOR map.</item>\n    ///  <item>If\n    /// the type is an enumeration constant (\"enum\"), and this CBOR object\n    /// is an integer or text string, returns the enumeration constant with\n    /// the given number or name, respectively. (Enumeration constants made\n    /// up of multiple enumeration constants, as allowed by .NET, can only\n    /// be matched by number this way.)</item>\n    ///  <item>If the type is\n    /// <c>DateTime</c>\n    ///  (or <c>Date</c>\n    ///  in Java) , returns a date/time\n    /// object if the CBOR object's outermost tag is 0 or 1. For tag 1,\n    /// this method treats the CBOR object as a number of seconds since the\n    /// start of 1970, which is based on the POSIX definition of \"seconds\n    /// since the Epoch\", a definition that does not count leap seconds. In\n    /// this method, this number of seconds assumes the use of a proleptic\n    /// Gregorian calendar, in which the rules regarding the number of days\n    /// in each month and which years are leap years are the same for all\n    /// years as they were in 1970 (including without regard to time zone\n    /// differences or transitions from other calendars to the Gregorian).\n    /// The string format used in tag 0 supports only years up to 4 decimal\n    /// digits long. For tag 1, CBOR objects that express infinity or\n    /// not-a-number (NaN) are treated as invalid by this method. This\n    /// default behavior for <c>DateTime</c>\n    ///  and <c>Date</c>\n    ///  can be changed\n    /// by passing a suitable CBORTypeMapper to this method, such as a\n    /// CBORTypeMapper that registers a CBORDateConverter for\n    /// <c>DateTime</c>\n    ///  or <c>Date</c>\n    ///  objects. See the examples.</item>\n    /// <item>If the type is <c>Uri</c>\n    ///  (or <c>URI</c>\n    ///  in Java), returns a\n    /// URI object if possible.</item>\n    ///  <item>If the type is <c>Guid</c>\n    ///  (or\n    /// <c>UUID</c>\n    ///  in Java), returns a UUID object if possible.</item>\n    /// <item>Plain-Old-Data deserialization: If the object is a type not\n    /// specially handled above, the type includes a zero-parameter\n    /// constructor (default or not), this CBOR object is a CBOR map, and\n    /// the \"mapper\" parameter (if any) allows this type to be eligible for\n    /// Plain-Old-Data deserialization, then this method checks the given\n    /// type for eligible setters as follows:</item>\n    ///  <item>(*) In the .NET\n    /// version, eligible setters are the public, nonstatic setters of\n    /// properties with a public, nonstatic getter. Eligible setters also\n    /// include public, nonstatic, non- <c>const</c>\n    ///  , non- <c>readonly</c>\n    /// fields. If a class has two properties and/or fields of the form \"X\"\n    /// and \"IsX\", where \"X\" is any name, or has multiple properties and/or\n    /// fields with the same name, those properties and fields are\n    /// ignored.</item>\n    ///  <item>(*) In the Java version, eligible setters are\n    /// public, nonstatic methods starting with \"set\" followed by a\n    /// character other than a basic digit or lower-case letter, that is,\n    /// other than \"a\" to \"z\" or \"0\" to \"9\", that take one parameter. The\n    /// class containing an eligible setter must have a public, nonstatic\n    /// method with the same name, but starting with \"get\" or \"is\" rather\n    /// than \"set\", that takes no parameters and does not return void. (For\n    /// example, if a class has \"public setValue(String)\" and \"public\n    /// getValue()\", \"setValue\" is an eligible setter. However,\n    /// \"setValue()\" and \"setValue(String, int)\" are not eligible setters.)\n    /// In addition, public, nonstatic, nonfinal fields are also eligible\n    /// setters. If a class has two or more otherwise eligible setters\n    /// (methods and/or fields) with the same name, but different parameter\n    /// type, they are not eligible setters.</item>\n    ///  <item>Then, the method\n    /// creates an object of the given type and invokes each eligible\n    /// setter with the corresponding value in the CBOR map, if any. Key\n    /// names in the map are matched to eligible setters according to the\n    /// rules described in the <see cref='PeterO.Cbor.PODOptions'/>\n    /// documentation. Note that for security reasons, certain types are\n    /// not supported even if they contain eligible setters. For the Java\n    /// version, the object creation may fail in the case of a nested\n    /// nonstatic class.</item>\n    ///  </list>\n    ///  </summary>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b>\n    ///  For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c>\n    ///  or\n    /// <c>String</c>\n    ///  , or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types. Can be\n    /// null.</param>\n    /// <param name='options'>Specifies options for controlling\n    /// deserialization of CBOR objects.</param>\n    /// <returns>The converted object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The given type\n    /// <paramref name='t'/> , or this object's CBOR type, is not\n    /// supported, or the given object's nesting is too deep, or another\n    /// error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='t'/> or <paramref name='options'/> is null.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the\n    /// DotNet version) uses a CBORTypeMapper to change how CBOR objects\n    /// are converted to DateTime objects. In this case, the ToObject\n    /// method assumes the CBOR object is an untagged number giving the\n    /// number of seconds since the start of 1970.</para>\n    /// <code>var conv = new CBORTypeMapper().AddConverter(typeof(DateTime),\n    /// CBORDateConverter.UntaggedNumber);\n    /// var obj = CBORObject.FromObject().ToObject&lt;DateTime&gt;(conv);</code>\n    /// <para>Java offers no easy way to express a generic type, at least\n    /// none as easy as C#'s <c>typeof</c>\n    ///  operator. The following example,\n    /// written in Java, is a way to specify that the return value will be\n    /// an ArrayList of String objects.</para>\n    /// <code>Type arrayListString = new ParameterizedType() { public Type[]\n    /// getActualTypeArguments() { &#x2f;&#x2a; Contains one type parameter,\n    /// String&#x2a;&#x2f;\n    /// return new Type[] { String.class }; }\n    /// public Type getRawType() { /* Raw type is\n    /// ArrayList */ return ArrayList.class; } public Type getOwnerType() {\n    /// return null; } }; ArrayList&lt;String&gt; array =\n    /// (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);</code>\n    /// <para>By comparison, the C# version is much shorter.</para>\n    /// <code>var array = (List&lt;String&gt;)cborArray.ToObject(\n    /// typeof(List&lt;String&gt;));</code>\n    ///  .\n    /// </example>\n    public object ToObject(Type t, CBORTypeMapper mapper, PODOptions\n      options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      return this.ToObject(t, mapper, options, 0);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object\n    /// to control the decoding process. It is equivalent to\n    /// DecodeFromBytes followed by ToObject. See the documentation for\n    /// those methods for more information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='enc'>Specifies options to control how the CBOR object\n    /// is decoded. See\n    /// <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more\n    /// information.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types. Can be\n    /// null.</param>\n    /// <param name='pod'>Specifies options for controlling deserialization\n    /// of CBOR objects.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='enc'/> is\n    /// null, or the parameter <paramref name='t'/> or <paramref\n    /// name='pod'/> is null.</exception>\n    public static object DecodeObjectFromBytes(\n      byte[] data,\n      CBOREncodeOptions enc,\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions pod) {\n      if (pod == null) {\n        throw new ArgumentNullException(nameof(pod));\n      }\n      if (enc == null) {\n        throw new ArgumentNullException(nameof(enc));\n      }\n      return DecodeFromBytes(data, enc).ToObject(t, mapper, pod);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes, using the given <c>CBOREncodeOptions</c> object\n    /// to control the decoding process. It is equivalent to\n    /// DecodeFromBytes followed by ToObject. See the documentation for\n    /// those methods for more information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='enc'>Specifies options to control how the CBOR object\n    /// is decoded. See\n    /// <see cref='PeterO.Cbor.CBOREncodeOptions'/> for more\n    /// information.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='enc'/> is\n    /// null, or the parameter <paramref name='t'/> is null.</exception>\n    public static object DecodeObjectFromBytes(\n      byte[] data,\n      CBOREncodeOptions enc,\n      Type t) {\n       return DecodeFromBytes(data, enc).ToObject(t);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by\n    /// ToObject. See the documentation for those methods for more\n    /// information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <param name='mapper'>This parameter controls which data types are\n    /// eligible for Plain-Old-Data deserialization and includes custom\n    /// converters from CBOR objects to certain data types. Can be\n    /// null.</param>\n    /// <param name='pod'>Specifies options for controlling deserialization\n    /// of CBOR objects.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='t'/> or\n    /// <paramref name='pod'/> is null.</exception>\n    public static object DecodeObjectFromBytes(\n      byte[] data,\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions pod) {\n       return\nDecodeObjectFromBytes(data, CBOREncodeOptions.Default, t, mapper, pod);\n    }\n\n    /// <summary>Generates an object of an arbitrary type from an array of\n    /// CBOR-encoded bytes. It is equivalent to DecodeFromBytes followed by\n    /// ToObject. See the documentation for those methods for more\n    /// information.</summary>\n    /// <param name='data'>A byte array in which a single CBOR object is\n    /// encoded.</param>\n    /// <param name='t'>The type, class, or interface that this method's\n    /// return value will belong to. To express a generic type in Java, see\n    /// the example. <b>Note:</b> For security reasons, an application\n    /// should not base this parameter on user input or other externally\n    /// supplied data. Whenever possible, this parameter should be either a\n    /// type specially handled by this method, such as <c>int</c> or\n    /// <c>String</c>, or a plain-old-data type (POCO or POJO type) within\n    /// the control of the application. If the plain-old-data type\n    /// references other data types, those types should likewise meet\n    /// either criterion above.</param>\n    /// <returns>An object of the given type decoded from the given byte\n    /// array. Returns null (as opposed to CBORObject.Null) if <paramref\n    /// name='data'/> is empty and the AllowEmpty property is set on the\n    /// given CBOREncodeOptions object.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data. This includes cases where not all of\n    /// the byte array represents a CBOR object. This exception is also\n    /// thrown if the parameter <paramref name='data'/> is empty unless the\n    /// AllowEmpty property is set on the given options object. Also thrown\n    /// if the given type <paramref name='t'/>, or this object's CBOR\n    /// type, is not supported, or the given object's nesting is too deep,\n    /// or another error occurred when serializing the object.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='data'/> is null, or the parameter <paramref name='t'/> is\n    /// null.</exception>\n    public static object DecodeObjectFromBytes(byte[] data, Type t) {\n       return DecodeObjectFromBytes(data, CBOREncodeOptions.Default, t);\n    }\n\n    internal object ToObject(\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      ++depth;\n      if (depth > 100) {\n        throw new CBORException(\"Depth level too high\");\n      }\n      if (t == null) {\n        throw new ArgumentNullException(nameof(t));\n      }\n      if (t.Equals(typeof(CBORObject))) {\n        return this;\n      }\n      if (this.IsNull) {\n        // TODO: In next major version, consider returning null\n        // here only if this object is untagged, to allow behavior\n        // to be customizable by CBORTypeMapper\n        return null;\n      }\n      if (mapper != null) {\n        object obj = mapper.ConvertBackWithConverter(this, t);\n        if (obj != null) {\n          return obj;\n        }\n      }\n      if (t.Equals(typeof(object))) {\n        return this;\n      }\n      // TODO: In next major version, address inconsistent\n      // implementations for EDecimal, EInteger, EFloat,\n      // and ERational (perhaps\n      // by using EDecimal implementation). Also, these operations\n      // might throw InvalidOperationException rather than CBORException.\n      // Make them throw CBORException in next major version.\n      if (t.Equals(typeof(EDecimal))) {\n        CBORNumber cn = this.AsNumber();\n        return cn.GetNumberInterface().AsEDecimal(cn.GetValue());\n      }\n      if (t.Equals(typeof(EFloat))) {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null) {\n          throw new InvalidOperationException(\"Not a number type\");\n        }\n        return cn.GetNumberInterface().AsEFloat(cn.GetValue());\n      }\n      if (t.Equals(typeof(EInteger))) {\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null) {\n          throw new InvalidOperationException(\"Not a number type\");\n        }\n        return cn.GetNumberInterface().AsEInteger(cn.GetValue());\n      }\n      if (t.Equals(typeof(ERational))) {\n        // NOTE: Will likely be simplified in version 5.0 and later\n        if (this.HasMostInnerTag(30) && this.Count != 2) {\n          EInteger num, den;\n          num = (EInteger)this[0].ToObject(typeof(EInteger));\n          den = (EInteger)this[1].ToObject(typeof(EInteger));\n          return ERational.Create(num, den);\n        }\n        CBORNumber cn = CBORNumber.FromCBORObject(this);\n        if (cn == null) {\n          throw new InvalidOperationException(\"Not a number type\");\n        }\n        return cn.GetNumberInterface().AsERational(cn.GetValue());\n      }\n      return t.Equals(typeof(string)) ? this.AsString() :\n        PropertyMap.TypeToObject(this, t, mapper, options, depth);\n    }\n\n    /// <summary>Generates a CBOR object from a 64-bit signed\n    /// integer.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 64-bit signed integer.</param>\n    /// <returns>A CBOR object.</returns>\n    public static CBORObject FromObject(long value) {\n      if (value >= 0L && value < 24L) {\n        return FixedObjects[(int)value];\n      } else {\n        return (value >= -24L && value < 0L) ? FixedObjects[0x20 - (int)(value +\n              1L)] : new CBORObject(CBORObjectTypeInteger, value);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a CBOR object.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// CBOR object.</param>\n    /// <returns>Same as <paramref name='value'/>, or \"CBORObject.Null\" is\n    /// <paramref name='value'/> is null.</returns>\n    public static CBORObject FromObject(CBORObject value) {\n      return value ?? CBORObject.Null;\n    }\n\n    private static int IntegerByteLength(int intValue) {\n      if (intValue < 0) {\n        intValue = -(intValue + 1);\n      }\n      if (intValue > 0xffff) {\n        return 5;\n      } else if (intValue > 0xff) {\n        return 3;\n      } else {\n        return (intValue > 23) ? 2 : 1;\n      }\n    }\n\n    private static int IntegerByteLength(long longValue) {\n      if (longValue < 0) {\n        longValue = -(longValue + 1);\n      }\n      if (longValue > 0xffffffffL) {\n        return 9;\n      } else if (longValue > 0xffffL) {\n        return 5;\n      } else if (longValue > 0xffL) {\n        return 3;\n      } else {\n        return (longValue > 23L) ? 2 : 1;\n      }\n    }\n\n    /// <summary>Calculates the number of bytes this CBOR object takes when\n    /// serialized as a byte array using the <c>EncodeToBytes()</c> method.\n    /// This calculation assumes that integers, lengths of maps and arrays,\n    /// lengths of text and byte strings, and tag numbers are encoded in\n    /// their shortest form; that floating-point numbers are encoded in\n    /// their shortest value-preserving form; and that no indefinite-length\n    /// encodings are used.</summary>\n    /// <returns>The number of bytes this CBOR object takes when serialized\n    /// as a byte array using the <c>EncodeToBytes()</c> method.</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>The CBOR object has an\n    /// extremely deep level of nesting, including if the CBOR object is or\n    /// has an array or map that includes itself.</exception>\n    public long CalcEncodedSize() {\n      return this.CalcEncodedSize(0);\n    }\n\n    private long CalcEncodedSize(int depth) {\n      if (depth > 1000) {\n        throw new CBORException(\"Too deeply nested\");\n      }\n      // DebugUtility.Log(\"type=\"+this.Type+\" depth=\"+depth);\n      long size = 0L;\n      CBORObject cbor = this;\n      while (cbor.IsTagged) {\n        EInteger etag = cbor.MostOuterTag;\n        if (etag.CanFitInInt64()) {\n          long tag = etag.ToInt64Checked();\n          size = checked(size + IntegerByteLength(tag));\n        } else {\n          size = checked(size + 9);\n        }\n        cbor = cbor.UntagOne();\n      }\n      if (cbor.ItemType == CBORObjectTypeTextStringUtf8) {\n        byte[] bytes = (byte[])this.ThisItem;\n        size = checked(size + IntegerByteLength(bytes.Length));\n        return checked(size + bytes.Length);\n      }\n      if (cbor.ItemType == CBORObjectTypeTextStringAscii) {\n        var str = (string)this.ThisItem;\n        size = checked(size + IntegerByteLength(str.Length));\n        return checked(size + str.Length);\n      }\n      switch (cbor.Type) {\n        case CBORType.Integer: {\n          if (cbor.CanValueFitInInt64()) {\n            long tag = cbor.AsInt64Value();\n            size = checked(size + IntegerByteLength(tag));\n            return size;\n          } else {\n            return checked(size + 9);\n          }\n        }\n        case CBORType.FloatingPoint: {\n          long valueBits = cbor.AsDoubleBits();\n          int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);\n          if (bits != -1) {\n            return checked(size + 3);\n          }\n          return CBORUtilities.DoubleRetainsSameValueInSingle(valueBits) ?\n            checked(size + 5) : checked(size + 9);\n        }\n        case CBORType.Array:\n          size = checked(size + IntegerByteLength(cbor.Count));\n          for (var i = 0; i < cbor.Count; ++i) {\n            long newsize = cbor[i].CalcEncodedSize(depth + 1);\n            size = checked(size + newsize);\n          }\n          return size;\n        case CBORType.Map: {\n          ICollection<KeyValuePair<CBORObject, CBORObject>> entries =\n            this.Entries;\n          size = checked(size + IntegerByteLength(entries.Count));\n          try {\n            foreach (KeyValuePair<CBORObject, CBORObject> entry in entries) {\n              CBORObject key = entry.Key;\n              CBORObject value = entry.Value;\n              size = checked(size + key.CalcEncodedSize(depth + 1));\n              size = checked(size + value.CalcEncodedSize(depth + 1));\n            }\n          } catch (InvalidOperationException ex) {\n            // Additional error that may occur in iteration\n            throw new CBORException(ex.Message, ex);\n          } catch (ArgumentException ex) {\n            // Additional error that may occur in iteration\n            throw new CBORException(ex.Message, ex);\n          }\n          return size;\n        }\n        case CBORType.TextString: {\n          long ulength = DataUtilities.GetUtf8Length(this.AsString(), false);\n          size = checked(size + IntegerByteLength(ulength));\n          return checked(size + ulength);\n        }\n        case CBORType.ByteString: {\n          byte[] bytes = cbor.GetByteString();\n          size = checked(size + IntegerByteLength(bytes.Length));\n          return checked(size + bytes.Length);\n        }\n        case CBORType.Boolean:\n          return checked(size + 1);\n        case CBORType.SimpleValue:\n          return checked(size + (cbor.SimpleValue >= 24 ? 2 : 1));\n        default: throw new InvalidOperationException();\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary-precision\n    /// integer. The CBOR object is generated as follows:\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number is greater than or equal to -(2^64)\n    /// and less than 2^64, the CBOR object will have the object type\n    /// Integer and the appropriate value.</item>\n    /// <item>Otherwise, the CBOR object will have tag 2 (zero or positive)\n    /// or 3 (negative) and the appropriate value.</item></list></summary>\n    /// <param name='bigintValue'>An arbitrary-precision integer. Can be\n    /// null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigintValue'/> is\n    /// null.</returns>\n    public static CBORObject FromObject(EInteger bigintValue) {\n      if ((object)bigintValue == (object)null) {\n        return CBORObject.Null;\n      }\n      if (bigintValue.CanFitInInt64()) {\n        return CBORObject.FromObject(bigintValue.ToInt64Checked());\n      } else {\n        EInteger bitLength = bigintValue.GetSignedBitLengthAsEInteger();\n        if (bitLength.CompareTo(64) <= 0) {\n          // Fits in major type 0 or 1\n          return new CBORObject(CBORObjectTypeEInteger, bigintValue);\n        } else {\n          int tag = (bigintValue.Sign < 0) ? 3 : 2;\n          return CBORObject.FromObjectAndTag(\n              EIntegerBytes(bigintValue),\n              tag);\n        }\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary-precision binary\n    /// floating-point number. The CBOR object is generated as follows\n    /// (this is a change in version 4.0):\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number expresses infinity, not-a-number, or\n    /// negative zero, the CBOR object will have tag 269 and the\n    /// appropriate format.</item>\n    /// <item>Otherwise, if the number's exponent is at least 2^64 or less\n    /// than -(2^64), the CBOR object will have tag 265 and the appropriate\n    /// format.</item>\n    /// <item>Otherwise, the CBOR object will have tag 5 and the\n    /// appropriate format.</item></list></summary>\n    /// <param name='bigValue'>An arbitrary-precision binary floating-point\n    /// number. Can be null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigValue'/> is null.</returns>\n    public static CBORObject FromObject(EFloat bigValue) {\n      if ((object)bigValue == (object)null) {\n        return CBORObject.Null;\n      }\n      CBORObject cbor;\n      int tag;\n      if (bigValue.IsInfinity() || bigValue.IsNaN() ||\n        (bigValue.IsNegative && bigValue.IsZero)) {\n        int options = bigValue.IsNegative ? 1 : 0;\n        if (bigValue.IsInfinity()) {\n          options += 2;\n        }\n        if (bigValue.IsQuietNaN()) {\n          options += 4;\n        }\n        if (bigValue.IsSignalingNaN()) {\n          options += 6;\n        }\n        cbor = CBORObject.NewArray(\n            CBORObject.FromObject(bigValue.Exponent),\n            CBORObject.FromObject(bigValue.UnsignedMantissa),\n            CBORObject.FromObject(options));\n        tag = 269;\n      } else {\n        EInteger exponent = bigValue.Exponent;\n        if (exponent.CanFitInInt64()) {\n          tag = 5;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent.ToInt64Checked()),\n              CBORObject.FromObject(bigValue.Mantissa));\n        } else {\n          tag = (exponent.GetSignedBitLengthAsInt64() > 64) ?\n            265 : 5;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent),\n              CBORObject.FromObject(bigValue.Mantissa));\n        }\n      }\n      return cbor.WithTag(tag);\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary-precision\n    /// rational number. The CBOR object is generated as follows (this is a\n    /// change in version 4.0):\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number expresses infinity, not-a-number, or\n    /// negative zero, the CBOR object will have tag 270 and the\n    /// appropriate format.</item>\n    /// <item>Otherwise, the CBOR object will have tag 30 and the\n    /// appropriate format.</item></list></summary>\n    /// <param name='bigValue'>An arbitrary-precision rational number. Can\n    /// be null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigValue'/> is null.</returns>\n    public static CBORObject FromObject(ERational bigValue) {\n      if ((object)bigValue == (object)null) {\n        return CBORObject.Null;\n      }\n      CBORObject cbor;\n      int tag;\n      if (bigValue.IsInfinity() || bigValue.IsNaN() ||\n        (bigValue.IsNegative && bigValue.IsZero)) {\n        int options = bigValue.IsNegative ? 1 : 0;\n        if (bigValue.IsInfinity()) {\n          options += 2;\n        }\n        if (bigValue.IsQuietNaN()) {\n          options += 4;\n        }\n        if (bigValue.IsSignalingNaN()) {\n          options += 6;\n        }\n        #if DEBUG\n        if (!(!bigValue.IsInfinity() || bigValue.UnsignedNumerator.IsZero)) {\n          throw new InvalidOperationException(\"doesn't satisfy\" +\n            \"\\u0020!bigValue.IsInfinity() ||\" +\n            \"\\u0020bigValue.UnsignedNumerator.IsZero\");\n        }\n        if (!(!bigValue.IsInfinity() || bigValue.Denominator.CompareTo(1) ==\n            0)) {\n          throw new InvalidOperationException(\"doesn't satisfy\" +\n            \"\\u0020!bigValue.IsInfinity() ||\" +\n            \"\\u0020bigValue.Denominator.CompareTo(1)==0\");\n        }\n        if (!(!bigValue.IsNaN() || bigValue.Denominator.CompareTo(1) == 0)) {\n          throw new InvalidOperationException(\"doesn't satisfy\" +\n            \"\\u0020!bigValue.IsNaN() ||\" +\n            \"\\u0020bigValue.Denominator.CompareTo(1)==0\");\n        }\n        #endif\n\n        cbor = CBORObject.NewArray(\n            FromObject(bigValue.UnsignedNumerator),\n            FromObject(bigValue.Denominator),\n            FromObject(options));\n        tag = 270;\n      } else {\n        tag = 30;\n        cbor = CBORObject.NewArray(\n            CBORObject.FromObject(bigValue.Numerator),\n            CBORObject.FromObject(bigValue.Denominator));\n      }\n      return cbor.WithTag(tag);\n    }\n\n    /// <summary>Generates a CBOR object from a decimal number. The CBOR\n    /// object is generated as follows (this is a change in version 4.0):\n    /// <list>\n    /// <item>If the number is null, returns CBORObject.Null.</item>\n    /// <item>Otherwise, if the number expresses infinity, not-a-number, or\n    /// negative zero, the CBOR object will have tag 268 and the\n    /// appropriate format.</item>\n    /// <item>If the number's exponent is at least 2^64 or less than\n    /// -(2^64), the CBOR object will have tag 264 and the appropriate\n    /// format.</item>\n    /// <item>Otherwise, the CBOR object will have tag 4 and the\n    /// appropriate format.</item></list></summary>\n    /// <param name='bigValue'>An arbitrary-precision decimal number. Can\n    /// be null.</param>\n    /// <returns>The given number encoded as a CBOR object. Returns\n    /// CBORObject.Null if <paramref name='bigValue'/> is null.</returns>\n    public static CBORObject FromObject(EDecimal bigValue) {\n      if ((object)bigValue == (object)null) {\n        return CBORObject.Null;\n      }\n      CBORObject cbor;\n      int tag;\n      if (bigValue.IsInfinity() || bigValue.IsNaN() ||\n        (bigValue.IsNegative && bigValue.IsZero)) {\n        int options = bigValue.IsNegative ? 1 : 0;\n        if (bigValue.IsInfinity()) {\n          options += 2;\n        }\n        if (bigValue.IsQuietNaN()) {\n          options += 4;\n        }\n        if (bigValue.IsSignalingNaN()) {\n          options += 6;\n        }\n        cbor = CBORObject.NewArray(\n            FromObject(bigValue.Exponent),\n            FromObject(bigValue.UnsignedMantissa),\n            FromObject(options));\n        tag = 268;\n      } else {\n        EInteger exponent = bigValue.Exponent;\n        if (exponent.CanFitInInt64()) {\n          tag = 4;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent.ToInt64Checked()),\n              CBORObject.FromObject(bigValue.Mantissa));\n        } else {\n          tag = (exponent.GetSignedBitLengthAsInt64() > 64) ?\n            264 : 4;\n          cbor = CBORObject.NewArray(\n              CBORObject.FromObject(exponent),\n              CBORObject.FromObject(bigValue.Mantissa));\n        }\n      }\n      return cbor.WithTag(tag);\n    }\n\n    /// <summary>Generates a CBOR object from a text string.</summary>\n    /// <param name='strValue'>A text string value. Can be null.</param>\n    /// <returns>A CBOR object representing the string, or CBORObject.Null\n    /// if stringValue is null.</returns>\n    /// <exception cref='ArgumentException'>The string contains an unpaired\n    /// surrogate code point.</exception>\n    public static CBORObject FromObject(string strValue) {\n      if (strValue == null) {\n        return CBORObject.Null;\n      }\n      if (strValue.Length == 0) {\n        return GetFixedObject(0x60);\n      }\n      long utf8Length = DataUtilities.GetUtf8Length(strValue, false);\n      if (utf8Length < 0) {\n        throw new ArgumentException(\"String contains an unpaired \" +\n          \"surrogate code point.\");\n      }\n      return new CBORObject(\n        strValue.Length == utf8Length ? CBORObjectTypeTextStringAscii : CBORObjectTypeTextString,\n        strValue);\n    }\n\n    /// <summary>Generates a CBOR object from a 32-bit signed\n    /// integer.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 32-bit signed integer.</param>\n    /// <returns>A CBOR object.</returns>\n    public static CBORObject FromObject(int value) {\n      if (value >= 0 && value < 24) {\n        return FixedObjects[value];\n      } else {\n        return (value >= -24 && value < 0) ? FixedObjects[0x20 - (value + 1)] :\n          FromObject((long)value);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a 16-bit signed\n    /// integer.</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 16-bit signed integer.</param>\n    /// <returns>A CBOR object generated from the given integer.</returns>\n    public static CBORObject FromObject(short value) {\n      if (value >= 0 && value < 24) {\n        return FixedObjects[value];\n      } else {\n        return (value >= -24 && value < 0) ? FixedObjects[0x20 - (value + 1)] :\n          FromObject((long)value);\n      }\n    }\n\n    /// <summary>Returns the CBOR true value or false value, depending on\n    /// \"value\".</summary>\n    /// <param name='value'>Either <c>true</c> or <c>false</c>.</param>\n    /// <returns>CBORObject.True if value is true; otherwise\n    /// CBORObject.False.</returns>\n    public static CBORObject FromObject(bool value) {\n      return value ? CBORObject.True : CBORObject.False;\n    }\n\n    /// <summary>Generates a CBOR object from a byte (0 to 255).</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// byte (from 0 to 255).</param>\n    /// <returns>A CBOR object generated from the given integer.</returns>\n    public static CBORObject FromObject(byte value) {\n      return FromObject(((int)value) & 0xff);\n    }\n\n    /// <summary>Generates a CBOR object from a 32-bit floating-point\n    /// number. The input value can be a not-a-number (NaN) value (such as\n    /// <c>Single.NaN</c> in DotNet or Float.NaN in Java); however, NaN\n    /// values have multiple forms that are equivalent for many\n    /// applications' purposes, and <c>Single.NaN</c> / <c>Float.NaN</c> is\n    /// only one of these equivalent forms. In fact,\n    /// <c>CBORObject.FromObject(Single.NaN)</c> or\n    /// <c>CBORObject.FromObject(Float.NaN)</c> could produce a\n    /// CBOR-encoded object that differs between DotNet and Java, because\n    /// <c>Single.NaN</c> / <c>Float.NaN</c> may have a different form in\n    /// DotNet and Java (for example, the NaN value's sign may be negative\n    /// in DotNet, but positive in Java).</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 32-bit floating-point number.</param>\n    /// <returns>A CBOR object generated from the given number.</returns>\n    public static CBORObject FromObject(float value) {\n      long doubleBits = CBORUtilities.SingleToDoublePrecision(\n          CBORUtilities.SingleToInt32Bits(value));\n      return new CBORObject(CBORObjectTypeDouble, doubleBits);\n    }\n\n    /// <summary>Generates a CBOR object from a 64-bit floating-point\n    /// number. The input value can be a not-a-number (NaN) value (such as\n    /// <c>Double.NaN</c> ); however, NaN values have multiple forms that\n    /// are equivalent for many applications' purposes, and\n    /// <c>Double.NaN</c> is only one of these equivalent forms. In fact,\n    /// <c>CBORObject.FromObject(Double.NaN)</c> could produce a\n    /// CBOR-encoded object that differs between DotNet and Java, because\n    /// <c>Double.NaN</c> may have a different form in DotNet and Java (for\n    /// example, the NaN value's sign may be negative in DotNet, but\n    /// positive in Java).</summary>\n    /// <param name='value'>The parameter <paramref name='value'/> is a\n    /// 64-bit floating-point number.</param>\n    /// <returns>A CBOR object generated from the given number.</returns>\n    public static CBORObject FromObject(double value) {\n      long doubleBits = CBORUtilities.DoubleToInt64Bits(value);\n      return new CBORObject(CBORObjectTypeDouble, doubleBits);\n    }\n\n    /// <summary>Generates a CBOR object from an array of 8-bit bytes; the\n    /// byte array is copied to a new byte array in this process. (This\n    /// method can't be used to decode CBOR data from a byte array; for\n    /// that, use the <b>DecodeFromBytes</b> method instead.).</summary>\n    /// <param name='bytes'>An array of 8-bit bytes; can be null.</param>\n    /// <returns>A CBOR object where each element of the given byte array\n    /// is copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(byte[] bytes) {\n      if (bytes == null) {\n        return CBORObject.Null;\n      }\n      var newvalue = new byte[bytes.Length];\n      Array.Copy(bytes, 0, newvalue, 0, bytes.Length);\n      return new CBORObject(CBORObjectTypeByteString, bytes);\n    }\n\n    /// <summary>Generates a CBOR object from an array of CBOR\n    /// objects.</summary>\n    /// <param name='array'>An array of CBOR objects.</param>\n    /// <returns>A CBOR object where each element of the given array is\n    /// copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(CBORObject[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = new List<CBORObject>();\n      foreach (CBORObject cbor in array) {\n        list.Add(cbor);\n      }\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    internal static CBORObject FromArrayBackedObject(CBORObject[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = PropertyMap.ListFromArray(array);\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Generates a CBOR object from an array of 32-bit\n    /// integers.</summary>\n    /// <param name='array'>An array of 32-bit integers.</param>\n    /// <returns>A CBOR array object where each element of the given array\n    /// is copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(int[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = new List<CBORObject>(array.Length ==\n        Int32.MaxValue ? array.Length : (array.Length + 1));\n      foreach (int i in array) {\n        list.Add(FromObject(i));\n      }\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Generates a CBOR object from an array of 64-bit\n    /// integers.</summary>\n    /// <param name='array'>An array of 64-bit integers.</param>\n    /// <returns>A CBOR array object where each element of the given array\n    /// is copied to a new array, or CBORObject.Null if the value is\n    /// null.</returns>\n    public static CBORObject FromObject(long[] array) {\n      if (array == null) {\n        return CBORObject.Null;\n      }\n      IList<CBORObject> list = new List<CBORObject>(array.Length ==\n        Int32.MaxValue ? array.Length : (array.Length + 1));\n      foreach (long i in array) {\n        list.Add(FromObject(i));\n      }\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Generates a CBORObject from an arbitrary object. See the\n    /// overload of this method that takes CBORTypeMapper and PODOptions\n    /// arguments.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object, which can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    public static CBORObject FromObject(object obj) {\n      return FromObject(obj, PODOptions.Default);\n    }\n\n    /// <summary>Generates a CBORObject from an arbitrary object. See the\n    /// overload of this method that takes CBORTypeMapper and PODOptions\n    /// arguments.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='options'>An object containing options to control how\n    /// certain objects are converted to CBOR objects.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    public static CBORObject FromObject(\n      object obj,\n      PODOptions options) {\n      return FromObject(obj, options, null, 0);\n    }\n\n    /// <summary>Generates a CBORObject from an arbitrary object. See the\n    /// overload of this method that takes CBORTypeMapper and PODOptions\n    /// arguments.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='mapper'>An object containing optional converters to\n    /// convert objects of certain types to CBOR objects.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='mapper'/> is null.</exception>\n    public static CBORObject FromObject(\n      object obj,\n      CBORTypeMapper mapper) {\n      if (mapper == null) {\n        throw new ArgumentNullException(nameof(mapper));\n      }\n      return FromObject(obj, PODOptions.Default, mapper, 0);\n    }\n\n    /// <summary><para>Generates a CBORObject from an arbitrary object,\n    /// using the given options to control how certain objects are\n    /// converted to CBOR objects. The following cases are checked in the\n    /// logical order given (rather than the strict order in which they are\n    /// implemented by this library):</para>\n    ///  <list><item><c>null</c>\n    ///  is\n    /// converted to <c>CBORObject.Null</c>\n    ///  .</item>\n    ///  <item>A\n    /// <c>CBORObject</c>\n    ///  is returned as itself.</item>\n    ///  <item>If the object\n    /// is of a type corresponding to a type converter mentioned in the\n    /// <paramref name='mapper'/> parameter, that converter will be used to\n    /// convert the object to a CBOR object. Type converters can be used to\n    /// override the default conversion behavior of almost any\n    /// object.</item>\n    ///  <item>A <c>char</c>\n    ///  is converted to an integer (from\n    /// 0 through 65535), and returns a CBOR object of that integer. (This\n    /// is a change in version 4.0 from previous versions, which converted\n    /// <c>char</c>\n    ///  , except surrogate code points from 0xd800 through\n    /// 0xdfff, into single-character text strings.)</item>\n    ///  <item>A\n    /// <c>bool</c>\n    ///  ( <c>boolean</c>\n    ///  in Java) is converted to\n    /// <c>CBORObject.True</c>\n    ///  or <c>CBORObject.False</c>\n    ///  .</item>\n    ///  <item>A\n    /// <c>byte</c>\n    ///  is converted to a CBOR integer from 0 through\n    /// 255.</item>\n    ///  <item>A primitive integer type ( <c>int</c>\n    ///  ,\n    /// <c>short</c>\n    ///  , <c>long</c>\n    ///  , as well as <c>sbyte</c>\n    ///  ,\n    /// <c>ushort</c>\n    ///  , <c>uint</c>\n    ///  , and <c>ulong</c>\n    ///  in.NET) is converted\n    /// to the corresponding CBOR integer.</item>\n    ///  <item>A primitive\n    /// floating-point type ( <c>float</c>\n    ///  , <c>double</c>\n    ///  , as well as\n    /// <c>decimal</c>\n    ///  in.NET) is converted to the corresponding CBOR\n    /// number.</item>\n    ///  <item>A <c>String</c>\n    ///  is converted to a CBOR text\n    /// string. To create a CBOR byte string object from <c>String</c>\n    ///  ,\n    /// see the example given in <see\n    /// cref='PeterO.Cbor.CBORObject.FromObject(System.Byte[])'/>.</item>\n    /// <item>In the.NET version, a nullable is converted to\n    /// <c>CBORObject.Null</c>\n    ///  if the nullable's value is <c>null</c>\n    ///  , or\n    /// converted according to the nullable's underlying type, if that type\n    /// is supported by this method.</item>\n    ///  <item>In the Java version, a\n    /// number of type <c>BigInteger</c>\n    ///  or <c>BigDecimal</c>\n    ///  is converted\n    /// to the corresponding CBOR number.</item>\n    ///  <item>A number of type\n    /// <c>EDecimal</c>\n    ///  , <c>EFloat</c>\n    ///  , <c>EInteger</c>\n    ///  , and\n    /// <c>ERational</c>\n    ///  in the <a\n    /// href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c>\n    /// </a>\n    ///  library (in .NET) or the <a\n    /// href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c>\n    /// </a>\n    ///  artifact (in Java) is converted to the corresponding CBOR\n    /// number.</item>\n    ///  <item>An array other than <c>byte[]</c>\n    ///  is converted\n    /// to a CBOR array. In the.NET version, a multidimensional array is\n    /// converted to an array of arrays.</item>\n    ///  <item>A <c>byte[]</c>\n    /// (1-dimensional byte array) is converted to a CBOR byte string; the\n    /// byte array is copied to a new byte array in this process. (This\n    /// method can't be used to decode CBOR data from a byte array; for\n    /// that, use the <b>DecodeFromBytes</b>\n    ///  method instead.)</item>\n    /// <item>An object implementing IDictionary (Map in Java) is converted\n    /// to a CBOR map containing the keys and values enumerated.</item>\n    /// <item>An object implementing IEnumerable (Iterable in Java) is\n    /// converted to a CBOR array containing the items enumerated.</item>\n    /// <item>An enumeration ( <c>Enum</c>\n    ///  ) object is converted to its\n    /// <i>underlying value</i>\n    ///  in the.NET version, or the result of its\n    /// <c>ordinal()</c>\n    ///  method in the Java version.</item>\n    ///  <item>An object\n    /// of type <c>DateTime</c>\n    ///  , <c>Uri</c>\n    ///  , or <c>Guid</c>\n    ///  ( <c>Date</c>\n    /// , <c>URI</c>\n    ///  , or <c>UUID</c>\n    ///  , respectively, in Java) will be\n    /// converted to a tagged CBOR object of the appropriate kind. By\n    /// default, <c>DateTime</c>\n    ///  / <c>Date</c>\n    ///  will be converted to a tag-0\n    /// string following the date format used in the Atom syndication\n    /// format, but this behavior can be changed by passing a suitable\n    /// CBORTypeMapper to this method, such as a CBORTypeMapper that\n    /// registers a CBORDateConverter for <c>DateTime</c>\n    ///  or <c>Date</c>\n    /// objects. See the examples.</item>\n    ///  <item>If the object is a type not\n    /// specially handled above, this method checks the <paramref\n    /// name='obj'/> parameter for eligible getters as follows:</item>\n    /// <item>(*) In the .NET version, eligible getters are the public,\n    /// nonstatic getters of read/write properties (and also those of\n    /// read-only properties in the case of a compiler-generated type or an\n    /// F# type). Eligible getters also include public, nonstatic, non-\n    /// <c>const</c>\n    ///  , non- <c>readonly</c>\n    ///  fields. If a class has two\n    /// properties and/or fields of the form \"X\" and \"IsX\", where \"X\" is\n    /// any name, or has multiple properties and/or fields with the same\n    /// name, those properties and fields are ignored.</item>\n    ///  <item>(*) In\n    /// the Java version, eligible getters are public, nonstatic methods\n    /// starting with \"get\" or \"is\" (either word followed by a character\n    /// other than a basic digit or lower-case letter, that is, other than\n    /// \"a\" to \"z\" or \"0\" to \"9\"), that take no parameters and do not\n    /// return void, except that methods named \"getClass\" are not eligible\n    /// getters. In addition, public, nonstatic, nonfinal fields are also\n    /// eligible getters. If a class has two otherwise eligible getters\n    /// (methods and/or fields) of the form \"isX\" and \"getX\", where \"X\" is\n    /// the same in both, or two such getters with the same name but\n    /// different return type, they are not eligible getters.</item>\n    /// <item>Then, the method returns a CBOR map with each eligible\n    /// getter's name or property name as each key, and with the\n    /// corresponding value returned by that getter as that key's value.\n    /// Before adding a key-value pair to the map, the key's name is\n    /// adjusted according to the rules described in the <see\n    /// cref='PeterO.Cbor.PODOptions'/> documentation. Note that for\n    /// security reasons, certain types are not supported even if they\n    /// contain eligible getters.</item>\n    ///  </list>\n    ///  <para><b>REMARK:</b>\n    ///  .NET\n    /// enumeration ( <c>Enum</c>\n    ///  ) constants could also have been\n    /// converted to text strings with <c>ToString()</c>\n    ///  , but that method\n    /// will return multiple names if the given Enum object is a\n    /// combination of Enum objects (e.g. if the object is\n    /// <c>FileAccess.Read | FileAccess.Write</c>\n    ///  ). More generally, if\n    /// Enums are converted to text strings, constants from Enum types with\n    /// the <c>Flags</c>\n    ///  attribute, and constants from the same Enum type\n    /// that share an underlying value, should not be passed to this\n    /// method.</para>\n    ///  </summary>\n    /// <param name='obj'>An arbitrary object to convert to a CBOR object.\n    /// <para><b>NOTE:</b>\n    ///  For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c>\n    ///  or <c>String</c>\n    ///  ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>\n    /// .</param>\n    /// <param name='mapper'>An object containing optional converters to\n    /// convert objects of certain types to CBOR objects. Can be\n    /// null.</param>\n    /// <param name='options'>An object containing options to control how\n    /// certain objects are converted to CBOR objects.</param>\n    /// <returns>A CBOR object corresponding to the given object. Returns\n    /// CBORObject.Null if the object is null.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>An error occurred while\n    /// converting the given object to a CBOR object.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the\n    /// DotNet version) uses a CBORTypeMapper to change how DateTime\n    /// objects are converted to CBOR. In this case, such objects are\n    /// converted to CBOR objects with tag 1 that store numbers giving the\n    /// number of seconds since the start of 1970.</para>\n    /// <code>var conv = new CBORTypeMapper().AddConverter(typeof(DateTime),\n    /// CBORDateConverter.TaggedNumber);\n    /// CBORObject obj = CBORObject.FromObject(DateTime.Now, conv);</code>\n    /// <para>The following example generates a CBOR object from a 64-bit\n    /// signed integer that is treated as a 64-bit unsigned integer (such\n    /// as DotNet's UInt64, which has no direct equivalent in the Java\n    /// language), in the sense that the value is treated as 2^64 plus the\n    /// original value if it's negative.</para>\n    /// <code>long x = -40L; &#x2f;&#x2a; Example 64-bit value treated as 2^64-40.&#x2a;&#x2f;\n    /// CBORObject obj = CBORObject.FromObject(\n    /// v &lt; 0 ? EInteger.FromInt32(1).ShiftLeft(64).Add(v) :\n    /// EInteger.FromInt64(v));</code>\n    /// <para>In the Java version, which has java.math.BigInteger, the\n    /// following can be used instead:</para>\n    /// <code>long x = -40L; &#x2f;&#x2a; Example 64-bit value treated as 2^64-40.&#x2a;&#x2f;\n    /// CBORObject obj = CBORObject.FromObject(\n    /// v &lt; 0 ? BigInteger.valueOf(1).shiftLeft(64).add(BigInteger.valueOf(v)) :\n    /// BigInteger.valueOf(v));</code>\n    /// </example>\n    public static CBORObject FromObject(\n      object obj,\n      CBORTypeMapper mapper,\n      PODOptions options) {\n      if (mapper == null) {\n        throw new ArgumentNullException(nameof(mapper));\n      }\n      return FromObject(obj, options, mapper, 0);\n    }\n\n    internal static CBORObject FromObject(\n      object obj,\n      PODOptions options,\n      CBORTypeMapper mapper,\n      int depth) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (depth >= 100) {\n        throw new CBORException(\"Nesting depth too high\");\n      }\n      if (obj == null) {\n        return CBORObject.Null;\n      }\n      if (obj is CBORObject) {\n        return FromObject((CBORObject)obj);\n      }\n      CBORObject objret;\n      if (mapper != null) {\n        objret = mapper.ConvertWithConverter(obj);\n        if (objret != null) {\n          return objret;\n        }\n      }\n      if (obj is string) {\n        return FromObject((string)obj);\n      }\n      if (obj is int) {\n        return FromObject((int)obj);\n      }\n      if (obj is long) {\n        return FromObject((long)obj);\n      }\n      var eif = obj as EInteger;\n      if (eif != null) {\n        return FromObject(eif);\n      }\n      var edf = obj as EDecimal;\n      if (edf != null) {\n        return FromObject(edf);\n      }\n      var eff = obj as EFloat;\n      if (eff != null) {\n        return FromObject(eff);\n      }\n      var erf = obj as ERational;\n      if (erf != null) {\n        return FromObject(erf);\n      }\n      if (obj is short) {\n        return FromObject((short)obj);\n      }\n      if (obj is char) {\n        return FromObject((int)(char)obj);\n      }\n      if (obj is bool) {\n        return FromObject((bool)obj);\n      }\n      if (obj is byte) {\n        return FromObject((byte)obj);\n      }\n      if (obj is float) {\n        return FromObject((float)obj);\n      }\n      if (obj is sbyte) {\n        return FromObject((sbyte)obj);\n      }\n      if (obj is ulong) {\n        return FromObject((ulong)obj);\n      }\n      if (obj is uint) {\n        return FromObject((uint)obj);\n      }\n      if (obj is ushort) {\n        return FromObject((ushort)obj);\n      }\n      if (obj is decimal) {\n        return FromObject((decimal)obj);\n      }\n      if (obj is double) {\n        return FromObject((double)obj);\n      }\n      byte[] bytearr = obj as byte[];\n      if (bytearr != null) {\n        return FromObject(bytearr);\n      }\n      if (obj is System.Collections.IDictionary) {\n        // IDictionary appears first because IDictionary includes IEnumerable\n        objret = CBORObject.NewMap();\n        System.Collections.IDictionary objdic =\n          (System.Collections.IDictionary)obj;\n        foreach (object keyPair in (System.Collections.IDictionary)objdic) {\n          System.Collections.DictionaryEntry\n          kvp = (System.Collections.DictionaryEntry)keyPair;\n          CBORObject objKey = CBORObject.FromObject(\n              kvp.Key,\n              options,\n              mapper,\n              depth + 1);\n          objret[objKey] = CBORObject.FromObject(\n              kvp.Value,\n              options,\n              mapper,\n              depth + 1);\n        }\n        return objret;\n      }\n      if (obj is Array) {\n        return PropertyMap.FromArray(obj, options, mapper, depth);\n      }\n      if (obj is System.Collections.IEnumerable) {\n        objret = CBORObject.NewArray();\n        foreach (object element in (System.Collections.IEnumerable)obj) {\n          objret.Add(\n            CBORObject.FromObject(\n              element,\n              options,\n              mapper,\n              depth + 1));\n        }\n        return objret;\n      }\n      if (obj is Enum) {\n        return FromObject(PropertyMap.EnumToObjectAsInteger((Enum)obj));\n      }\n      if (obj is DateTime) {\n        return new CBORDateConverter().ToCBORObject((DateTime)obj);\n      }\n      if (obj is Uri) {\n        return new CBORUriConverter().ToCBORObject((Uri)obj);\n      }\n      if (obj is Guid) {\n        return new CBORUuidConverter().ToCBORObject((Guid)obj);\n      }\n      objret = PropertyMap.FromObjectOther(obj);\n      if (objret != null) {\n        return objret;\n      }\n      objret = CBORObject.NewMap();\n      foreach (KeyValuePair<string, object> key in\n        PropertyMap.GetProperties(\n          obj,\n          options.UseCamelCase)) {\n        objret[key.Key] = CBORObject.FromObject(\n            key.Value,\n            options,\n            mapper,\n            depth + 1);\n      }\n      return objret;\n    }\n\n    /// <summary>Generates a CBOR object from this one, but gives the\n    /// resulting object a tag in addition to its existing tags (the new\n    /// tag is made the outermost tag).</summary>\n    /// <param name='bigintTag'>Tag number. The tag number 55799 can be\n    /// used to mark a \"self-described CBOR\" object. This document does not\n    /// attempt to list all CBOR tags and their meanings. An up-to-date\n    /// list can be found at the CBOR Tags registry maintained by the\n    /// Internet Assigned Numbers Authority(\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object with the same value as this one but given\n    /// the tag <paramref name='bigintTag'/> in addition to its existing\n    /// tags (the new tag is made the outermost tag).</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigintTag'/> is less than 0 or greater than\n    /// 2^64-1.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigintTag'/> is null.</exception>\n    public CBORObject WithTag(EInteger bigintTag) {\n      if (bigintTag == null) {\n        throw new ArgumentNullException(nameof(bigintTag));\n      }\n      if (bigintTag.Sign < 0) {\n        throw new ArgumentException(\"tagEInt's sign(\" + bigintTag.Sign +\n          \") is less than 0\");\n      }\n      if (bigintTag.CanFitInInt32()) {\n        // Low-numbered, commonly used tags\n        return this.WithTag(bigintTag.ToInt32Checked());\n      } else {\n        if (bigintTag.CompareTo(UInt64MaxValue) > 0) {\n          throw new ArgumentException(\n            \"tag more than 18446744073709551615 (\" + bigintTag + \")\");\n        }\n        var tagLow = 0;\n        var tagHigh = 0;\n        byte[] bytes = bigintTag.ToBytes(true);\n        for (var i = 0; i < Math.Min(4, bytes.Length); ++i) {\n          int b = ((int)bytes[i]) & 0xff;\n          tagLow = unchecked(tagLow | (((int)b) << (i * 8)));\n        }\n        for (int i = 4; i < Math.Min(8, bytes.Length); ++i) {\n          int b = ((int)bytes[i]) & 0xff;\n          tagHigh = unchecked(tagHigh | (((int)b) << (i * 8)));\n        }\n        return new CBORObject(this, tagLow, tagHigh);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary object and gives\n    /// the resulting object a tag in addition to its existing tags (the\n    /// new tag is made the outermost tag).</summary>\n    /// <param name='valueOb'>The parameter <paramref name='valueOb'/> is\n    /// an arbitrary object, which can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='bigintTag'>Tag number. The tag number 55799 can be\n    /// used to mark a \"self-described CBOR\" object. This document does not\n    /// attempt to list all CBOR tags and their meanings. An up-to-date\n    /// list can be found at the CBOR Tags registry maintained by the\n    /// Internet Assigned Numbers Authority(\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object where the object <paramref name='valueOb'/>\n    /// is converted to a CBOR object and given the tag <paramref\n    /// name='bigintTag'/>. If <paramref name='valueOb'/> is null, returns\n    /// a version of CBORObject.Null with the given tag.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigintTag'/> is less than 0 or greater than\n    /// 2^64-1.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigintTag'/> is null.</exception>\n    public static CBORObject FromObjectAndTag(\n      object valueOb,\n      EInteger bigintTag) {\n      if (bigintTag == null) {\n        throw new ArgumentNullException(nameof(bigintTag));\n      }\n      if (bigintTag.Sign < 0) {\n        throw new ArgumentException(\"tagEInt's sign(\" + bigintTag.Sign +\n          \") is less than 0\");\n      }\n      if (bigintTag.CompareTo(UInt64MaxValue) > 0) {\n        throw new ArgumentException(\n          \"tag more than 18446744073709551615 (\" + bigintTag + \")\");\n      }\n      return FromObject(valueOb).WithTag(bigintTag);\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary object and gives\n    /// the resulting object a tag in addition to its existing tags (the\n    /// new tag is made the outermost tag).</summary>\n    /// <param name='smallTag'>A 32-bit integer that specifies a tag\n    /// number. The tag number 55799 can be used to mark a \"self-described\n    /// CBOR\" object. This document does not attempt to list all CBOR tags\n    /// and their meanings. An up-to-date list can be found at the CBOR\n    /// Tags registry maintained by the Internet Assigned Numbers Authority\n    /// (\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object with the same value as this one but given\n    /// the tag <paramref name='smallTag'/> in addition to its existing\n    /// tags (the new tag is made the outermost tag).</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='smallTag'/> is less than 0.</exception>\n    public CBORObject WithTag(int smallTag) {\n      if (smallTag < 0) {\n        throw new ArgumentException(\"smallTag(\" + smallTag +\n          \") is less than 0\");\n      }\n      return new CBORObject(this, smallTag, 0);\n    }\n\n    /// <summary>Generates a CBOR object from an arbitrary object and gives\n    /// the resulting object a tag in addition to its existing tags (the\n    /// new tag is made the outermost tag).</summary>\n    /// <param name='valueObValue'>The parameter <paramref\n    /// name='valueObValue'/> is an arbitrary object, which can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='smallTag'>A 32-bit integer that specifies a tag\n    /// number. The tag number 55799 can be used to mark a \"self-described\n    /// CBOR\" object. This document does not attempt to list all CBOR tags\n    /// and their meanings. An up-to-date list can be found at the CBOR\n    /// Tags registry maintained by the Internet Assigned Numbers Authority\n    /// (\n    /// <i>iana.org/assignments/cbor-tags</i> ).</param>\n    /// <returns>A CBOR object where the object <paramref\n    /// name='valueObValue'/> is converted to a CBOR object and given the\n    /// tag <paramref name='smallTag'/>. If \"valueOb\" is null, returns a\n    /// version of CBORObject.Null with the given tag.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='smallTag'/> is less than 0.</exception>\n    public static CBORObject FromObjectAndTag(\n      object valueObValue,\n      int smallTag) {\n      if (smallTag < 0) {\n        throw new ArgumentException(\"smallTag(\" + smallTag +\n          \") is less than 0\");\n      }\n      return FromObject(valueObValue).WithTag(smallTag);\n    }\n\n    /// <summary>Creates a CBOR object from a simple value\n    /// number.</summary>\n    /// <param name='simpleValue'>The parameter <paramref\n    /// name='simpleValue'/> is a 32-bit signed integer.</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='simpleValue'/> is less than 0, greater than 255, or from 24\n    /// through 31.</exception>\n    public static CBORObject FromSimpleValue(int simpleValue) {\n      if (simpleValue < 0) {\n        throw new ArgumentException(\"simpleValue(\" + simpleValue +\n          \") is less than 0\");\n      }\n      if (simpleValue > 255) {\n        throw new ArgumentException(\"simpleValue(\" + simpleValue +\n          \") is more than \" + \"255\");\n      }\n      if (simpleValue >= 24 && simpleValue < 32) {\n        throw new ArgumentException(\"Simple value is from 24 to 31: \" +\n          simpleValue);\n      }\n      if (simpleValue < 32) {\n        return FixedObjects[0xe0 + simpleValue];\n      }\n      return new CBORObject(\n          CBORObjectTypeSimpleValue,\n          simpleValue);\n    }\n\n    /// <summary>Multiplies two CBOR numbers.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The product of the two numbers.</returns>\n    /// <exception cref='ArgumentException'>Either or both operands are not\n    /// numbers (as opposed to Not-a-Number, NaN).</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n        \"\\u0020.AsNumber()), and use the first number's .Multiply() method.\")]\n    public static CBORObject Multiply(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Multiply(b).ToCBORObject();\n    }\n\n    /// <summary>Creates a new empty CBOR array.</summary>\n    /// <returns>A new CBOR array.</returns>\n    public static CBORObject NewArray() {\n      return new CBORObject(CBORObjectTypeArray, new List<CBORObject>());\n    }\n\n    internal static CBORObject NewArray(CBORObject o1, CBORObject o2) {\n      var list = new List<CBORObject>(2);\n      list.Add(o1);\n      list.Add(o2);\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    internal static CBORObject NewArray(\n      CBORObject o1,\n      CBORObject o2,\n      CBORObject o3) {\n      var list = new List<CBORObject>(2);\n      list.Add(o1);\n      list.Add(o2);\n      list.Add(o3);\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    /// <summary>Creates a new empty CBOR map that stores its keys in an\n    /// undefined order.</summary>\n    /// <returns>A new CBOR map.</returns>\n    public static CBORObject NewMap() {\n      return new CBORObject(\n          CBORObjectTypeMap,\n          new SortedDictionary<CBORObject, CBORObject>());\n    }\n\n    /// <summary>Creates a new empty CBOR map that ensures that keys are\n    /// stored in the order in which they are first inserted.</summary>\n    /// <returns>A new CBOR map.</returns>\n    public static CBORObject NewOrderedMap() {\n      return new CBORObject(\n          CBORObjectTypeMap,\n          PropertyMap.NewOrderedDict());\n    }\n\n    /// <summary>\n    /// <para>Reads a sequence of objects in CBOR format from a data\n    /// stream. This method will read CBOR objects from the stream until\n    /// the end of the stream is reached or an error occurs, whichever\n    /// happens first.</para></summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <returns>An array containing the CBOR objects that were read from\n    /// the data stream. Returns an empty array if there is no unread data\n    /// in the stream.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null, or the parameter \"options\" is\n    /// null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data, including if the last CBOR object was\n    /// read only partially.</exception>\n    public static CBORObject[] ReadSequence(Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      var cborList = new List<CBORObject>();\n      while (true) {\n        CBORObject obj = Read(stream, AllowEmptyOptions);\n        if (obj == null) {\n          break;\n        }\n        cborList.Add(obj);\n      }\n      return (CBORObject[])cborList.ToArray();\n    }\n\n    /// <summary>\n    /// <para>Reads a sequence of objects in CBOR format from a data\n    /// stream. This method will read CBOR objects from the stream until\n    /// the end of the stream is reached or an error occurs, whichever\n    /// happens first.</para></summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <param name='options'>Specifies the options to use when decoding\n    /// the CBOR data stream. See CBOREncodeOptions for more information.\n    /// In this method, the AllowEmpty property is treated as set\n    /// regardless of the value of that property specified in this\n    /// parameter.</param>\n    /// <returns>An array containing the CBOR objects that were read from\n    /// the data stream. Returns an empty array if there is no unread data\n    /// in the stream.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null, or the parameter <paramref\n    /// name='options'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data, including if the last CBOR object was\n    /// read only partially.</exception>\n    public static CBORObject[] ReadSequence(Stream stream, CBOREncodeOptions\n      options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      CBOREncodeOptions opt = options;\n      if (!opt.AllowEmpty) {\n        opt = new CBOREncodeOptions(opt.ToString() + \";allowempty=1\");\n      }\n      var cborList = new List<CBORObject>();\n      while (true) {\n        CBORObject obj = Read(stream, opt);\n        if (obj == null) {\n          break;\n        }\n        cborList.Add(obj);\n      }\n      return (CBORObject[])cborList.ToArray();\n    }\n\n    /// <summary>\n    /// <para>Reads an object in CBOR format from a data stream. This\n    /// method will read from the stream until the end of the CBOR object\n    /// is reached or an error occurs, whichever happens\n    /// first.</para></summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <returns>A CBOR object that was read.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data.</exception>\n    public static CBORObject Read(Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      try {\n        var reader = new CBORReader(stream);\n        return reader.Read();\n      } catch (IOException ex) {\n        throw new CBORException(\"I/O error occurred.\", ex);\n      }\n    }\n\n    /// <summary>Reads an object in CBOR format from a data stream, using\n    /// the specified options to control the decoding process. This method\n    /// will read from the stream until the end of the CBOR object is\n    /// reached or an error occurs, whichever happens first.</summary>\n    /// <param name='stream'>A readable data stream.</param>\n    /// <param name='options'>Specifies the options to use when decoding\n    /// the CBOR data stream. See CBOREncodeOptions for more\n    /// information.</param>\n    /// <returns>A CBOR object that was read.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>There was an error in\n    /// reading or parsing the data.</exception>\n    public static CBORObject Read(Stream stream, CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      try {\n        var reader = new CBORReader(stream, options);\n        return reader.Read();\n      } catch (IOException ex) {\n        throw new CBORException(\"I/O error occurred.\", ex);\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a data stream in JavaScript\n    /// Object Notation (JSON) format. The JSON stream may begin with a\n    /// byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be\n    /// in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (In previous\n    /// versions, only UTF-8 was allowed.). (This behavior may change to\n    /// supporting only UTF-8, with or without a byte order mark, in\n    /// version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must contain a single JSON object and not\n    /// multiple objects.</param>\n    /// <returns>A CBOR object.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream\n    /// contains invalid encoding or is not in JSON format.</exception>\n    public static CBORObject ReadJSON(Stream stream) {\n      return ReadJSON(stream, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a list of CBOR objects from a data stream in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464).\n    /// The data stream must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must either be empty or begin with a\n    /// record separator byte (0x1e).</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream is not\n    /// empty and does not begin with a record separator byte\n    /// (0x1e).</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] ReadJSONSequence(Stream stream) {\n      return ReadJSONSequence(stream, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a data stream in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process. The JSON stream may begin with a\n    /// byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be\n    /// in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (In previous\n    /// versions, only UTF-8 was allowed.).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must contain a single JSON object and not\n    /// multiple objects.</param>\n    /// <param name='options'>Contains options to control the JSON decoding\n    /// process. This method uses only the AllowDuplicateKeys property of\n    /// this object.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream\n    /// contains invalid encoding or is not in JSON format.</exception>\n    [Obsolete(\"Instead, use .ReadJSON\\u0028stream, new\" +\n        \"\\u0020JSONOptions\\u0028\\\"allowduplicatekeys=true\\\")) or\" +\n        \"\\u0020.ReadJSON\\u0028stream, new\" +\n        \"\\u0020JSONOptions\\u0028\\\"allowduplicatekeys=false\\\")), as\" +\n        \"\\u0020appropriate.\")]\n    public static CBORObject ReadJSON(\n      Stream stream,\n      CBOREncodeOptions options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      var jsonoptions = new JSONOptions(options.AllowDuplicateKeys ?\n        \"allowduplicatekeys=1\" : \"allowduplicatekeys=0\");\n      return ReadJSON(stream, jsonoptions);\n    }\n\n    /// <summary>Generates a list of CBOR objects from a data stream in\n    /// JavaScript Object Notation (JSON) text sequence format (RFC 7464).\n    /// The data stream must be in UTF-8 encoding and may not begin with a\n    /// byte-order mark (U+FEFF).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must either be empty or begin with a\n    /// record separator byte (0x1e).</param>\n    /// <param name='jsonoptions'>Specifies options to control how JSON\n    /// texts in the stream are decoded to CBOR. See the JSONOptions\n    /// class.</param>\n    /// <returns>A list of CBOR objects read from the JSON sequence.\n    /// Objects that could not be parsed are replaced with <c>null</c> (as\n    /// opposed to <c>CBORObject.Null</c> ) in the given list.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream is not\n    /// empty and does not begin with a record separator byte\n    /// (0x1e).</exception>\n    /// <remarks>Generally, each JSON text in a JSON text sequence is\n    /// written as follows: Write a record separator byte (0x1e), then\n    /// write the JSON text in UTF-8 (without a byte order mark, U+FEFF),\n    /// then write the line feed byte (0x0a). RFC 7464, however, uses a\n    /// more liberal syntax for parsing JSON text sequences.</remarks>\n    public static CBORObject[] ReadJSONSequence(Stream stream, JSONOptions\n      jsonoptions) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      CharacterInputWithCount reader;\n      reader = new CharacterInputWithCount(\n        new CharacterReader(stream, 0, true, true));\n      try {\n        var nextchar = new int[1];\n        CBORObject[] objlist = CBORJson.ParseJSONSequence(\n            reader,\n            jsonoptions,\n            nextchar);\n        if (nextchar[0] != -1) {\n          reader.RaiseError(\"End of data stream not reached\");\n        }\n        return objlist;\n      } catch (CBORException ex) {\n        var ioex = ex.InnerException as IOException;\n        if (ioex != null) {\n          throw ioex;\n        }\n        throw;\n      }\n    }\n\n    /// <summary>Generates a CBOR object from a data stream in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process. The JSON stream may begin with a\n    /// byte-order mark (U+FEFF). Since version 2.0, the JSON stream can be\n    /// in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (In previous\n    /// versions, only UTF-8 was allowed.). (This behavior may change to\n    /// supporting only UTF-8, with or without a byte order mark, in\n    /// version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</summary>\n    /// <param name='stream'>A readable data stream. The sequence of bytes\n    /// read from the data stream must contain a single JSON object and not\n    /// multiple objects.</param>\n    /// <param name='jsonoptions'>Specifies options to control how the JSON\n    /// stream is decoded to CBOR. See the JSONOptions class.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The data stream\n    /// contains invalid encoding or is not in JSON format.</exception>\n    public static CBORObject ReadJSON(\n      Stream stream,\n      JSONOptions jsonoptions) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      CharacterInputWithCount reader;\n      reader = new CharacterInputWithCount(\n        new CharacterReader(stream, 2, true));\n      try {\n        var nextchar = new int[1];\n        CBORObject obj = CBORJson.ParseJSONValue(\n            reader,\n            jsonoptions,\n            nextchar);\n        if (nextchar[0] != -1) {\n          reader.RaiseError(\"End of data stream not reached\");\n        }\n        return obj;\n      } catch (CBORException ex) {\n        var ioex = ex.InnerException as IOException;\n        if (ioex != null) {\n          throw ioex;\n        }\n        throw;\n      }\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array in JSON format. The entire byte\n    /// array must contain a single JSON object and not multiple objects.\n    /// The byte array may begin with a byte-order mark (U+FEFF). The byte\n    /// array can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is\n    /// detected by assuming that the first character read must be a\n    /// byte-order mark or a nonzero basic character (U+0001 to U+007F).\n    /// (This behavior may change to supporting only UTF-8, with or without\n    /// a byte order mark, in version 5.0 or later, perhaps with an option\n    /// to restore the previous behavior of also supporting UTF-16 and\n    /// UTF-32.).</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    public static CBORObject FromJSONBytes(byte[] bytes) {\n      // TODO: In next major version, consider supporting UTF-8 only\n      return FromJSONBytes(bytes, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array in JSON format. The entire byte\n    /// array must contain a single JSON object and not multiple objects.\n    /// The byte array may begin with a byte-order mark (U+FEFF). The byte\n    /// array can be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is\n    /// detected by assuming that the first character read must be a\n    /// byte-order mark or a nonzero basic character (U+0001 to U+007F).\n    /// (This behavior may change to supporting only UTF-8, with or without\n    /// a byte order mark, in version 5.0 or later, perhaps with an option\n    /// to restore the previous behavior of also supporting UTF-16 and\n    /// UTF-32.).</param>\n    /// <param name='jsonoptions'>Specifies options to control how the JSON\n    /// data is decoded to CBOR. See the JSONOptions class.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> or <paramref name='jsonoptions'/> is\n    /// null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    public static CBORObject FromJSONBytes(\n      byte[] bytes,\n      JSONOptions jsonoptions) {\n      // TODO: In next major version, consider supporting UTF-8 only\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      if (bytes.Length == 0) {\n        throw new CBORException(\"Byte array is empty\");\n      }\n      return FromJSONBytes(bytes, 0, bytes.Length, jsonoptions);\n    }\n\n    /// <summary>\n    /// <para>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format.</para>\n    /// <para>If a JSON object has duplicate keys, a CBORException is\n    /// thrown.</para>\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array, the specified portion of which is\n    /// in JSON format. The specified portion of the byte array must\n    /// contain a single JSON object and not multiple objects. The portion\n    /// may begin with a byte-order mark (U+FEFF). The portion can be in\n    /// UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (This behavior may\n    /// change to supporting only UTF-8, with or without a byte order mark,\n    /// in version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='bytes'/> begins.</param>\n    /// <param name='count'>The length, in bytes, of the desired portion of\n    /// <paramref name='bytes'/> (but not more than <paramref\n    /// name='bytes'/> 's length).</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> is null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='bytes'/> 's length, or <paramref\n    /// name='bytes'/> 's length minus <paramref name='offset'/> is less\n    /// than <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONBytes(byte[] bytes, int offset, int\n      count) {\n      return FromJSONBytes(bytes, offset, count, JSONOptions.Default);\n    }\n\n    /// <summary>Generates a CBOR object from a byte array in JavaScript\n    /// Object Notation (JSON) format, using the specified options to\n    /// control the decoding process.\n    /// <para>Note that if a CBOR object is converted to JSON with\n    /// <c>ToJSONBytes</c>, then the JSON is converted back to CBOR with\n    /// this method, the new CBOR object will not necessarily be the same\n    /// as the old CBOR object, especially if the old CBOR object uses data\n    /// types not supported in JSON, such as integers in map\n    /// keys.</para></summary>\n    /// <param name='bytes'>A byte array, the specified portion of which is\n    /// in JSON format. The specified portion of the byte array must\n    /// contain a single JSON object and not multiple objects. The portion\n    /// may begin with a byte-order mark (U+FEFF). The portion can be in\n    /// UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected by\n    /// assuming that the first character read must be a byte-order mark or\n    /// a nonzero basic character (U+0001 to U+007F). (This behavior may\n    /// change to supporting only UTF-8, with or without a byte order mark,\n    /// in version 5.0 or later, perhaps with an option to restore the\n    /// previous behavior of also supporting UTF-16 and UTF-32.).</param>\n    /// <param name='offset'>An index, starting at 0, showing where the\n    /// desired portion of <paramref name='bytes'/> begins.</param>\n    /// <param name='count'>The length, in bytes, of the desired portion of\n    /// <paramref name='bytes'/> (but not more than <paramref\n    /// name='bytes'/> 's length).</param>\n    /// <param name='jsonoptions'>Specifies options to control how the JSON\n    /// data is decoded to CBOR. See the JSONOptions class.</param>\n    /// <returns>A CBOR object containing the JSON data decoded.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bytes'/> or <paramref name='jsonoptions'/> is\n    /// null.</exception>\n    /// <exception cref='PeterO.Cbor.CBORException'>The byte array contains\n    /// invalid encoding or is not in JSON format.</exception>\n    /// <exception cref='ArgumentException'>Either <paramref\n    /// name='offset'/> or <paramref name='count'/> is less than 0 or\n    /// greater than <paramref name='bytes'/> 's length, or <paramref\n    /// name='bytes'/> 's length minus <paramref name='offset'/> is less\n    /// than <paramref name='count'/>.</exception>\n    public static CBORObject FromJSONBytes(\n      byte[] bytes,\n      int offset,\n      int count,\n      JSONOptions jsonoptions) {\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (jsonoptions == null) {\n        throw new ArgumentNullException(nameof(jsonoptions));\n      }\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (offset < 0) {\n        throw new ArgumentException(\"offset (\" + offset + \") is not greater\" +\n          \"\\u0020or equal to 0\");\n      }\n      if (offset > bytes.Length) {\n        throw new ArgumentException(\"offset (\" + offset + \") is not less or\" +\n          \"\\u0020equal to \" + bytes.Length);\n      }\n      if (count < 0) {\n        throw new ArgumentException(\"count (\" + count + \") is not greater or\" +\n          \"\\u0020equal to 0\");\n      }\n      if (count > bytes.Length) {\n        throw new ArgumentException(\"count (\" + count + \") is not less or\" +\n          \"\\u0020equal to \" + bytes.Length);\n      }\n      if (bytes.Length - offset < count) {\n        throw new ArgumentException(\"bytes's length minus \" + offset + \" (\" +\n          (bytes.Length - offset) + \") is not greater or equal to \" + count);\n      }\n      if (count == 0) {\n        throw new CBORException(\"Byte array is empty\");\n      }\n      if (bytes[offset] >= 0x01 && bytes[offset] <= 0x7f && count >= 2 &&\n        bytes[offset + 1] != 0) {\n        // UTF-8 JSON bytes\n        return CBORJson2.ParseJSONValue(\n            bytes,\n            offset,\n            offset + count,\n            jsonoptions);\n      } else {\n        // Other than UTF-8 without byte order mark\n        try {\n          using (var ms = new MemoryStream(bytes, offset, count)) {\n            return ReadJSON(ms, jsonoptions);\n          }\n        } catch (IOException ex) {\n          throw new CBORException(ex.Message, ex);\n        }\n      }\n    }\n\n    /// <summary>Finds the remainder that results when a CBORObject object\n    /// is divided by the value of a CBOR object.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The remainder of the two numbers.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n        \"\\u0020.AsNumber()), and use the first number's .Remainder() method.\")]\n    public static CBORObject Remainder(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Remainder(b).ToCBORObject();\n    }\n\n    /// <summary>Finds the difference between two CBOR number\n    /// objects.</summary>\n    /// <param name='first'>The parameter <paramref name='first'/> is a\n    /// CBOR object.</param>\n    /// <param name='second'>The parameter <paramref name='second'/> is a\n    /// CBOR object.</param>\n    /// <returns>The difference of the two objects.</returns>\n    /// <exception cref='ArgumentException'>Either or both operands are not\n    /// numbers (as opposed to Not-a-Number, NaN).</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='first'/> or <paramref name='second'/> is null.</exception>\n    [Obsolete(\"Instead, convert both CBOR objects to numbers (with\" +\n\n        \"\\u0020.AsNumber()), and use the first number's .Subtract() method.\")]\n    public static CBORObject Subtract(CBORObject first, CBORObject second) {\n      if (first == null) {\n        throw new ArgumentNullException(nameof(first));\n      }\n      if (second == null) {\n        throw new ArgumentNullException(nameof(second));\n      }\n      CBORNumber a = CBORNumber.FromCBORObject(first);\n      if (a == null) {\n        throw new ArgumentException(nameof(first) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      CBORNumber b = CBORNumber.FromCBORObject(second);\n      if (b == null) {\n        throw new ArgumentException(nameof(second) + \"does not represent a\" +\n          \"\\u0020number\");\n      }\n      return a.Subtract(b).ToCBORObject();\n    }\n\n    /// <summary>\n    /// <para>Writes a text string in CBOR format to a data stream. The\n    /// string will be encoded using definite-length encoding regardless of\n    /// its length.</para></summary>\n    /// <param name='str'>The string to write. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(string str, Stream stream) {\n      Write(str, stream, CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes a text string in CBOR format to a data stream,\n    /// using the given options to control the encoding process.</summary>\n    /// <param name='str'>The string to write. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <param name='options'>Options for encoding the data to\n    /// CBOR.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(\n      string str,\n      Stream stream,\n      CBOREncodeOptions options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (str == null) {\n        stream.WriteByte(0xf6); // Write null instead of string\n      } else {\n        if (!options.UseIndefLengthStrings || options.Ctap2Canonical) {\n          // NOTE: Length of a String object won't be higher than the maximum\n          // allowed for definite-length strings\n          long codePointLength = DataUtilities.GetUtf8Length(str, true);\n          WritePositiveInt64(3, codePointLength, stream);\n          DataUtilities.WriteUtf8(str, stream, true);\n        } else {\n          WriteStreamedString(str, stream);\n        }\n      }\n    }\n\n    /// <summary>Writes a binary floating-point number in CBOR format to a\n    /// data stream, as though it were converted to a CBOR object via\n    /// CBORObject.FromObject(EFloat) and then written out.</summary>\n    /// <param name='bignum'>An arbitrary-precision binary floating-point\n    /// number. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(EFloat bignum, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (bignum == null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      if ((bignum.IsZero && bignum.IsNegative) || bignum.IsInfinity() ||\n        bignum.IsNaN()) {\n        Write(CBORObject.FromObject(bignum), stream);\n        return;\n      }\n      EInteger exponent = bignum.Exponent;\n      if (exponent.CanFitInInt64()) {\n        stream.WriteByte(0xc5); // tag 5\n        stream.WriteByte(0x82); // array, length 2\n      } else if (exponent.GetSignedBitLengthAsInt64() > 64) {\n        stream.WriteByte(0xd9); // tag 265\n        stream.WriteByte(0x01);\n        stream.WriteByte(0x09);\n        stream.WriteByte(0x82); // array, length 2\n      } else {\n        stream.WriteByte(0xc5); // tag 5\n        stream.WriteByte(0x82); // array, length 2\n      }\n      Write(\n        bignum.Exponent,\n        stream);\n      Write(bignum.Mantissa, stream);\n    }\n\n    /// <summary>Writes a rational number in CBOR format to a data stream,\n    /// as though it were converted to a CBOR object via\n    /// CBORObject.FromObject(ERational) and then written out.</summary>\n    /// <param name='rational'>An arbitrary-precision rational number. Can\n    /// be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(ERational rational, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (rational == null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      if (!rational.IsFinite || (rational.IsNegative && rational.IsZero)) {\n        Write(CBORObject.FromObject(rational), stream);\n        return;\n      }\n      stream.WriteByte(0xd8); // tag 30\n      stream.WriteByte(0x1e);\n      stream.WriteByte(0x82); // array, length 2\n      Write(rational.Numerator, stream);\n      Write(\n        rational.Denominator,\n        stream);\n    }\n\n    /// <summary>Writes a decimal floating-point number in CBOR format to a\n    /// data stream, as though it were converted to a CBOR object via\n    /// CBORObject.FromObject(EDecimal) and then written out.</summary>\n    /// <param name='bignum'>The arbitrary-precision decimal number to\n    /// write. Can be null.</param>\n    /// <param name='stream'>Stream to write to.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(EDecimal bignum, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (bignum == null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      if (!bignum.IsFinite || (bignum.IsNegative && bignum.IsZero)) {\n        Write(CBORObject.FromObject(bignum), stream);\n        return;\n      }\n      EInteger exponent = bignum.Exponent;\n      if (exponent.CanFitInInt64()) {\n        stream.WriteByte(0xc4); // tag 4\n        stream.WriteByte(0x82); // array, length 2\n      } else if (exponent.GetSignedBitLengthAsInt64() > 64) {\n        stream.WriteByte(0xd9); // tag 264\n        stream.WriteByte(0x01);\n        stream.WriteByte(0x08);\n        stream.WriteByte(0x82); // array, length 2\n      } else {\n        stream.WriteByte(0xc4); // tag 4\n        stream.WriteByte(0x82); // array, length 2\n      }\n      Write(exponent, stream);\n      Write(bignum.Mantissa, stream);\n    }\n\n    private static byte[] EIntegerBytes(EInteger ei) {\n      if (ei.IsZero) {\n        return new byte[] { 0 };\n      }\n      if (ei.Sign < 0) {\n        ei = ei.Add(1).Negate();\n      }\n      byte[] bytes = ei.ToBytes(false);\n      var index = 0;\n      while (index < bytes.Length && bytes[index] == 0) {\n        ++index;\n      }\n      if (index > 0) {\n        var newBytes = new byte[bytes.Length - index];\n        Array.Copy(bytes, index, newBytes, 0, newBytes.Length);\n        return newBytes;\n      }\n      return bytes;\n    }\n\n    /// <summary>Writes a arbitrary-precision integer in CBOR format to a\n    /// data stream.</summary>\n    /// <param name='bigint'>Arbitrary-precision integer to write. Can be\n    /// null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(EInteger bigint, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if ((object)bigint == (object)null) {\n        stream.WriteByte(0xf6);\n        return;\n      }\n      var datatype = 0;\n      if (bigint.Sign < 0) {\n        datatype = 1;\n        bigint = bigint.Add(EInteger.One);\n        bigint = -(EInteger)bigint;\n      }\n      if (bigint.CanFitInInt64()) {\n        // If the arbitrary-precision integer is representable as a long and in\n        // major type 0 or 1, write that major type\n        // instead of as a bignum\n        WritePositiveInt64(datatype, bigint.ToInt64Checked(), stream);\n      } else {\n        // Get a byte array of the arbitrary-precision integer's value,\n        // since shifting and doing AND operations is\n        // slow with large EIntegers\n        byte[] bytes = bigint.ToBytes(true);\n        int byteCount = bytes.Length;\n        while (byteCount > 0 && bytes[byteCount - 1] == 0) {\n          // Ignore trailing zero bytes\n          --byteCount;\n        }\n        if (byteCount != 0) {\n          int half = byteCount >> 1;\n          int right = byteCount - 1;\n          for (var i = 0; i < half; ++i, --right) {\n            byte value = bytes[i];\n            bytes[i] = bytes[right];\n            bytes[right] = value;\n          }\n        }\n        switch (byteCount) {\n          case 0:\n            stream.WriteByte((byte)(datatype << 5));\n            return;\n          case 1:\n            WritePositiveInt(datatype, ((int)bytes[0]) & 0xff, stream);\n            break;\n          case 2:\n            stream.WriteByte((byte)((datatype << 5) | 25));\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 3:\n            stream.WriteByte((byte)((datatype << 5) | 26));\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 4:\n            stream.WriteByte((byte)((datatype << 5) | 26));\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 5:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.WriteByte((byte)0);\n            stream.WriteByte((byte)0);\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 6:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.WriteByte((byte)0);\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 7:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.WriteByte((byte)0);\n            stream.Write(bytes, 0, byteCount);\n            break;\n          case 8:\n            stream.WriteByte((byte)((datatype << 5) | 27));\n            stream.Write(bytes, 0, byteCount);\n            break;\n          default: stream.WriteByte((datatype == 0) ?\n              (byte)0xc2 : (byte)0xc3);\n            WritePositiveInt(2, byteCount, stream);\n            stream.Write(bytes, 0, byteCount);\n            break;\n        }\n      }\n    }\n\n    /// <summary>Writes a 64-bit signed integer in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(long value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (value >= 0) {\n        WritePositiveInt64(0, value, stream);\n      } else {\n        ++value;\n        value = -value; // Will never overflow\n        WritePositiveInt64(1, value, stream);\n      }\n    }\n\n    /// <summary>Writes a 32-bit signed integer in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(int value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      var type = 0;\n      if (value < 0) {\n        ++value;\n        value = -value;\n        type = 0x20;\n      }\n      if (value < 24) {\n        stream.WriteByte((byte)(value | type));\n      } else if (value <= 0xff) {\n        byte[] bytes = { (byte)(24 | type), (byte)(value & 0xff) };\n        stream.Write(bytes, 0, 2);\n      } else if (value <= 0xffff) {\n        byte[] bytes = {\n          (byte)(25 | type), (byte)((value >> 8) & 0xff),\n          (byte)(value & 0xff),\n        };\n        stream.Write(bytes, 0, 3);\n      } else {\n        byte[] bytes = {\n          (byte)(26 | type), (byte)((value >> 24) & 0xff),\n          (byte)((value >> 16) & 0xff), (byte)((value >> 8) & 0xff),\n          (byte)(value & 0xff),\n        };\n        stream.Write(bytes, 0, 5);\n      }\n    }\n\n    /// <summary>Writes a 16-bit signed integer in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(short value, Stream stream) {\n      Write((long)value, stream);\n    }\n\n    /// <summary>Writes a Boolean value in CBOR format to a data\n    /// stream.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(bool value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      stream.WriteByte(value ? (byte)0xf5 : (byte)0xf4);\n    }\n\n    /// <summary>Writes a byte (0 to 255) in CBOR format to a data stream.\n    /// If the value is less than 24, writes that byte. If the value is 25\n    /// to 255, writes the byte 24, then this byte's value.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(byte value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if ((((int)value) & 0xff) < 24) {\n        stream.WriteByte(value);\n      } else {\n        stream.WriteByte((byte)24);\n        stream.WriteByte(value);\n      }\n    }\n\n    /// <summary>Writes a 32-bit floating-point number in CBOR format to a\n    /// data stream. The number is written using the shortest\n    /// floating-point encoding possible; this is a change from previous\n    /// versions.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(float value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      WriteFloatingPointBits(\n        stream,\n        CBORUtilities.SingleToInt32Bits(value),\n        4,\n        true);\n    }\n\n    /// <summary>Writes a 64-bit floating-point number in CBOR format to a\n    /// data stream. The number is written using the shortest\n    /// floating-point encoding possible; this is a change from previous\n    /// versions.</summary>\n    /// <param name='value'>The value to write.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    public static void Write(double value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      WriteFloatingPointBits(\n        stream,\n        CBORUtilities.DoubleToInt64Bits(value),\n        8,\n        true);\n    }\n\n    /// <summary>Writes a CBOR object to a CBOR data stream.</summary>\n    /// <param name='value'>The value to write. Can be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    public static void Write(CBORObject value, Stream stream) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (value == null) {\n        stream.WriteByte(0xf6);\n      } else {\n        value.WriteTo(stream);\n      }\n    }\n\n    /// <summary>\n    /// <para>Writes a CBOR object to a CBOR data stream. See the\n    /// three-parameter Write method that takes a\n    /// CBOREncodeOptions.</para></summary>\n    /// <param name='objValue'>The arbitrary object to be serialized. Can\n    /// be null.</param>\n    /// <param name='stream'>A writable data stream.</param>\n    public static void Write(object objValue, Stream stream) {\n      Write(objValue, stream, CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes an arbitrary object to a CBOR data stream, using\n    /// the specified options for controlling how the object is encoded to\n    /// CBOR data format. If the object is convertible to a CBOR map or a\n    /// CBOR object that contains CBOR maps, the order in which the keys to\n    /// those maps are written out to the data stream is undefined unless\n    /// the map was created using the NewOrderedMap method. The example\n    /// code given in\n    /// <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can\n    /// be used to write out certain keys of a CBOR map in a given order.\n    /// Currently, the following objects are supported:\n    /// <list type=''>\n    /// <item>Lists of CBORObject.</item>\n    /// <item>Maps of CBORObject. The order in which the keys to the map\n    /// are written out to the data stream is undefined unless the map was\n    /// created using the NewOrderedMap method.</item>\n    /// <item>Null.</item>\n    /// <item>Byte arrays, which will always be written as definite-length\n    /// byte strings.</item>\n    /// <item>String objects. The strings will be encoded using\n    /// definite-length encoding regardless of their length.</item>\n    /// <item>Any object accepted by the FromObject static\n    /// methods.</item></list></summary>\n    /// <param name='objValue'>The arbitrary object to be serialized. Can\n    /// be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='output'>A writable data stream.</param>\n    /// <param name='options'>CBOR options for encoding the CBOR object to\n    /// bytes.</param>\n    /// <exception cref='ArgumentException'>The object's type is not\n    /// supported.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> or <paramref name='output'/> is null.</exception>\n    public static void Write(\n      object objValue,\n      Stream output,\n      CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (output == null) {\n        throw new ArgumentNullException(nameof(output));\n      }\n      if (objValue == null) {\n        output.WriteByte(0xf6);\n        return;\n      }\n      if (options.Ctap2Canonical) {\n        FromObject(objValue).WriteTo(output, options);\n        return;\n      }\n      byte[] data = objValue as byte[];\n      if (data != null) {\n        WritePositiveInt(3, data.Length, output);\n        output.Write(data, 0, data.Length);\n        return;\n      }\n      if (objValue is IList<CBORObject>) {\n        WriteObjectArray(\n          (IList<CBORObject>)objValue,\n          output,\n          options);\n        return;\n      }\n      if (objValue is IDictionary<CBORObject, CBORObject>) {\n        WriteObjectMap(\n          (IDictionary<CBORObject, CBORObject>)objValue,\n          output,\n          options);\n        return;\n      }\n      FromObject(objValue).WriteTo(output, options);\n    }\n\n    /// <summary>Converts an arbitrary object to a text string in\n    /// JavaScript Object Notation (JSON) format, as in the ToJSONString\n    /// method, and writes that string to a data stream in UTF-8. If the\n    /// object is convertible to a CBOR map, or to a CBOR object that\n    /// contains CBOR maps, the order in which the keys to those maps are\n    /// written out to the JSON string is undefined unless the map was\n    /// created using the NewOrderedMap method. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object. Can be null.\n    /// <para><b>NOTE:</b> For security reasons, whenever possible, an\n    /// application should not base this parameter on user input or other\n    /// externally supplied data unless the application limits this\n    /// parameter's inputs to types specially handled by this method (such\n    /// as <c>int</c> or <c>String</c> ) and/or to plain-old-data types\n    /// (POCO or POJO types) within the control of the application. If the\n    /// plain-old-data type references other data types, those types should\n    /// likewise meet either criterion above.</para>.</param>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static void WriteJSON(object obj, Stream outputStream) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (obj == null) {\n        outputStream.Write(ValueNullBytes, 0, ValueNullBytes.Length);\n        return;\n      }\n      if (obj is bool) {\n        if ((bool)obj) {\n          outputStream.Write(ValueTrueBytes, 0, ValueTrueBytes.Length);\n          return;\n        }\n        outputStream.Write(ValueFalseBytes, 0, ValueFalseBytes.Length);\n        return;\n      }\n      CBORObject.FromObject(obj).WriteJSONTo(outputStream);\n    }\n\n    /// <summary>Gets this object's absolute value.</summary>\n    /// <returns>This object's absolute without its negative\n    /// sign.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    [Obsolete(\"Instead, convert this object to a number \\u0028with\" +\n        \"\\u0020.AsNumber\\u0028)), and use that number's .Abs\\u0028) method.\")]\n    public CBORObject Abs() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"This object is not a number.\");\n      }\n      object oldItem = cn.GetValue();\n      object newItem = cn.GetNumberInterface().Abs(oldItem);\n      if (oldItem == newItem) {\n        return this;\n      }\n      if (newItem is EDecimal) {\n        return CBORObject.FromObject((EDecimal)newItem);\n      }\n      if (newItem is EInteger) {\n        return CBORObject.FromObject((EInteger)newItem);\n      }\n      if (newItem is EFloat) {\n        return CBORObject.FromObject((EFloat)newItem);\n      }\n      var rat = newItem as ERational;\n      return (rat != null) ? CBORObject.FromObject(rat) : ((oldItem ==\n            newItem) ? this : CBORObject.FromObject(newItem));\n    }\n\n    /// <summary>\n    /// <para>Adds a new key and its value to this CBOR map, or adds the\n    /// value if the key doesn't exist.</para>\n    /// <para>NOTE: This method can't be used to add a tag to an existing\n    /// CBOR object. To create a CBOR object with a given tag, call the\n    /// <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object\n    /// and the desired tag number to that method.</para></summary>\n    /// <param name='key'>An object representing the key, which will be\n    /// converted to a CBORObject. Can be null, in which case this value is\n    /// converted to CBORObject.Null.</param>\n    /// <param name='valueOb'>An object representing the value, which will\n    /// be converted to a CBORObject. Can be null, in which case this value\n    /// is converted to CBORObject.Null.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='key'/> already exists in this map.</exception>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='key'/> or <paramref name='valueOb'/> has an unsupported\n    /// type.</exception>\n    public CBORObject Add(object key, object valueOb) {\n      if (this.Type == CBORType.Map) {\n        CBORObject mapKey;\n        CBORObject mapValue;\n        if (key == null) {\n          mapKey = CBORObject.Null;\n        } else {\n          mapKey = key as CBORObject;\n          mapKey = mapKey ?? CBORObject.FromObject(key);\n        }\n        if (valueOb == null) {\n          mapValue = CBORObject.Null;\n        } else {\n          mapValue = valueOb as CBORObject;\n          mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n        }\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        if (map.ContainsKey(mapKey)) {\n          throw new ArgumentException(\"Key already exists\");\n        }\n        map.Add(\n          mapKey,\n          mapValue);\n      } else {\n        throw new InvalidOperationException(\"Not a map\");\n      }\n      return this;\n    }\n\n    /// <summary><para>Adds a new object to the end of this array. (Used to\n    /// throw ArgumentNullException on a null reference, but now converts\n    /// the null reference to CBORObject.Null, for convenience with the\n    /// Object overload of this method).</para>\n    ///  <para>NOTE: This method\n    /// can't be used to add a tag to an existing CBOR object. To create a\n    /// CBOR object with a given tag, call the\n    /// <c>CBORObject.FromObjectAndTag</c>\n    ///  method and pass the CBOR object\n    /// and the desired tag number to that method.</para>\n    ///  </summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is a CBOR\n    /// object.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not an\n    /// array.</exception>\n    /// <example>\n    /// <para>The following example creates a CBOR array and adds several\n    /// CBOR objects, one of which has a custom CBOR tag, to that array.\n    /// Note the chaining behavior made possible by this method.</para>\n    /// <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False)\n    /// .Add(CBORObject.FromObject(5)) .Add(CBORObject.FromObject(\"text\n    /// string\")) .Add(CBORObject.FromObjectAndTag(9999, 1));</code>\n    ///  .\n    /// </example>\n    public CBORObject Add(CBORObject obj) {\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        list.Add(obj);\n        return this;\n      }\n      throw new InvalidOperationException(\"Not an array\");\n    }\n\n    /// <summary><para>Converts an object to a CBOR object and adds it to\n    /// the end of this array.</para>\n    ///  <para>NOTE: This method can't be used\n    /// to add a tag to an existing CBOR object. To create a CBOR object\n    /// with a given tag, call the <c>CBORObject.FromObjectAndTag</c>\n    /// method and pass the CBOR object and the desired tag number to that\n    /// method.</para>\n    ///  </summary>\n    /// <param name='obj'>A CBOR object (or an object convertible to a CBOR\n    /// object) to add to this CBOR array.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This instance is not an\n    /// array.</exception>\n    /// <exception cref='ArgumentException'>The type of <paramref\n    /// name='obj'/> is not supported.</exception>\n    /// <example>\n    /// <para>The following example creates a CBOR array and adds several\n    /// CBOR objects, one of which has a custom CBOR tag, to that array.\n    /// Note the chaining behavior made possible by this method.</para>\n    /// <code>CBORObject obj = CBORObject.NewArray() .Add(CBORObject.False) .Add(5)\n    /// .Add(\"text string\") .Add(CBORObject.FromObjectAndTag(9999, 1));</code>\n    ///  .\n    /// </example>\n    public CBORObject Add(object obj) {\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        list.Add(CBORObject.FromObject(obj));\n        return this;\n      }\n      throw new InvalidOperationException(\"Not an array\");\n    }\n\n    /// <summary>Converts this object to an arbitrary-precision integer.\n    /// See the ToObject overload taking a type for more\n    /// information.</summary>\n    /// <returns>The closest arbitrary-precision integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value is infinity\n    /// or not-a-number (NaN).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<PeterO.Numbers.EInteger>\\u0028) in\" +\n        \"\\u0020.NET\" +\n        \" or \\u0020.ToObject\\u0028com.upokecenter.numbers.EInteger.class) in\" +\n        \"\\u0020Java.\")]\n    public EInteger AsEInteger() {\n      return (EInteger)this.ToObject(typeof(EInteger));\n    }\n\n    /// <summary>Returns false if this object is a CBOR false, null, or\n    /// undefined value (whether or not the object has tags); otherwise,\n    /// true.</summary>\n    /// <returns>False if this object is a CBOR false, null, or undefined\n    /// value; otherwise, true.</returns>\n    public bool AsBoolean() {\n      return !this.IsFalse && !this.IsNull && !this.IsUndefined;\n    }\n\n    /// <summary>Converts this object to a byte (0 to 255). Floating point\n    /// values are converted to integers by discarding their fractional\n    /// parts.</summary>\n    /// <returns>The closest byte-sized integer to this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a byte (would be less than 0 or greater than 255 when\n    /// converted to an integer by discarding its fractional\n    /// part).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<byte>\\u0028) in\" +\n        \"\\u0020.NET\" + \" or \\u0020.ToObject\\u0028Byte.class) in\" +\n        \"\\u0020Java.\")]\n    public byte AsByte() {\n      return (byte)this.AsInt32(0, 255);\n    }\n\n    internal byte AsByteLegacy() {\n      return (byte)this.AsInt32(0, 255);\n    }\n\n    /// <summary>Converts this object to a 64-bit floating point\n    /// number.</summary>\n    /// <returns>The closest 64-bit floating point number to this object.\n    /// The return value can be positive infinity or negative infinity if\n    /// this value exceeds the range of a 64-bit floating point\n    /// number.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    public double AsDouble() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"Not a number type\");\n      }\n      return cn.GetNumberInterface().AsDouble(cn.GetValue());\n    }\n\n    /// <summary>Converts this object to a decimal number.</summary>\n    /// <returns>A decimal number for this object's value.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<PeterO.Numbers.EDecimal>\\u0028) in\" +\n\n        \"\\u0020.NET\" +\n        \" or \\u0020.ToObject\\u0028com.upokecenter.numbers.EDecimal.class) in\" +\n        \"\\u0020Java.\")]\n    public EDecimal AsEDecimal() {\n      return (EDecimal)this.ToObject(typeof(EDecimal));\n    }\n\n    /// <summary>Converts this object to an arbitrary-precision binary\n    /// floating point number. See the ToObject overload taking a type for\n    /// more information.</summary>\n    /// <returns>An arbitrary-precision binary floating-point number for\n    /// this object's value.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    [Obsolete(\"Instead, use \" +\n        \".ToObject<PeterO.Numbers.EFloat>\\u0028) in .NET\" +\n\n        \" or \\u0020.ToObject\\u0028com.upokecenter.numbers.EFloat.class) in\" +\n        \"\\u0020Java.\")]\n    public EFloat AsEFloat() {\n      return (EFloat)this.ToObject(typeof(EFloat));\n    }\n\n    /// <summary>Converts this object to a rational number. See the\n    /// ToObject overload taking a type for more information.</summary>\n    /// <returns>A rational number for this object's value.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers).</exception>\n    [Obsolete(\"Instead, use \" + \".ToObject<PeterO.Numbers.ERational>\" +\n        \"\\u0028) in .NET\" +\n        \"\\u0020or .ToObject\\u0028com.upokecenter.numbers.ERational.class) in\" +\n        \"\\u0020Java.\")]\n    public ERational AsERational() {\n      return (ERational)this.ToObject(typeof(ERational));\n    }\n\n    /// <summary>Converts this object to a 16-bit signed integer. Floating\n    /// point values are converted to integers by discarding their\n    /// fractional parts.</summary>\n    /// <returns>The closest 16-bit signed integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 16-bit signed integer.</exception>\n    [Obsolete(\"Instead, use the following:\" +\n        \"\\u0020\\u0028cbor.AsNumber().ToInt16Checked()), or\" +\n        \"\\u0020.ToObject<short>() in\" + \"\\u0020.NET.\")]\n    public short AsInt16() {\n      return (short)this.AsInt32(Int16.MinValue, Int16.MaxValue);\n    }\n\n    /// <summary>Converts this object to a 32-bit signed integer if this\n    /// CBOR object's type is Integer. This method disregards the tags this\n    /// object has, if any.</summary>\n    /// <returns>The 32-bit signed integer stored by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.Integer</c>\n    /// .</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 32-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 32-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt32(99999);\n    /// if (obj.CanValueFitInInt32()) { /* Not an Int32;\n    /// handle the error */ Console.WriteLine(\"Not a 32-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt32Value()); }</code>\n    ///  .\n    /// </example>\n    public int AsInt32Value() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger: {\n          var longValue = (long)this.ThisItem;\n          if (longValue < Int32.MinValue || longValue > Int32.MaxValue) {\n            throw new OverflowException();\n          }\n          return checked((int)longValue);\n        }\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.ToInt32Checked();\n        }\n        default: throw new InvalidOperationException(\"Not an integer type\");\n      }\n    }\n\n    /// <summary>Converts this object to a 64-bit signed integer if this\n    /// CBOR object's type is Integer. This method disregards the tags this\n    /// object has, if any.</summary>\n    /// <returns>The 64-bit signed integer stored by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.Integer</c>\n    /// .</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 64-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 64-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt64(99999);\n    /// if (obj.CanValueFitInInt64()) {\n    /// &#x2f;&#x2a; Not an Int64; handle the error&#x2a;&#x2f;\n    /// Console.WriteLine(\"Not a 64-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt64Value()); }</code>\n    ///  .\n    /// </example>\n    public long AsInt64Value() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger:\n          return (long)this.ThisItem;\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.ToInt64Checked();\n        }\n        default: throw new InvalidOperationException(\"Not an integer type\");\n      }\n    }\n\n    /// <summary>Returns whether this CBOR object stores an integer\n    /// (CBORType.Integer) within the range of a 64-bit signed integer.\n    /// This method disregards the tags this object has, if any.</summary>\n    /// <returns><c>true</c> if this CBOR object stores an integer\n    /// (CBORType.Integer) whose value is at least -(2^63) and less than\n    /// 2^63; otherwise, <c>false</c>.</returns>\n    public bool CanValueFitInInt64() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger:\n          return true;\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.CanFitInInt64();\n        }\n        default: return false;\n      }\n    }\n\n    /// <summary>Returns whether this CBOR object stores an integer\n    /// (CBORType.Integer) within the range of a 32-bit signed integer.\n    /// This method disregards the tags this object has, if any.</summary>\n    /// <returns><c>true</c> if this CBOR object stores an integer\n    /// (CBORType.Integer) whose value is at least -(2^31) and less than\n    /// 2^31; otherwise, <c>false</c>.</returns>\n    public bool CanValueFitInInt32() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger: {\n          var elong = (long)this.ThisItem;\n          return elong >= Int32.MinValue && elong <= Int32.MaxValue;\n        }\n        case CBORObjectTypeEInteger: {\n          var ei = (EInteger)this.ThisItem;\n          return ei.CanFitInInt32();\n        }\n        default:\n          return false;\n      }\n    }\n\n    /// <summary>Converts this object to an arbitrary-precision integer if\n    /// this CBOR object's type is Integer. This method disregards the tags\n    /// this object has, if any. (Note that CBOR stores untagged integers\n    /// at least -(2^64) and less than 2^64.).</summary>\n    /// <returns>The integer stored by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.Integer</c>.</exception>\n    public EInteger AsEIntegerValue() {\n      switch (this.ItemType) {\n        case CBORObjectTypeInteger:\n          return EInteger.FromInt64((long)this.ThisItem);\n        case CBORObjectTypeEInteger:\n          return (EInteger)this.ThisItem;\n        default: throw new InvalidOperationException(\"Not an integer type\");\n      }\n    }\n\n    /// <summary>Converts this object to the bits of a 64-bit\n    /// floating-point number if this CBOR object's type is FloatingPoint.\n    /// This method disregards the tags this object has, if any.</summary>\n    /// <returns>The bits of a 64-bit floating-point number stored by this\n    /// object. The most significant bit is the sign (set means negative,\n    /// clear means nonnegative); the next most significant 11 bits are the\n    /// exponent area; and the remaining bits are the significand area. If\n    /// all the bits of the exponent area are set and the significand area\n    /// is 0, this indicates infinity. If all the bits of the exponent area\n    /// are set and the significand area is other than 0, this indicates\n    /// not-a-number (NaN).</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.FloatingPoint</c>.</exception>\n    public long AsDoubleBits() {\n      switch (this.Type) {\n        case CBORType.FloatingPoint:\n          return (long)this.ThisItem;\n        default: throw new InvalidOperationException(\"Not a floating-point\" +\n            \"\\u0020type\");\n      }\n    }\n\n    /// <summary>Converts this object to a 64-bit floating-point number if\n    /// this CBOR object's type is FloatingPoint. This method disregards\n    /// the tags this object has, if any.</summary>\n    /// <returns>The 64-bit floating-point number stored by this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not <c>CBORType.FloatingPoint</c>.</exception>\n    public double AsDoubleValue() {\n      switch (this.Type) {\n        case CBORType.FloatingPoint:\n          return CBORUtilities.Int64BitsToDouble((long)this.ThisItem);\n        default: throw new InvalidOperationException(\"Not a floating-point\" +\n            \"\\u0020type\");\n      }\n    }\n\n    /// <summary>Converts this object to a CBOR number. (NOTE: To determine\n    /// whether this method call can succeed, call the <b>IsNumber</b>\n    /// property (isNumber() method in Java) before calling this\n    /// method.).</summary>\n    /// <returns>The number represented by this object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    public CBORNumber AsNumber() {\n      CBORNumber num = CBORNumber.FromCBORObject(this);\n      if (num == null) {\n        throw new InvalidOperationException(\"Not a number type\");\n      }\n      return num;\n    }\n\n    /// <summary>Converts this object to a 32-bit signed integer.\n    /// Non-integer number values are converted to integers by discarding\n    /// their fractional parts. (NOTE: To determine whether this method\n    /// call can succeed, call <b>AsNumber().CanTruncatedIntFitInInt32</b>\n    /// before calling this method. See the example.).</summary>\n    /// <returns>The closest 32-bit signed integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 32-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 32-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt32(99999);\n    /// if (obj.AsNumber().CanTruncatedIntFitInInt32()) {\n    /// &#x2f;&#x2a; Not an Int32; handle the error &#x2a;&#x2f;\n    /// Console.WriteLine(\"Not a 32-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt32()); }</code>\n    ///  .\n    /// </example>\n    public int AsInt32() {\n      return this.AsInt32(Int32.MinValue, Int32.MaxValue);\n    }\n\n    /// <summary>Converts this object to a 64-bit signed integer.\n    /// Non-integer numbers are converted to integers by discarding their\n    /// fractional parts. (NOTE: To determine whether this method call can\n    /// succeed, call <b>AsNumber().CanTruncatedIntFitInInt64</b>\n    ///  before\n    /// calling this method. See the example.).</summary>\n    /// <returns>The closest 64-bit signed integer to this\n    /// object.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    /// <exception cref='OverflowException'>This object's value exceeds the\n    /// range of a 64-bit signed integer.</exception>\n    /// <example>\n    /// <para>The following example code (originally written in C# for\n    /// the.NET Framework) shows a way to check whether a given CBOR object\n    /// stores a 64-bit signed integer before getting its value.</para>\n    /// <code>CBORObject obj = CBORObject.FromInt64(99999);\n    /// if (obj.IsIntegral &amp;&amp; obj.AsNumber().CanFitInInt64()) {\n    /// &#x2f;&#x2a; Not an Int64; handle the error &#x2a;&#x2f;\n    /// Console.WriteLine(\"Not a 64-bit integer.\"); } else {\n    /// Console.WriteLine(\"The value is \" + obj.AsInt64()); }</code>\n    ///  .\n    /// </example>\n    [Obsolete(\"Instead, use the following:\" +\n        \"\\u0020\\u0028cbor.AsNumber().ToInt64Checked()), or .ToObject<long>()\" +\n        \"\\u0020in .NET.\")]\n    public long AsInt64() {\n      CBORNumber cn = this.AsNumber();\n      return cn.GetNumberInterface().AsInt64(cn.GetValue());\n    }\n\n    /// <summary>Converts this object to a 32-bit floating point\n    /// number.</summary>\n    /// <returns>The closest 32-bit floating point number to this object.\n    /// The return value can be positive infinity or negative infinity if\n    /// this object's value exceeds the range of a 32-bit floating point\n    /// number.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    public float AsSingle() {\n      CBORNumber cn = this.AsNumber();\n      return cn.GetNumberInterface().AsSingle(cn.GetValue());\n    }\n\n    /// <summary>Gets the value of this object as a text string.</summary>\n    /// <returns>Gets this object's string.</returns>\n    /// <exception cref='InvalidOperationException'>This object's type is\n    /// not a text string (for the purposes of this method, infinity and\n    /// not-a-number values, but not <c>CBORObject.Null</c>, are\n    /// considered numbers). To check the CBOR object for null before\n    /// conversion, use the following idiom (originally written in C# for\n    /// the.NET version): <c>(cbor == null || cbor.IsNull) ? null :\n    /// cbor.AsString()</c>.</exception>\n    /// <remarks>This method is not the \"reverse\" of the <c>FromObject</c>\n    /// method in the sense that FromObject can take either a text string\n    /// or <c>null</c>, but this method can accept only text strings. The\n    /// <c>ToObject</c> method is closer to a \"reverse\" version to\n    /// <c>FromObject</c> than the <c>AsString</c> method:\n    /// <c>ToObject&lt;String&gt;(cbor)</c> in DotNet, or\n    /// <c>ToObject(String.class)</c> in Java, will convert a CBOR object\n    /// to a DotNet or Java String if it represents a text string, or to\n    /// <c>null</c> if <c>IsNull</c> returns <c>true</c> for the CBOR\n    /// object, and will fail in other cases.</remarks>\n    public string AsString() {\n      int type = this.ItemType;\n      switch (type) {\n        case CBORObjectTypeTextString:\n        case CBORObjectTypeTextStringAscii: {\n          return (string)this.ThisItem;\n        }\n        case CBORObjectTypeTextStringUtf8: {\n          return DataUtilities.GetUtf8String((byte[])this.ThisItem, false);\n        }\n        default:\n          throw new InvalidOperationException(\"Not a text string type\");\n      }\n    }\n\n    /// <summary>Returns whether this object's value can be converted to a\n    /// 64-bit floating point number without its value being rounded to\n    /// another numerical value.</summary>\n    /// <returns><c>true</c> if this object's value can be converted to a\n    /// 64-bit floating point number without its value being rounded to\n    /// another numerical value, or if this is a not-a-number value, even\n    /// if the value's diagnostic information can't fit in a 64-bit\n    /// floating point number; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanFitInDouble()).\")]\n    public bool CanFitInDouble() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanFitInDouble(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's numerical value is an\n    /// integer, is -(2^31) or greater, and is less than 2^31.</summary>\n    /// <returns><c>true</c> if this object's numerical value is an\n    /// integer, is -(2^31) or greater, and is less than 2^31; otherwise,\n    /// <c>false</c>.</returns>\n    [Obsolete(\"Instead, use \" +\n        \".CanValueFitInInt32(), if the application allows\" +\n\n        \"\\u0020only CBOR integers, or \\u0028cbor.IsNumber &&\" +\n        \"cbor.AsNumber().CanFitInInt32()),\" +\n        \"\\u0020 if the application allows any CBOR object convertible to an \" +\n        \"integer.\")]\n    public bool CanFitInInt32() {\n      if (!this.CanFitInInt64()) {\n        return false;\n      }\n      long v = this.AsInt64();\n      return v >= Int32.MinValue && v <= Int32.MaxValue;\n    }\n\n    /// <summary>Returns whether this object's numerical value is an\n    /// integer, is -(2^63) or greater, and is less than 2^63.</summary>\n    /// <returns><c>true</c> if this object's numerical value is an\n    /// integer, is -(2^63) or greater, and is less than 2^63; otherwise,\n    /// <c>false</c>.</returns>\n    [Obsolete(\"Instead, use \" +\n        \"CanValueFitInInt64(), if the application allows\" +\n\n        \"\\u0020only CBOR integers, or \\u0028cbor.IsNumber &&\" +\n        \"cbor.AsNumber().CanFitInInt64()),\" +\n        \"\\u0020 if the application allows any CBOR object convertible to an \" +\n        \"integer.\")]\n    public bool CanFitInInt64() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanFitInInt64(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's value can be converted to a\n    /// 32-bit floating point number without its value being rounded to\n    /// another numerical value.</summary>\n    /// <returns><c>true</c> if this object's value can be converted to a\n    /// 32-bit floating point number without its value being rounded to\n    /// another numerical value, or if this is a not-a-number value, even\n    /// if the value's diagnostic information can' t fit in a 32-bit\n    /// floating point number; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanFitInSingle()).\")]\n    public bool CanFitInSingle() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanFitInSingle(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^31) or\n    /// greater, and less than 2^31.</summary>\n    /// <returns><c>true</c> if this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^31) or\n    /// greater, and less than 2^31; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.CanValueFitInInt32()\" +\n        \"\\u0020if only integers of any tag are allowed, or\" +\n        \"\\u0020\\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanTruncatedIntFitInInt32()).\")]\n    public bool CanTruncatedIntFitInInt32() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return (cn != null) &&\n        cn.GetNumberInterface().CanTruncatedIntFitInInt32(cn.GetValue());\n    }\n\n    /// <summary>Returns whether this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^63) or\n    /// greater, and less than 2^63.</summary>\n    /// <returns><c>true</c> if this object's value, converted to an\n    /// integer by discarding its fractional part, would be -(2^63) or\n    /// greater, and less than 2^63; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.CanValueFitInInt64()\" +\n        \"\\u0020if only integers of any tag are allowed, or\" +\n        \"\\u0020\\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().CanTruncatedIntFitInInt64()).\")]\n    public bool CanTruncatedIntFitInInt64() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return cn != null &&\n        cn.GetNumberInterface().CanTruncatedIntFitInInt64(cn.GetValue());\n    }\n\n    private static string Chop(string str) {\n      return str.Substring(0, Math.Min(100, str.Length));\n    }\n\n    /// <summary>Compares two CBOR objects. This implementation was changed\n    /// in version 4.0.\n    /// <para>In this implementation:</para>\n    /// <list type=''>\n    /// <item>The null pointer (null reference) is considered less than any\n    /// other object.</item>\n    /// <item>If the two objects are both integers (CBORType.Integer) both\n    /// floating-point values, both byte strings, both simple values\n    /// (including True and False), or both text strings, their CBOR\n    /// encodings (as though EncodeToBytes were called on each integer) are\n    /// compared as though by a byte-by-byte comparison. (This means, for\n    /// example, that positive integers sort before negative\n    /// integers).</item>\n    /// <item>If both objects have a tag, they are compared first by the\n    /// tag's value then by the associated item (which itself can have a\n    /// tag).</item>\n    /// <item>If both objects are arrays, they are compared item by item.\n    /// In this case, if the arrays have different numbers of items, the\n    /// array with more items is treated as greater than the other\n    /// array.</item>\n    /// <item>If both objects are maps, their key-value pairs, sorted by\n    /// key in accordance with this method, are compared, where each pair\n    /// is compared first by key and then by value. In this case, if the\n    /// maps have different numbers of key-value pairs, the map with more\n    /// pairs is treated as greater than the other map.</item>\n    /// <item>If the two objects have different types, the object whose\n    /// type comes first in the order of untagged integers, untagged byte\n    /// strings, untagged text strings, untagged arrays, untagged maps,\n    /// tagged objects, untagged simple values (including True and False)\n    /// and untagged floating point values sorts before the other\n    /// object.</item></list>\n    /// <para>This method is consistent with the Equals\n    /// method.</para></summary>\n    /// <param name='other'>A value to compare with.</param>\n    /// <returns>A negative number, if this value is less than the other\n    /// object; or 0, if both values are equal; or a positive number, if\n    /// this value is less than the other object or if the other object is\n    /// null.\n    /// <para>This implementation returns a positive number if <paramref\n    /// name='other'/> is null, to conform to the.NET definition of\n    /// CompareTo. This is the case even in the Java version of this\n    /// library, for consistency's sake, even though implementations of\n    /// <c>Comparable.compareTo()</c> in Java ought to throw an exception\n    /// if they receive a null argument rather than treating null as less\n    /// or greater than any object.</para>.</returns>\n    public int CompareTo(CBORObject other) {\n      if (other == null) {\n        return 1;\n      }\n      if (this == other) {\n        return 0;\n      }\n      int typeA = this.itemtypeValue;\n      int typeB = other.itemtypeValue;\n      object objA = this.itemValue;\n      object objB = other.itemValue;\n      // DebugUtility.Log(\"typeA=\" + typeA);\n      // DebugUtility.Log(\"typeB=\" + typeB);\n      // DebugUtility.Log(\"objA=\" + Chop(this.ItemType ==\n      // CBORObjectTypeMap ? \"(map)\" :\n      // this.ToString()));\n      // DebugUtility.Log(\"objB=\" + Chop(other.ItemType ==\n      // CBORObjectTypeMap ? \"(map)\" :\n      // other.ToString()));\n      int cmp;\n      if (typeA == typeB) {\n        switch (typeA) {\n          case CBORObjectTypeInteger: {\n            var a = (long)objA;\n            var b = (long)objB;\n            if (a >= 0 && b >= 0) {\n              cmp = (a == b) ? 0 : ((a < b) ? -1 : 1);\n            } else if (a <= 0 && b <= 0) {\n              cmp = (a == b) ? 0 : ((a < b) ? 1 : -1);\n            } else if (a < 0 && b >= 0) {\n              // NOTE: Negative integers sort after\n              // nonnegative integers in the bytewise\n              // ordering of CBOR encodings\n              cmp = 1;\n            } else {\n              #if DEBUG\n              if (!(a >= 0 && b < 0)) {\n                throw new InvalidOperationException(\n                  \"doesn't satisfy a>= 0\" +\n                  \"\\u0020b<0\");\n              }\n              #endif\n              cmp = -1;\n            }\n            break;\n          }\n          case CBORObjectTypeEInteger: {\n            cmp = CBORUtilities.ByteArrayCompare(\n                this.EncodeToBytes(),\n                other.EncodeToBytes());\n            break;\n          }\n          case CBORObjectTypeByteString:\n          case CBORObjectTypeTextStringUtf8: {\n            cmp = CBORUtilities.ByteArrayCompareLengthFirst((byte[])objA,\n                (byte[])objB);\n            break;\n          }\n          case CBORObjectTypeTextStringAscii: {\n            var strA = (string)objA;\n            var strB = (string)objB;\n            int alen = strA.Length;\n            int blen = strB.Length;\n            cmp = (alen < blen) ? (-1) : ((alen > blen) ? 1 :\nString.CompareOrdinal(strA, strB));\n            break;\n          }\n          case CBORObjectTypeTextString: {\n            var strA = (string)objA;\n            var strB = (string)objB;\n            cmp = CBORUtilities.CompareStringsAsUtf8LengthFirst(\n                strA,\n                strB);\n            break;\n          }\n          case CBORObjectTypeArray: {\n            cmp = ListCompare(\n                (List<CBORObject>)objA,\n                (List<CBORObject>)objB);\n            break;\n          }\n          case CBORObjectTypeMap:\n            cmp = MapCompare(\n                (IDictionary<CBORObject, CBORObject>)objA,\n                (IDictionary<CBORObject, CBORObject>)objB);\n            break;\n          case CBORObjectTypeTagged:\n            cmp = this.MostOuterTag.CompareTo(other.MostOuterTag);\n            if (cmp == 0) {\n              cmp = ((CBORObject)objA).CompareTo((CBORObject)objB);\n            }\n            break;\n          case CBORObjectTypeSimpleValue: {\n            var valueA = (int)objA;\n            var valueB = (int)objB;\n            cmp = (valueA == valueB) ? 0 : ((valueA < valueB) ? -1 : 1);\n            break;\n          }\n          case CBORObjectTypeDouble: {\n            cmp = CBORUtilities.ByteArrayCompare(\n                GetDoubleBytes(this.AsDoubleBits(), 0),\n                GetDoubleBytes(other.AsDoubleBits(), 0));\n            break;\n          }\n          default: throw new InvalidOperationException(\"Unexpected data \" +\n              \"type\");\n        }\n      } else if ((typeB == CBORObjectTypeInteger && typeA ==\n          CBORObjectTypeEInteger) || (typeA == CBORObjectTypeInteger && typeB ==\n          CBORObjectTypeEInteger)) {\n        cmp = CBORUtilities.ByteArrayCompare(\n            this.EncodeToBytes(),\n            other.EncodeToBytes());\n      } else if ((typeB == CBORObjectTypeTextString || typeB ==\nCBORObjectTypeTextStringAscii) && typeA ==\n        CBORObjectTypeTextStringUtf8) {\n        cmp = -CBORUtilities.CompareUtf16Utf8LengthFirst(\n            (string)objB,\n            (byte[])objA);\n      } else if ((typeA == CBORObjectTypeTextString || typeA ==\nCBORObjectTypeTextStringAscii) && typeB ==\n        CBORObjectTypeTextStringUtf8) {\n        cmp = CBORUtilities.CompareUtf16Utf8LengthFirst(\n            (string)objA,\n            (byte[])objB);\n      } else if ((typeA == CBORObjectTypeTextString && typeB ==\nCBORObjectTypeTextStringAscii) ||\n         (typeB == CBORObjectTypeTextString && typeA ==\nCBORObjectTypeTextStringAscii)) {\n        cmp = -CBORUtilities.CompareStringsAsUtf8LengthFirst(\n            (string)objB,\n            (string)objA);\n      } else if ((typeA == CBORObjectTypeTextString || typeA ==\nCBORObjectTypeTextStringAscii) && typeB ==\n        CBORObjectTypeTextStringUtf8) {\n        cmp = CBORUtilities.CompareUtf16Utf8LengthFirst(\n            (string)objA,\n            (byte[])objB);\n      } else {\n        int ta = (typeA == CBORObjectTypeTextStringUtf8 || typeA ==\nCBORObjectTypeTextStringAscii) ?\n          CBORObjectTypeTextString : typeA;\n        int tb = (typeB == CBORObjectTypeTextStringUtf8 || typeB ==\nCBORObjectTypeTextStringAscii) ?\n          CBORObjectTypeTextString : typeB;\n        /* NOTE: itemtypeValue numbers are ordered such that they\n        // correspond to the lexicographical order of their CBOR encodings\n        // (with the exception of Integer and EInteger together,\n        // and TextString/TextStringUtf8) */\n        cmp = (ta < tb) ? -1 : 1;\n      }\n      // DebugUtility.Log(\" -> \" + (cmp));\n      return cmp;\n    }\n\n    /// <summary>Compares this object and another CBOR object, ignoring the\n    /// tags they have, if any. See the CompareTo method for more\n    /// information on the comparison function.</summary>\n    /// <param name='other'>A value to compare with.</param>\n    /// <returns>Less than 0, if this value is less than the other object;\n    /// or 0, if both values are equal; or greater than 0, if this value is\n    /// less than the other object or if the other object is\n    /// null.</returns>\n    public int CompareToIgnoreTags(CBORObject other) {\n      return (other == null) ? 1 : ((this == other) ? 0 :\n          this.Untag().CompareTo(other.Untag()));\n    }\n\n    /// <summary>Determines whether a value of the given key exists in this\n    /// object.</summary>\n    /// <param name='objKey'>The parameter <paramref name='objKey'/> is an\n    /// arbitrary object.</param>\n    /// <returns><c>true</c> if the given key is found, or <c>false</c> if\n    /// the given key is not found or this object is not a map.</returns>\n    public bool ContainsKey(object objKey) {\n      return (this.Type == CBORType.Map) ?\n        this.ContainsKey(CBORObject.FromObject(objKey)) : false;\n    }\n\n    /// <summary>Determines whether a value of the given key exists in this\n    /// object.</summary>\n    /// <param name='key'>An object that serves as the key. If this is\n    /// <c>null</c>, checks for <c>CBORObject.Null</c>.</param>\n    /// <returns><c>true</c> if the given key is found, or <c>false</c> if\n    /// the given key is not found or this object is not a map.</returns>\n    public bool ContainsKey(CBORObject key) {\n      key = key ?? CBORObject.Null;\n      if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        return map.ContainsKey(key);\n      }\n      return false;\n    }\n\n    /// <summary>Determines whether a value of the given key exists in this\n    /// object.</summary>\n    /// <param name='key'>A text string that serves as the key. If this is\n    /// <c>null</c>, checks for <c>CBORObject.Null</c>.</param>\n    /// <returns><c>true</c> if the given key (as a CBOR object) is found,\n    /// or <c>false</c> if the given key is not found or this object is not\n    /// a map.</returns>\n    public bool ContainsKey(string key) {\n      if (this.Type == CBORType.Map) {\n        CBORObject ckey = key == null ? CBORObject.Null :\n          CBORObject.FromObject(key);\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        return map.ContainsKey(ckey);\n      }\n      return false;\n    }\n\n    private static byte[] GetDoubleBytes64(long valueBits, int tagbyte) {\n      // Encode as double precision\n      return tagbyte != 0 ? new[] {\n        (byte)tagbyte, (byte)0xfb,\n        (byte)((valueBits >> 56) & 0xff), (byte)((valueBits >> 48) & 0xff),\n        (byte)((valueBits >> 40) & 0xff), (byte)((valueBits >> 32) & 0xff),\n        (byte)((valueBits >> 24) & 0xff), (byte)((valueBits >> 16) & 0xff),\n        (byte)((valueBits >> 8) & 0xff), (byte)(valueBits & 0xff),\n      } : new[] {\n   (byte)0xfb, (byte)((valueBits >> 56) & 0xff),\n   (byte)((valueBits >> 48) & 0xff), (byte)((valueBits >> 40) & 0xff),\n   (byte)((valueBits >> 32) & 0xff), (byte)((valueBits >> 24) & 0xff),\n   (byte)((valueBits >> 16) & 0xff), (byte)((valueBits >> 8) & 0xff),\n   (byte)(valueBits & 0xff),\n };\n    }\n\n    private static byte[] GetDoubleBytes(long valueBits, int tagbyte) {\n      int bits = CBORUtilities.DoubleToHalfPrecisionIfSameValue(valueBits);\n      if (bits != -1) {\n        return tagbyte != 0 ? new[] {\n          (byte)tagbyte, (byte)0xf9,\n          (byte)((bits >> 8) & 0xff), (byte)(bits & 0xff),\n        } : new[] {\n   (byte)0xf9, (byte)((bits >> 8) & 0xff),\n   (byte)(bits & 0xff),\n };\n      }\n      if (CBORUtilities.DoubleRetainsSameValueInSingle(valueBits)) {\n        bits = CBORUtilities.DoubleToRoundedSinglePrecision(valueBits);\n        return tagbyte != 0 ? new[] {\n          (byte)tagbyte, (byte)0xfa,\n          (byte)((bits >> 24) & 0xff), (byte)((bits >> 16) & 0xff),\n          (byte)((bits >> 8) & 0xff), (byte)(bits & 0xff),\n        } : new[] {\n   (byte)0xfa, (byte)((bits >> 24) & 0xff),\n   (byte)((bits >> 16) & 0xff), (byte)((bits >> 8) & 0xff),\n   (byte)(bits & 0xff),\n };\n      }\n      return GetDoubleBytes64(valueBits, tagbyte);\n    }\n\n    /// <summary>\n    /// <para>Writes the binary representation of this CBOR object and\n    /// returns a byte array of that representation. If the CBOR object\n    /// contains CBOR maps, or is a CBOR map itself, the order in which the\n    /// keys to the map are written out to the byte array is undefined\n    /// unless the map was created using the NewOrderedMap method. The\n    /// example code given in\n    /// <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can\n    /// be used to write out certain keys of a CBOR map in a given order.\n    /// For the CTAP2 (FIDO Client-to-Authenticator Protocol 2) canonical\n    /// ordering, which is useful for implementing Web Authentication, call\n    /// <c>EncodeToBytes(new CBOREncodeOptions(\"ctap2canonical=true\"))</c>\n    /// rather than this method.</para></summary>\n    /// <returns>A byte array in CBOR format.</returns>\n    public byte[] EncodeToBytes() {\n      return this.EncodeToBytes(CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes the binary representation of this CBOR object and\n    /// returns a byte array of that representation, using the specified\n    /// options for encoding the object to CBOR format. For the CTAP2 (FIDO\n    /// Client-to-Authenticator Protocol 2) canonical ordering, which is\n    /// useful for implementing Web Authentication, call this method as\n    /// follows: <c>EncodeToBytes(new\n    /// CBOREncodeOptions(\"ctap2canonical=true\"))</c>.</summary>\n    /// <param name='options'>Options for encoding the data to\n    /// CBOR.</param>\n    /// <returns>A byte array in CBOR format.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    public byte[] EncodeToBytes(CBOREncodeOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (options.Ctap2Canonical) {\n        return CBORCanonical.CtapCanonicalEncode(this);\n      }\n      // For some types, a memory stream is a lot of\n      // overhead since the amount of memory the types\n      // use is fixed and small\n      var hasComplexTag = false;\n      byte tagbyte = 0;\n      bool tagged = this.IsTagged;\n      if (this.IsTagged) {\n        var taggedItem = (CBORObject)this.itemValue;\n        if (taggedItem.IsTagged || this.tagHigh != 0 ||\n          (this.tagLow >> 16) != 0 || this.tagLow >= 24) {\n          hasComplexTag = true;\n        } else {\n          tagbyte = (byte)(0xc0 + (int)this.tagLow);\n        }\n      }\n      if (!hasComplexTag) {\n        switch (this.ItemType) {\n          case CBORObjectTypeTextString:\n          case CBORObjectTypeTextStringAscii: {\n            byte[] ret = GetOptimizedBytesIfShortAscii(\n                this.AsString(), tagged ? (((int)tagbyte) & 0xff) : -1);\n            if (ret != null) {\n              return ret;\n            }\n            break;\n          }\n          case CBORObjectTypeTextStringUtf8: {\n            if (!tagged && !options.UseIndefLengthStrings) {\n              byte[] bytes = (byte[])this.ThisItem;\n              return SerializeUtf8(bytes);\n            }\n            break;\n          }\n          case CBORObjectTypeSimpleValue: {\n            if (tagged) {\n              var simpleBytes = new byte[] { tagbyte, (byte)0xf4 };\n              if (this.IsFalse) {\n                simpleBytes[1] = (byte)0xf4;\n                return simpleBytes;\n              }\n              if (this.IsTrue) {\n                simpleBytes[1] = (byte)0xf5;\n                return simpleBytes;\n              }\n              if (this.IsNull) {\n                simpleBytes[1] = (byte)0xf6;\n                return simpleBytes;\n              }\n              if (this.IsUndefined) {\n                simpleBytes[1] = (byte)0xf7;\n                return simpleBytes;\n              }\n            } else {\n              if (this.IsFalse) {\n                return new[] { (byte)0xf4 };\n              }\n              if (this.IsTrue) {\n                return new[] { (byte)0xf5 };\n              }\n              if (this.IsNull) {\n                return new[] { (byte)0xf6 };\n              }\n              if (this.IsUndefined) {\n                return new[] { (byte)0xf7 };\n              }\n            }\n            break;\n          }\n          case CBORObjectTypeInteger: {\n            var value = (long)this.ThisItem;\n            byte[] intBytes = null;\n            if (value >= 0) {\n              intBytes = GetPositiveInt64Bytes(0, value);\n            } else {\n              ++value;\n              value = -value; // Will never overflow\n              intBytes = GetPositiveInt64Bytes(1, value);\n            }\n            if (!tagged) {\n              return intBytes;\n            }\n            var ret2 = new byte[intBytes.Length + 1];\n            Array.Copy(intBytes, 0, ret2, 1, intBytes.Length);\n            ret2[0] = tagbyte;\n            return ret2;\n          }\n          case CBORObjectTypeDouble: {\n            if (options.Float64) {\n            return GetDoubleBytes64(\n                this.AsDoubleBits(),\n                ((int)tagbyte) & 0xff);\n            } else {\n            return GetDoubleBytes(\n                this.AsDoubleBits(),\n                ((int)tagbyte) & 0xff);\n            }\n          }\n        }\n      }\n      try {\n        using (var ms = new MemoryStream(16)) {\n          this.WriteTo(ms, options);\n          return ms.ToArray();\n        }\n      } catch (IOException ex) {\n        throw new CBORException(\"I/O Error occurred\", ex);\n      }\n    }\n\n    /// <summary>Gets the CBOR object referred to by a JSON Pointer\n    /// according to RFC6901. For more information, see the overload taking\n    /// a default value parameter.</summary>\n    /// <param name='pointer'>A JSON pointer according to RFC 6901.</param>\n    /// <returns>An object within this CBOR object. Returns this object if\n    /// pointer is the empty string (even if this object has a CBOR type\n    /// other than array or map).</returns>\n    /// <exception cref='PeterO.Cbor.CBORException'>Thrown if the pointer\n    /// is null, or if the pointer is invalid, or if there is no object at\n    /// the given pointer, or the special key \"-\" appears in the pointer in\n    /// the context of an array (not a map), or if the pointer is non-empty\n    /// and this object has a CBOR type other than array or\n    /// map.</exception>\n    public CBORObject AtJSONPointer(string pointer) {\n      CBORObject ret = this.AtJSONPointer(pointer, null);\n      if (ret == null) {\n         throw new CBORException(\"Invalid JSON pointer\");\n      }\n      return ret;\n    }\n\n    /// <summary>Gets the CBOR object referred to by a JSON Pointer\n    /// according to RFC6901, or a default value if the operation fails.\n    /// The syntax for a JSON Pointer is:\n    /// <pre>'/' KEY '/' KEY [...]</pre> where KEY represents a key into\n    /// the JSON object or its sub-objects in the hierarchy. For example,\n    /// <pre>/foo/2/bar</pre> means the same as\n    /// <pre>obj['foo'][2]['bar']</pre> in JavaScript. If \"~\" and/or \"/\"\n    /// occurs in a key, it must be escaped with \"~0\" or \"~1\",\n    /// respectively, in a JSON pointer. JSON pointers also support the\n    /// special key \"-\" (as in \"/foo/-\") to indicate the end of an array,\n    /// but this method treats this key as an error since it refers to a\n    /// nonexistent item. Indices to arrays (such as 2 in the example) must\n    /// contain only basic digits 0 to 9 and no leading zeros. (Note that\n    /// RFC 6901 was published before JSON was extended to support\n    /// top-level values other than arrays and key-value\n    /// dictionaries.).</summary>\n    /// <param name='pointer'>A JSON pointer according to RFC 6901.</param>\n    /// <param name='defaultValue'>The parameter <paramref\n    /// name='defaultValue'/> is a Cbor.CBORObject object.</param>\n    /// <returns>An object within the specified JSON object. Returns this\n    /// object if pointer is the empty string (even if this object has a\n    /// CBOR type other than array or map). Returns <paramref\n    /// name='defaultValue'/> if the pointer is null, or if the pointer is\n    /// invalid, or if there is no object at the given pointer, or the\n    /// special key \"-\" appears in the pointer in the context of an array\n    /// (not a map), or if the pointer is non-empty and this object has a\n    /// CBOR type other than array or map.</returns>\n    public CBORObject AtJSONPointer(string pointer, CBORObject defaultValue) {\n      return JSONPointer.GetObject(this, pointer, null);\n    }\n\n  /// <summary>Returns a copy of this object after applying the\n  /// operations in a JSON patch, in the form of a CBOR object. JSON\n  /// patches are specified in RFC 6902 and their format is summarized in\n  /// the remarks below.</summary>\n  /// <param name='patch'>A JSON patch in the form of a CBOR object; it\n  /// has the form summarized in the remarks.</param>\n  /// <returns>The result of the patch operation.</returns>\n  /// <exception cref='PeterO.Cbor.CBORException'>The parameter <paramref\n  /// name='patch'/> is null or the patch operation failed.</exception>\n  /// <remarks><b>Remarks:</b> A JSON patch is an array with one or more\n  /// maps. Each map has the following keys:\n  /// <list>\n  /// <item>\"op\" - Required. This key's value is the patch operation and\n  /// must be \"add\", \"remove\", \"move\", \"copy\", \"test\", or \"replace\", in\n  /// basic lower case letters and no other case combination.</item>\n  /// <item>\"value\" - Required if the operation is \"add\", \"replace\", or\n  /// \"test\" and specifies the item to add (insert), or that will replace\n  /// the existing item, or to check an existing item for equality,\n  /// respectively. (For \"test\", the operation fails if the existing item\n  /// doesn't match the specified value.)</item>\n  /// <item>\"path\" - Required for all operations. A JSON Pointer (RFC\n  /// 6901) specifying the destination path in the CBOR object for the\n  /// operation. For more information, see RFC 6901 or the documentation\n  /// for AtJSONPointer(pointer, defaultValue).</item>\n  /// <item>\"from\" - Required if the operation is \"move\" or \"copy\". A\n  /// JSON Pointer (RFC 6901) specifying the path in the CBOR object\n  /// where the source value is located.</item></list></remarks>\n    public CBORObject ApplyJSONPatch(CBORObject patch) {\n      return JSONPatch.Patch(this, patch);\n    }\n\n    /// <summary>Determines whether this object and another object are\n    /// equal and have the same type. Not-a-number values can be considered\n    /// equal by this method.</summary>\n    /// <param name='obj'>The parameter <paramref name='obj'/> is an\n    /// arbitrary object.</param>\n    /// <returns><c>true</c> if the objects are equal; otherwise,\n    /// <c>false</c>. In this method, two objects are not equal if they\n    /// don't have the same type or if one is null and the other\n    /// isn't.</returns>\n    public override bool Equals(object obj) {\n      return this.Equals(obj as CBORObject);\n    }\n\n    /// <summary>Compares the equality of two CBOR objects. Not-a-number\n    /// values can be considered equal by this method.</summary>\n    /// <param name='other'>The object to compare.</param>\n    /// <returns><c>true</c> if the objects are equal; otherwise,\n    /// <c>false</c>. In this method, two objects are not equal if they\n    /// don't have the same type or if one is null and the other\n    /// isn't.</returns>\n    public bool Equals(CBORObject other) {\n      var otherValue = other as CBORObject;\n      if (otherValue == null) {\n        return false;\n      }\n      if (this == otherValue) {\n        return true;\n      }\n      if ((this.itemtypeValue == CBORObjectTypeTextString ||\nthis.itemtypeValue == CBORObjectTypeTextStringAscii) &&\n        otherValue.itemtypeValue == CBORObjectTypeTextStringUtf8) {\n        return CBORUtilities.StringEqualsUtf8(\n            (string)this.itemValue,\n            (byte[])otherValue.itemValue);\n      }\n      if ((otherValue.itemtypeValue == CBORObjectTypeTextString ||\notherValue.itemtypeValue == CBORObjectTypeTextStringAscii) &&\n        this.itemtypeValue == CBORObjectTypeTextStringUtf8) {\n        return CBORUtilities.StringEqualsUtf8(\n            (string)otherValue.itemValue,\n            (byte[])this.itemValue);\n      }\n      if ((otherValue.itemtypeValue == CBORObjectTypeTextString &&\nthis.itemtypeValue == CBORObjectTypeTextStringAscii) || (this.itemtypeValue\n== CBORObjectTypeTextString && otherValue.itemtypeValue ==\nCBORObjectTypeTextStringAscii)) {\n        return Object.Equals(this.itemValue, otherValue.itemValue);\n      }\n      if (this.itemtypeValue != otherValue.itemtypeValue) {\n        return false;\n      }\n      switch (this.itemtypeValue) {\n        case CBORObjectTypeByteString:\n        case CBORObjectTypeTextStringUtf8:\n          return CBORUtilities.ByteArrayEquals(\n              (byte[])this.itemValue,\n              otherValue.itemValue as byte[]);\n        case CBORObjectTypeMap: {\n          IDictionary<CBORObject, CBORObject> cbordict =\n            otherValue.itemValue as IDictionary<CBORObject, CBORObject>;\n          return CBORMapEquals(this.AsMap(), cbordict);\n        }\n        case CBORObjectTypeArray:\n          return CBORArrayEquals(\n              this.AsList(),\n              otherValue.itemValue as IList<CBORObject>);\n        case CBORObjectTypeTagged:\n          return this.tagLow == otherValue.tagLow &&\n            this.tagHigh == otherValue.tagHigh &&\n            Object.Equals(this.itemValue, otherValue.itemValue);\n        case CBORObjectTypeDouble:\n          return this.AsDoubleBits() == otherValue.AsDoubleBits();\n        default: return Object.Equals(this.itemValue, otherValue.itemValue);\n      }\n    }\n\n    /// <summary>Gets the backing byte array used in this CBOR object, if\n    /// this object is a byte string, without copying the data to a new\n    /// byte array. Any changes in the returned array's contents will be\n    /// reflected in this CBOR object. Note, though, that the array's\n    /// length can't be changed.</summary>\n    /// <returns>The byte array held by this CBOR object.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// byte string.</exception>\n    public byte[] GetByteString() {\n      if (this.ItemType == CBORObjectTypeByteString) {\n        return (byte[])this.ThisItem;\n      }\n      throw new InvalidOperationException(\"Not a byte string\");\n    }\n\n    /// <summary>Calculates the hash code of this object. The hash code for\n    /// a given instance of this class is not guaranteed to be the same\n    /// across versions of this class, and no application or process IDs\n    /// are used in the hash code calculation.</summary>\n    /// <returns>A 32-bit hash code.</returns>\n    public override int GetHashCode() {\n      var hashCode = 651869431;\n      unchecked {\n        if (this.itemValue != null) {\n          var itemHashCode = 0;\n          long longValue = 0L;\n          switch (this.itemtypeValue) {\n            case CBORObjectTypeByteString:\n              itemHashCode =\n                CBORUtilities.ByteArrayHashCode(this.GetByteString());\n              break;\n            case CBORObjectTypeTextStringUtf8:\n              itemHashCode = CBORUtilities.Utf8HashCode(\n                  (byte[])this.itemValue);\n              break;\n            case CBORObjectTypeMap:\n              itemHashCode = CBORMapHashCode(this.AsMap());\n              break;\n            case CBORObjectTypeArray:\n              itemHashCode = CBORArrayHashCode(this.AsList());\n              break;\n            case CBORObjectTypeTextString:\n            case CBORObjectTypeTextStringAscii:\n              itemHashCode = CBORUtilities.StringHashCode(\n                  (string)this.itemValue);\n              break;\n            case CBORObjectTypeSimpleValue:\n              itemHashCode = (int)this.itemValue;\n              break;\n            case CBORObjectTypeDouble:\n              longValue = this.AsDoubleBits();\n              longValue |= longValue >> 32;\n              itemHashCode = unchecked((int)longValue);\n              break;\n            case CBORObjectTypeInteger:\n              longValue = (long)this.itemValue;\n              longValue |= longValue >> 32;\n              itemHashCode = unchecked((int)longValue);\n              break;\n            case CBORObjectTypeTagged:\n              itemHashCode = unchecked(this.tagLow + this.tagHigh);\n              itemHashCode += 651869483 * this.itemValue.GetHashCode();\n              break;\n            default:\n              // EInteger, CBORObject\n              itemHashCode = this.itemValue.GetHashCode();\n              break;\n          }\n          hashCode += 651869479 * itemHashCode;\n        }\n      }\n      return hashCode;\n    }\n\n    /// <summary>Gets a list of all tags, from outermost to\n    /// innermost.</summary>\n    /// <returns>An array of tags, or the empty string if this object is\n    /// untagged.</returns>\n    public EInteger[] GetAllTags() {\n      if (!this.IsTagged) {\n        return ValueEmptyTags;\n      }\n      CBORObject curitem = this;\n      if (curitem.IsTagged) {\n        var list = new List<EInteger>();\n        while (curitem.IsTagged) {\n          list.Add(\n            LowHighToEInteger(\n              curitem.tagLow,\n              curitem.tagHigh));\n          curitem = (CBORObject)curitem.itemValue;\n        }\n        return (EInteger[])list.ToArray();\n      }\n      return new[] { LowHighToEInteger(this.tagLow, this.tagHigh) };\n    }\n\n    /// <summary>Returns whether this object has only one tag.</summary>\n    /// <returns><c>true</c> if this object has only one tag; otherwise,\n    /// <c>false</c>.</returns>\n    public bool HasOneTag() {\n      return this.IsTagged && !((CBORObject)this.itemValue).IsTagged;\n    }\n\n    /// <summary>Returns whether this object has only one tag and that tag\n    /// is the given number.</summary>\n    /// <param name='tagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has only one tag and that tag\n    /// is the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    public bool HasOneTag(int tagValue) {\n      return this.HasOneTag() && this.HasMostOuterTag(tagValue);\n    }\n\n    /// <summary>Returns whether this object has only one tag and that tag\n    /// is the given number, expressed as an arbitrary-precision\n    /// integer.</summary>\n    /// <param name='bigTagValue'>An arbitrary-precision integer.</param>\n    /// <returns><c>true</c> if this object has only one tag and that tag\n    /// is the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasOneTag(EInteger bigTagValue) {\n      return this.HasOneTag() && this.HasMostOuterTag(bigTagValue);\n    }\n\n    /// <summary>Gets the number of tags this object has.</summary>\n    /// <value>The number of tags this object has.</value>\n    public int TagCount {\n      get {\n        var count = 0;\n        CBORObject curitem = this;\n        while (curitem.IsTagged) {\n          count = checked(count + 1);\n          curitem = (CBORObject)curitem.itemValue;\n        }\n        return count;\n      }\n    }\n\n    /// <summary>Returns whether this object has an innermost tag and that\n    /// tag is of the given number.</summary>\n    /// <param name='tagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an innermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    public bool HasMostInnerTag(int tagValue) {\n      if (tagValue < 0) {\n        throw new ArgumentException(\"tagValue(\" + tagValue +\n          \") is less than 0\");\n      }\n      return this.IsTagged && this.HasMostInnerTag(\n          EInteger.FromInt32(tagValue));\n    }\n\n    /// <summary>Returns whether this object has an innermost tag and that\n    /// tag is of the given number, expressed as an arbitrary-precision\n    /// number.</summary>\n    /// <param name='bigTagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an innermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasMostInnerTag(EInteger bigTagValue) {\n      if (bigTagValue == null) {\n        throw new ArgumentNullException(nameof(bigTagValue));\n      }\n      if (bigTagValue.Sign < 0) {\n        throw new ArgumentException(\"bigTagValue(\" + bigTagValue +\n          \") is less than 0\");\n      }\n      return (!this.IsTagged) ? false : this.MostInnerTag.Equals(bigTagValue);\n    }\n\n    /// <summary>Returns whether this object has an outermost tag and that\n    /// tag is of the given number.</summary>\n    /// <param name='tagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an outermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    public bool HasMostOuterTag(int tagValue) {\n      if (tagValue < 0) {\n        throw new ArgumentException(\"tagValue(\" + tagValue +\n          \") is less than 0\");\n      }\n      return this.IsTagged && this.tagHigh == 0 && this.tagLow == tagValue;\n    }\n\n    /// <summary>Returns whether this object has an outermost tag and that\n    /// tag is of the given number.</summary>\n    /// <param name='bigTagValue'>The tag number.</param>\n    /// <returns><c>true</c> if this object has an outermost tag and that\n    /// tag is of the given number; otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasMostOuterTag(EInteger bigTagValue) {\n      if (bigTagValue == null) {\n        throw new ArgumentNullException(nameof(bigTagValue));\n      }\n      if (bigTagValue.Sign < 0) {\n        throw new ArgumentException(\"bigTagValue(\" + bigTagValue +\n          \") is less than 0\");\n      }\n      return (!this.IsTagged) ? false : this.MostOuterTag.Equals(bigTagValue);\n    }\n\n    /// <summary>Returns whether this object has a tag of the given\n    /// number.</summary>\n    /// <param name='tagValue'>The tag value to search for.</param>\n    /// <returns><c>true</c> if this object has a tag of the given number;\n    /// otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='tagValue'/> is less than 0.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='tagValue'/> is null.</exception>\n    public bool HasTag(int tagValue) {\n      if (tagValue < 0) {\n        throw new ArgumentException(\"tagValue(\" + tagValue +\n          \") is less than 0\");\n      }\n      CBORObject obj = this;\n      while (true) {\n        if (!obj.IsTagged) {\n          return false;\n        }\n        if (obj.tagHigh == 0 && tagValue == obj.tagLow) {\n          return true;\n        }\n        obj = (CBORObject)obj.itemValue;\n        #if DEBUG\n        if (obj == null) {\n          throw new ArgumentNullException(nameof(tagValue));\n        }\n        #endif\n      }\n    }\n\n    /// <summary>Returns whether this object has a tag of the given\n    /// number.</summary>\n    /// <param name='bigTagValue'>The tag value to search for.</param>\n    /// <returns><c>true</c> if this object has a tag of the given number;\n    /// otherwise, <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='bigTagValue'/> is null.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='bigTagValue'/> is less than 0.</exception>\n    public bool HasTag(EInteger bigTagValue) {\n      if (bigTagValue == null) {\n        throw new ArgumentNullException(nameof(bigTagValue));\n      }\n      if (bigTagValue.Sign < 0) {\n        throw new ArgumentException(\"doesn't satisfy bigTagValue.Sign>= 0\");\n      }\n      EInteger[] bigTags = this.GetAllTags();\n      foreach (EInteger bigTag in bigTags) {\n        if (bigTagValue.Equals(bigTag)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /// <summary>Inserts an object at the specified position in this CBOR\n    /// array.</summary>\n    /// <param name='index'>Index starting at 0 to insert at.</param>\n    /// <param name='valueOb'>An object representing the value, which will\n    /// be converted to a CBORObject. Can be null, in which case this value\n    /// is converted to CBORObject.Null.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not an\n    /// array.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='valueOb'/> has an unsupported type; or <paramref\n    /// name='index'/> is not a valid index into this array.</exception>\n    public CBORObject Insert(int index, object valueOb) {\n      if (this.Type == CBORType.Array) {\n        CBORObject mapValue;\n        IList<CBORObject> list = this.AsList();\n        if (index < 0 || index > list.Count) {\n          throw new ArgumentOutOfRangeException(nameof(index));\n        }\n        if (valueOb == null) {\n          mapValue = CBORObject.Null;\n        } else {\n          mapValue = valueOb as CBORObject;\n          mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n        }\n        list.Insert(\n          index,\n          mapValue);\n      } else {\n        throw new InvalidOperationException(\"Not an array\");\n      }\n      return this;\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents infinity.</summary>\n    /// <returns><c>true</c> if this CBOR object represents infinity;\n    /// otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n        \"\\u0020cbor.AsNumber().IsInfinity()).\")]\n    public bool IsInfinity() {\n      return this.IsNumber && this.AsNumber().IsInfinity();\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents a not-a-number value (as opposed to whether this object\n    /// does not express a number).</summary>\n    /// <returns><c>true</c> if this CBOR object represents a not-a-number\n    /// value (as opposed to whether this object does not represent a\n    /// number as defined by the IsNumber property or <c>isNumber()</c>\n    /// method in Java); otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n\n        \"\\u0020cbor.AsNumber().IsNaN()).\")]\n    public bool IsNaN() {\n      return this.IsNumber && this.AsNumber().IsNaN();\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents negative infinity.</summary>\n    /// <returns><c>true</c> if this CBOR object represents negative\n    /// infinity; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n\n        \"\\u0020cbor.AsNumber().IsNegativeInfinity()).\")]\n    public bool IsNegativeInfinity() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return cn != null &&\n        cn.GetNumberInterface().IsNegativeInfinity(cn.GetValue());\n    }\n\n    /// <summary>Gets a value indicating whether this CBOR object\n    /// represents positive infinity.</summary>\n    /// <returns><c>true</c> if this CBOR object represents positive\n    /// infinity; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Instead, use the following: \\u0028cbor.IsNumber &&\" +\n\n        \"\\u0020cbor.AsNumber().IsPositiveInfinity()).\")]\n    public bool IsPositiveInfinity() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      return cn != null &&\n        cn.GetNumberInterface().IsPositiveInfinity(cn.GetValue());\n    }\n\n    /// <summary>Gets this object's value with the sign reversed.</summary>\n    /// <returns>The reversed-sign form of this number.</returns>\n    /// <exception cref='InvalidOperationException'>This object does not\n    /// represent a number (for this purpose, infinities and not-a-number\n    /// or NaN values, but not CBORObject.Null, are considered\n    /// numbers).</exception>\n    [Obsolete(\"Instead, convert this object to a number \\u0028with\" +\n\n        \"\\u0020.AsNumber()), and use that number's .Negate() method.\")]\n    public CBORObject Negate() {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"This object is not a number.\");\n      }\n      object newItem = cn.GetNumberInterface().Negate(cn.GetValue());\n      if (newItem is EDecimal) {\n        return CBORObject.FromObject((EDecimal)newItem);\n      }\n      if (newItem is EInteger) {\n        return CBORObject.FromObject((EInteger)newItem);\n      }\n      if (newItem is EFloat) {\n        return CBORObject.FromObject((EFloat)newItem);\n      }\n      var rat = newItem as ERational;\n      return (rat != null) ? CBORObject.FromObject(rat) :\n        CBORObject.FromObject(newItem);\n    }\n\n    /// <summary>Removes all items from this CBOR array or all keys and\n    /// values from this CBOR map.</summary>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// CBOR array or CBOR map.</exception>\n    public void Clear() {\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        list.Clear();\n      } else if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n        dict.Clear();\n      } else {\n        throw new InvalidOperationException(\"Not a map or array\");\n      }\n    }\n\n    /// <summary>If this object is an array, removes the first instance of\n    /// the specified item (once converted to a CBOR object) from the\n    /// array. If this object is a map, removes the item with the given key\n    /// (once converted to a CBOR object) from the map.</summary>\n    /// <param name='obj'>The item or key (once converted to a CBOR object)\n    /// to remove.</param>\n    /// <returns><c>true</c> if the item was removed; otherwise,\n    /// <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='obj'/> is null (as opposed to CBORObject.Null).</exception>\n    /// <exception cref='InvalidOperationException'>The object is not an\n    /// array or map.</exception>\n    public bool Remove(object obj) {\n      return this.Remove(CBORObject.FromObject(obj));\n    }\n\n    /// <summary>Removes the item at the given index of this CBOR\n    /// array.</summary>\n    /// <param name='index'>The index, starting at 0, of the item to\n    /// remove.</param>\n    /// <returns>Returns \"true\" if the object was removed. Returns \"false\"\n    /// if the given index is less than 0, or is at least as high as the\n    /// number of items in the array.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// CBOR array.</exception>\n    public bool RemoveAt(int index) {\n      if (this.ItemType != CBORObjectTypeArray) {\n        throw new InvalidOperationException(\"Not an array\");\n      }\n      if (index < 0 || index >= this.Count) {\n        return false;\n      }\n      IList<CBORObject> list = this.AsList();\n      list.RemoveAt(index);\n      return true;\n    }\n\n    /// <summary>If this object is an array, removes the first instance of\n    /// the specified item from the array. If this object is a map, removes\n    /// the item with the given key from the map.</summary>\n    /// <param name='obj'>The item or key to remove.</param>\n    /// <returns><c>true</c> if the item was removed; otherwise,\n    /// <c>false</c>.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='obj'/> is null (as opposed to CBORObject.Null).</exception>\n    /// <exception cref='InvalidOperationException'>The object is not an\n    /// array or map.</exception>\n    public bool Remove(CBORObject obj) {\n      if (obj == null) {\n        throw new ArgumentNullException(nameof(obj));\n      }\n      if (this.Type == CBORType.Map) {\n        IDictionary<CBORObject, CBORObject> dict = this.AsMap();\n        bool hasKey = dict.ContainsKey(obj);\n        if (hasKey) {\n          dict.Remove(obj);\n          return true;\n        }\n        return false;\n      }\n      if (this.Type == CBORType.Array) {\n        IList<CBORObject> list = this.AsList();\n        return list.Remove(obj);\n      }\n      throw new InvalidOperationException(\"Not a map or array\");\n    }\n\n    /// <summary>Maps an object to a key in this CBOR map, or adds the\n    /// value if the key doesn't exist. If this is a CBOR array, instead\n    /// sets the value at the given index to the given value.</summary>\n    /// <param name='key'>If this instance is a CBOR map, this parameter is\n    /// an object representing the key, which will be converted to a\n    /// CBORObject; in this case, this parameter can be null, in which case\n    /// this value is converted to CBORObject.Null. If this instance is a\n    /// CBOR array, this parameter must be a 32-bit signed integer(\n    /// <c>int</c> ) identifying the index (starting from 0) of the item to\n    /// set in the array.</param>\n    /// <param name='valueOb'>An object representing the value, which will\n    /// be converted to a CBORObject. Can be null, in which case this value\n    /// is converted to CBORObject.Null.</param>\n    /// <returns>This instance.</returns>\n    /// <exception cref='InvalidOperationException'>This object is not a\n    /// map or an array.</exception>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='key'/> or <paramref name='valueOb'/> has an unsupported type,\n    /// or this instance is a CBOR array and <paramref name='key'/> is less\n    /// than 0, is the size of this array or greater, or is not a 32-bit\n    /// signed integer ( <c>int</c> ).</exception>\n    public CBORObject Set(object key, object valueOb) {\n      if (this.Type == CBORType.Map) {\n        CBORObject mapKey;\n        CBORObject mapValue;\n        if (key == null) {\n          mapKey = CBORObject.Null;\n        } else {\n          mapKey = key as CBORObject;\n          mapKey = mapKey ?? CBORObject.FromObject(key);\n        }\n        if (valueOb == null) {\n          mapValue = CBORObject.Null;\n        } else {\n          mapValue = valueOb as CBORObject;\n          mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n        }\n        IDictionary<CBORObject, CBORObject> map = this.AsMap();\n        if (map.ContainsKey(mapKey)) {\n          map[mapKey] = mapValue;\n        } else {\n          map.Add(mapKey, mapValue);\n        }\n      } else if (this.Type == CBORType.Array) {\n        if (key is int) {\n          IList<CBORObject> list = this.AsList();\n          var index = (int)key;\n          if (index < 0 || index >= this.Count) {\n            throw new ArgumentOutOfRangeException(nameof(key));\n          }\n          CBORObject mapValue;\n          if (valueOb == null) {\n            mapValue = CBORObject.Null;\n          } else {\n            mapValue = valueOb as CBORObject;\n            mapValue = mapValue ?? CBORObject.FromObject(valueOb);\n          }\n          list[index] = mapValue;\n        } else {\n          throw new ArgumentException(\"Is an array, but key is not int\");\n        }\n      } else {\n        throw new InvalidOperationException(\"Not a map or array\");\n      }\n      return this;\n    }\n\n    /// <summary>Converts this object to a text string in JavaScript Object\n    /// Notation (JSON) format. See the overload to ToJSONString taking a\n    /// JSONOptions argument for further information.\n    /// <para>If the CBOR object contains CBOR maps, or is a CBOR map\n    /// itself, the order in which the keys to the map are written out to\n    /// the JSON string is undefined unless the map was created using the\n    /// NewOrderedMap method. Map keys other than untagged text strings are\n    /// converted to JSON strings before writing them out (for example,\n    /// <c>22(\"Test\")</c> is converted to <c>\"Test\"</c> and <c>true</c> is\n    /// converted to <c>\"true\"</c> ). After such conversion, if two or more\n    /// keys for the same map are identical, this method throws a\n    /// CBORException. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string, or to write out a CBOR object as part of a\n    /// JSON text sequence.</para>\n    /// <para><b>Warning:</b> In general, if this CBOR object contains\n    /// integer map keys or uses other features not supported in JSON, and\n    /// the application converts this CBOR object to JSON and back to CBOR,\n    /// the application\n    /// <i>should not</i> expect the new CBOR object to be exactly the same\n    /// as the original. This is because the conversion in many cases may\n    /// have to convert unsupported features in JSON to supported features\n    /// which correspond to a different feature in CBOR (such as converting\n    /// integer map keys, which are supported in CBOR but not JSON, to text\n    /// strings, which are supported in both).</para></summary>\n    /// <returns>A text string containing the converted object in JSON\n    /// format.</returns>\n    public string ToJSONString() {\n      return this.ToJSONString(JSONOptions.Default);\n    }\n\n    /// <summary>\n    ///  Converts this object to a text string in JavaScript\n    /// Object Notation (JSON) format, using the specified\n    /// options to control the encoding process. This function\n    /// works not only with arrays and maps, but also integers,\n    /// strings, byte arrays, and other JSON data types. Notes:\n    ///\n    /// <list type=''><item>If this object contains maps with non-string\n    /// keys, the keys are converted to JSON strings before writing the map\n    /// as a JSON string.</item>\n    ///  <item>If this object represents a number\n    /// (the IsNumber property, or isNumber() method in Java, returns\n    /// true), then it is written out as a number.</item>\n    ///  <item>If the CBOR\n    /// object contains CBOR maps, or is a CBOR map itself, the order in\n    /// which the keys to the map are written out to the JSON string is\n    /// undefined unless the map was created using the NewOrderedMap\n    /// method. Map keys other than untagged text strings are converted to\n    /// JSON strings before writing them out (for example,\n    /// <c>22(\"Test\")</c>\n    ///  is converted to <c>\"Test\"</c>\n    ///  and <c>true</c>\n    ///  is\n    /// converted to <c>\"true\"</c>\n    ///  ). After such conversion, if two or more\n    /// keys for the same map are identical, this method throws a\n    /// CBORException.</item>\n    ///  <item>If a number in the form of an\n    /// arbitrary-precision binary floating-point number has a very high\n    /// binary exponent, it will be converted to a double before being\n    /// converted to a JSON string. (The resulting double could overflow to\n    /// infinity, in which case the arbitrary-precision binary\n    /// floating-point number is converted to null.)</item>\n    ///  <item>The\n    /// string will not begin with a byte-order mark (U+FEFF); RFC 8259\n    /// (the JSON specification) forbids placing a byte-order mark at the\n    /// beginning of a JSON string.</item>\n    ///  <item>Byte strings are converted\n    /// to Base64 URL without whitespace or padding by default (see section\n    /// 3.4.5.3 of RFC 8949). A byte string will instead be converted to\n    /// traditional base64 without whitespace and with padding if it has\n    /// tag 22, or base16 for tag 23. (To create a CBOR object with a given\n    /// tag, call the <c>CBORObject.FromObjectAndTag</c>\n    ///  method and pass\n    /// the CBOR object and the desired tag number to that method.)</item>\n    /// <item>Rational numbers will be converted to their exact form, if\n    /// possible, otherwise to a high-precision approximation. (The\n    /// resulting approximation could overflow to infinity, in which case\n    /// the rational number is converted to null.)</item>\n    ///  <item>Simple\n    /// values other than true and false will be converted to null. (This\n    /// doesn't include floating-point numbers.)</item>\n    ///  <item>Infinity and\n    /// not-a-number will be converted to null.</item>\n    ///  </list>\n    /// <para><b>Warning:</b>\n    ///  In general, if this CBOR object contains\n    /// integer map keys or uses other features not supported in JSON, and\n    /// the application converts this CBOR object to JSON and back to CBOR,\n    /// the application <i>should not</i>\n    ///  expect the new CBOR object to be\n    /// exactly the same as the original. This is because the conversion in\n    /// many cases may have to convert unsupported features in JSON to\n    /// supported features which correspond to a different feature in CBOR\n    /// (such as converting integer map keys, which are supported in CBOR\n    /// but not JSON, to text strings, which are supported in both).</para>\n    /// <para>The example code given below (originally written in C# for\n    /// the.NET version) can be used to write out certain keys of a CBOR\n    /// map in a given order to a JSON string.</para>\n    /// <code>/* Generates a JSON string of 'mapObj' whose keys are in the order\n    /// given\n    /// in 'keys' . Only keys found in 'keys' will be written if they exist in\n    /// 'mapObj'. */ private static string KeysToJSONMap(CBORObject mapObj,\n    /// IList&lt;CBORObject&gt; keys) { if (mapObj == null) { throw new\n    /// ArgumentNullException)nameof(mapObj));}\n    /// if (keys == null) { throw new\n    /// ArgumentNullException)nameof(keys));}\n    /// if (obj.Type != CBORType.Map) {\n    /// throw new ArgumentException(\"'obj' is not a map.\"); } StringBuilder\n    /// builder = new StringBuilder(); var first = true; builder.Append(\"{\");\n    /// for (CBORObject key in keys) { if (mapObj.ContainsKey(key)) { if\n    /// (!first) {builder.Append(\", \");} var keyString=(key.CBORType ==\n    /// CBORType.String) ? key.AsString() : key.ToJSONString();\n    /// builder.Append(CBORObject.FromObject(keyString) .ToJSONString())\n    /// .Append(\":\").Append(mapObj[key].ToJSONString()); first=false; } } return\n    /// builder.Append(\"}\").ToString(); }</code>\n    ///  .\n    /// </summary>\n    /// <param name='options'>Specifies options to control writing the CBOR\n    /// object to JSON.</param>\n    /// <returns>A text string containing the converted object in JSON\n    /// format.</returns>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='options'/> is null.</exception>\n    public string ToJSONString(JSONOptions options) {\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      CBORType type = this.Type;\n      switch (type) {\n        case CBORType.Boolean:\n        case CBORType.SimpleValue: {\n          return this.IsTrue ? \"true\" : (this.IsFalse ? \"false\" : \"null\");\n        }\n        case CBORType.Integer: {\n          return this.AsEIntegerValue().ToString();\n        }\n        case CBORType.FloatingPoint: {\n          long dblbits = this.AsDoubleBits();\n          return CBORUtilities.DoubleBitsFinite(dblbits) ?\n               CBORUtilities.DoubleBitsToString(dblbits) : \"null\";\n        }\n        default: {\n          var sb = new StringBuilder();\n          try {\n            CBORJsonWriter.WriteJSONToInternal(\n              this,\n              new StringOutput(sb),\n              options);\n          } catch (IOException ex) {\n            // This is truly exceptional\n            throw new InvalidOperationException(\"Internal error\", ex);\n          }\n          return sb.ToString();\n        }\n      }\n    }\n\n    /// <summary>Returns this CBOR object in a text form intended to be\n    /// read by humans. The value returned by this method is not intended\n    /// to be parsed by computer programs, and the exact text of the value\n    /// may change at any time between versions of this library.\n    /// <para>The returned string is not necessarily in JavaScript Object\n    /// Notation (JSON); to convert CBOR objects to JSON strings, use the\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// method instead.</para></summary>\n    /// <returns>A text representation of this object.</returns>\n    public override string ToString() {\n      return CBORDataUtilities.ToStringHelper(this, 0);\n    }\n\n    /// <summary>Gets an object with the same value as this one but without\n    /// the tags it has, if any. If this object is an array, map, or byte\n    /// string, the data will not be copied to the returned object, so\n    /// changes to the returned object will be reflected in this\n    /// one.</summary>\n    /// <returns>A CBOR object.</returns>\n    public CBORObject Untag() {\n      CBORObject curobject = this;\n      while (curobject.itemtypeValue == CBORObjectTypeTagged) {\n        curobject = (CBORObject)curobject.itemValue;\n      }\n      return curobject;\n    }\n\n    /// <summary>Gets an object with the same value as this one but without\n    /// this object's outermost tag, if any. If this object is an array,\n    /// map, or byte string, the data will not be copied to the returned\n    /// object, so changes to the returned object will be reflected in this\n    /// one.</summary>\n    /// <returns>A CBOR object.</returns>\n    public CBORObject UntagOne() {\n      return (this.itemtypeValue == CBORObjectTypeTagged) ?\n        ((CBORObject)this.itemValue) : this;\n    }\n\n    /// <summary>Converts this object to a text string in JavaScript Object\n    /// Notation (JSON) format, as in the ToJSONString method, and writes\n    /// that string to a data stream in UTF-8. If the CBOR object contains\n    /// CBOR maps, or is a CBOR map, the order in which the keys to the map\n    /// are written out to the JSON string is undefined unless the map was\n    /// created using the NewOrderedMap method. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    /// <example>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) writes out a CBOR object as part of a JSON text sequence\n    /// (RFC 7464).</para>\n    /// <code>\n    /// stream.WriteByte(0x1e); &#x2f;&#x2a; RS &#x2a;&#x2f;\n    /// cborObject.WriteJSONTo(stream); &#x2f;&#x2a; JSON &#x2a;&#x2f;\n    /// stream.WriteByte(0x0a); &#x2f;&#x2a; LF &#x2a;&#x2f;\n    /// </code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use the <c>LimitedMemoryStream</c>\n    ///  class\n    /// (implemented in <i>LimitedMemoryStream.cs</i>\n    ///  in the peteroupc/CBOR\n    /// open-source repository) to limit the size of supported JSON\n    /// serializations of CBOR objects.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;\n    /// var maxSize = 20000;\n    /// using (var ms = new LimitedMemoryStream(maxSize)) {\n    /// cborObject.WriteJSONTo(ms);\n    /// var bytes = ms.ToArray();\n    /// }\n    /// </code>\n    /// <para>The following example (written in Java for the Java version)\n    /// shows how to use a subclassed <c>OutputStream</c>\n    ///  together with a\n    /// <c>ByteArrayOutputStream</c>\n    ///  to limit the size of supported JSON\n    /// serializations of CBOR objects.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported JSON size in bytes&#x2a;&#x2f;\n    /// final int maxSize = 20000;\n    /// ByteArrayOutputStream ba = new ByteArrayOutputStream();\n    /// &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;\n    /// cborObject.WriteJSONTo(new FilterOutputStream(ba) {\n    /// private int size = 0;\n    /// public void write(byte[] b, int off, int len) throws IOException {\n    /// if (len&gt;(maxSize-size)) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size+=len; out.write(b, off, len);\n    /// }\n    /// public void write(byte b) throws IOException {\n    /// if (size &gt;= maxSize) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size++; out.write(b);\n    /// }\n    /// });\n    /// byte[] bytes = ba.toByteArray();\n    /// </code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use a.NET MemoryStream to limit the size of\n    /// supported JSON serializations of CBOR objects. The disadvantage is\n    /// that the extra memory needed to do so can be wasteful, especially\n    /// if the average serialized object is much smaller than the maximum\n    /// size given (for example, if the maximum size is 20000 bytes, but\n    /// the average serialized object has a size of 50 bytes).</para>\n    /// <code>\n    /// var backing = new byte[20000]; &#x2f;&#x2a; maximum supported JSON size in\n    /// bytes&#x2a;&#x2f;\n    /// byte[] bytes1, bytes2;\n    /// using (var ms = new MemoryStream(backing)) {\n    /// &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;\n    /// cborObject.WriteJSONTo(ms);\n    /// bytes1 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);\n    /// &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;\n    /// ms.Position = 0;\n    /// cborObject2.WriteJSONTo(ms);\n    /// bytes2 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);\n    /// }\n    /// </code>\n    /// </example>\n    public void WriteJSONTo(Stream outputStream) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      CBORJsonWriter.WriteJSONToInternal(\n        this,\n        new StringOutput(outputStream),\n        JSONOptions.Default);\n    }\n\n    /// <summary>Converts this object to a text string in JavaScript Object\n    /// Notation (JSON) format, as in the ToJSONString method, and writes\n    /// that string to a data stream in UTF-8, using the given JSON options\n    /// to control the encoding process. If the CBOR object contains CBOR\n    /// maps, or is a CBOR map, the order in which the keys to the map are\n    /// written out to the JSON string is undefined unless the map was\n    /// created using the NewOrderedMap method. The example code given in\n    /// <b>PeterO.Cbor.CBORObject.ToJSONString(PeterO.Cbor.JSONOptions)</b>\n    /// can be used to write out certain keys of a CBOR map in a given\n    /// order to a JSON string.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='options'>An object containing the options to control\n    /// writing the CBOR object to JSON.</param>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public void WriteJSONTo(Stream outputStream, JSONOptions options) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      CBORJsonWriter.WriteJSONToInternal(\n        this,\n        new StringOutput(outputStream),\n        options);\n    }\n\n    /// <summary>Generates a CBOR object from a floating-point number\n    /// represented by its bits.</summary>\n    /// <param name='floatingBits'>The bits of a floating-point number\n    /// number to write.</param>\n    /// <param name='byteCount'>The number of bytes of the stored\n    /// floating-point number; this also specifies the format of the\n    /// \"floatingBits\" parameter. This value can be 2 if \"floatingBits\"'s\n    /// lowest (least significant) 16 bits identify the floating-point\n    /// number in IEEE 754r binary16 format; or 4 if \"floatingBits\"'s\n    /// lowest (least significant) 32 bits identify the floating-point\n    /// number in IEEE 754r binary32 format; or 8 if \"floatingBits\"\n    /// identifies the floating point number in IEEE 754r binary64 format.\n    /// Any other values for this parameter are invalid.</param>\n    /// <returns>A CBOR object storing the given floating-point\n    /// number.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    public static CBORObject FromFloatingPointBits(\n      long floatingBits,\n      int byteCount) {\n      long value;\n      switch (byteCount) {\n        case 2:\n          value = CBORUtilities.HalfToDoublePrecision(\n              unchecked((int)(floatingBits & 0xffffL)));\n          return new CBORObject(CBORObjectTypeDouble, value);\n        case 4:\n\n          value = CBORUtilities.SingleToDoublePrecision(\n              unchecked((int)(floatingBits & 0xffffffffL)));\n          return new CBORObject(CBORObjectTypeDouble, value);\n        case 8:\n          return new CBORObject(CBORObjectTypeDouble, floatingBits);\n        default: throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes the bits of a floating-point number in CBOR format\n    /// to a data stream.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='floatingBits'>The bits of a floating-point number\n    /// number to write.</param>\n    /// <param name='byteCount'>The number of bytes of the stored\n    /// floating-point number; this also specifies the format of the\n    /// \"floatingBits\" parameter. This value can be 2 if \"floatingBits\"'s\n    /// lowest (least significant) 16 bits identify the floating-point\n    /// number in IEEE 754r binary16 format; or 4 if \"floatingBits\"'s\n    /// lowest (least significant) 32 bits identify the floating-point\n    /// number in IEEE 754r binary32 format; or 8 if \"floatingBits\"\n    /// identifies the floating point number in IEEE 754r binary64 format.\n    /// Any other values for this parameter are invalid. This method will\n    /// write one plus this many bytes to the data stream.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointBits(\n      Stream outputStream,\n      long floatingBits,\n      int byteCount) {\n      return WriteFloatingPointBits(\n          outputStream,\n          floatingBits,\n          byteCount,\n          false);\n    }\n\n    /// <summary>Writes the bits of a floating-point number in CBOR format\n    /// to a data stream.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='floatingBits'>The bits of a floating-point number\n    /// number to write.</param>\n    /// <param name='byteCount'>The number of bytes of the stored\n    /// floating-point number; this also specifies the format of the\n    /// \"floatingBits\" parameter. This value can be 2 if \"floatingBits\"'s\n    /// lowest (least significant) 16 bits identify the floating-point\n    /// number in IEEE 754r binary16 format; or 4 if \"floatingBits\"'s\n    /// lowest (least significant) 32 bits identify the floating-point\n    /// number in IEEE 754r binary32 format; or 8 if \"floatingBits\"\n    /// identifies the floating point number in IEEE 754r binary64 format.\n    /// Any other values for this parameter are invalid.</param>\n    /// <param name='shortestForm'>If true, writes the shortest form of the\n    /// floating-point number that preserves its value. If false, this\n    /// method will write the number in the form given by 'floatingBits' by\n    /// writing one plus the number of bytes given by 'byteCount' to the\n    /// data stream.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointBits(\n      Stream outputStream,\n      long floatingBits,\n      int byteCount,\n      bool shortestForm) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (shortestForm) {\n        if (byteCount == 8) {\n          int bits =\n            CBORUtilities.DoubleToHalfPrecisionIfSameValue(floatingBits);\n          if (bits != -1) {\n            return WriteFloatingPointBits(outputStream, (long)bits, 2, false);\n          }\n          if (CBORUtilities.DoubleRetainsSameValueInSingle(floatingBits)) {\n            bits = CBORUtilities.DoubleToRoundedSinglePrecision(floatingBits);\n            return WriteFloatingPointBits(outputStream, (long)bits, 4, false);\n          }\n        } else if (byteCount == 4) {\n          int bits =\n            CBORUtilities.SingleToHalfPrecisionIfSameValue(floatingBits);\n          if (bits != -1) {\n            return WriteFloatingPointBits(outputStream, (long)bits, 2, false);\n          }\n        }\n      }\n      byte[] bytes;\n      switch (byteCount) {\n        case 2:\n          bytes = new byte[] {\n            (byte)0xf9,\n            (byte)((floatingBits >> 8) & 0xffL),\n            (byte)(floatingBits & 0xffL),\n          };\n          outputStream.Write(bytes, 0, 3);\n          return 3;\n        case 4:\n          bytes = new byte[] {\n            (byte)0xfa,\n            (byte)((floatingBits >> 24) & 0xffL),\n            (byte)((floatingBits >> 16) & 0xffL),\n            (byte)((floatingBits >> 8) & 0xffL),\n            (byte)(floatingBits & 0xffL),\n          };\n          outputStream.Write(bytes, 0, 5);\n          return 5;\n        case 8:\n          bytes = new byte[] {\n            (byte)0xfb,\n            (byte)((floatingBits >> 56) & 0xffL),\n            (byte)((floatingBits >> 48) & 0xffL),\n            (byte)((floatingBits >> 40) & 0xffL),\n            (byte)((floatingBits >> 32) & 0xffL),\n            (byte)((floatingBits >> 24) & 0xffL),\n            (byte)((floatingBits >> 16) & 0xffL),\n            (byte)((floatingBits >> 8) & 0xffL),\n            (byte)(floatingBits & 0xffL),\n          };\n          outputStream.Write(bytes, 0, 9);\n          return 9;\n        default:\n          throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes a 64-bit binary floating-point number in CBOR\n    /// format to a data stream, either in its 64-bit form, or its rounded\n    /// 32-bit or 16-bit equivalent.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='doubleVal'>The double-precision floating-point number\n    /// to write.</param>\n    /// <param name='byteCount'>The number of 8-bit bytes of the stored\n    /// number. This value can be 2 to store the number in IEEE 754r\n    /// binary16, rounded to nearest, ties to even; or 4 to store the\n    /// number in IEEE 754r binary32, rounded to nearest, ties to even; or\n    /// 8 to store the number in IEEE 754r binary64. Any other values for\n    /// this parameter are invalid.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointValue(\n      Stream outputStream,\n      double doubleVal,\n      int byteCount) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      long bits = 0;\n      switch (byteCount) {\n        case 2:\n          bits = CBORUtilities.DoubleToInt64Bits(doubleVal);\n          bits = CBORUtilities.DoubleToRoundedHalfPrecision(bits);\n          bits &= 0xffffL;\n          return WriteFloatingPointBits(outputStream, bits, 2);\n        case 4:\n          bits = CBORUtilities.DoubleToInt64Bits(doubleVal);\n          bits = CBORUtilities.DoubleToRoundedSinglePrecision(bits);\n          bits &= 0xffffffffL;\n          return WriteFloatingPointBits(outputStream, bits, 4);\n        case 8:\n          bits = CBORUtilities.DoubleToInt64Bits(doubleVal);\n          return WriteFloatingPointBits(outputStream, bits, 8);\n        default: throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes a 32-bit binary floating-point number in CBOR\n    /// format to a data stream, either in its 64- or 32-bit form, or its\n    /// rounded 16-bit equivalent.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='singleVal'>The single-precision floating-point number\n    /// to write.</param>\n    /// <param name='byteCount'>The number of 8-bit bytes of the stored\n    /// number. This value can be 2 to store the number in IEEE 754r\n    /// binary16, rounded to nearest, ties to even; or 4 to store the\n    /// number in IEEE 754r binary32; or 8 to store the number in IEEE 754r\n    /// binary64. Any other values for this parameter are invalid.</param>\n    /// <returns>The number of 8-bit bytes ordered to be written to the\n    /// data stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='byteCount'/> is other than 2, 4, or 8.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    public static int WriteFloatingPointValue(\n      Stream outputStream,\n      float singleVal,\n      int byteCount) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      var bits = 0;\n      long longbits = 0L;\n      switch (byteCount) {\n        case 2:\n          bits = BitConverter.ToInt32(\n              BitConverter.GetBytes((float)singleVal),\n              0);\n          bits = CBORUtilities.SingleToRoundedHalfPrecision(bits);\n          bits &= 0xffff;\n          return WriteFloatingPointBits(outputStream, bits, 2);\n        case 4:\n          bits = BitConverter.ToInt32(\n              BitConverter.GetBytes((float)singleVal),\n              0);\n          longbits = ((long)bits) & 0xffffffffL;\n          return WriteFloatingPointBits(outputStream, longbits, 4);\n        case 8:\n          bits = BitConverter.ToInt32(\n              BitConverter.GetBytes((float)singleVal),\n              0);\n          longbits = CBORUtilities.SingleToDoublePrecision(bits);\n          return WriteFloatingPointBits(outputStream, longbits, 8);\n        default: throw new ArgumentOutOfRangeException(nameof(byteCount));\n      }\n    }\n\n    /// <summary>Writes a CBOR major type number and an integer 0 or\n    /// greater associated with it to a data stream, where that integer is\n    /// passed to this method as a 64-bit signed integer. This is a\n    /// low-level method that is useful for implementing custom CBOR\n    /// encoding methodologies. This method encodes the given major type\n    /// and value in the shortest form allowed for the major\n    /// type.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='majorType'>The CBOR major type to write. This is a\n    /// number from 0 through 7 as follows. 0: integer 0 or greater; 1:\n    /// negative integer; 2: byte string; 3: UTF-8 text string; 4: array;\n    /// 5: map; 6: tag; 7: simple value. See RFC 8949 for details on these\n    /// major types.</param>\n    /// <param name='value'>An integer 0 or greater associated with the\n    /// major type, as follows. 0: integer 0 or greater; 1: the negative\n    /// integer's absolute value is 1 plus this number; 2: length in bytes\n    /// of the byte string; 3: length in bytes of the UTF-8 text string; 4:\n    /// number of items in the array; 5: number of key-value pairs in the\n    /// map; 6: tag number; 7: simple value number, which must be in the\n    /// interval [0, 23] or [32, 255].</param>\n    /// <returns>The number of bytes ordered to be written to the data\n    /// stream.</returns>\n    /// <exception cref='ArgumentException'>Value is from 24 to 31 and\n    /// major type is 7.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    /// <remarks>There are other useful things to note when encoding CBOR\n    /// that are not covered by this WriteValue method. To mark the start\n    /// of an indefinite-length array, write the 8-bit byte 0x9f to the\n    /// output stream. To mark the start of an indefinite-length map, write\n    /// the 8-bit byte 0xbf to the output stream. To mark the end of an\n    /// indefinite-length array or map, write the 8-bit byte 0xff to the\n    /// output stream. For examples, see the WriteValue(Stream, int, int)\n    /// overload.</remarks>\n    public static int WriteValue(\n      Stream outputStream,\n      int majorType,\n      long value) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (majorType < 0) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is less than 0\");\n      }\n      if (majorType > 7) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is more than 7\");\n      }\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value +\n          \") is less than 0\");\n      }\n      if (majorType == 7) {\n        if (value > 255) {\n          throw new ArgumentException(\"value(\" + value +\n            \") is more than 255\");\n        }\n        if (value <= 23) {\n          outputStream.WriteByte((byte)(0xe0 + (int)value));\n          return 1;\n        } else if (value < 32) {\n          throw new ArgumentException(\"value is from 24 to 31 and major\" +\n            \" type is 7\");\n        } else {\n          outputStream.WriteByte((byte)0xf8);\n          outputStream.WriteByte((byte)value);\n          return 2;\n        }\n      } else {\n        return WritePositiveInt64(majorType, value, outputStream);\n      }\n    }\n\n    /// <summary>Writes a CBOR major type number and an integer 0 or\n    /// greater associated with it to a data stream, where that integer is\n    /// passed to this method as a 32-bit signed integer. This is a\n    /// low-level method that is useful for implementing custom CBOR\n    /// encoding methodologies. This method encodes the given major type\n    /// and value in the shortest form allowed for the major\n    /// type.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='majorType'>The CBOR major type to write. This is a\n    /// number from 0 through 7 as follows. 0: integer 0 or greater; 1:\n    /// negative integer; 2: byte string; 3: UTF-8 text string; 4: array;\n    /// 5: map; 6: tag; 7: simple value. See RFC 8949 for details on these\n    /// major types.</param>\n    /// <param name='value'>An integer 0 or greater associated with the\n    /// major type, as follows. 0: integer 0 or greater; 1: the negative\n    /// integer's absolute value is 1 plus this number; 2: length in bytes\n    /// of the byte string; 3: length in bytes of the UTF-8 text string; 4:\n    /// number of items in the array; 5: number of key-value pairs in the\n    /// map; 6: tag number; 7: simple value number, which must be in the\n    /// interval [0, 23] or [32, 255].</param>\n    /// <returns>The number of bytes ordered to be written to the data\n    /// stream.</returns>\n    /// <exception cref='ArgumentException'>Value is from 24 to 31 and\n    /// major type is 7.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> is null.</exception>\n    /// <remarks>There are other useful things to note when encoding CBOR\n    /// that are not covered by this WriteValue method. To mark the start\n    /// of an indefinite-length array, write the 8-bit byte 0x9f to the\n    /// output stream. To mark the start of an indefinite-length map, write\n    /// the 8-bit byte 0xbf to the output stream. To mark the end of an\n    /// indefinite-length array or map, write the 8-bit byte 0xff to the\n    /// output stream.</remarks>\n    /// <example>\n    /// <para>In the following example, an array of three objects is\n    /// written as CBOR to a data stream.</para>\n    /// <code>&#x2f;&#x2a; array, length 3&#x2a;&#x2f;\n    /// CBORObject.WriteValue(stream, 4, 3);\n    /// &#x2f;&#x2a; item 1 */\n    /// CBORObject.Write(\"hello world\", stream);\n    /// CBORObject.Write(25, stream); &#x2f;&#x2a; item 2&#x2a;&#x2f;\n    /// CBORObject.Write(false, stream); &#x2f;&#x2a; item 3&#x2a;&#x2f;</code>\n    /// <para>In the following example, a map consisting of two key-value\n    /// pairs is written as CBOR to a data stream.</para>\n    /// <code>CBORObject.WriteValue(stream, 5, 2); &#x2f;&#x2a; map, 2\n    /// pairs&#x2a;&#x2f;\n    /// CBORObject.Write(\"number\", stream); &#x2f;&#x2a; key 1 */\n    /// CBORObject.Write(25, stream); &#x2f;&#x2a; value 1 */\n    /// CBORObject.Write(\"string\", stream); &#x2f;&#x2a; key 2&#x2a;&#x2f;\n    /// CBORObject.Write(\"hello\", stream); &#x2f;&#x2a; value 2&#x2a;&#x2f;</code>\n    /// <para>In the following example (originally written in C# for\n    /// the.NET Framework version), a text string is written as CBOR to a\n    /// data stream.</para>\n    /// <code>string str = \"hello world\"; byte[] bytes =\n    /// DataUtilities.GetUtf8Bytes(str, true); CBORObject.WriteValue(stream, 4,\n    /// bytes.Length); stream.Write(bytes, 0, bytes.Length);</code>\n    ///  .\n    /// </example>\n    public static int WriteValue(\n      Stream outputStream,\n      int majorType,\n      int value) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (majorType < 0) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is less than 0\");\n      }\n      if (majorType > 7) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is more than 7\");\n      }\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value +\n          \") is less than 0\");\n      }\n      if (majorType == 7) {\n        if (value > 255) {\n          throw new ArgumentException(\"value(\" + value +\n            \") is more than 255\");\n        }\n        if (value <= 23) {\n          outputStream.WriteByte((byte)(0xe0 + value));\n          return 1;\n        } else if (value < 32) {\n          throw new ArgumentException(\"value is from 24 to 31 and major\" +\n            \"\\u0020type\" + \"\\u0020is 7\");\n        } else {\n          outputStream.WriteByte((byte)0xf8);\n          outputStream.WriteByte((byte)value);\n          return 2;\n        }\n      } else {\n        return WritePositiveInt(majorType, value, outputStream);\n      }\n    }\n\n    /// <summary>Writes a CBOR major type number and an integer 0 or\n    /// greater associated with it to a data stream, where that integer is\n    /// passed to this method as an arbitrary-precision integer. This is a\n    /// low-level method that is useful for implementing custom CBOR\n    /// encoding methodologies. This method encodes the given major type\n    /// and value in the shortest form allowed for the major\n    /// type.</summary>\n    /// <param name='outputStream'>A writable data stream.</param>\n    /// <param name='majorType'>The CBOR major type to write. This is a\n    /// number from 0 through 7 as follows. 0: integer 0 or greater; 1:\n    /// negative integer; 2: byte string; 3: UTF-8 text string; 4: array;\n    /// 5: map; 6: tag; 7: simple value. See RFC 8949 for details on these\n    /// major types.</param>\n    /// <param name='bigintValue'>An integer 0 or greater associated with\n    /// the major type, as follows. 0: integer 0 or greater; 1: the\n    /// negative integer's absolute value is 1 plus this number; 2: length\n    /// in bytes of the byte string; 3: length in bytes of the UTF-8 text\n    /// string; 4: number of items in the array; 5: number of key-value\n    /// pairs in the map; 6: tag number; 7: simple value number, which must\n    /// be in the interval [0, 23] or [32, 255]. For major types 0 to 6,\n    /// this number may not be greater than 2^64 - 1.</param>\n    /// <returns>The number of bytes ordered to be written to the data\n    /// stream.</returns>\n    /// <exception cref='ArgumentException'>The parameter <paramref\n    /// name='majorType'/> is 7 and value is greater than 255.</exception>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='outputStream'/> or <paramref name='bigintValue'/> is\n    /// null.</exception>\n    /// <remarks>There are other useful things to note when encoding CBOR\n    /// that are not covered by this WriteValue method. To mark the start\n    /// of an indefinite-length array, write the 8-bit byte 0x9f to the\n    /// output stream. To mark the start of an indefinite-length map, write\n    /// the 8-bit byte 0xbf to the output stream. To mark the end of an\n    /// indefinite-length array or map, write the 8-bit byte 0xff to the\n    /// output stream.</remarks>\n    public static int WriteValue(\n      Stream outputStream,\n      int majorType,\n      EInteger bigintValue) {\n      if (outputStream == null) {\n        throw new ArgumentNullException(nameof(outputStream));\n      }\n      if (bigintValue == null) {\n        throw new ArgumentNullException(nameof(bigintValue));\n      }\n      if (bigintValue.Sign < 0) {\n        throw new ArgumentException(\"tagEInt's sign(\" + bigintValue.Sign +\n          \") is less than 0\");\n      }\n      if (bigintValue.CompareTo(UInt64MaxValue) > 0) {\n        throw new ArgumentException(\n          \"tag more than 18446744073709551615 (\" + bigintValue + \")\");\n      }\n      if (bigintValue.CanFitInInt64()) {\n        return WriteValue(\n            outputStream,\n            majorType,\n            bigintValue.ToInt64Checked());\n      }\n      long longVal = bigintValue.ToInt64Unchecked();\n      var highbyte = (int)((longVal >> 56) & 0xff);\n      if (majorType < 0) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is less than 0\");\n      }\n      if (majorType > 7) {\n        throw new ArgumentException(\"majorType(\" + majorType +\n          \") is more than 7\");\n      }\n      if (majorType == 7) {\n        throw new ArgumentException(\n          \"majorType is 7 and value is greater\" + \"\\u0020than 255\");\n      }\n      byte[] bytes = new[] {\n        (byte)(27 | (majorType << 5)), (byte)highbyte,\n        (byte)((longVal >> 48) & 0xff), (byte)((longVal >> 40) & 0xff),\n        (byte)((longVal >> 32) & 0xff), (byte)((longVal >> 24) & 0xff),\n        (byte)((longVal >> 16) & 0xff), (byte)((longVal >> 8) & 0xff),\n        (byte)(longVal & 0xff),\n      };\n      outputStream.Write(bytes, 0, bytes.Length);\n      return bytes.Length;\n    }\n\n    /// <summary><para>Writes this CBOR object to a data stream. If the\n    /// CBOR object contains CBOR maps, or is a CBOR map, the order in\n    /// which the keys to the map are written out to the data stream is\n    /// undefined unless the map was created using the NewOrderedMap\n    /// method. See the examples (originally written in C# for the.NET\n    /// version) for ways to write out certain keys of a CBOR map in a\n    /// given order. In the case of CBOR objects of type FloatingPoint, the\n    /// number is written using the shortest floating-point encoding\n    /// possible; this is a change from previous versions.</para>\n    /// </summary>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <example>\n    /// <para>The following example shows a method that writes each key of\n    /// 'mapObj' to 'outputStream', in the order given in 'keys', where\n    /// 'mapObj' is written out in the form of a CBOR <b>definite-length\n    /// map</b>\n    /// . Only keys found in 'keys' will be written if they exist\n    /// in 'mapObj'.</para>\n    /// <code>private static void WriteKeysToMap(CBORObject mapObj,\n    /// IList&lt;CBORObject&gt; keys, Stream outputStream) {\n    /// if (mapObj == null) {\n    /// throw new ArgumentNullException(nameof(mapObj));}\n    /// if (keys == null)\n    /// {throw new ArgumentNullException(nameof(keys));}\n    /// if (outputStream ==\n    /// null) {throw new ArgumentNullException(nameof(outputStream));}\n    /// if\n    /// (obj.Type!=CBORType.Map) { throw new ArgumentException(\"'obj' is not a\n    /// map.\"); } int keyCount = 0; for (CBORObject key in keys) { if\n    /// (mapObj.ContainsKey(key)) { keyCount++; } }\n    /// CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in\n    /// keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);\n    /// mapObj[key].WriteTo(outputStream); } } }</code>\n    /// <para>The following example shows a method that writes each key of\n    /// 'mapObj' to 'outputStream', in the order given in 'keys', where\n    /// 'mapObj' is written out in the form of a CBOR <b>indefinite-length\n    /// map</b>\n    /// . Only keys found in 'keys' will be written if they exist\n    /// in 'mapObj'.</para>\n    /// <code>private static void WriteKeysToIndefMap(CBORObject mapObj,\n    /// IList&lt;CBORObject&gt; keys, Stream outputStream) { if (mapObj == null)\n    /// { throw new ArgumentNullException(nameof(mapObj));}\n    /// if (keys == null)\n    /// {throw new ArgumentNullException(nameof(keys));}\n    /// if (outputStream ==\n    /// null) {throw new ArgumentNullException(nameof(outputStream));}\n    /// if\n    /// (obj.Type!=CBORType.Map) { throw new ArgumentException(\"'obj' is not a\n    /// map.\"); } outputStream.WriteByte((byte)0xBF); for (CBORObject key in\n    /// keys) { if (mapObj.ContainsKey(key)) { key.WriteTo(outputStream);\n    /// mapObj[key].WriteTo(outputStream); } }\n    /// outputStream.WriteByte((byte)0xff); }</code>\n    /// <para>The following example shows a method that writes out a list\n    /// of objects to 'outputStream' as an <b>indefinite-length CBOR\n    /// array</b>\n    /// .</para>\n    /// <code>private static void WriteToIndefArray(IList&lt;object&gt; list,\n    /// Stream\n    /// outputStream) { if (list == null) { throw new\n    /// ArgumentNullException(nameof(list));}\n    /// if (outputStream == null) {throw\n    /// new ArgumentNullException(nameof(outputStream));}\n    /// outputStream.WriteByte((byte)0x9f); for (object item in list) { new\n    /// CBORObject(item).WriteTo(outputStream); }\n    /// outputStream.WriteByte((byte)0xff); }</code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use the <c>LimitedMemoryStream</c>\n    ///  class\n    /// (implemented in <i>LimitedMemoryStream.cs</i>\n    ///  in the peteroupc/CBOR\n    /// open-source repository) to limit the size of supported CBOR\n    /// serializations.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;\n    /// var maxSize = 20000;\n    /// using (var ms = new LimitedMemoryStream(maxSize)) {\n    /// cborObject.WriteTo(ms);\n    /// var bytes = ms.ToArray();\n    /// }\n    /// </code>\n    /// <para>The following example (written in Java for the Java version)\n    /// shows how to use a subclassed <c>OutputStream</c>\n    ///  together with a\n    /// <c>ByteArrayOutputStream</c>\n    ///  to limit the size of supported CBOR\n    /// serializations.</para>\n    /// <code>\n    /// &#x2f;&#x2a; maximum supported CBOR size in bytes&#x2a;&#x2f;\n    /// final int maxSize = 20000;\n    /// ByteArrayOutputStream ba = new ByteArrayOutputStream();\n    /// &#x2f;&#x2a; throws UnsupportedOperationException if too big&#x2a;&#x2f;\n    /// cborObject.WriteTo(new FilterOutputStream(ba) {\n    /// private int size = 0;\n    /// public void write(byte[] b, int off, int len) throws IOException {\n    /// if (len&gt;(maxSize-size)) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size+=len; out.write(b, off, len);\n    /// }\n    /// public void write(byte b) throws IOException {\n    /// if (size &gt;= maxSize) {\n    /// throw new UnsupportedOperationException();\n    /// }\n    /// size++; out.write(b);\n    /// }\n    /// });\n    /// byte[] bytes = ba.toByteArray();\n    /// </code>\n    /// <para>The following example (originally written in C# for the.NET\n    /// version) shows how to use a.NET MemoryStream to limit the size of\n    /// supported CBOR serializations. The disadvantage is that the extra\n    /// memory needed to do so can be wasteful, especially if the average\n    /// serialized object is much smaller than the maximum size given (for\n    /// example, if the maximum size is 20000 bytes, but the average\n    /// serialized object has a size of 50 bytes).</para>\n    /// <code>\n    /// var backing = new byte[20000]; &#x2f;&#x2a; maximum supported CBOR size in\n    /// bytes&#x2a;&#x2f;\n    /// byte[] bytes1, bytes2;\n    /// using (var ms = new MemoryStream(backing)) {\n    /// &#x2f;&#x2a; throws NotSupportedException if too big&#x2a;&#x2f;\n    /// cborObject.WriteTo(ms);\n    /// bytes1 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes1, 0, (int)ms.Position);\n    /// &#x2f;&#x2a; Reset memory stream&#x2a;&#x2f;\n    /// ms.Position = 0;\n    /// cborObject2.WriteTo(ms);\n    /// bytes2 = new byte[ms.Position];\n    /// &#x2f;&#x2a; Copy serialized data if successful&#x2a;&#x2f;\n    /// System.ArrayCopy(backing, 0, bytes2, 0, (int)ms.Position);\n    /// }\n    /// </code>\n    /// </example>\n    public void WriteTo(Stream stream) {\n      this.WriteTo(stream, CBOREncodeOptions.Default);\n    }\n\n    /// <summary>Writes this CBOR object to a data stream, using the\n    /// specified options for encoding the data to CBOR format. If the CBOR\n    /// object contains CBOR maps, or is a CBOR map, the order in which the\n    /// keys to the map are written out to the data stream is undefined\n    /// unless the map was created using the NewOrderedMap method. The\n    /// example code given in\n    /// <see cref='PeterO.Cbor.CBORObject.WriteTo(System.IO.Stream)'/> can\n    /// be used to write out certain keys of a CBOR map in a given order.\n    /// In the case of CBOR objects of type FloatingPoint, the number is\n    /// written using the shortest floating-point encoding possible; this\n    /// is a change from previous versions.</summary>\n    /// <param name='stream'>A writable data stream.</param>\n    /// <param name='options'>Options for encoding the data to\n    /// CBOR.</param>\n    /// <exception cref='ArgumentNullException'>The parameter <paramref\n    /// name='stream'/> is null.</exception>\n    /// <exception cref='System.IO.IOException'>An I/O error\n    /// occurred.</exception>\n    /// <exception cref='ArgumentException'>Unexpected data\n    /// type\".</exception>\n    public void WriteTo(Stream stream, CBOREncodeOptions options) {\n      if (stream == null) {\n        throw new ArgumentNullException(nameof(stream));\n      }\n      if (options == null) {\n        throw new ArgumentNullException(nameof(options));\n      }\n      if (options.Ctap2Canonical) {\n        byte[] bytes = CBORCanonical.CtapCanonicalEncode(this);\n        stream.Write(bytes, 0, bytes.Length);\n        return;\n      }\n      this.WriteTags(stream);\n      int type = this.ItemType;\n      switch (type) {\n        case CBORObjectTypeInteger: {\n          Write((long)this.ThisItem, stream);\n          break;\n        }\n        case CBORObjectTypeEInteger: {\n          Write((EInteger)this.ThisItem, stream);\n          break;\n        }\n        case CBORObjectTypeByteString:\n        case CBORObjectTypeTextStringUtf8: {\n          byte[] arr = (byte[])this.ThisItem;\n          WritePositiveInt(\n            (this.Type == CBORType.ByteString) ? 2 : 3,\n            arr.Length,\n            stream);\n          stream.Write(arr, 0, arr.Length);\n          break;\n        }\n        case CBORObjectTypeTextString:\n        case CBORObjectTypeTextStringAscii: {\n          Write((string)this.ThisItem, stream, options);\n          break;\n        }\n        case CBORObjectTypeArray: {\n          WriteObjectArray(this.AsList(), stream, options);\n          break;\n        }\n        case CBORObjectTypeMap: {\n          WriteObjectMap(this.AsMap(), stream, options);\n          break;\n        }\n        case CBORObjectTypeSimpleValue: {\n          int value = this.SimpleValue;\n          if (value < 24) {\n            stream.WriteByte((byte)(0xe0 + value));\n          } else {\n            #if DEBUG\n            if (value < 32) {\n              throw new ArgumentException(\"value(\" + value +\n                \") is less than \" + \"32\");\n            }\n            #endif\n\n            stream.WriteByte(0xf8);\n            stream.WriteByte((byte)value);\n          }\n\n          break;\n        }\n        case CBORObjectTypeDouble: {\n          WriteFloatingPointBits(\n             stream,\n             this.AsDoubleBits(),\n             8,\n             !options.Float64);\n          break;\n        }\n        default: {\n          throw new ArgumentException(\"Unexpected data type\");\n        }\n      }\n    }\n\n    internal static CBORObject FromRaw(byte[] bytes) {\n      return new CBORObject(CBORObjectTypeByteString, bytes);\n    }\n\n    internal static CBORObject FromRawUtf8(byte[] bytes) {\n      return new CBORObject(CBORObjectTypeTextStringUtf8, bytes);\n    }\n\n    internal static CBORObject FromRaw(string str) {\n      #if DEBUG\n      if (!CBORUtilities.CheckUtf16(str)) {\n        throw new InvalidOperationException();\n      }\n      #endif\n      return new CBORObject(CBORObjectTypeTextString, str);\n    }\n\n    internal static CBORObject FromRaw(IList<CBORObject> list) {\n      return new CBORObject(CBORObjectTypeArray, list);\n    }\n\n    internal static CBORObject FromRaw(IDictionary<CBORObject, CBORObject>\n      map) {\n      return new CBORObject(CBORObjectTypeMap, map);\n    }\n\n    internal static int GetExpectedLength(int value) {\n      return ValueExpectedLengths[value];\n    }\n\n    // Generate a CBOR object for head bytes with fixed length.\n    // Note that this function assumes that the length of the data\n    // was already checked.\n    internal static CBORObject GetFixedLengthObject(\n      int firstbyte,\n      byte[] data) {\n      CBORObject fixedObj = FixedObjects[firstbyte];\n      if (fixedObj != null) {\n        return fixedObj;\n      }\n      int majortype = firstbyte >> 5;\n      if ((firstbyte & 0x1c) == 0x18) {\n        // contains 1 to 8 extra bytes of additional information\n        long uadditional = 0;\n        switch (firstbyte & 0x1f) {\n          case 24:\n            uadditional = (int)(data[1] & (int)0xff);\n            break;\n          case 25:\n            uadditional = (data[1] & 0xffL) << 8;\n            uadditional |= (long)(data[2] & 0xffL);\n            break;\n          case 26:\n            uadditional = (data[1] & 0xffL) << 24;\n            uadditional |= (data[2] & 0xffL) << 16;\n            uadditional |= (data[3] & 0xffL) << 8;\n            uadditional |= (long)(data[4] & 0xffL);\n            break;\n          case 27:\n            uadditional = (data[1] & 0xffL) << 56;\n            uadditional |= (data[2] & 0xffL) << 48;\n            uadditional |= (data[3] & 0xffL) << 40;\n            uadditional |= (data[4] & 0xffL) << 32;\n            uadditional |= (data[5] & 0xffL) << 24;\n            uadditional |= (data[6] & 0xffL) << 16;\n            uadditional |= (data[7] & 0xffL) << 8;\n            uadditional |= (long)(data[8] & 0xffL);\n            break;\n          default:\n            throw new CBORException(\"Unexpected data encountered\");\n        }\n        switch (majortype) {\n          case 0:\n            if ((uadditional >> 63) == 0) {\n              // use only if additional's top bit isn't set\n              // (additional is a signed long)\n              return new CBORObject(CBORObjectTypeInteger, uadditional);\n            } else {\n              int low = unchecked((int)(uadditional & 0xffffffffL));\n              int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));\n              return FromObject(LowHighToEInteger(low, high));\n            }\n          case 1:\n            if ((uadditional >> 63) == 0) {\n              // use only if additional's top bit isn't set\n              // (additional is a signed long)\n              return new CBORObject(\n                  CBORObjectTypeInteger,\n                  -1 - uadditional);\n            } else {\n              int low = unchecked((int)(uadditional & 0xffffffffL));\n              int high = unchecked((int)((uadditional >> 32) & 0xffffffffL));\n              EInteger bigintAdditional = LowHighToEInteger(low, high);\n              EInteger minusOne = -EInteger.One;\n              bigintAdditional = minusOne - (EInteger)bigintAdditional;\n              return FromObject(bigintAdditional);\n            }\n          case 7:\n            if (firstbyte >= 0xf9 && firstbyte <= 0xfb) {\n              var dblbits = (long)uadditional;\n              if (firstbyte == 0xf9) {\n                dblbits = CBORUtilities.HalfToDoublePrecision(\n                    unchecked((int)uadditional));\n              } else if (firstbyte == 0xfa) {\n                dblbits = CBORUtilities.SingleToDoublePrecision(\n                    unchecked((int)uadditional));\n              }\n              return new CBORObject(\n                  CBORObjectTypeDouble,\n                  dblbits);\n            }\n            if (firstbyte == 0xf8) {\n              if ((int)uadditional < 32) {\n                throw new CBORException(\"Invalid overlong simple value\");\n              }\n              return new CBORObject(\n                  CBORObjectTypeSimpleValue,\n                  (int)uadditional);\n            }\n            throw new CBORException(\"Unexpected data encountered\");\n          default: throw new CBORException(\"Unexpected data encountered\");\n        }\n      }\n      if (majortype == 2) { // short byte string\n        var ret = new byte[firstbyte - 0x40];\n        Array.Copy(data, 1, ret, 0, firstbyte - 0x40);\n        return new CBORObject(CBORObjectTypeByteString, ret);\n      }\n      if (majortype == 3) { // short text string\n        var ret = new byte[firstbyte - 0x60];\n        Array.Copy(data, 1, ret, 0, firstbyte - 0x60);\n        if (!CBORUtilities.CheckUtf8(ret)) {\n          throw new CBORException(\"Invalid encoding\");\n        }\n        return new CBORObject(CBORObjectTypeTextStringUtf8, ret);\n      }\n      if (firstbyte == 0x80) {\n        // empty array\n        return CBORObject.NewArray();\n      }\n      if (firstbyte == 0xa0) {\n        // empty map\n        return CBORObject.NewOrderedMap();\n      }\n      throw new CBORException(\"Unexpected data encountered\");\n    }\n\n    internal static CBORObject GetFixedObject(int value) {\n      return FixedObjects[value];\n    }\n\n    private IList<CBORObject> AsList() {\n      return (IList<CBORObject>)this.ThisItem;\n    }\n\n    private IDictionary<CBORObject, CBORObject> AsMap() {\n      return (IDictionary<CBORObject, CBORObject>)this.ThisItem;\n    }\n\n    private static bool CBORArrayEquals(\n      IList<CBORObject> listA,\n      IList<CBORObject> listB) {\n      if (listA == null) {\n        return listB == null;\n      }\n      if (listB == null) {\n        return false;\n      }\n      int listACount = listA.Count;\n      int listBCount = listB.Count;\n      if (listACount != listBCount) {\n        return false;\n      }\n      for (var i = 0; i < listACount; ++i) {\n        CBORObject itemA = listA[i];\n        CBORObject itemB = listB[i];\n        if (!(itemA == null ? itemB == null : itemA.Equals(itemB))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static int CBORArrayHashCode(IList<CBORObject> list) {\n      if (list == null) {\n        return 0;\n      }\n      var ret = 19;\n      int count = list.Count;\n      unchecked {\n        ret = (ret * 31) + count;\n        for (var i = 0; i < count; ++i) {\n          ret = (ret * 31) + list[i].GetHashCode();\n        }\n      }\n      return ret;\n    }\n\n    private static bool StringEquals(string str, string str2) {\n      if (str == str2) {\n        return true;\n      }\n      if (str.Length != str2.Length) {\n        return false;\n      }\n      int count = str.Length;\n      for (var i = 0; i < count; ++i) {\n        if (str[i] != str2[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static bool CBORMapEquals(\n      IDictionary<CBORObject, CBORObject> mapA,\n      IDictionary<CBORObject, CBORObject> mapB) {\n      if (mapA == null) {\n        return mapB == null;\n      }\n      if (mapB == null) {\n        return false;\n      }\n      if (mapA.Count != mapB.Count) {\n        return false;\n      }\n      foreach (KeyValuePair<CBORObject, CBORObject> kvp in mapA) {\n        CBORObject valueB = null;\n        bool hasKey = mapB.TryGetValue(kvp.Key, out valueB);\n        if (hasKey) {\n          CBORObject valueA = kvp.Value;\n          if (!(valueA == null ? valueB == null : valueA.Equals(valueB))) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private static int CBORMapHashCode(IDictionary<CBORObject, CBORObject>\n      a) {\n      // To simplify matters, we use just the count of\n      // the map as the basis for the hash code. More complicated\n      // hash code calculation would involve the sum of the hash codes of\n      // the map's key-value pairs (an approach that works regardless of the order\n      // in which map keys are iterated, because wraparound addition\n      // is commutative and associative), but this could take much more time\n      // to calculate, especially if the keys and values are very big.\n      return unchecked(a.Count.GetHashCode() * 19);\n    }\n\n    private static void CheckCBORLength(\n      long expectedLength,\n      long actualLength) {\n      if (actualLength < expectedLength) {\n        throw new CBORException(\"Premature end of data\");\n      }\n      if (actualLength > expectedLength) {\n        throw new CBORException(\n            \"Too many bytes. There is data beyond the decoded CBOR object.\");\n      }\n    }\n\n    private static void CheckCBORLength(int expectedLength, int\n      actualLength) {\n      if (actualLength < expectedLength) {\n        throw new CBORException(\"Premature end of data\");\n      }\n      if (actualLength > expectedLength) {\n        throw new CBORException(\n            \"Too many bytes. There is data beyond the decoded CBOR object.\");\n      }\n    }\n\n    private static string ExtendedToString(EFloat ef) {\n      if (ef.IsFinite && (ef.Exponent.CompareTo((EInteger)2500) > 0 ||\n          ef.Exponent.CompareTo((EInteger)(-2500)) < 0)) {\n        // It can take very long to convert a number with a very high\n        // or very low exponent to a decimal string, so do this instead\n        return ef.Mantissa + \"p\" + ef.Exponent;\n      }\n      return ef.ToString();\n    }\n\n    private static byte[] GetOptimizedBytesIfShortAscii(\n      string str,\n      int tagbyteInt) {\n      byte[] bytes;\n      if (str.Length <= 255) {\n        // The strings will usually be short ASCII strings, so\n        // use this optimization\n        var offset = 0;\n        int length = str.Length;\n        int extra = (length < 24) ? 1 : 2;\n        if (tagbyteInt >= 0) {\n          ++extra;\n        }\n        bytes = new byte[length + extra];\n        if (tagbyteInt >= 0) {\n          bytes[offset] = (byte)tagbyteInt;\n          ++offset;\n        }\n        if (length < 24) {\n          bytes[offset] = (byte)(0x60 + str.Length);\n          ++offset;\n        } else {\n          bytes[offset] = (byte)0x78;\n          bytes[offset + 1] = (byte)str.Length;\n          offset += 2;\n        }\n        var issimple = true;\n        for (var i = 0; i < str.Length; ++i) {\n          char c = str[i];\n          if (c >= 0x80) {\n            issimple = false;\n            break;\n          }\n          bytes[i + offset] = unchecked((byte)c);\n        }\n        if (issimple) {\n          return bytes;\n        }\n      }\n      return null;\n    }\n\n    private static string GetOptimizedStringIfShortAscii(\n      byte[] data,\n      int offset) {\n      int length = data.Length;\n      if (length > offset) {\n        var nextbyte = (int)(data[offset] & (int)0xff);\n        if (nextbyte >= 0x60 && nextbyte < 0x78) {\n          int offsetp1 = 1 + offset;\n          // Check for type 3 string of short length\n          int rightLength = offsetp1 + (nextbyte - 0x60);\n          CheckCBORLength(\n            rightLength,\n            length);\n          // Check for all ASCII text\n          for (int i = offsetp1; i < length; ++i) {\n            if ((data[i] & ((byte)0x80)) != 0) {\n              return null;\n            }\n          }\n          // All ASCII text, so convert to a text string\n          // from a char array without having to\n          // convert from UTF-8 first\n          var c = new char[length - offsetp1];\n          for (int i = offsetp1; i < length; ++i) {\n            c[i - offsetp1] = (char)(data[i] & (int)0xff);\n          }\n          return new String(c);\n        }\n      }\n      return null;\n    }\n\n    private static byte[] SerializeUtf8(byte[] utf8) {\n      byte[] bytes;\n      if (utf8.Length < 24) {\n        bytes = new byte[utf8.Length + 1];\n        bytes[0] = (byte)(utf8.Length | 0x60);\n        Array.Copy(utf8, 0, bytes, 1, utf8.Length);\n        return bytes;\n      }\n      if (utf8.Length <= 0xffL) {\n        bytes = new byte[utf8.Length + 2];\n        bytes[0] = (byte)0x78;\n        bytes[1] = (byte)utf8.Length;\n        Array.Copy(utf8, 0, bytes, 2, utf8.Length);\n        return bytes;\n      }\n      if (utf8.Length <= 0xffffL) {\n        bytes = new byte[utf8.Length + 3];\n        bytes[0] = (byte)0x79;\n        bytes[1] = (byte)((utf8.Length >> 8) & 0xff);\n        bytes[2] = (byte)(utf8.Length & 0xff);\n        Array.Copy(utf8, 0, bytes, 3, utf8.Length);\n        return bytes;\n      }\n      byte[] posbytes = GetPositiveInt64Bytes(3, utf8.Length);\n      bytes = new byte[utf8.Length + posbytes.Length];\n      Array.Copy(posbytes, 0, bytes, 0, posbytes.Length);\n      Array.Copy(utf8, 0, bytes, posbytes.Length, utf8.Length);\n      return bytes;\n    }\n\n    private static byte[] GetPositiveInt64Bytes(int type, long value) {\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value + \") is less than \" +\n          \"0\");\n      }\n      if (value < 24) {\n        return new[] { (byte)((byte)value | (byte)(type << 5)) };\n      }\n      if (value <= 0xffL) {\n        return new[] {\n          (byte)(24 | (type << 5)), (byte)(value & 0xff),\n        };\n      }\n      if (value <= 0xffffL) {\n        return new[] {\n          (byte)(25 | (type << 5)),\n          (byte)((value >> 8) & 0xff), (byte)(value & 0xff),\n        };\n      }\n      if (value <= 0xffffffffL) {\n        return new[] {\n          (byte)(26 | (type << 5)),\n          (byte)((value >> 24) & 0xff), (byte)((value >> 16) & 0xff),\n          (byte)((value >> 8) & 0xff), (byte)(value & 0xff),\n        };\n      }\n      return new[] {\n        (byte)(27 | (type << 5)), (byte)((value >> 56) & 0xff),\n        (byte)((value >> 48) & 0xff), (byte)((value >> 40) & 0xff),\n        (byte)((value >> 32) & 0xff), (byte)((value >> 24) & 0xff),\n        (byte)((value >> 16) & 0xff), (byte)((value >> 8) & 0xff),\n        (byte)(value & 0xff),\n      };\n    }\n\n    private static byte[] GetPositiveIntBytes(int type, int value) {\n      if (value < 0) {\n        throw new ArgumentException(\"value(\" + value + \") is less than \" +\n          \"0\");\n      }\n      if (value < 24) {\n        return new[] { (byte)((byte)value | (byte)(type << 5)) };\n      }\n      if (value <= 0xff) {\n        return new[] {\n          (byte)(24 | (type << 5)), (byte)(value & 0xff),\n        };\n      }\n      if (value <= 0xffff) {\n        return new[] {\n          (byte)(25 | (type << 5)),\n          (byte)((value >> 8) & 0xff), (byte)(value & 0xff),\n        };\n      }\n      return new[] {\n        (byte)(26 | (type << 5)), (byte)((value >> 24) & 0xff),\n        (byte)((value >> 16) & 0xff), (byte)((value >> 8) & 0xff),\n        (byte)(value & 0xff),\n      };\n    }\n\n    // Initialize fixed values for certain\n    // head bytes\n    private static CBORObject[] InitializeFixedObjects() {\n      var fixedObjects = new CBORObject[256];\n      for (var i = 0; i < 0x18; ++i) {\n        fixedObjects[i] = new CBORObject(CBORObjectTypeInteger, (long)i);\n      }\n      for (int i = 0x20; i < 0x38; ++i) {\n        fixedObjects[i] = new CBORObject(\n          CBORObjectTypeInteger,\n          (long)(-1 - (i - 0x20)));\n      }\n      fixedObjects[0x60] = new CBORObject(\n        CBORObjectTypeTextString,\n        String.Empty);\n      for (int i = 0xe0; i < 0xf8; ++i) {\n        fixedObjects[i] = new CBORObject(\n          CBORObjectTypeSimpleValue,\n          (int)(i - 0xe0));\n      }\n      return fixedObjects;\n    }\n\n    private static int ListCompare(\n      IList<CBORObject> listA,\n      IList<CBORObject> listB) {\n      if (listA == null) {\n        return (listB == null) ? 0 : -1;\n      }\n      if (listB == null) {\n        return 1;\n      }\n      int listACount = listA.Count;\n      int listBCount = listB.Count;\n      // NOTE: Compare list counts to conform\n      // to bytewise lexicographical ordering\n      if (listACount != listBCount) {\n        return listACount < listBCount ? -1 : 1;\n      }\n      for (var i = 0; i < listACount; ++i) {\n        int cmp = listA[i].CompareTo(listB[i]);\n        if (cmp != 0) {\n          return cmp;\n        }\n      }\n      return 0;\n    }\n\n    private static EInteger LowHighToEInteger(int tagLow, int tagHigh) {\n      byte[] uabytes = null;\n      if (tagHigh != 0) {\n        uabytes = new byte[9];\n        uabytes[7] = (byte)((tagHigh >> 24) & 0xff);\n        uabytes[6] = (byte)((tagHigh >> 16) & 0xff);\n        uabytes[5] = (byte)((tagHigh >> 8) & 0xff);\n        uabytes[4] = (byte)(tagHigh & 0xff);\n        uabytes[3] = (byte)((tagLow >> 24) & 0xff);\n        uabytes[2] = (byte)((tagLow >> 16) & 0xff);\n        uabytes[1] = (byte)((tagLow >> 8) & 0xff);\n        uabytes[0] = (byte)(tagLow & 0xff);\n        uabytes[8] = 0;\n        return EInteger.FromBytes(uabytes, true);\n      }\n      if (tagLow != 0) {\n        uabytes = new byte[5];\n        uabytes[3] = (byte)((tagLow >> 24) & 0xff);\n        uabytes[2] = (byte)((tagLow >> 16) & 0xff);\n        uabytes[1] = (byte)((tagLow >> 8) & 0xff);\n        uabytes[0] = (byte)(tagLow & 0xff);\n        uabytes[4] = 0;\n        return EInteger.FromBytes(uabytes, true);\n      }\n      return EInteger.Zero;\n    }\n\n    private static int MapCompare(\n      IDictionary<CBORObject, CBORObject> mapA,\n      IDictionary<CBORObject, CBORObject> mapB) {\n      if (mapA == null) {\n        return (mapB == null) ? 0 : -1;\n      }\n      if (mapB == null) {\n        return 1;\n      }\n      if (mapA == mapB) {\n        return 0;\n      }\n      int listACount = mapA.Count;\n      int listBCount = mapB.Count;\n      if (listACount == 0 && listBCount == 0) {\n        return 0;\n      }\n      if (listACount == 0) {\n        return -1;\n      }\n      if (listBCount == 0) {\n        return 1;\n      }\n      // NOTE: Compare map key counts to conform\n      // to bytewise lexicographical ordering\n      if (listACount != listBCount) {\n        return listACount < listBCount ? -1 : 1;\n      }\n      var sortedASet = new List<CBORObject>(PropertyMap.GetSortedKeys(mapA));\n      var sortedBSet = new List<CBORObject>(PropertyMap.GetSortedKeys(mapB));\n      // DebugUtility.Log(\"---done sorting\");\n      listACount = sortedASet.Count;\n      listBCount = sortedBSet.Count;\n      // Compare the keys\n      /* for (var i = 0; i < listACount; ++i) {\n        string str = sortedASet[i].ToString();\n        str = str.Substring(0, Math.Min(100, str.Length));\n        DebugUtility.Log(\"A \" + i + \"=\" + str);\n      }\n      for (var i = 0; i < listBCount; ++i) {\n        string str = sortedBSet[i].ToString();\n        str = str.Substring(0, Math.Min(100, str.Length));\n        DebugUtility.Log(\"B \" + i + \"=\" + str);\n      }*/\n      for (var i = 0; i < listACount; ++i) {\n        CBORObject itemA = sortedASet[i];\n        CBORObject itemB = sortedBSet[i];\n        if (itemA == null) {\n          return -1;\n        }\n        int cmp = itemA.CompareTo(itemB);\n        // string ot = itemA + \"/\" +\n        // (cmp != 0 ? itemB.ToString() : \"~\") +\n        // \" -> cmp=\" + (cmp);\n        // DebugUtility.Log(ot);\n        if (cmp != 0) {\n          return cmp;\n        }\n        // Both maps have the same key, so compare\n        // the value under that key\n        cmp = mapA[itemA].CompareTo(mapB[itemB]);\n        // DebugUtility.Log(itemA + \"/~\" +\n        // \" -> \"+mapA[itemA]+\", \"+(cmp != 0 ? mapB[itemB].ToString() :\n        // \"~\") + \" -> cmp=\" + cmp);\n        if (cmp != 0) {\n          return cmp;\n        }\n      }\n      return 0;\n    }\n\n    private static IList<object> PushObject(\n      IList<object> stack,\n      object parent,\n      object child) {\n      if (stack == null) {\n        stack = new List<object>(4);\n        stack.Add(parent);\n      }\n      foreach (object o in stack) {\n        if (o == child) {\n          throw new ArgumentException(\"Circular reference in data\" +\n            \"\\u0020structure\");\n        }\n      }\n      stack.Add(child);\n      return stack;\n    }\n\n    private static int TagsCompare(EInteger[] tagsA, EInteger[] tagsB) {\n      if (tagsA == null) {\n        return (tagsB == null) ? 0 : -1;\n      }\n      if (tagsB == null) {\n        return 1;\n      }\n      int listACount = tagsA.Length;\n      int listBCount = tagsB.Length;\n      int c = Math.Min(listACount, listBCount);\n      for (var i = 0; i < c; ++i) {\n        int cmp = tagsA[i].CompareTo(tagsB[i]);\n        if (cmp != 0) {\n          return cmp;\n        }\n      }\n      return (listACount != listBCount) ? ((listACount < listBCount) ? -1 : 1) :\n        0;\n    }\n\n    private static IList<object> WriteChildObject(\n      object parentThisItem,\n      CBORObject child,\n      Stream outputStream,\n      IList<object> stack,\n      CBOREncodeOptions options) {\n      if (child == null) {\n        outputStream.WriteByte(0xf6);\n      } else {\n        int type = child.ItemType;\n        if (type == CBORObjectTypeArray) {\n          stack = PushObject(stack, parentThisItem, child.ThisItem);\n          child.WriteTags(outputStream);\n          WriteObjectArray(child.AsList(), outputStream, stack, options);\n          stack.RemoveAt(stack.Count - 1);\n        } else if (type == CBORObjectTypeMap) {\n          stack = PushObject(stack, parentThisItem, child.ThisItem);\n          child.WriteTags(outputStream);\n          WriteObjectMap(child.AsMap(), outputStream, stack, options);\n          stack.RemoveAt(stack.Count - 1);\n        } else {\n          child.WriteTo(outputStream, options);\n        }\n      }\n      return stack;\n    }\n\n    private static void WriteObjectArray(\n      IList<CBORObject> list,\n      Stream outputStream,\n      CBOREncodeOptions options) {\n      WriteObjectArray(list, outputStream, null, options);\n    }\n\n    private static void WriteObjectArray(\n      IList<CBORObject> list,\n      Stream outputStream,\n      IList<object> stack,\n      CBOREncodeOptions options) {\n      object thisObj = list;\n      WritePositiveInt(4, list.Count, outputStream);\n      foreach (CBORObject i in list) {\n        stack = WriteChildObject(thisObj, i, outputStream, stack, options);\n      }\n    }\n\n    private static void WriteObjectMap(\n      IDictionary<CBORObject, CBORObject> map,\n      Stream outputStream,\n      CBOREncodeOptions options) {\n      WriteObjectMap(map, outputStream, null, options);\n    }\n\n    private static void WriteObjectMap(\n      IDictionary<CBORObject, CBORObject> map,\n      Stream outputStream,\n      IList<object> stack,\n      CBOREncodeOptions options) {\n      object thisObj = map;\n      WritePositiveInt(5, map.Count, outputStream);\n      foreach (KeyValuePair<CBORObject, CBORObject> entry in map) {\n        CBORObject key = entry.Key;\n        CBORObject value = entry.Value;\n        stack = WriteChildObject(\n            thisObj,\n            key,\n            outputStream,\n            stack,\n            options);\n        stack = WriteChildObject(\n            thisObj,\n            value,\n            outputStream,\n            stack,\n            options);\n      }\n    }\n\n    private static int WritePositiveInt(int type, int value, Stream s) {\n      byte[] bytes = GetPositiveIntBytes(type, value);\n      s.Write(bytes, 0, bytes.Length);\n      return bytes.Length;\n    }\n\n    private static int WritePositiveInt64(int type, long value, Stream s) {\n      byte[] bytes = GetPositiveInt64Bytes(type, value);\n      s.Write(bytes, 0, bytes.Length);\n      return bytes.Length;\n    }\n\n    private static void WriteStreamedString(string str, Stream stream) {\n      byte[] bytes;\n      bytes = GetOptimizedBytesIfShortAscii(str, -1);\n      if (bytes != null) {\n        stream.Write(bytes, 0, bytes.Length);\n        return;\n      }\n      // Take string's length into account when allocating\n      // stream buffer, in case it's much smaller than the usual stream\n      // string buffer length and to improve performance on small strings\n      int bufferLength = Math.Min(StreamedStringBufferLength, str.Length);\n      if (bufferLength < StreamedStringBufferLength) {\n        bufferLength = Math.Min(\n            StreamedStringBufferLength,\n            bufferLength * 3);\n      }\n      bytes = new byte[bufferLength];\n      var byteIndex = 0;\n      var streaming = false;\n      for (int index = 0; index < str.Length; ++index) {\n        int c = str[index];\n        if (c <= 0x7f) {\n          if (byteIndex >= StreamedStringBufferLength) {\n            // Write bytes retrieved so far\n            if (!streaming) {\n              stream.WriteByte((byte)0x7f);\n            }\n            WritePositiveInt(3, byteIndex, stream);\n            stream.Write(bytes, 0, byteIndex);\n            byteIndex = 0;\n            streaming = true;\n          }\n          bytes[byteIndex++] = (byte)c;\n        } else if (c <= 0x7ff) {\n          if (byteIndex + 2 > StreamedStringBufferLength) {\n            // Write bytes retrieved so far - the next two bytes\n            // would exceed the length, and the CBOR spec forbids\n            // splitting characters when generating text strings\n            if (!streaming) {\n              stream.WriteByte((byte)0x7f);\n            }\n            WritePositiveInt(3, byteIndex, stream);\n            stream.Write(bytes, 0, byteIndex);\n            byteIndex = 0;\n            streaming = true;\n          }\n          bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));\n          bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));\n        } else {\n          if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&\n            (str[index + 1] & 0xfc00) == 0xdc00) {\n            // Get the Unicode code point for the surrogate pair\n            c = 0x10000 + ((c & 0x3ff) << 10) + (str[index + 1] & 0x3ff);\n            ++index;\n          } else if ((c & 0xf800) == 0xd800) {\n            // unpaired surrogate, write U+FFFD instead\n            c = 0xfffd;\n          }\n          if (c <= 0xffff) {\n            if (byteIndex + 3 > StreamedStringBufferLength) {\n              // Write bytes retrieved so far - the next three bytes\n              // would exceed the length, and the CBOR spec forbids\n              // splitting characters when generating text strings\n              if (!streaming) {\n                stream.WriteByte((byte)0x7f);\n              }\n              WritePositiveInt(3, byteIndex, stream);\n              stream.Write(bytes, 0, byteIndex);\n              byteIndex = 0;\n              streaming = true;\n            }\n            bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));\n            bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));\n            bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));\n          } else {\n            if (byteIndex + 4 > StreamedStringBufferLength) {\n              // Write bytes retrieved so far - the next four bytes\n              // would exceed the length, and the CBOR spec forbids\n              // splitting characters when generating text strings\n              if (!streaming) {\n                stream.WriteByte((byte)0x7f);\n              }\n              WritePositiveInt(3, byteIndex, stream);\n              stream.Write(bytes, 0, byteIndex);\n              byteIndex = 0;\n              streaming = true;\n            }\n            bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));\n            bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));\n            bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));\n            bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));\n          }\n        }\n      }\n      WritePositiveInt(3, byteIndex, stream);\n      stream.Write(bytes, 0, byteIndex);\n      if (streaming) {\n        stream.WriteByte((byte)0xff);\n      }\n    }\n\n    private int AsInt32(int minValue, int maxValue) {\n      CBORNumber cn = CBORNumber.FromCBORObject(this);\n      if (cn == null) {\n        throw new InvalidOperationException(\"not a number type\");\n      }\n      return cn.GetNumberInterface().AsInt32(\n          cn.GetValue(),\n          minValue,\n          maxValue);\n    }\n\n    private void WriteTags(Stream s) {\n      CBORObject curobject = this;\n      while (curobject.IsTagged) {\n        int low = curobject.tagLow;\n        int high = curobject.tagHigh;\n        if (high == 0 && (low >> 16) == 0) {\n          WritePositiveInt(6, low, s);\n        } else if (high == 0) {\n          long value = ((long)low) & 0xffffffffL;\n          WritePositiveInt64(6, value, s);\n        } else if ((high >> 16) == 0) {\n          long value = ((long)low) & 0xffffffffL;\n          long highValue = ((long)high) & 0xffffffffL;\n          value |= highValue << 32;\n          WritePositiveInt64(6, value, s);\n        } else {\n          byte[] arrayToWrite = {\n            (byte)0xdb,\n            (byte)((high >> 24) & 0xff), (byte)((high >> 16) & 0xff),\n            (byte)((high >> 8) & 0xff), (byte)(high & 0xff),\n            (byte)((low >> 24) & 0xff), (byte)((low >> 16) & 0xff),\n            (byte)((low >> 8) & 0xff), (byte)(low & 0xff),\n          };\n          s.Write(arrayToWrite, 0, 9);\n        }\n        curobject = (CBORObject)curobject.itemValue;\n      }\n    }\n  }\n}\n", "/*\nWritten by Peter O.\nAny copyright to this work is released to the Public Domain.\nIn case this is not possible, this work is also\nlicensed under Creative Commons Zero (CC0):\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\n */\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Reflection;\nusing PeterO;\nusing PeterO.Numbers;\n\nnamespace PeterO.Cbor {\n  internal static class PropertyMap {\n    private const int TicksDivFracSeconds =\n      CBORUtilities.FractionalSeconds / 10000000;\n\n    private sealed class OrderedDictionary<TKey, TValue> :\n      IDictionary<TKey, TValue> {\n      // NOTE: Note that this class will be used with CBORObjects, some of which are\n      // mutable. Storing mutable keys in an ordinary Dictionary can cause problems;\n      // for example:\n      // - 'Add'ing a key, then changing it, then calling CompareTo on the changed\n      // key can fail to find the key in the Dictionary, even though the old and new\n      // versions\n      // of the key have the same reference.\n      // - The same can happen if an object that contains a Dictionary is 'Add'ed to\n      // that\n      // Dictionary.\n      private readonly IDictionary<TKey, TValue> dict;\n      private readonly LinkedList<TKey> list;\n      public OrderedDictionary() {\n        this.dict = new SortedDictionary<TKey, TValue>();\n        this.list = new LinkedList<TKey>();\n      }\n      public void Add(KeyValuePair<TKey, TValue> kvp) {\n        this.Add(kvp.Key, kvp.Value);\n      }\n      public void Add(TKey k, TValue v) {\n        if (this.dict.ContainsKey(k)) {\n          throw new ArgumentException(\"duplicate key\");\n        } else {\n          // CheckKeyDoesNotExist(k);\n          // DebugUtility.Log(\"Adding: \" + (k.GetHashCode()) + \" [Type=\" + (CS(k)) +\n          // \"]\");\n          int keycnt = this.dict.Count;\n          this.dict.Add(k, v);\n          // if (keycnt == this.dict.Count) {\n          // throw new InvalidOperationException();\n          // }\n          this.list.AddLast(k);\n          // CheckKeyExists(k);\n        }\n      }\n      public TValue this[TKey key] {\n        get {\n          TValue v = default(TValue);\n          // NOTE: Don't use dict[key], since if it fails it could\n          // print the key in the exception's message, which could\n          // cause an infinite loop\n          if (!this.dict.TryGetValue(key, out v)) {\n            throw new ArgumentException(\"key not found\");\n          }\n          return v;\n        }\n        set {\n          if (this.dict.ContainsKey(key)) {\n            // DebugUtility.Log(\"Set existing: \" + (key.GetHashCode()) + \" [Type=\" +\n            // (CS(key)) + \"]\");\n            this.dict[key] = value;\n            // CheckKeyExists(key);\n          } else {\n            // DebugUtility.Log(\"Set new: \" + (key.GetHashCode()) + \" [Type=\" + (CS(key))\n            // +\n            // \"]\");\n            this.dict.Add(key, value);\n            this.list.AddLast(key);\n            // CheckKeyExists(key);\n          }\n        }\n      }\n      public void Clear() {\n        this.dict.Clear();\n        this.list.Clear();\n      }\n      public void CopyTo(KeyValuePair<TKey, TValue>[] a, int off) {\n        foreach (var kv in this) {\n          a[off++] = kv;\n        }\n      }\n      public bool Remove(KeyValuePair<TKey, TValue> kvp) {\n        if (this.Contains(kvp)) {\n          // CheckKeyExists(kvp.Key);\n          this.dict.Remove(kvp.Key);\n          this.list.Remove(kvp.Key);\n          return true;\n        }\n        return false;\n      }\n      public bool Remove(TKey key) {\n        if (this.dict.ContainsKey(key)) {\n          // CheckKeyExists(key);\n          this.dict.Remove(key);\n          this.list.Remove(key);\n          return true;\n        }\n        return false;\n      }\n      public bool Contains(KeyValuePair<TKey, TValue> kvp) {\n        if (this.dict.ContainsKey(kvp.Key)) {\n          if (this.dict[kvp.Key].Equals(kvp.Value)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      public bool ContainsKey(TKey key) {\n        return this.dict.ContainsKey(key);\n      }\n      public bool TryGetValue(TKey key, out TValue val) {\n        return this.dict.TryGetValue(key, out val);\n      }\n      public int Count {\n        get {\n          return this.dict.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return false;\n        }\n      }\n\n      [System.Diagnostics.Conditional(\"DEBUG\")]\n      private void CheckKeyExists(TKey key) {\n        TValue v = default(TValue);\n        if (!this.dict.ContainsKey(key)) {\n          /* DebugUtility.Log(\"hash \" + (key.GetHashCode()) + \" [\" +\n          (CS(key)) + \"]\");\n          foreach (var k in this.dict.Keys) {\n            DebugUtility.Log(\n            \"key {0} {1}\" + \"\\u0020\" + \"\\u0020 [{2}]\",\n                k.Equals(key), k.GetHashCode(), CS(k), CS(key),\n              this.dict.ContainsKey(k));\n          } */\n          throw new ArgumentException(\"key not found (ContainsKey)\");\n        }\n        // NOTE: Don't use dict[k], since if it fails it could\n        // print the key in the exception's message, which could\n        // cause an infinite loop\n        if (!this.dict.TryGetValue(key, out v)) {\n          throw new ArgumentException(\"key not found (TryGetValue)\");\n        }\n        if (this.dict.Count != this.list.Count) {\n          throw new InvalidOperationException();\n        }\n      }\n\n      [System.Diagnostics.Conditional(\"DEBUG\")]\n      private void CheckKeyDoesNotExist(TKey key) {\n        TValue v = default(TValue);\n        // NOTE: Don't use dict[k], since if it fails it could\n        // print the key in the exception's message, which could\n        // cause an infinite loop\n        if (!this.dict.TryGetValue(key, out v)) {\n          return;\n        }\n        throw new ArgumentException(\"key found\");\n      }\n\n      public ICollection<TKey> Keys {\n        get {\n          return new KeyWrapper<TKey, TValue>(this.dict, this.list);\n        }\n      }\n\n      public ICollection<TKey> SortedKeys {\n        get {\n           return this.dict.Keys;\n        }\n      }\n\n      public ICollection<TValue> Values {\n        get {\n          return new ValueWrapper<TKey, TValue>(this.dict, this.list);\n        }\n      }\n\n      private IEnumerable<KeyValuePair<TKey, TValue>> Iterate() {\n        foreach (var k in this.list) {\n          TValue v = default(TValue);\n          // DebugUtility.Log(\"Enumerating: \" + (k.GetHashCode()) + \" [Type=\" + ((k as\n          // CBORObject).Type) + \"]\");\n          // NOTE: Don't use dict[k], since if it fails it could\n          // print the key in the exception's message, which could\n          // cause an infinite loop\n          if (!this.dict.TryGetValue(k, out v)) {\n            throw new ArgumentException(\"key not found\");\n          }\n          yield return new KeyValuePair<TKey, TValue>(k, v);\n        }\n      }\n\n      public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() {\n        return this.Iterate().GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.Iterate()).GetEnumerator();\n      }\n    }\n\n    private sealed class ValueWrapper<TKey, TValue> : ICollection<TValue> {\n      private readonly IDictionary<TKey, TValue> dict;\n      private readonly LinkedList<TKey> list;\n      public ValueWrapper(IDictionary<TKey, TValue> dict, LinkedList<TKey>\n        list) {\n        this.dict = dict;\n        this.list = list;\n      }\n      public void Add(TValue v) {\n        throw new NotSupportedException();\n      }\n      public void Clear() {\n        throw new NotSupportedException();\n      }\n      public void CopyTo(TValue[] a, int off) {\n        foreach (var k in this.list) {\n          a[off++] = this.dict[k];\n        }\n      }\n      public bool Remove(TValue v) {\n        throw new NotSupportedException();\n      }\n      public bool Contains(TValue v) {\n        foreach (var k in this.list) {\n          if (this.dict[k].Equals(v)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      public int Count {\n        get {\n          return this.dict.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return true;\n        }\n      }\n\n      private IEnumerable<TValue> Iterate() {\n        foreach (var k in this.list) {\n          yield return this.dict[k];\n        }\n      }\n\n      public IEnumerator<TValue> GetEnumerator() {\n        return this.Iterate().GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.Iterate()).GetEnumerator();\n      }\n    }\n\n    private sealed class KeyWrapper<TKey, TValue> : ICollection<TKey> {\n      private readonly IDictionary<TKey, TValue> dict;\n      private readonly LinkedList<TKey> list;\n      public KeyWrapper(IDictionary<TKey, TValue> dict, LinkedList<TKey> list) {\n        this.dict = dict;\n        this.list = list;\n      }\n      public void Add(TKey v) {\n        throw new NotSupportedException();\n      }\n      public void Clear() {\n        throw new NotSupportedException();\n      }\n      public void CopyTo(TKey[] a, int off) {\n        this.list.CopyTo(a, off);\n      }\n      public bool Remove(TKey v) {\n        throw new NotSupportedException();\n      }\n      public bool Contains(TKey v) {\n        return this.dict.ContainsKey(v);\n      }\n      public int Count {\n        get {\n          return this.dict.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return true;\n        }\n      }\n      public IEnumerator<TKey> GetEnumerator() {\n        return this.list.GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.list).GetEnumerator();\n      }\n    }\n\n    private sealed class ReadOnlyWrapper<T> : ICollection<T> {\n      private readonly ICollection<T> o;\n      public ReadOnlyWrapper(ICollection<T> o) {\n        this.o = o;\n      }\n      public void Add(T v) {\n        throw new NotSupportedException();\n      }\n      public void Clear() {\n        throw new NotSupportedException();\n      }\n      public void CopyTo(T[] a, int off) {\n        this.o.CopyTo(a, off);\n      }\n      public bool Remove(T v) {\n        throw new NotSupportedException();\n      }\n      public bool Contains(T v) {\n        return this.o.Contains(v);\n      }\n      public int Count {\n        get {\n          return this.o.Count;\n        }\n      }\n      public bool IsReadOnly {\n        get {\n          return true;\n        }\n      }\n      public IEnumerator<T> GetEnumerator() {\n        return this.o.GetEnumerator();\n      }\n      IEnumerator IEnumerable.GetEnumerator() {\n        return ((IEnumerable)this.o).GetEnumerator();\n      }\n    }\n\n    private sealed class PropertyData {\n      private readonly string name;\n      private readonly MemberInfo prop;\n      private readonly string adjustedName;\n      private readonly string adjustedNameCamelCase;\n      public string Name {\n        get {\n          return this.name;\n        }\n      }\n\n      public PropertyData(string name, MemberInfo prop) {\n        this.name = name;\n        this.prop = prop;\n        this.adjustedNameCamelCase = this.GetAdjustedNameInternal(true);\n        this.adjustedName = this.GetAdjustedNameInternal(false);\n      }\n\n      public Type PropertyType {\n        get {\n          var pr = this.prop as PropertyInfo;\n          if (pr != null) {\n            return pr.PropertyType;\n          }\n          var fi = this.prop as FieldInfo;\n          return (fi != null) ? fi.FieldType : null;\n        }\n      }\n\n      public object GetValue(object obj) {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          return pr.GetValue(obj, null);\n        }\n        var fi = this.prop as FieldInfo;\n        return (fi != null) ? fi.GetValue(obj) : null;\n      }\n\n      public void SetValue(object obj, object value) {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          pr.SetValue(obj, value, null);\n        }\n        var fi = this.prop as FieldInfo;\n        if (fi != null) {\n          fi.SetValue(obj, value);\n        }\n      }\n\n      #if NET20 || NET40\n      public static bool HasUsableGetter(PropertyInfo pi) {\n        return pi != null && pi.CanRead && !pi.GetGetMethod().IsStatic &&\n          pi.GetGetMethod().IsPublic;\n      }\n\n      public static bool HasUsableSetter(PropertyInfo pi) {\n        return pi != null && pi.CanWrite && !pi.GetSetMethod().IsStatic &&\n          pi.GetSetMethod().IsPublic;\n      }\n      #else\n      public static bool HasUsableGetter(PropertyInfo pi) {\n        return pi != null && pi.CanRead && !pi.GetMethod.IsStatic &&\n          pi.GetMethod.IsPublic;\n      }\n\n      public static bool HasUsableSetter(PropertyInfo pi) {\n        return pi != null && pi.CanWrite && !pi.SetMethod.IsStatic &&\n          pi.SetMethod.IsPublic;\n      }\n      #endif\n      public bool HasUsableGetter() {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          return HasUsableGetter(pr);\n        }\n        var fi = this.prop as FieldInfo;\n        return fi != null && fi.IsPublic && !fi.IsStatic &&\n          !fi.IsInitOnly && !fi.IsLiteral;\n      }\n\n      public bool HasUsableSetter() {\n        var pr = this.prop as PropertyInfo;\n        if (pr != null) {\n          return HasUsableSetter(pr);\n        }\n        var fi = this.prop as FieldInfo;\n        return fi != null && fi.IsPublic && !fi.IsStatic &&\n          !fi.IsInitOnly && !fi.IsLiteral;\n      }\n\n      public string GetAdjustedName(bool useCamelCase) {\n        return useCamelCase ? this.adjustedNameCamelCase :\n          this.adjustedName;\n      }\n\n      public string GetAdjustedNameInternal(bool useCamelCase) {\n        string thisName = this.Name;\n        if (useCamelCase) {\n          if (CBORUtilities.NameStartsWithWord(thisName, \"Is\")) {\n            thisName = thisName.Substring(2);\n          }\n          thisName = CBORUtilities.FirstCharLower(thisName);\n        } else {\n          thisName = CBORUtilities.FirstCharUpper(thisName);\n        }\n        return thisName;\n      }\n\n      public MemberInfo Prop {\n        get {\n          return this.prop;\n        }\n      }\n    }\n\n    #if NET40 || NET20\n    private static bool IsGenericType(Type type) {\n      return type.IsGenericType;\n    }\n\n    private static bool IsClassOrValueType(Type type) {\n      return type.IsClass || type.IsValueType;\n    }\n\n    private static Type FirstGenericArgument(Type type) {\n      return type.GetGenericArguments()[0];\n    }\n\n    private static IEnumerable<PropertyInfo> GetTypeProperties(Type t) {\n      return t.GetProperties(BindingFlags.Public |\n          BindingFlags.Instance);\n    }\n\n    private static IEnumerable<FieldInfo> GetTypeFields(Type t) {\n      return t.GetFields(BindingFlags.Public | BindingFlags.Instance);\n    }\n\n    private static IEnumerable<Type> GetTypeInterfaces(Type t) {\n      return t.GetInterfaces();\n    }\n\n    private static bool IsAssignableFrom(Type superType, Type subType) {\n      return superType.IsAssignableFrom(subType);\n    }\n\n    private static MethodInfo GetTypeMethod(\n      Type t,\n      string name,\n      Type[] parameters) {\n      return t.GetMethod(name, parameters);\n    }\n\n    private static bool HasCustomAttribute(\n      Type t,\n      string name) {\n      foreach (var attr in t.GetCustomAttributes(false)) {\n        if (attr.GetType().FullName.Equals(name,\n            StringComparison.Ordinal)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    #else\n    private static bool IsGenericType(Type type) {\n      return type.GetTypeInfo().IsGenericType;\n    }\n\n    private static bool IsClassOrValueType(Type type) {\n      return type.GetTypeInfo().IsClass || type.GetTypeInfo().IsValueType;\n    }\n\n    private static Type FirstGenericArgument(Type type) {\n      return type.GenericTypeArguments[0];\n    }\n\n    private static bool IsAssignableFrom(Type superType, Type subType) {\n      return superType.GetTypeInfo().IsAssignableFrom(subType.GetTypeInfo());\n    }\n\n    private static IEnumerable<PropertyInfo> GetTypeProperties(Type t) {\n      return t.GetRuntimeProperties();\n    }\n\n    private static IEnumerable<FieldInfo> GetTypeFields(Type t) {\n      return t.GetRuntimeFields();\n    }\n\n    private static IEnumerable<Type> GetTypeInterfaces(Type t) {\n      return t.GetTypeInfo().ImplementedInterfaces;\n    }\n\n    private static MethodInfo GetTypeMethod(\n      Type t,\n      string name,\n      Type[] parameters) {\n      return t.GetRuntimeMethod(name, parameters);\n    }\n\n    private static bool HasCustomAttribute(\n      Type t,\n      string name) {\n      foreach (var attr in t.GetTypeInfo().GetCustomAttributes()) {\n        if (attr.GetType().FullName.Equals(name, StringComparison.Ordinal)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    #endif\n\n    // Give each thread its own version of propertyLists using ThreadStatic\n    [ThreadStatic]\n    private static IDictionary<Type, IList<PropertyData>>\n    propertyLists;\n\n    private static string RemoveIsPrefix(string pn) {\n      return CBORUtilities.NameStartsWithWord(pn, \"Is\") ? pn.Substring(2) :\n        pn;\n    }\n\n    private static IList<PropertyData> GetPropertyList(Type t) {\n      {\n        IList<PropertyData> ret = new List<PropertyData>();\n        propertyLists = propertyLists ?? new Dictionary<Type, IList<PropertyData>>();\n        if (propertyLists.ContainsKey(t)) {\n          return propertyLists[t];\n        }\n        bool anonymous = HasCustomAttribute(\n            t,\n            \"System.Runtime.CompilerServices.CompilerGeneratedAttribute\") ||\n          HasCustomAttribute(\n            t,\n            \"Microsoft.FSharp.Core.CompilationMappingAttribute\");\n        var names = new SortedDictionary<string, int>();\n        foreach (PropertyInfo pi in GetTypeProperties(t)) {\n          var pn = RemoveIsPrefix(pi.Name);\n          if (names.ContainsKey(pn)) {\n            ++names[pn];\n          } else {\n            names[pn] = 1;\n          }\n        }\n        foreach (FieldInfo pi in GetTypeFields(t)) {\n          var pn = RemoveIsPrefix(pi.Name);\n          if (names.ContainsKey(pn)) {\n            ++names[pn];\n          } else {\n            names[pn] = 1;\n          }\n        }\n        foreach (FieldInfo fi in GetTypeFields(t)) {\n          PropertyData pd = new PropertyMap.PropertyData(fi.Name, fi);\n          if (pd.HasUsableGetter() || pd.HasUsableSetter()) {\n            var pn = RemoveIsPrefix(pd.Name);\n            // Ignore ambiguous properties\n            if (names.ContainsKey(pn) && names[pn] > 1) {\n              continue;\n            }\n            ret.Add(pd);\n          }\n        }\n        foreach (PropertyInfo pi in GetTypeProperties(t)) {\n          if (pi.CanRead && (pi.CanWrite || anonymous) &&\n            pi.GetIndexParameters().Length == 0) {\n            if (PropertyData.HasUsableGetter(pi) ||\n              PropertyData.HasUsableSetter(pi)) {\n              var pn = RemoveIsPrefix(pi.Name);\n              // Ignore ambiguous properties\n              if (names.ContainsKey(pn) && names[pn] > 1) {\n                continue;\n              }\n              PropertyData pd = new PropertyMap.PropertyData(pi.Name, pi);\n              ret.Add(pd);\n            }\n          }\n        }\n        propertyLists.Add(\n          t,\n          ret);\n        return ret;\n      }\n    }\n\n    public static IList<CBORObject> ListFromArray(CBORObject[] array) {\n      return new List<CBORObject>(array);\n    }\n\n    public static bool ExceedsKnownLength(Stream inStream, long size) {\n      return (inStream is MemoryStream) && (size > (inStream.Length -\n            inStream.Position));\n    }\n\n    public static void SkipStreamToEnd(Stream inStream) {\n      if (inStream is MemoryStream) {\n        inStream.Position = inStream.Length;\n      }\n    }\n\n    public static bool FirstElement(int[] dimensions) {\n      foreach (var d in dimensions) {\n        if (d == 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    public static bool NextElement(int[] index, int[] dimensions) {\n      for (var i = dimensions.Length - 1; i >= 0; --i) {\n        if (dimensions[i] > 0) {\n          ++index[i];\n          if (index[i] >= dimensions[i]) {\n            index[i] = 0;\n          } else {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    public static CBORObject BuildCBORArray(int[] dimensions) {\n      int zeroPos = dimensions.Length;\n      for (var i = 0; i < dimensions.Length; ++i) {\n        if (dimensions[i] == 0) {\n          {\n            zeroPos = i;\n          }\n          break;\n        }\n      }\n      int arraydims = zeroPos - 1;\n      if (arraydims <= 0) {\n        return CBORObject.NewArray();\n      }\n      var stack = new CBORObject[zeroPos];\n      var index = new int[zeroPos];\n      var stackpos = 0;\n      CBORObject ret = CBORObject.NewArray();\n      stack[0] = ret;\n      index[0] = 0;\n      for (var i = 0; i < dimensions[0]; ++i) {\n        ret.Add(CBORObject.NewArray());\n      }\n      ++stackpos;\n      while (stackpos > 0) {\n        int curindex = index[stackpos - 1];\n        if (curindex < stack[stackpos - 1].Count) {\n          CBORObject subobj = stack[stackpos - 1][curindex];\n          if (stackpos < zeroPos) {\n            stack[stackpos] = subobj;\n            index[stackpos] = 0;\n            for (var i = 0; i < dimensions[stackpos]; ++i) {\n              subobj.Add(CBORObject.NewArray());\n            }\n            ++index[stackpos - 1];\n            ++stackpos;\n          } else {\n            ++index[stackpos - 1];\n          }\n        } else {\n          --stackpos;\n        }\n      }\n      return ret;\n    }\n\n    public static CBORObject FromArray(\n      Object arrObj,\n      PODOptions options,\n      CBORTypeMapper mapper,\n      int depth) {\n      var arr = (Array)arrObj;\n      int rank = arr.Rank;\n      if (rank == 0) {\n        return CBORObject.NewArray();\n      }\n      CBORObject obj = null;\n      if (rank == 1) {\n        // Most common case: the array is one-dimensional\n        obj = CBORObject.NewArray();\n        int len = arr.GetLength(0);\n        for (var i = 0; i < len; ++i) {\n          obj.Add(\n            CBORObject.FromObject(\n              arr.GetValue(i),\n              options,\n              mapper,\n              depth + 1));\n        }\n        return obj;\n      }\n      var index = new int[rank];\n      var dimensions = new int[rank];\n      for (var i = 0; i < rank; ++i) {\n        dimensions[i] = arr.GetLength(i);\n      }\n      if (!FirstElement(dimensions)) {\n        return obj;\n      }\n      obj = BuildCBORArray(dimensions);\n      do {\n        CBORObject o = CBORObject.FromObject(\n            arr.GetValue(index),\n            options,\n            mapper,\n            depth + 1);\n        SetCBORObject(obj, index, o);\n      } while (NextElement(index, dimensions));\n      return obj;\n    }\n\n    private static CBORObject GetCBORObject(CBORObject cbor, int[] index) {\n      CBORObject ret = cbor;\n      foreach (var i in index) {\n        ret = ret[i];\n      }\n      return ret;\n    }\n\n    private static void SetCBORObject(\n      CBORObject cbor,\n      int[] index,\n      CBORObject obj) {\n      CBORObject ret = cbor;\n      for (var i = 0; i < index.Length - 1; ++i) {\n        ret = ret[index[i]];\n      }\n      int ilen = index[index.Length - 1];\n      while (ilen >= ret.Count) {\n        {\n          ret.Add(CBORObject.Null);\n        }\n      }\n      ret[ilen] = obj;\n    }\n\n    public static Array FillArray(\n      Array arr,\n      Type elementType,\n      CBORObject cbor,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      int rank = arr.Rank;\n      if (rank == 0) {\n        return arr;\n      }\n      if (rank == 1) {\n        int len = arr.GetLength(0);\n        for (var i = 0; i < len; ++i) {\n          object item = cbor[i].ToObject(\n              elementType,\n              mapper,\n              options,\n              depth + 1);\n          arr.SetValue(\n            item,\n            i);\n        }\n        return arr;\n      }\n      var index = new int[rank];\n      var dimensions = new int[rank];\n      for (var i = 0; i < rank; ++i) {\n        dimensions[i] = arr.GetLength(i);\n      }\n      if (!FirstElement(dimensions)) {\n        return arr;\n      }\n      do {\n        object item = GetCBORObject(\n            cbor,\n            index).ToObject(\n            elementType,\n            mapper,\n            options,\n            depth + 1);\n        arr.SetValue(\n          item,\n          index);\n      } while (NextElement(index, dimensions));\n      return arr;\n    }\n\n    public static int[] GetDimensions(CBORObject obj) {\n      if (obj.Type != CBORType.Array) {\n        throw new CBORException();\n      }\n      // Common cases\n      if (obj.Count == 0) {\n        return new int[] { 0 };\n      }\n      if (obj[0].Type != CBORType.Array) {\n        return new int[] { obj.Count };\n      }\n      // Complex cases\n      var list = new List<int>();\n      list.Add(obj.Count);\n      while (obj.Type == CBORType.Array &&\n        obj.Count > 0 && obj[0].Type == CBORType.Array) {\n        list.Add(obj[0].Count);\n        obj = obj[0];\n      }\n      return list.ToArray();\n    }\n\n    public static object ObjectToEnum(CBORObject obj, Type enumType) {\n      Type utype = Enum.GetUnderlyingType(enumType);\n      object ret = null;\n      if (obj.IsNumber && obj.AsNumber().IsInteger()) {\n        ret = Enum.ToObject(enumType, TypeToIntegerObject(obj, utype));\n        if (!Enum.IsDefined(enumType, ret)) {\n          string estr = ret.ToString();\n          if (estr == null || estr.Length == 0 || estr[0] == '-' ||\n            (estr[0] >= '0' && estr[0] <= '9')) {\n            throw new CBORException(\"Unrecognized enum value: \" +\n              obj.ToString());\n          }\n        }\n        return ret;\n      } else if (obj.Type == CBORType.TextString) {\n        var nameString = obj.AsString();\n        foreach (var name in Enum.GetNames(enumType)) {\n          if (nameString.Equals(name, StringComparison.Ordinal)) {\n            return Enum.Parse(enumType, name);\n          }\n        }\n        throw new CBORException(\"Not found: \" + obj.ToString());\n      } else {\n        throw new CBORException(\"Unrecognized enum value: \" +\n          obj.ToString());\n      }\n    }\n\n    public static object EnumToObject(Enum value) {\n      return value.ToString();\n    }\n\n    public static object EnumToObjectAsInteger(Enum value) {\n      Type t = Enum.GetUnderlyingType(value.GetType());\n      if (t.Equals(typeof(ulong))) {\n        ulong uvalue = Convert.ToUInt64(value,\n            CultureInfo.InvariantCulture);\n        return EInteger.FromUInt64(uvalue);\n      }\n      return t.Equals(typeof(long)) ? Convert.ToInt64(value,\n          CultureInfo.InvariantCulture) : (t.Equals(typeof(uint)) ?\n          Convert.ToInt64(value,\n            CultureInfo.InvariantCulture) :\n          Convert.ToInt32(value, CultureInfo.InvariantCulture));\n    }\n\n    public static ICollection<TKey>\n    GetSortedKeys<TKey, TValue>(\n      IDictionary<TKey, TValue> dict) {\n      var odict = dict as OrderedDictionary<TKey, TValue>;\n      if (odict != null) {\n        return odict.SortedKeys;\n      }\n      var sdict = dict as SortedDictionary<TKey, TValue>;\n      if (sdict != null) {\n        return sdict.Keys;\n      }\n      throw new InvalidOperationException(\"Internal error: Map doesn't\" +\n\"\\u0020support sorted keys\");\n    }\n\n    public static ICollection<KeyValuePair<TKey, TValue>>\n    GetEntries<TKey, TValue>(\n      IDictionary<TKey, TValue> dict) {\n      var c = (ICollection<KeyValuePair<TKey, TValue>>)dict;\n      return new ReadOnlyWrapper<KeyValuePair<TKey, TValue>>(c);\n    }\n\n    public static IDictionary<CBORObject, CBORObject> NewOrderedDict() {\n      return new OrderedDictionary<CBORObject, CBORObject>();\n    }\n\n    public static object FindOneArgumentMethod(\n      object obj,\n      string name,\n      Type argtype) {\n      return GetTypeMethod(obj.GetType(), name, new[] { argtype });\n    }\n\n    public static object InvokeOneArgumentMethod(\n      object methodInfo,\n      object obj,\n      object argument) {\n      var mi = (MethodInfo)methodInfo;\n      return mi.Invoke(obj, new[] { argument });\n    }\n\n    public static byte[] UUIDToBytes(Guid guid) {\n      var bytes2 = new byte[16];\n      var bytes = guid.ToByteArray();\n      Array.Copy(bytes, bytes2, 16);\n      // Swap the bytes to conform with the UUID RFC\n      bytes2[0] = bytes[3];\n      bytes2[1] = bytes[2];\n      bytes2[2] = bytes[1];\n      bytes2[3] = bytes[0];\n      bytes2[4] = bytes[5];\n      bytes2[5] = bytes[4];\n      bytes2[6] = bytes[7];\n      bytes2[7] = bytes[6];\n      return bytes2;\n    }\n\n    private static bool StartsWith(string str, string pfx) {\n      return str != null && str.Length >= pfx.Length &&\n        str.Substring(0, pfx.Length).Equals(pfx, StringComparison.Ordinal);\n    }\n\n    // TODO: Replace* Legacy with AsNumber methods\n    // in next major version\n    private static object TypeToIntegerObject(CBORObject objThis, Type t) {\n      if (t.Equals(typeof(int))) {\n        return objThis.AsInt32();\n      }\n      if (t.Equals(typeof(short))) {\n        return objThis.AsNumber().ToInt16Checked();\n      }\n      if (t.Equals(typeof(ushort))) {\n        return objThis.AsUInt16Legacy();\n      }\n      if (t.Equals(typeof(byte))) {\n        return objThis.AsByteLegacy();\n      }\n      if (t.Equals(typeof(sbyte))) {\n        return objThis.AsSByteLegacy();\n      }\n      if (t.Equals(typeof(long))) {\n        return objThis.AsNumber().ToInt64Checked();\n      }\n      if (t.Equals(typeof(uint))) {\n        return objThis.AsUInt32Legacy();\n      }\n      if (t.Equals(typeof(ulong))) {\n        return objThis.AsUInt64Legacy();\n      }\n      throw new CBORException(\"Type not supported\");\n    }\n\n    public static object TypeToObject(\n      CBORObject objThis,\n      Type t,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      if (t.Equals(typeof(int))) {\n        return objThis.AsInt32();\n      }\n      if (t.Equals(typeof(short))) {\n        return objThis.AsNumber().ToInt16Checked();\n      }\n      if (t.Equals(typeof(ushort))) {\n        return objThis.AsUInt16Legacy();\n      }\n      if (t.Equals(typeof(byte))) {\n        return objThis.AsByteLegacy();\n      }\n      if (t.Equals(typeof(sbyte))) {\n        return objThis.AsSByteLegacy();\n      }\n      if (t.Equals(typeof(long))) {\n        return objThis.AsNumber().ToInt64Checked();\n      }\n      if (t.Equals(typeof(uint))) {\n        return objThis.AsUInt32Legacy();\n      }\n      if (t.Equals(typeof(ulong))) {\n        return objThis.AsUInt64Legacy();\n      }\n      if (t.Equals(typeof(double))) {\n        return objThis.AsDouble();\n      }\n      if (t.Equals(typeof(decimal))) {\n        return objThis.AsDecimalLegacy();\n      }\n      if (t.Equals(typeof(float))) {\n        return objThis.AsSingle();\n      }\n      if (t.Equals(typeof(bool))) {\n        return objThis.AsBoolean();\n      }\n      if (t.Equals(typeof(char))) {\n        if (objThis.Type == CBORType.TextString) {\n          string s = objThis.AsString();\n          if (s.Length != 1) {\n            throw new CBORException(\"Can't convert to char\");\n          }\n          return s[0];\n        }\n        if (objThis.IsNumber && objThis.AsNumber().CanFitInInt32()) {\n          int c = objThis.AsNumber().ToInt32IfExact();\n          if (c < 0 || c >= 0x10000) {\n            throw new CBORException(\"Can't convert to char\");\n          }\n          return (char)c;\n        }\n        throw new CBORException(\"Can't convert to char\");\n      }\n      if (t.Equals(typeof(DateTime))) {\n        return new CBORDateConverter().FromCBORObject(objThis);\n      }\n      if (t.Equals(typeof(Guid))) {\n        return new CBORUuidConverter().FromCBORObject(objThis);\n      }\n      if (t.Equals(typeof(Uri))) {\n        return new CBORUriConverter().FromCBORObject(objThis);\n      }\n      if (IsAssignableFrom(typeof(Enum), t)) {\n        return ObjectToEnum(objThis, t);\n      }\n      if (IsGenericType(t)) {\n        Type td = t.GetGenericTypeDefinition();\n        // Nullable types\n        if (td.Equals(typeof(Nullable<>))) {\n          Type nullableType = Nullable.GetUnderlyingType(t);\n          if (objThis.IsNull) {\n            return Activator.CreateInstance(t);\n          } else {\n            object wrappedObj = objThis.ToObject(\n                nullableType,\n                mapper,\n                options,\n                depth + 1);\n            return Activator.CreateInstance(\n                t,\n                wrappedObj);\n          }\n        }\n      }\n      if (objThis.Type == CBORType.ByteString) {\n        // TODO: Consider converting base64 strings\n        if (t.Equals(typeof(byte[]))) {\n          byte[] bytes = objThis.GetByteString();\n          var byteret = new byte[bytes.Length];\n          Array.Copy(bytes, 0, byteret, 0, byteret.Length);\n          return byteret;\n        }\n      }\n      if (objThis.Type == CBORType.Array) {\n        Type objectType = typeof(object);\n        var isList = false;\n        var isReadOnlyCollection = false;\n        object listObject = null;\n        object genericListObject = null;\n        if (IsAssignableFrom(typeof(Array), t)) {\n          Type elementType = t.GetElementType();\n          Array array = Array.CreateInstance(\n              elementType,\n              GetDimensions(objThis));\n          return FillArray(\n              array,\n              elementType,\n              objThis,\n              mapper,\n              options,\n              depth);\n        }\n        #if NET40 || NET20\n        if (t.IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isList = td.Equals(typeof(List<>)) || td.Equals(typeof(IList<>)) ||\n            td.Equals(typeof(ICollection<>)) ||\n            td.Equals(typeof(IEnumerable<>));\n          #if NET20 || NET40\n          isReadOnlyCollection = false;\n          #else\n          isReadOnlyCollection = (td.Equals(typeof(IReadOnlyCollection<>)) ||\n             td.Equals(typeof(IReadOnlyList<>)) ||\n\n             td.Equals(\n               typeof(System.Collections.ObjectModel.ReadOnlyCollection<>)))\n&&\n             t.GetGenericArguments().Length == 1;\n         #endif\n        }\n        isList = isList && t.GetGenericArguments().Length == 1;\n        if (isReadOnlyCollection) {\n          objectType = t.GetGenericArguments()[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        } else if (isList) {\n          objectType = t.GetGenericArguments()[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        }\n        #else\n        // TODO: Support IReadOnlyDictionary\n        if (t.GetTypeInfo().IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isList = td.Equals(typeof(List<>)) || td.Equals(typeof(IList<>)) ||\n            td.Equals(typeof(ICollection<>)) ||\n            td.Equals(typeof(IEnumerable<>));\n          isReadOnlyCollection = (td.Equals(typeof(IReadOnlyCollection<>)) ||\n             td.Equals(typeof(IReadOnlyList<>)) ||\n\n             td.Equals(\n               typeof(System.Collections.ObjectModel.ReadOnlyCollection<>)))\n&&\n             t.GenericTypeArguments.Length == 1;\n        }\n        isList = isList && t.GenericTypeArguments.Length == 1;\n        if (isReadOnlyCollection) {\n          objectType = t.GenericTypeArguments[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        } else if (isList) {\n          objectType = t.GenericTypeArguments[0];\n          Type listType = typeof(List<>).MakeGenericType(objectType);\n          listObject = Activator.CreateInstance(listType);\n        }\n        #endif\n        if (listObject == null) {\n          if (t.Equals(typeof(IList)) ||\n            t.Equals(typeof(ICollection)) || t.Equals(typeof(IEnumerable))) {\n            listObject = new List<object>();\n            objectType = typeof(object);\n          } else if (IsClassOrValueType(t)) {\n            var implementsList = false;\n            foreach (var interf in GetTypeInterfaces(t)) {\n              if (IsGenericType(interf) &&\n                interf.GetGenericTypeDefinition().Equals(typeof(IList<>))) {\n                if (implementsList) {\n                  implementsList = false;\n                  break;\n                } else {\n                  implementsList = true;\n                  objectType = FirstGenericArgument(interf);\n                }\n              }\n            }\n            if (implementsList) {\n              // DebugUtility.Log(\"assignable from ilist<>\");\n              genericListObject = Activator.CreateInstance(t);\n            } else {\n              // DebugUtility.Log(\"not assignable from ilist<> \" + t);\n            }\n          }\n        }\n        if (genericListObject != null) {\n          object addMethod = FindOneArgumentMethod(\n              genericListObject,\n              \"Add\",\n              objectType);\n          if (addMethod == null) {\n            throw new CBORException(\"no add method\");\n          }\n          foreach (CBORObject value in objThis.Values) {\n            PropertyMap.InvokeOneArgumentMethod(\n              addMethod,\n              genericListObject,\n              value.ToObject(objectType, mapper, options, depth + 1));\n          }\n          return genericListObject;\n        }\n        if (listObject != null) {\n          System.Collections.IList ie = (System.Collections.IList)listObject;\n          foreach (CBORObject value in objThis.Values) {\n            ie.Add(value.ToObject(objectType, mapper, options, depth + 1));\n          }\n          if (isReadOnlyCollection) {\n            objectType = FirstGenericArgument(t);\n            Type rocType =\ntypeof(System.Collections.ObjectModel.ReadOnlyCollection<>)\n               .MakeGenericType(objectType);\n            listObject = Activator.CreateInstance(rocType, listObject);\n          }\n          return listObject;\n        }\n      }\n      if (objThis.Type == CBORType.Map) {\n        var isDict = false;\n        var isReadOnlyDict = false;\n        Type keyType = null;\n        Type valueType = null;\n        object dictObject = null;\n        #if NET40 || NET20\n        isDict = t.IsGenericType;\n        if (t.IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isDict = td.Equals(typeof(Dictionary<,>)) ||\n            td.Equals(typeof(IDictionary<,>));\n          #if NET20 || NET40\n          isReadOnlyDict = false;\n          #else\n          isReadOnlyDict =\n(td.Equals(typeof(System.Collections.ObjectModel.ReadOnlyDictionary<,>)) ||\n            td.Equals(typeof(IReadOnlyDictionary<,>))) &&\n            t.GetGenericArguments().Length == 2;\n          #endif\n        }\n        // DebugUtility.Log(\"list=\" + isDict);\n        isDict = isDict && t.GetGenericArguments().Length == 2;\n        // DebugUtility.Log(\"list=\" + isDict);\n        if (isDict || isReadOnlyDict) {\n          keyType = t.GetGenericArguments()[0];\n          valueType = t.GetGenericArguments()[1];\n          Type listType = typeof(Dictionary<,>).MakeGenericType(\n              keyType,\n              valueType);\n          dictObject = Activator.CreateInstance(listType);\n        }\n        #else\n        isDict = t.GetTypeInfo().IsGenericType;\n        if (t.GetTypeInfo().IsGenericType) {\n          Type td = t.GetGenericTypeDefinition();\n          isDict = td.Equals(typeof(Dictionary<,>)) ||\n            td.Equals(typeof(IDictionary<,>));\n          isReadOnlyDict =\n(td.Equals(typeof(System.Collections.ObjectModel.ReadOnlyDictionary<,>)) ||\n            td.Equals(typeof(IReadOnlyDictionary<,>))) &&\n            t.GenericTypeArguments.Length == 2;\n        }\n        // DebugUtility.Log(\"list=\" + isDict);\n        isDict = isDict && t.GenericTypeArguments.Length == 2;\n        // DebugUtility.Log(\"list=\" + isDict);\n        if (isDict || isReadOnlyDict) {\n          keyType = t.GenericTypeArguments[0];\n          valueType = t.GenericTypeArguments[1];\n          Type listType = typeof(Dictionary<,>).MakeGenericType(\n              keyType,\n              valueType);\n          dictObject = Activator.CreateInstance(listType);\n        }\n        #endif\n        if (dictObject == null) {\n          if (t.Equals(typeof(IDictionary))) {\n            dictObject = new Dictionary<object, object>();\n            keyType = typeof(object);\n            valueType = typeof(object);\n          }\n        }\n        if (dictObject != null) {\n          System.Collections.IDictionary idic =\n            (System.Collections.IDictionary)dictObject;\n          foreach (CBORObject key in objThis.Keys) {\n            CBORObject value = objThis[key];\n            idic.Add(\n              key.ToObject(keyType, mapper, options, depth + 1),\n              value.ToObject(valueType, mapper, options, depth + 1));\n          }\n          #if !NET20 && !NET40\n          if (isReadOnlyDict) {\n            Type listType =\ntypeof(\n  System.Collections.ObjectModel.ReadOnlyDictionary<,>)\n           .MakeGenericType(keyType,\n              valueType);\n            dictObject = Activator.CreateInstance(listType, dictObject);\n          }\n          #endif\n          return dictObject;\n        }\n        if (mapper != null) {\n          if (!mapper.FilterTypeName(t.FullName)) {\n            throw new CBORException(\"Type \" + t.FullName +\n              \" not supported\");\n          }\n        } else {\n          if (t.FullName != null && (\n              StartsWith(t.FullName, \"Microsoft.Win32.\") ||\n              StartsWith(t.FullName, \"System.IO.\"))) {\n            throw new CBORException(\"Type \" + t.FullName +\n              \" not supported\");\n          }\n          if (StartsWith(t.FullName, \"System.\") &&\n            !HasCustomAttribute(t, \"System.SerializableAttribute\")) {\n            throw new CBORException(\"Type \" + t.FullName +\n              \" not supported\");\n          }\n        }\n        var values = new List<KeyValuePair<string, CBORObject>>();\n        var propNames = PropertyMap.GetPropertyNames(\n            t,\n            options == null || options.UseCamelCase);\n        foreach (string key in propNames) {\n          if (objThis.ContainsKey(key)) {\n            CBORObject cborValue = objThis[key];\n            var dict = new KeyValuePair<string, CBORObject>(\n              key,\n              cborValue);\n            values.Add(dict);\n          }\n        }\n        return PropertyMap.ObjectWithProperties(\n            t,\n            values,\n            mapper,\n            options,\n            depth);\n      } else {\n        throw new CBORException();\n      }\n    }\n\n    public static CBORObject GetOrDefault(IDictionary<CBORObject, CBORObject> map,\n      CBORObject key,\n      CBORObject defaultValue) {\n      CBORObject ret = null;\n      return (!map.TryGetValue(key, out ret)) ? defaultValue : ret;\n    }\n\n#pragma warning disable CA1801\n    public static CBORObject FromObjectOther(object obj) {\n      return null;\n    }\n#pragma warning restore CA1801\n\n    public static object ObjectWithProperties(\n      Type t,\n      IEnumerable<KeyValuePair<string, CBORObject>> keysValues,\n      CBORTypeMapper mapper,\n      PODOptions options,\n      int depth) {\n      try {\n        object o = Activator.CreateInstance(t);\n        var dict = new SortedDictionary<string, CBORObject>();\n        foreach (var kv in keysValues) {\n          var name = kv.Key;\n          dict[name] = kv.Value;\n        }\n        foreach (PropertyData key in GetPropertyList(o.GetType())) {\n          if (!key.HasUsableSetter() || !key.HasUsableGetter()) {\n            // Require properties to have both a setter and\n            // a getter to be eligible for setting\n            continue;\n          }\n          var name = key.GetAdjustedName(options != null ?\n              options.UseCamelCase : true);\n          if (dict.ContainsKey(name)) {\n            object dobj = dict[name].ToObject(\n                key.PropertyType,\n                mapper,\n                options,\n                depth + 1);\n            key.SetValue(\n              o,\n              dobj);\n          }\n        }\n        return o;\n      } catch (Exception ex) {\n        throw new CBORException(ex.Message, ex);\n      }\n    }\n\n    public static CBORObject CallToObject(\n      CBORTypeMapper.ConverterInfo convinfo,\n      object obj) {\n      return (CBORObject)PropertyMap.InvokeOneArgumentMethod(\n          convinfo.ToObject,\n          convinfo.Converter,\n          obj);\n    }\n\n    public static object CallFromObject(\n      CBORTypeMapper.ConverterInfo convinfo,\n      CBORObject obj) {\n      return (object)PropertyMap.InvokeOneArgumentMethod(\n          convinfo.FromObject,\n          convinfo.Converter,\n          obj);\n    }\n\n    public static IEnumerable<KeyValuePair<string, object>> GetProperties(\n      Object o) {\n      return GetProperties(o, true);\n    }\n\n    public static IEnumerable<string> GetPropertyNames(Type t, bool\n      useCamelCase) {\n      foreach (PropertyData key in GetPropertyList(t)) {\n        yield return key.GetAdjustedName(useCamelCase);\n      }\n    }\n\n    public static IEnumerable<KeyValuePair<string, object>> GetProperties(\n      Object o,\n      bool useCamelCase) {\n      foreach (PropertyData key in GetPropertyList(o.GetType())) {\n        if (!key.HasUsableGetter()) {\n          continue;\n        }\n        yield return new KeyValuePair<string, object>(\n            key.GetAdjustedName(useCamelCase),\n            key.GetValue(o));\n      }\n    }\n\n    public static void BreakDownDateTime(\n      DateTime bi,\n      EInteger[] year,\n      int[] lf) {\n      if (TicksDivFracSeconds == 0) {\n        throw new InvalidOperationException();\n      }\n      #if NET20\n      DateTime dt = bi.ToUniversalTime();\n      #else\n      DateTime dt = TimeZoneInfo.ConvertTime(bi, TimeZoneInfo.Utc);\n      #endif\n      year[0] = EInteger.FromInt32(dt.Year);\n      lf[0] = dt.Month;\n      lf[1] = dt.Day;\n      lf[2] = dt.Hour;\n      lf[3] = dt.Minute;\n      lf[4] = dt.Second;\n      // lf[5] is the number of nanoseconds\n      lf[5] = (int)(dt.Ticks % 10000000L) * TicksDivFracSeconds;\n    }\n\n    public static DateTime BuildUpDateTime(EInteger year, int[] dt) {\n      if (TicksDivFracSeconds == 0) {\n        throw new InvalidOperationException();\n      }\n      if (year.CompareTo(9999) > 0 || year.CompareTo(0) <= 0) {\n        throw new CBORException(\"Year is too big or too small for DateTime.\");\n      }\n      return new DateTime(\n          year.ToInt32Checked(),\n          dt[0],\n          dt[1],\n          dt[2],\n          dt[3],\n          dt[4],\n          DateTimeKind.Utc).AddMinutes(-dt[6]).AddTicks((long)(dt[5] /\n            TicksDivFracSeconds));\n    }\n  }\n}\n", "using System;\nusing System.Collections.Generic;\nusing PeterO;\n\nnamespace Test {\n  public sealed class CBORGenerator {\n    private sealed class ByteWriter {\n      private byte[] bytes = new byte[64];\n      private int pos;\n\n      public ByteWriter Write(int b) {\n        if (this.pos < this.bytes.Length) {\n          this.bytes[this.pos++] = (byte)b;\n        } else {\n          var newbytes = new byte[this.bytes.Length * 2];\n          Array.Copy(this.bytes, 0, newbytes, 0, this.bytes.Length);\n          this.bytes = newbytes;\n          this.bytes[this.pos++] = (byte)b;\n        }\n        return this;\n      }\n\n      public int ByteLength {\n        get {\n          return this.pos;\n        }\n      }\n\n      public byte[] ToBytes() {\n        var newbytes = new byte[this.pos];\n        Array.Copy(this.bytes, 0, newbytes, 0, this.pos);\n        return newbytes;\n      }\n    }\n\n    private static void GenerateArgument(\n      IRandomGenExtended r,\n      int majorType,\n      int len,\n      ByteWriter bs) {\n      var maxArg = 4;\n      var sh = 0;\n      int minArg = (len < 0x18) ? 0 : ((len <= 0xff) ? 1 :\n          ((len <= 0xffff) ? 2 : 3));\n      int arg = minArg + r.GetInt32(maxArg - minArg + 1);\n      switch (arg) {\n        case 0:\n          bs.Write((majorType * 0x20) + len);\n          break;\n        case 1:\n          bs.Write((majorType * 0x20) + 0x18);\n          bs.Write(len & 0xff);\n          break;\n        case 2:\n          bs.Write((majorType * 0x20) + 0x19);\n          sh = 8;\n          for (int i = 0; i < 2; ++i) {\n            bs.Write((len >> sh) & 0xff);\n            sh -= 8;\n          }\n          break;\n        case 3:\n          bs.Write((majorType * 0x20) + 0x1a);\n          sh = 24;\n          for (int i = 0; i < 4; ++i) {\n            bs.Write((len >> sh) & 0xff);\n            sh -= 8;\n          }\n          break;\n        case 4:\n          bs.Write((majorType * 0x20) + 0x1b);\n          for (int i = 0; i < 4; ++i) {\n            bs.Write(0);\n          }\n          sh = 24;\n          for (int i = 0; i < 4; ++i) {\n            bs.Write((len >> sh) & 0xff);\n            sh -= 8;\n          }\n          break;\n      }\n    }\n\n    private static int[]\n    valueMajorTypes = {\n      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4,\n      4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7,\n    };\n\n    private static int[]\n    valueMajorTypesHighDepth = {\n      0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n      5, 5, 5, 5, 5, 5, 6, 7,\n    };\n\n    private static int[] valueMajorTypesHighLength = {\n      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 6,\n      6, 7, 7, 7, 7, 7, 7,\n    };\n\n    private static void GenerateUtf8(IRandomGenExtended ra, ByteWriter bs, int\n      length) {\n      for (int i = 0; i < length;) {\n        int r = ra.GetInt32(10);\n        if (r > 0) {\n          bs.Write(ra.GetInt32(128));\n          ++i;\n        } else {\n          r = ra.GetInt32(3);\n          if (r == 0 && length - i >= 2) {\n            r = 0xc2 + ra.GetInt32((0xdf - 0xc2) + 1);\n            bs.Write(r);\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            i += 2;\n          } else if (r == 1 && length - i >= 3) {\n            r = 0xe0 + ra.GetInt32(16);\n            bs.Write(r);\n            int lower = (r == 0xe0) ? 0xa0 : 0x80;\n            int upper = (r == 0xed) ? 0x9f : 0xbf;\n            r = lower + ra.GetInt32((upper - lower) + 1);\n            bs.Write(r);\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            i += 3;\n          } else if (r == 2 && length - i >= 4) {\n            r = 0xf0 + ra.GetInt32(5);\n            bs.Write(r);\n            int lower = (r == 0xf0) ? 0x90 : 0x80;\n            int upper = (r == 0xf4) ? 0x8f : 0xbf;\n            r = lower + ra.GetInt32((upper - lower) + 1);\n            bs.Write(r);\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            bs.Write(0x80 + ra.GetInt32(0x40));\n            i += 4;\n          }\n        }\n      }\n    }\n\n    private void GenerateSmall(IRandomGenExtended r, int depth, ByteWriter bs) {\n      int v = r.GetInt32(100);\n      if (v < 25) {\n        GenerateArgument(r, 0, r.GetInt32(100), bs);\n      } else if (v < 35) {\n        bs.Write(0x41);\n      bs.Write(0x20);\n      } else if (v < 45) {\n        bs.Write(0x41);\n      bs.Write(0x20);\n      } else if (v < 50) {\n        bs.Write(0x81);\n      this.GenerateSmall(r, depth + 1, bs);\n      } else if (v < 53) {\n        bs.Write(0xa2);\n      bs.Write(0xf7);\n    bs.Write(0xf6);\n  this.GenerateSmall(r, depth + 1, bs);\n  bs.Write(0xf5);\n      } else if (v < 80) {\n        bs.Write(r.GetInt32(0x40));\n      } else if (v < 100) {\n        bs.Write(r.GetInt32(0x60));\n      }\n    }\n    private void Generate(IRandomGenExtended r, int depth, ByteWriter bs) {\n      int majorType = valueMajorTypes[r.GetInt32(valueMajorTypes.Length)];\n      if (depth > 6) {\n        majorType = valueMajorTypesHighDepth[r.GetInt32(\n              valueMajorTypesHighDepth.Length)];\n      }\n      if (bs.ByteLength > 2000000) {\n        majorType = valueMajorTypesHighLength[r.GetInt32(\n              valueMajorTypesHighLength.Length)];\n      }\n      if (majorType == 3 || majorType == 2) { // Byte and text strings\n        int len = r.GetInt32(1000);\n        if (r.GetInt32(50) == 0 && depth < 2) {\n          var v = (long)r.GetInt32(100000) * r.GetInt32(100000);\n          len = (int)(v / 100000);\n        } else if (depth > 6) {\n          len = r.GetInt32(100) == 0 ? 1 : 0;\n        } else if (depth > 2) {\n          len = r.GetInt32(16) + 1;\n        }\n        // TODO: Ensure key uniqueness\n        if (r.GetInt32(2) == 0) {\n          // Indefinite length\n          bs.Write(0x1f + (majorType * 0x20));\n          while (len > 0) {\n            int sublen = r.GetInt32(len + 1);\n            GenerateArgument(r, majorType, sublen, bs);\n            if (majorType == 3) {\n              GenerateUtf8(r, bs, sublen);\n            } else {\n              for (int i = 0; i < sublen; ++i) {\n                bs.Write(r.GetInt32(256));\n              }\n            }\n            len -= sublen;\n          }\n          bs.Write(0xff);\n        } else {\n          // Definite length\n          GenerateArgument(r, majorType, len, bs);\n          if (majorType == 3) {\n            GenerateUtf8(r, bs, len);\n          } else {\n            for (int i = 0; i < len; ++i) {\n              bs.Write(r.GetInt32(256));\n            }\n          }\n        }\n        return;\n      } else if (majorType == 4 || majorType == 5) { // Arrays and maps\n        int len = r.GetInt32(8);\n        if (r.GetInt32(50) == 0 && depth < 2) {\n          var v = (long)r.GetInt32(1000) * r.GetInt32(1000);\n          len = (int)(v / 1000);\n        } else if (depth > 6) {\n          len = r.GetInt32(100) == 0 ? 1 : 0;\n        } else if (depth > 2) {\n          len = r.GetInt32(3) + 1;\n        }\n        if (depth > 6) {\n          len = r.GetInt32(100) < 50 ? 1 : (r.GetInt32(100) < 10 ? 2 : 0);\n        }\n        bool indefiniteLength = r.GetInt32(2) == 0;\n        if (indefiniteLength) {\n          bs.Write(0x1f + (majorType * 0x20));\n        } else {\n          GenerateArgument(r, majorType, len, bs);\n        }\n        for (int i = 0; i < len; ++i) {\n          if (depth > 6) {\n            this.GenerateSmall(r, depth + 1, bs);\n          } else {\n            this.Generate(r, depth + 1, bs);\n          }\n          if (majorType == 5) {\n            this.Generate(r, depth + 1, bs);\n          }\n        }\n        if (indefiniteLength) {\n          bs.Write(0xff);\n        }\n        return;\n      }\n      int arg = r.GetInt32(5);\n      switch (arg) {\n        case 0:\n          bs.Write((majorType * 0x20) + r.GetInt32(0x18));\n          break;\n        case 1:\n          bs.Write((majorType * 0x20) + 0x18);\n          if (majorType == 7) {\n            bs.Write(32 + r.GetInt32(224));\n          } else {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n        case 2:\n          bs.Write((majorType * 0x20) + 0x19);\n          for (int i = 0; i < 2; ++i) {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n        case 3:\n          bs.Write((majorType * 0x20) + 0x1a);\n          for (int i = 0; i < 4; ++i) {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n        case 4:\n          bs.Write((majorType * 0x20) + 0x1b);\n          for (int i = 0; i < 8; ++i) {\n            bs.Write(r.GetInt32(256));\n          }\n          break;\n      }\n      if (majorType == 6) { // Tags\n        this.Generate(r, depth + 1, bs);\n      }\n    }\n\n    public byte[] Generate(IRandomGenExtended random) {\n      var bs = new ByteWriter();\n      if (random == null) {\n        throw new ArgumentNullException(nameof(random));\n      }\n      this.Generate(random, 0, bs);\n      byte[] ret = bs.ToBytes();\n      return ret;\n    }\n  }\n}\n", "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing NUnit.Framework;\nusing PeterO;\nusing PeterO.Cbor;\nusing PeterO.Numbers;\n\nnamespace Test {\n  [TestFixture]\n#pragma warning disable CS0618\n  public class CBORObjectTest {\n    private static readonly string[] ValueJsonFails = {\n      \"\\\"\\\\uxxxx\\\"\",\n      \"\\\"\\\\ud800\\udc00\\\"\",\n      \"\\\"\\ud800\\\\udc00\\\"\", \"\\\"\\\\U0023\\\"\", \"\\\"\\\\u002x\\\"\", \"\\\"\\\\u00xx\\\"\",\n      \"\\\"\\\\u0xxx\\\"\", \"\\\"\\\\u0\\\"\", \"\\\"\\\\u00\\\"\", \"\\\"\\\\u000\\\"\", \"trbb\",\n      \"trub\", \"falsb\", \"nulb\", \"[true\", \"[true,\", \"[true]!\", \"tr\\u0020\",\n      \"tr\", \"fa\", \"nu\", \"True\", \"False\", \"Null\", \"TRUE\", \"FALSE\", \"NULL\",\n      \"truE\", \"falsE\", \"nulL\", \"tRUE\", \"fALSE\", \"nULL\", \"tRuE\", \"fAlSe\", \"nUlL\",\n      \"[tr]\", \"[fa]\",\n      \"[nu]\", \"[True]\", \"[False]\", \"[Null]\", \"[TRUE]\", \"[FALSE]\", \"[NULL]\",\n      \"[truE]\", \"[falsE]\",\n      \"[nulL]\", \"[tRUE]\", \"[fALSE]\", \"[nULL]\", \"[tRuE]\", \"[fAlSe]\", \"[nUlL]\",\n      \"fa \", \"nu \", \"fa lse\", \"nu ll\", \"tr ue\",\n      \"[\\\"\\ud800\\\\udc00\\\"]\", \"[\\\"\\\\ud800\\udc00\\\"]\",\n      \"[\\\"\\\\udc00\\ud800\\udc00\\\"]\", \"[\\\"\\\\ud800\\ud800\\udc00\\\"]\",\n      \"[\\\"\\\\ud800\\\"]\", \"[1,2,\", \"[1,2,3\", \"{,\\\"0\\\":0,\\\"1\\\":1}\",\n      \"{\\\"0\\\"::0}\", \"{\\\"0\\\":0,,\\\"1\\\":1}\",\n      \"{\\\"0\\\":0,\\\"1\\\":1,}\", \"[,0,1,2]\", \"[0,,1,2]\", \"[0:1]\", \"[0:1:2]\",\n      \"[0,1,,2]\", \"[0,1,2,]\", \"[0001]\", \"{a:true}\",\n      \"{\\\"a\\\":#comment\\ntrue}\",\n      \"{\\\"a\\\"://comment\\ntrue}\", \"{\\\"a\\\":/*comment*/true}\", \"{'a':true}\",\n      \"{\\\"a\\\":'b'}\", \"{\\\"a\\t\\\":true}\", \"{\\\"a\\r\\\":true}\", \"{\\\"a\\n\\\":true}\",\n      \"['a']\", \"{\\\"a\\\":\\\"a\\t\\\"}\", \"[\\\"a\\\\'\\\"]\", \"[NaN]\", \"[+Infinity]\",\n      \"[-Infinity]\", \"[Infinity]\", \"{\\\"a\\\":\\\"a\\r\\\"}\", \"{\\\"a\\\":\\\"a\\n\\\"}\",\n      \"[\\\"a\\t\\\"]\", \"\\\"test\\\"\\\"\", \"\\\"test\\\"x\", \"\\\"test\\\"\\u0300\",\n      \"\\\"test\\\"\\u0005\", \"[5]\\\"\", \"[5]x\", \"[5]\\u0300\", \"[5]\\u0005\",\n      \"{\\\"test\\\":5}\\\"\", \"{\\\"test\\\":5}x\", \"{\\\"test\\\":5}\\u0300\",\n      \"{\\\"test\\\":5}\\u0005\", \"true\\\"\", \"truex\", \"true}\", \"true\\u0300\",\n      \"true\\u0005\", \"8024\\\"\", \"8024x\", \"8024}\", \"8024\\u0300\",\n      \"8024\\u0005\", \"{\\\"test\\\":5}}\", \"{\\\"test\\\":5}{\", \"[5]]\", \"[5][\",\n      \"00\", \"000\", \"001\", \"0001\", \"00.0\", \"001.0\", \"0001.0\", \"01E-4\", \"01.1E-4\",\n      \"01E4\", \"01.1E4\", \"01e-4\", \"01.1e-4\",\n      \"01e4\", \"01.1e4\",\n      \"+0\", \"+1\", \"+0.0\", \"+1e4\", \"+1e-4\", \"+1.0\", \"+1.0e4\",\n      \"+1.0e+4\", \"+1.0e-4\",\n      \"0000\", \"0x1\", \"0xf\", \"0x20\", \"0x01\",\n      \"-3x\", \"-3e89x\", \"\\u0005true\", \"x\\\\u0005z\",\n      \"0,2\", \"0,05\", \"-0,2\", \"-0,05\", \"\\u007F0.0\", \"\\u00010.0\", \"0.0\\u007F\",\n      \"0.0\\u0001\", \"-1.D\\r\\n\", \"-1.D\\u0020\", \"-1.5L\", \"-0.0L\", \"0L\", \"1L\",\n      \"1.5L\",\n      \"0.0L\",\n      \"0X1\", \"0Xf\", \"0X20\", \"0X01\", \".2\", \".05\", \"-.2\",\n      \"-.05\", \"23.\", \"23.e0\", \"23.e1\", \"0.\", \"-0.\", \"[0000]\", \"[0x1]\",\n      \"[0xf]\", \"[0x20]\", \"[0x01]\", \"[.2]\", \"[.05]\", \"[-.2]\", \"[-.05]\",\n      \"[23.]\", \"[23.e0]\", \"[23.e1]\", \"[0.]\", \"\\\"abc\", \"\\\"ab\\u0004c\\\"\",\n      \"\\u0004\\\"abc\\\"\",\n      \"{\\\"x\\\":true \\\"y\\\":true}\",\n      \"{\\\"x\\\":true\\n\\\"y\\\":true}\",\n      \"0,1,2,3\", \"\\\"x\\\",true\",\n      \"\\\"x\\\",true\",\n      \"\\\"x\\\":true\",\n      \"\\\"x\\\":true,\\\"y\\\":true\",\n      \"\\\"x\\\":true\\n\\\"y\\\":true\",\n      \"\\\"x\\\":true \\\"y\\\":true\",\n      \"{\\\"x\\\":true,\\\"y\\\"}\",\n      \"{\\\"x\\\",\\\"y\\\":true}\",\n      \"{\\\"x\\\":true, \\\"y\\\"}\",\n      \"{\\\"x\\\", \\\"y\\\":true}\",\n      \"{[\\\"x\\\"]:true}\",\n      \"{null:true}\", \"{true:true}\", \"{false:true}\",\n      \"{[0]:true}\", \"{1:true}\", \"{{\\\"a\\\":true}:true}\",\n      \"[1,\\u0004\" + \"2]\",\n    };\n\n    private static readonly string[] ValueJsonSucceeds = {\n      \"[0]\",\n      \"[0.1]\",\n      \"[0.1001]\",\n      \"[0.0]\", \"true\\n\\r\\t\\u0020\",\n      \"[-3 \" + \",-5]\", \"\\n\\r\\t\\u0020true\", \"\\\"x\\\\u0005z\\\"\",\n      \"[0.00]\", \"[0.000]\", \"[0.01]\", \"[0.001]\", \"[0.5]\", \"[0E5]\", \"[0e5]\",\n      \"[0E+6]\", \"[\\\"\\ud800\\udc00\\\"]\", \"[\\\"\\\\ud800\\\\udc00\\\"]\",\n      \"[\\\"\\\\ud800\\\\udc00\\ud800\\udc00\\\"]\", \"23.0e01\", \"23.0e00\", \"[23.0e01]\",\n      \"[23.0e00]\", \"0\", \"1\", \"0.2\", \"0.05\", \"-0.2\", \"-0.05\",\n    };\n\n    private static readonly JSONOptions ValueNoDuplicateKeys = new\n    JSONOptions(\"allowduplicatekeys=false\");\n\n    internal static void CheckPropertyNames(\n      object ao,\n      PODOptions cc,\n      string p1,\n      string p2,\n      string p3) {\n      CBORObjectTest.CheckPropertyNames(\n        CBORObject.FromObject(ao, cc),\n        p1,\n        p2,\n        p3);\n    }\n\n    internal static void CheckArrayPropertyNames(\n      CBORObject co,\n      int expectedCount,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.AreEqual(CBORType.Array, co.Type);\n      Assert.AreEqual(expectedCount, co.Count);\n      for (var i = 0; i < co.Count; ++i) {\n        CBORObjectTest.CheckPropertyNames(co[i], p1, p2, p3);\n      }\n      CBORTestCommon.AssertRoundTrip(co);\n    }\n\n    internal static void CheckPODPropertyNames(\n      CBORObject co,\n      PODOptions cc,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.AreEqual(CBORType.Map, co.Type);\n      string keyName = cc.UseCamelCase ? \"propValue\" : \"PropValue\";\n      if (!co.ContainsKey(keyName)) {\n        Assert.Fail(\"Expected \" + keyName + \" to exist: \" + co.ToString());\n      }\n      CBORObjectTest.CheckPropertyNames(co[keyName], p1, p2, p3);\n    }\n\n    internal static void CheckPODInDictPropertyNames(\n      CBORObject co,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.AreEqual(CBORType.Map, co.Type);\n      if (!co.ContainsKey(\"PropValue\")) {\n        Assert.Fail(\"Expected PropValue to exist: \" + co.ToString());\n      }\n      CBORObjectTest.CheckPropertyNames(co[\"PropValue\"], p1, p2, p3);\n    }\n\n    internal static void CheckPropertyNames(\n      CBORObject o,\n      string p1,\n      string p2,\n      string p3) {\n      Assert.IsFalse(o.ContainsKey(\"PrivatePropA\"));\n      Assert.IsFalse(o.ContainsKey(\"privatePropA\"));\n      Assert.IsFalse(o.ContainsKey(\"StaticPropA\"));\n      Assert.IsFalse(o.ContainsKey(\"staticPropA\"));\n      Assert.AreEqual(CBORType.Map, o.Type);\n      if (!o.ContainsKey(p1)) {\n        Assert.Fail(\"Expected \" + p1 + \" to exist: \" + o.ToString());\n      }\n      if (!o.ContainsKey(p2)) {\n        Assert.Fail(\"Expected \" + p2 + \" to exist: \" + o.ToString());\n      }\n      if (!o.ContainsKey(p3)) {\n        Assert.Fail(\"Expected \" + p3 + \" to exist: \" + o.ToString());\n      }\n      CBORTestCommon.AssertRoundTrip(o);\n    }\n\n    internal static void CheckPropertyNames(object ao) {\n      var valueCcTF = new PODOptions(true, false);\n      var valueCcFF = new PODOptions(false, false);\n      var valueCcFT = new PODOptions(false, true);\n      var valueCcTT = new PODOptions(true, true);\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcTF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      //--\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcFF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcFT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckPropertyNames(\n        ao,\n        valueCcTT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n    }\n\n    public static CBORObject GetNumberData() {\n      return new AppResources(\"Resources\").GetJSON(\"numbers\");\n    }\n\n    public static void TestFailingJSON(string str) {\n      TestFailingJSON(str, new JSONOptions(\"allowduplicatekeys=true\"));\n    }\n\n    public static void TestFailingJSON(string str, JSONOptions opt) {\n      byte[] bytes = null;\n      try {\n        bytes = DataUtilities.GetUtf8Bytes(str, false);\n      } catch (ArgumentException ex2) {\n        Console.WriteLine(ex2.Message);\n        // Check only FromJSONString\n        try {\n          CBORObject.FromJSONString(str, opt);\n          Assert.Fail(\"Should have failed: str = \" + str);\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        return;\n      }\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadJSON(ms, opt);\n          Assert.Fail(\"Should have failed: str = \" + str);\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(str + \"\\r\\n\" + ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      try {\n        CBORObject.FromJSONString(str, opt);\n        Assert.Fail(\"Should have failed: str = \" + str);\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static CBORObject TestSucceedingJSON(string str) {\n      return TestSucceedingJSON(str, null);\n    }\n\n    public static CBORObject TestSucceedingJSON(\n      string str,\n      JSONOptions options) {\n      byte[] bytes = DataUtilities.GetUtf8Bytes(str, false);\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          CBORObject obj = options == null ? CBORObject.ReadJSON(ms) :\n            CBORObject.ReadJSON(ms, options);\n          CBORObject obj2 = options == null ? CBORObject.FromJSONString(str) :\n            CBORObject.FromJSONString(str, options);\n          if (!obj.Equals(obj2)) {\n            TestCommon.CompareTestEqualAndConsistent(\n              obj,\n              obj2);\n          }\n          if (str == null) {\n            throw new ArgumentNullException(nameof(str));\n          }\n          CBORObject obj3 = options == null ? CBORObject.FromJSONString(\n              str,\n              0,\n              str.Length) :\n            CBORObject.FromJSONString(str, 0, str.Length, options);\n          if (!obj.Equals(obj3)) {\n            Assert.AreEqual(obj, obj3);\n          }\n          obj3 = options == null ? CBORObject.FromJSONString(\n              \"xyzxyz\" + str,\n              6,\n              str.Length) :\n            CBORObject.FromJSONString(\"xyzxyz\" + str, 6, str.Length, options);\n          if (!obj.Equals(obj3)) {\n            Assert.AreEqual(obj, obj3);\n          }\n          obj3 = options == null ? CBORObject.FromJSONString(\n              \"xyzxyz\" + str + \"xyzxyz\",\n              6,\n              str.Length) : CBORObject.FromJSONString(\n              \"xyzxyz\" + str + \"xyzxyz\",\n              6,\n              str.Length,\n              options);\n          if (!obj.Equals(obj3)) {\n            Assert.AreEqual(obj, obj3);\n          }\n          return obj;\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString() + \"\\n\" + str);\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static string CharString(int cp, bool quoted, char[] charbuf) {\n      var index = 0;\n      if (quoted) {\n        if (charbuf == null) {\n          throw new ArgumentNullException(nameof(charbuf));\n        }\n        charbuf[index++] = (char)0x22;\n      }\n      if (cp < 0x10000) {\n        if (cp >= 0xd800 && cp < 0xe000) {\n          return null;\n        }\n        if (charbuf == null) {\n          throw new ArgumentNullException(nameof(charbuf));\n        }\n        charbuf[index++] = (char)cp;\n        if (quoted) {\n          charbuf[index++] = (char)0x22;\n        }\n        return new String(charbuf, 0, index);\n      } else {\n        cp -= 0x10000;\n        if (charbuf == null) {\n          throw new ArgumentNullException(nameof(charbuf));\n        }\n        charbuf[index++] = (char)((cp >> 10) + 0xd800);\n        charbuf[index++] = (char)((cp & 0x3ff) | 0xdc00);\n        if (quoted) {\n          charbuf[index++] = (char)0x22;\n        }\n        return new String(charbuf, 0, index);\n      }\n    }\n\n    [Test]\n    public void TestAdd() {\n      CBORObject cbor = CBORObject.NewMap();\n      CBORObject cborNull = CBORObject.Null;\n      cbor.Add(null, true);\n      Assert.AreEqual(CBORObject.True, cbor[cborNull]);\n      cbor.Add(\"key\", null);\n      Assert.AreEqual(CBORObject.Null, cbor[\"key\"]);\n    }\n\n    [Test]\n    public void TestAddConverter() {\n      // not implemented yet\n    }\n\n    private static EDecimal AsED(CBORObject obj) {\n      return (EDecimal)obj.ToObject(typeof(EDecimal));\n    }\n\n    [Test]\n    [Timeout(5000)]\n    public void TestAsNumberAdd() {\n      var r = new RandomGenerator();\n      for (var i = 0; i < 1000; ++i) {\n        // NOTE: Avoid generating high-exponent numbers for this test\n        CBORObject o1 = CBORTestCommon.RandomNumber(r, true);\n        CBORObject o2 = CBORTestCommon.RandomNumber(r, true);\n        EDecimal cmpCobj = null;\n        try {\n          cmpCobj = o1.AsNumber().Add(o2.AsNumber()).ToEDecimal();\n        } catch (OutOfMemoryException) {\n          continue;\n        }\n        EDecimal cmpDecFrac = AsED(o1).Add(AsED(o2));\n        TestCommon.CompareTestEqual(cmpDecFrac, cmpCobj);\n        CBORTestCommon.AssertRoundTrip(o1);\n        CBORTestCommon.AssertRoundTrip(o2);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber().Add(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestAsBoolean() {\n      Assert.IsTrue(CBORObject.True.AsBoolean());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).AsBoolean());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .AsBoolean());\n      Assert.IsFalse(CBORObject.False.AsBoolean());\n      Assert.IsFalse(CBORObject.Null.AsBoolean());\n      Assert.IsFalse(CBORObject.Undefined.AsBoolean());\n      Assert.IsTrue(CBORObject.NewArray().AsBoolean());\n      Assert.IsTrue(CBORObject.NewMap().AsBoolean());\n    }\n\n    [Test]\n    public void TestAsByte() {\n      try {\n        CBORObject.NewArray().AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsByte();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"byte\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n            ((int)cbornumber.AsByte()) & 0xff);\n        } else {\n          try {\n            cbornumber.AsByte();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n      for (var i = 0; i < 255; ++i) {\n        Assert.AreEqual(\n          (byte)i,\n          ToObjectTest.TestToFromObjectRoundTrip(i).AsByte());\n      }\n      for (int i = -200; i < 0; ++i) {\n        try {\n          ToObjectTest.TestToFromObjectRoundTrip(i).AsByte();\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      for (int i = 256; i < 512; ++i) {\n        try {\n          ToObjectTest.TestToFromObjectRoundTrip(i).AsByte();\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsDouble() {\n      try {\n        CBORObject.NewArray().AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsDouble();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        {\n          var dtemp = (double)EDecimal.FromString(\n              numberinfo[\"number\"].AsString()).ToDouble();\n          double dtemp2 = cbornumber.AsDouble();\n          AreEqualExact(dtemp, dtemp2);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsInt16() {\n      try {\n        CBORObject.NewArray().AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsInt16();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(\n            EDecimal.FromString(numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"int16\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n            cbornumber.AsInt16());\n        } else {\n          try {\n            cbornumber.AsInt16();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsInt32() {\n      try {\n        CBORObject.NewArray().AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsInt32();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        EDecimal edec =\n          EDecimal.FromString(numberinfo[\"number\"].AsString());\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(edec);\n        bool isdouble = numberinfo[\"double\"].AsBoolean();\n        CBORObject cbornumberdouble =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToDouble());\n        bool issingle = numberinfo[\"single\"].AsBoolean();\n        CBORObject cbornumbersingle =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToSingle());\n        if (numberinfo[\"int32\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n            cbornumber.AsInt32());\n          if (isdouble) {\n            Assert.AreEqual(\n              TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n              cbornumberdouble.AsInt32());\n          }\n          if (issingle) {\n            Assert.AreEqual(\n              TestCommon.StringToInt(numberinfo[\"integer\"].AsString()),\n              cbornumbersingle.AsInt32());\n          }\n        } else {\n          try {\n            cbornumber.AsInt32();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          if (isdouble) {\n            try {\n              cbornumberdouble.AsInt32();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          if (issingle) {\n            try {\n              cbornumbersingle.AsInt32();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsInt64() {\n      try {\n        CBORObject.NewArray().AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsInt64();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        EDecimal edec =\n          EDecimal.FromString(numberinfo[\"number\"].AsString());\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(edec);\n        bool isdouble = numberinfo[\"double\"].AsBoolean();\n        CBORObject cbornumberdouble =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToDouble());\n        bool issingle = numberinfo[\"single\"].AsBoolean();\n        CBORObject cbornumbersingle =\n          ToObjectTest.TestToFromObjectRoundTrip(edec.ToSingle());\n        if (numberinfo[\"int64\"].AsBoolean()) {\n          Assert.AreEqual(\n            TestCommon.StringToLong(numberinfo[\"integer\"].AsString()),\n            cbornumber.AsInt64());\n          if (isdouble) {\n            Assert.AreEqual(\n              TestCommon.StringToLong(numberinfo[\"integer\"].AsString()),\n              cbornumberdouble.AsInt64());\n          }\n          if (issingle) {\n            Assert.AreEqual(\n              TestCommon.StringToLong(numberinfo[\"integer\"].AsString()),\n              cbornumbersingle.AsInt64());\n          }\n        } else {\n          try {\n            cbornumber.AsInt64();\n            Assert.Fail(\"Should have failed \" + cbornumber);\n          } catch (OverflowException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + cbornumber);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          if (isdouble) {\n            try {\n              cbornumberdouble.AsInt64();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          if (issingle) {\n            try {\n              cbornumbersingle.AsInt64();\n              Assert.Fail(\"Should have failed\");\n            } catch (OverflowException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsSByte() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestAsSingle() {\n      try {\n        CBORObject.NewArray().AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsSingle();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        {\n          var ftemp = (float)EDecimal.FromString(\n              numberinfo[\"number\"].AsString()).ToSingle();\n          float ftemp2 = cbornumber.AsSingle();\n          AreEqualExact(ftemp, ftemp2);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsString() {\n      {\n        string stringTemp = ToObjectTest.TestToFromObjectRoundTrip(\"test\")\n          .AsString();\n        Assert.AreEqual(\n          \"test\",\n          stringTemp);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(CBORObject.Null).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(true).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(false).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(5).AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewArray().AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestAsUInt16() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestAsUInt32() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestAsUInt64() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestCanFitInDouble() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(\n          0).CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleA() {\n      Assert.IsFalse(CBORObject.True.CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleB() {\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleC() {\n      Assert.IsFalse(CBORObject.NewArray().CanFitInDouble());\n      Assert.IsFalse(CBORObject.NewMap().CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleD() {\n      Assert.IsFalse(CBORObject.False.CanFitInDouble());\n      Assert.IsFalse(CBORObject.Null.CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleE() {\n      Assert.IsFalse(CBORObject.Undefined.CanFitInDouble());\n    }\n    [Test]\n    public void TestCanFitInDoubleF() {\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (cbornumber == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"double\"].AsBoolean()) {\n          if (!cbornumber.CanFitInDouble()) {\n            Assert.Fail(cbornumber.ToString());\n          }\n        } else {\n          if (cbornumber.CanFitInDouble()) {\n            Assert.Fail(cbornumber.ToString());\n          }\n        }\n      }\n      var rand = new RandomGenerator();\n      for (var i = 0; i < 2047; ++i) {\n        // Try a random double with a given\n        // exponent\n        object o = RandomObjects.RandomDouble(rand, i);\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(o);\n        if (cbornumber == null) {\n          Assert.Fail();\n        }\n        Assert.IsTrue(cbornumber.CanFitInDouble());\n      }\n    }\n\n    [Test]\n    public void TestCanFitInInt32() {\n      Assert.IsTrue(CInt32(ToObjectTest.TestToFromObjectRoundTrip(0)));\n      Assert.IsFalse(CInt32(CBORObject.True));\n      Assert.IsFalse(CInt32(ToObjectTest.TestToFromObjectRoundTrip(\n            String.Empty)));\n      Assert.IsFalse(CInt32(CBORObject.NewArray()));\n      Assert.IsFalse(CInt32(CBORObject.NewMap()));\n      Assert.IsFalse(CInt32(CBORObject.False));\n      Assert.IsFalse(CInt32(CBORObject.Null));\n      Assert.IsFalse(CInt32(CBORObject.Undefined));\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int32\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"isintegral\"] == null) {\n          Assert.Fail();\n        }\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (cbornumber == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int32\"].AsBoolean() &&\n          numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(CInt32(cbornumber));\n          Assert.IsTrue(\n            CInt32(ToObjectTest.TestToFromObjectRoundTrip(\n                cbornumber.AsInt32())));\n        } else {\n          Assert.IsFalse(CInt32(cbornumber));\n        }\n      }\n    }\n\n    private static bool CInt64(CBORObject cbor) {\n      return cbor != null && cbor.IsNumber && cbor.AsNumber().CanFitInInt64();\n    }\n\n    private static bool CInt32(CBORObject cbor) {\n      return cbor != null && cbor.IsNumber && cbor.AsNumber().CanFitInInt32();\n    }\n\n    [Test]\n    public void TestCanFitInInt64() {\n      Assert.IsTrue(CInt64(ToObjectTest.TestToFromObjectRoundTrip(0)));\n      Assert.IsFalse(CInt64(CBORObject.True));\n      Assert.IsFalse(CInt64(ToObjectTest.TestToFromObjectRoundTrip(\n            String.Empty)));\n      Assert.IsFalse(CInt64(CBORObject.NewArray()));\n      Assert.IsFalse(CInt64(CBORObject.NewMap()));\n      Assert.IsFalse(CInt64(CBORObject.False));\n      Assert.IsFalse(CInt64(CBORObject.Null));\n      Assert.IsFalse(CInt64(CBORObject.Undefined));\n\n      EInteger ei;\n      ei = EInteger.FromString(\"9223372036854775807\");\n      Assert.IsTrue(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"9223372036854775808\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775807\");\n      Assert.IsTrue(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775808\");\n      Assert.IsTrue(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775809\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"-9223373136366403584\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      ei = EInteger.FromString(\"9223373136366403584\");\n      Assert.IsFalse(CInt64(CBORObject.FromObject(ei)), ei.ToString());\n      var strings = new string[] {\n        \"8000FFFFFFFF0000\",\n        \"8000AAAAAAAA0000\",\n        \"8000800080000000\",\n        \"8000000100010000\",\n        \"8000FFFF00000000\",\n        \"80000000FFFF0000\",\n        \"8000800000000000\",\n        \"8000000080000000\",\n        \"8000AAAA00000000\",\n        \"80000000AAAA0000\",\n        \"8000000100000000\",\n        \"8000000000010000\",\n      };\n      foreach (var str in strings) {\n        ei = EInteger.FromRadixString(str, 16);\n        Assert.IsFalse(CInt64(CBORObject.FromObject(ei)));\n        ei = ei.Negate();\n        Assert.IsFalse(CInt64(CBORObject.FromObject(ei)));\n      }\n\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int64\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"isintegral\"] == null) {\n          Assert.Fail();\n        }\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"int64\"].AsBoolean() &&\n          numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(CInt64(cbornumber));\n\n          Assert.IsTrue(\n            CInt64(ToObjectTest.TestToFromObjectRoundTrip(\n                cbornumber.AsInt64())));\n        } else {\n          Assert.IsFalse(CInt64(cbornumber));\n        }\n      }\n    }\n\n    [Test]\n    public void TestCanFitInSingle() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(\n          0).CanFitInSingle());\n      Assert.IsFalse(CBORObject.True.CanFitInSingle());\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanFitInSingle());\n      Assert.IsFalse(CBORObject.NewArray().CanFitInSingle());\n      Assert.IsFalse(CBORObject.NewMap().CanFitInSingle());\n      Assert.IsFalse(CBORObject.False.CanFitInSingle());\n      Assert.IsFalse(CBORObject.Null.CanFitInSingle());\n      Assert.IsFalse(CBORObject.Undefined.CanFitInSingle());\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"single\"] == null) {\n          Assert.Fail();\n        }\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"single\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.CanFitInSingle());\n        } else {\n          Assert.IsFalse(cbornumber.CanFitInSingle());\n        }\n      }\n\n      var rand = new RandomGenerator();\n      for (var i = 0; i < 255; ++i) {\n        // Try a random float with a given\n        // exponent\n        Assert.IsTrue(\n          ToObjectTest.TestToFromObjectRoundTrip(\n            RandomObjects.RandomSingle(\n              rand,\n              i)).CanFitInSingle());\n      }\n    }\n\n    [Test]\n    public void TestCanTruncatedIntFitInInt32() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            11)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            12)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            13)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            14)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            15)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            16)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            17)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            18)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            19)).CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.True.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewArray().CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewMap().CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.False.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.Null.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.Undefined.CanTruncatedIntFitInInt32());\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        if (numberinfo[\"number\"] == null) {\n          Assert.Fail();\n        }\n        if (numberinfo[\"int32\"] == null) {\n          Assert.Fail();\n        }\n        string numberString = numberinfo[\"number\"].AsString();\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(\n            EDecimal.FromString(numberString));\n        if (numberinfo[\"int32\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.CanTruncatedIntFitInInt32(), numberString);\n        } else {\n          Assert.IsFalse(cbornumber.CanTruncatedIntFitInInt32(), numberString);\n        }\n      }\n\n      Assert.IsFalse(CBORObject.True.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.False.CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewArray().CanTruncatedIntFitInInt32());\n      Assert.IsFalse(CBORObject.NewMap().CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(2.5)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(Int32.MinValue)\n        .CanTruncatedIntFitInInt32());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(Int32.MaxValue)\n        .CanTruncatedIntFitInInt32());\n      var negint32 = new object[] {\n        Double.PositiveInfinity,\n        Double.NegativeInfinity,\n        Double.NaN,\n        CBORTestCommon.DecPosInf,\n        CBORTestCommon.DecNegInf,\n        EDecimal.NaN,\n      };\n      foreach (var obj in negint32) {\n        bool bval = ToObjectTest.TestToFromObjectRoundTrip(obj)\n          .CanTruncatedIntFitInInt32();\n        Assert.IsFalse(bval, obj.ToString());\n      }\n    }\n\n    [Test]\n    public void TestCanTruncatedIntFitInInt64() {\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            11)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            12)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            13)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            14)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            15)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            16)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            17)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            18)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(EFloat.Create(\n            -2,\n            19)).CanTruncatedIntFitInInt64());\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0)\n        .CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.True.CanTruncatedIntFitInInt64());\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.NewArray().CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.NewMap().CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.False.CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.Null.CanTruncatedIntFitInInt64());\n      Assert.IsFalse(CBORObject.Undefined.CanTruncatedIntFitInInt64());\n\n      EInteger ei;\n      ei = EInteger.FromString(\"9223372036854775807\");\n      {\n        bool btemp = CBORObject.FromObject(ei)\n          .CanTruncatedIntFitInInt64();\n        Assert.IsTrue(btemp, ei.ToString());\n      }\n      ei = EInteger.FromString(\"9223372036854775808\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775807\");\n      Assert.IsTrue(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775808\");\n      Assert.IsTrue(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223372036854775809\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"-9223373136366403584\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      ei = EInteger.FromString(\"9223373136366403584\");\n      Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64(),\n        ei.ToString());\n      var strings = new string[] {\n        \"8000FFFFFFFF0000\",\n        \"8000AAAAAAAA0000\",\n        \"8000800080000000\",\n        \"8000000100010000\",\n        \"8000FFFF00000000\",\n        \"80000000FFFF0000\",\n        \"8000800000000000\",\n        \"8000000080000000\",\n        \"8000AAAA00000000\",\n        \"80000000AAAA0000\",\n        \"8000000100000000\",\n        \"8000000000010000\",\n      };\n      foreach (var str in strings) {\n        ei = EInteger.FromRadixString(str, 16);\n        Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64());\n        ei = ei.Negate();\n        Assert.IsFalse(CBORObject.FromObject(ei).CanTruncatedIntFitInInt64());\n      }\n\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        string numberString = numberinfo[\"number\"].AsString();\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberString));\n        if (numberinfo[\"int64\"].AsBoolean()) {\n          Assert.IsTrue(\n            cbornumber.CanTruncatedIntFitInInt64(),\n            numberString);\n        } else {\n          Assert.IsFalse(\n            cbornumber.CanTruncatedIntFitInInt64(),\n            numberString);\n        }\n      }\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo2() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x00, 0x00, 0x00, (byte)0xd3, (byte)0xe1, 0x26,\n        (byte)0xf9, 0x3b, (byte)0xc2, 0x4c, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01,\n        0x01, 0x00, 0x00, 0x01, 0x00, 0x00,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x3b, 0x00, 0x00, 0x00, 0x56, (byte)0xe9, 0x21, (byte)0xda,\n        (byte)0xe9, (byte)0xc2, 0x58, 0x2a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,\n        0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x01,\n        0x00,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestGreater(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo6() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x1b, 0x00, 0x00, 0x00, 0x7a, 0x50, (byte)0xe0, 0x1f,\n        (byte)0xc6, (byte)0xc2, 0x4c, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01,\n        0x00, 0x00, 0x00, 0x01, 0x01,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x19, 0x01, 0x60, (byte)0xc2, 0x58, (byte)0x87, (byte)0xbb,\n        (byte)0xf8, 0x74, (byte)0xbe, (byte)0xcc, 0x46, 0x6b, 0x02, 0x3c,\n        (byte)0x84, (byte)0xe9, (byte)0xd1, (byte)0xe9, 0x3c, (byte)0xd3,\n        (byte)0xd5, 0x20, (byte)0xc1, 0x7e, 0x17, 0x09, 0x0f, (byte)0xdd, 0x73,\n        0x5d, (byte)0xe4, 0x51, (byte)0xd6, 0x10, 0x52, 0x2e, 0x6c, 0x77,\n        (byte)0x9f, 0x5e, 0x4f, 0x58, 0x72, 0x38, 0x43, (byte)0xb0, 0x28, 0x5a,\n        0x6c, (byte)0xe5, (byte)0xd2, 0x36, (byte)0x9e, 0x69, 0x50, (byte)0xf9,\n        0x62, 0x7f, (byte)0xcb, (byte)0xf5, 0x12, (byte)0x8c, 0x37, 0x2d,\n        (byte)0x8e, 0x4f, (byte)0x83, 0x5c, (byte)0xd6, 0x6d, 0x5e, (byte)0xf0,\n        0x65, 0x12, 0x4a, 0x0a, (byte)0x81, (byte)0x89, (byte)0xed, 0x20, 0x50,\n        (byte)0xca, 0x0e, (byte)0x81, (byte)0xbc, (byte)0x9e, (byte)0x83, 0x66,\n        (byte)0xb1, (byte)0xcd, 0x23, (byte)0xee, 0x24, 0x2e, (byte)0xec, 0x77,\n        0x13, (byte)0x89, (byte)0xbd, (byte)0xfb, 0x47, (byte)0xd1, 0x02, 0x1c,\n        0x4e, (byte)0xf5, 0x30, 0x59, 0x75, (byte)0xce, (byte)0xa8, (byte)0xaf,\n        0x23, 0x51, 0x7e, 0x26, (byte)0xaa, (byte)0xed, (byte)0xe9, 0x34, 0x02,\n        0x31, 0x70, (byte)0xe3, 0x3f, 0x71, (byte)0x9a, (byte)0x9a, (byte)0xe9,\n        (byte)0xf3, 0x6d, (byte)0xd7, 0x28, 0x18, (byte)0xa2, (byte)0xb5,\n        (byte)0x8b, (byte)0xca, 0x11, (byte)0x99,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestReciprocal(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo5() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x1b, 0x00, 0x00, 0x10, 0x57, (byte)0xa5, (byte)0x96,\n        (byte)0xbe, 0x7b, (byte)0xc2, 0x53, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,\n        0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,\n        0x00,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x19, 0x01, (byte)0x84, (byte)0xc2, 0x53, 0x20, 0x44, 0x52,\n        0x64, (byte)0x9d, (byte)0xea, (byte)0xe8, 0x57, 0x13, (byte)0xa3, 0x7c,\n        (byte)0xeb, 0x5e, 0x0e, 0x54, (byte)0xc8, (byte)0xf0, (byte)0xb2,\n        0x58,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestReciprocal(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x00, 0x00, 0x00, 0x15, (byte)0xfc, (byte)0xa0,\n        (byte)0xd9, (byte)0xf9, (byte)0xc3, 0x58, 0x36, 0x02, (byte)0x83, 0x3b,\n        0x3c, (byte)0x99, (byte)0xdb, (byte)0xe4, (byte)0xfc, 0x2a, 0x69, 0x69,\n        (byte)0xe7, 0x63, (byte)0xb7, 0x5d, 0x48, (byte)0xcf, 0x51, 0x33,\n        (byte)0xd7, (byte)0xc3, 0x59, 0x4d, 0x63, 0x3c, (byte)0xbb, (byte)0x9d,\n        0x43, 0x2d, (byte)0xd1, 0x51, 0x39, 0x1f, 0x03, 0x22, 0x5c, 0x13,\n        (byte)0xed, 0x02, (byte)0xca, (byte)0xda, 0x09, 0x22, 0x07, (byte)0x9f,\n        0x34, (byte)0x84, (byte)0xb4, 0x22, (byte)0xa8, 0x26, (byte)0x9f, 0x35,\n        (byte)0x8d,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x24, 0x26,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestGreater(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo3() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x04, 0x55, 0x0a, 0x12, (byte)0x94, (byte)0xf8, 0x1f,\n        (byte)0x9b, (byte)0xc2, 0x58, 0x1f, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,\n        0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01,\n        0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01,\n        0x00,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x39, 0x02, 0x03, (byte)0xc2, 0x58, 0x2d, 0x01, 0x00, 0x00,\n        0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,\n        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n        0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00,\n        0x01, 0x01, 0x00, 0x01, 0x00, 0x01,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestLess(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestSlowCompareTo4() {\n      CBORObject cbor1 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc4,\n        (byte)0x82, 0x2f, 0x3b, 0x00, 0x1e, (byte)0xdc, 0x5d, 0x51, 0x5d, 0x26,\n        (byte)0xb7,\n      });\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xc5,\n        (byte)0x82, 0x3b, 0x00, 0x18, 0x72, 0x44, 0x49, (byte)0xd0, 0x0c,\n        (byte)0xb6, (byte)0xc3, 0x58, (byte)0x88, 0x0a, (byte)0xd0, 0x12,\n        (byte)0x93, (byte)0xcb, 0x0a, 0x30, 0x2d, 0x11, 0x36, 0x59, 0x5a,\n        (byte)0xfe, (byte)0x81, 0x79, (byte)0x80, (byte)0x86, (byte)0xb8, 0x2f,\n        0x26, 0x4b, (byte)0xf4, 0x70, (byte)0xb4, 0x37, 0x3b, 0x7a, 0x1d,\n        (byte)0x89, 0x4b, (byte)0xd4, 0x75, 0x07, (byte)0xad, 0x0c, (byte)0x90,\n        0x6b, 0x1f, 0x53, (byte)0xf7, (byte)0xc3, (byte)0xde, 0x61, (byte)0xf2,\n        0x62, 0x78, (byte)0x8a, 0x29, 0x31, 0x44, (byte)0xdd, 0x20, (byte)0xa4,\n        0x79, 0x76, 0x59, (byte)0xb7, (byte)0xf7, 0x7c, 0x37, (byte)0xb8, 0x47,\n        (byte)0xcf, (byte)0x96, (byte)0xf8, (byte)0x85, (byte)0xae, (byte)0xee,\n        (byte)0xb4, 0x06, 0x13, (byte)0xef, (byte)0xd1, (byte)0xe6, 0x36,\n        (byte)0xa5, (byte)0xfe, (byte)0xec, (byte)0x8f, (byte)0x8e, 0x00,\n        (byte)0xaa, (byte)0xc2, (byte)0xd4, 0x77, (byte)0xcf, (byte)0xea,\n        (byte)0xff, 0x4d, 0x12, 0x0b, (byte)0xf5, 0x08, (byte)0xc4, 0x0f, 0x08,\n        (byte)0xa7, 0x07, (byte)0xb6, 0x45, 0x47, (byte)0x89, (byte)0xba, 0x5a,\n        (byte)0xde, 0x6c, 0x69, 0x6a, 0x49, (byte)0xba, (byte)0xb2, (byte)0xd9,\n        0x0f, (byte)0x9c, (byte)0xa4, (byte)0xec, 0x48, (byte)0xd2, 0x71, 0x50,\n        (byte)0xde, (byte)0x96, (byte)0x99, (byte)0x9e, (byte)0x89, 0x33,\n        (byte)0x8f, 0x6f, (byte)0xa8, 0x30, (byte)0xa1, 0x0a, 0x0f, (byte)0xab,\n        (byte)0xfe, (byte)0xbe,\n      });\n      Console.WriteLine(cbor1);\n      Console.WriteLine(cbor2);\n      TestCommon.CompareTestLess(cbor1.AsNumber(), cbor2.AsNumber());\n    }\n\n    private static string TrimStr(string str, int len) {\n      return str.Substring(0, Math.Min(len, str.Length));\n    }\n\n    [Test]\n    public void CompareLongDouble() {\n      CBORObject cbor1 = CBORObject.FromObject(3.5E-15);\n      CBORObject cbor2 = CBORObject.FromObject(281479271677953L);\n      TestCommon.CompareTestLess(cbor1.AsDouble(), cbor2.AsDouble());\n    }\n\n    [Test]\n    [Timeout(300000)]\n    public void TestCompareTo() {\n      var r = new RandomGenerator();\n      const int CompareCount = 3000;\n      var list = new List<CBORObject>();\n      for (var i = 0; i < CompareCount; ++i) {\n        CBORObject o1 = CBORTestCommon.RandomCBORObject(r);\n        CBORObject o2 = CBORTestCommon.RandomCBORObject(r);\n        CBORObject o3 = CBORTestCommon.RandomCBORObject(r);\n        TestCommon.CompareTestRelations(o1, o2, o3);\n      }\n      Console.WriteLine(\"Check compare\");\n      for (var i = 0; i < list.Count; ++i) {\n        int j;\n        j = i + 1;\n        for (; j < list.Count; ++j) {\n          CBORObject o1 = list[i];\n          CBORObject o2 = list[j];\n          TestCommon.CompareTestReciprocal(o1, o2);\n        }\n      }\n      Console.WriteLine(\"Sorting\");\n      list.Sort();\n      Console.WriteLine(\"Check compare 2\");\n      for (var i = 0; i < list.Count - 1; ++i) {\n        CBORObject o1 = list[i];\n        CBORObject o2 = list[i + 1];\n        TestCommon.CompareTestLessEqual(o1, o2);\n      }\n      for (var i = 0; i < 5000; ++i) {\n        CBORObject o1 = CBORTestCommon.RandomNumber(r);\n        CBORObject o2 = CBORTestCommon.RandomNumber(r);\n        CompareDecimals(o1, o2);\n      }\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(0.1),\n        ToObjectTest.TestToFromObjectRoundTrip(0.1));\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(0.1f),\n        ToObjectTest.TestToFromObjectRoundTrip(0.1f));\n      for (var i = 0; i < 50; ++i) {\n        CBORObject o1 =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.NegativeInfinity);\n        CBORObject o2 = CBORTestCommon.RandomNumberOrRational(r);\n        if (o2.AsNumber().IsInfinity() || o2.AsNumber().IsNaN()) {\n          continue;\n        }\n        TestCommon.CompareTestLess(o1.AsNumber(), o2.AsNumber());\n        o1 = ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        TestCommon.CompareTestLess(o1.AsNumber(), o2.AsNumber());\n        o1 = ToObjectTest.TestToFromObjectRoundTrip(Single.PositiveInfinity);\n        TestCommon.CompareTestGreater(o1.AsNumber(), o2.AsNumber());\n        o1 = ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        TestCommon.CompareTestGreater(o1.AsNumber(), o2.AsNumber());\n      }\n      byte[] bytes1 = { 0, 1 };\n      byte[] bytes2 = { 0, 2 };\n      byte[] bytes3 = { 1, 1 };\n      byte[] bytes4 = { 1, 2 };\n      byte[] bytes5 = { 0, 2, 0 };\n      byte[] bytes6 = { 1, 1, 4 };\n      byte[] bytes7 = { 1, 2, 6 };\n      CBORObject[] sortedObjects = {\n        ToObjectTest.TestToFromObjectRoundTrip(bytes1),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes2),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes3),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes4),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes5),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes6),\n        ToObjectTest.TestToFromObjectRoundTrip(bytes7),\n        ToObjectTest.TestToFromObjectRoundTrip(\"aa\"),\n        ToObjectTest.TestToFromObjectRoundTrip(\"ab\"),\n        ToObjectTest.TestToFromObjectRoundTrip(\"ba\"),\n        ToObjectTest.TestToFromObjectRoundTrip(\"abc\"),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORObject.NewArray()),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORObject.NewMap()),\n        CBORObject.FromSimpleValue(0),\n        CBORObject.FromSimpleValue(1),\n        CBORObject.FromSimpleValue(19), CBORObject.FromSimpleValue(32),\n        CBORObject.FromSimpleValue(255),\n        ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity),\n      };\n      for (var i = 0; i < sortedObjects.Length; ++i) {\n        for (int j = i; j < sortedObjects.Length; ++j) {\n          if (i == j) {\n            TestCommon.CompareTestEqual(sortedObjects[i], sortedObjects[j]);\n          } else {\n            TestCommon.CompareTestLess(sortedObjects[i], sortedObjects[j]);\n          }\n        }\n        Assert.AreEqual(1, sortedObjects[i].CompareTo(null));\n      }\n      CBORNumber sp =\n        CBORObject.FromObject(Single.PositiveInfinity).AsNumber();\n      CBORNumber sn = CBORObject.FromObject(\n          Single.NegativeInfinity).AsNumber();\n      CBORNumber snan = CBORObject.FromObject(Single.NaN).AsNumber();\n      CBORNumber dp = CBORObject.FromObject(\n          Double.PositiveInfinity).AsNumber();\n      CBORNumber dn = CBORObject.FromObject(\n          Double.NegativeInfinity).AsNumber();\n      CBORNumber dnan = CBORObject.FromObject(Double.NaN).AsNumber();\n      TestCommon.CompareTestEqual(sp, sp);\n      TestCommon.CompareTestEqual(sp, dp);\n      TestCommon.CompareTestEqual(dp, dp);\n      TestCommon.CompareTestEqual(sn, sn);\n      TestCommon.CompareTestEqual(sn, dn);\n      TestCommon.CompareTestEqual(dn, dn);\n      TestCommon.CompareTestEqual(snan, snan);\n      TestCommon.CompareTestEqual(snan, dnan);\n      TestCommon.CompareTestEqual(dnan, dnan);\n      TestCommon.CompareTestLess(sn, sp);\n      TestCommon.CompareTestLess(sn, dp);\n      TestCommon.CompareTestLess(sn, snan);\n      TestCommon.CompareTestLess(sn, dnan);\n      TestCommon.CompareTestLess(sp, snan);\n      TestCommon.CompareTestLess(sp, dnan);\n      TestCommon.CompareTestLess(dn, dp);\n      TestCommon.CompareTestLess(dp, dnan);\n      TestCommon.CompareTestLess(dn, dnan);\n      Assert.AreEqual(1, CBORObject.True.CompareTo(null));\n      Assert.AreEqual(1, CBORObject.False.CompareTo(null));\n      Assert.AreEqual(1, CBORObject.Null.CompareTo(null));\n      Assert.AreEqual(1, CBORObject.NewArray().CompareTo(null));\n      Assert.AreEqual(1, CBORObject.NewMap().CompareTo(null));\n      {\n        long numberTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(100).CompareTo(null);\n        Assert.AreEqual(1, numberTemp);\n      }\n      {\n        long numberTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NaN).CompareTo(null);\n        Assert.AreEqual(1, numberTemp);\n      }\n      TestCommon.CompareTestLess(\n        ToObjectTest.TestToFromObjectRoundTrip(0).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(1).AsNumber());\n      TestCommon.CompareTestLess(\n        ToObjectTest.TestToFromObjectRoundTrip(0.0f).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(1.0f).AsNumber());\n      TestCommon.CompareTestLess(\n        ToObjectTest.TestToFromObjectRoundTrip(0.0).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(1.0).AsNumber());\n      TestCommon.CompareTestEqual(\n        CBORObject.FromObject(10).AsNumber(),\n        CBORObject.FromObject(ERational.Create(10, 1)).AsNumber());\n    }\n\n    [Test]\n    public void TestContainsKey() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestCount() {\n      Assert.AreEqual(0, CBORObject.True.Count);\n      Assert.AreEqual(0, CBORObject.False.Count);\n      Assert.AreEqual(0, CBORObject.NewArray().Count);\n      Assert.AreEqual(0, CBORObject.NewMap().Count);\n    }\n\n    [Test]\n    public void TestDecodeFromBytes() {\n      try {\n        CBORObject.DecodeFromBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0 }, null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0x1c });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0x1e });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0xfe });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeFromBytes(new byte[] { 0xff });\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestDecodeFromBytesNoDuplicateKeys() {\n      byte[] bytes;\n      bytes = new byte[] { 0xa2, 0x01, 0x00, 0x02, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x01, 0x00, 0x01, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x01, 0x00, 0x01, 0x03 };\n      try {\n        string opts = \"allowduplicatekeys=1;useindeflengthstrings=1\";\n        CBORObject.DecodeFromBytes(bytes,\n          new CBOREncodeOptions(opts));\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x60, 0x00, 0x60, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] {\n        0xa3, 0x60, 0x00, 0x62, 0x41, 0x41, 0x00, 0x60,\n        0x03,\n      };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0xa2, 0x61, 0x41, 0x00, 0x61, 0x41, 0x03 };\n      try {\n        CBORObject.DecodeFromBytes(bytes, new\n          CBOREncodeOptions(\"allowduplicatekeys=0\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestDecodeSequenceFromBytes() {\n      CBORObject[] objs;\n      byte[] bytes;\n      bytes = new byte[] { 0 };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(1, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      bytes = new byte[] { 0, 1, 2 };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(2), objs[2]);\n      bytes = new byte[] { 0, 1, 0x61 };\n      try {\n        CBORObject.DecodeSequenceFromBytes(bytes);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0x61 };\n      try {\n        CBORObject.DecodeSequenceFromBytes(bytes);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      bytes = new byte[] { 0, 1, 0x61, 0x41 };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"A\"), objs[2]);\n      bytes = new byte[] { };\n      objs = CBORObject.DecodeSequenceFromBytes(bytes);\n      Assert.AreEqual(0, objs.Length);\n      try {\n        CBORObject.DecodeSequenceFromBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.DecodeSequenceFromBytes(bytes, null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestReadSequence() {\n      CBORObject[] objs;\n      byte[] bytes;\n      bytes = new byte[] { 0 };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(1, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      bytes = new byte[] { 0, 1, 2 };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(2), objs[2]);\n      bytes = new byte[] { 0, 1, 0x61 };\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadSequence(ms);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      bytes = new byte[] { 0x61 };\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadSequence(ms);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      bytes = new byte[] { 0, 1, 0x61, 0x41 };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(3, objs.Length);\n      Assert.AreEqual(CBORObject.FromObject(0), objs[0]);\n      Assert.AreEqual(CBORObject.FromObject(1), objs[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"A\"), objs[2]);\n      bytes = new byte[] { };\n      using (var ms = new MemoryStream(bytes)) {\n        objs = null;\n        try {\n          objs = CBORObject.ReadSequence(ms);\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Assert.AreEqual(0, objs.Length);\n      try {\n        CBORObject.ReadSequence(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadSequence(ms, null);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    [Test]\n    public void TestEncodeFloat64() {\n      try {\n        var rg = new RandomGenerator();\n        var options = new CBOREncodeOptions(\"float64=true\");\n        for (var i = 0; i < 10000; ++i) {\n          double dbl = 0.0;\n          dbl = (i == 0) ? Double.PositiveInfinity : ((i == 1) ?\n              Double.NegativeInfinity : RandomObjects.RandomDouble(rg));\n          CBORObject cbor = CBORObject.FromObject(dbl);\n          byte[] bytes = cbor.EncodeToBytes(options);\n          Assert.AreEqual(9, bytes.Length);\n          TestCommon.AssertEqualsHashCode(\n            cbor,\n            CBORObject.DecodeFromBytes(bytes));\n          using (var ms = new MemoryStream()) {\n            cbor.WriteTo(ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(9, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(dbl, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(9, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(9, bytes.Length);\n          }\n          CBORObject cbor2 = CBORObject.NewArray().Add(cbor);\n          bytes = cbor2.EncodeToBytes(options);\n          TestCommon.AssertEqualsHashCode(\n            cbor2,\n            CBORObject.DecodeFromBytes(bytes));\n          Assert.AreEqual(10, bytes.Length);\n          using (var ms = new MemoryStream()) {\n            cbor2.WriteTo(ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor2, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n          cbor2 = cbor.WithTag(1);\n          bytes = cbor2.EncodeToBytes(options);\n          Assert.AreEqual(10, bytes.Length);\n          TestCommon.AssertEqualsHashCode(\n            cbor2,\n            CBORObject.DecodeFromBytes(bytes));\n          using (var ms = new MemoryStream()) {\n            cbor2.WriteTo(ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor2, ms, options);\n            bytes = ms.ToArray();\n            Assert.AreEqual(10, bytes.Length);\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static readonly int[] EtbRanges = {\n      -24, 23, 1,\n      -256, -25, 2,\n      24, 255, 2,\n      256, 266, 3,\n      -266, -257, 3,\n      65525, 65535, 3,\n      -65536, -65525, 3,\n      65536, 65546, 5,\n      -65547, -65537, 5,\n    };\n\n    [Test]\n    public void TestEncodeToBytes() {\n      // Test minimum data length\n      int[] ranges = EtbRanges;\n      string[] bigRanges = {\n        \"4294967285\", \"4294967295\",\n        \"4294967296\", \"4294967306\",\n        \"18446744073709551604\", \"18446744073709551615\",\n        \"-4294967296\", \"-4294967286\",\n        \"-4294967306\", \"-4294967297\",\n        \"-18446744073709551616\", \"-18446744073709551604\",\n      };\n      int[] bigSizes = { 5, 9, 9, 5, 9, 9 };\n      for (int i = 0; i < ranges.Length; i += 3) {\n        for (int j = ranges[i]; j <= ranges[i + 1]; ++j) {\n          CBORObject bcbor = ToObjectTest.TestToFromObjectRoundTrip(j);\n          byte[] bytes = CBORTestCommon.CheckEncodeToBytes(bcbor);\n          if (bytes.Length != ranges[i + 2]) {\n            string i2s = TestCommon.IntToString(j);\n            Assert.AreEqual(\n              ranges[i + 2],\n              bytes.Length,\n              i2s);\n          }\n          bytes =\n            ToObjectTest.TestToFromObjectRoundTrip(j).EncodeToBytes(new\n              CBOREncodeOptions(false, false, true));\n          if (bytes.Length != ranges[i + 2]) {\n            string i2s = TestCommon.IntToString(j);\n            Assert.AreEqual(\n              ranges[i + 2],\n              bytes.Length,\n              i2s);\n          }\n        }\n      }\n      string veryLongString = TestCommon.Repeat(\"x\", 10000);\n      byte[] stringBytes =\n        ToObjectTest.TestToFromObjectRoundTrip(veryLongString)\n        .EncodeToBytes(new CBOREncodeOptions(false, false, true));\n      Assert.AreEqual(10003, stringBytes.Length);\n      stringBytes = ToObjectTest.TestToFromObjectRoundTrip(veryLongString)\n        .EncodeToBytes(new CBOREncodeOptions(false, true));\n      Assert.AreEqual(10003, stringBytes.Length);\n      for (int i = 0; i < bigRanges.Length; i += 2) {\n        EInteger bj = EInteger.FromString(bigRanges[i]);\n        EInteger valueBjEnd = EInteger.FromString(bigRanges[i + 1]);\n        while (bj < valueBjEnd) {\n          CBORObject cbor = ToObjectTest.TestToFromObjectRoundTrip(bj);\n          byte[] bytes = CBORTestCommon.CheckEncodeToBytes(cbor);\n          if (bytes.Length != bigSizes[i / 2]) {\n            Assert.Fail(bj.ToString() + \"\\n\" +\n              TestCommon.ToByteArrayString(bytes));\n          }\n          bytes = ToObjectTest.TestToFromObjectRoundTrip(bj)\n            .EncodeToBytes(new CBOREncodeOptions(false, false, true));\n          if (bytes.Length != bigSizes[i / 2]) {\n            Assert.Fail(bj.ToString() + \"\\n\" +\n              TestCommon.ToByteArrayString(bytes));\n          }\n          bj += EInteger.One;\n        }\n      }\n      try {\n        CBORObject.True.EncodeToBytes(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestItem() {\n      CBORObject cbor;\n      CBORObject dummy = CBORObject.True;\n      cbor = CBORObject.NewArray().Add(1).Add(2);\n      Assert.AreEqual(1, cbor[0].AsInt32());\n      Assert.AreEqual(2, cbor[1].AsInt32());\n      Assert.AreEqual(1, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(2, cbor[CBORObject.FromObject(1)].AsInt32());\n      try {\n        dummy = cbor[-1];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        dummy = cbor[2];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        dummy = cbor[CBORObject.FromObject(-1)];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        dummy = cbor[CBORObject.FromObject(2)];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor[0] = CBORObject.FromObject(3);\n      cbor[1] = CBORObject.FromObject(4);\n      Assert.AreEqual(3, cbor[0].AsInt32());\n      Assert.AreEqual(4, cbor[1].AsInt32());\n      Assert.AreEqual(3, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(4, cbor[CBORObject.FromObject(1)].AsInt32());\n      try {\n        cbor[-1] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[2] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(-1)] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(2)] = dummy;\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      var bytes = new byte[] { 1, 2, 3, 4 };\n      var othercbor = new CBORObject[] {\n        CBORObject.FromObject(9), CBORObject.True,\n        CBORObject.FromObject(bytes),\n        CBORObject.False, CBORObject.Null, CBORObject.FromObject(\"test\"),\n        CBORObject.FromObject(99999), CBORObject.FromObject(-1),\n      };\n      foreach (CBORObject c2 in othercbor) {\n        try {\n          dummy = c2[0];\n          Assert.Fail(\"Should have failed\");\n        } catch (InvalidOperationException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          dummy = c2[CBORObject.FromObject(0)];\n          Assert.Fail(\"Should have failed\");\n        } catch (InvalidOperationException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      cbor = CBORObject.NewMap().Add(0, 1).Add(-1, 2);\n      Assert.AreEqual(1, cbor[0].AsInt32());\n      Assert.AreEqual(2, cbor[-1].AsInt32());\n      Assert.AreEqual(1, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(2, cbor[CBORObject.FromObject(-1)].AsInt32());\n      if (cbor[-2] != null) {\n        Assert.Fail();\n      }\n      if (cbor[2] != null) {\n        Assert.Fail();\n      }\n      if (cbor[\"test\"] != null) {\n        Assert.Fail();\n      }\n      if (cbor[CBORObject.FromObject(-2)] != null) {\n        Assert.Fail();\n      }\n      if (cbor[CBORObject.FromObject(2)] != null) {\n        Assert.Fail();\n      }\n      if (cbor[CBORObject.FromObject(\"test\")] != null) {\n        Assert.Fail();\n      }\n      cbor[0] = CBORObject.FromObject(3);\n      cbor[-1] = CBORObject.FromObject(4);\n      Assert.AreEqual(3, cbor[0].AsInt32());\n      Assert.AreEqual(4, cbor[-1].AsInt32());\n      Assert.AreEqual(3, cbor[CBORObject.FromObject(0)].AsInt32());\n      Assert.AreEqual(4, cbor[CBORObject.FromObject(-1)].AsInt32());\n      try {\n        cbor[-2] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[-2]);\n      try {\n        cbor[2] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(-2)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[CBORObject.FromObject(2)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[2]);\n      try {\n        cbor[CBORObject.FromObject(-5)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[-5]);\n      try {\n        cbor[CBORObject.FromObject(5)] = dummy;\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(dummy, cbor[-5]);\n    }\n\n    [Test]\n    public void TestEquals() {\n      var cborbytes = new byte[] {\n        (byte)0xd8, 0x1e, (byte)0x82, 0x00, 0x19,\n        0x0f, 0x50,\n      };\n      CBORObject cbor = CBORObject.DecodeFromBytes(cborbytes);\n      CBORObject cbor2 = CBORObject.DecodeFromBytes(cborbytes);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      ERational erat = ERational.Create(0, 3920);\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(erat);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(cbor2);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      TestWriteObj(erat, erat);\n      erat = ERational.Create(\n          EInteger.Zero,\n          EInteger.FromString(\"84170882933504200501581262010093\"));\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(erat);\n      ERational erat2 = ERational.Create(\n          EInteger.Zero,\n          EInteger.FromString(\"84170882933504200501581262010093\"));\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(erat2);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      cbor2 = ToObjectTest.TestToFromObjectRoundTrip(cbor2);\n      TestCommon.CompareTestEqualAndConsistent(cbor, cbor2);\n      TestWriteObj(cbor, cbor2);\n      TestWriteObj(erat, erat2);\n    }\n\n    private static void CompareTestNumber(CBORObject o1, CBORObject o2) {\n      TestCommon.CompareTestEqual(o1.AsNumber(), o2.AsNumber());\n    }\n\n    [Test]\n    public void TestEquivalentNegativeInfinity() {\n      CompareTestNumber(\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecNegInf),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf));\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatNegInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n    }\n\n    [Test]\n    public void TestEquivalentPositiveInfinity() {\n      CompareTestNumber(\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecPosInf),\n        ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatPosInf));\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.RatPosInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.DecPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.RatPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n      {\n        CBORObject objectTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.FloatPosInf);\n        CBORObject objectTemp2 =\n          ToObjectTest.TestToFromObjectRoundTrip(CBORTestCommon.RatPosInf);\n        CompareTestNumber(objectTemp, objectTemp2);\n      }\n    }\n\n    [Test]\n    public void TestFalse() {\n      CBORTestCommon.AssertJSONSer(CBORObject.False, \"false\");\n      Assert.AreEqual(\n        CBORObject.False,\n        ToObjectTest.TestToFromObjectRoundTrip(false));\n    }\n\n    [Test]\n    [Timeout(100000)]\n    public void TestFromJSONString() {\n      var charbuf = new char[4];\n      CBORObject cbor;\n      // Test single-character strings\n      for (var i = 0; i < 0x110000; ++i) {\n        if (i >= 0xd800 && i < 0xe000) {\n          continue;\n        }\n        string str = CharString(i, true, charbuf);\n        if (i < 0x20 || i == 0x22 || i == 0x5c) {\n          TestFailingJSON(str);\n        } else {\n          cbor = TestSucceedingJSON(str);\n          string exp = CharString(i, false, charbuf);\n          if (!exp.Equals(cbor.AsString(), StringComparison.Ordinal)) {\n            Assert.AreEqual(exp, cbor.AsString());\n          }\n        }\n      }\n      foreach (string str in ValueJsonFails) {\n        TestFailingJSON(str);\n      }\n      foreach (string str in ValueJsonSucceeds) {\n        TestSucceedingJSON(str);\n      }\n      try {\n        CBORObject.FromJSONString(\"\\ufeff\\u0020 {}\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromJSONString(\"[]\", (CBOREncodeOptions)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromJSONString(\"[]\", (JSONOptions)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      TestFailingJSON(\"{\\\"a\\\":1,\\\"a\\\":2}\", ValueNoDuplicateKeys);\n      string aba = \"{\\\"a\\\":1,\\\"b\\\":3,\\\"a\\\":2}\";\n      TestFailingJSON(aba, ValueNoDuplicateKeys);\n      cbor = TestSucceedingJSON(aba, new JSONOptions(\"allowduplicatekeys=1\"));\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(2), cbor[\"a\"]);\n      aba = \"{\\\"a\\\":1,\\\"a\\\":4}\";\n      cbor = TestSucceedingJSON(aba, new JSONOptions(\"allowduplicatekeys=1\"));\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(4), cbor[\"a\"]);\n      aba = \"{\\\"a\\\" :1}\";\n      cbor = TestSucceedingJSON(aba);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(1), cbor[\"a\"]);\n      aba = \"{\\\"a\\\" : 1}\";\n      cbor = TestSucceedingJSON(aba);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(1), cbor[\"a\"]);\n      cbor = TestSucceedingJSON(\"\\\"\\\\t\\\"\");\n      {\n        string stringTemp = cbor.AsString();\n        Assert.AreEqual(\n          \"\\t\",\n          stringTemp);\n      }\n      Assert.AreEqual(CBORObject.True, TestSucceedingJSON(\"true\"));\n      Assert.AreEqual(CBORObject.False, TestSucceedingJSON(\"false\"));\n      Assert.AreEqual(CBORObject.Null, TestSucceedingJSON(\"null\"));\n      Assert.AreEqual(5, TestSucceedingJSON(\" 5 \").AsInt32());\n      {\n        string stringTemp = TestSucceedingJSON(\"\\\"\\\\/\\\\b\\\"\").AsString();\n        Assert.AreEqual(\n          \"/\\b\",\n          stringTemp);\n      }\n      {\n        string stringTemp = TestSucceedingJSON(\"\\\"\\\\/\\\\f\\\"\").AsString();\n        Assert.AreEqual(\n          \"/\\f\",\n          stringTemp);\n      }\n      string jsonTemp = TestCommon.Repeat(\n          \"[\",\n          2000) + TestCommon.Repeat(\n          \"]\",\n          2000);\n      TestFailingJSON(jsonTemp);\n    }\n\n    [Test]\n    public void TestTagArray() {\n      CBORObject obj = CBORObject.FromObjectAndTag(\"test\", 999);\n      EInteger[] etags = obj.GetAllTags();\n      Assert.AreEqual(1, etags.Length);\n      Assert.AreEqual(999, etags[0].ToInt32Checked());\n      obj = ToObjectTest.TestToFromObjectRoundTrip(\"test\");\n      etags = obj.GetAllTags();\n      Assert.AreEqual(0, etags.Length);\n    }\n\n    [Test]\n    public void TestEI() {\n      CBORObject cbor =\n        ToObjectTest.TestToFromObjectRoundTrip(EInteger.FromString(\"100\"));\n      Assert.IsTrue(cbor.IsNumber);\n      {\n        string stringTemp = cbor.ToJSONString();\n        Assert.AreEqual(\n          \"100\",\n          stringTemp);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n            \"200\"));\n      Assert.IsTrue(cbor.IsNumber);\n      {\n        string stringTemp = cbor.ToJSONString();\n        Assert.AreEqual(\n          \"200\",\n          stringTemp);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EFloat.FromString(\"300\"));\n      Assert.IsTrue(cbor.IsNumber);\n      {\n        string stringTemp = cbor.ToJSONString();\n        Assert.AreEqual(\n          \"300\",\n          stringTemp);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(ERational.Create(1, 2));\n      Assert.IsTrue(cbor.IsNumber);\n    }\n\n    [Test]\n    public void TestFromObject() {\n      var cborarray = new CBORObject[2];\n      cborarray[0] = CBORObject.False;\n      cborarray[1] = CBORObject.True;\n      CBORObject cbor = CBORObject.FromObject(cborarray);\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(CBORObject.False, cbor[0]);\n      Assert.AreEqual(CBORObject.True, cbor[1]);\n      CBORTestCommon.AssertRoundTrip(cbor);\n      Assert.AreEqual(\n        CBORObject.Null,\n        CBORObject.FromObject((int[])null));\n      long[] longarray = { 2, 3 };\n      cbor = CBORObject.FromObject(longarray);\n      Assert.AreEqual(2, cbor.Count);\n      Assert.IsTrue(CBORObject.FromObject(2).CompareTo(cbor[0])\n        == 0);\n      Assert.IsTrue(CBORObject.FromObject(3).CompareTo(cbor[1])\n        == 0);\n      CBORTestCommon.AssertRoundTrip(cbor);\n      Assert.AreEqual(\n        CBORObject.Null,\n        CBORObject.FromObject((ERational)null));\n      Assert.AreEqual(\n        CBORObject.Null,\n        CBORObject.FromObject((EDecimal)null));\n      try {\n        CBORObject.FromObject(ERational.Create(10, 2));\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n\n      try {\n        CBORObject.FromObject(CBORObject.FromObject(Double.NaN)\n          .Sign);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.True;\n      try {\n        CBORObject.FromObject(cbor[0]);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor[0] = CBORObject.False;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor = CBORObject.False;\n        CBORObject.FromObject(cbor.Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip('\\udddd');\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.NewArray().Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.NewArray().Sign);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.NewMap().Sign);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private static void CheckKeyValue(CBORObject o, string key, object value) {\n      if (!o.ContainsKey(key)) {\n        Assert.Fail(\"Expected \" + key + \" to exist: \" + o.ToString());\n      }\n      TestCommon.AssertEqualsHashCode(o[key], value);\n    }\n\n    public enum EnumClass {\n      /// <summary>Internal API.</summary>\n      Value1,\n\n      /// <summary>Internal API.</summary>\n      Value2,\n\n      /// <summary>Internal API.</summary>\n      Value3,\n    }\n\n    [Test]\n    public void TestFromObject_Enum() {\n      CBORObject cbor;\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EnumClass.Value1);\n      Assert.AreEqual(0, cbor.AsInt32());\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EnumClass.Value2);\n      Assert.AreEqual(1, cbor.AsInt32());\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EnumClass.Value3);\n      Assert.AreEqual(2, cbor.AsInt32());\n    }\n\n    [Test]\n    public void TestToObject_Enum() {\n      CBORObject cbor;\n      EnumClass ec;\n      cbor = CBORObject.FromObject(\"Value1\");\n      ec = (EnumClass)cbor.ToObject(typeof(EnumClass));\n      Assert.AreEqual(EnumClass.Value1, ec);\n      cbor = CBORObject.FromObject(\"Value2\");\n      ec = (EnumClass)cbor.ToObject(typeof(EnumClass));\n      Assert.AreEqual(EnumClass.Value2, ec);\n      cbor = CBORObject.FromObject(\"Value3\");\n      ec = (EnumClass)cbor.ToObject(typeof(EnumClass));\n      Assert.AreEqual(EnumClass.Value3, ec);\n      cbor = CBORObject.FromObject(\"ValueXYZ\");\n      try {\n        cbor.ToObject(typeof(EnumClass));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.FromObject(true);\n      try {\n        cbor.ToObject(typeof(EnumClass));\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToObject_UnknownEnum() {\n      CBORObject cbor;\n      cbor = CBORObject.FromObject(999);\n      try {\n        cbor.ToObject(typeof(EnumClass));\n        Assert.Fail(\"Should have failed -- \" +\n          cbor.ToObject(typeof(EnumClass)));\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private sealed class TestConverter : ICBORToFromConverter<string> {\n      public CBORObject ToCBORObject(string strValue) {\n        return CBORObject.FromObject(\n            DataUtilities.ToLowerCaseAscii(strValue));\n      }\n\n      public string FromCBORObject(CBORObject cbor) {\n        if (cbor == null) {\n          throw new ArgumentNullException(nameof(cbor));\n        }\n        if (cbor.Type == CBORType.TextString) {\n          return DataUtilities.ToLowerCaseAscii(cbor.AsString());\n        }\n        throw new CBORException();\n      }\n    }\n\n    [Test]\n    public void TestFromObject_TypeMapper() {\n      var mapper = new CBORTypeMapper()\n      .AddConverter(typeof(string), new TestConverter());\n      CBORObject cbor = CBORObject.FromObject(\"UPPER\", mapper);\n      Assert.AreEqual(CBORType.TextString, cbor.Type);\n      {\n        string stringTemp = cbor.AsString();\n        Assert.AreEqual(\n          \"upper\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"LoWeR\", mapper);\n      Assert.AreEqual(CBORType.TextString, cbor.Type);\n      {\n        string stringTemp = cbor.AsString();\n        Assert.AreEqual(\n          \"lower\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestFromObject_Dictionary() {\n      IDictionary<string, string> dict = new Dictionary<string, string>();\n      dict[\"TestKey\"] = \"TestValue\";\n      dict[\"TestKey2\"] = \"TestValue2\";\n      CBORObject c = CBORObject.FromObject(dict);\n      CheckKeyValue(c, \"TestKey\", \"TestValue\");\n      CheckKeyValue(c, \"TestKey2\", \"TestValue2\");\n      dict = (IDictionary<string, string>)c.ToObject(\n          typeof(IDictionary<string, string>));\n      Assert.AreEqual(2, dict.Keys.Count);\n      Assert.IsTrue(dict.ContainsKey(\"TestKey\"));\n      Assert.IsTrue(dict.ContainsKey(\"TestKey2\"));\n      Assert.AreEqual(\"TestValue\", dict[\"TestKey\"]);\n      Assert.AreEqual(\"TestValue2\", dict[\"TestKey2\"]);\n    }\n\n#pragma warning disable CA1034\n    // nesting a public type is needed\n    // here for testing purposes\n    public sealed class NestedPODClass {\n      public NestedPODClass() {\n        this.PropValue = new PODClass();\n      }\n\n      public PODClass PropValue {\n        get;\n        private set;\n      }\n    }\n#pragma warning restore CA1034\n\n    [Test]\n    public void TestBase64Extras() {\n      // Base64 tests\n      CBORObject o;\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xf0, 0xe8 },\n          23);\n      {\n        string stringTemp = o.ToJSONString();\n        Assert.AreEqual(\n          \"\\\"9AD6F0E8\\\"\",\n          stringTemp);\n      }\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xff, 0xe8,\n      });\n      // Encode with Base64URL by default\n      {\n        string stringTemp = o.ToJSONString();\n        Assert.AreEqual(\n          \"\\\"mtb_6A\\\"\",\n          stringTemp);\n      }\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xff, 0xe8 },\n          22);\n      // Encode with Base64\n      {\n        string stringTemp = o.ToJSONString();\n        Assert.AreEqual(\n          \"\\\"mtb/6A==\\\"\",\n          stringTemp);\n      }\n      var options = new JSONOptions(\"base64padding=1\");\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xff, 0xe8,\n      });\n      // Encode with Base64URL by default\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtb_6A\\\"\",\n          stringTemp);\n      }\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xff, 0xe8 },\n          22);\n      // Encode with Base64\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtb/6A==\\\"\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestFromObject_PODOptions() {\n      var ao = new PODClass();\n      var valueCcTF = new PODOptions(true, false);\n      var valueCcFF = new PODOptions(false, false);\n      var valueCcFT = new PODOptions(false, true);\n      var valueCcTT = new PODOptions(true, true);\n      CBORObject co;\n      CBORObjectTest.CheckPropertyNames(ao);\n      var arrao = new PODClass[] { ao, ao };\n      co = CBORObject.FromObject(arrao, valueCcTF);\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcTF),\n        2,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcFT),\n        2,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcTT),\n        2,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      var ao2 = new NestedPODClass();\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcTF),\n        valueCcTF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcFT),\n        valueCcFT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcTT),\n        valueCcTT,\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      var aodict = new Dictionary<string, object>();\n      aodict[\"PropValue\"] = new PODClass();\n\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcTF),\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcFT),\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcTT),\n        \"propA\",\n        \"propB\",\n        \"propC\");\n      CBORObjectTest.CheckArrayPropertyNames(\n        CBORObject.FromObject(arrao, valueCcFF),\n        2,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODPropertyNames(\n        CBORObject.FromObject(ao2, valueCcFF),\n        valueCcFF,\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n      CBORObjectTest.CheckPODInDictPropertyNames(\n        CBORObject.FromObject(aodict, valueCcFF),\n        \"PropA\",\n        \"PropB\",\n        \"IsPropC\");\n    }\n\n    [Test]\n    public void TestFromObjectAndTag() {\n      EInteger bigvalue = EInteger.FromString(\"99999999999999999999999999999\");\n      try {\n        CBORObject.FromObjectAndTag(2, bigvalue);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(2, -1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(CBORObject.Null, -1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(CBORObject.Null, 999999);\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      EInteger eintNull = null;\n      try {\n        CBORObject.FromObjectAndTag(2, eintNull);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObjectAndTag(2, EInteger.FromString(\"-1\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestFromSimpleValue() {\n      try {\n        CBORObject.FromSimpleValue(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromSimpleValue(256);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      for (int i = 0; i < 256; ++i) {\n        if (i >= 24 && i < 32) {\n          try {\n            CBORObject.FromSimpleValue(i);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          CBORObject cbor = CBORObject.FromSimpleValue(i);\n          Assert.AreEqual(i, cbor.SimpleValue);\n        }\n      }\n    }\n\n    [Test]\n    public void TestWithTag() {\n      EInteger bigvalue = EInteger.FromString(\"99999999999999999999999999999\");\n      try {\n        CBORObject.FromObject(2).WithTag(bigvalue);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(2).WithTag(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.Null).WithTag(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(CBORObject.Null).WithTag(999999);\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      EInteger eintNull = null;\n      try {\n        CBORObject.FromObject(2).WithTag(eintNull);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromObject(2).WithTag(EInteger.FromString(\"-1\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestGetByteString() {\n      try {\n        CBORObject.True.GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(0).GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(\"test\").GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewArray().GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().GetByteString();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestGetHashCode() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestGetTags() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestHasTag() {\n      try {\n        CBORObject.True.HasTag(-1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        const EInteger ValueBigintNull = null;\n        CBORObject.True.HasTag(ValueBigintNull);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.True.HasTag(EInteger.FromString(\"-1\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.IsFalse(CBORObject.True.HasTag(0));\n      Assert.IsFalse(CBORObject.True.HasTag(EInteger.Zero));\n    }\n\n    [Test]\n    public void TestMostInnerTag() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestInsert() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsFalse() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsFinite() {\n      CBORObject cbor;\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .IsFinite);\n      Assert.IsFalse(CBORObject.NewArray().IsFinite);\n      Assert.IsFalse(CBORObject.NewMap().IsFinite);\n      cbor = CBORObject.True;\n      Assert.IsFalse(cbor.IsFinite);\n      cbor = CBORObject.False;\n      Assert.IsFalse(cbor.IsFinite);\n      cbor = CBORObject.Null;\n      Assert.IsFalse(cbor.IsFinite);\n      cbor = CBORObject.Undefined;\n      Assert.IsFalse(cbor.IsFinite);\n      Assert.IsFalse(CBORObject.NewMap().IsFinite);\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).IsFinite);\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(2.5).IsFinite);\n      Assert.IsFalse(\n        ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity)\n        .IsFinite);\n\n      Assert.IsFalse(\n        ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity)\n        .IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(Double.NaN)\n        .IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecPosInf).IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecNegInf).IsFinite);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(EDecimal.NaN)\n        .IsFinite);\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        EDecimal ed = EDecimal.FromString(numberinfo[\"number\"].AsString());\n        CBORObject cbornumber = ToObjectTest.TestToFromObjectRoundTrip(ed);\n        if (numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.IsFinite, numberinfo[\"number\"].AsString());\n        }\n        // NOTE: A nonintegral number is not necessarily non-finite\n      }\n    }\n\n    [Test]\n    public void TestIsInfinity() {\n      Assert.IsTrue(CBORObject.PositiveInfinity.AsNumber().IsInfinity());\n      Assert.IsTrue(CBORObject.NegativeInfinity.AsNumber().IsInfinity());\n      Assert.IsTrue(CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, 0x7f,\n        (byte)0x80, 0x00, 0x00,\n      }).AsNumber().IsInfinity());\n    }\n\n    [Test]\n    public void TestIsIntegral() {\n      CBORObject cbor;\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(0).IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(String.Empty);\n      Assert.IsFalse(cbor.IsIntegral);\n      Assert.IsFalse(CBORObject.NewArray().IsIntegral);\n      Assert.IsFalse(CBORObject.NewMap().IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(\n          EInteger.FromRadixString(\n            \"8000000000000000\",\n            16));\n      Assert.IsTrue(cbor.IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(\n          EInteger.FromRadixString(\n            \"80000000000000000000\",\n            16));\n      Assert.IsTrue(cbor.IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(\n          EInteger.FromRadixString(\n            \"8000000000000000000000000\",\n            16));\n      Assert.IsTrue(cbor.IsIntegral);\n      Assert.IsTrue(ToObjectTest.TestToFromObjectRoundTrip(\n          EDecimal.FromString(\"4444e+800\")).IsIntegral);\n\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          EDecimal.FromString(\"4444e-800\")).IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(2.5).IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          999.99).IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity);\n\n      Assert.IsFalse(cbor.IsIntegral);\n\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity);\n\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(Double.NaN);\n\n      Assert.IsFalse(cbor.IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecPosInf).IsIntegral);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(\n          CBORTestCommon.DecNegInf).IsIntegral);\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(EDecimal.NaN);\n\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.True;\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.False;\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.Null;\n      Assert.IsFalse(cbor.IsIntegral);\n      cbor = CBORObject.Undefined;\n      Assert.IsFalse(cbor.IsIntegral);\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberinfo[\"number\"].AsString()));\n        if (numberinfo[\"isintegral\"].AsBoolean()) {\n          Assert.IsTrue(cbornumber.IsIntegral);\n          Assert.IsFalse(cbornumber.AsNumber().IsPositiveInfinity());\n          Assert.IsFalse(cbornumber.AsNumber().IsNegativeInfinity());\n          Assert.IsFalse(cbornumber.AsNumber().IsNaN());\n          Assert.IsFalse(cbornumber.IsNull);\n        } else {\n          Assert.IsFalse(cbornumber.IsIntegral);\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsNumber() {\n      try {\n        CBORObject.True.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(String.Empty).AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewArray().AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.NewMap().AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Undefined.AsNumber();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestAsNumberIsNegativeInfinity() {\n      Assert.IsFalse(CBORObject.FromObject(\n          0).AsNumber().IsNegativeInfinity());\n\n      Assert.IsFalse(\n        CBORObject.PositiveInfinity.AsNumber().IsNegativeInfinity());\n\n      Assert.IsTrue(\n        CBORObject.NegativeInfinity.AsNumber().IsNegativeInfinity());\n      Assert.IsFalse(CBORObject.NaN.AsNumber().IsNegativeInfinity());\n    }\n\n    [Test]\n    public void TestIsNull() {\n      Assert.IsFalse(CBORObject.True.IsNull);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .IsNull);\n      Assert.IsFalse(CBORObject.NewArray().IsNull);\n      Assert.IsFalse(CBORObject.NewMap().IsNull);\n      Assert.IsFalse(CBORObject.False.IsNull);\n      Assert.IsTrue(CBORObject.Null.IsNull);\n      Assert.IsFalse(CBORObject.Undefined.IsNull);\n      Assert.IsFalse(CBORObject.PositiveInfinity.IsNull);\n      Assert.IsFalse(CBORObject.NegativeInfinity.IsNull);\n      Assert.IsFalse(CBORObject.NaN.IsNull);\n    }\n\n    [Test]\n    public void TestAsNumberIsPositiveInfinity() {\n      Assert.IsFalse(CBORObject.FromObject(\n          0).AsNumber().IsPositiveInfinity());\n\n      Assert.IsTrue(\n        CBORObject.PositiveInfinity.AsNumber().IsPositiveInfinity());\n\n      Assert.IsFalse(\n        CBORObject.NegativeInfinity.AsNumber().IsPositiveInfinity());\n      Assert.IsFalse(CBORObject.NaN.AsNumber().IsPositiveInfinity());\n    }\n\n    [Test]\n    public void TestIsTagged() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsTrue() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestIsUndefined() {\n      Assert.IsFalse(CBORObject.True.IsUndefined);\n      Assert.IsFalse(ToObjectTest.TestToFromObjectRoundTrip(String.Empty)\n        .IsUndefined);\n      Assert.IsFalse(CBORObject.NewArray().IsUndefined);\n      Assert.IsFalse(CBORObject.NewMap().IsUndefined);\n      Assert.IsFalse(CBORObject.False.IsUndefined);\n      Assert.IsFalse(CBORObject.Null.IsUndefined);\n      Assert.IsTrue(CBORObject.Undefined.IsUndefined);\n      Assert.IsFalse(CBORObject.PositiveInfinity.IsUndefined);\n      Assert.IsFalse(CBORObject.NegativeInfinity.IsUndefined);\n      Assert.IsFalse(CBORObject.NaN.IsUndefined);\n    }\n\n    [Test]\n    public void TestIsZero() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestItem2() {\n      CBORObject cbor = CBORObject.True;\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.False;\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(0);\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = ToObjectTest.TestToFromObjectRoundTrip(2);\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        CBORObject cbor2 = cbor[0];\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestGetOrDefault() {\n      CBORObject cbor = CBORObject.NewArray().Add(2).Add(3).Add(7);\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(-1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = CBORObject.FromObject(2);\n        object objectTemp2 = cbor.GetOrDefault(\n            0,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(\n        CBORObject.FromObject(2),\n        cbor.GetOrDefault(CBORObject.FromObject(0), CBORObject.Null));\n      {\n        object objectTemp = CBORObject.FromObject(3);\n        object objectTemp2 = cbor.GetOrDefault(\n            1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = CBORObject.FromObject(7);\n        object objectTemp2 = cbor.GetOrDefault(\n            2,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(3, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(\"key\", \"value\");\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(-1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(0, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.FromObject(2);\n        object objectTemp2 = cbor.GetOrDefault(\n            1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(2, CBORObject.Null));\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(3, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.FromObject(\"value\");\n        object objectTemp2 = cbor.GetOrDefault(\n            \"key\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(\n        CBORObject.FromObject(\"value\"),\n        cbor.GetOrDefault(CBORObject.FromObject(\"key\"), CBORObject.Null));\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key2\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      cbor = CBORObject.False;\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(-1,\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      Assert.AreEqual(CBORObject.Null, cbor.GetOrDefault(0, CBORObject.Null));\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = CBORObject.Null;\n        object objectTemp2 = cbor.GetOrDefault(\"key2\",\n            CBORObject.Null);\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n    }\n\n    private static void Sink(object obj) {\n      Console.WriteLine(\"Sink for \" + obj);\n      Assert.Fail();\n    }\n\n    [Test]\n    public void TestKeys() {\n      CBORObject co;\n      try {\n        co = CBORObject.True;\n        Sink(co.Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(ToObjectTest.TestToFromObjectRoundTrip(0).Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(ToObjectTest.TestToFromObjectRoundTrip(\"string\").Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(CBORObject.NewArray().Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        Sink(ToObjectTest.TestToFromObjectRoundTrip(\n            new byte[] { 0 }).Keys);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      if (CBORObject.NewMap().Keys == null) {\n        Assert.Fail();\n      }\n    }\n\n    [Test]\n    [Timeout(200000)]\n    public void TestAsNumberMultiply() {\n      var r = new RandomGenerator();\n      for (var i = 0; i < 3000; ++i) {\n        CBORObject o1 = CBORTestCommon.RandomNumber(r);\n        CBORObject o2 = CBORTestCommon.RandomNumber(r);\n        EDecimal cmpDecFrac = AsED(o1).Multiply(AsED(o2));\n        EDecimal cmpCobj = o1.AsNumber().Multiply(o2.AsNumber()).ToEDecimal();\n        if (!cmpDecFrac.Equals(cmpCobj)) {\n          TestCommon.CompareTestEqual(\n            cmpDecFrac,\n            cmpCobj,\n            o1.ToString() + \"\\n\" + o2.ToString());\n        }\n      }\n    }\n\n    [Test]\n    public void TestAsNumberNegate() {\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(-2).AsNumber().Negate());\n      TestCommon.CompareTestEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(-2).AsNumber(),\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber().Negate());\n    }\n\n    [Test]\n    public void TestNegativeTenDigitLong() {\n      CBORObject obj = CBORObject.FromJSONString(\"-1000000000\");\n      {\n        string stringTemp = obj.ToJSONString();\n        Assert.AreEqual(\n          \"-1000000000\",\n          stringTemp);\n      }\n      {\n        string stringTemp = obj.ToString();\n        Assert.AreEqual(\n          \"-1000000000\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestNegativeZero() {\n      CBORObject negzero = ToObjectTest.TestToFromObjectRoundTrip(\n          EDecimal.FromString(\"-0\"));\n      CBORTestCommon.AssertRoundTrip(negzero);\n    }\n\n    [Test]\n    public void TestNewArray() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestNewMap() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorAddition() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorDivision() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorModulus() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorMultiply() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestOperatorSubtraction() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestMostOuterTag() {\n      CBORObject cbor = CBORObject.FromObjectAndTag(CBORObject.True, 999);\n      cbor = CBORObject.FromObjectAndTag(CBORObject.True, 1000);\n      Assert.AreEqual(EInteger.FromString(\"1000\"), cbor.MostOuterTag);\n      cbor = CBORObject.True;\n      Assert.AreEqual(EInteger.FromString(\"-1\"), cbor.MostOuterTag);\n    }\n\n    [Test]\n    public void TestRead() {\n      try {\n        CBORObject.Read(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        using (var ms2 = new MemoryStream(new byte[] { 0 })) {\n          try {\n            CBORObject.Read(ms2, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    public static void ExpectJsonSequenceError(byte[] bytes) {\n      using (var ms = new MemoryStream(bytes)) {\n        try {\n          CBORObject.ReadJSONSequence(ms);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    public static void ExpectJsonSequenceZero(byte[] bytes) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          string ss = TestCommon.ToByteArrayString(bytes);\n          CBORObject[] array = CBORObject.ReadJSONSequence(ms);\n          Assert.AreEqual(0, array.Length, ss);\n        }\n      } catch (IOException ioe) {\n        throw new InvalidOperationException(ioe.Message, ioe);\n      }\n    }\n\n    public static void ExpectJsonSequenceOne(byte[] bytes, CBORObject o1) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          string ss = TestCommon.ToByteArrayString(bytes);\n          CBORObject[] array = CBORObject.ReadJSONSequence(ms);\n          Assert.AreEqual(1, array.Length, ss);\n          Assert.AreEqual(o1, array[0], ss);\n        }\n      } catch (IOException ioe) {\n        throw new InvalidOperationException(ioe.Message, ioe);\n      }\n    }\n\n    public static void ExpectJsonSequenceTwo(\n      byte[] bytes,\n      CBORObject o1,\n      CBORObject o2) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          string ss = TestCommon.ToByteArrayString(bytes);\n          CBORObject[] array = CBORObject.ReadJSONSequence(ms);\n          Assert.AreEqual(2, array.Length, ss);\n          Assert.AreEqual(o1, array[0], ss);\n          Assert.AreEqual(o2, array[1], ss);\n        }\n      } catch (IOException ioe) {\n        throw new InvalidOperationException(ioe.Message, ioe);\n      }\n    }\n\n    [Test]\n    public void TestJsonSequence() {\n      byte[] bytes;\n      bytes = new byte[] { };\n      ExpectJsonSequenceZero(bytes);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x20 };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x09 };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0d };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] {\n        0x1e, (byte)0x66, (byte)0x61, (byte)0x6c, (byte)0x73,\n        (byte)0x65, 0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, CBORObject.False);\n      bytes = new byte[] {\n        0x1e, (byte)0x66, (byte)0x61, (byte)0x6c, (byte)0x73,\n        (byte)0x65,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, (byte)0x66, (byte)0x61, (byte)0x6c, (byte)0x73,\n        (byte)0x65, (byte)0x74, (byte)0x72, (byte)0x75, (byte)0x65, 0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, (byte)0x74, (byte)0x72, (byte)0x75, (byte)0x65,\n        0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, CBORObject.True);\n      bytes = new byte[] {\n        0x1e, (byte)0x74, (byte)0x72, (byte)0x75,\n        (byte)0x65,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, (byte)0x6e, (byte)0x75, (byte)0x6c, (byte)0x6c,\n        0x0a,\n      };\n      ExpectJsonSequenceOne(bytes, CBORObject.Null);\n      bytes = new byte[] {\n        0x1e, (byte)0x6e, (byte)0x75, (byte)0x6c,\n        (byte)0x6c,\n      };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x1e, (byte)'[', (byte)']' };\n      ExpectJsonSequenceTwo(\n        bytes,\n        CBORObject.FromObject(\"A\"),\n        CBORObject.NewArray());\n      bytes = new byte[] {\n        0x1e, 0x22, 0x41, 0x22, 0x0a, 0x1e, (byte)'[',\n        (byte)']',\n      };\n      ExpectJsonSequenceTwo(\n        bytes,\n        CBORObject.FromObject(\"A\"),\n        CBORObject.NewArray());\n      bytes = new byte[] {\n        0x1e, 0x22, 0x41, 0x22, 0x41, 0x1e, (byte)'[',\n        (byte)']',\n      };\n      ExpectJsonSequenceTwo(bytes, null, CBORObject.NewArray());\n      bytes = new byte[] { 0x1e, 0x1e, 0x22, 0x41, 0x22, 0x0a };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(\"A\"));\n      bytes = new byte[] { 0x1e, 0x1e, 0x30, 0x0a };\n      ExpectJsonSequenceOne(bytes, CBORObject.FromObject(0));\n      bytes = new byte[] { 0x1e, 0x1e, 0xef, 0xbb, 0xbf, 0x30, 0x0a };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] {\n        0x1e, 0x1e, 0xef, 0xbb, 0xbf, 0x30, 0x0a, 0x1e, 0x30,\n        0x0a,\n      };\n      ExpectJsonSequenceTwo(bytes, null, CBORObject.FromObject(0));\n      bytes = new byte[] { 0x22, 0x41, 0x22, 0x0a };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0xef, 0xbb, 0xbf, 0x1e, 0x30, 0x0a };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0xfe, 0xff, 0x00, 0x1e, 0, 0x30, 0, 0x0a };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0xff, 0xfe, 0x1e, 0, 0x30, 0, 0x0a, 0 };\n      ExpectJsonSequenceError(bytes);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a, 0x31, 0x31 };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a, 0x1e };\n      ExpectJsonSequenceTwo(bytes, CBORObject.FromObject(\"A\"), null);\n      bytes = new byte[] { 0x1e, 0x22, 0x41, 0x22, 0x0a, 0x31, 0x31, 0x1e };\n      ExpectJsonSequenceTwo(bytes, null, null);\n      bytes = new byte[] { 0x1e };\n      ExpectJsonSequenceOne(bytes, null);\n      bytes = new byte[] { 0x1e, 0x1e };\n      ExpectJsonSequenceOne(bytes, null);\n    }\n\n    [Test]\n    public void TestNonUtf8FromJSONBytes() {\n      byte[] bytes;\n      CBORObject cbor;\n      bytes = new byte[] { 0x31, 0, 0x31, 0 };\n      cbor = CBORObject.FromJSONBytes(bytes);\n      Assert.AreEqual(CBORObject.FromObject(11), cbor);\n      bytes = new byte[] { 0x31, 0, 0, 0, 0x31, 0, 0, 0 };\n      cbor = CBORObject.FromJSONBytes(bytes);\n      Assert.AreEqual(CBORObject.FromObject(11), cbor);\n    }\n\n    [Test]\n    public void TestReadJSON() {\n      try {\n        using (var ms2 = new MemoryStream(new byte[] { 0x30 })) {\n          try {\n            CBORObject.ReadJSON(ms2, (CBOREncodeOptions)null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.ReadJSON(ms2, (JSONOptions)null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var ms = new MemoryStream(new byte[] {\n          0xef, 0xbb, 0xbf,\n          0x7b, 0x7d,\n        })) {\n          try {\n            CBORObject.ReadJSON(ms);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // whitespace followed by BOM\n        using (var ms2 = new MemoryStream(new byte[] {\n          0x20, 0xef, 0xbb,\n          0xbf, 0x7b, 0x7d,\n        })) {\n          try {\n            CBORObject.ReadJSON(ms2);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var ms2a = new MemoryStream(new byte[] { 0x7b, 0x05, 0x7d })) {\n          try {\n            CBORObject.ReadJSON(ms2a);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var ms2b = new MemoryStream(new byte[] { 0x05, 0x7b, 0x7d })) {\n          try {\n            CBORObject.ReadJSON(ms2b);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // two BOMs\n        using (var ms3 = new MemoryStream(new byte[] {\n          0xef, 0xbb, 0xbf,\n          0xef, 0xbb, 0xbf, 0x7b, 0x7d,\n        })) {\n          try {\n            CBORObject.ReadJSON(ms3);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0,\n          0,\n          0x74, 0, 0, 0, 0x72, 0, 0, 0, 0x75, 0, 0, 0,\n          0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x74, 0, 0,\n          0, 0x72, 0,\n          0, 0, 0x75, 0, 0, 0, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0, 0,\n          0x74, 0, 0, 0,\n          0x72, 0, 0, 0, 0x75, 0, 0, 0, 0x65, 0, 0, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x74, 0, 0, 0, 0x72,\n          0,\n          0,\n          0,\n          0x75, 0, 0, 0, 0x65, 0, 0, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0, 0x74,\n          0, 0x72, 0,\n          0x75, 0, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0x74, 0, 0x72, 0,\n          0x75, 0, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x74, 0,\n          0x72,\n          0,\n          0x75,\n          0, 0x65, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x74, 0, 0x72, 0,\n          0x75, 0, 0x65, 0,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xef, 0xbb, 0xbf,\n          0x74, 0x72, 0x75, 0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x74, 0x72, 0x75,\n          0x65,\n        })) {\n          Assert.AreEqual(CBORObject.True, CBORObject.ReadJSON(msjson));\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0, 0x22,\n          0, 1, 0, 0, 0, 0, 0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x22, 0, 1,\n          0, 0, 0, 0,\n          0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0, 0,\n          0x22, 0, 0, 0,\n          0, 0, 1, 0, 0x22, 0, 0, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0, 0, 0,\n          1, 0, 0x22,\n          0,\n          0, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0,\n          0x22, 0xd8,\n          0,\n          0xdc, 0, 0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0x22, 0xd8, 0,\n          0xdc, 0, 0, 0x22,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x22, 0,\n          0, 0xd8, 0,\n          0xdc, 0x22, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0xd8, 0,\n          0xdc, 0x22, 0,\n        })) {\n          {\n            string stringTemp = CBORObject.ReadJSON(msjson).AsString();\n            Assert.AreEqual(\n              \"\\ud800\\udc00\",\n              stringTemp);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0, 0x22,\n          0, 0, 0xd8, 0, 0, 0, 0, 0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x22, 0, 0,\n          0xd8, 0, 0,\n          0,\n          0, 0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0, 0,\n          0x22, 0, 0, 0,\n          0, 0xd8, 0, 0, 0x22, 0, 0, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0, 0,\n          0xd8,\n          0,\n          0,\n          0x22, 0, 0, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0, 0x22,\n          0, 0xdc, 0,\n          0xdc, 0, 0, 0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0x22, 0, 0xdc, 0,\n          0xdc, 0, 0,\n          0x22,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x22, 0,\n          0, 0xdc, 0,\n          0xdc, 0x22, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0x22, 0, 0, 0xdc, 0,\n          0xdc, 0x22, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] { 0xfc })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] { 0, 0 })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // Illegal UTF-16\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0x20,\n          0x20, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x20,\n          0x20, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xd8,\n          0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xd8,\n          0x00, 0x20, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0x20, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xd8,\n          0x00, 0xd8, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0xd8, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0xd8, 0x00, 0xdc, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xfe, 0xff, 0xdc,\n          0x00, 0xdc, 0x00,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xd8,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xd8, 0x00, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0x20,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xd8, 0x00, 0xd8,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0xd8,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0xd8, 0x00, 0xdc,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        using (var msjson = new MemoryStream(new byte[] {\n          0xff, 0xfe, 0x00,\n          0xdc, 0x00, 0xdc,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n\n        // Illegal UTF-32\n        using (var msjson = new MemoryStream(new byte[] {\n          0, 0, 0, 0x20, 0,\n        })) {\n          try {\n            CBORObject.ReadJSON(msjson);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        var msbytes = new byte[] { 0, 0, 0, 0x20, 0, 0, };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0, 0x20, 0, 0, 0 };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0, 0,\n          0xd8, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0, 0,\n          0xdc, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0,\n          0x11, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0,\n          0xff, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0, 0x20, 0x1,\n          0, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0xfe, 0xff, 0, };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0xfe, 0xff, 0, 0, };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0xd8, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0, 0xdc, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0x11, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] {\n          0, 0, 0xfe, 0xff, 0,\n          0xff, 0x00, 0,\n        };\n        ReadJsonFail(msbytes);\n        msbytes = new byte[] { 0, 0, 0xfe, 0xff, 0x1, 0, 0x00, 0, };\n        ReadJsonFail(msbytes);\n      } catch (IOException ex) {\n        Assert.Fail(ex.Message);\n      }\n    }\n\n    private static void ReadJsonFail(byte[] msbytes) {\n      using (var msjson = new MemoryStream(msbytes)) {\n        try {\n          CBORObject.ReadJSON(msjson);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    // TODO: In next major version, consider using CBORException\n    // for circular refs in EncodeToBytes\n    [Test]\n    public void TestEncodeToBytesCircularRefs() {\n      CBORObject cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(cbor);\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(cbor, \"test\");\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(CBORObject.NewArray().Add(cbor), \"test\");\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.EncodeToBytes();\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs1() {\n      CBORObject cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs4() {\n      CBORObject cbor = CBORObject.NewArray().Add(1).Add(2);\n      cbor.Add(CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs2() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(cbor, \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs5() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(CBORObject.NewArray().Add(cbor), \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs6() {\n      CBORObject cbor = CBORObject.NewMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3b() {\n      CBORObject cbor;\n      cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3ba() {\n      CBORObject cbor;\n\n      cbor = CBORObject.NewOrderedMap().Add(\"abc\", 2).Add(\"def\", 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3bb() {\n      CBORObject cbor;\n\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", cbor);\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs3bc() {\n      CBORObject cbor;\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(CBORObject.NewOrderedMap().Add(\"jkl\", cbor), \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap().Add(\"jkl\", cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(CBORObject.NewOrderedMap().Add(cbor, \"jkl\"), \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap().Add(cbor, \"jkl\"));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = CBORObject.NewOrderedMap().Add(cbor,\n            \"jkl\").Add(\"mno\",\n            1);\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap().Add(cbor,\n            \"jkl\").Add(\"mno\", 1);\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap().Add(\"mno\",\n            1).Add(cbor, \"jkl\");\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = CBORObject.NewOrderedMap().Add(\"mno\", 1).Add(cbor,\n            \"jkl\");\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      // No circular refs\n      cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap());\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"abc\", 2).Add(\"def\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap());\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      cbor.Add(\"test\", CBORObject.NewOrderedMap());\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = CBORObject.NewOrderedMap().Add(\"jkl\",\n            CBORObject.NewOrderedMap());\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap().Add(\"jkl\",\n            CBORObject.NewOrderedMap());\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp =\n          CBORObject.NewOrderedMap().Add(CBORObject.NewOrderedMap(),\n            \"jkl\");\n        object objectTemp2 = \"test\";\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp = \"test\";\n        object objectTemp2 = CBORObject.NewOrderedMap()\n          .Add(CBORObject.NewOrderedMap(),\n            \"jkl\");\n        cbor.Add(objectTemp, objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        CBORObject.NewOrderedMap().Add(CBORObject.NewOrderedMap(),\n          \"jkl\").Add(\"mno\",\n            1);\n        object objectTemp2 = \"test\";\n        cbor.Add(\"test\", objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp2 =\n          CBORObject.NewOrderedMap().Add(CBORObject.NewOrderedMap(),\n            \"jkl\").Add(\"mno\",\n            1);\n        cbor.Add(\"test\", objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp2 =\n          CBORObject.NewOrderedMap().Add(\"mno\", 1).Add(\n            CBORObject.NewOrderedMap(),\n            \"jkl\");\n        cbor.Add(\"test\", objectTemp2);\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n      cbor = CBORObject.NewOrderedMap().Add(\"ghi\", 2).Add(\"abc\", 4);\n      {\n        object objectTemp =\n          CBORObject.NewOrderedMap().Add(\"mno\", 1).Add(\n            CBORObject.NewOrderedMap(),\n            \"jkl\");\n        cbor.Add(objectTemp, \"test\");\n      }\n      Assert.IsTrue(cbor.CalcEncodedSize() > 2);\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs2a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(cbor, \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs5a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      CBORObject cbor2 = CBORObject.NewArray().Add(cbor);\n      cbor.Add(cbor2, \"test\");\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n    [Test]\n    public void TestCalcEncodedSizeCircularRefs6a() {\n      CBORObject cbor = CBORObject.NewOrderedMap().Add(1, 2).Add(3, 4);\n      cbor.Add(\"test\", CBORObject.NewArray().Add(cbor));\n      try {\n        cbor.CalcEncodedSize();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestClear() {\n      CBORObject cbor;\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.AreEqual(3, cbor.Count);\n      cbor.Clear();\n      Assert.AreEqual(0, cbor.Count);\n      cbor = CBORObject.NewMap()\n        .Add(\"a\", 0).Add(\"b\", 1).Add(\"c\", 2);\n      Assert.AreEqual(3, cbor.Count);\n      cbor.Clear();\n      Assert.AreEqual(0, cbor.Count);\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1).Clear();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.Clear();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.Clear();\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestRemove() {\n      CBORObject cbor;\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.AreEqual(3, cbor.Count);\n      Assert.IsTrue(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"b\")));\n      Assert.IsFalse(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"x\")));\n      try {\n        cbor.Remove((CBORObject)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"a\"), cbor[0]);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"c\"), cbor[1]);\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.AreEqual(3, cbor.Count);\n\n      Assert.IsTrue(cbor.Remove(\"b\"));\n      Assert.IsFalse(cbor.Remove(\"x\"));\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"a\"), cbor[0]);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"c\"), cbor[1]);\n      cbor = CBORObject.NewMap().Add(\"a\", 0).Add(\"b\", 1).Add(\"c\", 2);\n      Assert.AreEqual(3, cbor.Count);\n\n      Assert.IsTrue(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"b\")));\n      Assert.IsFalse(cbor.Remove(ToObjectTest.TestToFromObjectRoundTrip(\n            \"x\")));\n      try {\n        cbor.Remove((CBORObject)null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(2, cbor.Count);\n      Assert.IsTrue(cbor.ContainsKey(\"a\"));\n      Assert.IsTrue(cbor.ContainsKey(\"c\"));\n      cbor = CBORObject.NewMap().Add(\"a\", 0).Add(\"b\", 1).Add(\"c\", 2);\n      Assert.AreEqual(3, cbor.Count);\n\n      Assert.IsTrue(cbor.Remove(\"b\"));\n      Assert.IsFalse(cbor.Remove(\"x\"));\n      Assert.AreEqual(2, cbor.Count);\n      Assert.IsTrue(cbor.ContainsKey(\"a\"));\n      Assert.IsTrue(cbor.ContainsKey(\"c\"));\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1).Remove(\"x\");\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.Remove(\"x\");\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.Remove(\"x\");\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1)\n        .Remove(ToObjectTest.TestToFromObjectRoundTrip(\"b\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.Remove(ToObjectTest.TestToFromObjectRoundTrip(\"b\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.Remove(ToObjectTest.TestToFromObjectRoundTrip(\"b\"));\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestRemoveAt() {\n      CBORObject cbor;\n      cbor = CBORObject.NewArray().Add(\"a\").Add(\"b\").Add(\"c\");\n      Assert.IsTrue(cbor.RemoveAt(1));\n      Assert.IsFalse(cbor.RemoveAt(2));\n      Assert.IsFalse(cbor.RemoveAt(-1));\n      Assert.AreEqual(2, cbor.Count);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"a\"), cbor[0]);\n      Assert.AreEqual(ToObjectTest.TestToFromObjectRoundTrip(\"c\"), cbor[1]);\n      try {\n        CBORObject.NewMap().RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(1).RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.False.RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Null.RemoveAt(0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestSet() {\n      CBORObject cbor = CBORObject.NewMap().Add(\"x\", 0).Add(\"y\", 1);\n      Assert.AreEqual(0, cbor[\"x\"].AsInt32());\n      Assert.AreEqual(1, cbor[\"y\"].AsInt32());\n      cbor.Set(\"x\", 5).Set(\"z\", 6);\n      Assert.AreEqual(5, cbor[\"x\"].AsInt32());\n      Assert.AreEqual(6, cbor[\"z\"].AsInt32());\n      cbor = CBORObject.NewArray().Add(1).Add(2).Add(3).Add(4);\n      Assert.AreEqual(1, cbor[0].AsInt32());\n      Assert.AreEqual(2, cbor[1].AsInt32());\n      Assert.AreEqual(3, cbor[2].AsInt32());\n      try {\n        cbor.Set(-1, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.Set(4, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.Set(999, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject cbor2 = CBORObject.True;\n      try {\n        cbor2.Set(0, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor.Set(0, 99);\n      Assert.AreEqual(99, cbor[0].AsInt32());\n      cbor.Set(3, 199);\n      Assert.AreEqual(199, cbor[3].AsInt32());\n    }\n\n    [Test]\n    public void TestSign() {\n      try {\n        int sign = CBORObject.True.Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        int sign = CBORObject.False.Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        int sign = CBORObject.NewArray().Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        int sign = CBORObject.NewMap().Sign;\n        Assert.Fail(\"Should have failed\");\n      } catch (InvalidOperationException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      CBORObject numbers = GetNumberData();\n      for (int i = 0; i < numbers.Count; ++i) {\n        CBORObject numberinfo = numbers[i];\n        string numberString = numberinfo[\"number\"].AsString();\n        CBORObject cbornumber =\n          ToObjectTest.TestToFromObjectRoundTrip(EDecimal.FromString(\n              numberString));\n        if (cbornumber.AsNumber().IsNaN()) {\n          try {\n            Assert.Fail(String.Empty + cbornumber.Sign);\n            Assert.Fail(\"Should have failed\");\n          } catch (InvalidOperationException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else if (numberString.Length > 0 && numberString[0] == '-') {\n          Assert.AreEqual(-1, cbornumber.Sign);\n        } else if (numberinfo[\"number\"].AsString().Equals(\"0\",\n            StringComparison.Ordinal)) {\n          Assert.AreEqual(0, cbornumber.Sign);\n        } else {\n          Assert.AreEqual(1, cbornumber.Sign);\n        }\n      }\n    }\n\n    [Test]\n    [Timeout(1000)]\n    public void TestAsNumberSubtract() {\n      try {\n        ToObjectTest.TestToFromObjectRoundTrip(2).AsNumber().Subtract(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestCompareToUnicodeString() {\n      CBORObject cbora;\n      CBORObject cborb;\n      cbora = CBORObject.FromObject(\"aa\\ud200\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud200\\ue001\");\n      TestCommon.CompareTestLess(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud200\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud201\\ue000\");\n      TestCommon.CompareTestLess(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud800\\udc00\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ue001\\ue000\");\n      TestCommon.CompareTestGreater(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud800\\udc00\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud800\\udc01\\ue000\");\n      TestCommon.CompareTestLess(cbora, cborb);\n      cbora = CBORObject.FromObject(\"aa\\ud800\\udc00\\ue000\");\n      cborb = CBORObject.FromObject(\"aa\\ud801\\udc00\\ue000\");\n      TestCommon.CompareTestLess(cbora, cborb);\n    }\n\n    [Test]\n    public void TestToJSONString() {\n      {\n        string stringTemp = ToObjectTest.TestToFromObjectRoundTrip(\n            \"\\u2027\\u2028\\u2029\\u202a\\u0008\\u000c\").ToJSONString();\n        Assert.AreEqual(\n          \"\\\"\\u2027\\\\u2028\\\\u2029\\u202a\\\\b\\\\f\\\"\",\n          stringTemp);\n      }\n      {\n        string stringTemp = ToObjectTest.TestToFromObjectRoundTrip(\n            \"\\u0085\\ufeff\\ufffe\\uffff\").ToJSONString();\n        Assert.AreEqual(\n          \"\\\"\\\\u0085\\\\uFEFF\\\\uFFFE\\\\uFFFF\\\"\",\n          stringTemp);\n      }\n      {\n        string stringTemp = CBORObject.True.ToJSONString();\n        Assert.AreEqual(\n          \"true\",\n          stringTemp);\n      }\n      {\n        string stringTemp = CBORObject.False.ToJSONString();\n        Assert.AreEqual(\n          \"false\",\n          stringTemp);\n      }\n      {\n        string stringTemp = CBORObject.Null.ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.PositiveInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.NegativeInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Single.NaN).ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.PositiveInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NegativeInfinity)\n          .ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n      {\n        string stringTemp =\n          ToObjectTest.TestToFromObjectRoundTrip(Double.NaN).ToJSONString();\n        Assert.AreEqual(\n          \"null\",\n          stringTemp);\n      }\n\n      CBORObject cbor = CBORObject.NewArray();\n      var b64bytes = new byte[] {\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xff, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xff, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n        0x01, 0xfe, 0xdd, 0xfd, 0xdc,\n      };\n      cbor.Add(b64bytes);\n      TestSucceedingJSON(cbor.ToJSONString());\n      cbor = CBORObject.NewMap();\n      cbor.Add(\"key\", \"\\ud800\\udc00\");\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\udc00\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\ud800\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"key\", \"\\udc00\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      cbor.Add(\"\\ud800\\udc00\", \"value\");\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\ud800\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\udc00\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\ud800\\udc00\\ud800\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      try {\n        cbor.Add(\"\\udc00\\udc00\\ud800\", \"value\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      cbor.Add(\"\\ud800\\udc00\");\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\udc00\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\ud800\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      try {\n        cbor.Add(\"\\udc00\\udc00\\ud800\");\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToJSONString_DuplicateKeys() {\n      CBORObject cbor;\n      cbor = CBORObject.NewMap().Add(\"true\", 1).Add(true, 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"true\", 1).Add(false, 1);\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"9999-01-01T00:00:00Z\", 1)\n        .Add(CBORObject.FromObjectAndTag(\"9999-01-01T00:00:00Z\", 0), 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"34\", 1).Add(34, 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"-34\", 1).Add(-34, 1);\n      try {\n        cbor.ToJSONString();\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"-34\", 1).Add(-35, 1);\n      try {\n        cbor.ToJSONString();\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToFloatingPointBits() {\n      try {\n        CBORObject.FromFloatingPointBits(0, 0);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 1);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 3);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 5);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 6);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 7);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.FromFloatingPointBits(0, 9);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestToFloatingPointBitsSingle() {\n      // Regression test\n      CBORObject o;\n      o = CBORObject.FromFloatingPointBits(2140148306L, 4);\n      Assert.IsTrue(Double.IsNaN(o.AsDoubleValue()));\n      o = CBORObject.FromFloatingPointBits(1651724151L, 4);\n      Assert.IsTrue(o.AsDoubleValue() == 1.1220712138406615E21);\n      o = CBORObject.FromFloatingPointBits(-1566356128L, 4);\n      Assert.IsTrue(o.AsDoubleValue() == -4.426316249665156E-18);\n    }\n\n    [Test]\n    public void TestToJSONString_ByteArray_Padding() {\n      CBORObject o;\n      var options = new JSONOptions(String.Empty);\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xf0, 0xe8 }, 22);\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtbw6A==\\\"\",\n          stringTemp);\n      }\n      // untagged, so base64url without padding\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xf0, 0xe8,\n      });\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"mtbw6A\\\"\",\n          stringTemp);\n      }\n      // tagged 23, so base16\n      o = CBORObject.FromObjectAndTag(\n          new byte[] { 0x9a, 0xd6, 0xf0, 0xe8 },\n          23);\n      {\n        string stringTemp = o.ToJSONString(options);\n        Assert.AreEqual(\n          \"\\\"9AD6F0E8\\\"\",\n          stringTemp);\n      }\n      o = ToObjectTest.TestToFromObjectRoundTrip(new byte[] {\n        0x9a, 0xd6,\n        0xff, 0xe8,\n      });\n    }\n\n    [Test]\n    public void TestToString() {\n      {\n        string stringTemp = CBORObject.Undefined.ToString();\n        Assert.AreEqual(\n          \"undefined\",\n          stringTemp);\n      }\n      CBORObject cbor = CBORObject.True;\n      string cborString;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"21\", cborString);\n      TestCommon.AssertNotEqual(\"simple(21)\", cborString);\n      cbor = CBORObject.False;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"20\", cborString);\n      TestCommon.AssertNotEqual(\"simple(20)\", cborString);\n      cbor = CBORObject.Null;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"22\", cborString);\n      TestCommon.AssertNotEqual(\"simple(22)\", cborString);\n      cbor = CBORObject.Undefined;\n      cborString = cbor.ToString();\n      if (cborString == null) {\n        Assert.Fail();\n      }\n      TestCommon.AssertNotEqual(\"23\", cborString);\n      TestCommon.AssertNotEqual(\"simple(23)\", cborString);\n      {\n        string stringTemp = CBORObject.FromSimpleValue(50).ToString();\n        Assert.AreEqual(\n          \"simple(50)\",\n          stringTemp);\n      }\n    }\n\n    [Test]\n    public void TestSimpleValuesNotIntegers() {\n      CBORObject cbor = CBORObject.True;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(21), cbor);\n      cbor = CBORObject.False;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(20), cbor);\n      cbor = CBORObject.Null;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(22), cbor);\n      cbor = CBORObject.Undefined;\n      TestCommon.AssertNotEqual(CBORObject.FromObject(23), cbor);\n    }\n\n    [Test]\n    public void TestTrue() {\n      CBORTestCommon.AssertJSONSer(CBORObject.True, \"true\");\n      Assert.AreEqual(\n        CBORObject.True,\n        ToObjectTest.TestToFromObjectRoundTrip(true));\n    }\n\n    [Test]\n    public void TestCalcEncodedBytesSpecific() {\n      CBORObject cbor;\n\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xda, 0x00, 0x1d,\n        (byte)0xdb, 0x03, (byte)0xd9, 0x01, 0x0d, (byte)0x83, 0x00, 0x00,\n        0x03,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xda, 0x00, 0x14,\n        0x57,\n        (byte)0xce,\n        (byte)0xc5,\n        (byte)0x82, 0x1a, 0x46, 0x5a, 0x37,\n        (byte)0x87,\n        (byte)0xc3, 0x50, 0x5e,\n        (byte)0xec,\n        (byte)0xfd, 0x73, 0x50, 0x64,\n        (byte)0xa1, 0x1f, 0x10,\n        (byte)0xc4, (byte)0xff, (byte)0xf2, (byte)0xc4, (byte)0xc9, 0x65,\n        0x12,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, 0x56, 0x00,\n        0x69, 0x2a,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xf9, (byte)0xfc,\n        0x00,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xa2,\n        (byte)0x82,\n        (byte)0xf6,\n        (byte)0x82,\n        (byte)0xfb, 0x3c,\n        (byte)0xf0, 0x03, 0x42,\n        (byte)0xcb, 0x54, 0x6c,\n        (byte)0x85,\n        (byte)0x82,\n        (byte)0xc5,\n        (byte)0x82, 0x18,\n        (byte)0xba, 0x0a,\n        (byte)0xfa,\n        (byte)0x84,\n        (byte)0xa0, 0x57,\n        (byte)0x97, 0x42, 0x00, 0x01, 0x65, 0x62, 0x7d, 0x45, 0x20, 0x6c, 0x41,\n        0x00,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0x82,\n        (byte)0xfa,\n        (byte)0xe0,\n        (byte)0xa0,\n        (byte)0x9d,\n        (byte)0xba,\n        (byte)0x82,\n        (byte)0x82,\n        (byte)0xf7, (byte)0xa2, (byte)0xa0, (byte)0xf7, 0x60, 0x41, 0x00,\n        (byte)0xf4,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, (byte)0xc7,\n        (byte)0x80, 0x01, (byte)0x80,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xa5, 0x64, 0x69,\n        0x74, 0x65, 0x6d, 0x6a, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x72, 0x69,\n        0x6e, 0x67, 0x66, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x2a, 0x63,\n        0x6d, 0x61, 0x70,\n        (byte)0xa1, 0x66, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x2a, 0x65,\n        0x61, 0x72, 0x72, 0x61, 0x79,\n        (byte)0x82,\n        (byte)0xf9, 0x63,\n        (byte)0xce, 0x63, 0x78, 0x79, 0x7a, 0x65, 0x62, 0x79, 0x74, 0x65, 0x73,\n        0x43, 0x00, 0x01, 0x02,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xda, 0x00, 0x14,\n        0x57,\n        (byte)0xce,\n        (byte)0xc5,\n        (byte)0x82, 0x1a, 0x46, 0x5a, 0x37,\n        (byte)0x87,\n        (byte)0xc3, 0x50, 0x5e,\n        (byte)0xec,\n        (byte)0xfd, 0x73, 0x50, 0x64,\n        (byte)0xa1, 0x1f, 0x10,\n        (byte)0xc4, (byte)0xff, (byte)0xf2, (byte)0xc4, (byte)0xc9, 0x65,\n        0x12,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, (byte)0xc7,\n        (byte)0x80, 0x01, (byte)0x80,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0x82,\n        (byte)0xda, 0x00, 0x0a,\n        (byte)0xe8,\n        (byte)0xb6,\n        (byte)0xfb, 0x43,\n        (byte)0xc0, 0x00, 0x00,\n        (byte)0xd5, 0x42, 0x7f,\n        (byte)0xdc, (byte)0xfa, 0x71, (byte)0x80, (byte)0xd7, (byte)0xc8,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n      cbor = CBORObject.DecodeFromBytes(new byte[] {\n        (byte)0xfa, 0x29, 0x0a,\n        0x4c, (byte)0x9e,\n      });\n      CBORTestCommon.CheckEncodeToBytes(cbor);\n    }\n\n    [Test]\n    public void TestType() {\n      CBORObject cbor = CBORObject.True;\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      // Simple value for true\n      cbor = CBORObject.FromSimpleValue(21);\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      cbor = CBORObject.FromObjectAndTag(CBORObject.True, 999);\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      cbor = CBORObject.False;\n      Assert.AreEqual(\n        CBORType.Boolean,\n        cbor.Type);\n      cbor = CBORObject.Null;\n      Assert.AreEqual(\n        CBORType.SimpleValue,\n        cbor.Type);\n      cbor = CBORObject.Undefined;\n      Assert.AreEqual(\n        CBORType.SimpleValue,\n        cbor.Type);\n      cbor = CBORObject.FromSimpleValue(99);\n      Assert.AreEqual(\n        CBORType.SimpleValue,\n        cbor.Type);\n    }\n\n    [Test]\n    public void TestUntag() {\n      CBORObject o = CBORObject.FromObjectAndTag(\"test\", 999);\n      Assert.AreEqual(EInteger.FromString(\"999\"), o.MostInnerTag);\n      o = o.Untag();\n      Assert.AreEqual(EInteger.FromString(\"-1\"), o.MostInnerTag);\n    }\n\n    [Test]\n    public void TestUntagOne() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestValues() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestWrite() {\n      for (var i = 0; i < 2000; ++i) {\n        this.TestWrite2();\n      }\n      for (var i = 0; i < 40; ++i) {\n        TestWrite3();\n      }\n    }\n\n    public static void TestWriteExtraOne(long longValue) {\n      try {\n        {\n          CBORObject cborTemp1 =\n            ToObjectTest.TestToFromObjectRoundTrip(longValue);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)longValue);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(longValue, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(longValue, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(longValue));\n          }\n          TestWriteObj((object)longValue, longValue);\n        }\n\n        EInteger bigintVal = EInteger.FromInt64(longValue);\n        {\n          CBORObject cborTemp1 =\n            ToObjectTest.TestToFromObjectRoundTrip(bigintVal);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)bigintVal);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(bigintVal, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(bigintVal, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(bigintVal));\n          }\n          TestWriteObj((object)bigintVal, bigintVal);\n        }\n\n        if (longValue >= (long)Int32.MinValue && longValue <=\n          (long)Int32.MaxValue) {\n          var intval = (int)longValue;\n          {\n            CBORObject cborTemp1 =\n              ToObjectTest.TestToFromObjectRoundTrip(intval);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)intval);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(intval, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(intval, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(intval));\n            }\n            TestWriteObj((object)intval, intval);\n          }\n        }\n        if (longValue >= -32768L && longValue <= 32767) {\n          var shortval = (short)longValue;\n          CBORObject cborTemp1 = ToObjectTest\n            .TestToFromObjectRoundTrip(shortval);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)shortval);\n          TestCommon.CompareTestEqualAndConsistent(\n            cborTemp1,\n            cborTemp2);\n          try {\n            CBORObject.Write(shortval, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(shortval, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(shortval));\n          }\n          TestWriteObj((object)shortval, shortval);\n        }\n        if (longValue >= 0L && longValue <= 255) {\n          var byteval = (byte)longValue;\n          {\n            CBORObject cborTemp1 =\n              ToObjectTest.TestToFromObjectRoundTrip(byteval);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)byteval);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1,\n              cborTemp2);\n            try {\n              CBORObject.Write(byteval, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(byteval, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(byteval));\n            }\n            TestWriteObj((object)byteval, byteval);\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteExtra() {\n      try {\n        string str = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(str);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)str);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(str, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(str, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)str, null);\n        }\n\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(\n              \"test\");\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)\"test\");\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(\"test\", null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(\"test\", ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            {\n              CBORObject objectTemp2 = ToObjectTest.TestToFromObjectRoundTrip(\n                  \"test\");\n              AssertReadThree(ms.ToArray(), objectTemp2);\n            }\n          }\n          TestWriteObj((object)\"test\", \"test\");\n        }\n\n        str = TestCommon.Repeat(\"test\", 4000);\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(str);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)str);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(str, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(str, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(str));\n          }\n          TestWriteObj((object)str, str);\n        }\n\n        long[] values = {\n          0, 1, 23, 24, -1, -23, -24, -25,\n          0x7f, -128, 255, 256, 0x7fff, -32768, 0x7fff,\n          -32768, -65536, -32769, -65537,\n          0x7fffff, 0x7fff7f, 0x7fff7fff, 0x7fff7fff7fL, 0x7fff7fff7fffL,\n          0x7fff7fff7fff7fL, 0x7fff7fff7fff7fffL,\n          Int64.MaxValue, Int64.MinValue, Int32.MinValue,\n          Int32.MaxValue,\n        };\n        for (var i = 0; i < values.Length; ++i) {\n          TestWriteExtraOne(values[i]);\n        }\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(0.0f);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)0.0f);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(0.0f, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(0.0f, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(0.0f));\n          }\n          TestWriteObj((object)0.0f, 0.0f);\n        }\n\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(2.6);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)2.6);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(2.6, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(2.6, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(2.6));\n          }\n          TestWriteObj((object)2.6, 2.6);\n        }\n\n        CBORObject cbor = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(cbor);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)cbor);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(cbor, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(cbor, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)cbor, null);\n        }\n\n        object aobj = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(aobj);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)aobj);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(aobj, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(aobj, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)aobj, null);\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    public static void TestWrite3() {\n      EFloat ef = null;\n      EDecimal ed = null;\n      var fr = new RandomGenerator();\n      try {\n        for (var i = 0; i < 256; ++i) {\n          var b = (byte)(i & 0xff);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write((byte)b, ms);\n            CBORObject cobj = CBORObject.DecodeFromBytes(ms.ToArray());\n            Assert.AreEqual(i, cobj.AsInt32());\n          }\n        }\n\n        for (var i = 0; i < 50; ++i) {\n          ef = RandomObjects.RandomEFloat(fr);\n          if (!ef.IsNaN()) {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ef, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ef, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(ef));\n            }\n            TestWriteObj((object)ef, ef);\n          }\n\n          ef = EFloat.Create(\n              RandomObjects.RandomEInteger(fr),\n              RandomObjects.RandomEInteger(fr));\n          {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ef, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ef, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              if (cborTemp1.IsNegative && cborTemp1.IsZero) {\n                AssertReadThree(ms.ToArray());\n              } else {\n                AssertReadThree(\n                  ms.ToArray(),\n                  ToObjectTest.TestToFromObjectRoundTrip(ef));\n              }\n            }\n            TestWriteObj((object)ef, ef);\n          }\n        }\n        for (var i = 0; i < 50; ++i) {\n          ed = RandomObjects.RandomEDecimal(fr);\n          if (!ed.IsNaN()) {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ed);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ed);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ed, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ed, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              if (cborTemp1.IsNegative && cborTemp1.IsZero) {\n                AssertReadThree(ms.ToArray());\n              } else {\n                AssertReadThree(\n                  ms.ToArray(),\n                  ToObjectTest.TestToFromObjectRoundTrip(ed));\n              }\n            }\n            if (!(cborTemp1.IsNegative && cborTemp1.IsZero)) {\n              TestWriteObj((object)ed, ed);\n            }\n          }\n\n          ed = EDecimal.Create(\n              RandomObjects.RandomEInteger(fr),\n              RandomObjects.RandomEInteger(fr));\n          {\n            CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ed);\n            CBORObject cborTemp2 =\n              ToObjectTest.TestToFromObjectRoundTrip((object)ed);\n            TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n            try {\n              CBORObject.Write(ed, null);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentNullException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            AssertWriteThrow(cborTemp1);\n            using (var ms = new MemoryStream()) {\n              CBORObject.Write(ed, ms);\n              CBORObject.Write(cborTemp1, ms);\n              cborTemp1.WriteTo(ms);\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(ed));\n            }\n            TestWriteObj((object)ed, ed);\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWrite2() {\n      try {\n        var fr = new RandomGenerator();\n\n        EFloat ef = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(ef, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(ef, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)ef, null);\n        }\n\n        ef = EFloat.FromString(\"20\");\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ef);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)ef);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(ef, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(ef, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(ef));\n          }\n          TestWriteObj((object)ef, ef);\n        }\n\n        ERational er = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(er);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)er);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(er, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(er, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)er, null);\n        }\n        do {\n          er = RandomObjects.RandomERational(fr);\n        } while (er.IsNegative && er.IsZero);\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(er);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)er);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(er, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(er, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            if (cborTemp1.IsNegative && cborTemp1.IsZero) {\n              AssertReadThree(ms.ToArray());\n            } else {\n              AssertReadThree(\n                ms.ToArray(),\n                ToObjectTest.TestToFromObjectRoundTrip(er));\n            }\n          }\n          TestWriteObj((object)er, er);\n        }\n\n        EDecimal ed = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(ed);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)ed);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(ed, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(ed, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)ed, null);\n        }\n\n        EInteger bigint = null;\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(\n              bigint);\n          CBORObject cborTemp2 =\n            ToObjectTest.TestToFromObjectRoundTrip((object)bigint);\n          TestCommon.CompareTestEqualAndConsistent(cborTemp1, cborTemp2);\n          try {\n            CBORObject.Write(bigint, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(bigint, ms);\n            CBORObject.Write(cborTemp1, ms);\n            cborTemp1.WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip((object)null));\n          }\n          TestWriteObj((object)bigint, null);\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteJSON() {\n      // not implemented yet\n      try {\n        using (var ms = new MemoryStream()) {\n          CBORObject.WriteJSON(CBORObject.True, ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"true\", str);\n        }\n        using (var ms = new MemoryStream()) {\n          CBORObject.True.WriteJSONTo(ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"true\", str);\n        }\n        using (var ms = new MemoryStream()) {\n          CBORObject.WriteJSON(CBORObject.False, ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"false\", str);\n        }\n        using (var ms = new MemoryStream()) {\n          CBORObject.False.WriteJSONTo(ms);\n          byte[] bytes = ms.ToArray();\n          string str = DataUtilities.GetUtf8String(bytes, false);\n          Assert.AreEqual(\"false\", str);\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteJSONTo() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestWriteTo() {\n      // not implemented yet\n    }\n\n    [Test]\n    public void TestZero() {\n      {\n        string stringTemp = CBORObject.Zero.ToString();\n        Assert.AreEqual(\n          \"0\",\n          stringTemp);\n      }\n      Assert.AreEqual(\n        ToObjectTest.TestToFromObjectRoundTrip(0),\n        CBORObject.Zero);\n    }\n\n    internal static void CompareDecimals(CBORObject o1, CBORObject o2) {\n      int cmpDecFrac = TestCommon.CompareTestReciprocal(\n          AsED(o1),\n          AsED(o2));\n      int cmpCobj = TestCommon.CompareTestReciprocal(o1.AsNumber(),\n          o2.AsNumber());\n      if (cmpDecFrac != cmpCobj) {\n        Assert.Fail(TestCommon.ObjectMessages(\n            o1,\n            o2,\n            \"Compare: Results\\u0020don't match\"));\n      }\n      CBORTestCommon.AssertRoundTrip(o1);\n      CBORTestCommon.AssertRoundTrip(o2);\n    }\n\n    internal static void AreEqualExact(double a, double b) {\n      if (Double.IsNaN(a)) {\n        Assert.IsTrue(Double.IsNaN(b));\n      } else if (a != b) {\n        Assert.Fail(\"expected \" + a + \", got \" + b);\n      }\n    }\n\n    internal static void AreEqualExact(float a, float b) {\n      if (Single.IsNaN(a)) {\n        Assert.IsTrue(Single.IsNaN(b));\n      } else if (a != b) {\n        Assert.Fail(\"expected \" + a + \", got \" + b);\n      }\n    }\n\n    private static string Chop(string str) {\n      return (str.Length < 100) ? str : (str.Substring(0, 100) + \"...\");\n    }\n\n    private static void AssertReadThree(byte[] bytes) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          CBORObject cbor1, cbor2, cbor3;\n          cbor1 = CBORObject.Read(ms);\n          cbor2 = CBORObject.Read(ms);\n          cbor3 = CBORObject.Read(ms);\n          TestCommon.CompareTestRelations(cbor1, cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor1, cbor2);\n          TestCommon.CompareTestEqualAndConsistent(cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor3, cbor1);\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString() + \"\\r\\n\" +\n          TestCommon.ToByteArrayString(bytes));\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    private static void AssertReadThree(byte[] bytes, CBORObject cbor) {\n      try {\n        using (var ms = new MemoryStream(bytes)) {\n          CBORObject cbor1, cbor2, cbor3;\n          cbor1 = CBORObject.Read(ms);\n          cbor2 = CBORObject.Read(ms);\n          cbor3 = CBORObject.Read(ms);\n          TestCommon.CompareTestEqualAndConsistent(cbor1, cbor);\n          TestCommon.CompareTestRelations(cbor1, cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor1, cbor2);\n          TestCommon.CompareTestEqualAndConsistent(cbor2, cbor3);\n          TestCommon.CompareTestEqualAndConsistent(cbor3, cbor1);\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString() + \"\\r\\n\" +\n          Chop(TestCommon.ToByteArrayString(bytes)) + \"\\r\\n\" +\n          \"cbor = \" + Chop(cbor.ToString()) + \"\\r\\n\");\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    private static void AssertWriteThrow(CBORObject cbor) {\n      try {\n        cbor.WriteTo(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        CBORObject.Write(cbor, null);\n        Assert.Fail(\"Should have failed\");\n      } catch (ArgumentNullException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteBigExponentNumber() {\n      var exponents = new string[] {\n        \"15368525994429920286\",\n        \"18446744073709551615\",\n        \"-18446744073709551616\",\n        \"18446744073709551616\",\n        \"-18446744073709551617\",\n        \"18446744073709551615\",\n        \"-18446744073709551614\",\n      };\n      foreach (string strexp in exponents) {\n        EInteger bigexp = EInteger.FromString(strexp);\n        EDecimal ed = EDecimal.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ed);\n        EFloat ef = EFloat.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ef);\n        bigexp = bigexp.Negate();\n        ed = EDecimal.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ed);\n        ef = EFloat.Create(EInteger.FromInt32(99), bigexp);\n        TestWriteObj(ef);\n      }\n    }\n\n    private static void TestWriteObj(object obj) {\n      try {\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(obj);\n          try {\n            CBORObject.Write(obj, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(obj, ms);\n            CBORObject.Write(ToObjectTest.TestToFromObjectRoundTrip(obj), ms);\n            ToObjectTest.TestToFromObjectRoundTrip(obj).WriteTo(ms);\n            AssertReadThree(ms.ToArray());\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestEMap() {\n      CBORObject cbor = CBORObject.NewMap()\n        .Add(\"name\", \"Example\");\n      byte[] bytes = CBORTestCommon.CheckEncodeToBytes(cbor);\n    }\n\n    private static void TestWriteObj(object obj, object objTest) {\n      try {\n        {\n          CBORObject cborTemp1 = ToObjectTest.TestToFromObjectRoundTrip(obj);\n          try {\n            CBORObject.Write(obj, null);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentNullException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          AssertWriteThrow(cborTemp1);\n          using (var ms = new MemoryStream()) {\n            CBORObject.Write(obj, ms);\n            CBORObject.Write(ToObjectTest.TestToFromObjectRoundTrip(obj), ms);\n            ToObjectTest.TestToFromObjectRoundTrip(obj).WriteTo(ms);\n            AssertReadThree(\n              ms.ToArray(),\n              ToObjectTest.TestToFromObjectRoundTrip(objTest));\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestWriteValue() {\n      try {\n        try {\n          CBORObject.WriteValue(null, 0, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 1, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 2, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 3, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          CBORObject.WriteValue(null, 4, 0);\n          Assert.Fail(\"Should have failed\");\n        } catch (ArgumentNullException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        using (var ms = new MemoryStream()) {\n          try {\n            CBORObject.WriteValue(ms, -1, 0);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 8, 0);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 7, 256);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 7, Int32.MaxValue);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.WriteValue(ms, 7, Int64.MaxValue);\n            Assert.Fail(\"Should have failed\");\n          } catch (ArgumentException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          for (var i = 0; i <= 7; ++i) {\n            try {\n              CBORObject.WriteValue(ms, i, -1);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, Int32.MinValue);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, -1L);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, Int64.MinValue);\n              Assert.Fail(\"Should have failed\");\n            } catch (ArgumentException) {\n              // NOTE: Intentionally empty\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          for (var i = 0; i <= 6; ++i) {\n            try {\n              CBORObject.WriteValue(ms, i, Int32.MaxValue);\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n            try {\n              CBORObject.WriteValue(ms, i, Int64.MaxValue);\n            } catch (Exception ex) {\n              Assert.Fail(ex.ToString());\n              throw new InvalidOperationException(String.Empty, ex);\n            }\n          }\n          // Test minimum data length\n          int[] ranges = {\n            0, 23, 1,\n            24, 255, 2,\n            256, 266, 3,\n            65525, 65535, 3,\n            65536, 65546, 5,\n          };\n          string[] bigRanges = {\n            \"4294967285\", \"4294967295\",\n            \"4294967296\", \"4294967306\",\n            \"18446744073709551604\", \"18446744073709551615\",\n          };\n          int[] bigSizes = { 5, 9, 9, 5, 9, 9 };\n          for (int i = 0; i < ranges.Length; i += 3) {\n            for (int j = ranges[i]; j <= ranges[i + 1]; ++j) {\n              for (var k = 0; k <= 6; ++k) {\n                int count;\n                count = CBORObject.WriteValue(ms, k, j);\n                Assert.AreEqual(ranges[i + 2], count);\n                count = CBORObject.WriteValue(ms, k, (long)j);\n                Assert.AreEqual(ranges[i + 2], count);\n                count = CBORObject.WriteValue(ms, k, EInteger.FromInt32(j));\n                Assert.AreEqual(ranges[i + 2], count);\n              }\n            }\n          }\n          for (int i = 0; i < bigRanges.Length; i += 2) {\n            EInteger bj = EInteger.FromString(bigRanges[i]);\n            EInteger valueBjEnd = EInteger.FromString(bigRanges[i + 1]);\n            while (bj < valueBjEnd) {\n              for (var k = 0; k <= 6; ++k) {\n                int count;\n                count = CBORObject.WriteValue(ms, k, bj);\n                Assert.AreEqual(bigSizes[i / 2], count);\n              }\n              bj += EInteger.One;\n            }\n          }\n        }\n      } catch (IOException ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(ex.ToString(), ex);\n      }\n    }\n\n    [Test]\n    public void TestKeepKeyOrder() {\n      byte[] bytes;\n      byte[] bytes2;\n      CBORObject cbor;\n      var list = new List<CBORObject>();\n      var options = new CBOREncodeOptions(\"keepkeyorder=true\");\n      Assert.IsTrue(options.KeepKeyOrder);\n      bytes = new byte[] { (byte)0xa3, 0x01, 0, 0x02, 0, 0x03, 0 };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(1), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(3), list[2]);\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n      list = new List<CBORObject>();\n      bytes = new byte[] { (byte)0xbf, 0x01, 0, 0x02, 0, 0x03, 0, 0xff };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(1), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(3), list[2]);\n      bytes = new byte[] { (byte)0xa3, 0x01, 0, 0x02, 0, 0x03, 0 };\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n      list = new List<CBORObject>();\n      bytes = new byte[] { (byte)0xa3, 0x03, 0, 0x02, 0, 0x01, 0 };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(3), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(1), list[2]);\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n      list = new List<CBORObject>();\n      bytes = new byte[] { (byte)0xbf, 0x03, 0, 0x02, 0, 0x01, 0, 0xff };\n      cbor = CBORObject.DecodeFromBytes(bytes, options);\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(3), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(2), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(1), list[2]);\n      bytes = new byte[] { (byte)0xa3, 0x03, 0, 0x02, 0, 0x01, 0 };\n      bytes2 = cbor.EncodeToBytes();\n      TestCommon.AssertByteArraysEqual(bytes, bytes2);\n\n      // JSON\n      var joptions = new JSONOptions(\"keepkeyorder=true\");\n      Assert.IsTrue(joptions.KeepKeyOrder);\n      string jsonstring;\n      jsonstring = \"{\\\"1\\\":0,\\\"2\\\":0,\\\"3\\\":0}\";\n      cbor = CBORObject.FromJSONString(jsonstring, joptions);\n      list = new List<CBORObject>();\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(\"1\"), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(\"2\"), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"3\"), list[2]);\n\n      jsonstring = \"{\\\"3\\\":0,\\\"2\\\":0,\\\"1\\\":0}\";\n      cbor = CBORObject.FromJSONString(jsonstring, joptions);\n      list = new List<CBORObject>();\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(\"3\"), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(\"2\"), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"1\"), list[2]);\n\n      jsonstring = \"{\\\"3\\\":0,\\\"2\\\":0,\\\"1\\\":0}\";\n      bytes = DataUtilities.GetUtf8Bytes(jsonstring, false);\n      cbor = CBORObject.FromJSONBytes(bytes, joptions);\n      list = new List<CBORObject>();\n      foreach (CBORObject key in cbor.Keys) {\n        list.Add(key);\n      }\n      Assert.AreEqual(CBORObject.FromObject(\"3\"), list[0]);\n      Assert.AreEqual(CBORObject.FromObject(\"2\"), list[1]);\n      Assert.AreEqual(CBORObject.FromObject(\"1\"), list[2]);\n    }\n\n    [Test]\n    public void TestWriteFloatingPointValue() {\n      var r = new RandomGenerator();\n      var bytes = new byte[] { 0, 0, 0 };\n      try {\n        for (var i = 0; i < 0x10000; ++i) {\n          bytes[0] = (byte)0xf9;\n          bytes[1] = (byte)((i >> 8) & 0xff);\n          bytes[2] = (byte)(i & 0xff);\n          CBORObject cbor = CBORObject.DecodeFromBytes(bytes);\n          if (!cbor.AsNumber().IsNaN()) {\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsDouble(),\n                2);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsSingle(),\n                2);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n          }\n        }\n        // 32-bit values\n        bytes = new byte[5];\n        for (var i = 0; i < 100000; ++i) {\n          bytes[0] = (byte)0xfa;\n          for (var j = 1; j <= 4; ++j) {\n            bytes[j] = (byte)r.UniformInt(256);\n          }\n\n          CBORObject cbor = CBORObject.DecodeFromBytes(bytes);\n          if (!cbor.AsNumber().IsNaN()) {\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsDouble(),\n                4);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsSingle(),\n                4);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n          }\n        }\n        // 64-bit values\n        bytes = new byte[9];\n        for (var i = 0; i < 100000; ++i) {\n          bytes[0] = (byte)0xfb;\n          for (var j = 1; j <= 8; ++j) {\n            bytes[j] = (byte)r.UniformInt(256);\n          }\n          CBORObject cbor = CBORObject.DecodeFromBytes(bytes);\n          if (!cbor.AsNumber().IsNaN()) {\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsDouble(),\n                8);\n              TestCommon.AssertByteArraysEqual(bytes, ms.ToArray());\n            }\n            CBORObject c2 = null;\n            byte[] c2bytes = null;\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                cbor.AsSingle(),\n                8);\n              c2bytes = ms.ToArray();\n              c2 = CBORObject.DecodeFromBytes(\n                  c2bytes);\n            }\n            using (var ms = new MemoryStream()) {\n              CBORObject.WriteFloatingPointValue(\n                ms,\n                c2.AsSingle(),\n                8);\n              TestCommon.AssertByteArraysEqual(c2bytes, ms.ToArray());\n            }\n            if (i == 0) {\n              using (var ms = new MemoryStream()) {\n                try {\n                  CBORObject.WriteFloatingPointValue(ms, cbor.AsSingle(), 5);\n                  Assert.Fail(\"Should have failed\");\n                } catch (ArgumentException) {\n                  // NOTE: Intentionally empty\n                } catch (Exception ex) {\n                  Assert.Fail(ex.ToString());\n                  throw new InvalidOperationException(String.Empty, ex);\n                }\n                try {\n                  CBORObject.WriteFloatingPointValue(null, cbor.AsSingle(), 4);\n                  Assert.Fail(\"Should have failed\");\n                } catch (ArgumentNullException) {\n                  // NOTE: Intentionally empty\n                } catch (Exception ex) {\n                  Assert.Fail(ex.ToString());\n                  throw new InvalidOperationException(String.Empty, ex);\n                }\n              }\n            }\n          }\n        }\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private static string DateTimeToString(\n      int year,\n      int month,\n      int day,\n      int hour,\n      int minute,\n      int second,\n      int millisecond) {\n      var charbuf = new char[millisecond > 0 ? 24 : 20];\n      charbuf[0] = (char)('0' + ((year / 1000) % 10));\n      charbuf[1] = (char)('0' + ((year / 100) % 10));\n      charbuf[2] = (char)('0' + ((year / 10) % 10));\n      charbuf[3] = (char)('0' + (year % 10));\n      charbuf[4] = '-';\n      charbuf[5] = (char)('0' + ((month / 10) % 10));\n      charbuf[6] = (char)('0' + (month % 10));\n      charbuf[7] = '-';\n      charbuf[8] = (char)('0' + ((day / 10) % 10));\n      charbuf[9] = (char)('0' + (day % 10));\n      charbuf[10] = 'T';\n      charbuf[11] = (char)('0' + ((hour / 10) % 10));\n      charbuf[12] = (char)('0' + (hour % 10));\n      charbuf[13] = ':';\n      charbuf[14] = (char)('0' + ((minute / 10) % 10));\n      charbuf[15] = (char)('0' + (minute % 10));\n      charbuf[16] = ':';\n      charbuf[17] = (char)('0' + ((second / 10) % 10));\n      charbuf[18] = (char)('0' + (second % 10));\n      if (millisecond > 0) {\n        charbuf[19] = '.';\n        charbuf[20] = (char)('0' + ((millisecond / 100) % 10));\n        charbuf[21] = (char)('0' + ((millisecond / 10) % 10));\n        charbuf[22] = (char)('0' + (millisecond % 10));\n        charbuf[23] = 'Z';\n      } else {\n        charbuf[19] = 'Z';\n      }\n      return new String(charbuf);\n    }\n\n    private static void TestDateTimeStringNumberOne(string str, long num) {\n      CBORObject dtstring = CBORObject.FromObject(str).WithTag(0);\n      CBORObject dtnum = CBORObject.FromObject(num).WithTag(1);\n      TestDateTimeStringNumberOne(dtstring, dtnum);\n    }\n    private static void TestDateTimeStringNumberOne(string str, double num) {\n      CBORObject dtstring = CBORObject.FromObject(str).WithTag(0);\n      CBORObject dtnum = CBORObject.FromObject(num).WithTag(1);\n      TestDateTimeStringNumberOne(dtstring, dtnum);\n    }\n    private static void TestDateTimeStringNumberOne(CBORObject dtstring,\n      CBORObject dtnum) {\n      CBORDateConverter convNumber = CBORDateConverter.TaggedNumber;\n      CBORDateConverter convString = CBORDateConverter.TaggedString;\n      CBORObject cbor;\n      var eiYear = new EInteger[1];\n      var lesserFields = new int[7];\n      string strnum = dtstring + \", \" + dtnum;\n      cbor = convNumber.ToCBORObject(convNumber.FromCBORObject(dtstring));\n      Assert.AreEqual(dtnum, cbor, strnum);\n      if (!convNumber.TryGetDateTimeFields(dtstring, eiYear, lesserFields)) {\n        Assert.Fail(strnum);\n      }\n      cbor = convNumber.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtnum, cbor, strnum);\n      cbor = convString.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtstring, cbor, strnum);\n      cbor = convString.ToCBORObject(convString.FromCBORObject(dtnum));\n      Assert.AreEqual(dtstring, cbor, strnum);\n      if (!convString.TryGetDateTimeFields(dtnum, eiYear, lesserFields)) {\n        Assert.Fail(strnum);\n      }\n      cbor = convNumber.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtnum, cbor, strnum);\n      cbor = convString.DateTimeFieldsToCBORObject(eiYear[0], lesserFields);\n      Assert.AreEqual(dtstring, cbor, strnum);\n    }\n\n    [Test]\n    public void TestDateTimeStringNumber() {\n      TestDateTimeStringNumberOne(\"1970-01-01T00:00:00.25Z\", 0.25);\n      TestDateTimeStringNumberOne(\"1970-01-01T00:00:00.75Z\", 0.75);\n      TestDateTimeStringNumberOne(\"1969-12-31T23:59:59.75Z\", -0.25);\n      TestDateTimeStringNumberOne(\"1969-12-31T23:59:59.25Z\", -0.75);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:00Z\", 172800);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:00Z\", 172800);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:00Z\", 172800);\n      TestDateTimeStringNumberOne(\"2001-01-03T00:00:00Z\", 978480000);\n      TestDateTimeStringNumberOne(\"2001-01-03T00:00:00.25Z\", 978480000.25);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:00Z\", -315446400);\n      TestDateTimeStringNumberOne(\"1400-01-03T00:00:00Z\", -17987270400L);\n      TestDateTimeStringNumberOne(\"2100-01-03T00:00:00Z\", 4102617600L);\n      TestDateTimeStringNumberOne(\"1970-01-03T00:00:01Z\", 172801);\n      TestDateTimeStringNumberOne(\"2001-01-03T00:00:01Z\", 978480001);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:01Z\", -315446399);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:00.25Z\", -315446399.75);\n      TestDateTimeStringNumberOne(\"1960-01-03T00:00:00.75Z\", -315446399.25);\n      TestDateTimeStringNumberOne(\"1400-01-03T00:00:01Z\", -17987270399L);\n      TestDateTimeStringNumberOne(\"2100-01-03T00:00:01Z\", 4102617601L);\n    }\n\n    public static void TestApplyJSONPatchOpAdd(\n      CBORObject expected,\n      CBORObject src,\n      string path,\n      object obj) {\n      CBORObject patch = CBORObject.NewMap().Add(\"op\", \"add\")\n        .Add(\"path\", path).Add(\"value\", CBORObject.FromObject(obj));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(expected, src, patch);\n    }\n\n    public void TestApplyJSONPatchOpReplace(\n      CBORObject expected,\n      CBORObject src,\n      string path,\n      object obj) {\n      CBORObject patch = CBORObject.NewMap().Add(\"op\", \"replace\")\n        .Add(\"path\", path).Add(\"value\", CBORObject.FromObject(obj));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(expected, src, patch);\n    }\n\n    public static void TestApplyJSONPatchOpRemove(\n      CBORObject expected,\n      CBORObject src,\n      string path) {\n      CBORObject patch = CBORObject.NewMap().Add(\"op\", \"remove\")\n        .Add(\"path\", path);\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(expected, src, patch);\n    }\n\n    public static void TestApplyJSONPatchOp(\n      CBORObject expected,\n      CBORObject src,\n      CBORObject patch) {\n      CBORObject actual = CBORObject.DecodeFromBytes(src.EncodeToBytes());\n      if (expected == null) {\n        try {\n          actual.ApplyJSONPatch(patch);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          throw new InvalidOperationException(ex.ToString() + \"\\n\" + patch);\n        }\n      } else {\n        try {\n          byte[] oldactualbytes = actual.EncodeToBytes();\n          CBORObject oldactual = actual;\n          actual = actual.ApplyJSONPatch(patch);\n          byte[] newactualbytes = oldactual.EncodeToBytes();\n          // Check whether the patch didn't change the existing object\n          TestCommon.AssertByteArraysEqual(oldactualbytes, newactualbytes);\n        } catch (Exception ex) {\n          throw new InvalidOperationException(ex.ToString() + \"\\n\" + patch);\n        }\n        Assert.AreEqual(expected, actual);\n      }\n    }\n\n    public static void TestApplyJSONPatchJSONTestsCore(string patchTests) {\n      CBORObject tests = CBORObject.FromJSONString(patchTests,\n          new JSONOptions(\"allowduplicatekeys=1\"));\n      foreach (CBORObject testcbor in tests.Values) {\n        if (testcbor.GetOrDefault(\"disabled\", CBORObject.False).AsBoolean()) {\n          continue;\n        }\n        string err = testcbor.GetOrDefault(\"error\",\n            CBORObject.FromObject(String.Empty)).AsString();\n        string comment = testcbor.GetOrDefault(\"comment\",\n            CBORObject.FromObject(String.Empty)).AsString();\n        try {\n          if (testcbor.ContainsKey(\"error\")) {\n            TestApplyJSONPatchOp(null, testcbor[\"doc\"], testcbor[\"patch\"]);\n          } else {\n            TestApplyJSONPatchOp(\n              testcbor[\"expected\"],\n              testcbor[\"doc\"],\n              testcbor[\"patch\"]);\n          }\n        } catch (Exception ex) {\n          string exmsg = ex.GetType() + \"\\n\" + comment + \"\\n\" + err;\n          throw new InvalidOperationException(exmsg, ex);\n        }\n      }\n    }\n\n    [Test]\n    public void TestApplyJSONPatchTest() {\n      CBORObject patch;\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\",\n          CBORObject.NewArray().Add(1).Add(2));\n      patch = CBORObject.NewArray().Add(patch);\n      CBORObject exp;\n      exp = CBORObject.NewArray().Add(1).Add(2);\n      TestApplyJSONPatchOp(exp, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\",\n          CBORObject.NewArray().Add(1).Add(3));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\",\n          CBORObject.NewArray().Add(2).Add(2));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\", CBORObject.NewMap().Add(2,\n            2));\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\", CBORObject.True);\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n      patch = CBORObject.NewMap().Add(\"op\", \"test\")\n        .Add(\"path\", String.Empty).Add(\"value\", CBORObject.Null);\n      patch = CBORObject.NewArray().Add(patch);\n      TestApplyJSONPatchOp(null, exp, patch);\n    }\n\n    [Test]\n    public void TestApplyJSONPatch() {\n      // TODO: Finish tests for ApplyJSONPatch\n      CBORObject patch;\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"ADD\").Add(\"path\", \"/0\").Add(\"value\",\n            3));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"RePlAcE\").Add(\"path\",\n            \"/0\").Add(\"value\", 3));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"unknown\").Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", String.Empty)\n          .Add(\"value\", CBORObject.True));\n      TestApplyJSONPatchOp(\n        CBORObject.True,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", String.Empty)\n          .Add(\"value\", CBORObject.NewMap()));\n      TestApplyJSONPatchOp(\n        CBORObject.NewMap(),\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"path\", null).Add(\"value\",\n            2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"add\").Add(\"value\", 2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"remove\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"remove\").Add(\"value\", 2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"replace\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"replace\").Add(\"valuuuuu\", 2));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n      patch = CBORObject.NewArray().Add(\n          CBORObject.NewMap().Add(\"op\", \"replace\").Add(\"path\", \"/0\"));\n      TestApplyJSONPatchOp(\n        null,\n        CBORObject.NewArray().Add(1),\n        patch);\n\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewArray().Add(1).Add(3),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/1\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewArray().Add(3).Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/0\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/00\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/00000\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", 3),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f3\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        CBORObject.NewMap().Add(\"f1\", 3).Add(\"f3\", \"f4\"),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/foo\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/xyz\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/0\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/-\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/-\",\n        3);\n      this.TestApplyJSONPatchOpReplace(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/foo\",\n        3);\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewArray().Add(1),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/1\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/01\");\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewArray().Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/0\");\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewMap().Add(\"f1\", \"f2\"),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f3\");\n      TestApplyJSONPatchOpRemove(\n        CBORObject.NewMap().Add(\"f3\", \"f4\"),\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/foo\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/xyz\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/f1/\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/0\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewMap().Add(\"f1\", \"f2\").Add(\"f3\", \"f4\"),\n        \"/-\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/-\");\n      TestApplyJSONPatchOpRemove(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/foo\");\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1),\n        CBORObject.NewArray(),\n        \"/-\",\n        1);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1),\n        CBORObject.NewArray(),\n        \"/0\",\n        1);\n      TestApplyJSONPatchOpAdd(\n        null,\n        CBORObject.NewArray(),\n        \"/1\",\n        1);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1).Add(2),\n        CBORObject.NewArray().Add(1),\n        \"/-\",\n        2);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(0).Add(1).Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/0\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1).Add(0).Add(2),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/1\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewArray().Add(1).Add(2).Add(0),\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/2\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/3\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        null,\n        CBORObject.NewArray().Add(1).Add(2),\n        \"/foo\",\n        0);\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewMap().Add(\"foo\", \"bar\"),\n        CBORObject.NewMap(),\n        \"/foo\",\n        \"bar\");\n      TestApplyJSONPatchOpAdd(\n        CBORObject.NewMap().Add(\"foo\", \"baz\"),\n        CBORObject.NewMap().Add(\"foo\", \"bar\"),\n        \"/foo\",\n        \"baz\");\n    }\n\n    [Test]\n    public void TestAtJSONPointer() {\n      CBORObject cbor;\n      cbor = CBORObject.FromObject(\"xyz\");\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.FromObject(0);\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.FromObject(0.5);\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap();\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewArray();\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor.Add(3);\n      Assert.AreEqual(cbor[0], cbor.AtJSONPointer(\"/0\"));\n      try {\n        cbor.AtJSONPointer(\"/1\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/-\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"foo\", 0);\n      Assert.AreEqual(cbor, cbor.AtJSONPointer(String.Empty));\n      try {\n        cbor.AtJSONPointer(null);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      Assert.AreEqual(cbor[\"foo\"], cbor.AtJSONPointer(\"/foo\"));\n      try {\n        cbor.AtJSONPointer(\"/bar\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"f~o\", 0);\n      Assert.AreEqual(cbor[\"f~o\"], cbor.AtJSONPointer(\"/f~0o\"));\n      cbor = CBORObject.NewMap().Add(\"f~0o\", 0);\n      Assert.AreEqual(cbor[\"f~0o\"], cbor.AtJSONPointer(\"/f~00o\"));\n      cbor = CBORObject.NewMap().Add(\"f~1o\", 0);\n      Assert.AreEqual(cbor[\"f~1o\"], cbor.AtJSONPointer(\"/f~01o\"));\n      cbor = CBORObject.NewMap().Add(\"f/o\", 0);\n      Assert.AreEqual(cbor[\"f/o\"], cbor.AtJSONPointer(\"/f~1o\"));\n      cbor = CBORObject.NewMap().Add(\"foo\", CBORObject.NewMap().Add(\"bar\",\n            345));\n\n      Assert.AreEqual(\n        CBORObject.FromObject(345),\n        cbor.AtJSONPointer(\"/foo/bar\"));\n      cbor = CBORObject.NewMap().Add(\"foo\", CBORObject.NewArray().Add(678));\n      Assert.AreEqual(CBORObject.FromObject(678), cbor.AtJSONPointer(\"/foo/0\"));\n      try {\n        cbor.AtJSONPointer(\"/foo/1\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo/-\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        cbor.AtJSONPointer(\"/foo/-1\");\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      cbor = CBORObject.NewMap().Add(\"-\", 0);\n      Assert.AreEqual(cbor[\"-\"], cbor.AtJSONPointer(\"/-\"));\n      cbor = CBORObject.NewMap().Add(String.Empty, 0);\n      Assert.AreEqual(cbor[String.Empty], cbor.AtJSONPointer(\"/\"));\n    }\n\n    [Test]\n    public void TestDateTime() {\n      var dateList = new List<string>();\n      dateList.Add(\"0783-08-19T03:10:29.406Z\");\n      dateList.Add(\"1954-03-07T16:20:38.256Z\");\n      var rng = new RandomGenerator();\n      for (var i = 0; i < 2000; ++i) {\n        string dtstr = DateTimeToString(\n            rng.UniformInt(9999) + 1,\n            rng.UniformInt(12) + 1,\n            rng.UniformInt(28) + 1,\n            rng.UniformInt(24),\n            rng.UniformInt(60),\n            rng.UniformInt(60),\n            rng.UniformInt(1000));\n        dateList.Add(dtstr);\n      }\n      foreach (string dtstr in dateList) {\n        CBORObject cbor = CBORObject.FromObjectAndTag(dtstr, 0);\n        var dt = (DateTime)cbor.ToObject(typeof(DateTime));\n        ToObjectTest.TestToFromObjectRoundTrip(dt);\n      }\n    }\n\n    public static void TestDateTimeTag1One(string str, long timeValue) {\n      TestDateTimeTag1One(str, EInteger.FromInt64(timeValue));\n    }\n\n    public static void TestDateTimeTag1One(string str, EInteger ei) {\n      CBORObject cbornum;\n      cbornum = CBORObject.FromObjectAndTag(str, 0);\n      var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx);\n      cbornum = CBORObject.FromObjectAndTag(ei, 1);\n      var dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      TestCommon.AssertEqualsHashCode(dtx, dtx2);\n      if (ei == null) {\n        throw new ArgumentNullException(nameof(ei));\n      }\n      if (ei.CanFitInInt64()) {\n        cbornum = CBORObject.FromObjectAndTag(ei.ToInt64Checked(), 1);\n        dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n        TestCommon.AssertEqualsHashCode(dtx, dtx2);\n        ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      }\n      EFloat ef1 = EFloat.FromEInteger(ei).Plus(EContext.Binary64);\n      EFloat ef2 = EFloat.FromEInteger(ei);\n      if (ef1.CompareTo(ef2) == 0) {\n        cbornum = CBORObject.FromObjectAndTag(ef1, 1);\n        dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n        TestCommon.AssertEqualsHashCode(dtx, dtx2);\n        ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n        cbornum = CBORObject.FromObjectAndTag(ef1.ToDouble(), 1);\n        dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n        TestCommon.AssertEqualsHashCode(dtx, dtx2);\n        ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      }\n    }\n\n    public static void TestDateTimeTag1One(string str, double dbl) {\n      CBORObject cbornum;\n      cbornum = CBORObject.FromObjectAndTag(str, 0);\n      var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx);\n      cbornum = CBORObject.FromObjectAndTag(dbl, 1);\n      var dtx2 = (DateTime)cbornum.ToObject(typeof(DateTime));\n      ToObjectTest.TestToFromObjectRoundTrip(dtx2);\n      TestCommon.AssertEqualsHashCode(dtx, dtx2);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestDateTimeTag1Specific1() {\n      // Test speed\n      EInteger ei = EInteger.FromString(\"-14261178672295354872\");\n      CBORObject cbornum = CBORObject.FromObjectAndTag(ei, 1);\n      try {\n        var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n        ToObjectTest.TestToFromObjectRoundTrip(dtx);\n      } catch (CBORException) {\n        Console.WriteLine(\"Not supported: \" + ei);\n      }\n    }\n\n    [Test]\n    public void TestDateTimeSpecific2() {\n      TestDateTimeTag1One(\"1758-09-28T23:25:24Z\", -6666626076L);\n      TestDateTimeTag1One(\"1758-09-28T23:25:24.000Z\", -6666626076L);\n      TestDateTimeTag1One(\"1758-09-28T23:25:24.500Z\", -6666626075.5);\n      TestDateTimeTag1One(\"2325-11-08T01:47:40Z\", 11229587260L);\n      TestDateTimeTag1One(\"2325-11-08T01:47:40.000Z\", 11229587260L);\n      TestDateTimeTag1One(\"2325-11-08T01:47:40.500Z\", 11229587260.5);\n      TestDateTimeTag1One(\"1787-03-04T10:21:24Z\", -5769495516L);\n      TestDateTimeTag1One(\"1787-03-04T10:21:24.000Z\", -5769495516L);\n      TestDateTimeTag1One(\"1787-03-04T10:21:24.500Z\", -5769495515.5);\n      TestDateTimeTag1One(\"1828-11-17T11:59:01Z\", -4453358459L);\n      TestDateTimeTag1One(\"1828-11-17T11:59:01.000Z\", -4453358459L);\n      TestDateTimeTag1One(\"1828-11-17T11:59:01.500Z\", -4453358458.5);\n      TestDateTimeTag1One(\"2379-01-22T01:20:02Z\", 12908596802L);\n      TestDateTimeTag1One(\"2379-01-22T01:20:02.000Z\", 12908596802L);\n      TestDateTimeTag1One(\"1699-05-31T22:37:24Z\", -8538830556L);\n      TestDateTimeTag1One(\"1699-05-31T22:37:24.000Z\", -8538830556L);\n      TestDateTimeTag1One(\"1699-05-31T22:37:24.500Z\", -8538830555.5);\n      TestDateTimeTag1One(\"2248-02-13T03:16:17Z\", 8776523777L);\n      TestDateTimeTag1One(\"2248-02-13T03:16:17.000Z\", 8776523777L);\n      TestDateTimeTag1One(\"2248-02-13T03:16:17.500Z\", 8776523777.5);\n      TestDateTimeTag1One(\"2136-04-15T16:45:29Z\", 5247564329L);\n      TestDateTimeTag1One(\"2136-04-15T16:45:29.000Z\", 5247564329L);\n      TestDateTimeTag1One(\"1889-09-05T00:23:45Z\", -2534715375L);\n      TestDateTimeTag1One(\"1889-09-05T00:23:45.000Z\", -2534715375L);\n      TestDateTimeTag1One(\"1889-09-05T00:23:45.500Z\", -2534715374.5);\n      TestDateTimeTag1One(\"2095-08-13T20:04:08Z\", 3964104248L);\n      TestDateTimeTag1One(\"2095-08-13T20:04:08.000Z\", 3964104248L);\n      TestDateTimeTag1One(\"2095-08-13T20:04:08.500Z\", 3964104248.5);\n      TestDateTimeTag1One(\"2475-03-27T17:41:48Z\", 15943714908L);\n      TestDateTimeTag1One(\"2475-03-27T17:41:48.000Z\", 15943714908L);\n      TestDateTimeTag1One(\"2475-03-27T17:41:48.500Z\", 15943714908.5);\n      TestDateTimeTag1One(\"1525-11-18T07:47:54Z\", -14015088726L);\n      TestDateTimeTag1One(\"1525-11-18T07:47:54.000Z\", -14015088726L);\n      TestDateTimeTag1One(\"2353-01-12T09:36:32Z\", 12087308192L);\n      TestDateTimeTag1One(\"2353-01-12T09:36:32.000Z\", 12087308192L);\n      TestDateTimeTag1One(\"2353-01-12T09:36:32.500Z\", 12087308192.5);\n      TestDateTimeTag1One(\"2218-11-29T08:23:31Z\", 7854827011L);\n      TestDateTimeTag1One(\"2218-11-29T08:23:31.000Z\", 7854827011L);\n      TestDateTimeTag1One(\"2377-08-21T09:44:12Z\", 12863785452L);\n      TestDateTimeTag1One(\"2377-08-21T09:44:12.000Z\", 12863785452L);\n      TestDateTimeTag1One(\"2377-08-21T09:44:12.500Z\", 12863785452.5);\n      TestDateTimeTag1One(\"1530-09-02T02:13:52Z\", -13863995168L);\n      TestDateTimeTag1One(\"1530-09-02T02:13:52.000Z\", -13863995168L);\n      TestDateTimeTag1One(\"1530-09-02T02:13:52.500Z\", -13863995167.5);\n      TestDateTimeTag1One(\"2319-03-11T18:18:48Z\", 11019349128L);\n      TestDateTimeTag1One(\"2319-03-11T18:18:48.000Z\", 11019349128L);\n      TestDateTimeTag1One(\"2319-03-11T18:18:48.500Z\", 11019349128.5);\n      TestDateTimeTag1One(\"1602-12-05T09:36:58Z\", -11583699782L);\n      TestDateTimeTag1One(\"1602-12-05T09:36:58.000Z\", -11583699782L);\n      TestDateTimeTag1One(\"1874-01-25T21:14:10Z\", -3027293150L);\n      TestDateTimeTag1One(\"1874-01-25T21:14:10.000Z\", -3027293150L);\n      TestDateTimeTag1One(\"1874-01-25T21:14:10.500Z\", -3027293149.5);\n      TestDateTimeTag1One(\"1996-02-26T04:09:49Z\", 825307789L);\n      TestDateTimeTag1One(\"1996-02-26T04:09:49.000Z\", 825307789L);\n      TestDateTimeTag1One(\"1996-02-26T04:09:49.500Z\", 825307789.5);\n      TestDateTimeTag1One(\"2113-11-27T22:16:09Z\", 4541264169L);\n      TestDateTimeTag1One(\"2113-11-27T22:16:09.000Z\", 4541264169L);\n      TestDateTimeTag1One(\"2113-11-27T22:16:09.500Z\", 4541264169.5);\n      TestDateTimeTag1One(\"1612-01-07T16:25:51Z\", -11296827249L);\n      TestDateTimeTag1One(\"1612-01-07T16:25:51.000Z\", -11296827249L);\n      TestDateTimeTag1One(\"1612-01-07T16:25:51.500Z\", -11296827248.5);\n      TestDateTimeTag1One(\"2077-12-08T22:15:00Z\", 3406227300L);\n      TestDateTimeTag1One(\"2077-12-08T22:15:00.000Z\", 3406227300L);\n      TestDateTimeTag1One(\"2077-12-08T22:15:00.500Z\", 3406227300.5);\n      TestDateTimeTag1One(\"1820-07-06T12:06:08Z\", -4717396432L);\n      TestDateTimeTag1One(\"1820-07-06T12:06:08.000Z\", -4717396432L);\n      TestDateTimeTag1One(\"1820-07-06T12:06:08.500Z\", -4717396431.5);\n      TestDateTimeTag1One(\"1724-01-17T16:42:20Z\", -7761597460L);\n      TestDateTimeTag1One(\"1724-01-17T16:42:20.000Z\", -7761597460L);\n      TestDateTimeTag1One(\"1724-01-17T16:42:20.500Z\", -7761597459.5);\n      TestDateTimeTag1One(\"2316-03-11T00:46:54Z\", 10924678014L);\n      TestDateTimeTag1One(\"2316-03-11T00:46:54.000Z\", 10924678014L);\n      TestDateTimeTag1One(\"2495-07-18T22:11:29Z\", 16584646289L);\n      TestDateTimeTag1One(\"2495-07-18T22:11:29.000Z\", 16584646289L);\n      TestDateTimeTag1One(\"2495-07-18T22:11:29.500Z\", 16584646289.5);\n      TestDateTimeTag1One(\"1874-04-25T08:52:46Z\", -3019561634L);\n      TestDateTimeTag1One(\"1874-04-25T08:52:46.000Z\", -3019561634L);\n      TestDateTimeTag1One(\"1874-04-25T08:52:46.500Z\", -3019561633.5);\n      TestDateTimeTag1One(\"2226-05-18T19:38:50Z\", 8090480330L);\n      TestDateTimeTag1One(\"2226-05-18T19:38:50.000Z\", 8090480330L);\n      TestDateTimeTag1One(\"2226-05-18T19:38:50.500Z\", 8090480330.5);\n      TestDateTimeTag1One(\"2108-06-26T09:01:48Z\", 4370144508L);\n      TestDateTimeTag1One(\"2108-06-26T09:01:48.000Z\", 4370144508L);\n      TestDateTimeTag1One(\"2108-06-26T09:01:48.500Z\", 4370144508.5);\n      TestDateTimeTag1One(\"1955-10-03T06:06:55Z\", -449603585L);\n      TestDateTimeTag1One(\"1955-10-03T06:06:55.000Z\", -449603585L);\n      TestDateTimeTag1One(\"1955-10-03T06:06:55.500Z\", -449603584.5);\n      TestDateTimeTag1One(\"1906-03-26T17:32:58Z\", -2012365622L);\n      TestDateTimeTag1One(\"1906-03-26T17:32:58.000Z\", -2012365622L);\n      TestDateTimeTag1One(\"1906-03-26T17:32:58.500Z\", -2012365621.5);\n      TestDateTimeTag1One(\"1592-03-10T03:46:03Z\", -11922581637L);\n      TestDateTimeTag1One(\"1592-03-10T03:46:03.000Z\", -11922581637L);\n      TestDateTimeTag1One(\"1592-03-10T03:46:03.500Z\", -11922581636.5);\n      TestDateTimeTag1One(\"2433-12-19T01:24:19Z\", 14641349059L);\n      TestDateTimeTag1One(\"2433-12-19T01:24:19.000Z\", 14641349059L);\n      TestDateTimeTag1One(\"2433-12-19T01:24:19.500Z\", 14641349059.5);\n      TestDateTimeTag1One(\"1802-02-07T09:43:23Z\", -5298358597L);\n      TestDateTimeTag1One(\"1802-02-07T09:43:23.000Z\", -5298358597L);\n      TestDateTimeTag1One(\"2318-04-11T20:11:23Z\", 10990498283L);\n      TestDateTimeTag1One(\"2318-04-11T20:11:23.000Z\", 10990498283L);\n      TestDateTimeTag1One(\"2318-04-11T20:11:23.500Z\", 10990498283.5);\n      TestDateTimeTag1One(\"2083-01-06T11:06:22Z\", 3566459182L);\n      TestDateTimeTag1One(\"2083-01-06T11:06:22.000Z\", 3566459182L);\n      TestDateTimeTag1One(\"2083-01-06T11:06:22.500Z\", 3566459182.5);\n      TestDateTimeTag1One(\"1561-08-16T19:31:48Z\", -12887094492L);\n      TestDateTimeTag1One(\"1561-08-16T19:31:48.000Z\", -12887094492L);\n      TestDateTimeTag1One(\"1561-08-16T19:31:48.500Z\", -12887094491.5);\n      TestDateTimeTag1One(\"2475-11-05T21:20:03Z\", 15962995203L);\n      TestDateTimeTag1One(\"2475-11-05T21:20:03.000Z\", 15962995203L);\n      TestDateTimeTag1One(\"2475-11-05T21:20:03.500Z\", 15962995203.5);\n      TestDateTimeTag1One(\"2209-05-13T09:31:56Z\", 7553554316L);\n      TestDateTimeTag1One(\"2209-05-13T09:31:56.000Z\", 7553554316L);\n      TestDateTimeTag1One(\"2209-05-13T09:31:56.500Z\", 7553554316.5);\n      TestDateTimeTag1One(\"1943-06-25T19:09:49Z\", -836887811L);\n      TestDateTimeTag1One(\"1943-06-25T19:09:49.000Z\", -836887811L);\n      TestDateTimeTag1One(\"1943-06-25T19:09:49.500Z\", -836887810.5);\n      TestDateTimeTag1One(\"1751-09-18T07:31:00Z\", -6888472140L);\n      TestDateTimeTag1One(\"1751-09-18T07:31:00.000Z\", -6888472140L);\n      TestDateTimeTag1One(\"1751-09-18T07:31:00.500Z\", -6888472139.5);\n      TestDateTimeTag1One(\"1538-05-07T23:40:25Z\", -13621652375L);\n      TestDateTimeTag1One(\"1538-05-07T23:40:25.000Z\", -13621652375L);\n      TestDateTimeTag1One(\"1538-05-07T23:40:25.500Z\", -13621652374.5);\n      TestDateTimeTag1One(\"1628-02-10T00:07:33Z\", -10789026747L);\n      TestDateTimeTag1One(\"1628-02-10T00:07:33.000Z\", -10789026747L);\n      TestDateTimeTag1One(\"1628-02-10T00:07:33.500Z\", -10789026746.5);\n      TestDateTimeTag1One(\"1584-08-23T09:30:49Z\", -12160679351L);\n      TestDateTimeTag1One(\"1584-08-23T09:30:49.000Z\", -12160679351L);\n      TestDateTimeTag1One(\"1584-08-23T09:30:49.500Z\", -12160679350.5);\n      TestDateTimeTag1One(\"2230-08-28T23:13:43Z\", 8225536423L);\n      TestDateTimeTag1One(\"2230-08-28T23:13:43.000Z\", 8225536423L);\n      TestDateTimeTag1One(\"1846-02-19T20:02:33Z\", -3908750247L);\n      TestDateTimeTag1One(\"1846-02-19T20:02:33.000Z\", -3908750247L);\n      TestDateTimeTag1One(\"1846-02-19T20:02:33.500Z\", -3908750246.5);\n      TestDateTimeTag1One(\"2114-07-28T00:06:13Z\", 4562179573L);\n      TestDateTimeTag1One(\"2114-07-28T00:06:13.000Z\", 4562179573L);\n      TestDateTimeTag1One(\"2114-07-28T00:06:13.500Z\", 4562179573.5);\n      TestDateTimeTag1One(\"1855-04-03T15:29:33Z\", -3621054627L);\n      TestDateTimeTag1One(\"1855-04-03T15:29:33.000Z\", -3621054627L);\n      TestDateTimeTag1One(\"1855-04-03T15:29:33.500Z\", -3621054626.5);\n      TestDateTimeTag1One(\"1532-02-04T13:08:22Z\", -13819027898L);\n      TestDateTimeTag1One(\"1532-02-04T13:08:22.000Z\", -13819027898L);\n      TestDateTimeTag1One(\"2285-12-28T16:35:29Z\", 9971742929L);\n      TestDateTimeTag1One(\"2285-12-28T16:35:29.000Z\", 9971742929L);\n      TestDateTimeTag1One(\"2285-12-28T16:35:29.500Z\", 9971742929.5);\n      TestDateTimeTag1One(\"1784-08-08T15:25:01Z\", -5850520499L);\n      TestDateTimeTag1One(\"1784-08-08T15:25:01.000Z\", -5850520499L);\n      TestDateTimeTag1One(\"2190-06-25T10:55:10Z\", 6957744910L);\n      TestDateTimeTag1One(\"2190-06-25T10:55:10.000Z\", 6957744910L);\n      TestDateTimeTag1One(\"2190-06-25T10:55:10.500Z\", 6957744910.5);\n      TestDateTimeTag1One(\"2263-10-08T20:28:28Z\", 9270448108L);\n      TestDateTimeTag1One(\"2263-10-08T20:28:28.000Z\", 9270448108L);\n      TestDateTimeTag1One(\"2263-10-08T20:28:28.500Z\", 9270448108.5);\n      TestDateTimeTag1One(\"2036-05-12T10:02:45Z\", 2094199365L);\n      TestDateTimeTag1One(\"2036-05-12T10:02:45.000Z\", 2094199365L);\n      TestDateTimeTag1One(\"2036-05-12T10:02:45.500Z\", 2094199365.5);\n      TestDateTimeTag1One(\"2166-09-08T09:25:14Z\", 6206837114L);\n      TestDateTimeTag1One(\"2166-09-08T09:25:14.000Z\", 6206837114L);\n      TestDateTimeTag1One(\"2166-09-08T09:25:14.500Z\", 6206837114.5);\n      TestDateTimeTag1One(\"1698-12-30T18:31:11Z\", -8551978129L);\n      TestDateTimeTag1One(\"1698-12-30T18:31:11.000Z\", -8551978129L);\n      TestDateTimeTag1One(\"1780-10-16T15:02:56Z\", -5970790624L);\n      TestDateTimeTag1One(\"1780-10-16T15:02:56.000Z\", -5970790624L);\n      TestDateTimeTag1One(\"1780-10-16T15:02:56.500Z\", -5970790623.5);\n      TestDateTimeTag1One(\"1710-10-12T20:07:58Z\", -8180193122L);\n      TestDateTimeTag1One(\"1710-10-12T20:07:58.000Z\", -8180193122L);\n      TestDateTimeTag1One(\"1710-10-12T20:07:58.500Z\", -8180193121.5);\n      TestDateTimeTag1One(\"2034-09-28T04:45:04Z\", 2043031504L);\n      TestDateTimeTag1One(\"2034-09-28T04:45:04.000Z\", 2043031504L);\n      TestDateTimeTag1One(\"2034-09-28T04:45:04.500Z\", 2043031504.5);\n      TestDateTimeTag1One(\"1801-12-10T15:45:47Z\", -5303434453L);\n      TestDateTimeTag1One(\"1801-12-10T15:45:47.000Z\", -5303434453L);\n      TestDateTimeTag1One(\"1537-08-24T13:13:09Z\", -13643808411L);\n      TestDateTimeTag1One(\"1537-08-24T13:13:09.000Z\", -13643808411L);\n      TestDateTimeTag1One(\"1537-08-24T13:13:09.500Z\", -13643808410.5);\n      TestDateTimeTag1One(\"2249-09-24T21:07:14Z\", 8827477634L);\n      TestDateTimeTag1One(\"2249-09-24T21:07:14.000Z\", 8827477634L);\n      TestDateTimeTag1One(\"2249-09-24T21:07:14.500Z\", 8827477634.5);\n      TestDateTimeTag1One(\"2137-11-27T05:22:38Z\", 5298585758L);\n      TestDateTimeTag1One(\"2137-11-27T05:22:38.000Z\", 5298585758L);\n      TestDateTimeTag1One(\"2137-11-27T05:22:38.500Z\", 5298585758.5);\n      TestDateTimeTag1One(\"2123-07-31T13:09:34Z\", 4846482574L);\n      TestDateTimeTag1One(\"2123-07-31T13:09:34.000Z\", 4846482574L);\n      TestDateTimeTag1One(\"2123-07-31T13:09:34.500Z\", 4846482574.5);\n      TestDateTimeTag1One(\"2242-01-31T12:14:20Z\", 8586130460L);\n      TestDateTimeTag1One(\"2242-01-31T12:14:20.000Z\", 8586130460L);\n      TestDateTimeTag1One(\"2242-01-31T12:14:20.500Z\", 8586130460.5);\n      TestDateTimeTag1One(\"2232-11-04T21:12:33Z\", 8294562753L);\n      TestDateTimeTag1One(\"2232-11-04T21:12:33.000Z\", 8294562753L);\n      TestDateTimeTag1One(\"1590-12-06T04:30:48Z\", -11962322952L);\n      TestDateTimeTag1One(\"1590-12-06T04:30:48.000Z\", -11962322952L);\n      TestDateTimeTag1One(\"1590-12-06T04:30:48.500Z\", -11962322951.5);\n      TestDateTimeTag1One(\"1910-05-16T17:54:04Z\", -1881727556L);\n      TestDateTimeTag1One(\"1910-05-16T17:54:04.000Z\", -1881727556L);\n      TestDateTimeTag1One(\"1910-05-16T17:54:04.500Z\", -1881727555.5);\n      TestDateTimeTag1One(\"2482-06-15T23:28:00Z\", 16171572480L);\n      TestDateTimeTag1One(\"2482-06-15T23:28:00.000Z\", 16171572480L);\n      TestDateTimeTag1One(\"2482-06-15T23:28:00.500Z\", 16171572480.5);\n      TestDateTimeTag1One(\"1808-01-17T13:11:23Z\", -5110858117L);\n      TestDateTimeTag1One(\"1808-01-17T13:11:23.000Z\", -5110858117L);\n      TestDateTimeTag1One(\"1872-05-04T12:15:05Z\", -3081843895L);\n      TestDateTimeTag1One(\"1872-05-04T12:15:05.000Z\", -3081843895L);\n      TestDateTimeTag1One(\"1872-05-04T12:15:05.500Z\", -3081843894.5);\n      TestDateTimeTag1One(\"1719-05-18T16:44:33Z\", -7908909327L);\n      TestDateTimeTag1One(\"1719-05-18T16:44:33.000Z\", -7908909327L);\n      TestDateTimeTag1One(\"2137-05-26T02:17:32Z\", 5282590652L);\n      TestDateTimeTag1One(\"2137-05-26T02:17:32.000Z\", 5282590652L);\n      TestDateTimeTag1One(\"2137-05-26T02:17:32.500Z\", 5282590652.5);\n      TestDateTimeTag1One(\"1714-06-15T13:41:14Z\", -8064267526L);\n      TestDateTimeTag1One(\"1714-06-15T13:41:14.000Z\", -8064267526L);\n      TestDateTimeTag1One(\"1714-06-15T13:41:14.500Z\", -8064267525.5);\n      TestDateTimeTag1One(\"1878-12-03T20:14:03Z\", -2874109557L);\n      TestDateTimeTag1One(\"1878-12-03T20:14:03.000Z\", -2874109557L);\n      TestDateTimeTag1One(\"1878-12-03T20:14:03.500Z\", -2874109556.5);\n      TestDateTimeTag1One(\"2190-11-26T23:45:55Z\", 6971096755L);\n      TestDateTimeTag1One(\"2190-11-26T23:45:55.000Z\", 6971096755L);\n      TestDateTimeTag1One(\"2020-01-22T15:58:52Z\", 1579708732L);\n      TestDateTimeTag1One(\"2020-01-22T15:58:52.000Z\", 1579708732L);\n      TestDateTimeTag1One(\"2020-01-22T15:58:52.500Z\", 1579708732.5);\n      TestDateTimeTag1One(\"2245-10-06T15:40:51Z\", 8702264451L);\n      TestDateTimeTag1One(\"2245-10-06T15:40:51.000Z\", 8702264451L);\n      TestDateTimeTag1One(\"2245-10-06T15:40:51.500Z\", 8702264451.5);\n      TestDateTimeTag1One(\"1647-08-10T21:26:16Z\", -10173695624L);\n      TestDateTimeTag1One(\"1647-08-10T21:26:16.000Z\", -10173695624L);\n      TestDateTimeTag1One(\"1647-08-10T21:26:16.500Z\", -10173695623.5);\n      TestDateTimeTag1One(\"1628-11-10T01:03:36Z\", -10765349784L);\n      TestDateTimeTag1One(\"1628-11-10T01:03:36.000Z\", -10765349784L);\n      TestDateTimeTag1One(\"1628-11-10T01:03:36.500Z\", -10765349783.5);\n      TestDateTimeTag1One(\"2359-11-30T16:24:04Z\", 12304455844L);\n      TestDateTimeTag1One(\"2359-11-30T16:24:04.000Z\", 12304455844L);\n      TestDateTimeTag1One(\"2359-11-30T16:24:04.500Z\", 12304455844.5);\n      TestDateTimeTag1One(\"1833-10-12T18:44:22Z\", -4298678138L);\n      TestDateTimeTag1One(\"1833-10-12T18:44:22.000Z\", -4298678138L);\n      TestDateTimeTag1One(\"1833-10-12T18:44:22.500Z\", -4298678137.5);\n      TestDateTimeTag1One(\"1550-07-27T20:11:15Z\", -13235975325L);\n      TestDateTimeTag1One(\"1550-07-27T20:11:15.000Z\", -13235975325L);\n      TestDateTimeTag1One(\"1550-07-27T20:11:15.500Z\", -13235975324.5);\n      TestDateTimeTag1One(\"2376-11-23T23:17:49Z\", 12840419869L);\n      TestDateTimeTag1One(\"2376-11-23T23:17:49.000Z\", 12840419869L);\n      TestDateTimeTag1One(\"2376-11-23T23:17:49.500Z\", 12840419869.5);\n      TestDateTimeTag1One(\"2291-11-16T10:53:45Z\", 10157396025L);\n      TestDateTimeTag1One(\"2291-11-16T10:53:45.000Z\", 10157396025L);\n      TestDateTimeTag1One(\"2291-11-16T10:53:45.500Z\", 10157396025.5);\n      TestDateTimeTag1One(\"2349-11-15T11:45:50Z\", 11987610350L);\n      TestDateTimeTag1One(\"2349-11-15T11:45:50.000Z\", 11987610350L);\n      TestDateTimeTag1One(\"2059-05-22T21:03:13Z\", 2820862993L);\n      TestDateTimeTag1One(\"2059-05-22T21:03:13.000Z\", 2820862993L);\n      TestDateTimeTag1One(\"2059-05-22T21:03:13.500Z\", 2820862993.5);\n      TestDateTimeTag1One(\"1601-04-03T01:34:37Z\", -11636519123L);\n      TestDateTimeTag1One(\"1601-04-03T01:34:37.000Z\", -11636519123L);\n      TestDateTimeTag1One(\"1601-04-03T01:34:37.500Z\", -11636519122.5);\n      TestDateTimeTag1One(\"1853-11-01T19:05:56Z\", -3665796844L);\n      TestDateTimeTag1One(\"1853-11-01T19:05:56.000Z\", -3665796844L);\n      TestDateTimeTag1One(\"1853-11-01T19:05:56.500Z\", -3665796843.5);\n      TestDateTimeTag1One(\"2465-03-10T00:10:34Z\", 15626650234L);\n      TestDateTimeTag1One(\"2465-03-10T00:10:34.000Z\", 15626650234L);\n      TestDateTimeTag1One(\"1961-06-28T14:59:41Z\", -268563619L);\n      TestDateTimeTag1One(\"1961-06-28T14:59:41.000Z\", -268563619L);\n      TestDateTimeTag1One(\"1961-06-28T14:59:41.500Z\", -268563618.5);\n      TestDateTimeTag1One(\"2078-02-03T01:57:23Z\", 3411079043L);\n      TestDateTimeTag1One(\"2078-02-03T01:57:23.000Z\", 3411079043L);\n      TestDateTimeTag1One(\"2078-02-03T01:57:23.500Z\", 3411079043.5);\n      TestDateTimeTag1One(\"2325-11-05T11:53:57Z\", 11229364437L);\n      TestDateTimeTag1One(\"2325-11-05T11:53:57.000Z\", 11229364437L);\n      TestDateTimeTag1One(\"2325-11-05T11:53:57.500Z\", 11229364437.5);\n      TestDateTimeTag1One(\"2189-02-10T04:55:14Z\", 6914523314L);\n      TestDateTimeTag1One(\"2189-02-10T04:55:14.000Z\", 6914523314L);\n      TestDateTimeTag1One(\"2189-02-10T04:55:14.500Z\", 6914523314.5);\n      TestDateTimeTag1One(\"2416-04-20T21:48:33Z\", 14083969713L);\n      TestDateTimeTag1One(\"2416-04-20T21:48:33.000Z\", 14083969713L);\n      TestDateTimeTag1One(\"2416-04-20T21:48:33.500Z\", 14083969713.5);\n      TestDateTimeTag1One(\"2009-06-24T20:06:34Z\", 1245873994L);\n      TestDateTimeTag1One(\"2009-06-24T20:06:34.000Z\", 1245873994L);\n      TestDateTimeTag1One(\"2009-06-24T20:06:34.500Z\", 1245873994.5);\n      TestDateTimeTag1One(\"2488-05-20T22:56:10Z\", 16358712970L);\n      TestDateTimeTag1One(\"2488-05-20T22:56:10.000Z\", 16358712970L);\n      TestDateTimeTag1One(\"1519-07-05T21:55:20Z\", -14216177080L);\n      TestDateTimeTag1One(\"1519-07-05T21:55:20.000Z\", -14216177080L);\n      TestDateTimeTag1One(\"1519-07-05T21:55:20.500Z\", -14216177079.5);\n      TestDateTimeTag1One(\"2349-05-25T11:44:14Z\", 11972576654L);\n      TestDateTimeTag1One(\"2349-05-25T11:44:14.000Z\", 11972576654L);\n    }\n\n    [Test]\n    [Timeout(100000)]\n    public void TestDateTimeTag1() {\n      CBORObject cbornum;\n      var rg = new RandomGenerator();\n      DateTime dt, dt2;\n      for (var i = 0; i < 1000; ++i) {\n        EInteger ei = CBORTestCommon.RandomEIntegerMajorType0Or1(rg);\n        cbornum = CBORObject.FromObjectAndTag(ei, 1);\n        try {\n          var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n          ToObjectTest.TestToFromObjectRoundTrip(dtx);\n        } catch (CBORException) {\n          // Console.WriteLine(\"Not supported: \"+ei);\n        }\n      }\n      for (var i = 0; i < 1000; ++i) {\n        double dbl = RandomObjects.RandomFiniteDouble(rg);\n        cbornum = CBORObject.FromObjectAndTag(dbl, 1);\n        try {\n          var dtx = (DateTime)cbornum.ToObject(typeof(DateTime));\n          ToObjectTest.TestToFromObjectRoundTrip(dtx);\n        } catch (CBORException) {\n          // Console.WriteLine(\"Not supported: \"+dbl);\n        }\n      }\n      string dateStr = \"1970-01-01T00:00:00.000Z\";\n      CBORObject cbor = CBORObject.FromObjectAndTag(dateStr, 0);\n      dt = (DateTime)cbor.ToObject(typeof(DateTime));\n      CBORObject cbor2 = CBORObject.FromObjectAndTag(0, 1);\n      dt2 = (DateTime)cbor.ToObject(typeof(DateTime));\n      Assert.AreEqual(dt2, dt);\n    }\n\n    private static string RandomQueryStringLike(IRandomGenExtended irg) {\n      var sb = new StringBuilder();\n      while (true) {\n        int x = irg.GetInt32(100);\n        if (x == 0) {\n          break;\n        } else if (x < 10) {\n          sb.Append('&');\n        } else if (x < 20) {\n          sb.Append('=');\n        } else if (x < 25) {\n          string hex = \"0123456789ABCDEF\";\n          sb.Append('%');\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n        } else if (x < 30) {\n          string hex = \"0123456789abcdef\";\n          sb.Append('%');\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n          sb.Append(hex[irg.GetInt32(hex.Length)]);\n        } else if (x < 95) {\n          sb.Append((char)(irg.GetInt32(0x5e) + 0x21));\n        } else {\n          sb.Append((char)irg.GetInt32(0x80));\n        }\n      }\n      return sb.ToString();\n    }\n\n    [Test]\n    public void TestQueryStrings() {\n      // TODO: Add utility to create query strings\n      String test = \"a=b&c=d&e=f&g\\u005b0]=h&g\\u005b1]=j&g\\u005b2]\\u005b\";\n      test += \"a]=k&g\\u005b2]\\u005bb]=m\";\n      CBORObject cbor =\n        CBORObject.FromObject(QueryStringHelper.QueryStringToDict(test));\n      Console.WriteLine(cbor.ToJSONString());\n      cbor = CBORObject.FromObject(QueryStringHelper.QueryStringToCBOR(test));\n      Console.WriteLine(cbor.ToJSONString());\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 100000; ++i) {\n        string str = RandomQueryStringLike(rg);\n        try {\n          cbor = QueryStringHelper.QueryStringToCBOR(str);\n          // Console.WriteLine(\"succ: \" + str);\n          // Console.WriteLine(cbor.ToJSONString());\n        } catch (InvalidOperationException) {\n          // Console.WriteLine(\"throws: \"+str);\n        }\n      }\n    }\n\n    private static CBORObject FromJSON(string json, JSONOptions jsonop) {\n      // var sw = new System.Diagnostics.Stopwatch();\n      // sw.Start();\n      CBORObject cbor = CBORObject.FromJSONString(json, jsonop);\n      // sw.Stop();\n      // Console.WriteLine(String.Empty + sw.ElapsedMilliseconds + \" ms\");\n      return cbor;\n    }\n\n    private static CBORObject FromJSON(string json, string numconv) {\n      return FromJSON(json, new JSONOptions(\"numberconversion=\" + numconv));\n    }\n\n    public static void AssertJSONDouble(\n      string json,\n      string numconv,\n      double dbl) {\n      var opt = new JSONOptions(\"numberconversion=\" + numconv);\n      CBORObject[] cbors = {\n        FromJSON(json, numconv),\n        CBORDataUtilities.ParseJSONNumber(json, opt),\n      };\n      foreach (CBORObject cbor in cbors) {\n        if (cbor.Type != CBORType.FloatingPoint) {\n          Assert.AreEqual(\n            CBORType.FloatingPoint,\n            cbor.Type,\n            json + \" \" + numconv + \" \" + dbl);\n        }\n        double cbordbl = cbor.AsDoubleValue();\n        if (dbl != cbordbl) {\n          Assert.Fail(\"dbl = \" + dbl + \", cbordbl = \" + cbordbl + \", \" +\n            json + \" \" + numconv + \" \" + dbl);\n        }\n      }\n    }\n\n    public static void AssertJSONInteger(\n      string json,\n      string numconv,\n      long longval) {\n      var opt = new JSONOptions(\"numberconversion=\" + numconv);\n      CBORObject[] cbors = {\n        FromJSON(json, numconv),\n        CBORDataUtilities.ParseJSONNumber(json, opt),\n      };\n      foreach (CBORObject cbor in cbors) {\n        if (cbor.Type != CBORType.Integer) {\n          string msg = json + \" \" + numconv + \" \" + longval;\n          msg = msg.Substring(0, Math.Min(100, msg.Length));\n          if (msg.Length > 100) {\n            msg += \"...\";\n          }\n          Assert.AreEqual(CBORType.Integer, cbor.Type, msg);\n        }\n        Assert.AreEqual(longval, cbor.AsInt64Value());\n      }\n    }\n\n    public static void AssertJSONInteger(\n      string json,\n      string numconv,\n      int intval) {\n      var opt = new JSONOptions(\"numberconversion=\" + numconv);\n      CBORObject[] cbors = {\n        FromJSON(json, numconv),\n        CBORDataUtilities.ParseJSONNumber(json, opt),\n      };\n      foreach (CBORObject cbor in cbors) {\n        if (cbor.Type != CBORType.Integer) {\n          string msg = json + \" \" + numconv + \" \" + intval;\n          msg = msg.Substring(0, Math.Min(100, msg.Length));\n          if (msg.Length > 100) {\n            msg += \"...\";\n          }\n          Assert.AreEqual(CBORType.Integer, cbor.Type, msg);\n        }\n        Assert.AreEqual(intval, cbor.AsInt32Value());\n      }\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongSpecific1() {\n      JSONOptions jsonop = JSONOptions.Default;\n      string json = \"{\\\"x\\\":-9.2574033594381E-7962\\u002c\\\"1\\\":\" +\n        \"-2.8131427974929237E+240}\";\n      try {\n        FromJSON(json, jsonop);\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    private static readonly JSONOptions JSONOptionsDouble = new JSONOptions(\n      \"numberconversion=double\");\n    private static readonly JSONOptions JSONOptionsFull = new JSONOptions(\n      \"numberconversion=full\");\n\n    public static void TestParseNumberFxxLine(string line) {\n      // Parse test case format used in:\n      // https://github.com/nigeltao/parse-number-fxx-test-data\n      string f16 = line.Substring(0, 4);\n      if (line[4] != ' ') {\n        Assert.Fail(line);\n      }\n      string f32 = line.Substring(4 + 1, 8);\n      if (line[4 + 9] != ' ') {\n        Assert.Fail(line);\n      }\n      string f64 = line.Substring(4 + 1 + 8 + 1, 16);\n      if (line[4 + 26] != ' ') {\n        Assert.Fail(line);\n      }\n      string str = line.Substring(4 + 1 + 8 + 1 + 16 + 1);\n      short sf16 = EInteger.FromRadixString(f16, 16).ToInt16Unchecked();\n      int sf32 = EInteger.FromRadixString(f32, 16).ToInt32Unchecked();\n      long sf64 = EInteger.FromRadixString(f64, 16).ToInt64Unchecked();\n      TestParseNumberFxx(str, sf16, sf32, sf64, line);\n    }\n\n    public static void TestParseNumberFxx(\n      string str,\n      short f16,\n      int f32,\n      long f64,\n      string line) {\n      if (str[0] == '.' || str[str.Length - 1] == '.' ||\n        str.Contains(\".e\") || str.Contains(\".E\")) {\n        // Not a valid JSON number, so skip\n        // Console.WriteLine(str);\n        return;\n      }\n      if (CBORObject.FromObject(f16) == null) {\n        Assert.Fail();\n      }\n      CBORObject cbor = CBORDataUtilities.ParseJSONNumber(str,\n          JSONOptionsDouble);\n      if (cbor == null) {\n        Console.WriteLine(str);\n        return;\n      }\n      Assert.AreEqual(f64, cbor.AsDoubleBits(), line);\n      cbor = CBORObject.FromJSONString(str, JSONOptionsDouble);\n      Assert.AreEqual(f64, cbor.AsDoubleBits(), line);\n      cbor = CBORObject.FromJSONBytes(\n          DataUtilities.GetUtf8Bytes(str, false),\n          JSONOptionsDouble);\n      Assert.AreEqual(f64, cbor.AsDoubleBits(), line);\n      float sing = CBORObject.FromFloatingPointBits(f32, 4).AsSingle();\n      cbor = CBORDataUtilities.ParseJSONNumber(str, JSONOptionsFull);\n      if (cbor == null) {\n        Assert.Fail();\n      }\n      Assert.AreEqual(sing, cbor.AsSingle(), line);\n      cbor = CBORObject.FromJSONString(str, JSONOptionsFull);\n      Assert.AreEqual(sing, cbor.AsSingle(), line);\n      cbor = CBORObject.FromJSONBytes(\n          DataUtilities.GetUtf8Bytes(str, false),\n          JSONOptionsFull);\n      Assert.AreEqual(sing, cbor.AsSingle(), line);\n      // TODO: Test f16\n    }\n\n    [Test]\n    public void TestCloseToPowerOfTwo() {\n      for (var i = 31; i < 129; ++i) {\n        EInteger ei = EInteger.FromInt32(1).ShiftLeft(i);\n        {\n          AssertJSONDouble(\n            ei.ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei).ToDouble());\n          AssertJSONDouble(\n            ei.Add(1).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Add(1)).ToDouble());\n          AssertJSONDouble(\n            ei.Subtract(2).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Subtract(2)).ToDouble());\n          AssertJSONDouble(\n            ei.Add(2).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Add(2)).ToDouble());\n          AssertJSONDouble(\n            ei.Subtract(2).ToString(),\n            \"double\",\n            EFloat.FromEInteger(ei.Subtract(2)).ToDouble());\n        }\n      }\n    }\n\n    [Test]\n    public void TestFromJsonStringFastCases() {\n      var op = new JSONOptions(\"numberconversion=double\");\n      Assert.AreEqual(\n        JSONOptions.ConversionMode.Double,\n        op.NumberConversion);\n      op = new JSONOptions(\"numberconversion=intorfloat\");\n      Assert.AreEqual(\n        JSONOptions.ConversionMode.IntOrFloat,\n        op.NumberConversion);\n      string manyzeros = TestCommon.Repeat(\"0\", 1000000);\n      string manythrees = TestCommon.Repeat(\"3\", 1000000);\n      AssertJSONDouble(\n        \"0e-\" + manyzeros,\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        \"0.\" + manyzeros,\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        \"0.\" + manyzeros + \"e-9999999999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-9999999999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-9999999999999\",\n        \"intorfloat\",\n        0.0);\n\n      AssertJSONInteger(\n        manythrees + \"e-9999999999999\",\n        \"intorfloatfromdouble\",\n        0);\n\n      AssertJSONDouble(\n        \"0.\" + manyzeros + \"e-99999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-99999999\",\n        \"double\",\n        0.0);\n\n      AssertJSONDouble(\n        manythrees + \"e-99999999\",\n        \"intorfloat\",\n        0.0);\n      AssertJSONInteger(\n        manythrees + \"e-99999999\",\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"0e-\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"0e-\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"-0e-\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"-0e-\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"0.\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"0.\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n      AssertJSONInteger(\n        \"-0.\" + manyzeros,\n        \"intorfloat\",\n        0);\n      AssertJSONInteger(\n        \"-0.\" + manyzeros,\n        \"intorfloatfromdouble\",\n        0);\n    }\n\n    [Test]\n    public void TestFromJsonStringFiniteDoubleSpec() {\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 10000; ++i) {\n        double dbl = RandomObjects.RandomFiniteDouble(rg);\n        EFloat efd = EFloat.FromDouble(dbl);\n        AssertJSONDouble(\n          efd.ToShortestString(EContext.Binary64),\n          \"double\",\n          dbl);\n        AssertJSONDouble(\n          efd.ToString(),\n          \"double\",\n          dbl);\n      }\n    }\n\n    [Test]\n    public void TestEDecimalEFloatWithHighExponent() {\n      string decstr = \"0E100441809235791722330759976\";\n      Assert.AreEqual(0L, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(0L, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      decstr = \"0E-100441809235791722330759976\";\n      Assert.AreEqual(0L, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(0L, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = 0L;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      decstr = \"-0E100441809235791722330759976\";\n      long negzero = 1L << 63;\n      Assert.AreEqual(negzero, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(negzero, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      decstr = \"-0E-100441809235791722330759976\";\n      Assert.AreEqual(negzero, EDecimal.FromString(decstr).ToDoubleBits());\n      Assert.AreEqual(negzero, EFloat.FromString(decstr).ToDoubleBits());\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EDecimal.FromString(decstr,\n            EContext.Decimal32).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n      {\n        object objectTemp = negzero;\n        object objectTemp2 = EFloat.FromString(decstr,\n            EContext.Binary64).ToDoubleBits();\n        Assert.AreEqual(objectTemp, objectTemp2);\n      }\n    }\n\n    [Test]\n    public void TestFromJsonStringZeroWithHighExponent() {\n      string decstr = \"0E100441809235791722330759976\";\n      EDecimal ed = EDecimal.FromString(decstr);\n      double dbl = ed.ToDouble();\n      Assert.AreEqual(0.0d, dbl);\n      AssertJSONDouble(decstr, \"double\", dbl);\n      AssertJSONInteger(decstr, \"intorfloat\", 0);\n      decstr = \"0E1321909565013040040586\";\n      ed = EDecimal.FromString(decstr);\n      dbl = ed.ToDouble();\n      Assert.AreEqual(0.0d, dbl);\n      AssertJSONDouble(decstr, \"double\", dbl);\n      AssertJSONInteger(decstr, \"intorfloat\", 0);\n      double dblnegzero = EFloat.FromString(\"-0\").ToDouble();\n      AssertJSONDouble(\"0E-1321909565013040040586\", \"double\", 0.0);\n      AssertJSONInteger(\"0E-1321909565013040040586\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E1321909565013040040586\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E1321909565013040040586\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E-1321909565013040040586\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E-1321909565013040040586\", \"intorfloat\", 0);\n\n      AssertJSONDouble(\"0E-100441809235791722330759976\", \"double\", 0.0);\n      AssertJSONInteger(\"0E-100441809235791722330759976\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E100441809235791722330759976\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E100441809235791722330759976\", \"intorfloat\", 0);\n      AssertJSONDouble(\"-0E-100441809235791722330759976\", \"double\", dblnegzero);\n      AssertJSONInteger(\"-0E-100441809235791722330759976\", \"intorfloat\", 0);\n    }\n\n    [Test]\n    public void TestFromJsonStringEDecimalSpec() {\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 2000; ++i) {\n        var decstring = new string[1];\n        EDecimal ed = RandomObjects.RandomEDecimal(rg, decstring);\n        if (decstring[0] == null) {\n          Assert.Fail();\n        }\n        double dbl = ed.ToDouble();\n        if (Double.IsPositiveInfinity(dbl) ||\n                 Double.IsNegativeInfinity(dbl) ||\n                 Double.IsNaN(dbl)) {\n          continue;\n        }\n        AssertJSONDouble(\n          decstring[0],\n          \"double\",\n          dbl);\n      }\n    }\n\n    [Test]\n    public void TestFromJsonCTLInString() {\n      for (var i = 0; i <= 0x20; ++i) {\n        byte[] bytes = { 0x22, (byte)i, 0x22 };\n        char[] chars = { (char)0x22, (char)i, (char)0x22 };\n        string str = new String(chars, 0, chars.Length);\n        if (i == 0x20) {\n          try {\n            CBORObject.FromJSONString(str);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.FromJSONBytes(bytes);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONString(str);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n          try {\n            CBORObject.FromJSONBytes(bytes);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    // [Test]\n    public void TestFromJsonLeadingTrailingCTLBytes() {\n      // TODO: Reenable eventually, once UTF-8 only support\n      // for CBORObject.FromJSONBytes is implemented\n      for (var i = 0; i <= 0x20; ++i) {\n        // Leading CTL\n        byte[] bytes = { (byte)i, 0x31 };\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"bytes \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n            Assert.Fail(\"Should have failed bytes \" + i);\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // Trailing CTL\n        bytes = new byte[] { 0x31, (byte)i };\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"bytes \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONBytes(bytes);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"bytes \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestFromJsonLeadingTrailingCTL() {\n      for (var i = 0; i <= 0x20; ++i) {\n        // Leading CTL\n        char[] chars = { (char)i, (char)0x31 };\n        string str = new String(chars, 0, chars.Length);\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONString(str);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"string \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONString(str);\n            Assert.Fail(\"Should have failed string \" + i);\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString());\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n        // Trailing CTL\n        chars = new char[] { (char)0x31, (char)i };\n        str = new String(chars, 0, chars.Length);\n        if (i == 0x09 || i == 0x0d || i == 0x0a || i == 0x20) {\n          try {\n            CBORObject.FromJSONString(str);\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"string \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        } else {\n          try {\n            CBORObject.FromJSONString(str);\n            Assert.Fail(\"Should have failed\");\n          } catch (CBORException) {\n            // NOTE: Intentionally empty\n          } catch (Exception ex) {\n            Assert.Fail(ex.ToString() + \"string \" + i);\n            throw new InvalidOperationException(String.Empty, ex);\n          }\n        }\n      }\n    }\n\n    [Test]\n    public void TestFromJsonStringSmallDoubleSpec() {\n      var rg = new RandomGenerator();\n      for (var i = 0; i < 10000; ++i) {\n        int rv = rg.GetInt32(Int32.MaxValue) * ((rg.GetInt32(2) * 2) - 1);\n        string rvstring = TestCommon.IntToString(rv);\n        AssertJSONDouble(\n          rvstring,\n          \"double\",\n          (double)rv);\n        AssertJSONInteger(\n          rvstring,\n          \"intorfloat\",\n          rv);\n      }\n      AssertJSONDouble(\"511\", \"double\", 511);\n      AssertJSONDouble(\"-511\", \"double\", -511);\n      AssertJSONDouble(\n        TestCommon.IntToString(Int32.MaxValue),\n        \"double\",\n        (double)Int32.MaxValue);\n      AssertJSONDouble(\n        TestCommon.IntToString(Int32.MaxValue),\n        \"double\",\n        (double)Int32.MaxValue);\n      AssertJSONDouble(\n        TestCommon.IntToString(Int32.MinValue),\n        \"double\",\n        (double)Int32.MinValue);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringSmallDouble() {\n      CBORObject cbor;\n      AssertJSONDouble(\"0\", \"double\", 0.0);\n      cbor = FromJSON(\"[0, 1, 2, 3]\", \"double\");\n      Assert.AreEqual(4, cbor.Count);\n      Assert.AreEqual((double)0.0, cbor[0].AsDouble());\n      Assert.AreEqual((double)1.0, cbor[1].AsDouble());\n      Assert.AreEqual((double)2.0, cbor[2].AsDouble());\n      Assert.AreEqual((double)3.0, cbor[3].AsDouble());\n      cbor = FromJSON(\"[0]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      Assert.AreEqual((double)0.0, cbor[0].AsDouble());\n      cbor = FromJSON(\"[-0]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      cbor = FromJSON(\"[1]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      Assert.AreEqual((double)1.0, cbor[0].AsDouble());\n      cbor = FromJSON(\"[-1]\", \"double\");\n      Assert.AreEqual(1, cbor.Count);\n      Assert.AreEqual((double)-1.0, cbor[0].AsDouble());\n      cbor = FromJSON(\"[-1022,-1023,-1024,-1025,1022,1023,1024,1025]\",\n          \"double\");\n      Assert.AreEqual(8, cbor.Count);\n      Assert.AreEqual((double)-1022.0, cbor[0].AsDouble());\n      Assert.AreEqual((double)-1023.0, cbor[1].AsDouble());\n      Assert.AreEqual((double)-1024.0, cbor[2].AsDouble());\n      Assert.AreEqual((double)-1025.0, cbor[3].AsDouble());\n      Assert.AreEqual((double)1022.0, cbor[4].AsDouble());\n      Assert.AreEqual((double)1023.0, cbor[5].AsDouble());\n      Assert.AreEqual((double)1024.0, cbor[6].AsDouble());\n      Assert.AreEqual((double)1025.0, cbor[7].AsDouble());\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindFull() {\n      var jsonop = new JSONOptions(\"numberconversion=full\");\n      string json = TestCommon.Repeat(\"7\", 100000);\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.IsTrue(cbor.IsTagged);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindFull2() {\n      var jsonop = new JSONOptions(\"numberconversion=full\");\n      string json = TestCommon.Repeat(\"7\", 100000) + \".0\";\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.IsTrue(cbor.IsTagged);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindFullBad() {\n      Console.WriteLine(\"FullBad 1\");\n      var jsonop = new JSONOptions(\"numberconversion=full\");\n      string manysevens = TestCommon.Repeat(\"7\", 1000000);\n      string[] badjson = {\n        manysevens + \"x\",\n        \"7x\" + manysevens,\n        manysevens + \"e0x\",\n        \"-\" + manysevens + \"x\",\n        \"-7x\" + manysevens,\n        \"-\" + manysevens + \"e0x\",\n      };\n      foreach (string str in badjson) {\n        try {\n          FromJSON(str, jsonop);\n          Assert.Fail(\"Should have failed\");\n        } catch (CBORException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n      Console.WriteLine(\"FullBad 2\");\n      string json = TestCommon.Repeat(\"0\", 1000000);\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindsBad() {\n      JSONOptions jsonop;\n      string json = TestCommon.Repeat(\"7\", 1000000) + \"x\";\n      jsonop = new JSONOptions(\"numberconversion=double\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloatfromdouble\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      json = TestCommon.Repeat(\"0\", 1000000);\n      jsonop = new JSONOptions(\"numberconversion=double\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloatfromdouble\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      try {\n        FromJSON(json, jsonop);\n        Assert.Fail(\"Should have failed\");\n      } catch (CBORException) {\n        // NOTE: Intentionally empty\n      } catch (Exception ex) {\n        Assert.Fail(ex.ToString());\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindIntOrFloatFromDouble() {\n      var jsonop = new JSONOptions(\"numberconversion=intorfloatfromdouble\");\n      string manysevens = TestCommon.Repeat(\"7\", 1000000);\n      string json = manysevens;\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n      json = manysevens + \"e+0\";\n      cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n      json = manysevens + \"e0\";\n      cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindIntOrFloat() {\n      var jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      string json = TestCommon.Repeat(\"7\", 1000000);\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.PositiveInfinity);\n    }\n\n    [Test]\n    [Timeout(10000)]\n    public void TestFromJsonStringLongKindIntOrFloat2() {\n      var jsonop = new JSONOptions(\"numberconversion=intorfloat\");\n      string json = \"-\" + TestCommon.Repeat(\"7\", 1000000);\n      CBORObject cbor = FromJSON(json, jsonop);\n      Assert.AreEqual(CBORType.FloatingPoint, cbor.Type);\n      Assert.IsTrue(cbor.AsDoubleValue() == Double.NegativeInfinity);\n    }\n\n[Test]\npublic void TestRoundTripRegressions() {\n{\nvar options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\nvar bytes = new byte[] {\n  (byte)0xba, 0x00, 0x00, 0x00, 0x03,\n  (byte)0xf9,\n  (byte)0x83, 0x1d,\n  (byte)0xda,\n  (byte)0xb6,\n  (byte)0xda, 0x50, 0x56, 0x1a, 0x50,\n  (byte)0xe3, 0x2c, 0x7a, 0x16,\n  (byte)0xfa, 0x50, 0x32, 0x73, 0x07,\n  (byte)0xfa, (byte)0xb9, 0x2d, 0x73, (byte)0xce, 0x38, (byte)0xd0,\n};\nCBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n}\n{\nvar options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\nvar bytes = new byte[] {\n  (byte)0xbf,\n  (byte)0x9f,\n  (byte)0xbf, 0x39, 0x20,\n  (byte)0x8f, 0x4a, 0x1f, 0x46, 0x26, 0x0b, 0x3e, 0x72, 0x2c, 0x7f, 0x11,\n  0x2e, 0x39,\n  (byte)0x9d,\n  (byte)0xba, 0x1a, 0x11,\n  (byte)0x8d,\n  (byte)0xc0,\n  (byte)0xb4, 0x38,\n  (byte)0xb6,\n  (byte)0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n  (byte)0xd8, 0x3b,\n  (byte)0x99, 0x00, 0x02, 0x3b, 0x05,\n  (byte)0xbb,\n  (byte)0xea,\n  (byte)0x8e, 0x4b,\n  (byte)0xd3, 0x5e, 0x22,\n  (byte)0x9f, 0x59, 0x00, 0x00,\n  (byte)0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x41, 0x20,\n  (byte)0xbf, 0x1a, 0x00, 0x00, 0x00, 0x61,\n  (byte)0xb9, 0x00, 0x01, 0x1a, 0x00, 0x00, 0x00, 0x0e,\n  (byte)0xba, 0x00, 0x00, 0x00, 0x00,\n  (byte)0xff,\n  (byte)0xff,\n  (byte)0xff,\n  (byte)0xd8, 0x22,\n  (byte)0xf8,\n  (byte)0x93,\n  (byte)0xd9,\n  (byte)0xaf, 0x33, 0x19,\n  (byte)0xf0,\n  (byte)0xf0,\n  (byte)0xf9,\n  (byte)0x85,\n  (byte)0x93,\n  (byte)0x99, 0x00, 0x01, 0x3a,\n  (byte)0xb5,\n  (byte)0xfb, 0x4d, 0x43,\n  (byte)0x98, 0x00,\n  (byte)0xff, (byte)0xfa, (byte)0xb0, (byte)0xb4, (byte)0xdc, 0x6d,\n  (byte)0xff,\n};\nCBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n}\n{\nvar options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\nvar bytes = new byte[] {\n  (byte)0xdb, 0x0d,\n  (byte)0xcb, 0x5d, 0x78,\n  (byte)0x92,\n  (byte)0xc2,\n  (byte)0xc7, 0x2b,\n  (byte)0xb9, 0x00, 0x02, 0x39,\n  (byte)0xee,\n  (byte)0xa0, (byte)0xa0, 0x1a, 0x0e, (byte)0xd9, (byte)0xec, (byte)0xca,\n  (byte)0xf2,\n};\nCBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n}\n{\nvar options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\nvar bytes = new byte[] {\n  (byte)0xbf,\n  (byte)0xfb,\n  (byte)0xb1, 0x21,\n  (byte)0x93,\n  (byte)0x8c,\n  (byte)0xc6,\n  (byte)0xf3,\n  (byte)0xcf,\n  (byte)0xb7, (byte)0xf8, 0x76, 0x18, (byte)0xda, 0x39, 0x60, (byte)0xf4,\n  (byte)0xff,\n};\nCBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n}\n{\nvar options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\nvar bytes = new byte[] {\n  (byte)0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n  0x00, 0x02, (byte)0xf0, 0x0d, 0x2a, 0x21,\n};\nCBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n}\n{\nvar options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\nvar bytes = new byte[] {\n  (byte)0xba, 0x00, 0x00, 0x00, 0x02,\n  (byte)0xf9, 0x48, 0x37,\n  (byte)0xda,\n  (byte)0xb5, 0x72,\n  (byte)0xcf,\n  (byte)0xf8, 0x31, 0x3b, 0x06, 0x78,\n  (byte)0xdb, 0x44, 0x7d, (byte)0xba, (byte)0xbd, 0x7d, 0x39, (byte)0x98,\n  (byte)0xb9,\n};\nCBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n}\n}\n[Test]\npublic void TestMapCompareRegressions() {\n  CBORObject m1, m2;\n  m1 = CBORObject.NewMap().Add(3, 4).Add(1, 2);\n  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n  Assert.AreEqual(0, m1.CompareTo(m2));\n  TestCommon.CompareTestEqualAndConsistent(m1, m2);\n  m1 = CBORObject.NewMap().Add(3, 2).Add(1, 2);\n  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n  TestCommon.CompareTestLess(m1, m2);\n  m1 = CBORObject.NewMap().Add(3, 7).Add(1, 2);\n  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n  TestCommon.CompareTestGreater(m1, m2);\n  m1 = CBORObject.NewMap().Add(3, 4).Add(1, 0);\n  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n  TestCommon.CompareTestLess(m1, m2);\n  m1 = CBORObject.NewMap().Add(3, 4).Add(1, 7);\n  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n  TestCommon.CompareTestGreater(m1, m2);\n}\n    [Test]\n    public void TestToObject_TypeMapper() {\n      var mapper = new CBORTypeMapper()\n      .AddConverter(typeof(string), new TestConverter());\n      CBORObject cbor = CBORObject.FromObject(\"UpPeR\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"upper\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"TRUE\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"true\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"false\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"false\",\n          stringTemp);\n      }\n      cbor = CBORObject.FromObject(\"FALSE\");\n      {\n        var stringTemp = (string)cbor.ToObject(typeof(string), mapper);\n        Assert.AreEqual(\n          \"false\",\n          stringTemp);\n      }\n    }\n  }\n}\n", "<Project Sdk='Microsoft.NET.Sdk'>\n  <PropertyGroup>\n    <TargetFramework>netcoreapp5.0</TargetFramework>\n  </PropertyGroup>\n  <PropertyGroup Condition=' &apos;$(Configuration)&apos;==&apos;Debug&apos; '>\n    <DebugType>full</DebugType>\n    <CodeAnalysisRuleSet>rules.ruleset</CodeAnalysisRuleSet></PropertyGroup>\n  <PropertyGroup Condition=' &apos;$(Configuration)&apos;==&apos;Release&apos; '>\n    <DebugType>none</DebugType>\n    <CodeAnalysisRuleSet>rules.ruleset</CodeAnalysisRuleSet></PropertyGroup>\n  <ItemGroup>\n    <ProjectReference Include='..\\CBOR\\CBOR.csproj'/>\n  <AdditionalFiles Include='stylecop.json'/><AdditionalFiles Include='rules.ruleset'/></ItemGroup>\n  <ItemGroup>\n    <EmbeddedResource Include='Resources.restext'>\n      <LogicalName>Resources.resources</LogicalName>\n    </EmbeddedResource></ItemGroup>\n      <ItemGroup>\n        <PackageReference Include='Microsoft.NET.Test.Sdk' Version='15.9.0'/>\n        <PackageReference Include='NUnit' Version='3.13.2'/>\n        <PackageReference Include='Microsoft.CodeAnalysis.NetAnalyzers' PrivateAssets='All' Version='5.0.3'/>\n        <PackageReference Include='NUnit3TestAdapter' Version='3.16.1'>\n          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>\n          <PrivateAssets>all</PrivateAssets>\n        </PackageReference>\n        <PackageReference Include='StyleCop.Analyzers' PrivateAssets='All' Version='1.2.0-beta.354'/>\n        <PackageReference Include='PeterO.Numbers' Version='1.8.2'/>\n      </ItemGroup>\n   </Project>\n", "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing NUnit.Framework;\nusing PeterO;\nusing PeterO.Cbor;\nusing PeterO.Numbers;\n\nnamespace Test {\n  internal static class CBORTestCommon {\n    internal static readonly EDecimal DecPosInf =\n      EDecimal.PositiveInfinity;\n\n    internal static readonly EDecimal DecNegInf =\n      EDecimal.NegativeInfinity;\n\n    internal static readonly EFloat FloatPosInf =\n      EFloat.PositiveInfinity;\n\n    internal static readonly EFloat FloatNegInf =\n      EFloat.NegativeInfinity;\n\n    internal static readonly ERational RatPosInf =\n      ERational.PositiveInfinity;\n\n    internal static readonly ERational RatNegInf =\n      ERational.NegativeInfinity;\n\n    private static EFloat RandomEFloatLowExponent(IRandomGenExtended rand) {\n      while (true) {\n         EFloat ef = RandomObjects.RandomEFloat(rand);\n         if (\n           ef.Exponent.CompareTo(-20000) >= 0 &&\nef.Exponent.CompareTo(20000) <= 0) {\n           return ef;\n         }\n       }\n    }\n\n    private static EDecimal RandomEDecimalLowExponent(IRandomGenExtended rand) {\n      while (true) {\n         EDecimal ef = RandomObjects.RandomEDecimal(rand);\n         if (\n           ef.Exponent.CompareTo(-20000) >= 0 &&\nef.Exponent.CompareTo(20000) <= 0) {\n           return ef;\n         }\n       }\n    }\n\n    public static CBORObject RandomNumber(IRandomGenExtended rand) {\n      return RandomNumber(rand, false);\n    }\n\n    public static CBORObject RandomNumber(IRandomGenExtended rand, bool\nlowExponent) {\n      object o = null;\n      switch (rand.GetInt32(6)) {\n        case 0:\n          o = RandomObjects.RandomDouble(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 1:\n          o = RandomObjects.RandomSingle(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 2:\n          return CBORObject.FromObject(\n              RandomObjects.RandomEInteger(rand));\n        case 3:\n          o = lowExponent ? RandomEFloatLowExponent(rand) :\n               RandomObjects.RandomEFloat(rand);\n          return CBORObject.FromObject(o);\n        case 4:\n          o = lowExponent ? RandomEDecimalLowExponent(rand) :\n               RandomObjects.RandomEDecimal(rand);\n          return CBORObject.FromObject(o);\n        case 5:\n          o = RandomObjects.RandomInt64(rand);\n          return CBORObject.FromObject(o);\n        default: throw new InvalidOperationException();\n      }\n    }\n\n    public static CBORObject RandomNumberOrRational(IRandomGenExtended rand) {\n      object o = null;\n      switch (rand.GetInt32(7)) {\n        case 0:\n          o = RandomObjects.RandomDouble(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 1:\n          o = RandomObjects.RandomSingle(\n            rand,\n            Int32.MaxValue);\n          return CBORObject.FromObject(o);\n        case 2:\n          return CBORObject.FromObject(\n              RandomObjects.RandomEInteger(rand));\n        case 3:\n          return CBORObject.FromObject(\n              RandomObjects.RandomEFloat(rand));\n        case 4:\n          o = RandomObjects.RandomEDecimal(rand);\n          return CBORObject.FromObject(o);\n        case 5:\n          o = RandomObjects.RandomInt64(rand);\n          return CBORObject.FromObject(o);\n        case 6:\n          o = RandomObjects.RandomERational(rand);\n          return CBORObject.FromObject(o);\n        default: throw new InvalidOperationException();\n      }\n    }\n\n    public static CBORObject RandomCBORMap(IRandomGenExtended rand, int depth) {\n      int x = rand.GetInt32(100);\n      int count = (x < 80) ? 2 : ((x < 93) ? 1 : ((x < 98) ? 0 : 10));\n      CBORObject cborRet = rand.GetInt32(100) < 30 ?\n         CBORObject.NewOrderedMap() : CBORObject.NewMap();\n      for (var i = 0; i < count; ++i) {\n        CBORObject key = RandomCBORObject(rand, depth + 1);\n        CBORObject value = RandomCBORObject(rand, depth + 1);\n        cborRet[key] = value;\n      }\n      return cborRet;\n    }\n\n    public static EInteger RandomEIntegerMajorType0(IRandomGenExtended rand) {\n      int v = rand.GetInt32(0x10000);\n      EInteger ei = EInteger.FromInt32(v);\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      return ei;\n    }\n\n    public static EInteger RandomEIntegerMajorType0Or1(IRandomGenExtended\nrand) {\n      int v = rand.GetInt32(0x10000);\n      EInteger ei = EInteger.FromInt32(v);\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      ei = ei.ShiftLeft(16).Add(rand.GetInt32(0x10000));\n      if (rand.GetInt32(2) == 0) {\n        ei = ei.Add(1).Negate();\n      }\n      return ei;\n    }\n\n    public static CBORObject RandomCBORTaggedObject(\n      IRandomGenExtended rand,\n      int depth) {\n      var tag = 0;\n      if (rand.GetInt32(2) == 0) {\n        int[] tagselection = {\n          2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 30, 30,\n          30, 0, 1, 25, 26, 27,\n        };\n        tag = tagselection[rand.GetInt32(tagselection.Length)];\n      } else if (rand.GetInt32(100) < 90) {\n        return CBORObject.FromObjectAndTag(\n            RandomCBORObject(rand, depth + 1),\n            rand.GetInt32(0x100000));\n      } else {\n        return CBORObject.FromObjectAndTag(\n            RandomCBORObject(rand, depth + 1),\n            RandomEIntegerMajorType0(rand));\n      }\n      if (tag == 25) {\n        tag = 0;\n      }\n      if (tag == 30) {\n        object o = RandomObjects.RandomByteString(rand);\n        return CBORObject.FromObject(o);\n      }\n      {\n        CBORObject cbor;\n        // Console.WriteLine(\"tag \"+tag+\" \"+i);\n        if (tag == 0 || tag == 1 || tag == 28 || tag == 29) {\n          tag = 999;\n        }\n        if (tag == 2 || tag == 3) {\n          object o = RandomObjects.RandomByteStringShort(rand);\n          cbor = CBORObject.FromObject(o);\n        } else if (tag == 4 || tag == 5) {\n          cbor = CBORObject.NewArray();\n          object o = RandomObjects.RandomSmallIntegral(rand);\n          cbor.Add(o);\n          o = RandomObjects.RandomEInteger(rand);\n          cbor.Add(o);\n        } else if (tag == 30) {\n          cbor = CBORObject.NewArray();\n          object o = RandomObjects.RandomSmallIntegral(rand);\n          cbor.Add(o);\n          o = RandomObjects.RandomEInteger(rand);\n          cbor.Add(o);\n        } else {\n          cbor = RandomCBORObject(rand, depth + 1);\n        }\n        return CBORObject.FromObjectAndTag(cbor, tag);\n      }\n    }\n\n    public static CBORObject RandomCBORArray(IRandomGenExtended rand, int\ndepth) {\n      int x = rand.GetInt32(100);\n      int count = (x < 80) ? 2 : ((x < 93) ? 1 : ((x < 98) ? 0 : 10));\n      CBORObject cborRet = CBORObject.NewArray();\n      for (var i = 0; i < count; ++i) {\n        cborRet.Add(RandomCBORObject(rand, depth + 1));\n      }\n      return cborRet;\n    }\n\n    public static CBORObject RandomCBORObject(IRandomGenExtended rand) {\n      return RandomCBORObject(rand, 0);\n    }\n\n    public static CBORObject RandomCBORObject(IRandomGenExtended rand, int\n      depth) {\n      int nextval = rand.GetInt32(11);\n      switch (nextval) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n          return RandomNumberOrRational(rand);\n        case 4:\n          return rand.GetInt32(2) == 0 ? CBORObject.True : CBORObject.False;\n        case 5:\n          return rand.GetInt32(2) == 0 ? CBORObject.Null :\n            CBORObject.Undefined;\n        case 6:\n          return CBORObject.FromObject(\n              RandomObjects.RandomTextString(rand));\n        case 7:\n          return CBORObject.FromObject(\n              RandomObjects.RandomByteString(rand));\n        case 8:\n          return RandomCBORArray(rand, depth);\n        case 9:\n          return RandomCBORMap(rand, depth);\n        case 10:\n          return RandomCBORTaggedObject(rand, depth);\n        default: return RandomNumber(rand);\n      }\n    }\n\n#pragma warning disable CS0618\n    public static void TestNumber(CBORObject o) {\n      if (o.Type != CBORType.Number) {\n        return;\n      }\n      if (o.IsPositiveInfinity() || o.IsNegativeInfinity() ||\n        o.IsNaN()) {\n        try {\n          o.AsByte();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsInt16();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsInt32();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsInt64();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsSingle();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsDouble();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o.AsEInteger();\n          Assert.Fail(\"Should have failed\");\n        } catch (OverflowException) {\n          // NOTE: Intentionally empty\n        } catch (Exception ex) {\n          Assert.Fail(\"Object: \" + o + \", \" + ex);\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        return;\n      }\n      try {\n        o.AsSingle();\n      } catch (Exception ex) {\n        Assert.Fail(\"Object: \" + o + \", \" + ex);\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n      try {\n        o.AsDouble();\n      } catch (Exception ex) {\n        Assert.Fail(\"Object: \" + o + \", \" + ex);\n        throw new InvalidOperationException(String.Empty, ex);\n      }\n    }\n#pragma warning restore CS0618\n\n    public static byte[] CheckEncodeToBytes(CBORObject o) {\n      byte[] bytes = o.EncodeToBytes();\n      if (bytes.Length != o.CalcEncodedSize()) {\n        string msg = \"encoded size doesn't match:\\no = \" +\n          TestCommon.ToByteArrayString(bytes) + \"\\nostring = \" + o.ToString();\n        Assert.AreEqual(bytes.Length, o.CalcEncodedSize(), msg);\n      }\n      return bytes;\n    }\n\n    public static void AssertRoundTrip(CBORObject o) {\n      CBORObject o2 = FromBytesTestAB(CheckEncodeToBytes(o));\n      TestCommon.CompareTestEqual(o, o2);\n      TestNumber(o);\n      TestCommon.AssertEqualsHashCode(o, o2);\n    }\n\n    public static void AssertJSONSer(CBORObject o, String s) {\n      if (!s.Equals(o.ToJSONString(), StringComparison.Ordinal)) {\n        Assert.AreEqual(s, o.ToJSONString(), \"o is not equal to s\");\n      }\n      byte[] bytes = CheckEncodeToBytes(o);\n      // Test round-tripping\n      CBORObject o2 = FromBytesTestAB(bytes);\n      if (!s.Equals(o2.ToJSONString(), StringComparison.Ordinal)) {\n        string msg = \"o2 is not equal to s:\\no = \" +\n          TestCommon.ToByteArrayString(bytes) +\n          \"\\no2 = \" + TestCommon.ToByteArrayString(o2.EncodeToBytes()) +\n          \"\\no2string = \" + o2.ToString();\n        Assert.AreEqual(s, o2.ToJSONString(), msg);\n      }\n      TestNumber(o);\n      TestCommon.AssertEqualsHashCode(o, o2);\n    }\n\n    // Tests the equivalence of the DecodeFromBytes and Read methods.\n    public static CBORObject FromBytesTestAB(byte[] b, CBOREncodeOptions\noptions) {\n      CBORObject oa = FromBytesA(b, options);\n      CBORObject ob = FromBytesB(b, options);\n      if (!oa.Equals(ob)) {\n        Assert.AreEqual(oa, ob);\n      }\n      return oa;\n    }\n\n    private static CBORObject FromBytesA(byte[] b, CBOREncodeOptions options) {\n      return CBORObject.DecodeFromBytes(b, options);\n    }\n\n    private static CBORObject FromBytesB(byte[] b, CBOREncodeOptions options) {\n      using (var ms = new System.IO.MemoryStream(b)) {\n        CBORObject o = CBORObject.Read(ms, options);\n        if (ms.Position != ms.Length) {\n          throw new CBORException(\"not at EOF\");\n        }\n        return o;\n      }\n    }\n\n    // Tests the equivalence of the DecodeFromBytes and Read methods.\n    public static CBORObject FromBytesTestAB(byte[] b) {\n      CBORObject oa = FromBytesA(b);\n      CBORObject ob = FromBytesB(b);\n      if (!oa.Equals(ob)) {\n        Assert.AreEqual(oa, ob);\n      }\n      return oa;\n    }\n\n    private static CBORObject FromBytesA(byte[] b) {\n      return CBORObject.DecodeFromBytes(b);\n    }\n\n    private static CBORObject FromBytesB(byte[] b) {\n      using (var ms = new System.IO.MemoryStream(b)) {\n        CBORObject o = CBORObject.Read(ms);\n        if (ms.Position != ms.Length) {\n          throw new CBORException(\"not at EOF\");\n        }\n        return o;\n      }\n    }\n  }\n}\n", "/*\nWritten in 2013-2018 by Peter O.\nAny copyright to this work is released to the Public Domain.\nIn case this is not possible, this work is also\nlicensed under Creative Commons Zero (CC0):\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\n */\nusing System;\nusing System.Text;\nusing NUnit.Framework;\n\nnamespace Test {\n  public static class TestCommon {\n    private const string Digits = \"0123456789\";\n\n    public static int StringToInt(string str) {\n      var neg = false;\n      var i = 0;\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (str.Length > 0 && str[0] == '-') {\n        neg = true;\n        ++i;\n      }\n      if (i == str.Length) {\n        throw new FormatException();\n      }\n      var ret = 0;\n      while (i < str.Length) {\n        int c = str[i];\n        ++i;\n        if (c >= '0' && c <= '9') {\n          int x = c - '0';\n          if (ret > 214748364) {\n            throw new FormatException();\n          }\n          ret *= 10;\n          if (ret == 2147483640) {\n            if (neg && x == 8) {\n              if (i != str.Length) {\n                throw new FormatException();\n              }\n              return Int32.MinValue;\n            }\n            if (x > 7) {\n              throw new FormatException();\n            }\n          }\n          ret += x;\n        } else {\n          throw new FormatException();\n        }\n      }\n      return neg ? -ret : ret;\n    }\n\n    public static long StringToLong(string str) {\n      var neg = false;\n      var i = 0;\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (str.Length > 0 && str[0] == '-') {\n        neg = true;\n        ++i;\n      }\n      if (i == str.Length) {\n        throw new FormatException();\n      }\n      long ret = 0;\n      while (i < str.Length) {\n        int c = str[i];\n        ++i;\n        if (c >= '0' && c <= '9') {\n          int x = c - '0';\n          if ((long)ret > 922337203685477580L) {\n            throw new FormatException();\n          }\n          ret *= 10;\n          if ((long)ret == 9223372036854775800L) {\n            if (neg && x == 8) {\n              if (i != str.Length) {\n                throw new FormatException();\n              }\n              return Int64.MinValue;\n            }\n            if (x > 7) {\n              throw new FormatException();\n            }\n          }\n          ret += x;\n        } else {\n          throw new FormatException();\n        }\n      }\n      return neg ? -ret : ret;\n    }\n\n    public static void AssertByteArraysEqual(byte[] arr1, byte[] arr2) {\n      if (!ByteArraysEqual(arr1, arr2)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertByteArraysEqual(\n      byte[] arr1,\n      int offset,\n      int length,\n      byte[] arr2) {\n      if (!ByteArraysEqual(\n         arr1,\n         offset,\n         length,\n         arr2,\n         0,\n         arr2 == null ? 0 : arr2.Length)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertByteArraysEqual(\n      byte[] arr1,\n      byte[] arr2,\n      int offset2,\n      int length2) {\n      if (!ByteArraysEqual(\n        arr1,\n        0,\n        arr1 == null ? 0 : arr1.Length,\n        arr2,\n        offset2,\n        length2)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertByteArraysEqual(\n      byte[] arr1,\n      int offset,\n      int length,\n      byte[] arr2,\n      int offset2,\n      int length2) {\n      if (!ByteArraysEqual(arr1, offset, length, arr2, offset2, length2)) {\n        Assert.Fail(\"Expected \" + ToByteArrayString(arr1) + \",\\ngot..... \" +\n          ToByteArrayString(arr2));\n      }\n    }\n\n    public static void AssertNotEqual(object o, object o2, string msg) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (o.Equals(o2)) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o,\n          o2,\n          \"Unexpectedly equal\");\n        Assert.Fail(str);\n      }\n    }\n\n    public static void AssertEquals(object o, object o2, string msg) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (!o.Equals(o2)) {\n        Assert.AreEqual(o, o2, msg);\n      }\n    }\n\n    public static void AssertNotEqual(Object o, Object o2) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (o.Equals(o2)) {\n        string str = ObjectMessages(\n          o,\n          o2,\n          \"Unexpectedly equal\");\n        Assert.Fail(str);\n      }\n    }\n\n    public static void AssertEquals(Object o, Object o2) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (!o.Equals(o2)) {\n        Assert.AreEqual(o, o2);\n      }\n    }\n\n    public static void AssertEqualsHashCode(Object o, Object o2) {\n      if (o == null) {\n        throw new ArgumentNullException(nameof(o));\n      }\n      if (o.Equals(o2)) {\n        if (o2 == null) {\n          throw new ArgumentNullException(nameof(o2));\n        }\n        if (!o2.Equals(o)) {\n          Assert.Fail(\n            String.Empty + o + \" equals \" + o2 + \" but not vice versa\");\n        }\n        // Test for the guarantee that equal objects\n        // must have equal hash codes\n        if (o2.GetHashCode() != o.GetHashCode()) {\n          // Don't use Assert.AreEqual directly because it has\n          // quite a lot of overhead\n          Assert.Fail(\n            String.Empty + o + \" and \" + o2 + \" don't have equal hash codes\");\n        }\n      } else {\n        if (o2 == null) {\n          throw new ArgumentNullException(nameof(o2));\n        }\n        if (o2.Equals(o)) {\n          Assert.Fail(String.Empty + o + \" does not equal \" + o2 +\n            \" but not vice versa\");\n        }\n        // At least check that GetHashCode doesn't throw\n        try {\n          o.GetHashCode();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n        try {\n          o2.GetHashCode();\n        } catch (Exception ex) {\n          Assert.Fail(ex.ToString());\n          throw new InvalidOperationException(String.Empty, ex);\n        }\n      }\n    }\n\n    public static void CompareTestConsistency<T>(T o1, T o2, T o3) where T :\n      IComparable<T> {\n      if (o1 == null) {\n        throw new ArgumentNullException(nameof(o1));\n      }\n      if (o2 == null) {\n        throw new ArgumentNullException(nameof(o2));\n      }\n      if (o3 == null) {\n        throw new ArgumentNullException(nameof(o3));\n      }\n      int cmp = CompareTestReciprocal(o1, o2);\n      int cmp2 = CompareTestReciprocal(o2, o3);\n      int cmp3 = CompareTestReciprocal(o1, o3);\n      Assert.AreEqual(cmp == 0, o1.Equals(o2));\n      Assert.AreEqual(cmp == 0, o2.Equals(o1));\n      Assert.AreEqual(cmp2 == 0, o2.Equals(o3));\n      Assert.AreEqual(cmp2 == 0, o3.Equals(o2));\n      Assert.AreEqual(cmp3 == 0, o1.Equals(o3));\n      Assert.AreEqual(cmp3 == 0, o3.Equals(o1));\n    }\n\n    public static void CompareTestNotEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) == 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Unexpectedly equal: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestNotEqual<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) == 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Unexpectedly equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) != 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Not equal: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestEqual<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) != 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestEqualAndConsistent<T>(T o1, T o2) where T :\n      IComparable<T> {\n      CompareTestEqualAndConsistent(o1, o2, null);\n    }\n\n    public static void CompareTestEqualAndConsistent<T>(\n      T o1,\n      T o2,\n      string msg) where T : IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) != 0) {\n        msg = (msg == null ? String.Empty : (msg + \"\\r\\n\")) +\n        \"Not equal: \" + CompareTestReciprocal(o1, o2);\n        Assert.Fail(ObjectMessages(\n          o1,\n          o2,\n          msg));\n      }\n      if (!o1.Equals(o2)) {\n        msg = (msg == null ? String.Empty : (msg + \"\\r\\n\")) +\n        \"Not equal: \" + CompareTestReciprocal(o1, o2);\n        Assert.Fail(ObjectMessages(\n          o1,\n          o2,\n          msg));\n      }\n    }\n\n    public static void CompareTestGreater<T>(T o1, T o2) where T :\n      IComparable<T> {\n      CompareTestLess(o2, o1);\n    }\n\n    public static void CompareTestLess<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) >= 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Not less: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestGreaterEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      CompareTestLessEqual(o2, o1);\n    }\n\n    public static void CompareTestLessEqual<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) > 0) {\n        Assert.Fail(ObjectMessages(\n            o1,\n            o2,\n            \"Not less or equal: \" + CompareTestReciprocal(o1, o2)));\n      }\n    }\n\n    public static void CompareTestLess<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) >= 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not less: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestLessEqual<T>(T o1, T o2, string msg)\n    where T : IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) > 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not less or equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestGreater<T>(T o1, T o2, string msg) where T :\n      IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) <= 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not greater: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static void CompareTestGreaterEqual<T>(T o1, T o2, string msg) where\n    T : IComparable<T> {\n      if (CompareTestReciprocal(o1, o2) < 0) {\n        string str = msg + \"\\r\\n\" + ObjectMessages(\n          o1,\n          o2,\n          \"Not greater or equal: \" + CompareTestReciprocal(o1, o2));\n        Assert.Fail(str);\n      }\n    }\n\n    public static int CompareTestReciprocal<T>(T o1, T o2) where T :\n      IComparable<T> {\n      if (o1 == null) {\n        throw new ArgumentNullException(nameof(o1));\n      }\n      if (o2 == null) {\n        throw new ArgumentNullException(nameof(o2));\n      }\n      int cmp, cmp2;\n      cmp = Math.Sign(o1.CompareTo(o2));\n      cmp2 = Math.Sign(o2.CompareTo(o1));\n      if (-cmp2 != cmp) {\n        Assert.AreEqual(cmp, -cmp2, ObjectMessages(o1, o2, \"Not reciprocal\"));\n      }\n      return cmp;\n    }\n\n    public static void CompareTestRelations<T>(T o1, T o2, T o3) where T :\n      IComparable<T> {\n      if (o1 == null) {\n        throw new ArgumentNullException(nameof(o1));\n      }\n      if (o2 == null) {\n        throw new ArgumentNullException(nameof(o2));\n      }\n      if (o3 == null) {\n        throw new ArgumentNullException(nameof(o3));\n      }\n      if (o1.CompareTo(o1) != 0) {\n        Assert.Fail(o1.ToString());\n      }\n      if (o2.CompareTo(o2) != 0) {\n        Assert.Fail(o2.ToString());\n      }\n      if (o3.CompareTo(o3) != 0) {\n        Assert.Fail(o3.ToString());\n      }\n      int cmp12 = CompareTestReciprocal(o1, o2);\n      int cmp23 = CompareTestReciprocal(o2, o3);\n      int cmp13 = CompareTestReciprocal(o1, o3);\n      // CompareTestReciprocal tests CompareTo both\n      // ways, so shortcutting by negating the values\n      // is allowed here\n      int cmp21 = -cmp12;\n      int cmp32 = -cmp23;\n      int cmp31 = -cmp13;\n      // Transitivity checks\n      for (int i = -1; i <= 1; ++i) {\n        if (cmp12 == i) {\n          if (cmp23 == i && cmp13 != i) {\n            Assert.Fail(ObjectMessages(o1, o2, o3, \"Not transitive\"));\n          }\n        }\n        if (cmp23 == i) {\n          if (cmp31 == i && cmp21 != i) {\n            Assert.Fail(ObjectMessages(o1, o2, o3, \"Not transitive\"));\n          }\n        }\n        if (cmp31 == i) {\n          if (cmp12 == i && cmp32 != i) {\n            Assert.Fail(ObjectMessages(o1, o2, o3, \"Not transitive\"));\n          }\n        }\n      }\n    }\n\n    public static string IntToString(int value) {\n      if (value == 0) {\n        return \"0\";\n      }\n      if (value == Int32.MinValue) {\n        return \"-2147483648\";\n      }\n      bool neg = value < 0;\n      if (neg) {\n        value = -value;\n      }\n      char[] chars;\n      int count;\n      if (value < 100000) {\n        if (neg) {\n         chars = new char[6];\n         count = 5;\n        } else {\n         chars = new char[5];\n         count = 4;\n        }\n        while (value > 9) {\n          int intdivvalue = unchecked((((value >> 1) * 52429) >> 18) & 16383);\n          char digit = Digits[(int)(value - (intdivvalue * 10))];\n          chars[count--] = digit;\n          value = intdivvalue;\n        }\n        if (value != 0) {\n          chars[count--] = Digits[(int)value];\n        }\n        if (neg) {\n          chars[count] = '-';\n        } else {\n          ++count;\n        }\n        return new String(chars, count, chars.Length - count);\n      }\n      chars = new char[12];\n      count = 11;\n      while (value >= 163840) {\n        int intdivvalue = value / 10;\n        char digit = Digits[(int)(value - (intdivvalue * 10))];\n        chars[count--] = digit;\n        value = intdivvalue;\n      }\n      while (value > 9) {\n        int intdivvalue = unchecked((((value >> 1) * 52429) >> 18) & 16383);\n        char digit = Digits[(int)(value - (intdivvalue * 10))];\n        chars[count--] = digit;\n        value = intdivvalue;\n      }\n      if (value != 0) {\n        chars[count--] = Digits[(int)value];\n      }\n      if (neg) {\n        chars[count] = '-';\n      } else {\n        ++count;\n      }\n      return new String(chars, count, 12 - count);\n    }\n\n    public static string LongToString(long longValue) {\n      if (longValue == Int64.MinValue) {\n        return \"-9223372036854775808\";\n      }\n      if (longValue == 0L) {\n        return \"0\";\n      }\n      bool neg = longValue < 0;\n      var count = 0;\n      char[] chars;\n      int intlongValue = unchecked((int)longValue);\n      if ((long)intlongValue == longValue) {\n        return IntToString(intlongValue);\n      } else {\n        chars = new char[24];\n        count = 23;\n        if (neg) {\n          longValue = -longValue;\n        }\n        while (longValue >= 163840) {\n          long divValue = longValue / 10;\n          char digit = Digits[(int)(longValue - (divValue * 10))];\n          chars[count--] = digit;\n          longValue = divValue;\n        }\n        while (longValue > 9) {\n          long divValue = unchecked((((longValue >> 1) * 52429) >> 18) & 16383);\n          char digit = Digits[(int)(longValue - (divValue * 10))];\n          chars[count--] = digit;\n          longValue = divValue;\n        }\n        if (longValue != 0) {\n          chars[count--] = Digits[(int)longValue];\n        }\n        if (neg) {\n          chars[count] = '-';\n        } else {\n          ++count;\n        }\n        return new String(chars, count, 24 - count);\n      }\n    }\n\n    public static string ObjectMessages(\n      object o1,\n      object o2,\n      String s) {\n      return s + \":\\n\" + o1 + \" and\\n\" + o2;\n    }\n\n    public static string ObjectMessages(\n      object o1,\n      object o2,\n      object o3,\n      String s) {\n      return s + \":\\n\" + o1 + \" and\\n\" + o2 + \" and\\n\" + o3;\n    }\n\n    private const int RepeatDivideThreshold = 10000;\n\n    public static string Repeat(char c, int num) {\n      if (num < 0) {\n        throw new ArgumentException(\"num (\" + num +\n           \") is not greater or equal to 0\");\n      }\n      var sb = new StringBuilder(num);\n      if (num > RepeatDivideThreshold) {\n        string sb2 = Repeat(c, RepeatDivideThreshold);\n        int count = num / RepeatDivideThreshold;\n        int rem = num % RepeatDivideThreshold;\n        for (var i = 0; i < count; ++i) {\n          sb.Append(sb2);\n        }\n        for (var i = 0; i < rem; ++i) {\n          sb.Append(c);\n        }\n      } else {\n        for (var i = 0; i < num; ++i) {\n          sb.Append(c);\n        }\n      }\n      return sb.ToString();\n    }\n\n    public static string Repeat(String str, int num) {\n      if (num < 0) {\n        throw new ArgumentException(\"num (\" + num +\n           \") is not greater or equal to 0\");\n      }\n      if (str == null) {\n        throw new ArgumentNullException(nameof(str));\n      }\n      if (str.Length == 1) {\n        return Repeat(str[0], num);\n      }\n      var sb = new StringBuilder(num * str.Length);\n      for (var i = 0; i < num; ++i) {\n        sb.Append(str);\n      }\n      return sb.ToString();\n    }\n\n    public static string ToByteArrayString(byte[] bytes) {\n      return (bytes == null) ? \"null\" : ToByteArrayString(\n         bytes,\n         0,\n         bytes.Length);\n    }\n\n    public static string ToByteArrayString(\n       byte[] bytes,\n       int offset,\n       int length) {\n      if (bytes == null) {\n        return \"null\";\n      }\n      if (bytes == null) {\n        throw new ArgumentNullException(nameof(bytes));\n      }\n      if (offset < 0) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not\" +\n\"\\u0020greater or equal to 0\");\n      }\n      if (offset > bytes.Length) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not less\" +\n\"\\u0020or equal to \" + bytes.Length);\n      }\n      if (length < 0) {\n        throw new ArgumentException(\" (\" + length + \") is not greater or\" +\n\"\\u0020equal to 0\");\n      }\n      if (length > bytes.Length) {\n        throw new ArgumentException(\" (\" + length + \") is not less or equal\" +\n\"\\u0020to \" + bytes.Length);\n      }\n      if (bytes.Length - offset < length) {\n        throw new ArgumentException(\"\\\"bytes\\\" + \\\"'s length minus \\\" +\" +\n\"\\u0020offset (\" + (bytes.Length - offset) + \") is not greater or equal to \" +\nlength);\n      }\n      var sb = new System.Text.StringBuilder();\n      const string ValueHex = \"0123456789ABCDEF\";\n      sb.Append(\"new byte[] { \");\n      for (var i = 0; i < length; ++i) {\n        if (i > 0) {\n          sb.Append(',');\n        }\n        if ((bytes[offset + i] & 0x80) != 0) {\n          sb.Append(\"(byte)0x\");\n        } else {\n          sb.Append(\"0x\");\n        }\n        sb.Append(ValueHex[(bytes[offset + i] >> 4) & 0xf]);\n        sb.Append(ValueHex[bytes[offset + i] & 0xf]);\n      }\n      sb.Append('}');\n      return sb.ToString();\n    }\n\n    private static bool ByteArraysEqual(\n      byte[] arr1,\n      int offset,\n      int length,\n      byte[] arr2,\n      int offset2,\n      int length2) {\n      if (arr1 == null) {\n        return arr2 == null;\n      }\n      if (arr2 == null) {\n        return false;\n      }\n      if (offset < 0) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not\" +\n\"\\u0020greater or equal to 0\");\n      }\n      if (offset > arr1.Length) {\n        throw new ArgumentException(\"\\\"offset\\\" (\" + offset + \") is not less\" +\n\"\\u0020or equal to \" + arr1.Length);\n      }\n      if (length < 0) {\n        throw new ArgumentException(\" (\" + length + \") is not greater or\" +\n\"\\u0020equal to 0\");\n      }\n      if (length > arr1.Length) {\n        throw new ArgumentException(\" (\" + length + \") is not less or equal\" +\n\"\\u0020to \" + arr1.Length);\n      }\n      if (arr1.Length - offset < length) {\n        throw new ArgumentException(\"\\\"arr1\\\" + \\\"'s length minus \\\" +\" +\n\"\\u0020offset (\" + (arr1.Length - offset) + \") is not greater or equal to \" +\nlength);\n      }\n      if (arr2 == null) {\n        throw new ArgumentNullException(nameof(arr2));\n      }\n      if (offset2 < 0) {\n        throw new ArgumentException(\"\\\"offset2\\\" (\" + offset2 + \") is not\" +\n\"\\u0020greater or equal to 0\");\n      }\n      if (offset2 > arr2.Length) {\n        throw new ArgumentException(\"\\\"offset2\\\" (\" + offset2 + \") is not\" +\n\"\\u0020less or equal to \" + arr2.Length);\n      }\n      if (length2 < 0) {\n        throw new ArgumentException(\" (\" + length2 + \") is not greater or\" +\n\"\\u0020equal to 0\");\n      }\n      if (length2 > arr2.Length) {\n        throw new ArgumentException(\" (\" + length2 + \") is not less or equal\" +\n\"\\u0020to \" + arr2.Length);\n      }\n      if (arr2.Length - offset2 < length2) {\n        throw new ArgumentException(\"\\\"arr2\\\"'s length minus \" +\n\"\\u0020offset2 (\" + (arr2.Length - offset2) + \") is not greater or equal to \" +\nlength2);\n      }\n      if (length != length2) {\n        return false;\n      }\n      for (var i = 0; i < length; ++i) {\n        if (arr1[offset + i] != arr2[offset2 + i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    public static bool ByteArraysEqual(byte[] arr1, byte[] arr2) {\n      if (arr1 == null) {\n        return arr2 == null;\n      }\n      if (arr2 == null) {\n        return false;\n      }\n      if (arr1.Length != arr2.Length) {\n        return false;\n      }\n      for (var i = 0; i < arr1.Length; ++i) {\n        if (arr1[i] != arr2[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n"], "filenames": ["CBOR/PeterO/Cbor/CBORObject.cs", "CBOR/PeterO/Cbor/PropertyMap.cs", "CBORTest/CBORGenerator.cs", "CBORTest/CBORObjectTest.cs", "CBORTest/CBORTest.csproj", "CBORTest/CBORTestCommon.cs", "CBORTest/TestCommon.cs"], "buggy_code_start_loc": [7945, 38, 87, 9723, 3, 122, 764], "buggy_code_end_loc": [7951, 895, 233, 9723, 4, 123, 765], "fixing_code_start_loc": [7945, 38, 87, 9724, 3, 122, 764], "fixing_code_end_loc": [7947, 917, 280, 9863, 4, 124, 765], "type": "CWE-407", "message": "PeterO.Cbor versions 4.0.0 through 4.5.0 are vulnerable to a denial of \nservice vulnerability. An attacker may trigger the denial of service \ncondition by providing crafted data to the DecodeFromBytes or other \ndecoding mechanisms in PeterO.Cbor. Depending on the usage of the \nlibrary, an unauthenticated and remote attacker may be able to cause the\n denial of service condition.\n", "other": {"cve": {"id": "CVE-2024-21909", "sourceIdentifier": "disclosure@vulncheck.com", "published": "2024-01-03T16:15:09.003", "lastModified": "2024-02-08T02:15:40.883", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PeterO.Cbor versions 4.0.0 through 4.5.0 are vulnerable to a denial of \nservice vulnerability. An attacker may trigger the denial of service \ncondition by providing crafted data to the DecodeFromBytes or other \ndecoding mechanisms in PeterO.Cbor. Depending on the usage of the \nlibrary, an unauthenticated and remote attacker may be able to cause the\n denial of service condition.\n"}, {"lang": "es", "value": "Las versiones de PeterO.Cbor 4.0.0 a 4.5.0 son vulnerables a una vulnerabilidad de denegaci\u00f3n de servicio. Un atacante puede desencadenar la condici\u00f3n de denegaci\u00f3n de servicio proporcionando datos manipulados a DecodeFromBytes u otros mecanismos de decodificaci\u00f3n en PeterO.Cbor. Dependiendo del uso de la biblioteca, un atacante remoto y no autenticado puede provocar la condici\u00f3n de denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-407"}]}, {"source": "disclosure@vulncheck.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-407"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:peteroupc:cbor:*:*:*:*:*:.net:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.5.1", "matchCriteriaId": "1ACE4764-C56D-427B-99DA-52922CA6C062"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-6r92-cgxc-r5fg", "source": "disclosure@vulncheck.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/peteroupc/CBOR/commit/b4117dbbb4cd5a4a963f9d0c9aa132f033e15b95", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/peteroupc/CBOR/compare/v4.5...v4.5.1", "source": "disclosure@vulncheck.com", "tags": ["Release Notes"]}, {"url": "https://github.com/peteroupc/CBOR/security/advisories/GHSA-6r92-cgxc-r5fg", "source": "disclosure@vulncheck.com", "tags": ["Third Party Advisory"]}, {"url": "https://vulncheck.com/advisories/vc-advisory-GHSA-6r92-cgxc-r5fg", "source": "disclosure@vulncheck.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/peteroupc/CBOR/commit/b4117dbbb4cd5a4a963f9d0c9aa132f033e15b95"}}