{"buggy_code": ["\"\"\"Tornado handlers for nbconvert.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport io\nimport os\nimport zipfile\n\nfrom tornado import web, escape\nfrom tornado.log import app_log\n\nfrom ..base.handlers import (\n    IPythonHandler, FilesRedirectHandler,\n    path_regex,\n)\nfrom nbformat import from_dict\n\nfrom ipython_genutils.py3compat import cast_bytes\nfrom ipython_genutils import text\n\ndef find_resource_files(output_files_dir):\n    files = []\n    for dirpath, dirnames, filenames in os.walk(output_files_dir):\n        files.extend([os.path.join(dirpath, f) for f in filenames])\n    return files\n\ndef respond_zip(handler, name, output, resources):\n    \"\"\"Zip up the output and resource files and respond with the zip file.\n\n    Returns True if it has served a zip file, False if there are no resource\n    files, in which case we serve the plain output file.\n    \"\"\"\n    # Check if we have resource files we need to zip\n    output_files = resources.get('outputs', None)\n    if not output_files:\n        return False\n\n    # Headers\n    zip_filename = os.path.splitext(name)[0] + '.zip'\n    handler.set_attachment_header(zip_filename)\n    handler.set_header('Content-Type', 'application/zip')\n    handler.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')\n\n    # Prepare the zip file\n    buffer = io.BytesIO()\n    zipf = zipfile.ZipFile(buffer, mode='w', compression=zipfile.ZIP_DEFLATED)\n    output_filename = os.path.splitext(name)[0] + resources['output_extension']\n    zipf.writestr(output_filename, cast_bytes(output, 'utf-8'))\n    for filename, data in output_files.items():\n        zipf.writestr(os.path.basename(filename), data)\n    zipf.close()\n\n    handler.finish(buffer.getvalue())\n    return True\n\ndef get_exporter(format, **kwargs):\n    \"\"\"get an exporter, raising appropriate errors\"\"\"\n    # if this fails, will raise 500\n    try:\n        from nbconvert.exporters.base import get_exporter\n    except ImportError as e:\n        raise web.HTTPError(500, \"Could not import nbconvert: %s\" % e)\n\n    try:\n        Exporter = get_exporter(format)\n    except KeyError:\n        # should this be 400?\n        raise web.HTTPError(404, u\"No exporter for format: %s\" % format)\n\n    try:\n        return Exporter(**kwargs)\n    except Exception as e:\n        app_log.exception(\"Could not construct Exporter: %s\", Exporter)\n        raise web.HTTPError(500, \"Could not construct Exporter: %s\" % e)\n\nclass NbconvertFileHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = ('GET',)\n\n    @web.authenticated\n    def get(self, format, path):\n\n        exporter = get_exporter(format, config=self.config, log=self.log)\n\n        path = path.strip('/')\n        # If the notebook relates to a real file (default contents manager),\n        # give its path to nbconvert.\n        if hasattr(self.contents_manager, '_get_os_path'):\n            os_path = self.contents_manager._get_os_path(path)\n            ext_resources_dir, basename = os.path.split(os_path)\n        else:\n            ext_resources_dir = None\n\n        model = self.contents_manager.get(path=path)\n        name = model['name']\n        if model['type'] != 'notebook':\n            # not a notebook, redirect to files\n            return FilesRedirectHandler.redirect_to_files(self, path)\n\n        nb = model['content']\n\n        self.set_header('Last-Modified', model['last_modified'])\n\n        # create resources dictionary\n        mod_date = model['last_modified'].strftime(text.date_format)\n        nb_title = os.path.splitext(name)[0]\n\n        resource_dict = {\n            \"metadata\": {\n                \"name\": nb_title,\n                \"modified_date\": mod_date\n            },\n            \"config_dir\": self.application.settings['config_dir']\n        }\n\n        if ext_resources_dir:\n            resource_dict['metadata']['path'] = ext_resources_dir\n\n        try:\n            output, resources = exporter.from_notebook_node(\n                nb,\n                resources=resource_dict\n            )\n        except Exception as e:\n            self.log.exception(\"nbconvert failed: %s\", e)\n            raise web.HTTPError(500, \"nbconvert failed: %s\" % e)\n\n        if respond_zip(self, name, output, resources):\n            return\n\n        # Force download if requested\n        if self.get_argument('download', 'false').lower() == 'true':\n            filename = os.path.splitext(name)[0] + resources['output_extension']\n            self.set_attachment_header(filename)\n\n        # MIME type\n        if exporter.output_mimetype:\n            self.set_header('Content-Type',\n                            '%s; charset=utf-8' % exporter.output_mimetype)\n\n        self.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')\n        self.finish(output)\n\nclass NbconvertPostHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('POST',)\n\n    @web.authenticated\n    def post(self, format):\n        exporter = get_exporter(format, config=self.config)\n\n        model = self.get_json_body()\n        name = model.get('name', 'notebook.ipynb')\n        nbnode = from_dict(model['content'])\n\n        try:\n            output, resources = exporter.from_notebook_node(nbnode, resources={\n                \"metadata\": {\"name\": name[:name.rfind('.')],},\n                \"config_dir\": self.application.settings['config_dir'],\n            })\n        except Exception as e:\n            raise web.HTTPError(500, \"nbconvert failed: %s\" % e)\n\n        if respond_zip(self, name, output, resources):\n            return\n\n        # MIME type\n        if exporter.output_mimetype:\n            self.set_header('Content-Type',\n                            '%s; charset=utf-8' % exporter.output_mimetype)\n\n        self.finish(output)\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n_format_regex = r\"(?P<format>\\w+)\"\n\n\ndefault_handlers = [\n    (r\"/nbconvert/%s\" % _format_regex, NbconvertPostHandler),\n    (r\"/nbconvert/%s%s\" % (_format_regex, path_regex),\n         NbconvertFileHandler),\n]\n"], "fixing_code": ["\"\"\"Tornado handlers for nbconvert.\"\"\"\n\n# Copyright (c) Jupyter Development Team.\n# Distributed under the terms of the Modified BSD License.\n\nimport io\nimport os\nimport zipfile\n\nfrom tornado import web, escape\nfrom tornado.log import app_log\n\nfrom ..base.handlers import (\n    IPythonHandler, FilesRedirectHandler,\n    path_regex,\n)\nfrom nbformat import from_dict\n\nfrom ipython_genutils.py3compat import cast_bytes\nfrom ipython_genutils import text\n\ndef find_resource_files(output_files_dir):\n    files = []\n    for dirpath, dirnames, filenames in os.walk(output_files_dir):\n        files.extend([os.path.join(dirpath, f) for f in filenames])\n    return files\n\ndef respond_zip(handler, name, output, resources):\n    \"\"\"Zip up the output and resource files and respond with the zip file.\n\n    Returns True if it has served a zip file, False if there are no resource\n    files, in which case we serve the plain output file.\n    \"\"\"\n    # Check if we have resource files we need to zip\n    output_files = resources.get('outputs', None)\n    if not output_files:\n        return False\n\n    # Headers\n    zip_filename = os.path.splitext(name)[0] + '.zip'\n    handler.set_attachment_header(zip_filename)\n    handler.set_header('Content-Type', 'application/zip')\n    handler.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')\n\n    # Prepare the zip file\n    buffer = io.BytesIO()\n    zipf = zipfile.ZipFile(buffer, mode='w', compression=zipfile.ZIP_DEFLATED)\n    output_filename = os.path.splitext(name)[0] + resources['output_extension']\n    zipf.writestr(output_filename, cast_bytes(output, 'utf-8'))\n    for filename, data in output_files.items():\n        zipf.writestr(os.path.basename(filename), data)\n    zipf.close()\n\n    handler.finish(buffer.getvalue())\n    return True\n\ndef get_exporter(format, **kwargs):\n    \"\"\"get an exporter, raising appropriate errors\"\"\"\n    # if this fails, will raise 500\n    try:\n        from nbconvert.exporters.base import get_exporter\n    except ImportError as e:\n        raise web.HTTPError(500, \"Could not import nbconvert: %s\" % e)\n\n    try:\n        Exporter = get_exporter(format)\n    except KeyError:\n        # should this be 400?\n        raise web.HTTPError(404, u\"No exporter for format: %s\" % format)\n\n    try:\n        return Exporter(**kwargs)\n    except Exception as e:\n        app_log.exception(\"Could not construct Exporter: %s\", Exporter)\n        raise web.HTTPError(500, \"Could not construct Exporter: %s\" % e)\n\nclass NbconvertFileHandler(IPythonHandler):\n\n    SUPPORTED_METHODS = ('GET',)\n\n    @property\n    def content_security_policy(self):\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the notebook server.\n        return super(NbconvertFileHandler, self).content_security_policy + \\\n               \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    def get(self, format, path):\n\n        exporter = get_exporter(format, config=self.config, log=self.log)\n\n        path = path.strip('/')\n        # If the notebook relates to a real file (default contents manager),\n        # give its path to nbconvert.\n        if hasattr(self.contents_manager, '_get_os_path'):\n            os_path = self.contents_manager._get_os_path(path)\n            ext_resources_dir, basename = os.path.split(os_path)\n        else:\n            ext_resources_dir = None\n\n        model = self.contents_manager.get(path=path)\n        name = model['name']\n        if model['type'] != 'notebook':\n            # not a notebook, redirect to files\n            return FilesRedirectHandler.redirect_to_files(self, path)\n\n        nb = model['content']\n\n        self.set_header('Last-Modified', model['last_modified'])\n\n        # create resources dictionary\n        mod_date = model['last_modified'].strftime(text.date_format)\n        nb_title = os.path.splitext(name)[0]\n\n        resource_dict = {\n            \"metadata\": {\n                \"name\": nb_title,\n                \"modified_date\": mod_date\n            },\n            \"config_dir\": self.application.settings['config_dir']\n        }\n\n        if ext_resources_dir:\n            resource_dict['metadata']['path'] = ext_resources_dir\n\n        try:\n            output, resources = exporter.from_notebook_node(\n                nb,\n                resources=resource_dict\n            )\n        except Exception as e:\n            self.log.exception(\"nbconvert failed: %s\", e)\n            raise web.HTTPError(500, \"nbconvert failed: %s\" % e)\n\n        if respond_zip(self, name, output, resources):\n            return\n\n        # Force download if requested\n        if self.get_argument('download', 'false').lower() == 'true':\n            filename = os.path.splitext(name)[0] + resources['output_extension']\n            self.set_attachment_header(filename)\n\n        # MIME type\n        if exporter.output_mimetype:\n            self.set_header('Content-Type',\n                            '%s; charset=utf-8' % exporter.output_mimetype)\n\n        self.set_header('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0')\n        self.finish(output)\n\nclass NbconvertPostHandler(IPythonHandler):\n    SUPPORTED_METHODS = ('POST',)\n\n    @property\n    def content_security_policy(self):\n        # In case we're serving HTML/SVG, confine any Javascript to a unique\n        # origin so it can't interact with the notebook server.\n        return super(NbconvertPostHandler, self).content_security_policy + \\\n               \"; sandbox allow-scripts\"\n\n    @web.authenticated\n    def post(self, format):\n        exporter = get_exporter(format, config=self.config)\n\n        model = self.get_json_body()\n        name = model.get('name', 'notebook.ipynb')\n        nbnode = from_dict(model['content'])\n\n        try:\n            output, resources = exporter.from_notebook_node(nbnode, resources={\n                \"metadata\": {\"name\": name[:name.rfind('.')],},\n                \"config_dir\": self.application.settings['config_dir'],\n            })\n        except Exception as e:\n            raise web.HTTPError(500, \"nbconvert failed: %s\" % e)\n\n        if respond_zip(self, name, output, resources):\n            return\n\n        # MIME type\n        if exporter.output_mimetype:\n            self.set_header('Content-Type',\n                            '%s; charset=utf-8' % exporter.output_mimetype)\n\n        self.finish(output)\n\n\n#-----------------------------------------------------------------------------\n# URL to handler mappings\n#-----------------------------------------------------------------------------\n\n_format_regex = r\"(?P<format>\\w+)\"\n\n\ndefault_handlers = [\n    (r\"/nbconvert/%s\" % _format_regex, NbconvertPostHandler),\n    (r\"/nbconvert/%s%s\" % (_format_regex, path_regex),\n         NbconvertFileHandler),\n]\n"], "filenames": ["notebook/nbconvert/handlers.py"], "buggy_code_start_loc": [80], "buggy_code_end_loc": [147], "fixing_code_start_loc": [81], "fixing_code_end_loc": [162], "type": "CWE-79", "message": "Jupyter Notebook before 5.7.1 allows XSS via an untrusted notebook because nbconvert responses are considered to have the same origin as the notebook server. In other words, nbconvert endpoints can execute JavaScript with access to the server API. In notebook/nbconvert/handlers.py, NbconvertFileHandler and NbconvertPostHandler do not set a Content Security Policy to prevent this.", "other": {"cve": {"id": "CVE-2018-19351", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-18T17:29:00.267", "lastModified": "2020-11-19T07:15:11.907", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Jupyter Notebook before 5.7.1 allows XSS via an untrusted notebook because nbconvert responses are considered to have the same origin as the notebook server. In other words, nbconvert endpoints can execute JavaScript with access to the server API. In notebook/nbconvert/handlers.py, NbconvertFileHandler and NbconvertPostHandler do not set a Content Security Policy to prevent this."}, {"lang": "es", "value": "Jupyter Notebook en versiones anteriores a la 5.7.1 permite Cross-Site Scripting (XSS) mediante un notebook no fiable debido a que se considera que las respuestas nbconvert tienen el mismo origen que el servidor notebook. En otras palabras, los endpoints nbconvert pueden ejecutar JavaScript con acceso a la API del servidor. En notebook/nbconvert/handlers.py, NbconvertFileHandler y NbconvertPostHandler no establecen una pol\u00edtica de seguridad del contenido (CSP) para evitarlo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyter:notebook:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.1", "matchCriteriaId": "2B483C62-F6D1-4C8C-BDC1-693EB26DF0D3"}]}]}], "references": [{"url": "https://github.com/jupyter/notebook/blob/master/docs/source/changelog.rst", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/jupyter/notebook/commit/107a89fce5f413fb5728c1c5d2c7788e1fb17491", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/forum/#!topic/jupyter/hWzu2BSsplY", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/11/msg00033.html", "source": "cve@mitre.org"}, {"url": "https://pypi.org/project/notebook/#history", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jupyter/notebook/commit/107a89fce5f413fb5728c1c5d2c7788e1fb17491"}}