{"buggy_code": ["# -*- coding: utf-8 -*-\n\"\"\"\nThis module provide some helpers for advanced types parsing.\n\nYou can define you own parser using the same pattern:\n\n.. code-block:: python\n\n    def my_type(value):\n        if not condition:\n            raise ValueError('This is not my type')\n        return parse(value)\n\n    # Swagger documentation\n    my_type.__schema__ = {'type': 'string', 'format': 'my-custom-format'}\n\nThe last line allows you to document properly the type in the Swagger documentation.\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport re\nimport socket\n\nfrom datetime import datetime, time, timedelta\nfrom email.utils import parsedate_tz, mktime_tz\nfrom six.moves.urllib.parse import urlparse\n\nimport aniso8601\nimport pytz\n\n# Constants for upgrading date-based intervals to full datetimes.\nSTART_OF_DAY = time(0, 0, 0, tzinfo=pytz.UTC)\nEND_OF_DAY = time(23, 59, 59, 999999, tzinfo=pytz.UTC)\n\n\nnetloc_regex = re.compile(\n    r\"(?:(?P<auth>[^:@]+?(?::[^:@]*?)?)@)?\"  # basic auth\n    r\"(?:\"\n    r\"(?P<localhost>localhost)|\"  # localhost...\n    r\"(?P<ipv4>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|\"  # ...or ipv4\n    r\"(?:\\[?(?P<ipv6>[A-F0-9]*:[A-F0-9:]+)\\]?)|\"  # ...or ipv6\n    r\"(?P<domain>(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?))\"  # domain...\n    r\")\"\n    r\"(?::(?P<port>\\d+))?\"  # optional port\n    r\"$\",\n    re.IGNORECASE,\n)\n\n\nemail_regex = re.compile(\n    r\"^\" \"(?P<local>[^@]*[^@.])\" r\"@\" r\"(?P<server>[^@]+(?:\\.[^@]+)*)\" r\"$\",\n    re.IGNORECASE,\n)\n\ntime_regex = re.compile(r\"\\d{2}:\\d{2}\")\n\n\ndef ipv4(value):\n    \"\"\"Validate an IPv4 address\"\"\"\n    try:\n        socket.inet_aton(value)\n        if value.count(\".\") == 3:\n            return value\n    except socket.error:\n        pass\n    raise ValueError(\"{0} is not a valid ipv4 address\".format(value))\n\n\nipv4.__schema__ = {\"type\": \"string\", \"format\": \"ipv4\"}\n\n\ndef ipv6(value):\n    \"\"\"Validate an IPv6 address\"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, value)\n        return value\n    except socket.error:\n        raise ValueError(\"{0} is not a valid ipv4 address\".format(value))\n\n\nipv6.__schema__ = {\"type\": \"string\", \"format\": \"ipv6\"}\n\n\ndef ip(value):\n    \"\"\"Validate an IP address (both IPv4 and IPv6)\"\"\"\n    try:\n        return ipv4(value)\n    except ValueError:\n        pass\n    try:\n        return ipv6(value)\n    except ValueError:\n        raise ValueError(\"{0} is not a valid ip\".format(value))\n\n\nip.__schema__ = {\"type\": \"string\", \"format\": \"ip\"}\n\n\nclass URL(object):\n    \"\"\"\n    Validate an URL.\n\n    Example::\n\n        parser = reqparse.RequestParser()\n        parser.add_argument('url', type=inputs.URL(schemes=['http', 'https']))\n\n    Input to the ``URL`` argument will be rejected\n    if it does not match an URL with specified constraints.\n    If ``check`` is True it will also be rejected if the domain does not exists.\n\n    :param bool check: Check the domain exists (perform a DNS resolution)\n    :param bool ip: Allow IP (both ipv4/ipv6) as domain\n    :param bool local: Allow localhost (both string or ip) as domain\n    :param bool port: Allow a port to be present\n    :param bool auth: Allow authentication to be present\n    :param list|tuple schemes: Restrict valid schemes to this list\n    :param list|tuple domains: Restrict valid domains to this list\n    :param list|tuple exclude: Exclude some domains\n    \"\"\"\n\n    def __init__(\n        self,\n        check=False,\n        ip=False,\n        local=False,\n        port=False,\n        auth=False,\n        schemes=None,\n        domains=None,\n        exclude=None,\n    ):\n        self.check = check\n        self.ip = ip\n        self.local = local\n        self.port = port\n        self.auth = auth\n        self.schemes = schemes\n        self.domains = domains\n        self.exclude = exclude\n\n    def error(self, value, details=None):\n        msg = \"{0} is not a valid URL\"\n        if details:\n            msg = \". \".join((msg, details))\n        raise ValueError(msg.format(value))\n\n    def __call__(self, value):\n        parsed = urlparse(value)\n        netloc_match = netloc_regex.match(parsed.netloc)\n        if not all((parsed.scheme, parsed.netloc)):\n            if netloc_regex.match(\n                parsed.netloc or parsed.path.split(\"/\", 1)[0].split(\"?\", 1)[0]\n            ):\n                self.error(value, \"Did you mean: http://{0}\")\n            self.error(value)\n        if parsed.scheme and self.schemes and parsed.scheme not in self.schemes:\n            self.error(value, \"Protocol is not allowed\")\n        if not netloc_match:\n            self.error(value)\n        data = netloc_match.groupdict()\n        if data[\"ipv4\"] or data[\"ipv6\"]:\n            if not self.ip:\n                self.error(value, \"IP is not allowed\")\n            else:\n                try:\n                    ip(data[\"ipv4\"] or data[\"ipv6\"])\n                except ValueError as e:\n                    self.error(value, str(e))\n            if not self.local:\n                if data[\"ipv4\"] and data[\"ipv4\"].startswith(\"127.\"):\n                    self.error(value, \"Localhost is not allowed\")\n                elif data[\"ipv6\"] == \"::1\":\n                    self.error(value, \"Localhost is not allowed\")\n            if self.check:\n                pass\n        if data[\"auth\"] and not self.auth:\n            self.error(value, \"Authentication is not allowed\")\n        if data[\"localhost\"] and not self.local:\n            self.error(value, \"Localhost is not allowed\")\n        if data[\"port\"]:\n            if not self.port:\n                self.error(value, \"Custom port is not allowed\")\n            else:\n                port = int(data[\"port\"])\n                if not 0 < port < 65535:\n                    self.error(value, \"Port is out of range\")\n        if data[\"domain\"]:\n            if self.domains and data[\"domain\"] not in self.domains:\n                self.error(value, \"Domain is not allowed\")\n            elif self.exclude and data[\"domain\"] in self.exclude:\n                self.error(value, \"Domain is not allowed\")\n            if self.check:\n                try:\n                    socket.getaddrinfo(data[\"domain\"], None)\n                except socket.error:\n                    self.error(value, \"Domain does not exists\")\n        return value\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"string\",\n            \"format\": \"url\",\n        }\n\n\n#: Validate an URL\n#:\n#: Legacy validator, allows, auth, port, ip and local\n#: Only allows schemes 'http', 'https', 'ftp' and 'ftps'\nurl = URL(\n    ip=True, auth=True, port=True, local=True, schemes=(\"http\", \"https\", \"ftp\", \"ftps\")\n)\n\n\nclass email(object):\n    \"\"\"\n    Validate an email.\n\n    Example::\n\n        parser = reqparse.RequestParser()\n        parser.add_argument('email', type=inputs.email(dns=True))\n\n    Input to the ``email`` argument will be rejected if it does not match an email\n    and if domain does not exists.\n\n    :param bool check: Check the domain exists (perform a DNS resolution)\n    :param bool ip: Allow IP (both ipv4/ipv6) as domain\n    :param bool local: Allow localhost (both string or ip) as domain\n    :param list|tuple domains: Restrict valid domains to this list\n    :param list|tuple exclude: Exclude some domains\n    \"\"\"\n\n    def __init__(self, check=False, ip=False, local=False, domains=None, exclude=None):\n        self.check = check\n        self.ip = ip\n        self.local = local\n        self.domains = domains\n        self.exclude = exclude\n\n    def error(self, value, msg=None):\n        msg = msg or \"{0} is not a valid email\"\n        raise ValueError(msg.format(value))\n\n    def is_ip(self, value):\n        try:\n            ip(value)\n            return True\n        except ValueError:\n            return False\n\n    def __call__(self, value):\n        match = email_regex.match(value)\n        if not match or \"..\" in value:\n            self.error(value)\n        server = match.group(\"server\")\n        if self.check:\n            try:\n                socket.getaddrinfo(server, None)\n            except socket.error:\n                self.error(value)\n        if self.domains and server not in self.domains:\n            self.error(value, \"{0} does not belong to the authorized domains\")\n        if self.exclude and server in self.exclude:\n            self.error(value, \"{0} belongs to a forbidden domain\")\n        if not self.local and (\n            server in (\"localhost\", \"::1\") or server.startswith(\"127.\")\n        ):\n            self.error(value)\n        if self.is_ip(server) and not self.ip:\n            self.error(value)\n        return value\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"string\",\n            \"format\": \"email\",\n        }\n\n\nclass regex(object):\n    \"\"\"\n    Validate a string based on a regular expression.\n\n    Example::\n\n        parser = reqparse.RequestParser()\n        parser.add_argument('example', type=inputs.regex('^[0-9]+$'))\n\n    Input to the ``example`` argument will be rejected if it contains anything\n    but numbers.\n\n    :param str pattern: The regular expression the input must match\n    \"\"\"\n\n    def __init__(self, pattern):\n        self.pattern = pattern\n        self.re = re.compile(pattern)\n\n    def __call__(self, value):\n        if not self.re.search(value):\n            message = 'Value does not match pattern: \"{0}\"'.format(self.pattern)\n            raise ValueError(message)\n        return value\n\n    def __deepcopy__(self, memo):\n        return regex(self.pattern)\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"string\",\n            \"pattern\": self.pattern,\n        }\n\n\ndef _normalize_interval(start, end, value):\n    \"\"\"\n    Normalize datetime intervals.\n\n    Given a pair of datetime.date or datetime.datetime objects,\n    returns a 2-tuple of tz-aware UTC datetimes spanning the same interval.\n\n    For datetime.date objects, the returned interval starts at 00:00:00.0\n    on the first date and ends at 00:00:00.0 on the second.\n\n    Naive datetimes are upgraded to UTC.\n\n    Timezone-aware datetimes are normalized to the UTC tzdata.\n\n    Params:\n        - start: A date or datetime\n        - end: A date or datetime\n    \"\"\"\n    if not isinstance(start, datetime):\n        start = datetime.combine(start, START_OF_DAY)\n        end = datetime.combine(end, START_OF_DAY)\n\n    if start.tzinfo is None:\n        start = pytz.UTC.localize(start)\n        end = pytz.UTC.localize(end)\n    else:\n        start = start.astimezone(pytz.UTC)\n        end = end.astimezone(pytz.UTC)\n\n    return start, end\n\n\ndef _expand_datetime(start, value):\n    if not isinstance(start, datetime):\n        # Expand a single date object to be the interval spanning\n        # that entire day.\n        end = start + timedelta(days=1)\n    else:\n        # Expand a datetime based on the finest resolution provided\n        # in the original input string.\n        time = value.split(\"T\")[1]\n        time_without_offset = re.sub(\"[+-].+\", \"\", time)\n        num_separators = time_without_offset.count(\":\")\n        if num_separators == 0:\n            # Hour resolution\n            end = start + timedelta(hours=1)\n        elif num_separators == 1:\n            # Minute resolution:\n            end = start + timedelta(minutes=1)\n        else:\n            # Second resolution\n            end = start + timedelta(seconds=1)\n\n    return end\n\n\ndef _parse_interval(value):\n    \"\"\"\n    Do some nasty try/except voodoo to get some sort of datetime\n    object(s) out of the string.\n    \"\"\"\n    try:\n        return sorted(aniso8601.parse_interval(value))\n    except ValueError:\n        try:\n            return aniso8601.parse_datetime(value), None\n        except ValueError:\n            return aniso8601.parse_date(value), None\n\n\ndef iso8601interval(value, argument=\"argument\"):\n    \"\"\"\n    Parses ISO 8601-formatted datetime intervals into tuples of datetimes.\n\n    Accepts both a single date(time) or a full interval using either start/end\n    or start/duration notation, with the following behavior:\n\n    - Intervals are defined as inclusive start, exclusive end\n    - Single datetimes are translated into the interval spanning the\n      largest resolution not specified in the input value, up to the day.\n    - The smallest accepted resolution is 1 second.\n    - All timezones are accepted as values; returned datetimes are\n      localized to UTC. Naive inputs and date inputs will are assumed UTC.\n\n    Examples::\n\n        \"2013-01-01\" -> datetime(2013, 1, 1), datetime(2013, 1, 2)\n        \"2013-01-01T12\" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)\n        \"2013-01-01/2013-02-28\" -> datetime(2013, 1, 1), datetime(2013, 2, 28)\n        \"2013-01-01/P3D\" -> datetime(2013, 1, 1), datetime(2013, 1, 4)\n        \"2013-01-01T12:00/PT30M\" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)\n        \"2013-01-01T06:00/2013-01-01T12:00\" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)\n\n    :param str value: The ISO8601 date time as a string\n    :return: Two UTC datetimes, the start and the end of the specified interval\n    :rtype: A tuple (datetime, datetime)\n    :raises ValueError: if the interval is invalid.\n    \"\"\"\n    if not value:\n        raise ValueError(\"Expected a valid ISO8601 date/time interval.\")\n\n    try:\n        start, end = _parse_interval(value)\n\n        if end is None:\n            end = _expand_datetime(start, value)\n\n        start, end = _normalize_interval(start, end, value)\n\n    except ValueError:\n        msg = (\n            \"Invalid {arg}: {value}. {arg} must be a valid ISO8601 date/time interval.\"\n        )\n        raise ValueError(msg.format(arg=argument, value=value))\n\n    return start, end\n\n\niso8601interval.__schema__ = {\"type\": \"string\", \"format\": \"iso8601-interval\"}\n\n\ndef date(value):\n    \"\"\"Parse a valid looking date in the format YYYY-mm-dd\"\"\"\n    date = datetime.strptime(value, \"%Y-%m-%d\")\n    return date\n\n\ndate.__schema__ = {\"type\": \"string\", \"format\": \"date\"}\n\n\ndef _get_integer(value):\n    try:\n        return int(value)\n    except (TypeError, ValueError):\n        raise ValueError(\"{0} is not a valid integer\".format(value))\n\n\ndef natural(value, argument=\"argument\"):\n    \"\"\"Restrict input type to the natural numbers (0, 1, 2, 3...)\"\"\"\n    value = _get_integer(value)\n    if value < 0:\n        msg = \"Invalid {arg}: {value}. {arg} must be a non-negative integer\"\n        raise ValueError(msg.format(arg=argument, value=value))\n    return value\n\n\nnatural.__schema__ = {\"type\": \"integer\", \"minimum\": 0}\n\n\ndef positive(value, argument=\"argument\"):\n    \"\"\"Restrict input type to the positive integers (1, 2, 3...)\"\"\"\n    value = _get_integer(value)\n    if value < 1:\n        msg = \"Invalid {arg}: {value}. {arg} must be a positive integer\"\n        raise ValueError(msg.format(arg=argument, value=value))\n    return value\n\n\npositive.__schema__ = {\"type\": \"integer\", \"minimum\": 0, \"exclusiveMinimum\": True}\n\n\nclass int_range(object):\n    \"\"\"Restrict input to an integer in a range (inclusive)\"\"\"\n\n    def __init__(self, low, high, argument=\"argument\"):\n        self.low = low\n        self.high = high\n        self.argument = argument\n\n    def __call__(self, value):\n        value = _get_integer(value)\n        if value < self.low or value > self.high:\n            msg = \"Invalid {arg}: {val}. {arg} must be within the range {lo} - {hi}\"\n            raise ValueError(\n                msg.format(arg=self.argument, val=value, lo=self.low, hi=self.high)\n            )\n        return value\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"integer\",\n            \"minimum\": self.low,\n            \"maximum\": self.high,\n        }\n\n\ndef boolean(value):\n    \"\"\"\n    Parse the string ``\"true\"`` or ``\"false\"`` as a boolean (case insensitive).\n\n    Also accepts ``\"1\"`` and ``\"0\"`` as ``True``/``False`` (respectively).\n\n    If the input is from the request JSON body, the type is already a native python boolean,\n    and will be passed through without further parsing.\n\n    :raises ValueError: if the boolean value is invalid\n    \"\"\"\n    if isinstance(value, bool):\n        return value\n\n    if value is None:\n        raise ValueError(\"boolean type must be non-null\")\n    elif not value:\n        return False\n    value = str(value).lower()\n    if value in (\"true\", \"1\", \"on\",):\n        return True\n    if value in (\"false\", \"0\",):\n        return False\n    raise ValueError(\"Invalid literal for boolean(): {0}\".format(value))\n\n\nboolean.__schema__ = {\"type\": \"boolean\"}\n\n\ndef datetime_from_rfc822(value):\n    \"\"\"\n    Turns an RFC822 formatted date into a datetime object.\n\n    Example::\n\n        inputs.datetime_from_rfc822('Wed, 02 Oct 2002 08:00:00 EST')\n\n    :param str value: The RFC822-complying string to transform\n    :return: The parsed datetime\n    :rtype: datetime\n    :raises ValueError: if value is an invalid date literal\n\n    \"\"\"\n    raw = value\n    if not time_regex.search(value):\n        value = \" \".join((value, \"00:00:00\"))\n    try:\n        timetuple = parsedate_tz(value)\n        timestamp = mktime_tz(timetuple)\n        if timetuple[-1] is None:\n            return datetime.fromtimestamp(timestamp).replace(tzinfo=pytz.utc)\n        else:\n            return datetime.fromtimestamp(timestamp, pytz.utc)\n    except Exception:\n        raise ValueError('Invalid date literal \"{0}\"'.format(raw))\n\n\ndef datetime_from_iso8601(value):\n    \"\"\"\n    Turns an ISO8601 formatted date into a datetime object.\n\n    Example::\n\n        inputs.datetime_from_iso8601(\"2012-01-01T23:30:00+02:00\")\n\n    :param str value: The ISO8601-complying string to transform\n    :return: A datetime\n    :rtype: datetime\n    :raises ValueError: if value is an invalid date literal\n\n    \"\"\"\n    try:\n        try:\n            return aniso8601.parse_datetime(value)\n        except ValueError:\n            date = aniso8601.parse_date(value)\n            return datetime(date.year, date.month, date.day)\n    except Exception:\n        raise ValueError('Invalid date literal \"{0}\"'.format(value))\n\n\ndatetime_from_iso8601.__schema__ = {\"type\": \"string\", \"format\": \"date-time\"}\n\n\ndef date_from_iso8601(value):\n    \"\"\"\n    Turns an ISO8601 formatted date into a date object.\n\n    Example::\n\n        inputs.date_from_iso8601(\"2012-01-01\")\n\n\n\n    :param str value: The ISO8601-complying string to transform\n    :return: A date\n    :rtype: date\n    :raises ValueError: if value is an invalid date literal\n\n    \"\"\"\n    return datetime_from_iso8601(value).date()\n\n\ndate_from_iso8601.__schema__ = {\"type\": \"string\", \"format\": \"date\"}\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\"\"\"\nThis module provide some helpers for advanced types parsing.\n\nYou can define you own parser using the same pattern:\n\n.. code-block:: python\n\n    def my_type(value):\n        if not condition:\n            raise ValueError('This is not my type')\n        return parse(value)\n\n    # Swagger documentation\n    my_type.__schema__ = {'type': 'string', 'format': 'my-custom-format'}\n\nThe last line allows you to document properly the type in the Swagger documentation.\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport re\nimport socket\n\nfrom datetime import datetime, time, timedelta\nfrom email.utils import parsedate_tz, mktime_tz\nfrom six.moves.urllib.parse import urlparse\n\nimport aniso8601\nimport pytz\n\n# Constants for upgrading date-based intervals to full datetimes.\nSTART_OF_DAY = time(0, 0, 0, tzinfo=pytz.UTC)\nEND_OF_DAY = time(23, 59, 59, 999999, tzinfo=pytz.UTC)\n\n\nnetloc_regex = re.compile(\n    r\"(?:(?P<auth>[^:@]+?(?::[^:@]*?)?)@)?\"  # basic auth\n    r\"(?:\"\n    r\"(?P<localhost>localhost)|\"  # localhost...\n    r\"(?P<ipv4>\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})|\"  # ...or ipv4\n    r\"(?:\\[?(?P<ipv6>[A-F0-9]*:[A-F0-9:]+)\\]?)|\"  # ...or ipv6\n    r\"(?P<domain>(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?))\"  # domain...\n    r\")\"\n    r\"(?::(?P<port>\\d+))?\"  # optional port\n    r\"$\",\n    re.IGNORECASE,\n)\n\n\nemail_regex = re.compile(\n    r\"^\" \"(?P<local>[^@]*[^@.])\" r\"@\" r\"(?P<server>[^@\\.]+(?:\\.[^@\\.]+)*)\" r\"$\",\n    re.IGNORECASE,\n)\n\ntime_regex = re.compile(r\"\\d{2}:\\d{2}\")\n\n\ndef ipv4(value):\n    \"\"\"Validate an IPv4 address\"\"\"\n    try:\n        socket.inet_aton(value)\n        if value.count(\".\") == 3:\n            return value\n    except socket.error:\n        pass\n    raise ValueError(\"{0} is not a valid ipv4 address\".format(value))\n\n\nipv4.__schema__ = {\"type\": \"string\", \"format\": \"ipv4\"}\n\n\ndef ipv6(value):\n    \"\"\"Validate an IPv6 address\"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, value)\n        return value\n    except socket.error:\n        raise ValueError(\"{0} is not a valid ipv4 address\".format(value))\n\n\nipv6.__schema__ = {\"type\": \"string\", \"format\": \"ipv6\"}\n\n\ndef ip(value):\n    \"\"\"Validate an IP address (both IPv4 and IPv6)\"\"\"\n    try:\n        return ipv4(value)\n    except ValueError:\n        pass\n    try:\n        return ipv6(value)\n    except ValueError:\n        raise ValueError(\"{0} is not a valid ip\".format(value))\n\n\nip.__schema__ = {\"type\": \"string\", \"format\": \"ip\"}\n\n\nclass URL(object):\n    \"\"\"\n    Validate an URL.\n\n    Example::\n\n        parser = reqparse.RequestParser()\n        parser.add_argument('url', type=inputs.URL(schemes=['http', 'https']))\n\n    Input to the ``URL`` argument will be rejected\n    if it does not match an URL with specified constraints.\n    If ``check`` is True it will also be rejected if the domain does not exists.\n\n    :param bool check: Check the domain exists (perform a DNS resolution)\n    :param bool ip: Allow IP (both ipv4/ipv6) as domain\n    :param bool local: Allow localhost (both string or ip) as domain\n    :param bool port: Allow a port to be present\n    :param bool auth: Allow authentication to be present\n    :param list|tuple schemes: Restrict valid schemes to this list\n    :param list|tuple domains: Restrict valid domains to this list\n    :param list|tuple exclude: Exclude some domains\n    \"\"\"\n\n    def __init__(\n        self,\n        check=False,\n        ip=False,\n        local=False,\n        port=False,\n        auth=False,\n        schemes=None,\n        domains=None,\n        exclude=None,\n    ):\n        self.check = check\n        self.ip = ip\n        self.local = local\n        self.port = port\n        self.auth = auth\n        self.schemes = schemes\n        self.domains = domains\n        self.exclude = exclude\n\n    def error(self, value, details=None):\n        msg = \"{0} is not a valid URL\"\n        if details:\n            msg = \". \".join((msg, details))\n        raise ValueError(msg.format(value))\n\n    def __call__(self, value):\n        parsed = urlparse(value)\n        netloc_match = netloc_regex.match(parsed.netloc)\n        if not all((parsed.scheme, parsed.netloc)):\n            if netloc_regex.match(\n                parsed.netloc or parsed.path.split(\"/\", 1)[0].split(\"?\", 1)[0]\n            ):\n                self.error(value, \"Did you mean: http://{0}\")\n            self.error(value)\n        if parsed.scheme and self.schemes and parsed.scheme not in self.schemes:\n            self.error(value, \"Protocol is not allowed\")\n        if not netloc_match:\n            self.error(value)\n        data = netloc_match.groupdict()\n        if data[\"ipv4\"] or data[\"ipv6\"]:\n            if not self.ip:\n                self.error(value, \"IP is not allowed\")\n            else:\n                try:\n                    ip(data[\"ipv4\"] or data[\"ipv6\"])\n                except ValueError as e:\n                    self.error(value, str(e))\n            if not self.local:\n                if data[\"ipv4\"] and data[\"ipv4\"].startswith(\"127.\"):\n                    self.error(value, \"Localhost is not allowed\")\n                elif data[\"ipv6\"] == \"::1\":\n                    self.error(value, \"Localhost is not allowed\")\n            if self.check:\n                pass\n        if data[\"auth\"] and not self.auth:\n            self.error(value, \"Authentication is not allowed\")\n        if data[\"localhost\"] and not self.local:\n            self.error(value, \"Localhost is not allowed\")\n        if data[\"port\"]:\n            if not self.port:\n                self.error(value, \"Custom port is not allowed\")\n            else:\n                port = int(data[\"port\"])\n                if not 0 < port < 65535:\n                    self.error(value, \"Port is out of range\")\n        if data[\"domain\"]:\n            if self.domains and data[\"domain\"] not in self.domains:\n                self.error(value, \"Domain is not allowed\")\n            elif self.exclude and data[\"domain\"] in self.exclude:\n                self.error(value, \"Domain is not allowed\")\n            if self.check:\n                try:\n                    socket.getaddrinfo(data[\"domain\"], None)\n                except socket.error:\n                    self.error(value, \"Domain does not exists\")\n        return value\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"string\",\n            \"format\": \"url\",\n        }\n\n\n#: Validate an URL\n#:\n#: Legacy validator, allows, auth, port, ip and local\n#: Only allows schemes 'http', 'https', 'ftp' and 'ftps'\nurl = URL(\n    ip=True, auth=True, port=True, local=True, schemes=(\"http\", \"https\", \"ftp\", \"ftps\")\n)\n\n\nclass email(object):\n    \"\"\"\n    Validate an email.\n\n    Example::\n\n        parser = reqparse.RequestParser()\n        parser.add_argument('email', type=inputs.email(dns=True))\n\n    Input to the ``email`` argument will be rejected if it does not match an email\n    and if domain does not exists.\n\n    :param bool check: Check the domain exists (perform a DNS resolution)\n    :param bool ip: Allow IP (both ipv4/ipv6) as domain\n    :param bool local: Allow localhost (both string or ip) as domain\n    :param list|tuple domains: Restrict valid domains to this list\n    :param list|tuple exclude: Exclude some domains\n    \"\"\"\n\n    def __init__(self, check=False, ip=False, local=False, domains=None, exclude=None):\n        self.check = check\n        self.ip = ip\n        self.local = local\n        self.domains = domains\n        self.exclude = exclude\n\n    def error(self, value, msg=None):\n        msg = msg or \"{0} is not a valid email\"\n        raise ValueError(msg.format(value))\n\n    def is_ip(self, value):\n        try:\n            ip(value)\n            return True\n        except ValueError:\n            return False\n\n    def __call__(self, value):\n        match = email_regex.match(value)\n        if not match or \"..\" in value:\n            self.error(value)\n        server = match.group(\"server\")\n        if self.check:\n            try:\n                socket.getaddrinfo(server, None)\n            except socket.error:\n                self.error(value)\n        if self.domains and server not in self.domains:\n            self.error(value, \"{0} does not belong to the authorized domains\")\n        if self.exclude and server in self.exclude:\n            self.error(value, \"{0} belongs to a forbidden domain\")\n        if not self.local and (\n            server in (\"localhost\", \"::1\") or server.startswith(\"127.\")\n        ):\n            self.error(value)\n        if self.is_ip(server) and not self.ip:\n            self.error(value)\n        return value\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"string\",\n            \"format\": \"email\",\n        }\n\n\nclass regex(object):\n    \"\"\"\n    Validate a string based on a regular expression.\n\n    Example::\n\n        parser = reqparse.RequestParser()\n        parser.add_argument('example', type=inputs.regex('^[0-9]+$'))\n\n    Input to the ``example`` argument will be rejected if it contains anything\n    but numbers.\n\n    :param str pattern: The regular expression the input must match\n    \"\"\"\n\n    def __init__(self, pattern):\n        self.pattern = pattern\n        self.re = re.compile(pattern)\n\n    def __call__(self, value):\n        if not self.re.search(value):\n            message = 'Value does not match pattern: \"{0}\"'.format(self.pattern)\n            raise ValueError(message)\n        return value\n\n    def __deepcopy__(self, memo):\n        return regex(self.pattern)\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"string\",\n            \"pattern\": self.pattern,\n        }\n\n\ndef _normalize_interval(start, end, value):\n    \"\"\"\n    Normalize datetime intervals.\n\n    Given a pair of datetime.date or datetime.datetime objects,\n    returns a 2-tuple of tz-aware UTC datetimes spanning the same interval.\n\n    For datetime.date objects, the returned interval starts at 00:00:00.0\n    on the first date and ends at 00:00:00.0 on the second.\n\n    Naive datetimes are upgraded to UTC.\n\n    Timezone-aware datetimes are normalized to the UTC tzdata.\n\n    Params:\n        - start: A date or datetime\n        - end: A date or datetime\n    \"\"\"\n    if not isinstance(start, datetime):\n        start = datetime.combine(start, START_OF_DAY)\n        end = datetime.combine(end, START_OF_DAY)\n\n    if start.tzinfo is None:\n        start = pytz.UTC.localize(start)\n        end = pytz.UTC.localize(end)\n    else:\n        start = start.astimezone(pytz.UTC)\n        end = end.astimezone(pytz.UTC)\n\n    return start, end\n\n\ndef _expand_datetime(start, value):\n    if not isinstance(start, datetime):\n        # Expand a single date object to be the interval spanning\n        # that entire day.\n        end = start + timedelta(days=1)\n    else:\n        # Expand a datetime based on the finest resolution provided\n        # in the original input string.\n        time = value.split(\"T\")[1]\n        time_without_offset = re.sub(\"[+-].+\", \"\", time)\n        num_separators = time_without_offset.count(\":\")\n        if num_separators == 0:\n            # Hour resolution\n            end = start + timedelta(hours=1)\n        elif num_separators == 1:\n            # Minute resolution:\n            end = start + timedelta(minutes=1)\n        else:\n            # Second resolution\n            end = start + timedelta(seconds=1)\n\n    return end\n\n\ndef _parse_interval(value):\n    \"\"\"\n    Do some nasty try/except voodoo to get some sort of datetime\n    object(s) out of the string.\n    \"\"\"\n    try:\n        return sorted(aniso8601.parse_interval(value))\n    except ValueError:\n        try:\n            return aniso8601.parse_datetime(value), None\n        except ValueError:\n            return aniso8601.parse_date(value), None\n\n\ndef iso8601interval(value, argument=\"argument\"):\n    \"\"\"\n    Parses ISO 8601-formatted datetime intervals into tuples of datetimes.\n\n    Accepts both a single date(time) or a full interval using either start/end\n    or start/duration notation, with the following behavior:\n\n    - Intervals are defined as inclusive start, exclusive end\n    - Single datetimes are translated into the interval spanning the\n      largest resolution not specified in the input value, up to the day.\n    - The smallest accepted resolution is 1 second.\n    - All timezones are accepted as values; returned datetimes are\n      localized to UTC. Naive inputs and date inputs will are assumed UTC.\n\n    Examples::\n\n        \"2013-01-01\" -> datetime(2013, 1, 1), datetime(2013, 1, 2)\n        \"2013-01-01T12\" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 13)\n        \"2013-01-01/2013-02-28\" -> datetime(2013, 1, 1), datetime(2013, 2, 28)\n        \"2013-01-01/P3D\" -> datetime(2013, 1, 1), datetime(2013, 1, 4)\n        \"2013-01-01T12:00/PT30M\" -> datetime(2013, 1, 1, 12), datetime(2013, 1, 1, 12, 30)\n        \"2013-01-01T06:00/2013-01-01T12:00\" -> datetime(2013, 1, 1, 6), datetime(2013, 1, 1, 12)\n\n    :param str value: The ISO8601 date time as a string\n    :return: Two UTC datetimes, the start and the end of the specified interval\n    :rtype: A tuple (datetime, datetime)\n    :raises ValueError: if the interval is invalid.\n    \"\"\"\n    if not value:\n        raise ValueError(\"Expected a valid ISO8601 date/time interval.\")\n\n    try:\n        start, end = _parse_interval(value)\n\n        if end is None:\n            end = _expand_datetime(start, value)\n\n        start, end = _normalize_interval(start, end, value)\n\n    except ValueError:\n        msg = (\n            \"Invalid {arg}: {value}. {arg} must be a valid ISO8601 date/time interval.\"\n        )\n        raise ValueError(msg.format(arg=argument, value=value))\n\n    return start, end\n\n\niso8601interval.__schema__ = {\"type\": \"string\", \"format\": \"iso8601-interval\"}\n\n\ndef date(value):\n    \"\"\"Parse a valid looking date in the format YYYY-mm-dd\"\"\"\n    date = datetime.strptime(value, \"%Y-%m-%d\")\n    return date\n\n\ndate.__schema__ = {\"type\": \"string\", \"format\": \"date\"}\n\n\ndef _get_integer(value):\n    try:\n        return int(value)\n    except (TypeError, ValueError):\n        raise ValueError(\"{0} is not a valid integer\".format(value))\n\n\ndef natural(value, argument=\"argument\"):\n    \"\"\"Restrict input type to the natural numbers (0, 1, 2, 3...)\"\"\"\n    value = _get_integer(value)\n    if value < 0:\n        msg = \"Invalid {arg}: {value}. {arg} must be a non-negative integer\"\n        raise ValueError(msg.format(arg=argument, value=value))\n    return value\n\n\nnatural.__schema__ = {\"type\": \"integer\", \"minimum\": 0}\n\n\ndef positive(value, argument=\"argument\"):\n    \"\"\"Restrict input type to the positive integers (1, 2, 3...)\"\"\"\n    value = _get_integer(value)\n    if value < 1:\n        msg = \"Invalid {arg}: {value}. {arg} must be a positive integer\"\n        raise ValueError(msg.format(arg=argument, value=value))\n    return value\n\n\npositive.__schema__ = {\"type\": \"integer\", \"minimum\": 0, \"exclusiveMinimum\": True}\n\n\nclass int_range(object):\n    \"\"\"Restrict input to an integer in a range (inclusive)\"\"\"\n\n    def __init__(self, low, high, argument=\"argument\"):\n        self.low = low\n        self.high = high\n        self.argument = argument\n\n    def __call__(self, value):\n        value = _get_integer(value)\n        if value < self.low or value > self.high:\n            msg = \"Invalid {arg}: {val}. {arg} must be within the range {lo} - {hi}\"\n            raise ValueError(\n                msg.format(arg=self.argument, val=value, lo=self.low, hi=self.high)\n            )\n        return value\n\n    @property\n    def __schema__(self):\n        return {\n            \"type\": \"integer\",\n            \"minimum\": self.low,\n            \"maximum\": self.high,\n        }\n\n\ndef boolean(value):\n    \"\"\"\n    Parse the string ``\"true\"`` or ``\"false\"`` as a boolean (case insensitive).\n\n    Also accepts ``\"1\"`` and ``\"0\"`` as ``True``/``False`` (respectively).\n\n    If the input is from the request JSON body, the type is already a native python boolean,\n    and will be passed through without further parsing.\n\n    :raises ValueError: if the boolean value is invalid\n    \"\"\"\n    if isinstance(value, bool):\n        return value\n\n    if value is None:\n        raise ValueError(\"boolean type must be non-null\")\n    elif not value:\n        return False\n    value = str(value).lower()\n    if value in (\"true\", \"1\", \"on\",):\n        return True\n    if value in (\"false\", \"0\",):\n        return False\n    raise ValueError(\"Invalid literal for boolean(): {0}\".format(value))\n\n\nboolean.__schema__ = {\"type\": \"boolean\"}\n\n\ndef datetime_from_rfc822(value):\n    \"\"\"\n    Turns an RFC822 formatted date into a datetime object.\n\n    Example::\n\n        inputs.datetime_from_rfc822('Wed, 02 Oct 2002 08:00:00 EST')\n\n    :param str value: The RFC822-complying string to transform\n    :return: The parsed datetime\n    :rtype: datetime\n    :raises ValueError: if value is an invalid date literal\n\n    \"\"\"\n    raw = value\n    if not time_regex.search(value):\n        value = \" \".join((value, \"00:00:00\"))\n    try:\n        timetuple = parsedate_tz(value)\n        timestamp = mktime_tz(timetuple)\n        if timetuple[-1] is None:\n            return datetime.fromtimestamp(timestamp).replace(tzinfo=pytz.utc)\n        else:\n            return datetime.fromtimestamp(timestamp, pytz.utc)\n    except Exception:\n        raise ValueError('Invalid date literal \"{0}\"'.format(raw))\n\n\ndef datetime_from_iso8601(value):\n    \"\"\"\n    Turns an ISO8601 formatted date into a datetime object.\n\n    Example::\n\n        inputs.datetime_from_iso8601(\"2012-01-01T23:30:00+02:00\")\n\n    :param str value: The ISO8601-complying string to transform\n    :return: A datetime\n    :rtype: datetime\n    :raises ValueError: if value is an invalid date literal\n\n    \"\"\"\n    try:\n        try:\n            return aniso8601.parse_datetime(value)\n        except ValueError:\n            date = aniso8601.parse_date(value)\n            return datetime(date.year, date.month, date.day)\n    except Exception:\n        raise ValueError('Invalid date literal \"{0}\"'.format(value))\n\n\ndatetime_from_iso8601.__schema__ = {\"type\": \"string\", \"format\": \"date-time\"}\n\n\ndef date_from_iso8601(value):\n    \"\"\"\n    Turns an ISO8601 formatted date into a date object.\n\n    Example::\n\n        inputs.date_from_iso8601(\"2012-01-01\")\n\n\n\n    :param str value: The ISO8601-complying string to transform\n    :return: A date\n    :rtype: date\n    :raises ValueError: if value is an invalid date literal\n\n    \"\"\"\n    return datetime_from_iso8601(value).date()\n\n\ndate_from_iso8601.__schema__ = {\"type\": \"string\", \"format\": \"date\"}\n"], "filenames": ["flask_restx/inputs.py"], "buggy_code_start_loc": [51], "buggy_code_end_loc": [52], "fixing_code_start_loc": [51], "fixing_code_end_loc": [52], "type": "CWE-400", "message": "Flask-RESTX (pypi package flask-restx) is a community driven fork of Flask-RESTPlus. Flask-RESTX before version 0.5.1 is vulnerable to ReDoS (Regular Expression Denial of Service) in email_regex. This is fixed in version 0.5.1.", "other": {"cve": {"id": "CVE-2021-32838", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-20T18:15:11.010", "lastModified": "2021-09-30T19:23:15.043", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flask-RESTX (pypi package flask-restx) is a community driven fork of Flask-RESTPlus. Flask-RESTX before version 0.5.1 is vulnerable to ReDoS (Regular Expression Denial of Service) in email_regex. This is fixed in version 0.5.1."}, {"lang": "es", "value": "Flask-RESTX (paquete pypi flask-restx) es un fork impulsado por la comunidad de Flask-RESTPlus. Flask-RESTX versiones anteriores a 0.5.1, es vulnerable a ReDoS (Denegaci\u00f3n de Servicio por Expresi\u00f3n Regular) en la funci\u00f3n email_regex. Esto ha sido corregido en la versi\u00f3n 0.5.1"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flask-restx_project:flask-restx:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.5.1", "matchCriteriaId": "BA9C0D28-C95B-41C6-A116-511860EDE383"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-3q6g-vf58-7m4g", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/python-restx/flask-restx/blob/fd99fe11a88531f5f3441a278f7020589f9d2cc0/flask_restx/inputs.py#L51", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/python-restx/flask-restx/commit/bab31e085f355dd73858fd3715f7ed71849656da", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/python-restx/flask-restx/issues/372", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5UCTFVDU3677B5OBGK4EF5NMUPJLL6SQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QUD6SWZLX52AAZUHDETJ2CDMQGEPGFL3/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://pypi.org/project/flask-restx/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/python-restx/flask-restx/commit/bab31e085f355dd73858fd3715f7ed71849656da"}}