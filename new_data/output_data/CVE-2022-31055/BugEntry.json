{"buggy_code": ["#!/bin/bash\n# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nsource \"${KCTF_BIN}/kctf-log\"\n\nBYE_MSG=\"\"\nKCTF_CLOUD_BASE_URL=\"https://kctf-cloud.appspot.com/v1\"\n# owned by kctf-cloud\nKCTF_CLOUD_API_KEY=\"AIzaSyC7Jgu4e0IygmImZNPmJHrcfZ3lJA9ZrZs\"\n\nif [[ \"$OSTYPE\" =~ ^darwin.* ]]; then\n  GETOPT=\"$(brew --prefix gnu-getopt)/bin/getopt\"\nelse\n  GETOPT=\"getopt\"\nfi\n\nfunction update_gcloud_config {\n  _kctf_log \"Updating gcloud config.\"\n  ACTIVE_ACCOUNT=\"$(CLOUDSDK_ACTIVE_CONFIG_NAME= gcloud config get-value core/account 2>/dev/null)\"\n  export CLOUDSDK_ACTIVE_CONFIG_NAME=\"kctf-${KCTF_SESSION}\"\n  if ! gcloud config configurations describe \"${CLOUDSDK_ACTIVE_CONFIG_NAME}\" >/dev/null 2>/dev/null; then\n        gcloud config configurations create --no-activate \"${CLOUDSDK_ACTIVE_CONFIG_NAME}\" >/dev/null 2>/dev/null || return\n  fi\n  gcloud config set core/account \"${ACTIVE_ACCOUNT}\" >/dev/null || return\n  gcloud config set core/project \"${PROJECT}\" >/dev/null || return\n  gcloud config set compute/zone \"${ZONE}\" >/dev/null || return\n  gcloud config set container/cluster \"${CLUSTER_NAME}\" >/dev/null || return\n}\n\nfunction set_lastconfig_link {\n  ln -sf \"${CONFIG_NAME}\" \"${KCTF_CTF_DIR}/kctf/config/.lastconfig\"\n}\n\nfunction kctf_cluster_load_usage {\n  echo \"usage: kctf cluster load config_name\" >&2\n  echo \"  run \\\"kctf cluster list\\\" to see a list of options\" >&2\n}\n\nfunction kctf_cluster_load {\n  if [[ $# -ne 1 ]]; then\n    _kctf_log_err \"missing config name\"\n    kctf_cluster_load_usage\n    return 1\n  fi\n\n  if [[ \"$1\" == \"-h\" ]] || [[ \"$1\" == \"--help\" ]]; then\n    kctf_cluster_load_usage\n    return 0\n  fi\n\n  CONFIG_NAME=\"$1\"\n  if [[ \"${CONFIG_NAME}\" == \".lastconfig\" ]]; then\n    CONFIG_NAME=$(readlink \"${KCTF_CTF_DIR}/kctf/config/.lastconfig\")\n    if [[ $? -ne 0 ]]; then\n      _kctf_log_err \"could not resolve .lastconfig link\"\n      return 1\n    fi\n  fi\n  CONFIG_PATH=\"${KCTF_CTF_DIR}/kctf/config/${CONFIG_NAME}\"\n  shift\n\n  source \"${CONFIG_PATH}\" || return\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      if ! command -v gcloud >/dev/null 2>&1; then\n        _kctf_log_err \"gcloud not installed\"\n        return 1\n      fi\n      update_gcloud_config || return\n\n      # try to fetch the creds of the k8s cluster\n      gcloud container clusters get-credentials \"${CLUSTER_NAME}\" >/dev/null 2>/dev/null\n      ;;\n    kind)\n      kube_config=$(\"${KCTF_BIN}/kind\" get kubeconfig --name \"${CLUSTER_NAME}\" 2>/dev/null)\n      if [[ $? -eq 0 ]]; then\n        echo \"${kube_config}\" > \"${KUBECONFIG}\"\n      fi\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n\n  _kctf_log \"loaded config\"\n\n  set_lastconfig_link\n\n  echo \"${CONFIG_NAME}\"\n}\n\nfunction kctf_cluster_list {\n  echo \"== available cluster configurations ==\"\n  for file in ${KCTF_CTF_DIR}/kctf/config/*; do\n    CONFIG_NAME=\"$(basename $file)\"\n    if [[ \"${CONFIG_NAME}\" = \".lastconfig\" ]]; then\n      continue\n    fi\n    echo \"${CONFIG_NAME}\"\n  done\n}\n\nfunction kctf_cluster_create_usage {\n  echo \"usage: kctf cluster create [args] config_name\" >&2\n  echo \"  -h|--help            print this help\" >&2\n  echo \"  --type               what kind of cluster to create (default: gce)\" >&2\n  echo \"                       supported values: \\\"gce\\\" (remote cluster) and \\\"kind\\\" (local cluster)\" >&2\n  echo \"  --project            Required (gce): Google Cloud Platform project name\" >&2\n  echo \"  --zone               GCP Zone (default: europe-west4-b)\" >&2\n  echo \"                       For a list of zones run:\" >&2\n  echo \"                         gcloud compute machine-types list --filter=\\\"name=( n2-standard-4 )\\\" --format 'value(zone)'\" >&2\n  echo \"  --registry           Container Registry (default: eu.gcr.io)\" >&2\n  echo \"                       Possible values are us.gcr.io, asia.gcr.io, and eu.gcr.io\" >&2\n  echo \"  --cluster-name       Name of the kubernetes cluster (default: kctf-cluster)\" >&2\n  echo \"  --domain-name        Required (gce): domain name to host challenges under\" >&2\n  echo \"                       Please make sure not to put anything secret in the challenge name.\" >&2\n  echo \"                       Supported options:\" >&2\n  echo \"                         \\\"none\\\": disable DNS support (might break some functionality)\" >&2\n  echo \"                         \\\"your.domain.com\\\": use your own domain. You will have to follow some\" >&2\n  echo \"                                              additional steps to configure your nameserver.\" >&2\n  echo \"                         \\\"yourname.kctf.cloud\\\": automatically get a subdomain under kctf.cloud\" >&2\n  echo \"  --email-address      Optional email address for LetsEncrypt registration (for wildcard certificates)\" >&2\n  echo \"                       To use it, please read and agree to the ACME Subscriber Agreement:\" >&2\n  echo \"                         https://letsencrypt.org/repository/\" >&2\n  echo \"  --start              Start the cluster if it's not running yet\" >&2\n  echo \"  --disable-src-ranges Disable the ip range feature (requires --start). Use this if you have security policy quota issues\" >&2\n}\n\nfunction kctf_cluster_create {\n  # Default Configuration\n  CLUSTER_TYPE=\"gce\"\n  REGISTRY=\"eu.gcr.io\"\n  PROJECT=\"\"\n  ZONE=\"europe-west4-b\"\n  CLUSTER_NAME=\"kctf-cluster\"\n  DOMAIN_NAME=\"\"\n  EMAIL_ADDRESS=\"\"\n  START_CLUSTER=\"0\"\n  DISABLE_SRC_RANGES=\"\"\n\n  OPTS=\"h\"\n  LONGOPTS=\"help,type:,project:,zone:,registry:,cluster-name:,domain-name:,email-address:,start,disable-src-ranges\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster create\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_create_usage\n    return 1\n  fi\n  eval set -- \"$PARSED\"\n\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_create_usage\n        return 1\n        ;;\n      --type)\n        CLUSTER_TYPE=$2\n        shift 2\n        ;;\n      --project)\n        PROJECT=$2\n        shift 2\n        ;;\n      --zone)\n        ZONE=$2\n        shift 2\n        ;;\n      --registry)\n        REGISTRY=$2\n        shift 2\n        ;;\n      --cluster-name)\n        CLUSTER_NAME=$2\n        shift 2\n        ;;\n      --domain-name)\n        DOMAIN_NAME=\"$2\"\n        shift 2\n        ;;\n      --email-address)\n        EMAIL_ADDRESS=\"$2\"\n        shift 2\n        ;;\n      --start)\n        START_CLUSTER=\"1\"\n        shift\n        ;;\n      --disable-src-ranges)\n        DISABLE_SRC_RANGES=\"--disable-src-ranges\"\n        shift\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_create_usage\n        return 1\n        ;;\n    esac\n  done\n\n  if [[ $# -ne 1 ]]; then\n    _kctf_log_err \"kctf cluster create: cluster config name missing\"\n    kctf_cluster_create_usage\n    return 1\n  fi\n\n  CONFIG_NAME=\"$1\"\n  if [[ \"${CONFIG_NAME}\" == \".lastconfig\" ]]; then\n    CONFIG_NAME=$(readlink \"${KCTF_CTF_DIR}/kctf/config/.lastconfig\")\n    if [[ $? -ne 0 ]]; then\n      _kctf_log_err \"could not resolve .lastconfig link\"\n      return 1\n    fi\n  fi\n  CONFIG_PATH=\"${KCTF_CTF_DIR}/kctf/config/${CONFIG_NAME}\"\n  shift\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      if [[ -z \"$PROJECT\" ]]; then\n        _kctf_log_err \"Missing required argument \\\"--project\\\".\"\n        kctf_cluster_create_usage\n        return 1\n      fi\n      if [[ -z \"${DOMAIN_NAME}\" ]]; then\n        _kctf_log_err \"Missing required argument \\\"--domain-name\\\".\"\n        kctf_cluster_create_usage\n        return 1\n      fi\n      ;;\n    kind)\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n\n  if [[ \"${DOMAIN_NAME}\" == \"none\" ]]; then\n    DOMAIN_NAME=\"\"\n  fi\n\n\n  mkdir -p \"${KCTF_CTF_DIR}/kctf/config\" || return\n\n  if [ -e \"${CONFIG_PATH}\" ]; then\n    _kctf_log_warn \"Overwriting existing cluster config file. Old content:\"\n    cat \"${CONFIG_PATH}\" >&2\n    rm \"${CONFIG_PATH}\" >&2\n  fi\n\n  cat > \"${CONFIG_PATH}\" << EOF\nCLUSTER_TYPE=${CLUSTER_TYPE}\nPROJECT=${PROJECT}\nZONE=${ZONE}\nREGISTRY=${REGISTRY}\nCLUSTER_NAME=${CLUSTER_NAME}\nDOMAIN_NAME=${DOMAIN_NAME}\nEMAIL_ADDRESS=${EMAIL_ADDRESS}\nEOF\n  if [[ $? -ne 0 ]]; then return 1; fi\n\n  set_lastconfig_link || return\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      if ! command -v gcloud >/dev/null 2>&1; then\n        if [[ \"${START_CLUSTER}\" == \"1\" ]]; then\n          _kctf_log_err \"Can't start cluster, configuration created only locally. Gcloud not installed.\"\n          return 1\n        else\n          _kctf_log_warn \"Configuration created only locally. Gcloud not installed.\"\n          return 0\n        fi\n      fi\n      update_gcloud_config || return\n      # try to fetch the creds of the k8s cluster\n      gcloud container clusters get-credentials \"${CLUSTER_NAME}\" >/dev/null 2>/dev/null\n      GET_CLUSTER_CREDS_RESULT=$?\n      ;;\n    kind)\n      kube_config=$(\"${KCTF_BIN}/kind\" get kubeconfig --name \"${CLUSTER_NAME}\" 2>/dev/null)\n      GET_CLUSTER_CREDS_RESULT=$?\n      if [[ \"${GET_CLUSTER_CREDS_RESULT}\" -eq 0 ]]; then\n        echo \"${kube_config}\" > \"${KUBECONFIG}\"\n      fi\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n\n  # there might be an existing cluster\n  # if it already exists, we try to update it\n  # otherwise, start it if requested\n  if [[ \"${START_CLUSTER}\" == \"1\" ]]; then\n    if [[ ${GET_CLUSTER_CREDS_RESULT} -eq 0 ]]; then\n      _kctf_log \"Existing cluster found, updating cluster.\"\n    else\n      _kctf_log \"Starting cluster.\"\n    fi\n    export CLUSTER_TYPE\n    export PROJECT\n    export ZONE\n    export REGISTRY\n    export CLUSTER_NAME\n    export DOMAIN_NAME\n    export EMAIL_ADDRESS\n    \"${KCTF_BIN}/kctf-cluster\" start \"${DISABLE_SRC_RANGES}\" >&2 || return\n  elif [[ ${GET_CLUSTER_CREDS_RESULT} -eq 0 ]]; then\n    _kctf_log_warn \"Existing cluster found. If it's running an old version of kCTF, remember to upgrade it with cluster start.\"\n  fi\n\n  echo \"${CONFIG_NAME}\"\n}\n\nfunction kctf_cluster_get_ip_ranges {\n  if [[ \"${CLUSTER_TYPE}\" != \"gce\" ]]; then\n    _kctf_log_err \"this command is only supported for GCE clusters\"\n    return\n  fi\n\n  get_cloud_armor_policy || return\n  _kctf_log \"Current IP range: \\\"$ret\\\"\"\n}\n\nfunction kctf_cluster_ip_ranges_usage {\n  echo \"usage: kctf cluster set-src-ip-ranges ranges\" >&2\n  echo \"  -h|--help       print this help\" >&2\n  echo \"  ranges          ip ranges to allow of the form 1.1.1.1/32,2.2.2.0/24\" >&2\n}\n\nfunction kctf_cluster_ip_ranges {\n  if [[ \"${CLUSTER_TYPE}\" != \"gce\" ]]; then\n    _kctf_log_err \"this command is only supported for GCE clusters\"\n    return\n  fi\n\n  OPTS=\"h\"\n  LONGOPTS=\"help\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster set-src-ip-ranges\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_ip_ranges_usage\n    return 1\n  fi\n  eval set -- \"$PARSED\"\n\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_ip_ranges_usage\n        return 1\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_ip_ranges_usage\n        return 1\n        ;;\n    esac\n  done\n\n  if [[ $# -ne 1 ]]; then\n    _kctf_log_err \"kctf cluster set-src-ip-ranges: expecting a single range argument\"\n    kctf_cluster_ip_ranges_usage\n    return 1\n  fi\n\n  RANGES=\"$1\"\n\n  # update the cloud armor policy\n  set_cloud_armor_policy \"${RANGES}\" || return\n\n  # stop the operator\n  \"${KCTF_BIN}/kubectl\" delete -f \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" || return\n\n  start_operator_gce || return\n}\n\nfunction start_operator_gce {\n  if [[ \"${DISABLE_SRC_RANGES}\" == \"1\" ]]; then\n     \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" || return\n  else\n    get_cloud_armor_policy || return\n    RANGES=$ret\n    SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n    POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n    # restart the operator with the new range\n    \"${KCTF_BIN}/yq\" eval \"(((.|select(has(\\\"spec\\\"))).spec|select(has(\\\"template\\\"))).template.spec.containers[0].env[] | select(.name == \\\"ALLOWED_IPS\\\")).value = \\\"${RANGES}\\\"\" \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" \\\n      | \"${KCTF_BIN}/yq\" eval \"(((.|select(has(\\\"spec\\\"))).spec|select(has(\\\"template\\\"))).template.spec.containers[0].env[] | select(.name == \\\"SECURITY_POLICY\\\")).value = \\\"${POLICY_NAME}\\\"\" - \\\n      | \"${KCTF_BIN}/kubectl\" apply -f - || return\n  fi\n}\n\nfunction set_cloud_armor_policy {\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n  gcloud compute security-policies rules update --action allow --security-policy \"${POLICY_NAME}\" --src-ip-ranges \"$1\" 0 || return\n}\n\nfunction get_cloud_armor_policy {\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n  ret=$(gcloud compute security-policies rules describe --security-policy \"${POLICY_NAME}\" 0 --format 'value[delimiter=\",\"](match.config.srcIpRanges)')\n}\n\nfunction create_cloud_armor_policy {\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n  if [[ -z $(gcloud compute security-policies list --filter \"name=\"${POLICY_NAME}\"\" --format 'get(name)') ]]; then\n    gcloud compute security-policies create \"${POLICY_NAME}\" || return\n    gcloud compute security-policies rules create --action allow --security-policy \"${POLICY_NAME}\" --src-ip-ranges \"0.0.0.0/0\" 0 || return\n\n    # make sure the default policy (2147483647) is deny\n    gcloud compute security-policies rules update --action deny-404 --security-policy \"${POLICY_NAME}\" 2147483647 || return\n\n    set_cloud_armor_policy \"0.0.0.0/0\" || return\n  fi\n}\n\nfunction create_operator {\n  # Creating CRD, rbac and operator\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf.dev_challenges.yaml\" || return\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf-operator-metrics-reader_rbac.authorization.k8s.io_v1_clusterrole.yaml\" || return\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf-operator-manager-config_v1_configmap.yaml\" || return\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf-operator-controller-manager-metrics-service_v1_service.yaml\" || return\n  if [[ \"$CLUSTER_TYPE\" == \"gce\" ]]; then\n    start_operator_gce || return\n  else\n    \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" || return\n  fi\n  OPERATOR_IMAGE=$(\"${KCTF_BIN}/yq\" eval '.spec.template.spec.containers[].image | select(.==\"*kctf-operator*\")' \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\")\n  if [[ $? -ne 0 ]]; then\n    echo \"Failed to find the operator image.\" >&2\n    return 1\n  fi\n\n  # The operator needs to create some subresources, e.g. the gcsfuse service account\n  for i in {1..100}; do\n    \"${KCTF_BIN}/kubectl\" get pods --namespace kctf-operator-system -o=jsonpath='{.items[*].status.containerStatuses[?(@.ready==true)].imageID}' | grep \"${OPERATOR_IMAGE}\" && break\n    if [ \"$i\" == \"100\" ]; then\n      _kctf_log_err \"Couldn't find a kctf-operator pod with status ready=true and image \\\"${OPERATOR_IMAGE}\\\" after 5 minutes\"\n      \"${KCTF_BIN}/kubectl\" get pods --namespace kctf-operator-system -o=yaml >&2\n      exit 1\n    fi\n    echo -n '.'\n    sleep 3\n  done\n}\n\nfunction wait_for_nameserver {\n  nameserver=\"$1\"\n  initial_timeout=300\n  timeout=$initial_timeout\n  sleep_time=10\n  while [[ \"${timeout}\" -gt 0 ]]; do\n    if nslookup -nosearch -norecurse -type=NS \"${DOMAIN_NAME}.\" \"${nameserver}\" >/dev/null 2>/dev/null; then\n      return 0\n    fi\n    _kctf_log \"nameserver didn't serve NS record yet, sleeping for ${sleep_time}s\"\n    sleep ${sleep_time}\n    timeout=$(($timeout - $sleep_time))\n  done\n  _kctf_log_err \"nameserver didn't serve NS record after ${initial_timeout}s\"\n  return 1\n}\n\nrequired_apis=(\"containerregistry.googleapis.com\" \"compute.googleapis.com\" \"container.googleapis.com\" \"dns.googleapis.com\")\n\nfunction check_required_apis {\n  GCP_APIS=\"$(gcloud services list --format 'get(config.name)')\"\n  for required_api in \"${required_apis[@]}\"; do\n    if [[ ! \"${GCP_APIS}\" =~ \"${required_api}\" ]]; then\n      _kctf_log_err \"Required GCP API \\\"${required_api}\\\" is not enabled\"\n      return 1\n    fi\n  done\n  return 0\n}\n\nfunction kctf_cluster_start_gce {\n  MIN_NODES=\"1\"\n  MAX_NODES=\"2\"\n  NUM_NODES=\"1\"\n  MACHINE_TYPE=\"n2-standard-4\"\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  NETWORK=\"kctf-network-${SUFFIX:0:16}\"\n\n  if ! check_required_apis; then\n    _kctf_log_err \"Please enable the required APIs by running 'gcloud services enable ${required_apis[@]}'\"\n    return 1\n  fi\n\n  EXISTING_NETWORK=$(gcloud compute networks list --filter=\"name=${NETWORK}\" --format 'get(name)')\n  if [ -z \"${EXISTING_NETWORK}\" ]; then\n    gcloud compute networks create ${NETWORK} --description \"kCTF network for cluster ${CLUSTER_NAME}\" >/dev/null || return\n  fi\n\n  EXISTING_CLUSTER=$(gcloud container clusters list --filter \"name=${CLUSTER_NAME}\" --format 'get(name)')\n  if [ -z \"${EXISTING_CLUSTER}\" ]; then\n    CIDR=\"172.16.0.32/28\"\n    gcloud container clusters create --release-channel=regular --enable-network-policy --enable-autoscaling --min-nodes ${MIN_NODES} --max-nodes ${MAX_NODES} --num-nodes ${NUM_NODES} --network ${NETWORK} --create-subnetwork name=kctf-subnet-${NETWORK} --no-enable-master-authorized-networks --enable-ip-alias --enable-private-nodes --master-ipv4-cidr ${CIDR} --enable-autorepair --preemptible --machine-type ${MACHINE_TYPE} --workload-pool=${PROJECT}.svc.id.goog ${CLUSTER_NAME} || return\n  fi\n\n  EXISTING_ROUTER=$(gcloud compute routers list --filter \"name=kctf-${CLUSTER_NAME}-nat-router\" --format 'get(name)')\n  if [ -z \"${EXISTING_ROUTER}\" ]; then\n    gcloud compute routers create \"kctf-${CLUSTER_NAME}-nat-router\" --network=\"${NETWORK}\" --region \"${ZONE::${#ZONE}-2}\" || return\n  fi\n\n  EXISTING_NAT=$(gcloud compute routers nats list --router \"kctf-${CLUSTER_NAME}-nat-router\" --router-region \"${ZONE::${#ZONE}-2}\" --format 'get(name)')\n  if [ -z \"${EXISTING_NAT}\" ]; then\n    gcloud compute routers nats create \"kctf-${CLUSTER_NAME}-nat-config\" --router-region \"${ZONE::${#ZONE}-2}\" --router kctf-${CLUSTER_NAME}-nat-router --nat-all-subnet-ip-ranges --auto-allocate-nat-external-ips || return\n  fi\n\n  \"${KCTF_BIN}/kubectl\" create namespace \"kctf-system\" --dry-run=client -oyaml | \"${KCTF_BIN}/kubectl\" apply -f - >&2 || return\n\n  # GCSFUSE\n\n  BUCKET_NAME=\"kctf-gcsfuse-${SUFFIX:0:16}\"\n  GCS_GSA_NAME=\"${BUCKET_NAME}\"\n  GCS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GCS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)' || true)\n  if [ -z \"${GCS_GSA_EMAIL}\" ]; then\n    gcloud iam service-accounts create \"${GCS_GSA_NAME}\" --description \"kCTF GCSFUSE service account ${CLUSTER_NAME} ${ZONE}\" --display-name \"kCTF GCSFUSE ${CLUSTER_NAME} ${ZONE}\" || return\n    GCS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GCS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n    while [ -z \"${GCS_GSA_EMAIL}\" ]; do\n      sleep 1\n      GCS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GCS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n    done\n  fi\n\n  GCS_KSA_NAME=\"gcsfuse-sa\"\n\n  gcloud iam service-accounts add-iam-policy-binding --role roles/iam.workloadIdentityUser --member \"serviceAccount:${PROJECT}.svc.id.goog[kctf-system/${GCS_KSA_NAME}]\" ${GCS_GSA_EMAIL} || return\n  \"${KCTF_BIN}/kubectl\" create serviceaccount --namespace kctf-system ${GCS_KSA_NAME} --save-config --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n  \"${KCTF_BIN}/kubectl\" annotate serviceaccount --namespace kctf-system ${GCS_KSA_NAME} iam.gke.io/gcp-service-account=${GCS_GSA_EMAIL} --overwrite || return\n\n  if ! gsutil du \"gs://${BUCKET_NAME}/\"; then\n    gsutil mb -l eu \"gs://${BUCKET_NAME}/\" || return\n  fi\n\n  if gsutil uniformbucketlevelaccess get \"gs://${BUCKET_NAME}\" | grep -q \"Enabled: True\"; then\n    gsutil iam ch \"serviceAccount:${GCS_GSA_EMAIL}:roles/storage.legacyBucketOwner\" \"gs://${BUCKET_NAME}\" || return\n    gsutil iam ch \"serviceAccount:${GCS_GSA_EMAIL}:roles/storage.legacyObjectOwner\" \"gs://${BUCKET_NAME}\" || return\n  else\n    gsutil acl ch -u \"${GCS_GSA_EMAIL}:O\" \"gs://${BUCKET_NAME}\" || return\n  fi\n\n  \"${KCTF_BIN}/kubectl\" create configmap gcsfuse-config --from-literal=gcs_bucket=\"${BUCKET_NAME}\" --namespace kctf-system --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n\n  \"${KCTF_BIN}/kubectl\" patch ServiceAccount default --patch \"automountServiceAccountToken: false\" || return\n\n  # Cloud DNS\n\n  if [ ! -z \"${DOMAIN_NAME}\" ]; then\n    ZONE_NAME=$(gcloud dns managed-zones list --filter \"dns_name:${DOMAIN_NAME}.\" --format 'get(name)')\n\n    if [ -z \"${ZONE_NAME}\" ]; then\n      ZONE_NAME=\"kctf-$(echo ${DOMAIN_NAME} | sed 's/[.]/--/g')\"\n      _kctf_log \"creating new managed-zone \\\"${ZONE_NAME}\\\"\"\n      gcloud dns managed-zones create \"${ZONE_NAME}\" --description \"DNS Zone for ${DOMAIN_NAME}\" --dns-name=\"${DOMAIN_NAME}.\" || return\n      soa_ttl=\"$(gcloud dns record-sets list --zone=${ZONE_NAME} --type=SOA --name=\"${DOMAIN_NAME}.\" --format='get(ttl)')\"\n      if [[ $? -ne 0 ]]; then return 1; fi\n      soa_data=\"$(gcloud dns record-sets list --zone=${ZONE_NAME} --type=SOA --name=\"${DOMAIN_NAME}.\" --format='get(rrdatas)')\"\n      if [[ $? -ne 0 ]]; then return 1; fi\n      new_soa=($soa_data)\n      # update the serial no\n      new_soa[2]=$((${new_soa[2]} + 1))\n      # change the ttl\n      new_soa[6]=\"60\"\n\n      _kctf_log \"changing the SOA entry to reduce TTL\"\n      gcloud dns record-sets transaction start --zone=\"${ZONE_NAME}\" || return\n      gcloud dns record-sets transaction remove --zone=\"${ZONE_NAME}\" --name \"${DOMAIN_NAME}.\" --ttl \"${soa_ttl}\" --type \"SOA\" \"${soa_data}\" || return\n      gcloud dns record-sets transaction add --zone=\"${ZONE_NAME}\" --name \"${DOMAIN_NAME}.\" --ttl \"60\" --type \"SOA\" \"${new_soa[*]}\" || return\n      gcloud dns record-sets transaction describe --zone=\"${ZONE_NAME}\" || return\n      if ! gcloud dns record-sets transaction execute --zone=\"${ZONE_NAME}\"; then\n        gcloud dns record-sets transaction abort --zone=\"${ZONE_NAME}\" || return\n        _kctf_log_err 'updating the SOA entry failed'\n        exit 1\n      fi\n      _kctf_log \"SOA updated\"\n    else\n      _kctf_log \"managed-zone \\\"${ZONE_NAME}\\\" exists, reusing\"\n    fi\n\n    DNS_ZONE_NAMESERVERS=$(gcloud dns managed-zones describe \"${ZONE_NAME}\" --format 'value[delimiter=\"\\n\"](nameServers)')\n    if [[ \"${DOMAIN_NAME}\" == *\".kctf.cloud\" ]]; then\n      _kctf_log \"waiting for nameservers to be updated (should take roughly 1m)\"\n      for nameserver in ${DNS_ZONE_NAMESERVERS}; do\n        wait_for_nameserver \"${nameserver}\" || return\n      done\n      KCTF_CLOUD_URL=\"${KCTF_CLOUD_BASE_URL}/subdomain?name=${DOMAIN_NAME%.kctf.cloud}&nameservers=$(paste -sd ',' <(echo \"${DNS_ZONE_NAMESERVERS}\"))\"\n      _kctf_log 'requesting kctf.cloud subdomain'\n      kctf_cloud_tries=3\n      kctf_cloud_timeout=10\n      while true; do\n        curl --fail -X POST -H \"x-api-key: ${KCTF_CLOUD_API_KEY}\" \"${KCTF_CLOUD_URL}\" >/dev/null && break\n        kctf_cloud_tries=$(($kctf_cloud_tries - 1))\n        if [[ $kctf_cloud_tries -le 0 ]]; then\n          _kctf_log_err 'could not register kctf.cloud subdomain'\n          exit 1\n        fi\n        _kctf_log_warn \"registering kctf.cloud subdomain failed, retrying in ${kctf_cloud_timeout}s\"\n        sleep \"${kctf_cloud_timeout}\"\n      done\n    else\n      # print in red for attention\n      _kctf_log $'\\001\\e[0;31m\\002'\"ATTENTION: \"$'\\001\\e[0m\\002'\"You need to add the following NS entries for your domain \\\"${DOMAIN_NAME}\\\":\"$'\\n'\"${DNS_ZONE_NAMESERVERS}\"\n      BYE_MSG=$'\\001\\e[0;31m\\002'\"ATTENTION: \"$'\\001\\e[0m\\002'\"You need to add the following NS entries for your domain \\\"${DOMAIN_NAME}\\\":\"$'\\n'\"${DNS_ZONE_NAMESERVERS}\"\n    fi\n\n    DNS_GSA_NAME=\"kctf-cloud-dns\"\n    DNS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${DNS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)' || true)\n\n    if [ -z \"${DNS_GSA_EMAIL}\" ]; then\n      gcloud iam service-accounts create \"${DNS_GSA_NAME}\" --description \"kCTF Cloud DNS service account ${CLUSTER_NAME} ${ZONE}\" --display-name \"kCTF Cloud DNS ${CLUSTER_NAME} ${ZONE}\" || return\n      DNS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${DNS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n      while [ -z \"${DNS_GSA_EMAIL}\" ]; do\n        sleep 1\n        DNS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${DNS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n      done\n    fi\n\n    DNS_KSA_NAME=\"external-dns-sa\"\n\n    gcloud iam service-accounts add-iam-policy-binding --role roles/iam.workloadIdentityUser --member \"serviceAccount:${PROJECT}.svc.id.goog[kctf-system/${DNS_KSA_NAME}]\" ${DNS_GSA_EMAIL} || return\n    \"${KCTF_BIN}/kubectl\" create serviceaccount --namespace kctf-system ${DNS_KSA_NAME} --save-config --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n    \"${KCTF_BIN}/kubectl\" annotate serviceaccount --namespace kctf-system ${DNS_KSA_NAME} iam.gke.io/gcp-service-account=${DNS_GSA_EMAIL} --overwrite || return\n\n    gcloud projects add-iam-policy-binding ${PROJECT} --member=serviceAccount:${DNS_GSA_EMAIL} --role=roles/dns.admin || return\n\n    \"${KCTF_BIN}/kubectl\" create configmap --namespace kctf-system external-dns --from-literal=DOMAIN_NAME=${DOMAIN_NAME} --from-literal=EMAIL_ADDRESS=${EMAIL_ADDRESS:-} --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n  fi\n\n  if [[ \"${DISABLE_SRC_RANGES}\" == \"0\" ]]; then\n    if ! create_cloud_armor_policy; then\n      echo \"Could not create the cloud armor policy. If you have quota issues, you can disable the feature with --disable-src-ranges.\" >&2\n      return 1\n    fi\n  fi\n\n  create_operator || return\n}\n\nfunction kctf_cluster_start_usage {\n  echo \"usage: kctf cluster start [args]\" >&2\n  echo \"  -h|--help            print this help\" >&2\n  echo \"  --disable-src-ranges Disable the ip range feature (gce only). Use this if you have security policy quota issues\" >&2\n}\n\nfunction kctf_cluster_start {\n  DISABLE_SRC_RANGES=\"0\"\n\n  OPTS=\"h\"\n  LONGOPTS=\"help,disable-src-ranges\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster start\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_start_usage\n    return 1\n  fi\n  eval set -- \"$PARSED\"\n\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_start_usage\n        return 1\n        ;;\n      --disable-src-ranges)\n        DISABLE_SRC_RANGES=\"1\"\n        shift\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_start_usage\n        return 1\n        ;;\n    esac\n  done\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      kctf_cluster_start_gce\n      return\n      ;;\n    kind)\n      kctf_cluster_start_kind\n      return\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n}\n\nfunction kctf_cluster_stop_gce {\n  _kctf_log \"deleting all challenges so that load balancers etc can be cleaned up\"\n  CHALLENGES=$(\"${KCTF_BIN}/kubectl\" get challenge --all-namespaces -o=jsonpath='{range .items[*]}{@.metadata.namespace}{\"/\"}{@.metadata.name}{\" \"}{end}')\n  if [[ ! -z \"${CHALLENGES}\" ]]; then\n    for chal_and_ns in ${CHALLENGES}; do\n      IFS='/' read -r -a chal_and_ns_array <<< \"$chal_and_ns\"\n      chal_namespace=\"${chal_and_ns_array[0]}\"\n      chal_name=\"${chal_and_ns_array[1]}\"\n      \"${KCTF_BIN}/kubectl\" delete \"challenge/${chal_name}\" --namespace \"${chal_namespace}\"\n    done\n  fi\n\n  # deleting the cluster below takes a while, so sleeping for a bit doesn't hurt\n  _kctf_log \"Sleeping 20s to give time to delete resources\"\n  sleep 20\n\n  CLOUDSDK_CORE_DISABLE_PROMPTS=1 gcloud container clusters delete ${CLUSTER_NAME}\n  gcloud compute routers delete \"kctf-${CLUSTER_NAME}-nat-router\" --region \"${ZONE::${#ZONE}-2}\" --quiet\n\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n\n  NETWORK=\"kctf-network-${SUFFIX:0:16}\"\n  gcloud compute networks delete ${NETWORK} --quiet\n\n  GSA_NAME=\"kctf-gcsfuse-${SUFFIX:0:16}\"\n  GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)' || true)\n  if [ -z \"${GSA_EMAIL}\" ]; then\n    gcloud iam service-accounts delete \"${GSA_EMAIL}\"\n  fi\n}\n\nfunction kctf_cluster_start_kind {\n  if ! \"${KCTF_BIN}/kind\" get kubeconfig --name \"${CLUSTER_NAME}\" >/dev/null 2>/dev/null; then\n    \"${KCTF_BIN}/kind\" create cluster --name \"${CLUSTER_NAME}\" || return\n  fi\n\n  \"${KCTF_BIN}/kubectl\" create namespace \"kctf-system\" --dry-run=client -oyaml | \"${KCTF_BIN}/kubectl\" apply -f - >&2 || return\n\n  create_operator\n\n  \"${KCTF_BIN}/kubectl\" patch ServiceAccount default --patch \"automountServiceAccountToken: false\" || return\n}\n\nfunction kctf_cluster_stop_kind {\n  \"${KCTF_BIN}/kind\" delete cluster --name \"${CLUSTER_NAME}\" || return\n}\n\nfunction kctf_cluster_stop {\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      kctf_cluster_stop_gce || return\n      return\n      ;;\n    kind)\n      kctf_cluster_stop_kind || return\n      return\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n}\n\nfunction kctf_cluster_resize_usage {\n  echo -e \"usage: kctf cluster resize [args]\" >&2\n  echo -e \"args:\" >&2\n  echo -e \"  -h|--help      print this help\" >&2\n  echo -e \"  --machine-type machine type to use\" >&2\n  echo -e \"                 to list available types, run: gcloud compute machine-types list --zones=\\\"${ZONE}\\\"\" >&2\n  echo -e \"  --min-nodes    (required) minimum number of nodes in the cluster\" >&2\n  echo -e \"  --max-nodes    (required) maximum number of nodes in the cluster\" >&2\n  echo -e \"  --num-nodes    (required) initial number of nodes in the cluster\" >&2\n  echo -e \"  --pool-name    name of the node pool\" >&2\n  echo -e \"  --old-pool     name of the old pool to replace\" >&2\n}\n\nfunction kctf_cluster_resize {\n  if [[ \"${CLUSTER_TYPE}\" != \"gce\" ]]; then\n    _kctf_log_err \"only cluster type \\\"gce\\\" is supported by resize\"\n    return 1\n  fi\n\n  OPTS=\"h\"\n  LONGOPTS=\"help,machine-type:,min-nodes:,max-nodes:,num-nodes:,pool-name:,old-pool:\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster resize\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_resize_usage\n    exit 1\n  fi\n  eval set -- \"$PARSED\"\n\n  MACHINE_TYPE=\"n2-standard-4\"\n  MIN_NODES=\n  MAX_NODES=\n  NUM_NODES=\n  NEW_POOL_NAME=\n  OLD_POOL_NAME=\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_resize_usage\n        exit 0\n        ;;\n      --machine-type)\n        MACHINE_TYPE=\"$2\"\n        shift 2\n        ;;\n      --min-nodes)\n        MIN_NODES=\"$2\"\n        shift 2\n        ;;\n      --max-nodes)\n        MAX_NODES=\"$2\"\n        shift 2\n        ;;\n      --num-nodes)\n        NUM_NODES=\"$2\"\n        shift 2\n        ;;\n      --pool-name)\n        NEW_POOL_NAME=\"$2\"\n        shift 2\n        ;;\n      --old-pool)\n        OLD_POOL_NAME=\"$2\"\n        shift 2\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_resize_usage\n        exit 1\n        ;;\n    esac\n  done\n\n  if [[ -z \"${MIN_NODES}\" ]] || [[ -z \"${MAX_NODES}\" ]] || [[ -z \"${NUM_NODES}\" ]]; then\n    _kctf_log_err \"Required arguments missing\"\n    kctf_cluster_resize_usage\n    exit 1\n  fi\n\n  if [[ -z \"${OLD_POOL_NAME}\" ]]; then\n    OLD_POOL_NAME=$(gcloud container node-pools list --cluster ${CLUSTER_NAME} --format 'value(name)')\n    if [ $(echo \"${OLD_POOL_NAME}\" | wc -l) != \"1\" ]; then\n      _kctf_log_err 'Multiple node pools found. Please choose which to replace with --old-pool.'\n      echo '== node pools ==' >&2\n      echo \"${OLD_POOL_NAME}\" >&2\n      exit 1\n    fi\n  fi\n\n  if [[ -z \"${NEW_POOL_NAME}\" ]]; then\n    NEW_POOL_NAME=\"${OLD_POOL_NAME}-resized\"\n  fi\n\n  if [ \"${OLD_POOL_NAME}\" = \"${NEW_POOL_NAME}\" ]; then\n    _kctf_log_err \"New pool can't have the same name as the old pool.\"\n    exit 1\n  fi\n\n  if [[ $# -ne 0 ]]; then\n    _kctf_log_err \"Unrecognized arguments \\\"$@\\\".\"\n    kctf_cluster_resize_usage\n    exit 1\n  fi\n\n  _kctf_log 'Creating the new node pool'\n  gcloud container node-pools create \"${NEW_POOL_NAME}\" \\\n    --cluster=\"${CLUSTER_NAME}\" \\\n    --machine-type=\"${MACHINE_TYPE}\" \\\n    --enable-autorepair \\\n    --enable-autoupgrade \\\n    --num-nodes=\"${NUM_NODES}\" \\\n    --enable-autoscaling \\\n    --min-nodes=\"${MIN_NODES}\" \\\n    --max-nodes=\"${MAX_NODES}\" || return\n\n  _kctf_log 'Cordoning old nodes'\n  for node in $(\"${KCTF_BIN}/kubectl\" get nodes -l cloud.google.com/gke-nodepool=\"${OLD_POOL_NAME}\" -o=name); do\n    \"${KCTF_BIN}/kubectl\" cordon \"$node\" || return\n  done\n\n  _kctf_log 'Draining old nodes'\n  for node in $(\"${KCTF_BIN}/kubectl\" get nodes -l cloud.google.com/gke-nodepool=\"${OLD_POOL_NAME}\" -o=name); do\n    \"${KCTF_BIN}/kubectl\" drain --force --ignore-daemonsets --delete-local-data --grace-period=10 \"$node\" || return\n  done\n\n  _kctf_log \"Deleting old node pool \\\"${OLD_POOL_NAME}\\\"\"\n  gcloud container node-pools delete \"${OLD_POOL_NAME}\" --cluster \"${CLUSTER_NAME}\" || return\n}\n\nfunction kctf_cluster_usage {\n  echo -e \"usage: kctf cluster command\" >&2\n  echo -e \"available commands:\" >&2\n  echo -e \"  create:            create a new cluster config\" >&2\n  echo -e \"  list:              list available cluster configs\" >&2\n  echo -e \"  load:              load an existing cluster config\" >&2\n  echo -e \"  start:             start the cluster\" >&2\n  echo -e \"  stop:              stop the cluster\" >&2\n  echo -e \"  resize:            resize the cluster\" >&2\n  echo -e \"  set-src-ip-ranges: allow ranges of IPs to access the services\" >&2\n  echo -e \"  get-src-ip-ranges: print the current allowed IP ranges\" >&2\n}\n\nfunction check_cluster_name {\n  if [[ -z \"${CLUSTER_NAME-}\" ]]; then\n    _kctf_log_err \"No cluster config loaded. You need to run \\\"kctf cluster create\\\" or \\\"kctf cluster load\\\" first.\"\n    exit 1\n  fi\n}\n\nif [[ $# -lt 1 ]]; then\n  _kctf_log_err \"unexpected argument count\"\n  kctf_cluster_usage\n  exit 1\nfi\n\ncase \"$1\" in\n  -h|--help)\n    kctf_cluster_usage\n    exit 0\n    ;;\n  start)\n    shift\n    check_cluster_name\n    kctf_cluster_start $@\n    # This is used for printing DNS settings once again at the end\n    echo $BYE_MSG\n    ;;\n  stop)\n    shift\n    check_cluster_name\n    kctf_cluster_stop $@\n    ;;\n  resize)\n    shift\n    check_cluster_name\n    kctf_cluster_resize $@\n    ;;\n  create)\n    shift\n    kctf_cluster_create $@\n    ;;\n  list)\n    shift\n    kctf_cluster_list $@\n    ;;\n  load)\n    shift\n    kctf_cluster_load $@\n    ;;\n  set-src-ip-ranges)\n    shift\n    kctf_cluster_ip_ranges $@\n    ;;\n  get-src-ip-ranges)\n    shift\n    kctf_cluster_get_ip_ranges $@\n    ;;\n  *)\n    _kctf_log_err \"unknown command\"\n    kctf_cluster_usage\n    exit 1\n    ;;\nesac\n"], "fixing_code": ["#!/bin/bash\n# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     https://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nsource \"${KCTF_BIN}/kctf-log\"\n\nBYE_MSG=\"\"\nKCTF_CLOUD_BASE_URL=\"https://kctf-cloud.appspot.com/v1\"\n# owned by kctf-cloud\nKCTF_CLOUD_API_KEY=\"AIzaSyC7Jgu4e0IygmImZNPmJHrcfZ3lJA9ZrZs\"\n\nif [[ \"$OSTYPE\" =~ ^darwin.* ]]; then\n  GETOPT=\"$(brew --prefix gnu-getopt)/bin/getopt\"\nelse\n  GETOPT=\"getopt\"\nfi\n\nfunction update_gcloud_config {\n  _kctf_log \"Updating gcloud config.\"\n  ACTIVE_ACCOUNT=\"$(CLOUDSDK_ACTIVE_CONFIG_NAME= gcloud config get-value core/account 2>/dev/null)\"\n  export CLOUDSDK_ACTIVE_CONFIG_NAME=\"kctf-${KCTF_SESSION}\"\n  if ! gcloud config configurations describe \"${CLOUDSDK_ACTIVE_CONFIG_NAME}\" >/dev/null 2>/dev/null; then\n        gcloud config configurations create --no-activate \"${CLOUDSDK_ACTIVE_CONFIG_NAME}\" >/dev/null 2>/dev/null || return\n  fi\n  gcloud config set core/account \"${ACTIVE_ACCOUNT}\" >/dev/null || return\n  gcloud config set core/project \"${PROJECT}\" >/dev/null || return\n  gcloud config set compute/zone \"${ZONE}\" >/dev/null || return\n  gcloud config set container/cluster \"${CLUSTER_NAME}\" >/dev/null || return\n}\n\nfunction set_lastconfig_link {\n  ln -sf \"${CONFIG_NAME}\" \"${KCTF_CTF_DIR}/kctf/config/.lastconfig\"\n}\n\nfunction kctf_cluster_load_usage {\n  echo \"usage: kctf cluster load config_name\" >&2\n  echo \"  run \\\"kctf cluster list\\\" to see a list of options\" >&2\n}\n\nfunction kctf_cluster_load {\n  if [[ $# -ne 1 ]]; then\n    _kctf_log_err \"missing config name\"\n    kctf_cluster_load_usage\n    return 1\n  fi\n\n  if [[ \"$1\" == \"-h\" ]] || [[ \"$1\" == \"--help\" ]]; then\n    kctf_cluster_load_usage\n    return 0\n  fi\n\n  CONFIG_NAME=\"$1\"\n  if [[ \"${CONFIG_NAME}\" == \".lastconfig\" ]]; then\n    CONFIG_NAME=$(readlink \"${KCTF_CTF_DIR}/kctf/config/.lastconfig\")\n    if [[ $? -ne 0 ]]; then\n      _kctf_log_err \"could not resolve .lastconfig link\"\n      return 1\n    fi\n  fi\n  CONFIG_PATH=\"${KCTF_CTF_DIR}/kctf/config/${CONFIG_NAME}\"\n  shift\n\n  source \"${CONFIG_PATH}\" || return\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      if ! command -v gcloud >/dev/null 2>&1; then\n        _kctf_log_err \"gcloud not installed\"\n        return 1\n      fi\n      update_gcloud_config || return\n\n      # try to fetch the creds of the k8s cluster\n      gcloud container clusters get-credentials \"${CLUSTER_NAME}\" >/dev/null 2>/dev/null\n      ;;\n    kind)\n      kube_config=$(\"${KCTF_BIN}/kind\" get kubeconfig --name \"${CLUSTER_NAME}\" 2>/dev/null)\n      if [[ $? -eq 0 ]]; then\n        echo \"${kube_config}\" > \"${KUBECONFIG}\"\n      fi\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n\n  _kctf_log \"loaded config\"\n\n  set_lastconfig_link\n\n  echo \"${CONFIG_NAME}\"\n}\n\nfunction kctf_cluster_list {\n  echo \"== available cluster configurations ==\"\n  for file in ${KCTF_CTF_DIR}/kctf/config/*; do\n    CONFIG_NAME=\"$(basename $file)\"\n    if [[ \"${CONFIG_NAME}\" = \".lastconfig\" ]]; then\n      continue\n    fi\n    echo \"${CONFIG_NAME}\"\n  done\n}\n\nfunction kctf_cluster_create_usage {\n  echo \"usage: kctf cluster create [args] config_name\" >&2\n  echo \"  -h|--help            print this help\" >&2\n  echo \"  --type               what kind of cluster to create (default: gce)\" >&2\n  echo \"                       supported values: \\\"gce\\\" (remote cluster) and \\\"kind\\\" (local cluster)\" >&2\n  echo \"  --project            Required (gce): Google Cloud Platform project name\" >&2\n  echo \"  --zone               GCP Zone (default: europe-west4-b)\" >&2\n  echo \"                       For a list of zones run:\" >&2\n  echo \"                         gcloud compute machine-types list --filter=\\\"name=( n2-standard-4 )\\\" --format 'value(zone)'\" >&2\n  echo \"  --registry           Container Registry (default: eu.gcr.io)\" >&2\n  echo \"                       Possible values are us.gcr.io, asia.gcr.io, and eu.gcr.io\" >&2\n  echo \"  --cluster-name       Name of the kubernetes cluster (default: kctf-cluster)\" >&2\n  echo \"  --domain-name        Required (gce): domain name to host challenges under\" >&2\n  echo \"                       Please make sure not to put anything secret in the challenge name.\" >&2\n  echo \"                       Supported options:\" >&2\n  echo \"                         \\\"none\\\": disable DNS support (might break some functionality)\" >&2\n  echo \"                         \\\"your.domain.com\\\": use your own domain. You will have to follow some\" >&2\n  echo \"                                              additional steps to configure your nameserver.\" >&2\n  echo \"                         \\\"yourname.kctf.cloud\\\": automatically get a subdomain under kctf.cloud\" >&2\n  echo \"  --email-address      Optional email address for LetsEncrypt registration (for wildcard certificates)\" >&2\n  echo \"                       To use it, please read and agree to the ACME Subscriber Agreement:\" >&2\n  echo \"                         https://letsencrypt.org/repository/\" >&2\n  echo \"  --start              Start the cluster if it's not running yet\" >&2\n  echo \"  --disable-src-ranges Disable the ip range feature (requires --start). Use this if you have security policy quota issues\" >&2\n}\n\nfunction kctf_cluster_create {\n  # Default Configuration\n  CLUSTER_TYPE=\"gce\"\n  REGISTRY=\"eu.gcr.io\"\n  PROJECT=\"\"\n  ZONE=\"europe-west4-b\"\n  CLUSTER_NAME=\"kctf-cluster\"\n  DOMAIN_NAME=\"\"\n  EMAIL_ADDRESS=\"\"\n  START_CLUSTER=\"0\"\n  DISABLE_SRC_RANGES=\"\"\n\n  OPTS=\"h\"\n  LONGOPTS=\"help,type:,project:,zone:,registry:,cluster-name:,domain-name:,email-address:,start,disable-src-ranges\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster create\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_create_usage\n    return 1\n  fi\n  eval set -- \"$PARSED\"\n\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_create_usage\n        return 1\n        ;;\n      --type)\n        CLUSTER_TYPE=$2\n        shift 2\n        ;;\n      --project)\n        PROJECT=$2\n        shift 2\n        ;;\n      --zone)\n        ZONE=$2\n        shift 2\n        ;;\n      --registry)\n        REGISTRY=$2\n        shift 2\n        ;;\n      --cluster-name)\n        CLUSTER_NAME=$2\n        shift 2\n        ;;\n      --domain-name)\n        DOMAIN_NAME=\"$2\"\n        shift 2\n        ;;\n      --email-address)\n        EMAIL_ADDRESS=\"$2\"\n        shift 2\n        ;;\n      --start)\n        START_CLUSTER=\"1\"\n        shift\n        ;;\n      --disable-src-ranges)\n        DISABLE_SRC_RANGES=\"--disable-src-ranges\"\n        shift\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_create_usage\n        return 1\n        ;;\n    esac\n  done\n\n  if [[ $# -ne 1 ]]; then\n    _kctf_log_err \"kctf cluster create: cluster config name missing\"\n    kctf_cluster_create_usage\n    return 1\n  fi\n\n  CONFIG_NAME=\"$1\"\n  if [[ \"${CONFIG_NAME}\" == \".lastconfig\" ]]; then\n    CONFIG_NAME=$(readlink \"${KCTF_CTF_DIR}/kctf/config/.lastconfig\")\n    if [[ $? -ne 0 ]]; then\n      _kctf_log_err \"could not resolve .lastconfig link\"\n      return 1\n    fi\n  fi\n  CONFIG_PATH=\"${KCTF_CTF_DIR}/kctf/config/${CONFIG_NAME}\"\n  shift\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      if [[ -z \"$PROJECT\" ]]; then\n        _kctf_log_err \"Missing required argument \\\"--project\\\".\"\n        kctf_cluster_create_usage\n        return 1\n      fi\n      if [[ -z \"${DOMAIN_NAME}\" ]]; then\n        _kctf_log_err \"Missing required argument \\\"--domain-name\\\".\"\n        kctf_cluster_create_usage\n        return 1\n      fi\n      ;;\n    kind)\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n\n  if [[ \"${DOMAIN_NAME}\" == \"none\" ]]; then\n    DOMAIN_NAME=\"\"\n  fi\n\n\n  mkdir -p \"${KCTF_CTF_DIR}/kctf/config\" || return\n\n  if [ -e \"${CONFIG_PATH}\" ]; then\n    _kctf_log_warn \"Overwriting existing cluster config file. Old content:\"\n    cat \"${CONFIG_PATH}\" >&2\n    rm \"${CONFIG_PATH}\" >&2\n  fi\n\n  cat > \"${CONFIG_PATH}\" << EOF\nCLUSTER_TYPE=${CLUSTER_TYPE}\nPROJECT=${PROJECT}\nZONE=${ZONE}\nREGISTRY=${REGISTRY}\nCLUSTER_NAME=${CLUSTER_NAME}\nDOMAIN_NAME=${DOMAIN_NAME}\nEMAIL_ADDRESS=${EMAIL_ADDRESS}\nEOF\n  if [[ $? -ne 0 ]]; then return 1; fi\n\n  set_lastconfig_link || return\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      if ! command -v gcloud >/dev/null 2>&1; then\n        if [[ \"${START_CLUSTER}\" == \"1\" ]]; then\n          _kctf_log_err \"Can't start cluster, configuration created only locally. Gcloud not installed.\"\n          return 1\n        else\n          _kctf_log_warn \"Configuration created only locally. Gcloud not installed.\"\n          return 0\n        fi\n      fi\n      update_gcloud_config || return\n      # try to fetch the creds of the k8s cluster\n      gcloud container clusters get-credentials \"${CLUSTER_NAME}\" >/dev/null 2>/dev/null\n      GET_CLUSTER_CREDS_RESULT=$?\n      ;;\n    kind)\n      kube_config=$(\"${KCTF_BIN}/kind\" get kubeconfig --name \"${CLUSTER_NAME}\" 2>/dev/null)\n      GET_CLUSTER_CREDS_RESULT=$?\n      if [[ \"${GET_CLUSTER_CREDS_RESULT}\" -eq 0 ]]; then\n        echo \"${kube_config}\" > \"${KUBECONFIG}\"\n      fi\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n\n  # there might be an existing cluster\n  # if it already exists, we try to update it\n  # otherwise, start it if requested\n  if [[ \"${START_CLUSTER}\" == \"1\" ]]; then\n    if [[ ${GET_CLUSTER_CREDS_RESULT} -eq 0 ]]; then\n      _kctf_log \"Existing cluster found, updating cluster.\"\n    else\n      _kctf_log \"Starting cluster.\"\n    fi\n    export CLUSTER_TYPE\n    export PROJECT\n    export ZONE\n    export REGISTRY\n    export CLUSTER_NAME\n    export DOMAIN_NAME\n    export EMAIL_ADDRESS\n    \"${KCTF_BIN}/kctf-cluster\" start \"${DISABLE_SRC_RANGES}\" >&2 || return\n  elif [[ ${GET_CLUSTER_CREDS_RESULT} -eq 0 ]]; then\n    _kctf_log_warn \"Existing cluster found. If it's running an old version of kCTF, remember to upgrade it with cluster start.\"\n  fi\n\n  echo \"${CONFIG_NAME}\"\n}\n\nfunction kctf_cluster_get_ip_ranges {\n  if [[ \"${CLUSTER_TYPE}\" != \"gce\" ]]; then\n    _kctf_log_err \"this command is only supported for GCE clusters\"\n    return\n  fi\n\n  get_cloud_armor_policy || return\n  _kctf_log \"Current IP range: \\\"$ret\\\"\"\n}\n\nfunction kctf_cluster_ip_ranges_usage {\n  echo \"usage: kctf cluster set-src-ip-ranges ranges\" >&2\n  echo \"  -h|--help       print this help\" >&2\n  echo \"  ranges          ip ranges to allow of the form 1.1.1.1/32,2.2.2.0/24\" >&2\n}\n\nfunction kctf_cluster_ip_ranges {\n  if [[ \"${CLUSTER_TYPE}\" != \"gce\" ]]; then\n    _kctf_log_err \"this command is only supported for GCE clusters\"\n    return\n  fi\n\n  OPTS=\"h\"\n  LONGOPTS=\"help\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster set-src-ip-ranges\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_ip_ranges_usage\n    return 1\n  fi\n  eval set -- \"$PARSED\"\n\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_ip_ranges_usage\n        return 1\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_ip_ranges_usage\n        return 1\n        ;;\n    esac\n  done\n\n  if [[ $# -ne 1 ]]; then\n    _kctf_log_err \"kctf cluster set-src-ip-ranges: expecting a single range argument\"\n    kctf_cluster_ip_ranges_usage\n    return 1\n  fi\n\n  RANGES=\"$1\"\n\n  # update the cloud armor policy\n  set_cloud_armor_policy \"${RANGES}\" || return\n\n  # stop the operator\n  \"${KCTF_BIN}/yq\" eval \"select(.kind == \\\"Deployment\\\")\" \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" \\\n    | \"${KCTF_BIN}/kubectl\" delete -f - || return\n\n  start_operator_gce || return\n}\n\nfunction start_operator_gce {\n  if [[ \"${DISABLE_SRC_RANGES}\" == \"1\" ]]; then\n     \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" || return\n  else\n    get_cloud_armor_policy || return\n    RANGES=$ret\n    SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n    POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n    # restart the operator with the new range\n    \"${KCTF_BIN}/yq\" eval \"(select(.kind == \\\"Deployment\\\").spec.template.spec.containers[] | select(.name == \\\"manager\\\").env[] | select(.name == \\\"ALLOWED_IPS\\\").value) |= \\\"${RANGES}\\\"\" \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" \\\n      | \"${KCTF_BIN}/yq\" eval \"(select(.kind == \\\"Deployment\\\").spec.template.spec.containers[] | select(.name == \\\"manager\\\").env[] | select(.name == \\\"SECURITY_POLICY\\\").value) |= \\\"${POLICY_NAME}\\\"\" - \\\n      | \"${KCTF_BIN}/kubectl\" apply -f - || return\n  fi\n}\n\nfunction set_cloud_armor_policy {\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n  gcloud compute security-policies rules update --action allow --security-policy \"${POLICY_NAME}\" --src-ip-ranges \"$1\" 0 || return\n}\n\nfunction get_cloud_armor_policy {\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n  ret=$(gcloud compute security-policies rules describe --security-policy \"${POLICY_NAME}\" 0 --format 'value[delimiter=\",\"](match.config.srcIpRanges)')\n}\n\nfunction create_cloud_armor_policy {\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  POLICY_NAME=\"kctf-policy-${SUFFIX:0:16}\"\n  if [[ -z $(gcloud compute security-policies list --filter \"name=\"${POLICY_NAME}\"\" --format 'get(name)') ]]; then\n    gcloud compute security-policies create \"${POLICY_NAME}\" || return\n    gcloud compute security-policies rules create --action allow --security-policy \"${POLICY_NAME}\" --src-ip-ranges \"0.0.0.0/0\" 0 || return\n\n    # make sure the default policy (2147483647) is deny\n    gcloud compute security-policies rules update --action deny-404 --security-policy \"${POLICY_NAME}\" 2147483647 || return\n\n    set_cloud_armor_policy \"0.0.0.0/0\" || return\n  fi\n}\n\nfunction create_operator {\n  # Creating CRD, rbac and operator\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf.dev_challenges.yaml\" || return\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf-operator-metrics-reader_rbac.authorization.k8s.io_v1_clusterrole.yaml\" || return\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf-operator-manager-config_v1_configmap.yaml\" || return\n  \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/kctf-operator-controller-manager-metrics-service_v1_service.yaml\" || return\n  if [[ \"$CLUSTER_TYPE\" == \"gce\" ]]; then\n    start_operator_gce || return\n  else\n    \"${KCTF_BIN}/kubectl\" apply -f \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\" || return\n  fi\n  OPERATOR_IMAGE=$(\"${KCTF_BIN}/yq\" eval '.spec.template.spec.containers[].image | select(.==\"*kctf-operator*\")' \"${KCTF_CTF_DIR}/kctf/resources/operator.yaml\")\n  if [[ $? -ne 0 ]]; then\n    echo \"Failed to find the operator image.\" >&2\n    return 1\n  fi\n\n  # The operator needs to create some subresources, e.g. the gcsfuse service account\n  for i in {1..100}; do\n    \"${KCTF_BIN}/kubectl\" get pods --namespace kctf-operator-system -o=jsonpath='{.items[*].status.containerStatuses[?(@.ready==true)].imageID}' | grep \"${OPERATOR_IMAGE}\" && break\n    if [ \"$i\" == \"100\" ]; then\n      _kctf_log_err \"Couldn't find a kctf-operator pod with status ready=true and image \\\"${OPERATOR_IMAGE}\\\" after 5 minutes\"\n      \"${KCTF_BIN}/kubectl\" get pods --namespace kctf-operator-system -o=yaml >&2\n      exit 1\n    fi\n    echo -n '.'\n    sleep 3\n  done\n}\n\nfunction wait_for_nameserver {\n  nameserver=\"$1\"\n  initial_timeout=300\n  timeout=$initial_timeout\n  sleep_time=10\n  while [[ \"${timeout}\" -gt 0 ]]; do\n    if nslookup -nosearch -norecurse -type=NS \"${DOMAIN_NAME}.\" \"${nameserver}\" >/dev/null 2>/dev/null; then\n      return 0\n    fi\n    _kctf_log \"nameserver didn't serve NS record yet, sleeping for ${sleep_time}s\"\n    sleep ${sleep_time}\n    timeout=$(($timeout - $sleep_time))\n  done\n  _kctf_log_err \"nameserver didn't serve NS record after ${initial_timeout}s\"\n  return 1\n}\n\nrequired_apis=(\"containerregistry.googleapis.com\" \"compute.googleapis.com\" \"container.googleapis.com\" \"dns.googleapis.com\")\n\nfunction check_required_apis {\n  GCP_APIS=\"$(gcloud services list --format 'get(config.name)')\"\n  for required_api in \"${required_apis[@]}\"; do\n    if [[ ! \"${GCP_APIS}\" =~ \"${required_api}\" ]]; then\n      _kctf_log_err \"Required GCP API \\\"${required_api}\\\" is not enabled\"\n      return 1\n    fi\n  done\n  return 0\n}\n\nfunction kctf_cluster_start_gce {\n  MIN_NODES=\"1\"\n  MAX_NODES=\"2\"\n  NUM_NODES=\"1\"\n  MACHINE_TYPE=\"n2-standard-4\"\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n  NETWORK=\"kctf-network-${SUFFIX:0:16}\"\n\n  if ! check_required_apis; then\n    _kctf_log_err \"Please enable the required APIs by running 'gcloud services enable ${required_apis[@]}'\"\n    return 1\n  fi\n\n  EXISTING_NETWORK=$(gcloud compute networks list --filter=\"name=${NETWORK}\" --format 'get(name)')\n  if [ -z \"${EXISTING_NETWORK}\" ]; then\n    gcloud compute networks create ${NETWORK} --description \"kCTF network for cluster ${CLUSTER_NAME}\" >/dev/null || return\n  fi\n\n  EXISTING_CLUSTER=$(gcloud container clusters list --filter \"name=${CLUSTER_NAME}\" --format 'get(name)')\n  if [ -z \"${EXISTING_CLUSTER}\" ]; then\n    CIDR=\"172.16.0.32/28\"\n    gcloud container clusters create --release-channel=regular --enable-network-policy --enable-autoscaling --min-nodes ${MIN_NODES} --max-nodes ${MAX_NODES} --num-nodes ${NUM_NODES} --network ${NETWORK} --create-subnetwork name=kctf-subnet-${NETWORK} --no-enable-master-authorized-networks --enable-ip-alias --enable-private-nodes --master-ipv4-cidr ${CIDR} --enable-autorepair --preemptible --machine-type ${MACHINE_TYPE} --workload-pool=${PROJECT}.svc.id.goog ${CLUSTER_NAME} || return\n  fi\n\n  EXISTING_ROUTER=$(gcloud compute routers list --filter \"name=kctf-${CLUSTER_NAME}-nat-router\" --format 'get(name)')\n  if [ -z \"${EXISTING_ROUTER}\" ]; then\n    gcloud compute routers create \"kctf-${CLUSTER_NAME}-nat-router\" --network=\"${NETWORK}\" --region \"${ZONE::${#ZONE}-2}\" || return\n  fi\n\n  EXISTING_NAT=$(gcloud compute routers nats list --router \"kctf-${CLUSTER_NAME}-nat-router\" --router-region \"${ZONE::${#ZONE}-2}\" --format 'get(name)')\n  if [ -z \"${EXISTING_NAT}\" ]; then\n    gcloud compute routers nats create \"kctf-${CLUSTER_NAME}-nat-config\" --router-region \"${ZONE::${#ZONE}-2}\" --router kctf-${CLUSTER_NAME}-nat-router --nat-all-subnet-ip-ranges --auto-allocate-nat-external-ips || return\n  fi\n\n  \"${KCTF_BIN}/kubectl\" create namespace \"kctf-system\" --dry-run=client -oyaml | \"${KCTF_BIN}/kubectl\" apply -f - >&2 || return\n\n  # GCSFUSE\n\n  BUCKET_NAME=\"kctf-gcsfuse-${SUFFIX:0:16}\"\n  GCS_GSA_NAME=\"${BUCKET_NAME}\"\n  GCS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GCS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)' || true)\n  if [ -z \"${GCS_GSA_EMAIL}\" ]; then\n    gcloud iam service-accounts create \"${GCS_GSA_NAME}\" --description \"kCTF GCSFUSE service account ${CLUSTER_NAME} ${ZONE}\" --display-name \"kCTF GCSFUSE ${CLUSTER_NAME} ${ZONE}\" || return\n    GCS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GCS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n    while [ -z \"${GCS_GSA_EMAIL}\" ]; do\n      sleep 1\n      GCS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GCS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n    done\n  fi\n\n  GCS_KSA_NAME=\"gcsfuse-sa\"\n\n  gcloud iam service-accounts add-iam-policy-binding --role roles/iam.workloadIdentityUser --member \"serviceAccount:${PROJECT}.svc.id.goog[kctf-system/${GCS_KSA_NAME}]\" ${GCS_GSA_EMAIL} || return\n  \"${KCTF_BIN}/kubectl\" create serviceaccount --namespace kctf-system ${GCS_KSA_NAME} --save-config --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n  \"${KCTF_BIN}/kubectl\" annotate serviceaccount --namespace kctf-system ${GCS_KSA_NAME} iam.gke.io/gcp-service-account=${GCS_GSA_EMAIL} --overwrite || return\n\n  if ! gsutil du \"gs://${BUCKET_NAME}/\"; then\n    gsutil mb -l eu \"gs://${BUCKET_NAME}/\" || return\n  fi\n\n  if gsutil uniformbucketlevelaccess get \"gs://${BUCKET_NAME}\" | grep -q \"Enabled: True\"; then\n    gsutil iam ch \"serviceAccount:${GCS_GSA_EMAIL}:roles/storage.legacyBucketOwner\" \"gs://${BUCKET_NAME}\" || return\n    gsutil iam ch \"serviceAccount:${GCS_GSA_EMAIL}:roles/storage.legacyObjectOwner\" \"gs://${BUCKET_NAME}\" || return\n  else\n    gsutil acl ch -u \"${GCS_GSA_EMAIL}:O\" \"gs://${BUCKET_NAME}\" || return\n  fi\n\n  \"${KCTF_BIN}/kubectl\" create configmap gcsfuse-config --from-literal=gcs_bucket=\"${BUCKET_NAME}\" --namespace kctf-system --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n\n  \"${KCTF_BIN}/kubectl\" patch ServiceAccount default --patch \"automountServiceAccountToken: false\" || return\n\n  # Cloud DNS\n\n  if [ ! -z \"${DOMAIN_NAME}\" ]; then\n    ZONE_NAME=$(gcloud dns managed-zones list --filter \"dns_name:${DOMAIN_NAME}.\" --format 'get(name)')\n\n    if [ -z \"${ZONE_NAME}\" ]; then\n      ZONE_NAME=\"kctf-$(echo ${DOMAIN_NAME} | sed 's/[.]/--/g')\"\n      _kctf_log \"creating new managed-zone \\\"${ZONE_NAME}\\\"\"\n      gcloud dns managed-zones create \"${ZONE_NAME}\" --description \"DNS Zone for ${DOMAIN_NAME}\" --dns-name=\"${DOMAIN_NAME}.\" || return\n      soa_ttl=\"$(gcloud dns record-sets list --zone=${ZONE_NAME} --type=SOA --name=\"${DOMAIN_NAME}.\" --format='get(ttl)')\"\n      if [[ $? -ne 0 ]]; then return 1; fi\n      soa_data=\"$(gcloud dns record-sets list --zone=${ZONE_NAME} --type=SOA --name=\"${DOMAIN_NAME}.\" --format='get(rrdatas)')\"\n      if [[ $? -ne 0 ]]; then return 1; fi\n      new_soa=($soa_data)\n      # update the serial no\n      new_soa[2]=$((${new_soa[2]} + 1))\n      # change the ttl\n      new_soa[6]=\"60\"\n\n      _kctf_log \"changing the SOA entry to reduce TTL\"\n      gcloud dns record-sets transaction start --zone=\"${ZONE_NAME}\" || return\n      gcloud dns record-sets transaction remove --zone=\"${ZONE_NAME}\" --name \"${DOMAIN_NAME}.\" --ttl \"${soa_ttl}\" --type \"SOA\" \"${soa_data}\" || return\n      gcloud dns record-sets transaction add --zone=\"${ZONE_NAME}\" --name \"${DOMAIN_NAME}.\" --ttl \"60\" --type \"SOA\" \"${new_soa[*]}\" || return\n      gcloud dns record-sets transaction describe --zone=\"${ZONE_NAME}\" || return\n      if ! gcloud dns record-sets transaction execute --zone=\"${ZONE_NAME}\"; then\n        gcloud dns record-sets transaction abort --zone=\"${ZONE_NAME}\" || return\n        _kctf_log_err 'updating the SOA entry failed'\n        exit 1\n      fi\n      _kctf_log \"SOA updated\"\n    else\n      _kctf_log \"managed-zone \\\"${ZONE_NAME}\\\" exists, reusing\"\n    fi\n\n    DNS_ZONE_NAMESERVERS=$(gcloud dns managed-zones describe \"${ZONE_NAME}\" --format 'value[delimiter=\"\\n\"](nameServers)')\n    if [[ \"${DOMAIN_NAME}\" == *\".kctf.cloud\" ]]; then\n      _kctf_log \"waiting for nameservers to be updated (should take roughly 1m)\"\n      for nameserver in ${DNS_ZONE_NAMESERVERS}; do\n        wait_for_nameserver \"${nameserver}\" || return\n      done\n      KCTF_CLOUD_URL=\"${KCTF_CLOUD_BASE_URL}/subdomain?name=${DOMAIN_NAME%.kctf.cloud}&nameservers=$(paste -sd ',' <(echo \"${DNS_ZONE_NAMESERVERS}\"))\"\n      _kctf_log 'requesting kctf.cloud subdomain'\n      kctf_cloud_tries=3\n      kctf_cloud_timeout=10\n      while true; do\n        curl --fail -X POST -H \"x-api-key: ${KCTF_CLOUD_API_KEY}\" \"${KCTF_CLOUD_URL}\" >/dev/null && break\n        kctf_cloud_tries=$(($kctf_cloud_tries - 1))\n        if [[ $kctf_cloud_tries -le 0 ]]; then\n          _kctf_log_err 'could not register kctf.cloud subdomain'\n          exit 1\n        fi\n        _kctf_log_warn \"registering kctf.cloud subdomain failed, retrying in ${kctf_cloud_timeout}s\"\n        sleep \"${kctf_cloud_timeout}\"\n      done\n    else\n      # print in red for attention\n      _kctf_log $'\\001\\e[0;31m\\002'\"ATTENTION: \"$'\\001\\e[0m\\002'\"You need to add the following NS entries for your domain \\\"${DOMAIN_NAME}\\\":\"$'\\n'\"${DNS_ZONE_NAMESERVERS}\"\n      BYE_MSG=$'\\001\\e[0;31m\\002'\"ATTENTION: \"$'\\001\\e[0m\\002'\"You need to add the following NS entries for your domain \\\"${DOMAIN_NAME}\\\":\"$'\\n'\"${DNS_ZONE_NAMESERVERS}\"\n    fi\n\n    DNS_GSA_NAME=\"kctf-cloud-dns\"\n    DNS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${DNS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)' || true)\n\n    if [ -z \"${DNS_GSA_EMAIL}\" ]; then\n      gcloud iam service-accounts create \"${DNS_GSA_NAME}\" --description \"kCTF Cloud DNS service account ${CLUSTER_NAME} ${ZONE}\" --display-name \"kCTF Cloud DNS ${CLUSTER_NAME} ${ZONE}\" || return\n      DNS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${DNS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n      while [ -z \"${DNS_GSA_EMAIL}\" ]; do\n        sleep 1\n        DNS_GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${DNS_GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)')\n      done\n    fi\n\n    DNS_KSA_NAME=\"external-dns-sa\"\n\n    gcloud iam service-accounts add-iam-policy-binding --role roles/iam.workloadIdentityUser --member \"serviceAccount:${PROJECT}.svc.id.goog[kctf-system/${DNS_KSA_NAME}]\" ${DNS_GSA_EMAIL} || return\n    \"${KCTF_BIN}/kubectl\" create serviceaccount --namespace kctf-system ${DNS_KSA_NAME} --save-config --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n    \"${KCTF_BIN}/kubectl\" annotate serviceaccount --namespace kctf-system ${DNS_KSA_NAME} iam.gke.io/gcp-service-account=${DNS_GSA_EMAIL} --overwrite || return\n\n    gcloud projects add-iam-policy-binding ${PROJECT} --member=serviceAccount:${DNS_GSA_EMAIL} --role=roles/dns.admin || return\n\n    \"${KCTF_BIN}/kubectl\" create configmap --namespace kctf-system external-dns --from-literal=DOMAIN_NAME=${DOMAIN_NAME} --from-literal=EMAIL_ADDRESS=${EMAIL_ADDRESS:-} --dry-run=client -o yaml | \"${KCTF_BIN}/kubectl\" apply -f - || return\n  fi\n\n  if [[ \"${DISABLE_SRC_RANGES}\" == \"0\" ]]; then\n    if ! create_cloud_armor_policy; then\n      echo \"Could not create the cloud armor policy. If you have quota issues, you can disable the feature with --disable-src-ranges.\" >&2\n      return 1\n    fi\n  fi\n\n  create_operator || return\n}\n\nfunction kctf_cluster_start_usage {\n  echo \"usage: kctf cluster start [args]\" >&2\n  echo \"  -h|--help            print this help\" >&2\n  echo \"  --disable-src-ranges Disable the ip range feature (gce only). Use this if you have security policy quota issues\" >&2\n}\n\nfunction kctf_cluster_start {\n  DISABLE_SRC_RANGES=\"0\"\n\n  OPTS=\"h\"\n  LONGOPTS=\"help,disable-src-ranges\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster start\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_start_usage\n    return 1\n  fi\n  eval set -- \"$PARSED\"\n\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_start_usage\n        return 1\n        ;;\n      --disable-src-ranges)\n        DISABLE_SRC_RANGES=\"1\"\n        shift\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_start_usage\n        return 1\n        ;;\n    esac\n  done\n\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      kctf_cluster_start_gce\n      return\n      ;;\n    kind)\n      kctf_cluster_start_kind\n      return\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n}\n\nfunction kctf_cluster_stop_gce {\n  _kctf_log \"deleting all challenges so that load balancers etc can be cleaned up\"\n  CHALLENGES=$(\"${KCTF_BIN}/kubectl\" get challenge --all-namespaces -o=jsonpath='{range .items[*]}{@.metadata.namespace}{\"/\"}{@.metadata.name}{\" \"}{end}')\n  if [[ ! -z \"${CHALLENGES}\" ]]; then\n    for chal_and_ns in ${CHALLENGES}; do\n      IFS='/' read -r -a chal_and_ns_array <<< \"$chal_and_ns\"\n      chal_namespace=\"${chal_and_ns_array[0]}\"\n      chal_name=\"${chal_and_ns_array[1]}\"\n      \"${KCTF_BIN}/kubectl\" delete \"challenge/${chal_name}\" --namespace \"${chal_namespace}\"\n    done\n  fi\n\n  # deleting the cluster below takes a while, so sleeping for a bit doesn't hurt\n  _kctf_log \"Sleeping 20s to give time to delete resources\"\n  sleep 20\n\n  CLOUDSDK_CORE_DISABLE_PROMPTS=1 gcloud container clusters delete ${CLUSTER_NAME}\n  gcloud compute routers delete \"kctf-${CLUSTER_NAME}-nat-router\" --region \"${ZONE::${#ZONE}-2}\" --quiet\n\n  SUFFIX=$(echo \"${PROJECT}-${CLUSTER_NAME}-${ZONE}\" | sha1sum)\n\n  NETWORK=\"kctf-network-${SUFFIX:0:16}\"\n  gcloud compute networks delete ${NETWORK} --quiet\n\n  GSA_NAME=\"kctf-gcsfuse-${SUFFIX:0:16}\"\n  GSA_EMAIL=$(gcloud iam service-accounts list --filter \"email=${GSA_NAME}@${PROJECT}.iam.gserviceaccount.com\" --format 'get(email)' || true)\n  if [ -z \"${GSA_EMAIL}\" ]; then\n    gcloud iam service-accounts delete \"${GSA_EMAIL}\"\n  fi\n}\n\nfunction kctf_cluster_start_kind {\n  if ! \"${KCTF_BIN}/kind\" get kubeconfig --name \"${CLUSTER_NAME}\" >/dev/null 2>/dev/null; then\n    \"${KCTF_BIN}/kind\" create cluster --name \"${CLUSTER_NAME}\" || return\n  fi\n\n  \"${KCTF_BIN}/kubectl\" create namespace \"kctf-system\" --dry-run=client -oyaml | \"${KCTF_BIN}/kubectl\" apply -f - >&2 || return\n\n  create_operator\n\n  \"${KCTF_BIN}/kubectl\" patch ServiceAccount default --patch \"automountServiceAccountToken: false\" || return\n}\n\nfunction kctf_cluster_stop_kind {\n  \"${KCTF_BIN}/kind\" delete cluster --name \"${CLUSTER_NAME}\" || return\n}\n\nfunction kctf_cluster_stop {\n  case \"${CLUSTER_TYPE}\" in\n    gce)\n      kctf_cluster_stop_gce || return\n      return\n      ;;\n    kind)\n      kctf_cluster_stop_kind || return\n      return\n      ;;\n    *)\n      _kctf_log_err \"unknown cluster type \\\"${CLUSTER_TYPE}\\\"\"\n      return 1\n      ;;\n  esac\n}\n\nfunction kctf_cluster_resize_usage {\n  echo -e \"usage: kctf cluster resize [args]\" >&2\n  echo -e \"args:\" >&2\n  echo -e \"  -h|--help      print this help\" >&2\n  echo -e \"  --machine-type machine type to use\" >&2\n  echo -e \"                 to list available types, run: gcloud compute machine-types list --zones=\\\"${ZONE}\\\"\" >&2\n  echo -e \"  --min-nodes    (required) minimum number of nodes in the cluster\" >&2\n  echo -e \"  --max-nodes    (required) maximum number of nodes in the cluster\" >&2\n  echo -e \"  --num-nodes    (required) initial number of nodes in the cluster\" >&2\n  echo -e \"  --pool-name    name of the node pool\" >&2\n  echo -e \"  --old-pool     name of the old pool to replace\" >&2\n}\n\nfunction kctf_cluster_resize {\n  if [[ \"${CLUSTER_TYPE}\" != \"gce\" ]]; then\n    _kctf_log_err \"only cluster type \\\"gce\\\" is supported by resize\"\n    return 1\n  fi\n\n  OPTS=\"h\"\n  LONGOPTS=\"help,machine-type:,min-nodes:,max-nodes:,num-nodes:,pool-name:,old-pool:\"\n  PARSED=$(${GETOPT} --options=$OPTS --longoptions=$LONGOPTS --name \"kctf cluster resize\" -- \"$@\")\n  if [[ $? -ne 0 ]]; then\n    kctf_cluster_resize_usage\n    exit 1\n  fi\n  eval set -- \"$PARSED\"\n\n  MACHINE_TYPE=\"n2-standard-4\"\n  MIN_NODES=\n  MAX_NODES=\n  NUM_NODES=\n  NEW_POOL_NAME=\n  OLD_POOL_NAME=\n  while true; do\n    case \"$1\" in\n      -h|--help)\n        kctf_cluster_resize_usage\n        exit 0\n        ;;\n      --machine-type)\n        MACHINE_TYPE=\"$2\"\n        shift 2\n        ;;\n      --min-nodes)\n        MIN_NODES=\"$2\"\n        shift 2\n        ;;\n      --max-nodes)\n        MAX_NODES=\"$2\"\n        shift 2\n        ;;\n      --num-nodes)\n        NUM_NODES=\"$2\"\n        shift 2\n        ;;\n      --pool-name)\n        NEW_POOL_NAME=\"$2\"\n        shift 2\n        ;;\n      --old-pool)\n        OLD_POOL_NAME=\"$2\"\n        shift 2\n        ;;\n      --)\n        shift\n        break\n        ;;\n      *)\n        _kctf_log_err \"Unrecognized argument \\\"$1\\\".\"\n        kctf_cluster_resize_usage\n        exit 1\n        ;;\n    esac\n  done\n\n  if [[ -z \"${MIN_NODES}\" ]] || [[ -z \"${MAX_NODES}\" ]] || [[ -z \"${NUM_NODES}\" ]]; then\n    _kctf_log_err \"Required arguments missing\"\n    kctf_cluster_resize_usage\n    exit 1\n  fi\n\n  if [[ -z \"${OLD_POOL_NAME}\" ]]; then\n    OLD_POOL_NAME=$(gcloud container node-pools list --cluster ${CLUSTER_NAME} --format 'value(name)')\n    if [ $(echo \"${OLD_POOL_NAME}\" | wc -l) != \"1\" ]; then\n      _kctf_log_err 'Multiple node pools found. Please choose which to replace with --old-pool.'\n      echo '== node pools ==' >&2\n      echo \"${OLD_POOL_NAME}\" >&2\n      exit 1\n    fi\n  fi\n\n  if [[ -z \"${NEW_POOL_NAME}\" ]]; then\n    NEW_POOL_NAME=\"${OLD_POOL_NAME}-resized\"\n  fi\n\n  if [ \"${OLD_POOL_NAME}\" = \"${NEW_POOL_NAME}\" ]; then\n    _kctf_log_err \"New pool can't have the same name as the old pool.\"\n    exit 1\n  fi\n\n  if [[ $# -ne 0 ]]; then\n    _kctf_log_err \"Unrecognized arguments \\\"$@\\\".\"\n    kctf_cluster_resize_usage\n    exit 1\n  fi\n\n  _kctf_log 'Creating the new node pool'\n  gcloud container node-pools create \"${NEW_POOL_NAME}\" \\\n    --cluster=\"${CLUSTER_NAME}\" \\\n    --machine-type=\"${MACHINE_TYPE}\" \\\n    --enable-autorepair \\\n    --enable-autoupgrade \\\n    --num-nodes=\"${NUM_NODES}\" \\\n    --enable-autoscaling \\\n    --min-nodes=\"${MIN_NODES}\" \\\n    --max-nodes=\"${MAX_NODES}\" || return\n\n  _kctf_log 'Cordoning old nodes'\n  for node in $(\"${KCTF_BIN}/kubectl\" get nodes -l cloud.google.com/gke-nodepool=\"${OLD_POOL_NAME}\" -o=name); do\n    \"${KCTF_BIN}/kubectl\" cordon \"$node\" || return\n  done\n\n  _kctf_log 'Draining old nodes'\n  for node in $(\"${KCTF_BIN}/kubectl\" get nodes -l cloud.google.com/gke-nodepool=\"${OLD_POOL_NAME}\" -o=name); do\n    \"${KCTF_BIN}/kubectl\" drain --force --ignore-daemonsets --delete-local-data --grace-period=10 \"$node\" || return\n  done\n\n  _kctf_log \"Deleting old node pool \\\"${OLD_POOL_NAME}\\\"\"\n  gcloud container node-pools delete \"${OLD_POOL_NAME}\" --cluster \"${CLUSTER_NAME}\" || return\n}\n\nfunction kctf_cluster_usage {\n  echo -e \"usage: kctf cluster command\" >&2\n  echo -e \"available commands:\" >&2\n  echo -e \"  create:            create a new cluster config\" >&2\n  echo -e \"  list:              list available cluster configs\" >&2\n  echo -e \"  load:              load an existing cluster config\" >&2\n  echo -e \"  start:             start the cluster\" >&2\n  echo -e \"  stop:              stop the cluster\" >&2\n  echo -e \"  resize:            resize the cluster\" >&2\n  echo -e \"  set-src-ip-ranges: allow ranges of IPs to access the services\" >&2\n  echo -e \"  get-src-ip-ranges: print the current allowed IP ranges\" >&2\n}\n\nfunction check_cluster_name {\n  if [[ -z \"${CLUSTER_NAME-}\" ]]; then\n    _kctf_log_err \"No cluster config loaded. You need to run \\\"kctf cluster create\\\" or \\\"kctf cluster load\\\" first.\"\n    exit 1\n  fi\n}\n\nif [[ $# -lt 1 ]]; then\n  _kctf_log_err \"unexpected argument count\"\n  kctf_cluster_usage\n  exit 1\nfi\n\ncase \"$1\" in\n  -h|--help)\n    kctf_cluster_usage\n    exit 0\n    ;;\n  start)\n    shift\n    check_cluster_name\n    kctf_cluster_start $@\n    # This is used for printing DNS settings once again at the end\n    echo $BYE_MSG\n    ;;\n  stop)\n    shift\n    check_cluster_name\n    kctf_cluster_stop $@\n    ;;\n  resize)\n    shift\n    check_cluster_name\n    kctf_cluster_resize $@\n    ;;\n  create)\n    shift\n    kctf_cluster_create $@\n    ;;\n  list)\n    shift\n    kctf_cluster_list $@\n    ;;\n  load)\n    shift\n    kctf_cluster_load $@\n    ;;\n  set-src-ip-ranges)\n    shift\n    kctf_cluster_ip_ranges $@\n    ;;\n  get-src-ip-ranges)\n    shift\n    kctf_cluster_get_ip_ranges $@\n    ;;\n  *)\n    _kctf_log_err \"unknown command\"\n    kctf_cluster_usage\n    exit 1\n    ;;\nesac\n"], "filenames": ["dist/bin/kctf-cluster"], "buggy_code_start_loc": [396], "buggy_code_end_loc": [412], "fixing_code_start_loc": [396], "fixing_code_end_loc": [413], "type": "CWE-863", "message": "kCTF is a Kubernetes-based infrastructure for capture the flag (CTF) competitions. Prior to version 1.6.0, the kctf cluster set-src-ip-ranges was broken and allowed traffic from any IP. The problem has been patched in v1.6.0. As a workaround, those who want to test challenges privately can mark them as `public: false` and use `kctf chal debug port-forward` to connect.", "other": {"cve": {"id": "CVE-2022-31055", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-13T16:15:08.487", "lastModified": "2022-06-27T16:12:40.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "kCTF is a Kubernetes-based infrastructure for capture the flag (CTF) competitions. Prior to version 1.6.0, the kctf cluster set-src-ip-ranges was broken and allowed traffic from any IP. The problem has been patched in v1.6.0. As a workaround, those who want to test challenges privately can mark them as `public: false` and use `kctf chal debug port-forward` to connect."}, {"lang": "es", "value": "kCTF es una infraestructura basada en Kubernetes para competiciones de captura de la bandera (CTF). En versiones anteriores a 1.6.0, el cluster kctf set-src-ip-ranges estaba roto y permit\u00eda el tr\u00e1fico desde cualquier IP. El problema ha sido parcheado en versi\u00f3n v1.6.0. Como mitigaci\u00f3n, aquellos que quieran probar los retos de forma privada pueden marcarlos como \"public: false\" y usar \"kctf chal debug port-forward\" para conectarse"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:kctf:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.0", "matchCriteriaId": "B80D91E1-40B9-40C1-ACD2-91D177C0EF56"}]}]}], "references": [{"url": "https://github.com/google/kctf/commit/8cf050be974fcc2fd8aa136701f9a66f2b2a5202", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/kctf/pull/371", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/kctf/security/advisories/GHSA-4g2v-6qc6-6jv5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/kctf/commit/8cf050be974fcc2fd8aa136701f9a66f2b2a5202"}}