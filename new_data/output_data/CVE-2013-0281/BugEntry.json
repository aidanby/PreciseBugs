{"buggy_code": ["/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <grp.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <crm/crm.h>\n#include <crm/cib.h>\n#include <crm/msg_xml.h>\n#include <crm/common/ipc.h>\n#include <crm/cluster/internal.h>\n\n#include <crm/common/xml.h>\n\n\n#include <cibio.h>\n#include <callbacks.h>\n#include <cibmessages.h>\n#include <notify.h>\n#include \"common.h\"\n\nextern GMainLoop *mainloop;\nextern gboolean cib_shutdown_flag;\nextern gboolean stand_alone;\nextern const char *cib_root;\n\nstatic unsigned long cib_local_bcast_num = 0;\n\ntypedef struct cib_local_notify_s {\n    xmlNode *notify_src;\n    char *client_id;\n    gboolean from_peer;\n    gboolean sync_reply;\n} cib_local_notify_t;\n\nqb_ipcs_service_t *ipcs_ro = NULL;\nqb_ipcs_service_t *ipcs_rw = NULL;\nqb_ipcs_service_t *ipcs_shm = NULL;\n\nextern crm_cluster_t crm_cluster;\n\nextern int cib_update_counter(xmlNode * xml_obj, const char *field, gboolean reset);\n\nextern void GHFunc_count_peers(gpointer key, gpointer value, gpointer user_data);\n\ngint cib_GCompareFunc(gconstpointer a, gconstpointer b);\ngboolean can_write(int flags);\nvoid send_cib_replace(const xmlNode * sync_request, const char *host);\nvoid cib_process_request(xmlNode * request, gboolean privileged, gboolean force_synchronous,\n                         gboolean from_peer, cib_client_t * cib_client);\n\nextern GHashTable *client_list;\nextern GHashTable *local_notify_queue;\n\nint next_client_id = 0;\nextern const char *cib_our_uname;\nextern unsigned long cib_num_ops, cib_num_local, cib_num_updates, cib_num_fail;\nextern unsigned long cib_bad_connects, cib_num_timeouts;\nextern int cib_status;\n\nint cib_process_command(xmlNode * request, xmlNode ** reply,\n                                    xmlNode ** cib_diff, gboolean privileged);\n\ngboolean cib_common_callback(qb_ipcs_connection_t *c, void *data, size_t size, gboolean privileged);\n\nstatic int32_t\ncib_ipc_accept(qb_ipcs_connection_t *c, uid_t uid, gid_t gid)\n{\n    cib_client_t *new_client = NULL;\n#if ENABLE_ACL\n    struct group *crm_grp = NULL;\n#endif\n\n    crm_trace(\"Connecting %p for uid=%d gid=%d pid=%d\", c, uid, gid, crm_ipcs_client_pid(c));\n    if (cib_shutdown_flag) {\n        crm_info(\"Ignoring new client [%d] during shutdown\", crm_ipcs_client_pid(c));\n        return -EPERM;\n    }\n\n    new_client = calloc(1, sizeof(cib_client_t));\n    new_client->ipc = c;\n\n    CRM_CHECK(new_client->id == NULL, free(new_client->id));\n    new_client->id = crm_generate_uuid();\n\n#if ENABLE_ACL\n    crm_grp = getgrnam(CRM_DAEMON_GROUP);\n    if (crm_grp) {\n        qb_ipcs_connection_auth_set(c, -1, crm_grp->gr_gid, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    new_client->user = uid2username(uid);\n#endif\n\n    /* make sure we can find ourselves later for sync calls\n     * redirected to the master instance\n     */\n    g_hash_table_insert(client_list, new_client->id, new_client);\n\n    qb_ipcs_context_set(c, new_client);\n\n    return 0;\n}\n\nstatic void\ncib_ipc_created(qb_ipcs_connection_t *c)\n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n\n    crm_trace(\"%p connected for client %s\", c, cib_client->id);\n}\n\nstatic int32_t\ncib_ipc_dispatch_rw(qb_ipcs_connection_t *c, void *data, size_t size)\n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n    crm_trace(\"%p message from %s\", c, cib_client->id);\n    return cib_common_callback(c, data, size, TRUE);\n}\n\nstatic int32_t\ncib_ipc_dispatch_ro(qb_ipcs_connection_t *c, void *data, size_t size)\n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n    crm_trace(\"%p message from %s\", c, cib_client->id);\n    return cib_common_callback(c, data, size, FALSE);\n}\n\n/* Error code means? */\nstatic int32_t\ncib_ipc_closed(qb_ipcs_connection_t *c) \n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n    crm_trace(\"Connection %p closed\", c);\n\n    CRM_ASSERT(cib_client != NULL);\n    CRM_ASSERT(cib_client->id != NULL);\n\n    if (!g_hash_table_remove(client_list, cib_client->id)) {\n        crm_err(\"Client %s not found in the hashtable\", cib_client->name);\n    }\n\n    return 0;\n}\n\nstatic void\ncib_ipc_destroy(qb_ipcs_connection_t *c) \n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n\n    CRM_ASSERT(cib_client != NULL);\n    CRM_ASSERT(cib_client->id != NULL);\n\n    /* In case we arrive here without a call to cib_ipc_close() */\n    g_hash_table_remove(client_list, cib_client->id);\n\n    crm_trace(\"Destroying %s (%p)\", cib_client->name, c);\n    free(cib_client->name);\n    free(cib_client->callback_id);\n    free(cib_client->id);\n    free(cib_client->user);\n    free(cib_client);\n    crm_trace(\"Freed the cib client\");\n\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n}\n\nstruct qb_ipcs_service_handlers ipc_ro_callbacks = \n{\n    .connection_accept = cib_ipc_accept,\n    .connection_created = cib_ipc_created,\n    .msg_process = cib_ipc_dispatch_ro,\n    .connection_closed = cib_ipc_closed,\n    .connection_destroyed = cib_ipc_destroy\n};\n\nstruct qb_ipcs_service_handlers ipc_rw_callbacks = \n{\n    .connection_accept = cib_ipc_accept,\n    .connection_created = cib_ipc_created,\n    .msg_process = cib_ipc_dispatch_rw,\n    .connection_closed = cib_ipc_closed,\n    .connection_destroyed = cib_ipc_destroy\n};\n\nvoid\ncib_common_callback_worker(uint32_t id, uint32_t flags, xmlNode * op_request, cib_client_t * cib_client, gboolean privileged)\n{\n    const char *op = crm_element_value(op_request, F_CIB_OPERATION);\n\n    if (crm_str_eq(op, CRM_OP_REGISTER, TRUE)) {\n        if(flags & crm_ipc_client_response) {\n            xmlNode *ack = create_xml_node(NULL, __FUNCTION__);\n\n            crm_xml_add(ack, F_CIB_OPERATION, CRM_OP_REGISTER);\n            crm_xml_add(ack, F_CIB_CLIENTID, cib_client->id);\n            crm_ipcs_send(cib_client->ipc, id, ack, FALSE);\n            cib_client->request_id = 0;\n            free_xml(ack);\n        }\n        return;\n\n    } else if (crm_str_eq(op, T_CIB_NOTIFY, TRUE)) {\n        /* Update the notify filters for this client */\n        int on_off = 0;\n        const char *type = crm_element_value(op_request, F_CIB_NOTIFY_TYPE);\n        crm_element_value_int(op_request, F_CIB_NOTIFY_ACTIVATE, &on_off);\n\n        crm_debug(\"Setting %s callbacks for %s (%s): %s\",\n                  type, cib_client->name, cib_client->id, on_off ? \"on\" : \"off\");\n\n        if (safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n            cib_client->post_notify = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n            cib_client->pre_notify = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n            cib_client->confirmations = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n            cib_client->diffs = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n            cib_client->replace = on_off;\n        }\n\n        if(flags & crm_ipc_client_response) {\n            /* TODO - include rc */\n            crm_ipcs_send_ack(cib_client->ipc, id, \"ack\", __FUNCTION__, __LINE__);\n            cib_client->request_id = 0;\n        }\n        return;\n    }\n\n    cib_client->num_calls++;\n    cib_process_request(op_request, FALSE, privileged, FALSE, cib_client);\n}\n\nint32_t\ncib_common_callback(qb_ipcs_connection_t *c, void *data, size_t size, gboolean privileged)\n{\n    uint32_t id = 0;\n    uint32_t flags = 0;\n    int call_options = 0;\n    xmlNode *op_request = crm_ipcs_recv(c, data, size, &id, &flags);\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n\n    if(op_request) {\n        crm_element_value_int(op_request, F_CIB_CALLOPTS, &call_options);\n    }\n\n    crm_trace(\"Inbound: %.200s\", data);\n    if (op_request == NULL || cib_client == NULL) {\n        crm_ipcs_send_ack(c, id, \"nack\", __FUNCTION__, __LINE__);\n        return 0;\n    }\n\n    if(is_set(call_options, cib_sync_call)) {\n        CRM_ASSERT(flags & crm_ipc_client_response);\n    }\n\n    if(flags & crm_ipc_client_response) {\n        CRM_LOG_ASSERT(cib_client->request_id == 0); /* This means the client has two synchronous events in-flight */\n        cib_client->request_id = id;                 /* Reply only to the last one */\n    }\n\n    \n    if (cib_client->name == NULL) {\n        const char *value = crm_element_value(op_request, F_CIB_CLIENTNAME);\n        if (value == NULL) {\n            cib_client->name = crm_itoa(crm_ipcs_client_pid(c));\n        } else {\n            cib_client->name = strdup(value);\n        }\n    }\n\n    if (cib_client->callback_id == NULL) {\n        const char *value = crm_element_value(op_request, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            cib_client->callback_id = strdup(value);\n            \n        } else {\n            cib_client->callback_id = strdup(cib_client->id);\n        }\n    }\n    \n    crm_xml_add(op_request, F_CIB_CLIENTID, cib_client->id);\n    crm_xml_add(op_request, F_CIB_CLIENTNAME, cib_client->name);\n\n#if ENABLE_ACL\n    determine_request_user(cib_client->user, op_request, F_CIB_USER);\n#endif\n\n    crm_log_xml_trace(op_request, \"Client[inbound]\");\n\n    cib_common_callback_worker(id, flags, op_request, cib_client, privileged);\n    free_xml(op_request);\n\n    return 0;\n}\n\nstatic void\ndo_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    /* send callback to originating child */\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n\n    } else {\n        int rid = 0;\n\n        if(sync_reply) {\n            CRM_LOG_ASSERT(client_obj->request_id);\n\n            rid = client_obj->request_id;\n            client_obj->request_id = 0;\n\n            crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}\n\nstatic void\nlocal_notify_destroy_callback(gpointer data)\n{\n    cib_local_notify_t *notify = data;\n\n    free_xml(notify->notify_src);\n    free(notify->client_id);\n    free(notify);\n}\n\nstatic void\ncheck_local_notify(int bcast_id)\n{\n    cib_local_notify_t *notify = NULL;\n\n    if (!local_notify_queue) {\n        return;\n    }\n\n    notify = g_hash_table_lookup(local_notify_queue, GINT_TO_POINTER(bcast_id));\n\n    if (notify) {\n        do_local_notify(notify->notify_src, notify->client_id, notify->sync_reply, notify->from_peer);\n        g_hash_table_remove(local_notify_queue, GINT_TO_POINTER(bcast_id));\n    }\n}\n\nstatic void\nqueue_local_notify(xmlNode * notify_src, const char *client_id, gboolean sync_reply, gboolean from_peer)\n{\n    cib_local_notify_t *notify = calloc(1, sizeof(cib_local_notify_t));\n\n    notify->notify_src = notify_src;\n    notify->client_id = strdup(client_id);\n    notify->sync_reply = sync_reply;\n    notify->from_peer = from_peer;\n\n    if (!local_notify_queue) {\n        local_notify_queue = g_hash_table_new_full(g_direct_hash,\n            g_direct_equal, NULL, local_notify_destroy_callback);\n    }\n\n    g_hash_table_insert(local_notify_queue, GINT_TO_POINTER(cib_local_bcast_num), notify);\n}\n\nstatic void\nparse_local_options(cib_client_t * cib_client, int call_type, int call_options, const char *host,\n                    const char *op, gboolean * local_notify, gboolean * needs_reply,\n                    gboolean * process, gboolean * needs_forward)\n{\n    if (cib_op_modifies(call_type)\n        && !(call_options & cib_inhibit_bcast)) {\n        /* we need to send an update anyway */\n        *needs_reply = TRUE;\n    } else {\n        *needs_reply = FALSE;\n    }\n\n    if (host == NULL && (call_options & cib_scope_local)) {\n        crm_trace(\"Processing locally scoped %s op from %s\", op, cib_client->name);\n        *local_notify = TRUE;\n\n    } else if (host == NULL && cib_is_master) {\n        crm_trace(\"Processing master %s op locally from %s\", op, cib_client->name);\n        *local_notify = TRUE;\n\n    } else if (safe_str_eq(host, cib_our_uname)) {\n        crm_trace(\"Processing locally addressed %s op from %s\", op, cib_client->name);\n        *local_notify = TRUE;\n\n    } else if (stand_alone) {\n        *needs_forward = FALSE;\n        *local_notify = TRUE;\n        *process = TRUE;\n\n    } else {\n        crm_trace(\"%s op from %s needs to be forwarded to %s\",\n                    op, cib_client->name, host ? host : \"the master instance\");\n        *needs_forward = TRUE;\n        *process = FALSE;\n    }\n}\n\nstatic gboolean\nparse_peer_options(int call_type, xmlNode * request,\n                   gboolean * local_notify, gboolean * needs_reply, gboolean * process,\n                   gboolean * needs_forward)\n{\n    const char *op = NULL;\n    const char *host = NULL;\n    const char *delegated = NULL;\n    const char *originator = crm_element_value(request, F_ORIG);\n    const char *reply_to = crm_element_value(request, F_CIB_ISREPLY);\n    const char *update = crm_element_value(request, F_CIB_GLOBAL_UPDATE);\n\n    gboolean is_reply = safe_str_eq(reply_to, cib_our_uname);\n\n    if (crm_is_true(update)) {\n        *needs_reply = FALSE;\n        if (is_reply) {\n            *local_notify = TRUE;\n            crm_trace(\"Processing global/peer update from %s\"\n                      \" that originated from us\", originator);\n        } else {\n            crm_trace(\"Processing global/peer update from %s\", originator);\n        }\n        return TRUE;\n    }\n\n    host = crm_element_value(request, F_CIB_HOST);\n    if (host != NULL && safe_str_eq(host, cib_our_uname)) {\n        crm_trace(\"Processing request sent to us from %s\", originator);\n        return TRUE;\n\n    } else if (host == NULL && cib_is_master == TRUE) {\n        crm_trace(\"Processing request sent to master instance from %s\", originator);\n        return TRUE;\n    }\n\n    op = crm_element_value(request, F_CIB_OPERATION);\n    if(safe_str_eq(op, \"cib_shutdown_req\")) {\n        /* Always process these */\n        *local_notify = FALSE;\n        if(reply_to == NULL || is_reply) {\n            *process = TRUE;\n        }\n        if(is_reply) {\n            *needs_reply = FALSE;\n        }\n        return *process;\n    }\n\n    if (is_reply) {\n        crm_trace(\"Forward reply sent from %s to local clients\", originator);\n        *process = FALSE;\n        *needs_reply = FALSE;\n        *local_notify = TRUE;\n        return TRUE;\n    }\n\n    delegated = crm_element_value(request, F_CIB_DELEGATED);\n    if (delegated != NULL) {\n        crm_trace(\"Ignoring msg for master instance\");\n\n    } else if (host != NULL) {\n        /* this is for a specific instance and we're not it */\n        crm_trace(\"Ignoring msg for instance on %s\", crm_str(host));\n\n    } else if (reply_to == NULL && cib_is_master == FALSE) {\n        /* this is for the master instance and we're not it */\n        crm_trace(\"Ignoring reply to %s\", crm_str(reply_to));\n\n    } else if (safe_str_eq(op, \"cib_shutdown_req\")) {\n        if (reply_to != NULL) {\n            crm_debug(\"Processing %s from %s\", op, host);\n            *needs_reply = FALSE;\n\n        } else {\n            crm_debug(\"Processing %s reply from %s\", op, host);\n        }\n        return TRUE;\n\n    } else {\n        crm_err(\"Nothing for us to do?\");\n        crm_log_xml_err(request, \"Peer[inbound]\");\n    }\n\n    return FALSE;\n}\n\nstatic void\nforward_request(xmlNode * request, cib_client_t * cib_client, int call_options)\n{\n    const char *op = crm_element_value(request, F_CIB_OPERATION);\n    const char *host = crm_element_value(request, F_CIB_HOST);\n\n    crm_xml_add(request, F_CIB_DELEGATED, cib_our_uname);\n\n    if (host != NULL) {\n        crm_trace(\"Forwarding %s op to %s\", op, host);\n        send_cluster_message(crm_get_peer(0, host), crm_msg_cib, request, FALSE);\n\n    } else {\n        crm_trace(\"Forwarding %s op to master instance\", op);\n        send_cluster_message(NULL, crm_msg_cib, request, FALSE);\n    }\n\n    /* Return the request to its original state */\n    xml_remove_prop(request, F_CIB_DELEGATED);\n\n    if (call_options & cib_discard_reply) {\n        crm_trace(\"Client not interested in reply\");\n    }\n}\n\nstatic gboolean\nsend_peer_reply(xmlNode * msg, xmlNode * result_diff, const char *originator, gboolean broadcast)\n{\n    CRM_ASSERT(msg != NULL);\n\n    if (broadcast) {\n        /* this (successful) call modified the CIB _and_ the\n         * change needs to be broadcast...\n         *   send via HA to other nodes\n         */\n        int diff_add_updates = 0;\n        int diff_add_epoch = 0;\n        int diff_add_admin_epoch = 0;\n\n        int diff_del_updates = 0;\n        int diff_del_epoch = 0;\n        int diff_del_admin_epoch = 0;\n\n        const char *digest = NULL;\n\n        digest = crm_element_value(result_diff, XML_ATTR_DIGEST);\n        cib_diff_version_details(result_diff,\n                                 &diff_add_admin_epoch, &diff_add_epoch, &diff_add_updates,\n                                 &diff_del_admin_epoch, &diff_del_epoch, &diff_del_updates);\n\n        crm_trace(\"Sending update diff %d.%d.%d -> %d.%d.%d %s\",\n                    diff_del_admin_epoch, diff_del_epoch, diff_del_updates,\n                  diff_add_admin_epoch, diff_add_epoch, diff_add_updates, digest);\n\n        crm_xml_add(msg, F_CIB_ISREPLY, originator);\n        crm_xml_add(msg, F_CIB_GLOBAL_UPDATE, XML_BOOLEAN_TRUE);\n        crm_xml_add(msg, F_CIB_OPERATION, CIB_OP_APPLY_DIFF);\n\n        CRM_ASSERT(digest != NULL);\n\n        add_message_xml(msg, F_CIB_UPDATE_DIFF, result_diff);\n        crm_log_xml_trace(msg, \"copy\");\n        return send_cluster_message(NULL, crm_msg_cib, msg, TRUE);\n\n    } else if (originator != NULL) {\n        /* send reply via HA to originating node */\n        crm_trace(\"Sending request result to originator only\");\n        crm_xml_add(msg, F_CIB_ISREPLY, originator);\n        return send_cluster_message(crm_get_peer(0, originator), crm_msg_cib, msg, FALSE);\n    }\n\n    return FALSE;\n}\n\nvoid\ncib_process_request(xmlNode * request, gboolean force_synchronous, gboolean privileged,\n                    gboolean from_peer, cib_client_t * cib_client)\n{\n    int call_type = 0;\n    int call_options = 0;\n\n    gboolean process = TRUE;\n    gboolean is_update = TRUE;\n    gboolean needs_reply = TRUE;\n    gboolean local_notify = FALSE;\n    gboolean needs_forward = FALSE;\n    gboolean global_update = crm_is_true(crm_element_value(request, F_CIB_GLOBAL_UPDATE));\n\n    xmlNode *op_reply = NULL;\n    xmlNode *result_diff = NULL;\n\n    int rc = pcmk_ok;\n    const char *op = crm_element_value(request, F_CIB_OPERATION);\n    const char *originator = crm_element_value(request, F_ORIG);\n    const char *host = crm_element_value(request, F_CIB_HOST);\n    const char *client_id = crm_element_value(request, F_CIB_CLIENTID);\n\n    crm_trace(\"%s Processing msg %s\", cib_our_uname, crm_element_value(request, F_SEQ));\n\n    cib_num_ops++;\n    if (cib_num_ops == 0) {\n        cib_num_fail = 0;\n        cib_num_local = 0;\n        cib_num_updates = 0;\n        crm_info(\"Stats wrapped around\");\n    }\n\n    if (host != NULL && strlen(host) == 0) {\n        host = NULL;\n    }\n\n    crm_element_value_int(request, F_CIB_CALLOPTS, &call_options);\n    if (force_synchronous) {\n        call_options |= cib_sync_call;\n    }\n\n    crm_trace(\"Processing %s message (%s) for %s...\",\n                from_peer ? \"peer\" : \"local\",\n                from_peer ? originator : cib_our_uname, host ? host : \"master\");\n\n    rc = cib_get_operation_id(op, &call_type);\n    if (rc != pcmk_ok) {\n        /* TODO: construct error reply? */\n        crm_err(\"Pre-processing of command failed: %s\", pcmk_strerror(rc));\n        return;\n    }\n\n    is_update = cib_op_modifies(call_type);\n    if (is_update) {\n        cib_num_updates++;\n    }\n\n    if (from_peer == FALSE) {\n        parse_local_options(cib_client, call_type, call_options, host, op,\n                            &local_notify, &needs_reply, &process, &needs_forward);\n\n    } else if (parse_peer_options(call_type, request, &local_notify,\n                                  &needs_reply, &process, &needs_forward) == FALSE) {\n        return;\n    }\n    crm_trace(\"Finished determining processing actions\");\n\n    if (call_options & cib_discard_reply) {\n        needs_reply = is_update;\n        local_notify = FALSE;\n    }\n\n    if (needs_forward) {\n        forward_request(request, cib_client, call_options);\n        return;\n    }\n\n    if (cib_status != pcmk_ok) {\n        rc = cib_status;\n        crm_err(\"Operation ignored, cluster configuration is invalid.\"\n                \" Please repair and restart: %s\", pcmk_strerror(cib_status));\n        op_reply = cib_construct_reply(request, the_cib, cib_status);\n\n    } else if (process) {\n        int level = LOG_INFO;\n        const char *section = crm_element_value(request, F_CIB_SECTION);\n\n        cib_num_local++;\n        rc = cib_process_command(request, &op_reply, &result_diff, privileged);\n\n        if (global_update) {\n            switch (rc) {\n                case pcmk_ok:\n                case -pcmk_err_old_data:\n                case -pcmk_err_diff_resync:\n                case -pcmk_err_diff_failed:\n                    level = LOG_DEBUG_2;\n                    break;\n                default:\n                    level = LOG_ERR;\n            }\n\n        } else if (safe_str_eq(op, CIB_OP_QUERY)) {\n            level = LOG_DEBUG_2;\n\n        } else if (rc != pcmk_ok) {\n            cib_num_fail++;\n            level = LOG_WARNING;\n\n        } else if (safe_str_eq(op, CIB_OP_SLAVE)) {\n            level = LOG_DEBUG_2;\n\n        } else if (safe_str_eq(section, XML_CIB_TAG_STATUS)) {\n            level = LOG_DEBUG_2;\n        }\n\n        do_crm_log_unlikely(level,\n                       \"Operation complete: op %s for section %s (origin=%s/%s/%s, version=%s.%s.%s): %s (rc=%d)\",\n                       op, section ? section : \"'all'\", originator ? originator : \"local\",\n                       crm_element_value(request, F_CIB_CLIENTNAME), crm_element_value(request,\n                                                                                       F_CIB_CALLID),\n                       the_cib ? crm_element_value(the_cib, XML_ATTR_GENERATION_ADMIN) : \"0\",\n                       the_cib ? crm_element_value(the_cib, XML_ATTR_GENERATION) : \"0\",\n                       the_cib ? crm_element_value(the_cib, XML_ATTR_NUMUPDATES) : \"0\",\n                       pcmk_strerror(rc), rc);\n\n        if (op_reply == NULL && (needs_reply || local_notify)) {\n            crm_err(\"Unexpected NULL reply to message\");\n            crm_log_xml_err(request, \"null reply\");\n            needs_reply = FALSE;\n            local_notify = FALSE;\n        }\n    }\n    crm_trace(\"processing response cases %.16x %.16x\", call_options, cib_sync_call);\n\n    /* from now on we are the server */\n    if (needs_reply == FALSE || stand_alone) {\n        /* nothing more to do...\n         * this was a non-originating slave update\n         */\n        crm_trace(\"Completed slave update\");\n\n    } else if (rc == pcmk_ok && result_diff != NULL && !(call_options & cib_inhibit_bcast)) {\n        gboolean broadcast = FALSE;\n\n        cib_local_bcast_num++;\n        crm_xml_add_int(request, F_CIB_LOCAL_NOTIFY_ID, cib_local_bcast_num);\n        broadcast = send_peer_reply(request, result_diff, originator, TRUE);\n\n        if (broadcast &&\n            client_id &&\n            local_notify &&\n            op_reply) {\n\n            /* If we have been asked to sync the reply,\n             * and a bcast msg has gone out, we queue the local notify\n             * until we know the bcast message has been received */\n            local_notify = FALSE;\n            queue_local_notify(op_reply, client_id, (call_options & cib_sync_call), from_peer);\n            op_reply = NULL; /* the reply is queued, so don't free here */\n        }\n\n    } else if (call_options & cib_discard_reply) {\n        crm_trace(\"Caller isn't interested in reply\");\n\n    } else if (from_peer) {\n        if (is_update == FALSE || result_diff == NULL) {\n            crm_trace(\"Request not broadcast: R/O call\");\n\n        } else if (call_options & cib_inhibit_bcast) {\n            crm_trace(\"Request not broadcast: inhibited\");\n\n        } else if (rc != pcmk_ok) {\n            crm_trace(\"Request not broadcast: call failed: %s\", pcmk_strerror(rc));\n        } else {\n            crm_trace(\"Directing reply to %s\", originator);\n        }\n\n        send_peer_reply(op_reply, result_diff, originator, FALSE);\n    }\n\n    if (local_notify && client_id) {\n        if (process == FALSE) {\n            do_local_notify(request, client_id, call_options & cib_sync_call, from_peer);\n        } else {\n            do_local_notify(op_reply, client_id, call_options & cib_sync_call, from_peer);\n        }\n    }\n\n    free_xml(op_reply);\n    free_xml(result_diff);\n\n    return;\n}\n\nxmlNode *\ncib_construct_reply(xmlNode * request, xmlNode * output, int rc)\n{\n    int lpc = 0;\n    xmlNode *reply = NULL;\n    const char *name = NULL;\n    const char *value = NULL;\n\n    const char *names[] = {\n        F_CIB_OPERATION,\n        F_CIB_CALLID,\n        F_CIB_CLIENTID,\n        F_CIB_CALLOPTS\n    };\n    static int max = DIMOF(names);\n\n    crm_trace(\"Creating a basic reply\");\n    reply = create_xml_node(NULL, \"cib-reply\");\n    crm_xml_add(reply, F_TYPE, T_CIB);\n\n    for (lpc = 0; lpc < max; lpc++) {\n        name = names[lpc];\n        value = crm_element_value(request, name);\n        crm_xml_add(reply, name, value);\n    }\n\n    crm_xml_add_int(reply, F_CIB_RC, rc);\n\n    if (output != NULL) {\n        crm_trace(\"Attaching reply output\");\n        add_message_xml(reply, F_CIB_CALLDATA, output);\n    }\n    return reply;\n}\n\nint\ncib_process_command(xmlNode * request, xmlNode ** reply, xmlNode ** cib_diff, gboolean privileged)\n{\n    xmlNode *input = NULL;\n    xmlNode *output = NULL;\n    xmlNode *result_cib = NULL;\n    xmlNode *current_cib = NULL;\n\n#if ENABLE_ACL\n    xmlNode *filtered_current_cib = NULL;\n#endif\n\n    int call_type = 0;\n    int call_options = 0;\n    int log_level = LOG_DEBUG_4;\n\n    const char *op = NULL;\n    const char *section = NULL;\n\n    int rc = pcmk_ok;\n    int rc2 = pcmk_ok;\n\n    gboolean send_r_notify = FALSE;\n    gboolean global_update = FALSE;\n    gboolean config_changed = FALSE;\n    gboolean manage_counters = TRUE;\n\n    CRM_ASSERT(cib_status == pcmk_ok);\n\n    *reply = NULL;\n    *cib_diff = NULL;\n    current_cib = the_cib;\n\n    /* Start processing the request... */\n    op = crm_element_value(request, F_CIB_OPERATION);\n    crm_element_value_int(request, F_CIB_CALLOPTS, &call_options);\n    rc = cib_get_operation_id(op, &call_type);\n\n    if (rc == pcmk_ok && privileged == FALSE) {\n        rc = cib_op_can_run(call_type, call_options, privileged, global_update);\n    }\n\n    rc2 = cib_op_prepare(call_type, request, &input, &section);\n    if (rc == pcmk_ok) {\n        rc = rc2;\n    }\n\n    if (rc != pcmk_ok) {\n        crm_trace(\"Call setup failed: %s\", pcmk_strerror(rc));\n        goto done;\n\n    } else if (cib_op_modifies(call_type) == FALSE) {\n#if ENABLE_ACL\n        if (acl_enabled(config_hash) == FALSE\n            || acl_filter_cib(request, current_cib, current_cib, &filtered_current_cib) == FALSE) {\n            rc = cib_perform_op(op, call_options, cib_op_func(call_type), TRUE,\n                                section, request, input, FALSE, &config_changed,\n                                current_cib, &result_cib, NULL, &output);\n\n        } else if (filtered_current_cib == NULL) {\n            crm_debug(\"Pre-filtered the entire cib\");\n            rc = -EACCES;\n\n        } else {\n            crm_debug(\"Pre-filtered the queried cib according to the ACLs\");\n            rc = cib_perform_op(op, call_options, cib_op_func(call_type), TRUE,\n                                section, request, input, FALSE, &config_changed,\n                                filtered_current_cib, &result_cib, NULL, &output);\n        }\n#else\n        rc = cib_perform_op(op, call_options, cib_op_func(call_type), TRUE,\n                            section, request, input, FALSE, &config_changed,\n                            current_cib, &result_cib, NULL, &output);\n\n#endif\n\n        CRM_CHECK(result_cib == NULL, free_xml(result_cib));\n        goto done;\n    }\n\n    /* Handle a valid write action */\n    global_update = crm_is_true(crm_element_value(request, F_CIB_GLOBAL_UPDATE));\n    if (global_update) {\n        manage_counters = FALSE;\n        call_options |= cib_force_diff;\n\n        CRM_CHECK(call_type == 3 || call_type == 4, crm_err(\"Call type: %d\", call_type);\n                  crm_log_xml_err(request, \"bad op\"));\n    }\n#ifdef SUPPORT_PRENOTIFY\n    if ((call_options & cib_inhibit_notify) == 0) {\n        cib_pre_notify(call_options, op, the_cib, input);\n    }\n#endif\n\n    if (rc == pcmk_ok) {\n        if (call_options & cib_inhibit_bcast) {\n            /* skip */\n            crm_trace(\"Skipping update: inhibit broadcast\");\n            manage_counters = FALSE;\n        }\n\n        rc = cib_perform_op(op, call_options, cib_op_func(call_type), FALSE,\n                            section, request, input, manage_counters, &config_changed,\n                            current_cib, &result_cib, cib_diff, &output);\n\n#if ENABLE_ACL\n        if (acl_enabled(config_hash) == TRUE\n            && acl_check_diff(request, current_cib, result_cib, *cib_diff) == FALSE) {\n            rc = -EACCES;\n        }\n#endif\n\n        if (rc == pcmk_ok && config_changed) {\n            time_t now;\n            char *now_str = NULL;\n            const char *validation = crm_element_value(result_cib, XML_ATTR_VALIDATION);\n\n            if (validation) {\n                int current_version = get_schema_version(validation);\n                int support_version = get_schema_version(\"pacemaker-1.1\");\n\n                /* Once the later schemas support the \"update-*\" attributes, change \"==\" to \">=\" -- Changed */\n                if (current_version >= support_version) {\n                    const char *origin = crm_element_value(request, F_ORIG);\n\n                    crm_xml_replace(result_cib, XML_ATTR_UPDATE_ORIG,\n                                    origin ? origin : cib_our_uname);\n                    crm_xml_replace(result_cib, XML_ATTR_UPDATE_CLIENT,\n                                    crm_element_value(request, F_CIB_CLIENTNAME));\n#if ENABLE_ACL\n                    crm_xml_replace(result_cib, XML_ATTR_UPDATE_USER,\n                                    crm_element_value(request, F_CIB_USER));\n#endif\n                }\n            }\n\n            now = time(NULL);\n            now_str = ctime(&now);\n            now_str[24] = EOS;  /* replace the newline */\n            crm_xml_replace(result_cib, XML_CIB_ATTR_WRITTEN, now_str);\n        }\n\n        if (manage_counters == FALSE) {\n            config_changed = cib_config_changed(current_cib, result_cib, cib_diff);\n        }\n\n        /* Always write to disk for replace ops,\n         * this negates the need to detect ordering changes\n         */\n        if (config_changed == FALSE && crm_str_eq(CIB_OP_REPLACE, op, TRUE)) {\n            config_changed = TRUE;\n        }\n    }\n\n    cib_add_digest(result_cib, *cib_diff);\n\n    if (rc == pcmk_ok && (call_options & cib_dryrun) == 0) {\n        rc = activateCibXml(result_cib, config_changed, op);\n        if (rc == pcmk_ok && cib_internal_config_changed(*cib_diff)) {\n            cib_read_config(config_hash, result_cib);\n        }\n\n        if (crm_str_eq(CIB_OP_REPLACE, op, TRUE)) {\n            if (section == NULL) {\n                send_r_notify = TRUE;\n\n            } else if (safe_str_eq(section, XML_TAG_CIB)) {\n                send_r_notify = TRUE;\n\n            } else if (safe_str_eq(section, XML_CIB_TAG_NODES)) {\n                send_r_notify = TRUE;\n\n            } else if (safe_str_eq(section, XML_CIB_TAG_STATUS)) {\n                send_r_notify = TRUE;\n            }\n\n        } else if (crm_str_eq(CIB_OP_ERASE, op, TRUE)) {\n            send_r_notify = TRUE;\n        }\n\n    } else if (rc == -pcmk_err_dtd_validation) {\n        if (output != NULL) {\n            crm_log_xml_info(output, \"cib:output\");\n            free_xml(output);\n        }\n#if ENABLE_ACL\n        {\n            xmlNode *filtered_result_cib = NULL;\n\n            if (acl_enabled(config_hash) == FALSE\n                || acl_filter_cib(request, current_cib, result_cib,\n                                  &filtered_result_cib) == FALSE) {\n                output = result_cib;\n\n            } else {\n                crm_debug(\"Filtered the result cib for output according to the ACLs\");\n                output = filtered_result_cib;\n                if (result_cib != NULL) {\n                    free_xml(result_cib);\n                }\n            }\n        }\n#else\n        output = result_cib;\n#endif\n\n    } else {\n        free_xml(result_cib);\n    }\n\n    if ((call_options & cib_inhibit_notify) == 0) {\n        const char *call_id = crm_element_value(request, F_CIB_CALLID);\n        const char *client = crm_element_value(request, F_CIB_CLIENTNAME);\n\n#ifdef SUPPORT_POSTNOTIFY\n        cib_post_notify(call_options, op, input, rc, the_cib);\n#endif\n        cib_diff_notify(call_options, client, call_id, op, input, rc, *cib_diff);\n    }\n\n    if (send_r_notify) {\n        const char *origin = crm_element_value(request, F_ORIG);\n\n        cib_replace_notify(origin, the_cib, rc, *cib_diff);\n    }\n\n    if (rc != pcmk_ok) {\n        log_level = LOG_DEBUG_4;\n        if (rc == -pcmk_err_dtd_validation && global_update) {\n            log_level = LOG_WARNING;\n            crm_log_xml_info(input, \"cib:global_update\");\n        }\n\n    } else if (config_changed) {\n        log_level = LOG_DEBUG_3;\n        if (cib_is_master) {\n            log_level = LOG_NOTICE;\n        }\n\n    } else if (cib_is_master) {\n        log_level = LOG_DEBUG_2;\n    }\n\n    log_cib_diff(log_level, *cib_diff, \"cib:diff\");\n\n  done:\n    if ((call_options & cib_discard_reply) == 0) {\n        *reply = cib_construct_reply(request, output, rc);\n        crm_log_xml_trace(*reply, \"cib:reply\");\n    }\n#if ENABLE_ACL\n    if (filtered_current_cib != NULL) {\n        free_xml(filtered_current_cib);\n    }\n#endif\n\n    if (call_type >= 0) {\n        cib_op_cleanup(call_type, call_options, &input, &output);\n    }\n    return rc;\n}\n\ngint\ncib_GCompareFunc(gconstpointer a, gconstpointer b)\n{\n    const xmlNode *a_msg = a;\n    const xmlNode *b_msg = b;\n\n    int msg_a_id = 0;\n    int msg_b_id = 0;\n    const char *value = NULL;\n\n    value = crm_element_value_const(a_msg, F_CIB_CALLID);\n    msg_a_id = crm_parse_int(value, NULL);\n\n    value = crm_element_value_const(b_msg, F_CIB_CALLID);\n    msg_b_id = crm_parse_int(value, NULL);\n\n    if (msg_a_id == msg_b_id) {\n        return 0;\n    } else if (msg_a_id < msg_b_id) {\n        return -1;\n    }\n    return 1;\n}\n\n#if SUPPORT_HEARTBEAT\nvoid\ncib_ha_peer_callback(HA_Message * msg, void *private_data)\n{\n    xmlNode *xml = convert_ha_message(NULL, msg, __FUNCTION__);\n\n    cib_peer_callback(xml, private_data);\n    free_xml(xml);\n}\n#endif\n\nvoid\ncib_peer_callback(xmlNode * msg, void *private_data)\n{\n    const char *reason = NULL;\n    const char *originator = crm_element_value(msg, F_ORIG);\n\n    if (originator == NULL || crm_str_eq(originator, cib_our_uname, TRUE)) {\n        /* message is from ourselves */\n        int bcast_id = 0;\n        if (!(crm_element_value_int(msg, F_CIB_LOCAL_NOTIFY_ID, &bcast_id))) {\n            check_local_notify(bcast_id);\n        }\n        return;\n\n    } else if (crm_peer_cache == NULL) {\n        reason = \"membership not established\";\n        goto bail;\n    }\n\n    if (crm_element_value(msg, F_CIB_CLIENTNAME) == NULL) {\n        crm_xml_add(msg, F_CIB_CLIENTNAME, originator);\n    }\n\n    /* crm_log_xml_trace(\"Peer[inbound]\", msg); */\n    cib_process_request(msg, FALSE, TRUE, TRUE, NULL);\n    return;\n\n  bail:\n    if (reason) {\n        const char *seq = crm_element_value(msg, F_SEQ);\n        const char *op = crm_element_value(msg, F_CIB_OPERATION);\n\n        crm_warn(\"Discarding %s message (%s) from %s: %s\", op, seq, originator, reason);\n    }\n}\n\n\n#if SUPPORT_HEARTBEAT\nextern oc_ev_t *cib_ev_token;\nstatic void *ccm_library = NULL;\nint (*ccm_api_callback_done) (void *cookie) = NULL;\nint (*ccm_api_handle_event) (const oc_ev_t * token) = NULL;\n\nvoid\ncib_client_status_callback(const char *node, const char *client, const char *status, void *private)\n{\n    crm_node_t *peer = NULL;\n\n    if (safe_str_eq(client, CRM_SYSTEM_CIB)) {\n        crm_info(\"Status update: Client %s/%s now has status [%s]\", node, client, status);\n\n        if (safe_str_eq(status, JOINSTATUS)) {\n            status = ONLINESTATUS;\n\n        } else if (safe_str_eq(status, LEAVESTATUS)) {\n            status = OFFLINESTATUS;\n        }\n\n        peer = crm_get_peer(0, node);\n        crm_update_peer_proc(__FUNCTION__, peer, crm_proc_cib, status);\n    }\n    return;\n}\n\nint\ncib_ccm_dispatch(gpointer user_data)\n{\n    int rc = 0;\n    oc_ev_t *ccm_token = (oc_ev_t *) user_data;\n\n    crm_trace(\"received callback\");\n\n    if (ccm_api_handle_event == NULL) {\n        ccm_api_handle_event =\n            find_library_function(&ccm_library, CCM_LIBRARY, \"oc_ev_handle_event\", 1);\n    }\n\n    rc = (*ccm_api_handle_event) (ccm_token);\n    if (0 == rc) {\n        return 0;\n    }\n\n    crm_err(\"CCM connection appears to have failed: rc=%d.\", rc);\n\n    /* eventually it might be nice to recover and reconnect... but until then... */\n    crm_err(\"Exiting to recover from CCM connection failure\");\n    crm_exit(2);\n\n    return -1;\n}\n\nint current_instance = 0;\nvoid\ncib_ccm_msg_callback(oc_ed_t event, void *cookie, size_t size, const void *data)\n{\n    gboolean update_id = FALSE;\n    const oc_ev_membership_t *membership = data;\n\n    CRM_ASSERT(membership != NULL);\n\n    crm_info(\"Processing CCM event=%s (id=%d)\", ccm_event_name(event), membership->m_instance);\n\n    if (current_instance > membership->m_instance) {\n        crm_err(\"Membership instance ID went backwards! %d->%d\",\n                current_instance, membership->m_instance);\n        CRM_ASSERT(current_instance <= membership->m_instance);\n    }\n\n    switch (event) {\n        case OC_EV_MS_NEW_MEMBERSHIP:\n        case OC_EV_MS_INVALID:\n            update_id = TRUE;\n            break;\n        case OC_EV_MS_PRIMARY_RESTORED:\n            update_id = TRUE;\n            break;\n        case OC_EV_MS_NOT_PRIMARY:\n            crm_trace(\"Ignoring transitional CCM event: %s\", ccm_event_name(event));\n            break;\n        case OC_EV_MS_EVICTED:\n            crm_err(\"Evicted from CCM: %s\", ccm_event_name(event));\n            break;\n        default:\n            crm_err(\"Unknown CCM event: %d\", event);\n    }\n\n    if (update_id) {\n        unsigned int lpc = 0;\n\n        CRM_CHECK(membership != NULL, return);\n\n        current_instance = membership->m_instance;\n\n        for (lpc = 0; lpc < membership->m_n_out; lpc++) {\n            crm_update_ccm_node(membership, lpc + membership->m_out_idx, CRM_NODE_LOST,\n                                current_instance);\n        }\n\n        for (lpc = 0; lpc < membership->m_n_member; lpc++) {\n            crm_update_ccm_node(membership, lpc + membership->m_memb_idx, CRM_NODE_ACTIVE,\n                                current_instance);\n        }\n    }\n\n    if (ccm_api_callback_done == NULL) {\n        ccm_api_callback_done =\n            find_library_function(&ccm_library, CCM_LIBRARY, \"oc_ev_callback_done\", 1);\n    }\n    (*ccm_api_callback_done) (cookie);\n    return;\n}\n#endif\n\ngboolean\ncan_write(int flags)\n{\n    return TRUE;\n}\n\nstatic gboolean\ncib_force_exit(gpointer data)\n{\n    crm_notice(\"Forcing exit!\");\n    terminate_cib(__FUNCTION__, TRUE);\n    return FALSE;\n}\n\nstatic void\ndisconnect_remote_client(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *a_client = value;\n    crm_err(\"Disconnecting %s... Not implemented\", crm_str(a_client->name));\n}\n\nvoid\ncib_shutdown(int nsig)\n{\n    struct qb_ipcs_stats srv_stats;\n    if (cib_shutdown_flag == FALSE) {\n        int disconnects = 0;\n        qb_ipcs_connection_t *c = NULL;\n\n        cib_shutdown_flag = TRUE;\n\n        c = qb_ipcs_connection_first_get(ipcs_rw);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_rw, last);\n\n            crm_debug(\"Disconnecting r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_ro);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_ro, last);\n\n            crm_debug(\"Disconnecting r/o client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_shm);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_shm, last);\n\n            crm_debug(\"Disconnecting non-blocking r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        disconnects += g_hash_table_size(client_list);\n\n        crm_debug(\"Disconnecting %d remote clients\", g_hash_table_size(client_list));\n        g_hash_table_foreach(client_list, disconnect_remote_client, NULL);\n        crm_info(\"Disconnected %d clients\", disconnects);\n    }\n\n    qb_ipcs_stats_get(ipcs_rw, &srv_stats, QB_FALSE);\n    \n    if(g_hash_table_size(client_list) == 0) {\n        crm_info(\"All clients disconnected (%d)\", srv_stats.active_connections);\n        initiate_exit();\n        \n    } else {\n        crm_info(\"Waiting on %d clients to disconnect (%d)\", g_hash_table_size(client_list), srv_stats.active_connections);\n    }\n}\n\nvoid\ninitiate_exit(void)\n{\n    int active = 0;\n    xmlNode *leaving = NULL;\n\n    active = crm_active_peers();\n    if (active < 2) {\n        terminate_cib(__FUNCTION__, FALSE);\n        return;\n    }\n\n    crm_info(\"Sending disconnect notification to %d peers...\", active);\n\n    leaving = create_xml_node(NULL, \"exit-notification\");\n    crm_xml_add(leaving, F_TYPE, \"cib\");\n    crm_xml_add(leaving, F_CIB_OPERATION, \"cib_shutdown_req\");\n\n    send_cluster_message(NULL, crm_msg_cib, leaving, TRUE);\n    free_xml(leaving);\n\n    g_timeout_add(crm_get_msec(\"5s\"), cib_force_exit, NULL);\n}\n\nextern int remote_fd;\nextern int remote_tls_fd;\nextern void terminate_cs_connection(void);\n\nvoid\nterminate_cib(const char *caller, gboolean fast)\n{\n    if (remote_fd > 0) {\n        close(remote_fd);\n        remote_fd = 0;\n    }\n    if (remote_tls_fd > 0) {\n        close(remote_tls_fd);\n        remote_tls_fd = 0;\n    }\n    \n    if(!fast) {\n        crm_info(\"%s: Disconnecting from cluster infrastructure\", caller);\n        crm_cluster_disconnect(&crm_cluster);\n    }\n\n    uninitializeCib();\n\n    crm_info(\"%s: Exiting%s...\", caller, fast?\" fast\":mainloop?\" from mainloop\":\"\");\n\n    if(fast == FALSE && mainloop != NULL && g_main_is_running(mainloop)) {\n        g_main_quit(mainloop);\n\n    } else {\n        qb_ipcs_destroy(ipcs_ro);\n        qb_ipcs_destroy(ipcs_rw);\n        qb_ipcs_destroy(ipcs_shm);\n\n        if (fast) {\n            crm_exit(EX_USAGE);\n        } else {\n            crm_exit(EX_OK);\n        }\n    }\n}\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <crm/crm.h>\n#include <crm/cib.h>\n#include <crm/common/xml.h>\n#include <crm/cluster.h>\n#include <crm/common/mainloop.h>\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\n#endif\n\n\nextern gboolean cib_is_master;\nextern GHashTable *client_list;\nextern GHashTable *peer_hash;\nextern GHashTable *config_hash;\n\ntypedef struct cib_client_s {\n    char *id;\n    char *name;\n    char *callback_id;\n    char *user;\n    int request_id;\n\n    qb_ipcs_connection_t *ipc;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    gnutls_session *session;\n#else\n    void *session;\n#endif\n    gboolean encrypted;\n    mainloop_io_t *remote;\n        \n    unsigned long num_calls;\n\n    int pre_notify;\n    int post_notify;\n    int confirmations;\n    int replace;\n    int diffs;\n\n    GList *delegated_calls;\n} cib_client_t;\n\ntypedef struct cib_operation_s {\n    const char *operation;\n    gboolean modifies_cib;\n    gboolean needs_privileges;\n    gboolean needs_quorum;\n    int (*prepare) (xmlNode *, xmlNode **, const char **);\n    int (*cleanup) (int, xmlNode **, xmlNode **);\n    int (*fn) (const char *, int, const char *, xmlNode *,\n                           xmlNode *, xmlNode *, xmlNode **, xmlNode **);\n} cib_operation_t;\n\nextern struct qb_ipcs_service_handlers ipc_ro_callbacks;\nextern struct qb_ipcs_service_handlers ipc_rw_callbacks;\nextern qb_ipcs_service_t *ipcs_ro;\nextern qb_ipcs_service_t *ipcs_rw;\nextern qb_ipcs_service_t *ipcs_shm;\n\nextern void cib_peer_callback(xmlNode * msg, void *private_data);\nextern void cib_client_status_callback(const char *node, const char *client,\n                                       const char *status, void *private);\nextern void cib_common_callback_worker(uint32_t id, uint32_t flags, xmlNode * op_request, cib_client_t * cib_client, gboolean privileged);\n\nvoid cib_shutdown(int nsig);\nvoid initiate_exit(void);\nvoid terminate_cib(const char *caller, gboolean fast);\n\n#if SUPPORT_HEARTBEAT\nextern void cib_ha_peer_callback(HA_Message * msg, void *private_data);\nextern int cib_ccm_dispatch(gpointer user_data);\nextern void cib_ccm_msg_callback(oc_ed_t event, void *cookie, size_t size, const void *data);\n#endif\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <time.h>\n\n#include <crm/crm.h>\n#include <crm/cib/internal.h>\n#include <crm/msg_xml.h>\n\n#include <crm/common/xml.h>\n#include <cibio.h>\n#include <callbacks.h>\n#include <notify.h>\n\nint pending_updates = 0;\nextern GHashTable *client_list;\n\ngboolean cib_notify_client(gpointer key, gpointer value, gpointer user_data);\nvoid attach_cib_generation(xmlNode * msg, const char *field, xmlNode * a_cib);\n\nvoid do_cib_notify(int options, const char *op, xmlNode * update,\n                   int result, xmlNode * result_data, const char *msg_type);\n\nstatic void\nneed_pre_notify(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *client = value;\n\n    if (client->pre_notify) {\n        gboolean *needed = user_data;\n\n        *needed = TRUE;\n    }\n}\n\nstatic void\nneed_post_notify(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *client = value;\n\n    if (client->post_notify) {\n        gboolean *needed = user_data;\n\n        *needed = TRUE;\n    }\n}\n\ngboolean\ncib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n\n    type = crm_element_value(update_msg, F_SUBTYPE);\n\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}\n\nvoid\ncib_pre_notify(int options, const char *op, xmlNode * existing, xmlNode * update)\n{\n    xmlNode *update_msg = NULL;\n    const char *type = NULL;\n    const char *id = NULL;\n    gboolean needed = FALSE;\n\n    g_hash_table_foreach(client_list, need_pre_notify, &needed);\n    if (needed == FALSE) {\n        return;\n    }\n\n    /* TODO: consider pre-notification for removal */\n    update_msg = create_xml_node(NULL, \"pre-notify\");\n\n    if (update != NULL) {\n        id = crm_element_value(update, XML_ATTR_ID);\n    }\n\n    crm_xml_add(update_msg, F_TYPE, T_CIB_NOTIFY);\n    crm_xml_add(update_msg, F_SUBTYPE, T_CIB_PRE_NOTIFY);\n    crm_xml_add(update_msg, F_CIB_OPERATION, op);\n\n    if (id != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJID, id);\n    }\n\n    if (update != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(update));\n    } else if (existing != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(existing));\n    }\n\n    type = crm_element_value(update_msg, F_CIB_OBJTYPE);\n    attach_cib_generation(update_msg, \"cib_generation\", the_cib);\n\n    if (existing != NULL) {\n        add_message_xml(update_msg, F_CIB_EXISTING, existing);\n    }\n    if (update != NULL) {\n        add_message_xml(update_msg, F_CIB_UPDATE, update);\n    }\n\n    g_hash_table_foreach_remove(client_list, cib_notify_client, update_msg);\n\n    if (update == NULL) {\n        crm_trace(\"Performing operation %s (on section=%s)\", op, type);\n\n    } else {\n        crm_trace(\"Performing %s on <%s%s%s>\", op, type, id ? \" id=\" : \"\", id ? id : \"\");\n    }\n\n    free_xml(update_msg);\n}\n\nvoid\ncib_post_notify(int options, const char *op, xmlNode * update,\n                int result, xmlNode * new_obj)\n{\n    gboolean needed = FALSE;\n\n    g_hash_table_foreach(client_list, need_post_notify, &needed);\n    if (needed == FALSE) {\n        return;\n    }\n\n    do_cib_notify(options, op, update, result, new_obj, T_CIB_UPDATE_CONFIRM);\n}\n\nvoid\ncib_diff_notify(int options, const char *client, const char *call_id, const char *op,\n                xmlNode * update, int result, xmlNode * diff)\n{\n    int add_updates = 0;\n    int add_epoch = 0;\n    int add_admin_epoch = 0;\n\n    int del_updates = 0;\n    int del_epoch = 0;\n    int del_admin_epoch = 0;\n\n    int log_level = LOG_DEBUG_2;\n\n    if (diff == NULL) {\n        return;\n    }\n\n    if (result != pcmk_ok) {\n        log_level = LOG_WARNING;\n    }\n\n    cib_diff_version_details(diff, &add_admin_epoch, &add_epoch, &add_updates,\n                             &del_admin_epoch, &del_epoch, &del_updates);\n\n    if (add_updates != del_updates) {\n        do_crm_log(log_level,\n                   \"Update (client: %s%s%s): %d.%d.%d -> %d.%d.%d (%s)\",\n                   client, call_id ? \", call:\" : \"\", call_id ? call_id : \"\",\n                   del_admin_epoch, del_epoch, del_updates,\n                   add_admin_epoch, add_epoch, add_updates, pcmk_strerror(result));\n\n    } else if (diff != NULL) {\n        do_crm_log(log_level,\n                   \"Local-only Change (client:%s%s%s): %d.%d.%d (%s)\",\n                   client, call_id ? \", call: \" : \"\", call_id ? call_id : \"\",\n                   add_admin_epoch, add_epoch, add_updates, pcmk_strerror(result));\n    }\n\n    do_cib_notify(options, op, update, result, diff, T_CIB_DIFF_NOTIFY);\n}\n\nvoid\ndo_cib_notify(int options, const char *op, xmlNode * update,\n              int result, xmlNode * result_data, const char *msg_type)\n{\n    xmlNode *update_msg = NULL;\n    const char *id = NULL;\n\n    update_msg = create_xml_node(NULL, \"notify\");\n\n    if (result_data != NULL) {\n        id = crm_element_value(result_data, XML_ATTR_ID);\n    }\n\n    crm_xml_add(update_msg, F_TYPE, T_CIB_NOTIFY);\n    crm_xml_add(update_msg, F_SUBTYPE, msg_type);\n    crm_xml_add(update_msg, F_CIB_OPERATION, op);\n    crm_xml_add_int(update_msg, F_CIB_RC, result);\n\n    if (id != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJID, id);\n    }\n\n    if (update != NULL) {\n        crm_trace(\"Setting type to update->name: %s\", crm_element_name(update));\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(update));\n\n    } else if (result_data != NULL) {\n        crm_trace(\"Setting type to new_obj->name: %s\", crm_element_name(result_data));\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(result_data));\n\n    } else {\n        crm_trace(\"Not Setting type\");\n    }\n\n    attach_cib_generation(update_msg, \"cib_generation\", the_cib);\n    if (update != NULL) {\n        add_message_xml(update_msg, F_CIB_UPDATE, update);\n    }\n    if (result_data != NULL) {\n        add_message_xml(update_msg, F_CIB_UPDATE_RESULT, result_data);\n    }\n\n    crm_trace(\"Notifying clients\");\n    g_hash_table_foreach_remove(client_list, cib_notify_client, update_msg);\n    free_xml(update_msg);\n    crm_trace(\"Notify complete\");\n}\n\nvoid\nattach_cib_generation(xmlNode * msg, const char *field, xmlNode * a_cib)\n{\n    xmlNode *generation = create_xml_node(NULL, XML_CIB_TAG_GENERATION_TUPPLE);\n\n    if (a_cib != NULL) {\n        copy_in_properties(generation, a_cib);\n    }\n    add_message_xml(msg, field, generation);\n    free_xml(generation);\n}\n\nvoid\ncib_replace_notify(const char *origin, xmlNode * update, int result, xmlNode * diff)\n{\n    xmlNode *replace_msg = NULL;\n\n    int add_updates = 0;\n    int add_epoch = 0;\n    int add_admin_epoch = 0;\n\n    int del_updates = 0;\n    int del_epoch = 0;\n    int del_admin_epoch = 0;\n\n    if (diff == NULL) {\n        return;\n    }\n\n    cib_diff_version_details(diff, &add_admin_epoch, &add_epoch, &add_updates,\n                             &del_admin_epoch, &del_epoch, &del_updates);\n\n    if(del_updates < 0) {\n        crm_log_xml_debug(diff, \"Bad replace diff\");\n    }\n\n    if (add_updates != del_updates) {\n        crm_info(\"Replaced: %d.%d.%d -> %d.%d.%d from %s\",\n                 del_admin_epoch, del_epoch, del_updates,\n                 add_admin_epoch, add_epoch, add_updates, crm_str(origin));\n    } else if (diff != NULL) {\n        crm_info(\"Local-only Replace: %d.%d.%d from %s\",\n                 add_admin_epoch, add_epoch, add_updates, crm_str(origin));\n    }\n\n    replace_msg = create_xml_node(NULL, \"notify-replace\");\n    crm_xml_add(replace_msg, F_TYPE, T_CIB_NOTIFY);\n    crm_xml_add(replace_msg, F_SUBTYPE, T_CIB_REPLACE_NOTIFY);\n    crm_xml_add(replace_msg, F_CIB_OPERATION, CIB_OP_REPLACE);\n    crm_xml_add_int(replace_msg, F_CIB_RC, result);\n    attach_cib_generation(replace_msg, \"cib-replace-generation\", update);\n\n    crm_log_xml_trace(replace_msg, \"CIB Replaced\");\n\n    g_hash_table_foreach_remove(client_list, cib_notify_client, replace_msg);\n    free_xml(replace_msg);\n}\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n#include <crm/crm.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\n#include <netinet/ip.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <glib.h>\n\n#include <crm/msg_xml.h>\n#include <crm/common/ipc.h>\n#include <crm/common/xml.h>\n#include <crm/cib/internal.h>\n\n#include \"callbacks.h\"\n/* #undef HAVE_PAM_PAM_APPL_H */\n/* #undef HAVE_GNUTLS_GNUTLS_H */\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\n#endif\n\n#include <pwd.h>\n#include <grp.h>\n#if HAVE_SECURITY_PAM_APPL_H\n#  include <security/pam_appl.h>\n#  define HAVE_PAM 1\n#else\n#  if HAVE_PAM_PAM_APPL_H\n#    include <pam/pam_appl.h>\n#    define HAVE_PAM 1\n#  endif\n#endif\n\n#ifdef HAVE_DECL_NANOSLEEP\n#  include <time.h>\n#endif\n\nextern int remote_tls_fd;\nextern gboolean cib_shutdown_flag;\n\nint init_remote_listener(int port, gboolean encrypted);\nvoid cib_remote_connection_destroy(gpointer user_data);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  define DH_BITS 1024\ngnutls_dh_params dh_params;\nextern gnutls_anon_server_credentials anon_cred_s;\nstatic void\ndebug_log(int level, const char *str)\n{\n    fputs(str, stderr);\n}\n\nextern gnutls_session *create_tls_session(int csock, int type);\n\n#endif\n\nint num_clients;\nint authenticate_user(const char *user, const char *passwd);\nint cib_remote_listen(gpointer data);\nint cib_remote_msg(gpointer data);\n\nstatic void\nremote_connection_destroy(gpointer user_data)\n{\n    return;\n}\n\n#define ERROR_SUFFIX \"  Shutting down remote listener\"\nint\ninit_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n\n    if (port <= 0) {\n        /* dont start it */\n        return 0;\n    }\n\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n/* \tgnutls_global_set_log_level (10); */\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n\n    /* create server socket */\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n\n    /* reuse address */\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n\n    /* bind server socket */\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n\n    return *ssock;\n}\n\nstatic int\ncheck_group_membership(const char *usr, const char *grp)\n{\n    int index = 0;\n    struct passwd *pwd = NULL;\n    struct group *group = NULL;\n\n    CRM_CHECK(usr != NULL, return FALSE);\n    CRM_CHECK(grp != NULL, return FALSE);\n\n    pwd = getpwnam(usr);\n    if (pwd == NULL) {\n        crm_err(\"No user named '%s' exists!\", usr);\n        return FALSE;\n    }\n\n    group = getgrgid(pwd->pw_gid);\n    if (group != NULL && crm_str_eq(grp, group->gr_name, TRUE)) {\n        return TRUE;\n    }\n\n    group = getgrnam(grp);\n    if (group == NULL) {\n        crm_err(\"No group named '%s' exists!\", grp);\n        return FALSE;\n    }\n\n    while (TRUE) {\n        char *member = group->gr_mem[index++];\n\n        if (member == NULL) {\n            break;\n\n        } else if (crm_str_eq(usr, member, TRUE)) {\n            return TRUE;\n        }\n    };\n\n    return FALSE;\n}\n\nint\ncib_remote_listen(gpointer data)\n{\n    int lpc = 0;\n    int csock = 0;\n    unsigned laddr;\n    time_t now = 0;\n    time_t start = time(NULL);\n    struct sockaddr_in addr;\n    int ssock = *(int *)data;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    gnutls_session *session = NULL;\n#endif\n    cib_client_t *new_client = NULL;\n\n    xmlNode *login = NULL;\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n\n#ifdef HAVE_DECL_NANOSLEEP\n    const struct timespec sleepfast = { 0, 10000000 };  /* 10 millisec */\n#endif\n\n    static struct mainloop_fd_callbacks remote_client_fd_callbacks = \n        {\n            .dispatch = cib_remote_msg,\n            .destroy = cib_remote_connection_destroy,\n        };    \n    \n    /* accept the connection */\n    laddr = sizeof(addr);\n    csock = accept(ssock, (struct sockaddr *)&addr, &laddr);\n    crm_debug(\"New %s connection from %s\",\n              ssock == remote_tls_fd ? \"secure\" : \"clear-text\", inet_ntoa(addr.sin_addr));\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        /* create gnutls session for the server socket */\n        session = create_tls_session(csock, GNUTLS_SERVER);\n        if (session == NULL) {\n            crm_err(\"TLS session creation failed\");\n            close(csock);\n            return TRUE;\n        }\n#endif\n    }\n\n    do {\n        crm_trace(\"Iter: %d\", lpc++);\n        if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n            login = crm_recv_remote_msg(session, TRUE);\n#endif\n        } else {\n            login = crm_recv_remote_msg(GINT_TO_POINTER(csock), FALSE);\n        }\n        if (login != NULL) {\n            break;\n        }\n#ifdef HAVE_DECL_NANOSLEEP\n        nanosleep(&sleepfast, NULL);\n#else\n        sleep(1);\n#endif\n        now = time(NULL);\n\n        /* Peers have 3s to connect */\n    } while (login == NULL && (start - now) < 4);\n\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        goto bail;\n    }\n\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        goto bail;\n    }\n\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        goto bail;\n    }\n\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n\n    /* Non-root daemons can only validate the password of the\n     * user they're running as\n     */\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        goto bail;\n\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        goto bail;\n    }\n\n    /* send ACK */\n    num_clients++;\n    new_client = calloc(1, sizeof(cib_client_t));\n    new_client->name = crm_element_value_copy(login, \"name\");\n\n    CRM_CHECK(new_client->id == NULL, free(new_client->id));\n    new_client->id = crm_generate_uuid();\n\n#if ENABLE_ACL\n    new_client->user = strdup(user);\n#endif\n\n    new_client->callback_id = NULL;\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        new_client->encrypted = TRUE;\n        new_client->session = session;\n#endif\n    } else {\n        new_client->session = GINT_TO_POINTER(csock);\n    }\n\n    free_xml(login);\n    login = create_xml_node(NULL, \"cib_result\");\n    crm_xml_add(login, F_CIB_OPERATION, CRM_OP_REGISTER);\n    crm_xml_add(login, F_CIB_CLIENTID, new_client->id);\n    crm_send_remote_msg(new_client->session, login, new_client->encrypted);\n    free_xml(login);\n\n    new_client->remote = mainloop_add_fd(\n        \"cib-remote-client\", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);\n\n    g_hash_table_insert(client_list, new_client->id, new_client);\n\n    return TRUE;\n\n  bail:\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_bye(*session, GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*session);\n        gnutls_free(session);\n#endif\n    }\n    close(csock);\n    free_xml(login);\n    return TRUE;\n}\n\nvoid\ncib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n\n    if (client == NULL) {\n        return;\n    }\n\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}\n\nint\ncib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n\n    /* unset dangerous options */\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n\n        /* fix the command */\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}\n\n#ifdef HAVE_PAM\n/* \n * Useful Examples:\n *    http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html\n *    http://developer.apple.com/samplecode/CryptNoMore/index.html\n */\nstatic int\nconstruct_pam_passwd(int num_msg, const struct pam_message **msg,\n                     struct pam_response **response, void *data)\n{\n    int count = 0;\n    struct pam_response *reply;\n    char *string = (char *)data;\n\n    CRM_CHECK(data, return PAM_CONV_ERR);\n    CRM_CHECK(num_msg == 1, return PAM_CONV_ERR);       /* We only want to handle one message */\n\n    reply = calloc(1, sizeof(struct pam_response));\n    CRM_ASSERT(reply != NULL);\n\n    for (count = 0; count < num_msg; ++count) {\n        switch (msg[count]->msg_style) {\n            case PAM_TEXT_INFO:\n                crm_info(\"PAM: %s\\n\", msg[count]->msg);\n                break;\n            case PAM_PROMPT_ECHO_OFF:\n            case PAM_PROMPT_ECHO_ON:\n                reply[count].resp_retcode = 0;\n                reply[count].resp = string;     /* We already made a copy */\n            case PAM_ERROR_MSG:\n                /* In theory we'd want to print this, but then\n                 * we see the password prompt in the logs\n                 */\n                /* crm_err(\"PAM error: %s\\n\", msg[count]->msg); */\n                break;\n            default:\n                crm_err(\"Unhandled conversation type: %d\", msg[count]->msg_style);\n                goto bail;\n        }\n    }\n\n    *response = reply;\n    reply = NULL;\n\n    return PAM_SUCCESS;\n\n  bail:\n    for (count = 0; count < num_msg; ++count) {\n        if (reply[count].resp != NULL) {\n            switch (msg[count]->msg_style) {\n                case PAM_PROMPT_ECHO_ON:\n                case PAM_PROMPT_ECHO_OFF:\n                    /* Erase the data - it contained a password */\n                    while (*(reply[count].resp)) {\n                        *(reply[count].resp)++ = '\\0';\n                    }\n                    free(reply[count].resp);\n                    break;\n            }\n            reply[count].resp = NULL;\n        }\n    }\n    free(reply);\n    reply = NULL;\n\n    return PAM_CONV_ERR;\n}\n#endif\n\nint\nauthenticate_user(const char *user, const char *passwd)\n{\n#ifndef HAVE_PAM\n    gboolean pass = TRUE;\n#else\n    int rc = 0;\n    gboolean pass = FALSE;\n    const void *p_user = NULL;\n\n    struct pam_conv p_conv;\n    struct pam_handle *pam_h = NULL;\n    static const char *pam_name = NULL;\n\n    if (pam_name == NULL) {\n        pam_name = getenv(\"CIB_pam_service\");\n    }\n    if (pam_name == NULL) {\n        pam_name = \"login\";\n    }\n\n    p_conv.conv = construct_pam_passwd;\n    p_conv.appdata_ptr = strdup(passwd);\n\n    rc = pam_start(pam_name, user, &p_conv, &pam_h);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Could not initialize PAM: %s (%d)\", pam_strerror(pam_h, rc), rc);\n        goto bail;\n    }\n\n    rc = pam_authenticate(pam_h, 0);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Authentication failed for %s: %s (%d)\", user, pam_strerror(pam_h, rc), rc);\n        goto bail;\n    }\n\n    /* Make sure we authenticated the user we wanted to authenticate.\n     * Since we also run as non-root, it might be worth pre-checking\n     * the user has the same EID as us, since that the only user we\n     * can authenticate.\n     */\n    rc = pam_get_item(pam_h, PAM_USER, &p_user);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Internal PAM error: %s (%d)\", pam_strerror(pam_h, rc), rc);\n        goto bail;\n\n    } else if (p_user == NULL) {\n        crm_err(\"Unknown user authenticated.\");\n        goto bail;\n\n    } else if (safe_str_neq(p_user, user)) {\n        crm_err(\"User mismatch: %s vs. %s.\", (const char *)p_user, (const char *)user);\n        goto bail;\n    }\n\n    rc = pam_acct_mgmt(pam_h, 0);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Access denied: %s (%d)\", pam_strerror(pam_h, rc), rc);\n        goto bail;\n    }\n    pass = TRUE;\n\n  bail:\n    rc = pam_end(pam_h, rc);\n#endif\n    return pass;\n}\n", "/* crm_internal.h */\n\n/* \n * Copyright (C) 2006 - 2008\n *     Andrew Beekhof <andrew@beekhof.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef CRM_INTERNAL__H\n#  define CRM_INTERNAL__H\n\n#  include <config.h>\n#  include <portability.h>\n\n#  include <glib.h>\n#  include <stdbool.h>\n#  include <libxml/tree.h>\n\n#  include <crm/lrmd.h>\n#  include <crm/common/logging.h>\n\n/* Dynamic loading of libraries */\nvoid *find_library_function(void **handle, const char *lib, const char *fn, int fatal);\nvoid *convert_const_pointer(const void *ptr);\n\n/* For ACLs */\nchar *uid2username(uid_t uid);\nvoid determine_request_user(char *user, xmlNode * request, const char *field);\n\n#  if ENABLE_ACL\n#    include <string.h>\nstatic inline gboolean\nis_privileged(const char *user)\n{\n    if (user == NULL) {\n        return FALSE;\n    } else if (strcmp(user, CRM_DAEMON_USER) == 0) {\n        return TRUE;\n    } else if (strcmp(user, \"root\") == 0) {\n        return TRUE;\n    }\n    return FALSE;\n}\n#  endif\n\n/* CLI option processing*/\n#  ifdef HAVE_GETOPT_H\n#    include <getopt.h>\n#  else\n#    define no_argument 0\n#    define required_argument 1\n#  endif\n\n#  define pcmk_option_default\t0x00000\n#  define pcmk_option_hidden\t0x00001\n#  define pcmk_option_paragraph\t0x00002\n#  define pcmk_option_example\t0x00004\n\nstruct crm_option {\n    /* Fields from 'struct option' in getopt.h */\n    /* name of long option */\n    const char *name;\n    /*\n     * one of no_argument, required_argument, and optional_argument:\n     * whether option takes an argument\n     */\n    int has_arg;\n    /* if not NULL, set *flag to val when option found */\n    int *flag;\n    /* if flag not NULL, value to set *flag to; else return value */\n    int val;\n\n    /* Custom fields */\n    const char *desc;\n    long flags;\n};\n\nvoid crm_set_options(const char *short_options, const char *usage, struct crm_option *long_options, const char *app_desc);\nint crm_get_option(int argc, char **argv, int *index);\nint crm_get_option_long(int argc, char **argv, int *index, const char **longname);\nvoid crm_help(char cmd, int exit_code);\n\n/* Cluster Option Processing */\ntypedef struct pe_cluster_option_s {\n    const char *name;\n    const char *alt_name;\n    const char *type;\n    const char *values;\n    const char *default_value;\n\n     gboolean(*is_valid) (const char *);\n\n    const char *description_short;\n    const char *description_long;\n\n} pe_cluster_option;\n\nconst char *cluster_option(GHashTable * options, gboolean(*validate) (const char *),\n                           const char *name, const char *old_name, const char *def_value);\n\nconst char *get_cluster_pref(GHashTable * options, pe_cluster_option * option_list, int len, const char *name);\n\nvoid config_metadata(const char *name, const char *version, const char *desc_short,\n                     const char *desc_long, pe_cluster_option * option_list, int len);\n\nvoid verify_all_options(GHashTable * options, pe_cluster_option * option_list, int len);\ngboolean check_time(const char *value);\ngboolean check_timer(const char *value);\ngboolean check_boolean(const char *value);\ngboolean check_number(const char *value);\n\n/* Shared PE/crmd functionality */\nvoid filter_action_parameters(xmlNode * param_set, const char *version);\nvoid filter_reload_parameters(xmlNode * param_set, const char *restart_string);\n\n/* Resource operation updates */\nxmlNode *create_operation_update(xmlNode * parent, lrmd_event_data_t *event, const char *caller_version,\n                                 int target_rc, const char *origin, int level);\n\n/* char2score */\nextern int node_score_red;\nextern int node_score_green;\nextern int node_score_yellow;\nextern int node_score_infinity;\n\n\n/* Assorted convenience functions */\nstatic inline int\ncrm_strlen_zero(const char *s)\n{\n    return !s || *s == '\\0';\n}\n\nchar *add_list_element(char *list, const char *value);\nchar *generate_series_filename(const char *directory, const char *series, int sequence, gboolean bzip);\nint get_last_sequence(const char *directory, const char *series);\nvoid write_last_sequence(const char *directory, const char *series, int sequence, int max);\n\nint crm_pid_active(long pid);\nvoid crm_make_daemon(const char *name, gboolean daemonize, const char *pidfile);\ngboolean crm_is_writable(const char *dir, const char *file, const char *user, const char *group, gboolean need_both);\n\nchar *generate_op_key(const char *rsc_id, const char *op_type, int interval);\nchar *generate_notify_key(const char *rsc_id, const char *notify_type, const char *op_type);\nchar *generate_transition_magic_v202(const char *transition_key, int op_status);\nchar *generate_transition_magic(const char *transition_key, int op_status, int op_rc);\nchar *generate_transition_key(int action, int transition_id, int target_rc, const char *node);\n\nstatic inline long long\ncrm_clear_bit(const char *function, const char *target, long long word, long long bit)\n{\n    long long rc = (word & ~bit);\n\n    if(rc == word) {\n        /* Unchanged */\n    } else if (target) {\n        crm_trace(\"Bit 0x%.8llx for %s cleared by %s\", bit, target, function);\n    } else {\n        crm_trace(\"Bit 0x%.8llx cleared by %s\", bit, function);\n    }\n\n    return rc;\n}\n\nstatic inline long long\ncrm_set_bit(const char *function, const char *target, long long word, long long bit)\n{\n    long long rc = (word|bit);\n\n    if(rc == word) {\n        /* Unchanged */\n    } else if (target) {\n        crm_trace(\"Bit 0x%.8llx for %s set by %s\", bit, target, function);\n    } else {\n        crm_trace(\"Bit 0x%.8llx set by %s\", bit, function);\n    }\n\n    return rc;\n}\n\n#  define set_bit(word, bit) word = crm_set_bit(__PRETTY_FUNCTION__, NULL, word, bit)\n#  define clear_bit(word, bit) word = crm_clear_bit(__PRETTY_FUNCTION__, NULL, word, bit)\n\nvoid g_hash_destroy_str(gpointer data);\n\nlong long crm_int_helper(const char *text, char **end_text);\nchar *crm_concat(const char *prefix, const char *suffix, char join);\nchar *generate_hash_key(const char *crm_msg_reference, const char *sys);\nxmlNode *crm_recv_remote_msg(void *session, gboolean encrypted);\nvoid crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted);\n\nconst char *daemon_option(const char *option);\nvoid set_daemon_option(const char *option, const char *value);\ngboolean daemon_option_enabled(const char *daemon, const char *option);\nvoid strip_text_nodes(xmlNode *xml);\n\n#  define crm_config_err(fmt...) { crm_config_error = TRUE; crm_err(fmt); }\n#  define crm_config_warn(fmt...) { crm_config_warning = TRUE; crm_warn(fmt); }\n\n#  define attrd_channel\t\tT_ATTRD\n#  define F_ATTRD_KEY\t\t\"attr_key\"\n#  define F_ATTRD_ATTRIBUTE\t\"attr_name\"\n#  define F_ATTRD_TASK\t\t\"task\"\n#  define F_ATTRD_VALUE\t\t\"attr_value\"\n#  define F_ATTRD_SET\t\t\"attr_set\"\n#  define F_ATTRD_SECTION\t\"attr_section\"\n#  define F_ATTRD_DAMPEN\t\"attr_dampening\"\n#  define F_ATTRD_IGNORE_LOCALLY \"attr_ignore_locally\"\n#  define F_ATTRD_HOST\t\t\"attr_host\"\n#  define F_ATTRD_USER\t\t\"attr_user\"\n\n#  if SUPPORT_COROSYNC\n#    if CS_USES_LIBQB\n#      include <qb/qbipc_common.h>\n#      include <corosync/corotypes.h>\ntypedef struct qb_ipc_request_header cs_ipc_header_request_t;\ntypedef struct qb_ipc_response_header cs_ipc_header_response_t;\n#    else\n#      include <corosync/corodefs.h>\n#      include <corosync/coroipcc.h>\n#      include <corosync/coroipc_types.h>\nstatic inline int\nqb_to_cs_error(int a)\n{\n    return a;\n}\n\ntypedef coroipc_request_header_t cs_ipc_header_request_t;\ntypedef coroipc_response_header_t cs_ipc_header_response_t;\n#    endif\n#  else\ntypedef struct {\n    int size __attribute__ ((aligned(8)));\n    int id __attribute__ ((aligned(8)));\n} __attribute__ ((aligned(8))) cs_ipc_header_request_t;\n\ntypedef struct {\n    int size __attribute__ ((aligned(8)));\n    int id __attribute__ ((aligned(8)));\n    int error __attribute__ ((aligned(8)));\n} __attribute__ ((aligned(8))) cs_ipc_header_response_t;\n\n#  endif\n\n#endif                          /* CRM_INTERNAL__H */\n", "/*\n * Copyright (c) 2008 Andrew Beekhof\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n#include <crm_internal.h>\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <netdb.h>\n#include <termios.h>\n#include <sys/socket.h>\n\n#include <glib.h>\n\n#include <crm/crm.h>\n#include <crm/cib/internal.h>\n#include <crm/msg_xml.h>\n#include <crm/common/ipc.h>\n#include <crm/common/mainloop.h>\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\nextern gnutls_anon_client_credentials anon_cred_c;\nextern gnutls_session *create_tls_session(int csock, int type);\n\nconst int kx_prio[] = {\n    GNUTLS_KX_ANON_DH,\n    0\n};\n\n#else\ntypedef void gnutls_session;\n#endif\n\n#include <arpa/inet.h>\n#include <sgtty.h>\n\n#define DH_BITS 1024\n\nstruct remote_connection_s {\n    int socket;\n    gboolean encrypted;\n    gnutls_session *session;\n    mainloop_io_t *source;\n    char *token;\n};\n\ntypedef struct cib_remote_opaque_s {\n    int flags;\n    int socket;\n    int port;\n    char *server;\n    char *user;\n    char *passwd;\n    struct remote_connection_s command;\n    struct remote_connection_s callback;\n\n} cib_remote_opaque_t;\n\nvoid cib_remote_connection_destroy(gpointer user_data);\nint cib_remote_dispatch(gpointer user_data);\nint cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type);\nint cib_remote_signoff(cib_t * cib);\nint cib_remote_free(cib_t * cib);\n\nint cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                          xmlNode * data, xmlNode ** output_data, int call_options, const char *name);\n\nstatic int\ncib_remote_inputfd(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    return private->callback.socket;\n}\n\nstatic int\ncib_remote_set_connection_dnotify(cib_t * cib, void (*dnotify) (gpointer user_data))\n{\n    return -EPROTONOSUPPORT;\n}\n\nstatic int\ncib_remote_register_notification(cib_t * cib, const char *callback, int enabled)\n{\n    xmlNode *notify_msg = create_xml_node(NULL, \"cib_command\");\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    crm_xml_add(notify_msg, F_CIB_OPERATION, T_CIB_NOTIFY);\n    crm_xml_add(notify_msg, F_CIB_NOTIFY_TYPE, callback);\n    crm_xml_add_int(notify_msg, F_CIB_NOTIFY_ACTIVATE, enabled);\n    crm_send_remote_msg(private->callback.session, notify_msg, private->callback.encrypted);\n    free_xml(notify_msg);\n    return pcmk_ok;\n}\n\ncib_t *\ncib_remote_new(const char *server, const char *user, const char *passwd, int port,\n               gboolean encrypted)\n{\n    cib_remote_opaque_t *private = NULL;\n    cib_t *cib = cib_new_variant();\n\n    private = calloc(1, sizeof(cib_remote_opaque_t));\n\n    cib->variant = cib_remote;\n    cib->variant_opaque = private;\n\n    if (server) {\n        private->server = strdup(server);\n    }\n\n    if (user) {\n        private->user = strdup(user);\n    }\n\n    if (passwd) {\n        private->passwd = strdup(passwd);\n    }\n\n    private->port = port;\n    private->command.encrypted = encrypted;\n    private->callback.encrypted = encrypted;\n\n    /* assign variant specific ops */\n    cib->delegate_fn = cib_remote_perform_op;\n    cib->cmds->signon = cib_remote_signon;\n    cib->cmds->signoff = cib_remote_signoff;\n    cib->cmds->free = cib_remote_free;\n    cib->cmds->inputfd = cib_remote_inputfd;\n\n    cib->cmds->register_notification = cib_remote_register_notification;\n    cib->cmds->set_connection_dnotify = cib_remote_set_connection_dnotify;\n\n    return cib;\n}\n\nstatic int\ncib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    shutdown(private->command.socket, SHUT_RDWR);       /* no more receptions */\n    shutdown(private->callback.socket, SHUT_RDWR);      /* no more receptions */\n    close(private->command.socket);\n    close(private->callback.socket);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}\n\nstatic int\ncib_tls_signon(cib_t * cib, struct remote_connection_s *connection)\n{\n    int sock;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    struct sockaddr_in addr;\n    int rc = 0;\n    char *server = private->server;\n\n    int ret_ga;\n    struct addrinfo *res;\n    struct addrinfo hints;\n\n    xmlNode *answer = NULL;\n    xmlNode *login = NULL;\n\n    static struct mainloop_fd_callbacks cib_fd_callbacks = \n        {\n            .dispatch = cib_remote_dispatch,\n            .destroy = cib_remote_connection_destroy,\n        };\n\n    connection->socket = 0;\n    connection->session = NULL;\n\n    /* create socket */\n    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (sock == -1) {\n        crm_perror(LOG_ERR, \"Socket creation failed\");\n        return -1;\n    }\n\n    /* getaddrinfo */\n    bzero(&hints, sizeof(struct addrinfo));\n    hints.ai_flags = AI_CANONNAME;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_RAW;\n\n    if (hints.ai_family == AF_INET6) {\n        hints.ai_protocol = IPPROTO_ICMPV6;\n    } else {\n        hints.ai_protocol = IPPROTO_ICMP;\n    }\n\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        close(sock);\n        return -1;\n    }\n\n    if (res->ai_canonname) {\n        server = res->ai_canonname;\n    }\n\n    crm_debug(\"Got address %s for %s\", server, private->server);\n\n    if (!res->ai_addr) {\n        fprintf(stderr, \"getaddrinfo failed\");\n        crm_exit(1);\n    }\n#if 1\n    memcpy(&addr, res->ai_addr, res->ai_addrlen);\n#else\n    /* connect to server */\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = inet_addr(server);\n#endif\n    addr.sin_port = htons(private->port);\n\n    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        crm_perror(LOG_ERR, \"Connection to %s:%d failed\", server, private->port);\n        close(sock);\n        return -1;\n    }\n\n    if (connection->encrypted) {\n        /* initialize GnuTls lib */\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_global_init();\n        gnutls_anon_allocate_client_credentials(&anon_cred_c);\n\n        /* bind the socket to GnuTls lib */\n        connection->session = create_tls_session(sock, GNUTLS_CLIENT);\n        if (connection->session == NULL) {\n            crm_perror(LOG_ERR, \"Session creation for %s:%d failed\", server, private->port);\n            close(sock);\n            cib_tls_close(cib);\n            return -1;\n        }\n#else\n        return -EPROTONOSUPPORT;\n#endif\n    } else {\n        connection->session = GUINT_TO_POINTER(sock);\n    }\n\n    /* login to server */\n    login = create_xml_node(NULL, \"cib_command\");\n    crm_xml_add(login, \"op\", \"authenticate\");\n    crm_xml_add(login, \"user\", private->user);\n    crm_xml_add(login, \"password\", private->passwd);\n    crm_xml_add(login, \"hidden\", \"password\");\n\n    crm_send_remote_msg(connection->session, login, connection->encrypted);\n    free_xml(login);\n\n    answer = crm_recv_remote_msg(connection->session, connection->encrypted);\n    crm_log_xml_trace(answer, \"Reply\");\n    if (answer == NULL) {\n        rc = -EPROTO;\n\n    } else {\n        /* grab the token */\n        const char *msg_type = crm_element_value(answer, F_CIB_OPERATION);\n        const char *tmp_ticket = crm_element_value(answer, F_CIB_CLIENTID);\n\n        if (safe_str_neq(msg_type, CRM_OP_REGISTER)) {\n            crm_err(\"Invalid registration message: %s\", msg_type);\n            rc = -EPROTO;\n\n        } else if (tmp_ticket == NULL) {\n            rc = -EPROTO;\n\n        } else {\n            connection->token = strdup(tmp_ticket);\n        }\n    }\n\n    if (rc != 0) {\n        cib_tls_close(cib);\n    }\n\n    connection->socket = sock;\n    connection->source = mainloop_add_fd(\"cib-remote\", G_PRIORITY_HIGH, connection->socket, cib, &cib_fd_callbacks);\n    return rc;\n}\n\nvoid\ncib_remote_connection_destroy(gpointer user_data)\n{\n    crm_err(\"Connection destroyed\");\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    cib_tls_close(user_data);\n#endif\n    return;\n}\n\nint\ncib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}\n\nint\ncib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        /* fprintf(stderr, \"entered: '%s'\\n\", buffer); */\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n\n    return rc;\n}\n\nint\ncib_remote_signoff(cib_t * cib)\n{\n    int rc = pcmk_ok;\n\n    /* cib_remote_opaque_t *private = cib->variant_opaque; */\n\n    crm_debug(\"Signing out of the CIB Service\");\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    cib_tls_close(cib);\n#endif\n\n    cib->state = cib_disconnected;\n    cib->type = cib_none;\n\n    return rc;\n}\n\nint\ncib_remote_free(cib_t * cib)\n{\n    int rc = pcmk_ok;\n\n    crm_warn(\"Freeing CIB\");\n    if (cib->state != cib_disconnected) {\n        rc = cib_remote_signoff(cib);\n        if (rc == pcmk_ok) {\n            cib_remote_opaque_t *private = cib->variant_opaque;\n\n            free(private->server);\n            free(private->user);\n            free(private->passwd);\n            free(cib->cmds);\n            free(private);\n            free(cib);\n        }\n    }\n\n    return rc;\n}\n\nstatic gboolean timer_expired = FALSE;\nstatic struct timer_rec_s *sync_timer = NULL;\nstatic gboolean\ncib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n\n    /* Always return TRUE, never remove the handler\n     * We do that after the while-loop in cib_native_perform_op()\n     */\n    return TRUE;\n}\n\nint\ncib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                      xmlNode * data, xmlNode ** output_data, int call_options, const char *name)\n{\n    int rc = pcmk_ok;\n\n    xmlNode *op_msg = NULL;\n    xmlNode *op_reply = NULL;\n\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (sync_timer == NULL) {\n        sync_timer = calloc(1, sizeof(struct timer_rec_s));\n    }\n\n    if (cib->state == cib_disconnected) {\n        return -ENOTCONN;\n    }\n\n    if (output_data != NULL) {\n        *output_data = NULL;\n    }\n\n    if (op == NULL) {\n        crm_err(\"No operation specified\");\n        return -EINVAL;\n    }\n\n    cib->call_id++;\n    /* prevent call_id from being negative (or zero) and conflicting\n     *    with the cib_errors enum\n     * use 2 because we use it as (cib->call_id - 1) below\n     */\n    if (cib->call_id < 1) {\n        cib->call_id = 1;\n    }\n\n    op_msg =\n        cib_create_op(cib->call_id, private->callback.token, op, host, section, data, call_options,\n                      NULL);\n    if (op_msg == NULL) {\n        return -EPROTO;\n    }\n\n    crm_trace(\"Sending %s message to CIB service\", op);\n    crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);\n    free_xml(op_msg);\n\n    if ((call_options & cib_discard_reply)) {\n        crm_trace(\"Discarding reply\");\n        return pcmk_ok;\n\n    } else if (!(call_options & cib_sync_call)) {\n        return cib->call_id;\n    }\n\n    crm_trace(\"Waiting for a syncronous reply\");\n\n    if (cib->call_timeout > 0) {\n        /* We need this, even with msgfromIPC_timeout(), because we might\n         * get other/older replies that don't match the active request\n         */\n        timer_expired = FALSE;\n        sync_timer->call_id = cib->call_id;\n        sync_timer->timeout = cib->call_timeout * 1000;\n        sync_timer->ref = g_timeout_add(sync_timer->timeout, cib_timeout_handler, sync_timer);\n    }\n\n    while (timer_expired == FALSE) {\n        int reply_id = -1;\n        int msg_id = cib->call_id;\n\n        op_reply = crm_recv_remote_msg(private->command.session, private->command.encrypted);\n        if (op_reply == NULL) {\n            break;\n        }\n\n        crm_element_value_int(op_reply, F_CIB_CALLID, &reply_id);\n        CRM_CHECK(reply_id > 0, free_xml(op_reply);\n                  if (sync_timer->ref > 0) {\n                  g_source_remove(sync_timer->ref); sync_timer->ref = 0;}\n                  return -ENOMSG) ;\n\n        if (reply_id == msg_id) {\n            break;\n\n        } else if (reply_id < msg_id) {\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n\n        } else if ((reply_id - 10000) > msg_id) {\n            /* wrap-around case */\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n        } else {\n            crm_err(\"Received a __future__ reply:\" \" %d (wanted %d)\", reply_id, msg_id);\n        }\n\n        free_xml(op_reply);\n        op_reply = NULL;\n    }\n\n    if (sync_timer->ref > 0) {\n        g_source_remove(sync_timer->ref);\n        sync_timer->ref = 0;\n    }\n\n    if (timer_expired) {\n        return -ETIME;\n    }\n\n    /* if(IPC_ISRCONN(native->command_channel) == FALSE) { */\n    /*      crm_err(\"CIB disconnected: %d\",  */\n    /*              native->command_channel->ch_status); */\n    /*      cib->state = cib_disconnected; */\n    /* } */\n\n    if (op_reply == NULL) {\n        crm_err(\"No reply message - empty\");\n        return -ENOMSG;\n    }\n\n    crm_trace(\"Syncronous reply received\");\n\n    /* Start processing the reply... */\n    if (crm_element_value_int(op_reply, F_CIB_RC, &rc) != 0) {\n        rc = -EPROTO;\n    }\n\n    if (rc == -pcmk_err_diff_resync) {\n        /* This is an internal value that clients do not and should not care about */\n        rc = pcmk_ok;\n    }\n\n    if (rc == pcmk_ok || rc == -EPERM) {\n        crm_log_xml_debug(op_reply, \"passed\");\n\n    } else {\n/* \t} else if(rc == -ETIME) { */\n        crm_err(\"Call failed: %s\", pcmk_strerror(rc));\n        crm_log_xml_warn(op_reply, \"failed\");\n    }\n\n    if (output_data == NULL) {\n        /* do nothing more */\n\n    } else if (!(call_options & cib_discard_reply)) {\n        xmlNode *tmp = get_message_xml(op_reply, F_CIB_CALLDATA);\n\n        if (tmp == NULL) {\n            crm_trace(\"No output in reply to \\\"%s\\\" command %d\", op, cib->call_id - 1);\n        } else {\n            *output_data = copy_xml(tmp);\n        }\n    }\n\n    free_xml(op_reply);\n\n    return rc;\n}\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE\n#endif\n\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n\n#include <sys/wait.h>\n\n#include <crm/crm.h>\n#include <crm/common/xml.h>\n#include <crm/common/mainloop.h>\n#include <crm/common/ipc.h>\n\nstruct mainloop_child_s {\n    pid_t     pid;\n    char     *desc;\n    unsigned  timerid;\n    unsigned  watchid;\n    gboolean  timeout;\n    void     *privatedata;\n\n    /* Called when a process dies */\n    void (*callback)(mainloop_child_t* p, int status, int signo, int exitcode);\n};\n\nstruct trigger_s {\n    GSource source;\n    gboolean running;\n    gboolean trigger;\n    void *user_data;\n    guint id;\n\n};\n\nstatic gboolean\ncrm_trigger_prepare(GSource * source, gint * timeout)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    /* cluster-glue's FD and IPC related sources make use of\n     * g_source_add_poll() but do not set a timeout in their prepare\n     * functions\n     *\n     * This means mainloop's poll() will block until an event for one\n     * of these sources occurs - any /other/ type of source, such as\n     * this one or g_idle_*, that doesn't use g_source_add_poll() is\n     * S-O-L and wont be processed until there is something fd-based\n     * happens.\n     *\n     * Luckily the timeout we can set here affects all sources and\n     * puts an upper limit on how long poll() can take.\n     *\n     * So unconditionally set a small-ish timeout, not too small that\n     * we're in constant motion, which will act as an upper bound on\n     * how long the signal handling might be delayed for.\n     */\n    *timeout = 500;             /* Timeout in ms */\n\n    return trig->trigger;\n}\n\nstatic gboolean\ncrm_trigger_check(GSource * source)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    return trig->trigger;\n}\n\nstatic gboolean\ncrm_trigger_dispatch(GSource * source, GSourceFunc callback, gpointer userdata)\n{\n    int rc = TRUE;\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    if(trig->running) {\n        /* Wait until the existing job is complete before starting the next one */\n        return TRUE;\n    }\n    trig->trigger = FALSE;\n\n    if (callback) {\n        rc = callback(trig->user_data);\n        if(rc < 0) {\n            crm_trace(\"Trigger handler %p not yet complete\", trig);\n            trig->running = TRUE;\n            rc = TRUE;\n        }\n    }\n    return rc;\n}\n\nstatic GSourceFuncs crm_trigger_funcs = {\n    crm_trigger_prepare,\n    crm_trigger_check,\n    crm_trigger_dispatch,\n    NULL\n};\n\nstatic crm_trigger_t *\nmainloop_setup_trigger(GSource * source, int priority, int(*dispatch) (gpointer user_data),\n                       gpointer userdata)\n{\n    crm_trigger_t *trigger = NULL;\n\n    trigger = (crm_trigger_t *) source;\n\n    trigger->id = 0;\n    trigger->trigger = FALSE;\n    trigger->user_data = userdata;\n\n    if (dispatch) {\n        g_source_set_callback(source, dispatch, trigger, NULL);\n    }\n\n    g_source_set_priority(source, priority);\n    g_source_set_can_recurse(source, FALSE);\n\n    trigger->id = g_source_attach(source, NULL);\n    return trigger;\n}\n\nvoid\nmainloop_trigger_complete(crm_trigger_t *trig) \n{\n    crm_trace(\"Trigger handler %p complete\", trig);\n    trig->running = FALSE;\n}\n\n/* If dispatch returns:\n *  -1: Job running but not complete\n *   0: Remove the trigger from mainloop\n *   1: Leave the trigger in mainloop\n */\ncrm_trigger_t *\nmainloop_add_trigger(int priority, int(*dispatch) (gpointer user_data), gpointer userdata)\n{\n    GSource *source = NULL;\n\n    CRM_ASSERT(sizeof(crm_trigger_t) > sizeof(GSource));\n    source = g_source_new(&crm_trigger_funcs, sizeof(crm_trigger_t));\n    CRM_ASSERT(source != NULL);\n\n    return mainloop_setup_trigger(source, priority, dispatch, userdata);\n}\n\nvoid\nmainloop_set_trigger(crm_trigger_t * source)\n{\n    source->trigger = TRUE;\n}\n\ngboolean\nmainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n    }\n    return TRUE;\n}\n\ntypedef struct signal_s {\n    crm_trigger_t trigger;      /* must be first */\n    void (*handler) (int sig);\n    int signal;\n\n} crm_signal_t;\n\nstatic crm_signal_t *crm_signals[NSIG];\n\nstatic gboolean\ncrm_signal_dispatch(GSource * source, GSourceFunc callback, gpointer userdata)\n{\n    crm_signal_t *sig = (crm_signal_t *) source;\n\n    crm_info(\"Invoking handler for signal %d: %s\", sig->signal, strsignal(sig->signal));\n\n    sig->trigger.trigger = FALSE;\n    if (sig->handler) {\n        sig->handler(sig->signal);\n    }\n    return TRUE;\n}\n\nstatic void\nmainloop_signal_handler(int sig)\n{\n    if (sig > 0 && sig < NSIG && crm_signals[sig] != NULL) {\n        mainloop_set_trigger((crm_trigger_t *) crm_signals[sig]);\n    }\n}\n\nstatic GSourceFuncs crm_signal_funcs = {\n    crm_trigger_prepare,\n    crm_trigger_check,\n    crm_signal_dispatch,\n    NULL\n};\n\ngboolean\ncrm_signal(int sig, void (*dispatch) (int sig))\n{\n    sigset_t mask;\n    struct sigaction sa;\n    struct sigaction old;\n\n    if (sigemptyset(&mask) < 0) {\n        crm_perror(LOG_ERR, \"Call to sigemptyset failed\");\n        return FALSE;\n    }\n\n    memset(&sa, 0, sizeof(struct sigaction));\n    sa.sa_handler = dispatch;\n    sa.sa_flags = SA_RESTART;\n    sa.sa_mask = mask;\n\n    if (sigaction(sig, &sa, &old) < 0) {\n        crm_perror(LOG_ERR, \"Could not install signal handler for signal %d\", sig);\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\ngboolean\nmainloop_add_signal(int sig, void (*dispatch) (int sig))\n{\n    GSource *source = NULL;\n    int priority = G_PRIORITY_HIGH - 1;\n\n    if (sig == SIGTERM) {\n        /* TERM is higher priority than other signals,\n         *   signals are higher priority than other ipc.\n         * Yes, minus: smaller is \"higher\"\n         */\n        priority--;\n    }\n\n    if (sig >= NSIG || sig < 0) {\n        crm_err(\"Signal %d is out of range\", sig);\n        return FALSE;\n\n    } else if (crm_signals[sig] != NULL\n               && crm_signals[sig]->handler == dispatch) {\n        crm_trace(\"Signal handler for %d is already installed\", sig);\n        return TRUE;\n\n    } else if (crm_signals[sig] != NULL) {\n        crm_err(\"Different signal handler for %d is already installed\", sig);\n        return FALSE;\n    }\n\n    CRM_ASSERT(sizeof(crm_signal_t) > sizeof(GSource));\n    source = g_source_new(&crm_signal_funcs, sizeof(crm_signal_t));\n\n    crm_signals[sig] = (crm_signal_t *) mainloop_setup_trigger(source, priority, NULL, NULL);\n    CRM_ASSERT(crm_signals[sig] != NULL);\n\n    crm_signals[sig]->handler = dispatch;\n    crm_signals[sig]->signal = sig;\n\n    if (crm_signal(sig, mainloop_signal_handler) == FALSE) {\n        crm_signal_t *tmp = crm_signals[sig];\n\n        crm_signals[sig] = NULL;\n\n        mainloop_destroy_trigger((crm_trigger_t *) tmp);\n        return FALSE;\n    }\n#if 0\n    /* If we want signals to interrupt mainloop's poll(), instead of waiting for\n     * the timeout, then we should call siginterrupt() below\n     *\n     * For now, just enforce a low timeout\n     */\n    if (siginterrupt(sig, 1) < 0) {\n        crm_perror(LOG_INFO, \"Could not enable system call interruptions for signal %d\", sig);\n    }\n#endif\n\n    return TRUE;\n}\n\ngboolean\nmainloop_destroy_signal(int sig)\n{\n    crm_signal_t *tmp = NULL;\n\n    if (sig >= NSIG || sig < 0) {\n        crm_err(\"Signal %d is out of range\", sig);\n        return FALSE;\n\n    } else if (crm_signal(sig, NULL) == FALSE) {\n        crm_perror(LOG_ERR, \"Could not uninstall signal handler for signal %d\", sig);\n        return FALSE;\n\n    } else if (crm_signals[sig] == NULL) {\n        return TRUE;\n    }\n\n    tmp = crm_signals[sig];\n    crm_signals[sig] = NULL;\n    mainloop_destroy_trigger((crm_trigger_t *) tmp);\n    return TRUE;\n}\n\nstatic qb_array_t *gio_map = NULL;\n\n/*\n * libqb...\n */\nstruct gio_to_qb_poll {\n        int32_t is_used;\n        GIOChannel *channel;\n        guint source;\n        int32_t events;\n        void * data;\n        qb_ipcs_dispatch_fn_t fn;\n        enum qb_loop_priority p;\n};\n\nstatic int\ngio_adapter_refcount(struct gio_to_qb_poll *adaptor)\n{\n    /* This is evil\n     * Looking at the giochannel header file, ref_count is the first member of channel\n     * So cheat...\n     */\n    if(adaptor && adaptor->channel) {\n        int *ref = (void*)adaptor->channel;\n        return *ref;\n    }\n    return 0;\n}\n\nstatic gboolean\ngio_read_socket (GIOChannel *gio, GIOCondition condition, gpointer data)\n{\n    struct gio_to_qb_poll *adaptor = (struct gio_to_qb_poll *)data;\n    gint fd = g_io_channel_unix_get_fd(gio);\n\n    crm_trace(\"%p.%d %d (ref=%d)\", data, fd, condition, gio_adapter_refcount(adaptor));\n\n    if(condition & G_IO_NVAL) {\n        crm_trace(\"Marking failed adaptor %p unused\", adaptor);\n        adaptor->is_used = QB_FALSE;\n    }\n\n    return (adaptor->fn(fd, condition, adaptor->data) == 0);\n}\n\nstatic void\ngio_poll_destroy(gpointer data) \n{\n    /* adaptor->source is valid but about to be destroyed (ref_count == 0) in gmain.c\n     * adaptor->channel will still have ref_count > 0... should be == 1\n     */\n    struct gio_to_qb_poll *adaptor = (struct gio_to_qb_poll *)data;\n\n    crm_trace(\"Destroying adaptor %p channel %p (ref=%d)\", adaptor, adaptor->channel, gio_adapter_refcount(adaptor));\n    adaptor->is_used = QB_FALSE;\n    adaptor->channel = NULL;\n    adaptor->source = 0;\n}\n\n\nstatic int32_t\ngio_poll_dispatch_add(enum qb_loop_priority p, int32_t fd, int32_t evts,\n                  void *data, qb_ipcs_dispatch_fn_t fn)\n{\n    struct gio_to_qb_poll *adaptor;\n    GIOChannel *channel;\n    int32_t res = 0;\n\n    res = qb_array_index(gio_map, fd, (void**)&adaptor);\n    if (res < 0) {\n        crm_err(\"Array lookup failed for fd=%d: %d\", fd, res);\n        return res;\n    }\n\n    crm_trace(\"Adding fd=%d to mainloop as adapater %p\", fd, adaptor);\n    if (adaptor->is_used) {\n        crm_err(\"Adapter for descriptor %d is still in-use\", fd);\n        return -EEXIST;\n    }\n\n    /* channel is created with ref_count = 1 */\n    channel = g_io_channel_unix_new(fd);\n    if (!channel) {\n        crm_err(\"No memory left to add fd=%d\", fd);\n        return -ENOMEM;\n    }\n\n    /* Because unlike the poll() API, glib doesn't tell us about HUPs by default */\n    evts |= (G_IO_HUP|G_IO_NVAL|G_IO_ERR);\n\n    adaptor->channel = channel;\n    adaptor->fn = fn;\n    adaptor->events = evts;\n    adaptor->data = data;\n    adaptor->p = p;\n    adaptor->is_used = QB_TRUE;\n    adaptor->source = g_io_add_watch_full(channel, G_PRIORITY_DEFAULT, evts, gio_read_socket, adaptor, gio_poll_destroy);\n\n    /* Now that mainloop now holds a reference to adaptor->channel,\n     * thanks to g_io_add_watch_full(), drop ours from g_io_channel_unix_new().\n     *\n     * This means that adaptor->channel will be free'd by:\n     * g_main_context_dispatch()\n     *  -> g_source_destroy_internal()\n     *      -> g_source_callback_unref()\n     * shortly after gio_poll_destroy() completes\n     */\n    g_io_channel_unref(adaptor->channel);    \n\n    crm_trace(\"Added to mainloop with gsource id=%d, ref=%d\", adaptor->source, gio_adapter_refcount(adaptor));\n    if(adaptor->source > 0) {\n        return 0;\n    }\n    \n    return -EINVAL;\n}\n\nstatic int32_t\ngio_poll_dispatch_mod(enum qb_loop_priority p, int32_t fd, int32_t evts,\n                  void *data, qb_ipcs_dispatch_fn_t fn)\n{\n    return 0;\n}\n\nstatic int32_t\ngio_poll_dispatch_del(int32_t fd)\n{\n    struct gio_to_qb_poll *adaptor;\n    crm_trace(\"Looking for fd=%d\", fd);\n    if (qb_array_index(gio_map, fd, (void**)&adaptor) == 0) {\n        crm_trace(\"Marking adaptor %p unused (ref=%d)\", adaptor, gio_adapter_refcount(adaptor));\n        adaptor->is_used = QB_FALSE;\n    }\n    return 0;\n}\n\nstruct qb_ipcs_poll_handlers gio_poll_funcs = {\n    .job_add = NULL,\n    .dispatch_add = gio_poll_dispatch_add,\n    .dispatch_mod = gio_poll_dispatch_mod,\n    .dispatch_del = gio_poll_dispatch_del,\n};\n\nstatic enum qb_ipc_type\npick_ipc_type(enum qb_ipc_type requested)\n{\n    const char *env = getenv(\"PCMK_ipc_type\");\n\n    if(env && strcmp(\"shared-mem\", env) == 0) {\n        return QB_IPC_SHM;\n    } else if(env && strcmp(\"socket\", env) == 0) {\n        return QB_IPC_SOCKET;\n    } else if(env && strcmp(\"posix\", env) == 0) {\n        return QB_IPC_POSIX_MQ;\n    } else if(env && strcmp(\"sysv\", env) == 0) {\n        return QB_IPC_SYSV_MQ;\n    } else if(requested == QB_IPC_NATIVE) {\n        /* We prefer sockets actually */\n        return QB_IPC_SOCKET;\n    }\n    return requested;\n}\n\nqb_ipcs_service_t *mainloop_add_ipc_server(\n    const char *name, enum qb_ipc_type type, struct qb_ipcs_service_handlers *callbacks) \n{\n    int rc = 0;\n    qb_ipcs_service_t* server = NULL;\n\n    if(gio_map == NULL) {\n        gio_map = qb_array_create_2(64, sizeof(struct gio_to_qb_poll), 1);\n    }\n\n    server = qb_ipcs_create(name, 0, pick_ipc_type(type), callbacks);\n    qb_ipcs_poll_handlers_set(server, &gio_poll_funcs);\n\n    rc = qb_ipcs_run(server);\n    if (rc < 0) {\n        crm_err(\"Could not start %s IPC server: %s (%d)\", name, pcmk_strerror(rc), rc);\n        return NULL;\n    }\n\n    return server;\n}\n\nvoid mainloop_del_ipc_server(qb_ipcs_service_t *server) \n{\n    if(server) {\n        qb_ipcs_destroy(server);\n    }\n}\n\nstruct mainloop_io_s\n{\n        char *name;\n        void *userdata;\n\n        guint source;\n        crm_ipc_t *ipc;\n        GIOChannel *channel;\n\n        int (*dispatch_fn_ipc)(const char *buffer, ssize_t length, gpointer userdata);\n        int (*dispatch_fn_io) (gpointer userdata);\n        void (*destroy_fn) (gpointer userdata);\n\n};\n\nstatic int\nmainloop_gio_refcount(mainloop_io_t *client) \n{\n    /* This is evil\n     * Looking at the giochannel header file, ref_count is the first member of channel\n     * So cheat...\n     */\n    if(client && client->channel) {\n        int *ref = (void*)client->channel;\n        return *ref;\n    }\n    return 0;\n}\n\nstatic gboolean\nmainloop_gio_callback(GIOChannel *gio, GIOCondition condition, gpointer data)\n{\n    gboolean keep = TRUE;\n    mainloop_io_t *client = data;\n\n    if(condition & G_IO_IN) {\n        if(client->ipc) {\n            long rc = 0;\n            int max = 10;\n            do {\n                rc = crm_ipc_read(client->ipc);\n                if(rc <= 0) {\n                    crm_trace(\"Message acquisition from %s[%p] failed: %s (%ld)\",\n                              client->name, client, pcmk_strerror(rc), rc);\n\n                } else if(client->dispatch_fn_ipc) {\n                    const char *buffer = crm_ipc_buffer(client->ipc);\n                    crm_trace(\"New message from %s[%p] = %d\", client->name, client, rc, condition);\n                    if(client->dispatch_fn_ipc(buffer, rc, client->userdata) < 0) {\n                        crm_trace(\"Connection to %s no longer required\", client->name);\n                        keep = FALSE;\n                    }\n                }\n\n            } while(keep && rc > 0 && --max > 0);\n\n        } else {\n            crm_trace(\"New message from %s[%p]\", client->name, client);\n            if(client->dispatch_fn_io) {\n                if(client->dispatch_fn_io(client->userdata) < 0) {\n                    crm_trace(\"Connection to %s no longer required\", client->name);\n                    keep = FALSE;\n                }\n            }\n        }\n    }\n\n    if(client->ipc && crm_ipc_connected(client->ipc) == FALSE) {\n        crm_err(\"Connection to %s[%p] closed (I/O condition=%d)\", client->name, client, condition);\n        keep = FALSE;\n\n    } else if(condition & (G_IO_HUP|G_IO_NVAL|G_IO_ERR)) {\n        crm_trace(\"The connection %s[%p] has been closed (I/O condition=%d, refcount=%d)\",\n                  client->name, client, condition, mainloop_gio_refcount(client));\n        keep = FALSE;\n\n    } else if((condition & G_IO_IN) == 0) {\n        /*\n          #define \tGLIB_SYSDEF_POLLIN     =1\n          #define \tGLIB_SYSDEF_POLLPRI    =2\n          #define \tGLIB_SYSDEF_POLLOUT    =4\n          #define \tGLIB_SYSDEF_POLLERR    =8\n          #define \tGLIB_SYSDEF_POLLHUP    =16\n          #define \tGLIB_SYSDEF_POLLNVAL   =32\n\n          typedef enum\n          {\n            G_IO_IN\tGLIB_SYSDEF_POLLIN,\n            G_IO_OUT\tGLIB_SYSDEF_POLLOUT,\n            G_IO_PRI\tGLIB_SYSDEF_POLLPRI,\n            G_IO_ERR\tGLIB_SYSDEF_POLLERR,\n            G_IO_HUP\tGLIB_SYSDEF_POLLHUP,\n            G_IO_NVAL\tGLIB_SYSDEF_POLLNVAL\n          } GIOCondition;\n\n          A bitwise combination representing a condition to watch for on an event source.\n\n          G_IO_IN\tThere is data to read.\n          G_IO_OUT\tData can be written (without blocking).\n          G_IO_PRI\tThere is urgent data to read.\n          G_IO_ERR\tError condition.\n          G_IO_HUP\tHung up (the connection has been broken, usually for pipes and sockets).\n          G_IO_NVAL\tInvalid request. The file descriptor is not open.    \n        */\n        crm_err(\"Strange condition: %d\", condition);\n    }\n\n    /* keep == FALSE results in mainloop_gio_destroy() being called\n     * just before the source is removed from mainloop\n     */\n    return keep;\n}\n\nstatic void\nmainloop_gio_destroy(gpointer c)\n{\n    mainloop_io_t *client = c;\n\n    /* client->source is valid but about to be destroyed (ref_count == 0) in gmain.c\n     * client->channel will still have ref_count > 0... should be == 1\n     */\n    crm_trace(\"Destroying client %s[%p] %d\", client->name, c, mainloop_gio_refcount(client));\n\n    if(client->ipc) {\n        crm_ipc_close(client->ipc);\n    }\n\n    if(client->destroy_fn) {\n        client->destroy_fn(client->userdata);\n    }\n    \n    if(client->ipc) {\n        crm_ipc_destroy(client->ipc);\n    }\n\n    crm_trace(\"Destroyed client %s[%p] %d\", client->name, c, mainloop_gio_refcount(client));\n    free(client->name);\n\n    memset(client, 0, sizeof(mainloop_io_t)); /* A bit of pointless paranoia */\n    free(client);\n}\n\nmainloop_io_t *\nmainloop_add_ipc_client(\n    const char *name, int priority, size_t max_size, void *userdata, struct ipc_client_callbacks *callbacks) \n{\n    mainloop_io_t *client = NULL;\n    crm_ipc_t *conn = crm_ipc_new(name, max_size);\n\n    if(conn && crm_ipc_connect(conn)) {\n        int32_t fd = crm_ipc_get_fd(conn);\n        client = mainloop_add_fd(name, priority, fd, userdata, NULL);\n        client->ipc = conn;\n        client->destroy_fn = callbacks->destroy;\n        client->dispatch_fn_ipc = callbacks->dispatch;\n    }\n\n    if(conn && client == NULL) {\n        crm_trace(\"Connection to %s failed\", name);\n        crm_ipc_close(conn);\n        crm_ipc_destroy(conn);\n    }\n    \n    return client;\n}\n\nvoid\nmainloop_del_ipc_client(mainloop_io_t *client)\n{\n    mainloop_del_fd(client);\n}\n\ncrm_ipc_t *\nmainloop_get_ipc_client(mainloop_io_t *client)\n{\n    if(client) {\n        return client->ipc;\n    }\n    return NULL;\n}\n\nmainloop_io_t *\nmainloop_add_fd(\n    const char *name, int priority, int fd, void *userdata, struct mainloop_fd_callbacks *callbacks) \n{\n    mainloop_io_t *client = NULL;\n    if(fd > 0) {\n        client = calloc(1, sizeof(mainloop_io_t));          \n        client->name = strdup(name);\n        client->userdata = userdata;\n\n        if(callbacks) {\n            client->destroy_fn = callbacks->destroy;\n            client->dispatch_fn_io = callbacks->dispatch;\n        }\n\n        client->channel = g_io_channel_unix_new(fd);\n        client->source = g_io_add_watch_full(\n            client->channel, priority, (G_IO_IN|G_IO_HUP|G_IO_NVAL|G_IO_ERR),\n            mainloop_gio_callback, client, mainloop_gio_destroy);\n\n        /* Now that mainloop now holds a reference to adaptor->channel,\n         * thanks to g_io_add_watch_full(), drop ours from g_io_channel_unix_new().\n         *\n         * This means that adaptor->channel will be free'd by:\n         * g_main_context_dispatch() or g_source_remove()\n         *  -> g_source_destroy_internal()\n         *      -> g_source_callback_unref()\n         * shortly after mainloop_gio_destroy() completes\n         */\n        g_io_channel_unref(client->channel);\n        crm_trace(\"Added connection %d for %s[%p].%d %d\", client->source, client->name, client, fd, mainloop_gio_refcount(client));\n    }\n\n    return client;\n}\n\nvoid\nmainloop_del_fd(mainloop_io_t *client)\n{\n    if(client != NULL) {\n        crm_trace(\"Removing client %s[%p] %d\", client->name, client, mainloop_gio_refcount(client));\n        if (client->source) {\n            /* Results in mainloop_gio_destroy() being called just\n             * before the source is removed from mainloop\n             */\n            g_source_remove(client->source);\n        }\n    }\n}\n\npid_t\nmainloop_get_child_pid(mainloop_child_t *child)\n{\n    return child->pid;\n}\n\nint\nmainloop_get_child_timeout(mainloop_child_t *child)\n{\n    return child->timeout;\n}\n\nvoid *\nmainloop_get_child_userdata(mainloop_child_t *child)\n{\n    return child->privatedata;\n}\n\nvoid\nmainloop_clear_child_userdata(mainloop_child_t *child)\n{\n    child->privatedata = NULL;\n}\n\nstatic gboolean\nchild_timeout_callback(gpointer p)\n{\n    mainloop_child_t *child = p;\n\n    child->timerid = 0;\n    if (child->timeout) {\n        crm_crit(\"%s process (PID %d) will not die!\", child->desc, (int)child->pid);\n        return FALSE;\n    }\n\n    child->timeout = TRUE;\n    crm_warn(\"%s process (PID %d) timed out\", child->desc, (int)child->pid);\n\n    if (kill(child->pid, SIGKILL) < 0) {\n        if (errno == ESRCH) {\n            /* Nothing left to do */\n            return FALSE;\n        }\n        crm_perror(LOG_ERR, \"kill(%d, KILL) failed\", child->pid);\n    }\n\n    child->timerid = g_timeout_add(5000, child_timeout_callback, child);\n    return FALSE;\n}\n\nstatic void\nmainloop_child_destroy(mainloop_child_t *child)\n{\n    if (child->timerid != 0) {\n        crm_trace(\"Removing timer %d\", child->timerid);\n        g_source_remove(child->timerid);\n        child->timerid = 0;\n    }\n\n    free(child->desc);\n    g_free(child);\n}\n\nstatic void\nchild_death_dispatch(GPid pid, gint status, gpointer user_data)\n{\n    int signo = 0;\n    int exitcode = 0;\n    mainloop_child_t *child = user_data;\n\n    crm_trace(\"Managed process %d exited: %p\", pid, child);\n\n    if (WIFEXITED(status)) {\n        exitcode = WEXITSTATUS(status);\n        crm_trace(\"Managed process %d (%s) exited with rc=%d\", pid,\n                 child->desc, exitcode);\n\n    } else if (WIFSIGNALED(status)) {\n        signo = WTERMSIG(status);\n        crm_trace(\"Managed process %d (%s) exited with signal=%d\", pid,\n                 child->desc, signo);\n    }\n#ifdef WCOREDUMP\n    if (WCOREDUMP(status)) {\n        crm_err(\"Managed process %d (%s) dumped core\", pid, child->desc);\n    }\n#endif\n\n    if (child->callback) {\n       child->callback(child, status, signo, exitcode);\n    }\n    crm_trace(\"Removed process entry for %d\", pid);\n\n    mainloop_child_destroy(child);\n    return;\n}\n\n/* Create/Log a new tracked process\n * To track a process group, use -pid\n */\nvoid\nmainloop_add_child(pid_t pid, int timeout, const char *desc, void * privatedata,\n    void (*callback)(mainloop_child_t *p, int status, int signo, int exitcode))\n{\n    mainloop_child_t *child = g_new(mainloop_child_t, 1);\n\n    child->pid = pid;\n    child->timerid = 0;\n    child->timeout = FALSE;\n    child->desc = strdup(desc);\n    child->privatedata = privatedata;\n    child->callback = callback;\n\n    if (timeout) {\n        child->timerid = g_timeout_add(\n            timeout, child_timeout_callback, child);\n    }\n\n    child->watchid = g_child_watch_add(pid, child_death_dispatch, child);\n}\n", "/*\n * Copyright (c) 2008 Andrew Beekhof\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n#include <crm_internal.h>\n#include <crm/crm.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/socket.h>\n\n#include <netinet/ip.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <glib.h>\n\n#include <crm/common/ipc.h>\n#include <crm/common/xml.h>\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\n#endif\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\nconst int tls_kx_order[] = {\n    GNUTLS_KX_ANON_DH,\n    GNUTLS_KX_DHE_RSA,\n    GNUTLS_KX_DHE_DSS,\n    GNUTLS_KX_RSA,\n    0\n};\n\ngnutls_anon_client_credentials anon_cred_c;\ngnutls_anon_server_credentials anon_cred_s;\nstatic char *cib_send_tls(gnutls_session * session, xmlNode * msg);\nstatic char *cib_recv_tls(gnutls_session * session);\n#endif\n\nchar *cib_recv_plaintext(int sock);\nchar *cib_send_plaintext(int sock, xmlNode * msg);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\ngnutls_session *create_tls_session(int csock, int type);\n\ngnutls_session *\ncreate_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */ )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n/*      http://www.manpagez.com/info/gnutls/gnutls-2.10.4/gnutls_81.php#Echo-Server-with-anonymous-authentication */\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n/*\tgnutls_priority_set_direct (*session, \"NONE:+VERS-TLS-ALL:+CIPHER-ALL:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-DH\", NULL); */\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}\n\nstatic char *\ncib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n\n#  if 0\n    const char *name = crm_element_name(msg);\n\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n\n        len++;                  /* null char */\n        crm_trace(\"Message size: %d\", len);\n\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n\n    }\n    free(xml_text);\n    return NULL;\n\n}\n\nstatic char *\ncib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n\n    if (session == NULL) {\n        return NULL;\n    }\n\n    buf = calloc(1, chunk_size);\n\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n\n}\n#endif\n\nchar *\ncib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n\n        len++;                  /* null char */\n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n\n}\n\nchar *\ncib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n\n    buf = calloc(1, chunk_size);\n\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n\n}\n\nvoid\ncrm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}\n\nxmlNode *\ncrm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n\n    free(reply);\n    return xml;\n}\n", "\n/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#include <sys/param.h>\n\n#include <crm/crm.h>\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <sys/utsname.h>\n\n#include <crm/msg_xml.h>\n#include <crm/services.h>\n#include <crm/lrmd.h>\n#include <crm/common/util.h>\n#include <crm/common/xml.h>\n#include <crm/common/ipc.h>\n#include <crm/common/mainloop.h>\n\n#include <crm/cib/internal.h>\n#include <crm/pengine/status.h>\n#include <../lib/pengine/unpack.h>\n#include <../pengine/pengine.h>\n#include <crm/stonith-ng.h>\n\n/* GMainLoop *mainloop = NULL; */\n\nvoid wait_for_refresh(int offset, const char *prefix, int msec);\nvoid clean_up(int rc);\nvoid crm_diff_update(const char *event, xmlNode * msg);\ngboolean mon_refresh_display(gpointer user_data);\nint cib_connect(gboolean full);\nvoid mon_st_callback(stonith_t *st, stonith_event_t *e);\n\nchar *xml_file = NULL;\nchar *as_html_file = NULL;\nint as_xml = 0;\nchar *pid_file = NULL;\nchar *snmp_target = NULL;\nchar *snmp_community = NULL;\n\ngboolean as_console = TRUE;;\ngboolean simple_status = FALSE;\ngboolean group_by_node = FALSE;\ngboolean inactive_resources = FALSE;\ngboolean web_cgi = FALSE;\nint reconnect_msec = 5000;\ngboolean daemonize = FALSE;\nGMainLoop *mainloop = NULL;\nguint timer_id = 0;\nGList *attr_list = NULL;\n\nconst char *crm_mail_host = NULL;\nconst char *crm_mail_prefix = NULL;\nconst char *crm_mail_from = NULL;\nconst char *crm_mail_to = NULL;\nconst char *external_agent = NULL;\nconst char *external_recipient = NULL;\n\ncib_t *cib = NULL;\nstonith_t *st = NULL;\nxmlNode *current_cib = NULL;\n\ngboolean one_shot = FALSE;\ngboolean has_warnings = FALSE;\ngboolean print_failcount = FALSE;\ngboolean print_operations = FALSE;\ngboolean print_timing = FALSE;\ngboolean print_nodes_attr = FALSE;\ngboolean print_last_updated = TRUE;\ngboolean print_last_change = TRUE;\ngboolean print_tickets = FALSE;\ngboolean watch_fencing = FALSE;\n\n#define FILTER_STR {\"shutdown\", \"terminate\", \"standby\", \"fail-count\",\t\\\n\t    \"last-failure\", \"probe_complete\", \"#id\", \"#uname\",\t\t\\\n\t    \"#is_dc\", NULL}\n\ngboolean log_diffs = FALSE;\ngboolean log_updates = FALSE;\n\nlong last_refresh = 0;\ncrm_trigger_t *refresh_trigger = NULL;\n\n/*\n * 1.3.6.1.4.1.32723 has been assigned to the project by IANA\n * http://www.iana.org/assignments/enterprise-numbers\n */\n#define PACEMAKER_PREFIX \"1.3.6.1.4.1.32723\"\n#define PACEMAKER_TRAP_PREFIX PACEMAKER_PREFIX \".1\"\n\n#define snmp_crm_trap_oid   PACEMAKER_TRAP_PREFIX\n#define snmp_crm_oid_node   PACEMAKER_TRAP_PREFIX \".1\"\n#define snmp_crm_oid_rsc    PACEMAKER_TRAP_PREFIX \".2\"\n#define snmp_crm_oid_task   PACEMAKER_TRAP_PREFIX \".3\"\n#define snmp_crm_oid_desc   PACEMAKER_TRAP_PREFIX \".4\"\n#define snmp_crm_oid_status PACEMAKER_TRAP_PREFIX \".5\"\n#define snmp_crm_oid_rc     PACEMAKER_TRAP_PREFIX \".6\"\n#define snmp_crm_oid_trc    PACEMAKER_TRAP_PREFIX \".7\"\n\n#if CURSES_ENABLED\n#  define print_dot() if(as_console) {\t\t\\\n\tprintw(\".\");\t\t\t\t\\\n\tclrtoeol();\t\t\t\t\\\n\trefresh();\t\t\t\t\\\n    } else {\t\t\t\t\t\\\n\tfprintf(stdout, \".\");\t\t\t\\\n    }\n#else\n#  define print_dot() fprintf(stdout, \".\");\n#endif\n\n#if CURSES_ENABLED\n#  define print_as(fmt, args...) if(as_console) {\t\\\n\tprintw(fmt, ##args);\t\t\t\t\\\n\tclrtoeol();\t\t\t\t\t\\\n\trefresh();\t\t\t\t\t\\\n    } else {\t\t\t\t\t\t\\\n\tfprintf(stdout, fmt, ##args);\t\t\t\\\n    }\n#else\n#  define print_as(fmt, args...) fprintf(stdout, fmt, ##args);\n#endif\n\nstatic void\nblank_screen(void)\n{\n#if CURSES_ENABLED\n    int lpc = 0;\n\n    for (lpc = 0; lpc < LINES; lpc++) {\n        move(lpc, 0);\n        clrtoeol();\n    }\n    move(0, 0);\n    refresh();\n#endif\n}\n\nstatic gboolean\nmon_timer_popped(gpointer data)\n{\n    int rc = pcmk_ok;\n\n    if (timer_id > 0) {\n        g_source_remove(timer_id);\n    }\n\n    rc = cib_connect(TRUE);\n\n    if (rc != pcmk_ok) {\n        print_dot();\n        timer_id = g_timeout_add(reconnect_msec, mon_timer_popped, NULL);\n    }\n    return FALSE;\n}\n\nstatic void\nmon_cib_connection_destroy(gpointer user_data)\n{\n    print_as(\"Connection to the CIB terminated\\n\");\n    if (cib) {\n        print_as(\"Reconnecting...\");\n        cib->cmds->signoff(cib);\n        timer_id = g_timeout_add(reconnect_msec, mon_timer_popped, NULL);\n    }\n    return;\n}\n\n/*\n * Mainloop signal handler.\n */\nstatic void\nmon_shutdown(int nsig)\n{\n    clean_up(EX_OK);\n}\n\n#if ON_DARWIN\n#  define sighandler_t sig_t\n#endif\n\n#if CURSES_ENABLED\n#ifndef HAVE_SIGHANDLER_T\ntypedef void (*sighandler_t)(int);\n#endif\nstatic sighandler_t ncurses_winch_handler;\nstatic void\nmon_winresize(int nsig)\n{\n    static int not_done;\n    int lines = 0, cols = 0;\n\n    if (!not_done++) {\n        if (ncurses_winch_handler)\n            /* the original ncurses WINCH signal handler does the\n             * magic of retrieving the new window size;\n             * otherwise, we'd have to use ioctl or tgetent */\n            (*ncurses_winch_handler) (SIGWINCH);\n        getmaxyx(stdscr, lines, cols);\n        resizeterm(lines, cols);\n        mainloop_set_trigger(refresh_trigger);\n    }\n    not_done--;\n}\n#endif\n\nint\ncib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n\n    CRM_CHECK(cib != NULL, return -EINVAL);\n\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    \n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    \n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n\n            }\n\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}\n\n/* *INDENT-OFF* */\nstatic struct crm_option long_options[] = {\n    /* Top-level Options */\n    {\"help\",           0, 0, '?', \"\\tThis text\"},\n    {\"version\",        0, 0, '$', \"\\tVersion information\"  },\n    {\"verbose\",        0, 0, 'V', \"\\tIncrease debug output\"},\n    {\"quiet\",          0, 0, 'Q', \"\\tDisplay only essential output\" },\n\n    {\"-spacer-\",\t1, 0, '-', \"\\nModes:\"},\n    {\"as-html\",        1, 0, 'h', \"Write cluster status to the named html file\"},\n    {\"as-xml\",         0, 0, 'X', \"\\tWrite cluster status as xml to stdout. This will enable one-shot mode.\"},\n    {\"web-cgi\",        0, 0, 'w', \"\\tWeb mode with output suitable for cgi\"},\n    {\"simple-status\",  0, 0, 's', \"Display the cluster status once as a simple one line output (suitable for nagios)\"},\n    {\"snmp-traps\",     1, 0, 'S', \"Send SNMP traps to this station\", !ENABLE_SNMP},\n    {\"snmp-community\", 1, 0, 'C', \"Specify community for SNMP traps(default is NULL)\", !ENABLE_SNMP},\n    {\"mail-to\",        1, 0, 'T', \"Send Mail alerts to this user.  See also --mail-from, --mail-host, --mail-prefix\", !ENABLE_ESMTP},\n    \n    {\"-spacer-\",\t1, 0, '-', \"\\nDisplay Options:\"},\n    {\"group-by-node\",  0, 0, 'n', \"\\tGroup resources by node\"     },\n    {\"inactive\",       0, 0, 'r', \"\\tDisplay inactive resources\"  },\n    {\"failcounts\",     0, 0, 'f', \"\\tDisplay resource fail counts\"},\n    {\"operations\",     0, 0, 'o', \"\\tDisplay resource operation history\" },\n    {\"timing-details\", 0, 0, 't', \"\\tDisplay resource operation history with timing details\" },\n    {\"tickets\",        0, 0, 'c', \"\\t\\tDisplay cluster tickets\"},\n    {\"watch-fencing\",  0, 0, 'W', \"\\t\\tListen for fencing events. For use with --external-agent, --mail-to and/or --snmp-traps where supported\"},\n    {\"show-node-attributes\", 0, 0, 'A', \"Display node attributes\" },\n\n    {\"-spacer-\",\t1, 0, '-', \"\\nAdditional Options:\"},\n    {\"interval\",       1, 0, 'i', \"\\tUpdate frequency in seconds\" },\n    {\"one-shot\",       0, 0, '1', \"\\tDisplay the cluster status once on the console and exit\"},\n    {\"disable-ncurses\",0, 0, 'N', \"\\tDisable the use of ncurses\", !CURSES_ENABLED},\n    {\"daemonize\",      0, 0, 'd', \"\\tRun in the background as a daemon\"},\n    {\"pid-file\",       1, 0, 'p', \"\\t(Advanced) Daemon pid file location\"},\n    {\"mail-from\",      1, 0, 'F', \"\\tMail alerts should come from the named user\", !ENABLE_ESMTP},\n    {\"mail-host\",      1, 0, 'H', \"\\tMail alerts should be sent via the named host\", !ENABLE_ESMTP},\n    {\"mail-prefix\",    1, 0, 'P', \"Subjects for mail alerts should start with this string\", !ENABLE_ESMTP},\n    {\"external-agent\",    1, 0, 'E', \"A program to run when resource operations take place.\"},\n    {\"external-recipient\",1, 0, 'e', \"A recipient for your program (assuming you want the program to send something to someone).\"},\n\n    \n    {\"xml-file\",       1, 0, 'x', NULL, 1},\n\n    {\"-spacer-\",\t1, 0, '-', \"\\nExamples:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \"Display the cluster status on the console with updates as they occur:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Display the cluster status on the console just once then exit:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon -1\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Display your cluster status, group resources by node, and include inactive resources in the list:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --group-by-node --inactive\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon as a background daemon and have it write the cluster status to an HTML file:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --daemonize --as-html /path/to/docroot/filename.html\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon and export the current cluster status as xml to stdout, then exit.:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --as-xml\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon as a background daemon and have it send email alerts:\", pcmk_option_paragraph|!ENABLE_ESMTP},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --daemonize --mail-to user@example.com --mail-host mail.example.com\", pcmk_option_example|!ENABLE_ESMTP},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon as a background daemon and have it send SNMP alerts:\", pcmk_option_paragraph|!ENABLE_SNMP},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --daemonize --snmp-traps snmptrapd.example.com\", pcmk_option_example|!ENABLE_SNMP},\n    \n    {NULL, 0, 0, 0}\n};\n/* *INDENT-ON* */\n\nint\nmain(int argc, char **argv)\n{\n    int flag;\n    int argerr = 0;\n    int exit_code = 0;\n    int option_index = 0;\n\n    pid_file = strdup(\"/tmp/ClusterMon.pid\");\n    crm_log_cli_init(\"crm_mon\");\n    crm_set_options(NULL, \"mode [options]\", long_options,\n                    \"Provides a summary of cluster's current state.\"\n                    \"\\n\\nOutputs varying levels of detail in a number of different formats.\\n\");\n\n#ifndef ON_DARWIN\n    /* prevent zombies */\n    signal(SIGCLD, SIG_IGN);\n#endif\n\n    if (strcmp(crm_system_name, \"crm_mon.cgi\") == 0) {\n        web_cgi = TRUE;\n        one_shot = TRUE;\n    }\n\n    while (1) {\n        flag = crm_get_option(argc, argv, &option_index);\n        if (flag == -1)\n            break;\n\n        switch (flag) {\n            case 'V':\n                crm_bump_log_level(argc, argv);\n                break;\n            case 'Q':\n                print_last_updated = FALSE;\n                print_last_change = FALSE;\n                break;\n            case 'i':\n                reconnect_msec = crm_get_msec(optarg);\n                break;\n            case 'n':\n                group_by_node = TRUE;\n                break;\n            case 'r':\n                inactive_resources = TRUE;\n                break;\n            case 'W':\n                watch_fencing = TRUE;\n                break;\n            case 'd':\n                daemonize = TRUE;\n                break;\n            case 't':\n                print_timing = TRUE;\n                print_operations = TRUE;\n                break;\n            case 'o':\n                print_operations = TRUE;\n                break;\n            case 'f':\n                print_failcount = TRUE;\n                break;\n            case 'A':\n                print_nodes_attr = TRUE;\n                break;\n            case 'c':\n                print_tickets = TRUE;\n                break;\n            case 'p':\n                free(pid_file);\n                pid_file = strdup(optarg);\n                break;\n            case 'x':\n                xml_file = strdup(optarg);\n                one_shot = TRUE;\n                break;\n            case 'h':\n                as_html_file = strdup(optarg);\n                break;\n            case 'X':\n                as_xml = TRUE;\n                one_shot = TRUE;\n                break;\n            case 'w':\n                web_cgi = TRUE;\n                one_shot = TRUE;\n                break;\n            case 's':\n                simple_status = TRUE;\n                one_shot = TRUE;\n                break;\n            case 'S':\n                snmp_target = optarg;\n                break;\n            case 'T':\n                crm_mail_to = optarg;\n                break;\n            case 'F':\n                crm_mail_from = optarg;\n                break;\n            case 'H':\n                crm_mail_host = optarg;\n                break;\n            case 'P':\n                crm_mail_prefix = optarg;\n                break;\n            case 'E':\n                external_agent = optarg;\n                break;\n            case 'e':\n                external_recipient = optarg;\n                break;\n            case '1':\n                one_shot = TRUE;\n                break;\n            case 'N':\n                as_console = FALSE;\n                break;\n            case 'C':\n                snmp_community = optarg;\n                break;\n            case '$':\n            case '?':\n                crm_help(flag, EX_OK);\n                break;\n            default:\n                printf(\"Argument code 0%o (%c) is not (?yet?) supported\\n\", flag, flag);\n                ++argerr;\n                break;\n        }\n    }\n\n    if (optind < argc) {\n        printf(\"non-option ARGV-elements: \");\n        while (optind < argc)\n            printf(\"%s \", argv[optind++]);\n        printf(\"\\n\");\n    }\n    if (argerr) {\n        crm_help('?', EX_USAGE);\n    }\n\n    if (one_shot) {\n        as_console = FALSE;\n\n    } else if (daemonize) {\n        as_console = FALSE;\n        crm_enable_stderr(FALSE);\n\n        if (!as_html_file && !snmp_target && !crm_mail_to && !external_agent && !as_xml) {\n            printf\n                (\"Looks like you forgot to specify one or more of: --as-html, --as-xml, --mail-to, --snmp-target, --external-agent\\n\");\n            crm_help('?', EX_USAGE);\n        }\n\n        crm_make_daemon(crm_system_name, TRUE, pid_file);\n\n    } else if (as_console) {\n#if CURSES_ENABLED\n        initscr();\n        cbreak();\n        noecho();\n        crm_enable_stderr(FALSE);\n#else\n        one_shot = TRUE;\n        as_console = FALSE;\n        printf(\"Defaulting to one-shot mode\\n\");\n        printf(\"You need to have curses available at compile time to enable console mode\\n\");\n#endif\n    }\n\n    crm_info(\"Starting %s\", crm_system_name);\n    if (xml_file != NULL) {\n        current_cib = filename2xml(xml_file);\n        mon_refresh_display(NULL);\n        return exit_code;\n    }\n\n    if (current_cib == NULL) {\n        cib = cib_new();\n        if (!one_shot) {\n            print_as(\"Attempting connection to the cluster...\");\n        }\n\n        do {\n            exit_code = cib_connect(!one_shot);\n\n            if (one_shot) {\n                break;\n\n            } else if (exit_code != pcmk_ok) {\n                print_dot();\n                sleep(reconnect_msec / 1000);\n            }\n\n        } while (exit_code == -ENOTCONN);\n\n        if (exit_code != pcmk_ok) {\n            print_as(\"\\nConnection to cluster failed: %s\\n\", pcmk_strerror(exit_code));\n            if (as_console) {\n                sleep(2);\n            }\n            clean_up(-exit_code);\n        }\n    }\n\n    if (one_shot) {\n        return exit_code;\n    }\n\n    mainloop = g_main_new(FALSE);\n\n    mainloop_add_signal(SIGTERM, mon_shutdown);\n    mainloop_add_signal(SIGINT, mon_shutdown);\n#if CURSES_ENABLED\n    if (as_console) {\n        ncurses_winch_handler = signal(SIGWINCH, mon_winresize);\n        if (ncurses_winch_handler == SIG_DFL ||\n            ncurses_winch_handler == SIG_IGN || ncurses_winch_handler == SIG_ERR)\n            ncurses_winch_handler = NULL;\n    }\n#endif\n    refresh_trigger = mainloop_add_trigger(G_PRIORITY_LOW, mon_refresh_display, NULL);\n\n    g_main_run(mainloop);\n    g_main_destroy(mainloop);\n\n    crm_info(\"Exiting %s\", crm_system_name);\n\n    clean_up(0);\n    return 0;                   /* never reached */\n}\n\nvoid\nwait_for_refresh(int offset, const char *prefix, int msec)\n{\n    int lpc = msec / 1000;\n    struct timespec sleept = { 1, 0 };\n\n    if (as_console == FALSE) {\n        timer_id = g_timeout_add(msec, mon_timer_popped, NULL);\n        return;\n    }\n\n    crm_notice(\"%sRefresh in %ds...\", prefix ? prefix : \"\", lpc);\n    while (lpc > 0) {\n#if CURSES_ENABLED\n        move(offset, 0);\n/* \t\tprintw(\"%sRefresh in \\033[01;32m%ds\\033[00m...\", prefix?prefix:\"\", lpc); */\n        printw(\"%sRefresh in %ds...\\n\", prefix ? prefix : \"\", lpc);\n        clrtoeol();\n        refresh();\n#endif\n        lpc--;\n        if (lpc == 0) {\n            timer_id = g_timeout_add(1000, mon_timer_popped, NULL);\n        } else {\n            if (nanosleep(&sleept, NULL) != 0) {\n                return;\n            }\n        }\n    }\n}\n\n#define mon_warn(fmt...) do {\t\t\t\\\n\tif (!has_warnings) {\t\t\t\\\n\t    print_as(\"Warning:\");\t\t\\\n\t} else {\t\t\t\t\\\n\t    print_as(\",\");\t\t\t\\\n\t}\t\t\t\t\t\\\n\tprint_as(fmt);\t\t\t\t\\\n\thas_warnings = TRUE;\t\t\t\\\n    } while(0)\n\nstatic int\ncount_resources(pe_working_set_t * data_set, resource_t * rsc)\n{\n    int count = 0;\n    GListPtr gIter = NULL;\n\n    if (rsc == NULL) {\n        gIter = data_set->resources;\n    } else if (rsc->children) {\n        gIter = rsc->children;\n    } else {\n        return is_not_set(rsc->flags, pe_rsc_orphan);\n    }\n\n    for (; gIter != NULL; gIter = gIter->next) {\n        count += count_resources(data_set, gIter->data);\n    }\n    return count;\n}\n\nstatic int\nprint_simple_status(pe_working_set_t * data_set)\n{\n    node_t *dc = NULL;\n    GListPtr gIter = NULL;\n    int nodes_online = 0;\n    int nodes_standby = 0;\n\n    dc = data_set->dc_node;\n\n    if (dc == NULL) {\n        mon_warn(\"No DC \");\n    }\n\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n\n        if (node->details->standby && node->details->online) {\n            nodes_standby++;\n        } else if (node->details->online) {\n            nodes_online++;\n        } else {\n            mon_warn(\"offline node: %s\", node->details->uname);\n        }\n    }\n\n    if (!has_warnings) {\n        print_as(\"Ok: %d nodes online\", nodes_online);\n        if (nodes_standby > 0) {\n            print_as(\", %d standby nodes\", nodes_standby);\n        }\n        print_as(\", %d resources configured\", count_resources(data_set, NULL));\n    }\n\n    print_as(\"\\n\");\n    return 0;\n}\n\nextern int get_failcount(node_t * node, resource_t * rsc, int *last_failure,\n                         pe_working_set_t * data_set);\n\nstatic void\nprint_date(time_t time)\n{\n    int lpc = 0;\n    char date_str[26];\n\n    asctime_r(localtime(&time), date_str);\n    for (; lpc < 26; lpc++) {\n        if (date_str[lpc] == '\\n') {\n            date_str[lpc] = 0;\n        }\n    }\n    print_as(\"'%s'\", date_str);\n}\n\nstatic void\nprint_rsc_summary(pe_working_set_t * data_set, node_t * node, resource_t * rsc, gboolean all)\n{\n    gboolean printed = FALSE;\n    time_t last_failure = 0;\n\n    char *fail_attr = crm_concat(\"fail-count\", rsc->id, '-');\n    const char *value = g_hash_table_lookup(node->details->attrs, fail_attr);\n\n    int failcount = char2score(value);  /* Get the true value, not the effective one from get_failcount() */\n\n    get_failcount(node, rsc, (int *)&last_failure, data_set);\n    free(fail_attr);\n\n    if (all || failcount || last_failure > 0) {\n        printed = TRUE;\n        print_as(\"   %s: migration-threshold=%d\", rsc->id, rsc->migration_threshold);\n    }\n\n    if (failcount > 0) {\n        printed = TRUE;\n        print_as(\" fail-count=%d\", failcount);\n    }\n\n    if (last_failure > 0) {\n        printed = TRUE;\n        print_as(\" last-failure=\");\n        print_date(last_failure);\n    }\n\n    if (printed) {\n        print_as(\"\\n\");\n    }\n}\n\nstatic void\nprint_rsc_history(pe_working_set_t * data_set, node_t * node, xmlNode * rsc_entry)\n{\n    GListPtr gIter = NULL;\n    GListPtr op_list = NULL;\n    gboolean print_name = TRUE;\n    GListPtr sorted_op_list = NULL;\n    const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);\n    resource_t *rsc = pe_find_resource(data_set->resources, rsc_id);\n\n    xmlNode *rsc_op = NULL;\n\n    for (rsc_op = __xml_first_child(rsc_entry); rsc_op != NULL; rsc_op = __xml_next(rsc_op)) {\n        if (crm_str_eq((const char *)rsc_op->name, XML_LRM_TAG_RSC_OP, TRUE)) {\n            op_list = g_list_append(op_list, rsc_op);\n        }\n    }\n\n    sorted_op_list = g_list_sort(op_list, sort_op_by_callid);\n    for (gIter = sorted_op_list; gIter != NULL; gIter = gIter->next) {\n        xmlNode *xml_op = (xmlNode *) gIter->data;\n        const char *value = NULL;\n        const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);\n        const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);\n        const char *op_rc = crm_element_value(xml_op, XML_LRM_ATTR_RC);\n        const char *interval = crm_element_value(xml_op, XML_LRM_ATTR_INTERVAL);\n        int rc = crm_parse_int(op_rc, \"0\");\n\n        if (safe_str_eq(task, CRMD_ACTION_STATUS)\n            && safe_str_eq(interval, \"0\")) {\n            task = \"probe\";\n        }\n\n        if (rc == 7 && safe_str_eq(task, \"probe\")) {\n            continue;\n\n        } else if (safe_str_eq(task, CRMD_ACTION_NOTIFY)) {\n            continue;\n        }\n\n        if (print_name) {\n            print_name = FALSE;\n            if (rsc == NULL) {\n                print_as(\"Orphan resource: %s\", rsc_id);\n            } else {\n                print_rsc_summary(data_set, node, rsc, TRUE);\n            }\n        }\n\n        print_as(\"    + (%s) %s:\", call, task);\n        if (safe_str_neq(interval, \"0\")) {\n            print_as(\" interval=%sms\", interval);\n        }\n\n        if (print_timing) {\n            int int_value;\n            const char *attr = \"last-rc-change\";\n\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=\", attr);\n                print_date(int_value);\n            }\n\n            attr = \"last-run\";\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=\", attr);\n                print_date(int_value);\n            }\n\n            attr = \"exec-time\";\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=%dms\", attr, int_value);\n            }\n\n            attr = \"queue-time\";\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=%dms\", attr, int_value);\n            }\n        }\n\n        print_as(\" rc=%s (%s)\\n\", op_rc, lrmd_event_rc2str(rc));\n    }\n\n    /* no need to free the contents */\n    g_list_free(sorted_op_list);\n}\n\nstatic void\nprint_attr_msg(node_t * node, GListPtr rsc_list, const char *attrname, const char *attrvalue)\n{\n    GListPtr gIter = NULL;\n\n    for (gIter = rsc_list; gIter != NULL; gIter = gIter->next) {\n        resource_t *rsc = (resource_t *) gIter->data;\n        const char *type = g_hash_table_lookup(rsc->meta, \"type\");\n\n        if (rsc->children != NULL) {\n            print_attr_msg(node, rsc->children, attrname, attrvalue);\n        }\n\n        if (safe_str_eq(type, \"ping\") || safe_str_eq(type, \"pingd\")) {\n            const char *name = \"pingd\";\n            const char *multiplier = NULL;\n            char **host_list = NULL;\n            int host_list_num = 0;\n            int expected_score = 0;\n\n            if (g_hash_table_lookup(rsc->meta, \"name\") != NULL) {\n                name = g_hash_table_lookup(rsc->meta, \"name\");\n            }\n\n            /* To identify the resource with the attribute name. */\n            if (safe_str_eq(name, attrname)) {\n                int value = crm_parse_int(attrvalue, \"0\");\n\n                multiplier = g_hash_table_lookup(rsc->meta, \"multiplier\");\n                host_list = g_strsplit(g_hash_table_lookup(rsc->meta, \"host_list\"), \" \", 0);\n                host_list_num = g_strv_length(host_list);\n                g_strfreev(host_list);\n                /* pingd multiplier is the same as the default value. */\n                expected_score = host_list_num * crm_parse_int(multiplier, \"1\");\n\n                /* pingd is abnormal score. */\n                if (value <= 0) {\n                    print_as(\"\\t: Connectivity is lost\");\n                } else if (value < expected_score) {\n                    print_as(\"\\t: Connectivity is degraded (Expected=%d)\", expected_score);\n                }\n            }\n        }\n    }\n}\n\nstatic int\ncompare_attribute(gconstpointer a, gconstpointer b)\n{\n    int rc;\n\n    rc = strcmp((const char *)a, (const char *)b);\n\n    return rc;\n}\n\nstatic void\ncreate_attr_list(gpointer name, gpointer value, gpointer data)\n{\n    int i;\n    const char *filt_str[] = FILTER_STR;\n\n    CRM_CHECK(name != NULL, return);\n\n    /* filtering automatic attributes */\n    for (i = 0; filt_str[i] != NULL; i++) {\n        if (g_str_has_prefix(name, filt_str[i])) {\n            return;\n        }\n    }\n\n    attr_list = g_list_insert_sorted(attr_list, name, compare_attribute);\n}\n\nstatic void\nprint_node_attribute(gpointer name, gpointer node_data)\n{\n    const char *value = NULL;\n    node_t *node = (node_t *) node_data;\n\n    value = g_hash_table_lookup(node->details->attrs, name);\n    print_as(\"    + %-32s\\t: %-10s\", (char *)name, value);\n    print_attr_msg(node, node->details->running_rsc, name, value);\n    print_as(\"\\n\");\n}\n\nstatic void\nprint_node_summary(pe_working_set_t * data_set, gboolean operations)\n{\n    xmlNode *lrm_rsc = NULL;\n    xmlNode *rsc_entry = NULL;\n    xmlNode *node_state = NULL;\n    xmlNode *cib_status = get_object_root(XML_CIB_TAG_STATUS, data_set->input);\n\n    if (operations) {\n        print_as(\"\\nOperations:\\n\");\n    } else {\n        print_as(\"\\nMigration summary:\\n\");\n    }\n\n    for (node_state = __xml_first_child(cib_status); node_state != NULL;\n         node_state = __xml_next(node_state)) {\n        if (crm_str_eq((const char *)node_state->name, XML_CIB_TAG_STATE, TRUE)) {\n            node_t *node = pe_find_node_id(data_set->nodes, ID(node_state));\n\n            if (node == NULL || node->details->online == FALSE) {\n                continue;\n            }\n\n            print_as(\"* Node %s: \", crm_element_value(node_state, XML_ATTR_UNAME));\n            print_as(\"\\n\");\n\n            lrm_rsc = find_xml_node(node_state, XML_CIB_TAG_LRM, FALSE);\n            lrm_rsc = find_xml_node(lrm_rsc, XML_LRM_TAG_RESOURCES, FALSE);\n\n            for (rsc_entry = __xml_first_child(lrm_rsc); rsc_entry != NULL;\n                 rsc_entry = __xml_next(rsc_entry)) {\n                if (crm_str_eq((const char *)rsc_entry->name, XML_LRM_TAG_RESOURCE, TRUE)) {\n                    if (operations) {\n                        print_rsc_history(data_set, node, rsc_entry);\n\n                    } else {\n                        const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);\n                        resource_t *rsc = pe_find_resource(data_set->resources, rsc_id);\n\n                        if (rsc) {\n                            print_rsc_summary(data_set, node, rsc, FALSE);\n                        } else {\n                            print_as(\"   %s: orphan\\n\", rsc_id);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nstatic void\nprint_ticket(gpointer name, gpointer value, gpointer data)\n{\n    ticket_t *ticket = (ticket_t *) value;\n\n    print_as(\" %s\\t%s%10s\", ticket->id,\n             ticket->granted ? \"granted\":\"revoked\",\n             ticket->standby ? \" [standby]\":\"\");\n    if (ticket->last_granted > -1) {\n        print_as(\" last-granted=\");\n        print_date(ticket->last_granted);\n    }\n    print_as(\"\\n\");\n\n    return;\n}\n\nstatic void\nprint_cluster_tickets(pe_working_set_t * data_set)\n{\n    xmlNode *cib_constraints = get_object_root(XML_CIB_TAG_CONSTRAINTS, data_set->input);\n\n    /* For recording the tickets that are referenced in rsc_ticket constraints\n     * but have never been granted yet. */\n    unpack_constraints(cib_constraints, data_set);\n\n    print_as(\"\\nTickets:\\n\");\n    g_hash_table_foreach(data_set->tickets, print_ticket, NULL);\n\n    return;\n}\n\nstatic int\nprint_status(pe_working_set_t * data_set)\n{\n    static int updates = 0;\n\n    GListPtr gIter = NULL;\n    node_t *dc = NULL;\n    char *since_epoch = NULL;\n    char *online_nodes = NULL;\n    char *offline_nodes = NULL;\n    xmlNode *dc_version = NULL;\n    xmlNode *quorum_node = NULL;\n    xmlNode *stack = NULL;\n    time_t a_time = time(NULL);\n\n    int print_opts = pe_print_ncurses;\n    const char *quorum_votes = \"unknown\";\n\n    if (as_console) {\n        blank_screen();\n    } else {\n        print_opts = pe_print_printf;\n    }\n\n    updates++;\n    dc = data_set->dc_node;\n\n    if (a_time == (time_t) - 1) {\n        crm_perror(LOG_ERR, \"set_node_tstamp(): Invalid time returned\");\n        return 1;\n    }\n\n    since_epoch = ctime(&a_time);\n    if (since_epoch != NULL && print_last_updated) {\n        print_as(\"Last updated: %s\", since_epoch);\n    }\n\n    if (print_last_change) {\n        const char *last_written = crm_element_value(data_set->input, XML_CIB_ATTR_WRITTEN);\n        const char *user = crm_element_value(data_set->input, XML_ATTR_UPDATE_USER);\n        const char *client = crm_element_value(data_set->input, XML_ATTR_UPDATE_CLIENT);\n        const char *origin = crm_element_value(data_set->input, XML_ATTR_UPDATE_ORIG);\n\n        print_as(\"Last change: %s\", last_written ? last_written : \"\");\n        if (user) {\n            print_as(\" by %s\", user);\n        }\n        if (client) {\n            print_as(\" via %s\", client);\n        }\n        if (origin) {\n            print_as(\" on %s\", origin);\n        }\n        print_as(\"\\n\");\n    }\n\n    stack =\n        get_xpath_object(\"//nvpair[@name='cluster-infrastructure']\", data_set->input, LOG_DEBUG);\n    if (stack) {\n        print_as(\"Stack: %s\\n\", crm_element_value(stack, XML_NVPAIR_ATTR_VALUE));\n    }\n\n    dc_version = get_xpath_object(\"//nvpair[@name='dc-version']\", data_set->input, LOG_DEBUG);\n    if (dc == NULL) {\n        print_as(\"Current DC: NONE\\n\");\n    } else {\n        const char *quorum = crm_element_value(data_set->input, XML_ATTR_HAVE_QUORUM);\n\n        if (safe_str_neq(dc->details->uname, dc->details->id)) {\n            print_as(\"Current DC: %s (%s)\", dc->details->uname, dc->details->id);\n        } else {\n            print_as(\"Current DC: %s\", dc->details->uname);\n        }\n        print_as(\" - partition %s quorum\\n\", crm_is_true(quorum) ? \"with\" : \"WITHOUT\");\n        if (dc_version) {\n            print_as(\"Version: %s\\n\", crm_element_value(dc_version, XML_NVPAIR_ATTR_VALUE));\n        }\n    }\n\n    quorum_node =\n        get_xpath_object(\"//nvpair[@name='\" XML_ATTR_EXPECTED_VOTES \"']\", data_set->input,\n                         LOG_DEBUG);\n    if (quorum_node) {\n        quorum_votes = crm_element_value(quorum_node, XML_NVPAIR_ATTR_VALUE);\n    }\n\n    print_as(\"%d Nodes configured, %s expected votes\\n\", g_list_length(data_set->nodes),\n             quorum_votes);\n    print_as(\"%d Resources configured.\\n\", count_resources(data_set, NULL));\n    print_as(\"\\n\\n\");\n\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n        const char *node_mode = NULL;\n\n        if (node->details->unclean) {\n            if (node->details->online && node->details->unclean) {\n                node_mode = \"UNCLEAN (online)\";\n\n            } else if (node->details->pending) {\n                node_mode = \"UNCLEAN (pending)\";\n\n            } else {\n                node_mode = \"UNCLEAN (offline)\";\n            }\n\n        } else if (node->details->pending) {\n            node_mode = \"pending\";\n\n        } else if (node->details->standby_onfail && node->details->online) {\n            node_mode = \"standby (on-fail)\";\n\n        } else if (node->details->standby) {\n            if (node->details->online) {\n                node_mode = \"standby\";\n            } else {\n                node_mode = \"OFFLINE (standby)\";\n            }\n\n        } else if (node->details->online) {\n            node_mode = \"online\";\n            if (group_by_node == FALSE) {\n                online_nodes = add_list_element(online_nodes, node->details->uname);\n                continue;\n            }\n\n        } else {\n            node_mode = \"OFFLINE\";\n            if (group_by_node == FALSE) {\n                offline_nodes = add_list_element(offline_nodes, node->details->uname);\n                continue;\n            }\n        }\n\n        if (safe_str_eq(node->details->uname, node->details->id)) {\n            print_as(\"Node %s: %s\\n\", node->details->uname, node_mode);\n        } else {\n            print_as(\"Node %s (%s): %s\\n\", node->details->uname, node->details->id, node_mode);\n        }\n\n        if (group_by_node) {\n            GListPtr gIter2 = NULL;\n\n            for (gIter2 = node->details->running_rsc; gIter2 != NULL; gIter2 = gIter2->next) {\n                resource_t *rsc = (resource_t *) gIter2->data;\n\n                rsc->fns->print(rsc, \"\\t\", print_opts | pe_print_rsconly, stdout);\n            }\n        }\n    }\n\n    if (online_nodes) {\n        print_as(\"Online: [%s ]\\n\", online_nodes);\n        free(online_nodes);\n    }\n    if (offline_nodes) {\n        print_as(\"OFFLINE: [%s ]\\n\", offline_nodes);\n        free(offline_nodes);\n    }\n\n    if (group_by_node == FALSE && inactive_resources) {\n        print_as(\"\\nFull list of resources:\\n\");\n\n    } else if (inactive_resources) {\n        print_as(\"\\nInactive resources:\\n\");\n    }\n\n    if (group_by_node == FALSE || inactive_resources) {\n        print_as(\"\\n\");\n        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {\n            resource_t *rsc = (resource_t *) gIter->data;\n\n            gboolean is_active = rsc->fns->active(rsc, TRUE);\n            gboolean partially_active = rsc->fns->active(rsc, FALSE);\n\n            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {\n                continue;\n\n            } else if (group_by_node == FALSE) {\n                if (partially_active || inactive_resources) {\n                    rsc->fns->print(rsc, NULL, print_opts, stdout);\n                }\n\n            } else if (is_active == FALSE && inactive_resources) {\n                rsc->fns->print(rsc, NULL, print_opts, stdout);\n            }\n        }\n    }\n\n    if (print_nodes_attr) {\n        print_as(\"\\nNode Attributes:\\n\");\n        for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n            node_t *node = (node_t *) gIter->data;\n\n            if (node == NULL || node->details->online == FALSE) {\n                continue;\n            }\n            attr_list = NULL;\n            print_as(\"* Node %s:\\n\", node->details->uname);\n            g_hash_table_foreach(node->details->attrs, create_attr_list, NULL);\n            g_list_foreach(attr_list, print_node_attribute, node);\n        }\n    }\n\n    if (print_operations || print_failcount) {\n        print_node_summary(data_set, print_operations);\n    }\n\n    if (xml_has_children(data_set->failed)) {\n        xmlNode *xml_op = NULL;\n\n        print_as(\"\\nFailed actions:\\n\");\n        for (xml_op = __xml_first_child(data_set->failed); xml_op != NULL;\n             xml_op = __xml_next(xml_op)) {\n            int val = 0;\n            const char *id = ID(xml_op);\n            const char *op_key = crm_element_value(xml_op, XML_LRM_ATTR_TASK_KEY);\n            const char *last = crm_element_value(xml_op, \"last_run\");\n            const char *node = crm_element_value(xml_op, XML_ATTR_UNAME);\n            const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);\n            const char *rc = crm_element_value(xml_op, XML_LRM_ATTR_RC);\n            const char *status = crm_element_value(xml_op, XML_LRM_ATTR_OPSTATUS);\n\n            val = crm_parse_int(status, \"0\");\n            print_as(\"    %s (node=%s, call=%s, rc=%s, status=%s\",\n                     op_key ? op_key : id, node, call, rc, services_lrm_status_str(val));\n\n            if (last) {\n                time_t run_at = crm_parse_int(last, \"0\");\n\n                print_as(\", last-run=%s, queued=%sms, exec=%sms\\n\",\n                         ctime(&run_at),\n                         crm_element_value(xml_op, \"exec_time\"),\n                         crm_element_value(xml_op, \"queue_time\"));\n            }\n\n            val = crm_parse_int(rc, \"0\");\n            print_as(\"): %s\\n\", lrmd_event_rc2str(val));\n        }\n    }\n\n    if (print_tickets) {\n        print_cluster_tickets(data_set);\n    }\n\n#if CURSES_ENABLED\n    if (as_console) {\n        refresh();\n    }\n#endif\n    return 0;\n}\n\nstatic int\nprint_xml_status(pe_working_set_t * data_set)\n{\n    FILE *stream = stdout;\n    GListPtr gIter = NULL;\n    node_t *dc = NULL;\n    xmlNode *stack = NULL;\n    xmlNode *quorum_node = NULL;\n    const char *quorum_votes = \"unknown\";\n\n    dc = data_set->dc_node;\n\n\n    fprintf(stream, \"<?xml version=\\\"1.0\\\"?>\\n\");\n    fprintf(stream, \"<crm_mon version=\\\"%s\\\">\\n\", VERSION);\n\n    /*** SUMMARY ***/\n    fprintf(stream, \"    <summary>\\n\");\n\n    if (print_last_updated) {\n        time_t now = time(NULL);\n        char *now_str = ctime(&now);\n\n        now_str[24] = EOS;      /* replace the newline */\n        fprintf(stream, \"        <last_update time=\\\"%s\\\" />\\n\", now_str);\n    }\n\n    if (print_last_change) {\n        const char *last_written = crm_element_value(data_set->input, XML_CIB_ATTR_WRITTEN);\n        const char *user = crm_element_value(data_set->input, XML_ATTR_UPDATE_USER);\n        const char *client = crm_element_value(data_set->input, XML_ATTR_UPDATE_CLIENT);\n        const char *origin = crm_element_value(data_set->input, XML_ATTR_UPDATE_ORIG);\n\n        fprintf(stream, \"        <last_change time=\\\"%s\\\" user=\\\"%s\\\" client=\\\"%s\\\" origin=\\\"%s\\\" />\\n\",\n            last_written ? last_written : \"\",\n            user ? user : \"\",\n            client ? client : \"\",\n            origin ? origin : \"\");\n    }\n\n    stack = get_xpath_object(\"//nvpair[@name='cluster-infrastructure']\",\n        data_set->input,\n        LOG_DEBUG);\n    if (stack) {\n        fprintf(stream, \"        <stack type=\\\"%s\\\" />\\n\", crm_element_value(stack, XML_NVPAIR_ATTR_VALUE));\n    }\n\n    if (!dc) {\n        fprintf(stream, \"        <current_dc present=\\\"false\\\" />\\n\");\n    } else {\n        const char *quorum = crm_element_value(data_set->input, XML_ATTR_HAVE_QUORUM);\n        const char *uname = dc->details->uname;\n        const char *id = dc->details->id;\n        xmlNode *dc_version = get_xpath_object(\"//nvpair[@name='dc-version']\",\n            data_set->input,\n            LOG_DEBUG);\n        fprintf(stream, \"        <current_dc present=\\\"true\\\" version=\\\"%s\\\" name=\\\"%s\\\" id=\\\"%s\\\" with_quorum=\\\"%s\\\" />\\n\",\n            dc_version ? crm_element_value(dc_version, XML_NVPAIR_ATTR_VALUE) : \"\",\n            uname,\n            id,\n            quorum ? (crm_is_true(quorum) ? \"true\" : \"false\") : \"false\");\n    }\n\n    quorum_node = get_xpath_object(\"//nvpair[@name='\" XML_ATTR_EXPECTED_VOTES \"']\",\n                    data_set->input,\n                    LOG_DEBUG);\n    if (quorum_node) {\n        quorum_votes = crm_element_value(quorum_node, XML_NVPAIR_ATTR_VALUE);\n    }\n    fprintf(stream, \"        <nodes_configured number=\\\"%d\\\" expected_votes=\\\"%s\\\" />\\n\",\n        g_list_length(data_set->nodes),\n        quorum_votes);\n\n    fprintf(stream, \"        <resources_configured number=\\\"%d\\\" />\\n\", count_resources(data_set, NULL));\n\n    fprintf(stream, \"    </summary>\\n\");\n\n    /*** NODES ***/\n    fprintf(stream, \"    <nodes>\\n\");\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n        const char *node_type = \"unknown\";\n\n        switch (node->details->type) {\n        case node_member:\n            node_type = \"member\";\n            break;\n        case node_ping:\n            node_type = \"ping\";\n            break;\n        }\n\n        fprintf(stream, \"        <node name=\\\"%s\\\" \", node->details->uname);\n        fprintf(stream, \"id=\\\"%s\\\" \", node->details->id);\n        fprintf(stream, \"online=\\\"%s\\\" \", node->details->online ? \"true\" : \"false\");\n        fprintf(stream, \"standby=\\\"%s\\\" \", node->details->standby ? \"true\" : \"false\");\n        fprintf(stream, \"standby_onfail=\\\"%s\\\" \", node->details->standby_onfail ? \"true\" : \"false\");\n        fprintf(stream, \"pending=\\\"%s\\\" \", node->details->pending ? \"true\" : \"false\");\n        fprintf(stream, \"unclean=\\\"%s\\\" \", node->details->unclean ? \"true\" : \"false\");\n        fprintf(stream, \"shutdown=\\\"%s\\\" \", node->details->shutdown ? \"true\" : \"false\");\n        fprintf(stream, \"expected_up=\\\"%s\\\" \", node->details->expected_up ? \"true\" : \"false\");\n        fprintf(stream, \"is_dc=\\\"%s\\\" \", node->details->is_dc ? \"true\" : \"false\");\n        fprintf(stream, \"resources_running=\\\"%d\\\" \", g_list_length(node->details->running_rsc));\n        fprintf(stream, \"type=\\\"%s\\\" \", node_type);\n\n        if (group_by_node) {\n            GListPtr lpc2 = NULL;\n            fprintf(stream, \">\\n\");\n            for (lpc2 = node->details->running_rsc; lpc2 != NULL; lpc2 = lpc2->next) {\n                resource_t *rsc = (resource_t *) lpc2->data;\n\n                rsc->fns->print(rsc, \"            \", pe_print_xml | pe_print_rsconly, stream);\n            }\n            fprintf(stream, \"        </node>\\n\");\n        } else {\n            fprintf(stream, \"/>\\n\");\n        }\n    }\n    fprintf(stream, \"    </nodes>\\n\");\n\n    /*** RESOURCES ***/\n    if (group_by_node == FALSE || inactive_resources) {\n        fprintf(stream, \"    <resources>\\n\");\n        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {\n            resource_t *rsc = (resource_t *) gIter->data;\n            gboolean is_active = rsc->fns->active(rsc, TRUE);\n            gboolean partially_active = rsc->fns->active(rsc, FALSE);\n\n            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {\n                continue;\n\n            } else if (group_by_node == FALSE) {\n                if (partially_active || inactive_resources) {\n                    rsc->fns->print(rsc, \"        \", pe_print_xml, stream);\n                }\n\n            } else if (is_active == FALSE && inactive_resources) {\n                rsc->fns->print(rsc, \"        \", pe_print_xml, stream);\n            }\n        }\n        fprintf(stream, \"    </resources>\\n\");\n    }\n\n    fprintf(stream, \"</crm_mon>\\n\");\n    fflush(stream);\n    fclose(stream);\n\n    return 0;\n}\n\nstatic int\nprint_html_status(pe_working_set_t * data_set, const char *filename, gboolean web_cgi)\n{\n    FILE *stream;\n    GListPtr gIter = NULL;\n    node_t *dc = NULL;\n    static int updates = 0;\n    char *filename_tmp = NULL;\n\n    if (web_cgi) {\n        stream = stdout;\n        fprintf(stream, \"Content-type: text/html\\n\\n\");\n\n    } else {\n        filename_tmp = crm_concat(filename, \"tmp\", '.');\n        stream = fopen(filename_tmp, \"w\");\n        if (stream == NULL) {\n            crm_perror(LOG_ERR, \"Cannot open %s for writing\", filename_tmp);\n            free(filename_tmp);\n            return -1;\n        }\n    }\n\n    updates++;\n    dc = data_set->dc_node;\n\n    fprintf(stream, \"<html>\");\n    fprintf(stream, \"<head>\");\n    fprintf(stream, \"<title>Cluster status</title>\");\n/* content=\"%d;url=http://webdesign.about.com\" */\n    fprintf(stream, \"<meta http-equiv=\\\"refresh\\\" content=\\\"%d\\\">\", reconnect_msec / 1000);\n    fprintf(stream, \"</head>\");\n\n    /*** SUMMARY ***/\n\n    fprintf(stream, \"<h2>Cluster summary</h2>\");\n    {\n        char *now_str = NULL;\n        time_t now = time(NULL);\n\n        now_str = ctime(&now);\n        now_str[24] = EOS;      /* replace the newline */\n        fprintf(stream, \"Last updated: <b>%s</b><br/>\\n\", now_str);\n    }\n\n    if (dc == NULL) {\n        fprintf(stream, \"Current DC: <font color=\\\"red\\\"><b>NONE</b></font><br/>\");\n    } else {\n        fprintf(stream, \"Current DC: %s (%s)<br/>\", dc->details->uname, dc->details->id);\n    }\n    fprintf(stream, \"%d Nodes configured.<br/>\", g_list_length(data_set->nodes));\n    fprintf(stream, \"%d Resources configured.<br/>\", count_resources(data_set, NULL));\n\n    /*** CONFIG ***/\n\n    fprintf(stream, \"<h3>Config Options</h3>\\n\");\n\n    fprintf(stream, \"<table>\\n\");\n    fprintf(stream, \"<tr><td>STONITH of failed nodes</td><td>:</td><td>%s</td></tr>\\n\",\n            is_set(data_set->flags, pe_flag_stonith_enabled) ? \"enabled\" : \"disabled\");\n\n    fprintf(stream, \"<tr><td>Cluster is</td><td>:</td><td>%ssymmetric</td></tr>\\n\",\n            is_set(data_set->flags, pe_flag_symmetric_cluster) ? \"\" : \"a-\");\n\n    fprintf(stream, \"<tr><td>No Quorum Policy</td><td>:</td><td>\");\n    switch (data_set->no_quorum_policy) {\n        case no_quorum_freeze:\n            fprintf(stream, \"Freeze resources\");\n            break;\n        case no_quorum_stop:\n            fprintf(stream, \"Stop ALL resources\");\n            break;\n        case no_quorum_ignore:\n            fprintf(stream, \"Ignore\");\n            break;\n        case no_quorum_suicide:\n            fprintf(stream, \"Suicide\");\n            break;\n    }\n    fprintf(stream, \"\\n</td></tr>\\n</table>\\n\");\n\n    /*** NODE LIST ***/\n\n    fprintf(stream, \"<h2>Node List</h2>\\n\");\n    fprintf(stream, \"<ul>\\n\");\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n\n        fprintf(stream, \"<li>\");\n        if (node->details->standby_onfail && node->details->online) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"orange\\\">standby (on-fail)</font>\\n\");\n        } else if (node->details->standby && node->details->online) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"orange\\\">standby</font>\\n\");\n        } else if (node->details->standby) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"red\\\">OFFLINE (standby)</font>\\n\");\n        } else if (node->details->online) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"green\\\">online</font>\\n\");\n        } else {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"red\\\">OFFLINE</font>\\n\");\n        }\n        if (group_by_node) {\n            GListPtr lpc2 = NULL;\n\n            fprintf(stream, \"<ul>\\n\");\n            for (lpc2 = node->details->running_rsc; lpc2 != NULL; lpc2 = lpc2->next) {\n                resource_t *rsc = (resource_t *) lpc2->data;\n\n                fprintf(stream, \"<li>\");\n                rsc->fns->print(rsc, NULL, pe_print_html | pe_print_rsconly, stream);\n                fprintf(stream, \"</li>\\n\");\n            }\n            fprintf(stream, \"</ul>\\n\");\n        }\n        fprintf(stream, \"</li>\\n\");\n    }\n    fprintf(stream, \"</ul>\\n\");\n\n    if (group_by_node && inactive_resources) {\n        fprintf(stream, \"<h2>Inactive Resources</h2>\\n\");\n\n    } else if (group_by_node == FALSE) {\n        fprintf(stream, \"<h2>Resource List</h2>\\n\");\n    }\n\n    if (group_by_node == FALSE || inactive_resources) {\n        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {\n            resource_t *rsc = (resource_t *) gIter->data;\n            gboolean is_active = rsc->fns->active(rsc, TRUE);\n            gboolean partially_active = rsc->fns->active(rsc, FALSE);\n\n            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {\n                continue;\n\n            } else if (group_by_node == FALSE) {\n                if (partially_active || inactive_resources) {\n                    rsc->fns->print(rsc, NULL, pe_print_html, stream);\n                }\n\n            } else if (is_active == FALSE && inactive_resources) {\n                rsc->fns->print(rsc, NULL, pe_print_html, stream);\n            }\n        }\n    }\n\n    fprintf(stream, \"</html>\");\n    fflush(stream);\n    fclose(stream);\n\n    if (!web_cgi) {\n        if (rename(filename_tmp, filename) != 0) {\n            crm_perror(LOG_ERR, \"Unable to rename %s->%s\", filename_tmp, filename);\n        }\n        free(filename_tmp);\n    }\n    return 0;\n}\n\n#if ENABLE_SNMP\n#  include <net-snmp/net-snmp-config.h>\n#  include <net-snmp/snmpv3_api.h>\n#  include <net-snmp/agent/agent_trap.h>\n#  include <net-snmp/library/snmp_client.h>\n#  include <net-snmp/library/mib.h>\n#  include <net-snmp/library/snmp_debug.h>\n\n#  define add_snmp_field(list, oid_string, value) do {\t\t\t\\\n\toid name[MAX_OID_LEN];\t\t\t\t\t\t\\\n        size_t name_length = MAX_OID_LEN;\t\t\t\t\\\n\tif (snmp_parse_oid(oid_string, name, &name_length)) {\t\t\\\n\t    int s_rc = snmp_add_var(list, name, name_length, 's', (value)); \\\n\t    if(s_rc != 0) {\t\t\t\t\t\t\\\n\t\tcrm_err(\"Could not add %s=%s rc=%d\", oid_string, value, s_rc); \\\n\t    } else {\t\t\t\t\t\t\t\\\n\t\tcrm_trace(\"Added %s=%s\", oid_string, value);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t    crm_err(\"Could not parse OID: %s\", oid_string);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    } while(0)\t\t\t\t\t\t\t\t\\\n\n#  define add_snmp_field_int(list, oid_string, value) do {\t\t\\\n\toid name[MAX_OID_LEN];\t\t\t\t\t\t\\\n        size_t name_length = MAX_OID_LEN;\t\t\t\t\\\n\tif (snmp_parse_oid(oid_string, name, &name_length)) {\t\t\\\n\t    if(NULL == snmp_pdu_add_variable(\t\t\t\t\\\n\t\t   list, name, name_length, ASN_INTEGER,\t\t\\\n\t\t   (u_char *) & value, sizeof(value))) {\t\t\\\n\t\tcrm_err(\"Could not add %s=%d\", oid_string, value);\t\\\n\t    } else {\t\t\t\t\t\t\t\\\n\t\tcrm_trace(\"Added %s=%d\", oid_string, value);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t    crm_err(\"Could not parse OID: %s\", oid_string);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    } while(0)\t\t\t\t\t\t\t\t\\\n\nstatic int\nsnmp_input(int operation, netsnmp_session * session, int reqid, netsnmp_pdu * pdu, void *magic)\n{\n    return 1;\n}\n\nstatic netsnmp_session *\ncrm_snmp_init(const char *target, char *community)\n{\n    static netsnmp_session *session = NULL;\n\n#  ifdef NETSNMPV53\n    char target53[128];\n\n    snprintf(target53, sizeof(target53), \"%s:162\", target);\n#  endif\n\n    if (session) {\n        return session;\n    }\n\n    if (target == NULL) {\n        return NULL;\n    }\n\n    if (get_crm_log_level() > LOG_INFO) {\n        char *debug_tokens = strdup(\"run:shell,snmptrap,tdomain\");\n\n        debug_register_tokens(debug_tokens);\n        snmp_set_do_debugging(1);\n    }\n\n    session = calloc(1, sizeof(netsnmp_session));\n    snmp_sess_init(session);\n    session->version = SNMP_VERSION_2c;\n    session->callback = snmp_input;\n    session->callback_magic = NULL;\n\n    if (community) {\n        session->community_len = strlen(community);\n        session->community = (unsigned char *)community;\n    }\n\n    session = snmp_add(session,\n#  ifdef NETSNMPV53\n                       netsnmp_tdomain_transport(target53, 0, \"udp\"),\n#  else\n                       netsnmp_transport_open_client(\"snmptrap\", target),\n#  endif\n                       NULL, NULL);\n\n    if (session == NULL) {\n        snmp_sess_perror(\"Could not create snmp transport\", session);\n    }\n    return session;\n}\n\n#endif\n\nstatic int\nsend_snmp_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,\n               int status, const char *desc)\n{\n    int ret = 1;\n\n#if ENABLE_SNMP\n    static oid snmptrap_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };\n    static oid sysuptime_oid[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };\n\n    netsnmp_pdu *trap_pdu;\n    netsnmp_session *session = crm_snmp_init(snmp_target, snmp_community);\n\n    trap_pdu = snmp_pdu_create(SNMP_MSG_TRAP2);\n    if (!trap_pdu) {\n        crm_err(\"Failed to create SNMP notification\");\n        return SNMPERR_GENERR;\n    }\n\n    if (1) {\n        /* send uptime */\n        char csysuptime[20];\n        time_t now = time(NULL);\n\n        sprintf(csysuptime, \"%ld\", now);\n        snmp_add_var(trap_pdu, sysuptime_oid, sizeof(sysuptime_oid) / sizeof(oid), 't', csysuptime);\n    }\n\n    /* Indicate what the trap is by setting snmpTrapOid.0 */\n    ret =\n        snmp_add_var(trap_pdu, snmptrap_oid, sizeof(snmptrap_oid) / sizeof(oid), 'o',\n                     snmp_crm_trap_oid);\n    if (ret != 0) {\n        crm_err(\"Failed set snmpTrapOid.0=%s\", snmp_crm_trap_oid);\n        return ret;\n    }\n\n    /* Add extries to the trap */\n    if (rsc) {\n        add_snmp_field(trap_pdu, snmp_crm_oid_rsc, rsc);\n    }\n    add_snmp_field(trap_pdu, snmp_crm_oid_node, node);\n    add_snmp_field(trap_pdu, snmp_crm_oid_task, task);\n    add_snmp_field(trap_pdu, snmp_crm_oid_desc, desc);\n\n    add_snmp_field_int(trap_pdu, snmp_crm_oid_rc, rc);\n    add_snmp_field_int(trap_pdu, snmp_crm_oid_trc, target_rc);\n    add_snmp_field_int(trap_pdu, snmp_crm_oid_status, status);\n\n    /* Send and cleanup */\n    ret = snmp_send(session, trap_pdu);\n    if (ret == 0) {\n        /* error */\n        snmp_sess_perror(\"Could not send SNMP trap\", session);\n        snmp_free_pdu(trap_pdu);\n        ret = SNMPERR_GENERR;\n    } else {\n        ret = SNMPERR_SUCCESS;\n    }\n#else\n    crm_err(\"Sending SNMP traps is not supported by this installation\");\n#endif\n    return ret;\n}\n\n#if ENABLE_ESMTP\n#  include <auth-client.h>\n#  include <libesmtp.h>\n\nstatic void\nprint_recipient_status(smtp_recipient_t recipient, const char *mailbox, void *arg)\n{\n    const smtp_status_t *status;\n\n    status = smtp_recipient_status(recipient);\n    printf(\"%s: %d %s\", mailbox, status->code, status->text);\n}\n\nstatic void\nevent_cb(smtp_session_t session, int event_no, void *arg, ...)\n{\n    int *ok;\n    va_list alist;\n\n    va_start(alist, arg);\n    switch (event_no) {\n        case SMTP_EV_CONNECT:\n        case SMTP_EV_MAILSTATUS:\n        case SMTP_EV_RCPTSTATUS:\n        case SMTP_EV_MESSAGEDATA:\n        case SMTP_EV_MESSAGESENT:\n        case SMTP_EV_DISCONNECT:\n            break;\n\n        case SMTP_EV_WEAK_CIPHER:{\n                int bits = va_arg(alist, long);\n                ok = va_arg(alist, int *);\n\n                crm_debug(\"SMTP_EV_WEAK_CIPHER, bits=%d - accepted.\", bits);\n                *ok = 1;\n                break;\n            }\n        case SMTP_EV_STARTTLS_OK:\n            crm_debug(\"SMTP_EV_STARTTLS_OK - TLS started here.\");\n            break;\n\n        case SMTP_EV_INVALID_PEER_CERTIFICATE:{\n                long vfy_result = va_arg(alist, long);\n                ok = va_arg(alist, int *);\n\n                /* There is a table in handle_invalid_peer_certificate() of mail-file.c */\n                crm_err(\"SMTP_EV_INVALID_PEER_CERTIFICATE: %ld\", vfy_result);\n                *ok = 1;\n                break;\n            }\n        case SMTP_EV_NO_PEER_CERTIFICATE:\n            ok = va_arg(alist, int *);\n\n            crm_debug(\"SMTP_EV_NO_PEER_CERTIFICATE - accepted.\");\n            *ok = 1;\n            break;\n        case SMTP_EV_WRONG_PEER_CERTIFICATE:\n            ok = va_arg(alist, int *);\n\n            crm_debug(\"SMTP_EV_WRONG_PEER_CERTIFICATE - accepted.\");\n            *ok = 1;\n            break;\n        case SMTP_EV_NO_CLIENT_CERTIFICATE:\n            ok = va_arg(alist, int *);\n\n            crm_debug(\"SMTP_EV_NO_CLIENT_CERTIFICATE - accepted.\");\n            *ok = 1;\n            break;\n        default:\n            crm_debug(\"Got event: %d - ignored.\\n\", event_no);\n    }\n    va_end(alist);\n}\n#endif\n\n#define BODY_MAX 2048\n\n#if ENABLE_ESMTP\nstatic void\ncrm_smtp_debug(const char *buf, int buflen, int writing, void *arg)\n{\n    char type = 0;\n    int lpc = 0, last = 0, level = *(int *)arg;\n\n    if (writing == SMTP_CB_HEADERS) {\n        type = 'H';\n    } else if (writing) {\n        type = 'C';\n    } else {\n        type = 'S';\n    }\n\n    for (; lpc < buflen; lpc++) {\n        switch (buf[lpc]) {\n            case 0:\n            case '\\n':\n                if (last > 0) {\n                    do_crm_log(level, \"   %.*s\", lpc - last, buf + last);\n                } else {\n                    do_crm_log(level, \"%c: %.*s\", type, lpc - last, buf + last);\n                }\n                last = lpc + 1;\n                break;\n        }\n    }\n}\n#endif\n\nstatic int\nsend_custom_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,\n                 int status, const char *desc)\n{\n    pid_t pid;\n\n    /*setenv needs chars, these are ints */\n    char *rc_s = crm_itoa(rc);\n    char *status_s = crm_itoa(status);\n    char *target_rc_s = crm_itoa(target_rc);\n\n    crm_debug(\"Sending external notification to '%s' via '%s'\", external_recipient, external_agent);\n\n    setenv(\"CRM_notify_recipient\", external_recipient, 1);\n    setenv(\"CRM_notify_node\", node, 1);\n    setenv(\"CRM_notify_rsc\", rsc, 1);\n    setenv(\"CRM_notify_task\", task, 1);\n    setenv(\"CRM_notify_desc\", desc, 1);\n    setenv(\"CRM_notify_rc\", rc_s, 1);\n    setenv(\"CRM_notify_target_rc\", target_rc_s, 1);\n    setenv(\"CRM_notify_status\", status_s, 1);\n\n    pid = fork();\n    if (pid == -1) {\n        crm_perror(LOG_ERR, \"notification fork() failed.\");\n    }\n    if (pid == 0) {\n        /* crm_debug(\"notification: I am the child. Executing the nofitication program.\"); */\n        execl(external_agent, external_agent, NULL);\n    }\n\n    crm_trace(\"Finished running custom notification program '%s'.\", external_agent);\n    free(target_rc_s);\n    free(status_s);\n    free(rc_s);\n    return 0;\n}\n\nstatic int\nsend_smtp_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,\n               int status, const char *desc)\n{\n#if ENABLE_ESMTP\n    smtp_session_t session;\n    smtp_message_t message;\n    auth_context_t authctx;\n    struct sigaction sa;\n\n    int len = 20;\n    int noauth = 1;\n    int smtp_debug = LOG_DEBUG;\n    char crm_mail_body[BODY_MAX];\n    char *crm_mail_subject = NULL;\n\n    memset(&sa, 0, sizeof(struct sigaction));\n\n    if (node == NULL) {\n        node = \"-\";\n    }\n    if (rsc == NULL) {\n        rsc = \"-\";\n    }\n    if (desc == NULL) {\n        desc = \"-\";\n    }\n\n    if (crm_mail_to == NULL) {\n        return 1;\n    }\n\n    if (crm_mail_host == NULL) {\n        crm_mail_host = \"localhost:25\";\n    }\n\n    if (crm_mail_prefix == NULL) {\n        crm_mail_prefix = \"Cluster notification\";\n    }\n\n    crm_debug(\"Sending '%s' mail to %s via %s\", crm_mail_prefix, crm_mail_to, crm_mail_host);\n\n    len += strlen(crm_mail_prefix);\n    len += strlen(task);\n    len += strlen(rsc);\n    len += strlen(node);\n    len += strlen(desc);\n    len++;\n\n    crm_mail_subject = calloc(1, len);\n    snprintf(crm_mail_subject, len, \"%s - %s event for %s on %s: %s\\r\\n\", crm_mail_prefix, task,\n             rsc, node, desc);\n\n    len = 0;\n    len += snprintf(crm_mail_body + len, BODY_MAX - len, \"\\r\\n%s\\r\\n\", crm_mail_prefix);\n    len += snprintf(crm_mail_body + len, BODY_MAX - len, \"====\\r\\n\\r\\n\");\n    if (rc == target_rc) {\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"Completed operation %s for resource %s on %s\\r\\n\", task, rsc, node);\n    } else {\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"Operation %s for resource %s on %s failed: %s\\r\\n\", task, rsc, node, desc);\n    }\n\n    len += snprintf(crm_mail_body + len, BODY_MAX - len, \"\\r\\nDetails:\\r\\n\");\n    len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                    \"\\toperation status: (%d) %s\\r\\n\", status, services_lrm_status_str(status));\n    if (status == PCMK_LRM_OP_DONE) {\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"\\tscript returned: (%d) %s\\r\\n\", rc, lrmd_event_rc2str(rc));\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"\\texpected return value: (%d) %s\\r\\n\", target_rc,\n                        lrmd_event_rc2str(target_rc));\n    }\n\n    auth_client_init();\n    session = smtp_create_session();\n    message = smtp_add_message(session);\n\n    smtp_starttls_enable(session, Starttls_ENABLED);\n\n    sa.sa_handler = SIG_IGN;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGPIPE, &sa, NULL);\n\n    smtp_set_server(session, crm_mail_host);\n\n    authctx = auth_create_context();\n    auth_set_mechanism_flags(authctx, AUTH_PLUGIN_PLAIN, 0);\n\n    smtp_set_eventcb(session, event_cb, NULL);\n\n    /* Now tell libESMTP it can use the SMTP AUTH extension.\n     */\n    if (!noauth) {\n        crm_debug(\"Adding authentication context\");\n        smtp_auth_set_context(session, authctx);\n    }\n\n    if (crm_mail_from == NULL) {\n        struct utsname us;\n        char auto_from[BODY_MAX];\n\n        CRM_ASSERT(uname(&us) == 0);\n        snprintf(auto_from, BODY_MAX, \"crm_mon@%s\", us.nodename);\n        smtp_set_reverse_path(message, auto_from);\n\n    } else {\n        /* NULL is ok */\n        smtp_set_reverse_path(message, crm_mail_from);\n    }\n\n    smtp_set_header(message, \"To\", NULL /*phrase */ , NULL /*addr */ ); /* \"Phrase\" <addr> */\n    smtp_add_recipient(message, crm_mail_to);\n\n    /* Set the Subject: header and override any subject line in the message headers. */\n    smtp_set_header(message, \"Subject\", crm_mail_subject);\n    smtp_set_header_option(message, \"Subject\", Hdr_OVERRIDE, 1);\n\n    smtp_set_message_str(message, crm_mail_body);\n    smtp_set_monitorcb(session, crm_smtp_debug, &smtp_debug, 1);\n\n    if (smtp_start_session(session)) {\n        char buf[128];\n        int rc = smtp_errno();\n\n        crm_err(\"SMTP server problem: %s (%d)\", smtp_strerror(rc, buf, sizeof buf), rc);\n\n    } else {\n        char buf[128];\n        int rc = smtp_errno();\n        const smtp_status_t *smtp_status = smtp_message_transfer_status(message);\n\n        if (rc != 0) {\n            crm_err(\"SMTP server problem: %s (%d)\", smtp_strerror(rc, buf, sizeof buf), rc);\n        }\n        crm_info(\"Send status: %d %s\", smtp_status->code, crm_str(smtp_status->text));\n        smtp_enumerate_recipients(message, print_recipient_status, NULL);\n    }\n\n    smtp_destroy_session(session);\n    auth_destroy_context(authctx);\n    auth_client_exit();\n#endif\n    return 0;\n}\n\nstatic void\nhandle_rsc_op(xmlNode * rsc_op)\n{\n    int rc = -1;\n    int status = -1;\n    int action = -1;\n    int interval = 0;\n    int target_rc = -1;\n    int transition_num = -1;\n    gboolean notify = TRUE;\n\n    char *rsc = NULL;\n    char *task = NULL;\n    const char *desc = NULL;\n    const char *node = NULL;\n    const char *magic = NULL;\n    const char *id = crm_element_value(rsc_op, XML_LRM_ATTR_TASK_KEY);\n    char *update_te_uuid = NULL;\n\n    xmlNode *n = rsc_op;\n\n    if (id == NULL) {\n        /* Compatability with <= 1.1.5 */\n        id = ID(rsc_op);\n    }\n\n    magic = crm_element_value(rsc_op, XML_ATTR_TRANSITION_MAGIC);\n    if (magic == NULL) {\n        /* non-change */\n        return;\n    }\n\n    if (FALSE == decode_transition_magic(magic, &update_te_uuid, &transition_num, &action,\n                                         &status, &rc, &target_rc)) {\n        crm_err(\"Invalid event %s detected for %s\", magic, id);\n        return;\n    }\n\n    if (parse_op_key(id, &rsc, &task, &interval) == FALSE) {\n        crm_err(\"Invalid event detected for %s\", id);\n        goto bail;\n    }\n\n    while (n != NULL && safe_str_neq(XML_CIB_TAG_STATE, TYPE(n))) {\n        n = n->parent;\n    }\n\n    node = crm_element_value(n, XML_ATTR_UNAME);\n    if (node == NULL) {\n        node = ID(n);\n    }\n    if (node == NULL) {\n        crm_err(\"No node detected for event %s (%s)\", magic, id);\n        goto bail;\n    }\n\n    /* look up where we expected it to be? */\n    desc = pcmk_strerror(pcmk_ok);\n    if (status == PCMK_LRM_OP_DONE && target_rc == rc) {\n        crm_notice(\"%s of %s on %s completed: %s\", task, rsc, node, desc);\n        if (rc == PCMK_EXECRA_NOT_RUNNING) {\n            notify = FALSE;\n        }\n\n    } else if (status == PCMK_LRM_OP_DONE) {\n        desc = lrmd_event_rc2str(rc);\n        crm_warn(\"%s of %s on %s failed: %s\", task, rsc, node, desc);\n\n    } else {\n        desc = services_lrm_status_str(status);\n        crm_warn(\"%s of %s on %s failed: %s\", task, rsc, node, desc);\n    }\n\n    if (notify && snmp_target) {\n        send_snmp_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n    if (notify && crm_mail_to) {\n        send_smtp_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n    if (notify && external_agent) {\n        send_custom_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n  bail:\n    free(update_te_uuid);\n    free(rsc);\n    free(task);\n}\n\nvoid\ncrm_diff_update(const char *event, xmlNode * msg)\n{\n    int rc = -1;\n    long now = time(NULL);\n    const char *op = NULL;\n\n    print_dot();\n\n    if (current_cib != NULL) {\n        xmlNode *cib_last = current_cib;\n        current_cib = NULL;\n\n        rc = cib_apply_patch_event(msg, cib_last, &current_cib, LOG_DEBUG);\n        free_xml(cib_last);\n\n        switch(rc) {\n            case pcmk_err_diff_resync:\n            case pcmk_err_diff_failed:\n                crm_warn(\"[%s] %s Patch aborted: %s (%d)\", event, op, pcmk_strerror(rc), rc);\n            case pcmk_ok:\n                break;\n            default:\n                crm_warn(\"[%s] %s ABORTED: %s (%d)\", event, op, pcmk_strerror(rc), rc);\n                return;\n        }\n    }\n\n    if (current_cib == NULL) {\n        current_cib = get_cib_copy(cib);\n    }\n\n    if (crm_mail_to || snmp_target || external_agent) {\n        /* Process operation updates */\n        xmlXPathObject *xpathObj =\n            xpath_search(msg,\n                         \"//\" F_CIB_UPDATE_RESULT \"//\" XML_TAG_DIFF_ADDED \"//\" XML_LRM_TAG_RSC_OP);\n        if (xpathObj && xpathObj->nodesetval->nodeNr > 0) {\n            int lpc = 0, max = xpathObj->nodesetval->nodeNr;\n\n            for (lpc = 0; lpc < max; lpc++) {\n                xmlNode *rsc_op = getXpathResult(xpathObj, lpc);\n\n                handle_rsc_op(rsc_op);\n            }\n        }\n        if (xpathObj) {\n            xmlXPathFreeObject(xpathObj);\n        }\n    }\n\n    if ((now - last_refresh) > (reconnect_msec / 1000)) {\n        /* Force a refresh */\n        mon_refresh_display(NULL);\n\n    } else {\n        mainloop_set_trigger(refresh_trigger);\n    }\n}\n\ngboolean\nmon_refresh_display(gpointer user_data)\n{\n    xmlNode *cib_copy = copy_xml(current_cib);\n    pe_working_set_t data_set;\n\n    last_refresh = time(NULL);\n\n    if (cli_config_update(&cib_copy, NULL, FALSE) == FALSE) {\n        if (cib) {\n            cib->cmds->signoff(cib);\n        }\n        print_as(\"Upgrade failed: %s\", pcmk_strerror(-pcmk_err_dtd_validation));\n        if (as_console) {\n            sleep(2);\n        }\n        clean_up(EX_USAGE);\n        return FALSE;\n    }\n\n    set_working_set_defaults(&data_set);\n    data_set.input = cib_copy;\n    cluster_status(&data_set);\n\n    if (as_html_file || web_cgi) {\n        if (print_html_status(&data_set, as_html_file, web_cgi) != 0) {\n            fprintf(stderr, \"Critical: Unable to output html file\\n\");\n            clean_up(EX_USAGE);\n        }\n    } else if (as_xml) {\n        if (print_xml_status(&data_set) != 0) {\n            fprintf(stderr, \"Critical: Unable to output xml file\\n\");\n            clean_up(EX_USAGE);\n        }\n    } else if (daemonize) {\n        /* do nothing */\n\n    } else if (simple_status) {\n        print_simple_status(&data_set);\n        if (has_warnings) {\n            clean_up(EX_USAGE);\n        }\n\n    } else {\n        print_status(&data_set);\n    }\n\n    cleanup_calculations(&data_set);\n    return TRUE;\n}\n\nvoid mon_st_callback(stonith_t *st, stonith_event_t *e)\n{\n    char *desc = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); \n\n    if (snmp_target) {\n        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (crm_mail_to) {\n        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (external_agent) {\n        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    g_free(desc);\n}\n\n/*\n * De-init ncurses, signoff from the CIB and deallocate memory.\n */\nvoid\nclean_up(int rc)\n{\n#if ENABLE_SNMP\n    netsnmp_session *session = crm_snmp_init(NULL, NULL);\n\n    if (session) {\n        snmp_close(session);\n        snmp_shutdown(\"snmpapp\");\n    }\n#endif\n\n#if CURSES_ENABLED\n    if (as_console) {\n        as_console = FALSE;\n        echo();\n        nocbreak();\n        endwin();\n    }\n#endif\n\n    if (cib != NULL) {\n        cib->cmds->signoff(cib);\n        cib_delete(cib);\n        cib = NULL;\n    }\n\n    free(as_html_file);\n    free(xml_file);\n    free(pid_file);\n\n    if (rc >= 0) {\n        crm_exit(rc);\n    }\n    return;\n}\n"], "fixing_code": ["/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <grp.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <crm/crm.h>\n#include <crm/cib.h>\n#include <crm/msg_xml.h>\n#include <crm/common/ipc.h>\n#include <crm/cluster/internal.h>\n\n#include <crm/common/xml.h>\n\n\n#include <cibio.h>\n#include <callbacks.h>\n#include <cibmessages.h>\n#include <notify.h>\n#include \"common.h\"\n\nextern GMainLoop *mainloop;\nextern gboolean cib_shutdown_flag;\nextern gboolean stand_alone;\nextern const char *cib_root;\n\nstatic unsigned long cib_local_bcast_num = 0;\n\ntypedef struct cib_local_notify_s {\n    xmlNode *notify_src;\n    char *client_id;\n    gboolean from_peer;\n    gboolean sync_reply;\n} cib_local_notify_t;\n\nqb_ipcs_service_t *ipcs_ro = NULL;\nqb_ipcs_service_t *ipcs_rw = NULL;\nqb_ipcs_service_t *ipcs_shm = NULL;\n\nextern crm_cluster_t crm_cluster;\n\nextern int cib_update_counter(xmlNode * xml_obj, const char *field, gboolean reset);\n\nextern void GHFunc_count_peers(gpointer key, gpointer value, gpointer user_data);\n\ngint cib_GCompareFunc(gconstpointer a, gconstpointer b);\ngboolean can_write(int flags);\nvoid send_cib_replace(const xmlNode * sync_request, const char *host);\nvoid cib_process_request(xmlNode * request, gboolean privileged, gboolean force_synchronous,\n                         gboolean from_peer, cib_client_t * cib_client);\n\nextern GHashTable *client_list;\nextern GHashTable *local_notify_queue;\n\nint next_client_id = 0;\nextern const char *cib_our_uname;\nextern unsigned long cib_num_ops, cib_num_local, cib_num_updates, cib_num_fail;\nextern unsigned long cib_bad_connects, cib_num_timeouts;\nextern int cib_status;\n\nint cib_process_command(xmlNode * request, xmlNode ** reply,\n                                    xmlNode ** cib_diff, gboolean privileged);\n\ngboolean cib_common_callback(qb_ipcs_connection_t *c, void *data, size_t size, gboolean privileged);\n\nstatic int32_t\ncib_ipc_accept(qb_ipcs_connection_t *c, uid_t uid, gid_t gid)\n{\n    cib_client_t *new_client = NULL;\n#if ENABLE_ACL\n    struct group *crm_grp = NULL;\n#endif\n\n    crm_trace(\"Connecting %p for uid=%d gid=%d pid=%d\", c, uid, gid, crm_ipcs_client_pid(c));\n    if (cib_shutdown_flag) {\n        crm_info(\"Ignoring new client [%d] during shutdown\", crm_ipcs_client_pid(c));\n        return -EPERM;\n    }\n\n    new_client = calloc(1, sizeof(cib_client_t));\n    new_client->ipc = c;\n\n    CRM_CHECK(new_client->id == NULL, free(new_client->id));\n    new_client->id = crm_generate_uuid();\n\n#if ENABLE_ACL\n    crm_grp = getgrnam(CRM_DAEMON_GROUP);\n    if (crm_grp) {\n        qb_ipcs_connection_auth_set(c, -1, crm_grp->gr_gid, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    new_client->user = uid2username(uid);\n#endif\n\n    /* make sure we can find ourselves later for sync calls\n     * redirected to the master instance\n     */\n    g_hash_table_insert(client_list, new_client->id, new_client);\n\n    qb_ipcs_context_set(c, new_client);\n\n    return 0;\n}\n\nstatic void\ncib_ipc_created(qb_ipcs_connection_t *c)\n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n\n    crm_trace(\"%p connected for client %s\", c, cib_client->id);\n}\n\nstatic int32_t\ncib_ipc_dispatch_rw(qb_ipcs_connection_t *c, void *data, size_t size)\n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n    crm_trace(\"%p message from %s\", c, cib_client->id);\n    return cib_common_callback(c, data, size, TRUE);\n}\n\nstatic int32_t\ncib_ipc_dispatch_ro(qb_ipcs_connection_t *c, void *data, size_t size)\n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n    crm_trace(\"%p message from %s\", c, cib_client->id);\n    return cib_common_callback(c, data, size, FALSE);\n}\n\n/* Error code means? */\nstatic int32_t\ncib_ipc_closed(qb_ipcs_connection_t *c) \n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n    crm_trace(\"Connection %p closed\", c);\n\n    CRM_ASSERT(cib_client != NULL);\n    CRM_ASSERT(cib_client->id != NULL);\n\n    if (!g_hash_table_remove(client_list, cib_client->id)) {\n        crm_err(\"Client %s not found in the hashtable\", cib_client->name);\n    }\n\n    return 0;\n}\n\nstatic void\ncib_ipc_destroy(qb_ipcs_connection_t *c) \n{\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n\n    CRM_ASSERT(cib_client != NULL);\n    CRM_ASSERT(cib_client->id != NULL);\n\n    /* In case we arrive here without a call to cib_ipc_close() */\n    g_hash_table_remove(client_list, cib_client->id);\n\n    crm_trace(\"Destroying %s (%p)\", cib_client->name, c);\n    free(cib_client->name);\n    free(cib_client->callback_id);\n    free(cib_client->id);\n    free(cib_client->user);\n    free(cib_client);\n    crm_trace(\"Freed the cib client\");\n\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n}\n\nstruct qb_ipcs_service_handlers ipc_ro_callbacks = \n{\n    .connection_accept = cib_ipc_accept,\n    .connection_created = cib_ipc_created,\n    .msg_process = cib_ipc_dispatch_ro,\n    .connection_closed = cib_ipc_closed,\n    .connection_destroyed = cib_ipc_destroy\n};\n\nstruct qb_ipcs_service_handlers ipc_rw_callbacks = \n{\n    .connection_accept = cib_ipc_accept,\n    .connection_created = cib_ipc_created,\n    .msg_process = cib_ipc_dispatch_rw,\n    .connection_closed = cib_ipc_closed,\n    .connection_destroyed = cib_ipc_destroy\n};\n\nvoid\ncib_common_callback_worker(uint32_t id, uint32_t flags, xmlNode * op_request, cib_client_t * cib_client, gboolean privileged)\n{\n    const char *op = crm_element_value(op_request, F_CIB_OPERATION);\n\n    if (crm_str_eq(op, CRM_OP_REGISTER, TRUE)) {\n        if(flags & crm_ipc_client_response) {\n            xmlNode *ack = create_xml_node(NULL, __FUNCTION__);\n\n            crm_xml_add(ack, F_CIB_OPERATION, CRM_OP_REGISTER);\n            crm_xml_add(ack, F_CIB_CLIENTID, cib_client->id);\n            crm_ipcs_send(cib_client->ipc, id, ack, FALSE);\n            cib_client->request_id = 0;\n            free_xml(ack);\n        }\n        return;\n\n    } else if (crm_str_eq(op, T_CIB_NOTIFY, TRUE)) {\n        /* Update the notify filters for this client */\n        int on_off = 0;\n        const char *type = crm_element_value(op_request, F_CIB_NOTIFY_TYPE);\n        crm_element_value_int(op_request, F_CIB_NOTIFY_ACTIVATE, &on_off);\n\n        crm_debug(\"Setting %s callbacks for %s (%s): %s\",\n                  type, cib_client->name, cib_client->id, on_off ? \"on\" : \"off\");\n\n        if (safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n            cib_client->post_notify = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n            cib_client->pre_notify = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n            cib_client->confirmations = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n            cib_client->diffs = on_off;\n\n        } else if (safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n            cib_client->replace = on_off;\n        }\n\n        if(flags & crm_ipc_client_response) {\n            /* TODO - include rc */\n            crm_ipcs_send_ack(cib_client->ipc, id, \"ack\", __FUNCTION__, __LINE__);\n            cib_client->request_id = 0;\n        }\n        return;\n    }\n\n    cib_client->num_calls++;\n    cib_process_request(op_request, FALSE, privileged, FALSE, cib_client);\n}\n\nint32_t\ncib_common_callback(qb_ipcs_connection_t *c, void *data, size_t size, gboolean privileged)\n{\n    uint32_t id = 0;\n    uint32_t flags = 0;\n    int call_options = 0;\n    xmlNode *op_request = crm_ipcs_recv(c, data, size, &id, &flags);\n    cib_client_t *cib_client = qb_ipcs_context_get(c);\n\n    if(op_request) {\n        crm_element_value_int(op_request, F_CIB_CALLOPTS, &call_options);\n    }\n\n    crm_trace(\"Inbound: %.200s\", data);\n    if (op_request == NULL || cib_client == NULL) {\n        crm_ipcs_send_ack(c, id, \"nack\", __FUNCTION__, __LINE__);\n        return 0;\n    }\n\n    if(is_set(call_options, cib_sync_call)) {\n        CRM_ASSERT(flags & crm_ipc_client_response);\n    }\n\n    if(flags & crm_ipc_client_response) {\n        CRM_LOG_ASSERT(cib_client->request_id == 0); /* This means the client has two synchronous events in-flight */\n        cib_client->request_id = id;                 /* Reply only to the last one */\n    }\n\n    \n    if (cib_client->name == NULL) {\n        const char *value = crm_element_value(op_request, F_CIB_CLIENTNAME);\n        if (value == NULL) {\n            cib_client->name = crm_itoa(crm_ipcs_client_pid(c));\n        } else {\n            cib_client->name = strdup(value);\n        }\n    }\n\n    if (cib_client->callback_id == NULL) {\n        const char *value = crm_element_value(op_request, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            cib_client->callback_id = strdup(value);\n            \n        } else {\n            cib_client->callback_id = strdup(cib_client->id);\n        }\n    }\n    \n    crm_xml_add(op_request, F_CIB_CLIENTID, cib_client->id);\n    crm_xml_add(op_request, F_CIB_CLIENTNAME, cib_client->name);\n\n#if ENABLE_ACL\n    determine_request_user(cib_client->user, op_request, F_CIB_USER);\n#endif\n\n    crm_log_xml_trace(op_request, \"Client[inbound]\");\n\n    cib_common_callback_worker(id, flags, op_request, cib_client, privileged);\n    free_xml(op_request);\n\n    return 0;\n}\n\nstatic void\ndo_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    /* send callback to originating child */\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n\n    } else {\n        int rid = 0;\n\n        if(sync_reply) {\n            if (client_obj->ipc) {\n                CRM_LOG_ASSERT(client_obj->request_id);\n\n                rid = client_obj->request_id;\n                client_obj->request_id = 0;\n\n                crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n            } else {\n                crm_trace(\"Sending response to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n            }\n\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}\n\nstatic void\nlocal_notify_destroy_callback(gpointer data)\n{\n    cib_local_notify_t *notify = data;\n\n    free_xml(notify->notify_src);\n    free(notify->client_id);\n    free(notify);\n}\n\nstatic void\ncheck_local_notify(int bcast_id)\n{\n    cib_local_notify_t *notify = NULL;\n\n    if (!local_notify_queue) {\n        return;\n    }\n\n    notify = g_hash_table_lookup(local_notify_queue, GINT_TO_POINTER(bcast_id));\n\n    if (notify) {\n        do_local_notify(notify->notify_src, notify->client_id, notify->sync_reply, notify->from_peer);\n        g_hash_table_remove(local_notify_queue, GINT_TO_POINTER(bcast_id));\n    }\n}\n\nstatic void\nqueue_local_notify(xmlNode * notify_src, const char *client_id, gboolean sync_reply, gboolean from_peer)\n{\n    cib_local_notify_t *notify = calloc(1, sizeof(cib_local_notify_t));\n\n    notify->notify_src = notify_src;\n    notify->client_id = strdup(client_id);\n    notify->sync_reply = sync_reply;\n    notify->from_peer = from_peer;\n\n    if (!local_notify_queue) {\n        local_notify_queue = g_hash_table_new_full(g_direct_hash,\n            g_direct_equal, NULL, local_notify_destroy_callback);\n    }\n\n    g_hash_table_insert(local_notify_queue, GINT_TO_POINTER(cib_local_bcast_num), notify);\n}\n\nstatic void\nparse_local_options(cib_client_t * cib_client, int call_type, int call_options, const char *host,\n                    const char *op, gboolean * local_notify, gboolean * needs_reply,\n                    gboolean * process, gboolean * needs_forward)\n{\n    if (cib_op_modifies(call_type)\n        && !(call_options & cib_inhibit_bcast)) {\n        /* we need to send an update anyway */\n        *needs_reply = TRUE;\n    } else {\n        *needs_reply = FALSE;\n    }\n\n    if (host == NULL && (call_options & cib_scope_local)) {\n        crm_trace(\"Processing locally scoped %s op from %s\", op, cib_client->name);\n        *local_notify = TRUE;\n\n    } else if (host == NULL && cib_is_master) {\n        crm_trace(\"Processing master %s op locally from %s\", op, cib_client->name);\n        *local_notify = TRUE;\n\n    } else if (safe_str_eq(host, cib_our_uname)) {\n        crm_trace(\"Processing locally addressed %s op from %s\", op, cib_client->name);\n        *local_notify = TRUE;\n\n    } else if (stand_alone) {\n        *needs_forward = FALSE;\n        *local_notify = TRUE;\n        *process = TRUE;\n\n    } else {\n        crm_trace(\"%s op from %s needs to be forwarded to %s\",\n                    op, cib_client->name, host ? host : \"the master instance\");\n        *needs_forward = TRUE;\n        *process = FALSE;\n    }\n}\n\nstatic gboolean\nparse_peer_options(int call_type, xmlNode * request,\n                   gboolean * local_notify, gboolean * needs_reply, gboolean * process,\n                   gboolean * needs_forward)\n{\n    const char *op = NULL;\n    const char *host = NULL;\n    const char *delegated = NULL;\n    const char *originator = crm_element_value(request, F_ORIG);\n    const char *reply_to = crm_element_value(request, F_CIB_ISREPLY);\n    const char *update = crm_element_value(request, F_CIB_GLOBAL_UPDATE);\n\n    gboolean is_reply = safe_str_eq(reply_to, cib_our_uname);\n\n    if (crm_is_true(update)) {\n        *needs_reply = FALSE;\n        if (is_reply) {\n            *local_notify = TRUE;\n            crm_trace(\"Processing global/peer update from %s\"\n                      \" that originated from us\", originator);\n        } else {\n            crm_trace(\"Processing global/peer update from %s\", originator);\n        }\n        return TRUE;\n    }\n\n    host = crm_element_value(request, F_CIB_HOST);\n    if (host != NULL && safe_str_eq(host, cib_our_uname)) {\n        crm_trace(\"Processing request sent to us from %s\", originator);\n        return TRUE;\n\n    } else if (host == NULL && cib_is_master == TRUE) {\n        crm_trace(\"Processing request sent to master instance from %s\", originator);\n        return TRUE;\n    }\n\n    op = crm_element_value(request, F_CIB_OPERATION);\n    if(safe_str_eq(op, \"cib_shutdown_req\")) {\n        /* Always process these */\n        *local_notify = FALSE;\n        if(reply_to == NULL || is_reply) {\n            *process = TRUE;\n        }\n        if(is_reply) {\n            *needs_reply = FALSE;\n        }\n        return *process;\n    }\n\n    if (is_reply) {\n        crm_trace(\"Forward reply sent from %s to local clients\", originator);\n        *process = FALSE;\n        *needs_reply = FALSE;\n        *local_notify = TRUE;\n        return TRUE;\n    }\n\n    delegated = crm_element_value(request, F_CIB_DELEGATED);\n    if (delegated != NULL) {\n        crm_trace(\"Ignoring msg for master instance\");\n\n    } else if (host != NULL) {\n        /* this is for a specific instance and we're not it */\n        crm_trace(\"Ignoring msg for instance on %s\", crm_str(host));\n\n    } else if (reply_to == NULL && cib_is_master == FALSE) {\n        /* this is for the master instance and we're not it */\n        crm_trace(\"Ignoring reply to %s\", crm_str(reply_to));\n\n    } else if (safe_str_eq(op, \"cib_shutdown_req\")) {\n        if (reply_to != NULL) {\n            crm_debug(\"Processing %s from %s\", op, host);\n            *needs_reply = FALSE;\n\n        } else {\n            crm_debug(\"Processing %s reply from %s\", op, host);\n        }\n        return TRUE;\n\n    } else {\n        crm_err(\"Nothing for us to do?\");\n        crm_log_xml_err(request, \"Peer[inbound]\");\n    }\n\n    return FALSE;\n}\n\nstatic void\nforward_request(xmlNode * request, cib_client_t * cib_client, int call_options)\n{\n    const char *op = crm_element_value(request, F_CIB_OPERATION);\n    const char *host = crm_element_value(request, F_CIB_HOST);\n\n    crm_xml_add(request, F_CIB_DELEGATED, cib_our_uname);\n\n    if (host != NULL) {\n        crm_trace(\"Forwarding %s op to %s\", op, host);\n        send_cluster_message(crm_get_peer(0, host), crm_msg_cib, request, FALSE);\n\n    } else {\n        crm_trace(\"Forwarding %s op to master instance\", op);\n        send_cluster_message(NULL, crm_msg_cib, request, FALSE);\n    }\n\n    /* Return the request to its original state */\n    xml_remove_prop(request, F_CIB_DELEGATED);\n\n    if (call_options & cib_discard_reply) {\n        crm_trace(\"Client not interested in reply\");\n    }\n}\n\nstatic gboolean\nsend_peer_reply(xmlNode * msg, xmlNode * result_diff, const char *originator, gboolean broadcast)\n{\n    CRM_ASSERT(msg != NULL);\n\n    if (broadcast) {\n        /* this (successful) call modified the CIB _and_ the\n         * change needs to be broadcast...\n         *   send via HA to other nodes\n         */\n        int diff_add_updates = 0;\n        int diff_add_epoch = 0;\n        int diff_add_admin_epoch = 0;\n\n        int diff_del_updates = 0;\n        int diff_del_epoch = 0;\n        int diff_del_admin_epoch = 0;\n\n        const char *digest = NULL;\n\n        digest = crm_element_value(result_diff, XML_ATTR_DIGEST);\n        cib_diff_version_details(result_diff,\n                                 &diff_add_admin_epoch, &diff_add_epoch, &diff_add_updates,\n                                 &diff_del_admin_epoch, &diff_del_epoch, &diff_del_updates);\n\n        crm_trace(\"Sending update diff %d.%d.%d -> %d.%d.%d %s\",\n                    diff_del_admin_epoch, diff_del_epoch, diff_del_updates,\n                  diff_add_admin_epoch, diff_add_epoch, diff_add_updates, digest);\n\n        crm_xml_add(msg, F_CIB_ISREPLY, originator);\n        crm_xml_add(msg, F_CIB_GLOBAL_UPDATE, XML_BOOLEAN_TRUE);\n        crm_xml_add(msg, F_CIB_OPERATION, CIB_OP_APPLY_DIFF);\n\n        CRM_ASSERT(digest != NULL);\n\n        add_message_xml(msg, F_CIB_UPDATE_DIFF, result_diff);\n        crm_log_xml_trace(msg, \"copy\");\n        return send_cluster_message(NULL, crm_msg_cib, msg, TRUE);\n\n    } else if (originator != NULL) {\n        /* send reply via HA to originating node */\n        crm_trace(\"Sending request result to originator only\");\n        crm_xml_add(msg, F_CIB_ISREPLY, originator);\n        return send_cluster_message(crm_get_peer(0, originator), crm_msg_cib, msg, FALSE);\n    }\n\n    return FALSE;\n}\n\nvoid\ncib_process_request(xmlNode * request, gboolean force_synchronous, gboolean privileged,\n                    gboolean from_peer, cib_client_t * cib_client)\n{\n    int call_type = 0;\n    int call_options = 0;\n\n    gboolean process = TRUE;\n    gboolean is_update = TRUE;\n    gboolean needs_reply = TRUE;\n    gboolean local_notify = FALSE;\n    gboolean needs_forward = FALSE;\n    gboolean global_update = crm_is_true(crm_element_value(request, F_CIB_GLOBAL_UPDATE));\n\n    xmlNode *op_reply = NULL;\n    xmlNode *result_diff = NULL;\n\n    int rc = pcmk_ok;\n    const char *op = crm_element_value(request, F_CIB_OPERATION);\n    const char *originator = crm_element_value(request, F_ORIG);\n    const char *host = crm_element_value(request, F_CIB_HOST);\n    const char *client_id = crm_element_value(request, F_CIB_CLIENTID);\n\n    crm_trace(\"%s Processing msg %s\", cib_our_uname, crm_element_value(request, F_SEQ));\n\n    cib_num_ops++;\n    if (cib_num_ops == 0) {\n        cib_num_fail = 0;\n        cib_num_local = 0;\n        cib_num_updates = 0;\n        crm_info(\"Stats wrapped around\");\n    }\n\n    if (host != NULL && strlen(host) == 0) {\n        host = NULL;\n    }\n\n    crm_element_value_int(request, F_CIB_CALLOPTS, &call_options);\n    if (force_synchronous) {\n        call_options |= cib_sync_call;\n    }\n\n    crm_trace(\"Processing %s message (%s) for %s...\",\n                from_peer ? \"peer\" : \"local\",\n                from_peer ? originator : cib_our_uname, host ? host : \"master\");\n\n    rc = cib_get_operation_id(op, &call_type);\n    if (rc != pcmk_ok) {\n        /* TODO: construct error reply? */\n        crm_err(\"Pre-processing of command failed: %s\", pcmk_strerror(rc));\n        return;\n    }\n\n    is_update = cib_op_modifies(call_type);\n    if (is_update) {\n        cib_num_updates++;\n    }\n\n    if (from_peer == FALSE) {\n        parse_local_options(cib_client, call_type, call_options, host, op,\n                            &local_notify, &needs_reply, &process, &needs_forward);\n\n    } else if (parse_peer_options(call_type, request, &local_notify,\n                                  &needs_reply, &process, &needs_forward) == FALSE) {\n        return;\n    }\n    crm_trace(\"Finished determining processing actions\");\n\n    if (call_options & cib_discard_reply) {\n        needs_reply = is_update;\n        local_notify = FALSE;\n    }\n\n    if (needs_forward) {\n        forward_request(request, cib_client, call_options);\n        return;\n    }\n\n    if (cib_status != pcmk_ok) {\n        rc = cib_status;\n        crm_err(\"Operation ignored, cluster configuration is invalid.\"\n                \" Please repair and restart: %s\", pcmk_strerror(cib_status));\n        op_reply = cib_construct_reply(request, the_cib, cib_status);\n\n    } else if (process) {\n        int level = LOG_INFO;\n        const char *section = crm_element_value(request, F_CIB_SECTION);\n\n        cib_num_local++;\n        rc = cib_process_command(request, &op_reply, &result_diff, privileged);\n\n        if (global_update) {\n            switch (rc) {\n                case pcmk_ok:\n                case -pcmk_err_old_data:\n                case -pcmk_err_diff_resync:\n                case -pcmk_err_diff_failed:\n                    level = LOG_DEBUG_2;\n                    break;\n                default:\n                    level = LOG_ERR;\n            }\n\n        } else if (safe_str_eq(op, CIB_OP_QUERY)) {\n            level = LOG_DEBUG_2;\n\n        } else if (rc != pcmk_ok) {\n            cib_num_fail++;\n            level = LOG_WARNING;\n\n        } else if (safe_str_eq(op, CIB_OP_SLAVE)) {\n            level = LOG_DEBUG_2;\n\n        } else if (safe_str_eq(section, XML_CIB_TAG_STATUS)) {\n            level = LOG_DEBUG_2;\n        }\n\n        do_crm_log_unlikely(level,\n                       \"Operation complete: op %s for section %s (origin=%s/%s/%s, version=%s.%s.%s): %s (rc=%d)\",\n                       op, section ? section : \"'all'\", originator ? originator : \"local\",\n                       crm_element_value(request, F_CIB_CLIENTNAME), crm_element_value(request,\n                                                                                       F_CIB_CALLID),\n                       the_cib ? crm_element_value(the_cib, XML_ATTR_GENERATION_ADMIN) : \"0\",\n                       the_cib ? crm_element_value(the_cib, XML_ATTR_GENERATION) : \"0\",\n                       the_cib ? crm_element_value(the_cib, XML_ATTR_NUMUPDATES) : \"0\",\n                       pcmk_strerror(rc), rc);\n\n        if (op_reply == NULL && (needs_reply || local_notify)) {\n            crm_err(\"Unexpected NULL reply to message\");\n            crm_log_xml_err(request, \"null reply\");\n            needs_reply = FALSE;\n            local_notify = FALSE;\n        }\n    }\n    crm_trace(\"processing response cases %.16x %.16x\", call_options, cib_sync_call);\n\n    /* from now on we are the server */\n    if (needs_reply == FALSE || stand_alone) {\n        /* nothing more to do...\n         * this was a non-originating slave update\n         */\n        crm_trace(\"Completed slave update\");\n\n    } else if (rc == pcmk_ok && result_diff != NULL && !(call_options & cib_inhibit_bcast)) {\n        gboolean broadcast = FALSE;\n\n        cib_local_bcast_num++;\n        crm_xml_add_int(request, F_CIB_LOCAL_NOTIFY_ID, cib_local_bcast_num);\n        broadcast = send_peer_reply(request, result_diff, originator, TRUE);\n\n        if (broadcast &&\n            client_id &&\n            local_notify &&\n            op_reply) {\n\n            /* If we have been asked to sync the reply,\n             * and a bcast msg has gone out, we queue the local notify\n             * until we know the bcast message has been received */\n            local_notify = FALSE;\n            queue_local_notify(op_reply, client_id, (call_options & cib_sync_call), from_peer);\n            op_reply = NULL; /* the reply is queued, so don't free here */\n        }\n\n    } else if (call_options & cib_discard_reply) {\n        crm_trace(\"Caller isn't interested in reply\");\n\n    } else if (from_peer) {\n        if (is_update == FALSE || result_diff == NULL) {\n            crm_trace(\"Request not broadcast: R/O call\");\n\n        } else if (call_options & cib_inhibit_bcast) {\n            crm_trace(\"Request not broadcast: inhibited\");\n\n        } else if (rc != pcmk_ok) {\n            crm_trace(\"Request not broadcast: call failed: %s\", pcmk_strerror(rc));\n        } else {\n            crm_trace(\"Directing reply to %s\", originator);\n        }\n\n        send_peer_reply(op_reply, result_diff, originator, FALSE);\n    }\n\n    if (local_notify && client_id) {\n        if (process == FALSE) {\n            do_local_notify(request, client_id, call_options & cib_sync_call, from_peer);\n        } else {\n            do_local_notify(op_reply, client_id, call_options & cib_sync_call, from_peer);\n        }\n    }\n\n    free_xml(op_reply);\n    free_xml(result_diff);\n\n    return;\n}\n\nxmlNode *\ncib_construct_reply(xmlNode * request, xmlNode * output, int rc)\n{\n    int lpc = 0;\n    xmlNode *reply = NULL;\n    const char *name = NULL;\n    const char *value = NULL;\n\n    const char *names[] = {\n        F_CIB_OPERATION,\n        F_CIB_CALLID,\n        F_CIB_CLIENTID,\n        F_CIB_CALLOPTS\n    };\n    static int max = DIMOF(names);\n\n    crm_trace(\"Creating a basic reply\");\n    reply = create_xml_node(NULL, \"cib-reply\");\n    crm_xml_add(reply, F_TYPE, T_CIB);\n\n    for (lpc = 0; lpc < max; lpc++) {\n        name = names[lpc];\n        value = crm_element_value(request, name);\n        crm_xml_add(reply, name, value);\n    }\n\n    crm_xml_add_int(reply, F_CIB_RC, rc);\n\n    if (output != NULL) {\n        crm_trace(\"Attaching reply output\");\n        add_message_xml(reply, F_CIB_CALLDATA, output);\n    }\n    return reply;\n}\n\nint\ncib_process_command(xmlNode * request, xmlNode ** reply, xmlNode ** cib_diff, gboolean privileged)\n{\n    xmlNode *input = NULL;\n    xmlNode *output = NULL;\n    xmlNode *result_cib = NULL;\n    xmlNode *current_cib = NULL;\n\n#if ENABLE_ACL\n    xmlNode *filtered_current_cib = NULL;\n#endif\n\n    int call_type = 0;\n    int call_options = 0;\n    int log_level = LOG_DEBUG_4;\n\n    const char *op = NULL;\n    const char *section = NULL;\n\n    int rc = pcmk_ok;\n    int rc2 = pcmk_ok;\n\n    gboolean send_r_notify = FALSE;\n    gboolean global_update = FALSE;\n    gboolean config_changed = FALSE;\n    gboolean manage_counters = TRUE;\n\n    CRM_ASSERT(cib_status == pcmk_ok);\n\n    *reply = NULL;\n    *cib_diff = NULL;\n    current_cib = the_cib;\n\n    /* Start processing the request... */\n    op = crm_element_value(request, F_CIB_OPERATION);\n    crm_element_value_int(request, F_CIB_CALLOPTS, &call_options);\n    rc = cib_get_operation_id(op, &call_type);\n\n    if (rc == pcmk_ok && privileged == FALSE) {\n        rc = cib_op_can_run(call_type, call_options, privileged, global_update);\n    }\n\n    rc2 = cib_op_prepare(call_type, request, &input, &section);\n    if (rc == pcmk_ok) {\n        rc = rc2;\n    }\n\n    if (rc != pcmk_ok) {\n        crm_trace(\"Call setup failed: %s\", pcmk_strerror(rc));\n        goto done;\n\n    } else if (cib_op_modifies(call_type) == FALSE) {\n#if ENABLE_ACL\n        if (acl_enabled(config_hash) == FALSE\n            || acl_filter_cib(request, current_cib, current_cib, &filtered_current_cib) == FALSE) {\n            rc = cib_perform_op(op, call_options, cib_op_func(call_type), TRUE,\n                                section, request, input, FALSE, &config_changed,\n                                current_cib, &result_cib, NULL, &output);\n\n        } else if (filtered_current_cib == NULL) {\n            crm_debug(\"Pre-filtered the entire cib\");\n            rc = -EACCES;\n\n        } else {\n            crm_debug(\"Pre-filtered the queried cib according to the ACLs\");\n            rc = cib_perform_op(op, call_options, cib_op_func(call_type), TRUE,\n                                section, request, input, FALSE, &config_changed,\n                                filtered_current_cib, &result_cib, NULL, &output);\n        }\n#else\n        rc = cib_perform_op(op, call_options, cib_op_func(call_type), TRUE,\n                            section, request, input, FALSE, &config_changed,\n                            current_cib, &result_cib, NULL, &output);\n\n#endif\n\n        CRM_CHECK(result_cib == NULL, free_xml(result_cib));\n        goto done;\n    }\n\n    /* Handle a valid write action */\n    global_update = crm_is_true(crm_element_value(request, F_CIB_GLOBAL_UPDATE));\n    if (global_update) {\n        manage_counters = FALSE;\n        call_options |= cib_force_diff;\n\n        CRM_CHECK(call_type == 3 || call_type == 4, crm_err(\"Call type: %d\", call_type);\n                  crm_log_xml_err(request, \"bad op\"));\n    }\n#ifdef SUPPORT_PRENOTIFY\n    if ((call_options & cib_inhibit_notify) == 0) {\n        cib_pre_notify(call_options, op, the_cib, input);\n    }\n#endif\n\n    if (rc == pcmk_ok) {\n        if (call_options & cib_inhibit_bcast) {\n            /* skip */\n            crm_trace(\"Skipping update: inhibit broadcast\");\n            manage_counters = FALSE;\n        }\n\n        rc = cib_perform_op(op, call_options, cib_op_func(call_type), FALSE,\n                            section, request, input, manage_counters, &config_changed,\n                            current_cib, &result_cib, cib_diff, &output);\n\n#if ENABLE_ACL\n        if (acl_enabled(config_hash) == TRUE\n            && acl_check_diff(request, current_cib, result_cib, *cib_diff) == FALSE) {\n            rc = -EACCES;\n        }\n#endif\n\n        if (rc == pcmk_ok && config_changed) {\n            time_t now;\n            char *now_str = NULL;\n            const char *validation = crm_element_value(result_cib, XML_ATTR_VALIDATION);\n\n            if (validation) {\n                int current_version = get_schema_version(validation);\n                int support_version = get_schema_version(\"pacemaker-1.1\");\n\n                /* Once the later schemas support the \"update-*\" attributes, change \"==\" to \">=\" -- Changed */\n                if (current_version >= support_version) {\n                    const char *origin = crm_element_value(request, F_ORIG);\n\n                    crm_xml_replace(result_cib, XML_ATTR_UPDATE_ORIG,\n                                    origin ? origin : cib_our_uname);\n                    crm_xml_replace(result_cib, XML_ATTR_UPDATE_CLIENT,\n                                    crm_element_value(request, F_CIB_CLIENTNAME));\n#if ENABLE_ACL\n                    crm_xml_replace(result_cib, XML_ATTR_UPDATE_USER,\n                                    crm_element_value(request, F_CIB_USER));\n#endif\n                }\n            }\n\n            now = time(NULL);\n            now_str = ctime(&now);\n            now_str[24] = EOS;  /* replace the newline */\n            crm_xml_replace(result_cib, XML_CIB_ATTR_WRITTEN, now_str);\n        }\n\n        if (manage_counters == FALSE) {\n            config_changed = cib_config_changed(current_cib, result_cib, cib_diff);\n        }\n\n        /* Always write to disk for replace ops,\n         * this negates the need to detect ordering changes\n         */\n        if (config_changed == FALSE && crm_str_eq(CIB_OP_REPLACE, op, TRUE)) {\n            config_changed = TRUE;\n        }\n    }\n\n    cib_add_digest(result_cib, *cib_diff);\n\n    if (rc == pcmk_ok && (call_options & cib_dryrun) == 0) {\n        rc = activateCibXml(result_cib, config_changed, op);\n        if (rc == pcmk_ok && cib_internal_config_changed(*cib_diff)) {\n            cib_read_config(config_hash, result_cib);\n        }\n\n        if (crm_str_eq(CIB_OP_REPLACE, op, TRUE)) {\n            if (section == NULL) {\n                send_r_notify = TRUE;\n\n            } else if (safe_str_eq(section, XML_TAG_CIB)) {\n                send_r_notify = TRUE;\n\n            } else if (safe_str_eq(section, XML_CIB_TAG_NODES)) {\n                send_r_notify = TRUE;\n\n            } else if (safe_str_eq(section, XML_CIB_TAG_STATUS)) {\n                send_r_notify = TRUE;\n            }\n\n        } else if (crm_str_eq(CIB_OP_ERASE, op, TRUE)) {\n            send_r_notify = TRUE;\n        }\n\n    } else if (rc == -pcmk_err_dtd_validation) {\n        if (output != NULL) {\n            crm_log_xml_info(output, \"cib:output\");\n            free_xml(output);\n        }\n#if ENABLE_ACL\n        {\n            xmlNode *filtered_result_cib = NULL;\n\n            if (acl_enabled(config_hash) == FALSE\n                || acl_filter_cib(request, current_cib, result_cib,\n                                  &filtered_result_cib) == FALSE) {\n                output = result_cib;\n\n            } else {\n                crm_debug(\"Filtered the result cib for output according to the ACLs\");\n                output = filtered_result_cib;\n                if (result_cib != NULL) {\n                    free_xml(result_cib);\n                }\n            }\n        }\n#else\n        output = result_cib;\n#endif\n\n    } else {\n        free_xml(result_cib);\n    }\n\n    if ((call_options & cib_inhibit_notify) == 0) {\n        const char *call_id = crm_element_value(request, F_CIB_CALLID);\n        const char *client = crm_element_value(request, F_CIB_CLIENTNAME);\n\n#ifdef SUPPORT_POSTNOTIFY\n        cib_post_notify(call_options, op, input, rc, the_cib);\n#endif\n        cib_diff_notify(call_options, client, call_id, op, input, rc, *cib_diff);\n    }\n\n    if (send_r_notify) {\n        const char *origin = crm_element_value(request, F_ORIG);\n\n        cib_replace_notify(origin, the_cib, rc, *cib_diff);\n    }\n\n    if (rc != pcmk_ok) {\n        log_level = LOG_DEBUG_4;\n        if (rc == -pcmk_err_dtd_validation && global_update) {\n            log_level = LOG_WARNING;\n            crm_log_xml_info(input, \"cib:global_update\");\n        }\n\n    } else if (config_changed) {\n        log_level = LOG_DEBUG_3;\n        if (cib_is_master) {\n            log_level = LOG_NOTICE;\n        }\n\n    } else if (cib_is_master) {\n        log_level = LOG_DEBUG_2;\n    }\n\n    log_cib_diff(log_level, *cib_diff, \"cib:diff\");\n\n  done:\n    if ((call_options & cib_discard_reply) == 0) {\n        *reply = cib_construct_reply(request, output, rc);\n        crm_log_xml_trace(*reply, \"cib:reply\");\n    }\n#if ENABLE_ACL\n    if (filtered_current_cib != NULL) {\n        free_xml(filtered_current_cib);\n    }\n#endif\n\n    if (call_type >= 0) {\n        cib_op_cleanup(call_type, call_options, &input, &output);\n    }\n    return rc;\n}\n\ngint\ncib_GCompareFunc(gconstpointer a, gconstpointer b)\n{\n    const xmlNode *a_msg = a;\n    const xmlNode *b_msg = b;\n\n    int msg_a_id = 0;\n    int msg_b_id = 0;\n    const char *value = NULL;\n\n    value = crm_element_value_const(a_msg, F_CIB_CALLID);\n    msg_a_id = crm_parse_int(value, NULL);\n\n    value = crm_element_value_const(b_msg, F_CIB_CALLID);\n    msg_b_id = crm_parse_int(value, NULL);\n\n    if (msg_a_id == msg_b_id) {\n        return 0;\n    } else if (msg_a_id < msg_b_id) {\n        return -1;\n    }\n    return 1;\n}\n\n#if SUPPORT_HEARTBEAT\nvoid\ncib_ha_peer_callback(HA_Message * msg, void *private_data)\n{\n    xmlNode *xml = convert_ha_message(NULL, msg, __FUNCTION__);\n\n    cib_peer_callback(xml, private_data);\n    free_xml(xml);\n}\n#endif\n\nvoid\ncib_peer_callback(xmlNode * msg, void *private_data)\n{\n    const char *reason = NULL;\n    const char *originator = crm_element_value(msg, F_ORIG);\n\n    if (originator == NULL || crm_str_eq(originator, cib_our_uname, TRUE)) {\n        /* message is from ourselves */\n        int bcast_id = 0;\n        if (!(crm_element_value_int(msg, F_CIB_LOCAL_NOTIFY_ID, &bcast_id))) {\n            check_local_notify(bcast_id);\n        }\n        return;\n\n    } else if (crm_peer_cache == NULL) {\n        reason = \"membership not established\";\n        goto bail;\n    }\n\n    if (crm_element_value(msg, F_CIB_CLIENTNAME) == NULL) {\n        crm_xml_add(msg, F_CIB_CLIENTNAME, originator);\n    }\n\n    /* crm_log_xml_trace(\"Peer[inbound]\", msg); */\n    cib_process_request(msg, FALSE, TRUE, TRUE, NULL);\n    return;\n\n  bail:\n    if (reason) {\n        const char *seq = crm_element_value(msg, F_SEQ);\n        const char *op = crm_element_value(msg, F_CIB_OPERATION);\n\n        crm_warn(\"Discarding %s message (%s) from %s: %s\", op, seq, originator, reason);\n    }\n}\n\n\n#if SUPPORT_HEARTBEAT\nextern oc_ev_t *cib_ev_token;\nstatic void *ccm_library = NULL;\nint (*ccm_api_callback_done) (void *cookie) = NULL;\nint (*ccm_api_handle_event) (const oc_ev_t * token) = NULL;\n\nvoid\ncib_client_status_callback(const char *node, const char *client, const char *status, void *private)\n{\n    crm_node_t *peer = NULL;\n\n    if (safe_str_eq(client, CRM_SYSTEM_CIB)) {\n        crm_info(\"Status update: Client %s/%s now has status [%s]\", node, client, status);\n\n        if (safe_str_eq(status, JOINSTATUS)) {\n            status = ONLINESTATUS;\n\n        } else if (safe_str_eq(status, LEAVESTATUS)) {\n            status = OFFLINESTATUS;\n        }\n\n        peer = crm_get_peer(0, node);\n        crm_update_peer_proc(__FUNCTION__, peer, crm_proc_cib, status);\n    }\n    return;\n}\n\nint\ncib_ccm_dispatch(gpointer user_data)\n{\n    int rc = 0;\n    oc_ev_t *ccm_token = (oc_ev_t *) user_data;\n\n    crm_trace(\"received callback\");\n\n    if (ccm_api_handle_event == NULL) {\n        ccm_api_handle_event =\n            find_library_function(&ccm_library, CCM_LIBRARY, \"oc_ev_handle_event\", 1);\n    }\n\n    rc = (*ccm_api_handle_event) (ccm_token);\n    if (0 == rc) {\n        return 0;\n    }\n\n    crm_err(\"CCM connection appears to have failed: rc=%d.\", rc);\n\n    /* eventually it might be nice to recover and reconnect... but until then... */\n    crm_err(\"Exiting to recover from CCM connection failure\");\n    crm_exit(2);\n\n    return -1;\n}\n\nint current_instance = 0;\nvoid\ncib_ccm_msg_callback(oc_ed_t event, void *cookie, size_t size, const void *data)\n{\n    gboolean update_id = FALSE;\n    const oc_ev_membership_t *membership = data;\n\n    CRM_ASSERT(membership != NULL);\n\n    crm_info(\"Processing CCM event=%s (id=%d)\", ccm_event_name(event), membership->m_instance);\n\n    if (current_instance > membership->m_instance) {\n        crm_err(\"Membership instance ID went backwards! %d->%d\",\n                current_instance, membership->m_instance);\n        CRM_ASSERT(current_instance <= membership->m_instance);\n    }\n\n    switch (event) {\n        case OC_EV_MS_NEW_MEMBERSHIP:\n        case OC_EV_MS_INVALID:\n            update_id = TRUE;\n            break;\n        case OC_EV_MS_PRIMARY_RESTORED:\n            update_id = TRUE;\n            break;\n        case OC_EV_MS_NOT_PRIMARY:\n            crm_trace(\"Ignoring transitional CCM event: %s\", ccm_event_name(event));\n            break;\n        case OC_EV_MS_EVICTED:\n            crm_err(\"Evicted from CCM: %s\", ccm_event_name(event));\n            break;\n        default:\n            crm_err(\"Unknown CCM event: %d\", event);\n    }\n\n    if (update_id) {\n        unsigned int lpc = 0;\n\n        CRM_CHECK(membership != NULL, return);\n\n        current_instance = membership->m_instance;\n\n        for (lpc = 0; lpc < membership->m_n_out; lpc++) {\n            crm_update_ccm_node(membership, lpc + membership->m_out_idx, CRM_NODE_LOST,\n                                current_instance);\n        }\n\n        for (lpc = 0; lpc < membership->m_n_member; lpc++) {\n            crm_update_ccm_node(membership, lpc + membership->m_memb_idx, CRM_NODE_ACTIVE,\n                                current_instance);\n        }\n    }\n\n    if (ccm_api_callback_done == NULL) {\n        ccm_api_callback_done =\n            find_library_function(&ccm_library, CCM_LIBRARY, \"oc_ev_callback_done\", 1);\n    }\n    (*ccm_api_callback_done) (cookie);\n    return;\n}\n#endif\n\ngboolean\ncan_write(int flags)\n{\n    return TRUE;\n}\n\nstatic gboolean\ncib_force_exit(gpointer data)\n{\n    crm_notice(\"Forcing exit!\");\n    terminate_cib(__FUNCTION__, TRUE);\n    return FALSE;\n}\n\nstatic void\ndisconnect_remote_client(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *a_client = value;\n    crm_err(\"Disconnecting %s... Not implemented\", crm_str(a_client->name));\n}\n\nvoid\ncib_shutdown(int nsig)\n{\n    struct qb_ipcs_stats srv_stats;\n    if (cib_shutdown_flag == FALSE) {\n        int disconnects = 0;\n        qb_ipcs_connection_t *c = NULL;\n\n        cib_shutdown_flag = TRUE;\n\n        c = qb_ipcs_connection_first_get(ipcs_rw);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_rw, last);\n\n            crm_debug(\"Disconnecting r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_ro);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_ro, last);\n\n            crm_debug(\"Disconnecting r/o client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        c = qb_ipcs_connection_first_get(ipcs_shm);\n        while(c != NULL) {\n            qb_ipcs_connection_t *last = c;\n            c = qb_ipcs_connection_next_get(ipcs_shm, last);\n\n            crm_debug(\"Disconnecting non-blocking r/w client %p...\", last);\n            qb_ipcs_disconnect(last);\n            qb_ipcs_connection_unref(last);\n            disconnects++;\n        }\n\n        disconnects += g_hash_table_size(client_list);\n\n        crm_debug(\"Disconnecting %d remote clients\", g_hash_table_size(client_list));\n        g_hash_table_foreach(client_list, disconnect_remote_client, NULL);\n        crm_info(\"Disconnected %d clients\", disconnects);\n    }\n\n    qb_ipcs_stats_get(ipcs_rw, &srv_stats, QB_FALSE);\n    \n    if(g_hash_table_size(client_list) == 0) {\n        crm_info(\"All clients disconnected (%d)\", srv_stats.active_connections);\n        initiate_exit();\n        \n    } else {\n        crm_info(\"Waiting on %d clients to disconnect (%d)\", g_hash_table_size(client_list), srv_stats.active_connections);\n    }\n}\n\nvoid\ninitiate_exit(void)\n{\n    int active = 0;\n    xmlNode *leaving = NULL;\n\n    active = crm_active_peers();\n    if (active < 2) {\n        terminate_cib(__FUNCTION__, FALSE);\n        return;\n    }\n\n    crm_info(\"Sending disconnect notification to %d peers...\", active);\n\n    leaving = create_xml_node(NULL, \"exit-notification\");\n    crm_xml_add(leaving, F_TYPE, \"cib\");\n    crm_xml_add(leaving, F_CIB_OPERATION, \"cib_shutdown_req\");\n\n    send_cluster_message(NULL, crm_msg_cib, leaving, TRUE);\n    free_xml(leaving);\n\n    g_timeout_add(crm_get_msec(\"5s\"), cib_force_exit, NULL);\n}\n\nextern int remote_fd;\nextern int remote_tls_fd;\nextern void terminate_cs_connection(void);\n\nvoid\nterminate_cib(const char *caller, gboolean fast)\n{\n    if (remote_fd > 0) {\n        close(remote_fd);\n        remote_fd = 0;\n    }\n    if (remote_tls_fd > 0) {\n        close(remote_tls_fd);\n        remote_tls_fd = 0;\n    }\n    \n    if(!fast) {\n        crm_info(\"%s: Disconnecting from cluster infrastructure\", caller);\n        crm_cluster_disconnect(&crm_cluster);\n    }\n\n    uninitializeCib();\n\n    crm_info(\"%s: Exiting%s...\", caller, fast?\" fast\":mainloop?\" from mainloop\":\"\");\n\n    if(fast == FALSE && mainloop != NULL && g_main_is_running(mainloop)) {\n        g_main_quit(mainloop);\n\n    } else {\n        qb_ipcs_destroy(ipcs_ro);\n        qb_ipcs_destroy(ipcs_rw);\n        qb_ipcs_destroy(ipcs_shm);\n\n        if (fast) {\n            crm_exit(EX_USAGE);\n        } else {\n            crm_exit(EX_OK);\n        }\n    }\n}\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <crm/crm.h>\n#include <crm/cib.h>\n#include <crm/common/xml.h>\n#include <crm/cluster.h>\n#include <crm/common/mainloop.h>\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\n#endif\n\n\nextern gboolean cib_is_master;\nextern GHashTable *client_list;\nextern GHashTable *peer_hash;\nextern GHashTable *config_hash;\n\ntypedef struct cib_client_s {\n    char *id;\n    char *name;\n    char *callback_id;\n    char *user;\n    char *recv_buf;\n    int request_id;\n\n    qb_ipcs_connection_t *ipc;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    gnutls_session *session;\n    gboolean handshake_complete;\n#else\n    void *session;\n#endif\n    gboolean encrypted;\n    gboolean remote_auth;\n    mainloop_io_t *remote;\n\n    unsigned long num_calls;\n\n    int pre_notify;\n    int post_notify;\n    int confirmations;\n    int replace;\n    int diffs;\n    int remote_auth_timeout;\n\n    GList *delegated_calls;\n} cib_client_t;\n\ntypedef struct cib_operation_s {\n    const char *operation;\n    gboolean modifies_cib;\n    gboolean needs_privileges;\n    gboolean needs_quorum;\n    int (*prepare) (xmlNode *, xmlNode **, const char **);\n    int (*cleanup) (int, xmlNode **, xmlNode **);\n    int (*fn) (const char *, int, const char *, xmlNode *,\n                           xmlNode *, xmlNode *, xmlNode **, xmlNode **);\n} cib_operation_t;\n\nextern struct qb_ipcs_service_handlers ipc_ro_callbacks;\nextern struct qb_ipcs_service_handlers ipc_rw_callbacks;\nextern qb_ipcs_service_t *ipcs_ro;\nextern qb_ipcs_service_t *ipcs_rw;\nextern qb_ipcs_service_t *ipcs_shm;\n\nextern void cib_peer_callback(xmlNode * msg, void *private_data);\nextern void cib_client_status_callback(const char *node, const char *client,\n                                       const char *status, void *private);\nextern void cib_common_callback_worker(uint32_t id, uint32_t flags, xmlNode * op_request, cib_client_t * cib_client, gboolean privileged);\n\nvoid cib_shutdown(int nsig);\nvoid initiate_exit(void);\nvoid terminate_cib(const char *caller, gboolean fast);\n\n#if SUPPORT_HEARTBEAT\nextern void cib_ha_peer_callback(HA_Message * msg, void *private_data);\nextern int cib_ccm_dispatch(gpointer user_data);\nextern void cib_ccm_msg_callback(oc_ed_t event, void *cookie, size_t size, const void *data);\n#endif\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <time.h>\n\n#include <crm/crm.h>\n#include <crm/cib/internal.h>\n#include <crm/msg_xml.h>\n\n#include <crm/common/xml.h>\n#include <cibio.h>\n#include <callbacks.h>\n#include <notify.h>\n\nint pending_updates = 0;\nextern GHashTable *client_list;\n\ngboolean cib_notify_client(gpointer key, gpointer value, gpointer user_data);\nvoid attach_cib_generation(xmlNode * msg, const char *field, xmlNode * a_cib);\n\nvoid do_cib_notify(int options, const char *op, xmlNode * update,\n                   int result, xmlNode * result_data, const char *msg_type);\n\nstatic void\nneed_pre_notify(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *client = value;\n\n    if (client->pre_notify) {\n        gboolean *needed = user_data;\n\n        *needed = TRUE;\n    }\n}\n\nstatic void\nneed_post_notify(gpointer key, gpointer value, gpointer user_data)\n{\n    cib_client_t *client = value;\n\n    if (client->post_notify) {\n        gboolean *needed = user_data;\n\n        *needed = TRUE;\n    }\n}\n\ngboolean\ncib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n\n    if (client->ipc == NULL && client->session == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n\n    type = crm_element_value(update_msg, F_SUBTYPE);\n\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}\n\nvoid\ncib_pre_notify(int options, const char *op, xmlNode * existing, xmlNode * update)\n{\n    xmlNode *update_msg = NULL;\n    const char *type = NULL;\n    const char *id = NULL;\n    gboolean needed = FALSE;\n\n    g_hash_table_foreach(client_list, need_pre_notify, &needed);\n    if (needed == FALSE) {\n        return;\n    }\n\n    /* TODO: consider pre-notification for removal */\n    update_msg = create_xml_node(NULL, \"pre-notify\");\n\n    if (update != NULL) {\n        id = crm_element_value(update, XML_ATTR_ID);\n    }\n\n    crm_xml_add(update_msg, F_TYPE, T_CIB_NOTIFY);\n    crm_xml_add(update_msg, F_SUBTYPE, T_CIB_PRE_NOTIFY);\n    crm_xml_add(update_msg, F_CIB_OPERATION, op);\n\n    if (id != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJID, id);\n    }\n\n    if (update != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(update));\n    } else if (existing != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(existing));\n    }\n\n    type = crm_element_value(update_msg, F_CIB_OBJTYPE);\n    attach_cib_generation(update_msg, \"cib_generation\", the_cib);\n\n    if (existing != NULL) {\n        add_message_xml(update_msg, F_CIB_EXISTING, existing);\n    }\n    if (update != NULL) {\n        add_message_xml(update_msg, F_CIB_UPDATE, update);\n    }\n\n    g_hash_table_foreach_remove(client_list, cib_notify_client, update_msg);\n\n    if (update == NULL) {\n        crm_trace(\"Performing operation %s (on section=%s)\", op, type);\n\n    } else {\n        crm_trace(\"Performing %s on <%s%s%s>\", op, type, id ? \" id=\" : \"\", id ? id : \"\");\n    }\n\n    free_xml(update_msg);\n}\n\nvoid\ncib_post_notify(int options, const char *op, xmlNode * update,\n                int result, xmlNode * new_obj)\n{\n    gboolean needed = FALSE;\n\n    g_hash_table_foreach(client_list, need_post_notify, &needed);\n    if (needed == FALSE) {\n        return;\n    }\n\n    do_cib_notify(options, op, update, result, new_obj, T_CIB_UPDATE_CONFIRM);\n}\n\nvoid\ncib_diff_notify(int options, const char *client, const char *call_id, const char *op,\n                xmlNode * update, int result, xmlNode * diff)\n{\n    int add_updates = 0;\n    int add_epoch = 0;\n    int add_admin_epoch = 0;\n\n    int del_updates = 0;\n    int del_epoch = 0;\n    int del_admin_epoch = 0;\n\n    int log_level = LOG_DEBUG_2;\n\n    if (diff == NULL) {\n        return;\n    }\n\n    if (result != pcmk_ok) {\n        log_level = LOG_WARNING;\n    }\n\n    cib_diff_version_details(diff, &add_admin_epoch, &add_epoch, &add_updates,\n                             &del_admin_epoch, &del_epoch, &del_updates);\n\n    if (add_updates != del_updates) {\n        do_crm_log(log_level,\n                   \"Update (client: %s%s%s): %d.%d.%d -> %d.%d.%d (%s)\",\n                   client, call_id ? \", call:\" : \"\", call_id ? call_id : \"\",\n                   del_admin_epoch, del_epoch, del_updates,\n                   add_admin_epoch, add_epoch, add_updates, pcmk_strerror(result));\n\n    } else if (diff != NULL) {\n        do_crm_log(log_level,\n                   \"Local-only Change (client:%s%s%s): %d.%d.%d (%s)\",\n                   client, call_id ? \", call: \" : \"\", call_id ? call_id : \"\",\n                   add_admin_epoch, add_epoch, add_updates, pcmk_strerror(result));\n    }\n\n    do_cib_notify(options, op, update, result, diff, T_CIB_DIFF_NOTIFY);\n}\n\nvoid\ndo_cib_notify(int options, const char *op, xmlNode * update,\n              int result, xmlNode * result_data, const char *msg_type)\n{\n    xmlNode *update_msg = NULL;\n    const char *id = NULL;\n\n    update_msg = create_xml_node(NULL, \"notify\");\n\n    if (result_data != NULL) {\n        id = crm_element_value(result_data, XML_ATTR_ID);\n    }\n\n    crm_xml_add(update_msg, F_TYPE, T_CIB_NOTIFY);\n    crm_xml_add(update_msg, F_SUBTYPE, msg_type);\n    crm_xml_add(update_msg, F_CIB_OPERATION, op);\n    crm_xml_add_int(update_msg, F_CIB_RC, result);\n\n    if (id != NULL) {\n        crm_xml_add(update_msg, F_CIB_OBJID, id);\n    }\n\n    if (update != NULL) {\n        crm_trace(\"Setting type to update->name: %s\", crm_element_name(update));\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(update));\n\n    } else if (result_data != NULL) {\n        crm_trace(\"Setting type to new_obj->name: %s\", crm_element_name(result_data));\n        crm_xml_add(update_msg, F_CIB_OBJTYPE, crm_element_name(result_data));\n\n    } else {\n        crm_trace(\"Not Setting type\");\n    }\n\n    attach_cib_generation(update_msg, \"cib_generation\", the_cib);\n    if (update != NULL) {\n        add_message_xml(update_msg, F_CIB_UPDATE, update);\n    }\n    if (result_data != NULL) {\n        add_message_xml(update_msg, F_CIB_UPDATE_RESULT, result_data);\n    }\n\n    crm_trace(\"Notifying clients\");\n    g_hash_table_foreach_remove(client_list, cib_notify_client, update_msg);\n    free_xml(update_msg);\n    crm_trace(\"Notify complete\");\n}\n\nvoid\nattach_cib_generation(xmlNode * msg, const char *field, xmlNode * a_cib)\n{\n    xmlNode *generation = create_xml_node(NULL, XML_CIB_TAG_GENERATION_TUPPLE);\n\n    if (a_cib != NULL) {\n        copy_in_properties(generation, a_cib);\n    }\n    add_message_xml(msg, field, generation);\n    free_xml(generation);\n}\n\nvoid\ncib_replace_notify(const char *origin, xmlNode * update, int result, xmlNode * diff)\n{\n    xmlNode *replace_msg = NULL;\n\n    int add_updates = 0;\n    int add_epoch = 0;\n    int add_admin_epoch = 0;\n\n    int del_updates = 0;\n    int del_epoch = 0;\n    int del_admin_epoch = 0;\n\n    if (diff == NULL) {\n        return;\n    }\n\n    cib_diff_version_details(diff, &add_admin_epoch, &add_epoch, &add_updates,\n                             &del_admin_epoch, &del_epoch, &del_updates);\n\n    if(del_updates < 0) {\n        crm_log_xml_debug(diff, \"Bad replace diff\");\n    }\n\n    if (add_updates != del_updates) {\n        crm_info(\"Replaced: %d.%d.%d -> %d.%d.%d from %s\",\n                 del_admin_epoch, del_epoch, del_updates,\n                 add_admin_epoch, add_epoch, add_updates, crm_str(origin));\n    } else if (diff != NULL) {\n        crm_info(\"Local-only Replace: %d.%d.%d from %s\",\n                 add_admin_epoch, add_epoch, add_updates, crm_str(origin));\n    }\n\n    replace_msg = create_xml_node(NULL, \"notify-replace\");\n    crm_xml_add(replace_msg, F_TYPE, T_CIB_NOTIFY);\n    crm_xml_add(replace_msg, F_SUBTYPE, T_CIB_REPLACE_NOTIFY);\n    crm_xml_add(replace_msg, F_CIB_OPERATION, CIB_OP_REPLACE);\n    crm_xml_add_int(replace_msg, F_CIB_RC, result);\n    attach_cib_generation(replace_msg, \"cib-replace-generation\", update);\n\n    crm_log_xml_trace(replace_msg, \"CIB Replaced\");\n\n    g_hash_table_foreach_remove(client_list, cib_notify_client, replace_msg);\n    free_xml(replace_msg);\n}\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n#include <crm/crm.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\n#include <netinet/ip.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <glib.h>\n\n#include <crm/msg_xml.h>\n#include <crm/common/ipc.h>\n#include <crm/common/xml.h>\n#include <crm/cib/internal.h>\n\n#include \"callbacks.h\"\n/* #undef HAVE_PAM_PAM_APPL_H */\n/* #undef HAVE_GNUTLS_GNUTLS_H */\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\n#endif\n\n#include <pwd.h>\n#include <grp.h>\n#if HAVE_SECURITY_PAM_APPL_H\n#  include <security/pam_appl.h>\n#  define HAVE_PAM 1\n#else\n#  if HAVE_PAM_PAM_APPL_H\n#    include <pam/pam_appl.h>\n#    define HAVE_PAM 1\n#  endif\n#endif\n\nextern int remote_tls_fd;\nextern gboolean cib_shutdown_flag;\n\nint init_remote_listener(int port, gboolean encrypted);\nvoid cib_remote_connection_destroy(gpointer user_data);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  define DH_BITS 1024\ngnutls_dh_params dh_params;\ngnutls_anon_server_credentials anon_cred_s;\nstatic void\ndebug_log(int level, const char *str)\n{\n    fputs(str, stderr);\n}\n#endif\n\n#define REMOTE_AUTH_TIMEOUT 10000\n\nint num_clients;\nint authenticate_user(const char *user, const char *passwd);\nint cib_remote_listen(gpointer data);\nint cib_remote_msg(gpointer data);\n\nstatic void\nremote_connection_destroy(gpointer user_data)\n{\n    return;\n}\n\n#define ERROR_SUFFIX \"  Shutting down remote listener\"\nint\ninit_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n\n    if (port <= 0) {\n        /* dont start it */\n        return 0;\n    }\n\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n        /* gnutls_global_set_log_level (10); */\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n\n    /* create server socket */\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n\n    /* reuse address */\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n\n    /* bind server socket */\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n\n    return *ssock;\n}\n\nstatic int\ncheck_group_membership(const char *usr, const char *grp)\n{\n    int index = 0;\n    struct passwd *pwd = NULL;\n    struct group *group = NULL;\n\n    CRM_CHECK(usr != NULL, return FALSE);\n    CRM_CHECK(grp != NULL, return FALSE);\n\n    pwd = getpwnam(usr);\n    if (pwd == NULL) {\n        crm_err(\"No user named '%s' exists!\", usr);\n        return FALSE;\n    }\n\n    group = getgrgid(pwd->pw_gid);\n    if (group != NULL && crm_str_eq(grp, group->gr_name, TRUE)) {\n        return TRUE;\n    }\n\n    group = getgrnam(grp);\n    if (group == NULL) {\n        crm_err(\"No group named '%s' exists!\", grp);\n        return FALSE;\n    }\n\n    while (TRUE) {\n        char *member = group->gr_mem[index++];\n\n        if (member == NULL) {\n            break;\n\n        } else if (crm_str_eq(usr, member, TRUE)) {\n            return TRUE;\n        }\n    };\n\n    return FALSE;\n}\n\nstatic gboolean\ncib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n\n    /* Non-root daemons can only validate the password of the\n     * user they're running as\n     */\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\nstatic gboolean\nremote_auth_timeout_cb(gpointer data)\n{\n    cib_client_t *client = data;\n\n    client->remote_auth_timeout = 0;\n\n    if (client->remote_auth == TRUE) {\n        return FALSE;\n    }\n\n    mainloop_del_fd(client->remote);\n    crm_err(\"Remote client authentication timed out\");\n\n    return FALSE;\n}\nint\ncib_remote_listen(gpointer data)\n{\n    int csock = 0;\n    unsigned laddr;\n    struct sockaddr_in addr;\n    int ssock = *(int *)data;\n    int flag;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    gnutls_session *session = NULL;\n#endif\n    cib_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks remote_client_fd_callbacks = \n        {\n            .dispatch = cib_remote_msg,\n            .destroy = cib_remote_connection_destroy,\n        };\n\n    /* accept the connection */\n    laddr = sizeof(addr);\n    csock = accept(ssock, (struct sockaddr *)&addr, &laddr);\n    crm_debug(\"New %s connection from %s\",\n              ssock == remote_tls_fd ? \"secure\" : \"clear-text\", inet_ntoa(addr.sin_addr));\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err( \"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err( \"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        /* create gnutls session for the server socket */\n        session = crm_create_anon_tls_session(csock, GNUTLS_SERVER, anon_cred_s);\n        if (session == NULL) {\n            crm_err(\"TLS session creation failed\");\n            close(csock);\n            return TRUE;\n        }\n#endif\n    }\n\n    num_clients++;\n    new_client = calloc(1, sizeof(cib_client_t));\n    new_client->id = crm_generate_uuid();\n    new_client->callback_id = NULL;\n    /* clients have a few seconds to perform handshake. */\n    new_client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, new_client);\n\n    if (ssock == remote_tls_fd) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        new_client->encrypted = TRUE;\n        new_client->session = session;\n#endif\n    } else {\n        new_client->session = GINT_TO_POINTER(csock);\n    }\n\n    new_client->remote = mainloop_add_fd(\n        \"cib-remote-client\", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);\n\n    g_hash_table_insert(client_list, new_client->id, new_client);\n\n    return TRUE;\n}\n\nvoid\ncib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n    int csock = 0;\n\n    if (client == NULL) {\n        return;\n    }\n\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    if (client->remote_auth_timeout) {\n        g_source_remove(client->remote_auth_timeout);\n    }\n\n    if (client->encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (client->session) {\n            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n            csock = GPOINTER_TO_INT(sock_ptr);\n            if (client->handshake_complete) {\n                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n            }\n            gnutls_deinit(*client->session);\n            gnutls_free(client->session);\n        }\n#endif\n    } else {\n        csock = GPOINTER_TO_INT(client->session);\n    }\n    client->session = NULL;\n\n    if (csock > 0) {\n        close(csock);\n    }\n\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client->recv_buf);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}\n\nstatic void\ncib_handle_remote_msg(cib_client_t *client, xmlNode *command)\n{\n    const char *value = NULL;\n\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        return;\n    }\n\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n\n    /* unset dangerous options */\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n\n        /* fix the command */\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n}\n\nint\ncib_remote_msg(gpointer data)\n{\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    int disconnected = 0;\n    int timeout = client->remote_auth ? -1 : 1000;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (client->encrypted && (client->handshake_complete == FALSE)) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote cib tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote cib tls handshake completed\");\n            client->handshake_complete = TRUE;\n            if (client->remote_auth_timeout) {\n                g_source_remove(client->remote_auth_timeout);\n            }\n            /* after handshake, clients must send auth in a few seconds */\n            client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);\n        }\n        return 0;\n    }\n#endif\n\n    crm_recv_remote_msg(client->session, &client->recv_buf, client->encrypted, timeout, &disconnected);\n\n    /* must pass auth before we will process anything else */\n    if (client->remote_auth == FALSE) {\n        xmlNode *reg;\n#if ENABLE_ACL\n        const char *user = NULL;\n#endif\n        command = crm_parse_remote_buffer(&client->recv_buf);\n        if (cib_remote_auth(command) == FALSE) {\n            free_xml(command);\n            return -1;\n        }\n\n        crm_debug(\"remote connection authenticated successfully\");\n        client->remote_auth = TRUE;\n        g_source_remove(client->remote_auth_timeout);\n        client->remote_auth_timeout = 0;\n        client->name = crm_element_value_copy(command, \"name\");\n\n#if ENABLE_ACL\n        user = crm_element_value(command, \"user\");\n        if (user) {\n           new_client->user = strdup(user);\n        }\n#endif\n\n        /* send ACK */\n        reg = create_xml_node(NULL, \"cib_result\");\n        crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);\n        crm_xml_add(reg, F_CIB_CLIENTID, client->id);\n        crm_send_remote_msg(client->session, reg, client->encrypted);\n        free_xml(reg);\n        free_xml(command);\n    }\n\n    command = crm_parse_remote_buffer(&client->recv_buf);\n    while (command) {\n        crm_trace(\"command received\");\n        cib_handle_remote_msg(client, command);\n        free_xml(command);\n        command = crm_parse_remote_buffer(&client->recv_buf);\n    }\n\n    if (disconnected) {\n        crm_trace(\"disconnected while receiving remote cib msg.\");\n        return -1;\n    }\n\n    return 0;\n}\n\n#ifdef HAVE_PAM\n/* \n * Useful Examples:\n *    http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html\n *    http://developer.apple.com/samplecode/CryptNoMore/index.html\n */\nstatic int\nconstruct_pam_passwd(int num_msg, const struct pam_message **msg,\n                     struct pam_response **response, void *data)\n{\n    int count = 0;\n    struct pam_response *reply;\n    char *string = (char *)data;\n\n    CRM_CHECK(data, return PAM_CONV_ERR);\n    CRM_CHECK(num_msg == 1, return PAM_CONV_ERR);       /* We only want to handle one message */\n\n    reply = calloc(1, sizeof(struct pam_response));\n    CRM_ASSERT(reply != NULL);\n\n    for (count = 0; count < num_msg; ++count) {\n        switch (msg[count]->msg_style) {\n            case PAM_TEXT_INFO:\n                crm_info(\"PAM: %s\\n\", msg[count]->msg);\n                break;\n            case PAM_PROMPT_ECHO_OFF:\n            case PAM_PROMPT_ECHO_ON:\n                reply[count].resp_retcode = 0;\n                reply[count].resp = string;     /* We already made a copy */\n            case PAM_ERROR_MSG:\n                /* In theory we'd want to print this, but then\n                 * we see the password prompt in the logs\n                 */\n                /* crm_err(\"PAM error: %s\\n\", msg[count]->msg); */\n                break;\n            default:\n                crm_err(\"Unhandled conversation type: %d\", msg[count]->msg_style);\n                goto bail;\n        }\n    }\n\n    *response = reply;\n    reply = NULL;\n\n    return PAM_SUCCESS;\n\n  bail:\n    for (count = 0; count < num_msg; ++count) {\n        if (reply[count].resp != NULL) {\n            switch (msg[count]->msg_style) {\n                case PAM_PROMPT_ECHO_ON:\n                case PAM_PROMPT_ECHO_OFF:\n                    /* Erase the data - it contained a password */\n                    while (*(reply[count].resp)) {\n                        *(reply[count].resp)++ = '\\0';\n                    }\n                    free(reply[count].resp);\n                    break;\n            }\n            reply[count].resp = NULL;\n        }\n    }\n    free(reply);\n    reply = NULL;\n\n    return PAM_CONV_ERR;\n}\n#endif\n\nint\nauthenticate_user(const char *user, const char *passwd)\n{\n#ifndef HAVE_PAM\n    gboolean pass = TRUE;\n#else\n    int rc = 0;\n    gboolean pass = FALSE;\n    const void *p_user = NULL;\n\n    struct pam_conv p_conv;\n    struct pam_handle *pam_h = NULL;\n    static const char *pam_name = NULL;\n\n    if (pam_name == NULL) {\n        pam_name = getenv(\"CIB_pam_service\");\n    }\n    if (pam_name == NULL) {\n        pam_name = \"login\";\n    }\n\n    p_conv.conv = construct_pam_passwd;\n    p_conv.appdata_ptr = strdup(passwd);\n\n    rc = pam_start(pam_name, user, &p_conv, &pam_h);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Could not initialize PAM: %s (%d)\", pam_strerror(pam_h, rc), rc);\n        goto bail;\n    }\n\n    rc = pam_authenticate(pam_h, 0);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Authentication failed for %s: %s (%d)\", user, pam_strerror(pam_h, rc), rc);\n        goto bail;\n    }\n\n    /* Make sure we authenticated the user we wanted to authenticate.\n     * Since we also run as non-root, it might be worth pre-checking\n     * the user has the same EID as us, since that the only user we\n     * can authenticate.\n     */\n    rc = pam_get_item(pam_h, PAM_USER, &p_user);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Internal PAM error: %s (%d)\", pam_strerror(pam_h, rc), rc);\n        goto bail;\n\n    } else if (p_user == NULL) {\n        crm_err(\"Unknown user authenticated.\");\n        goto bail;\n\n    } else if (safe_str_neq(p_user, user)) {\n        crm_err(\"User mismatch: %s vs. %s.\", (const char *)p_user, (const char *)user);\n        goto bail;\n    }\n\n    rc = pam_acct_mgmt(pam_h, 0);\n    if (rc != PAM_SUCCESS) {\n        crm_err(\"Access denied: %s (%d)\", pam_strerror(pam_h, rc), rc);\n        goto bail;\n    }\n    pass = TRUE;\n\n  bail:\n    rc = pam_end(pam_h, rc);\n#endif\n    return pass;\n}\n", "/* crm_internal.h */\n\n/* \n * Copyright (C) 2006 - 2008\n *     Andrew Beekhof <andrew@beekhof.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef CRM_INTERNAL__H\n#  define CRM_INTERNAL__H\n\n#  include <config.h>\n#  include <portability.h>\n\n#  include <glib.h>\n#  include <stdbool.h>\n#  include <libxml/tree.h>\n\n#  include <crm/lrmd.h>\n#  include <crm/common/logging.h>\n\n/* Dynamic loading of libraries */\nvoid *find_library_function(void **handle, const char *lib, const char *fn, int fatal);\nvoid *convert_const_pointer(const void *ptr);\n\n/* For ACLs */\nchar *uid2username(uid_t uid);\nvoid determine_request_user(char *user, xmlNode * request, const char *field);\n\n#  if ENABLE_ACL\n#    include <string.h>\nstatic inline gboolean\nis_privileged(const char *user)\n{\n    if (user == NULL) {\n        return FALSE;\n    } else if (strcmp(user, CRM_DAEMON_USER) == 0) {\n        return TRUE;\n    } else if (strcmp(user, \"root\") == 0) {\n        return TRUE;\n    }\n    return FALSE;\n}\n#  endif\n\n/* CLI option processing*/\n#  ifdef HAVE_GETOPT_H\n#    include <getopt.h>\n#  else\n#    define no_argument 0\n#    define required_argument 1\n#  endif\n\n#  define pcmk_option_default\t0x00000\n#  define pcmk_option_hidden\t0x00001\n#  define pcmk_option_paragraph\t0x00002\n#  define pcmk_option_example\t0x00004\n\nstruct crm_option {\n    /* Fields from 'struct option' in getopt.h */\n    /* name of long option */\n    const char *name;\n    /*\n     * one of no_argument, required_argument, and optional_argument:\n     * whether option takes an argument\n     */\n    int has_arg;\n    /* if not NULL, set *flag to val when option found */\n    int *flag;\n    /* if flag not NULL, value to set *flag to; else return value */\n    int val;\n\n    /* Custom fields */\n    const char *desc;\n    long flags;\n};\n\nvoid crm_set_options(const char *short_options, const char *usage, struct crm_option *long_options, const char *app_desc);\nint crm_get_option(int argc, char **argv, int *index);\nint crm_get_option_long(int argc, char **argv, int *index, const char **longname);\nvoid crm_help(char cmd, int exit_code);\n\n/* Cluster Option Processing */\ntypedef struct pe_cluster_option_s {\n    const char *name;\n    const char *alt_name;\n    const char *type;\n    const char *values;\n    const char *default_value;\n\n     gboolean(*is_valid) (const char *);\n\n    const char *description_short;\n    const char *description_long;\n\n} pe_cluster_option;\n\nconst char *cluster_option(GHashTable * options, gboolean(*validate) (const char *),\n                           const char *name, const char *old_name, const char *def_value);\n\nconst char *get_cluster_pref(GHashTable * options, pe_cluster_option * option_list, int len, const char *name);\n\nvoid config_metadata(const char *name, const char *version, const char *desc_short,\n                     const char *desc_long, pe_cluster_option * option_list, int len);\n\nvoid verify_all_options(GHashTable * options, pe_cluster_option * option_list, int len);\ngboolean check_time(const char *value);\ngboolean check_timer(const char *value);\ngboolean check_boolean(const char *value);\ngboolean check_number(const char *value);\n\n/* Shared PE/crmd functionality */\nvoid filter_action_parameters(xmlNode * param_set, const char *version);\nvoid filter_reload_parameters(xmlNode * param_set, const char *restart_string);\n\n/* Resource operation updates */\nxmlNode *create_operation_update(xmlNode * parent, lrmd_event_data_t *event, const char *caller_version,\n                                 int target_rc, const char *origin, int level);\n\n/* char2score */\nextern int node_score_red;\nextern int node_score_green;\nextern int node_score_yellow;\nextern int node_score_infinity;\n\n\n/* Assorted convenience functions */\nstatic inline int\ncrm_strlen_zero(const char *s)\n{\n    return !s || *s == '\\0';\n}\n\nchar *add_list_element(char *list, const char *value);\nchar *generate_series_filename(const char *directory, const char *series, int sequence, gboolean bzip);\nint get_last_sequence(const char *directory, const char *series);\nvoid write_last_sequence(const char *directory, const char *series, int sequence, int max);\n\nint crm_pid_active(long pid);\nvoid crm_make_daemon(const char *name, gboolean daemonize, const char *pidfile);\ngboolean crm_is_writable(const char *dir, const char *file, const char *user, const char *group, gboolean need_both);\n\nchar *generate_op_key(const char *rsc_id, const char *op_type, int interval);\nchar *generate_notify_key(const char *rsc_id, const char *notify_type, const char *op_type);\nchar *generate_transition_magic_v202(const char *transition_key, int op_status);\nchar *generate_transition_magic(const char *transition_key, int op_status, int op_rc);\nchar *generate_transition_key(int action, int transition_id, int target_rc, const char *node);\n\nstatic inline long long\ncrm_clear_bit(const char *function, const char *target, long long word, long long bit)\n{\n    long long rc = (word & ~bit);\n\n    if(rc == word) {\n        /* Unchanged */\n    } else if (target) {\n        crm_trace(\"Bit 0x%.8llx for %s cleared by %s\", bit, target, function);\n    } else {\n        crm_trace(\"Bit 0x%.8llx cleared by %s\", bit, function);\n    }\n\n    return rc;\n}\n\nstatic inline long long\ncrm_set_bit(const char *function, const char *target, long long word, long long bit)\n{\n    long long rc = (word|bit);\n\n    if(rc == word) {\n        /* Unchanged */\n    } else if (target) {\n        crm_trace(\"Bit 0x%.8llx for %s set by %s\", bit, target, function);\n    } else {\n        crm_trace(\"Bit 0x%.8llx set by %s\", bit, function);\n    }\n\n    return rc;\n}\n\n#  define set_bit(word, bit) word = crm_set_bit(__PRETTY_FUNCTION__, NULL, word, bit)\n#  define clear_bit(word, bit) word = crm_clear_bit(__PRETTY_FUNCTION__, NULL, word, bit)\n\nvoid g_hash_destroy_str(gpointer data);\n\nlong long crm_int_helper(const char *text, char **end_text);\nchar *crm_concat(const char *prefix, const char *suffix, char join);\nchar *generate_hash_key(const char *crm_msg_reference, const char *sys);\n\n\n/*! remote tcp/tls helper functions */\ngboolean crm_recv_remote_msg(void *session, char **recv_buf, gboolean encrypted, int total_timeout_ms, int *disconnected);\nchar *crm_recv_remote_raw(void *data, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected);\nint crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted);\nint crm_recv_remote_ready(void *session, gboolean encrypted, int timeout_ms);\nxmlNode *crm_parse_remote_buffer(char **msg_buf);\nint crm_remote_tcp_connect(const char *host, int port);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n/*!\n * \\internal\n * \\brief Initiate the client handshake after establishing the tcp socket.\n * \\note This is a blocking function, it will block until the entire handshake\n *       is complete or until the timeout period is reached.\n * \\retval 0 success\n * \\retval negative, failure\n */\nint crm_initiate_client_tls_handshake(void *session_data, int timeout_ms);\n/*!\n * \\internal\n * \\brief Create client or server session for anon DH encryption credentials\n * \\param sock, the socket the session will use for transport\n * \\param type, GNUTLS_SERVER or GNUTLS_CLIENT\n * \\param credentials, gnutls_anon_server_credentials_t or gnutls_anon_client_credentials_t\n *\n * \\retval gnutls_session * on success\n * \\retval NULL on failure\n */\nvoid *crm_create_anon_tls_session(int sock, int type, void *credentials);\n#endif\n\n#define REMOTE_MSG_TERMINATOR \"\\r\\n\\r\\n\"\n\nconst char *daemon_option(const char *option);\nvoid set_daemon_option(const char *option, const char *value);\ngboolean daemon_option_enabled(const char *daemon, const char *option);\nvoid strip_text_nodes(xmlNode *xml);\n\n#  define crm_config_err(fmt...) { crm_config_error = TRUE; crm_err(fmt); }\n#  define crm_config_warn(fmt...) { crm_config_warning = TRUE; crm_warn(fmt); }\n\n#  define attrd_channel\t\tT_ATTRD\n#  define F_ATTRD_KEY\t\t\"attr_key\"\n#  define F_ATTRD_ATTRIBUTE\t\"attr_name\"\n#  define F_ATTRD_TASK\t\t\"task\"\n#  define F_ATTRD_VALUE\t\t\"attr_value\"\n#  define F_ATTRD_SET\t\t\"attr_set\"\n#  define F_ATTRD_SECTION\t\"attr_section\"\n#  define F_ATTRD_DAMPEN\t\"attr_dampening\"\n#  define F_ATTRD_IGNORE_LOCALLY \"attr_ignore_locally\"\n#  define F_ATTRD_HOST\t\t\"attr_host\"\n#  define F_ATTRD_USER\t\t\"attr_user\"\n\n#  if SUPPORT_COROSYNC\n#    if CS_USES_LIBQB\n#      include <qb/qbipc_common.h>\n#      include <corosync/corotypes.h>\ntypedef struct qb_ipc_request_header cs_ipc_header_request_t;\ntypedef struct qb_ipc_response_header cs_ipc_header_response_t;\n#    else\n#      include <corosync/corodefs.h>\n#      include <corosync/coroipcc.h>\n#      include <corosync/coroipc_types.h>\nstatic inline int\nqb_to_cs_error(int a)\n{\n    return a;\n}\n\ntypedef coroipc_request_header_t cs_ipc_header_request_t;\ntypedef coroipc_response_header_t cs_ipc_header_response_t;\n#    endif\n#  else\ntypedef struct {\n    int size __attribute__ ((aligned(8)));\n    int id __attribute__ ((aligned(8)));\n} __attribute__ ((aligned(8))) cs_ipc_header_request_t;\n\ntypedef struct {\n    int size __attribute__ ((aligned(8)));\n    int id __attribute__ ((aligned(8)));\n    int error __attribute__ ((aligned(8)));\n} __attribute__ ((aligned(8))) cs_ipc_header_response_t;\n\n#  endif\n\n#endif                          /* CRM_INTERNAL__H */\n", "/*\n * Copyright (c) 2008 Andrew Beekhof\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n#include <crm_internal.h>\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <netdb.h>\n#include <termios.h>\n#include <sys/socket.h>\n\n#include <glib.h>\n\n#include <crm/crm.h>\n#include <crm/cib/internal.h>\n#include <crm/msg_xml.h>\n#include <crm/common/ipc.h>\n#include <crm/common/mainloop.h>\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\ngnutls_anon_client_credentials anon_cred_c;\n#define DEFAULT_CLIENT_HANDSHAKE_TIMEOUT 5000 /* 5 seconds */\n\nconst int kx_prio[] = {\n    GNUTLS_KX_ANON_DH,\n    0\n};\n\nstatic gboolean remote_gnutls_credentials_init = FALSE;\n#else\ntypedef void gnutls_session;\n#endif\n\n#include <arpa/inet.h>\n#include <sgtty.h>\n\n#define DH_BITS 1024\n\nstruct remote_connection_s {\n    int socket;\n    gboolean encrypted;\n    gnutls_session *session;\n    mainloop_io_t *source;\n    char *token;\n    char *recv_buf;\n};\n\ntypedef struct cib_remote_opaque_s {\n    int flags;\n    int socket;\n    int port;\n    char *server;\n    char *user;\n    char *passwd;\n    struct remote_connection_s command;\n    struct remote_connection_s callback;\n\n} cib_remote_opaque_t;\n\nvoid cib_remote_connection_destroy(gpointer user_data);\nint cib_remote_callback_dispatch(gpointer user_data);\nint cib_remote_command_dispatch(gpointer user_data);\nint cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type);\nint cib_remote_signoff(cib_t * cib);\nint cib_remote_free(cib_t * cib);\n\nint cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                          xmlNode * data, xmlNode ** output_data, int call_options, const char *name);\n\nstatic int\ncib_remote_inputfd(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    return private->callback.socket;\n}\n\nstatic int\ncib_remote_set_connection_dnotify(cib_t * cib, void (*dnotify) (gpointer user_data))\n{\n    return -EPROTONOSUPPORT;\n}\n\nstatic int\ncib_remote_register_notification(cib_t * cib, const char *callback, int enabled)\n{\n    xmlNode *notify_msg = create_xml_node(NULL, \"cib_command\");\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    crm_xml_add(notify_msg, F_CIB_OPERATION, T_CIB_NOTIFY);\n    crm_xml_add(notify_msg, F_CIB_NOTIFY_TYPE, callback);\n    crm_xml_add_int(notify_msg, F_CIB_NOTIFY_ACTIVATE, enabled);\n    crm_send_remote_msg(private->callback.session, notify_msg, private->callback.encrypted);\n    free_xml(notify_msg);\n    return pcmk_ok;\n}\n\ncib_t *\ncib_remote_new(const char *server, const char *user, const char *passwd, int port,\n               gboolean encrypted)\n{\n    cib_remote_opaque_t *private = NULL;\n    cib_t *cib = cib_new_variant();\n\n    private = calloc(1, sizeof(cib_remote_opaque_t));\n\n    cib->variant = cib_remote;\n    cib->variant_opaque = private;\n\n    if (server) {\n        private->server = strdup(server);\n    }\n\n    if (user) {\n        private->user = strdup(user);\n    }\n\n    if (passwd) {\n        private->passwd = strdup(passwd);\n    }\n\n    private->port = port;\n    private->command.encrypted = encrypted;\n    private->callback.encrypted = encrypted;\n\n    /* assign variant specific ops */\n    cib->delegate_fn = cib_remote_perform_op;\n    cib->cmds->signon = cib_remote_signon;\n    cib->cmds->signoff = cib_remote_signoff;\n    cib->cmds->free = cib_remote_free;\n    cib->cmds->inputfd = cib_remote_inputfd;\n\n    cib->cmds->register_notification = cib_remote_register_notification;\n    cib->cmds->set_connection_dnotify = cib_remote_set_connection_dnotify;\n\n    return cib;\n}\n\nstatic int\ncib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        if (private->command.session) {\n            gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n            gnutls_deinit(*(private->command.session));\n            gnutls_free(private->command.session);\n        }\n\n        if (private->callback.session) {\n            gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n            gnutls_deinit(*(private->callback.session));\n            gnutls_free(private->callback.session);\n        }\n        private->command.session = NULL;\n        private->callback.session = NULL;\n        if (remote_gnutls_credentials_init) {\n            gnutls_anon_free_client_credentials(anon_cred_c);\n            gnutls_global_deinit();\n            remote_gnutls_credentials_init = FALSE;\n        }\n    }\n#endif\n\n    if (private->command.socket) {\n        shutdown(private->command.socket, SHUT_RDWR);       /* no more receptions */\n        close(private->command.socket);\n    }\n    if (private->callback.socket) {\n        shutdown(private->callback.socket, SHUT_RDWR);      /* no more receptions */\n        close(private->callback.socket);\n    }\n    private->command.socket = 0;\n    private->callback.socket = 0;\n\n    free(private->command.recv_buf);\n    free(private->callback.recv_buf);\n    private->command.recv_buf = NULL;\n    private->callback.recv_buf = NULL;\n\n    return 0;\n}\n\nstatic int\ncib_tls_signon(cib_t * cib, struct remote_connection_s *connection, gboolean event_channel)\n{\n    int sock;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    int rc = 0;\n    int disconnected = 0;\n\n    xmlNode *answer = NULL;\n    xmlNode *login = NULL;\n\n    static struct mainloop_fd_callbacks cib_fd_callbacks = { 0, };\n\n    cib_fd_callbacks.dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch;\n    cib_fd_callbacks.destroy = cib_remote_connection_destroy;\n\n    connection->socket = 0;\n    connection->session = NULL;\n\n    sock = crm_remote_tcp_connect(private->server, private->port);\n    if (sock <= 0) {\n        crm_perror(LOG_ERR, \"remote tcp connection to %s:%d failed\", private->server, private->port);\n    }\n\n    connection->socket = sock;\n    if (connection->encrypted) {\n        /* initialize GnuTls lib */\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (remote_gnutls_credentials_init == FALSE) {\n            gnutls_global_init();\n            gnutls_anon_allocate_client_credentials(&anon_cred_c);\n            remote_gnutls_credentials_init = TRUE;\n        }\n\n        /* bind the socket to GnuTls lib */\n        connection->session = crm_create_anon_tls_session(sock, GNUTLS_CLIENT, anon_cred_c);\n\n        if (crm_initiate_client_tls_handshake(connection->session, DEFAULT_CLIENT_HANDSHAKE_TIMEOUT) != 0) {\n            crm_err(\"Session creation for %s:%d failed\", private->server, private->port);\n\n            gnutls_deinit(*connection->session);\n            gnutls_free(connection->session);\n            connection->session = NULL;\n            cib_tls_close(cib);\n            return -1;\n        }\n#else\n        return -EPROTONOSUPPORT;\n#endif\n    } else {\n        connection->session = GUINT_TO_POINTER(sock);\n    }\n\n    /* login to server */\n    login = create_xml_node(NULL, \"cib_command\");\n    crm_xml_add(login, \"op\", \"authenticate\");\n    crm_xml_add(login, \"user\", private->user);\n    crm_xml_add(login, \"password\", private->passwd);\n    crm_xml_add(login, \"hidden\", \"password\");\n\n    crm_send_remote_msg(connection->session, login, connection->encrypted);\n    free_xml(login);\n\n    crm_recv_remote_msg(connection->session, &connection->recv_buf, connection->encrypted, -1, &disconnected);\n\n    if (disconnected) {\n        rc = -ENOTCONN;\n    }\n\n    answer = crm_parse_remote_buffer(&connection->recv_buf);\n\n    crm_log_xml_trace(answer, \"Reply\");\n    if (answer == NULL) {\n        rc = -EPROTO;\n\n    } else {\n        /* grab the token */\n        const char *msg_type = crm_element_value(answer, F_CIB_OPERATION);\n        const char *tmp_ticket = crm_element_value(answer, F_CIB_CLIENTID);\n\n        if (safe_str_neq(msg_type, CRM_OP_REGISTER)) {\n            crm_err(\"Invalid registration message: %s\", msg_type);\n            rc = -EPROTO;\n\n        } else if (tmp_ticket == NULL) {\n            rc = -EPROTO;\n\n        } else {\n            connection->token = strdup(tmp_ticket);\n        }\n    }\n    free_xml(answer);\n    answer = NULL;\n\n    if (rc != 0) {\n        cib_tls_close(cib);\n        return rc;\n    }\n\n    crm_trace(\"remote client connection established\");\n    connection->source = mainloop_add_fd(\"cib-remote\", G_PRIORITY_HIGH, connection->socket, cib, &cib_fd_callbacks);\n    return rc;\n}\n\nvoid\ncib_remote_connection_destroy(gpointer user_data)\n{\n    crm_err(\"Connection destroyed\");\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    cib_tls_close(user_data);\n#endif\n    return;\n}\n\nint\ncib_remote_command_dispatch(gpointer user_data)\n{\n    int disconnected = 0;\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n\n    free(private->command.recv_buf);\n    private->command.recv_buf = NULL;\n    crm_err(\"received late reply for remote cib connection, discarding\");\n\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}\n\nint\ncib_remote_callback_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    xmlNode *msg = NULL;\n    int disconnected = 0;\n\n    crm_info(\"Message on callback channel\");\n\n    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n\n    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    while (msg) {\n        const char *type = crm_element_value(msg, F_TYPE);\n        crm_trace(\"Activating %s callbacks...\", type);\n\n        if (safe_str_eq(type, T_CIB)) {\n            cib_native_callback(cib, msg, 0, 0);\n\n        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n\n        } else {\n            crm_err(\"Unknown message type: %s\", type);\n        }\n\n        free_xml(msg);\n        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    }\n\n    if (disconnected) {\n        return -1;\n    }\n\n    return 0;\n}\n\nint\ncib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        /* fprintf(stderr, \"entered: '%s'\\n\", buffer); */\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command), FALSE);\n    }\n\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback), TRUE);\n    }\n\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n\n    return rc;\n}\n\nint\ncib_remote_signoff(cib_t * cib)\n{\n    int rc = pcmk_ok;\n\n    /* cib_remote_opaque_t *private = cib->variant_opaque; */\n\n    crm_debug(\"Signing out of the CIB Service\");\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    cib_tls_close(cib);\n#endif\n\n    cib->state = cib_disconnected;\n    cib->type = cib_none;\n\n    return rc;\n}\n\nint\ncib_remote_free(cib_t * cib)\n{\n    int rc = pcmk_ok;\n\n    crm_warn(\"Freeing CIB\");\n    if (cib->state != cib_disconnected) {\n        rc = cib_remote_signoff(cib);\n        if (rc == pcmk_ok) {\n            cib_remote_opaque_t *private = cib->variant_opaque;\n\n            free(private->server);\n            free(private->user);\n            free(private->passwd);\n            free(cib->cmds);\n            free(private);\n            free(cib);\n        }\n    }\n\n    return rc;\n}\n\nint\ncib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                      xmlNode * data, xmlNode ** output_data, int call_options, const char *name)\n{\n    int rc = pcmk_ok;\n    int disconnected = 0;\n    int remaining_time = 0;\n    time_t start_time;\n\n    xmlNode *op_msg = NULL;\n    xmlNode *op_reply = NULL;\n\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    if (cib->state == cib_disconnected) {\n        return -ENOTCONN;\n    }\n\n    if (output_data != NULL) {\n        *output_data = NULL;\n    }\n\n    if (op == NULL) {\n        crm_err(\"No operation specified\");\n        return -EINVAL;\n    }\n\n    cib->call_id++;\n    /* prevent call_id from being negative (or zero) and conflicting\n     *    with the cib_errors enum\n     * use 2 because we use it as (cib->call_id - 1) below\n     */\n    if (cib->call_id < 1) {\n        cib->call_id = 1;\n    }\n\n    op_msg =\n        cib_create_op(cib->call_id, private->callback.token, op, host, section, data, call_options,\n                      NULL);\n    if (op_msg == NULL) {\n        return -EPROTO;\n    }\n\n    crm_trace(\"Sending %s message to CIB service\", op);\n    if (!(call_options & cib_sync_call)) {\n        crm_send_remote_msg(private->callback.session, op_msg, private->command.encrypted);\n    } else {\n        crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);\n    }\n    free_xml(op_msg);\n\n    if ((call_options & cib_discard_reply)) {\n        crm_trace(\"Discarding reply\");\n        return pcmk_ok;\n\n    } else if (!(call_options & cib_sync_call)) {\n        return cib->call_id;\n    }\n\n    crm_trace(\"Waiting for a syncronous reply\");\n\n    start_time = time(NULL);\n    remaining_time = cib->call_timeout ? cib->call_timeout : 60;\n\n    while (remaining_time > 0 && !disconnected) {\n        int reply_id = -1;\n        int msg_id = cib->call_id;\n\n        crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, remaining_time * 1000, &disconnected);\n        op_reply = crm_parse_remote_buffer(&private->command.recv_buf);\n\n        if (!op_reply) {\n            break;\n        }\n\n        crm_element_value_int(op_reply, F_CIB_CALLID, &reply_id);\n\n        if (reply_id == msg_id) {\n            break;\n\n        } else if (reply_id < msg_id) {\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n\n        } else if ((reply_id - 10000) > msg_id) {\n            /* wrap-around case */\n            crm_debug(\"Received old reply: %d (wanted %d)\", reply_id, msg_id);\n            crm_log_xml_trace(op_reply, \"Old reply\");\n        } else {\n            crm_err(\"Received a __future__ reply:\" \" %d (wanted %d)\", reply_id, msg_id);\n        }\n\n        free_xml(op_reply);\n        op_reply = NULL;\n\n        /* wasn't the right reply, try and read some more */\n        remaining_time = time(NULL) - start_time;\n    }\n\n    /* if(IPC_ISRCONN(native->command_channel) == FALSE) { */\n    /*      crm_err(\"CIB disconnected: %d\",  */\n    /*              native->command_channel->ch_status); */\n    /*      cib->state = cib_disconnected; */\n    /* } */\n\n    if (disconnected) {\n        crm_err(\"Disconnected while waiting for reply.\");\n        return -ENOTCONN;\n    } else if (op_reply == NULL) {\n        crm_err(\"No reply message - empty\");\n        return -ENOMSG;\n    }\n\n    crm_trace(\"Syncronous reply received\");\n\n    /* Start processing the reply... */\n    if (crm_element_value_int(op_reply, F_CIB_RC, &rc) != 0) {\n        rc = -EPROTO;\n    }\n\n    if (rc == -pcmk_err_diff_resync) {\n        /* This is an internal value that clients do not and should not care about */\n        rc = pcmk_ok;\n    }\n\n    if (rc == pcmk_ok || rc == -EPERM) {\n        crm_log_xml_debug(op_reply, \"passed\");\n\n    } else {\n/* \t} else if(rc == -ETIME) { */\n        crm_err(\"Call failed: %s\", pcmk_strerror(rc));\n        crm_log_xml_warn(op_reply, \"failed\");\n    }\n\n    if (output_data == NULL) {\n        /* do nothing more */\n\n    } else if (!(call_options & cib_discard_reply)) {\n        xmlNode *tmp = get_message_xml(op_reply, F_CIB_CALLDATA);\n\n        if (tmp == NULL) {\n            crm_trace(\"No output in reply to \\\"%s\\\" command %d\", op, cib->call_id - 1);\n        } else {\n            *output_data = copy_xml(tmp);\n        }\n    }\n\n    free_xml(op_reply);\n\n    return rc;\n}\n", "/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#ifndef _GNU_SOURCE\n#  define _GNU_SOURCE\n#endif\n\n#include <stdlib.h>\n#include <signal.h>\n#include <errno.h>\n\n#include <sys/wait.h>\n\n#include <crm/crm.h>\n#include <crm/common/xml.h>\n#include <crm/common/mainloop.h>\n#include <crm/common/ipc.h>\n\nstruct mainloop_child_s {\n    pid_t     pid;\n    char     *desc;\n    unsigned  timerid;\n    unsigned  watchid;\n    gboolean  timeout;\n    void     *privatedata;\n\n    /* Called when a process dies */\n    void (*callback)(mainloop_child_t* p, int status, int signo, int exitcode);\n};\n\nstruct trigger_s {\n    GSource source;\n    gboolean running;\n    gboolean trigger;\n    void *user_data;\n    guint id;\n\n};\n\nstatic gboolean\ncrm_trigger_prepare(GSource * source, gint * timeout)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    /* cluster-glue's FD and IPC related sources make use of\n     * g_source_add_poll() but do not set a timeout in their prepare\n     * functions\n     *\n     * This means mainloop's poll() will block until an event for one\n     * of these sources occurs - any /other/ type of source, such as\n     * this one or g_idle_*, that doesn't use g_source_add_poll() is\n     * S-O-L and wont be processed until there is something fd-based\n     * happens.\n     *\n     * Luckily the timeout we can set here affects all sources and\n     * puts an upper limit on how long poll() can take.\n     *\n     * So unconditionally set a small-ish timeout, not too small that\n     * we're in constant motion, which will act as an upper bound on\n     * how long the signal handling might be delayed for.\n     */\n    *timeout = 500;             /* Timeout in ms */\n\n    return trig->trigger;\n}\n\nstatic gboolean\ncrm_trigger_check(GSource * source)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    return trig->trigger;\n}\n\nstatic gboolean\ncrm_trigger_dispatch(GSource * source, GSourceFunc callback, gpointer userdata)\n{\n    int rc = TRUE;\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    if(trig->running) {\n        /* Wait until the existing job is complete before starting the next one */\n        return TRUE;\n    }\n    trig->trigger = FALSE;\n\n    if (callback) {\n        rc = callback(trig->user_data);\n        if(rc < 0) {\n            crm_trace(\"Trigger handler %p not yet complete\", trig);\n            trig->running = TRUE;\n            rc = TRUE;\n        }\n    }\n    return rc;\n}\n\nstatic GSourceFuncs crm_trigger_funcs = {\n    crm_trigger_prepare,\n    crm_trigger_check,\n    crm_trigger_dispatch,\n    NULL\n};\n\nstatic crm_trigger_t *\nmainloop_setup_trigger(GSource * source, int priority, int(*dispatch) (gpointer user_data),\n                       gpointer userdata)\n{\n    crm_trigger_t *trigger = NULL;\n\n    trigger = (crm_trigger_t *) source;\n\n    trigger->id = 0;\n    trigger->trigger = FALSE;\n    trigger->user_data = userdata;\n\n    if (dispatch) {\n        g_source_set_callback(source, dispatch, trigger, NULL);\n    }\n\n    g_source_set_priority(source, priority);\n    g_source_set_can_recurse(source, FALSE);\n\n    trigger->id = g_source_attach(source, NULL);\n    return trigger;\n}\n\nvoid\nmainloop_trigger_complete(crm_trigger_t *trig) \n{\n    crm_trace(\"Trigger handler %p complete\", trig);\n    trig->running = FALSE;\n}\n\n/* If dispatch returns:\n *  -1: Job running but not complete\n *   0: Remove the trigger from mainloop\n *   1: Leave the trigger in mainloop\n */\ncrm_trigger_t *\nmainloop_add_trigger(int priority, int(*dispatch) (gpointer user_data), gpointer userdata)\n{\n    GSource *source = NULL;\n\n    CRM_ASSERT(sizeof(crm_trigger_t) > sizeof(GSource));\n    source = g_source_new(&crm_trigger_funcs, sizeof(crm_trigger_t));\n    CRM_ASSERT(source != NULL);\n\n    return mainloop_setup_trigger(source, priority, dispatch, userdata);\n}\n\nvoid\nmainloop_set_trigger(crm_trigger_t * source)\n{\n    source->trigger = TRUE;\n}\n\ngboolean\nmainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n        source->id = 0;\n    }\n    return TRUE;\n}\n\ntypedef struct signal_s {\n    crm_trigger_t trigger;      /* must be first */\n    void (*handler) (int sig);\n    int signal;\n\n} crm_signal_t;\n\nstatic crm_signal_t *crm_signals[NSIG];\n\nstatic gboolean\ncrm_signal_dispatch(GSource * source, GSourceFunc callback, gpointer userdata)\n{\n    crm_signal_t *sig = (crm_signal_t *) source;\n\n    crm_info(\"Invoking handler for signal %d: %s\", sig->signal, strsignal(sig->signal));\n\n    sig->trigger.trigger = FALSE;\n    if (sig->handler) {\n        sig->handler(sig->signal);\n    }\n    return TRUE;\n}\n\nstatic void\nmainloop_signal_handler(int sig)\n{\n    if (sig > 0 && sig < NSIG && crm_signals[sig] != NULL) {\n        mainloop_set_trigger((crm_trigger_t *) crm_signals[sig]);\n    }\n}\n\nstatic GSourceFuncs crm_signal_funcs = {\n    crm_trigger_prepare,\n    crm_trigger_check,\n    crm_signal_dispatch,\n    NULL\n};\n\ngboolean\ncrm_signal(int sig, void (*dispatch) (int sig))\n{\n    sigset_t mask;\n    struct sigaction sa;\n    struct sigaction old;\n\n    if (sigemptyset(&mask) < 0) {\n        crm_perror(LOG_ERR, \"Call to sigemptyset failed\");\n        return FALSE;\n    }\n\n    memset(&sa, 0, sizeof(struct sigaction));\n    sa.sa_handler = dispatch;\n    sa.sa_flags = SA_RESTART;\n    sa.sa_mask = mask;\n\n    if (sigaction(sig, &sa, &old) < 0) {\n        crm_perror(LOG_ERR, \"Could not install signal handler for signal %d\", sig);\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\ngboolean\nmainloop_add_signal(int sig, void (*dispatch) (int sig))\n{\n    GSource *source = NULL;\n    int priority = G_PRIORITY_HIGH - 1;\n\n    if (sig == SIGTERM) {\n        /* TERM is higher priority than other signals,\n         *   signals are higher priority than other ipc.\n         * Yes, minus: smaller is \"higher\"\n         */\n        priority--;\n    }\n\n    if (sig >= NSIG || sig < 0) {\n        crm_err(\"Signal %d is out of range\", sig);\n        return FALSE;\n\n    } else if (crm_signals[sig] != NULL\n               && crm_signals[sig]->handler == dispatch) {\n        crm_trace(\"Signal handler for %d is already installed\", sig);\n        return TRUE;\n\n    } else if (crm_signals[sig] != NULL) {\n        crm_err(\"Different signal handler for %d is already installed\", sig);\n        return FALSE;\n    }\n\n    CRM_ASSERT(sizeof(crm_signal_t) > sizeof(GSource));\n    source = g_source_new(&crm_signal_funcs, sizeof(crm_signal_t));\n\n    crm_signals[sig] = (crm_signal_t *) mainloop_setup_trigger(source, priority, NULL, NULL);\n    CRM_ASSERT(crm_signals[sig] != NULL);\n\n    crm_signals[sig]->handler = dispatch;\n    crm_signals[sig]->signal = sig;\n\n    if (crm_signal(sig, mainloop_signal_handler) == FALSE) {\n        crm_signal_t *tmp = crm_signals[sig];\n\n        crm_signals[sig] = NULL;\n\n        mainloop_destroy_trigger((crm_trigger_t *) tmp);\n        return FALSE;\n    }\n#if 0\n    /* If we want signals to interrupt mainloop's poll(), instead of waiting for\n     * the timeout, then we should call siginterrupt() below\n     *\n     * For now, just enforce a low timeout\n     */\n    if (siginterrupt(sig, 1) < 0) {\n        crm_perror(LOG_INFO, \"Could not enable system call interruptions for signal %d\", sig);\n    }\n#endif\n\n    return TRUE;\n}\n\ngboolean\nmainloop_destroy_signal(int sig)\n{\n    crm_signal_t *tmp = NULL;\n\n    if (sig >= NSIG || sig < 0) {\n        crm_err(\"Signal %d is out of range\", sig);\n        return FALSE;\n\n    } else if (crm_signal(sig, NULL) == FALSE) {\n        crm_perror(LOG_ERR, \"Could not uninstall signal handler for signal %d\", sig);\n        return FALSE;\n\n    } else if (crm_signals[sig] == NULL) {\n        return TRUE;\n    }\n\n    tmp = crm_signals[sig];\n    crm_signals[sig] = NULL;\n    mainloop_destroy_trigger((crm_trigger_t *) tmp);\n    return TRUE;\n}\n\nstatic qb_array_t *gio_map = NULL;\n\n/*\n * libqb...\n */\nstruct gio_to_qb_poll {\n        int32_t is_used;\n        GIOChannel *channel;\n        guint source;\n        int32_t events;\n        void * data;\n        qb_ipcs_dispatch_fn_t fn;\n        enum qb_loop_priority p;\n};\n\nstatic int\ngio_adapter_refcount(struct gio_to_qb_poll *adaptor)\n{\n    /* This is evil\n     * Looking at the giochannel header file, ref_count is the first member of channel\n     * So cheat...\n     */\n    if(adaptor && adaptor->channel) {\n        int *ref = (void*)adaptor->channel;\n        return *ref;\n    }\n    return 0;\n}\n\nstatic gboolean\ngio_read_socket (GIOChannel *gio, GIOCondition condition, gpointer data)\n{\n    struct gio_to_qb_poll *adaptor = (struct gio_to_qb_poll *)data;\n    gint fd = g_io_channel_unix_get_fd(gio);\n\n    crm_trace(\"%p.%d %d (ref=%d)\", data, fd, condition, gio_adapter_refcount(adaptor));\n\n    if(condition & G_IO_NVAL) {\n        crm_trace(\"Marking failed adaptor %p unused\", adaptor);\n        adaptor->is_used = QB_FALSE;\n    }\n\n    return (adaptor->fn(fd, condition, adaptor->data) == 0);\n}\n\nstatic void\ngio_poll_destroy(gpointer data) \n{\n    /* adaptor->source is valid but about to be destroyed (ref_count == 0) in gmain.c\n     * adaptor->channel will still have ref_count > 0... should be == 1\n     */\n    struct gio_to_qb_poll *adaptor = (struct gio_to_qb_poll *)data;\n\n    crm_trace(\"Destroying adaptor %p channel %p (ref=%d)\", adaptor, adaptor->channel, gio_adapter_refcount(adaptor));\n    adaptor->is_used = QB_FALSE;\n    adaptor->channel = NULL;\n    adaptor->source = 0;\n}\n\n\nstatic int32_t\ngio_poll_dispatch_add(enum qb_loop_priority p, int32_t fd, int32_t evts,\n                  void *data, qb_ipcs_dispatch_fn_t fn)\n{\n    struct gio_to_qb_poll *adaptor;\n    GIOChannel *channel;\n    int32_t res = 0;\n\n    res = qb_array_index(gio_map, fd, (void**)&adaptor);\n    if (res < 0) {\n        crm_err(\"Array lookup failed for fd=%d: %d\", fd, res);\n        return res;\n    }\n\n    crm_trace(\"Adding fd=%d to mainloop as adapater %p\", fd, adaptor);\n    if (adaptor->is_used) {\n        crm_err(\"Adapter for descriptor %d is still in-use\", fd);\n        return -EEXIST;\n    }\n\n    /* channel is created with ref_count = 1 */\n    channel = g_io_channel_unix_new(fd);\n    if (!channel) {\n        crm_err(\"No memory left to add fd=%d\", fd);\n        return -ENOMEM;\n    }\n\n    /* Because unlike the poll() API, glib doesn't tell us about HUPs by default */\n    evts |= (G_IO_HUP|G_IO_NVAL|G_IO_ERR);\n\n    adaptor->channel = channel;\n    adaptor->fn = fn;\n    adaptor->events = evts;\n    adaptor->data = data;\n    adaptor->p = p;\n    adaptor->is_used = QB_TRUE;\n    adaptor->source = g_io_add_watch_full(channel, G_PRIORITY_DEFAULT, evts, gio_read_socket, adaptor, gio_poll_destroy);\n\n    /* Now that mainloop now holds a reference to adaptor->channel,\n     * thanks to g_io_add_watch_full(), drop ours from g_io_channel_unix_new().\n     *\n     * This means that adaptor->channel will be free'd by:\n     * g_main_context_dispatch()\n     *  -> g_source_destroy_internal()\n     *      -> g_source_callback_unref()\n     * shortly after gio_poll_destroy() completes\n     */\n    g_io_channel_unref(adaptor->channel);    \n\n    crm_trace(\"Added to mainloop with gsource id=%d, ref=%d\", adaptor->source, gio_adapter_refcount(adaptor));\n    if(adaptor->source > 0) {\n        return 0;\n    }\n    \n    return -EINVAL;\n}\n\nstatic int32_t\ngio_poll_dispatch_mod(enum qb_loop_priority p, int32_t fd, int32_t evts,\n                  void *data, qb_ipcs_dispatch_fn_t fn)\n{\n    return 0;\n}\n\nstatic int32_t\ngio_poll_dispatch_del(int32_t fd)\n{\n    struct gio_to_qb_poll *adaptor;\n    crm_trace(\"Looking for fd=%d\", fd);\n    if (qb_array_index(gio_map, fd, (void**)&adaptor) == 0) {\n        crm_trace(\"Marking adaptor %p unused (ref=%d)\", adaptor, gio_adapter_refcount(adaptor));\n        adaptor->is_used = QB_FALSE;\n    }\n    return 0;\n}\n\nstruct qb_ipcs_poll_handlers gio_poll_funcs = {\n    .job_add = NULL,\n    .dispatch_add = gio_poll_dispatch_add,\n    .dispatch_mod = gio_poll_dispatch_mod,\n    .dispatch_del = gio_poll_dispatch_del,\n};\n\nstatic enum qb_ipc_type\npick_ipc_type(enum qb_ipc_type requested)\n{\n    const char *env = getenv(\"PCMK_ipc_type\");\n\n    if(env && strcmp(\"shared-mem\", env) == 0) {\n        return QB_IPC_SHM;\n    } else if(env && strcmp(\"socket\", env) == 0) {\n        return QB_IPC_SOCKET;\n    } else if(env && strcmp(\"posix\", env) == 0) {\n        return QB_IPC_POSIX_MQ;\n    } else if(env && strcmp(\"sysv\", env) == 0) {\n        return QB_IPC_SYSV_MQ;\n    } else if(requested == QB_IPC_NATIVE) {\n        /* We prefer sockets actually */\n        return QB_IPC_SOCKET;\n    }\n    return requested;\n}\n\nqb_ipcs_service_t *mainloop_add_ipc_server(\n    const char *name, enum qb_ipc_type type, struct qb_ipcs_service_handlers *callbacks) \n{\n    int rc = 0;\n    qb_ipcs_service_t* server = NULL;\n\n    if(gio_map == NULL) {\n        gio_map = qb_array_create_2(64, sizeof(struct gio_to_qb_poll), 1);\n    }\n\n    server = qb_ipcs_create(name, 0, pick_ipc_type(type), callbacks);\n    qb_ipcs_poll_handlers_set(server, &gio_poll_funcs);\n\n    rc = qb_ipcs_run(server);\n    if (rc < 0) {\n        crm_err(\"Could not start %s IPC server: %s (%d)\", name, pcmk_strerror(rc), rc);\n        return NULL;\n    }\n\n    return server;\n}\n\nvoid mainloop_del_ipc_server(qb_ipcs_service_t *server) \n{\n    if(server) {\n        qb_ipcs_destroy(server);\n    }\n}\n\nstruct mainloop_io_s\n{\n        char *name;\n        void *userdata;\n\n        guint source;\n        crm_ipc_t *ipc;\n        GIOChannel *channel;\n\n        int (*dispatch_fn_ipc)(const char *buffer, ssize_t length, gpointer userdata);\n        int (*dispatch_fn_io) (gpointer userdata);\n        void (*destroy_fn) (gpointer userdata);\n\n};\n\nstatic int\nmainloop_gio_refcount(mainloop_io_t *client) \n{\n    /* This is evil\n     * Looking at the giochannel header file, ref_count is the first member of channel\n     * So cheat...\n     */\n    if(client && client->channel) {\n        int *ref = (void*)client->channel;\n        return *ref;\n    }\n    return 0;\n}\n\nstatic gboolean\nmainloop_gio_callback(GIOChannel *gio, GIOCondition condition, gpointer data)\n{\n    gboolean keep = TRUE;\n    mainloop_io_t *client = data;\n\n    if(condition & G_IO_IN) {\n        if(client->ipc) {\n            long rc = 0;\n            int max = 10;\n            do {\n                rc = crm_ipc_read(client->ipc);\n                if(rc <= 0) {\n                    crm_trace(\"Message acquisition from %s[%p] failed: %s (%ld)\",\n                              client->name, client, pcmk_strerror(rc), rc);\n\n                } else if(client->dispatch_fn_ipc) {\n                    const char *buffer = crm_ipc_buffer(client->ipc);\n                    crm_trace(\"New message from %s[%p] = %d\", client->name, client, rc, condition);\n                    if(client->dispatch_fn_ipc(buffer, rc, client->userdata) < 0) {\n                        crm_trace(\"Connection to %s no longer required\", client->name);\n                        keep = FALSE;\n                    }\n                }\n\n            } while(keep && rc > 0 && --max > 0);\n\n        } else {\n            crm_trace(\"New message from %s[%p]\", client->name, client);\n            if(client->dispatch_fn_io) {\n                if(client->dispatch_fn_io(client->userdata) < 0) {\n                    crm_trace(\"Connection to %s no longer required\", client->name);\n                    keep = FALSE;\n                }\n            }\n        }\n    }\n\n    if(client->ipc && crm_ipc_connected(client->ipc) == FALSE) {\n        crm_err(\"Connection to %s[%p] closed (I/O condition=%d)\", client->name, client, condition);\n        keep = FALSE;\n\n    } else if(condition & (G_IO_HUP|G_IO_NVAL|G_IO_ERR)) {\n        crm_trace(\"The connection %s[%p] has been closed (I/O condition=%d, refcount=%d)\",\n                  client->name, client, condition, mainloop_gio_refcount(client));\n        keep = FALSE;\n\n    } else if((condition & G_IO_IN) == 0) {\n        /*\n          #define \tGLIB_SYSDEF_POLLIN     =1\n          #define \tGLIB_SYSDEF_POLLPRI    =2\n          #define \tGLIB_SYSDEF_POLLOUT    =4\n          #define \tGLIB_SYSDEF_POLLERR    =8\n          #define \tGLIB_SYSDEF_POLLHUP    =16\n          #define \tGLIB_SYSDEF_POLLNVAL   =32\n\n          typedef enum\n          {\n            G_IO_IN\tGLIB_SYSDEF_POLLIN,\n            G_IO_OUT\tGLIB_SYSDEF_POLLOUT,\n            G_IO_PRI\tGLIB_SYSDEF_POLLPRI,\n            G_IO_ERR\tGLIB_SYSDEF_POLLERR,\n            G_IO_HUP\tGLIB_SYSDEF_POLLHUP,\n            G_IO_NVAL\tGLIB_SYSDEF_POLLNVAL\n          } GIOCondition;\n\n          A bitwise combination representing a condition to watch for on an event source.\n\n          G_IO_IN\tThere is data to read.\n          G_IO_OUT\tData can be written (without blocking).\n          G_IO_PRI\tThere is urgent data to read.\n          G_IO_ERR\tError condition.\n          G_IO_HUP\tHung up (the connection has been broken, usually for pipes and sockets).\n          G_IO_NVAL\tInvalid request. The file descriptor is not open.    \n        */\n        crm_err(\"Strange condition: %d\", condition);\n    }\n\n    /* keep == FALSE results in mainloop_gio_destroy() being called\n     * just before the source is removed from mainloop\n     */\n    return keep;\n}\n\nstatic void\nmainloop_gio_destroy(gpointer c)\n{\n    mainloop_io_t *client = c;\n\n    /* client->source is valid but about to be destroyed (ref_count == 0) in gmain.c\n     * client->channel will still have ref_count > 0... should be == 1\n     */\n    crm_trace(\"Destroying client %s[%p] %d\", client->name, c, mainloop_gio_refcount(client));\n\n    if(client->ipc) {\n        crm_ipc_close(client->ipc);\n    }\n\n    if(client->destroy_fn) {\n        client->destroy_fn(client->userdata);\n    }\n    \n    if(client->ipc) {\n        crm_ipc_destroy(client->ipc);\n    }\n\n    crm_trace(\"Destroyed client %s[%p] %d\", client->name, c, mainloop_gio_refcount(client));\n    free(client->name);\n\n    memset(client, 0, sizeof(mainloop_io_t)); /* A bit of pointless paranoia */\n    free(client);\n}\n\nmainloop_io_t *\nmainloop_add_ipc_client(\n    const char *name, int priority, size_t max_size, void *userdata, struct ipc_client_callbacks *callbacks) \n{\n    mainloop_io_t *client = NULL;\n    crm_ipc_t *conn = crm_ipc_new(name, max_size);\n\n    if(conn && crm_ipc_connect(conn)) {\n        int32_t fd = crm_ipc_get_fd(conn);\n        client = mainloop_add_fd(name, priority, fd, userdata, NULL);\n        client->ipc = conn;\n        client->destroy_fn = callbacks->destroy;\n        client->dispatch_fn_ipc = callbacks->dispatch;\n    }\n\n    if(conn && client == NULL) {\n        crm_trace(\"Connection to %s failed\", name);\n        crm_ipc_close(conn);\n        crm_ipc_destroy(conn);\n    }\n    \n    return client;\n}\n\nvoid\nmainloop_del_ipc_client(mainloop_io_t *client)\n{\n    mainloop_del_fd(client);\n}\n\ncrm_ipc_t *\nmainloop_get_ipc_client(mainloop_io_t *client)\n{\n    if(client) {\n        return client->ipc;\n    }\n    return NULL;\n}\n\nmainloop_io_t *\nmainloop_add_fd(\n    const char *name, int priority, int fd, void *userdata, struct mainloop_fd_callbacks *callbacks) \n{\n    mainloop_io_t *client = NULL;\n    if(fd > 0) {\n        client = calloc(1, sizeof(mainloop_io_t));          \n        client->name = strdup(name);\n        client->userdata = userdata;\n\n        if(callbacks) {\n            client->destroy_fn = callbacks->destroy;\n            client->dispatch_fn_io = callbacks->dispatch;\n        }\n\n        client->channel = g_io_channel_unix_new(fd);\n        client->source = g_io_add_watch_full(\n            client->channel, priority, (G_IO_IN|G_IO_HUP|G_IO_NVAL|G_IO_ERR),\n            mainloop_gio_callback, client, mainloop_gio_destroy);\n\n        /* Now that mainloop now holds a reference to adaptor->channel,\n         * thanks to g_io_add_watch_full(), drop ours from g_io_channel_unix_new().\n         *\n         * This means that adaptor->channel will be free'd by:\n         * g_main_context_dispatch() or g_source_remove()\n         *  -> g_source_destroy_internal()\n         *      -> g_source_callback_unref()\n         * shortly after mainloop_gio_destroy() completes\n         */\n        g_io_channel_unref(client->channel);\n        crm_trace(\"Added connection %d for %s[%p].%d %d\", client->source, client->name, client, fd, mainloop_gio_refcount(client));\n    }\n\n    return client;\n}\n\nvoid\nmainloop_del_fd(mainloop_io_t *client)\n{\n    if(client != NULL) {\n        crm_trace(\"Removing client %s[%p] %d\", client->name, client, mainloop_gio_refcount(client));\n        if (client->source) {\n            /* Results in mainloop_gio_destroy() being called just\n             * before the source is removed from mainloop\n             */\n            g_source_remove(client->source);\n        }\n    }\n}\n\npid_t\nmainloop_get_child_pid(mainloop_child_t *child)\n{\n    return child->pid;\n}\n\nint\nmainloop_get_child_timeout(mainloop_child_t *child)\n{\n    return child->timeout;\n}\n\nvoid *\nmainloop_get_child_userdata(mainloop_child_t *child)\n{\n    return child->privatedata;\n}\n\nvoid\nmainloop_clear_child_userdata(mainloop_child_t *child)\n{\n    child->privatedata = NULL;\n}\n\nstatic gboolean\nchild_timeout_callback(gpointer p)\n{\n    mainloop_child_t *child = p;\n\n    child->timerid = 0;\n    if (child->timeout) {\n        crm_crit(\"%s process (PID %d) will not die!\", child->desc, (int)child->pid);\n        return FALSE;\n    }\n\n    child->timeout = TRUE;\n    crm_warn(\"%s process (PID %d) timed out\", child->desc, (int)child->pid);\n\n    if (kill(child->pid, SIGKILL) < 0) {\n        if (errno == ESRCH) {\n            /* Nothing left to do */\n            return FALSE;\n        }\n        crm_perror(LOG_ERR, \"kill(%d, KILL) failed\", child->pid);\n    }\n\n    child->timerid = g_timeout_add(5000, child_timeout_callback, child);\n    return FALSE;\n}\n\nstatic void\nmainloop_child_destroy(mainloop_child_t *child)\n{\n    if (child->timerid != 0) {\n        crm_trace(\"Removing timer %d\", child->timerid);\n        g_source_remove(child->timerid);\n        child->timerid = 0;\n    }\n\n    free(child->desc);\n    g_free(child);\n}\n\nstatic void\nchild_death_dispatch(GPid pid, gint status, gpointer user_data)\n{\n    int signo = 0;\n    int exitcode = 0;\n    mainloop_child_t *child = user_data;\n\n    crm_trace(\"Managed process %d exited: %p\", pid, child);\n\n    if (WIFEXITED(status)) {\n        exitcode = WEXITSTATUS(status);\n        crm_trace(\"Managed process %d (%s) exited with rc=%d\", pid,\n                 child->desc, exitcode);\n\n    } else if (WIFSIGNALED(status)) {\n        signo = WTERMSIG(status);\n        crm_trace(\"Managed process %d (%s) exited with signal=%d\", pid,\n                 child->desc, signo);\n    }\n#ifdef WCOREDUMP\n    if (WCOREDUMP(status)) {\n        crm_err(\"Managed process %d (%s) dumped core\", pid, child->desc);\n    }\n#endif\n\n    if (child->callback) {\n       child->callback(child, status, signo, exitcode);\n    }\n    crm_trace(\"Removed process entry for %d\", pid);\n\n    mainloop_child_destroy(child);\n    return;\n}\n\n/* Create/Log a new tracked process\n * To track a process group, use -pid\n */\nvoid\nmainloop_add_child(pid_t pid, int timeout, const char *desc, void * privatedata,\n    void (*callback)(mainloop_child_t *p, int status, int signo, int exitcode))\n{\n    mainloop_child_t *child = g_new(mainloop_child_t, 1);\n\n    child->pid = pid;\n    child->timerid = 0;\n    child->timeout = FALSE;\n    child->desc = strdup(desc);\n    child->privatedata = privatedata;\n    child->callback = callback;\n\n    if (timeout) {\n        child->timerid = g_timeout_add(\n            timeout, child_timeout_callback, child);\n    }\n\n    child->watchid = g_child_watch_add(pid, child_death_dispatch, child);\n}\n", "/*\n * Copyright (c) 2008 Andrew Beekhof\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n#include <crm_internal.h>\n#include <crm/crm.h>\n\n#include <sys/param.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <netinet/ip.h>\n#include <netdb.h>\n\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <glib.h>\n\n#include <crm/common/ipc.h>\n#include <crm/common/xml.h>\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n#  undef KEYFILE\n#  include <gnutls/gnutls.h>\n#endif\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\nconst int anon_tls_kx_order[] = {\n    GNUTLS_KX_ANON_DH,\n    GNUTLS_KX_DHE_RSA,\n    GNUTLS_KX_DHE_DSS,\n    GNUTLS_KX_RSA,\n    0\n};\n\nint\ncrm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n{\n    int rc = 0;\n    int pollrc = 0;\n    time_t start = time(NULL);\n    gnutls_session *session = session_data;\n\n    do {\n        rc = gnutls_handshake(*session);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n            if (pollrc < 0) {\n                /* poll returned error, there is no hope */\n                rc = -1;\n            }\n        }\n    } while (((time(NULL) - start) < (timeout_ms/1000)) &&\n            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n\n    return rc;\n}\n\nvoid *\ncrm_create_anon_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */, void *credentials)\n{\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n/*      http://www.manpagez.com/info/gnutls/gnutls-2.10.4/gnutls_81.php#Echo-Server-with-anonymous-authentication */\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n/*\tgnutls_priority_set_direct (*session, \"NONE:+VERS-TLS-ALL:+CIPHER-ALL:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-DH\", NULL); */\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n    case GNUTLS_SERVER:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n        break;\n    case GNUTLS_CLIENT:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n        break;\n    }\n\n    return session;\n}\n\nstatic int\ncrm_send_tls(gnutls_session * session, const char *buf, size_t len)\n{\n    const char *unsent = buf;\n    int rc = 0;\n    int total_send;\n\n    if (buf == NULL) {\n        return -1;\n    }\n\n    total_send = len;\n    crm_trace(\"Message size: %d\", len);\n\n    while (TRUE) {\n        rc = gnutls_record_send(*session, unsent, len);\n\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_debug(\"Retry\");\n\n        } else if (rc < 0) {\n            crm_err(\"Connection terminated rc = %d\", rc);\n            break;\n\n        } else if (rc < len) {\n            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n        } else {\n            crm_debug(\"Sent %d bytes\", rc);\n            break;\n        }\n    }\n\n    return rc < 0 ? rc : total_send;\n}\n\n\n/*!\n * \\internal\n * \\brief Read bytes off non blocking tls session.\n *\n * \\param session - tls session to read\n * \\param max_size - max bytes allowed to read for buffer. 0 assumes no limit\n *\n * \\note only use with NON-Blocking sockets. Should only be used after polling socket.\n *       This function will return once max_size is met, the socket read buffer\n *       is empty, or an error is encountered.\n *\n * \\retval '\\0' terminated buffer on success\n */\nstatic char *\ncrm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n\n    while (TRUE) {\n        read_size = buf_size - len;\n\n        /* automatically grow the buffer when needed if max_size is not set.*/\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n\n            read_size = buf_size - len;\n        }\n\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            /* always null terminate buffer, the +1 to alloc always allows for this.*/\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n\n        /* process any errors. */\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\n\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n\n}\n#endif\n\nstatic int\ncrm_send_plaintext(int sock, const char *buf, size_t len)\n{\n\n    int rc = 0;\n    const char *unsent = buf;\n    int total_send;\n\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n\n    crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n    rc = write(sock, unsent, len);\n    if (rc < 0) {\n        switch (errno) {\n        case EINTR:\n        case EAGAIN:\n            crm_trace(\"Retry\");\n            goto retry;\n        default:\n            crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);\n            break;\n        }\n\n    } else if (rc < len) {\n        crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n        len -= rc;\n        unsent += rc;\n        goto retry;\n\n     } else {\n        crm_trace(\"Sent %d bytes: %.100s\", rc, buf);\n    }\n\n    return rc < 0 ? rc : total_send;\n\n}\n\n/*!\n * \\internal\n * \\brief Read bytes off non blocking socket.\n *\n * \\param session - tls session to read\n * \\param max_size - max bytes allowed to read for buffer. 0 assumes no limit\n *\n * \\note only use with NON-Blocking sockets. Should only be used after polling socket.\n *       This function will return once max_size is met, the socket read buffer\n *       is empty, or an error is encountered.\n *\n * \\retval '\\0' terminated buffer on success\n */\nstatic char *\ncrm_recv_plaintext(int sock, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n\n    if (sock <= 0) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n\n    while (TRUE) {\n        errno = 0;\n        read_size = buf_size - len;\n\n        /* automatically grow the buffer when needed if max_size is not set.*/\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n\n            read_size = buf_size - len;\n        }\n\n        rc = read(sock, buf + len, chunk_size);\n\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n            len += rc;\n            /* always null terminate buffer, the +1 to alloc always allows for this.*/\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n\n        if (rc > 0) {\n            continue;\n        } else if (rc == 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_trace(\"EOF encoutered during read\");\n            goto done;\n        }\n\n        /* process errors */\n        if (errno == EINTR) {\n            crm_trace(\"EINTER encoutered, retry socket read.\");\n        } else if (errno == EAGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (errno <= 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_debug(\"Error receiving message: %d\", (int)rc);\n            goto done;\n        }\n    }\n\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}\n\nstatic int\ncrm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\n    int rc = -1;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        rc = crm_send_tls(session, buf, len);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n    }\n    return rc;\n}\n\nint\ncrm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    int rc = -1;\n    char *xml_text = NULL;\n    int len = 0;\n\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text) {\n        len = strlen(xml_text);\n    } else {\n        crm_err(\"Invalid XML, can not send msg\");\n        return -1;\n    }\n\n    rc = crm_send_remote_msg_raw(session, xml_text, len, encrypted);\n    if (rc < 0) {\n        goto done;\n    }\n    rc = crm_send_remote_msg_raw(session, REMOTE_MSG_TERMINATOR, strlen(REMOTE_MSG_TERMINATOR), encrypted);\n\ndone:\n    if (rc < 0) {\n        crm_err(\"Failed to send remote msg, rc = %d\", rc);\n    }\n\n    free(xml_text);\n    return rc;\n}\n\n/*!\n * \\internal\n * \\brief handles the recv buffer and parsing out msgs.\n * \\note new_data is owned by this function once it is passed in.\n */\nxmlNode *\ncrm_parse_remote_buffer(char **msg_buf)\n{\n    char *buf = NULL;\n    char *start = NULL;\n    char *end = NULL;\n    xmlNode *xml = NULL;\n\n    if (*msg_buf == NULL) {\n        return NULL;\n    }\n\n    /* take ownership of the buffer */\n    buf = *msg_buf;\n    *msg_buf = NULL;\n\n    /* MSGS are separated by a '\\r\\n\\r\\n'. Split a message off the buffer and return it. */\n    start = buf;\n    end = strstr(start, REMOTE_MSG_TERMINATOR);\n\n    while (!xml && end) {\n\n        /* grab the message */\n        end[0] = '\\0';\n        end += strlen(REMOTE_MSG_TERMINATOR);\n\n        xml = string2xml(start);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", start);\n        }\n        start = end;\n        end = strstr(start, REMOTE_MSG_TERMINATOR);\n    }\n\n    if (xml && start) {\n        /* we have msgs left over, save it until next time */\n        *msg_buf = strdup(start);\n        free(buf);\n    } else if (!xml) {\n        /* no msg present */\n        *msg_buf = buf;\n    }\n\n    return xml;\n}\n\n/*!\n * \\internal\n * \\brief Determine if a remote session has data to read\n *\n * \\retval 0, timeout occured.\n * \\retval positive, data is ready to be read\n * \\retval negative, session has ended\n */\nint\ncrm_recv_remote_ready(void *session, gboolean encrypted, int timeout /* ms */)\n{\n    struct pollfd fds = { 0, };\n    int sock = 0;\n    void *sock_ptr = NULL;\n    int rc = 0;\n    time_t start;\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_session *tls_session = session;\n        sock_ptr = gnutls_transport_get_ptr(*tls_session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        sock_ptr = session;\n    }\n\n    sock = GPOINTER_TO_INT(sock_ptr);\n    if (sock <= 0) {\n        return -ENOTCONN;\n    }\n\n    start = time(NULL);\n    errno = 0;\n    do {\n        fds.fd = sock;\n        fds.events = POLLIN;\n\n        /* If we got an EINTR while polling, and we have a\n         * specific timeout we are trying to honor, attempt\n         * to adjust the timeout to the closest second. */\n        if (errno == EINTR && (timeout > 0)) {\n            timeout = timeout - ((time(NULL) - start) * 1000);\n            if (timeout < 1000) {\n                timeout = 1000;\n            }\n        }\n\n        rc = poll(&fds, 1, timeout);\n    } while (rc < 0 && errno == EINTR);\n\n    return rc;\n}\n\nchar *\ncrm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)\n{\n    char *reply = NULL;\n    if (recv_len) {\n        *recv_len = 0;\n    }\n\n    if (disconnected) {\n        *disconnected = 0;\n    }\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = crm_recv_tls(session, max_recv, recv_len, disconnected);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    }\n\n    return reply;\n}\n\n/*!\n * \\internal\n * \\brief Read data off the socket until at least one full message is present or timeout occures.\n * \\retval TRUE message read\n * \\retval FALSE full message not read\n */\n\ngboolean\ncrm_recv_remote_msg(void *session, char **recv_buf, gboolean encrypted, int total_timeout /*ms */, int *disconnected)\n{\n    int ret;\n    size_t request_len = 0;\n    time_t start = time(NULL);\n    char *raw_request = NULL;\n    int remaining_timeout = 0;\n\n    if (total_timeout == 0) {\n        total_timeout = 10000;\n    } else if (total_timeout < 0) {\n        total_timeout = 60000;\n    }\n    *disconnected = 0;\n\n    remaining_timeout = total_timeout;\n    while ((remaining_timeout > 0) && !(*disconnected)) {\n\n        /* read some more off the tls buffer if we still have time left. */\n        crm_trace(\"waiting to receive remote msg, starting timeout %d, remaining_timeout %d\", total_timeout, remaining_timeout);\n        ret = crm_recv_remote_ready(session, encrypted, remaining_timeout);\n        raw_request = NULL;\n\n        if (ret == 0) {\n            crm_err(\"poll timed out (%d ms) while waiting to receive msg\", remaining_timeout);\n            return FALSE;\n\n        } else if (ret < 0) {\n            if (errno != EINTR) {\n                crm_debug(\"poll returned error while waiting for msg, rc: %d, errno: %d\", ret, errno);\n                *disconnected = 1;\n                return FALSE;\n            }\n            crm_debug(\"poll EINTR encountered during poll, retrying\");\n        } else {\n            raw_request = crm_recv_remote_raw(session, encrypted, 0, &request_len, disconnected);\n        }\n\n        remaining_timeout = remaining_timeout - ((time(NULL) - start) * 1000);\n\n        if (!raw_request) {\n            crm_debug(\"Empty msg received after poll\");\n            continue;\n        }\n\n        if (*recv_buf) {\n            int old_len = strlen(*recv_buf);\n\n            crm_trace(\"Expanding recv buffer from %d to %d\", old_len, old_len+request_len);\n\n            *recv_buf = realloc(*recv_buf, old_len + request_len + 1);\n            memcpy(*recv_buf + old_len, raw_request, request_len);\n            *(*recv_buf+old_len+request_len) = '\\0';\n            free(raw_request);\n        } else {\n            *recv_buf = raw_request;\n        }\n\n        if (strstr(*recv_buf, REMOTE_MSG_TERMINATOR)) {\n            return TRUE;\n        }\n    }\n\n    return FALSE;\n}\n\n/*!\n * \\internal\n * \\brief tcp connection to server at specified port\n * \\retval positive, socket fd.\n * \\retval negative, failed to connect.\n */\nint\ncrm_remote_tcp_connect(const char *host, int port)\n{\n    struct addrinfo *res;\n    struct addrinfo *rp;\n    struct addrinfo hints;\n    const char *server = host;\n    int ret_ga;\n    int sock;\n\n    /* getaddrinfo */\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_CANONNAME;\n\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        return -1;\n    }\n\n    if (!res || !res->ai_addr) {\n        crm_err(\"getaddrinfo failed\");\n        return -1;\n    }\n\n    for (rp = res; rp != NULL; rp = rp->ai_next) {\n        struct sockaddr *addr = rp->ai_addr;\n        int flag = 0;\n        if (!addr) {\n            continue;\n        }\n\n        if (rp->ai_canonname) {\n            server = res->ai_canonname;\n        }\n        crm_debug(\"Got address %s for %s\", server, host);\n\n        /* create socket */\n        sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == -1) {\n            crm_err(\"Socket creation failed for remote client connection.\");\n            continue;\n        }\n        if (addr->sa_family == AF_INET6) {\n            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n            addr_in->sin6_port = htons(port);\n        } else {\n            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n            addr_in->sin_port = htons(port);\n            crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);\n        }\n\n        if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {\n            if ((flag = fcntl(sock, F_GETFL)) >= 0) {\n                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {\n                    crm_err( \"fcntl() write failed\");\n                    close(sock);\n                    sock = -1;\n                    continue;\n                }\n            }\n            break;                  /* Success */\n        }\n\n        close(sock);\n        sock = -1;\n    }\n    freeaddrinfo(res);\n\n    return sock;\n}\n\n", "\n/* \n * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n * \n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n * \n * You should have received a copy of the GNU General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include <crm_internal.h>\n\n#include <sys/param.h>\n\n#include <crm/crm.h>\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <sys/utsname.h>\n\n#include <crm/msg_xml.h>\n#include <crm/services.h>\n#include <crm/lrmd.h>\n#include <crm/common/util.h>\n#include <crm/common/xml.h>\n#include <crm/common/ipc.h>\n#include <crm/common/mainloop.h>\n\n#include <crm/cib/internal.h>\n#include <crm/pengine/status.h>\n#include <../lib/pengine/unpack.h>\n#include <../pengine/pengine.h>\n#include <crm/stonith-ng.h>\n\n/* GMainLoop *mainloop = NULL; */\n\nvoid wait_for_refresh(int offset, const char *prefix, int msec);\nvoid clean_up(int rc);\nvoid crm_diff_update(const char *event, xmlNode * msg);\ngboolean mon_refresh_display(gpointer user_data);\nint cib_connect(gboolean full);\nvoid mon_st_callback(stonith_t *st, stonith_event_t *e);\n\nchar *xml_file = NULL;\nchar *as_html_file = NULL;\nint as_xml = 0;\nchar *pid_file = NULL;\nchar *snmp_target = NULL;\nchar *snmp_community = NULL;\n\ngboolean as_console = TRUE;;\ngboolean simple_status = FALSE;\ngboolean group_by_node = FALSE;\ngboolean inactive_resources = FALSE;\ngboolean web_cgi = FALSE;\nint reconnect_msec = 5000;\ngboolean daemonize = FALSE;\nGMainLoop *mainloop = NULL;\nguint timer_id = 0;\nGList *attr_list = NULL;\n\nconst char *crm_mail_host = NULL;\nconst char *crm_mail_prefix = NULL;\nconst char *crm_mail_from = NULL;\nconst char *crm_mail_to = NULL;\nconst char *external_agent = NULL;\nconst char *external_recipient = NULL;\n\ncib_t *cib = NULL;\nstonith_t *st = NULL;\nxmlNode *current_cib = NULL;\n\ngboolean one_shot = FALSE;\ngboolean has_warnings = FALSE;\ngboolean print_failcount = FALSE;\ngboolean print_operations = FALSE;\ngboolean print_timing = FALSE;\ngboolean print_nodes_attr = FALSE;\ngboolean print_last_updated = TRUE;\ngboolean print_last_change = TRUE;\ngboolean print_tickets = FALSE;\ngboolean watch_fencing = FALSE;\n\n#define FILTER_STR {\"shutdown\", \"terminate\", \"standby\", \"fail-count\",\t\\\n\t    \"last-failure\", \"probe_complete\", \"#id\", \"#uname\",\t\t\\\n\t    \"#is_dc\", NULL}\n\ngboolean log_diffs = FALSE;\ngboolean log_updates = FALSE;\n\nlong last_refresh = 0;\ncrm_trigger_t *refresh_trigger = NULL;\n\n/*\n * 1.3.6.1.4.1.32723 has been assigned to the project by IANA\n * http://www.iana.org/assignments/enterprise-numbers\n */\n#define PACEMAKER_PREFIX \"1.3.6.1.4.1.32723\"\n#define PACEMAKER_TRAP_PREFIX PACEMAKER_PREFIX \".1\"\n\n#define snmp_crm_trap_oid   PACEMAKER_TRAP_PREFIX\n#define snmp_crm_oid_node   PACEMAKER_TRAP_PREFIX \".1\"\n#define snmp_crm_oid_rsc    PACEMAKER_TRAP_PREFIX \".2\"\n#define snmp_crm_oid_task   PACEMAKER_TRAP_PREFIX \".3\"\n#define snmp_crm_oid_desc   PACEMAKER_TRAP_PREFIX \".4\"\n#define snmp_crm_oid_status PACEMAKER_TRAP_PREFIX \".5\"\n#define snmp_crm_oid_rc     PACEMAKER_TRAP_PREFIX \".6\"\n#define snmp_crm_oid_trc    PACEMAKER_TRAP_PREFIX \".7\"\n\n#if CURSES_ENABLED\n#  define print_dot() if(as_console) {\t\t\\\n\tprintw(\".\");\t\t\t\t\\\n\tclrtoeol();\t\t\t\t\\\n\trefresh();\t\t\t\t\\\n    } else {\t\t\t\t\t\\\n\tfprintf(stdout, \".\");\t\t\t\\\n    }\n#else\n#  define print_dot() fprintf(stdout, \".\");\n#endif\n\n#if CURSES_ENABLED\n#  define print_as(fmt, args...) if(as_console) {\t\\\n\tprintw(fmt, ##args);\t\t\t\t\\\n\tclrtoeol();\t\t\t\t\t\\\n\trefresh();\t\t\t\t\t\\\n    } else {\t\t\t\t\t\t\\\n\tfprintf(stdout, fmt, ##args);\t\t\t\\\n    }\n#else\n#  define print_as(fmt, args...) fprintf(stdout, fmt, ##args);\n#endif\n\nstatic void\nblank_screen(void)\n{\n#if CURSES_ENABLED\n    int lpc = 0;\n\n    for (lpc = 0; lpc < LINES; lpc++) {\n        move(lpc, 0);\n        clrtoeol();\n    }\n    move(0, 0);\n    refresh();\n#endif\n}\n\nstatic gboolean\nmon_timer_popped(gpointer data)\n{\n    int rc = pcmk_ok;\n\n    if (timer_id > 0) {\n        g_source_remove(timer_id);\n    }\n\n    rc = cib_connect(TRUE);\n\n    if (rc != pcmk_ok) {\n        print_dot();\n        timer_id = g_timeout_add(reconnect_msec, mon_timer_popped, NULL);\n    }\n    return FALSE;\n}\n\nstatic void\nmon_cib_connection_destroy(gpointer user_data)\n{\n    print_as(\"Connection to the CIB terminated\\n\");\n    if (cib) {\n        print_as(\"Reconnecting...\");\n        cib->cmds->signoff(cib);\n        timer_id = g_timeout_add(reconnect_msec, mon_timer_popped, NULL);\n    }\n    return;\n}\n\n/*\n * Mainloop signal handler.\n */\nstatic void\nmon_shutdown(int nsig)\n{\n    clean_up(EX_OK);\n}\n\n#if ON_DARWIN\n#  define sighandler_t sig_t\n#endif\n\n#if CURSES_ENABLED\n#ifndef HAVE_SIGHANDLER_T\ntypedef void (*sighandler_t)(int);\n#endif\nstatic sighandler_t ncurses_winch_handler;\nstatic void\nmon_winresize(int nsig)\n{\n    static int not_done;\n    int lines = 0, cols = 0;\n\n    if (!not_done++) {\n        if (ncurses_winch_handler)\n            /* the original ncurses WINCH signal handler does the\n             * magic of retrieving the new window size;\n             * otherwise, we'd have to use ioctl or tgetent */\n            (*ncurses_winch_handler) (SIGWINCH);\n        getmaxyx(stdscr, lines, cols);\n        resizeterm(lines, cols);\n        mainloop_set_trigger(refresh_trigger);\n    }\n    not_done--;\n}\n#endif\n\nint\ncib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n\n    CRM_CHECK(cib != NULL, return -EINVAL);\n\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    \n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    \n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup not supported, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n\n            }\n\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}\n\n/* *INDENT-OFF* */\nstatic struct crm_option long_options[] = {\n    /* Top-level Options */\n    {\"help\",           0, 0, '?', \"\\tThis text\"},\n    {\"version\",        0, 0, '$', \"\\tVersion information\"  },\n    {\"verbose\",        0, 0, 'V', \"\\tIncrease debug output\"},\n    {\"quiet\",          0, 0, 'Q', \"\\tDisplay only essential output\" },\n\n    {\"-spacer-\",\t1, 0, '-', \"\\nModes:\"},\n    {\"as-html\",        1, 0, 'h', \"Write cluster status to the named html file\"},\n    {\"as-xml\",         0, 0, 'X', \"\\tWrite cluster status as xml to stdout. This will enable one-shot mode.\"},\n    {\"web-cgi\",        0, 0, 'w', \"\\tWeb mode with output suitable for cgi\"},\n    {\"simple-status\",  0, 0, 's', \"Display the cluster status once as a simple one line output (suitable for nagios)\"},\n    {\"snmp-traps\",     1, 0, 'S', \"Send SNMP traps to this station\", !ENABLE_SNMP},\n    {\"snmp-community\", 1, 0, 'C', \"Specify community for SNMP traps(default is NULL)\", !ENABLE_SNMP},\n    {\"mail-to\",        1, 0, 'T', \"Send Mail alerts to this user.  See also --mail-from, --mail-host, --mail-prefix\", !ENABLE_ESMTP},\n    \n    {\"-spacer-\",\t1, 0, '-', \"\\nDisplay Options:\"},\n    {\"group-by-node\",  0, 0, 'n', \"\\tGroup resources by node\"     },\n    {\"inactive\",       0, 0, 'r', \"\\tDisplay inactive resources\"  },\n    {\"failcounts\",     0, 0, 'f', \"\\tDisplay resource fail counts\"},\n    {\"operations\",     0, 0, 'o', \"\\tDisplay resource operation history\" },\n    {\"timing-details\", 0, 0, 't', \"\\tDisplay resource operation history with timing details\" },\n    {\"tickets\",        0, 0, 'c', \"\\t\\tDisplay cluster tickets\"},\n    {\"watch-fencing\",  0, 0, 'W', \"\\t\\tListen for fencing events. For use with --external-agent, --mail-to and/or --snmp-traps where supported\"},\n    {\"show-node-attributes\", 0, 0, 'A', \"Display node attributes\" },\n\n    {\"-spacer-\",\t1, 0, '-', \"\\nAdditional Options:\"},\n    {\"interval\",       1, 0, 'i', \"\\tUpdate frequency in seconds\" },\n    {\"one-shot\",       0, 0, '1', \"\\tDisplay the cluster status once on the console and exit\"},\n    {\"disable-ncurses\",0, 0, 'N', \"\\tDisable the use of ncurses\", !CURSES_ENABLED},\n    {\"daemonize\",      0, 0, 'd', \"\\tRun in the background as a daemon\"},\n    {\"pid-file\",       1, 0, 'p', \"\\t(Advanced) Daemon pid file location\"},\n    {\"mail-from\",      1, 0, 'F', \"\\tMail alerts should come from the named user\", !ENABLE_ESMTP},\n    {\"mail-host\",      1, 0, 'H', \"\\tMail alerts should be sent via the named host\", !ENABLE_ESMTP},\n    {\"mail-prefix\",    1, 0, 'P', \"Subjects for mail alerts should start with this string\", !ENABLE_ESMTP},\n    {\"external-agent\",    1, 0, 'E', \"A program to run when resource operations take place.\"},\n    {\"external-recipient\",1, 0, 'e', \"A recipient for your program (assuming you want the program to send something to someone).\"},\n\n    \n    {\"xml-file\",       1, 0, 'x', NULL, 1},\n\n    {\"-spacer-\",\t1, 0, '-', \"\\nExamples:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \"Display the cluster status on the console with updates as they occur:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Display the cluster status on the console just once then exit:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon -1\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Display your cluster status, group resources by node, and include inactive resources in the list:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --group-by-node --inactive\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon as a background daemon and have it write the cluster status to an HTML file:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --daemonize --as-html /path/to/docroot/filename.html\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon and export the current cluster status as xml to stdout, then exit.:\", pcmk_option_paragraph},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --as-xml\", pcmk_option_example},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon as a background daemon and have it send email alerts:\", pcmk_option_paragraph|!ENABLE_ESMTP},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --daemonize --mail-to user@example.com --mail-host mail.example.com\", pcmk_option_example|!ENABLE_ESMTP},\n    {\"-spacer-\",\t1, 0, '-', \"Start crm_mon as a background daemon and have it send SNMP alerts:\", pcmk_option_paragraph|!ENABLE_SNMP},\n    {\"-spacer-\",\t1, 0, '-', \" crm_mon --daemonize --snmp-traps snmptrapd.example.com\", pcmk_option_example|!ENABLE_SNMP},\n    \n    {NULL, 0, 0, 0}\n};\n/* *INDENT-ON* */\n\nint\nmain(int argc, char **argv)\n{\n    int flag;\n    int argerr = 0;\n    int exit_code = 0;\n    int option_index = 0;\n\n    pid_file = strdup(\"/tmp/ClusterMon.pid\");\n    crm_log_cli_init(\"crm_mon\");\n    crm_set_options(NULL, \"mode [options]\", long_options,\n                    \"Provides a summary of cluster's current state.\"\n                    \"\\n\\nOutputs varying levels of detail in a number of different formats.\\n\");\n\n#ifndef ON_DARWIN\n    /* prevent zombies */\n    signal(SIGCLD, SIG_IGN);\n#endif\n\n    if (strcmp(crm_system_name, \"crm_mon.cgi\") == 0) {\n        web_cgi = TRUE;\n        one_shot = TRUE;\n    }\n\n    while (1) {\n        flag = crm_get_option(argc, argv, &option_index);\n        if (flag == -1)\n            break;\n\n        switch (flag) {\n            case 'V':\n                crm_bump_log_level(argc, argv);\n                break;\n            case 'Q':\n                print_last_updated = FALSE;\n                print_last_change = FALSE;\n                break;\n            case 'i':\n                reconnect_msec = crm_get_msec(optarg);\n                break;\n            case 'n':\n                group_by_node = TRUE;\n                break;\n            case 'r':\n                inactive_resources = TRUE;\n                break;\n            case 'W':\n                watch_fencing = TRUE;\n                break;\n            case 'd':\n                daemonize = TRUE;\n                break;\n            case 't':\n                print_timing = TRUE;\n                print_operations = TRUE;\n                break;\n            case 'o':\n                print_operations = TRUE;\n                break;\n            case 'f':\n                print_failcount = TRUE;\n                break;\n            case 'A':\n                print_nodes_attr = TRUE;\n                break;\n            case 'c':\n                print_tickets = TRUE;\n                break;\n            case 'p':\n                free(pid_file);\n                pid_file = strdup(optarg);\n                break;\n            case 'x':\n                xml_file = strdup(optarg);\n                one_shot = TRUE;\n                break;\n            case 'h':\n                as_html_file = strdup(optarg);\n                break;\n            case 'X':\n                as_xml = TRUE;\n                one_shot = TRUE;\n                break;\n            case 'w':\n                web_cgi = TRUE;\n                one_shot = TRUE;\n                break;\n            case 's':\n                simple_status = TRUE;\n                one_shot = TRUE;\n                break;\n            case 'S':\n                snmp_target = optarg;\n                break;\n            case 'T':\n                crm_mail_to = optarg;\n                break;\n            case 'F':\n                crm_mail_from = optarg;\n                break;\n            case 'H':\n                crm_mail_host = optarg;\n                break;\n            case 'P':\n                crm_mail_prefix = optarg;\n                break;\n            case 'E':\n                external_agent = optarg;\n                break;\n            case 'e':\n                external_recipient = optarg;\n                break;\n            case '1':\n                one_shot = TRUE;\n                break;\n            case 'N':\n                as_console = FALSE;\n                break;\n            case 'C':\n                snmp_community = optarg;\n                break;\n            case '$':\n            case '?':\n                crm_help(flag, EX_OK);\n                break;\n            default:\n                printf(\"Argument code 0%o (%c) is not (?yet?) supported\\n\", flag, flag);\n                ++argerr;\n                break;\n        }\n    }\n\n    if (optind < argc) {\n        printf(\"non-option ARGV-elements: \");\n        while (optind < argc)\n            printf(\"%s \", argv[optind++]);\n        printf(\"\\n\");\n    }\n    if (argerr) {\n        crm_help('?', EX_USAGE);\n    }\n\n    if (one_shot) {\n        as_console = FALSE;\n\n    } else if (daemonize) {\n        as_console = FALSE;\n        crm_enable_stderr(FALSE);\n\n        if (!as_html_file && !snmp_target && !crm_mail_to && !external_agent && !as_xml) {\n            printf\n                (\"Looks like you forgot to specify one or more of: --as-html, --as-xml, --mail-to, --snmp-target, --external-agent\\n\");\n            crm_help('?', EX_USAGE);\n        }\n\n        crm_make_daemon(crm_system_name, TRUE, pid_file);\n\n    } else if (as_console) {\n#if CURSES_ENABLED\n        initscr();\n        cbreak();\n        noecho();\n        crm_enable_stderr(FALSE);\n#else\n        one_shot = TRUE;\n        as_console = FALSE;\n        printf(\"Defaulting to one-shot mode\\n\");\n        printf(\"You need to have curses available at compile time to enable console mode\\n\");\n#endif\n    }\n\n    crm_info(\"Starting %s\", crm_system_name);\n    if (xml_file != NULL) {\n        current_cib = filename2xml(xml_file);\n        mon_refresh_display(NULL);\n        return exit_code;\n    }\n\n    if (current_cib == NULL) {\n        cib = cib_new();\n        if (!one_shot) {\n            print_as(\"Attempting connection to the cluster...\");\n        }\n\n        do {\n            exit_code = cib_connect(!one_shot);\n\n            if (one_shot) {\n                break;\n\n            } else if (exit_code != pcmk_ok) {\n                print_dot();\n                sleep(reconnect_msec / 1000);\n            }\n\n        } while (exit_code == -ENOTCONN);\n\n        if (exit_code != pcmk_ok) {\n            print_as(\"\\nConnection to cluster failed: %s\\n\", pcmk_strerror(exit_code));\n            if (as_console) {\n                sleep(2);\n            }\n            clean_up(-exit_code);\n        }\n    }\n\n    if (one_shot) {\n        return exit_code;\n    }\n\n    mainloop = g_main_new(FALSE);\n\n    mainloop_add_signal(SIGTERM, mon_shutdown);\n    mainloop_add_signal(SIGINT, mon_shutdown);\n#if CURSES_ENABLED\n    if (as_console) {\n        ncurses_winch_handler = signal(SIGWINCH, mon_winresize);\n        if (ncurses_winch_handler == SIG_DFL ||\n            ncurses_winch_handler == SIG_IGN || ncurses_winch_handler == SIG_ERR)\n            ncurses_winch_handler = NULL;\n    }\n#endif\n    refresh_trigger = mainloop_add_trigger(G_PRIORITY_LOW, mon_refresh_display, NULL);\n\n    g_main_run(mainloop);\n    g_main_destroy(mainloop);\n\n    crm_info(\"Exiting %s\", crm_system_name);\n\n    clean_up(0);\n    return 0;                   /* never reached */\n}\n\nvoid\nwait_for_refresh(int offset, const char *prefix, int msec)\n{\n    int lpc = msec / 1000;\n    struct timespec sleept = { 1, 0 };\n\n    if (as_console == FALSE) {\n        timer_id = g_timeout_add(msec, mon_timer_popped, NULL);\n        return;\n    }\n\n    crm_notice(\"%sRefresh in %ds...\", prefix ? prefix : \"\", lpc);\n    while (lpc > 0) {\n#if CURSES_ENABLED\n        move(offset, 0);\n/* \t\tprintw(\"%sRefresh in \\033[01;32m%ds\\033[00m...\", prefix?prefix:\"\", lpc); */\n        printw(\"%sRefresh in %ds...\\n\", prefix ? prefix : \"\", lpc);\n        clrtoeol();\n        refresh();\n#endif\n        lpc--;\n        if (lpc == 0) {\n            timer_id = g_timeout_add(1000, mon_timer_popped, NULL);\n        } else {\n            if (nanosleep(&sleept, NULL) != 0) {\n                return;\n            }\n        }\n    }\n}\n\n#define mon_warn(fmt...) do {\t\t\t\\\n\tif (!has_warnings) {\t\t\t\\\n\t    print_as(\"Warning:\");\t\t\\\n\t} else {\t\t\t\t\\\n\t    print_as(\",\");\t\t\t\\\n\t}\t\t\t\t\t\\\n\tprint_as(fmt);\t\t\t\t\\\n\thas_warnings = TRUE;\t\t\t\\\n    } while(0)\n\nstatic int\ncount_resources(pe_working_set_t * data_set, resource_t * rsc)\n{\n    int count = 0;\n    GListPtr gIter = NULL;\n\n    if (rsc == NULL) {\n        gIter = data_set->resources;\n    } else if (rsc->children) {\n        gIter = rsc->children;\n    } else {\n        return is_not_set(rsc->flags, pe_rsc_orphan);\n    }\n\n    for (; gIter != NULL; gIter = gIter->next) {\n        count += count_resources(data_set, gIter->data);\n    }\n    return count;\n}\n\nstatic int\nprint_simple_status(pe_working_set_t * data_set)\n{\n    node_t *dc = NULL;\n    GListPtr gIter = NULL;\n    int nodes_online = 0;\n    int nodes_standby = 0;\n\n    dc = data_set->dc_node;\n\n    if (dc == NULL) {\n        mon_warn(\"No DC \");\n    }\n\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n\n        if (node->details->standby && node->details->online) {\n            nodes_standby++;\n        } else if (node->details->online) {\n            nodes_online++;\n        } else {\n            mon_warn(\"offline node: %s\", node->details->uname);\n        }\n    }\n\n    if (!has_warnings) {\n        print_as(\"Ok: %d nodes online\", nodes_online);\n        if (nodes_standby > 0) {\n            print_as(\", %d standby nodes\", nodes_standby);\n        }\n        print_as(\", %d resources configured\", count_resources(data_set, NULL));\n    }\n\n    print_as(\"\\n\");\n    return 0;\n}\n\nextern int get_failcount(node_t * node, resource_t * rsc, int *last_failure,\n                         pe_working_set_t * data_set);\n\nstatic void\nprint_date(time_t time)\n{\n    int lpc = 0;\n    char date_str[26];\n\n    asctime_r(localtime(&time), date_str);\n    for (; lpc < 26; lpc++) {\n        if (date_str[lpc] == '\\n') {\n            date_str[lpc] = 0;\n        }\n    }\n    print_as(\"'%s'\", date_str);\n}\n\nstatic void\nprint_rsc_summary(pe_working_set_t * data_set, node_t * node, resource_t * rsc, gboolean all)\n{\n    gboolean printed = FALSE;\n    time_t last_failure = 0;\n\n    char *fail_attr = crm_concat(\"fail-count\", rsc->id, '-');\n    const char *value = g_hash_table_lookup(node->details->attrs, fail_attr);\n\n    int failcount = char2score(value);  /* Get the true value, not the effective one from get_failcount() */\n\n    get_failcount(node, rsc, (int *)&last_failure, data_set);\n    free(fail_attr);\n\n    if (all || failcount || last_failure > 0) {\n        printed = TRUE;\n        print_as(\"   %s: migration-threshold=%d\", rsc->id, rsc->migration_threshold);\n    }\n\n    if (failcount > 0) {\n        printed = TRUE;\n        print_as(\" fail-count=%d\", failcount);\n    }\n\n    if (last_failure > 0) {\n        printed = TRUE;\n        print_as(\" last-failure=\");\n        print_date(last_failure);\n    }\n\n    if (printed) {\n        print_as(\"\\n\");\n    }\n}\n\nstatic void\nprint_rsc_history(pe_working_set_t * data_set, node_t * node, xmlNode * rsc_entry)\n{\n    GListPtr gIter = NULL;\n    GListPtr op_list = NULL;\n    gboolean print_name = TRUE;\n    GListPtr sorted_op_list = NULL;\n    const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);\n    resource_t *rsc = pe_find_resource(data_set->resources, rsc_id);\n\n    xmlNode *rsc_op = NULL;\n\n    for (rsc_op = __xml_first_child(rsc_entry); rsc_op != NULL; rsc_op = __xml_next(rsc_op)) {\n        if (crm_str_eq((const char *)rsc_op->name, XML_LRM_TAG_RSC_OP, TRUE)) {\n            op_list = g_list_append(op_list, rsc_op);\n        }\n    }\n\n    sorted_op_list = g_list_sort(op_list, sort_op_by_callid);\n    for (gIter = sorted_op_list; gIter != NULL; gIter = gIter->next) {\n        xmlNode *xml_op = (xmlNode *) gIter->data;\n        const char *value = NULL;\n        const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);\n        const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);\n        const char *op_rc = crm_element_value(xml_op, XML_LRM_ATTR_RC);\n        const char *interval = crm_element_value(xml_op, XML_LRM_ATTR_INTERVAL);\n        int rc = crm_parse_int(op_rc, \"0\");\n\n        if (safe_str_eq(task, CRMD_ACTION_STATUS)\n            && safe_str_eq(interval, \"0\")) {\n            task = \"probe\";\n        }\n\n        if (rc == 7 && safe_str_eq(task, \"probe\")) {\n            continue;\n\n        } else if (safe_str_eq(task, CRMD_ACTION_NOTIFY)) {\n            continue;\n        }\n\n        if (print_name) {\n            print_name = FALSE;\n            if (rsc == NULL) {\n                print_as(\"Orphan resource: %s\", rsc_id);\n            } else {\n                print_rsc_summary(data_set, node, rsc, TRUE);\n            }\n        }\n\n        print_as(\"    + (%s) %s:\", call, task);\n        if (safe_str_neq(interval, \"0\")) {\n            print_as(\" interval=%sms\", interval);\n        }\n\n        if (print_timing) {\n            int int_value;\n            const char *attr = \"last-rc-change\";\n\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=\", attr);\n                print_date(int_value);\n            }\n\n            attr = \"last-run\";\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=\", attr);\n                print_date(int_value);\n            }\n\n            attr = \"exec-time\";\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=%dms\", attr, int_value);\n            }\n\n            attr = \"queue-time\";\n            value = crm_element_value(xml_op, attr);\n            if (value) {\n                int_value = crm_parse_int(value, NULL);\n                print_as(\" %s=%dms\", attr, int_value);\n            }\n        }\n\n        print_as(\" rc=%s (%s)\\n\", op_rc, lrmd_event_rc2str(rc));\n    }\n\n    /* no need to free the contents */\n    g_list_free(sorted_op_list);\n}\n\nstatic void\nprint_attr_msg(node_t * node, GListPtr rsc_list, const char *attrname, const char *attrvalue)\n{\n    GListPtr gIter = NULL;\n\n    for (gIter = rsc_list; gIter != NULL; gIter = gIter->next) {\n        resource_t *rsc = (resource_t *) gIter->data;\n        const char *type = g_hash_table_lookup(rsc->meta, \"type\");\n\n        if (rsc->children != NULL) {\n            print_attr_msg(node, rsc->children, attrname, attrvalue);\n        }\n\n        if (safe_str_eq(type, \"ping\") || safe_str_eq(type, \"pingd\")) {\n            const char *name = \"pingd\";\n            const char *multiplier = NULL;\n            char **host_list = NULL;\n            int host_list_num = 0;\n            int expected_score = 0;\n\n            if (g_hash_table_lookup(rsc->meta, \"name\") != NULL) {\n                name = g_hash_table_lookup(rsc->meta, \"name\");\n            }\n\n            /* To identify the resource with the attribute name. */\n            if (safe_str_eq(name, attrname)) {\n                int value = crm_parse_int(attrvalue, \"0\");\n\n                multiplier = g_hash_table_lookup(rsc->meta, \"multiplier\");\n                host_list = g_strsplit(g_hash_table_lookup(rsc->meta, \"host_list\"), \" \", 0);\n                host_list_num = g_strv_length(host_list);\n                g_strfreev(host_list);\n                /* pingd multiplier is the same as the default value. */\n                expected_score = host_list_num * crm_parse_int(multiplier, \"1\");\n\n                /* pingd is abnormal score. */\n                if (value <= 0) {\n                    print_as(\"\\t: Connectivity is lost\");\n                } else if (value < expected_score) {\n                    print_as(\"\\t: Connectivity is degraded (Expected=%d)\", expected_score);\n                }\n            }\n        }\n    }\n}\n\nstatic int\ncompare_attribute(gconstpointer a, gconstpointer b)\n{\n    int rc;\n\n    rc = strcmp((const char *)a, (const char *)b);\n\n    return rc;\n}\n\nstatic void\ncreate_attr_list(gpointer name, gpointer value, gpointer data)\n{\n    int i;\n    const char *filt_str[] = FILTER_STR;\n\n    CRM_CHECK(name != NULL, return);\n\n    /* filtering automatic attributes */\n    for (i = 0; filt_str[i] != NULL; i++) {\n        if (g_str_has_prefix(name, filt_str[i])) {\n            return;\n        }\n    }\n\n    attr_list = g_list_insert_sorted(attr_list, name, compare_attribute);\n}\n\nstatic void\nprint_node_attribute(gpointer name, gpointer node_data)\n{\n    const char *value = NULL;\n    node_t *node = (node_t *) node_data;\n\n    value = g_hash_table_lookup(node->details->attrs, name);\n    print_as(\"    + %-32s\\t: %-10s\", (char *)name, value);\n    print_attr_msg(node, node->details->running_rsc, name, value);\n    print_as(\"\\n\");\n}\n\nstatic void\nprint_node_summary(pe_working_set_t * data_set, gboolean operations)\n{\n    xmlNode *lrm_rsc = NULL;\n    xmlNode *rsc_entry = NULL;\n    xmlNode *node_state = NULL;\n    xmlNode *cib_status = get_object_root(XML_CIB_TAG_STATUS, data_set->input);\n\n    if (operations) {\n        print_as(\"\\nOperations:\\n\");\n    } else {\n        print_as(\"\\nMigration summary:\\n\");\n    }\n\n    for (node_state = __xml_first_child(cib_status); node_state != NULL;\n         node_state = __xml_next(node_state)) {\n        if (crm_str_eq((const char *)node_state->name, XML_CIB_TAG_STATE, TRUE)) {\n            node_t *node = pe_find_node_id(data_set->nodes, ID(node_state));\n\n            if (node == NULL || node->details->online == FALSE) {\n                continue;\n            }\n\n            print_as(\"* Node %s: \", crm_element_value(node_state, XML_ATTR_UNAME));\n            print_as(\"\\n\");\n\n            lrm_rsc = find_xml_node(node_state, XML_CIB_TAG_LRM, FALSE);\n            lrm_rsc = find_xml_node(lrm_rsc, XML_LRM_TAG_RESOURCES, FALSE);\n\n            for (rsc_entry = __xml_first_child(lrm_rsc); rsc_entry != NULL;\n                 rsc_entry = __xml_next(rsc_entry)) {\n                if (crm_str_eq((const char *)rsc_entry->name, XML_LRM_TAG_RESOURCE, TRUE)) {\n                    if (operations) {\n                        print_rsc_history(data_set, node, rsc_entry);\n\n                    } else {\n                        const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);\n                        resource_t *rsc = pe_find_resource(data_set->resources, rsc_id);\n\n                        if (rsc) {\n                            print_rsc_summary(data_set, node, rsc, FALSE);\n                        } else {\n                            print_as(\"   %s: orphan\\n\", rsc_id);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nstatic void\nprint_ticket(gpointer name, gpointer value, gpointer data)\n{\n    ticket_t *ticket = (ticket_t *) value;\n\n    print_as(\" %s\\t%s%10s\", ticket->id,\n             ticket->granted ? \"granted\":\"revoked\",\n             ticket->standby ? \" [standby]\":\"\");\n    if (ticket->last_granted > -1) {\n        print_as(\" last-granted=\");\n        print_date(ticket->last_granted);\n    }\n    print_as(\"\\n\");\n\n    return;\n}\n\nstatic void\nprint_cluster_tickets(pe_working_set_t * data_set)\n{\n    xmlNode *cib_constraints = get_object_root(XML_CIB_TAG_CONSTRAINTS, data_set->input);\n\n    /* For recording the tickets that are referenced in rsc_ticket constraints\n     * but have never been granted yet. */\n    unpack_constraints(cib_constraints, data_set);\n\n    print_as(\"\\nTickets:\\n\");\n    g_hash_table_foreach(data_set->tickets, print_ticket, NULL);\n\n    return;\n}\n\nstatic int\nprint_status(pe_working_set_t * data_set)\n{\n    static int updates = 0;\n\n    GListPtr gIter = NULL;\n    node_t *dc = NULL;\n    char *since_epoch = NULL;\n    char *online_nodes = NULL;\n    char *offline_nodes = NULL;\n    xmlNode *dc_version = NULL;\n    xmlNode *quorum_node = NULL;\n    xmlNode *stack = NULL;\n    time_t a_time = time(NULL);\n\n    int print_opts = pe_print_ncurses;\n    const char *quorum_votes = \"unknown\";\n\n    if (as_console) {\n        blank_screen();\n    } else {\n        print_opts = pe_print_printf;\n    }\n\n    updates++;\n    dc = data_set->dc_node;\n\n    if (a_time == (time_t) - 1) {\n        crm_perror(LOG_ERR, \"set_node_tstamp(): Invalid time returned\");\n        return 1;\n    }\n\n    since_epoch = ctime(&a_time);\n    if (since_epoch != NULL && print_last_updated) {\n        print_as(\"Last updated: %s\", since_epoch);\n    }\n\n    if (print_last_change) {\n        const char *last_written = crm_element_value(data_set->input, XML_CIB_ATTR_WRITTEN);\n        const char *user = crm_element_value(data_set->input, XML_ATTR_UPDATE_USER);\n        const char *client = crm_element_value(data_set->input, XML_ATTR_UPDATE_CLIENT);\n        const char *origin = crm_element_value(data_set->input, XML_ATTR_UPDATE_ORIG);\n\n        print_as(\"Last change: %s\", last_written ? last_written : \"\");\n        if (user) {\n            print_as(\" by %s\", user);\n        }\n        if (client) {\n            print_as(\" via %s\", client);\n        }\n        if (origin) {\n            print_as(\" on %s\", origin);\n        }\n        print_as(\"\\n\");\n    }\n\n    stack =\n        get_xpath_object(\"//nvpair[@name='cluster-infrastructure']\", data_set->input, LOG_DEBUG);\n    if (stack) {\n        print_as(\"Stack: %s\\n\", crm_element_value(stack, XML_NVPAIR_ATTR_VALUE));\n    }\n\n    dc_version = get_xpath_object(\"//nvpair[@name='dc-version']\", data_set->input, LOG_DEBUG);\n    if (dc == NULL) {\n        print_as(\"Current DC: NONE\\n\");\n    } else {\n        const char *quorum = crm_element_value(data_set->input, XML_ATTR_HAVE_QUORUM);\n\n        if (safe_str_neq(dc->details->uname, dc->details->id)) {\n            print_as(\"Current DC: %s (%s)\", dc->details->uname, dc->details->id);\n        } else {\n            print_as(\"Current DC: %s\", dc->details->uname);\n        }\n        print_as(\" - partition %s quorum\\n\", crm_is_true(quorum) ? \"with\" : \"WITHOUT\");\n        if (dc_version) {\n            print_as(\"Version: %s\\n\", crm_element_value(dc_version, XML_NVPAIR_ATTR_VALUE));\n        }\n    }\n\n    quorum_node =\n        get_xpath_object(\"//nvpair[@name='\" XML_ATTR_EXPECTED_VOTES \"']\", data_set->input,\n                         LOG_DEBUG);\n    if (quorum_node) {\n        quorum_votes = crm_element_value(quorum_node, XML_NVPAIR_ATTR_VALUE);\n    }\n\n    print_as(\"%d Nodes configured, %s expected votes\\n\", g_list_length(data_set->nodes),\n             quorum_votes);\n    print_as(\"%d Resources configured.\\n\", count_resources(data_set, NULL));\n    print_as(\"\\n\\n\");\n\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n        const char *node_mode = NULL;\n\n        if (node->details->unclean) {\n            if (node->details->online && node->details->unclean) {\n                node_mode = \"UNCLEAN (online)\";\n\n            } else if (node->details->pending) {\n                node_mode = \"UNCLEAN (pending)\";\n\n            } else {\n                node_mode = \"UNCLEAN (offline)\";\n            }\n\n        } else if (node->details->pending) {\n            node_mode = \"pending\";\n\n        } else if (node->details->standby_onfail && node->details->online) {\n            node_mode = \"standby (on-fail)\";\n\n        } else if (node->details->standby) {\n            if (node->details->online) {\n                node_mode = \"standby\";\n            } else {\n                node_mode = \"OFFLINE (standby)\";\n            }\n\n        } else if (node->details->online) {\n            node_mode = \"online\";\n            if (group_by_node == FALSE) {\n                online_nodes = add_list_element(online_nodes, node->details->uname);\n                continue;\n            }\n\n        } else {\n            node_mode = \"OFFLINE\";\n            if (group_by_node == FALSE) {\n                offline_nodes = add_list_element(offline_nodes, node->details->uname);\n                continue;\n            }\n        }\n\n        if (safe_str_eq(node->details->uname, node->details->id)) {\n            print_as(\"Node %s: %s\\n\", node->details->uname, node_mode);\n        } else {\n            print_as(\"Node %s (%s): %s\\n\", node->details->uname, node->details->id, node_mode);\n        }\n\n        if (group_by_node) {\n            GListPtr gIter2 = NULL;\n\n            for (gIter2 = node->details->running_rsc; gIter2 != NULL; gIter2 = gIter2->next) {\n                resource_t *rsc = (resource_t *) gIter2->data;\n\n                rsc->fns->print(rsc, \"\\t\", print_opts | pe_print_rsconly, stdout);\n            }\n        }\n    }\n\n    if (online_nodes) {\n        print_as(\"Online: [%s ]\\n\", online_nodes);\n        free(online_nodes);\n    }\n    if (offline_nodes) {\n        print_as(\"OFFLINE: [%s ]\\n\", offline_nodes);\n        free(offline_nodes);\n    }\n\n    if (group_by_node == FALSE && inactive_resources) {\n        print_as(\"\\nFull list of resources:\\n\");\n\n    } else if (inactive_resources) {\n        print_as(\"\\nInactive resources:\\n\");\n    }\n\n    if (group_by_node == FALSE || inactive_resources) {\n        print_as(\"\\n\");\n        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {\n            resource_t *rsc = (resource_t *) gIter->data;\n\n            gboolean is_active = rsc->fns->active(rsc, TRUE);\n            gboolean partially_active = rsc->fns->active(rsc, FALSE);\n\n            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {\n                continue;\n\n            } else if (group_by_node == FALSE) {\n                if (partially_active || inactive_resources) {\n                    rsc->fns->print(rsc, NULL, print_opts, stdout);\n                }\n\n            } else if (is_active == FALSE && inactive_resources) {\n                rsc->fns->print(rsc, NULL, print_opts, stdout);\n            }\n        }\n    }\n\n    if (print_nodes_attr) {\n        print_as(\"\\nNode Attributes:\\n\");\n        for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n            node_t *node = (node_t *) gIter->data;\n\n            if (node == NULL || node->details->online == FALSE) {\n                continue;\n            }\n            attr_list = NULL;\n            print_as(\"* Node %s:\\n\", node->details->uname);\n            g_hash_table_foreach(node->details->attrs, create_attr_list, NULL);\n            g_list_foreach(attr_list, print_node_attribute, node);\n        }\n    }\n\n    if (print_operations || print_failcount) {\n        print_node_summary(data_set, print_operations);\n    }\n\n    if (xml_has_children(data_set->failed)) {\n        xmlNode *xml_op = NULL;\n\n        print_as(\"\\nFailed actions:\\n\");\n        for (xml_op = __xml_first_child(data_set->failed); xml_op != NULL;\n             xml_op = __xml_next(xml_op)) {\n            int val = 0;\n            const char *id = ID(xml_op);\n            const char *op_key = crm_element_value(xml_op, XML_LRM_ATTR_TASK_KEY);\n            const char *last = crm_element_value(xml_op, \"last_run\");\n            const char *node = crm_element_value(xml_op, XML_ATTR_UNAME);\n            const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);\n            const char *rc = crm_element_value(xml_op, XML_LRM_ATTR_RC);\n            const char *status = crm_element_value(xml_op, XML_LRM_ATTR_OPSTATUS);\n\n            val = crm_parse_int(status, \"0\");\n            print_as(\"    %s (node=%s, call=%s, rc=%s, status=%s\",\n                     op_key ? op_key : id, node, call, rc, services_lrm_status_str(val));\n\n            if (last) {\n                time_t run_at = crm_parse_int(last, \"0\");\n\n                print_as(\", last-run=%s, queued=%sms, exec=%sms\\n\",\n                         ctime(&run_at),\n                         crm_element_value(xml_op, \"exec_time\"),\n                         crm_element_value(xml_op, \"queue_time\"));\n            }\n\n            val = crm_parse_int(rc, \"0\");\n            print_as(\"): %s\\n\", lrmd_event_rc2str(val));\n        }\n    }\n\n    if (print_tickets) {\n        print_cluster_tickets(data_set);\n    }\n\n#if CURSES_ENABLED\n    if (as_console) {\n        refresh();\n    }\n#endif\n    return 0;\n}\n\nstatic int\nprint_xml_status(pe_working_set_t * data_set)\n{\n    FILE *stream = stdout;\n    GListPtr gIter = NULL;\n    node_t *dc = NULL;\n    xmlNode *stack = NULL;\n    xmlNode *quorum_node = NULL;\n    const char *quorum_votes = \"unknown\";\n\n    dc = data_set->dc_node;\n\n\n    fprintf(stream, \"<?xml version=\\\"1.0\\\"?>\\n\");\n    fprintf(stream, \"<crm_mon version=\\\"%s\\\">\\n\", VERSION);\n\n    /*** SUMMARY ***/\n    fprintf(stream, \"    <summary>\\n\");\n\n    if (print_last_updated) {\n        time_t now = time(NULL);\n        char *now_str = ctime(&now);\n\n        now_str[24] = EOS;      /* replace the newline */\n        fprintf(stream, \"        <last_update time=\\\"%s\\\" />\\n\", now_str);\n    }\n\n    if (print_last_change) {\n        const char *last_written = crm_element_value(data_set->input, XML_CIB_ATTR_WRITTEN);\n        const char *user = crm_element_value(data_set->input, XML_ATTR_UPDATE_USER);\n        const char *client = crm_element_value(data_set->input, XML_ATTR_UPDATE_CLIENT);\n        const char *origin = crm_element_value(data_set->input, XML_ATTR_UPDATE_ORIG);\n\n        fprintf(stream, \"        <last_change time=\\\"%s\\\" user=\\\"%s\\\" client=\\\"%s\\\" origin=\\\"%s\\\" />\\n\",\n            last_written ? last_written : \"\",\n            user ? user : \"\",\n            client ? client : \"\",\n            origin ? origin : \"\");\n    }\n\n    stack = get_xpath_object(\"//nvpair[@name='cluster-infrastructure']\",\n        data_set->input,\n        LOG_DEBUG);\n    if (stack) {\n        fprintf(stream, \"        <stack type=\\\"%s\\\" />\\n\", crm_element_value(stack, XML_NVPAIR_ATTR_VALUE));\n    }\n\n    if (!dc) {\n        fprintf(stream, \"        <current_dc present=\\\"false\\\" />\\n\");\n    } else {\n        const char *quorum = crm_element_value(data_set->input, XML_ATTR_HAVE_QUORUM);\n        const char *uname = dc->details->uname;\n        const char *id = dc->details->id;\n        xmlNode *dc_version = get_xpath_object(\"//nvpair[@name='dc-version']\",\n            data_set->input,\n            LOG_DEBUG);\n        fprintf(stream, \"        <current_dc present=\\\"true\\\" version=\\\"%s\\\" name=\\\"%s\\\" id=\\\"%s\\\" with_quorum=\\\"%s\\\" />\\n\",\n            dc_version ? crm_element_value(dc_version, XML_NVPAIR_ATTR_VALUE) : \"\",\n            uname,\n            id,\n            quorum ? (crm_is_true(quorum) ? \"true\" : \"false\") : \"false\");\n    }\n\n    quorum_node = get_xpath_object(\"//nvpair[@name='\" XML_ATTR_EXPECTED_VOTES \"']\",\n                    data_set->input,\n                    LOG_DEBUG);\n    if (quorum_node) {\n        quorum_votes = crm_element_value(quorum_node, XML_NVPAIR_ATTR_VALUE);\n    }\n    fprintf(stream, \"        <nodes_configured number=\\\"%d\\\" expected_votes=\\\"%s\\\" />\\n\",\n        g_list_length(data_set->nodes),\n        quorum_votes);\n\n    fprintf(stream, \"        <resources_configured number=\\\"%d\\\" />\\n\", count_resources(data_set, NULL));\n\n    fprintf(stream, \"    </summary>\\n\");\n\n    /*** NODES ***/\n    fprintf(stream, \"    <nodes>\\n\");\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n        const char *node_type = \"unknown\";\n\n        switch (node->details->type) {\n        case node_member:\n            node_type = \"member\";\n            break;\n        case node_ping:\n            node_type = \"ping\";\n            break;\n        }\n\n        fprintf(stream, \"        <node name=\\\"%s\\\" \", node->details->uname);\n        fprintf(stream, \"id=\\\"%s\\\" \", node->details->id);\n        fprintf(stream, \"online=\\\"%s\\\" \", node->details->online ? \"true\" : \"false\");\n        fprintf(stream, \"standby=\\\"%s\\\" \", node->details->standby ? \"true\" : \"false\");\n        fprintf(stream, \"standby_onfail=\\\"%s\\\" \", node->details->standby_onfail ? \"true\" : \"false\");\n        fprintf(stream, \"pending=\\\"%s\\\" \", node->details->pending ? \"true\" : \"false\");\n        fprintf(stream, \"unclean=\\\"%s\\\" \", node->details->unclean ? \"true\" : \"false\");\n        fprintf(stream, \"shutdown=\\\"%s\\\" \", node->details->shutdown ? \"true\" : \"false\");\n        fprintf(stream, \"expected_up=\\\"%s\\\" \", node->details->expected_up ? \"true\" : \"false\");\n        fprintf(stream, \"is_dc=\\\"%s\\\" \", node->details->is_dc ? \"true\" : \"false\");\n        fprintf(stream, \"resources_running=\\\"%d\\\" \", g_list_length(node->details->running_rsc));\n        fprintf(stream, \"type=\\\"%s\\\" \", node_type);\n\n        if (group_by_node) {\n            GListPtr lpc2 = NULL;\n            fprintf(stream, \">\\n\");\n            for (lpc2 = node->details->running_rsc; lpc2 != NULL; lpc2 = lpc2->next) {\n                resource_t *rsc = (resource_t *) lpc2->data;\n\n                rsc->fns->print(rsc, \"            \", pe_print_xml | pe_print_rsconly, stream);\n            }\n            fprintf(stream, \"        </node>\\n\");\n        } else {\n            fprintf(stream, \"/>\\n\");\n        }\n    }\n    fprintf(stream, \"    </nodes>\\n\");\n\n    /*** RESOURCES ***/\n    if (group_by_node == FALSE || inactive_resources) {\n        fprintf(stream, \"    <resources>\\n\");\n        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {\n            resource_t *rsc = (resource_t *) gIter->data;\n            gboolean is_active = rsc->fns->active(rsc, TRUE);\n            gboolean partially_active = rsc->fns->active(rsc, FALSE);\n\n            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {\n                continue;\n\n            } else if (group_by_node == FALSE) {\n                if (partially_active || inactive_resources) {\n                    rsc->fns->print(rsc, \"        \", pe_print_xml, stream);\n                }\n\n            } else if (is_active == FALSE && inactive_resources) {\n                rsc->fns->print(rsc, \"        \", pe_print_xml, stream);\n            }\n        }\n        fprintf(stream, \"    </resources>\\n\");\n    }\n\n    fprintf(stream, \"</crm_mon>\\n\");\n    fflush(stream);\n    fclose(stream);\n\n    return 0;\n}\n\nstatic int\nprint_html_status(pe_working_set_t * data_set, const char *filename, gboolean web_cgi)\n{\n    FILE *stream;\n    GListPtr gIter = NULL;\n    node_t *dc = NULL;\n    static int updates = 0;\n    char *filename_tmp = NULL;\n\n    if (web_cgi) {\n        stream = stdout;\n        fprintf(stream, \"Content-type: text/html\\n\\n\");\n\n    } else {\n        filename_tmp = crm_concat(filename, \"tmp\", '.');\n        stream = fopen(filename_tmp, \"w\");\n        if (stream == NULL) {\n            crm_perror(LOG_ERR, \"Cannot open %s for writing\", filename_tmp);\n            free(filename_tmp);\n            return -1;\n        }\n    }\n\n    updates++;\n    dc = data_set->dc_node;\n\n    fprintf(stream, \"<html>\");\n    fprintf(stream, \"<head>\");\n    fprintf(stream, \"<title>Cluster status</title>\");\n/* content=\"%d;url=http://webdesign.about.com\" */\n    fprintf(stream, \"<meta http-equiv=\\\"refresh\\\" content=\\\"%d\\\">\", reconnect_msec / 1000);\n    fprintf(stream, \"</head>\");\n\n    /*** SUMMARY ***/\n\n    fprintf(stream, \"<h2>Cluster summary</h2>\");\n    {\n        char *now_str = NULL;\n        time_t now = time(NULL);\n\n        now_str = ctime(&now);\n        now_str[24] = EOS;      /* replace the newline */\n        fprintf(stream, \"Last updated: <b>%s</b><br/>\\n\", now_str);\n    }\n\n    if (dc == NULL) {\n        fprintf(stream, \"Current DC: <font color=\\\"red\\\"><b>NONE</b></font><br/>\");\n    } else {\n        fprintf(stream, \"Current DC: %s (%s)<br/>\", dc->details->uname, dc->details->id);\n    }\n    fprintf(stream, \"%d Nodes configured.<br/>\", g_list_length(data_set->nodes));\n    fprintf(stream, \"%d Resources configured.<br/>\", count_resources(data_set, NULL));\n\n    /*** CONFIG ***/\n\n    fprintf(stream, \"<h3>Config Options</h3>\\n\");\n\n    fprintf(stream, \"<table>\\n\");\n    fprintf(stream, \"<tr><td>STONITH of failed nodes</td><td>:</td><td>%s</td></tr>\\n\",\n            is_set(data_set->flags, pe_flag_stonith_enabled) ? \"enabled\" : \"disabled\");\n\n    fprintf(stream, \"<tr><td>Cluster is</td><td>:</td><td>%ssymmetric</td></tr>\\n\",\n            is_set(data_set->flags, pe_flag_symmetric_cluster) ? \"\" : \"a-\");\n\n    fprintf(stream, \"<tr><td>No Quorum Policy</td><td>:</td><td>\");\n    switch (data_set->no_quorum_policy) {\n        case no_quorum_freeze:\n            fprintf(stream, \"Freeze resources\");\n            break;\n        case no_quorum_stop:\n            fprintf(stream, \"Stop ALL resources\");\n            break;\n        case no_quorum_ignore:\n            fprintf(stream, \"Ignore\");\n            break;\n        case no_quorum_suicide:\n            fprintf(stream, \"Suicide\");\n            break;\n    }\n    fprintf(stream, \"\\n</td></tr>\\n</table>\\n\");\n\n    /*** NODE LIST ***/\n\n    fprintf(stream, \"<h2>Node List</h2>\\n\");\n    fprintf(stream, \"<ul>\\n\");\n    for (gIter = data_set->nodes; gIter != NULL; gIter = gIter->next) {\n        node_t *node = (node_t *) gIter->data;\n\n        fprintf(stream, \"<li>\");\n        if (node->details->standby_onfail && node->details->online) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"orange\\\">standby (on-fail)</font>\\n\");\n        } else if (node->details->standby && node->details->online) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"orange\\\">standby</font>\\n\");\n        } else if (node->details->standby) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"red\\\">OFFLINE (standby)</font>\\n\");\n        } else if (node->details->online) {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"green\\\">online</font>\\n\");\n        } else {\n            fprintf(stream, \"Node: %s (%s): %s\", node->details->uname, node->details->id,\n                    \"<font color=\\\"red\\\">OFFLINE</font>\\n\");\n        }\n        if (group_by_node) {\n            GListPtr lpc2 = NULL;\n\n            fprintf(stream, \"<ul>\\n\");\n            for (lpc2 = node->details->running_rsc; lpc2 != NULL; lpc2 = lpc2->next) {\n                resource_t *rsc = (resource_t *) lpc2->data;\n\n                fprintf(stream, \"<li>\");\n                rsc->fns->print(rsc, NULL, pe_print_html | pe_print_rsconly, stream);\n                fprintf(stream, \"</li>\\n\");\n            }\n            fprintf(stream, \"</ul>\\n\");\n        }\n        fprintf(stream, \"</li>\\n\");\n    }\n    fprintf(stream, \"</ul>\\n\");\n\n    if (group_by_node && inactive_resources) {\n        fprintf(stream, \"<h2>Inactive Resources</h2>\\n\");\n\n    } else if (group_by_node == FALSE) {\n        fprintf(stream, \"<h2>Resource List</h2>\\n\");\n    }\n\n    if (group_by_node == FALSE || inactive_resources) {\n        for (gIter = data_set->resources; gIter != NULL; gIter = gIter->next) {\n            resource_t *rsc = (resource_t *) gIter->data;\n            gboolean is_active = rsc->fns->active(rsc, TRUE);\n            gboolean partially_active = rsc->fns->active(rsc, FALSE);\n\n            if (is_set(rsc->flags, pe_rsc_orphan) && is_active == FALSE) {\n                continue;\n\n            } else if (group_by_node == FALSE) {\n                if (partially_active || inactive_resources) {\n                    rsc->fns->print(rsc, NULL, pe_print_html, stream);\n                }\n\n            } else if (is_active == FALSE && inactive_resources) {\n                rsc->fns->print(rsc, NULL, pe_print_html, stream);\n            }\n        }\n    }\n\n    fprintf(stream, \"</html>\");\n    fflush(stream);\n    fclose(stream);\n\n    if (!web_cgi) {\n        if (rename(filename_tmp, filename) != 0) {\n            crm_perror(LOG_ERR, \"Unable to rename %s->%s\", filename_tmp, filename);\n        }\n        free(filename_tmp);\n    }\n    return 0;\n}\n\n#if ENABLE_SNMP\n#  include <net-snmp/net-snmp-config.h>\n#  include <net-snmp/snmpv3_api.h>\n#  include <net-snmp/agent/agent_trap.h>\n#  include <net-snmp/library/snmp_client.h>\n#  include <net-snmp/library/mib.h>\n#  include <net-snmp/library/snmp_debug.h>\n\n#  define add_snmp_field(list, oid_string, value) do {\t\t\t\\\n\toid name[MAX_OID_LEN];\t\t\t\t\t\t\\\n        size_t name_length = MAX_OID_LEN;\t\t\t\t\\\n\tif (snmp_parse_oid(oid_string, name, &name_length)) {\t\t\\\n\t    int s_rc = snmp_add_var(list, name, name_length, 's', (value)); \\\n\t    if(s_rc != 0) {\t\t\t\t\t\t\\\n\t\tcrm_err(\"Could not add %s=%s rc=%d\", oid_string, value, s_rc); \\\n\t    } else {\t\t\t\t\t\t\t\\\n\t\tcrm_trace(\"Added %s=%s\", oid_string, value);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t    crm_err(\"Could not parse OID: %s\", oid_string);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    } while(0)\t\t\t\t\t\t\t\t\\\n\n#  define add_snmp_field_int(list, oid_string, value) do {\t\t\\\n\toid name[MAX_OID_LEN];\t\t\t\t\t\t\\\n        size_t name_length = MAX_OID_LEN;\t\t\t\t\\\n\tif (snmp_parse_oid(oid_string, name, &name_length)) {\t\t\\\n\t    if(NULL == snmp_pdu_add_variable(\t\t\t\t\\\n\t\t   list, name, name_length, ASN_INTEGER,\t\t\\\n\t\t   (u_char *) & value, sizeof(value))) {\t\t\\\n\t\tcrm_err(\"Could not add %s=%d\", oid_string, value);\t\\\n\t    } else {\t\t\t\t\t\t\t\\\n\t\tcrm_trace(\"Added %s=%d\", oid_string, value);\t\t\\\n\t    }\t\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t    crm_err(\"Could not parse OID: %s\", oid_string);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n    } while(0)\t\t\t\t\t\t\t\t\\\n\nstatic int\nsnmp_input(int operation, netsnmp_session * session, int reqid, netsnmp_pdu * pdu, void *magic)\n{\n    return 1;\n}\n\nstatic netsnmp_session *\ncrm_snmp_init(const char *target, char *community)\n{\n    static netsnmp_session *session = NULL;\n\n#  ifdef NETSNMPV53\n    char target53[128];\n\n    snprintf(target53, sizeof(target53), \"%s:162\", target);\n#  endif\n\n    if (session) {\n        return session;\n    }\n\n    if (target == NULL) {\n        return NULL;\n    }\n\n    if (get_crm_log_level() > LOG_INFO) {\n        char *debug_tokens = strdup(\"run:shell,snmptrap,tdomain\");\n\n        debug_register_tokens(debug_tokens);\n        snmp_set_do_debugging(1);\n    }\n\n    session = calloc(1, sizeof(netsnmp_session));\n    snmp_sess_init(session);\n    session->version = SNMP_VERSION_2c;\n    session->callback = snmp_input;\n    session->callback_magic = NULL;\n\n    if (community) {\n        session->community_len = strlen(community);\n        session->community = (unsigned char *)community;\n    }\n\n    session = snmp_add(session,\n#  ifdef NETSNMPV53\n                       netsnmp_tdomain_transport(target53, 0, \"udp\"),\n#  else\n                       netsnmp_transport_open_client(\"snmptrap\", target),\n#  endif\n                       NULL, NULL);\n\n    if (session == NULL) {\n        snmp_sess_perror(\"Could not create snmp transport\", session);\n    }\n    return session;\n}\n\n#endif\n\nstatic int\nsend_snmp_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,\n               int status, const char *desc)\n{\n    int ret = 1;\n\n#if ENABLE_SNMP\n    static oid snmptrap_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };\n    static oid sysuptime_oid[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };\n\n    netsnmp_pdu *trap_pdu;\n    netsnmp_session *session = crm_snmp_init(snmp_target, snmp_community);\n\n    trap_pdu = snmp_pdu_create(SNMP_MSG_TRAP2);\n    if (!trap_pdu) {\n        crm_err(\"Failed to create SNMP notification\");\n        return SNMPERR_GENERR;\n    }\n\n    if (1) {\n        /* send uptime */\n        char csysuptime[20];\n        time_t now = time(NULL);\n\n        sprintf(csysuptime, \"%ld\", now);\n        snmp_add_var(trap_pdu, sysuptime_oid, sizeof(sysuptime_oid) / sizeof(oid), 't', csysuptime);\n    }\n\n    /* Indicate what the trap is by setting snmpTrapOid.0 */\n    ret =\n        snmp_add_var(trap_pdu, snmptrap_oid, sizeof(snmptrap_oid) / sizeof(oid), 'o',\n                     snmp_crm_trap_oid);\n    if (ret != 0) {\n        crm_err(\"Failed set snmpTrapOid.0=%s\", snmp_crm_trap_oid);\n        return ret;\n    }\n\n    /* Add extries to the trap */\n    if (rsc) {\n        add_snmp_field(trap_pdu, snmp_crm_oid_rsc, rsc);\n    }\n    add_snmp_field(trap_pdu, snmp_crm_oid_node, node);\n    add_snmp_field(trap_pdu, snmp_crm_oid_task, task);\n    add_snmp_field(trap_pdu, snmp_crm_oid_desc, desc);\n\n    add_snmp_field_int(trap_pdu, snmp_crm_oid_rc, rc);\n    add_snmp_field_int(trap_pdu, snmp_crm_oid_trc, target_rc);\n    add_snmp_field_int(trap_pdu, snmp_crm_oid_status, status);\n\n    /* Send and cleanup */\n    ret = snmp_send(session, trap_pdu);\n    if (ret == 0) {\n        /* error */\n        snmp_sess_perror(\"Could not send SNMP trap\", session);\n        snmp_free_pdu(trap_pdu);\n        ret = SNMPERR_GENERR;\n    } else {\n        ret = SNMPERR_SUCCESS;\n    }\n#else\n    crm_err(\"Sending SNMP traps is not supported by this installation\");\n#endif\n    return ret;\n}\n\n#if ENABLE_ESMTP\n#  include <auth-client.h>\n#  include <libesmtp.h>\n\nstatic void\nprint_recipient_status(smtp_recipient_t recipient, const char *mailbox, void *arg)\n{\n    const smtp_status_t *status;\n\n    status = smtp_recipient_status(recipient);\n    printf(\"%s: %d %s\", mailbox, status->code, status->text);\n}\n\nstatic void\nevent_cb(smtp_session_t session, int event_no, void *arg, ...)\n{\n    int *ok;\n    va_list alist;\n\n    va_start(alist, arg);\n    switch (event_no) {\n        case SMTP_EV_CONNECT:\n        case SMTP_EV_MAILSTATUS:\n        case SMTP_EV_RCPTSTATUS:\n        case SMTP_EV_MESSAGEDATA:\n        case SMTP_EV_MESSAGESENT:\n        case SMTP_EV_DISCONNECT:\n            break;\n\n        case SMTP_EV_WEAK_CIPHER:{\n                int bits = va_arg(alist, long);\n                ok = va_arg(alist, int *);\n\n                crm_debug(\"SMTP_EV_WEAK_CIPHER, bits=%d - accepted.\", bits);\n                *ok = 1;\n                break;\n            }\n        case SMTP_EV_STARTTLS_OK:\n            crm_debug(\"SMTP_EV_STARTTLS_OK - TLS started here.\");\n            break;\n\n        case SMTP_EV_INVALID_PEER_CERTIFICATE:{\n                long vfy_result = va_arg(alist, long);\n                ok = va_arg(alist, int *);\n\n                /* There is a table in handle_invalid_peer_certificate() of mail-file.c */\n                crm_err(\"SMTP_EV_INVALID_PEER_CERTIFICATE: %ld\", vfy_result);\n                *ok = 1;\n                break;\n            }\n        case SMTP_EV_NO_PEER_CERTIFICATE:\n            ok = va_arg(alist, int *);\n\n            crm_debug(\"SMTP_EV_NO_PEER_CERTIFICATE - accepted.\");\n            *ok = 1;\n            break;\n        case SMTP_EV_WRONG_PEER_CERTIFICATE:\n            ok = va_arg(alist, int *);\n\n            crm_debug(\"SMTP_EV_WRONG_PEER_CERTIFICATE - accepted.\");\n            *ok = 1;\n            break;\n        case SMTP_EV_NO_CLIENT_CERTIFICATE:\n            ok = va_arg(alist, int *);\n\n            crm_debug(\"SMTP_EV_NO_CLIENT_CERTIFICATE - accepted.\");\n            *ok = 1;\n            break;\n        default:\n            crm_debug(\"Got event: %d - ignored.\\n\", event_no);\n    }\n    va_end(alist);\n}\n#endif\n\n#define BODY_MAX 2048\n\n#if ENABLE_ESMTP\nstatic void\ncrm_smtp_debug(const char *buf, int buflen, int writing, void *arg)\n{\n    char type = 0;\n    int lpc = 0, last = 0, level = *(int *)arg;\n\n    if (writing == SMTP_CB_HEADERS) {\n        type = 'H';\n    } else if (writing) {\n        type = 'C';\n    } else {\n        type = 'S';\n    }\n\n    for (; lpc < buflen; lpc++) {\n        switch (buf[lpc]) {\n            case 0:\n            case '\\n':\n                if (last > 0) {\n                    do_crm_log(level, \"   %.*s\", lpc - last, buf + last);\n                } else {\n                    do_crm_log(level, \"%c: %.*s\", type, lpc - last, buf + last);\n                }\n                last = lpc + 1;\n                break;\n        }\n    }\n}\n#endif\n\nstatic int\nsend_custom_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,\n                 int status, const char *desc)\n{\n    pid_t pid;\n\n    /*setenv needs chars, these are ints */\n    char *rc_s = crm_itoa(rc);\n    char *status_s = crm_itoa(status);\n    char *target_rc_s = crm_itoa(target_rc);\n\n    crm_debug(\"Sending external notification to '%s' via '%s'\", external_recipient, external_agent);\n\n    setenv(\"CRM_notify_recipient\", external_recipient, 1);\n    setenv(\"CRM_notify_node\", node, 1);\n    setenv(\"CRM_notify_rsc\", rsc, 1);\n    setenv(\"CRM_notify_task\", task, 1);\n    setenv(\"CRM_notify_desc\", desc, 1);\n    setenv(\"CRM_notify_rc\", rc_s, 1);\n    setenv(\"CRM_notify_target_rc\", target_rc_s, 1);\n    setenv(\"CRM_notify_status\", status_s, 1);\n\n    pid = fork();\n    if (pid == -1) {\n        crm_perror(LOG_ERR, \"notification fork() failed.\");\n    }\n    if (pid == 0) {\n        /* crm_debug(\"notification: I am the child. Executing the nofitication program.\"); */\n        execl(external_agent, external_agent, NULL);\n    }\n\n    crm_trace(\"Finished running custom notification program '%s'.\", external_agent);\n    free(target_rc_s);\n    free(status_s);\n    free(rc_s);\n    return 0;\n}\n\nstatic int\nsend_smtp_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,\n               int status, const char *desc)\n{\n#if ENABLE_ESMTP\n    smtp_session_t session;\n    smtp_message_t message;\n    auth_context_t authctx;\n    struct sigaction sa;\n\n    int len = 20;\n    int noauth = 1;\n    int smtp_debug = LOG_DEBUG;\n    char crm_mail_body[BODY_MAX];\n    char *crm_mail_subject = NULL;\n\n    memset(&sa, 0, sizeof(struct sigaction));\n\n    if (node == NULL) {\n        node = \"-\";\n    }\n    if (rsc == NULL) {\n        rsc = \"-\";\n    }\n    if (desc == NULL) {\n        desc = \"-\";\n    }\n\n    if (crm_mail_to == NULL) {\n        return 1;\n    }\n\n    if (crm_mail_host == NULL) {\n        crm_mail_host = \"localhost:25\";\n    }\n\n    if (crm_mail_prefix == NULL) {\n        crm_mail_prefix = \"Cluster notification\";\n    }\n\n    crm_debug(\"Sending '%s' mail to %s via %s\", crm_mail_prefix, crm_mail_to, crm_mail_host);\n\n    len += strlen(crm_mail_prefix);\n    len += strlen(task);\n    len += strlen(rsc);\n    len += strlen(node);\n    len += strlen(desc);\n    len++;\n\n    crm_mail_subject = calloc(1, len);\n    snprintf(crm_mail_subject, len, \"%s - %s event for %s on %s: %s\\r\\n\", crm_mail_prefix, task,\n             rsc, node, desc);\n\n    len = 0;\n    len += snprintf(crm_mail_body + len, BODY_MAX - len, \"\\r\\n%s\\r\\n\", crm_mail_prefix);\n    len += snprintf(crm_mail_body + len, BODY_MAX - len, \"====\\r\\n\\r\\n\");\n    if (rc == target_rc) {\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"Completed operation %s for resource %s on %s\\r\\n\", task, rsc, node);\n    } else {\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"Operation %s for resource %s on %s failed: %s\\r\\n\", task, rsc, node, desc);\n    }\n\n    len += snprintf(crm_mail_body + len, BODY_MAX - len, \"\\r\\nDetails:\\r\\n\");\n    len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                    \"\\toperation status: (%d) %s\\r\\n\", status, services_lrm_status_str(status));\n    if (status == PCMK_LRM_OP_DONE) {\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"\\tscript returned: (%d) %s\\r\\n\", rc, lrmd_event_rc2str(rc));\n        len += snprintf(crm_mail_body + len, BODY_MAX - len,\n                        \"\\texpected return value: (%d) %s\\r\\n\", target_rc,\n                        lrmd_event_rc2str(target_rc));\n    }\n\n    auth_client_init();\n    session = smtp_create_session();\n    message = smtp_add_message(session);\n\n    smtp_starttls_enable(session, Starttls_ENABLED);\n\n    sa.sa_handler = SIG_IGN;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGPIPE, &sa, NULL);\n\n    smtp_set_server(session, crm_mail_host);\n\n    authctx = auth_create_context();\n    auth_set_mechanism_flags(authctx, AUTH_PLUGIN_PLAIN, 0);\n\n    smtp_set_eventcb(session, event_cb, NULL);\n\n    /* Now tell libESMTP it can use the SMTP AUTH extension.\n     */\n    if (!noauth) {\n        crm_debug(\"Adding authentication context\");\n        smtp_auth_set_context(session, authctx);\n    }\n\n    if (crm_mail_from == NULL) {\n        struct utsname us;\n        char auto_from[BODY_MAX];\n\n        CRM_ASSERT(uname(&us) == 0);\n        snprintf(auto_from, BODY_MAX, \"crm_mon@%s\", us.nodename);\n        smtp_set_reverse_path(message, auto_from);\n\n    } else {\n        /* NULL is ok */\n        smtp_set_reverse_path(message, crm_mail_from);\n    }\n\n    smtp_set_header(message, \"To\", NULL /*phrase */ , NULL /*addr */ ); /* \"Phrase\" <addr> */\n    smtp_add_recipient(message, crm_mail_to);\n\n    /* Set the Subject: header and override any subject line in the message headers. */\n    smtp_set_header(message, \"Subject\", crm_mail_subject);\n    smtp_set_header_option(message, \"Subject\", Hdr_OVERRIDE, 1);\n\n    smtp_set_message_str(message, crm_mail_body);\n    smtp_set_monitorcb(session, crm_smtp_debug, &smtp_debug, 1);\n\n    if (smtp_start_session(session)) {\n        char buf[128];\n        int rc = smtp_errno();\n\n        crm_err(\"SMTP server problem: %s (%d)\", smtp_strerror(rc, buf, sizeof buf), rc);\n\n    } else {\n        char buf[128];\n        int rc = smtp_errno();\n        const smtp_status_t *smtp_status = smtp_message_transfer_status(message);\n\n        if (rc != 0) {\n            crm_err(\"SMTP server problem: %s (%d)\", smtp_strerror(rc, buf, sizeof buf), rc);\n        }\n        crm_info(\"Send status: %d %s\", smtp_status->code, crm_str(smtp_status->text));\n        smtp_enumerate_recipients(message, print_recipient_status, NULL);\n    }\n\n    smtp_destroy_session(session);\n    auth_destroy_context(authctx);\n    auth_client_exit();\n#endif\n    return 0;\n}\n\nstatic void\nhandle_rsc_op(xmlNode * rsc_op)\n{\n    int rc = -1;\n    int status = -1;\n    int action = -1;\n    int interval = 0;\n    int target_rc = -1;\n    int transition_num = -1;\n    gboolean notify = TRUE;\n\n    char *rsc = NULL;\n    char *task = NULL;\n    const char *desc = NULL;\n    const char *node = NULL;\n    const char *magic = NULL;\n    const char *id = crm_element_value(rsc_op, XML_LRM_ATTR_TASK_KEY);\n    char *update_te_uuid = NULL;\n\n    xmlNode *n = rsc_op;\n\n    if (id == NULL) {\n        /* Compatability with <= 1.1.5 */\n        id = ID(rsc_op);\n    }\n\n    magic = crm_element_value(rsc_op, XML_ATTR_TRANSITION_MAGIC);\n    if (magic == NULL) {\n        /* non-change */\n        return;\n    }\n\n    if (FALSE == decode_transition_magic(magic, &update_te_uuid, &transition_num, &action,\n                                         &status, &rc, &target_rc)) {\n        crm_err(\"Invalid event %s detected for %s\", magic, id);\n        return;\n    }\n\n    if (parse_op_key(id, &rsc, &task, &interval) == FALSE) {\n        crm_err(\"Invalid event detected for %s\", id);\n        goto bail;\n    }\n\n    while (n != NULL && safe_str_neq(XML_CIB_TAG_STATE, TYPE(n))) {\n        n = n->parent;\n    }\n\n    node = crm_element_value(n, XML_ATTR_UNAME);\n    if (node == NULL) {\n        node = ID(n);\n    }\n    if (node == NULL) {\n        crm_err(\"No node detected for event %s (%s)\", magic, id);\n        goto bail;\n    }\n\n    /* look up where we expected it to be? */\n    desc = pcmk_strerror(pcmk_ok);\n    if (status == PCMK_LRM_OP_DONE && target_rc == rc) {\n        crm_notice(\"%s of %s on %s completed: %s\", task, rsc, node, desc);\n        if (rc == PCMK_EXECRA_NOT_RUNNING) {\n            notify = FALSE;\n        }\n\n    } else if (status == PCMK_LRM_OP_DONE) {\n        desc = lrmd_event_rc2str(rc);\n        crm_warn(\"%s of %s on %s failed: %s\", task, rsc, node, desc);\n\n    } else {\n        desc = services_lrm_status_str(status);\n        crm_warn(\"%s of %s on %s failed: %s\", task, rsc, node, desc);\n    }\n\n    if (notify && snmp_target) {\n        send_snmp_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n    if (notify && crm_mail_to) {\n        send_smtp_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n    if (notify && external_agent) {\n        send_custom_trap(node, rsc, task, target_rc, rc, status, desc);\n    }\n  bail:\n    free(update_te_uuid);\n    free(rsc);\n    free(task);\n}\n\nvoid\ncrm_diff_update(const char *event, xmlNode * msg)\n{\n    int rc = -1;\n    long now = time(NULL);\n    const char *op = NULL;\n\n    print_dot();\n\n    if (current_cib != NULL) {\n        xmlNode *cib_last = current_cib;\n        current_cib = NULL;\n\n        rc = cib_apply_patch_event(msg, cib_last, &current_cib, LOG_DEBUG);\n        free_xml(cib_last);\n\n        switch(rc) {\n            case pcmk_err_diff_resync:\n            case pcmk_err_diff_failed:\n                crm_warn(\"[%s] %s Patch aborted: %s (%d)\", event, op, pcmk_strerror(rc), rc);\n            case pcmk_ok:\n                break;\n            default:\n                crm_warn(\"[%s] %s ABORTED: %s (%d)\", event, op, pcmk_strerror(rc), rc);\n                return;\n        }\n    }\n\n    if (current_cib == NULL) {\n        current_cib = get_cib_copy(cib);\n    }\n\n    if (crm_mail_to || snmp_target || external_agent) {\n        /* Process operation updates */\n        xmlXPathObject *xpathObj =\n            xpath_search(msg,\n                         \"//\" F_CIB_UPDATE_RESULT \"//\" XML_TAG_DIFF_ADDED \"//\" XML_LRM_TAG_RSC_OP);\n        if (xpathObj && xpathObj->nodesetval->nodeNr > 0) {\n            int lpc = 0, max = xpathObj->nodesetval->nodeNr;\n\n            for (lpc = 0; lpc < max; lpc++) {\n                xmlNode *rsc_op = getXpathResult(xpathObj, lpc);\n\n                handle_rsc_op(rsc_op);\n            }\n        }\n        if (xpathObj) {\n            xmlXPathFreeObject(xpathObj);\n        }\n    }\n\n    if ((now - last_refresh) > (reconnect_msec / 1000)) {\n        /* Force a refresh */\n        mon_refresh_display(NULL);\n\n    } else {\n        mainloop_set_trigger(refresh_trigger);\n    }\n}\n\ngboolean\nmon_refresh_display(gpointer user_data)\n{\n    xmlNode *cib_copy = copy_xml(current_cib);\n    pe_working_set_t data_set;\n\n    last_refresh = time(NULL);\n\n    if (cli_config_update(&cib_copy, NULL, FALSE) == FALSE) {\n        if (cib) {\n            cib->cmds->signoff(cib);\n        }\n        print_as(\"Upgrade failed: %s\", pcmk_strerror(-pcmk_err_dtd_validation));\n        if (as_console) {\n            sleep(2);\n        }\n        clean_up(EX_USAGE);\n        return FALSE;\n    }\n\n    set_working_set_defaults(&data_set);\n    data_set.input = cib_copy;\n    cluster_status(&data_set);\n\n    if (as_html_file || web_cgi) {\n        if (print_html_status(&data_set, as_html_file, web_cgi) != 0) {\n            fprintf(stderr, \"Critical: Unable to output html file\\n\");\n            clean_up(EX_USAGE);\n        }\n    } else if (as_xml) {\n        if (print_xml_status(&data_set) != 0) {\n            fprintf(stderr, \"Critical: Unable to output xml file\\n\");\n            clean_up(EX_USAGE);\n        }\n    } else if (daemonize) {\n        /* do nothing */\n\n    } else if (simple_status) {\n        print_simple_status(&data_set);\n        if (has_warnings) {\n            clean_up(EX_USAGE);\n        }\n\n    } else {\n        print_status(&data_set);\n    }\n\n    cleanup_calculations(&data_set);\n    return TRUE;\n}\n\nvoid mon_st_callback(stonith_t *st, stonith_event_t *e)\n{\n    char *desc = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); \n\n    if (snmp_target) {\n        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (crm_mail_to) {\n        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (external_agent) {\n        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    g_free(desc);\n}\n\n/*\n * De-init ncurses, signoff from the CIB and deallocate memory.\n */\nvoid\nclean_up(int rc)\n{\n#if ENABLE_SNMP\n    netsnmp_session *session = crm_snmp_init(NULL, NULL);\n\n    if (session) {\n        snmp_close(session);\n        snmp_shutdown(\"snmpapp\");\n    }\n#endif\n\n#if CURSES_ENABLED\n    if (as_console) {\n        as_console = FALSE;\n        echo();\n        nocbreak();\n        endwin();\n    }\n#endif\n\n    if (cib != NULL) {\n        cib->cmds->signoff(cib);\n        cib_delete(cib);\n        cib = NULL;\n    }\n\n    free(as_html_file);\n    free(xml_file);\n    free(pid_file);\n\n    if (rc >= 0) {\n        crm_exit(rc);\n    }\n    return;\n}\n"], "filenames": ["cib/callbacks.c", "cib/callbacks.h", "cib/notify.c", "cib/remote.c", "include/crm_internal.h", "lib/cib/cib_remote.c", "lib/common/mainloop.c", "lib/common/remote.c", "tools/crm_mon.c"], "buggy_code_start_loc": [350, 43, 86, 63, 202, 41, 180, 28, 278], "buggy_code_end_loc": [356, 62, 87, 478, 204, 600, 180, 341, 279], "fixing_code_start_loc": [350, 44, 86, 62, 202, 41, 181, 28, 278], "fixing_code_end_loc": [362, 67, 87, 562, 236, 588, 182, 706, 279], "type": "CWE-399", "message": "Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking).", "other": {"cve": {"id": "CVE-2013-0281", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-23T11:55:04.287", "lastModified": "2019-04-22T17:48:00.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking)."}, {"lang": "es", "value": "Pacemaker 1.1.10, cuando la configuraci\u00f3n o recurso de la administraci\u00f3n remota Cluster Information Base (CIB) est\u00e1 activada, no limita la duraci\u00f3n de las conexiones hacia los sockets de bloqueo, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (bloqueo de conexi\u00f3n)."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clusterlabs:pacemaker:1.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "477AF770-650A-4292-BB7E-F0BF092187E9"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2013-1635.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=891922", "source": "secalert@redhat.com"}, {"url": "https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93"}}