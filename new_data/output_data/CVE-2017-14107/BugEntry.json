{"buggy_code": ["/*\n  zip_open.c -- open zip archive by name\n  Copyright (C) 1999-2016 Dieter Baron and Thomas Klausner\n\n  This file is part of libzip, a library to manipulate ZIP archives.\n  The authors can be contacted at <libzip@nih.at>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n     distribution.\n  3. The names of the authors may not be used to endorse or promote\n     products derived from this software without specific prior\n     written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <sys/stat.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"zipint.h\"\n\ntypedef enum {\n    EXISTS_ERROR = -1,\n    EXISTS_NOT = 0,\n    EXISTS_EMPTY,\n    EXISTS_NONEMPTY,\n} exists_t;\nstatic zip_t *_zip_allocate_new(zip_source_t *src, unsigned int flags, zip_error_t *error);\nstatic zip_int64_t _zip_checkcons(zip_t *za, zip_cdir_t *cdir, zip_error_t *error);\nstatic zip_cdir_t *_zip_find_central_dir(zip_t *za, zip_uint64_t len);\nstatic exists_t _zip_file_exists(zip_source_t *src, zip_error_t *error);\nstatic int _zip_headercomp(const zip_dirent_t *, const zip_dirent_t *);\nstatic unsigned char *_zip_memmem(const unsigned char *, size_t, const unsigned char *, size_t);\nstatic zip_cdir_t *_zip_read_cdir(zip_t *za, zip_buffer_t *buffer, zip_uint64_t buf_offset, zip_error_t *error);\nstatic zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error);\nstatic zip_cdir_t *_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error);\n\n\nZIP_EXTERN zip_t *\nzip_open(const char *fn, int _flags, int *zep)\n{\n    zip_t *za;\n    zip_source_t *src;\n    struct zip_error error;\n\n    zip_error_init(&error);\n    if ((src = zip_source_file_create(fn, 0, -1, &error)) == NULL) {\n\t_zip_set_open_error(zep, &error, 0);\n\tzip_error_fini(&error);\n\treturn NULL;\n    }\n\n    if ((za = zip_open_from_source(src, _flags, &error)) == NULL) {\n\tzip_source_free(src);\n\t_zip_set_open_error(zep, &error, 0);\n\tzip_error_fini(&error);\n\treturn NULL;\n    }\n\n    zip_error_fini(&error);\n    return za;\n}\n\n\nZIP_EXTERN zip_t *\nzip_open_from_source(zip_source_t *src, int _flags, zip_error_t *error)\n{\n    static zip_int64_t needed_support_read = -1;\n    static zip_int64_t needed_support_write = -1;\n\n    unsigned int flags;\n    zip_int64_t supported;\n    exists_t exists;\n\n    if (_flags < 0 || src == NULL) {\n\tzip_error_set(error, ZIP_ER_INVAL, 0);\n        return NULL;\n    }\n    flags = (unsigned int)_flags;\n\n    supported = zip_source_supports(src);\n    if (needed_support_read == -1) {\n        needed_support_read = zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_SEEK, ZIP_SOURCE_TELL, ZIP_SOURCE_STAT, -1);\n        needed_support_write = zip_source_make_command_bitmap(ZIP_SOURCE_BEGIN_WRITE, ZIP_SOURCE_COMMIT_WRITE, ZIP_SOURCE_ROLLBACK_WRITE, ZIP_SOURCE_SEEK_WRITE, ZIP_SOURCE_TELL_WRITE, ZIP_SOURCE_REMOVE, -1);\n    }\n    if ((supported & needed_support_read) != needed_support_read) {\n        zip_error_set(error, ZIP_ER_OPNOTSUPP, 0);\n        return NULL;\n    }\n    if ((supported & needed_support_write) != needed_support_write) {\n        flags |= ZIP_RDONLY;\n    }\n\n    if ((flags & (ZIP_RDONLY|ZIP_TRUNCATE)) == (ZIP_RDONLY|ZIP_TRUNCATE)) {\n\tzip_error_set(error, ZIP_ER_RDONLY, 0);\n\treturn NULL;\n    }\n\n    exists = _zip_file_exists(src, error);\n    switch (exists) {\n    case EXISTS_ERROR:\n\treturn NULL;\n\n    case EXISTS_NOT:\n\tif ((flags & ZIP_CREATE) == 0) {\n\t    zip_error_set(error, ZIP_ER_NOENT, 0);\n\t    return NULL;\n\t}\n\treturn _zip_allocate_new(src, flags, error);\n\n    default: {\n\tzip_t *za;\n\tif (flags & ZIP_EXCL) {\n\t    zip_error_set(error, ZIP_ER_EXISTS, 0);\n\t    return NULL;\n\t}\n\tif (zip_source_open(src) < 0) {\n\t    _zip_error_set_from_source(error, src);\n\t    return NULL;\n\t}\n\n\tif (flags & ZIP_TRUNCATE) {\n\t    za = _zip_allocate_new(src, flags, error);\n\t}\n\telse {\n\t    /* ZIP_CREATE gets ignored if file exists and not ZIP_EXCL, just like open() */\n\t    za = _zip_open(src, flags, error);\n\t}\n\n\tif (za == NULL) {\n\t    zip_source_close(src);\n\t    return NULL;\n\t}\n\treturn za;\n    }\n    }\n}\n\n\nzip_t *\n_zip_open(zip_source_t *src, unsigned int flags, zip_error_t *error)\n{\n    zip_t *za;\n    zip_cdir_t *cdir;\n    struct zip_stat st;\n    zip_uint64_t len, idx;\n\n    zip_stat_init(&st);\n    if (zip_source_stat(src, &st) < 0) {\n\t_zip_error_set_from_source(error, src);\n\treturn NULL;\n    }\n    if ((st.valid & ZIP_STAT_SIZE) == 0) {\n\tzip_error_set(error, ZIP_ER_SEEK, EOPNOTSUPP);\n\treturn NULL;\n    }\n    len = st.size;\n\n    /* treat empty files as empty archives */\n    if (len == 0) {\n\tif ((za=_zip_allocate_new(src, flags, error)) == NULL) {\n\t    zip_source_free(src);\n\t    return NULL;\n\t}\n\n\treturn za;\n    }\n\n    if ((za=_zip_allocate_new(src, flags, error)) == NULL) {\n        return NULL;\n    }\n\n    if ((cdir = _zip_find_central_dir(za, len)) == NULL) {\n        _zip_error_copy(error, &za->error);\n\t/* keep src so discard does not get rid of it */\n\tzip_source_keep(src);\n\tzip_discard(za);\n\treturn NULL;\n    }\n\n    za->entry = cdir->entry;\n    za->nentry = cdir->nentry;\n    za->nentry_alloc = cdir->nentry_alloc;\n    za->comment_orig = cdir->comment;\n\n    free(cdir);\n\n    _zip_hash_reserve_capacity(za->names, za->nentry, &za->error);\n    \n    for (idx = 0; idx < za->nentry; idx++) {\n\tconst zip_uint8_t *name = _zip_string_get(za->entry[idx].orig->filename, NULL, 0, error);\n\tif (name == NULL) {\n\t\t/* keep src so discard does not get rid of it */\n\t\tzip_source_keep(src);\n\t\tzip_discard(za);\n\t\treturn NULL;\n\t}\n\n\tif (_zip_hash_add(za->names, name, idx, ZIP_FL_UNCHANGED, &za->error) == false) {\n\t    if (za->error.zip_err != ZIP_ER_EXISTS || (flags & ZIP_CHECKCONS)) {\n\t\t_zip_error_copy(error, &za->error);\n\t\t/* keep src so discard does not get rid of it */\n\t\tzip_source_keep(src);\n\t\tzip_discard(za);\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    za->ch_flags = za->flags;\n\n    return za;\n}\n\n\nvoid\n_zip_set_open_error(int *zep, const zip_error_t *err, int ze)\n{\n    if (err) {\n\tze = zip_error_code_zip(err);\n\tif (zip_error_system_type(err) == ZIP_ET_SYS) {\n\t    errno = zip_error_code_system(err);\n\t}\n    }\n\n    if (zep)\n\t*zep = ze;\n}\n\n\n/* _zip_readcdir:\n   tries to find a valid end-of-central-directory at the beginning of\n   buf, and then the corresponding central directory entries.\n   Returns a struct zip_cdir which contains the central directory\n   entries, or NULL if unsuccessful. */\n\nstatic zip_cdir_t *\n_zip_read_cdir(zip_t *za, zip_buffer_t *buffer, zip_uint64_t buf_offset, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint16_t comment_len;\n    zip_uint64_t i, left;\n    zip_uint64_t eocd_offset = _zip_buffer_offset(buffer);\n    zip_buffer_t *cd_buffer;\n\n    if (_zip_buffer_left(buffer) < EOCDLEN) {\n\t/* not enough bytes left for comment */\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn NULL;\n    }\n\n    /* check for end-of-central-dir magic */\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset >= EOCD64LOCLEN && memcmp(_zip_buffer_data(buffer) + eocd_offset - EOCD64LOCLEN, EOCD64LOC_MAGIC, 4) == 0) {\n        _zip_buffer_set_offset(buffer, eocd_offset - EOCD64LOCLEN);\n        cd = _zip_read_eocd64(za->src, buffer, buf_offset, za->flags, error);\n    }\n    else {\n        _zip_buffer_set_offset(buffer, eocd_offset);\n        cd = _zip_read_eocd(buffer, buf_offset, za->flags, error);\n    }\n\n    if (cd == NULL)\n\treturn NULL;\n\n    _zip_buffer_set_offset(buffer, eocd_offset + 20);\n    comment_len = _zip_buffer_get_16(buffer);\n\n    if (cd->offset + cd->size > buf_offset + eocd_offset) {\n\t/* cdir spans past EOCD record */\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t_zip_cdir_free(cd);\n\treturn NULL;\n    }\n\n    if (comment_len || (za->open_flags & ZIP_CHECKCONS)) {\n        zip_uint64_t tail_len;\n\n        _zip_buffer_set_offset(buffer, eocd_offset + EOCDLEN);\n        tail_len = _zip_buffer_left(buffer);\n\n        if (tail_len < comment_len || ((za->open_flags & ZIP_CHECKCONS) && tail_len != comment_len)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n\n        if (comment_len) {\n            if ((cd->comment=_zip_string_new(_zip_buffer_get(buffer, comment_len), comment_len, ZIP_FL_ENC_GUESS, error)) == NULL) {\n                _zip_cdir_free(cd);\n                return NULL;\n            }\n        }\n    }\n\n    if (cd->offset >= buf_offset) {\n        zip_uint8_t *data;\n\t/* if buffer already read in, use it */\n        _zip_buffer_set_offset(buffer, cd->offset - buf_offset);\n\n        if ((data = _zip_buffer_get(buffer, cd->size)) == NULL) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n        if ((cd_buffer = _zip_buffer_new(data, cd->size)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n    }\n    else {\n        cd_buffer = NULL;\n\n        if (zip_source_seek(za->src, (zip_int64_t)cd->offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, za->src);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n\n\t/* possible consistency check: cd->offset = len-(cd->size+cd->comment_len+EOCDLEN) ? */\n\tif (zip_source_tell(za->src) != (zip_int64_t)cd->offset) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n\t    _zip_cdir_free(cd);\n\t    return NULL;\n\t}\n    }\n\n    left = (zip_uint64_t)cd->size;\n    i=0;\n    while (left > 0) {\n\tbool grown = false;\n        zip_int64_t entry_size;\n\n\tif (i == cd->nentry) {\n\t    /* InfoZIP has a hack to avoid using Zip64: it stores nentries % 0x10000 */\n\t    /* This hack isn't applicable if we're using Zip64, or if there is no central directory entry following. */\n\n\t    if (cd->is_zip64 || left < CDENTRYSIZE) {\n\t\tbreak;\n\t    }\n\n\t    if (!_zip_cdir_grow(cd, 0x10000, error)) {\n\t\t_zip_cdir_free(cd);\n\t\t_zip_buffer_free(cd_buffer);\n\t\treturn NULL;\n\t    }\n\t    grown = true;\n\t}\n\n\tif ((cd->entry[i].orig=_zip_dirent_new()) == NULL || (entry_size = _zip_dirent_read(cd->entry[i].orig, za->src, cd_buffer, false, error)) < 0) {\n\t    if (grown && zip_error_code_zip(error) == ZIP_ER_NOZIP) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t    }\n\t    _zip_cdir_free(cd);\n            _zip_buffer_free(cd_buffer);\n\t    return NULL;\n\t}\n\ti++;\n        left -= (zip_uint64_t)entry_size;\n    }\n\n    if (i != cd->nentry || left > 0) {\n        zip_error_set(error, ZIP_ER_INCONS, 0);\n        _zip_buffer_free(cd_buffer);\n        _zip_cdir_free(cd);\n        return NULL;\n    }\n\n    if (za->open_flags & ZIP_CHECKCONS) {\n        bool ok;\n\n        if (cd_buffer) {\n            ok = _zip_buffer_eof(cd_buffer);\n        }\n        else {\n            zip_int64_t offset = zip_source_tell(za->src);\n\n            if (offset < 0) {\n                _zip_error_set_from_source(error, za->src);\n                _zip_cdir_free(cd);\n                return NULL;\n            }\n            ok = ((zip_uint64_t)offset == cd->offset + cd->size);\n        }\n\n        if (!ok) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(cd_buffer);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n    }\n\n    _zip_buffer_free(cd_buffer);\n    return cd;\n}\n\n\n/* _zip_checkcons:\n   Checks the consistency of the central directory by comparing central\n   directory entries with local headers and checking for plausible\n   file and header offsets. Returns -1 if not plausible, else the\n   difference between the lowest and the highest fileposition reached */\n\nstatic zip_int64_t\n_zip_checkcons(zip_t *za, zip_cdir_t *cd, zip_error_t *error)\n{\n    zip_uint64_t i;\n    zip_uint64_t min, max, j;\n    struct zip_dirent temp;\n\n    _zip_dirent_init(&temp);\n    if (cd->nentry) {\n\tmax = cd->entry[0].orig->offset;\n\tmin = cd->entry[0].orig->offset;\n    }\n    else\n\tmin = max = 0;\n\n    for (i=0; i<cd->nentry; i++) {\n\tif (cd->entry[i].orig->offset < min)\n\t    min = cd->entry[i].orig->offset;\n\tif (min > (zip_uint64_t)cd->offset) {\n\t    zip_error_set(error, ZIP_ER_NOZIP, 0);\n\t    return -1;\n\t}\n\n\tj = cd->entry[i].orig->offset + cd->entry[i].orig->comp_size\n\t    + _zip_string_length(cd->entry[i].orig->filename) + LENTRYSIZE;\n\tif (j > max)\n\t    max = j;\n\tif (max > (zip_uint64_t)cd->offset) {\n\t    zip_error_set(error, ZIP_ER_NOZIP, 0);\n\t    return -1;\n\t}\n\n        if (zip_source_seek(za->src, (zip_int64_t)cd->entry[i].orig->offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, za->src);\n            return -1;\n\t}\n\n\tif (_zip_dirent_read(&temp, za->src, NULL, true, error) == -1) {\n\t    _zip_dirent_finalize(&temp);\n\t    return -1;\n\t}\n\n\tif (_zip_headercomp(cd->entry[i].orig, &temp) != 0) {\n\t    zip_error_set(error, ZIP_ER_INCONS, 0);\n\t    _zip_dirent_finalize(&temp);\n\t    return -1;\n\t}\n\n\tcd->entry[i].orig->extra_fields = _zip_ef_merge(cd->entry[i].orig->extra_fields, temp.extra_fields);\n\tcd->entry[i].orig->local_extra_fields_read = 1;\n\ttemp.extra_fields = NULL;\n\n\t_zip_dirent_finalize(&temp);\n    }\n\n    return (max-min) < ZIP_INT64_MAX ? (zip_int64_t)(max-min) : ZIP_INT64_MAX;\n}\n\n\n/* _zip_headercomp:\n   compares a central directory entry and a local file header\n   Return 0 if they are consistent, -1 if not. */\n\nstatic int\n_zip_headercomp(const zip_dirent_t *central, const zip_dirent_t *local)\n{\n    if ((central->version_needed < local->version_needed)\n#if 0\n\t/* some zip-files have different values in local\n\t   and global headers for the bitflags */\n\t|| (central->bitflags != local->bitflags)\n#endif\n\t|| (central->comp_method != local->comp_method)\n\t|| (central->last_mod != local->last_mod)\n\t|| !_zip_string_equal(central->filename, local->filename))\n\treturn -1;\n\n    if ((central->crc != local->crc) || (central->comp_size != local->comp_size)\n\t|| (central->uncomp_size != local->uncomp_size)) {\n\t/* InfoZip stores valid values in local header even when data descriptor is used.\n\t   This is in violation of the appnote. */\n\tif (((local->bitflags & ZIP_GPBF_DATA_DESCRIPTOR) == 0\n\t     || local->crc != 0 || local->comp_size != 0 || local->uncomp_size != 0))\n\t    return -1;\n    }\n\n    return 0;\n}\n\n\nstatic zip_t *\n_zip_allocate_new(zip_source_t *src, unsigned int flags, zip_error_t *error)\n{\n    zip_t *za;\n\n    if ((za = _zip_new(error)) == NULL) {\n\treturn NULL;\n    }\n\n    za->src = src;\n    za->open_flags = flags;\n    if (flags & ZIP_RDONLY) {\n        za->flags |= ZIP_AFL_RDONLY;\n        za->ch_flags |= ZIP_AFL_RDONLY;\n    }\n    return za;\n}\n\n\n/*\n * tests for file existence\n */\nstatic exists_t\n_zip_file_exists(zip_source_t *src, zip_error_t *error)\n{\n    struct zip_stat st;\n\n    zip_stat_init(&st);\n    if (zip_source_stat(src, &st) != 0) {\n        zip_error_t *src_error = zip_source_error(src);\n        if (zip_error_code_zip(src_error) == ZIP_ER_READ && zip_error_code_system(src_error) == ENOENT) {\n\t    return EXISTS_NOT;\n\t}\n\t_zip_error_copy(error, src_error);\n\treturn EXISTS_ERROR;\n    }\n\n    return (st.valid & ZIP_STAT_SIZE) && st.size == 0 ? EXISTS_EMPTY : EXISTS_NONEMPTY;\n}\n\n\nstatic zip_cdir_t *\n_zip_find_central_dir(zip_t *za, zip_uint64_t len)\n{\n    zip_cdir_t *cdir, *cdirnew;\n    zip_uint8_t *match;\n    zip_int64_t buf_offset;\n    zip_uint64_t buflen;\n    zip_int64_t a;\n    zip_int64_t best;\n    zip_error_t error;\n    zip_buffer_t *buffer;\n\n    if (len < EOCDLEN) {\n\tzip_error_set(&za->error, ZIP_ER_NOZIP, 0);\n        return NULL;\n    }\n\n    buflen = (len < CDBUFSIZE ? len : CDBUFSIZE);\n    if (zip_source_seek(za->src, -(zip_int64_t)buflen, SEEK_END) < 0) {\n\tzip_error_t *src_error = zip_source_error(za->src);\n\tif (zip_error_code_zip(src_error) != ZIP_ER_SEEK || zip_error_code_system(src_error) != EFBIG) {\n\t    /* seek before start of file on my machine */\n\t    _zip_error_copy(&za->error, src_error);\n\t    return NULL;\n\t}\n    }\n    if ((buf_offset = zip_source_tell(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return NULL;\n    }\n\n    if ((buffer = _zip_buffer_new_from_source(za->src, buflen, NULL, &za->error)) == NULL) {\n        return NULL;\n    }\n\n    best = -1;\n    cdir = NULL;\n    if (buflen >= CDBUFSIZE) {\n        /* EOCD64 locator is before EOCD, so leave place for it */\n        _zip_buffer_set_offset(buffer, EOCD64LOCLEN);\n    }\n    zip_error_set(&error, ZIP_ER_NOZIP, 0);\n\n    match = _zip_buffer_get(buffer, 0);\n    while ((match=_zip_memmem(match, _zip_buffer_left(buffer)-(EOCDLEN-4), (const unsigned char *)EOCD_MAGIC, 4)) != NULL) {\n        _zip_buffer_set_offset(buffer, (zip_uint64_t)(match - _zip_buffer_data(buffer)));\n        if ((cdirnew = _zip_read_cdir(za, buffer, (zip_uint64_t)buf_offset, &error)) != NULL) {\n            if (cdir) {\n                if (best <= 0) {\n                    best = _zip_checkcons(za, cdir, &error);\n                }\n\n                a = _zip_checkcons(za, cdirnew, &error);\n                if (best < a) {\n                    _zip_cdir_free(cdir);\n                    cdir = cdirnew;\n                    best = a;\n                }\n                else {\n                    _zip_cdir_free(cdirnew);\n                }\n            }\n            else {\n                cdir = cdirnew;\n                if (za->open_flags & ZIP_CHECKCONS)\n                    best = _zip_checkcons(za, cdir, &error);\n                else {\n                    best = 0;\n                }\n            }\n            cdirnew = NULL;\n        }\n\n        match++;\n        _zip_buffer_set_offset(buffer, (zip_uint64_t)(match - _zip_buffer_data(buffer)));\n    }\n\n    _zip_buffer_free(buffer);\n\n    if (best < 0) {\n        _zip_error_copy(&za->error, &error);\n        _zip_cdir_free(cdir);\n        return NULL;\n    }\n\n    return cdir;\n}\n\n\nstatic unsigned char *\n_zip_memmem(const unsigned char *big, size_t biglen, const unsigned char *little, size_t littlelen)\n{\n    const unsigned char *p;\n\n    if ((biglen < littlelen) || (littlelen == 0))\n\treturn NULL;\n    p = big-1;\n    while ((p=(const unsigned char *)\n\t        memchr(p+1, little[0], (size_t)(big-(p+1))+(size_t)(biglen-littlelen)+1)) != NULL) {\n\tif (memcmp(p+1, little+1, littlelen-1)==0)\n\t    return (unsigned char *)p;\n    }\n\n    return NULL;\n}\n\n\nstatic zip_cdir_t *\n_zip_read_eocd(zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t i, nentry, size, offset, eocd_offset;\n\n    if (_zip_buffer_left(buffer) < EOCDLEN) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    eocd_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    if (_zip_buffer_get_32(buffer) != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n\treturn NULL;\n    }\n\n    /* number of cdir-entries on this disk */\n    i = _zip_buffer_get_16(buffer);\n    /* number of cdir-entries */\n    nentry = _zip_buffer_get_16(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_32(buffer);\n    offset = _zip_buffer_get_32(buffer);\n\n    if (offset+size < offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (offset+size > buf_offset + eocd_offset) {\n\t/* cdir spans past EOCD record */\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd->is_zip64 = false;\n    cd->size = size;\n    cd->offset = offset;\n\n    return cd;\n}\n\n\nstatic zip_cdir_t *\n_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t offset;\n    zip_uint8_t eocd[EOCD64LEN];\n    zip_uint64_t eocd_offset;\n    zip_uint64_t size, nentry, i, eocdloc_offset;\n    bool free_buffer;\n    zip_uint32_t num_disks, num_disks64, eocd_disk, eocd_disk64;\n\n    eocdloc_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    num_disks = _zip_buffer_get_16(buffer);\n    eocd_disk = _zip_buffer_get_16(buffer);\n    eocd_offset = _zip_buffer_get_64(buffer);\n\n    if (eocd_offset > ZIP_INT64_MAX || eocd_offset + EOCD64LEN < eocd_offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (eocd_offset + EOCD64LEN > eocdloc_offset + buf_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset >= buf_offset && eocd_offset + EOCD64LEN <= buf_offset + _zip_buffer_size(buffer)) {\n        _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);\n        free_buffer = false;\n    }\n    else {\n        if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, src);\n            return NULL;\n        }\n        if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {\n            return NULL;\n        }\n        free_buffer = true;\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n\n    if ((flags & ZIP_CHECKCONS) && size + eocd_offset + 12 != buf_offset + eocdloc_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    _zip_buffer_get(buffer, 4); /* skip version made by/needed */\n\n    num_disks64 = _zip_buffer_get_32(buffer);\n    eocd_disk64 = _zip_buffer_get_32(buffer);\n\n    /* if eocd values are 0xffff, we have to use eocd64 values.\n       otherwise, if the values are not the same, it's inconsistent;\n       in any case, if the value is not 0, we don't support it */\n    if (num_disks == 0xffff) {\n\tnum_disks = num_disks64;\n    }\n    if (eocd_disk == 0xffff) {\n\teocd_disk = eocd_disk64;\n    }\n    if ((flags & ZIP_CHECKCONS) && (eocd_disk != eocd_disk64 || num_disks != num_disks64)) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n    if (num_disks != 0 || eocd_disk != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    nentry = _zip_buffer_get_64(buffer);\n    i = _zip_buffer_get_64(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n    offset = _zip_buffer_get_64(buffer);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    if (free_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    if (offset > ZIP_INT64_MAX || offset+size < offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n    if ((flags & ZIP_CHECKCONS) && offset+size != eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd->is_zip64 = true;\n    cd->size = size;\n    cd->offset = offset;\n\n    return cd;\n}\n"], "fixing_code": ["/*\n  zip_open.c -- open zip archive by name\n  Copyright (C) 1999-2016 Dieter Baron and Thomas Klausner\n\n  This file is part of libzip, a library to manipulate ZIP archives.\n  The authors can be contacted at <libzip@nih.at>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n  1. Redistributions of source code must retain the above copyright\n     notice, this list of conditions and the following disclaimer.\n  2. Redistributions in binary form must reproduce the above copyright\n     notice, this list of conditions and the following disclaimer in\n     the documentation and/or other materials provided with the\n     distribution.\n  3. The names of the authors may not be used to endorse or promote\n     products derived from this software without specific prior\n     written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <sys/stat.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"zipint.h\"\n\ntypedef enum {\n    EXISTS_ERROR = -1,\n    EXISTS_NOT = 0,\n    EXISTS_EMPTY,\n    EXISTS_NONEMPTY,\n} exists_t;\nstatic zip_t *_zip_allocate_new(zip_source_t *src, unsigned int flags, zip_error_t *error);\nstatic zip_int64_t _zip_checkcons(zip_t *za, zip_cdir_t *cdir, zip_error_t *error);\nstatic zip_cdir_t *_zip_find_central_dir(zip_t *za, zip_uint64_t len);\nstatic exists_t _zip_file_exists(zip_source_t *src, zip_error_t *error);\nstatic int _zip_headercomp(const zip_dirent_t *, const zip_dirent_t *);\nstatic unsigned char *_zip_memmem(const unsigned char *, size_t, const unsigned char *, size_t);\nstatic zip_cdir_t *_zip_read_cdir(zip_t *za, zip_buffer_t *buffer, zip_uint64_t buf_offset, zip_error_t *error);\nstatic zip_cdir_t *_zip_read_eocd(zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error);\nstatic zip_cdir_t *_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error);\n\n\nZIP_EXTERN zip_t *\nzip_open(const char *fn, int _flags, int *zep)\n{\n    zip_t *za;\n    zip_source_t *src;\n    struct zip_error error;\n\n    zip_error_init(&error);\n    if ((src = zip_source_file_create(fn, 0, -1, &error)) == NULL) {\n\t_zip_set_open_error(zep, &error, 0);\n\tzip_error_fini(&error);\n\treturn NULL;\n    }\n\n    if ((za = zip_open_from_source(src, _flags, &error)) == NULL) {\n\tzip_source_free(src);\n\t_zip_set_open_error(zep, &error, 0);\n\tzip_error_fini(&error);\n\treturn NULL;\n    }\n\n    zip_error_fini(&error);\n    return za;\n}\n\n\nZIP_EXTERN zip_t *\nzip_open_from_source(zip_source_t *src, int _flags, zip_error_t *error)\n{\n    static zip_int64_t needed_support_read = -1;\n    static zip_int64_t needed_support_write = -1;\n\n    unsigned int flags;\n    zip_int64_t supported;\n    exists_t exists;\n\n    if (_flags < 0 || src == NULL) {\n\tzip_error_set(error, ZIP_ER_INVAL, 0);\n        return NULL;\n    }\n    flags = (unsigned int)_flags;\n\n    supported = zip_source_supports(src);\n    if (needed_support_read == -1) {\n        needed_support_read = zip_source_make_command_bitmap(ZIP_SOURCE_OPEN, ZIP_SOURCE_READ, ZIP_SOURCE_CLOSE, ZIP_SOURCE_SEEK, ZIP_SOURCE_TELL, ZIP_SOURCE_STAT, -1);\n        needed_support_write = zip_source_make_command_bitmap(ZIP_SOURCE_BEGIN_WRITE, ZIP_SOURCE_COMMIT_WRITE, ZIP_SOURCE_ROLLBACK_WRITE, ZIP_SOURCE_SEEK_WRITE, ZIP_SOURCE_TELL_WRITE, ZIP_SOURCE_REMOVE, -1);\n    }\n    if ((supported & needed_support_read) != needed_support_read) {\n        zip_error_set(error, ZIP_ER_OPNOTSUPP, 0);\n        return NULL;\n    }\n    if ((supported & needed_support_write) != needed_support_write) {\n        flags |= ZIP_RDONLY;\n    }\n\n    if ((flags & (ZIP_RDONLY|ZIP_TRUNCATE)) == (ZIP_RDONLY|ZIP_TRUNCATE)) {\n\tzip_error_set(error, ZIP_ER_RDONLY, 0);\n\treturn NULL;\n    }\n\n    exists = _zip_file_exists(src, error);\n    switch (exists) {\n    case EXISTS_ERROR:\n\treturn NULL;\n\n    case EXISTS_NOT:\n\tif ((flags & ZIP_CREATE) == 0) {\n\t    zip_error_set(error, ZIP_ER_NOENT, 0);\n\t    return NULL;\n\t}\n\treturn _zip_allocate_new(src, flags, error);\n\n    default: {\n\tzip_t *za;\n\tif (flags & ZIP_EXCL) {\n\t    zip_error_set(error, ZIP_ER_EXISTS, 0);\n\t    return NULL;\n\t}\n\tif (zip_source_open(src) < 0) {\n\t    _zip_error_set_from_source(error, src);\n\t    return NULL;\n\t}\n\n\tif (flags & ZIP_TRUNCATE) {\n\t    za = _zip_allocate_new(src, flags, error);\n\t}\n\telse {\n\t    /* ZIP_CREATE gets ignored if file exists and not ZIP_EXCL, just like open() */\n\t    za = _zip_open(src, flags, error);\n\t}\n\n\tif (za == NULL) {\n\t    zip_source_close(src);\n\t    return NULL;\n\t}\n\treturn za;\n    }\n    }\n}\n\n\nzip_t *\n_zip_open(zip_source_t *src, unsigned int flags, zip_error_t *error)\n{\n    zip_t *za;\n    zip_cdir_t *cdir;\n    struct zip_stat st;\n    zip_uint64_t len, idx;\n\n    zip_stat_init(&st);\n    if (zip_source_stat(src, &st) < 0) {\n\t_zip_error_set_from_source(error, src);\n\treturn NULL;\n    }\n    if ((st.valid & ZIP_STAT_SIZE) == 0) {\n\tzip_error_set(error, ZIP_ER_SEEK, EOPNOTSUPP);\n\treturn NULL;\n    }\n    len = st.size;\n\n    /* treat empty files as empty archives */\n    if (len == 0) {\n\tif ((za=_zip_allocate_new(src, flags, error)) == NULL) {\n\t    zip_source_free(src);\n\t    return NULL;\n\t}\n\n\treturn za;\n    }\n\n    if ((za=_zip_allocate_new(src, flags, error)) == NULL) {\n        return NULL;\n    }\n\n    if ((cdir = _zip_find_central_dir(za, len)) == NULL) {\n        _zip_error_copy(error, &za->error);\n\t/* keep src so discard does not get rid of it */\n\tzip_source_keep(src);\n\tzip_discard(za);\n\treturn NULL;\n    }\n\n    za->entry = cdir->entry;\n    za->nentry = cdir->nentry;\n    za->nentry_alloc = cdir->nentry_alloc;\n    za->comment_orig = cdir->comment;\n\n    free(cdir);\n\n    _zip_hash_reserve_capacity(za->names, za->nentry, &za->error);\n    \n    for (idx = 0; idx < za->nentry; idx++) {\n\tconst zip_uint8_t *name = _zip_string_get(za->entry[idx].orig->filename, NULL, 0, error);\n\tif (name == NULL) {\n\t\t/* keep src so discard does not get rid of it */\n\t\tzip_source_keep(src);\n\t\tzip_discard(za);\n\t\treturn NULL;\n\t}\n\n\tif (_zip_hash_add(za->names, name, idx, ZIP_FL_UNCHANGED, &za->error) == false) {\n\t    if (za->error.zip_err != ZIP_ER_EXISTS || (flags & ZIP_CHECKCONS)) {\n\t\t_zip_error_copy(error, &za->error);\n\t\t/* keep src so discard does not get rid of it */\n\t\tzip_source_keep(src);\n\t\tzip_discard(za);\n\t\treturn NULL;\n\t    }\n\t}\n    }\n\n    za->ch_flags = za->flags;\n\n    return za;\n}\n\n\nvoid\n_zip_set_open_error(int *zep, const zip_error_t *err, int ze)\n{\n    if (err) {\n\tze = zip_error_code_zip(err);\n\tif (zip_error_system_type(err) == ZIP_ET_SYS) {\n\t    errno = zip_error_code_system(err);\n\t}\n    }\n\n    if (zep)\n\t*zep = ze;\n}\n\n\n/* _zip_readcdir:\n   tries to find a valid end-of-central-directory at the beginning of\n   buf, and then the corresponding central directory entries.\n   Returns a struct zip_cdir which contains the central directory\n   entries, or NULL if unsuccessful. */\n\nstatic zip_cdir_t *\n_zip_read_cdir(zip_t *za, zip_buffer_t *buffer, zip_uint64_t buf_offset, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint16_t comment_len;\n    zip_uint64_t i, left;\n    zip_uint64_t eocd_offset = _zip_buffer_offset(buffer);\n    zip_buffer_t *cd_buffer;\n\n    if (_zip_buffer_left(buffer) < EOCDLEN) {\n\t/* not enough bytes left for comment */\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn NULL;\n    }\n\n    /* check for end-of-central-dir magic */\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset >= EOCD64LOCLEN && memcmp(_zip_buffer_data(buffer) + eocd_offset - EOCD64LOCLEN, EOCD64LOC_MAGIC, 4) == 0) {\n        _zip_buffer_set_offset(buffer, eocd_offset - EOCD64LOCLEN);\n        cd = _zip_read_eocd64(za->src, buffer, buf_offset, za->flags, error);\n    }\n    else {\n        _zip_buffer_set_offset(buffer, eocd_offset);\n        cd = _zip_read_eocd(buffer, buf_offset, za->flags, error);\n    }\n\n    if (cd == NULL)\n\treturn NULL;\n\n    _zip_buffer_set_offset(buffer, eocd_offset + 20);\n    comment_len = _zip_buffer_get_16(buffer);\n\n    if (cd->offset + cd->size > buf_offset + eocd_offset) {\n\t/* cdir spans past EOCD record */\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t_zip_cdir_free(cd);\n\treturn NULL;\n    }\n\n    if (comment_len || (za->open_flags & ZIP_CHECKCONS)) {\n        zip_uint64_t tail_len;\n\n        _zip_buffer_set_offset(buffer, eocd_offset + EOCDLEN);\n        tail_len = _zip_buffer_left(buffer);\n\n        if (tail_len < comment_len || ((za->open_flags & ZIP_CHECKCONS) && tail_len != comment_len)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n\n        if (comment_len) {\n            if ((cd->comment=_zip_string_new(_zip_buffer_get(buffer, comment_len), comment_len, ZIP_FL_ENC_GUESS, error)) == NULL) {\n                _zip_cdir_free(cd);\n                return NULL;\n            }\n        }\n    }\n\n    if (cd->offset >= buf_offset) {\n        zip_uint8_t *data;\n\t/* if buffer already read in, use it */\n        _zip_buffer_set_offset(buffer, cd->offset - buf_offset);\n\n        if ((data = _zip_buffer_get(buffer, cd->size)) == NULL) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n        if ((cd_buffer = _zip_buffer_new(data, cd->size)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n    }\n    else {\n        cd_buffer = NULL;\n\n        if (zip_source_seek(za->src, (zip_int64_t)cd->offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, za->src);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n\n\t/* possible consistency check: cd->offset = len-(cd->size+cd->comment_len+EOCDLEN) ? */\n\tif (zip_source_tell(za->src) != (zip_int64_t)cd->offset) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n\t    _zip_cdir_free(cd);\n\t    return NULL;\n\t}\n    }\n\n    left = (zip_uint64_t)cd->size;\n    i=0;\n    while (left > 0) {\n\tbool grown = false;\n        zip_int64_t entry_size;\n\n\tif (i == cd->nentry) {\n\t    /* InfoZIP has a hack to avoid using Zip64: it stores nentries % 0x10000 */\n\t    /* This hack isn't applicable if we're using Zip64, or if there is no central directory entry following. */\n\n\t    if (cd->is_zip64 || left < CDENTRYSIZE) {\n\t\tbreak;\n\t    }\n\n\t    if (!_zip_cdir_grow(cd, 0x10000, error)) {\n\t\t_zip_cdir_free(cd);\n\t\t_zip_buffer_free(cd_buffer);\n\t\treturn NULL;\n\t    }\n\t    grown = true;\n\t}\n\n\tif ((cd->entry[i].orig=_zip_dirent_new()) == NULL || (entry_size = _zip_dirent_read(cd->entry[i].orig, za->src, cd_buffer, false, error)) < 0) {\n\t    if (grown && zip_error_code_zip(error) == ZIP_ER_NOZIP) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\t    }\n\t    _zip_cdir_free(cd);\n            _zip_buffer_free(cd_buffer);\n\t    return NULL;\n\t}\n\ti++;\n        left -= (zip_uint64_t)entry_size;\n    }\n\n    if (i != cd->nentry || left > 0) {\n        zip_error_set(error, ZIP_ER_INCONS, 0);\n        _zip_buffer_free(cd_buffer);\n        _zip_cdir_free(cd);\n        return NULL;\n    }\n\n    if (za->open_flags & ZIP_CHECKCONS) {\n        bool ok;\n\n        if (cd_buffer) {\n            ok = _zip_buffer_eof(cd_buffer);\n        }\n        else {\n            zip_int64_t offset = zip_source_tell(za->src);\n\n            if (offset < 0) {\n                _zip_error_set_from_source(error, za->src);\n                _zip_cdir_free(cd);\n                return NULL;\n            }\n            ok = ((zip_uint64_t)offset == cd->offset + cd->size);\n        }\n\n        if (!ok) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(cd_buffer);\n            _zip_cdir_free(cd);\n            return NULL;\n        }\n    }\n\n    _zip_buffer_free(cd_buffer);\n    return cd;\n}\n\n\n/* _zip_checkcons:\n   Checks the consistency of the central directory by comparing central\n   directory entries with local headers and checking for plausible\n   file and header offsets. Returns -1 if not plausible, else the\n   difference between the lowest and the highest fileposition reached */\n\nstatic zip_int64_t\n_zip_checkcons(zip_t *za, zip_cdir_t *cd, zip_error_t *error)\n{\n    zip_uint64_t i;\n    zip_uint64_t min, max, j;\n    struct zip_dirent temp;\n\n    _zip_dirent_init(&temp);\n    if (cd->nentry) {\n\tmax = cd->entry[0].orig->offset;\n\tmin = cd->entry[0].orig->offset;\n    }\n    else\n\tmin = max = 0;\n\n    for (i=0; i<cd->nentry; i++) {\n\tif (cd->entry[i].orig->offset < min)\n\t    min = cd->entry[i].orig->offset;\n\tif (min > (zip_uint64_t)cd->offset) {\n\t    zip_error_set(error, ZIP_ER_NOZIP, 0);\n\t    return -1;\n\t}\n\n\tj = cd->entry[i].orig->offset + cd->entry[i].orig->comp_size\n\t    + _zip_string_length(cd->entry[i].orig->filename) + LENTRYSIZE;\n\tif (j > max)\n\t    max = j;\n\tif (max > (zip_uint64_t)cd->offset) {\n\t    zip_error_set(error, ZIP_ER_NOZIP, 0);\n\t    return -1;\n\t}\n\n        if (zip_source_seek(za->src, (zip_int64_t)cd->entry[i].orig->offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, za->src);\n            return -1;\n\t}\n\n\tif (_zip_dirent_read(&temp, za->src, NULL, true, error) == -1) {\n\t    _zip_dirent_finalize(&temp);\n\t    return -1;\n\t}\n\n\tif (_zip_headercomp(cd->entry[i].orig, &temp) != 0) {\n\t    zip_error_set(error, ZIP_ER_INCONS, 0);\n\t    _zip_dirent_finalize(&temp);\n\t    return -1;\n\t}\n\n\tcd->entry[i].orig->extra_fields = _zip_ef_merge(cd->entry[i].orig->extra_fields, temp.extra_fields);\n\tcd->entry[i].orig->local_extra_fields_read = 1;\n\ttemp.extra_fields = NULL;\n\n\t_zip_dirent_finalize(&temp);\n    }\n\n    return (max-min) < ZIP_INT64_MAX ? (zip_int64_t)(max-min) : ZIP_INT64_MAX;\n}\n\n\n/* _zip_headercomp:\n   compares a central directory entry and a local file header\n   Return 0 if they are consistent, -1 if not. */\n\nstatic int\n_zip_headercomp(const zip_dirent_t *central, const zip_dirent_t *local)\n{\n    if ((central->version_needed < local->version_needed)\n#if 0\n\t/* some zip-files have different values in local\n\t   and global headers for the bitflags */\n\t|| (central->bitflags != local->bitflags)\n#endif\n\t|| (central->comp_method != local->comp_method)\n\t|| (central->last_mod != local->last_mod)\n\t|| !_zip_string_equal(central->filename, local->filename))\n\treturn -1;\n\n    if ((central->crc != local->crc) || (central->comp_size != local->comp_size)\n\t|| (central->uncomp_size != local->uncomp_size)) {\n\t/* InfoZip stores valid values in local header even when data descriptor is used.\n\t   This is in violation of the appnote. */\n\tif (((local->bitflags & ZIP_GPBF_DATA_DESCRIPTOR) == 0\n\t     || local->crc != 0 || local->comp_size != 0 || local->uncomp_size != 0))\n\t    return -1;\n    }\n\n    return 0;\n}\n\n\nstatic zip_t *\n_zip_allocate_new(zip_source_t *src, unsigned int flags, zip_error_t *error)\n{\n    zip_t *za;\n\n    if ((za = _zip_new(error)) == NULL) {\n\treturn NULL;\n    }\n\n    za->src = src;\n    za->open_flags = flags;\n    if (flags & ZIP_RDONLY) {\n        za->flags |= ZIP_AFL_RDONLY;\n        za->ch_flags |= ZIP_AFL_RDONLY;\n    }\n    return za;\n}\n\n\n/*\n * tests for file existence\n */\nstatic exists_t\n_zip_file_exists(zip_source_t *src, zip_error_t *error)\n{\n    struct zip_stat st;\n\n    zip_stat_init(&st);\n    if (zip_source_stat(src, &st) != 0) {\n        zip_error_t *src_error = zip_source_error(src);\n        if (zip_error_code_zip(src_error) == ZIP_ER_READ && zip_error_code_system(src_error) == ENOENT) {\n\t    return EXISTS_NOT;\n\t}\n\t_zip_error_copy(error, src_error);\n\treturn EXISTS_ERROR;\n    }\n\n    return (st.valid & ZIP_STAT_SIZE) && st.size == 0 ? EXISTS_EMPTY : EXISTS_NONEMPTY;\n}\n\n\nstatic zip_cdir_t *\n_zip_find_central_dir(zip_t *za, zip_uint64_t len)\n{\n    zip_cdir_t *cdir, *cdirnew;\n    zip_uint8_t *match;\n    zip_int64_t buf_offset;\n    zip_uint64_t buflen;\n    zip_int64_t a;\n    zip_int64_t best;\n    zip_error_t error;\n    zip_buffer_t *buffer;\n\n    if (len < EOCDLEN) {\n\tzip_error_set(&za->error, ZIP_ER_NOZIP, 0);\n        return NULL;\n    }\n\n    buflen = (len < CDBUFSIZE ? len : CDBUFSIZE);\n    if (zip_source_seek(za->src, -(zip_int64_t)buflen, SEEK_END) < 0) {\n\tzip_error_t *src_error = zip_source_error(za->src);\n\tif (zip_error_code_zip(src_error) != ZIP_ER_SEEK || zip_error_code_system(src_error) != EFBIG) {\n\t    /* seek before start of file on my machine */\n\t    _zip_error_copy(&za->error, src_error);\n\t    return NULL;\n\t}\n    }\n    if ((buf_offset = zip_source_tell(za->src)) < 0) {\n        _zip_error_set_from_source(&za->error, za->src);\n        return NULL;\n    }\n\n    if ((buffer = _zip_buffer_new_from_source(za->src, buflen, NULL, &za->error)) == NULL) {\n        return NULL;\n    }\n\n    best = -1;\n    cdir = NULL;\n    if (buflen >= CDBUFSIZE) {\n        /* EOCD64 locator is before EOCD, so leave place for it */\n        _zip_buffer_set_offset(buffer, EOCD64LOCLEN);\n    }\n    zip_error_set(&error, ZIP_ER_NOZIP, 0);\n\n    match = _zip_buffer_get(buffer, 0);\n    while ((match=_zip_memmem(match, _zip_buffer_left(buffer)-(EOCDLEN-4), (const unsigned char *)EOCD_MAGIC, 4)) != NULL) {\n        _zip_buffer_set_offset(buffer, (zip_uint64_t)(match - _zip_buffer_data(buffer)));\n        if ((cdirnew = _zip_read_cdir(za, buffer, (zip_uint64_t)buf_offset, &error)) != NULL) {\n            if (cdir) {\n                if (best <= 0) {\n                    best = _zip_checkcons(za, cdir, &error);\n                }\n\n                a = _zip_checkcons(za, cdirnew, &error);\n                if (best < a) {\n                    _zip_cdir_free(cdir);\n                    cdir = cdirnew;\n                    best = a;\n                }\n                else {\n                    _zip_cdir_free(cdirnew);\n                }\n            }\n            else {\n                cdir = cdirnew;\n                if (za->open_flags & ZIP_CHECKCONS)\n                    best = _zip_checkcons(za, cdir, &error);\n                else {\n                    best = 0;\n                }\n            }\n            cdirnew = NULL;\n        }\n\n        match++;\n        _zip_buffer_set_offset(buffer, (zip_uint64_t)(match - _zip_buffer_data(buffer)));\n    }\n\n    _zip_buffer_free(buffer);\n\n    if (best < 0) {\n        _zip_error_copy(&za->error, &error);\n        _zip_cdir_free(cdir);\n        return NULL;\n    }\n\n    return cdir;\n}\n\n\nstatic unsigned char *\n_zip_memmem(const unsigned char *big, size_t biglen, const unsigned char *little, size_t littlelen)\n{\n    const unsigned char *p;\n\n    if ((biglen < littlelen) || (littlelen == 0))\n\treturn NULL;\n    p = big-1;\n    while ((p=(const unsigned char *)\n\t        memchr(p+1, little[0], (size_t)(big-(p+1))+(size_t)(biglen-littlelen)+1)) != NULL) {\n\tif (memcmp(p+1, little+1, littlelen-1)==0)\n\t    return (unsigned char *)p;\n    }\n\n    return NULL;\n}\n\n\nstatic zip_cdir_t *\n_zip_read_eocd(zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t i, nentry, size, offset, eocd_offset;\n\n    if (_zip_buffer_left(buffer) < EOCDLEN) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    eocd_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    if (_zip_buffer_get_32(buffer) != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n\treturn NULL;\n    }\n\n    /* number of cdir-entries on this disk */\n    i = _zip_buffer_get_16(buffer);\n    /* number of cdir-entries */\n    nentry = _zip_buffer_get_16(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_32(buffer);\n    offset = _zip_buffer_get_32(buffer);\n\n    if (offset+size < offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (offset+size > buf_offset + eocd_offset) {\n\t/* cdir spans past EOCD record */\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd->is_zip64 = false;\n    cd->size = size;\n    cd->offset = offset;\n\n    return cd;\n}\n\n\nstatic zip_cdir_t *\n_zip_read_eocd64(zip_source_t *src, zip_buffer_t *buffer, zip_uint64_t buf_offset, unsigned int flags, zip_error_t *error)\n{\n    zip_cdir_t *cd;\n    zip_uint64_t offset;\n    zip_uint8_t eocd[EOCD64LEN];\n    zip_uint64_t eocd_offset;\n    zip_uint64_t size, nentry, i, eocdloc_offset;\n    bool free_buffer;\n    zip_uint32_t num_disks, num_disks64, eocd_disk, eocd_disk64;\n\n    eocdloc_offset = _zip_buffer_offset(buffer);\n\n    _zip_buffer_get(buffer, 4); /* magic already verified */\n\n    num_disks = _zip_buffer_get_16(buffer);\n    eocd_disk = _zip_buffer_get_16(buffer);\n    eocd_offset = _zip_buffer_get_64(buffer);\n\n    if (eocd_offset > ZIP_INT64_MAX || eocd_offset + EOCD64LEN < eocd_offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n\n    if (eocd_offset + EOCD64LEN > eocdloc_offset + buf_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if (eocd_offset >= buf_offset && eocd_offset + EOCD64LEN <= buf_offset + _zip_buffer_size(buffer)) {\n        _zip_buffer_set_offset(buffer, eocd_offset - buf_offset);\n        free_buffer = false;\n    }\n    else {\n        if (zip_source_seek(src, (zip_int64_t)eocd_offset, SEEK_SET) < 0) {\n            _zip_error_set_from_source(error, src);\n            return NULL;\n        }\n        if ((buffer = _zip_buffer_new_from_source(src, EOCD64LEN, eocd, error)) == NULL) {\n            return NULL;\n        }\n        free_buffer = true;\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), EOCD64_MAGIC, 4) != 0) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n\n    if ((flags & ZIP_CHECKCONS) && size + eocd_offset + 12 != buf_offset + eocdloc_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    _zip_buffer_get(buffer, 4); /* skip version made by/needed */\n\n    num_disks64 = _zip_buffer_get_32(buffer);\n    eocd_disk64 = _zip_buffer_get_32(buffer);\n\n    /* if eocd values are 0xffff, we have to use eocd64 values.\n       otherwise, if the values are not the same, it's inconsistent;\n       in any case, if the value is not 0, we don't support it */\n    if (num_disks == 0xffff) {\n\tnum_disks = num_disks64;\n    }\n    if (eocd_disk == 0xffff) {\n\teocd_disk = eocd_disk64;\n    }\n    if ((flags & ZIP_CHECKCONS) && (eocd_disk != eocd_disk64 || num_disks != num_disks64)) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n    if (num_disks != 0 || eocd_disk != 0) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    nentry = _zip_buffer_get_64(buffer);\n    i = _zip_buffer_get_64(buffer);\n\n    if (nentry != i) {\n\tzip_error_set(error, ZIP_ER_MULTIDISK, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn NULL;\n    }\n\n    size = _zip_buffer_get_64(buffer);\n    offset = _zip_buffer_get_64(buffer);\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (free_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return NULL;\n    }\n\n    if (free_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    if (offset > ZIP_INT64_MAX || offset+size < offset) {\n        zip_error_set(error, ZIP_ER_SEEK, EFBIG);\n        return NULL;\n    }\n    if (offset+size > buf_offset + eocd_offset) {\n\t/* cdir spans past EOCD record */\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n    if ((flags & ZIP_CHECKCONS) && offset+size != buf_offset + eocd_offset) {\n\tzip_error_set(error, ZIP_ER_INCONS, 0);\n\treturn NULL;\n    }\n\n    if ((cd=_zip_cdir_new(nentry, error)) == NULL)\n\treturn NULL;\n\n    cd->is_zip64 = true;\n    cd->size = size;\n    cd->offset = offset;\n\n    return cd;\n}\n"], "filenames": ["lib/zip_open.c"], "buggy_code_start_loc": [850], "buggy_code_end_loc": [851], "fixing_code_start_loc": [850], "fixing_code_end_loc": [856], "type": "CWE-770", "message": "The _zip_read_eocd64 function in zip_open.c in libzip before 1.3.0 mishandles EOCD records, which allows remote attackers to cause a denial of service (memory allocation failure in _zip_cdir_grow in zip_dirent.c) via a crafted ZIP archive.", "other": {"cve": {"id": "CVE-2017-14107", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-01T17:29:00.260", "lastModified": "2022-04-06T18:35:22.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The _zip_read_eocd64 function in zip_open.c in libzip before 1.3.0 mishandles EOCD records, which allows remote attackers to cause a denial of service (memory allocation failure in _zip_cdir_grow in zip_dirent.c) via a crafted ZIP archive."}, {"lang": "es", "value": "La funci\u00f3n _zip_read_eocd64 en zip_open.c en libzip en versiones anteriores a la 1.3.0 no gestiona correctamente los registros EOCD, lo que permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (error de asignaci\u00f3n de memoria en _zip_cdir_grow en zip_dirent.c) mediante un archivo ZIP manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libzip:libzip:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.0", "matchCriteriaId": "977BC6AD-09AF-4808-BBA3-352B6A932B59"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/09/01/libzip-memory-allocation-failure-in-_zip_cdir_grow-zip_dirent-c/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/nih-at/libzip/commit/9b46957ec98d85a572e9ef98301247f39338a3b5", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nih-at/libzip/commit/9b46957ec98d85a572e9ef98301247f39338a3b5"}}