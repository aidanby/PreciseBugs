{"buggy_code": ["# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nclass ApplicationController < ActionController::Base\n\n  before_filter :set_context\n  before_filter :clear_setting_cache\n  before_filter \"hook(:app_before_filter, self)\"\n  after_filter  \"hook(:app_after_filter,  self)\"\n\n  helper_method :current_user_session, :current_user, :can_signup?\n  helper_method :called_from_index_page?, :called_from_landing_page?\n  helper_method :klass\n\n  respond_to :html, :only => [ :index, :show, :auto_complete ]\n  respond_to :js\n  respond_to :json, :xml, :except => :edit\n  respond_to :atom, :csv, :rss, :xls, :only => :index\n\n  rescue_from ActiveRecord::RecordNotFound, :with => :respond_to_not_found\n  rescue_from CanCan::AccessDenied,         :with => :respond_to_access_denied\n\n  # Common auto_complete handler for all core controllers.\n  #----------------------------------------------------------------------------\n  def auto_complete\n    @query = params[:auto_complete_query] || ''\n    @auto_complete = hook(:auto_complete, self, :query => @query, :user => current_user)\n    if @auto_complete.empty?\n      exclude_ids = auto_complete_ids_to_exclude(params[:related])\n      @auto_complete = klass.my.text_search(@query).search(:id_not_in => exclude_ids).result.limit(10)\n    else\n      @auto_complete = @auto_complete.last\n    end\n\n    session[:auto_complete] = controller_name.to_sym\n    respond_to do |format|\n      format.any(:js, :html)   { render :partial => 'auto_complete' }\n      format.json { render :json => @auto_complete.inject({}){|h,a|\n        h[a.id] = a.respond_to?(:full_name) ? a.full_name : a.name; h\n      }}\n    end\n  end\n\nprivate\n\n  #\n  # Takes { :related => 'campaigns/7' } or { :related => '5' }\n  #   and returns array of object ids that should be excluded from search\n  #   assumes controller_name is an method on 'related' class that returns a collection\n  #----------------------------------------------------------------------------\n  def auto_complete_ids_to_exclude(related)\n    return [] if related.blank?\n    return [related.to_i].compact unless related.index('/')\n    related_class, id = related.split('/')\n    obj = related_class.classify.constantize.find_by_id(id)\n    if obj and obj.respond_to?(controller_name)\n      obj.send(controller_name).map(&:id)\n    else\n      []\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def klass\n    @klass ||= controller_name.classify.constantize\n  end\n\n  #----------------------------------------------------------------------------\n  def clear_setting_cache\n    Setting.clear_cache!\n  end\n\n  #----------------------------------------------------------------------------\n  def set_context\n    Time.zone = ActiveSupport::TimeZone[session[:timezone_offset]] if session[:timezone_offset]\n    if current_user.present? and (locale = current_user.preference[:locale]).present?\n      I18n.locale = locale\n    elsif Setting.locale.present?\n      I18n.locale = Setting.locale\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def set_current_tab(tab = controller_name)\n    @current_tab = tab\n  end\n\n  #----------------------------------------------------------------------------\n  def current_user_session\n    @current_user_session ||= Authentication.find\n    if @current_user_session && @current_user_session.record.suspended?\n      @current_user_session = nil\n    end\n    @current_user_session\n  end\n\n  #----------------------------------------------------------------------------\n  def current_user\n    unless @current_user\n      @current_user = (current_user_session && current_user_session.record)\n      if @current_user\n        @current_user.set_individual_locale\n        @current_user.set_single_access_token\n      end\n      User.current_user = @current_user\n    end\n    @current_user\n  end\n\n  #----------------------------------------------------------------------------\n  def require_user\n    unless current_user\n      store_location\n      flash[:notice] = t(:msg_login_needed) if request.fullpath != \"/\"\n      respond_to do |format|\n        format.html { redirect_to login_url }\n        format.js   { render(:index) { |page| page.redirect_to login_url } }\n      end\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def require_no_user\n    if current_user\n      store_location\n      flash[:notice] = t(:msg_logout_needed)\n      redirect_to profile_url\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def store_location\n    session[:return_to] = request.fullpath\n  end\n\n  #----------------------------------------------------------------------------\n  def redirect_back_or_default(default)\n    redirect_to(session[:return_to] || default)\n    session[:return_to] = nil\n  end\n\n  #----------------------------------------------------------------------------\n  def can_signup?\n    [ :allowed, :needs_approval ].include? Setting.user_signup\n  end\n\n  #----------------------------------------------------------------------------\n  def called_from_index_page?(controller = controller_name)\n    if controller != \"tasks\"\n      request.referer =~ %r(/#{controller}$)\n    else\n      request.referer =~ /tasks\\?*/\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def called_from_landing_page?(controller = controller_name)\n    request.referer =~ %r(/#{controller}/\\w+)\n  end\n\n  # Proxy current page for any of the controllers by storing it in a session.\n  #----------------------------------------------------------------------------\n  def current_page=(page)\n    p = page.to_i\n    @current_page = session[:\"#{controller_name}_current_page\"] = (p.zero? ? 1 : p)\n  end\n\n  #----------------------------------------------------------------------------\n  def current_page\n    page = params[:page] || session[:\"#{controller_name}_current_page\"] || 1\n    @current_page = page.to_i\n  end\n\n  # Proxy current search query for any of the controllers by storing it in a session.\n  #----------------------------------------------------------------------------\n  def current_query=(query)\n    if session[:\"#{controller_name}_current_query\"].to_s != query.to_s # nil.to_s == \"\"\n      self.current_page = params[:page] # reset paging otherwise results might be hidden, defaults to 1 if nil\n    end\n    @current_query = session[:\"#{controller_name}_current_query\"] = query\n  end\n\n  #----------------------------------------------------------------------------\n  def current_query\n    @current_query = params[:query] || session[:\"#{controller_name}_current_query\"] || ''\n  end\n\n  #----------------------------------------------------------------------------\n  def asset\n    self.controller_name.singularize\n  end\n\n  #----------------------------------------------------------------------------\n  def respond_to_not_found(*types)\n    flash[:warning] = t(:msg_asset_not_available, asset)\n\n    respond_to do |format|\n      format.html { redirect_to :action => :index }\n      format.js   { render(:update) { |page| page.reload } }\n      format.json { render :text => flash[:warning], :status => :not_found }\n      format.xml  { render :text => flash[:warning], :status => :not_found }\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def respond_to_related_not_found(related, *types)\n    asset = \"note\" if asset == \"comment\"\n    flash[:warning] = t(:msg_cant_create_related, :asset => asset, :related => related)\n\n    url = send(\"#{related.pluralize}_path\")\n    respond_to do |format|\n      format.html { redirect_to url }\n      format.js   { render(:update) { |page| page.redirect_to url } }\n      format.json { render :text => flash[:warning], :status => :not_found }\n      format.xml  { render :text => flash[:warning], :status => :not_found }\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def respond_to_access_denied\n    if self.action_name == \"show\"\n      flash[:warning] = t(:msg_asset_not_authorized, asset)\n\n    else\n      flick = case self.action_name\n        when \"destroy\" then \"delete\"\n        when \"promote\" then \"convert\"\n        else self.action_name\n      end\n      flash[:warning] = t(:msg_cant_do, :action => flick, :asset => asset)\n    end\n\n    respond_to do |format|\n      format.html { redirect_to :action => :index }\n      format.js   { render(:update) { |page| page.reload } }\n      format.json { render :text => flash[:warning], :status => :unauthorized }\n      format.xml  { render :text => flash[:warning], :status => :unauthorized }\n    end\n  end\nend\n"], "fixing_code": ["# Copyright (c) 2008-2013 Michael Dvorkin and contributors.\n#\n# Fat Free CRM is freely distributable under the terms of MIT license.\n# See MIT-LICENSE file or http://www.opensource.org/licenses/mit-license.php\n#------------------------------------------------------------------------------\nclass ApplicationController < ActionController::Base\n\n  protect_from_forgery\n\n  before_filter :set_context\n  before_filter :clear_setting_cache\n  before_filter \"hook(:app_before_filter, self)\"\n  after_filter  \"hook(:app_after_filter,  self)\"\n\n  helper_method :current_user_session, :current_user, :can_signup?\n  helper_method :called_from_index_page?, :called_from_landing_page?\n  helper_method :klass\n\n  respond_to :html, :only => [ :index, :show, :auto_complete ]\n  respond_to :js\n  respond_to :json, :xml, :except => :edit\n  respond_to :atom, :csv, :rss, :xls, :only => :index\n\n  rescue_from ActiveRecord::RecordNotFound, :with => :respond_to_not_found\n  rescue_from CanCan::AccessDenied,         :with => :respond_to_access_denied\n\n  # Common auto_complete handler for all core controllers.\n  #----------------------------------------------------------------------------\n  def auto_complete\n    @query = params[:auto_complete_query] || ''\n    @auto_complete = hook(:auto_complete, self, :query => @query, :user => current_user)\n    if @auto_complete.empty?\n      exclude_ids = auto_complete_ids_to_exclude(params[:related])\n      @auto_complete = klass.my.text_search(@query).search(:id_not_in => exclude_ids).result.limit(10)\n    else\n      @auto_complete = @auto_complete.last\n    end\n\n    session[:auto_complete] = controller_name.to_sym\n    respond_to do |format|\n      format.any(:js, :html)   { render :partial => 'auto_complete' }\n      format.json { render :json => @auto_complete.inject({}){|h,a|\n        h[a.id] = a.respond_to?(:full_name) ? a.full_name : a.name; h\n      }}\n    end\n  end\n\nprivate\n\n  #\n  # Takes { :related => 'campaigns/7' } or { :related => '5' }\n  #   and returns array of object ids that should be excluded from search\n  #   assumes controller_name is an method on 'related' class that returns a collection\n  #----------------------------------------------------------------------------\n  def auto_complete_ids_to_exclude(related)\n    return [] if related.blank?\n    return [related.to_i].compact unless related.index('/')\n    related_class, id = related.split('/')\n    obj = related_class.classify.constantize.find_by_id(id)\n    if obj and obj.respond_to?(controller_name)\n      obj.send(controller_name).map(&:id)\n    else\n      []\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def klass\n    @klass ||= controller_name.classify.constantize\n  end\n\n  #----------------------------------------------------------------------------\n  def clear_setting_cache\n    Setting.clear_cache!\n  end\n\n  #----------------------------------------------------------------------------\n  def set_context\n    Time.zone = ActiveSupport::TimeZone[session[:timezone_offset]] if session[:timezone_offset]\n    if current_user.present? and (locale = current_user.preference[:locale]).present?\n      I18n.locale = locale\n    elsif Setting.locale.present?\n      I18n.locale = Setting.locale\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def set_current_tab(tab = controller_name)\n    @current_tab = tab\n  end\n\n  #----------------------------------------------------------------------------\n  def current_user_session\n    @current_user_session ||= Authentication.find\n    if @current_user_session && @current_user_session.record.suspended?\n      @current_user_session = nil\n    end\n    @current_user_session\n  end\n\n  #----------------------------------------------------------------------------\n  def current_user\n    unless @current_user\n      @current_user = (current_user_session && current_user_session.record)\n      if @current_user\n        @current_user.set_individual_locale\n        @current_user.set_single_access_token\n      end\n      User.current_user = @current_user\n    end\n    @current_user\n  end\n\n  #----------------------------------------------------------------------------\n  def require_user\n    unless current_user\n      store_location\n      flash[:notice] = t(:msg_login_needed) if request.fullpath != \"/\"\n      respond_to do |format|\n        format.html { redirect_to login_url }\n        format.js   { render(:index) { |page| page.redirect_to login_url } }\n      end\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def require_no_user\n    if current_user\n      store_location\n      flash[:notice] = t(:msg_logout_needed)\n      redirect_to profile_url\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def store_location\n    session[:return_to] = request.fullpath\n  end\n\n  #----------------------------------------------------------------------------\n  def redirect_back_or_default(default)\n    redirect_to(session[:return_to] || default)\n    session[:return_to] = nil\n  end\n\n  #----------------------------------------------------------------------------\n  def can_signup?\n    [ :allowed, :needs_approval ].include? Setting.user_signup\n  end\n\n  #----------------------------------------------------------------------------\n  def called_from_index_page?(controller = controller_name)\n    if controller != \"tasks\"\n      request.referer =~ %r(/#{controller}$)\n    else\n      request.referer =~ /tasks\\?*/\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def called_from_landing_page?(controller = controller_name)\n    request.referer =~ %r(/#{controller}/\\w+)\n  end\n\n  # Proxy current page for any of the controllers by storing it in a session.\n  #----------------------------------------------------------------------------\n  def current_page=(page)\n    p = page.to_i\n    @current_page = session[:\"#{controller_name}_current_page\"] = (p.zero? ? 1 : p)\n  end\n\n  #----------------------------------------------------------------------------\n  def current_page\n    page = params[:page] || session[:\"#{controller_name}_current_page\"] || 1\n    @current_page = page.to_i\n  end\n\n  # Proxy current search query for any of the controllers by storing it in a session.\n  #----------------------------------------------------------------------------\n  def current_query=(query)\n    if session[:\"#{controller_name}_current_query\"].to_s != query.to_s # nil.to_s == \"\"\n      self.current_page = params[:page] # reset paging otherwise results might be hidden, defaults to 1 if nil\n    end\n    @current_query = session[:\"#{controller_name}_current_query\"] = query\n  end\n\n  #----------------------------------------------------------------------------\n  def current_query\n    @current_query = params[:query] || session[:\"#{controller_name}_current_query\"] || ''\n  end\n\n  #----------------------------------------------------------------------------\n  def asset\n    self.controller_name.singularize\n  end\n\n  #----------------------------------------------------------------------------\n  def respond_to_not_found(*types)\n    flash[:warning] = t(:msg_asset_not_available, asset)\n\n    respond_to do |format|\n      format.html { redirect_to :action => :index }\n      format.js   { render(:update) { |page| page.reload } }\n      format.json { render :text => flash[:warning], :status => :not_found }\n      format.xml  { render :text => flash[:warning], :status => :not_found }\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def respond_to_related_not_found(related, *types)\n    asset = \"note\" if asset == \"comment\"\n    flash[:warning] = t(:msg_cant_create_related, :asset => asset, :related => related)\n\n    url = send(\"#{related.pluralize}_path\")\n    respond_to do |format|\n      format.html { redirect_to url }\n      format.js   { render(:update) { |page| page.redirect_to url } }\n      format.json { render :text => flash[:warning], :status => :not_found }\n      format.xml  { render :text => flash[:warning], :status => :not_found }\n    end\n  end\n\n  #----------------------------------------------------------------------------\n  def respond_to_access_denied\n    if self.action_name == \"show\"\n      flash[:warning] = t(:msg_asset_not_authorized, asset)\n\n    else\n      flick = case self.action_name\n        when \"destroy\" then \"delete\"\n        when \"promote\" then \"convert\"\n        else self.action_name\n      end\n      flash[:warning] = t(:msg_cant_do, :action => flick, :asset => asset)\n    end\n\n    respond_to do |format|\n      format.html { redirect_to :action => :index }\n      format.js   { render(:update) { |page| page.reload } }\n      format.json { render :text => flash[:warning], :status => :unauthorized }\n      format.xml  { render :text => flash[:warning], :status => :unauthorized }\n    end\n  end\nend\n"], "filenames": ["app/controllers/application_controller.rb"], "buggy_code_start_loc": [6], "buggy_code_end_loc": [6], "fixing_code_start_loc": [7], "fixing_code_end_loc": [9], "type": "CWE-352", "message": "Multiple cross-site request forgery (CSRF) vulnerabilities in Fat Free CRM before 0.12.1 allow remote attackers to hijack the authentication of unspecified victims via unknown vectors, related to the lack of a protect_from_forgery line in app/controllers/application_controller.rb.", "other": {"cve": {"id": "CVE-2013-7223", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-02T14:59:04.080", "lastModified": "2014-01-03T17:11:44.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple cross-site request forgery (CSRF) vulnerabilities in Fat Free CRM before 0.12.1 allow remote attackers to hijack the authentication of unspecified victims via unknown vectors, related to the lack of a protect_from_forgery line in app/controllers/application_controller.rb."}, {"lang": "es", "value": "Multiples vulnerabilidades cross-site request forgery (CSRF)  en Fat Free CRM antes 0.12.1 permite a atacantes remotos secuestrar la autenticaci\u00f3n de las v\u00edctimas a trav\u00e9s de vectores no especificados desconocidos, relacionados con la falta de una l\u00ednea de protecci\u00f3n en app/controllers/application_controller.rb."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.12.0", "matchCriteriaId": "437226C5-1A19-4BFE-9177-603284DAEADA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "ADF154CE-04ED-446E-B2F4-483D7D356975"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "34CFB3C8-9C3B-43D8-B946-0EB2FAFD3BF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "8C2B22FC-6FA2-4365-BC71-ED79D914B781"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "0108A4ED-2D1F-49C8-88C7-7A074767CFE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "0A5888F1-1D68-4131-ADDC-BBEDB62E74ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "0F5CBECE-E4A4-48A7-8880-D9562378FE22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "33170E54-4CF5-42B2-9F9A-269C26C9FB70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "890482B9-D9AC-4D10-9764-4E23A112070F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fatfreecrm:fat_free_crm:0.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3C652479-AE15-4BAC-AE75-9018FE71AABA"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2013/12/28/2", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2013/Dec/199", "source": "cve@mitre.org"}, {"url": "http://www.phenoelit.org/stuff/ffcrm.txt", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/commit/a7fedbb36388bad0c0f32b2346481e0ea126dea6", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/fatfreecrm/fat_free_crm/issues/300", "source": "cve@mitre.org"}, {"url": "https://github.com/fatfreecrm/fat_free_crm/wiki/Fixing-security-vulnerabilities-%2827th-Dec-2013%29", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/fatfreecrm/fat_free_crm/commit/a7fedbb36388bad0c0f32b2346481e0ea126dea6"}}