{"buggy_code": ["/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.applicationimpl;\n\nimport static com.sun.faces.application.ApplicationImpl.THIS_LIBRARY;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.DateTimeConverterUsesSystemTimezone;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.RegisterConverterPropertyEditors;\nimport static com.sun.faces.util.Util.isEmpty;\nimport static com.sun.faces.util.Util.loadClass;\nimport static com.sun.faces.util.Util.notNull;\nimport static com.sun.faces.util.Util.notNullNamedObject;\nimport static java.beans.Introspector.getBeanInfo;\nimport static java.beans.PropertyEditorManager.findEditor;\nimport static java.text.MessageFormat.format;\nimport static java.util.Collections.unmodifiableMap;\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.SEVERE;\nimport static java.util.logging.Level.WARNING;\nimport static javax.faces.application.Resource.COMPONENT_RESOURCE_KEY;\nimport static javax.faces.component.UIComponent.ATTRS_WITH_DECLARED_DEFAULT_VALUES;\nimport static javax.faces.component.UIComponent.BEANINFO_KEY;\nimport static javax.faces.component.UIComponent.COMPOSITE_COMPONENT_TYPE_KEY;\n\nimport java.beans.BeanDescriptor;\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.PropertyDescriptor;\nimport java.beans.PropertyEditor;\nimport java.beans.PropertyEditorManager;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.text.MessageFormat;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.enterprise.inject.spi.BeanManager;\nimport javax.faces.FacesException;\nimport javax.faces.application.Application;\nimport javax.faces.application.Resource;\nimport javax.faces.component.UIComponent;\nimport javax.faces.component.behavior.Behavior;\nimport javax.faces.context.FacesContext;\nimport javax.faces.convert.Converter;\nimport javax.faces.convert.DateTimeConverter;\nimport javax.faces.el.ValueBinding;\nimport javax.faces.render.RenderKit;\nimport javax.faces.render.Renderer;\nimport javax.faces.validator.Validator;\nimport javax.faces.view.ViewDeclarationLanguage;\n\nimport com.sun.faces.application.ApplicationAssociate;\nimport com.sun.faces.application.ConverterPropertyEditorFactory;\nimport com.sun.faces.application.ViewMemberInstanceFactoryMetadataMap;\nimport com.sun.faces.cdi.CdiUtils;\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.MessageUtils;\nimport com.sun.faces.util.ReflectionUtils;\nimport com.sun.faces.util.Util;\n\npublic class InstanceFactory {\n    \n    // Log instance for this class\n    private static final Logger LOGGER = FacesLogger.APPLICATION.getLogger();\n    \n    private static final String CONTEXT = \"context\";\n    private static final String COMPONENT_EXPRESSION = \"componentExpression\";\n    private static final String COMPONENT_TYPE = \"componentType\";\n    private static final String COMPONENT_CLASS = \"componentClass\";\n    \n    private static final Map<String, Class<?>[]> STANDARD_CONV_ID_TO_TYPE_MAP = new HashMap<>(8, 1.0f);\n    private static final Map<Class<?>, String> STANDARD_TYPE_TO_CONV_ID_MAP = new HashMap<>(16, 1.0f);\n\n    static {\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Byte\", new Class[] { Byte.TYPE, Byte.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Boolean\", new Class[] { Boolean.TYPE, Boolean.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Character\", new Class[] { Character.TYPE, Character.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Short\", new Class[] { Short.TYPE, Short.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Integer\", new Class[] { Integer.TYPE, Integer.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Long\", new Class[] { Long.TYPE, Long.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Float\", new Class[] { Float.TYPE, Float.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Double\", new Class[] { Double.TYPE, Double.class });\n        for (Map.Entry<String, Class<?>[]> entry : STANDARD_CONV_ID_TO_TYPE_MAP.entrySet()) {\n            Class<?>[] types = entry.getValue();\n            String key = entry.getKey();\n            for (Class<?> clazz : types) {\n                STANDARD_TYPE_TO_CONV_ID_MAP.put(clazz, key);\n            }\n        }\n    }\n    \n    private final String[] STANDARD_BY_TYPE_CONVERTER_CLASSES = { \"java.math.BigDecimal\", \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\",\n            \"java.lang.Double\", \"java.lang.Float\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Short\", \"java.lang.Enum\" };\n\n    private Map<Class<?>, Object> converterTypeMap;\n    private boolean registerPropertyEditors;\n    private boolean passDefaultTimeZone;\n    \n    private TimeZone systemTimeZone;\n    \n    private static final class ComponentResourceClassNotFound{}\n    \n    //\n    // These four maps store store \"identifier\" | \"class name\"\n    // mappings.\n    //\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> componentMap;\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> behaviorMap;\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> converterIdMap;\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> validatorMap;\n    \n    private Set<String> defaultValidatorIds;\n    private volatile Map<String, String> defaultValidatorInfo;\n    \n    private final ApplicationAssociate associate;\n    private Version version;\n    \n    /**\n     * Stores the bean manager.\n     */\n    private BeanManager beanManager;\n    \n    public InstanceFactory(ApplicationAssociate applicationAssociate) {\n        this.associate = applicationAssociate;\n        version = new Version();\n        \n        componentMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        converterIdMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        converterTypeMap = new ConcurrentHashMap<>();\n        validatorMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        defaultValidatorIds = new LinkedHashSet<>();\n        behaviorMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        \n        WebConfiguration webConfig = WebConfiguration.getInstance(FacesContext.getCurrentInstance().getExternalContext());\n        registerPropertyEditors = webConfig.isOptionEnabled(RegisterConverterPropertyEditors);\n        \n        passDefaultTimeZone = webConfig.isOptionEnabled(DateTimeConverterUsesSystemTimezone);\n        if (passDefaultTimeZone) {\n            systemTimeZone = TimeZone.getDefault();\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addComponent(java.lang.String, java.lang.String)\n     */\n    public void addComponent(String componentType, String componentClass) {\n\n        notNull(COMPONENT_TYPE, componentType);\n        notNull(COMPONENT_CLASS, componentClass);\n\n        if (LOGGER.isLoggable(FINE) && componentMap.containsKey(componentType)) {\n            LOGGER.log(FINE, \"componentType {0} has already been registered.  Replacing existing component class type {1} with {2}.\",\n                    new Object[] { componentType, componentMap.get(componentType), componentClass });\n        }\n\n        componentMap.put(componentType, componentClass);\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"added component of type ''{0}'' and class ''{1}''\", componentType, componentClass));\n        }\n    }\n    \n    public UIComponent createComponent(ValueExpression componentExpression, FacesContext context, String componentType) throws FacesException {\n\n        notNull(COMPONENT_EXPRESSION, componentExpression);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(context, componentExpression, componentType, null, true);\n    }\n    \n    public UIComponent createComponent(String componentType) throws FacesException {\n\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(FacesContext.getCurrentInstance(), componentType, null, true);\n    }\n    \n    public UIComponent createComponent(FacesContext context, Resource componentResource, ExpressionFactory expressionFactory) throws FacesException {\n\n        // RELEASE_PENDING (rlubke,driscoll) this method needs review.\n\n        notNull(CONTEXT, context);\n        notNull(\"componentResource\", componentResource);\n\n        UIComponent result = null;\n\n        // Use the application defined in the FacesContext as we may be calling\n        // overriden methods\n        Application app = context.getApplication();\n\n        ViewDeclarationLanguage vdl = app.getViewHandler().getViewDeclarationLanguage(context, context.getViewRoot().getViewId());\n        BeanInfo componentMetadata = vdl.getComponentMetadata(context, componentResource);\n\n        if (componentMetadata != null) {\n            BeanDescriptor componentBeanDescriptor = componentMetadata.getBeanDescriptor();\n\n            // Step 1. See if the composite component author explicitly\n            // gave a componentType as part of the composite component metadata\n            ValueExpression valueExpression = (ValueExpression) componentBeanDescriptor.getValue(COMPOSITE_COMPONENT_TYPE_KEY);\n\n            if (valueExpression != null) {\n                String componentType = (String) valueExpression.getValue(context.getELContext());\n                if (!isEmpty(componentType)) {\n                    result = app.createComponent(componentType);\n                }\n            }\n        }\n\n        // Step 2. If that didn't work, if a script based resource can be\n        // found for the scriptComponentResource, see if a component can be generated from it\n        if (result == null) {\n            Resource scriptComponentResource = vdl.getScriptComponentResource(context, componentResource);\n\n            if (scriptComponentResource != null) {\n                result = createComponentFromScriptResource(context, scriptComponentResource, componentResource);\n            }\n        }\n\n        // Step 3. Use the libraryName of the resource as the java package\n        // and use the resourceName as the class name. See\n        // if a Java class can be loaded\n        if (result == null) {\n            String packageName = componentResource.getLibraryName();\n            String className = componentResource.getResourceName();\n            className = packageName + '.' + className.substring(0, className.lastIndexOf('.'));\n            try {\n                Class<?> clazz = (Class<?>) componentMap.get(className);\n                if (clazz == null) {\n                    clazz = loadClass(className, this);\n                }\n                if (clazz != ComponentResourceClassNotFound.class) {\n                    if (!associate.isDevModeEnabled()) {\n                        componentMap.put(className, clazz);\n                    }\n                    result = (UIComponent) clazz.newInstance();\n                }\n            } catch (ClassNotFoundException ex) {\n                if (!associate.isDevModeEnabled()) {\n                    componentMap.put(className, ComponentResourceClassNotFound.class);\n                }\n            } catch (InstantiationException | IllegalAccessException | ClassCastException ie) {\n                throw new FacesException(ie);\n            }\n        }\n\n        // Step 4. Use javax.faces.NamingContainer as the component type\n        if (result == null) {\n            result = app.createComponent(\"javax.faces.NamingContainer\");\n        }\n\n        result.setRendererType(\"javax.faces.Composite\");\n\n        Map<String, Object> attrs = result.getAttributes();\n        attrs.put(COMPONENT_RESOURCE_KEY, componentResource);\n        attrs.put(BEANINFO_KEY, componentMetadata);\n\n        associate.getAnnotationManager().applyComponentAnnotations(context, result);\n        pushDeclaredDefaultValuesToAttributesMap(context, componentMetadata, attrs, result, expressionFactory);\n\n        return result;\n    }\n    \n    public UIComponent createComponent(FacesContext context, String componentType, String rendererType) {\n        return createComponentApplyAnnotations(context, componentType, rendererType, true);\n    }\n    \n    public UIComponent createComponent(ValueExpression componentExpression, FacesContext context, String componentType, String rendererType) {\n\n        notNull(COMPONENT_EXPRESSION, componentExpression);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(context, componentExpression, componentType, rendererType, true);\n    }\n    \n    public UIComponent createComponent(ValueBinding componentBinding, FacesContext context, String componentType) throws FacesException {\n\n        notNull(\"componentBinding\", componentBinding);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        Object result;\n        boolean createOne = false;\n        try {\n            result = componentBinding.getValue(context);\n            if (result != null) {\n                createOne = !(result instanceof UIComponent);\n            }\n\n            if (result == null || createOne) {\n                result = createComponentApplyAnnotations(context, componentType, null, false);\n                componentBinding.setValue(context, result);\n            }\n        } catch (Exception ex) {\n            throw new FacesException(ex);\n        }\n\n        return (UIComponent) result;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getComponentTypes()\n     */\n    public Iterator<String> getComponentTypes() {\n        return componentMap.keySet().iterator();\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addBehavior(String, String)\n     */\n    public void addBehavior(String behaviorId, String behaviorClass) {\n\n        notNull(\"behaviorId\", behaviorId);\n        notNull(\"behaviorClass\", behaviorClass);\n\n        if (LOGGER.isLoggable(FINE) && behaviorMap.containsKey(behaviorId)) {\n            LOGGER.log(FINE, \"behaviorId {0} has already been registered.  Replacing existing behavior class type {1} with {2}.\",\n                    new Object[] { behaviorId, behaviorMap.get(behaviorId), behaviorClass });\n        }\n\n        behaviorMap.put(behaviorId, behaviorClass);\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"added behavior of type ''{0}'' class ''{1}''\", behaviorId, behaviorClass));\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createBehavior(String)\n     */\n    public Behavior createBehavior(String behaviorId) throws FacesException {\n\n        notNull(\"behaviorId\", behaviorId);\n\n        Behavior behavior = createCDIBehavior(behaviorId);\n        if (behavior != null) {\n            return behavior;\n        }\n\n        behavior = newThing(behaviorId, behaviorMap);\n        \n        notNullNamedObject(behavior, behaviorId, \"jsf.cannot_instantiate_behavior_error\");\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"created behavior of type ''{0}''\", behaviorId));\n        }\n\n        associate.getAnnotationManager().applyBehaviorAnnotations(FacesContext.getCurrentInstance(), behavior);\n\n        return behavior;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getBehaviorIds()\n     */\n    public Iterator<String> getBehaviorIds() {\n        return behaviorMap.keySet().iterator();\n    }\n    \n    public void addConverter(String converterId, String converterClass) {\n\n        notNull(\"converterId\", converterId);\n        notNull(\"converterClass\", converterClass);\n\n        if (LOGGER.isLoggable(FINE) && converterIdMap.containsKey(converterId)) {\n            LOGGER.log(FINE, \"converterId {0} has already been registered.  Replacing existing converter class type {1} with {2}.\",\n                    new Object[] { converterId, converterIdMap.get(converterId), converterClass });\n        }\n\n        converterIdMap.put(converterId, converterClass);\n\n        Class<?>[] types = STANDARD_CONV_ID_TO_TYPE_MAP.get(converterId);\n        if (types != null) {\n            for (Class<?> clazz : types) {\n                // go directly against map to prevent cyclic method calls\n                converterTypeMap.put(clazz, converterClass);\n                addPropertyEditorIfNecessary(clazz);\n            }\n        }\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(format(\"added converter of type ''{0}'' and class ''{1}''\", converterId, converterClass));\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addConverter(Class, String)\n     */\n    public void addConverter(Class<?> targetClass, String converterClass) {\n\n        notNull(\"targetClass\", targetClass);\n        notNull(\"converterClass\", converterClass);\n\n        String converterId = STANDARD_TYPE_TO_CONV_ID_MAP.get(targetClass);\n        if (converterId != null) {\n            addConverter(converterId, converterClass);\n        } else {\n            if (LOGGER.isLoggable(FINE) && converterTypeMap.containsKey(targetClass)) {\n                LOGGER.log(FINE, \"converter target class {0} has already been registered.  Replacing existing converter class type {1} with {2}.\",\n                        new Object[] { targetClass.getName(), converterTypeMap.get(targetClass), converterClass });\n            }\n\n            converterTypeMap.put(targetClass, converterClass);\n            addPropertyEditorIfNecessary(targetClass);\n        }\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(format(\"added converter of class type ''{0}''\", converterClass));\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createConverter(String)\n     */\n    public Converter<?> createConverter(String converterId) {\n\n        notNull(\"converterId\", converterId);\n        \n        Converter<?> converter = createCDIConverter(converterId);\n        if (converter != null) {\n            return converter;\n        }\n\n        converter = newThing(converterId, converterIdMap);\n        \n        notNullNamedObject(converter, converterId, \"jsf.cannot_instantiate_converter_error\");\n        \n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"created converter of type ''{0}''\", converterId));\n        }\n        \n        if (passDefaultTimeZone && converter instanceof DateTimeConverter) {\n            ((DateTimeConverter) converter).setTimeZone(systemTimeZone);\n        }\n        \n        associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), converter);\n        \n        return converter;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createConverter(Class)\n     */\n    public Converter createConverter(Class<?> targetClass) {\n\n        Util.notNull(\"targetClass\", targetClass);\n        Converter returnVal = null;\n\n        if (version.isJsf23()) {\n            BeanManager beanManager = getBeanManager();\n            returnVal = CdiUtils.createConverter(beanManager, targetClass);\n            if (returnVal != null) {\n                return returnVal;\n            }\n        }\n\n        returnVal = (Converter) newConverter(targetClass, converterTypeMap, targetClass);\n        if (returnVal != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n            }\n            if (passDefaultTimeZone && returnVal instanceof DateTimeConverter) {\n                ((DateTimeConverter) returnVal).setTimeZone(systemTimeZone);\n            }\n            associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), returnVal);\n            return returnVal;\n        }\n\n        // Search for converters registered to interfaces implemented by\n        // targetClass\n        Class<?>[] interfaces = targetClass.getInterfaces();\n        if (interfaces != null) {\n            for (int i = 0; i < interfaces.length; i++) {\n                returnVal = createConverterBasedOnClass(interfaces[i], targetClass);\n                if (returnVal != null) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                    }\n                    if (passDefaultTimeZone && returnVal instanceof DateTimeConverter) {\n                        ((DateTimeConverter) returnVal).setTimeZone(systemTimeZone);\n                    }\n                    associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), returnVal);\n                    return returnVal;\n                }\n            }\n        }\n\n        // Search for converters registered to superclasses of targetClass\n        Class<?> superclass = targetClass.getSuperclass();\n        if (superclass != null) {\n            returnVal = createConverterBasedOnClass(superclass, targetClass);\n            if (returnVal != null) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                }\n                if (passDefaultTimeZone && returnVal instanceof DateTimeConverter) {\n                    ((DateTimeConverter) returnVal).setTimeZone(systemTimeZone);\n                }\n                associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), returnVal);\n                return returnVal;\n            }\n        }\n\n        return returnVal;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getConverterIds()\n     */\n    public Iterator<String> getConverterIds() {\n        return converterIdMap.keySet().iterator();\n\n    }\n\n    /**\n     * @see javax.faces.application.Application#getConverterTypes()\n     */\n    public Iterator<Class<?>> getConverterTypes() {\n        return converterTypeMap.keySet().iterator();\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addValidator(String, String)\n     */\n    public void addValidator(String validatorId, String validatorClass) {\n\n        Util.notNull(\"validatorId\", validatorId);\n        Util.notNull(\"validatorClass\", validatorClass);\n\n        if (LOGGER.isLoggable(Level.FINE) && validatorMap.containsKey(validatorId)) {\n            LOGGER.log(Level.FINE, \"validatorId {0} has already been registered.  Replacing existing validator class type {1} with {2}.\",\n                    new Object[] { validatorId, validatorMap.get(validatorId), validatorClass });\n        }\n\n        validatorMap.put(validatorId, validatorClass);\n\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(MessageFormat.format(\"added validator of type ''{0}'' class ''{1}''\", validatorId, validatorClass));\n        }\n\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createValidator(String)\n     */\n    public Validator<?> createValidator(String validatorId) throws FacesException {\n\n        notNull(\"validatorId\", validatorId);\n\n        Validator<?> validator = createCDIValidator(validatorId);\n        if (validator != null) {\n            return validator;\n        }\n\n        validator = newThing(validatorId, validatorMap);\n        \n        notNullNamedObject(validator, validatorId, \"jsf.cannot_instantiate_validator_error\");\n        \n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"created validator of type ''{0}''\", validatorId));\n        }\n        \n        associate.getAnnotationManager().applyValidatorAnnotations(FacesContext.getCurrentInstance(), validator);\n        \n        return validator;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getValidatorIds()\n     */\n    public Iterator<String> getValidatorIds() {\n        return validatorMap.keySet().iterator();\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addDefaultValidatorId(String)\n     */\n    public synchronized void addDefaultValidatorId(String validatorId) {\n\n        notNull(\"validatorId\", validatorId);\n        \n        defaultValidatorInfo = null;\n        defaultValidatorIds.add(validatorId);\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getDefaultValidatorInfo()\n     */\n    public Map<String, String> getDefaultValidatorInfo() {\n\n        if (defaultValidatorInfo == null) {\n            synchronized (this) {\n                if (defaultValidatorInfo == null) {\n                    defaultValidatorInfo = new LinkedHashMap<>();\n                    if (!defaultValidatorIds.isEmpty()) {\n                        for (String id : defaultValidatorIds) {\n                            String validatorClass;\n                            Object result = validatorMap.get(id);\n                            if (null != result) {\n                                if (result instanceof Class) {\n                                    validatorClass = ((Class) result).getName();\n                                } else {\n                                    validatorClass = result.toString();\n                                }\n                                defaultValidatorInfo.put(id, validatorClass);\n                            }\n                        }\n\n                    }\n                }\n            }\n            defaultValidatorInfo = unmodifiableMap(defaultValidatorInfo);\n        }\n\n        return defaultValidatorInfo;\n\n    }\n    \n    \n    \n    \n   \n    // --------------------------------------------------------- Private Methods\n    \n\n    private UIComponent createComponentFromScriptResource(FacesContext context, Resource scriptComponentResource, Resource componentResource) {\n\n        UIComponent result = null;\n\n        String className = scriptComponentResource.getResourceName();\n        int lastDot = className.lastIndexOf('.');\n        className = className.substring(0, lastDot);\n\n        try {\n\n            Class<?> componentClass = (Class<?>) componentMap.get(className);\n            if (componentClass == null) {\n                componentClass = Util.loadClass(className, this);\n            }\n            if (!associate.isDevModeEnabled()) {\n                componentMap.put(className, componentClass);\n            }\n            result = (UIComponent) componentClass.newInstance();\n        } catch (IllegalAccessException | InstantiationException | ClassNotFoundException ex) {\n            if (LOGGER.isLoggable(Level.SEVERE)) {\n                LOGGER.log(Level.SEVERE, null, ex);\n            }\n        }\n\n        if (result != null) {\n            // Make sure the resource is there for the annotation processor.\n            result.getAttributes().put(Resource.COMPONENT_RESOURCE_KEY, componentResource);\n            // In case there are any \"this\" references,\n            // make sure they can be resolved.\n            context.getAttributes().put(THIS_LIBRARY, componentResource.getLibraryName());\n            try {\n                associate.getAnnotationManager().applyComponentAnnotations(context, result);\n            } finally {\n                context.getAttributes().remove(THIS_LIBRARY);\n            }\n        }\n\n        return result;\n\n    }\n    \n    /**\n     * Leveraged by\n     * {@link Application#createComponent(javax.el.ValueExpression, javax.faces.context.FacesContext, String)}\n     * and\n     * {@link Application#createComponent(javax.el.ValueExpression, javax.faces.context.FacesContext, String, String)}.\n     * This method will apply any component and render annotations that may be present.\n     */\n    private UIComponent createComponentApplyAnnotations(FacesContext ctx, ValueExpression componentExpression, String componentType, String rendererType,\n            boolean applyAnnotations) {\n\n        UIComponent c;\n\n        try {\n            c = (UIComponent) componentExpression.getValue(ctx.getELContext());\n\n            if (c == null) {\n                c = this.createComponentApplyAnnotations(ctx, componentType, rendererType, applyAnnotations);\n                componentExpression.setValue(ctx.getELContext(), c);\n            } else if (applyAnnotations) {\n                this.applyAnnotations(ctx, rendererType, c);\n            }\n        } catch (Exception ex) {\n            throw new FacesException(ex);\n        }\n\n        return c;\n\n    }\n    \n    /**\n     * Leveraged by {@link Application#createComponent(String)} and\n     * {@link Application#createComponent(javax.faces.context.FacesContext, String, String)} This\n     * method will apply any component and render annotations that may be present.\n     */\n    private UIComponent createComponentApplyAnnotations(FacesContext ctx, String componentType, String rendererType, boolean applyAnnotations) {\n\n        UIComponent component;\n        try {\n            component = newThing(componentType, componentMap);\n        } catch (Exception ex) {\n            if (LOGGER.isLoggable(SEVERE)) {\n                LOGGER.log(Level.SEVERE, \"jsf.cannot_instantiate_component_error\", componentType);\n            }\n            throw new FacesException(ex);\n        }\n        \n        notNullNamedObject(component, componentType, \"jsf.cannot_instantiate_component_error\");\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.log(FINE, MessageFormat.format(\"Created component with component type of ''{0}''\", componentType));\n        }\n\n        if (applyAnnotations) {\n            applyAnnotations(ctx, rendererType, component);\n        }\n        \n        return component;\n    }\n    \n    \n    /**\n     * Process any annotations associated with this component/renderer.\n     */\n    private void applyAnnotations(FacesContext ctx, String rendererType, UIComponent c) {\n\n        if (c != null && ctx != null) {\n            associate.getAnnotationManager().applyComponentAnnotations(ctx, c);\n            if (rendererType != null) {\n                RenderKit rk = ctx.getRenderKit();\n                Renderer r = null;\n                if (rk != null) {\n                    r = rk.getRenderer(c.getFamily(), rendererType);\n                    if (r != null) {\n                        c.setRendererType(rendererType);\n                        associate.getAnnotationManager().applyRendererAnnotations(ctx, r, c);\n                    }\n                }\n                if ((rk == null || r == null) && LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Unable to create Renderer with rendererType {0} for component with component type of {1}\",\n                            new Object[] { rendererType, c.getFamily() });\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * PRECONDITIONS: the values in the Map are either Strings representing fully qualified java\n     * class names, or java.lang.Class instances.\n     * </p>\n     * <p>\n     * ALGORITHM: Look in the argument map for a value for the argument key. If found, if the value\n     * is instanceof String, assume the String specifies a fully qualified java class name and\n     * obtain the java.lang.Class instance for that String using Util.loadClass(). Replace the\n     * String instance in the argument map with the Class instance. If the value is instanceof\n     * Class, proceed. Assert that the value is either instanceof java.lang.Class or\n     * java.lang.String.\n     * </p>\n     * <p>\n     * Now that you have a java.lang.class, call its newInstance and return it as the result of this\n     * method.\n     * </p>\n     *\n     * @param key Used to look up the value in the <code>Map</code>.\n     * @param map The <code>Map</code> that will be searched.\n     * @return The new object instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private <T> T newThing(String key, ViewMemberInstanceFactoryMetadataMap<String, Object> map) {\n\n        Object result;\n        Class<?> clazz;\n        Object value;\n\n        value = map.get(key);\n        if (value == null) {\n            return null;\n        }\n        assert value instanceof String || value instanceof Class;\n        if (value instanceof String) {\n            String cValue = (String) value;\n            try {\n                clazz = Util.loadClass(cValue, value);\n                if (!associate.isDevModeEnabled()) {\n                    map.put(key, clazz);\n                }\n                assert clazz != null;\n            } catch (Exception e) {\n                throw new FacesException(e.getMessage(), e);\n            }\n        } else {\n            clazz = (Class) value;\n        }\n\n        try {\n            result = clazz.newInstance();\n        } catch (Throwable t) {\n            Throwable previousT;\n            do {\n                previousT = t;\n                if (LOGGER.isLoggable(Level.SEVERE)) {\n                    LOGGER.log(Level.SEVERE, \"Unable to load class: \", t);\n                }\n            } while (null != (t = t.getCause()));\n            t = previousT;\n\n            throw new FacesException(MessageUtils.getExceptionMessageString(MessageUtils.CANT_INSTANTIATE_CLASS_ERROR_MESSAGE_ID, clazz.getName()), t);\n        }\n\n        return (T) result;\n    }\n    \n    /*\n     * This method makes it so that any cc:attribute elements that have a \"default\" attribute value\n     * have those values pushed into the composite component attribute map so that programmatic\n     * access (as opposed to EL access) will find the attribute values.\n     *\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void pushDeclaredDefaultValuesToAttributesMap(FacesContext context, BeanInfo componentMetadata, Map<String, Object> attrs, UIComponent component, ExpressionFactory expressionFactory) {\n\n        Collection<String> attributesWithDeclaredDefaultValues = null;\n        PropertyDescriptor[] propertyDescriptors = null;\n\n        for (PropertyDescriptor propertyDescriptor : componentMetadata.getPropertyDescriptors()) {\n            Object defaultValue = propertyDescriptor.getValue(\"default\");\n\n            if (defaultValue != null) {\n                String key = propertyDescriptor.getName();\n                boolean isLiteralText = false;\n\n                if (defaultValue instanceof ValueExpression) {\n                    isLiteralText = ((ValueExpression) defaultValue).isLiteralText();\n                    if (isLiteralText) {\n                        defaultValue = ((ValueExpression) defaultValue).getValue(context.getELContext());\n                    }\n                }\n\n                // Ensure this attribute is not a method-signature. method-signature\n                // declared default values are handled in retargetMethodExpressions.\n                if (propertyDescriptor.getValue(\"method-signature\") == null || propertyDescriptor.getValue(\"type\") != null) {\n\n                    if (attributesWithDeclaredDefaultValues == null) {\n                        BeanDescriptor beanDescriptor = componentMetadata.getBeanDescriptor();\n                        attributesWithDeclaredDefaultValues = (Collection<String>) beanDescriptor.getValue(ATTRS_WITH_DECLARED_DEFAULT_VALUES);\n                        if (attributesWithDeclaredDefaultValues == null) {\n                            attributesWithDeclaredDefaultValues = new HashSet<>();\n                            beanDescriptor.setValue(ATTRS_WITH_DECLARED_DEFAULT_VALUES, attributesWithDeclaredDefaultValues);\n                        }\n                    }\n                    attributesWithDeclaredDefaultValues.add(key);\n\n                    // Only store the attribute if it is literal text. If it\n                    // is a ValueExpression, it will be handled explicitly in\n                    // CompositeComponentAttributesELResolver.ExpressionEvalMap.get().\n                    // If it is a MethodExpression, it will be dealt with in\n                    // retargetMethodExpressions.\n                    if (isLiteralText) {\n                        try {\n                            if (propertyDescriptors == null) {\n                                propertyDescriptors = getBeanInfo(component.getClass()).getPropertyDescriptors();\n                            }\n                        } catch (IntrospectionException e) {\n                            throw new FacesException(e);\n                        }\n\n                        defaultValue = convertValueToTypeIfNecessary(key, defaultValue, propertyDescriptors, expressionFactory);\n                        attrs.put(key, defaultValue);\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Helper method to convert a value to a type as defined in PropertyDescriptor(s)\n     * \n     * @param name\n     * @param value\n     * @param propertyDescriptors\n     * @return value\n     */\n    private Object convertValueToTypeIfNecessary(String name, Object value, PropertyDescriptor[] propertyDescriptors, ExpressionFactory expressionFactory) {\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            if (propertyDescriptor.getName().equals(name)) {\n                value = expressionFactory.coerceToType(value, propertyDescriptor.getPropertyType());\n                break;\n            }\n        }\n\n        return value;\n    }\n    \n\n    /**\n     * <p>\n     * To enable EL Coercion to use JSF Custom converters, this method will call\n     * <code>PropertyEditorManager.registerEditor()</code>, passing the\n     * <code>ConverterPropertyEditor</code> class for the <code>targetClass</code> if the target\n     * class is not one of the standard by-type converter target classes.\n     * \n     * @param targetClass the target class for which a PropertyEditory may or may not be created\n     */\n    private void addPropertyEditorIfNecessary(Class<?> targetClass) {\n\n        if (!registerPropertyEditors) {\n            return;\n        }\n\n        PropertyEditor editor = findEditor(targetClass);\n        if (editor != null) {\n            return;\n        }\n        String className = targetClass.getName();\n\n        // Don't add a PropertyEditor for the standard by-type converters.\n        if (targetClass.isPrimitive()) {\n            return;\n        }\n\n        for (String standardClass : STANDARD_BY_TYPE_CONVERTER_CLASSES) {\n            if (standardClass.indexOf(className) != -1) {\n                return;\n            }\n        }\n\n        Class<?> editorClass = ConverterPropertyEditorFactory.getDefaultInstance().definePropertyEditorClassFor(targetClass);\n        if (editorClass != null) {\n            PropertyEditorManager.registerEditor(targetClass, editorClass);\n        } else {\n            if (LOGGER.isLoggable(WARNING)) {\n                LOGGER.warning(MessageFormat.format(\"definePropertyEditorClassFor({0}) returned null.\", targetClass.getName()));\n            }\n        }\n    }\n    \n    private Converter createConverterBasedOnClass(Class<?> targetClass, Class<?> baseClass) {\n\n        Converter returnVal = (Converter) newConverter(targetClass, converterTypeMap, baseClass);\n        if (returnVal != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n            }\n            return returnVal;\n        }\n\n        // Search for converters registered to interfaces implemented by\n        // targetClass\n        Class<?>[] interfaces = targetClass.getInterfaces();\n        if (interfaces != null) {\n            for (int i = 0; i < interfaces.length; i++) {\n                returnVal = createConverterBasedOnClass(interfaces[i], null);\n                if (returnVal != null) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                    }\n                    return returnVal;\n                }\n            }\n        }\n\n        // Search for converters registered to superclasses of targetClass\n        Class<?> superclass = targetClass.getSuperclass();\n        if (superclass != null) {\n            returnVal = createConverterBasedOnClass(superclass, targetClass);\n            if (returnVal != null) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                }\n                return returnVal;\n            }\n        }\n        return returnVal;\n    }\n    \n    /**\n     * <p>\n     * The same as newThing except that a single argument constructor that accepts a Class is looked\n     * for before calling the no-arg version.\n     * </p>\n     *\n     * <p>\n     * PRECONDITIONS: the values in the Map are either Strings representing fully qualified java\n     * class names, or java.lang.Class instances.\n     * </p>\n     * <p>\n     * ALGORITHM: Look in the argument map for a value for the argument key. If found, if the value\n     * is instanceof String, assume the String specifies a fully qualified java class name and\n     * obtain the java.lang.Class instance for that String using Util.loadClass(). Replace the\n     * String instance in the argument map with the Class instance. If the value is instanceof\n     * Class, proceed. Assert that the value is either instanceof java.lang.Class or\n     * java.lang.String.\n     * </p>\n     * <p>\n     * Now that you have a java.lang.class, call its newInstance and return it as the result of this\n     * method.\n     * </p>\n     *\n     * @param key Used to look up the value in the <code>Map</code>.\n     * @param map The <code>Map</code> that will be searched.\n     * @param targetClass the target class for the single argument ctor\n     * @return The new object instance.\n     */\n    protected Object newConverter(Class<?> key, Map<Class<?>, Object> map, Class<?> targetClass) {\n        assert key != null && map != null;\n\n        Object result = null;\n        Class<?> clazz;\n        Object value;\n\n        value = map.get(key);\n        if (value == null) {\n            return null;\n        }\n        assert value instanceof String || value instanceof Class;\n        if (value instanceof String) {\n            String cValue = (String) value;\n            try {\n                clazz = Util.loadClass(cValue, value);\n                if (!associate.isDevModeEnabled()) {\n                    map.put(key, clazz);\n                }\n                assert clazz != null;\n            } catch (Exception e) {\n                throw new FacesException(e.getMessage(), e);\n            }\n        } else {\n            clazz = (Class) value;\n        }\n\n        Constructor ctor = ReflectionUtils.lookupConstructor(clazz, Class.class);\n        Throwable cause = null;\n        if (ctor != null) {\n            try {\n                result = ctor.newInstance(targetClass);\n            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n                cause = e;\n            }\n        } else {\n            try {\n                result = clazz.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                cause = e;\n            }\n        }\n\n        if (null != cause) {\n            throw new FacesException(MessageUtils.getExceptionMessageString(MessageUtils.CANT_INSTANTIATE_CLASS_ERROR_MESSAGE_ID, clazz.getName()), cause);\n\n        }\n        return result;\n    }\n    \n\n    \n    /**\n     * Get the bean manager.\n     * \n     * @return the bean manager.\n     */\n    private BeanManager getBeanManager() {\n        if (beanManager == null) {\n            FacesContext facesContext = FacesContext.getCurrentInstance();\n            beanManager = Util.getCdiBeanManager(facesContext);\n        }\n        return beanManager;\n    }\n    \n    private Behavior createCDIBehavior(String behaviorId) {\n        if (version.isJsf23()) {\n            return CdiUtils.createBehavior(getBeanManager(), behaviorId);\n        }\n        \n        return null;\n    }\n    \n    private Converter<?> createCDIConverter(String converterId) {\n        if (version.isJsf23()) {\n            return CdiUtils.createConverter(getBeanManager(), converterId);\n        }\n        \n        return null;\n    }\n    \n    private Validator<?> createCDIValidator(String validatorId) {\n        if (version.isJsf23()) {\n            return CdiUtils.createValidator(getBeanManager(), validatorId);\n        }\n        \n        return null;\n    }\n\n}\n", "/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Stream;\n\nimport javax.faces.application.ProjectStage;\nimport javax.faces.application.ResourceHandler;\nimport javax.faces.application.ResourceVisitOption;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.Util;\n\n/**\n * This class is used to lookup {@link ResourceInfo} instances\n * and cache any that are successfully looked up to reduce the\n * computational overhead with the scanning/version checking.\n *\n * @since 2.0\n */\npublic class ResourceManager {\n\n    private static final Logger LOGGER = FacesLogger.RESOURCE.getLogger();\n\n    /**\n     * {@link Pattern} for valid mime types to configure compression.\n     */\n    private static final Pattern CONFIG_MIMETYPE_PATTERN = Pattern.compile(\"[a-z-]*/[a-z0-9.\\\\*-]*\");\n    \n    private FaceletWebappResourceHelper faceletWebappResourceHelper = new FaceletWebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up webapp-based resources.\n     */\n    private ResourceHelper webappResourceHelper = new WebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up classpath-based resources.\n     */\n    private ClasspathResourceHelper classpathResourceHelper = new ClasspathResourceHelper();\n\n    /**\n     * Cache for storing {@link ResourceInfo} instances to reduce the cost\n     * of the resource lookups.\n     */\n    private ResourceCache cache;\n\n    /**\n     * Patterns used to find {@link ResourceInfo} instances that may have their\n     * content compressed.\n     */\n    private List<Pattern> compressableTypes;\n\n    /**\n     * This lock is used to ensure the lookup of compressable {@link ResourceInfo}\n     * instances are atomic to prevent theading issues when writing the compressed\n     * content during a lookup.\n     */\n    private ReentrantLock lock = new ReentrantLock();\n\n\n    // ------------------------------------------------------------ Constructors\n\n    /*\n     * This ctor is only ever called by test code.\n     */\n\n    public ResourceManager(ResourceCache cache) {\n        this.cache = cache;\n        Map<String, Object> throwAwayMap = new HashMap<>();\n        initCompressableTypes(throwAwayMap);\n    }\n\n    /**\n     * Constructs a new <code>ResourceManager</code>.  Note:  if the current\n     * {@link ProjectStage} is {@link ProjectStage#Development} caching or\n     * {@link ResourceInfo} instances will not occur.\n     */\n    public ResourceManager(Map<String, Object> appMap, ResourceCache cache) {\n        this.cache = cache;\n        initCompressableTypes(appMap);\n    }\n\n\n    // ------------------------------------------------------ Public Methods\n\n\n    /**\n     * <p>\n     * Attempt to lookup a {@link ResourceInfo} based on the specified\n     * <code>libraryName<code> and <code>resourceName</code>\n     * </p>\n     *\n     * <p>\n     * Implementation Note:  Synchronization is necessary when looking up\n     * compressed resources.  This ensures the atomicity of the content\n     * being compressed.  As such, the cost of doing this is low as once\n     * the resource is in the cache, the lookup won't be performed again\n     * until the cache is cleared.  That said, it's not a good idea\n     * to have caching disabled in a production environment if leveraging\n     * compression.\n     *\n     * If the resource isn't compressable, then we don't worry about creating\n     * a few extra copies of ResourceInfo until the cache is populated.\n     * </p>\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param contentType the content type of the resource.  This will be\n     *  used to determine if the resource is compressable\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *  \n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, FacesContext ctx) {\n        return findResource(libraryName, resourceName, contentType, false, ctx);\n    }\n    \n    public ResourceInfo findViewResource(String resourceName, String contentType, FacesContext facesContext) {\n        String localePrefix = getLocalePrefix(facesContext);\n        List<String> contracts = getResourceLibraryContracts(facesContext);\n        \n        ResourceInfo info = getFromCache(resourceName, null, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, facesContext)) {\n                info = findResourceCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            } else {\n               info = findResourceNonCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            }\n        }\n\n        return info;\n    }\n    \n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, boolean isViewResource, FacesContext ctx) {\n        \n        String localePrefix = getLocalePrefix(ctx);\n        List<String> contracts = getResourceLibraryContracts(ctx);\n        \n        ResourceInfo info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, ctx)) {\n                info = findResourceCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            } else {\n               info = findResourceNonCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            }\n        }\n\n        return info;\n    }\n    \n    public Stream<String> getViewResources(FacesContext facesContext, String path, int maxDepth, ResourceVisitOption... options) {\n        return faceletWebappResourceHelper.getViewResources(facesContext, path, maxDepth, options);\n    }\n\n\n    // ----------------------------------------------------- Private Methods\n\n    private ResourceInfo findResourceCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        \n        ResourceInfo info = null;\n        \n        lock.lock();\n        try {\n            info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n            if (info == null) {\n                info = doLookup(libraryName, resourceName, localePrefix, true, isViewResource, contracts, ctx);\n                if (info != null) {\n                    addToCache(info, contracts);\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        \n        return info;\n    }\n    \n    private ResourceInfo findResourceNonCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        ResourceInfo info = doLookup(libraryName, resourceName, localePrefix, false, isViewResource, contracts, ctx);\n\n        if (info == null && contracts != null) {\n            info = doLookup(libraryNameFromContracts(libraryName, contracts), resourceName, localePrefix, false, isViewResource, contracts, ctx);\n        }\n        \n        if (info != null && !info.isDoNotCache()) {\n            addToCache(info, contracts);\n        }\n        \n        return info;\n    }\n    \n    private String libraryNameFromContracts(String libraryName, List<String> contracts) {\n        // If the library name is equal to one of the contracts,\n        // assume the resource to be found is within that contract\n        for (String contract : contracts) {\n            if (contract.equals(libraryName)) {\n                return null;\n            }\n        }\n        \n        return libraryName;\n    }\n    \n\n    /**\n     * Attempt to look up the Resource based on the provided details.\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param localePrefix the locale prefix for this resource (if any)\n     * @param compressable if this resource can be compressed\n     * @param isViewResource \n     * @param contracts the contracts to consider\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *\n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    private ResourceInfo doLookup(String libraryName, String resourceName, String localePrefix, boolean compressable, boolean isViewResource, List<String> contracts, FacesContext ctx) {\n        \n        // Loop over the contracts as described in deriveResourceIdConsideringLocalePrefixAndContracts in the spec\n        for (String contract : contracts) {\n            ResourceInfo info = getResourceInfo(libraryName, resourceName, localePrefix, contract, compressable, isViewResource, ctx, null);\n            if (info != null) {\n                return info;\n            }\n        }\n        \n        return getResourceInfo(libraryName, resourceName, localePrefix, null, compressable, isViewResource, ctx, null);\n    }\n\n    private ResourceInfo getResourceInfo(String libraryName, String resourceName, String localePrefix, String contract, boolean compressable, boolean isViewResource, FacesContext ctx, LibraryInfo library) {\n        if (libraryName != null && !nameContainsForbiddenSequence(libraryName)) {\n            library = findLibrary(libraryName, localePrefix, contract, ctx);\n            \n            if (library == null && localePrefix != null) {\n                // no localized library found.  Try to find a library that isn't localized.\n                library = findLibrary(libraryName, null, contract, ctx);\n            }\n            \n            if (library == null) {\n                // If we don't have one by now, perhaps it's time to consider scanning directories.\n                library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, false);\n                \n                if (library == null && localePrefix != null) {\n                    // no localized library found.  Try to find\n                    // a library that isn't localized.\n                    library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, null, contract, ctx, false);\n                }\n                \n                if (library == null) {\n                    return null;\n                }\n            }\n        } else if (nameContainsForbiddenSequence(libraryName)) {\n            return null;\n        }\n\n        String resName = trimLeadingSlash(resourceName);\n        if (nameContainsForbiddenSequence(resName) || (!isViewResource && resName.startsWith(\"WEB-INF\"))) {\n            return null;\n        }\n\n        ResourceInfo info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n        if (info == null && localePrefix != null) {\n            // no localized resource found, try to find a\n            // resource that isn't localized\n            info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n        }\n\n        // If no resource has been found so far, and we have a library that\n        // was found in the webapp filesystem, see if there is a matching\n        // library on the classpath.  If one is found, try to find a matching\n        // resource in that library.\n        if (info == null && library != null && library.getHelper() instanceof WebappResourceHelper) {\n            LibraryInfo altLibrary = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n            if (altLibrary != null) {\n                VersionInfo originalVersion = library.getVersion();\n                VersionInfo altVersion = altLibrary.getVersion();\n                if (originalVersion == null && altVersion == null) {\n                    library = altLibrary;\n                } else if (originalVersion == null && altVersion != null) {\n                    library = null;\n                } else if (originalVersion != null && altVersion == null) {\n                    library = null;\n                } else if (originalVersion.compareTo(altVersion) == 0) {\n                    library = altLibrary;\n                }\n\n            }\n\n            if (library != null) {\n                info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n                if (info == null && localePrefix != null) {\n                    // no localized resource found, try to find a\n                    // resource that isn't localized\n                    info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n                }\n            }\n        }\n        \n        return info;\n    }\n\n    /**\n     * @param s input String\n     * @return the String without a leading slash if it has one.\n     */\n    private String trimLeadingSlash(String s) {\n        if (s.charAt(0) == '/') {\n            return s.substring(1);\n        } else {\n            return s;\n        }\n    }\n    \n    private static boolean nameContainsForbiddenSequence(String name) {\n        boolean result = false;\n        if (name != null) {\n            name = name.toLowerCase();\n    \n            result = name.startsWith(\".\") ||\n                     name.contains(\"../\") ||\n                     name.contains(\"..\\\\\") ||\n                     name.startsWith(\"/\") ||\n                     name.startsWith(\"\\\\\") ||\n                     name.endsWith(\"/\") ||\n    \n                     name.contains(\"..%2f\") ||\n                     name.contains(\"..%5c\") ||\n                     name.startsWith(\"%2f\") ||\n                     name.startsWith(\"%5c\") ||\n                     name.endsWith(\"%2f\") ||\n    \n                     name.contains(\"..\\\\u002f\") ||\n                     name.contains(\"..\\\\u005c\") ||\n                     name.startsWith(\"\\\\u002f\") ||\n                     name.startsWith(\"\\\\u005c\") ||\n                     name.endsWith(\"\\\\u002f\")\n    \n                    ;\n        }\n        \n        return result;\n    }\n\n\n    /**\n     *\n     * @param name the resource name\n     * @param library the library name\n     * @param localePrefix the Locale prefix\n     * @param contracts\n     * @return the {@link ResourceInfo} from the cache or <code>null</code>\n     *  if no cached entry is found\n     */\n    private ResourceInfo getFromCache(String name, String library, String localePrefix, List<String> contracts) {\n        if (cache == null) {\n            return null;\n        }\n        \n        return cache.get(name, library, localePrefix, contracts);\n    }\n\n\n    /**\n     * Adds the the specified {@link ResourceInfo} to the cache.\n     * @param info the @{link ResourceInfo} to add.\n     * @param contracts the contracts\n     */\n    private void addToCache(ResourceInfo info, List<String> contracts) {\n        if (cache == null) {\n            return;\n        }\n        \n        cache.add(info, contracts);\n    }\n\n    /**\n     * <p> Attempt to lookup and return a {@link LibraryInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application *within the resources directory*.  \n     * If the library is not found, then it processed to\n     * searching the classpath, if not found there, search from the webapp root\n     * *excluding* the resources directory.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     *\n     * @param libraryName the library to find\n     * @param localePrefix the prefix for the desired locale\n     * @param contract the contract to use\n     *@param ctx         the {@link javax.faces.context.FacesContext} for the current request\n     *  @return the Library instance for the specified library\n     */\n     LibraryInfo findLibrary(String libraryName, String localePrefix, String contract, FacesContext ctx) {\n\n        LibraryInfo library = webappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        \n        if (library == null) {\n            library = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n        \n        if (library == null && contract == null) {\n            // FCAPUTO facelets in contracts should have been found by the webapphelper already\n            library = faceletWebappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n\n        // if not library is found at this point, let the caller deal with it\n        return library;\n    }\n\n     LibraryInfo findLibraryOnClasspathWithZipDirectoryEntryScan(String libraryName,\n                                                                 String localePrefix,\n                                                                 String contract, FacesContext ctx, boolean forceScan) {\n         return classpathResourceHelper.findLibraryWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, forceScan);\n     }\n\n   /**\n     * <p> Attempt to lookup and return a {@link ResourceInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application.  If the library is not found, then it processed to\n     * searching the classpath.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     * @param library the library the resource should be found in\n     * @param resourceName the name of the resource\n     * @param localePrefix the prefix for the desired locale\n     * @param compressable <code>true</code> if the resource can be compressed\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current request\n     *\n     * @return the Library instance for the specified library\n     */\n    private ResourceInfo findResource(LibraryInfo library,\n                                      String resourceName,\n                                      String localePrefix,\n                                      boolean compressable,\n                                      boolean skipToFaceletResourceHelper,\n                                      FacesContext ctx) {\n\n        if (library != null) {\n            return library.getHelper().findResource(library,\n                                                    resourceName,\n                                                    localePrefix,\n                                                    compressable,\n                                                    ctx);\n        } else {\n            ResourceInfo resource = null;\n            \n            if (!skipToFaceletResourceHelper) {\n                resource = webappResourceHelper.findResource(null,\n                        resourceName,\n                        localePrefix,\n                        compressable,\n                        ctx);\n            }\n            if (resource == null && !skipToFaceletResourceHelper) {\n                resource = classpathResourceHelper.findResource(null,\n                                                        resourceName,\n                                                        localePrefix,\n                                                        compressable, \n                                                        ctx);\n            }\n            if (resource == null) {\n                resource = faceletWebappResourceHelper.findResource(library, \n                    resourceName, \n                    localePrefix, \n                    compressable, \n                    ctx);\n            }\n            return resource;\n        }\n\n    }\n    \n    ResourceInfo findResource(String resourceId) {\n        // PENDING(fcaputo) do we need to handle contracts here?\n        String libraryName = null;\n        String resourceName = null;\n        int end = 0, start = 0;\n        if (-1 != (end = resourceId.lastIndexOf(\"/\"))) {\n            resourceName = resourceId.substring(end+1);\n            if (-1 != (start = resourceId.lastIndexOf(\"/\", end - 1))) {\n                libraryName = resourceId.substring(start+1, end);\n            } else {\n                libraryName = resourceId.substring(0, end);\n            }\n        }\n        FacesContext context = FacesContext.getCurrentInstance();\n        LibraryInfo info = this.findLibrary(libraryName, null, null, context);\n        ResourceInfo resourceInfo = this.findResource(info, resourceName, libraryName, true, false, context);\n        \n        return resourceInfo;\n    }\n\n\n    /**\n     * <p>\n     * Obtains the application configured message resources for the current\n     * request locale.  If a ResourceBundle is found and contains the key\n     * <code>javax.faces.resource.localePrefix</code>, use the value associated\n     * with that key as the prefix for locale specific resources.\n     * </p>\n     *\n     * <p>\n     * For example, say the request locale is en_US, and\n     * <code>javax.faces.resourceLocalePrefix</code> is found with a value of\n     * <code>en</code>, a resource path within a web application might look like\n     * <code>/resources/en/corp/images/greetings.jpg</code>\n     * </p>\n     *\n     * @param context the {@link FacesContext} for the current request\n     * @return the localePrefix based on the current request, or <code>null</code>\n     *  if no prefix can be determined\n     */\n    private String getLocalePrefix(FacesContext context) {\n\n        String localePrefix = null;\n        \n        localePrefix = context.getExternalContext().getRequestParameterMap().get(\"loc\");\n        \n        if(localePrefix != null){\n            return localePrefix;\n        }\n        \n        String appBundleName = context.getApplication().getMessageBundle();\n        if (null != appBundleName) {\n        \t\n            Locale locale = null;\n            if (context.getViewRoot() != null) {\n                locale = context.getViewRoot().getLocale();\n            } else {\n                locale = context.getApplication().getViewHandler().calculateLocale(context);\n            }\n            \n                try {\n                    ResourceBundle appBundle =\n                          ResourceBundle.getBundle(appBundleName,\n                                                   locale,\n                                                   Util.getCurrentLoader(ResourceManager.class));\n                    localePrefix =\n                          appBundle\n                                .getString(ResourceHandler.LOCALE_PREFIX);\n                } catch (MissingResourceException mre) { \n                    if (LOGGER.isLoggable(Level.FINEST)) {\n                        LOGGER.log(Level.FINEST, \"Ignoring missing resource\", mre);\n                    }\n                }\n        }\n        return localePrefix;\n\n    }\n\n    private List<String> getResourceLibraryContracts(FacesContext context) {\n        UIViewRoot viewRoot = context.getViewRoot();\n        if(viewRoot == null) {\n\n            if(context.getApplication().getResourceHandler().isResourceRequest(context)) {\n                // it is a resource request. look at the parameter con=.\n\n                String param = context.getExternalContext().getRequestParameterMap().get(\"con\");\n                if(!nameContainsForbiddenSequence(param) && param != null && param.trim().length() > 0) {\n                    return Arrays.asList(param);\n                }\n            }\n            // PENDING(edburns): calculate the contracts!\n            return Collections.emptyList();\n        }\n        return context.getResourceLibraryContracts();\n    }\n\n\n    /**\n     * @param contentType content-type in question\n     * @param ctx the @{link FacesContext} for the current request\n     * @return <code>true</code> if this resource can be compressed, otherwise\n     *  <code>false</code>\n     */\n    private boolean isCompressable(String contentType, FacesContext ctx) {\n\n        // No compression when developing.\n        if (contentType == null || ctx.isProjectStage(ProjectStage.Development)) {\n            return false;\n        } else {\n            if (compressableTypes != null && !compressableTypes.isEmpty()) {\n                for (Pattern p : compressableTypes) {\n                    boolean matches = p.matcher(contentType).matches();\n                    if (matches) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n\n    }\n\n\n    /**\n     * Init <code>compressableTypes</code> from the configuration.\n     */\n    private void initCompressableTypes(Map<String, Object> appMap) {\n\n        WebConfiguration config = WebConfiguration.getInstance();\n        String value = config.getOptionValue(WebConfiguration.WebContextInitParameter.CompressableMimeTypes);\n        if (value != null && value.length() > 0) {\n            String[] values = Util.split(appMap, value, \",\");\n            if (values != null) {\n                for (String s : values) {\n                    String pattern = s.trim();\n                    if (!isPatternValid(pattern)) {\n                        continue;\n                    }\n                    if (pattern.endsWith(\"/*\")) {\n                        pattern = pattern.substring(0, pattern.indexOf(\"/*\"));\n                        pattern += \"/[a-z0-9.-]*\";\n                    }\n                    if (compressableTypes == null) {\n                        compressableTypes = new ArrayList<>(values.length);\n                    }\n                    try {\n                        compressableTypes.add(Pattern.compile(pattern));\n                    } catch (PatternSyntaxException pse) {\n                        if (LOGGER.isLoggable(Level.WARNING)) {\n                            // PENDING i18n\n                            LOGGER.log(Level.WARNING,\n                                       \"jsf.resource.mime.type.configration.invalid\",\n                                       new Object[] { pattern, pse.getPattern()});\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * @param input input mime-type pattern from the configuration\n     * @return <code>true</code> if the input matches the expected pattern,\n     *  otherwise <code>false</code>\n     */\n    private boolean isPatternValid(String input) {\n\n        return (CONFIG_MIMETYPE_PATTERN.matcher(input).matches());\n\n    }\n\n\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.applicationimpl;\n\nimport static com.sun.faces.application.ApplicationImpl.THIS_LIBRARY;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.DateTimeConverterUsesSystemTimezone;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.RegisterConverterPropertyEditors;\nimport static com.sun.faces.util.Util.isEmpty;\nimport static com.sun.faces.util.Util.loadClass;\nimport static com.sun.faces.util.Util.notNull;\nimport static com.sun.faces.util.Util.notNullNamedObject;\nimport static java.beans.Introspector.getBeanInfo;\nimport static java.beans.PropertyEditorManager.findEditor;\nimport static java.text.MessageFormat.format;\nimport static java.util.Collections.unmodifiableMap;\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.SEVERE;\nimport static java.util.logging.Level.WARNING;\nimport static javax.faces.application.Resource.COMPONENT_RESOURCE_KEY;\nimport static javax.faces.component.UIComponent.ATTRS_WITH_DECLARED_DEFAULT_VALUES;\nimport static javax.faces.component.UIComponent.BEANINFO_KEY;\nimport static javax.faces.component.UIComponent.COMPOSITE_COMPONENT_TYPE_KEY;\n\nimport java.beans.BeanDescriptor;\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.PropertyDescriptor;\nimport java.beans.PropertyEditor;\nimport java.beans.PropertyEditorManager;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.text.MessageFormat;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.el.ExpressionFactory;\nimport javax.el.ValueExpression;\nimport javax.enterprise.inject.spi.BeanManager;\nimport javax.faces.FacesException;\nimport javax.faces.application.Application;\nimport javax.faces.application.Resource;\nimport javax.faces.component.UIComponent;\nimport javax.faces.component.behavior.Behavior;\nimport javax.faces.context.FacesContext;\nimport javax.faces.convert.Converter;\nimport javax.faces.convert.DateTimeConverter;\nimport javax.faces.el.ValueBinding;\nimport javax.faces.render.RenderKit;\nimport javax.faces.render.Renderer;\nimport javax.faces.validator.Validator;\nimport javax.faces.view.ViewDeclarationLanguage;\n\nimport com.sun.faces.application.ApplicationAssociate;\nimport com.sun.faces.application.ConverterPropertyEditorFactory;\nimport com.sun.faces.application.ViewMemberInstanceFactoryMetadataMap;\nimport com.sun.faces.cdi.CdiUtils;\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.MessageUtils;\nimport com.sun.faces.util.ReflectionUtils;\nimport com.sun.faces.util.Util;\n\npublic class InstanceFactory {\n    \n    // Log instance for this class\n    private static final Logger LOGGER = FacesLogger.APPLICATION.getLogger();\n    \n    private static final String CONTEXT = \"context\";\n    private static final String COMPONENT_EXPRESSION = \"componentExpression\";\n    private static final String COMPONENT_TYPE = \"componentType\";\n    private static final String COMPONENT_CLASS = \"componentClass\";\n    \n    private static final Map<String, Class<?>[]> STANDARD_CONV_ID_TO_TYPE_MAP = new HashMap<>(8, 1.0f);\n    private static final Map<Class<?>, String> STANDARD_TYPE_TO_CONV_ID_MAP = new HashMap<>(16, 1.0f);\n\n    static {\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Byte\", new Class[] { Byte.TYPE, Byte.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Boolean\", new Class[] { Boolean.TYPE, Boolean.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Character\", new Class[] { Character.TYPE, Character.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Short\", new Class[] { Short.TYPE, Short.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Integer\", new Class[] { Integer.TYPE, Integer.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Long\", new Class[] { Long.TYPE, Long.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Float\", new Class[] { Float.TYPE, Float.class });\n        STANDARD_CONV_ID_TO_TYPE_MAP.put(\"javax.faces.Double\", new Class[] { Double.TYPE, Double.class });\n        for (Map.Entry<String, Class<?>[]> entry : STANDARD_CONV_ID_TO_TYPE_MAP.entrySet()) {\n            Class<?>[] types = entry.getValue();\n            String key = entry.getKey();\n            for (Class<?> clazz : types) {\n                STANDARD_TYPE_TO_CONV_ID_MAP.put(clazz, key);\n            }\n        }\n    }\n    \n    private final String[] STANDARD_BY_TYPE_CONVERTER_CLASSES = { \"java.math.BigDecimal\", \"java.lang.Boolean\", \"java.lang.Byte\", \"java.lang.Character\",\n            \"java.lang.Double\", \"java.lang.Float\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Short\", \"java.lang.Enum\" };\n\n    private Map<Class<?>, Object> converterTypeMap;\n    private boolean registerPropertyEditors;\n    private boolean passDefaultTimeZone;\n    \n    private TimeZone systemTimeZone;\n    \n    private static final class ComponentResourceClassNotFound{}\n    \n    //\n    // These four maps store store \"identifier\" | \"class name\"\n    // mappings.\n    //\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> componentMap;\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> behaviorMap;\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> converterIdMap;\n    private ViewMemberInstanceFactoryMetadataMap<String, Object> validatorMap;\n    \n    private Set<String> defaultValidatorIds;\n    private volatile Map<String, String> defaultValidatorInfo;\n    \n    private final ApplicationAssociate associate;\n    private Version version;\n    \n    /**\n     * Stores the bean manager.\n     */\n    private BeanManager beanManager;\n    \n    public InstanceFactory(ApplicationAssociate applicationAssociate) {\n        this.associate = applicationAssociate;\n        version = new Version();\n        \n        componentMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        converterIdMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        converterTypeMap = new ConcurrentHashMap<>();\n        validatorMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        defaultValidatorIds = new LinkedHashSet<>();\n        behaviorMap = new ViewMemberInstanceFactoryMetadataMap<>(new ConcurrentHashMap<>());\n        \n        WebConfiguration webConfig = WebConfiguration.getInstance(FacesContext.getCurrentInstance().getExternalContext());\n        registerPropertyEditors = webConfig.isOptionEnabled(RegisterConverterPropertyEditors);\n        \n        passDefaultTimeZone = webConfig.isOptionEnabled(DateTimeConverterUsesSystemTimezone);\n        if (passDefaultTimeZone) {\n            systemTimeZone = TimeZone.getDefault();\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addComponent(java.lang.String, java.lang.String)\n     */\n    public void addComponent(String componentType, String componentClass) {\n\n        notNull(COMPONENT_TYPE, componentType);\n        notNull(COMPONENT_CLASS, componentClass);\n\n        if (LOGGER.isLoggable(FINE) && componentMap.containsKey(componentType)) {\n            LOGGER.log(FINE, \"componentType {0} has already been registered.  Replacing existing component class type {1} with {2}.\",\n                    new Object[] { componentType, componentMap.get(componentType), componentClass });\n        }\n\n        componentMap.put(componentType, componentClass);\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"added component of type ''{0}'' and class ''{1}''\", componentType, componentClass));\n        }\n    }\n    \n    public UIComponent createComponent(ValueExpression componentExpression, FacesContext context, String componentType) throws FacesException {\n\n        notNull(COMPONENT_EXPRESSION, componentExpression);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(context, componentExpression, componentType, null, true);\n    }\n    \n    public UIComponent createComponent(String componentType) throws FacesException {\n\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(FacesContext.getCurrentInstance(), componentType, null, true);\n    }\n    \n    public UIComponent createComponent(FacesContext context, Resource componentResource, ExpressionFactory expressionFactory) throws FacesException {\n\n        // RELEASE_PENDING (rlubke,driscoll) this method needs review.\n\n        notNull(CONTEXT, context);\n        notNull(\"componentResource\", componentResource);\n\n        UIComponent result = null;\n\n        // Use the application defined in the FacesContext as we may be calling\n        // overriden methods\n        Application app = context.getApplication();\n\n        ViewDeclarationLanguage vdl = app.getViewHandler().getViewDeclarationLanguage(context, context.getViewRoot().getViewId());\n        BeanInfo componentMetadata = vdl.getComponentMetadata(context, componentResource);\n\n        if (componentMetadata != null) {\n            BeanDescriptor componentBeanDescriptor = componentMetadata.getBeanDescriptor();\n\n            // Step 1. See if the composite component author explicitly\n            // gave a componentType as part of the composite component metadata\n            ValueExpression valueExpression = (ValueExpression) componentBeanDescriptor.getValue(COMPOSITE_COMPONENT_TYPE_KEY);\n\n            if (valueExpression != null) {\n                String componentType = (String) valueExpression.getValue(context.getELContext());\n                if (!isEmpty(componentType)) {\n                    result = app.createComponent(componentType);\n                }\n            }\n        }\n\n        // Step 2. If that didn't work, if a script based resource can be\n        // found for the scriptComponentResource, see if a component can be generated from it\n        if (result == null) {\n            Resource scriptComponentResource = vdl.getScriptComponentResource(context, componentResource);\n\n            if (scriptComponentResource != null) {\n                result = createComponentFromScriptResource(context, scriptComponentResource, componentResource);\n            }\n        }\n\n        // Step 3. Use the libraryName of the resource as the java package\n        // and use the resourceName as the class name. See\n        // if a Java class can be loaded\n        if (result == null) {\n            String packageName = componentResource.getLibraryName();\n            String className = componentResource.getResourceName();\n            className = packageName + '.' + className.substring(0, className.lastIndexOf('.'));\n            try {\n                Class<?> clazz = (Class<?>) componentMap.get(className);\n                if (clazz == null) {\n                    clazz = loadClass(className, this);\n                }\n                if (clazz != ComponentResourceClassNotFound.class) {\n                    if (!associate.isDevModeEnabled()) {\n                        componentMap.put(className, clazz);\n                    }\n                    result = (UIComponent) clazz.newInstance();\n                }\n            } catch (ClassNotFoundException ex) {\n                if (!associate.isDevModeEnabled()) {\n                    componentMap.put(className, ComponentResourceClassNotFound.class);\n                }\n            } catch (InstantiationException | IllegalAccessException | ClassCastException ie) {\n                throw new FacesException(ie);\n            }\n        }\n\n        // Step 4. Use javax.faces.NamingContainer as the component type\n        if (result == null) {\n            result = app.createComponent(\"javax.faces.NamingContainer\");\n        }\n\n        result.setRendererType(\"javax.faces.Composite\");\n\n        Map<String, Object> attrs = result.getAttributes();\n        attrs.put(COMPONENT_RESOURCE_KEY, componentResource);\n        attrs.put(BEANINFO_KEY, componentMetadata);\n\n        associate.getAnnotationManager().applyComponentAnnotations(context, result);\n        pushDeclaredDefaultValuesToAttributesMap(context, componentMetadata, attrs, result, expressionFactory);\n\n        return result;\n    }\n    \n    public UIComponent createComponent(FacesContext context, String componentType, String rendererType) {\n        \n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n        \n        return createComponentApplyAnnotations(context, componentType, rendererType, true);\n    }\n    \n    public UIComponent createComponent(ValueExpression componentExpression, FacesContext context, String componentType, String rendererType) {\n\n        notNull(COMPONENT_EXPRESSION, componentExpression);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        return createComponentApplyAnnotations(context, componentExpression, componentType, rendererType, true);\n    }\n    \n    public UIComponent createComponent(ValueBinding componentBinding, FacesContext context, String componentType) throws FacesException {\n\n        notNull(\"componentBinding\", componentBinding);\n        notNull(CONTEXT, context);\n        notNull(COMPONENT_TYPE, componentType);\n\n        Object result;\n        boolean createOne = false;\n        try {\n            result = componentBinding.getValue(context);\n            if (result != null) {\n                createOne = !(result instanceof UIComponent);\n            }\n\n            if (result == null || createOne) {\n                result = createComponentApplyAnnotations(context, componentType, null, false);\n                componentBinding.setValue(context, result);\n            }\n        } catch (Exception ex) {\n            throw new FacesException(ex);\n        }\n\n        return (UIComponent) result;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getComponentTypes()\n     */\n    public Iterator<String> getComponentTypes() {\n        return componentMap.keySet().iterator();\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addBehavior(String, String)\n     */\n    public void addBehavior(String behaviorId, String behaviorClass) {\n\n        notNull(\"behaviorId\", behaviorId);\n        notNull(\"behaviorClass\", behaviorClass);\n\n        if (LOGGER.isLoggable(FINE) && behaviorMap.containsKey(behaviorId)) {\n            LOGGER.log(FINE, \"behaviorId {0} has already been registered.  Replacing existing behavior class type {1} with {2}.\",\n                    new Object[] { behaviorId, behaviorMap.get(behaviorId), behaviorClass });\n        }\n\n        behaviorMap.put(behaviorId, behaviorClass);\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"added behavior of type ''{0}'' class ''{1}''\", behaviorId, behaviorClass));\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createBehavior(String)\n     */\n    public Behavior createBehavior(String behaviorId) throws FacesException {\n\n        notNull(\"behaviorId\", behaviorId);\n\n        Behavior behavior = createCDIBehavior(behaviorId);\n        if (behavior != null) {\n            return behavior;\n        }\n\n        behavior = newThing(behaviorId, behaviorMap);\n        \n        notNullNamedObject(behavior, behaviorId, \"jsf.cannot_instantiate_behavior_error\");\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"created behavior of type ''{0}''\", behaviorId));\n        }\n\n        associate.getAnnotationManager().applyBehaviorAnnotations(FacesContext.getCurrentInstance(), behavior);\n\n        return behavior;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getBehaviorIds()\n     */\n    public Iterator<String> getBehaviorIds() {\n        return behaviorMap.keySet().iterator();\n    }\n    \n    public void addConverter(String converterId, String converterClass) {\n\n        notNull(\"converterId\", converterId);\n        notNull(\"converterClass\", converterClass);\n\n        if (LOGGER.isLoggable(FINE) && converterIdMap.containsKey(converterId)) {\n            LOGGER.log(FINE, \"converterId {0} has already been registered.  Replacing existing converter class type {1} with {2}.\",\n                    new Object[] { converterId, converterIdMap.get(converterId), converterClass });\n        }\n\n        converterIdMap.put(converterId, converterClass);\n\n        Class<?>[] types = STANDARD_CONV_ID_TO_TYPE_MAP.get(converterId);\n        if (types != null) {\n            for (Class<?> clazz : types) {\n                // go directly against map to prevent cyclic method calls\n                converterTypeMap.put(clazz, converterClass);\n                addPropertyEditorIfNecessary(clazz);\n            }\n        }\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(format(\"added converter of type ''{0}'' and class ''{1}''\", converterId, converterClass));\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addConverter(Class, String)\n     */\n    public void addConverter(Class<?> targetClass, String converterClass) {\n\n        notNull(\"targetClass\", targetClass);\n        notNull(\"converterClass\", converterClass);\n\n        String converterId = STANDARD_TYPE_TO_CONV_ID_MAP.get(targetClass);\n        if (converterId != null) {\n            addConverter(converterId, converterClass);\n        } else {\n            if (LOGGER.isLoggable(FINE) && converterTypeMap.containsKey(targetClass)) {\n                LOGGER.log(FINE, \"converter target class {0} has already been registered.  Replacing existing converter class type {1} with {2}.\",\n                        new Object[] { targetClass.getName(), converterTypeMap.get(targetClass), converterClass });\n            }\n\n            converterTypeMap.put(targetClass, converterClass);\n            addPropertyEditorIfNecessary(targetClass);\n        }\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(format(\"added converter of class type ''{0}''\", converterClass));\n        }\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createConverter(String)\n     */\n    public Converter<?> createConverter(String converterId) {\n\n        notNull(\"converterId\", converterId);\n        \n        Converter<?> converter = createCDIConverter(converterId);\n        if (converter != null) {\n            return converter;\n        }\n\n        converter = newThing(converterId, converterIdMap);\n        \n        notNullNamedObject(converter, converterId, \"jsf.cannot_instantiate_converter_error\");\n        \n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"created converter of type ''{0}''\", converterId));\n        }\n        \n        if (passDefaultTimeZone && converter instanceof DateTimeConverter) {\n            ((DateTimeConverter) converter).setTimeZone(systemTimeZone);\n        }\n        \n        associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), converter);\n        \n        return converter;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createConverter(Class)\n     */\n    public Converter createConverter(Class<?> targetClass) {\n\n        Util.notNull(\"targetClass\", targetClass);\n        Converter returnVal = null;\n\n        if (version.isJsf23()) {\n            BeanManager beanManager = getBeanManager();\n            returnVal = CdiUtils.createConverter(beanManager, targetClass);\n            if (returnVal != null) {\n                return returnVal;\n            }\n        }\n\n        returnVal = (Converter) newConverter(targetClass, converterTypeMap, targetClass);\n        if (returnVal != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n            }\n            if (passDefaultTimeZone && returnVal instanceof DateTimeConverter) {\n                ((DateTimeConverter) returnVal).setTimeZone(systemTimeZone);\n            }\n            associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), returnVal);\n            return returnVal;\n        }\n\n        // Search for converters registered to interfaces implemented by\n        // targetClass\n        Class<?>[] interfaces = targetClass.getInterfaces();\n        if (interfaces != null) {\n            for (int i = 0; i < interfaces.length; i++) {\n                returnVal = createConverterBasedOnClass(interfaces[i], targetClass);\n                if (returnVal != null) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                    }\n                    if (passDefaultTimeZone && returnVal instanceof DateTimeConverter) {\n                        ((DateTimeConverter) returnVal).setTimeZone(systemTimeZone);\n                    }\n                    associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), returnVal);\n                    return returnVal;\n                }\n            }\n        }\n\n        // Search for converters registered to superclasses of targetClass\n        Class<?> superclass = targetClass.getSuperclass();\n        if (superclass != null) {\n            returnVal = createConverterBasedOnClass(superclass, targetClass);\n            if (returnVal != null) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                }\n                if (passDefaultTimeZone && returnVal instanceof DateTimeConverter) {\n                    ((DateTimeConverter) returnVal).setTimeZone(systemTimeZone);\n                }\n                associate.getAnnotationManager().applyConverterAnnotations(FacesContext.getCurrentInstance(), returnVal);\n                return returnVal;\n            }\n        }\n\n        return returnVal;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getConverterIds()\n     */\n    public Iterator<String> getConverterIds() {\n        return converterIdMap.keySet().iterator();\n\n    }\n\n    /**\n     * @see javax.faces.application.Application#getConverterTypes()\n     */\n    public Iterator<Class<?>> getConverterTypes() {\n        return converterTypeMap.keySet().iterator();\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addValidator(String, String)\n     */\n    public void addValidator(String validatorId, String validatorClass) {\n\n        Util.notNull(\"validatorId\", validatorId);\n        Util.notNull(\"validatorClass\", validatorClass);\n\n        if (LOGGER.isLoggable(Level.FINE) && validatorMap.containsKey(validatorId)) {\n            LOGGER.log(Level.FINE, \"validatorId {0} has already been registered.  Replacing existing validator class type {1} with {2}.\",\n                    new Object[] { validatorId, validatorMap.get(validatorId), validatorClass });\n        }\n\n        validatorMap.put(validatorId, validatorClass);\n\n        if (LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.fine(MessageFormat.format(\"added validator of type ''{0}'' class ''{1}''\", validatorId, validatorClass));\n        }\n\n    }\n    \n    /**\n     * @see javax.faces.application.Application#createValidator(String)\n     */\n    public Validator<?> createValidator(String validatorId) throws FacesException {\n\n        notNull(\"validatorId\", validatorId);\n\n        Validator<?> validator = createCDIValidator(validatorId);\n        if (validator != null) {\n            return validator;\n        }\n\n        validator = newThing(validatorId, validatorMap);\n        \n        notNullNamedObject(validator, validatorId, \"jsf.cannot_instantiate_validator_error\");\n        \n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.fine(MessageFormat.format(\"created validator of type ''{0}''\", validatorId));\n        }\n        \n        associate.getAnnotationManager().applyValidatorAnnotations(FacesContext.getCurrentInstance(), validator);\n        \n        return validator;\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getValidatorIds()\n     */\n    public Iterator<String> getValidatorIds() {\n        return validatorMap.keySet().iterator();\n    }\n    \n    /**\n     * @see javax.faces.application.Application#addDefaultValidatorId(String)\n     */\n    public synchronized void addDefaultValidatorId(String validatorId) {\n\n        notNull(\"validatorId\", validatorId);\n        \n        defaultValidatorInfo = null;\n        defaultValidatorIds.add(validatorId);\n    }\n    \n    /**\n     * @see javax.faces.application.Application#getDefaultValidatorInfo()\n     */\n    public Map<String, String> getDefaultValidatorInfo() {\n\n        if (defaultValidatorInfo == null) {\n            synchronized (this) {\n                if (defaultValidatorInfo == null) {\n                    defaultValidatorInfo = new LinkedHashMap<>();\n                    if (!defaultValidatorIds.isEmpty()) {\n                        for (String id : defaultValidatorIds) {\n                            String validatorClass;\n                            Object result = validatorMap.get(id);\n                            if (null != result) {\n                                if (result instanceof Class) {\n                                    validatorClass = ((Class) result).getName();\n                                } else {\n                                    validatorClass = result.toString();\n                                }\n                                defaultValidatorInfo.put(id, validatorClass);\n                            }\n                        }\n\n                    }\n                }\n            }\n            defaultValidatorInfo = unmodifiableMap(defaultValidatorInfo);\n        }\n\n        return defaultValidatorInfo;\n\n    }\n    \n    \n    \n    \n   \n    // --------------------------------------------------------- Private Methods\n    \n\n    private UIComponent createComponentFromScriptResource(FacesContext context, Resource scriptComponentResource, Resource componentResource) {\n\n        UIComponent result = null;\n\n        String className = scriptComponentResource.getResourceName();\n        int lastDot = className.lastIndexOf('.');\n        className = className.substring(0, lastDot);\n\n        try {\n\n            Class<?> componentClass = (Class<?>) componentMap.get(className);\n            if (componentClass == null) {\n                componentClass = Util.loadClass(className, this);\n            }\n            if (!associate.isDevModeEnabled()) {\n                componentMap.put(className, componentClass);\n            }\n            result = (UIComponent) componentClass.newInstance();\n        } catch (IllegalAccessException | InstantiationException | ClassNotFoundException ex) {\n            if (LOGGER.isLoggable(Level.SEVERE)) {\n                LOGGER.log(Level.SEVERE, null, ex);\n            }\n        }\n\n        if (result != null) {\n            // Make sure the resource is there for the annotation processor.\n            result.getAttributes().put(Resource.COMPONENT_RESOURCE_KEY, componentResource);\n            // In case there are any \"this\" references,\n            // make sure they can be resolved.\n            context.getAttributes().put(THIS_LIBRARY, componentResource.getLibraryName());\n            try {\n                associate.getAnnotationManager().applyComponentAnnotations(context, result);\n            } finally {\n                context.getAttributes().remove(THIS_LIBRARY);\n            }\n        }\n\n        return result;\n\n    }\n    \n    /**\n     * Leveraged by\n     * {@link Application#createComponent(javax.el.ValueExpression, javax.faces.context.FacesContext, String)}\n     * and\n     * {@link Application#createComponent(javax.el.ValueExpression, javax.faces.context.FacesContext, String, String)}.\n     * This method will apply any component and render annotations that may be present.\n     */\n    private UIComponent createComponentApplyAnnotations(FacesContext ctx, ValueExpression componentExpression, String componentType, String rendererType,\n            boolean applyAnnotations) {\n\n        UIComponent c;\n\n        try {\n            c = (UIComponent) componentExpression.getValue(ctx.getELContext());\n\n            if (c == null) {\n                c = this.createComponentApplyAnnotations(ctx, componentType, rendererType, applyAnnotations);\n                componentExpression.setValue(ctx.getELContext(), c);\n            } else if (applyAnnotations) {\n                this.applyAnnotations(ctx, rendererType, c);\n            }\n        } catch (Exception ex) {\n            throw new FacesException(ex);\n        }\n\n        return c;\n\n    }\n    \n    /**\n     * Leveraged by {@link Application#createComponent(String)} and\n     * {@link Application#createComponent(javax.faces.context.FacesContext, String, String)} This\n     * method will apply any component and render annotations that may be present.\n     */\n    private UIComponent createComponentApplyAnnotations(FacesContext ctx, String componentType, String rendererType, boolean applyAnnotations) {\n\n        UIComponent component;\n        try {\n            component = newThing(componentType, componentMap);\n        } catch (Exception ex) {\n            if (LOGGER.isLoggable(SEVERE)) {\n                LOGGER.log(Level.SEVERE, \"jsf.cannot_instantiate_component_error\", componentType);\n            }\n            throw new FacesException(ex);\n        }\n        \n        notNullNamedObject(component, componentType, \"jsf.cannot_instantiate_component_error\");\n\n        if (LOGGER.isLoggable(FINE)) {\n            LOGGER.log(FINE, MessageFormat.format(\"Created component with component type of ''{0}''\", componentType));\n        }\n\n        if (applyAnnotations) {\n            applyAnnotations(ctx, rendererType, component);\n        }\n        \n        return component;\n    }\n    \n    \n    /**\n     * Process any annotations associated with this component/renderer.\n     */\n    private void applyAnnotations(FacesContext ctx, String rendererType, UIComponent c) {\n\n        if (c != null && ctx != null) {\n            associate.getAnnotationManager().applyComponentAnnotations(ctx, c);\n            if (rendererType != null) {\n                RenderKit rk = ctx.getRenderKit();\n                Renderer r = null;\n                if (rk != null) {\n                    r = rk.getRenderer(c.getFamily(), rendererType);\n                    if (r != null) {\n                        c.setRendererType(rendererType);\n                        associate.getAnnotationManager().applyRendererAnnotations(ctx, r, c);\n                    }\n                }\n                if ((rk == null || r == null) && LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Unable to create Renderer with rendererType {0} for component with component type of {1}\",\n                            new Object[] { rendererType, c.getFamily() });\n                }\n            }\n        }\n    }\n\n    /**\n     * <p>\n     * PRECONDITIONS: the values in the Map are either Strings representing fully qualified java\n     * class names, or java.lang.Class instances.\n     * </p>\n     * <p>\n     * ALGORITHM: Look in the argument map for a value for the argument key. If found, if the value\n     * is instanceof String, assume the String specifies a fully qualified java class name and\n     * obtain the java.lang.Class instance for that String using Util.loadClass(). Replace the\n     * String instance in the argument map with the Class instance. If the value is instanceof\n     * Class, proceed. Assert that the value is either instanceof java.lang.Class or\n     * java.lang.String.\n     * </p>\n     * <p>\n     * Now that you have a java.lang.class, call its newInstance and return it as the result of this\n     * method.\n     * </p>\n     *\n     * @param key Used to look up the value in the <code>Map</code>.\n     * @param map The <code>Map</code> that will be searched.\n     * @return The new object instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private <T> T newThing(String key, ViewMemberInstanceFactoryMetadataMap<String, Object> map) {\n\n        Object result;\n        Class<?> clazz;\n        Object value;\n\n        value = map.get(key);\n        if (value == null) {\n            return null;\n        }\n        assert value instanceof String || value instanceof Class;\n        if (value instanceof String) {\n            String cValue = (String) value;\n            try {\n                clazz = Util.loadClass(cValue, value);\n                if (!associate.isDevModeEnabled()) {\n                    map.put(key, clazz);\n                }\n                assert clazz != null;\n            } catch (Exception e) {\n                throw new FacesException(e.getMessage(), e);\n            }\n        } else {\n            clazz = (Class) value;\n        }\n\n        try {\n            result = clazz.newInstance();\n        } catch (Throwable t) {\n            Throwable previousT;\n            do {\n                previousT = t;\n                if (LOGGER.isLoggable(Level.SEVERE)) {\n                    LOGGER.log(Level.SEVERE, \"Unable to load class: \", t);\n                }\n            } while (null != (t = t.getCause()));\n            t = previousT;\n\n            throw new FacesException(MessageUtils.getExceptionMessageString(MessageUtils.CANT_INSTANTIATE_CLASS_ERROR_MESSAGE_ID, clazz.getName()), t);\n        }\n\n        return (T) result;\n    }\n    \n    /*\n     * This method makes it so that any cc:attribute elements that have a \"default\" attribute value\n     * have those values pushed into the composite component attribute map so that programmatic\n     * access (as opposed to EL access) will find the attribute values.\n     *\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void pushDeclaredDefaultValuesToAttributesMap(FacesContext context, BeanInfo componentMetadata, Map<String, Object> attrs, UIComponent component, ExpressionFactory expressionFactory) {\n\n        Collection<String> attributesWithDeclaredDefaultValues = null;\n        PropertyDescriptor[] propertyDescriptors = null;\n\n        for (PropertyDescriptor propertyDescriptor : componentMetadata.getPropertyDescriptors()) {\n            Object defaultValue = propertyDescriptor.getValue(\"default\");\n\n            if (defaultValue != null) {\n                String key = propertyDescriptor.getName();\n                boolean isLiteralText = false;\n\n                if (defaultValue instanceof ValueExpression) {\n                    isLiteralText = ((ValueExpression) defaultValue).isLiteralText();\n                    if (isLiteralText) {\n                        defaultValue = ((ValueExpression) defaultValue).getValue(context.getELContext());\n                    }\n                }\n\n                // Ensure this attribute is not a method-signature. method-signature\n                // declared default values are handled in retargetMethodExpressions.\n                if (propertyDescriptor.getValue(\"method-signature\") == null || propertyDescriptor.getValue(\"type\") != null) {\n\n                    if (attributesWithDeclaredDefaultValues == null) {\n                        BeanDescriptor beanDescriptor = componentMetadata.getBeanDescriptor();\n                        attributesWithDeclaredDefaultValues = (Collection<String>) beanDescriptor.getValue(ATTRS_WITH_DECLARED_DEFAULT_VALUES);\n                        if (attributesWithDeclaredDefaultValues == null) {\n                            attributesWithDeclaredDefaultValues = new HashSet<>();\n                            beanDescriptor.setValue(ATTRS_WITH_DECLARED_DEFAULT_VALUES, attributesWithDeclaredDefaultValues);\n                        }\n                    }\n                    attributesWithDeclaredDefaultValues.add(key);\n\n                    // Only store the attribute if it is literal text. If it\n                    // is a ValueExpression, it will be handled explicitly in\n                    // CompositeComponentAttributesELResolver.ExpressionEvalMap.get().\n                    // If it is a MethodExpression, it will be dealt with in\n                    // retargetMethodExpressions.\n                    if (isLiteralText) {\n                        try {\n                            if (propertyDescriptors == null) {\n                                propertyDescriptors = getBeanInfo(component.getClass()).getPropertyDescriptors();\n                            }\n                        } catch (IntrospectionException e) {\n                            throw new FacesException(e);\n                        }\n\n                        defaultValue = convertValueToTypeIfNecessary(key, defaultValue, propertyDescriptors, expressionFactory);\n                        attrs.put(key, defaultValue);\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Helper method to convert a value to a type as defined in PropertyDescriptor(s)\n     * \n     * @param name\n     * @param value\n     * @param propertyDescriptors\n     * @return value\n     */\n    private Object convertValueToTypeIfNecessary(String name, Object value, PropertyDescriptor[] propertyDescriptors, ExpressionFactory expressionFactory) {\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            if (propertyDescriptor.getName().equals(name)) {\n                value = expressionFactory.coerceToType(value, propertyDescriptor.getPropertyType());\n                break;\n            }\n        }\n\n        return value;\n    }\n    \n\n    /**\n     * <p>\n     * To enable EL Coercion to use JSF Custom converters, this method will call\n     * <code>PropertyEditorManager.registerEditor()</code>, passing the\n     * <code>ConverterPropertyEditor</code> class for the <code>targetClass</code> if the target\n     * class is not one of the standard by-type converter target classes.\n     * \n     * @param targetClass the target class for which a PropertyEditory may or may not be created\n     */\n    private void addPropertyEditorIfNecessary(Class<?> targetClass) {\n\n        if (!registerPropertyEditors) {\n            return;\n        }\n\n        PropertyEditor editor = findEditor(targetClass);\n        if (editor != null) {\n            return;\n        }\n        String className = targetClass.getName();\n\n        // Don't add a PropertyEditor for the standard by-type converters.\n        if (targetClass.isPrimitive()) {\n            return;\n        }\n\n        for (String standardClass : STANDARD_BY_TYPE_CONVERTER_CLASSES) {\n            if (standardClass.indexOf(className) != -1) {\n                return;\n            }\n        }\n\n        Class<?> editorClass = ConverterPropertyEditorFactory.getDefaultInstance().definePropertyEditorClassFor(targetClass);\n        if (editorClass != null) {\n            PropertyEditorManager.registerEditor(targetClass, editorClass);\n        } else {\n            if (LOGGER.isLoggable(WARNING)) {\n                LOGGER.warning(MessageFormat.format(\"definePropertyEditorClassFor({0}) returned null.\", targetClass.getName()));\n            }\n        }\n    }\n    \n    private Converter createConverterBasedOnClass(Class<?> targetClass, Class<?> baseClass) {\n\n        Converter returnVal = (Converter) newConverter(targetClass, converterTypeMap, baseClass);\n        if (returnVal != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n            }\n            return returnVal;\n        }\n\n        // Search for converters registered to interfaces implemented by\n        // targetClass\n        Class<?>[] interfaces = targetClass.getInterfaces();\n        if (interfaces != null) {\n            for (int i = 0; i < interfaces.length; i++) {\n                returnVal = createConverterBasedOnClass(interfaces[i], null);\n                if (returnVal != null) {\n                    if (LOGGER.isLoggable(Level.FINE)) {\n                        LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                    }\n                    return returnVal;\n                }\n            }\n        }\n\n        // Search for converters registered to superclasses of targetClass\n        Class<?> superclass = targetClass.getSuperclass();\n        if (superclass != null) {\n            returnVal = createConverterBasedOnClass(superclass, targetClass);\n            if (returnVal != null) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.fine(MessageFormat.format(\"Created converter of type ''{0}''\", returnVal.getClass().getName()));\n                }\n                return returnVal;\n            }\n        }\n        return returnVal;\n    }\n    \n    /**\n     * <p>\n     * The same as newThing except that a single argument constructor that accepts a Class is looked\n     * for before calling the no-arg version.\n     * </p>\n     *\n     * <p>\n     * PRECONDITIONS: the values in the Map are either Strings representing fully qualified java\n     * class names, or java.lang.Class instances.\n     * </p>\n     * <p>\n     * ALGORITHM: Look in the argument map for a value for the argument key. If found, if the value\n     * is instanceof String, assume the String specifies a fully qualified java class name and\n     * obtain the java.lang.Class instance for that String using Util.loadClass(). Replace the\n     * String instance in the argument map with the Class instance. If the value is instanceof\n     * Class, proceed. Assert that the value is either instanceof java.lang.Class or\n     * java.lang.String.\n     * </p>\n     * <p>\n     * Now that you have a java.lang.class, call its newInstance and return it as the result of this\n     * method.\n     * </p>\n     *\n     * @param key Used to look up the value in the <code>Map</code>.\n     * @param map The <code>Map</code> that will be searched.\n     * @param targetClass the target class for the single argument ctor\n     * @return The new object instance.\n     */\n    protected Object newConverter(Class<?> key, Map<Class<?>, Object> map, Class<?> targetClass) {\n        assert key != null && map != null;\n\n        Object result = null;\n        Class<?> clazz;\n        Object value;\n\n        value = map.get(key);\n        if (value == null) {\n            return null;\n        }\n        assert value instanceof String || value instanceof Class;\n        if (value instanceof String) {\n            String cValue = (String) value;\n            try {\n                clazz = Util.loadClass(cValue, value);\n                if (!associate.isDevModeEnabled()) {\n                    map.put(key, clazz);\n                }\n                assert clazz != null;\n            } catch (Exception e) {\n                throw new FacesException(e.getMessage(), e);\n            }\n        } else {\n            clazz = (Class) value;\n        }\n\n        Constructor ctor = ReflectionUtils.lookupConstructor(clazz, Class.class);\n        Throwable cause = null;\n        if (ctor != null) {\n            try {\n                result = ctor.newInstance(targetClass);\n            } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n                cause = e;\n            }\n        } else {\n            try {\n                result = clazz.newInstance();\n            } catch (InstantiationException | IllegalAccessException e) {\n                cause = e;\n            }\n        }\n\n        if (null != cause) {\n            throw new FacesException(MessageUtils.getExceptionMessageString(MessageUtils.CANT_INSTANTIATE_CLASS_ERROR_MESSAGE_ID, clazz.getName()), cause);\n\n        }\n        return result;\n    }\n    \n\n    \n    /**\n     * Get the bean manager.\n     * \n     * @return the bean manager.\n     */\n    private BeanManager getBeanManager() {\n        if (beanManager == null) {\n            FacesContext facesContext = FacesContext.getCurrentInstance();\n            beanManager = Util.getCdiBeanManager(facesContext);\n        }\n        return beanManager;\n    }\n    \n    private Behavior createCDIBehavior(String behaviorId) {\n        if (version.isJsf23()) {\n            return CdiUtils.createBehavior(getBeanManager(), behaviorId);\n        }\n        \n        return null;\n    }\n    \n    private Converter<?> createCDIConverter(String converterId) {\n        if (version.isJsf23()) {\n            return CdiUtils.createConverter(getBeanManager(), converterId);\n        }\n        \n        return null;\n    }\n    \n    private Validator<?> createCDIValidator(String validatorId) {\n        if (version.isJsf23()) {\n            return CdiUtils.createValidator(getBeanManager(), validatorId);\n        }\n        \n        return null;\n    }\n\n}\n", "/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Stream;\n\nimport javax.faces.application.ProjectStage;\nimport javax.faces.application.ResourceHandler;\nimport javax.faces.application.ResourceVisitOption;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.Util;\n\n/**\n * This class is used to lookup {@link ResourceInfo} instances\n * and cache any that are successfully looked up to reduce the\n * computational overhead with the scanning/version checking.\n *\n * @since 2.0\n */\npublic class ResourceManager {\n\n    private static final Logger LOGGER = FacesLogger.RESOURCE.getLogger();\n\n    /**\n     * {@link Pattern} for valid mime types to configure compression.\n     */\n    private static final Pattern CONFIG_MIMETYPE_PATTERN = Pattern.compile(\"[a-z-]*/[a-z0-9.\\\\*-]*\");\n    \n    private FaceletWebappResourceHelper faceletWebappResourceHelper = new FaceletWebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up webapp-based resources.\n     */\n    private ResourceHelper webappResourceHelper = new WebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up classpath-based resources.\n     */\n    private ClasspathResourceHelper classpathResourceHelper = new ClasspathResourceHelper();\n\n    /**\n     * Cache for storing {@link ResourceInfo} instances to reduce the cost\n     * of the resource lookups.\n     */\n    private ResourceCache cache;\n\n    /**\n     * Patterns used to find {@link ResourceInfo} instances that may have their\n     * content compressed.\n     */\n    private List<Pattern> compressableTypes;\n\n    /**\n     * This lock is used to ensure the lookup of compressable {@link ResourceInfo}\n     * instances are atomic to prevent theading issues when writing the compressed\n     * content during a lookup.\n     */\n    private ReentrantLock lock = new ReentrantLock();\n\n\n    // ------------------------------------------------------------ Constructors\n\n    /*\n     * This ctor is only ever called by test code.\n     */\n\n    public ResourceManager(ResourceCache cache) {\n        this.cache = cache;\n        Map<String, Object> throwAwayMap = new HashMap<>();\n        initCompressableTypes(throwAwayMap);\n    }\n\n    /**\n     * Constructs a new <code>ResourceManager</code>.  Note:  if the current\n     * {@link ProjectStage} is {@link ProjectStage#Development} caching or\n     * {@link ResourceInfo} instances will not occur.\n     */\n    public ResourceManager(Map<String, Object> appMap, ResourceCache cache) {\n        this.cache = cache;\n        initCompressableTypes(appMap);\n    }\n\n\n    // ------------------------------------------------------ Public Methods\n\n\n    /**\n     * <p>\n     * Attempt to lookup a {@link ResourceInfo} based on the specified\n     * <code>libraryName<code> and <code>resourceName</code>\n     * </p>\n     *\n     * <p>\n     * Implementation Note:  Synchronization is necessary when looking up\n     * compressed resources.  This ensures the atomicity of the content\n     * being compressed.  As such, the cost of doing this is low as once\n     * the resource is in the cache, the lookup won't be performed again\n     * until the cache is cleared.  That said, it's not a good idea\n     * to have caching disabled in a production environment if leveraging\n     * compression.\n     *\n     * If the resource isn't compressable, then we don't worry about creating\n     * a few extra copies of ResourceInfo until the cache is populated.\n     * </p>\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param contentType the content type of the resource.  This will be\n     *  used to determine if the resource is compressable\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *  \n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, FacesContext ctx) {\n        return findResource(libraryName, resourceName, contentType, false, ctx);\n    }\n    \n    public ResourceInfo findViewResource(String resourceName, String contentType, FacesContext facesContext) {\n        String localePrefix = getLocalePrefix(facesContext);\n        List<String> contracts = getResourceLibraryContracts(facesContext);\n        \n        ResourceInfo info = getFromCache(resourceName, null, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, facesContext)) {\n                info = findResourceCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            } else {\n               info = findResourceNonCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            }\n        }\n\n        return info;\n    }\n    \n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, boolean isViewResource, FacesContext ctx) {\n        \n        String localePrefix = getLocalePrefix(ctx);\n        List<String> contracts = getResourceLibraryContracts(ctx);\n        \n        ResourceInfo info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, ctx)) {\n                info = findResourceCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            } else {\n               info = findResourceNonCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            }\n        }\n\n        return info;\n    }\n    \n    public Stream<String> getViewResources(FacesContext facesContext, String path, int maxDepth, ResourceVisitOption... options) {\n        return faceletWebappResourceHelper.getViewResources(facesContext, path, maxDepth, options);\n    }\n\n\n    // ----------------------------------------------------- Private Methods\n\n    private ResourceInfo findResourceCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        \n        ResourceInfo info = null;\n        \n        lock.lock();\n        try {\n            info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n            if (info == null) {\n                info = doLookup(libraryName, resourceName, localePrefix, true, isViewResource, contracts, ctx);\n                if (info != null) {\n                    addToCache(info, contracts);\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        \n        return info;\n    }\n    \n    private ResourceInfo findResourceNonCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        ResourceInfo info = doLookup(libraryName, resourceName, localePrefix, false, isViewResource, contracts, ctx);\n\n        if (info == null && contracts != null) {\n            info = doLookup(libraryNameFromContracts(libraryName, contracts), resourceName, localePrefix, false, isViewResource, contracts, ctx);\n        }\n        \n        if (info != null && !info.isDoNotCache()) {\n            addToCache(info, contracts);\n        }\n        \n        return info;\n    }\n    \n    private String libraryNameFromContracts(String libraryName, List<String> contracts) {\n        // If the library name is equal to one of the contracts,\n        // assume the resource to be found is within that contract\n        for (String contract : contracts) {\n            if (contract.equals(libraryName)) {\n                return null;\n            }\n        }\n        \n        return libraryName;\n    }\n    \n\n    /**\n     * Attempt to look up the Resource based on the provided details.\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param localePrefix the locale prefix for this resource (if any)\n     * @param compressable if this resource can be compressed\n     * @param isViewResource \n     * @param contracts the contracts to consider\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *\n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    private ResourceInfo doLookup(String libraryName, String resourceName, String localePrefix, boolean compressable, boolean isViewResource, List<String> contracts, FacesContext ctx) {\n        \n        // Loop over the contracts as described in deriveResourceIdConsideringLocalePrefixAndContracts in the spec\n        for (String contract : contracts) {\n            ResourceInfo info = getResourceInfo(libraryName, resourceName, localePrefix, contract, compressable, isViewResource, ctx, null);\n            if (info != null) {\n                return info;\n            }\n        }\n        \n        return getResourceInfo(libraryName, resourceName, localePrefix, null, compressable, isViewResource, ctx, null);\n    }\n\n    private ResourceInfo getResourceInfo(String libraryName, String resourceName, String localePrefix, String contract, boolean compressable, boolean isViewResource, FacesContext ctx, LibraryInfo library) {\n        if (libraryName != null && !nameContainsForbiddenSequence(libraryName)) {\n            library = findLibrary(libraryName, localePrefix, contract, ctx);\n            \n            if (library == null && localePrefix != null) {\n                // no localized library found.  Try to find a library that isn't localized.\n                library = findLibrary(libraryName, null, contract, ctx);\n            }\n            \n            if (library == null) {\n                // If we don't have one by now, perhaps it's time to consider scanning directories.\n                library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, false);\n                \n                if (library == null && localePrefix != null) {\n                    // no localized library found.  Try to find\n                    // a library that isn't localized.\n                    library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, null, contract, ctx, false);\n                }\n                \n                if (library == null) {\n                    return null;\n                }\n            }\n        } else if (nameContainsForbiddenSequence(libraryName)) {\n            return null;\n        }\n\n        String resName = trimLeadingSlash(resourceName);\n        if (nameContainsForbiddenSequence(resName) || (!isViewResource && resName.startsWith(\"WEB-INF\"))) {\n            return null;\n        }\n\n        ResourceInfo info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n        if (info == null && localePrefix != null) {\n            // no localized resource found, try to find a\n            // resource that isn't localized\n            info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n        }\n\n        // If no resource has been found so far, and we have a library that\n        // was found in the webapp filesystem, see if there is a matching\n        // library on the classpath.  If one is found, try to find a matching\n        // resource in that library.\n        if (info == null && library != null && library.getHelper() instanceof WebappResourceHelper) {\n            LibraryInfo altLibrary = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n            if (altLibrary != null) {\n                VersionInfo originalVersion = library.getVersion();\n                VersionInfo altVersion = altLibrary.getVersion();\n                if (originalVersion == null && altVersion == null) {\n                    library = altLibrary;\n                } else if (originalVersion == null && altVersion != null) {\n                    library = null;\n                } else if (originalVersion != null && altVersion == null) {\n                    library = null;\n                } else if (originalVersion.compareTo(altVersion) == 0) {\n                    library = altLibrary;\n                }\n\n            }\n\n            if (library != null) {\n                info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n                if (info == null && localePrefix != null) {\n                    // no localized resource found, try to find a\n                    // resource that isn't localized\n                    info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n                }\n            }\n        }\n        \n        return info;\n    }\n\n    /**\n     * @param s input String\n     * @return the String without a leading slash if it has one.\n     */\n    private String trimLeadingSlash(String s) {\n        if (s.charAt(0) == '/') {\n            return s.substring(1);\n        } else {\n            return s;\n        }\n    }\n    \n    private static boolean nameContainsForbiddenSequence(String name) {\n        boolean result = false;\n        if (name != null) {\n            name = name.toLowerCase();\n    \n            result = name.startsWith(\".\") ||\n                     name.contains(\"../\") ||\n                     name.contains(\"..\\\\\") ||\n                     name.startsWith(\"/\") ||\n                     name.startsWith(\"\\\\\") ||\n                     name.endsWith(\"/\") ||\n    \n                     name.contains(\"..%2f\") ||\n                     name.contains(\"..%5c\") ||\n                     name.startsWith(\"%2f\") ||\n                     name.startsWith(\"%5c\") ||\n                     name.endsWith(\"%2f\") ||\n    \n                     name.contains(\"..\\\\u002f\") ||\n                     name.contains(\"..\\\\u005c\") ||\n                     name.startsWith(\"\\\\u002f\") ||\n                     name.startsWith(\"\\\\u005c\") ||\n                     name.endsWith(\"\\\\u002f\")\n    \n                    ;\n        }\n        \n        return result;\n    }\n\n\n    /**\n     *\n     * @param name the resource name\n     * @param library the library name\n     * @param localePrefix the Locale prefix\n     * @param contracts\n     * @return the {@link ResourceInfo} from the cache or <code>null</code>\n     *  if no cached entry is found\n     */\n    private ResourceInfo getFromCache(String name, String library, String localePrefix, List<String> contracts) {\n        if (cache == null) {\n            return null;\n        }\n        \n        return cache.get(name, library, localePrefix, contracts);\n    }\n\n\n    /**\n     * Adds the the specified {@link ResourceInfo} to the cache.\n     * @param info the @{link ResourceInfo} to add.\n     * @param contracts the contracts\n     */\n    private void addToCache(ResourceInfo info, List<String> contracts) {\n        if (cache == null) {\n            return;\n        }\n        \n        cache.add(info, contracts);\n    }\n\n    /**\n     * <p> Attempt to lookup and return a {@link LibraryInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application *within the resources directory*.  \n     * If the library is not found, then it processed to\n     * searching the classpath, if not found there, search from the webapp root\n     * *excluding* the resources directory.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     *\n     * @param libraryName the library to find\n     * @param localePrefix the prefix for the desired locale\n     * @param contract the contract to use\n     *@param ctx         the {@link javax.faces.context.FacesContext} for the current request\n     *  @return the Library instance for the specified library\n     */\n     LibraryInfo findLibrary(String libraryName, String localePrefix, String contract, FacesContext ctx) {\n\n        LibraryInfo library = webappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        \n        if (library == null) {\n            library = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n        \n        if (library == null && contract == null) {\n            // FCAPUTO facelets in contracts should have been found by the webapphelper already\n            library = faceletWebappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n\n        // if not library is found at this point, let the caller deal with it\n        return library;\n    }\n\n     LibraryInfo findLibraryOnClasspathWithZipDirectoryEntryScan(String libraryName,\n                                                                 String localePrefix,\n                                                                 String contract, FacesContext ctx, boolean forceScan) {\n         return classpathResourceHelper.findLibraryWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, forceScan);\n     }\n\n   /**\n     * <p> Attempt to lookup and return a {@link ResourceInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application.  If the library is not found, then it processed to\n     * searching the classpath.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     * @param library the library the resource should be found in\n     * @param resourceName the name of the resource\n     * @param localePrefix the prefix for the desired locale\n     * @param compressable <code>true</code> if the resource can be compressed\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current request\n     *\n     * @return the Library instance for the specified library\n     */\n    private ResourceInfo findResource(LibraryInfo library,\n                                      String resourceName,\n                                      String localePrefix,\n                                      boolean compressable,\n                                      boolean skipToFaceletResourceHelper,\n                                      FacesContext ctx) {\n\n        if (library != null) {\n            return library.getHelper().findResource(library,\n                                                    resourceName,\n                                                    localePrefix,\n                                                    compressable,\n                                                    ctx);\n        } else {\n            ResourceInfo resource = null;\n            \n            if (!skipToFaceletResourceHelper) {\n                resource = webappResourceHelper.findResource(null,\n                        resourceName,\n                        localePrefix,\n                        compressable,\n                        ctx);\n            }\n            if (resource == null && !skipToFaceletResourceHelper) {\n                resource = classpathResourceHelper.findResource(null,\n                                                        resourceName,\n                                                        localePrefix,\n                                                        compressable, \n                                                        ctx);\n            }\n            if (resource == null) {\n                resource = faceletWebappResourceHelper.findResource(library, \n                    resourceName, \n                    localePrefix, \n                    compressable, \n                    ctx);\n            }\n            return resource;\n        }\n\n    }\n    \n    ResourceInfo findResource(String resourceId) {\n        // PENDING(fcaputo) do we need to handle contracts here?\n        String libraryName = null;\n        String resourceName = null;\n        int end = 0, start = 0;\n        if (-1 != (end = resourceId.lastIndexOf(\"/\"))) {\n            resourceName = resourceId.substring(end+1);\n            if (-1 != (start = resourceId.lastIndexOf(\"/\", end - 1))) {\n                libraryName = resourceId.substring(start+1, end);\n            } else {\n                libraryName = resourceId.substring(0, end);\n            }\n        }\n        FacesContext context = FacesContext.getCurrentInstance();\n        LibraryInfo info = this.findLibrary(libraryName, null, null, context);\n        ResourceInfo resourceInfo = this.findResource(info, resourceName, libraryName, true, false, context);\n        \n        return resourceInfo;\n    }\n\n\n    /**\n     * <p>\n     * Obtains the application configured message resources for the current\n     * request locale.  If a ResourceBundle is found and contains the key\n     * <code>javax.faces.resource.localePrefix</code>, use the value associated\n     * with that key as the prefix for locale specific resources.\n     * </p>\n     *\n     * <p>\n     * For example, say the request locale is en_US, and\n     * <code>javax.faces.resourceLocalePrefix</code> is found with a value of\n     * <code>en</code>, a resource path within a web application might look like\n     * <code>/resources/en/corp/images/greetings.jpg</code>\n     * </p>\n     *\n     * @param context the {@link FacesContext} for the current request\n     * @return the localePrefix based on the current request, or <code>null</code>\n     *  if no prefix can be determined\n     */\n    private String getLocalePrefix(FacesContext context) {\n\n        String localePrefix = null;\n        \n        localePrefix = context.getExternalContext().getRequestParameterMap().get(\"loc\");\n        \n        if(localePrefix != null && !nameContainsForbiddenSequence(localePrefix)){\n            return localePrefix;\n        }\n        \n        String appBundleName = context.getApplication().getMessageBundle();\n        if (null != appBundleName) {\n        \t\n            Locale locale = null;\n            if (context.getViewRoot() != null) {\n                locale = context.getViewRoot().getLocale();\n            } else {\n                locale = context.getApplication().getViewHandler().calculateLocale(context);\n            }\n            \n                try {\n                    ResourceBundle appBundle =\n                          ResourceBundle.getBundle(appBundleName,\n                                                   locale,\n                                                   Util.getCurrentLoader(ResourceManager.class));\n                    localePrefix =\n                          appBundle\n                                .getString(ResourceHandler.LOCALE_PREFIX);\n                } catch (MissingResourceException mre) { \n                    if (LOGGER.isLoggable(Level.FINEST)) {\n                        LOGGER.log(Level.FINEST, \"Ignoring missing resource\", mre);\n                    }\n                }\n        }\n        return localePrefix;\n\n    }\n\n    private List<String> getResourceLibraryContracts(FacesContext context) {\n        UIViewRoot viewRoot = context.getViewRoot();\n        if(viewRoot == null) {\n\n            if(context.getApplication().getResourceHandler().isResourceRequest(context)) {\n                // it is a resource request. look at the parameter con=.\n\n                String param = context.getExternalContext().getRequestParameterMap().get(\"con\");\n                if(!nameContainsForbiddenSequence(param) && param != null && param.trim().length() > 0) {\n                    return Arrays.asList(param);\n                }\n            }\n            // PENDING(edburns): calculate the contracts!\n            return Collections.emptyList();\n        }\n        return context.getResourceLibraryContracts();\n    }\n\n\n    /**\n     * @param contentType content-type in question\n     * @param ctx the @{link FacesContext} for the current request\n     * @return <code>true</code> if this resource can be compressed, otherwise\n     *  <code>false</code>\n     */\n    private boolean isCompressable(String contentType, FacesContext ctx) {\n\n        // No compression when developing.\n        if (contentType == null || ctx.isProjectStage(ProjectStage.Development)) {\n            return false;\n        } else {\n            if (compressableTypes != null && !compressableTypes.isEmpty()) {\n                for (Pattern p : compressableTypes) {\n                    boolean matches = p.matcher(contentType).matches();\n                    if (matches) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n\n    }\n\n\n    /**\n     * Init <code>compressableTypes</code> from the configuration.\n     */\n    private void initCompressableTypes(Map<String, Object> appMap) {\n\n        WebConfiguration config = WebConfiguration.getInstance();\n        String value = config.getOptionValue(WebConfiguration.WebContextInitParameter.CompressableMimeTypes);\n        if (value != null && value.length() > 0) {\n            String[] values = Util.split(appMap, value, \",\");\n            if (values != null) {\n                for (String s : values) {\n                    String pattern = s.trim();\n                    if (!isPatternValid(pattern)) {\n                        continue;\n                    }\n                    if (pattern.endsWith(\"/*\")) {\n                        pattern = pattern.substring(0, pattern.indexOf(\"/*\"));\n                        pattern += \"/[a-z0-9.-]*\";\n                    }\n                    if (compressableTypes == null) {\n                        compressableTypes = new ArrayList<>(values.length);\n                    }\n                    try {\n                        compressableTypes.add(Pattern.compile(pattern));\n                    } catch (PatternSyntaxException pse) {\n                        if (LOGGER.isLoggable(Level.WARNING)) {\n                            // PENDING i18n\n                            LOGGER.log(Level.WARNING,\n                                       \"jsf.resource.mime.type.configration.invalid\",\n                                       new Object[] { pattern, pse.getPattern()});\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * @param input input mime-type pattern from the configuration\n     * @return <code>true</code> if the input matches the expected pattern,\n     *  otherwise <code>false</code>\n     */\n    private boolean isPatternValid(String input) {\n\n        return (CONFIG_MIMETYPE_PATTERN.matcher(input).matches());\n\n    }\n\n\n}\n"], "filenames": ["impl/src/main/java/com/sun/faces/application/applicationimpl/InstanceFactory.java", "impl/src/main/java/com/sun/faces/application/resource/ResourceManager.java"], "buggy_code_start_loc": [290, 568], "buggy_code_end_loc": [290, 569], "fixing_code_start_loc": [291, 568], "fixing_code_end_loc": [295, 569], "type": "CWE-22", "message": "The getLocalePrefix function in ResourceManager.java in Eclipse Mojarra before 2.3.7 is affected by Directory Traversal via the loc parameter. A remote attacker can download configuration files or Java bytecodes from applications.", "other": {"cve": {"id": "CVE-2018-14371", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-18T12:29:00.257", "lastModified": "2018-09-17T13:55:35.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The getLocalePrefix function in ResourceManager.java in Eclipse Mojarra before 2.3.7 is affected by Directory Traversal via the loc parameter. A remote attacker can download configuration files or Java bytecodes from applications."}, {"lang": "es", "value": "La funci\u00f3n getLocalePrefix en ResourceManager.java en Eclipse Mojarra en versiones anteriores a la 2.3.7 se ha visto afectada por un salto de directorio mediante el par\u00e1metro loc. Un atacante remoto puedes descargar archivos de configuraci\u00f3n o bytecodes de Java desde las aplicaciones."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:mojarra:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.7", "matchCriteriaId": "B439B1B0-6A38-47BC-993D-A08A64E789F6"}]}]}], "references": [{"url": "https://github.com/eclipse-ee4j/mojarra/commit/1b434748d9239f42eae8aa7d37d7a0930c061e24", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/javaserverfaces/mojarra/issues/4364", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eclipse-ee4j/mojarra/commit/1b434748d9239f42eae8aa7d37d7a0930c061e24"}}