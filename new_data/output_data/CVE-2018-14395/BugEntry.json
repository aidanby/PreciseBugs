{"buggy_code": ["/*\n * MOV, 3GP, MP4 muxer\n * Copyright (c) 2003 Thomas Raivio\n * Copyright (c) 2004 Gildas Bazin <gbazin at videolan dot org>\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdint.h>\n#include <inttypes.h>\n\n#include \"movenc.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"riff.h\"\n#include \"avio.h\"\n#include \"isom.h\"\n#include \"avc.h\"\n#include \"libavcodec/ac3_parser.h\"\n#include \"libavcodec/dnxhddata.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/vc1_common.h\"\n#include \"libavcodec/raw.h\"\n#include \"internal.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/libm.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavutil/color_utils.h\"\n#include \"hevc.h\"\n#include \"rtpenc.h\"\n#include \"mov_chan.h\"\n#include \"vpcc.h\"\n\nstatic const AVOption options[] = {\n    { \"movflags\", \"MOV muxer flags\", offsetof(MOVMuxContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"rtphint\", \"Add RTP hint tracks\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_RTP_HINT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"moov_size\", \"maximum moov size so it can be placed at the begin\", offsetof(MOVMuxContext, reserved_moov_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, 0 },\n    { \"empty_moov\", \"Make the initial moov atom empty\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_EMPTY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"frag_keyframe\", \"Fragment at video keyframes\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_KEYFRAME}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"separate_moof\", \"Write separate moof/mdat atoms for each track\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_SEPARATE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"frag_custom\", \"Flush fragments on caller requests\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_CUSTOM}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"isml\", \"Create a live smooth streaming feed (for pushing to a publishing point)\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_ISML}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"faststart\", \"Run a second pass to put the index (moov atom) at the beginning of the file\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FASTSTART}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"omit_tfhd_offset\", \"Omit the base data offset in tfhd atoms\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_OMIT_TFHD_OFFSET}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"disable_chpl\", \"Disable Nero chapter atom\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DISABLE_CHPL}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"default_base_moof\", \"Set the default-base-is-moof flag in tfhd atoms\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DEFAULT_BASE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"dash\", \"Write DASH compatible fragmented MP4\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DASH}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"frag_discont\", \"Signal that the next fragment is discontinuous from earlier ones\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_DISCONT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"delay_moov\", \"Delay writing the initial moov until the first fragment is cut, or until the first fragment flush\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DELAY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"global_sidx\", \"Write a global sidx index at the start of the file\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_GLOBAL_SIDX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"write_colr\", \"Write colr atom (Experimental, may be renamed or changed, do not use from scripts)\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_COLR}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"write_gama\", \"Write deprecated gama atom\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_GAMA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"use_metadata_tags\", \"Use mdta atom for metadata.\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_USE_MDTA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    FF_RTP_FLAG_OPTS(MOVMuxContext, rtp_flags),\n    { \"skip_iods\", \"Skip writing iods atom.\", offsetof(MOVMuxContext, iods_skip), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"iods_audio_profile\", \"iods audio profile atom.\", offsetof(MOVMuxContext, iods_audio_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"iods_video_profile\", \"iods video profile atom.\", offsetof(MOVMuxContext, iods_video_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"frag_duration\", \"Maximum fragment duration\", offsetof(MOVMuxContext, max_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"min_frag_duration\", \"Minimum fragment duration\", offsetof(MOVMuxContext, min_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"frag_size\", \"Maximum fragment size\", offsetof(MOVMuxContext, max_fragment_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"ism_lookahead\", \"Number of lookahead entries for ISM files\", offsetof(MOVMuxContext, ism_lookahead), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"video_track_timescale\", \"set timescale of all video tracks\", offsetof(MOVMuxContext, video_track_timescale), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"brand\",    \"Override major brand\", offsetof(MOVMuxContext, major_brand),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"use_editlist\", \"use edit list\", offsetof(MOVMuxContext, use_editlist), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"fragment_index\", \"Fragment number of the next fragment\", offsetof(MOVMuxContext, fragments), AV_OPT_TYPE_INT, {.i64 = 1}, 1, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"mov_gamma\", \"gamma value for gama atom\", offsetof(MOVMuxContext, gamma), AV_OPT_TYPE_FLOAT, {.dbl = 0.0 }, 0.0, 10, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"frag_interleave\", \"Interleave samples within fragments (max number of consecutive samples, lower is tighter interleaving, but with more overhead)\", offsetof(MOVMuxContext, frag_interleave), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM },\n    { \"encryption_scheme\",    \"Configures the encryption scheme, allowed values are none, cenc-aes-ctr\", offsetof(MOVMuxContext, encryption_scheme_str),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"encryption_key\", \"The media encryption key (hex)\", offsetof(MOVMuxContext, encryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"encryption_kid\", \"The media encryption key identifier (hex)\", offsetof(MOVMuxContext, encryption_kid), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"use_stream_ids_as_track_ids\", \"use stream ids as track ids\", offsetof(MOVMuxContext, use_stream_ids_as_track_ids), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"write_tmcd\", \"force or disable writing tmcd\", offsetof(MOVMuxContext, write_tmcd), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { NULL },\n};\n\n#define MOV_CLASS(flavor)\\\nstatic const AVClass flavor ## _muxer_class = {\\\n    .class_name = #flavor \" muxer\",\\\n    .item_name  = av_default_item_name,\\\n    .option     = options,\\\n    .version    = LIBAVUTIL_VERSION_INT,\\\n};\n\nstatic int get_moov_size(AVFormatContext *s);\n\nstatic int utf8len(const uint8_t *b)\n{\n    int len = 0;\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        len++;\n    }\n    return len;\n}\n\n//FIXME support 64 bit variant with wide placeholders\nstatic int64_t update_size(AVIOContext *pb, int64_t pos)\n{\n    int64_t curpos = avio_tell(pb);\n    avio_seek(pb, pos, SEEK_SET);\n    avio_wb32(pb, curpos - pos); /* rewrite size */\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return curpos - pos;\n}\n\nstatic int co64_required(const MOVTrack *track)\n{\n    if (track->entry > 0 && track->cluster[track->entry - 1].pos + track->data_offset > UINT32_MAX)\n        return 1;\n    return 0;\n}\n\n/* Chunk offset atom */\nstatic int mov_write_stco_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    int mode64 = co64_required(track); // use 32 bit size variant if possible\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    if (mode64)\n        ffio_wfourcc(pb, \"co64\");\n    else\n        ffio_wfourcc(pb, \"stco\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, track->chunkCount); /* entry count */\n    for (i = 0; i < track->entry; i++) {\n        if (!track->cluster[i].chunkNum)\n            continue;\n        if (mode64 == 1)\n            avio_wb64(pb, track->cluster[i].pos + track->data_offset);\n        else\n            avio_wb32(pb, track->cluster[i].pos + track->data_offset);\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample size atom */\nstatic int mov_write_stsz_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int equalChunks = 1;\n    int i, j, entries = 0, tst = -1, oldtst = -1;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stsz\");\n    avio_wb32(pb, 0); /* version & flags */\n\n    for (i = 0; i < track->entry; i++) {\n        tst = track->cluster[i].size / track->cluster[i].entries;\n        if (oldtst != -1 && tst != oldtst)\n            equalChunks = 0;\n        oldtst = tst;\n        entries += track->cluster[i].entries;\n    }\n    if (equalChunks && track->entry) {\n        int sSize = track->entry ? track->cluster[0].size / track->cluster[0].entries : 0;\n        sSize = FFMAX(1, sSize); // adpcm mono case could make sSize == 0\n        avio_wb32(pb, sSize); // sample size\n        avio_wb32(pb, entries); // sample count\n    } else {\n        avio_wb32(pb, 0); // sample size\n        avio_wb32(pb, entries); // sample count\n        for (i = 0; i < track->entry; i++) {\n            for (j = 0; j < track->cluster[i].entries; j++) {\n                avio_wb32(pb, track->cluster[i].size /\n                          track->cluster[i].entries);\n            }\n        }\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample to chunk atom */\nstatic int mov_write_stsc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int index = 0, oldval = -1, i;\n    int64_t entryPos, curpos;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stsc\");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->chunkCount); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (oldval != track->cluster[i].samples_in_chunk && track->cluster[i].chunkNum) {\n            avio_wb32(pb, track->cluster[i].chunkNum); // first chunk\n            avio_wb32(pb, track->cluster[i].samples_in_chunk); // samples per chunk\n            avio_wb32(pb, 0x1); // sample description index\n            oldval = track->cluster[i].samples_in_chunk;\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return update_size(pb, pos);\n}\n\n/* Sync sample atom */\nstatic int mov_write_stss_tag(AVIOContext *pb, MOVTrack *track, uint32_t flag)\n{\n    int64_t curpos, entryPos;\n    int i, index = 0;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, flag == MOV_SYNC_SAMPLE ? \"stss\" : \"stps\");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->entry); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (track->cluster[i].flags & flag) {\n            avio_wb32(pb, i + 1);\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_amr_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x11); /* size */\n    if (track->mode == MODE_MOV) ffio_wfourcc(pb, \"samr\");\n    else                         ffio_wfourcc(pb, \"damr\");\n    ffio_wfourcc(pb, \"FFMP\");\n    avio_w8(pb, 0); /* decoder version */\n\n    avio_wb16(pb, 0x81FF); /* Mode set (all modes for AMR_NB) */\n    avio_w8(pb, 0x00); /* Mode change period (no restriction) */\n    avio_w8(pb, 0x01); /* Frames per sample */\n    return 0x11;\n}\n\nstatic int mov_write_ac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    GetBitContext gbc;\n    PutBitContext pbc;\n    uint8_t buf[3];\n    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;\n\n    if (track->vos_len < 7)\n        return -1;\n\n    avio_wb32(pb, 11);\n    ffio_wfourcc(pb, \"dac3\");\n\n    init_get_bits(&gbc, track->vos_data + 4, (track->vos_len - 4) * 8);\n    fscod      = get_bits(&gbc, 2);\n    frmsizecod = get_bits(&gbc, 6);\n    bsid       = get_bits(&gbc, 5);\n    bsmod      = get_bits(&gbc, 3);\n    acmod      = get_bits(&gbc, 3);\n    if (acmod == 2) {\n        skip_bits(&gbc, 2); // dsurmod\n    } else {\n        if ((acmod & 1) && acmod != 1)\n            skip_bits(&gbc, 2); // cmixlev\n        if (acmod & 4)\n            skip_bits(&gbc, 2); // surmixlev\n    }\n    lfeon = get_bits1(&gbc);\n\n    init_put_bits(&pbc, buf, sizeof(buf));\n    put_bits(&pbc, 2, fscod);\n    put_bits(&pbc, 5, bsid);\n    put_bits(&pbc, 3, bsmod);\n    put_bits(&pbc, 3, acmod);\n    put_bits(&pbc, 1, lfeon);\n    put_bits(&pbc, 5, frmsizecod >> 1); // bit_rate_code\n    put_bits(&pbc, 5, 0); // reserved\n\n    flush_put_bits(&pbc);\n    avio_write(pb, buf, sizeof(buf));\n\n    return 11;\n}\n\nstruct eac3_info {\n    AVPacket pkt;\n    uint8_t ec3_done;\n    uint8_t num_blocks;\n\n    /* Layout of the EC3SpecificBox */\n    /* maximum bitrate */\n    uint16_t data_rate;\n    /* number of independent substreams */\n    uint8_t  num_ind_sub;\n    struct {\n        /* sample rate code (see ff_ac3_sample_rate_tab) 2 bits */\n        uint8_t fscod;\n        /* bit stream identification 5 bits */\n        uint8_t bsid;\n        /* one bit reserved */\n        /* audio service mixing (not supported yet) 1 bit */\n        /* bit stream mode 3 bits */\n        uint8_t bsmod;\n        /* audio coding mode 3 bits */\n        uint8_t acmod;\n        /* sub woofer on 1 bit */\n        uint8_t lfeon;\n        /* 3 bits reserved */\n        /* number of dependent substreams associated with this substream 4 bits */\n        uint8_t num_dep_sub;\n        /* channel locations of the dependent substream(s), if any, 9 bits */\n        uint16_t chan_loc;\n        /* if there is no dependent substream, then one bit reserved instead */\n    } substream[1]; /* TODO: support 8 independent substreams */\n};\n\n#if CONFIG_AC3_PARSER\nstatic int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    GetBitContext gbc;\n    AC3HeaderInfo tmp, *hdr = &tmp;\n    struct eac3_info *info;\n    int num_blocks;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    init_get_bits(&gbc, pkt->data, pkt->size * 8);\n    if (avpriv_ac3_parse_header(&gbc, &hdr) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");\n            return 0;\n        }\n        return AVERROR_INVALIDDATA;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0)\n            return AVERROR(EINVAL);\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1)\n                return AVERROR(EINVAL);\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(mov->fc, \"Multiple independent substreams\");\n                return AVERROR_PATCHWELCOME;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr->substreamid != 0) {\n                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");\n                return AVERROR_PATCHWELCOME;\n            }\n        }\n\n        /* fill the info needed for the \"dec3\" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                int i;\n                init_get_bits(&gbc, pkt->data + cumul_size, (pkt->size - cumul_size) * 8);\n                if (avpriv_ac3_parse_header(&gbc, &hdr) < 0)\n                    return AVERROR_INVALIDDATA;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT)\n                    return AVERROR(EINVAL);\n                cumul_size += hdr->frame_size;\n                info->substream[parent].num_dep_sub++;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6)\n        return pkt->size;\n    else if (info->num_blocks + num_blocks > 6)\n        return AVERROR_INVALIDDATA;\n\n    if (!info->num_blocks) {\n        int ret;\n        if ((ret = av_copy_packet(&info->pkt, pkt)) < 0)\n            return ret;\n        info->num_blocks = num_blocks;\n        return 0;\n    } else {\n        int ret;\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            return ret;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            return ret;\n        if (info->num_blocks != 6)\n            return 0;\n        av_packet_unref(pkt);\n        if ((ret = av_copy_packet(pkt, &info->pkt)) < 0)\n            return ret;\n        av_packet_unref(&info->pkt);\n        info->num_blocks = 0;\n    }\n\n    return pkt->size;\n}\n#endif\n\nstatic int mov_write_eac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    PutBitContext pbc;\n    uint8_t *buf;\n    struct eac3_info *info;\n    int size, i;\n\n    if (!track->eac3_priv)\n        return AVERROR(EINVAL);\n\n    info = track->eac3_priv;\n    size = 2 + 4 * (info->num_ind_sub + 1);\n    buf = av_malloc(size);\n    if (!buf) {\n        size = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    init_put_bits(&pbc, buf, size);\n    put_bits(&pbc, 13, info->data_rate);\n    put_bits(&pbc,  3, info->num_ind_sub);\n    for (i = 0; i <= info->num_ind_sub; i++) {\n        put_bits(&pbc, 2, info->substream[i].fscod);\n        put_bits(&pbc, 5, info->substream[i].bsid);\n        put_bits(&pbc, 1, 0); /* reserved */\n        put_bits(&pbc, 1, 0); /* asvc */\n        put_bits(&pbc, 3, info->substream[i].bsmod);\n        put_bits(&pbc, 3, info->substream[i].acmod);\n        put_bits(&pbc, 1, info->substream[i].lfeon);\n        put_bits(&pbc, 5, 0); /* reserved */\n        put_bits(&pbc, 4, info->substream[i].num_dep_sub);\n        if (!info->substream[i].num_dep_sub) {\n            put_bits(&pbc, 1, 0); /* reserved */\n            size--;\n        } else {\n            put_bits(&pbc, 9, info->substream[i].chan_loc);\n        }\n    }\n    flush_put_bits(&pbc);\n\n    avio_wb32(pb, size + 8);\n    ffio_wfourcc(pb, \"dec3\");\n    avio_write(pb, buf, size);\n\n    av_free(buf);\n\nend:\n    av_packet_unref(&info->pkt);\n    av_freep(&track->eac3_priv);\n\n    return size;\n}\n\n/**\n * This function writes extradata \"as is\".\n * Extradata must be formatted like a valid atom (with size and tag).\n */\nstatic int mov_write_extradata_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_write(pb, track->par->extradata, track->par->extradata_size);\n    return track->par->extradata_size;\n}\n\nstatic int mov_write_enda_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 10);\n    ffio_wfourcc(pb, \"enda\");\n    avio_wb16(pb, 1); /* little endian */\n    return 10;\n}\n\nstatic int mov_write_enda_tag_be(AVIOContext *pb)\n{\n  avio_wb32(pb, 10);\n  ffio_wfourcc(pb, \"enda\");\n  avio_wb16(pb, 0); /* big endian */\n  return 10;\n}\n\nstatic void put_descr(AVIOContext *pb, int tag, unsigned int size)\n{\n    int i = 3;\n    avio_w8(pb, tag);\n    for (; i > 0; i--)\n        avio_w8(pb, (size >> (7 * i)) | 0x80);\n    avio_w8(pb, size & 0x7F);\n}\n\nstatic unsigned compute_avg_bitrate(MOVTrack *track)\n{\n    uint64_t size = 0;\n    int i;\n    if (!track->track_duration)\n        return 0;\n    for (i = 0; i < track->entry; i++)\n        size += track->cluster[i].size;\n    return size * 8 * track->timescale / track->track_duration;\n}\n\nstatic int mov_write_esds_tag(AVIOContext *pb, MOVTrack *track) // Basic\n{\n    AVCPBProperties *props;\n    int64_t pos = avio_tell(pb);\n    int decoder_specific_info_len = track->vos_len ? 5 + track->vos_len : 0;\n    unsigned avg_bitrate;\n\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, \"esds\");\n    avio_wb32(pb, 0); // Version\n\n    // ES descriptor\n    put_descr(pb, 0x03, 3 + 5+13 + decoder_specific_info_len + 5+1);\n    avio_wb16(pb, track->track_id);\n    avio_w8(pb, 0x00); // flags (= no flags)\n\n    // DecoderConfig descriptor\n    put_descr(pb, 0x04, 13 + decoder_specific_info_len);\n\n    // Object type indication\n    if ((track->par->codec_id == AV_CODEC_ID_MP2 ||\n         track->par->codec_id == AV_CODEC_ID_MP3) &&\n        track->par->sample_rate > 24000)\n        avio_w8(pb, 0x6B); // 11172-3\n    else\n        avio_w8(pb, ff_codec_get_tag(ff_mp4_obj_type, track->par->codec_id));\n\n    // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)\n    // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)\n    if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n        avio_w8(pb, (0x38 << 2) | 1); // flags (= NeroSubpicStream)\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        avio_w8(pb, 0x15); // flags (= Audiostream)\n    else\n        avio_w8(pb, 0x11); // flags (= Visualstream)\n\n    props = (AVCPBProperties*)av_stream_get_side_data(track->st, AV_PKT_DATA_CPB_PROPERTIES,\n                                                      NULL);\n\n    avio_wb24(pb, props ? props->buffer_size / 8 : 0); // Buffersize DB\n\n    avg_bitrate = compute_avg_bitrate(track);\n    avio_wb32(pb, props ? FFMAX3(props->max_bitrate, props->avg_bitrate, avg_bitrate) : FFMAX(track->par->bit_rate, avg_bitrate)); // maxbitrate (FIXME should be max rate in any 1 sec window)\n    avio_wb32(pb, avg_bitrate);\n\n    if (track->vos_len) {\n        // DecoderSpecific info descriptor\n        put_descr(pb, 0x05, track->vos_len);\n        avio_write(pb, track->vos_data, track->vos_len);\n    }\n\n    // SL descriptor\n    put_descr(pb, 0x06, 1);\n    avio_w8(pb, 0x02);\n    return update_size(pb, pos);\n}\n\nstatic int mov_pcm_le_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24LE ||\n           codec_id == AV_CODEC_ID_PCM_S32LE ||\n           codec_id == AV_CODEC_ID_PCM_F32LE ||\n           codec_id == AV_CODEC_ID_PCM_F64LE;\n}\n\nstatic int mov_pcm_be_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24BE ||\n           codec_id == AV_CODEC_ID_PCM_S32BE ||\n           codec_id == AV_CODEC_ID_PCM_F32BE ||\n           codec_id == AV_CODEC_ID_PCM_F64BE;\n}\n\nstatic int mov_write_ms_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int ret;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    avio_wl32(pb, track->tag); // store it byteswapped\n    track->par->codec_tag = av_bswap16(track->tag >> 16);\n    if ((ret = ff_put_wav_header(s, pb, track->par, 0)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_wfex_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int ret;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"wfex\");\n    if ((ret = ff_put_wav_header(s, pb, track->st->codecpar, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_chan_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    uint32_t layout_tag, bitmap;\n    int64_t pos = avio_tell(pb);\n\n    layout_tag = ff_mov_get_channel_layout_tag(track->par->codec_id,\n                                               track->par->channel_layout,\n                                               &bitmap);\n    if (!layout_tag) {\n        av_log(s, AV_LOG_WARNING, \"not writing 'chan' tag due to \"\n               \"lack of channel information\\n\");\n        return 0;\n    }\n\n    if (track->multichannel_as_mono)\n        return 0;\n\n    avio_wb32(pb, 0);           // Size\n    ffio_wfourcc(pb, \"chan\");   // Type\n    avio_w8(pb, 0);             // Version\n    avio_wb24(pb, 0);           // Flags\n    avio_wb32(pb, layout_tag);  // mChannelLayoutTag\n    avio_wb32(pb, bitmap);      // mChannelBitmap\n    avio_wb32(pb, 0);           // mNumberChannelDescriptions\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_wave_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);     /* size */\n    ffio_wfourcc(pb, \"wave\");\n\n    if (track->par->codec_id != AV_CODEC_ID_QDM2) {\n    avio_wb32(pb, 12);    /* size */\n    ffio_wfourcc(pb, \"frma\");\n    avio_wl32(pb, track->tag);\n    }\n\n    if (track->par->codec_id == AV_CODEC_ID_AAC) {\n        /* useless atom needed by mplayer, ipod, not needed by quicktime */\n        avio_wb32(pb, 12); /* size */\n        ffio_wfourcc(pb, \"mp4a\");\n        avio_wb32(pb, 0);\n        mov_write_esds_tag(pb, track);\n    } else if (mov_pcm_le_gt16(track->par->codec_id))  {\n      mov_write_enda_tag(pb);\n    } else if (mov_pcm_be_gt16(track->par->codec_id))  {\n      mov_write_enda_tag_be(pb);\n    } else if (track->par->codec_id == AV_CODEC_ID_AMR_NB) {\n        mov_write_amr_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_AC3) {\n        mov_write_ac3_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_EAC3) {\n        mov_write_eac3_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_ALAC ||\n               track->par->codec_id == AV_CODEC_ID_QDM2) {\n        mov_write_extradata_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        mov_write_ms_tag(s, pb, track);\n    }\n\n    avio_wb32(pb, 8);     /* size */\n    avio_wb32(pb, 0);     /* null tag */\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_dvc1_structs(MOVTrack *track, uint8_t *buf)\n{\n    uint8_t *unescaped;\n    const uint8_t *start, *next, *end = track->vos_data + track->vos_len;\n    int unescaped_size, seq_found = 0;\n    int level = 0, interlace = 0;\n    int packet_seq   = track->vc1_info.packet_seq;\n    int packet_entry = track->vc1_info.packet_entry;\n    int slices       = track->vc1_info.slices;\n    PutBitContext pbc;\n\n    if (track->start_dts == AV_NOPTS_VALUE) {\n        /* No packets written yet, vc1_info isn't authoritative yet. */\n        /* Assume inline sequence and entry headers. */\n        packet_seq = packet_entry = 1;\n        av_log(NULL, AV_LOG_WARNING,\n               \"moov atom written before any packets, unable to write correct \"\n               \"dvc1 atom. Set the delay_moov flag to fix this.\\n\");\n    }\n\n    unescaped = av_mallocz(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!unescaped)\n        return AVERROR(ENOMEM);\n    start = find_next_marker(track->vos_data, end);\n    for (next = start; next < end; start = next) {\n        GetBitContext gb;\n        int size;\n        next = find_next_marker(start + 4, end);\n        size = next - start - 4;\n        if (size <= 0)\n            continue;\n        unescaped_size = vc1_unescape_buffer(start + 4, size, unescaped);\n        init_get_bits(&gb, unescaped, 8 * unescaped_size);\n        if (AV_RB32(start) == VC1_CODE_SEQHDR) {\n            int profile = get_bits(&gb, 2);\n            if (profile != PROFILE_ADVANCED) {\n                av_free(unescaped);\n                return AVERROR(ENOSYS);\n            }\n            seq_found = 1;\n            level = get_bits(&gb, 3);\n            /* chromaformat, frmrtq_postproc, bitrtq_postproc, postprocflag,\n             * width, height */\n            skip_bits_long(&gb, 2 + 3 + 5 + 1 + 2*12);\n            skip_bits(&gb, 1); /* broadcast */\n            interlace = get_bits1(&gb);\n            skip_bits(&gb, 4); /* tfcntrflag, finterpflag, reserved, psf */\n        }\n    }\n    if (!seq_found) {\n        av_free(unescaped);\n        return AVERROR(ENOSYS);\n    }\n\n    init_put_bits(&pbc, buf, 7);\n    /* VC1DecSpecStruc */\n    put_bits(&pbc, 4, 12); /* profile - advanced */\n    put_bits(&pbc, 3, level);\n    put_bits(&pbc, 1, 0); /* reserved */\n    /* VC1AdvDecSpecStruc */\n    put_bits(&pbc, 3, level);\n    put_bits(&pbc, 1, 0); /* cbr */\n    put_bits(&pbc, 6, 0); /* reserved */\n    put_bits(&pbc, 1, !interlace); /* no interlace */\n    put_bits(&pbc, 1, !packet_seq); /* no multiple seq */\n    put_bits(&pbc, 1, !packet_entry); /* no multiple entry */\n    put_bits(&pbc, 1, !slices); /* no slice code */\n    put_bits(&pbc, 1, 0); /* no bframe */\n    put_bits(&pbc, 1, 0); /* reserved */\n\n    /* framerate */\n    if (track->st->avg_frame_rate.num > 0 && track->st->avg_frame_rate.den > 0)\n        put_bits32(&pbc, track->st->avg_frame_rate.num / track->st->avg_frame_rate.den);\n    else\n        put_bits32(&pbc, 0xffffffff);\n\n    flush_put_bits(&pbc);\n\n    av_free(unescaped);\n\n    return 0;\n}\n\nstatic int mov_write_dvc1_tag(AVIOContext *pb, MOVTrack *track)\n{\n    uint8_t buf[7] = { 0 };\n    int ret;\n\n    if ((ret = mov_write_dvc1_structs(track, buf)) < 0)\n        return ret;\n\n    avio_wb32(pb, track->vos_len + 8 + sizeof(buf));\n    ffio_wfourcc(pb, \"dvc1\");\n    avio_write(pb, buf, sizeof(buf));\n    avio_write(pb, track->vos_data, track->vos_len);\n\n    return 0;\n}\n\nstatic int mov_write_glbl_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, track->vos_len + 8);\n    ffio_wfourcc(pb, \"glbl\");\n    avio_write(pb, track->vos_data, track->vos_len);\n    return 8 + track->vos_len;\n}\n\n/**\n * Compute flags for 'lpcm' tag.\n * See CoreAudioTypes and AudioStreamBasicDescription at Apple.\n */\nstatic int mov_get_lpcm_flags(enum AVCodecID codec_id)\n{\n    switch (codec_id) {\n    case AV_CODEC_ID_PCM_F32BE:\n    case AV_CODEC_ID_PCM_F64BE:\n        return 11;\n    case AV_CODEC_ID_PCM_F32LE:\n    case AV_CODEC_ID_PCM_F64LE:\n        return 9;\n    case AV_CODEC_ID_PCM_U8:\n        return 10;\n    case AV_CODEC_ID_PCM_S16BE:\n    case AV_CODEC_ID_PCM_S24BE:\n    case AV_CODEC_ID_PCM_S32BE:\n        return 14;\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S24LE:\n    case AV_CODEC_ID_PCM_S32LE:\n        return 12;\n    default:\n        return 0;\n    }\n}\n\nstatic int get_cluster_duration(MOVTrack *track, int cluster_idx)\n{\n    int64_t next_dts;\n\n    if (cluster_idx >= track->entry)\n        return 0;\n\n    if (cluster_idx + 1 == track->entry)\n        next_dts = track->track_duration + track->start_dts;\n    else\n        next_dts = track->cluster[cluster_idx + 1].dts;\n\n    next_dts -= track->cluster[cluster_idx].dts;\n\n    av_assert0(next_dts >= 0);\n    av_assert0(next_dts <= INT_MAX);\n\n    return next_dts;\n}\n\nstatic int get_samples_per_packet(MOVTrack *track)\n{\n    int i, first_duration;\n\n// return track->par->frame_size;\n\n    /* use 1 for raw PCM */\n    if (!track->audio_vbr)\n        return 1;\n\n    /* check to see if duration is constant for all clusters */\n    if (!track->entry)\n        return 0;\n    first_duration = get_cluster_duration(track, 0);\n    for (i = 1; i < track->entry; i++) {\n        if (get_cluster_duration(track, i) != first_duration)\n            return 0;\n    }\n    return first_duration;\n}\n\nstatic int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int version = 0;\n    uint32_t tag = track->tag;\n\n    if (track->mode == MODE_MOV) {\n        if (track->timescale > UINT16_MAX) {\n            if (mov_get_lpcm_flags(track->par->codec_id))\n                tag = AV_RL32(\"lpcm\");\n            version = 2;\n        } else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||\n                   mov_pcm_be_gt16(track->par->codec_id) ||\n                   track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n                   track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||\n                   track->par->codec_id == AV_CODEC_ID_QDM2) {\n            version = 1;\n        }\n    }\n\n    avio_wb32(pb, 0); /* size */\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ffio_wfourcc(pb, \"enca\");\n    } else {\n        avio_wl32(pb, tag); // store it byteswapped\n    }\n    avio_wb32(pb, 0); /* Reserved */\n    avio_wb16(pb, 0); /* Reserved */\n    avio_wb16(pb, 1); /* Data-reference index, XXX  == 1 */\n\n    /* SoundDescription */\n    avio_wb16(pb, version); /* Version */\n    avio_wb16(pb, 0); /* Revision level */\n    avio_wb32(pb, 0); /* Reserved */\n\n    if (version == 2) {\n        avio_wb16(pb, 3);\n        avio_wb16(pb, 16);\n        avio_wb16(pb, 0xfffe);\n        avio_wb16(pb, 0);\n        avio_wb32(pb, 0x00010000);\n        avio_wb32(pb, 72);\n        avio_wb64(pb, av_double2int(track->par->sample_rate));\n        avio_wb32(pb, track->par->channels);\n        avio_wb32(pb, 0x7F000000);\n        avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));\n        avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));\n        avio_wb32(pb, track->sample_size);\n        avio_wb32(pb, get_samples_per_packet(track));\n    } else {\n        if (track->mode == MODE_MOV) {\n            avio_wb16(pb, track->par->channels);\n            if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||\n                track->par->codec_id == AV_CODEC_ID_PCM_S8)\n                avio_wb16(pb, 8); /* bits per sample */\n            else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)\n                avio_wb16(pb, track->par->bits_per_coded_sample);\n            else\n                avio_wb16(pb, 16);\n            avio_wb16(pb, track->audio_vbr ? -2 : 0); /* compression ID */\n        } else { /* reserved for mp4/3gp */\n            avio_wb16(pb, 2);\n            avio_wb16(pb, 16);\n            avio_wb16(pb, 0);\n        }\n\n        avio_wb16(pb, 0); /* packet size (= 0) */\n        avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?\n                      track->par->sample_rate : 0);\n        avio_wb16(pb, 0); /* Reserved */\n    }\n\n    if (version == 1) { /* SoundDescription V1 extended info */\n        if (mov_pcm_le_gt16(track->par->codec_id) ||\n            mov_pcm_be_gt16(track->par->codec_id))\n            avio_wb32(pb, 1); /*  must be 1 for  uncompressed formats */\n        else\n            avio_wb32(pb, track->par->frame_size); /* Samples per packet */\n        avio_wb32(pb, track->sample_size / track->par->channels); /* Bytes per packet */\n        avio_wb32(pb, track->sample_size); /* Bytes per frame */\n        avio_wb32(pb, 2); /* Bytes per sample */\n    }\n\n    if (track->mode == MODE_MOV &&\n        (track->par->codec_id == AV_CODEC_ID_AAC           ||\n         track->par->codec_id == AV_CODEC_ID_AC3           ||\n         track->par->codec_id == AV_CODEC_ID_EAC3          ||\n         track->par->codec_id == AV_CODEC_ID_AMR_NB        ||\n         track->par->codec_id == AV_CODEC_ID_ALAC          ||\n         track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||\n         track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||\n         track->par->codec_id == AV_CODEC_ID_QDM2          ||\n         (mov_pcm_le_gt16(track->par->codec_id) && version==1) ||\n         (mov_pcm_be_gt16(track->par->codec_id) && version==1)))\n        mov_write_wave_tag(s, pb, track);\n    else if (track->tag == MKTAG('m','p','4','a'))\n        mov_write_esds_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)\n        mov_write_amr_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_AC3)\n        mov_write_ac3_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_EAC3)\n        mov_write_eac3_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_ALAC)\n        mov_write_extradata_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)\n        mov_write_wfex_tag(s, pb, track);\n    else if (track->vos_len > 0)\n        mov_write_glbl_tag(pb, track);\n\n    if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_chan_tag(s, pb, track);\n\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_d263_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 0xf); /* size */\n    ffio_wfourcc(pb, \"d263\");\n    ffio_wfourcc(pb, \"FFMP\");\n    avio_w8(pb, 0); /* decoder version */\n    /* FIXME use AVCodecContext level/profile, when encoder will set values */\n    avio_w8(pb, 0xa); /* level */\n    avio_w8(pb, 0); /* profile */\n    return 0xf;\n}\n\nstatic int mov_write_avcc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"avcC\");\n    ff_isom_write_avcc(pb, track->vos_data, track->vos_len);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); /* version & flags */\n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_hvcc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"hvcC\");\n    ff_isom_write_hvcc(pb, track->vos_data, track->vos_len, 0);\n    return update_size(pb, pos);\n}\n\n/* also used by all avid codecs (dv, imx, meridien) and their variants */\nstatic int mov_write_avid_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    int interlaced;\n    int cid;\n    int display_width = track->par->width;\n\n    if (track->vos_data && track->vos_len > 0x29) {\n        if (ff_dnxhd_parse_header_prefix(track->vos_data) != 0) {\n            /* looks like a DNxHD bit stream */\n            interlaced = (track->vos_data[5] & 2);\n            cid = AV_RB32(track->vos_data + 0x28);\n        } else {\n            av_log(NULL, AV_LOG_WARNING, \"Could not locate DNxHD bit stream in vos_data\\n\");\n            return 0;\n        }\n    } else {\n        av_log(NULL, AV_LOG_WARNING, \"Could not locate DNxHD bit stream, vos_data too small\\n\");\n        return 0;\n    }\n\n    avio_wb32(pb, 24); /* size */\n    ffio_wfourcc(pb, \"ACLR\");\n    ffio_wfourcc(pb, \"ACLR\");\n    ffio_wfourcc(pb, \"0001\");\n    if (track->par->color_range == AVCOL_RANGE_MPEG || /* Legal range (16-235) */\n        track->par->color_range == AVCOL_RANGE_UNSPECIFIED) {\n        avio_wb32(pb, 1); /* Corresponds to 709 in official encoder */\n    } else { /* Full range (0-255) */\n        avio_wb32(pb, 2); /* Corresponds to RGB in official encoder */\n    }\n    avio_wb32(pb, 0); /* unknown */\n\n    if (track->tag == MKTAG('A','V','d','h')) {\n        avio_wb32(pb, 32);\n        ffio_wfourcc(pb, \"ADHR\");\n        ffio_wfourcc(pb, \"0001\");\n        avio_wb32(pb, cid);\n        avio_wb32(pb, 0); /* unknown */\n        avio_wb32(pb, 1); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        return 0;\n    }\n\n    avio_wb32(pb, 24); /* size */\n    ffio_wfourcc(pb, \"APRG\");\n    ffio_wfourcc(pb, \"APRG\");\n    ffio_wfourcc(pb, \"0001\");\n    avio_wb32(pb, 1); /* unknown */\n    avio_wb32(pb, 0); /* unknown */\n\n    avio_wb32(pb, 120); /* size */\n    ffio_wfourcc(pb, \"ARES\");\n    ffio_wfourcc(pb, \"ARES\");\n    ffio_wfourcc(pb, \"0001\");\n    avio_wb32(pb, cid); /* dnxhd cid, some id ? */\n    if (   track->par->sample_aspect_ratio.num > 0\n        && track->par->sample_aspect_ratio.den > 0)\n        display_width = display_width * track->par->sample_aspect_ratio.num / track->par->sample_aspect_ratio.den;\n    avio_wb32(pb, display_width);\n    /* values below are based on samples created with quicktime and avid codecs */\n    if (interlaced) {\n        avio_wb32(pb, track->par->height / 2);\n        avio_wb32(pb, 2); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        avio_wb32(pb, 4); /* unknown */\n    } else {\n        avio_wb32(pb, track->par->height);\n        avio_wb32(pb, 1); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        if (track->par->height == 1080)\n            avio_wb32(pb, 5); /* unknown */\n        else\n            avio_wb32(pb, 6); /* unknown */\n    }\n    /* padding */\n    for (i = 0; i < 10; i++)\n        avio_wb64(pb, 0);\n\n    return 0;\n}\n\nstatic int mov_write_dpxe_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 12);\n    ffio_wfourcc(pb, \"DpxE\");\n    if (track->par->extradata_size >= 12 &&\n        !memcmp(&track->par->extradata[4], \"DpxE\", 4)) {\n        avio_wb32(pb, track->par->extradata[11]);\n    } else {\n        avio_wb32(pb, 1);\n    }\n    return 0;\n}\n\nstatic int mp4_get_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n\n    if (!ff_codec_get_tag(ff_mp4_obj_type, track->par->codec_id))\n        return 0;\n\n    if      (track->par->codec_id == AV_CODEC_ID_H264)      tag = MKTAG('a','v','c','1');\n    else if (track->par->codec_id == AV_CODEC_ID_HEVC)      tag = MKTAG('h','e','v','1');\n    else if (track->par->codec_id == AV_CODEC_ID_VP9)       tag = MKTAG('v','p','0','9');\n    else if (track->par->codec_id == AV_CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');\n    else if (track->par->codec_id == AV_CODEC_ID_EAC3)      tag = MKTAG('e','c','-','3');\n    else if (track->par->codec_id == AV_CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');\n    else if (track->par->codec_id == AV_CODEC_ID_MOV_TEXT)  tag = MKTAG('t','x','3','g');\n    else if (track->par->codec_id == AV_CODEC_ID_VC1)       tag = MKTAG('v','c','-','1');\n    else if (track->par->codec_type == AVMEDIA_TYPE_VIDEO)  tag = MKTAG('m','p','4','v');\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)  tag = MKTAG('m','p','4','a');\n    else if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)  tag = MKTAG('m','p','4','s');\n\n    return tag;\n}\n\nstatic const AVCodecTag codec_ipod_tags[] = {\n    { AV_CODEC_ID_H264,     MKTAG('a','v','c','1') },\n    { AV_CODEC_ID_MPEG4,    MKTAG('m','p','4','v') },\n    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },\n    { AV_CODEC_ID_ALAC,     MKTAG('a','l','a','c') },\n    { AV_CODEC_ID_AC3,      MKTAG('a','c','-','3') },\n    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },\n    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','e','x','t') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic int ipod_get_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n\n    // keep original tag for subs, ipod supports both formats\n    if (!(track->par->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n          (tag == MKTAG('t', 'x', '3', 'g') ||\n           tag == MKTAG('t', 'e', 'x', 't'))))\n        tag = ff_codec_get_tag(codec_ipod_tags, track->par->codec_id);\n\n    if (!av_match_ext(s->filename, \"m4a\") &&\n        !av_match_ext(s->filename, \"m4b\") &&\n        !av_match_ext(s->filename, \"m4v\"))\n        av_log(s, AV_LOG_WARNING, \"Warning, extension is not .m4a, .m4v nor  .m4b \"\n               \"Quicktime/Ipod might not play the file\\n\");\n\n    return tag;\n}\n\nstatic int mov_get_dv_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag;\n\n    if (track->par->width == 720) { /* SD */\n        if (track->par->height == 480) { /* NTSC */\n            if  (track->par->format == AV_PIX_FMT_YUV422P) tag = MKTAG('d','v','5','n');\n            else                                            tag = MKTAG('d','v','c',' ');\n       }else if (track->par->format == AV_PIX_FMT_YUV422P) tag = MKTAG('d','v','5','p');\n        else if (track->par->format == AV_PIX_FMT_YUV420P) tag = MKTAG('d','v','c','p');\n        else                                                tag = MKTAG('d','v','p','p');\n    } else if (track->par->height == 720) { /* HD 720 line */\n        if  (track->st->time_base.den == 50)                tag = MKTAG('d','v','h','q');\n        else                                                tag = MKTAG('d','v','h','p');\n    } else if (track->par->height == 1080) { /* HD 1080 line */\n        if  (track->st->time_base.den == 25)                tag = MKTAG('d','v','h','5');\n        else                                                tag = MKTAG('d','v','h','6');\n    } else {\n        av_log(s, AV_LOG_ERROR, \"unsupported height for dv codec\\n\");\n        return 0;\n    }\n\n    return tag;\n}\n\nstatic AVRational find_fps(AVFormatContext *s, AVStream *st)\n{\n    AVRational rate = st->avg_frame_rate;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    rate = av_inv_q(st->codec->time_base);\n    if (av_timecode_check_frame_rate(rate) < 0) {\n        av_log(s, AV_LOG_DEBUG, \"timecode: tbc=%d/%d invalid, fallback on %d/%d\\n\",\n               rate.num, rate.den, st->avg_frame_rate.num, st->avg_frame_rate.den);\n        rate = st->avg_frame_rate;\n    }\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    return rate;\n}\n\nstatic int mov_get_mpeg2_xdcam_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n    int interlaced = track->par->field_order > AV_FIELD_PROGRESSIVE;\n    AVStream *st = track->st;\n    int rate = av_q2d(find_fps(s, st));\n\n    if (!tag)\n        tag = MKTAG('m', '2', 'v', '1'); //fallback tag\n\n    if (track->par->format == AV_PIX_FMT_YUV420P) {\n        if (track->par->width == 1280 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','v','4');\n                else if (rate == 25) tag = MKTAG('x','d','v','5');\n                else if (rate == 30) tag = MKTAG('x','d','v','1');\n                else if (rate == 50) tag = MKTAG('x','d','v','a');\n                else if (rate == 60) tag = MKTAG('x','d','v','9');\n            }\n        } else if (track->par->width == 1440 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','v','6');\n                else if (rate == 25) tag = MKTAG('x','d','v','7');\n                else if (rate == 30) tag = MKTAG('x','d','v','8');\n            } else {\n                if      (rate == 25) tag = MKTAG('x','d','v','3');\n                else if (rate == 30) tag = MKTAG('x','d','v','2');\n            }\n        } else if (track->par->width == 1920 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','v','d');\n                else if (rate == 25) tag = MKTAG('x','d','v','e');\n                else if (rate == 30) tag = MKTAG('x','d','v','f');\n            } else {\n                if      (rate == 25) tag = MKTAG('x','d','v','c');\n                else if (rate == 30) tag = MKTAG('x','d','v','b');\n            }\n        }\n    } else if (track->par->format == AV_PIX_FMT_YUV422P) {\n        if (track->par->width == 1280 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','5','4');\n                else if (rate == 25) tag = MKTAG('x','d','5','5');\n                else if (rate == 30) tag = MKTAG('x','d','5','1');\n                else if (rate == 50) tag = MKTAG('x','d','5','a');\n                else if (rate == 60) tag = MKTAG('x','d','5','9');\n            }\n        } else if (track->par->width == 1920 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','5','d');\n                else if (rate == 25) tag = MKTAG('x','d','5','e');\n                else if (rate == 30) tag = MKTAG('x','d','5','f');\n            } else {\n                if      (rate == 25) tag = MKTAG('x','d','5','c');\n                else if (rate == 30) tag = MKTAG('x','d','5','b');\n            }\n        }\n    }\n\n    return tag;\n}\n\nstatic int mov_get_h264_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n    int interlaced = track->par->field_order > AV_FIELD_PROGRESSIVE;\n    AVStream *st = track->st;\n    int rate = av_q2d(find_fps(s, st));\n\n    if (!tag)\n        tag = MKTAG('a', 'v', 'c', 'i'); //fallback tag\n\n    if (track->par->format == AV_PIX_FMT_YUV420P10) {\n        if (track->par->width == 960 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','5','p');\n                else if (rate == 25) tag = MKTAG('a','i','5','q');\n                else if (rate == 30) tag = MKTAG('a','i','5','p');\n                else if (rate == 50) tag = MKTAG('a','i','5','q');\n                else if (rate == 60) tag = MKTAG('a','i','5','p');\n            }\n        } else if (track->par->width == 1440 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','5','3');\n                else if (rate == 25) tag = MKTAG('a','i','5','2');\n                else if (rate == 30) tag = MKTAG('a','i','5','3');\n            } else {\n                if      (rate == 50) tag = MKTAG('a','i','5','5');\n                else if (rate == 60) tag = MKTAG('a','i','5','6');\n            }\n        }\n    } else if (track->par->format == AV_PIX_FMT_YUV422P10) {\n        if (track->par->width == 1280 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','1','p');\n                else if (rate == 25) tag = MKTAG('a','i','1','q');\n                else if (rate == 30) tag = MKTAG('a','i','1','p');\n                else if (rate == 50) tag = MKTAG('a','i','1','q');\n                else if (rate == 60) tag = MKTAG('a','i','1','p');\n            }\n        } else if (track->par->width == 1920 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','1','3');\n                else if (rate == 25) tag = MKTAG('a','i','1','2');\n                else if (rate == 30) tag = MKTAG('a','i','1','3');\n            } else {\n                if      (rate == 25) tag = MKTAG('a','i','1','5');\n                else if (rate == 50) tag = MKTAG('a','i','1','5');\n                else if (rate == 60) tag = MKTAG('a','i','1','6');\n            }\n        } else if (   track->par->width == 4096 && track->par->height == 2160\n                   || track->par->width == 3840 && track->par->height == 2160\n                   || track->par->width == 2048 && track->par->height == 1080) {\n            tag = MKTAG('a','i','v','x');\n        }\n    }\n\n    return tag;\n}\n\nstatic const struct {\n    enum AVPixelFormat pix_fmt;\n    uint32_t tag;\n    unsigned bps;\n} mov_pix_fmt_tags[] = {\n    { AV_PIX_FMT_YUYV422, MKTAG('y','u','v','2'),  0 },\n    { AV_PIX_FMT_YUYV422, MKTAG('y','u','v','s'),  0 },\n    { AV_PIX_FMT_UYVY422, MKTAG('2','v','u','y'),  0 },\n    { AV_PIX_FMT_RGB555BE,MKTAG('r','a','w',' '), 16 },\n    { AV_PIX_FMT_RGB555LE,MKTAG('L','5','5','5'), 16 },\n    { AV_PIX_FMT_RGB565LE,MKTAG('L','5','6','5'), 16 },\n    { AV_PIX_FMT_RGB565BE,MKTAG('B','5','6','5'), 16 },\n    { AV_PIX_FMT_GRAY16BE,MKTAG('b','1','6','g'), 16 },\n    { AV_PIX_FMT_RGB24,   MKTAG('r','a','w',' '), 24 },\n    { AV_PIX_FMT_BGR24,   MKTAG('2','4','B','G'), 24 },\n    { AV_PIX_FMT_ARGB,    MKTAG('r','a','w',' '), 32 },\n    { AV_PIX_FMT_BGRA,    MKTAG('B','G','R','A'), 32 },\n    { AV_PIX_FMT_RGBA,    MKTAG('R','G','B','A'), 32 },\n    { AV_PIX_FMT_ABGR,    MKTAG('A','B','G','R'), 32 },\n    { AV_PIX_FMT_RGB48BE, MKTAG('b','4','8','r'), 48 },\n};\n\nstatic int mov_get_dnxhd_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n  int tag = MKTAG('A','V','d','n');\n  if (track->par->profile != FF_PROFILE_UNKNOWN &&\n      track->par->profile != FF_PROFILE_DNXHD)\n      tag = MKTAG('A','V','d','h');\n  return tag;\n}\n\nstatic int mov_get_rawvideo_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n    int i;\n    enum AVPixelFormat pix_fmt;\n\n    for (i = 0; i < FF_ARRAY_ELEMS(mov_pix_fmt_tags); i++) {\n        if (track->par->format == mov_pix_fmt_tags[i].pix_fmt) {\n            tag = mov_pix_fmt_tags[i].tag;\n            track->par->bits_per_coded_sample = mov_pix_fmt_tags[i].bps;\n            if (track->par->codec_tag == mov_pix_fmt_tags[i].tag)\n                break;\n        }\n    }\n\n    pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_mov,\n                                  track->par->bits_per_coded_sample);\n    if (tag == MKTAG('r','a','w',' ') &&\n        track->par->format != pix_fmt &&\n        track->par->format != AV_PIX_FMT_NONE)\n        av_log(s, AV_LOG_ERROR, \"%s rawvideo cannot be written to mov, output file will be unreadable\\n\",\n               av_get_pix_fmt_name(track->par->format));\n    return tag;\n}\n\nstatic int mov_get_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n\n    if (!tag || (s->strict_std_compliance >= FF_COMPLIANCE_NORMAL &&\n                 (track->par->codec_id == AV_CODEC_ID_DVVIDEO ||\n                  track->par->codec_id == AV_CODEC_ID_RAWVIDEO ||\n                  track->par->codec_id == AV_CODEC_ID_H263 ||\n                  track->par->codec_id == AV_CODEC_ID_H264 ||\n                  track->par->codec_id == AV_CODEC_ID_DNXHD ||\n                  track->par->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n                  av_get_bits_per_sample(track->par->codec_id)))) { // pcm audio\n        if (track->par->codec_id == AV_CODEC_ID_DVVIDEO)\n            tag = mov_get_dv_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_RAWVIDEO)\n            tag = mov_get_rawvideo_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_MPEG2VIDEO)\n            tag = mov_get_mpeg2_xdcam_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_H264)\n            tag = mov_get_h264_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_DNXHD)\n            tag = mov_get_dnxhd_codec_tag(s, track);\n        else if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            tag = ff_codec_get_tag(ff_codec_movvideo_tags, track->par->codec_id);\n            if (!tag) { // if no mac fcc found, try with Microsoft tags\n                tag = ff_codec_get_tag(ff_codec_bmp_tags, track->par->codec_id);\n                if (tag)\n                    av_log(s, AV_LOG_WARNING, \"Using MS style video codec tag, \"\n                           \"the file may be unplayable!\\n\");\n            }\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            tag = ff_codec_get_tag(ff_codec_movaudio_tags, track->par->codec_id);\n            if (!tag) { // if no mac fcc found, try with Microsoft tags\n                int ms_tag = ff_codec_get_tag(ff_codec_wav_tags, track->par->codec_id);\n                if (ms_tag) {\n                    tag = MKTAG('m', 's', ((ms_tag >> 8) & 0xff), (ms_tag & 0xff));\n                    av_log(s, AV_LOG_WARNING, \"Using MS style audio codec tag, \"\n                           \"the file may be unplayable!\\n\");\n                }\n            }\n        } else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)\n            tag = ff_codec_get_tag(ff_codec_movsubtitle_tags, track->par->codec_id);\n    }\n\n    return tag;\n}\n\nstatic const AVCodecTag codec_3gp_tags[] = {\n    { AV_CODEC_ID_H263,     MKTAG('s','2','6','3') },\n    { AV_CODEC_ID_H264,     MKTAG('a','v','c','1') },\n    { AV_CODEC_ID_MPEG4,    MKTAG('m','p','4','v') },\n    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },\n    { AV_CODEC_ID_AMR_NB,   MKTAG('s','a','m','r') },\n    { AV_CODEC_ID_AMR_WB,   MKTAG('s','a','w','b') },\n    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic const AVCodecTag codec_f4v_tags[] = { // XXX: add GIF/PNG/JPEG?\n    { AV_CODEC_ID_MP3,    MKTAG('.','m','p','3') },\n    { AV_CODEC_ID_AAC,    MKTAG('m','p','4','a') },\n    { AV_CODEC_ID_H264,   MKTAG('a','v','c','1') },\n    { AV_CODEC_ID_VP6A,   MKTAG('V','P','6','A') },\n    { AV_CODEC_ID_VP6F,   MKTAG('V','P','6','F') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag;\n\n    if (track->mode == MODE_MP4 || track->mode == MODE_PSP)\n        tag = mp4_get_codec_tag(s, track);\n    else if (track->mode == MODE_ISM) {\n        tag = mp4_get_codec_tag(s, track);\n        if (!tag && track->par->codec_id == AV_CODEC_ID_WMAPRO)\n            tag = MKTAG('w', 'm', 'a', ' ');\n    } else if (track->mode == MODE_IPOD)\n        tag = ipod_get_codec_tag(s, track);\n    else if (track->mode & MODE_3GP)\n        tag = ff_codec_get_tag(codec_3gp_tags, track->par->codec_id);\n    else if (track->mode == MODE_F4V)\n        tag = ff_codec_get_tag(codec_f4v_tags, track->par->codec_id);\n    else\n        tag = mov_get_codec_tag(s, track);\n\n    return tag;\n}\n\n/** Write uuid atom.\n * Needed to make file play in iPods running newest firmware\n * goes after avcC atom in moov.trak.mdia.minf.stbl.stsd.avc1\n */\nstatic int mov_write_uuid_tag_ipod(AVIOContext *pb)\n{\n    avio_wb32(pb, 28);\n    ffio_wfourcc(pb, \"uuid\");\n    avio_wb32(pb, 0x6b6840f2);\n    avio_wb32(pb, 0x5f244fc5);\n    avio_wb32(pb, 0xba39a51b);\n    avio_wb32(pb, 0xcf0323f3);\n    avio_wb32(pb, 0x0);\n    return 28;\n}\n\nstatic const uint16_t fiel_data[] = {\n    0x0000, 0x0100, 0x0201, 0x0206, 0x0209, 0x020e\n};\n\nstatic int mov_write_fiel_tag(AVIOContext *pb, MOVTrack *track, int field_order)\n{\n    unsigned mov_field_order = 0;\n    if (field_order < FF_ARRAY_ELEMS(fiel_data))\n        mov_field_order = fiel_data[field_order];\n    else\n        return 0;\n    avio_wb32(pb, 10);\n    ffio_wfourcc(pb, \"fiel\");\n    avio_wb16(pb, mov_field_order);\n    return 10;\n}\n\nstatic int mov_write_subtitle_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);    /* size */\n    avio_wl32(pb, track->tag); // store it byteswapped\n    avio_wb32(pb, 0);    /* Reserved */\n    avio_wb16(pb, 0);    /* Reserved */\n    avio_wb16(pb, 1);    /* Data-reference index */\n\n    if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n        mov_write_esds_tag(pb, track);\n    else if (track->par->extradata_size)\n        avio_write(pb, track->par->extradata, track->par->extradata_size);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_pasp_tag(AVIOContext *pb, MOVTrack *track)\n{\n    AVRational sar;\n    av_reduce(&sar.num, &sar.den, track->par->sample_aspect_ratio.num,\n              track->par->sample_aspect_ratio.den, INT_MAX);\n\n    avio_wb32(pb, 16);\n    ffio_wfourcc(pb, \"pasp\");\n    avio_wb32(pb, sar.num);\n    avio_wb32(pb, sar.den);\n    return 16;\n}\n\nstatic int mov_write_gama_tag(AVIOContext *pb, MOVTrack *track, double gamma)\n{\n    uint32_t gama = 0;\n    if (gamma <= 0.0)\n    {\n        gamma = avpriv_get_gamma_from_trc(track->par->color_trc);\n    }\n    av_log(pb, AV_LOG_DEBUG, \"gamma value %g\\n\", gamma);\n\n    if (gamma > 1e-6) {\n        gama = (uint32_t)lrint((double)(1<<16) * gamma);\n        av_log(pb, AV_LOG_DEBUG, \"writing gama value %d\\n\", gama);\n\n        av_assert0(track->mode == MODE_MOV);\n        avio_wb32(pb, 12);\n        ffio_wfourcc(pb, \"gama\");\n        avio_wb32(pb, gama);\n        return 12;\n    }\n    else {\n        av_log(pb, AV_LOG_WARNING, \"gamma value unknown, unable to write gama atom\\n\");\n    }\n    return 0;\n}\n\nstatic int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)\n{\n    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9\n    // Ref (MP4): ISO/IEC 14496-12:2012\n\n    if (track->par->color_primaries == AVCOL_PRI_UNSPECIFIED &&\n        track->par->color_trc == AVCOL_TRC_UNSPECIFIED &&\n        track->par->color_space == AVCOL_SPC_UNSPECIFIED) {\n        if ((track->par->width >= 1920 && track->par->height >= 1080)\n          || (track->par->width == 1280 && track->par->height == 720)) {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt709\\n\");\n            track->par->color_primaries = AVCOL_PRI_BT709;\n        } else if (track->par->width == 720 && track->height == 576) {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt470bg\\n\");\n            track->par->color_primaries = AVCOL_PRI_BT470BG;\n        } else if (track->par->width == 720 &&\n                   (track->height == 486 || track->height == 480)) {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming smpte170\\n\");\n            track->par->color_primaries = AVCOL_PRI_SMPTE170M;\n        } else {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, unable to assume anything\\n\");\n        }\n        switch (track->par->color_primaries) {\n        case AVCOL_PRI_BT709:\n            track->par->color_trc = AVCOL_TRC_BT709;\n            track->par->color_space = AVCOL_SPC_BT709;\n            break;\n        case AVCOL_PRI_SMPTE170M:\n        case AVCOL_PRI_BT470BG:\n            track->par->color_trc = AVCOL_TRC_BT709;\n            track->par->color_space = AVCOL_SPC_SMPTE170M;\n            break;\n        }\n    }\n\n    /* We should only ever be called by MOV or MP4. */\n    av_assert0(track->mode == MODE_MOV || track->mode == MODE_MP4);\n\n    avio_wb32(pb, 18 + (track->mode == MODE_MP4));\n    ffio_wfourcc(pb, \"colr\");\n    if (track->mode == MODE_MP4)\n        ffio_wfourcc(pb, \"nclx\");\n    else\n        ffio_wfourcc(pb, \"nclc\");\n    switch (track->par->color_primaries) {\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n    case AVCOL_PRI_SMPTE170M:\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n    default:                  avio_wb16(pb, 2);\n    }\n    switch (track->par->color_trc) {\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n    default:                  avio_wb16(pb, 2);\n    }\n    switch (track->par->color_space) {\n    case AVCOL_SPC_BT709:     avio_wb16(pb, 1); break;\n    case AVCOL_SPC_BT470BG:\n    case AVCOL_SPC_SMPTE170M: avio_wb16(pb, 6); break;\n    case AVCOL_SPC_SMPTE240M: avio_wb16(pb, 7); break;\n    default:                  avio_wb16(pb, 2);\n    }\n\n    if (track->mode == MODE_MP4) {\n        int full_range = track->par->color_range == AVCOL_RANGE_JPEG;\n        avio_w8(pb, full_range << 7);\n        return 19;\n    } else {\n        return 18;\n    }\n}\n\nstatic void find_compressor(char * compressor_name, int len, MOVTrack *track)\n{\n    AVDictionaryEntry *encoder;\n    int xdcam_res =  (track->par->width == 1280 && track->par->height == 720)\n                  || (track->par->width == 1440 && track->par->height == 1080)\n                  || (track->par->width == 1920 && track->par->height == 1080);\n\n    if (track->mode == MODE_MOV &&\n        (encoder = av_dict_get(track->st->metadata, \"encoder\", NULL, 0))) {\n        av_strlcpy(compressor_name, encoder->value, 32);\n    } else if (track->par->codec_id == AV_CODEC_ID_MPEG2VIDEO && xdcam_res) {\n        int interlaced = track->par->field_order > AV_FIELD_PROGRESSIVE;\n        AVStream *st = track->st;\n        int rate = av_q2d(find_fps(NULL, st));\n        av_strlcatf(compressor_name, len, \"XDCAM\");\n        if (track->par->format == AV_PIX_FMT_YUV422P) {\n            av_strlcatf(compressor_name, len, \" HD422\");\n        } else if(track->par->width == 1440) {\n            av_strlcatf(compressor_name, len, \" HD\");\n        } else\n            av_strlcatf(compressor_name, len, \" EX\");\n\n        av_strlcatf(compressor_name, len, \" %d%c\", track->par->height, interlaced ? 'i' : 'p');\n\n        av_strlcatf(compressor_name, len, \"%d\", rate * (interlaced + 1));\n    }\n}\n\nstatic int mov_write_video_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    char compressor_name[32] = { 0 };\n    int avid = 0;\n\n    avio_wb32(pb, 0); /* size */\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ffio_wfourcc(pb, \"encv\");\n    } else {\n        avio_wl32(pb, track->tag); // store it byteswapped\n    }\n    avio_wb32(pb, 0); /* Reserved */\n    avio_wb16(pb, 0); /* Reserved */\n    avio_wb16(pb, 1); /* Data-reference index */\n\n    avio_wb16(pb, 0); /* Codec stream version */\n    avio_wb16(pb, 0); /* Codec stream revision (=0) */\n    if (track->mode == MODE_MOV) {\n        ffio_wfourcc(pb, \"FFMP\"); /* Vendor */\n        if (track->par->codec_id == AV_CODEC_ID_RAWVIDEO) {\n            avio_wb32(pb, 0); /* Temporal Quality */\n            avio_wb32(pb, 0x400); /* Spatial Quality = lossless*/\n        } else {\n            avio_wb32(pb, 0x200); /* Temporal Quality = normal */\n            avio_wb32(pb, 0x200); /* Spatial Quality = normal */\n        }\n    } else {\n        avio_wb32(pb, 0); /* Reserved */\n        avio_wb32(pb, 0); /* Reserved */\n        avio_wb32(pb, 0); /* Reserved */\n    }\n    avio_wb16(pb, track->par->width); /* Video width */\n    avio_wb16(pb, track->height); /* Video height */\n    avio_wb32(pb, 0x00480000); /* Horizontal resolution 72dpi */\n    avio_wb32(pb, 0x00480000); /* Vertical resolution 72dpi */\n    avio_wb32(pb, 0); /* Data size (= 0) */\n    avio_wb16(pb, 1); /* Frame count (= 1) */\n\n    /* FIXME not sure, ISO 14496-1 draft where it shall be set to 0 */\n    find_compressor(compressor_name, 32, track);\n    avio_w8(pb, strlen(compressor_name));\n    avio_write(pb, compressor_name, 31);\n\n    if (track->mode == MODE_MOV && track->par->bits_per_coded_sample)\n        avio_wb16(pb, track->par->bits_per_coded_sample |\n                  (track->par->format == AV_PIX_FMT_GRAY8 ? 0x20 : 0));\n    else\n        avio_wb16(pb, 0x18); /* Reserved */\n\n    if (track->mode == MODE_MOV && track->par->format == AV_PIX_FMT_PAL8) {\n        int pal_size = 1 << track->par->bits_per_coded_sample;\n        int i;\n        avio_wb16(pb, 0);             /* Color table ID */\n        avio_wb32(pb, 0);             /* Color table seed */\n        avio_wb16(pb, 0x8000);        /* Color table flags */\n        avio_wb16(pb, pal_size - 1);  /* Color table size (zero-relative) */\n        for (i = 0; i < pal_size; i++) {\n            uint32_t rgb = track->palette[i];\n            uint16_t r = (rgb >> 16) & 0xff;\n            uint16_t g = (rgb >> 8)  & 0xff;\n            uint16_t b = rgb         & 0xff;\n            avio_wb16(pb, 0);\n            avio_wb16(pb, (r << 8) | r);\n            avio_wb16(pb, (g << 8) | g);\n            avio_wb16(pb, (b << 8) | b);\n        }\n    } else\n        avio_wb16(pb, 0xffff); /* Reserved */\n\n    if (track->tag == MKTAG('m','p','4','v'))\n        mov_write_esds_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_H263)\n        mov_write_d263_tag(pb);\n    else if (track->par->codec_id == AV_CODEC_ID_AVUI ||\n            track->par->codec_id == AV_CODEC_ID_SVQ3) {\n        mov_write_extradata_tag(pb, track);\n        avio_wb32(pb, 0);\n    } else if (track->par->codec_id == AV_CODEC_ID_DNXHD) {\n        mov_write_avid_tag(pb, track);\n        avid = 1;\n    } else if (track->par->codec_id == AV_CODEC_ID_HEVC)\n        mov_write_hvcc_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_H264 && !TAG_IS_AVCI(track->tag)) {\n        mov_write_avcc_tag(pb, track);\n        if (track->mode == MODE_IPOD)\n            mov_write_uuid_tag_ipod(pb);\n    } else if (track->par->codec_id == AV_CODEC_ID_VP9) {\n        mov_write_vpcc_tag(mov->fc, pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_VC1 && track->vos_len > 0)\n        mov_write_dvc1_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_VP6F ||\n             track->par->codec_id == AV_CODEC_ID_VP6A) {\n        /* Don't write any potential extradata here - the cropping\n         * is signalled via the normal width/height fields. */\n    } else if (track->par->codec_id == AV_CODEC_ID_R10K) {\n        if (track->par->codec_tag == MKTAG('R','1','0','k'))\n            mov_write_dpxe_tag(pb, track);\n    } else if (track->vos_len > 0)\n        mov_write_glbl_tag(pb, track);\n\n    if (track->par->codec_id != AV_CODEC_ID_H264 &&\n        track->par->codec_id != AV_CODEC_ID_MPEG4 &&\n        track->par->codec_id != AV_CODEC_ID_DNXHD) {\n        int field_order = track->par->field_order;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    if (field_order != track->st->codec->field_order && track->st->codec->field_order != AV_FIELD_UNKNOWN)\n        field_order = track->st->codec->field_order;\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (field_order != AV_FIELD_UNKNOWN)\n            mov_write_fiel_tag(pb, track, field_order);\n    }\n\n    if (mov->flags & FF_MOV_FLAG_WRITE_GAMA) {\n        if (track->mode == MODE_MOV)\n            mov_write_gama_tag(pb, track, mov->gamma);\n        else\n            av_log(mov->fc, AV_LOG_WARNING, \"Not writing 'gama' atom. Format is not MOV.\\n\");\n    }\n    if (mov->flags & FF_MOV_FLAG_WRITE_COLR) {\n        if (track->mode == MODE_MOV || track->mode == MODE_MP4)\n            mov_write_colr_tag(pb, track);\n        else\n            av_log(mov->fc, AV_LOG_WARNING, \"Not writing 'colr' atom. Format is not MOV or MP4.\\n\");\n    }\n\n    if (track->par->sample_aspect_ratio.den && track->par->sample_aspect_ratio.num) {\n        mov_write_pasp_tag(pb, track);\n    }\n\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);\n    }\n\n    /* extra padding for avid stsd */\n    /* https://developer.apple.com/library/mac/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-61112 */\n    if (avid)\n        avio_wb32(pb, 0);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_rtp_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"rtp \");\n    avio_wb32(pb, 0); /* Reserved */\n    avio_wb16(pb, 0); /* Reserved */\n    avio_wb16(pb, 1); /* Data-reference index */\n\n    avio_wb16(pb, 1); /* Hint track version */\n    avio_wb16(pb, 1); /* Highest compatible version */\n    avio_wb32(pb, track->max_packet_size); /* Max packet size */\n\n    avio_wb32(pb, 12); /* size */\n    ffio_wfourcc(pb, \"tims\");\n    avio_wb32(pb, track->timescale);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_source_reference_tag(AVIOContext *pb, MOVTrack *track, const char *reel_name)\n{\n    uint64_t str_size =strlen(reel_name);\n    int64_t pos = avio_tell(pb);\n\n    if (str_size >= UINT16_MAX){\n        av_log(NULL, AV_LOG_ERROR, \"reel_name length %\"PRIu64\" is too large\\n\", str_size);\n        avio_wb16(pb, 0);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb32(pb, 0);                              /* size */\n    ffio_wfourcc(pb, \"name\");                      /* Data format */\n    avio_wb16(pb, str_size);                       /* string size */\n    avio_wb16(pb, track->language);                /* langcode */\n    avio_write(pb, reel_name, str_size);           /* reel name */\n    return update_size(pb,pos);\n}\n\nstatic int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n#if 1\n    int frame_duration;\n    int nb_frames;\n    AVDictionaryEntry *t = NULL;\n\n    if (!track->st->avg_frame_rate.num || !track->st->avg_frame_rate.den) {\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n        frame_duration = av_rescale(track->timescale, track->st->codec->time_base.num, track->st->codec->time_base.den);\n        nb_frames      = ROUNDED_DIV(track->st->codec->time_base.den, track->st->codec->time_base.num);\n    FF_ENABLE_DEPRECATION_WARNINGS\n#else\n        av_log(NULL, AV_LOG_ERROR, \"avg_frame_rate not set for tmcd track.\\n\");\n        return AVERROR(EINVAL);\n#endif\n    } else {\n        frame_duration = av_rescale(track->timescale, track->st->avg_frame_rate.num, track->st->avg_frame_rate.den);\n        nb_frames      = ROUNDED_DIV(track->st->avg_frame_rate.den, track->st->avg_frame_rate.num);\n    }\n\n    if (nb_frames > 255) {\n        av_log(NULL, AV_LOG_ERROR, \"fps %d is too large\\n\", nb_frames);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n    avio_wb32(pb, 0);                       /* Reserved */\n    avio_wb32(pb, 1);                       /* Data reference index */\n    avio_wb32(pb, 0);                       /* Flags */\n    avio_wb32(pb, track->timecode_flags);   /* Flags (timecode) */\n    avio_wb32(pb, track->timescale);        /* Timescale */\n    avio_wb32(pb, frame_duration);          /* Frame duration */\n    avio_w8(pb, nb_frames);                 /* Number of frames */\n    avio_w8(pb, 0);                         /* Reserved */\n\n    t = av_dict_get(track->st->metadata, \"reel_name\", NULL, 0);\n    if (t && utf8len(t->value) && track->mode != MODE_MP4)\n        mov_write_source_reference_tag(pb, track, t->value);\n    else\n        avio_wb16(pb, 0); /* zero size */\n#else\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n    avio_wb32(pb, 0);                       /* Reserved */\n    avio_wb32(pb, 1);                       /* Data reference index */\n    if (track->par->extradata_size)\n        avio_write(pb, track->par->extradata, track->par->extradata_size);\n#endif\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_stsd_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stsd\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, 1); /* entry count */\n    if (track->par->codec_type == AVMEDIA_TYPE_VIDEO)\n        mov_write_video_tag(pb, mov, track);\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_audio_tag(s, pb, mov, track);\n    else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)\n        mov_write_subtitle_tag(pb, track);\n    else if (track->par->codec_tag == MKTAG('r','t','p',' '))\n        mov_write_rtp_tag(pb, track);\n    else if (track->par->codec_tag == MKTAG('t','m','c','d'))\n        mov_write_tmcd_tag(pb, track);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_ctts_tag(AVIOContext *pb, MOVTrack *track)\n{\n    MOVStts *ctts_entries;\n    uint32_t entries = 0;\n    uint32_t atom_size;\n    int i;\n\n    ctts_entries = av_malloc_array((track->entry + 1), sizeof(*ctts_entries)); /* worst case */\n    if (!ctts_entries)\n        return AVERROR(ENOMEM);\n    ctts_entries[0].count = 1;\n    ctts_entries[0].duration = track->cluster[0].cts;\n    for (i = 1; i < track->entry; i++) {\n        if (track->cluster[i].cts == ctts_entries[entries].duration) {\n            ctts_entries[entries].count++; /* compress */\n        } else {\n            entries++;\n            ctts_entries[entries].duration = track->cluster[i].cts;\n            ctts_entries[entries].count = 1;\n        }\n    }\n    entries++; /* last one */\n    atom_size = 16 + (entries * 8);\n    avio_wb32(pb, atom_size); /* size */\n    ffio_wfourcc(pb, \"ctts\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, entries); /* entry count */\n    for (i = 0; i < entries; i++) {\n        avio_wb32(pb, ctts_entries[i].count);\n        avio_wb32(pb, ctts_entries[i].duration);\n    }\n    av_free(ctts_entries);\n    return atom_size;\n}\n\n/* Time to sample atom */\nstatic int mov_write_stts_tag(AVIOContext *pb, MOVTrack *track)\n{\n    MOVStts *stts_entries = NULL;\n    uint32_t entries = -1;\n    uint32_t atom_size;\n    int i;\n\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO && !track->audio_vbr) {\n        stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */\n        if (!stts_entries)\n            return AVERROR(ENOMEM);\n        stts_entries[0].count = track->sample_count;\n        stts_entries[0].duration = 1;\n        entries = 1;\n    } else {\n        if (track->entry) {\n            stts_entries = av_malloc_array(track->entry, sizeof(*stts_entries)); /* worst case */\n            if (!stts_entries)\n                return AVERROR(ENOMEM);\n        }\n        for (i = 0; i < track->entry; i++) {\n            int duration = get_cluster_duration(track, i);\n            if (i && duration == stts_entries[entries].duration) {\n                stts_entries[entries].count++; /* compress */\n            } else {\n                entries++;\n                stts_entries[entries].duration = duration;\n                stts_entries[entries].count = 1;\n            }\n        }\n        entries++; /* last one */\n    }\n    atom_size = 16 + (entries * 8);\n    avio_wb32(pb, atom_size); /* size */\n    ffio_wfourcc(pb, \"stts\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, entries); /* entry count */\n    for (i = 0; i < entries; i++) {\n        avio_wb32(pb, stts_entries[i].count);\n        avio_wb32(pb, stts_entries[i].duration);\n    }\n    av_free(stts_entries);\n    return atom_size;\n}\n\nstatic int mov_write_dref_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 28); /* size */\n    ffio_wfourcc(pb, \"dref\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, 1); /* entry count */\n\n    avio_wb32(pb, 0xc); /* size */\n    //FIXME add the alis and rsrc atom\n    ffio_wfourcc(pb, \"url \");\n    avio_wb32(pb, 1); /* version & flags */\n\n    return 28;\n}\n\nstatic int mov_write_stbl_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int ret;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stbl\");\n    mov_write_stsd_tag(s, pb, mov, track);\n    mov_write_stts_tag(pb, track);\n    if ((track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n         track->par->codec_tag == MKTAG('r','t','p',' ')) &&\n        track->has_keyframes && track->has_keyframes < track->entry)\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n    if (track->par->codec_type == AVMEDIA_TYPE_VIDEO &&\n        track->flags & MOV_TRACK_CTTS && track->entry) {\n\n        if ((ret = mov_write_ctts_tag(pb, track)) < 0)\n            return ret;\n    }\n    mov_write_stsc_tag(pb, track);\n    mov_write_stsz_tag(pb, track);\n    mov_write_stco_tag(pb, track);\n    if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n        ff_mov_cenc_write_stbl_atoms(&track->cenc, pb);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_dinf_tag(AVIOContext *pb)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"dinf\");\n    mov_write_dref_tag(pb);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_nmhd_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 12);\n    ffio_wfourcc(pb, \"nmhd\");\n    avio_wb32(pb, 0);\n    return 12;\n}\n\nstatic int mov_write_tcmi_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    const char *font = \"Lucida Grande\";\n    avio_wb32(pb, 0);                   /* size */\n    ffio_wfourcc(pb, \"tcmi\");           /* timecode media information atom */\n    avio_wb32(pb, 0);                   /* version & flags */\n    avio_wb16(pb, 0);                   /* text font */\n    avio_wb16(pb, 0);                   /* text face */\n    avio_wb16(pb, 12);                  /* text size */\n    avio_wb16(pb, 0);                   /* (unknown, not in the QT specs...) */\n    avio_wb16(pb, 0x0000);              /* text color (red) */\n    avio_wb16(pb, 0x0000);              /* text color (green) */\n    avio_wb16(pb, 0x0000);              /* text color (blue) */\n    avio_wb16(pb, 0xffff);              /* background color (red) */\n    avio_wb16(pb, 0xffff);              /* background color (green) */\n    avio_wb16(pb, 0xffff);              /* background color (blue) */\n    avio_w8(pb, strlen(font));          /* font len (part of the pascal string) */\n    avio_write(pb, font, strlen(font)); /* font name */\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_gmhd_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);      /* size */\n    ffio_wfourcc(pb, \"gmhd\");\n    avio_wb32(pb, 0x18);   /* gmin size */\n    ffio_wfourcc(pb, \"gmin\");/* generic media info */\n    avio_wb32(pb, 0);      /* version & flags */\n    avio_wb16(pb, 0x40);   /* graphics mode = */\n    avio_wb16(pb, 0x8000); /* opColor (r?) */\n    avio_wb16(pb, 0x8000); /* opColor (g?) */\n    avio_wb16(pb, 0x8000); /* opColor (b?) */\n    avio_wb16(pb, 0);      /* balance */\n    avio_wb16(pb, 0);      /* reserved */\n\n    /*\n     * This special text atom is required for\n     * Apple Quicktime chapters. The contents\n     * don't appear to be documented, so the\n     * bytes are copied verbatim.\n     */\n    if (track->tag != MKTAG('c','6','0','8')) {\n    avio_wb32(pb, 0x2C);   /* size */\n    ffio_wfourcc(pb, \"text\");\n    avio_wb16(pb, 0x01);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x01);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00004000);\n    avio_wb16(pb, 0x0000);\n    }\n\n    if (track->par->codec_tag == MKTAG('t','m','c','d')) {\n        int64_t tmcd_pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size */\n        ffio_wfourcc(pb, \"tmcd\");\n        mov_write_tcmi_tag(pb, track);\n        update_size(pb, tmcd_pos);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_smhd_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 16); /* size */\n    ffio_wfourcc(pb, \"smhd\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb16(pb, 0); /* reserved (balance, normally = 0) */\n    avio_wb16(pb, 0); /* reserved */\n    return 16;\n}\n\nstatic int mov_write_vmhd_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 0x14); /* size (always 0x14) */\n    ffio_wfourcc(pb, \"vmhd\");\n    avio_wb32(pb, 0x01); /* version & flags */\n    avio_wb64(pb, 0); /* reserved (graphics mode = copy) */\n    return 0x14;\n}\n\nstatic int is_clcp_track(MOVTrack *track)\n{\n    return track->tag == MKTAG('c','7','0','8') ||\n           track->tag == MKTAG('c','6','0','8');\n}\n\nstatic int mov_write_hdlr_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n    int64_t pos = avio_tell(pb);\n\n    hdlr      = \"dhlr\";\n    hdlr_type = \"url \";\n    descr     = \"DataHandler\";\n\n    if (track) {\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            hdlr_type = \"vide\";\n            descr     = \"VideoHandler\";\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            hdlr_type = \"soun\";\n            descr     = \"SoundHandler\";\n        } else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            if (is_clcp_track(track)) {\n                hdlr_type = \"clcp\";\n                descr = \"ClosedCaptionHandler\";\n            } else {\n                if (track->tag == MKTAG('t','x','3','g')) {\n                    hdlr_type = \"sbtl\";\n                } else if (track->tag == MKTAG('m','p','4','s')) {\n                    hdlr_type = \"subp\";\n                } else {\n                    hdlr_type = \"text\";\n                }\n            descr = \"SubtitleHandler\";\n            }\n        } else if (track->par->codec_tag == MKTAG('r','t','p',' ')) {\n            hdlr_type = \"hint\";\n            descr     = \"HintHandler\";\n        } else if (track->par->codec_tag == MKTAG('t','m','c','d')) {\n            hdlr_type = \"tmcd\";\n            descr = \"TimeCodeHandler\";\n        } else {\n            char tag_buf[32];\n            av_get_codec_tag_string(tag_buf, sizeof(tag_buf),\n                                    track->par->codec_tag);\n\n            av_log(s, AV_LOG_WARNING,\n                   \"Unknown hldr_type for %s / 0x%04X, writing dummy values\\n\",\n                   tag_buf, track->par->codec_tag);\n        }\n        if (track->st) {\n            // hdlr.name is used by some players to identify the content title\n            // of the track. So if an alternate handler description is\n            // specified, use it.\n            AVDictionaryEntry *t;\n            t = av_dict_get(track->st->metadata, \"handler\", NULL, 0);\n            if (t && utf8len(t->value))\n                descr = t->value;\n        }\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"hdlr\");\n    avio_wb32(pb, 0); /* Version & flags */\n    avio_write(pb, hdlr, 4); /* handler */\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    if (!track || track->mode == MODE_MOV)\n        avio_w8(pb, strlen(descr)); /* pascal string */\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n    if (track && track->mode != MODE_MOV)\n        avio_w8(pb, 0); /* c string */\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_hmhd_tag(AVIOContext *pb)\n{\n    /* This atom must be present, but leaving the values at zero\n     * seems harmless. */\n    avio_wb32(pb, 28); /* size */\n    ffio_wfourcc(pb, \"hmhd\");\n    avio_wb32(pb, 0); /* version, flags */\n    avio_wb16(pb, 0); /* maxPDUsize */\n    avio_wb16(pb, 0); /* avgPDUsize */\n    avio_wb32(pb, 0); /* maxbitrate */\n    avio_wb32(pb, 0); /* avgbitrate */\n    avio_wb32(pb, 0); /* reserved */\n    return 28;\n}\n\nstatic int mov_write_minf_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int ret;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"minf\");\n    if (track->par->codec_type == AVMEDIA_TYPE_VIDEO)\n        mov_write_vmhd_tag(pb);\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_smhd_tag(pb);\n    else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n            mov_write_gmhd_tag(pb, track);\n        } else {\n            mov_write_nmhd_tag(pb);\n        }\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n        mov_write_hmhd_tag(pb);\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n        if (track->mode != MODE_MOV)\n            mov_write_nmhd_tag(pb);\n        else\n            mov_write_gmhd_tag(pb, track);\n    }\n    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */\n        mov_write_hdlr_tag(s, pb, NULL);\n    mov_write_dinf_tag(pb);\n    if ((ret = mov_write_stbl_tag(s, pb, mov, track)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track)\n{\n    int version = track->track_duration < INT32_MAX ? 0 : 1;\n\n    if (track->mode == MODE_ISM)\n        version = 1;\n\n    (version == 1) ? avio_wb32(pb, 44) : avio_wb32(pb, 32); /* size */\n    ffio_wfourcc(pb, \"mdhd\");\n    avio_w8(pb, version);\n    avio_wb24(pb, 0); /* flags */\n    if (version == 1) {\n        avio_wb64(pb, track->time);\n        avio_wb64(pb, track->time);\n    } else {\n        avio_wb32(pb, track->time); /* creation time */\n        avio_wb32(pb, track->time); /* modification time */\n    }\n    avio_wb32(pb, track->timescale); /* time scale (sample rate for audio) */\n    if (!track->entry && mov->mode == MODE_ISM)\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n    else if (!track->entry)\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n    else\n        (version == 1) ? avio_wb64(pb, track->track_duration) : avio_wb32(pb, track->track_duration); /* duration */\n    avio_wb16(pb, track->language); /* language */\n    avio_wb16(pb, 0); /* reserved (quality) */\n\n    if (version != 0 && track->mode == MODE_MOV) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"FATAL error, file duration too long for timebase, this file will not be\\n\"\n               \"playable with quicktime. Choose a different timebase or a different\\n\"\n               \"container format\\n\");\n    }\n\n    return 32;\n}\n\nstatic int mov_write_mdia_tag(AVFormatContext *s, AVIOContext *pb,\n                              MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int ret;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"mdia\");\n    mov_write_mdhd_tag(pb, mov, track);\n    mov_write_hdlr_tag(s, pb, track);\n    if ((ret = mov_write_minf_tag(s, pb, mov, track)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\n/* transformation matrix\n     |a  b  u|\n     |c  d  v|\n     |tx ty w| */\nstatic void write_matrix(AVIOContext *pb, int16_t a, int16_t b, int16_t c,\n                         int16_t d, int16_t tx, int16_t ty)\n{\n    avio_wb32(pb, a << 16);  /* 16.16 format */\n    avio_wb32(pb, b << 16);  /* 16.16 format */\n    avio_wb32(pb, 0);        /* u in 2.30 format */\n    avio_wb32(pb, c << 16);  /* 16.16 format */\n    avio_wb32(pb, d << 16);  /* 16.16 format */\n    avio_wb32(pb, 0);        /* v in 2.30 format */\n    avio_wb32(pb, tx << 16); /* 16.16 format */\n    avio_wb32(pb, ty << 16); /* 16.16 format */\n    avio_wb32(pb, 1 << 30);  /* w in 2.30 format */\n}\n\nstatic int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, AVStream *st)\n{\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n                                      track->timescale, AV_ROUND_UP);\n    int version = duration < INT32_MAX ? 0 : 1;\n    int flags   = MOV_TKHD_FLAG_IN_MOVIE;\n    int rotation = 0;\n    int group   = 0;\n\n    uint32_t *display_matrix = NULL;\n    int      display_matrix_size, i;\n\n    if (st) {\n        if (mov->per_stream_grouping)\n            group = st->index;\n        else\n            group = st->codecpar->codec_type;\n\n        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,\n                                                            &display_matrix_size);\n        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))\n            display_matrix = NULL;\n    }\n\n    if (track->flags & MOV_TRACK_ENABLED)\n        flags |= MOV_TKHD_FLAG_ENABLED;\n\n    if (track->mode == MODE_ISM)\n        version = 1;\n\n    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */\n    ffio_wfourcc(pb, \"tkhd\");\n    avio_w8(pb, version);\n    avio_wb24(pb, flags);\n    if (version == 1) {\n        avio_wb64(pb, track->time);\n        avio_wb64(pb, track->time);\n    } else {\n        avio_wb32(pb, track->time); /* creation time */\n        avio_wb32(pb, track->time); /* modification time */\n    }\n    avio_wb32(pb, track->track_id); /* track-id */\n    avio_wb32(pb, 0); /* reserved */\n    if (!track->entry && mov->mode == MODE_ISM)\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n    else if (!track->entry)\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n    else\n        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);\n\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb16(pb, 0); /* layer */\n    avio_wb16(pb, group); /* alternate group) */\n    /* Volume, only for audio */\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        avio_wb16(pb, 0x0100);\n    else\n        avio_wb16(pb, 0);\n    avio_wb16(pb, 0); /* reserved */\n\n    /* Matrix structure */\n    if (st && st->metadata) {\n        AVDictionaryEntry *rot = av_dict_get(st->metadata, \"rotate\", NULL, 0);\n        rotation = (rot && rot->value) ? atoi(rot->value) : 0;\n    }\n    if (display_matrix) {\n        for (i = 0; i < 9; i++)\n            avio_wb32(pb, display_matrix[i]);\n    } else if (rotation == 90) {\n        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);\n    } else if (rotation == 180) {\n        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);\n    } else if (rotation == 270) {\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n    } else {\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n    }\n    /* Track width and height, for visual only */\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n        int64_t track_width_1616;\n        if (track->mode == MODE_MOV) {\n            track_width_1616 = track->par->width * 0x10000ULL;\n        } else {\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n                                                  track->par->width * 0x10000LL,\n                                                  st->sample_aspect_ratio.den);\n            if (!track_width_1616 ||\n                track->height != track->par->height ||\n                track_width_1616 > UINT32_MAX)\n                track_width_1616 = track->par->width * 0x10000ULL;\n        }\n        if (track_width_1616 > UINT32_MAX) {\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n            track_width_1616 = 0;\n        }\n        avio_wb32(pb, track_width_1616);\n        if (track->height > 0xFFFF) {\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n            avio_wb32(pb, 0);\n        } else\n            avio_wb32(pb, track->height * 0x10000U);\n    } else {\n        avio_wb32(pb, 0);\n        avio_wb32(pb, 0);\n    }\n    return 0x5c;\n}\n\nstatic int mov_write_tapt_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int32_t width = av_rescale(track->par->sample_aspect_ratio.num, track->par->width,\n                               track->par->sample_aspect_ratio.den);\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tapt\");\n\n    avio_wb32(pb, 20);\n    ffio_wfourcc(pb, \"clef\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, width << 16);\n    avio_wb32(pb, track->par->height << 16);\n\n    avio_wb32(pb, 20);\n    ffio_wfourcc(pb, \"prof\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, width << 16);\n    avio_wb32(pb, track->par->height << 16);\n\n    avio_wb32(pb, 20);\n    ffio_wfourcc(pb, \"enof\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, track->par->width << 16);\n    avio_wb32(pb, track->par->height << 16);\n\n    return update_size(pb, pos);\n}\n\n// This box seems important for the psp playback ... without it the movie seems to hang\nstatic int mov_write_edts_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track)\n{\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n                                      track->timescale, AV_ROUND_UP);\n    int version = duration < INT32_MAX ? 0 : 1;\n    int entry_size, entry_count, size;\n    int64_t delay, start_ct = track->start_cts;\n    int64_t start_dts = track->start_dts;\n\n    if (track->entry) {\n        if (start_dts != track->cluster[0].dts || start_ct != track->cluster[0].cts) {\n\n            av_log(mov->fc, AV_LOG_DEBUG,\n                   \"EDTS using dts:%\"PRId64\" cts:%d instead of dts:%\"PRId64\" cts:%\"PRId64\" tid:%d\\n\",\n                   track->cluster[0].dts, track->cluster[0].cts,\n                   start_dts, start_ct, track->track_id);\n            start_dts = track->cluster[0].dts;\n            start_ct  = track->cluster[0].cts;\n        }\n    }\n\n    delay = av_rescale_rnd(start_dts + start_ct, MOV_TIMESCALE,\n                           track->timescale, AV_ROUND_DOWN);\n    version |= delay < INT32_MAX ? 0 : 1;\n\n    entry_size = (version == 1) ? 20 : 12;\n    entry_count = 1 + (delay > 0);\n    size = 24 + entry_count * entry_size;\n\n    /* write the atom data */\n    avio_wb32(pb, size);\n    ffio_wfourcc(pb, \"edts\");\n    avio_wb32(pb, size - 8);\n    ffio_wfourcc(pb, \"elst\");\n    avio_w8(pb, version);\n    avio_wb24(pb, 0); /* flags */\n\n    avio_wb32(pb, entry_count);\n    if (delay > 0) { /* add an empty edit to delay presentation */\n        /* In the positive delay case, the delay includes the cts\n         * offset, and the second edit list entry below trims out\n         * the same amount from the actual content. This makes sure\n         * that the offset last sample is included in the edit\n         * list duration as well. */\n        if (version == 1) {\n            avio_wb64(pb, delay);\n            avio_wb64(pb, -1);\n        } else {\n            avio_wb32(pb, delay);\n            avio_wb32(pb, -1);\n        }\n        avio_wb32(pb, 0x00010000);\n    } else {\n        /* Avoid accidentally ending up with start_ct = -1 which has got a\n         * special meaning. Normally start_ct should end up positive or zero\n         * here, but use FFMIN in case dts is a small positive integer\n         * rounded to 0 when represented in MOV_TIMESCALE units. */\n        av_assert0(av_rescale_rnd(start_dts, MOV_TIMESCALE, track->timescale, AV_ROUND_DOWN) <= 0);\n        start_ct  = -FFMIN(start_dts, 0);\n        /* Note, this delay is calculated from the pts of the first sample,\n         * ensuring that we don't reduce the duration for cases with\n         * dts<0 pts=0. */\n        duration += delay;\n    }\n\n    /* For fragmented files, we don't know the full length yet. Setting\n     * duration to 0 allows us to only specify the offset, including\n     * the rest of the content (from all future fragments) without specifying\n     * an explicit duration. */\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT)\n        duration = 0;\n\n    /* duration */\n    if (version == 1) {\n        avio_wb64(pb, duration);\n        avio_wb64(pb, start_ct);\n    } else {\n        avio_wb32(pb, duration);\n        avio_wb32(pb, start_ct);\n    }\n    avio_wb32(pb, 0x00010000);\n    return size;\n}\n\nstatic int mov_write_tref_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 20);   // size\n    ffio_wfourcc(pb, \"tref\");\n    avio_wb32(pb, 12);   // size (subatom)\n    avio_wl32(pb, track->tref_tag);\n    avio_wb32(pb, track->tref_id);\n    return 20;\n}\n\n// goes at the end of each track!  ... Critical for PSP playback (\"Incompatible data\" without it)\nstatic int mov_write_uuid_tag_psp(AVIOContext *pb, MOVTrack *mov)\n{\n    avio_wb32(pb, 0x34); /* size ... reports as 28 in mp4box! */\n    ffio_wfourcc(pb, \"uuid\");\n    ffio_wfourcc(pb, \"USMT\");\n    avio_wb32(pb, 0x21d24fce);\n    avio_wb32(pb, 0xbb88695c);\n    avio_wb32(pb, 0xfac9c740);\n    avio_wb32(pb, 0x1c);     // another size here!\n    ffio_wfourcc(pb, \"MTDT\");\n    avio_wb32(pb, 0x00010012);\n    avio_wb32(pb, 0x0a);\n    avio_wb32(pb, 0x55c40000);\n    avio_wb32(pb, 0x1);\n    avio_wb32(pb, 0x0);\n    return 0x34;\n}\n\nstatic int mov_write_udta_sdp(AVIOContext *pb, MOVTrack *track)\n{\n    AVFormatContext *ctx = track->rtp_ctx;\n    char buf[1000] = \"\";\n    int len;\n\n    ff_sdp_write_media(buf, sizeof(buf), ctx->streams[0], track->src_track,\n                       NULL, NULL, 0, 0, ctx);\n    av_strlcatf(buf, sizeof(buf), \"a=control:streamid=%d\\r\\n\", track->track_id);\n    len = strlen(buf);\n\n    avio_wb32(pb, len + 24);\n    ffio_wfourcc(pb, \"udta\");\n    avio_wb32(pb, len + 16);\n    ffio_wfourcc(pb, \"hnti\");\n    avio_wb32(pb, len + 8);\n    ffio_wfourcc(pb, \"sdp \");\n    avio_write(pb, buf, len);\n    return len + 24;\n}\n\nstatic int mov_write_track_metadata(AVIOContext *pb, AVStream *st,\n                                    const char *tag, const char *str)\n{\n    int64_t pos = avio_tell(pb);\n    AVDictionaryEntry *t = av_dict_get(st->metadata, str, NULL, 0);\n    if (!t || !utf8len(t->value))\n        return 0;\n\n    avio_wb32(pb, 0);   /* size */\n    ffio_wfourcc(pb, tag); /* type */\n    avio_write(pb, t->value, strlen(t->value)); /* UTF8 string value */\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_track_udta_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                    AVStream *st)\n{\n    AVIOContext *pb_buf;\n    int ret, size;\n    uint8_t *buf;\n\n    if (!st)\n        return 0;\n\n    ret = avio_open_dyn_buf(&pb_buf);\n    if (ret < 0)\n        return ret;\n\n    if (mov->mode & MODE_MP4)\n        mov_write_track_metadata(pb_buf, st, \"name\", \"title\");\n\n    if ((size = avio_close_dyn_buf(pb_buf, &buf)) > 0) {\n        avio_wb32(pb, size + 8);\n        ffio_wfourcc(pb, \"udta\");\n        avio_write(pb, buf, size);\n    }\n    av_free(buf);\n\n    return 0;\n}\n\nstatic int mov_write_trak_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, AVStream *st)\n{\n    int64_t pos = avio_tell(pb);\n    int entry_backup = track->entry;\n    int chunk_backup = track->chunkCount;\n    int ret;\n\n    /* If we want to have an empty moov, but some samples already have been\n     * buffered (delay_moov), pretend that no samples have been written yet. */\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV)\n        track->chunkCount = track->entry = 0;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"trak\");\n    mov_write_tkhd_tag(pb, mov, track, st);\n\n    av_assert2(mov->use_editlist >= 0);\n\n    if (track->start_dts != AV_NOPTS_VALUE) {\n        if (mov->use_editlist)\n            mov_write_edts_tag(pb, mov, track);  // PSP Movies and several other cases require edts box\n        else if ((track->entry && track->cluster[0].dts) || track->mode == MODE_PSP || is_clcp_track(track))\n            av_log(mov->fc, AV_LOG_WARNING,\n                   \"Not writing any edit list even though one would have been required\\n\");\n    }\n\n    if (track->tref_tag)\n        mov_write_tref_tag(pb, track);\n\n    if ((ret = mov_write_mdia_tag(s, pb, mov, track)) < 0)\n        return ret;\n    if (track->mode == MODE_PSP)\n        mov_write_uuid_tag_psp(pb, track); // PSP Movies require this uuid box\n    if (track->tag == MKTAG('r','t','p',' '))\n        mov_write_udta_sdp(pb, track);\n    if (track->mode == MODE_MOV) {\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            double sample_aspect_ratio = av_q2d(st->sample_aspect_ratio);\n            if (st->sample_aspect_ratio.num && 1.0 != sample_aspect_ratio) {\n                mov_write_tapt_tag(pb, track);\n            }\n        }\n        if (is_clcp_track(track) && st->sample_aspect_ratio.num) {\n            mov_write_tapt_tag(pb, track);\n        }\n    }\n    mov_write_track_udta_tag(pb, mov, st);\n    track->entry = entry_backup;\n    track->chunkCount = chunk_backup;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_iods_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int i, has_audio = 0, has_video = 0;\n    int64_t pos = avio_tell(pb);\n    int audio_profile = mov->iods_audio_profile;\n    int video_profile = mov->iods_video_profile;\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry > 0 || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            has_audio |= mov->tracks[i].par->codec_type == AVMEDIA_TYPE_AUDIO;\n            has_video |= mov->tracks[i].par->codec_type == AVMEDIA_TYPE_VIDEO;\n        }\n    }\n    if (audio_profile < 0)\n        audio_profile = 0xFF - has_audio;\n    if (video_profile < 0)\n        video_profile = 0xFF - has_video;\n    avio_wb32(pb, 0x0); /* size */\n    ffio_wfourcc(pb, \"iods\");\n    avio_wb32(pb, 0);    /* version & flags */\n    put_descr(pb, 0x10, 7);\n    avio_wb16(pb, 0x004f);\n    avio_w8(pb, 0xff);\n    avio_w8(pb, 0xff);\n    avio_w8(pb, audio_profile);\n    avio_w8(pb, video_profile);\n    avio_w8(pb, 0xff);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_trex_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x20); /* size */\n    ffio_wfourcc(pb, \"trex\");\n    avio_wb32(pb, 0);   /* version & flags */\n    avio_wb32(pb, track->track_id); /* track ID */\n    avio_wb32(pb, 1);   /* default sample description index */\n    avio_wb32(pb, 0);   /* default sample duration */\n    avio_wb32(pb, 0);   /* default sample size */\n    avio_wb32(pb, 0);   /* default sample flags */\n    return 0;\n}\n\nstatic int mov_write_mvex_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    avio_wb32(pb, 0x0); /* size */\n    ffio_wfourcc(pb, \"mvex\");\n    for (i = 0; i < mov->nb_streams; i++)\n        mov_write_trex_tag(pb, &mov->tracks[i]);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mvhd_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int max_track_id = 1, i;\n    int64_t max_track_len = 0;\n    int version;\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry > 0 && mov->tracks[i].timescale) {\n            int64_t max_track_len_temp = av_rescale_rnd(mov->tracks[i].track_duration,\n                                                MOV_TIMESCALE,\n                                                mov->tracks[i].timescale,\n                                                AV_ROUND_UP);\n            if (max_track_len < max_track_len_temp)\n                max_track_len = max_track_len_temp;\n            if (max_track_id < mov->tracks[i].track_id)\n                max_track_id = mov->tracks[i].track_id;\n        }\n    }\n    /* If using delay_moov, make sure the output is the same as if no\n     * samples had been written yet. */\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n        max_track_len = 0;\n        max_track_id  = 1;\n    }\n\n    version = max_track_len < UINT32_MAX ? 0 : 1;\n    avio_wb32(pb, version == 1 ? 120 : 108); /* size */\n\n    ffio_wfourcc(pb, \"mvhd\");\n    avio_w8(pb, version);\n    avio_wb24(pb, 0); /* flags */\n    if (version == 1) {\n        avio_wb64(pb, mov->time);\n        avio_wb64(pb, mov->time);\n    } else {\n        avio_wb32(pb, mov->time); /* creation time */\n        avio_wb32(pb, mov->time); /* modification time */\n    }\n    avio_wb32(pb, MOV_TIMESCALE);\n    (version == 1) ? avio_wb64(pb, max_track_len) : avio_wb32(pb, max_track_len); /* duration of longest track */\n\n    avio_wb32(pb, 0x00010000); /* reserved (preferred rate) 1.0 = normal */\n    avio_wb16(pb, 0x0100); /* reserved (preferred volume) 1.0 = normal */\n    avio_wb16(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n\n    /* Matrix structure */\n    write_matrix(pb, 1, 0, 0, 1, 0, 0);\n\n    avio_wb32(pb, 0); /* reserved (preview time) */\n    avio_wb32(pb, 0); /* reserved (preview duration) */\n    avio_wb32(pb, 0); /* reserved (poster time) */\n    avio_wb32(pb, 0); /* reserved (selection time) */\n    avio_wb32(pb, 0); /* reserved (selection duration) */\n    avio_wb32(pb, 0); /* reserved (current time) */\n    avio_wb32(pb, max_track_id + 1); /* Next track id */\n    return 0x6c;\n}\n\nstatic int mov_write_itunes_hdlr_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                     AVFormatContext *s)\n{\n    avio_wb32(pb, 33); /* size */\n    ffio_wfourcc(pb, \"hdlr\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"mdir\");\n    ffio_wfourcc(pb, \"appl\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    avio_w8(pb, 0);\n    return 33;\n}\n\n/* helper function to write a data tag with the specified string as data */\nstatic int mov_write_string_data_tag(AVIOContext *pb, const char *data, int lang, int long_style)\n{\n    if (long_style) {\n        int size = 16 + strlen(data);\n        avio_wb32(pb, size); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 1);\n        avio_wb32(pb, 0);\n        avio_write(pb, data, strlen(data));\n        return size;\n    } else {\n        if (!lang)\n            lang = ff_mov_iso639_to_lang(\"und\", 1);\n        avio_wb16(pb, strlen(data)); /* string length */\n        avio_wb16(pb, lang);\n        avio_write(pb, data, strlen(data));\n        return strlen(data) + 4;\n    }\n}\n\nstatic int mov_write_string_tag(AVIOContext *pb, const char *name,\n                                const char *value, int lang, int long_style)\n{\n    int size = 0;\n    if (value && value[0]) {\n        int64_t pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size */\n        ffio_wfourcc(pb, name);\n        mov_write_string_data_tag(pb, value, lang, long_style);\n        size = update_size(pb, pos);\n    }\n    return size;\n}\n\nstatic AVDictionaryEntry *get_metadata_lang(AVFormatContext *s,\n                                            const char *tag, int *lang)\n{\n    int l, len, len2;\n    AVDictionaryEntry *t, *t2 = NULL;\n    char tag2[16];\n\n    *lang = 0;\n\n    if (!(t = av_dict_get(s->metadata, tag, NULL, 0)))\n        return NULL;\n\n    len = strlen(t->key);\n    snprintf(tag2, sizeof(tag2), \"%s-\", tag);\n    while ((t2 = av_dict_get(s->metadata, tag2, t2, AV_DICT_IGNORE_SUFFIX))) {\n        len2 = strlen(t2->key);\n        if (len2 == len + 4 && !strcmp(t->value, t2->value)\n            && (l = ff_mov_iso639_to_lang(&t2->key[len2 - 3], 1)) >= 0) {\n            *lang = l;\n            return t;\n        }\n    }\n    return t;\n}\n\nstatic int mov_write_string_metadata(AVFormatContext *s, AVIOContext *pb,\n                                     const char *name, const char *tag,\n                                     int long_style)\n{\n    int lang;\n    AVDictionaryEntry *t = get_metadata_lang(s, tag, &lang);\n    if (!t)\n        return 0;\n    return mov_write_string_tag(pb, name, t->value, lang, long_style);\n}\n\n/* iTunes bpm number */\nstatic int mov_write_tmpo_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVDictionaryEntry *t = av_dict_get(s->metadata, \"tmpo\", NULL, 0);\n    int size = 0, tmpo = t ? atoi(t->value) : 0;\n    if (tmpo) {\n        size = 26;\n        avio_wb32(pb, size);\n        ffio_wfourcc(pb, \"tmpo\");\n        avio_wb32(pb, size-8); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 0x15);  //type specifier\n        avio_wb32(pb, 0);\n        avio_wb16(pb, tmpo);        // data\n    }\n    return size;\n}\n\n/* 3GPP TS 26.244 */\nstatic int mov_write_loci_tag(AVFormatContext *s, AVIOContext *pb)\n{\n    int lang;\n    int64_t pos = avio_tell(pb);\n    double latitude, longitude, altitude;\n    int32_t latitude_fix, longitude_fix, altitude_fix;\n    AVDictionaryEntry *t = get_metadata_lang(s, \"location\", &lang);\n    const char *ptr, *place = \"\";\n    char *end;\n    static const char *astronomical_body = \"earth\";\n    if (!t)\n        return 0;\n\n    ptr = t->value;\n    longitude = strtod(ptr, &end);\n    if (end == ptr) {\n        av_log(s, AV_LOG_WARNING, \"malformed location metadata\\n\");\n        return 0;\n    }\n    ptr = end;\n    latitude = strtod(ptr, &end);\n    if (end == ptr) {\n        av_log(s, AV_LOG_WARNING, \"malformed location metadata\\n\");\n        return 0;\n    }\n    ptr = end;\n    altitude = strtod(ptr, &end);\n    /* If no altitude was present, the default 0 should be fine */\n    if (*end == '/')\n        place = end + 1;\n\n    latitude_fix  = (int32_t) ((1 << 16) * latitude);\n    longitude_fix = (int32_t) ((1 << 16) * longitude);\n    altitude_fix  = (int32_t) ((1 << 16) * altitude);\n\n    avio_wb32(pb, 0);         /* size */\n    ffio_wfourcc(pb, \"loci\"); /* type */\n    avio_wb32(pb, 0);         /* version + flags */\n    avio_wb16(pb, lang);\n    avio_write(pb, place, strlen(place) + 1);\n    avio_w8(pb, 0);           /* role of place (0 == shooting location, 1 == real location, 2 == fictional location) */\n    avio_wb32(pb, latitude_fix);\n    avio_wb32(pb, longitude_fix);\n    avio_wb32(pb, altitude_fix);\n    avio_write(pb, astronomical_body, strlen(astronomical_body) + 1);\n    avio_w8(pb, 0);           /* additional notes, null terminated string */\n\n    return update_size(pb, pos);\n}\n\n/* iTunes track or disc number */\nstatic int mov_write_trkn_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s, int disc)\n{\n    AVDictionaryEntry *t = av_dict_get(s->metadata,\n                                       disc ? \"disc\" : \"track\",\n                                       NULL, 0);\n    int size = 0, track = t ? atoi(t->value) : 0;\n    if (track) {\n        int tracks = 0;\n        char *slash = strchr(t->value, '/');\n        if (slash)\n            tracks = atoi(slash + 1);\n        avio_wb32(pb, 32); /* size */\n        ffio_wfourcc(pb, disc ? \"disk\" : \"trkn\");\n        avio_wb32(pb, 24); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 0);        // 8 bytes empty\n        avio_wb32(pb, 0);\n        avio_wb16(pb, 0);        // empty\n        avio_wb16(pb, track);    // track / disc number\n        avio_wb16(pb, tracks);   // total track / disc number\n        avio_wb16(pb, 0);        // empty\n        size = 32;\n    }\n    return size;\n}\n\nstatic int mov_write_int8_metadata(AVFormatContext *s, AVIOContext *pb,\n                                   const char *name, const char *tag,\n                                   int len)\n{\n    AVDictionaryEntry *t = NULL;\n    uint8_t num;\n    int size = 24 + len;\n\n    if (len != 1 && len != 4)\n        return -1;\n\n    if (!(t = av_dict_get(s->metadata, tag, NULL, 0)))\n        return 0;\n    num = atoi(t->value);\n\n    avio_wb32(pb, size);\n    ffio_wfourcc(pb, name);\n    avio_wb32(pb, size - 8);\n    ffio_wfourcc(pb, \"data\");\n    avio_wb32(pb, 0x15);\n    avio_wb32(pb, 0);\n    if (len==4) avio_wb32(pb, num);\n    else        avio_w8 (pb, num);\n\n    return size;\n}\n\n/* iTunes meta data list */\nstatic int mov_write_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"ilst\");\n    mov_write_string_metadata(s, pb, \"\\251nam\", \"title\"    , 1);\n    mov_write_string_metadata(s, pb, \"\\251ART\", \"artist\"   , 1);\n    mov_write_string_metadata(s, pb, \"aART\", \"album_artist\", 1);\n    mov_write_string_metadata(s, pb, \"\\251wrt\", \"composer\" , 1);\n    mov_write_string_metadata(s, pb, \"\\251alb\", \"album\"    , 1);\n    mov_write_string_metadata(s, pb, \"\\251day\", \"date\"     , 1);\n    if (!mov_write_string_metadata(s, pb, \"\\251too\", \"encoding_tool\", 1)) {\n        if (!(s->flags & AVFMT_FLAG_BITEXACT))\n            mov_write_string_tag(pb, \"\\251too\", LIBAVFORMAT_IDENT, 0, 1);\n    }\n    mov_write_string_metadata(s, pb, \"\\251cmt\", \"comment\"  , 1);\n    mov_write_string_metadata(s, pb, \"\\251gen\", \"genre\"    , 1);\n    mov_write_string_metadata(s, pb, \"\\251cpy\", \"copyright\", 1);\n    mov_write_string_metadata(s, pb, \"\\251grp\", \"grouping\" , 1);\n    mov_write_string_metadata(s, pb, \"\\251lyr\", \"lyrics\"   , 1);\n    mov_write_string_metadata(s, pb, \"desc\",    \"description\",1);\n    mov_write_string_metadata(s, pb, \"ldes\",    \"synopsis\" , 1);\n    mov_write_string_metadata(s, pb, \"tvsh\",    \"show\"     , 1);\n    mov_write_string_metadata(s, pb, \"tven\",    \"episode_id\",1);\n    mov_write_string_metadata(s, pb, \"tvnn\",    \"network\"  , 1);\n    mov_write_int8_metadata  (s, pb, \"tves\",    \"episode_sort\",4);\n    mov_write_int8_metadata  (s, pb, \"tvsn\",    \"season_number\",4);\n    mov_write_int8_metadata  (s, pb, \"stik\",    \"media_type\",1);\n    mov_write_int8_metadata  (s, pb, \"hdvd\",    \"hd_video\",  1);\n    mov_write_int8_metadata  (s, pb, \"pgap\",    \"gapless_playback\",1);\n    mov_write_int8_metadata  (s, pb, \"cpil\",    \"compilation\", 1);\n    mov_write_trkn_tag(pb, mov, s, 0); // track number\n    mov_write_trkn_tag(pb, mov, s, 1); // disc number\n    mov_write_tmpo_tag(pb, s);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdta_hdlr_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                   AVFormatContext *s)\n{\n    avio_wb32(pb, 33); /* size */\n    ffio_wfourcc(pb, \"hdlr\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"mdta\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    avio_w8(pb, 0);\n    return 33;\n}\n\nstatic int mov_write_mdta_keys_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                   AVFormatContext *s)\n{\n    AVDictionaryEntry *t = NULL;\n    int64_t pos = avio_tell(pb);\n    int64_t curpos, entry_pos;\n    int count = 0;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"keys\");\n    avio_wb32(pb, 0);\n    entry_pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* entry count */\n\n    while (t = av_dict_get(s->metadata, \"\", t, AV_DICT_IGNORE_SUFFIX)) {\n        avio_wb32(pb, strlen(t->key) + 8);\n        ffio_wfourcc(pb, \"mdta\");\n        avio_write(pb, t->key, strlen(t->key));\n        count += 1;\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entry_pos, SEEK_SET);\n    avio_wb32(pb, count); // rewrite entry count\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdta_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                   AVFormatContext *s)\n{\n    AVDictionaryEntry *t = NULL;\n    int64_t pos = avio_tell(pb);\n    int count = 1; /* keys are 1-index based */\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"ilst\");\n\n    while (t = av_dict_get(s->metadata, \"\", t, AV_DICT_IGNORE_SUFFIX)) {\n        int64_t entry_pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size */\n        avio_wb32(pb, count); /* key */\n        mov_write_string_data_tag(pb, t->value, 0, 1);\n        update_size(pb, entry_pos);\n        count += 1;\n    }\n    return update_size(pb, pos);\n}\n\n/* meta data tags */\nstatic int mov_write_meta_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    int size = 0;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"meta\");\n    avio_wb32(pb, 0);\n    if (mov->flags & FF_MOV_FLAG_USE_MDTA) {\n        mov_write_mdta_hdlr_tag(pb, mov, s);\n        mov_write_mdta_keys_tag(pb, mov, s);\n        mov_write_mdta_ilst_tag(pb, mov, s);\n    }\n    else {\n        /* iTunes metadata tag */\n        mov_write_itunes_hdlr_tag(pb, mov, s);\n        mov_write_ilst_tag(pb, mov, s);\n    }\n    size = update_size(pb, pos);\n    return size;\n}\n\nstatic int mov_write_raw_metadata_tag(AVFormatContext *s, AVIOContext *pb,\n                                      const char *name, const char *key)\n{\n    int len;\n    AVDictionaryEntry *t;\n\n    if (!(t = av_dict_get(s->metadata, key, NULL, 0)))\n        return 0;\n\n    len = strlen(t->value);\n    if (len > 0) {\n        int size = len + 8;\n        avio_wb32(pb, size);\n        ffio_wfourcc(pb, name);\n        avio_write(pb, t->value, len);\n        return size;\n    }\n    return 0;\n}\n\nstatic int ascii_to_wc(AVIOContext *pb, const uint8_t *b)\n{\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        avio_wb16(pb, val);\n    }\n    avio_wb16(pb, 0x00);\n    return 0;\n}\n\nstatic uint16_t language_code(const char *str)\n{\n    return (((str[0] - 0x60) & 0x1F) << 10) +\n           (((str[1] - 0x60) & 0x1F) <<  5) +\n           (( str[2] - 0x60) & 0x1F);\n}\n\nstatic int mov_write_3gp_udta_tag(AVIOContext *pb, AVFormatContext *s,\n                                  const char *tag, const char *str)\n{\n    int64_t pos = avio_tell(pb);\n    AVDictionaryEntry *t = av_dict_get(s->metadata, str, NULL, 0);\n    if (!t || !utf8len(t->value))\n        return 0;\n    avio_wb32(pb, 0);   /* size */\n    ffio_wfourcc(pb, tag); /* type */\n    avio_wb32(pb, 0);   /* version + flags */\n    if (!strcmp(tag, \"yrrc\"))\n        avio_wb16(pb, atoi(t->value));\n    else {\n        avio_wb16(pb, language_code(\"eng\")); /* language */\n        avio_write(pb, t->value, strlen(t->value) + 1); /* UTF8 string value */\n        if (!strcmp(tag, \"albm\") &&\n            (t = av_dict_get(s->metadata, \"track\", NULL, 0)))\n            avio_w8(pb, atoi(t->value));\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_chpl_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    int64_t pos = avio_tell(pb);\n    int i, nb_chapters = FFMIN(s->nb_chapters, 255);\n\n    avio_wb32(pb, 0);            // size\n    ffio_wfourcc(pb, \"chpl\");\n    avio_wb32(pb, 0x01000000);   // version + flags\n    avio_wb32(pb, 0);            // unknown\n    avio_w8(pb, nb_chapters);\n\n    for (i = 0; i < nb_chapters; i++) {\n        AVChapter *c = s->chapters[i];\n        AVDictionaryEntry *t;\n        avio_wb64(pb, av_rescale_q(c->start, c->time_base, (AVRational){1,10000000}));\n\n        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {\n            int len = FFMIN(strlen(t->value), 255);\n            avio_w8(pb, len);\n            avio_write(pb, t->value, len);\n        } else\n            avio_w8(pb, 0);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_udta_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    AVIOContext *pb_buf;\n    int ret, size;\n    uint8_t *buf;\n\n    ret = avio_open_dyn_buf(&pb_buf);\n    if (ret < 0)\n        return ret;\n\n    if (mov->mode & MODE_3GP) {\n        mov_write_3gp_udta_tag(pb_buf, s, \"perf\", \"artist\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"titl\", \"title\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"auth\", \"author\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"gnre\", \"genre\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"dscp\", \"comment\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"albm\", \"album\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"cprt\", \"copyright\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"yrrc\", \"date\");\n        mov_write_loci_tag(s, pb_buf);\n    } else if (mov->mode == MODE_MOV && !(mov->flags & FF_MOV_FLAG_USE_MDTA)) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4\n        mov_write_string_metadata(s, pb_buf, \"\\251ART\", \"artist\",      0);\n        mov_write_string_metadata(s, pb_buf, \"\\251nam\", \"title\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251aut\", \"author\",      0);\n        mov_write_string_metadata(s, pb_buf, \"\\251alb\", \"album\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251day\", \"date\",        0);\n        mov_write_string_metadata(s, pb_buf, \"\\251swr\", \"encoder\",     0);\n        // currently ignored by mov.c\n        mov_write_string_metadata(s, pb_buf, \"\\251des\", \"comment\",     0);\n        // add support for libquicktime, this atom is also actually read by mov.c\n        mov_write_string_metadata(s, pb_buf, \"\\251cmt\", \"comment\",     0);\n        mov_write_string_metadata(s, pb_buf, \"\\251gen\", \"genre\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251cpy\", \"copyright\",   0);\n        mov_write_string_metadata(s, pb_buf, \"\\251mak\", \"make\",        0);\n        mov_write_string_metadata(s, pb_buf, \"\\251mod\", \"model\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251xyz\", \"location\",    0);\n        mov_write_raw_metadata_tag(s, pb_buf, \"XMP_\", \"xmp\");\n    } else {\n        /* iTunes meta data */\n        mov_write_meta_tag(pb_buf, mov, s);\n        mov_write_loci_tag(s, pb_buf);\n    }\n\n    if (s->nb_chapters && !(mov->flags & FF_MOV_FLAG_DISABLE_CHPL))\n        mov_write_chpl_tag(pb_buf, s);\n\n    if ((size = avio_close_dyn_buf(pb_buf, &buf)) > 0) {\n        avio_wb32(pb, size + 8);\n        ffio_wfourcc(pb, \"udta\");\n        avio_write(pb, buf, size);\n    }\n    av_free(buf);\n\n    return 0;\n}\n\nstatic void mov_write_psp_udta_tag(AVIOContext *pb,\n                                   const char *str, const char *lang, int type)\n{\n    int len = utf8len(str) + 1;\n    if (len <= 0)\n        return;\n    avio_wb16(pb, len * 2 + 10);        /* size */\n    avio_wb32(pb, type);                /* type */\n    avio_wb16(pb, language_code(lang)); /* language */\n    avio_wb16(pb, 0x01);                /* ? */\n    ascii_to_wc(pb, str);\n}\n\nstatic int mov_write_uuidusmt_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVDictionaryEntry *title = av_dict_get(s->metadata, \"title\", NULL, 0);\n    int64_t pos, pos2;\n\n    if (title) {\n        pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size placeholder*/\n        ffio_wfourcc(pb, \"uuid\");\n        ffio_wfourcc(pb, \"USMT\");\n        avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n        avio_wb32(pb, 0xbb88695c);\n        avio_wb32(pb, 0xfac9c740);\n\n        pos2 = avio_tell(pb);\n        avio_wb32(pb, 0); /* size placeholder*/\n        ffio_wfourcc(pb, \"MTDT\");\n        avio_wb16(pb, 4);\n\n        // ?\n        avio_wb16(pb, 0x0C);                 /* size */\n        avio_wb32(pb, 0x0B);                 /* type */\n        avio_wb16(pb, language_code(\"und\")); /* language */\n        avio_wb16(pb, 0x0);                  /* ? */\n        avio_wb16(pb, 0x021C);               /* data */\n\n        if (!(s->flags & AVFMT_FLAG_BITEXACT))\n            mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      \"eng\", 0x04);\n        mov_write_psp_udta_tag(pb, title->value,          \"eng\", 0x01);\n        mov_write_psp_udta_tag(pb, \"2006/04/01 11:11:11\", \"und\", 0x03);\n\n        update_size(pb, pos2);\n        return update_size(pb, pos);\n    }\n\n    return 0;\n}\n\nstatic void build_chunks(MOVTrack *trk)\n{\n    int i;\n    MOVIentry *chunk = &trk->cluster[0];\n    uint64_t chunkSize = chunk->size;\n    chunk->chunkNum = 1;\n    if (trk->chunkCount)\n        return;\n    trk->chunkCount = 1;\n    for (i = 1; i<trk->entry; i++){\n        if (chunk->pos + chunkSize == trk->cluster[i].pos &&\n            chunkSize + trk->cluster[i].size < (1<<20)){\n            chunkSize             += trk->cluster[i].size;\n            chunk->samples_in_chunk += trk->cluster[i].entries;\n        } else {\n            trk->cluster[i].chunkNum = chunk->chunkNum+1;\n            chunk=&trk->cluster[i];\n            chunkSize = chunk->size;\n            trk->chunkCount++;\n        }\n    }\n}\n\n/**\n * Assign track ids. If option \"use_stream_ids_as_track_ids\" is set,\n * the stream ids are used as track ids.\n *\n * This assumes mov->tracks and s->streams are in the same order and\n * there are no gaps in either of them (so mov->tracks[n] refers to\n * s->streams[n]).\n *\n * As an exception, there can be more entries in\n * s->streams than in mov->tracks, in which case new track ids are\n * generated (starting after the largest found stream id).\n */\nstatic int mov_setup_track_ids(MOVMuxContext *mov, AVFormatContext *s)\n{\n    int i;\n\n    if (mov->track_ids_ok)\n        return 0;\n\n    if (mov->use_stream_ids_as_track_ids) {\n        int next_generated_track_id = 0;\n        for (i = 0; i < s->nb_streams; i++) {\n            if (s->streams[i]->id > next_generated_track_id)\n                next_generated_track_id = s->streams[i]->id;\n        }\n\n        for (i = 0; i < mov->nb_streams; i++) {\n            if (mov->tracks[i].entry <= 0 && !(mov->flags & FF_MOV_FLAG_FRAGMENT))\n                continue;\n\n            mov->tracks[i].track_id = i >= s->nb_streams ? ++next_generated_track_id : s->streams[i]->id;\n        }\n    } else {\n        for (i = 0; i < mov->nb_streams; i++) {\n            if (mov->tracks[i].entry <= 0 && !(mov->flags & FF_MOV_FLAG_FRAGMENT))\n                continue;\n\n            mov->tracks[i].track_id = i + 1;\n        }\n    }\n\n    mov->track_ids_ok = 1;\n\n    return 0;\n}\n\nstatic int mov_write_moov_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    int i;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size placeholder*/\n    ffio_wfourcc(pb, \"moov\");\n\n    mov_setup_track_ids(mov, s);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry <= 0 && !(mov->flags & FF_MOV_FLAG_FRAGMENT))\n            continue;\n\n        mov->tracks[i].time     = mov->time;\n\n        if (mov->tracks[i].entry)\n            build_chunks(&mov->tracks[i]);\n    }\n\n    if (mov->chapter_track)\n        for (i = 0; i < s->nb_streams; i++) {\n            mov->tracks[i].tref_tag = MKTAG('c','h','a','p');\n            mov->tracks[i].tref_id  = mov->tracks[mov->chapter_track].track_id;\n        }\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (track->tag == MKTAG('r','t','p',' ')) {\n            track->tref_tag = MKTAG('h','i','n','t');\n            track->tref_id = mov->tracks[track->src_track].track_id;\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            int * fallback, size;\n            fallback = (int*)av_stream_get_side_data(track->st,\n                                                     AV_PKT_DATA_FALLBACK_TRACK,\n                                                     &size);\n            if (fallback != NULL && size == sizeof(int)) {\n                if (*fallback >= 0 && *fallback < mov->nb_streams) {\n                    track->tref_tag = MKTAG('f','a','l','l');\n                    track->tref_id = mov->tracks[*fallback].track_id;\n                }\n            }\n        }\n    }\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].tag == MKTAG('t','m','c','d')) {\n            int src_trk = mov->tracks[i].src_track;\n            mov->tracks[src_trk].tref_tag = mov->tracks[i].tag;\n            mov->tracks[src_trk].tref_id  = mov->tracks[i].track_id;\n            //src_trk may have a different timescale than the tmcd track\n            mov->tracks[i].track_duration = av_rescale(mov->tracks[src_trk].track_duration,\n                                                       mov->tracks[i].timescale,\n                                                       mov->tracks[src_trk].timescale);\n        }\n    }\n\n    mov_write_mvhd_tag(pb, mov);\n    if (mov->mode != MODE_MOV && !mov->iods_skip)\n        mov_write_iods_tag(pb, mov);\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry > 0 || mov->flags & FF_MOV_FLAG_FRAGMENT) {\n            int ret = mov_write_trak_tag(s, pb, mov, &(mov->tracks[i]), i < s->nb_streams ? s->streams[i] : NULL);\n            if (ret < 0)\n                return ret;\n        }\n    }\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT)\n        mov_write_mvex_tag(pb, mov); /* QuickTime requires trak to precede this */\n\n    if (mov->mode == MODE_PSP)\n        mov_write_uuidusmt_tag(pb, s);\n    else\n        mov_write_udta_tag(pb, mov, s);\n\n    return update_size(pb, pos);\n}\n\nstatic void param_write_int(AVIOContext *pb, const char *name, int value)\n{\n    avio_printf(pb, \"<param name=\\\"%s\\\" value=\\\"%d\\\" valuetype=\\\"data\\\"/>\\n\", name, value);\n}\n\nstatic void param_write_string(AVIOContext *pb, const char *name, const char *value)\n{\n    avio_printf(pb, \"<param name=\\\"%s\\\" value=\\\"%s\\\" valuetype=\\\"data\\\"/>\\n\", name, value);\n}\n\nstatic void param_write_hex(AVIOContext *pb, const char *name, const uint8_t *value, int len)\n{\n    char buf[150];\n    len = FFMIN(sizeof(buf) / 2 - 1, len);\n    ff_data_to_hex(buf, value, len, 0);\n    buf[2 * len] = '\\0';\n    avio_printf(pb, \"<param name=\\\"%s\\\" value=\\\"%s\\\" valuetype=\\\"data\\\"/>\\n\", name, buf);\n}\n\nstatic int mov_write_isml_manifest(AVIOContext *pb, MOVMuxContext *mov, AVFormatContext *s)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    int64_t manifest_bit_rate = 0;\n    AVCPBProperties *props = NULL;\n\n    static const uint8_t uuid[] = {\n        0xa5, 0xd4, 0x0b, 0x30, 0xe8, 0x14, 0x11, 0xdd,\n        0xba, 0x2f, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66\n    };\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"uuid\");\n    avio_write(pb, uuid, sizeof(uuid));\n    avio_wb32(pb, 0);\n\n    avio_printf(pb, \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\n    avio_printf(pb, \"<smil xmlns=\\\"http://www.w3.org/2001/SMIL20/Language\\\">\\n\");\n    avio_printf(pb, \"<head>\\n\");\n    if (!(mov->fc->flags & AVFMT_FLAG_BITEXACT))\n        avio_printf(pb, \"<meta name=\\\"creator\\\" content=\\\"%s\\\" />\\n\",\n                    LIBAVFORMAT_IDENT);\n    avio_printf(pb, \"</head>\\n\");\n    avio_printf(pb, \"<body>\\n\");\n    avio_printf(pb, \"<switch>\\n\");\n\n    mov_setup_track_ids(mov, s);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        const char *type;\n        int track_id = track->track_id;\n\n        AVStream *st = track->st;\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            type = \"video\";\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            type = \"audio\";\n        } else {\n            continue;\n        }\n\n        props = (AVCPBProperties*)av_stream_get_side_data(track->st, AV_PKT_DATA_CPB_PROPERTIES, NULL);\n\n        if (track->par->bit_rate) {\n            manifest_bit_rate = track->par->bit_rate;\n        } else if (props) {\n            manifest_bit_rate = props->max_bitrate;\n        }\n\n        avio_printf(pb, \"<%s systemBitrate=\\\"%\"PRId64\"\\\">\\n\", type,\n                    manifest_bit_rate);\n        param_write_int(pb, \"systemBitrate\", manifest_bit_rate);\n        param_write_int(pb, \"trackID\", track_id);\n        param_write_string(pb, \"systemLanguage\", lang ? lang->value : \"und\");\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            if (track->par->codec_id == AV_CODEC_ID_H264) {\n                uint8_t *ptr;\n                int size = track->par->extradata_size;\n                if (!ff_avc_write_annexb_extradata(track->par->extradata, &ptr,\n                                                   &size)) {\n                    param_write_hex(pb, \"CodecPrivateData\",\n                                    ptr ? ptr : track->par->extradata,\n                                    size);\n                    av_free(ptr);\n                }\n                param_write_string(pb, \"FourCC\", \"H264\");\n            } else if (track->par->codec_id == AV_CODEC_ID_VC1) {\n                param_write_string(pb, \"FourCC\", \"WVC1\");\n                param_write_hex(pb, \"CodecPrivateData\", track->par->extradata,\n                                track->par->extradata_size);\n            }\n            param_write_int(pb, \"MaxWidth\", track->par->width);\n            param_write_int(pb, \"MaxHeight\", track->par->height);\n            param_write_int(pb, \"DisplayWidth\", track->par->width);\n            param_write_int(pb, \"DisplayHeight\", track->par->height);\n        } else {\n            if (track->par->codec_id == AV_CODEC_ID_AAC) {\n                switch (track->par->profile)\n                {\n                    case FF_PROFILE_AAC_HE_V2:\n                        param_write_string(pb, \"FourCC\", \"AACP\");\n                        break;\n                    case FF_PROFILE_AAC_HE:\n                        param_write_string(pb, \"FourCC\", \"AACH\");\n                        break;\n                    default:\n                        param_write_string(pb, \"FourCC\", \"AACL\");\n                }\n            } else if (track->par->codec_id == AV_CODEC_ID_WMAPRO) {\n                param_write_string(pb, \"FourCC\", \"WMAP\");\n            }\n            param_write_hex(pb, \"CodecPrivateData\", track->par->extradata,\n                            track->par->extradata_size);\n            param_write_int(pb, \"AudioTag\", ff_codec_get_tag(ff_codec_wav_tags,\n                                                             track->par->codec_id));\n            param_write_int(pb, \"Channels\", track->par->channels);\n            param_write_int(pb, \"SamplingRate\", track->par->sample_rate);\n            param_write_int(pb, \"BitsPerSample\", 16);\n            param_write_int(pb, \"PacketSize\", track->par->block_align ?\n                                              track->par->block_align : 4);\n        }\n        avio_printf(pb, \"</%s>\\n\", type);\n    }\n    avio_printf(pb, \"</switch>\\n\");\n    avio_printf(pb, \"</body>\\n\");\n    avio_printf(pb, \"</smil>\\n\");\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mfhd_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    avio_wb32(pb, 16);\n    ffio_wfourcc(pb, \"mfhd\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, mov->fragments);\n    return 0;\n}\n\nstatic uint32_t get_sample_flags(MOVTrack *track, MOVIentry *entry)\n{\n    return entry->flags & MOV_SYNC_SAMPLE ? MOV_FRAG_SAMPLE_FLAG_DEPENDS_NO :\n           (MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES | MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC);\n}\n\nstatic int mov_write_tfhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int64_t moof_offset)\n{\n    int64_t pos = avio_tell(pb);\n    uint32_t flags = MOV_TFHD_DEFAULT_SIZE | MOV_TFHD_DEFAULT_DURATION |\n                     MOV_TFHD_BASE_DATA_OFFSET;\n    if (!track->entry) {\n        flags |= MOV_TFHD_DURATION_IS_EMPTY;\n    } else {\n        flags |= MOV_TFHD_DEFAULT_FLAGS;\n    }\n    if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET)\n        flags &= ~MOV_TFHD_BASE_DATA_OFFSET;\n    if (mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF) {\n        flags &= ~MOV_TFHD_BASE_DATA_OFFSET;\n        flags |= MOV_TFHD_DEFAULT_BASE_IS_MOOF;\n    }\n\n    /* Don't set a default sample size, the silverlight player refuses\n     * to play files with that set. Don't set a default sample duration,\n     * WMP freaks out if it is set. Don't set a base data offset, PIFF\n     * file format says it MUST NOT be set. */\n    if (track->mode == MODE_ISM)\n        flags &= ~(MOV_TFHD_DEFAULT_SIZE | MOV_TFHD_DEFAULT_DURATION |\n                   MOV_TFHD_BASE_DATA_OFFSET);\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"tfhd\");\n    avio_w8(pb, 0); /* version */\n    avio_wb24(pb, flags);\n\n    avio_wb32(pb, track->track_id); /* track-id */\n    if (flags & MOV_TFHD_BASE_DATA_OFFSET)\n        avio_wb64(pb, moof_offset);\n    if (flags & MOV_TFHD_DEFAULT_DURATION) {\n        track->default_duration = get_cluster_duration(track, 0);\n        avio_wb32(pb, track->default_duration);\n    }\n    if (flags & MOV_TFHD_DEFAULT_SIZE) {\n        track->default_size = track->entry ? track->cluster[0].size : 1;\n        avio_wb32(pb, track->default_size);\n    } else\n        track->default_size = -1;\n\n    if (flags & MOV_TFHD_DEFAULT_FLAGS) {\n        /* Set the default flags based on the second sample, if available.\n         * If the first sample is different, that can be signaled via a separate field. */\n        if (track->entry > 1)\n            track->default_sample_flags = get_sample_flags(track, &track->cluster[1]);\n        else\n            track->default_sample_flags =\n                track->par->codec_type == AVMEDIA_TYPE_VIDEO ?\n                (MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES | MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC) :\n                MOV_FRAG_SAMPLE_FLAG_DEPENDS_NO;\n        avio_wb32(pb, track->default_sample_flags);\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_trun_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int moof_size,\n                              int first, int end)\n{\n    int64_t pos = avio_tell(pb);\n    uint32_t flags = MOV_TRUN_DATA_OFFSET;\n    int i;\n\n    for (i = first; i < end; i++) {\n        if (get_cluster_duration(track, i) != track->default_duration)\n            flags |= MOV_TRUN_SAMPLE_DURATION;\n        if (track->cluster[i].size != track->default_size)\n            flags |= MOV_TRUN_SAMPLE_SIZE;\n        if (i > first && get_sample_flags(track, &track->cluster[i]) != track->default_sample_flags)\n            flags |= MOV_TRUN_SAMPLE_FLAGS;\n    }\n    if (!(flags & MOV_TRUN_SAMPLE_FLAGS) && track->entry > 0 &&\n         get_sample_flags(track, &track->cluster[0]) != track->default_sample_flags)\n        flags |= MOV_TRUN_FIRST_SAMPLE_FLAGS;\n    if (track->flags & MOV_TRACK_CTTS)\n        flags |= MOV_TRUN_SAMPLE_CTS;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"trun\");\n    avio_w8(pb, 0); /* version */\n    avio_wb24(pb, flags);\n\n    avio_wb32(pb, end - first); /* sample count */\n    if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET &&\n        !(mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF) &&\n        !mov->first_trun)\n        avio_wb32(pb, 0); /* Later tracks follow immediately after the previous one */\n    else\n        avio_wb32(pb, moof_size + 8 + track->data_offset +\n                      track->cluster[first].pos); /* data offset */\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS)\n        avio_wb32(pb, get_sample_flags(track, &track->cluster[first]));\n\n    for (i = first; i < end; i++) {\n        if (flags & MOV_TRUN_SAMPLE_DURATION)\n            avio_wb32(pb, get_cluster_duration(track, i));\n        if (flags & MOV_TRUN_SAMPLE_SIZE)\n            avio_wb32(pb, track->cluster[i].size);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)\n            avio_wb32(pb, get_sample_flags(track, &track->cluster[i]));\n        if (flags & MOV_TRUN_SAMPLE_CTS)\n            avio_wb32(pb, track->cluster[i].cts);\n    }\n\n    mov->first_trun = 0;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_tfxd_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    static const uint8_t uuid[] = {\n        0x6d, 0x1d, 0x9b, 0x05, 0x42, 0xd5, 0x44, 0xe6,\n        0x80, 0xe2, 0x14, 0x1d, 0xaf, 0xf7, 0x57, 0xb2\n    };\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"uuid\");\n    avio_write(pb, uuid, sizeof(uuid));\n    avio_w8(pb, 1);\n    avio_wb24(pb, 0);\n    avio_wb64(pb, track->start_dts + track->frag_start +\n                  track->cluster[0].cts);\n    avio_wb64(pb, track->end_pts -\n                  (track->cluster[0].dts + track->cluster[0].cts));\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_tfrf_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int entry)\n{\n    int n = track->nb_frag_info - 1 - entry, i;\n    int size = 8 + 16 + 4 + 1 + 16*n;\n    static const uint8_t uuid[] = {\n        0xd4, 0x80, 0x7e, 0xf2, 0xca, 0x39, 0x46, 0x95,\n        0x8e, 0x54, 0x26, 0xcb, 0x9e, 0x46, 0xa7, 0x9f\n    };\n\n    if (entry < 0)\n        return 0;\n\n    avio_seek(pb, track->frag_info[entry].tfrf_offset, SEEK_SET);\n    avio_wb32(pb, size);\n    ffio_wfourcc(pb, \"uuid\");\n    avio_write(pb, uuid, sizeof(uuid));\n    avio_w8(pb, 1);\n    avio_wb24(pb, 0);\n    avio_w8(pb, n);\n    for (i = 0; i < n; i++) {\n        int index = entry + 1 + i;\n        avio_wb64(pb, track->frag_info[index].time);\n        avio_wb64(pb, track->frag_info[index].duration);\n    }\n    if (n < mov->ism_lookahead) {\n        int free_size = 16 * (mov->ism_lookahead - n);\n        avio_wb32(pb, free_size);\n        ffio_wfourcc(pb, \"free\");\n        ffio_fill(pb, 0, free_size - 8);\n    }\n\n    return 0;\n}\n\nstatic int mov_write_tfrf_tags(AVIOContext *pb, MOVMuxContext *mov,\n                               MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    for (i = 0; i < mov->ism_lookahead; i++) {\n        /* Update the tfrf tag for the last ism_lookahead fragments,\n         * nb_frag_info - 1 is the next fragment to be written. */\n        mov_write_tfrf_tag(pb, mov, track, track->nb_frag_info - 2 - i);\n    }\n    avio_seek(pb, pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_add_tfra_entries(AVIOContext *pb, MOVMuxContext *mov, int tracks,\n                                int size)\n{\n    int i;\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        MOVFragmentInfo *info;\n        if ((tracks >= 0 && i != tracks) || !track->entry)\n            continue;\n        track->nb_frag_info++;\n        if (track->nb_frag_info >= track->frag_info_capacity) {\n            unsigned new_capacity = track->nb_frag_info + MOV_FRAG_INFO_ALLOC_INCREMENT;\n            if (av_reallocp_array(&track->frag_info,\n                                  new_capacity,\n                                  sizeof(*track->frag_info)))\n                return AVERROR(ENOMEM);\n            track->frag_info_capacity = new_capacity;\n        }\n        info = &track->frag_info[track->nb_frag_info - 1];\n        info->offset   = avio_tell(pb);\n        info->size     = size;\n        // Try to recreate the original pts for the first packet\n        // from the fields we have stored\n        info->time     = track->start_dts + track->frag_start +\n                         track->cluster[0].cts;\n        info->duration = track->end_pts -\n                         (track->cluster[0].dts + track->cluster[0].cts);\n        // If the pts is less than zero, we will have trimmed\n        // away parts of the media track using an edit list,\n        // and the corresponding start presentation time is zero.\n        if (info->time < 0) {\n            info->duration += info->time;\n            info->time = 0;\n        }\n        info->tfrf_offset = 0;\n        mov_write_tfrf_tags(pb, mov, track);\n    }\n    return 0;\n}\n\nstatic int mov_write_tfdt_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tfdt\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n    avio_wb64(pb, track->frag_start);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_traf_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int64_t moof_offset,\n                              int moof_size)\n{\n    int64_t pos = avio_tell(pb);\n    int i, start = 0;\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"traf\");\n\n    mov_write_tfhd_tag(pb, mov, track, moof_offset);\n    if (mov->mode != MODE_ISM)\n        mov_write_tfdt_tag(pb, track);\n    for (i = 1; i < track->entry; i++) {\n        if (track->cluster[i].pos != track->cluster[i - 1].pos + track->cluster[i - 1].size) {\n            mov_write_trun_tag(pb, mov, track, moof_size, start, i);\n            start = i;\n        }\n    }\n    mov_write_trun_tag(pb, mov, track, moof_size, start, track->entry);\n    if (mov->mode == MODE_ISM) {\n        mov_write_tfxd_tag(pb, track);\n\n        if (mov->ism_lookahead) {\n            int i, size = 16 + 4 + 1 + 16 * mov->ism_lookahead;\n\n            if (track->nb_frag_info > 0) {\n                MOVFragmentInfo *info = &track->frag_info[track->nb_frag_info - 1];\n                if (!info->tfrf_offset)\n                    info->tfrf_offset = avio_tell(pb);\n            }\n            avio_wb32(pb, 8 + size);\n            ffio_wfourcc(pb, \"free\");\n            for (i = 0; i < size; i++)\n                avio_w8(pb, 0);\n        }\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_moof_tag_internal(AVIOContext *pb, MOVMuxContext *mov,\n                                       int tracks, int moof_size)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"moof\");\n    mov->first_trun = 1;\n\n    mov_write_mfhd_tag(pb, mov);\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (tracks >= 0 && i != tracks)\n            continue;\n        if (!track->entry)\n            continue;\n        mov_write_traf_tag(pb, mov, track, pos, moof_size);\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_sidx_tag(AVIOContext *pb,\n                              MOVTrack *track, int ref_size, int total_sidx_size)\n{\n    int64_t pos = avio_tell(pb), offset_pos, end_pos;\n    int64_t presentation_time, duration, offset;\n    int starts_with_SAP, i, entries;\n\n    if (track->entry) {\n        entries = 1;\n        presentation_time = track->start_dts + track->frag_start +\n                            track->cluster[0].cts;\n        duration = track->end_pts -\n                   (track->cluster[0].dts + track->cluster[0].cts);\n        starts_with_SAP = track->cluster[0].flags & MOV_SYNC_SAMPLE;\n\n        // pts<0 should be cut away using edts\n        if (presentation_time < 0) {\n            duration += presentation_time;\n            presentation_time = 0;\n        }\n    } else {\n        entries = track->nb_frag_info;\n        if (entries <= 0)\n            return 0;\n        presentation_time = track->frag_info[0].time;\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"sidx\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n    avio_wb32(pb, track->track_id); /* reference_ID */\n    avio_wb32(pb, track->timescale); /* timescale */\n    avio_wb64(pb, presentation_time); /* earliest_presentation_time */\n    offset_pos = avio_tell(pb);\n    avio_wb64(pb, 0); /* first_offset (offset to referenced moof) */\n    avio_wb16(pb, 0); /* reserved */\n\n    avio_wb16(pb, entries); /* reference_count */\n    for (i = 0; i < entries; i++) {\n        if (!track->entry) {\n            if (i > 1 && track->frag_info[i].offset != track->frag_info[i - 1].offset + track->frag_info[i - 1].size) {\n               av_log(NULL, AV_LOG_ERROR, \"Non-consecutive fragments, writing incorrect sidx\\n\");\n            }\n            duration = track->frag_info[i].duration;\n            ref_size = track->frag_info[i].size;\n            starts_with_SAP = 1;\n        }\n        avio_wb32(pb, (0 << 31) | (ref_size & 0x7fffffff)); /* reference_type (0 = media) | referenced_size */\n        avio_wb32(pb, duration); /* subsegment_duration */\n        avio_wb32(pb, (starts_with_SAP << 31) | (0 << 28) | 0); /* starts_with_SAP | SAP_type | SAP_delta_time */\n    }\n\n    end_pos = avio_tell(pb);\n    offset = pos + total_sidx_size - end_pos;\n    avio_seek(pb, offset_pos, SEEK_SET);\n    avio_wb64(pb, offset);\n    avio_seek(pb, end_pos, SEEK_SET);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_sidx_tags(AVIOContext *pb, MOVMuxContext *mov,\n                               int tracks, int ref_size)\n{\n    int i, round, ret;\n    AVIOContext *avio_buf;\n    int total_size = 0;\n    for (round = 0; round < 2; round++) {\n        // First run one round to calculate the total size of all\n        // sidx atoms.\n        // This would be much simpler if we'd only write one sidx\n        // atom, for the first track in the moof.\n        if (round == 0) {\n            if ((ret = ffio_open_null_buf(&avio_buf)) < 0)\n                return ret;\n        } else {\n            avio_buf = pb;\n        }\n        for (i = 0; i < mov->nb_streams; i++) {\n            MOVTrack *track = &mov->tracks[i];\n            if (tracks >= 0 && i != tracks)\n                continue;\n            // When writing a sidx for the full file, entry is 0, but\n            // we want to include all tracks. ref_size is 0 in this case,\n            // since we read it from frag_info instead.\n            if (!track->entry && ref_size > 0)\n                continue;\n            total_size -= mov_write_sidx_tag(avio_buf, track, ref_size,\n                                             total_size);\n        }\n        if (round == 0)\n            total_size = ffio_close_null_buf(avio_buf);\n    }\n    return 0;\n}\n\nstatic int mov_write_moof_tag(AVIOContext *pb, MOVMuxContext *mov, int tracks,\n                              int64_t mdat_size)\n{\n    AVIOContext *avio_buf;\n    int ret, moof_size;\n\n    if ((ret = ffio_open_null_buf(&avio_buf)) < 0)\n        return ret;\n    mov_write_moof_tag_internal(avio_buf, mov, tracks, 0);\n    moof_size = ffio_close_null_buf(avio_buf);\n\n    if (mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX))\n        mov_write_sidx_tags(pb, mov, tracks, moof_size + 8 + mdat_size);\n\n    if ((ret = mov_add_tfra_entries(pb, mov, tracks, moof_size + 8 + mdat_size)) < 0)\n        return ret;\n\n    return mov_write_moof_tag_internal(pb, mov, tracks, moof_size);\n}\n\nstatic int mov_write_tfra_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"tfra\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n\n    avio_wb32(pb, track->track_id);\n    avio_wb32(pb, 0); /* length of traf/trun/sample num */\n    avio_wb32(pb, track->nb_frag_info);\n    for (i = 0; i < track->nb_frag_info; i++) {\n        avio_wb64(pb, track->frag_info[i].time);\n        avio_wb64(pb, track->frag_info[i].offset + track->data_offset);\n        avio_w8(pb, 1); /* traf number */\n        avio_w8(pb, 1); /* trun number */\n        avio_w8(pb, 1); /* sample number */\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mfra_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"mfra\");\n    /* An empty mfra atom is enough to indicate to the publishing point that\n     * the stream has ended. */\n    if (mov->flags & FF_MOV_FLAG_ISML)\n        return update_size(pb, pos);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (track->nb_frag_info)\n            mov_write_tfra_tag(pb, track);\n    }\n\n    avio_wb32(pb, 16);\n    ffio_wfourcc(pb, \"mfro\");\n    avio_wb32(pb, 0); /* version + flags */\n    avio_wb32(pb, avio_tell(pb) + 4 - pos);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdat_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    avio_wb32(pb, 8);    // placeholder for extended size field (64 bit)\n    ffio_wfourcc(pb, mov->mode == MODE_MOV ? \"wide\" : \"free\");\n\n    mov->mdat_pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size placeholder*/\n    ffio_wfourcc(pb, \"mdat\");\n    return 0;\n}\n\n/* TODO: This needs to be more general */\nstatic int mov_write_ftyp_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int64_t pos = avio_tell(pb);\n    int has_h264 = 0, has_video = 0;\n    int minor = 0x200;\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n            has_video = 1;\n        if (st->codecpar->codec_id == AV_CODEC_ID_H264)\n            has_h264 = 1;\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"ftyp\");\n\n    if (mov->major_brand && strlen(mov->major_brand) >= 4)\n        ffio_wfourcc(pb, mov->major_brand);\n    else if (mov->mode == MODE_3GP) {\n        ffio_wfourcc(pb, has_h264 ? \"3gp6\"  : \"3gp4\");\n        minor =     has_h264 ?   0x100 :   0x200;\n    } else if (mov->mode & MODE_3G2) {\n        ffio_wfourcc(pb, has_h264 ? \"3g2b\"  : \"3g2a\");\n        minor =     has_h264 ? 0x20000 : 0x10000;\n    } else if (mov->mode == MODE_PSP)\n        ffio_wfourcc(pb, \"MSNV\");\n    else if (mov->mode == MODE_MP4 && mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF)\n        ffio_wfourcc(pb, \"iso5\"); // Required when using default-base-is-moof\n    else if (mov->mode == MODE_MP4)\n        ffio_wfourcc(pb, \"isom\");\n    else if (mov->mode == MODE_IPOD)\n        ffio_wfourcc(pb, has_video ? \"M4V \":\"M4A \");\n    else if (mov->mode == MODE_ISM)\n        ffio_wfourcc(pb, \"isml\");\n    else if (mov->mode == MODE_F4V)\n        ffio_wfourcc(pb, \"f4v \");\n    else\n        ffio_wfourcc(pb, \"qt  \");\n\n    avio_wb32(pb, minor);\n\n    if (mov->mode == MODE_MOV)\n        ffio_wfourcc(pb, \"qt  \");\n    else if (mov->mode == MODE_ISM) {\n        ffio_wfourcc(pb, \"piff\");\n    } else if (!(mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF)) {\n        ffio_wfourcc(pb, \"isom\");\n        ffio_wfourcc(pb, \"iso2\");\n        if (has_h264)\n            ffio_wfourcc(pb, \"avc1\");\n    }\n\n    // We add tfdt atoms when fragmenting, signal this with the iso6 compatible\n    // brand. This is compatible with users that don't understand tfdt.\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT && mov->mode != MODE_ISM)\n        ffio_wfourcc(pb, \"iso6\");\n\n    if (mov->mode == MODE_3GP)\n        ffio_wfourcc(pb, has_h264 ? \"3gp6\":\"3gp4\");\n    else if (mov->mode & MODE_3G2)\n        ffio_wfourcc(pb, has_h264 ? \"3g2b\":\"3g2a\");\n    else if (mov->mode == MODE_PSP)\n        ffio_wfourcc(pb, \"MSNV\");\n    else if (mov->mode == MODE_MP4)\n        ffio_wfourcc(pb, \"mp41\");\n\n    if (mov->flags & FF_MOV_FLAG_DASH && mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n        ffio_wfourcc(pb, \"dash\");\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVStream       *video_st    = s->streams[0];\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n    int audio_rate = audio_par->sample_rate;\n    int64_t frame_rate = (video_st->avg_frame_rate.num * 0x10000LL) / video_st->avg_frame_rate.den;\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n    if (frame_rate < 0 || frame_rate > INT32_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Frame rate %f outside supported range\\n\", frame_rate / (double)0x10000);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb32(pb, 0x94); /* size */\n    ffio_wfourcc(pb, \"uuid\");\n    ffio_wfourcc(pb, \"PROF\");\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n    avio_wb32(pb, 0xbb88695c);\n    avio_wb32(pb, 0xfac9c740);\n\n    avio_wb32(pb, 0x0);  /* ? */\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n    avio_wb32(pb, 0x14); /* size */\n    ffio_wfourcc(pb, \"FPRF\");\n    avio_wb32(pb, 0x0);  /* ? */\n    avio_wb32(pb, 0x0);  /* ? */\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x2c);  /* size */\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, 0x2);   /* TrackID */\n    ffio_wfourcc(pb, \"mp4a\");\n    avio_wb32(pb, 0x20f);\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, audio_kbitrate);\n    avio_wb32(pb, audio_kbitrate);\n    avio_wb32(pb, audio_rate);\n    avio_wb32(pb, audio_par->channels);\n\n    avio_wb32(pb, 0x34);  /* size */\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, 0x1);    /* TrackID */\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n        ffio_wfourcc(pb, \"avc1\");\n        avio_wb16(pb, 0x014D);\n        avio_wb16(pb, 0x0015);\n    } else {\n        ffio_wfourcc(pb, \"mp4v\");\n        avio_wb16(pb, 0x0000);\n        avio_wb16(pb, 0x0103);\n    }\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, video_kbitrate);\n    avio_wb32(pb, video_kbitrate);\n    avio_wb32(pb, frame_rate);\n    avio_wb32(pb, frame_rate);\n    avio_wb16(pb, video_par->width);\n    avio_wb16(pb, video_par->height);\n    avio_wb32(pb, 0x010001); /* ? */\n\n    return 0;\n}\n\nstatic int mov_write_identification(AVIOContext *pb, AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i;\n\n    mov_write_ftyp_tag(pb,s);\n    if (mov->mode == MODE_PSP) {\n        int video_streams_nb = 0, audio_streams_nb = 0, other_streams_nb = 0;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n                video_streams_nb++;\n            else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n                audio_streams_nb++;\n            else\n                other_streams_nb++;\n            }\n\n        if (video_streams_nb != 1 || audio_streams_nb != 1 || other_streams_nb) {\n            av_log(s, AV_LOG_ERROR, \"PSP mode need one video and one audio stream\\n\");\n            return AVERROR(EINVAL);\n        }\n        return mov_write_uuidprof_tag(pb, s);\n    }\n    return 0;\n}\n\nstatic int mov_parse_mpeg2_frame(AVPacket *pkt, uint32_t *flags)\n{\n    uint32_t c = -1;\n    int i, closed_gop = 0;\n\n    for (i = 0; i < pkt->size - 4; i++) {\n        c = (c << 8) + pkt->data[i];\n        if (c == 0x1b8) { // gop\n            closed_gop = pkt->data[i + 4] >> 6 & 0x01;\n        } else if (c == 0x100) { // pic\n            int temp_ref = (pkt->data[i + 1] << 2) | (pkt->data[i + 2] >> 6);\n            if (!temp_ref || closed_gop) // I picture is not reordered\n                *flags = MOV_SYNC_SAMPLE;\n            else\n                *flags = MOV_PARTIAL_SYNC_SAMPLE;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic void mov_parse_vc1_frame(AVPacket *pkt, MOVTrack *trk)\n{\n    const uint8_t *start, *next, *end = pkt->data + pkt->size;\n    int seq = 0, entry = 0;\n    int key = pkt->flags & AV_PKT_FLAG_KEY;\n    start = find_next_marker(pkt->data, end);\n    for (next = start; next < end; start = next) {\n        next = find_next_marker(start + 4, end);\n        switch (AV_RB32(start)) {\n        case VC1_CODE_SEQHDR:\n            seq = 1;\n            break;\n        case VC1_CODE_ENTRYPOINT:\n            entry = 1;\n            break;\n        case VC1_CODE_SLICE:\n            trk->vc1_info.slices = 1;\n            break;\n        }\n    }\n    if (!trk->entry && trk->vc1_info.first_packet_seen)\n        trk->vc1_info.first_frag_written = 1;\n    if (!trk->entry && !trk->vc1_info.first_frag_written) {\n        /* First packet in first fragment */\n        trk->vc1_info.first_packet_seq   = seq;\n        trk->vc1_info.first_packet_entry = entry;\n        trk->vc1_info.first_packet_seen  = 1;\n    } else if ((seq && !trk->vc1_info.packet_seq) ||\n               (entry && !trk->vc1_info.packet_entry)) {\n        int i;\n        for (i = 0; i < trk->entry; i++)\n            trk->cluster[i].flags &= ~MOV_SYNC_SAMPLE;\n        trk->has_keyframes = 0;\n        if (seq)\n            trk->vc1_info.packet_seq = 1;\n        if (entry)\n            trk->vc1_info.packet_entry = 1;\n        if (!trk->vc1_info.first_frag_written) {\n            /* First fragment */\n            if ((!seq   || trk->vc1_info.first_packet_seq) &&\n                (!entry || trk->vc1_info.first_packet_entry)) {\n                /* First packet had the same headers as this one, readd the\n                 * sync sample flag. */\n                trk->cluster[0].flags |= MOV_SYNC_SAMPLE;\n                trk->has_keyframes = 1;\n            }\n        }\n    }\n    if (trk->vc1_info.packet_seq && trk->vc1_info.packet_entry)\n        key = seq && entry;\n    else if (trk->vc1_info.packet_seq)\n        key = seq;\n    else if (trk->vc1_info.packet_entry)\n        key = entry;\n    if (key) {\n        trk->cluster[trk->entry].flags |= MOV_SYNC_SAMPLE;\n        trk->has_keyframes++;\n    }\n}\n\nstatic int mov_flush_fragment_interleaving(AVFormatContext *s, MOVTrack *track)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int ret, buf_size;\n    uint8_t *buf;\n    int i, offset;\n\n    if (!track->mdat_buf)\n        return 0;\n    if (!mov->mdat_buf) {\n        if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n            return ret;\n    }\n    buf_size = avio_close_dyn_buf(track->mdat_buf, &buf);\n    track->mdat_buf = NULL;\n\n    offset = avio_tell(mov->mdat_buf);\n    avio_write(mov->mdat_buf, buf, buf_size);\n    av_free(buf);\n\n    for (i = track->entries_flushed; i < track->entry; i++)\n        track->cluster[i].pos += offset;\n    track->entries_flushed = track->entry;\n    return 0;\n}\n\nstatic int mov_flush_fragment(AVFormatContext *s, int force)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i, first_track = -1;\n    int64_t mdat_size = 0;\n    int ret;\n    int has_video = 0, starts_with_key = 0, first_video_track = 1;\n\n    if (!(mov->flags & FF_MOV_FLAG_FRAGMENT))\n        return 0;\n\n    // Try to fill in the duration of the last packet in each stream\n    // from queued packets in the interleave queues. If the flushing\n    // of fragments was triggered automatically by an AVPacket, we\n    // already have reliable info for the end of that track, but other\n    // tracks may need to be filled in.\n    for (i = 0; i < s->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (!track->end_reliable) {\n            int64_t ts_offset;\n            const AVPacket *next = ff_interleaved_peek(s, i, &ts_offset);\n            if (next) {\n                track->track_duration = next->dts - track->start_dts + ts_offset;\n                if (next->pts != AV_NOPTS_VALUE)\n                    track->end_pts = next->pts;\n                else\n                    track->end_pts = next->dts;\n                track->end_pts += ts_offset;\n            }\n        }\n    }\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (track->entry <= 1)\n            continue;\n        // Sample durations are calculated as the diff of dts values,\n        // but for the last sample in a fragment, we don't know the dts\n        // of the first sample in the next fragment, so we have to rely\n        // on what was set as duration in the AVPacket. Not all callers\n        // set this though, so we might want to replace it with an\n        // estimate if it currently is zero.\n        if (get_cluster_duration(track, track->entry - 1) != 0)\n            continue;\n        // Use the duration (i.e. dts diff) of the second last sample for\n        // the last one. This is a wild guess (and fatal if it turns out\n        // to be too long), but probably the best we can do - having a zero\n        // duration is bad as well.\n        track->track_duration += get_cluster_duration(track, track->entry - 2);\n        track->end_pts        += get_cluster_duration(track, track->entry - 2);\n        if (!mov->missing_duration_warned) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Estimating the duration of the last packet in a \"\n                   \"fragment, consider setting the duration field in \"\n                   \"AVPacket instead.\\n\");\n            mov->missing_duration_warned = 1;\n        }\n    }\n\n    if (!mov->moov_written) {\n        int64_t pos = avio_tell(s->pb);\n        uint8_t *buf;\n        int buf_size, moov_size;\n\n        for (i = 0; i < mov->nb_streams; i++)\n            if (!mov->tracks[i].entry)\n                break;\n        /* Don't write the initial moov unless all tracks have data */\n        if (i < mov->nb_streams && !force)\n            return 0;\n\n        moov_size = get_moov_size(s);\n        for (i = 0; i < mov->nb_streams; i++)\n            mov->tracks[i].data_offset = pos + moov_size + 8;\n\n        avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_HEADER);\n        if (mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n            mov_write_identification(s->pb, s);\n        if ((ret = mov_write_moov_tag(s->pb, mov, s)) < 0)\n            return ret;\n\n        if (mov->flags & FF_MOV_FLAG_DELAY_MOOV) {\n            if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n                mov->reserved_header_pos = avio_tell(s->pb);\n            avio_flush(s->pb);\n            mov->moov_written = 1;\n            return 0;\n        }\n\n        buf_size = avio_close_dyn_buf(mov->mdat_buf, &buf);\n        mov->mdat_buf = NULL;\n        avio_wb32(s->pb, buf_size + 8);\n        ffio_wfourcc(s->pb, \"mdat\");\n        avio_write(s->pb, buf, buf_size);\n        av_free(buf);\n\n        if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n            mov->reserved_header_pos = avio_tell(s->pb);\n\n        mov->moov_written = 1;\n        mov->mdat_size = 0;\n        for (i = 0; i < mov->nb_streams; i++) {\n            if (mov->tracks[i].entry)\n                mov->tracks[i].frag_start += mov->tracks[i].start_dts +\n                                             mov->tracks[i].track_duration -\n                                             mov->tracks[i].cluster[0].dts;\n            mov->tracks[i].entry = 0;\n            mov->tracks[i].end_reliable = 0;\n        }\n        avio_flush(s->pb);\n        return 0;\n    }\n\n    if (mov->frag_interleave) {\n        for (i = 0; i < mov->nb_streams; i++) {\n            MOVTrack *track = &mov->tracks[i];\n            int ret;\n            if ((ret = mov_flush_fragment_interleaving(s, track)) < 0)\n                return ret;\n        }\n\n        if (!mov->mdat_buf)\n            return 0;\n        mdat_size = avio_tell(mov->mdat_buf);\n    }\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (mov->flags & FF_MOV_FLAG_SEPARATE_MOOF || mov->frag_interleave)\n            track->data_offset = 0;\n        else\n            track->data_offset = mdat_size;\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            has_video = 1;\n            if (first_video_track) {\n                if (track->entry)\n                    starts_with_key = track->cluster[0].flags & MOV_SYNC_SAMPLE;\n                first_video_track = 0;\n            }\n        }\n        if (!track->entry)\n            continue;\n        if (track->mdat_buf)\n            mdat_size += avio_tell(track->mdat_buf);\n        if (first_track < 0)\n            first_track = i;\n    }\n\n    if (!mdat_size)\n        return 0;\n\n    avio_write_marker(s->pb,\n                      av_rescale(mov->tracks[first_track].cluster[0].dts, AV_TIME_BASE, mov->tracks[first_track].timescale),\n                      (has_video ? starts_with_key : mov->tracks[first_track].cluster[0].flags & MOV_SYNC_SAMPLE) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        int buf_size, write_moof = 1, moof_tracks = -1;\n        uint8_t *buf;\n        int64_t duration = 0;\n\n        if (track->entry)\n            duration = track->start_dts + track->track_duration -\n                       track->cluster[0].dts;\n        if (mov->flags & FF_MOV_FLAG_SEPARATE_MOOF) {\n            if (!track->mdat_buf)\n                continue;\n            mdat_size = avio_tell(track->mdat_buf);\n            moof_tracks = i;\n        } else {\n            write_moof = i == first_track;\n        }\n\n        if (write_moof) {\n            avio_flush(s->pb);\n\n            mov_write_moof_tag(s->pb, mov, moof_tracks, mdat_size);\n            mov->fragments++;\n\n            avio_wb32(s->pb, mdat_size + 8);\n            ffio_wfourcc(s->pb, \"mdat\");\n        }\n\n        if (track->entry)\n            track->frag_start += duration;\n        track->entry = 0;\n        track->entries_flushed = 0;\n        track->end_reliable = 0;\n        if (!mov->frag_interleave) {\n            if (!track->mdat_buf)\n                continue;\n            buf_size = avio_close_dyn_buf(track->mdat_buf, &buf);\n            track->mdat_buf = NULL;\n        } else {\n            if (!mov->mdat_buf)\n                continue;\n            buf_size = avio_close_dyn_buf(mov->mdat_buf, &buf);\n            mov->mdat_buf = NULL;\n        }\n\n        avio_write(s->pb, buf, buf_size);\n        av_free(buf);\n    }\n\n    mov->mdat_size = 0;\n\n    avio_flush(s->pb);\n    return 0;\n}\n\nstatic int mov_auto_flush_fragment(AVFormatContext *s, int force)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int had_moov = mov->moov_written;\n    int ret = mov_flush_fragment(s, force);\n    if (ret < 0)\n        return ret;\n    // If using delay_moov, the first flush only wrote the moov,\n    // not the actual moof+mdat pair, thus flush once again.\n    if (!had_moov && mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n        ret = mov_flush_fragment(s, force);\n    return ret;\n}\n\nstatic int check_pkt(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    int64_t ref;\n    uint64_t duration;\n\n    if (trk->entry) {\n        ref = trk->cluster[trk->entry - 1].dts;\n    } else if (   trk->start_dts != AV_NOPTS_VALUE\n               && !trk->frag_discont) {\n        ref = trk->start_dts + trk->track_duration;\n    } else\n        ref = pkt->dts; // Skip tests for the first packet\n\n    duration = pkt->dts - ref;\n    if (pkt->dts < ref || duration >= INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" / timestamp: %\"PRId64\" is out of range for mov/mp4 format\\n\",\n            duration, pkt->dts\n        );\n\n        pkt->dts = ref + 1;\n        pkt->pts = AV_NOPTS_VALUE;\n    }\n\n    if (pkt->duration < 0 || pkt->duration > INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" is invalid\\n\", pkt->duration);\n        return AVERROR(EINVAL);\n    }\n    return 0;\n}\n\nint ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecParameters *par = trk->par;\n    unsigned int samples_in_chunk = 0;\n    int size = pkt->size, ret = 0;\n    uint8_t *reformatted_data = NULL;\n\n    ret = check_pkt(s, pkt);\n    if (ret < 0)\n        return ret;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        int ret;\n        if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            if (mov->frag_interleave && mov->fragments > 0) {\n                if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {\n                    if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)\n                        return ret;\n                }\n            }\n\n            if (!trk->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = trk->mdat_buf;\n        } else {\n            if (!mov->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = mov->mdat_buf;\n        }\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static const uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        samples_in_chunk = trk->par->frame_size;\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n    else\n        samples_in_chunk = 1;\n\n    if (samples_in_chunk < 1) {\n        av_log(s, AV_LOG_ERROR, \"fatal error, input packet contains no samples\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* copy extradata if it exists */\n    if (trk->vos_len == 0 && par->extradata_size > 0 &&\n        !TAG_IS_AVCI(trk->tag) &&\n        (par->codec_id != AV_CODEC_ID_DNXHD)) {\n        trk->vos_len  = par->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, par->extradata, trk->vos_len);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n        (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n            av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n                   \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n                   \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n            return -1;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n    if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {\n        /* from x264 or from bytestream H.264 */\n        /* NAL reformatting needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n                size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);\n                if (size < 0) {\n                    ret = size;\n                    goto err;\n                }\n            } else {\n                size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n            }\n        }\n    } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&\n               (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {\n        /* extradata is Annex B, assume the bitstream is too and convert it */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);\n        }\n#if CONFIG_AC3_PARSER\n    } else if (par->codec_id == AV_CODEC_ID_EAC3) {\n        size = handle_eac3(mov, pkt, trk);\n        if (size < 0)\n            return size;\n        else if (!size)\n            goto end;\n        avio_write(pb, pkt->data, size);\n#endif\n    } else {\n        if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n            if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {\n                int nal_size_length = (par->extradata[4] & 0x3) + 1;\n                ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);\n            } else {\n                ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);\n            }\n\n            if (ret) {\n                goto err;\n            }\n        } else {\n            avio_write(pb, pkt->data, size);\n        }\n    }\n\n    if ((par->codec_id == AV_CODEC_ID_DNXHD ||\n         par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len  = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (trk->entry >= trk->cluster_capacity) {\n        unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);\n        if (av_reallocp_array(&trk->cluster, new_capacity,\n                              sizeof(*trk->cluster))) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        trk->cluster_capacity = new_capacity;\n    }\n\n    trk->cluster[trk->entry].pos              = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].chunkNum         = 0;\n    trk->cluster[trk->entry].size             = size;\n    trk->cluster[trk->entry].entries          = samples_in_chunk;\n    trk->cluster[trk->entry].dts              = pkt->dts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        if (!trk->frag_discont) {\n            /* First packet of a new fragment. We already wrote the duration\n             * of the last packet of the previous fragment based on track_duration,\n             * which might not exactly match our dts. Therefore adjust the dts\n             * of this packet to be what the previous packets duration implies. */\n            trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n            /* We also may have written the pts and the corresponding duration\n             * in sidx/tfrf/tfxd tags; make sure the sidx pts and duration match up with\n             * the next fragment. This means the cts of the first sample must\n             * be the same in all fragments, unless end_pts was updated by\n             * the packet causing the fragment to be written. */\n            if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||\n                mov->mode == MODE_ISM)\n                pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;\n        } else {\n            /* New fragment, but discontinuous from previous fragments.\n             * Pretend the duration sum of the earlier fragments is\n             * pkt->dts - trk->start_dts. */\n            trk->frag_start = pkt->dts - trk->start_dts;\n            trk->end_pts = AV_NOPTS_VALUE;\n            trk->frag_discont = 0;\n        }\n    }\n\n    if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        /* Not using edit lists and shifting the first track to start from zero.\n         * If the other streams start from a later timestamp, we won't be able\n         * to signal the difference in starting time without an edit list.\n         * Thus move the timestamp for this first sample to 0, increasing\n         * its duration instead. */\n        trk->cluster[trk->entry].dts = trk->start_dts = 0;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE) {\n        trk->start_dts = pkt->dts;\n        if (trk->frag_discont) {\n            if (mov->use_editlist) {\n                /* Pretend the whole stream started at pts=0, with earlier fragments\n                 * already written. If the stream started at pts=0, the duration sum\n                 * of earlier fragments would have been pkt->pts. */\n                trk->frag_start = pkt->pts;\n                trk->start_dts  = pkt->dts - pkt->pts;\n            } else {\n                /* Pretend the whole stream started at dts=0, with earlier fragments\n                 * already written, with a duration summing up to pkt->dts. */\n                trk->frag_start = pkt->dts;\n                trk->start_dts  = 0;\n            }\n            trk->frag_discont = 0;\n        } else if (pkt->dts && mov->moov_written)\n            av_log(s, AV_LOG_WARNING,\n                   \"Track %d starts with a nonzero dts %\"PRId64\", while the moov \"\n                   \"already has been written. Set the delay_moov flag to handle \"\n                   \"this case.\\n\",\n                   pkt->stream_index, pkt->dts);\n    }\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n    trk->last_sample_is_subtitle_end = 0;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (trk->start_cts == AV_NOPTS_VALUE)\n        trk->start_cts = pkt->pts - pkt->dts;\n    if (trk->end_pts == AV_NOPTS_VALUE)\n        trk->end_pts = trk->cluster[trk->entry].dts +\n                       trk->cluster[trk->entry].cts + pkt->duration;\n    else\n        trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +\n                                           trk->cluster[trk->entry].cts +\n                                           pkt->duration);\n\n    if (par->codec_id == AV_CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size    += size;\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n\nend:\nerr:\n\n    av_free(reformatted_data);\n    return ret;\n}\n\nstatic int mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)\n{\n        MOVMuxContext *mov = s->priv_data;\n        MOVTrack *trk = &mov->tracks[pkt->stream_index];\n        AVCodecParameters *par = trk->par;\n        int64_t frag_duration = 0;\n        int size = pkt->size;\n\n        int ret = check_pkt(s, pkt);\n        if (ret < 0)\n            return ret;\n\n        if (mov->flags & FF_MOV_FLAG_FRAG_DISCONT) {\n            int i;\n            for (i = 0; i < s->nb_streams; i++)\n                mov->tracks[i].frag_discont = 1;\n            mov->flags &= ~FF_MOV_FLAG_FRAG_DISCONT;\n        }\n\n        if (!pkt->size) {\n            if (trk->start_dts == AV_NOPTS_VALUE && trk->frag_discont) {\n                trk->start_dts = pkt->dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->start_cts = pkt->pts - pkt->dts;\n                else\n                    trk->start_cts = 0;\n            }\n\n            if (trk->par->codec_id == AV_CODEC_ID_MP4ALS) {\n                int side_size = 0;\n                uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n                if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n                    void *newextra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n                    if (!newextra)\n                        return AVERROR(ENOMEM);\n                    av_free(par->extradata);\n                    par->extradata = newextra;\n                    memcpy(par->extradata, side, side_size);\n                    par->extradata_size = side_size;\n                    mov->need_rewrite_extradata = 1;\n                }\n            }\n\n            return 0;             /* Discard 0 sized packets */\n        }\n\n        if (trk->entry && pkt->stream_index < s->nb_streams)\n            frag_duration = av_rescale_q(pkt->dts - trk->cluster[0].dts,\n                                         s->streams[pkt->stream_index]->time_base,\n                                         AV_TIME_BASE_Q);\n        if ((mov->max_fragment_duration &&\n             frag_duration >= mov->max_fragment_duration) ||\n             (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) ||\n             (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME &&\n              par->codec_type == AVMEDIA_TYPE_VIDEO &&\n              trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) {\n            if (frag_duration >= mov->min_fragment_duration) {\n                // Set the duration of this track to line up with the next\n                // sample in this track. This avoids relying on AVPacket\n                // duration, but only helps for this particular track, not\n                // for the other ones that are flushed at the same time.\n                trk->track_duration = pkt->dts - trk->start_dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->end_pts = pkt->pts;\n                else\n                    trk->end_pts = pkt->dts;\n                trk->end_reliable = 1;\n                mov_auto_flush_fragment(s, 0);\n            }\n        }\n\n        return ff_mov_write_packet(s, pkt);\n}\n\nstatic int mov_write_subtitle_end_packet(AVFormatContext *s,\n                                         int stream_index,\n                                         int64_t dts) {\n    AVPacket end;\n    uint8_t data[2] = {0};\n    int ret;\n\n    av_init_packet(&end);\n    end.size = sizeof(data);\n    end.data = data;\n    end.pts = dts;\n    end.dts = dts;\n    end.duration = 0;\n    end.stream_index = stream_index;\n\n    ret = mov_write_single_packet(s, &end);\n    av_packet_unref(&end);\n\n    return ret;\n}\n\nstatic int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    if (!pkt) {\n        mov_flush_fragment(s, 1);\n        return 1;\n    } else {\n        int i;\n        MOVMuxContext *mov = s->priv_data;\n        MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n        if (!pkt->size)\n            return mov_write_single_packet(s, pkt); /* Passthrough. */\n\n        /*\n         * Subtitles require special handling.\n         *\n         * 1) For full complaince, every track must have a sample at\n         * dts == 0, which is rarely true for subtitles. So, as soon\n         * as we see any packet with dts > 0, write an empty subtitle\n         * at dts == 0 for any subtitle track with no samples in it.\n         *\n         * 2) For each subtitle track, check if the current packet's\n         * dts is past the duration of the last subtitle sample. If\n         * so, we now need to write an end sample for that subtitle.\n         *\n         * This must be done conditionally to allow for subtitles that\n         * immediately replace each other, in which case an end sample\n         * is not needed, and is, in fact, actively harmful.\n         *\n         * 3) See mov_write_trailer for how the final end sample is\n         * handled.\n         */\n        for (i = 0; i < mov->nb_streams; i++) {\n            MOVTrack *trk = &mov->tracks[i];\n            int ret;\n\n            if (trk->par->codec_id == AV_CODEC_ID_MOV_TEXT &&\n                trk->track_duration < pkt->dts &&\n                (trk->entry == 0 || !trk->last_sample_is_subtitle_end)) {\n                ret = mov_write_subtitle_end_packet(s, i, trk->track_duration);\n                if (ret < 0) return ret;\n                trk->last_sample_is_subtitle_end = 1;\n            }\n        }\n\n        if (trk->mode == MODE_MOV && trk->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            AVPacket *opkt = pkt;\n            int reshuffle_ret, ret;\n            if (trk->is_unaligned_qt_rgb) {\n                int64_t bpc = trk->par->bits_per_coded_sample != 15 ? trk->par->bits_per_coded_sample : 16;\n                int expected_stride = ((trk->par->width * bpc + 15) >> 4)*2;\n                reshuffle_ret = ff_reshuffle_raw_rgb(s, &pkt, trk->par, expected_stride);\n                if (reshuffle_ret < 0)\n                    return reshuffle_ret;\n            } else\n                reshuffle_ret = 0;\n            if (trk->par->format == AV_PIX_FMT_PAL8 && !trk->pal_done) {\n                ret = ff_get_packet_palette(s, opkt, reshuffle_ret, trk->palette);\n                if (ret < 0)\n                    goto fail;\n                if (ret)\n                    trk->pal_done++;\n            } else if (trk->par->codec_id == AV_CODEC_ID_RAWVIDEO &&\n                       (trk->par->format == AV_PIX_FMT_GRAY8 ||\n                       trk->par->format == AV_PIX_FMT_MONOBLACK)) {\n                for (i = 0; i < pkt->size; i++)\n                    pkt->data[i] = ~pkt->data[i];\n            }\n            if (reshuffle_ret) {\n                ret = mov_write_single_packet(s, pkt);\nfail:\n                if (reshuffle_ret)\n                    av_packet_free(&pkt);\n                return ret;\n            }\n        }\n\n        return mov_write_single_packet(s, pkt);\n    }\n}\n\n// QuickTime chapters involve an additional text track with the chapter names\n// as samples, and a tref pointing from the other tracks to the chapter one.\nstatic int mov_create_chapter_track(AVFormatContext *s, int tracknum)\n{\n    AVIOContext *pb;\n\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *track = &mov->tracks[tracknum];\n    AVPacket pkt = { .stream_index = tracknum, .flags = AV_PKT_FLAG_KEY };\n    int i, len;\n\n    track->mode = mov->mode;\n    track->tag = MKTAG('t','e','x','t');\n    track->timescale = MOV_TIMESCALE;\n    track->par = avcodec_parameters_alloc();\n    if (!track->par)\n        return AVERROR(ENOMEM);\n    track->par->codec_type = AVMEDIA_TYPE_SUBTITLE;\n#if 0\n    // These properties are required to make QT recognize the chapter track\n    uint8_t chapter_properties[43] = { 0, 0, 0, 0, 0, 0, 0, 1, };\n    if (ff_alloc_extradata(track->par, sizeof(chapter_properties)))\n        return AVERROR(ENOMEM);\n    memcpy(track->par->extradata, chapter_properties, sizeof(chapter_properties));\n#else\n    if (avio_open_dyn_buf(&pb) >= 0) {\n        int size;\n        uint8_t *buf;\n\n        /* Stub header (usually for Quicktime chapter track) */\n        // TextSampleEntry\n        avio_wb32(pb, 0x01); // displayFlags\n        avio_w8(pb, 0x00);   // horizontal justification\n        avio_w8(pb, 0x00);   // vertical justification\n        avio_w8(pb, 0x00);   // bgColourRed\n        avio_w8(pb, 0x00);   // bgColourGreen\n        avio_w8(pb, 0x00);   // bgColourBlue\n        avio_w8(pb, 0x00);   // bgColourAlpha\n        // BoxRecord\n        avio_wb16(pb, 0x00); // defTextBoxTop\n        avio_wb16(pb, 0x00); // defTextBoxLeft\n        avio_wb16(pb, 0x00); // defTextBoxBottom\n        avio_wb16(pb, 0x00); // defTextBoxRight\n        // StyleRecord\n        avio_wb16(pb, 0x00); // startChar\n        avio_wb16(pb, 0x00); // endChar\n        avio_wb16(pb, 0x01); // fontID\n        avio_w8(pb, 0x00);   // fontStyleFlags\n        avio_w8(pb, 0x00);   // fontSize\n        avio_w8(pb, 0x00);   // fgColourRed\n        avio_w8(pb, 0x00);   // fgColourGreen\n        avio_w8(pb, 0x00);   // fgColourBlue\n        avio_w8(pb, 0x00);   // fgColourAlpha\n        // FontTableBox\n        avio_wb32(pb, 0x0D); // box size\n        ffio_wfourcc(pb, \"ftab\"); // box atom name\n        avio_wb16(pb, 0x01); // entry count\n        // FontRecord\n        avio_wb16(pb, 0x01); // font ID\n        avio_w8(pb, 0x00);   // font name length\n\n        if ((size = avio_close_dyn_buf(pb, &buf)) > 0) {\n            track->par->extradata = buf;\n            track->par->extradata_size = size;\n        } else {\n            av_freep(&buf);\n        }\n    }\n#endif\n\n    for (i = 0; i < s->nb_chapters; i++) {\n        AVChapter *c = s->chapters[i];\n        AVDictionaryEntry *t;\n\n        int64_t end = av_rescale_q(c->end, c->time_base, (AVRational){1,MOV_TIMESCALE});\n        pkt.pts = pkt.dts = av_rescale_q(c->start, c->time_base, (AVRational){1,MOV_TIMESCALE});\n        pkt.duration = end - pkt.dts;\n\n        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {\n            static const char encd[12] = {\n                0x00, 0x00, 0x00, 0x0C,\n                'e',  'n',  'c',  'd',\n                0x00, 0x00, 0x01, 0x00 };\n            len      = strlen(t->value);\n            pkt.size = len + 2 + 12;\n            pkt.data = av_malloc(pkt.size);\n            if (!pkt.data)\n                return AVERROR(ENOMEM);\n            AV_WB16(pkt.data, len);\n            memcpy(pkt.data + 2, t->value, len);\n            memcpy(pkt.data + len + 2, encd, sizeof(encd));\n            ff_mov_write_packet(s, &pkt);\n            av_freep(&pkt.data);\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int mov_check_timecode_track(AVFormatContext *s, AVTimecode *tc, int src_index, const char *tcstr)\n{\n    int ret;\n\n    /* compute the frame number */\n    ret = av_timecode_init_from_string(tc, find_fps(s,  s->streams[src_index]), tcstr, s);\n    return ret;\n}\n\nstatic int mov_create_timecode_track(AVFormatContext *s, int index, int src_index, AVTimecode tc)\n{\n    int ret;\n    MOVMuxContext *mov  = s->priv_data;\n    MOVTrack *track     = &mov->tracks[index];\n    AVStream *src_st    = s->streams[src_index];\n    AVPacket pkt    = {.stream_index = index, .flags = AV_PKT_FLAG_KEY, .size = 4};\n    AVRational rate = find_fps(s, src_st);\n\n    /* tmcd track based on video stream */\n    track->mode      = mov->mode;\n    track->tag       = MKTAG('t','m','c','d');\n    track->src_track = src_index;\n    track->timescale = mov->tracks[src_index].timescale;\n    if (tc.flags & AV_TIMECODE_FLAG_DROPFRAME)\n        track->timecode_flags |= MOV_TIMECODE_FLAG_DROPFRAME;\n\n    /* set st to src_st for metadata access*/\n    track->st = src_st;\n\n    /* encode context: tmcd data stream */\n    track->par = avcodec_parameters_alloc();\n    if (!track->par)\n        return AVERROR(ENOMEM);\n    track->par->codec_type = AVMEDIA_TYPE_DATA;\n    track->par->codec_tag  = track->tag;\n    track->st->avg_frame_rate = av_inv_q(rate);\n\n    /* the tmcd track just contains one packet with the frame number */\n    pkt.data = av_malloc(pkt.size);\n    if (!pkt.data)\n        return AVERROR(ENOMEM);\n    AV_WB32(pkt.data, tc.start);\n    ret = ff_mov_write_packet(s, &pkt);\n    av_free(pkt.data);\n    return ret;\n}\n\n/*\n * st->disposition controls the \"enabled\" flag in the tkhd tag.\n * QuickTime will not play a track if it is not enabled.  So make sure\n * that one track of each type (audio, video, subtitle) is enabled.\n *\n * Subtitles are special.  For audio and video, setting \"enabled\" also\n * makes the track \"default\" (i.e. it is rendered when played). For\n * subtitles, an \"enabled\" subtitle is not rendered by default, but\n * if no subtitle is enabled, the subtitle menu in QuickTime will be\n * empty!\n */\nstatic void enable_tracks(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i;\n    int enabled[AVMEDIA_TYPE_NB];\n    int first[AVMEDIA_TYPE_NB];\n\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        enabled[i] = 0;\n        first[i] = -1;\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n\n        if (st->codecpar->codec_type <= AVMEDIA_TYPE_UNKNOWN ||\n            st->codecpar->codec_type >= AVMEDIA_TYPE_NB)\n            continue;\n\n        if (first[st->codecpar->codec_type] < 0)\n            first[st->codecpar->codec_type] = i;\n        if (st->disposition & AV_DISPOSITION_DEFAULT) {\n            mov->tracks[i].flags |= MOV_TRACK_ENABLED;\n            enabled[st->codecpar->codec_type]++;\n        }\n    }\n\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        switch (i) {\n        case AVMEDIA_TYPE_VIDEO:\n        case AVMEDIA_TYPE_AUDIO:\n        case AVMEDIA_TYPE_SUBTITLE:\n            if (enabled[i] > 1)\n                mov->per_stream_grouping = 1;\n            if (!enabled[i] && first[i] >= 0)\n                mov->tracks[first[i]].flags |= MOV_TRACK_ENABLED;\n            break;\n        }\n    }\n}\n\nstatic void mov_free(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i;\n\n    if (mov->chapter_track) {\n        if (mov->tracks[mov->chapter_track].par)\n            av_freep(&mov->tracks[mov->chapter_track].par->extradata);\n        av_freep(&mov->tracks[mov->chapter_track].par);\n    }\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].tag == MKTAG('r','t','p',' '))\n            ff_mov_close_hinting(&mov->tracks[i]);\n        else if (mov->tracks[i].tag == MKTAG('t','m','c','d') && mov->nb_meta_tmcd)\n            av_freep(&mov->tracks[i].par);\n        av_freep(&mov->tracks[i].cluster);\n        av_freep(&mov->tracks[i].frag_info);\n\n        if (mov->tracks[i].vos_len)\n            av_freep(&mov->tracks[i].vos_data);\n\n        ff_mov_cenc_free(&mov->tracks[i].cenc);\n    }\n\n    av_freep(&mov->tracks);\n}\n\nstatic uint32_t rgb_to_yuv(uint32_t rgb)\n{\n    uint8_t r, g, b;\n    int y, cb, cr;\n\n    r = (rgb >> 16) & 0xFF;\n    g = (rgb >>  8) & 0xFF;\n    b = (rgb      ) & 0xFF;\n\n    y  = av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000);\n    cb = av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000);\n    cr = av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000);\n\n    return (y << 16) | (cr << 8) | cb;\n}\n\nstatic int mov_create_dvd_sub_decoder_specific_info(MOVTrack *track,\n                                                    AVStream *st)\n{\n    int i, width = 720, height = 480;\n    int have_palette = 0, have_size = 0;\n    uint32_t palette[16];\n    char *cur = st->codecpar->extradata;\n\n    while (cur && *cur) {\n        if (strncmp(\"palette:\", cur, 8) == 0) {\n            int i, count;\n            count = sscanf(cur + 8,\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\"\",\n                &palette[ 0], &palette[ 1], &palette[ 2], &palette[ 3],\n                &palette[ 4], &palette[ 5], &palette[ 6], &palette[ 7],\n                &palette[ 8], &palette[ 9], &palette[10], &palette[11],\n                &palette[12], &palette[13], &palette[14], &palette[15]);\n\n            for (i = 0; i < count; i++) {\n                palette[i] = rgb_to_yuv(palette[i]);\n            }\n            have_palette = 1;\n        } else if (!strncmp(\"size:\", cur, 5)) {\n            sscanf(cur + 5, \"%dx%d\", &width, &height);\n            have_size = 1;\n        }\n        if (have_palette && have_size)\n            break;\n        cur += strcspn(cur, \"\\n\\r\");\n        cur += strspn(cur, \"\\n\\r\");\n    }\n    if (have_palette) {\n        track->vos_data = av_malloc(16*4);\n        if (!track->vos_data)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < 16; i++) {\n            AV_WB32(track->vos_data + i * 4, palette[i]);\n        }\n        track->vos_len = 16 * 4;\n    }\n    st->codecpar->width = width;\n    st->codecpar->height = track->height = height;\n\n    return 0;\n}\n\nstatic int mov_init(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVDictionaryEntry *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);\n    int i, ret, hint_track = 0, tmcd_track = 0;\n\n    mov->fc = s;\n\n    /* Default mode == MP4 */\n    mov->mode = MODE_MP4;\n\n    if (s->oformat) {\n        if (!strcmp(\"3gp\", s->oformat->name)) mov->mode = MODE_3GP;\n        else if (!strcmp(\"3g2\", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;\n        else if (!strcmp(\"mov\", s->oformat->name)) mov->mode = MODE_MOV;\n        else if (!strcmp(\"psp\", s->oformat->name)) mov->mode = MODE_PSP;\n        else if (!strcmp(\"ipod\",s->oformat->name)) mov->mode = MODE_IPOD;\n        else if (!strcmp(\"ismv\",s->oformat->name)) mov->mode = MODE_ISM;\n        else if (!strcmp(\"f4v\", s->oformat->name)) mov->mode = MODE_F4V;\n    }\n\n    if (mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV;\n\n    /* Set the FRAGMENT flag if any of the fragmentation methods are\n     * enabled. */\n    if (mov->max_fragment_duration || mov->max_fragment_size ||\n        mov->flags & (FF_MOV_FLAG_EMPTY_MOOV |\n                      FF_MOV_FLAG_FRAG_KEYFRAME |\n                      FF_MOV_FLAG_FRAG_CUSTOM))\n        mov->flags |= FF_MOV_FLAG_FRAGMENT;\n\n    /* Set other implicit flags immediately */\n    if (mov->mode == MODE_ISM)\n        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_SEPARATE_MOOF |\n                      FF_MOV_FLAG_FRAGMENT;\n    if (mov->flags & FF_MOV_FLAG_DASH)\n        mov->flags |= FF_MOV_FLAG_FRAGMENT | FF_MOV_FLAG_EMPTY_MOOV |\n                      FF_MOV_FLAG_DEFAULT_BASE_MOOF;\n\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV && s->flags & AVFMT_FLAG_AUTO_BSF) {\n        av_log(s, AV_LOG_VERBOSE, \"Empty MOOV enabled; disabling automatic bitstream filtering\\n\");\n        s->flags &= ~AVFMT_FLAG_AUTO_BSF;\n    }\n\n    if (mov->flags & FF_MOV_FLAG_FASTSTART) {\n        mov->reserved_moov_size = -1;\n    }\n\n    if (mov->use_editlist < 0) {\n        mov->use_editlist = 1;\n        if (mov->flags & FF_MOV_FLAG_FRAGMENT &&\n            !(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) {\n            // If we can avoid needing an edit list by shifting the\n            // tracks, prefer that over (trying to) write edit lists\n            // in fragmented output.\n            if (s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO ||\n                s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)\n                mov->use_editlist = 0;\n        }\n    }\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV &&\n        !(mov->flags & FF_MOV_FLAG_DELAY_MOOV) && mov->use_editlist)\n        av_log(s, AV_LOG_WARNING, \"No meaningful edit list will be written when using empty_moov without delay_moov\\n\");\n\n    if (!mov->use_editlist && s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO)\n        s->avoid_negative_ts = AVFMT_AVOID_NEG_TS_MAKE_ZERO;\n\n    /* Clear the omit_tfhd_offset flag if default_base_moof is set;\n     * if the latter is set that's enough and omit_tfhd_offset doesn't\n     * add anything extra on top of that. */\n    if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET &&\n        mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF)\n        mov->flags &= ~FF_MOV_FLAG_OMIT_TFHD_OFFSET;\n\n    if (mov->frag_interleave &&\n        mov->flags & (FF_MOV_FLAG_OMIT_TFHD_OFFSET | FF_MOV_FLAG_SEPARATE_MOOF)) {\n        av_log(s, AV_LOG_ERROR,\n               \"Sample interleaving in fragments is mutually exclusive with \"\n               \"omit_tfhd_offset and separate_moof\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* Non-seekable output is ok if using fragmentation. If ism_lookahead\n     * is enabled, we don't support non-seekable output at all. */\n    if (!s->pb->seekable &&\n        (!(mov->flags & FF_MOV_FLAG_FRAGMENT) || mov->ism_lookahead)) {\n        av_log(s, AV_LOG_ERROR, \"muxer does not support non seekable output\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    mov->nb_streams = s->nb_streams;\n    if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters)\n        mov->chapter_track = mov->nb_streams++;\n\n    if (mov->flags & FF_MOV_FLAG_RTP_HINT) {\n        /* Add hint tracks for each audio and video stream */\n        hint_track = mov->nb_streams;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n                mov->nb_streams++;\n            }\n        }\n    }\n\n    if (   mov->write_tmcd == -1 && (mov->mode == MODE_MOV || mov->mode == MODE_MP4)\n        || mov->write_tmcd == 1) {\n        tmcd_track = mov->nb_streams;\n\n        /* +1 tmcd track for each video stream with a timecode */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            AVDictionaryEntry *t = global_tcr;\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n                (t || (t=av_dict_get(st->metadata, \"timecode\", NULL, 0)))) {\n                AVTimecode tc;\n                ret = mov_check_timecode_track(s, &tc, i, t->value);\n                if (ret >= 0)\n                    mov->nb_meta_tmcd++;\n            }\n        }\n\n        /* check if there is already a tmcd track to remux */\n        if (mov->nb_meta_tmcd) {\n            for (i = 0; i < s->nb_streams; i++) {\n                AVStream *st = s->streams[i];\n                if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {\n                    av_log(s, AV_LOG_WARNING, \"You requested a copy of the original timecode track \"\n                           \"so timecode metadata are now ignored\\n\");\n                    mov->nb_meta_tmcd = 0;\n                }\n            }\n        }\n\n        mov->nb_streams += mov->nb_meta_tmcd;\n    }\n\n    // Reserve an extra stream for chapters for the case where chapters\n    // are written in the trailer\n    mov->tracks = av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks));\n    if (!mov->tracks)\n        return AVERROR(ENOMEM);\n\n    if (mov->encryption_scheme_str != NULL && strcmp(mov->encryption_scheme_str, \"none\") != 0) {\n        if (strcmp(mov->encryption_scheme_str, \"cenc-aes-ctr\") == 0) {\n            mov->encryption_scheme = MOV_ENC_CENC_AES_CTR;\n\n            if (mov->encryption_key_len != AES_CTR_KEY_SIZE) {\n                av_log(s, AV_LOG_ERROR, \"Invalid encryption key len %d expected %d\\n\",\n                    mov->encryption_key_len, AES_CTR_KEY_SIZE);\n                return AVERROR(EINVAL);\n            }\n\n            if (mov->encryption_kid_len != CENC_KID_SIZE) {\n                av_log(s, AV_LOG_ERROR, \"Invalid encryption kid len %d expected %d\\n\",\n                    mov->encryption_kid_len, CENC_KID_SIZE);\n                return AVERROR(EINVAL);\n            }\n        } else {\n            av_log(s, AV_LOG_ERROR, \"unsupported encryption scheme %s\\n\",\n                mov->encryption_scheme_str);\n            return AVERROR(EINVAL);\n        }\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st= s->streams[i];\n        MOVTrack *track= &mov->tracks[i];\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        track->st  = st;\n        track->par = st->codecpar;\n        track->language = ff_mov_iso639_to_lang(lang?lang->value:\"und\", mov->mode!=MODE_MOV);\n        if (track->language < 0)\n            track->language = 0;\n        track->mode = mov->mode;\n        track->tag  = mov_find_codec_tag(s, track);\n        if (!track->tag) {\n            av_log(s, AV_LOG_ERROR, \"Could not find tag for codec %s in stream #%d, \"\n                   \"codec not currently supported in container\\n\",\n                   avcodec_get_name(st->codecpar->codec_id), i);\n            return AVERROR(EINVAL);\n        }\n        /* If hinting of this track is enabled by a later hint track,\n         * this is updated. */\n        track->hint_track = -1;\n        track->start_dts  = AV_NOPTS_VALUE;\n        track->start_cts  = AV_NOPTS_VALUE;\n        track->end_pts    = AV_NOPTS_VALUE;\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            if (track->tag == MKTAG('m','x','3','p') || track->tag == MKTAG('m','x','3','n') ||\n                track->tag == MKTAG('m','x','4','p') || track->tag == MKTAG('m','x','4','n') ||\n                track->tag == MKTAG('m','x','5','p') || track->tag == MKTAG('m','x','5','n')) {\n                if (st->codecpar->width != 720 || (st->codecpar->height != 608 && st->codecpar->height != 512)) {\n                    av_log(s, AV_LOG_ERROR, \"D-10/IMX must use 720x608 or 720x512 video resolution\\n\");\n                    return AVERROR(EINVAL);\n                }\n                track->height = track->tag >> 24 == 'n' ? 486 : 576;\n            }\n            if (mov->video_track_timescale) {\n                track->timescale = mov->video_track_timescale;\n            } else {\n                track->timescale = st->time_base.den;\n                while(track->timescale < 10000)\n                    track->timescale *= 2;\n            }\n            if (st->codecpar->width > 65535 || st->codecpar->height > 65535) {\n                av_log(s, AV_LOG_ERROR, \"Resolution %dx%d too large for mov/mp4\\n\", st->codecpar->width, st->codecpar->height);\n                return AVERROR(EINVAL);\n            }\n            if (track->mode == MODE_MOV && track->timescale > 100000)\n                av_log(s, AV_LOG_WARNING,\n                       \"WARNING codec timebase is very high. If duration is too long,\\n\"\n                       \"file may not be playable by quicktime. Specify a shorter timebase\\n\"\n                       \"or choose different container.\\n\");\n            if (track->mode == MODE_MOV &&\n                track->par->codec_id == AV_CODEC_ID_RAWVIDEO &&\n                track->tag == MKTAG('r','a','w',' ')) {\n                enum AVPixelFormat pix_fmt = track->par->format;\n                if (pix_fmt == AV_PIX_FMT_NONE && track->par->bits_per_coded_sample == 1)\n                    pix_fmt = AV_PIX_FMT_MONOWHITE;\n                track->is_unaligned_qt_rgb =\n                        pix_fmt == AV_PIX_FMT_RGB24 ||\n                        pix_fmt == AV_PIX_FMT_BGR24 ||\n                        pix_fmt == AV_PIX_FMT_PAL8 ||\n                        pix_fmt == AV_PIX_FMT_GRAY8 ||\n                        pix_fmt == AV_PIX_FMT_MONOWHITE ||\n                        pix_fmt == AV_PIX_FMT_MONOBLACK;\n            }\n            if (track->mode == MODE_MP4 &&\n                track->par->codec_id == AV_CODEC_ID_VP9) {\n                if (s->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"VP9 in MP4 support is experimental, add \"\n                           \"'-strict %d' if you want to use it.\\n\",\n                           FF_COMPLIANCE_EXPERIMENTAL);\n                    return AVERROR_EXPERIMENTAL;\n                }\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            track->timescale = st->codecpar->sample_rate;\n            if (!st->codecpar->frame_size && !av_get_bits_per_sample(st->codecpar->codec_id)) {\n                av_log(s, AV_LOG_WARNING, \"track %d: codec frame size is not set\\n\", i);\n                track->audio_vbr = 1;\n            }else if (st->codecpar->codec_id == AV_CODEC_ID_ADPCM_MS ||\n                     st->codecpar->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||\n                     st->codecpar->codec_id == AV_CODEC_ID_ILBC){\n                if (!st->codecpar->block_align) {\n                    av_log(s, AV_LOG_ERROR, \"track %d: codec block align is not set for adpcm\\n\", i);\n                    return AVERROR(EINVAL);\n                }\n                track->sample_size = st->codecpar->block_align;\n            }else if (st->codecpar->frame_size > 1){ /* assume compressed audio */\n                track->audio_vbr = 1;\n            }else{\n                track->sample_size = (av_get_bits_per_sample(st->codecpar->codec_id) >> 3) * st->codecpar->channels;\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_ILBC ||\n                st->codecpar->codec_id == AV_CODEC_ID_ADPCM_IMA_QT) {\n                track->audio_vbr = 1;\n            }\n            if (track->mode != MODE_MOV &&\n                track->par->codec_id == AV_CODEC_ID_MP3 && track->timescale < 16000) {\n                if (s->strict_std_compliance >= FF_COMPLIANCE_NORMAL) {\n                    av_log(s, AV_LOG_ERROR, \"track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\\n\",\n                        i, track->par->sample_rate);\n                    return AVERROR(EINVAL);\n                } else {\n                    av_log(s, AV_LOG_WARNING, \"track %d: muxing mp3 at %dhz is not standard in MP4\\n\",\n                           i, track->par->sample_rate);\n                }\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            track->timescale = st->time_base.den;\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n            track->timescale = st->time_base.den;\n        } else {\n            track->timescale = MOV_TIMESCALE;\n        }\n        if (!track->height)\n            track->height = st->codecpar->height;\n        /* The ism specific timescale isn't mandatory, but is assumed by\n         * some tools, such as mp4split. */\n        if (mov->mode == MODE_ISM)\n            track->timescale = 10000000;\n\n        avpriv_set_pts_info(st, 64, 1, track->timescale);\n\n        if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n            ret = ff_mov_cenc_init(&track->cenc, mov->encryption_key,\n                track->par->codec_id == AV_CODEC_ID_H264, s->flags & AVFMT_FLAG_BITEXACT);\n            if (ret)\n                return ret;\n        }\n    }\n\n    enable_tracks(s);\n    return 0;\n}\n\nstatic int mov_write_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    MOVMuxContext *mov = s->priv_data;\n    AVDictionaryEntry *t, *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);\n    int i, ret, hint_track = 0, tmcd_track = 0, nb_tracks = s->nb_streams;\n\n    if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters)\n        nb_tracks++;\n\n    if (mov->flags & FF_MOV_FLAG_RTP_HINT) {\n        /* Add hint tracks for each audio and video stream */\n        hint_track = nb_tracks;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n                nb_tracks++;\n            }\n        }\n    }\n\n    if (mov->mode == MODE_MOV || mov->mode == MODE_MP4)\n        tmcd_track = nb_tracks;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        int j;\n        AVStream *st= s->streams[i];\n        MOVTrack *track= &mov->tracks[i];\n\n        /* copy extradata if it exists */\n        if (st->codecpar->extradata_size) {\n            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n                mov_create_dvd_sub_decoder_specific_info(track, st);\n            else if (!TAG_IS_AVCI(track->tag) && st->codecpar->codec_id != AV_CODEC_ID_DNXHD) {\n                track->vos_len  = st->codecpar->extradata_size;\n                track->vos_data = av_malloc(track->vos_len);\n                if (!track->vos_data) {\n                    return AVERROR(ENOMEM);\n                }\n                memcpy(track->vos_data, st->codecpar->extradata, track->vos_len);\n            }\n        }\n\n        if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO ||\n            track->par->channel_layout != AV_CH_LAYOUT_MONO)\n            continue;\n\n        for (j = 0; j < s->nb_streams; j++) {\n            AVStream *stj= s->streams[j];\n            MOVTrack *trackj= &mov->tracks[j];\n            if (j == i)\n                continue;\n\n            if (stj->codecpar->codec_type != AVMEDIA_TYPE_AUDIO ||\n                trackj->par->channel_layout != AV_CH_LAYOUT_MONO ||\n                trackj->language != track->language ||\n                trackj->tag != track->tag\n            )\n                continue;\n            track->multichannel_as_mono++;\n        }\n    }\n\n    if (!(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) {\n        if ((ret = mov_write_identification(pb, s)) < 0)\n            return ret;\n    }\n\n    if (mov->reserved_moov_size){\n        mov->reserved_header_pos = avio_tell(pb);\n        if (mov->reserved_moov_size > 0)\n            avio_skip(pb, mov->reserved_moov_size);\n    }\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        /* If no fragmentation options have been set, set a default. */\n        if (!(mov->flags & (FF_MOV_FLAG_FRAG_KEYFRAME |\n                            FF_MOV_FLAG_FRAG_CUSTOM)) &&\n            !mov->max_fragment_duration && !mov->max_fragment_size)\n            mov->flags |= FF_MOV_FLAG_FRAG_KEYFRAME;\n    } else {\n        if (mov->flags & FF_MOV_FLAG_FASTSTART)\n            mov->reserved_header_pos = avio_tell(pb);\n        mov_write_mdat_tag(pb, mov);\n    }\n\n    ff_parse_creation_time_metadata(s, &mov->time, 1);\n    if (mov->time)\n        mov->time += 0x7C25B080; // 1970 based -> 1904 based\n\n    if (mov->chapter_track)\n        if ((ret = mov_create_chapter_track(s, mov->chapter_track)) < 0)\n            return ret;\n\n    if (mov->flags & FF_MOV_FLAG_RTP_HINT) {\n        /* Initialize the hint tracks for each audio and video stream */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n                if ((ret = ff_mov_init_hinting(s, hint_track, i)) < 0)\n                    return ret;\n                hint_track++;\n            }\n        }\n    }\n\n    if (mov->nb_meta_tmcd) {\n        /* Initialize the tmcd tracks */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            t = global_tcr;\n\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n                AVTimecode tc;\n                if (!t)\n                    t = av_dict_get(st->metadata, \"timecode\", NULL, 0);\n                if (!t)\n                    continue;\n                if (mov_check_timecode_track(s, &tc, i, t->value) < 0)\n                    continue;\n                if ((ret = mov_create_timecode_track(s, tmcd_track, i, tc)) < 0)\n                    return ret;\n                tmcd_track++;\n            }\n        }\n    }\n\n    avio_flush(pb);\n\n    if (mov->flags & FF_MOV_FLAG_ISML)\n        mov_write_isml_manifest(pb, mov, s);\n\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV &&\n        !(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) {\n        if ((ret = mov_write_moov_tag(pb, mov, s)) < 0)\n            return ret;\n        avio_flush(pb);\n        mov->moov_written = 1;\n        if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n            mov->reserved_header_pos = avio_tell(pb);\n    }\n\n    return 0;\n}\n\nstatic int get_moov_size(AVFormatContext *s)\n{\n    int ret;\n    AVIOContext *moov_buf;\n    MOVMuxContext *mov = s->priv_data;\n\n    if ((ret = ffio_open_null_buf(&moov_buf)) < 0)\n        return ret;\n    if ((ret = mov_write_moov_tag(moov_buf, mov, s)) < 0)\n        return ret;\n    return ffio_close_null_buf(moov_buf);\n}\n\nstatic int get_sidx_size(AVFormatContext *s)\n{\n    int ret;\n    AVIOContext *buf;\n    MOVMuxContext *mov = s->priv_data;\n\n    if ((ret = ffio_open_null_buf(&buf)) < 0)\n        return ret;\n    mov_write_sidx_tags(buf, mov, -1, 0);\n    return ffio_close_null_buf(buf);\n}\n\n/*\n * This function gets the moov size if moved to the top of the file: the chunk\n * offset table can switch between stco (32-bit entries) to co64 (64-bit\n * entries) when the moov is moved to the beginning, so the size of the moov\n * would change. It also updates the chunk offset tables.\n */\nstatic int compute_moov_size(AVFormatContext *s)\n{\n    int i, moov_size, moov_size2;\n    MOVMuxContext *mov = s->priv_data;\n\n    moov_size = get_moov_size(s);\n    if (moov_size < 0)\n        return moov_size;\n\n    for (i = 0; i < mov->nb_streams; i++)\n        mov->tracks[i].data_offset += moov_size;\n\n    moov_size2 = get_moov_size(s);\n    if (moov_size2 < 0)\n        return moov_size2;\n\n    /* if the size changed, we just switched from stco to co64 and need to\n     * update the offsets */\n    if (moov_size2 != moov_size)\n        for (i = 0; i < mov->nb_streams; i++)\n            mov->tracks[i].data_offset += moov_size2 - moov_size;\n\n    return moov_size2;\n}\n\nstatic int compute_sidx_size(AVFormatContext *s)\n{\n    int i, sidx_size;\n    MOVMuxContext *mov = s->priv_data;\n\n    sidx_size = get_sidx_size(s);\n    if (sidx_size < 0)\n        return sidx_size;\n\n    for (i = 0; i < mov->nb_streams; i++)\n        mov->tracks[i].data_offset += sidx_size;\n\n    return sidx_size;\n}\n\nstatic int shift_data(AVFormatContext *s)\n{\n    int ret = 0, moov_size;\n    MOVMuxContext *mov = s->priv_data;\n    int64_t pos, pos_end = avio_tell(s->pb);\n    uint8_t *buf, *read_buf[2];\n    int read_buf_id = 0;\n    int read_size[2];\n    AVIOContext *read_pb;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT)\n        moov_size = compute_sidx_size(s);\n    else\n        moov_size = compute_moov_size(s);\n    if (moov_size < 0)\n        return moov_size;\n\n    buf = av_malloc(moov_size * 2);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    read_buf[0] = buf;\n    read_buf[1] = buf + moov_size;\n\n    /* Shift the data: the AVIO context of the output can only be used for\n     * writing, so we re-open the same output, but for reading. It also avoids\n     * a read/seek/write/seek back and forth. */\n    avio_flush(s->pb);\n    ret = s->io_open(s, &read_pb, s->filename, AVIO_FLAG_READ, NULL);\n    if (ret < 0) {\n        av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"\n               \"the second pass (faststart)\\n\", s->filename);\n        goto end;\n    }\n\n    /* mark the end of the shift to up to the last data we wrote, and get ready\n     * for writing */\n    pos_end = avio_tell(s->pb);\n    avio_seek(s->pb, mov->reserved_header_pos + moov_size, SEEK_SET);\n\n    /* start reading at where the new moov will be placed */\n    avio_seek(read_pb, mov->reserved_header_pos, SEEK_SET);\n    pos = avio_tell(read_pb);\n\n#define READ_BLOCK do {                                                             \\\n    read_size[read_buf_id] = avio_read(read_pb, read_buf[read_buf_id], moov_size);  \\\n    read_buf_id ^= 1;                                                               \\\n} while (0)\n\n    /* shift data by chunk of at most moov_size */\n    READ_BLOCK;\n    do {\n        int n;\n        READ_BLOCK;\n        n = read_size[read_buf_id];\n        if (n <= 0)\n            break;\n        avio_write(s->pb, read_buf[read_buf_id], n);\n        pos += n;\n    } while (pos < pos_end);\n    ff_format_io_close(s, &read_pb);\n\nend:\n    av_free(buf);\n    return ret;\n}\n\nstatic int mov_write_trailer(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int res = 0;\n    int i;\n    int64_t moov_pos;\n\n    if (mov->need_rewrite_extradata) {\n        for (i = 0; i < s->nb_streams; i++) {\n            MOVTrack *track = &mov->tracks[i];\n            AVCodecParameters *par = track->par;\n\n            track->vos_len  = par->extradata_size;\n            track->vos_data = av_malloc(track->vos_len);\n            if (!track->vos_data)\n                return AVERROR(ENOMEM);\n            memcpy(track->vos_data, par->extradata, track->vos_len);\n        }\n        mov->need_rewrite_extradata = 0;\n    }\n\n    /*\n     * Before actually writing the trailer, make sure that there are no\n     * dangling subtitles, that need a terminating sample.\n     */\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *trk = &mov->tracks[i];\n        if (trk->par->codec_id == AV_CODEC_ID_MOV_TEXT &&\n            !trk->last_sample_is_subtitle_end) {\n            mov_write_subtitle_end_packet(s, i, trk->track_duration);\n            trk->last_sample_is_subtitle_end = 1;\n        }\n    }\n\n    // If there were no chapters when the header was written, but there\n    // are chapters now, write them in the trailer.  This only works\n    // when we are not doing fragments.\n    if (!mov->chapter_track && !(mov->flags & FF_MOV_FLAG_FRAGMENT)) {\n        if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters) {\n            mov->chapter_track = mov->nb_streams++;\n            if ((res = mov_create_chapter_track(s, mov->chapter_track)) < 0)\n                return res;\n        }\n    }\n\n    if (!(mov->flags & FF_MOV_FLAG_FRAGMENT)) {\n        moov_pos = avio_tell(pb);\n\n        /* Write size of mdat tag */\n        if (mov->mdat_size + 8 <= UINT32_MAX) {\n            avio_seek(pb, mov->mdat_pos, SEEK_SET);\n            avio_wb32(pb, mov->mdat_size + 8);\n        } else {\n            /* overwrite 'wide' placeholder atom */\n            avio_seek(pb, mov->mdat_pos - 8, SEEK_SET);\n            /* special value: real atom size will be 64 bit value after\n             * tag field */\n            avio_wb32(pb, 1);\n            ffio_wfourcc(pb, \"mdat\");\n            avio_wb64(pb, mov->mdat_size + 16);\n        }\n        avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET);\n\n        if (mov->flags & FF_MOV_FLAG_FASTSTART) {\n            av_log(s, AV_LOG_INFO, \"Starting second pass: moving the moov atom to the beginning of the file\\n\");\n            res = shift_data(s);\n            if (res < 0)\n                return res;\n            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);\n            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)\n                return res;\n        } else if (mov->reserved_moov_size > 0) {\n            int64_t size;\n            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)\n                return res;\n            size = mov->reserved_moov_size - (avio_tell(pb) - mov->reserved_header_pos);\n            if (size < 8){\n                av_log(s, AV_LOG_ERROR, \"reserved_moov_size is too small, needed %\"PRId64\" additional\\n\", 8-size);\n                return AVERROR(EINVAL);\n            }\n            avio_wb32(pb, size);\n            ffio_wfourcc(pb, \"free\");\n            ffio_fill(pb, 0, size - 8);\n            avio_seek(pb, moov_pos, SEEK_SET);\n        } else {\n            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)\n                return res;\n        }\n        res = 0;\n    } else {\n        mov_auto_flush_fragment(s, 1);\n        for (i = 0; i < mov->nb_streams; i++)\n           mov->tracks[i].data_offset = 0;\n        if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX) {\n            int64_t end;\n            av_log(s, AV_LOG_INFO, \"Starting second pass: inserting sidx atoms\\n\");\n            res = shift_data(s);\n            if (res < 0)\n                return res;\n            end = avio_tell(pb);\n            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);\n            mov_write_sidx_tags(pb, mov, -1, 0);\n            avio_seek(pb, end, SEEK_SET);\n            avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER);\n            mov_write_mfra_tag(pb, mov);\n        } else {\n            avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER);\n            mov_write_mfra_tag(pb, mov);\n        }\n    }\n\n    return res;\n}\n\nstatic int mov_check_bitstream(struct AVFormatContext *s, const AVPacket *pkt)\n{\n    int ret = 1;\n    AVStream *st = s->streams[pkt->stream_index];\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_AAC) {\n        if (pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0)\n            ret = ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL);\n    }\n\n    return ret;\n}\n\n#if CONFIG_MOV_MUXER\nMOV_CLASS(mov)\nAVOutputFormat ff_mov_muxer = {\n    .name              = \"mov\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),\n    .extensions        = \"mov\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = CONFIG_LIBX264_ENCODER ?\n                         AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){\n        ff_codec_movvideo_tags, ff_codec_movaudio_tags, 0\n    },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &mov_muxer_class,\n};\n#endif\n#if CONFIG_TGP_MUXER\nMOV_CLASS(tgp)\nAVOutputFormat ff_tgp_muxer = {\n    .name              = \"3gp\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP (3GPP file format)\"),\n    .extensions        = \"3gp\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AMR_NB,\n    .video_codec       = AV_CODEC_ID_H263,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ codec_3gp_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &tgp_muxer_class,\n};\n#endif\n#if CONFIG_MP4_MUXER\nMOV_CLASS(mp4)\nAVOutputFormat ff_mp4_muxer = {\n    .name              = \"mp4\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\"),\n    .mime_type         = \"video/mp4\",\n    .extensions        = \"mp4\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = CONFIG_LIBX264_ENCODER ?\n                         AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ ff_mp4_obj_type, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &mp4_muxer_class,\n};\n#endif\n#if CONFIG_PSP_MUXER\nMOV_CLASS(psp)\nAVOutputFormat ff_psp_muxer = {\n    .name              = \"psp\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"PSP MP4 (MPEG-4 Part 14)\"),\n    .extensions        = \"mp4,psp\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = CONFIG_LIBX264_ENCODER ?\n                         AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ ff_mp4_obj_type, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &psp_muxer_class,\n};\n#endif\n#if CONFIG_TG2_MUXER\nMOV_CLASS(tg2)\nAVOutputFormat ff_tg2_muxer = {\n    .name              = \"3g2\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP2 (3GPP2 file format)\"),\n    .extensions        = \"3g2\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AMR_NB,\n    .video_codec       = AV_CODEC_ID_H263,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ codec_3gp_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &tg2_muxer_class,\n};\n#endif\n#if CONFIG_IPOD_MUXER\nMOV_CLASS(ipod)\nAVOutputFormat ff_ipod_muxer = {\n    .name              = \"ipod\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"iPod H.264 MP4 (MPEG-4 Part 14)\"),\n    .mime_type         = \"video/mp4\",\n    .extensions        = \"m4v,m4a\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_H264,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ codec_ipod_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &ipod_muxer_class,\n};\n#endif\n#if CONFIG_ISMV_MUXER\nMOV_CLASS(ismv)\nAVOutputFormat ff_ismv_muxer = {\n    .name              = \"ismv\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"ISMV/ISMA (Smooth Streaming)\"),\n    .mime_type         = \"video/mp4\",\n    .extensions        = \"ismv,isma\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_H264,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ ff_mp4_obj_type, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &ismv_muxer_class,\n};\n#endif\n#if CONFIG_F4V_MUXER\nMOV_CLASS(f4v)\nAVOutputFormat ff_f4v_muxer = {\n    .name              = \"f4v\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"F4V Adobe Flash Video\"),\n    .mime_type         = \"application/f4v\",\n    .extensions        = \"f4v\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_H264,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH,\n    .codec_tag         = (const AVCodecTag* const []){ codec_f4v_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &f4v_muxer_class,\n};\n#endif\n"], "fixing_code": ["/*\n * MOV, 3GP, MP4 muxer\n * Copyright (c) 2003 Thomas Raivio\n * Copyright (c) 2004 Gildas Bazin <gbazin at videolan dot org>\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <stdint.h>\n#include <inttypes.h>\n\n#include \"movenc.h\"\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"riff.h\"\n#include \"avio.h\"\n#include \"isom.h\"\n#include \"avc.h\"\n#include \"libavcodec/ac3_parser.h\"\n#include \"libavcodec/dnxhddata.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/vc1_common.h\"\n#include \"libavcodec/raw.h\"\n#include \"internal.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/libm.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavutil/color_utils.h\"\n#include \"hevc.h\"\n#include \"rtpenc.h\"\n#include \"mov_chan.h\"\n#include \"vpcc.h\"\n\nstatic const AVOption options[] = {\n    { \"movflags\", \"MOV muxer flags\", offsetof(MOVMuxContext, flags), AV_OPT_TYPE_FLAGS, {.i64 = 0}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"rtphint\", \"Add RTP hint tracks\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_RTP_HINT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"moov_size\", \"maximum moov size so it can be placed at the begin\", offsetof(MOVMuxContext, reserved_moov_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, 0 },\n    { \"empty_moov\", \"Make the initial moov atom empty\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_EMPTY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"frag_keyframe\", \"Fragment at video keyframes\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_KEYFRAME}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"separate_moof\", \"Write separate moof/mdat atoms for each track\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_SEPARATE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"frag_custom\", \"Flush fragments on caller requests\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_CUSTOM}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"isml\", \"Create a live smooth streaming feed (for pushing to a publishing point)\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_ISML}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"faststart\", \"Run a second pass to put the index (moov atom) at the beginning of the file\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FASTSTART}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"omit_tfhd_offset\", \"Omit the base data offset in tfhd atoms\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_OMIT_TFHD_OFFSET}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"disable_chpl\", \"Disable Nero chapter atom\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DISABLE_CHPL}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"default_base_moof\", \"Set the default-base-is-moof flag in tfhd atoms\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DEFAULT_BASE_MOOF}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"dash\", \"Write DASH compatible fragmented MP4\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DASH}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"frag_discont\", \"Signal that the next fragment is discontinuous from earlier ones\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_FRAG_DISCONT}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"delay_moov\", \"Delay writing the initial moov until the first fragment is cut, or until the first fragment flush\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_DELAY_MOOV}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"global_sidx\", \"Write a global sidx index at the start of the file\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_GLOBAL_SIDX}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"write_colr\", \"Write colr atom (Experimental, may be renamed or changed, do not use from scripts)\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_COLR}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"write_gama\", \"Write deprecated gama atom\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_WRITE_GAMA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    { \"use_metadata_tags\", \"Use mdta atom for metadata.\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_USE_MDTA}, INT_MIN, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM, \"movflags\" },\n    FF_RTP_FLAG_OPTS(MOVMuxContext, rtp_flags),\n    { \"skip_iods\", \"Skip writing iods atom.\", offsetof(MOVMuxContext, iods_skip), AV_OPT_TYPE_BOOL, {.i64 = 1}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"iods_audio_profile\", \"iods audio profile atom.\", offsetof(MOVMuxContext, iods_audio_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"iods_video_profile\", \"iods video profile atom.\", offsetof(MOVMuxContext, iods_video_profile), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 255, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"frag_duration\", \"Maximum fragment duration\", offsetof(MOVMuxContext, max_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"min_frag_duration\", \"Minimum fragment duration\", offsetof(MOVMuxContext, min_fragment_duration), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"frag_size\", \"Maximum fragment size\", offsetof(MOVMuxContext, max_fragment_size), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"ism_lookahead\", \"Number of lookahead entries for ISM files\", offsetof(MOVMuxContext, ism_lookahead), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"video_track_timescale\", \"set timescale of all video tracks\", offsetof(MOVMuxContext, video_track_timescale), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"brand\",    \"Override major brand\", offsetof(MOVMuxContext, major_brand),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"use_editlist\", \"use edit list\", offsetof(MOVMuxContext, use_editlist), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"fragment_index\", \"Fragment number of the next fragment\", offsetof(MOVMuxContext, fragments), AV_OPT_TYPE_INT, {.i64 = 1}, 1, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"mov_gamma\", \"gamma value for gama atom\", offsetof(MOVMuxContext, gamma), AV_OPT_TYPE_FLOAT, {.dbl = 0.0 }, 0.0, 10, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"frag_interleave\", \"Interleave samples within fragments (max number of consecutive samples, lower is tighter interleaving, but with more overhead)\", offsetof(MOVMuxContext, frag_interleave), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_ENCODING_PARAM },\n    { \"encryption_scheme\",    \"Configures the encryption scheme, allowed values are none, cenc-aes-ctr\", offsetof(MOVMuxContext, encryption_scheme_str),   AV_OPT_TYPE_STRING, {.str = NULL}, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"encryption_key\", \"The media encryption key (hex)\", offsetof(MOVMuxContext, encryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"encryption_kid\", \"The media encryption key identifier (hex)\", offsetof(MOVMuxContext, encryption_kid), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_ENCODING_PARAM },\n    { \"use_stream_ids_as_track_ids\", \"use stream ids as track ids\", offsetof(MOVMuxContext, use_stream_ids_as_track_ids), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { \"write_tmcd\", \"force or disable writing tmcd\", offsetof(MOVMuxContext, write_tmcd), AV_OPT_TYPE_BOOL, {.i64 = -1}, -1, 1, AV_OPT_FLAG_ENCODING_PARAM},\n    { NULL },\n};\n\n#define MOV_CLASS(flavor)\\\nstatic const AVClass flavor ## _muxer_class = {\\\n    .class_name = #flavor \" muxer\",\\\n    .item_name  = av_default_item_name,\\\n    .option     = options,\\\n    .version    = LIBAVUTIL_VERSION_INT,\\\n};\n\nstatic int get_moov_size(AVFormatContext *s);\n\nstatic int utf8len(const uint8_t *b)\n{\n    int len = 0;\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        len++;\n    }\n    return len;\n}\n\n//FIXME support 64 bit variant with wide placeholders\nstatic int64_t update_size(AVIOContext *pb, int64_t pos)\n{\n    int64_t curpos = avio_tell(pb);\n    avio_seek(pb, pos, SEEK_SET);\n    avio_wb32(pb, curpos - pos); /* rewrite size */\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return curpos - pos;\n}\n\nstatic int co64_required(const MOVTrack *track)\n{\n    if (track->entry > 0 && track->cluster[track->entry - 1].pos + track->data_offset > UINT32_MAX)\n        return 1;\n    return 0;\n}\n\n/* Chunk offset atom */\nstatic int mov_write_stco_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    int mode64 = co64_required(track); // use 32 bit size variant if possible\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    if (mode64)\n        ffio_wfourcc(pb, \"co64\");\n    else\n        ffio_wfourcc(pb, \"stco\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, track->chunkCount); /* entry count */\n    for (i = 0; i < track->entry; i++) {\n        if (!track->cluster[i].chunkNum)\n            continue;\n        if (mode64 == 1)\n            avio_wb64(pb, track->cluster[i].pos + track->data_offset);\n        else\n            avio_wb32(pb, track->cluster[i].pos + track->data_offset);\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample size atom */\nstatic int mov_write_stsz_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int equalChunks = 1;\n    int i, j, entries = 0, tst = -1, oldtst = -1;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stsz\");\n    avio_wb32(pb, 0); /* version & flags */\n\n    for (i = 0; i < track->entry; i++) {\n        tst = track->cluster[i].size / track->cluster[i].entries;\n        if (oldtst != -1 && tst != oldtst)\n            equalChunks = 0;\n        oldtst = tst;\n        entries += track->cluster[i].entries;\n    }\n    if (equalChunks && track->entry) {\n        int sSize = track->entry ? track->cluster[0].size / track->cluster[0].entries : 0;\n        sSize = FFMAX(1, sSize); // adpcm mono case could make sSize == 0\n        avio_wb32(pb, sSize); // sample size\n        avio_wb32(pb, entries); // sample count\n    } else {\n        avio_wb32(pb, 0); // sample size\n        avio_wb32(pb, entries); // sample count\n        for (i = 0; i < track->entry; i++) {\n            for (j = 0; j < track->cluster[i].entries; j++) {\n                avio_wb32(pb, track->cluster[i].size /\n                          track->cluster[i].entries);\n            }\n        }\n    }\n    return update_size(pb, pos);\n}\n\n/* Sample to chunk atom */\nstatic int mov_write_stsc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int index = 0, oldval = -1, i;\n    int64_t entryPos, curpos;\n\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stsc\");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->chunkCount); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (oldval != track->cluster[i].samples_in_chunk && track->cluster[i].chunkNum) {\n            avio_wb32(pb, track->cluster[i].chunkNum); // first chunk\n            avio_wb32(pb, track->cluster[i].samples_in_chunk); // samples per chunk\n            avio_wb32(pb, 0x1); // sample description index\n            oldval = track->cluster[i].samples_in_chunk;\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return update_size(pb, pos);\n}\n\n/* Sync sample atom */\nstatic int mov_write_stss_tag(AVIOContext *pb, MOVTrack *track, uint32_t flag)\n{\n    int64_t curpos, entryPos;\n    int i, index = 0;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, flag == MOV_SYNC_SAMPLE ? \"stss\" : \"stps\");\n    avio_wb32(pb, 0); // version & flags\n    entryPos = avio_tell(pb);\n    avio_wb32(pb, track->entry); // entry count\n    for (i = 0; i < track->entry; i++) {\n        if (track->cluster[i].flags & flag) {\n            avio_wb32(pb, i + 1);\n            index++;\n        }\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entryPos, SEEK_SET);\n    avio_wb32(pb, index); // rewrite size\n    avio_seek(pb, curpos, SEEK_SET);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_amr_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x11); /* size */\n    if (track->mode == MODE_MOV) ffio_wfourcc(pb, \"samr\");\n    else                         ffio_wfourcc(pb, \"damr\");\n    ffio_wfourcc(pb, \"FFMP\");\n    avio_w8(pb, 0); /* decoder version */\n\n    avio_wb16(pb, 0x81FF); /* Mode set (all modes for AMR_NB) */\n    avio_w8(pb, 0x00); /* Mode change period (no restriction) */\n    avio_w8(pb, 0x01); /* Frames per sample */\n    return 0x11;\n}\n\nstatic int mov_write_ac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    GetBitContext gbc;\n    PutBitContext pbc;\n    uint8_t buf[3];\n    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;\n\n    if (track->vos_len < 7)\n        return -1;\n\n    avio_wb32(pb, 11);\n    ffio_wfourcc(pb, \"dac3\");\n\n    init_get_bits(&gbc, track->vos_data + 4, (track->vos_len - 4) * 8);\n    fscod      = get_bits(&gbc, 2);\n    frmsizecod = get_bits(&gbc, 6);\n    bsid       = get_bits(&gbc, 5);\n    bsmod      = get_bits(&gbc, 3);\n    acmod      = get_bits(&gbc, 3);\n    if (acmod == 2) {\n        skip_bits(&gbc, 2); // dsurmod\n    } else {\n        if ((acmod & 1) && acmod != 1)\n            skip_bits(&gbc, 2); // cmixlev\n        if (acmod & 4)\n            skip_bits(&gbc, 2); // surmixlev\n    }\n    lfeon = get_bits1(&gbc);\n\n    init_put_bits(&pbc, buf, sizeof(buf));\n    put_bits(&pbc, 2, fscod);\n    put_bits(&pbc, 5, bsid);\n    put_bits(&pbc, 3, bsmod);\n    put_bits(&pbc, 3, acmod);\n    put_bits(&pbc, 1, lfeon);\n    put_bits(&pbc, 5, frmsizecod >> 1); // bit_rate_code\n    put_bits(&pbc, 5, 0); // reserved\n\n    flush_put_bits(&pbc);\n    avio_write(pb, buf, sizeof(buf));\n\n    return 11;\n}\n\nstruct eac3_info {\n    AVPacket pkt;\n    uint8_t ec3_done;\n    uint8_t num_blocks;\n\n    /* Layout of the EC3SpecificBox */\n    /* maximum bitrate */\n    uint16_t data_rate;\n    /* number of independent substreams */\n    uint8_t  num_ind_sub;\n    struct {\n        /* sample rate code (see ff_ac3_sample_rate_tab) 2 bits */\n        uint8_t fscod;\n        /* bit stream identification 5 bits */\n        uint8_t bsid;\n        /* one bit reserved */\n        /* audio service mixing (not supported yet) 1 bit */\n        /* bit stream mode 3 bits */\n        uint8_t bsmod;\n        /* audio coding mode 3 bits */\n        uint8_t acmod;\n        /* sub woofer on 1 bit */\n        uint8_t lfeon;\n        /* 3 bits reserved */\n        /* number of dependent substreams associated with this substream 4 bits */\n        uint8_t num_dep_sub;\n        /* channel locations of the dependent substream(s), if any, 9 bits */\n        uint16_t chan_loc;\n        /* if there is no dependent substream, then one bit reserved instead */\n    } substream[1]; /* TODO: support 8 independent substreams */\n};\n\n#if CONFIG_AC3_PARSER\nstatic int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n{\n    GetBitContext gbc;\n    AC3HeaderInfo tmp, *hdr = &tmp;\n    struct eac3_info *info;\n    int num_blocks;\n\n    if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))\n        return AVERROR(ENOMEM);\n    info = track->eac3_priv;\n\n    init_get_bits(&gbc, pkt->data, pkt->size * 8);\n    if (avpriv_ac3_parse_header(&gbc, &hdr) < 0) {\n        /* drop the packets until we see a good one */\n        if (!track->entry) {\n            av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");\n            return 0;\n        }\n        return AVERROR_INVALIDDATA;\n    }\n\n    info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);\n    num_blocks = hdr->num_blocks;\n\n    if (!info->ec3_done) {\n        /* AC-3 substream must be the first one */\n        if (hdr->bitstream_id <= 10 && hdr->substreamid != 0)\n            return AVERROR(EINVAL);\n\n        /* this should always be the case, given that our AC-3 parser\n         * concatenates dependent frames to their independent parent */\n        if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {\n            /* substream ids must be incremental */\n            if (hdr->substreamid > info->num_ind_sub + 1)\n                return AVERROR(EINVAL);\n\n            if (hdr->substreamid == info->num_ind_sub + 1) {\n                //info->num_ind_sub++;\n                avpriv_request_sample(mov->fc, \"Multiple independent substreams\");\n                return AVERROR_PATCHWELCOME;\n            } else if (hdr->substreamid < info->num_ind_sub ||\n                       hdr->substreamid == 0 && info->substream[0].bsid) {\n                info->ec3_done = 1;\n                goto concatenate;\n            }\n        } else {\n            if (hdr->substreamid != 0) {\n                avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");\n                return AVERROR_PATCHWELCOME;\n            }\n        }\n\n        /* fill the info needed for the \"dec3\" atom */\n        info->substream[hdr->substreamid].fscod = hdr->sr_code;\n        info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;\n        info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;\n        info->substream[hdr->substreamid].acmod = hdr->channel_mode;\n        info->substream[hdr->substreamid].lfeon = hdr->lfe_on;\n\n        /* Parse dependent substream(s), if any */\n        if (pkt->size != hdr->frame_size) {\n            int cumul_size = hdr->frame_size;\n            int parent = hdr->substreamid;\n\n            while (cumul_size != pkt->size) {\n                int i;\n                init_get_bits(&gbc, pkt->data + cumul_size, (pkt->size - cumul_size) * 8);\n                if (avpriv_ac3_parse_header(&gbc, &hdr) < 0)\n                    return AVERROR_INVALIDDATA;\n                if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT)\n                    return AVERROR(EINVAL);\n                cumul_size += hdr->frame_size;\n                info->substream[parent].num_dep_sub++;\n\n                /* header is parsed up to lfeon, but custom channel map may be needed */\n                /* skip bsid */\n                skip_bits(&gbc, 5);\n                /* skip volume control params */\n                for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {\n                    skip_bits(&gbc, 5); // skip dialog normalization\n                    if (get_bits1(&gbc)) {\n                        skip_bits(&gbc, 8); // skip compression gain word\n                    }\n                }\n                /* get the dependent stream channel map, if exists */\n                if (get_bits1(&gbc))\n                    info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;\n                else\n                    info->substream[parent].chan_loc |= hdr->channel_mode;\n            }\n        }\n    }\n\nconcatenate:\n    if (!info->num_blocks && num_blocks == 6)\n        return pkt->size;\n    else if (info->num_blocks + num_blocks > 6)\n        return AVERROR_INVALIDDATA;\n\n    if (!info->num_blocks) {\n        int ret;\n        if ((ret = av_copy_packet(&info->pkt, pkt)) < 0)\n            return ret;\n        info->num_blocks = num_blocks;\n        return 0;\n    } else {\n        int ret;\n        if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)\n            return ret;\n        memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);\n        info->num_blocks += num_blocks;\n        info->pkt.duration += pkt->duration;\n        if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)\n            return ret;\n        if (info->num_blocks != 6)\n            return 0;\n        av_packet_unref(pkt);\n        if ((ret = av_copy_packet(pkt, &info->pkt)) < 0)\n            return ret;\n        av_packet_unref(&info->pkt);\n        info->num_blocks = 0;\n    }\n\n    return pkt->size;\n}\n#endif\n\nstatic int mov_write_eac3_tag(AVIOContext *pb, MOVTrack *track)\n{\n    PutBitContext pbc;\n    uint8_t *buf;\n    struct eac3_info *info;\n    int size, i;\n\n    if (!track->eac3_priv)\n        return AVERROR(EINVAL);\n\n    info = track->eac3_priv;\n    size = 2 + 4 * (info->num_ind_sub + 1);\n    buf = av_malloc(size);\n    if (!buf) {\n        size = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    init_put_bits(&pbc, buf, size);\n    put_bits(&pbc, 13, info->data_rate);\n    put_bits(&pbc,  3, info->num_ind_sub);\n    for (i = 0; i <= info->num_ind_sub; i++) {\n        put_bits(&pbc, 2, info->substream[i].fscod);\n        put_bits(&pbc, 5, info->substream[i].bsid);\n        put_bits(&pbc, 1, 0); /* reserved */\n        put_bits(&pbc, 1, 0); /* asvc */\n        put_bits(&pbc, 3, info->substream[i].bsmod);\n        put_bits(&pbc, 3, info->substream[i].acmod);\n        put_bits(&pbc, 1, info->substream[i].lfeon);\n        put_bits(&pbc, 5, 0); /* reserved */\n        put_bits(&pbc, 4, info->substream[i].num_dep_sub);\n        if (!info->substream[i].num_dep_sub) {\n            put_bits(&pbc, 1, 0); /* reserved */\n            size--;\n        } else {\n            put_bits(&pbc, 9, info->substream[i].chan_loc);\n        }\n    }\n    flush_put_bits(&pbc);\n\n    avio_wb32(pb, size + 8);\n    ffio_wfourcc(pb, \"dec3\");\n    avio_write(pb, buf, size);\n\n    av_free(buf);\n\nend:\n    av_packet_unref(&info->pkt);\n    av_freep(&track->eac3_priv);\n\n    return size;\n}\n\n/**\n * This function writes extradata \"as is\".\n * Extradata must be formatted like a valid atom (with size and tag).\n */\nstatic int mov_write_extradata_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_write(pb, track->par->extradata, track->par->extradata_size);\n    return track->par->extradata_size;\n}\n\nstatic int mov_write_enda_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 10);\n    ffio_wfourcc(pb, \"enda\");\n    avio_wb16(pb, 1); /* little endian */\n    return 10;\n}\n\nstatic int mov_write_enda_tag_be(AVIOContext *pb)\n{\n  avio_wb32(pb, 10);\n  ffio_wfourcc(pb, \"enda\");\n  avio_wb16(pb, 0); /* big endian */\n  return 10;\n}\n\nstatic void put_descr(AVIOContext *pb, int tag, unsigned int size)\n{\n    int i = 3;\n    avio_w8(pb, tag);\n    for (; i > 0; i--)\n        avio_w8(pb, (size >> (7 * i)) | 0x80);\n    avio_w8(pb, size & 0x7F);\n}\n\nstatic unsigned compute_avg_bitrate(MOVTrack *track)\n{\n    uint64_t size = 0;\n    int i;\n    if (!track->track_duration)\n        return 0;\n    for (i = 0; i < track->entry; i++)\n        size += track->cluster[i].size;\n    return size * 8 * track->timescale / track->track_duration;\n}\n\nstatic int mov_write_esds_tag(AVIOContext *pb, MOVTrack *track) // Basic\n{\n    AVCPBProperties *props;\n    int64_t pos = avio_tell(pb);\n    int decoder_specific_info_len = track->vos_len ? 5 + track->vos_len : 0;\n    unsigned avg_bitrate;\n\n    avio_wb32(pb, 0); // size\n    ffio_wfourcc(pb, \"esds\");\n    avio_wb32(pb, 0); // Version\n\n    // ES descriptor\n    put_descr(pb, 0x03, 3 + 5+13 + decoder_specific_info_len + 5+1);\n    avio_wb16(pb, track->track_id);\n    avio_w8(pb, 0x00); // flags (= no flags)\n\n    // DecoderConfig descriptor\n    put_descr(pb, 0x04, 13 + decoder_specific_info_len);\n\n    // Object type indication\n    if ((track->par->codec_id == AV_CODEC_ID_MP2 ||\n         track->par->codec_id == AV_CODEC_ID_MP3) &&\n        track->par->sample_rate > 24000)\n        avio_w8(pb, 0x6B); // 11172-3\n    else\n        avio_w8(pb, ff_codec_get_tag(ff_mp4_obj_type, track->par->codec_id));\n\n    // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)\n    // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)\n    if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n        avio_w8(pb, (0x38 << 2) | 1); // flags (= NeroSubpicStream)\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        avio_w8(pb, 0x15); // flags (= Audiostream)\n    else\n        avio_w8(pb, 0x11); // flags (= Visualstream)\n\n    props = (AVCPBProperties*)av_stream_get_side_data(track->st, AV_PKT_DATA_CPB_PROPERTIES,\n                                                      NULL);\n\n    avio_wb24(pb, props ? props->buffer_size / 8 : 0); // Buffersize DB\n\n    avg_bitrate = compute_avg_bitrate(track);\n    avio_wb32(pb, props ? FFMAX3(props->max_bitrate, props->avg_bitrate, avg_bitrate) : FFMAX(track->par->bit_rate, avg_bitrate)); // maxbitrate (FIXME should be max rate in any 1 sec window)\n    avio_wb32(pb, avg_bitrate);\n\n    if (track->vos_len) {\n        // DecoderSpecific info descriptor\n        put_descr(pb, 0x05, track->vos_len);\n        avio_write(pb, track->vos_data, track->vos_len);\n    }\n\n    // SL descriptor\n    put_descr(pb, 0x06, 1);\n    avio_w8(pb, 0x02);\n    return update_size(pb, pos);\n}\n\nstatic int mov_pcm_le_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24LE ||\n           codec_id == AV_CODEC_ID_PCM_S32LE ||\n           codec_id == AV_CODEC_ID_PCM_F32LE ||\n           codec_id == AV_CODEC_ID_PCM_F64LE;\n}\n\nstatic int mov_pcm_be_gt16(enum AVCodecID codec_id)\n{\n    return codec_id == AV_CODEC_ID_PCM_S24BE ||\n           codec_id == AV_CODEC_ID_PCM_S32BE ||\n           codec_id == AV_CODEC_ID_PCM_F32BE ||\n           codec_id == AV_CODEC_ID_PCM_F64BE;\n}\n\nstatic int mov_write_ms_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int ret;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    avio_wl32(pb, track->tag); // store it byteswapped\n    track->par->codec_tag = av_bswap16(track->tag >> 16);\n    if ((ret = ff_put_wav_header(s, pb, track->par, 0)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_wfex_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int ret;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"wfex\");\n    if ((ret = ff_put_wav_header(s, pb, track->st->codecpar, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_chan_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    uint32_t layout_tag, bitmap;\n    int64_t pos = avio_tell(pb);\n\n    layout_tag = ff_mov_get_channel_layout_tag(track->par->codec_id,\n                                               track->par->channel_layout,\n                                               &bitmap);\n    if (!layout_tag) {\n        av_log(s, AV_LOG_WARNING, \"not writing 'chan' tag due to \"\n               \"lack of channel information\\n\");\n        return 0;\n    }\n\n    if (track->multichannel_as_mono)\n        return 0;\n\n    avio_wb32(pb, 0);           // Size\n    ffio_wfourcc(pb, \"chan\");   // Type\n    avio_w8(pb, 0);             // Version\n    avio_wb24(pb, 0);           // Flags\n    avio_wb32(pb, layout_tag);  // mChannelLayoutTag\n    avio_wb32(pb, bitmap);      // mChannelBitmap\n    avio_wb32(pb, 0);           // mNumberChannelDescriptions\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_wave_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);     /* size */\n    ffio_wfourcc(pb, \"wave\");\n\n    if (track->par->codec_id != AV_CODEC_ID_QDM2) {\n    avio_wb32(pb, 12);    /* size */\n    ffio_wfourcc(pb, \"frma\");\n    avio_wl32(pb, track->tag);\n    }\n\n    if (track->par->codec_id == AV_CODEC_ID_AAC) {\n        /* useless atom needed by mplayer, ipod, not needed by quicktime */\n        avio_wb32(pb, 12); /* size */\n        ffio_wfourcc(pb, \"mp4a\");\n        avio_wb32(pb, 0);\n        mov_write_esds_tag(pb, track);\n    } else if (mov_pcm_le_gt16(track->par->codec_id))  {\n      mov_write_enda_tag(pb);\n    } else if (mov_pcm_be_gt16(track->par->codec_id))  {\n      mov_write_enda_tag_be(pb);\n    } else if (track->par->codec_id == AV_CODEC_ID_AMR_NB) {\n        mov_write_amr_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_AC3) {\n        mov_write_ac3_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_EAC3) {\n        mov_write_eac3_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_ALAC ||\n               track->par->codec_id == AV_CODEC_ID_QDM2) {\n        mov_write_extradata_tag(pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        mov_write_ms_tag(s, pb, track);\n    }\n\n    avio_wb32(pb, 8);     /* size */\n    avio_wb32(pb, 0);     /* null tag */\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_dvc1_structs(MOVTrack *track, uint8_t *buf)\n{\n    uint8_t *unescaped;\n    const uint8_t *start, *next, *end = track->vos_data + track->vos_len;\n    int unescaped_size, seq_found = 0;\n    int level = 0, interlace = 0;\n    int packet_seq   = track->vc1_info.packet_seq;\n    int packet_entry = track->vc1_info.packet_entry;\n    int slices       = track->vc1_info.slices;\n    PutBitContext pbc;\n\n    if (track->start_dts == AV_NOPTS_VALUE) {\n        /* No packets written yet, vc1_info isn't authoritative yet. */\n        /* Assume inline sequence and entry headers. */\n        packet_seq = packet_entry = 1;\n        av_log(NULL, AV_LOG_WARNING,\n               \"moov atom written before any packets, unable to write correct \"\n               \"dvc1 atom. Set the delay_moov flag to fix this.\\n\");\n    }\n\n    unescaped = av_mallocz(track->vos_len + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!unescaped)\n        return AVERROR(ENOMEM);\n    start = find_next_marker(track->vos_data, end);\n    for (next = start; next < end; start = next) {\n        GetBitContext gb;\n        int size;\n        next = find_next_marker(start + 4, end);\n        size = next - start - 4;\n        if (size <= 0)\n            continue;\n        unescaped_size = vc1_unescape_buffer(start + 4, size, unescaped);\n        init_get_bits(&gb, unescaped, 8 * unescaped_size);\n        if (AV_RB32(start) == VC1_CODE_SEQHDR) {\n            int profile = get_bits(&gb, 2);\n            if (profile != PROFILE_ADVANCED) {\n                av_free(unescaped);\n                return AVERROR(ENOSYS);\n            }\n            seq_found = 1;\n            level = get_bits(&gb, 3);\n            /* chromaformat, frmrtq_postproc, bitrtq_postproc, postprocflag,\n             * width, height */\n            skip_bits_long(&gb, 2 + 3 + 5 + 1 + 2*12);\n            skip_bits(&gb, 1); /* broadcast */\n            interlace = get_bits1(&gb);\n            skip_bits(&gb, 4); /* tfcntrflag, finterpflag, reserved, psf */\n        }\n    }\n    if (!seq_found) {\n        av_free(unescaped);\n        return AVERROR(ENOSYS);\n    }\n\n    init_put_bits(&pbc, buf, 7);\n    /* VC1DecSpecStruc */\n    put_bits(&pbc, 4, 12); /* profile - advanced */\n    put_bits(&pbc, 3, level);\n    put_bits(&pbc, 1, 0); /* reserved */\n    /* VC1AdvDecSpecStruc */\n    put_bits(&pbc, 3, level);\n    put_bits(&pbc, 1, 0); /* cbr */\n    put_bits(&pbc, 6, 0); /* reserved */\n    put_bits(&pbc, 1, !interlace); /* no interlace */\n    put_bits(&pbc, 1, !packet_seq); /* no multiple seq */\n    put_bits(&pbc, 1, !packet_entry); /* no multiple entry */\n    put_bits(&pbc, 1, !slices); /* no slice code */\n    put_bits(&pbc, 1, 0); /* no bframe */\n    put_bits(&pbc, 1, 0); /* reserved */\n\n    /* framerate */\n    if (track->st->avg_frame_rate.num > 0 && track->st->avg_frame_rate.den > 0)\n        put_bits32(&pbc, track->st->avg_frame_rate.num / track->st->avg_frame_rate.den);\n    else\n        put_bits32(&pbc, 0xffffffff);\n\n    flush_put_bits(&pbc);\n\n    av_free(unescaped);\n\n    return 0;\n}\n\nstatic int mov_write_dvc1_tag(AVIOContext *pb, MOVTrack *track)\n{\n    uint8_t buf[7] = { 0 };\n    int ret;\n\n    if ((ret = mov_write_dvc1_structs(track, buf)) < 0)\n        return ret;\n\n    avio_wb32(pb, track->vos_len + 8 + sizeof(buf));\n    ffio_wfourcc(pb, \"dvc1\");\n    avio_write(pb, buf, sizeof(buf));\n    avio_write(pb, track->vos_data, track->vos_len);\n\n    return 0;\n}\n\nstatic int mov_write_glbl_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, track->vos_len + 8);\n    ffio_wfourcc(pb, \"glbl\");\n    avio_write(pb, track->vos_data, track->vos_len);\n    return 8 + track->vos_len;\n}\n\n/**\n * Compute flags for 'lpcm' tag.\n * See CoreAudioTypes and AudioStreamBasicDescription at Apple.\n */\nstatic int mov_get_lpcm_flags(enum AVCodecID codec_id)\n{\n    switch (codec_id) {\n    case AV_CODEC_ID_PCM_F32BE:\n    case AV_CODEC_ID_PCM_F64BE:\n        return 11;\n    case AV_CODEC_ID_PCM_F32LE:\n    case AV_CODEC_ID_PCM_F64LE:\n        return 9;\n    case AV_CODEC_ID_PCM_U8:\n        return 10;\n    case AV_CODEC_ID_PCM_S16BE:\n    case AV_CODEC_ID_PCM_S24BE:\n    case AV_CODEC_ID_PCM_S32BE:\n        return 14;\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S24LE:\n    case AV_CODEC_ID_PCM_S32LE:\n        return 12;\n    default:\n        return 0;\n    }\n}\n\nstatic int get_cluster_duration(MOVTrack *track, int cluster_idx)\n{\n    int64_t next_dts;\n\n    if (cluster_idx >= track->entry)\n        return 0;\n\n    if (cluster_idx + 1 == track->entry)\n        next_dts = track->track_duration + track->start_dts;\n    else\n        next_dts = track->cluster[cluster_idx + 1].dts;\n\n    next_dts -= track->cluster[cluster_idx].dts;\n\n    av_assert0(next_dts >= 0);\n    av_assert0(next_dts <= INT_MAX);\n\n    return next_dts;\n}\n\nstatic int get_samples_per_packet(MOVTrack *track)\n{\n    int i, first_duration;\n\n// return track->par->frame_size;\n\n    /* use 1 for raw PCM */\n    if (!track->audio_vbr)\n        return 1;\n\n    /* check to see if duration is constant for all clusters */\n    if (!track->entry)\n        return 0;\n    first_duration = get_cluster_duration(track, 0);\n    for (i = 1; i < track->entry; i++) {\n        if (get_cluster_duration(track, i) != first_duration)\n            return 0;\n    }\n    return first_duration;\n}\n\nstatic int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int version = 0;\n    uint32_t tag = track->tag;\n\n    if (track->mode == MODE_MOV) {\n        if (track->timescale > UINT16_MAX || !track->par->channels) {\n            if (mov_get_lpcm_flags(track->par->codec_id))\n                tag = AV_RL32(\"lpcm\");\n            version = 2;\n        } else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||\n                   mov_pcm_be_gt16(track->par->codec_id) ||\n                   track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n                   track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||\n                   track->par->codec_id == AV_CODEC_ID_QDM2) {\n            version = 1;\n        }\n    }\n\n    avio_wb32(pb, 0); /* size */\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ffio_wfourcc(pb, \"enca\");\n    } else {\n        avio_wl32(pb, tag); // store it byteswapped\n    }\n    avio_wb32(pb, 0); /* Reserved */\n    avio_wb16(pb, 0); /* Reserved */\n    avio_wb16(pb, 1); /* Data-reference index, XXX  == 1 */\n\n    /* SoundDescription */\n    avio_wb16(pb, version); /* Version */\n    avio_wb16(pb, 0); /* Revision level */\n    avio_wb32(pb, 0); /* Reserved */\n\n    if (version == 2) {\n        avio_wb16(pb, 3);\n        avio_wb16(pb, 16);\n        avio_wb16(pb, 0xfffe);\n        avio_wb16(pb, 0);\n        avio_wb32(pb, 0x00010000);\n        avio_wb32(pb, 72);\n        avio_wb64(pb, av_double2int(track->par->sample_rate));\n        avio_wb32(pb, track->par->channels);\n        avio_wb32(pb, 0x7F000000);\n        avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));\n        avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));\n        avio_wb32(pb, track->sample_size);\n        avio_wb32(pb, get_samples_per_packet(track));\n    } else {\n        if (track->mode == MODE_MOV) {\n            avio_wb16(pb, track->par->channels);\n            if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||\n                track->par->codec_id == AV_CODEC_ID_PCM_S8)\n                avio_wb16(pb, 8); /* bits per sample */\n            else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)\n                avio_wb16(pb, track->par->bits_per_coded_sample);\n            else\n                avio_wb16(pb, 16);\n            avio_wb16(pb, track->audio_vbr ? -2 : 0); /* compression ID */\n        } else { /* reserved for mp4/3gp */\n            avio_wb16(pb, 2);\n            avio_wb16(pb, 16);\n            avio_wb16(pb, 0);\n        }\n\n        avio_wb16(pb, 0); /* packet size (= 0) */\n        avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?\n                      track->par->sample_rate : 0);\n        avio_wb16(pb, 0); /* Reserved */\n    }\n\n    if (version == 1) { /* SoundDescription V1 extended info */\n        if (mov_pcm_le_gt16(track->par->codec_id) ||\n            mov_pcm_be_gt16(track->par->codec_id))\n            avio_wb32(pb, 1); /*  must be 1 for  uncompressed formats */\n        else\n            avio_wb32(pb, track->par->frame_size); /* Samples per packet */\n        avio_wb32(pb, track->sample_size / track->par->channels); /* Bytes per packet */\n        avio_wb32(pb, track->sample_size); /* Bytes per frame */\n        avio_wb32(pb, 2); /* Bytes per sample */\n    }\n\n    if (track->mode == MODE_MOV &&\n        (track->par->codec_id == AV_CODEC_ID_AAC           ||\n         track->par->codec_id == AV_CODEC_ID_AC3           ||\n         track->par->codec_id == AV_CODEC_ID_EAC3          ||\n         track->par->codec_id == AV_CODEC_ID_AMR_NB        ||\n         track->par->codec_id == AV_CODEC_ID_ALAC          ||\n         track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||\n         track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||\n         track->par->codec_id == AV_CODEC_ID_QDM2          ||\n         (mov_pcm_le_gt16(track->par->codec_id) && version==1) ||\n         (mov_pcm_be_gt16(track->par->codec_id) && version==1)))\n        mov_write_wave_tag(s, pb, track);\n    else if (track->tag == MKTAG('m','p','4','a'))\n        mov_write_esds_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)\n        mov_write_amr_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_AC3)\n        mov_write_ac3_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_EAC3)\n        mov_write_eac3_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_ALAC)\n        mov_write_extradata_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)\n        mov_write_wfex_tag(s, pb, track);\n    else if (track->vos_len > 0)\n        mov_write_glbl_tag(pb, track);\n\n    if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_chan_tag(s, pb, track);\n\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_d263_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 0xf); /* size */\n    ffio_wfourcc(pb, \"d263\");\n    ffio_wfourcc(pb, \"FFMP\");\n    avio_w8(pb, 0); /* decoder version */\n    /* FIXME use AVCodecContext level/profile, when encoder will set values */\n    avio_w8(pb, 0xa); /* level */\n    avio_w8(pb, 0); /* profile */\n    return 0xf;\n}\n\nstatic int mov_write_avcc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"avcC\");\n    ff_isom_write_avcc(pb, track->vos_data, track->vos_len);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); /* version & flags */\n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_hvcc_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"hvcC\");\n    ff_isom_write_hvcc(pb, track->vos_data, track->vos_len, 0);\n    return update_size(pb, pos);\n}\n\n/* also used by all avid codecs (dv, imx, meridien) and their variants */\nstatic int mov_write_avid_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int i;\n    int interlaced;\n    int cid;\n    int display_width = track->par->width;\n\n    if (track->vos_data && track->vos_len > 0x29) {\n        if (ff_dnxhd_parse_header_prefix(track->vos_data) != 0) {\n            /* looks like a DNxHD bit stream */\n            interlaced = (track->vos_data[5] & 2);\n            cid = AV_RB32(track->vos_data + 0x28);\n        } else {\n            av_log(NULL, AV_LOG_WARNING, \"Could not locate DNxHD bit stream in vos_data\\n\");\n            return 0;\n        }\n    } else {\n        av_log(NULL, AV_LOG_WARNING, \"Could not locate DNxHD bit stream, vos_data too small\\n\");\n        return 0;\n    }\n\n    avio_wb32(pb, 24); /* size */\n    ffio_wfourcc(pb, \"ACLR\");\n    ffio_wfourcc(pb, \"ACLR\");\n    ffio_wfourcc(pb, \"0001\");\n    if (track->par->color_range == AVCOL_RANGE_MPEG || /* Legal range (16-235) */\n        track->par->color_range == AVCOL_RANGE_UNSPECIFIED) {\n        avio_wb32(pb, 1); /* Corresponds to 709 in official encoder */\n    } else { /* Full range (0-255) */\n        avio_wb32(pb, 2); /* Corresponds to RGB in official encoder */\n    }\n    avio_wb32(pb, 0); /* unknown */\n\n    if (track->tag == MKTAG('A','V','d','h')) {\n        avio_wb32(pb, 32);\n        ffio_wfourcc(pb, \"ADHR\");\n        ffio_wfourcc(pb, \"0001\");\n        avio_wb32(pb, cid);\n        avio_wb32(pb, 0); /* unknown */\n        avio_wb32(pb, 1); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        return 0;\n    }\n\n    avio_wb32(pb, 24); /* size */\n    ffio_wfourcc(pb, \"APRG\");\n    ffio_wfourcc(pb, \"APRG\");\n    ffio_wfourcc(pb, \"0001\");\n    avio_wb32(pb, 1); /* unknown */\n    avio_wb32(pb, 0); /* unknown */\n\n    avio_wb32(pb, 120); /* size */\n    ffio_wfourcc(pb, \"ARES\");\n    ffio_wfourcc(pb, \"ARES\");\n    ffio_wfourcc(pb, \"0001\");\n    avio_wb32(pb, cid); /* dnxhd cid, some id ? */\n    if (   track->par->sample_aspect_ratio.num > 0\n        && track->par->sample_aspect_ratio.den > 0)\n        display_width = display_width * track->par->sample_aspect_ratio.num / track->par->sample_aspect_ratio.den;\n    avio_wb32(pb, display_width);\n    /* values below are based on samples created with quicktime and avid codecs */\n    if (interlaced) {\n        avio_wb32(pb, track->par->height / 2);\n        avio_wb32(pb, 2); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        avio_wb32(pb, 4); /* unknown */\n    } else {\n        avio_wb32(pb, track->par->height);\n        avio_wb32(pb, 1); /* unknown */\n        avio_wb32(pb, 0); /* unknown */\n        if (track->par->height == 1080)\n            avio_wb32(pb, 5); /* unknown */\n        else\n            avio_wb32(pb, 6); /* unknown */\n    }\n    /* padding */\n    for (i = 0; i < 10; i++)\n        avio_wb64(pb, 0);\n\n    return 0;\n}\n\nstatic int mov_write_dpxe_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 12);\n    ffio_wfourcc(pb, \"DpxE\");\n    if (track->par->extradata_size >= 12 &&\n        !memcmp(&track->par->extradata[4], \"DpxE\", 4)) {\n        avio_wb32(pb, track->par->extradata[11]);\n    } else {\n        avio_wb32(pb, 1);\n    }\n    return 0;\n}\n\nstatic int mp4_get_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n\n    if (!ff_codec_get_tag(ff_mp4_obj_type, track->par->codec_id))\n        return 0;\n\n    if      (track->par->codec_id == AV_CODEC_ID_H264)      tag = MKTAG('a','v','c','1');\n    else if (track->par->codec_id == AV_CODEC_ID_HEVC)      tag = MKTAG('h','e','v','1');\n    else if (track->par->codec_id == AV_CODEC_ID_VP9)       tag = MKTAG('v','p','0','9');\n    else if (track->par->codec_id == AV_CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');\n    else if (track->par->codec_id == AV_CODEC_ID_EAC3)      tag = MKTAG('e','c','-','3');\n    else if (track->par->codec_id == AV_CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');\n    else if (track->par->codec_id == AV_CODEC_ID_MOV_TEXT)  tag = MKTAG('t','x','3','g');\n    else if (track->par->codec_id == AV_CODEC_ID_VC1)       tag = MKTAG('v','c','-','1');\n    else if (track->par->codec_type == AVMEDIA_TYPE_VIDEO)  tag = MKTAG('m','p','4','v');\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)  tag = MKTAG('m','p','4','a');\n    else if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)  tag = MKTAG('m','p','4','s');\n\n    return tag;\n}\n\nstatic const AVCodecTag codec_ipod_tags[] = {\n    { AV_CODEC_ID_H264,     MKTAG('a','v','c','1') },\n    { AV_CODEC_ID_MPEG4,    MKTAG('m','p','4','v') },\n    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },\n    { AV_CODEC_ID_ALAC,     MKTAG('a','l','a','c') },\n    { AV_CODEC_ID_AC3,      MKTAG('a','c','-','3') },\n    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },\n    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','e','x','t') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic int ipod_get_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n\n    // keep original tag for subs, ipod supports both formats\n    if (!(track->par->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n          (tag == MKTAG('t', 'x', '3', 'g') ||\n           tag == MKTAG('t', 'e', 'x', 't'))))\n        tag = ff_codec_get_tag(codec_ipod_tags, track->par->codec_id);\n\n    if (!av_match_ext(s->filename, \"m4a\") &&\n        !av_match_ext(s->filename, \"m4b\") &&\n        !av_match_ext(s->filename, \"m4v\"))\n        av_log(s, AV_LOG_WARNING, \"Warning, extension is not .m4a, .m4v nor  .m4b \"\n               \"Quicktime/Ipod might not play the file\\n\");\n\n    return tag;\n}\n\nstatic int mov_get_dv_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag;\n\n    if (track->par->width == 720) { /* SD */\n        if (track->par->height == 480) { /* NTSC */\n            if  (track->par->format == AV_PIX_FMT_YUV422P) tag = MKTAG('d','v','5','n');\n            else                                            tag = MKTAG('d','v','c',' ');\n       }else if (track->par->format == AV_PIX_FMT_YUV422P) tag = MKTAG('d','v','5','p');\n        else if (track->par->format == AV_PIX_FMT_YUV420P) tag = MKTAG('d','v','c','p');\n        else                                                tag = MKTAG('d','v','p','p');\n    } else if (track->par->height == 720) { /* HD 720 line */\n        if  (track->st->time_base.den == 50)                tag = MKTAG('d','v','h','q');\n        else                                                tag = MKTAG('d','v','h','p');\n    } else if (track->par->height == 1080) { /* HD 1080 line */\n        if  (track->st->time_base.den == 25)                tag = MKTAG('d','v','h','5');\n        else                                                tag = MKTAG('d','v','h','6');\n    } else {\n        av_log(s, AV_LOG_ERROR, \"unsupported height for dv codec\\n\");\n        return 0;\n    }\n\n    return tag;\n}\n\nstatic AVRational find_fps(AVFormatContext *s, AVStream *st)\n{\n    AVRational rate = st->avg_frame_rate;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    rate = av_inv_q(st->codec->time_base);\n    if (av_timecode_check_frame_rate(rate) < 0) {\n        av_log(s, AV_LOG_DEBUG, \"timecode: tbc=%d/%d invalid, fallback on %d/%d\\n\",\n               rate.num, rate.den, st->avg_frame_rate.num, st->avg_frame_rate.den);\n        rate = st->avg_frame_rate;\n    }\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    return rate;\n}\n\nstatic int mov_get_mpeg2_xdcam_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n    int interlaced = track->par->field_order > AV_FIELD_PROGRESSIVE;\n    AVStream *st = track->st;\n    int rate = av_q2d(find_fps(s, st));\n\n    if (!tag)\n        tag = MKTAG('m', '2', 'v', '1'); //fallback tag\n\n    if (track->par->format == AV_PIX_FMT_YUV420P) {\n        if (track->par->width == 1280 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','v','4');\n                else if (rate == 25) tag = MKTAG('x','d','v','5');\n                else if (rate == 30) tag = MKTAG('x','d','v','1');\n                else if (rate == 50) tag = MKTAG('x','d','v','a');\n                else if (rate == 60) tag = MKTAG('x','d','v','9');\n            }\n        } else if (track->par->width == 1440 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','v','6');\n                else if (rate == 25) tag = MKTAG('x','d','v','7');\n                else if (rate == 30) tag = MKTAG('x','d','v','8');\n            } else {\n                if      (rate == 25) tag = MKTAG('x','d','v','3');\n                else if (rate == 30) tag = MKTAG('x','d','v','2');\n            }\n        } else if (track->par->width == 1920 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','v','d');\n                else if (rate == 25) tag = MKTAG('x','d','v','e');\n                else if (rate == 30) tag = MKTAG('x','d','v','f');\n            } else {\n                if      (rate == 25) tag = MKTAG('x','d','v','c');\n                else if (rate == 30) tag = MKTAG('x','d','v','b');\n            }\n        }\n    } else if (track->par->format == AV_PIX_FMT_YUV422P) {\n        if (track->par->width == 1280 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','5','4');\n                else if (rate == 25) tag = MKTAG('x','d','5','5');\n                else if (rate == 30) tag = MKTAG('x','d','5','1');\n                else if (rate == 50) tag = MKTAG('x','d','5','a');\n                else if (rate == 60) tag = MKTAG('x','d','5','9');\n            }\n        } else if (track->par->width == 1920 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('x','d','5','d');\n                else if (rate == 25) tag = MKTAG('x','d','5','e');\n                else if (rate == 30) tag = MKTAG('x','d','5','f');\n            } else {\n                if      (rate == 25) tag = MKTAG('x','d','5','c');\n                else if (rate == 30) tag = MKTAG('x','d','5','b');\n            }\n        }\n    }\n\n    return tag;\n}\n\nstatic int mov_get_h264_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n    int interlaced = track->par->field_order > AV_FIELD_PROGRESSIVE;\n    AVStream *st = track->st;\n    int rate = av_q2d(find_fps(s, st));\n\n    if (!tag)\n        tag = MKTAG('a', 'v', 'c', 'i'); //fallback tag\n\n    if (track->par->format == AV_PIX_FMT_YUV420P10) {\n        if (track->par->width == 960 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','5','p');\n                else if (rate == 25) tag = MKTAG('a','i','5','q');\n                else if (rate == 30) tag = MKTAG('a','i','5','p');\n                else if (rate == 50) tag = MKTAG('a','i','5','q');\n                else if (rate == 60) tag = MKTAG('a','i','5','p');\n            }\n        } else if (track->par->width == 1440 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','5','3');\n                else if (rate == 25) tag = MKTAG('a','i','5','2');\n                else if (rate == 30) tag = MKTAG('a','i','5','3');\n            } else {\n                if      (rate == 50) tag = MKTAG('a','i','5','5');\n                else if (rate == 60) tag = MKTAG('a','i','5','6');\n            }\n        }\n    } else if (track->par->format == AV_PIX_FMT_YUV422P10) {\n        if (track->par->width == 1280 && track->par->height == 720) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','1','p');\n                else if (rate == 25) tag = MKTAG('a','i','1','q');\n                else if (rate == 30) tag = MKTAG('a','i','1','p');\n                else if (rate == 50) tag = MKTAG('a','i','1','q');\n                else if (rate == 60) tag = MKTAG('a','i','1','p');\n            }\n        } else if (track->par->width == 1920 && track->par->height == 1080) {\n            if (!interlaced) {\n                if      (rate == 24) tag = MKTAG('a','i','1','3');\n                else if (rate == 25) tag = MKTAG('a','i','1','2');\n                else if (rate == 30) tag = MKTAG('a','i','1','3');\n            } else {\n                if      (rate == 25) tag = MKTAG('a','i','1','5');\n                else if (rate == 50) tag = MKTAG('a','i','1','5');\n                else if (rate == 60) tag = MKTAG('a','i','1','6');\n            }\n        } else if (   track->par->width == 4096 && track->par->height == 2160\n                   || track->par->width == 3840 && track->par->height == 2160\n                   || track->par->width == 2048 && track->par->height == 1080) {\n            tag = MKTAG('a','i','v','x');\n        }\n    }\n\n    return tag;\n}\n\nstatic const struct {\n    enum AVPixelFormat pix_fmt;\n    uint32_t tag;\n    unsigned bps;\n} mov_pix_fmt_tags[] = {\n    { AV_PIX_FMT_YUYV422, MKTAG('y','u','v','2'),  0 },\n    { AV_PIX_FMT_YUYV422, MKTAG('y','u','v','s'),  0 },\n    { AV_PIX_FMT_UYVY422, MKTAG('2','v','u','y'),  0 },\n    { AV_PIX_FMT_RGB555BE,MKTAG('r','a','w',' '), 16 },\n    { AV_PIX_FMT_RGB555LE,MKTAG('L','5','5','5'), 16 },\n    { AV_PIX_FMT_RGB565LE,MKTAG('L','5','6','5'), 16 },\n    { AV_PIX_FMT_RGB565BE,MKTAG('B','5','6','5'), 16 },\n    { AV_PIX_FMT_GRAY16BE,MKTAG('b','1','6','g'), 16 },\n    { AV_PIX_FMT_RGB24,   MKTAG('r','a','w',' '), 24 },\n    { AV_PIX_FMT_BGR24,   MKTAG('2','4','B','G'), 24 },\n    { AV_PIX_FMT_ARGB,    MKTAG('r','a','w',' '), 32 },\n    { AV_PIX_FMT_BGRA,    MKTAG('B','G','R','A'), 32 },\n    { AV_PIX_FMT_RGBA,    MKTAG('R','G','B','A'), 32 },\n    { AV_PIX_FMT_ABGR,    MKTAG('A','B','G','R'), 32 },\n    { AV_PIX_FMT_RGB48BE, MKTAG('b','4','8','r'), 48 },\n};\n\nstatic int mov_get_dnxhd_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n  int tag = MKTAG('A','V','d','n');\n  if (track->par->profile != FF_PROFILE_UNKNOWN &&\n      track->par->profile != FF_PROFILE_DNXHD)\n      tag = MKTAG('A','V','d','h');\n  return tag;\n}\n\nstatic int mov_get_rawvideo_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n    int i;\n    enum AVPixelFormat pix_fmt;\n\n    for (i = 0; i < FF_ARRAY_ELEMS(mov_pix_fmt_tags); i++) {\n        if (track->par->format == mov_pix_fmt_tags[i].pix_fmt) {\n            tag = mov_pix_fmt_tags[i].tag;\n            track->par->bits_per_coded_sample = mov_pix_fmt_tags[i].bps;\n            if (track->par->codec_tag == mov_pix_fmt_tags[i].tag)\n                break;\n        }\n    }\n\n    pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_mov,\n                                  track->par->bits_per_coded_sample);\n    if (tag == MKTAG('r','a','w',' ') &&\n        track->par->format != pix_fmt &&\n        track->par->format != AV_PIX_FMT_NONE)\n        av_log(s, AV_LOG_ERROR, \"%s rawvideo cannot be written to mov, output file will be unreadable\\n\",\n               av_get_pix_fmt_name(track->par->format));\n    return tag;\n}\n\nstatic int mov_get_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag = track->par->codec_tag;\n\n    if (!tag || (s->strict_std_compliance >= FF_COMPLIANCE_NORMAL &&\n                 (track->par->codec_id == AV_CODEC_ID_DVVIDEO ||\n                  track->par->codec_id == AV_CODEC_ID_RAWVIDEO ||\n                  track->par->codec_id == AV_CODEC_ID_H263 ||\n                  track->par->codec_id == AV_CODEC_ID_H264 ||\n                  track->par->codec_id == AV_CODEC_ID_DNXHD ||\n                  track->par->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n                  av_get_bits_per_sample(track->par->codec_id)))) { // pcm audio\n        if (track->par->codec_id == AV_CODEC_ID_DVVIDEO)\n            tag = mov_get_dv_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_RAWVIDEO)\n            tag = mov_get_rawvideo_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_MPEG2VIDEO)\n            tag = mov_get_mpeg2_xdcam_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_H264)\n            tag = mov_get_h264_codec_tag(s, track);\n        else if (track->par->codec_id == AV_CODEC_ID_DNXHD)\n            tag = mov_get_dnxhd_codec_tag(s, track);\n        else if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            tag = ff_codec_get_tag(ff_codec_movvideo_tags, track->par->codec_id);\n            if (!tag) { // if no mac fcc found, try with Microsoft tags\n                tag = ff_codec_get_tag(ff_codec_bmp_tags, track->par->codec_id);\n                if (tag)\n                    av_log(s, AV_LOG_WARNING, \"Using MS style video codec tag, \"\n                           \"the file may be unplayable!\\n\");\n            }\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            tag = ff_codec_get_tag(ff_codec_movaudio_tags, track->par->codec_id);\n            if (!tag) { // if no mac fcc found, try with Microsoft tags\n                int ms_tag = ff_codec_get_tag(ff_codec_wav_tags, track->par->codec_id);\n                if (ms_tag) {\n                    tag = MKTAG('m', 's', ((ms_tag >> 8) & 0xff), (ms_tag & 0xff));\n                    av_log(s, AV_LOG_WARNING, \"Using MS style audio codec tag, \"\n                           \"the file may be unplayable!\\n\");\n                }\n            }\n        } else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)\n            tag = ff_codec_get_tag(ff_codec_movsubtitle_tags, track->par->codec_id);\n    }\n\n    return tag;\n}\n\nstatic const AVCodecTag codec_3gp_tags[] = {\n    { AV_CODEC_ID_H263,     MKTAG('s','2','6','3') },\n    { AV_CODEC_ID_H264,     MKTAG('a','v','c','1') },\n    { AV_CODEC_ID_MPEG4,    MKTAG('m','p','4','v') },\n    { AV_CODEC_ID_AAC,      MKTAG('m','p','4','a') },\n    { AV_CODEC_ID_AMR_NB,   MKTAG('s','a','m','r') },\n    { AV_CODEC_ID_AMR_WB,   MKTAG('s','a','w','b') },\n    { AV_CODEC_ID_MOV_TEXT, MKTAG('t','x','3','g') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic const AVCodecTag codec_f4v_tags[] = { // XXX: add GIF/PNG/JPEG?\n    { AV_CODEC_ID_MP3,    MKTAG('.','m','p','3') },\n    { AV_CODEC_ID_AAC,    MKTAG('m','p','4','a') },\n    { AV_CODEC_ID_H264,   MKTAG('a','v','c','1') },\n    { AV_CODEC_ID_VP6A,   MKTAG('V','P','6','A') },\n    { AV_CODEC_ID_VP6F,   MKTAG('V','P','6','F') },\n    { AV_CODEC_ID_NONE, 0 },\n};\n\nstatic int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)\n{\n    int tag;\n\n    if (track->mode == MODE_MP4 || track->mode == MODE_PSP)\n        tag = mp4_get_codec_tag(s, track);\n    else if (track->mode == MODE_ISM) {\n        tag = mp4_get_codec_tag(s, track);\n        if (!tag && track->par->codec_id == AV_CODEC_ID_WMAPRO)\n            tag = MKTAG('w', 'm', 'a', ' ');\n    } else if (track->mode == MODE_IPOD)\n        tag = ipod_get_codec_tag(s, track);\n    else if (track->mode & MODE_3GP)\n        tag = ff_codec_get_tag(codec_3gp_tags, track->par->codec_id);\n    else if (track->mode == MODE_F4V)\n        tag = ff_codec_get_tag(codec_f4v_tags, track->par->codec_id);\n    else\n        tag = mov_get_codec_tag(s, track);\n\n    return tag;\n}\n\n/** Write uuid atom.\n * Needed to make file play in iPods running newest firmware\n * goes after avcC atom in moov.trak.mdia.minf.stbl.stsd.avc1\n */\nstatic int mov_write_uuid_tag_ipod(AVIOContext *pb)\n{\n    avio_wb32(pb, 28);\n    ffio_wfourcc(pb, \"uuid\");\n    avio_wb32(pb, 0x6b6840f2);\n    avio_wb32(pb, 0x5f244fc5);\n    avio_wb32(pb, 0xba39a51b);\n    avio_wb32(pb, 0xcf0323f3);\n    avio_wb32(pb, 0x0);\n    return 28;\n}\n\nstatic const uint16_t fiel_data[] = {\n    0x0000, 0x0100, 0x0201, 0x0206, 0x0209, 0x020e\n};\n\nstatic int mov_write_fiel_tag(AVIOContext *pb, MOVTrack *track, int field_order)\n{\n    unsigned mov_field_order = 0;\n    if (field_order < FF_ARRAY_ELEMS(fiel_data))\n        mov_field_order = fiel_data[field_order];\n    else\n        return 0;\n    avio_wb32(pb, 10);\n    ffio_wfourcc(pb, \"fiel\");\n    avio_wb16(pb, mov_field_order);\n    return 10;\n}\n\nstatic int mov_write_subtitle_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);    /* size */\n    avio_wl32(pb, track->tag); // store it byteswapped\n    avio_wb32(pb, 0);    /* Reserved */\n    avio_wb16(pb, 0);    /* Reserved */\n    avio_wb16(pb, 1);    /* Data-reference index */\n\n    if (track->par->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n        mov_write_esds_tag(pb, track);\n    else if (track->par->extradata_size)\n        avio_write(pb, track->par->extradata, track->par->extradata_size);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_pasp_tag(AVIOContext *pb, MOVTrack *track)\n{\n    AVRational sar;\n    av_reduce(&sar.num, &sar.den, track->par->sample_aspect_ratio.num,\n              track->par->sample_aspect_ratio.den, INT_MAX);\n\n    avio_wb32(pb, 16);\n    ffio_wfourcc(pb, \"pasp\");\n    avio_wb32(pb, sar.num);\n    avio_wb32(pb, sar.den);\n    return 16;\n}\n\nstatic int mov_write_gama_tag(AVIOContext *pb, MOVTrack *track, double gamma)\n{\n    uint32_t gama = 0;\n    if (gamma <= 0.0)\n    {\n        gamma = avpriv_get_gamma_from_trc(track->par->color_trc);\n    }\n    av_log(pb, AV_LOG_DEBUG, \"gamma value %g\\n\", gamma);\n\n    if (gamma > 1e-6) {\n        gama = (uint32_t)lrint((double)(1<<16) * gamma);\n        av_log(pb, AV_LOG_DEBUG, \"writing gama value %d\\n\", gama);\n\n        av_assert0(track->mode == MODE_MOV);\n        avio_wb32(pb, 12);\n        ffio_wfourcc(pb, \"gama\");\n        avio_wb32(pb, gama);\n        return 12;\n    }\n    else {\n        av_log(pb, AV_LOG_WARNING, \"gamma value unknown, unable to write gama atom\\n\");\n    }\n    return 0;\n}\n\nstatic int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)\n{\n    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9\n    // Ref (MP4): ISO/IEC 14496-12:2012\n\n    if (track->par->color_primaries == AVCOL_PRI_UNSPECIFIED &&\n        track->par->color_trc == AVCOL_TRC_UNSPECIFIED &&\n        track->par->color_space == AVCOL_SPC_UNSPECIFIED) {\n        if ((track->par->width >= 1920 && track->par->height >= 1080)\n          || (track->par->width == 1280 && track->par->height == 720)) {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt709\\n\");\n            track->par->color_primaries = AVCOL_PRI_BT709;\n        } else if (track->par->width == 720 && track->height == 576) {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt470bg\\n\");\n            track->par->color_primaries = AVCOL_PRI_BT470BG;\n        } else if (track->par->width == 720 &&\n                   (track->height == 486 || track->height == 480)) {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming smpte170\\n\");\n            track->par->color_primaries = AVCOL_PRI_SMPTE170M;\n        } else {\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, unable to assume anything\\n\");\n        }\n        switch (track->par->color_primaries) {\n        case AVCOL_PRI_BT709:\n            track->par->color_trc = AVCOL_TRC_BT709;\n            track->par->color_space = AVCOL_SPC_BT709;\n            break;\n        case AVCOL_PRI_SMPTE170M:\n        case AVCOL_PRI_BT470BG:\n            track->par->color_trc = AVCOL_TRC_BT709;\n            track->par->color_space = AVCOL_SPC_SMPTE170M;\n            break;\n        }\n    }\n\n    /* We should only ever be called by MOV or MP4. */\n    av_assert0(track->mode == MODE_MOV || track->mode == MODE_MP4);\n\n    avio_wb32(pb, 18 + (track->mode == MODE_MP4));\n    ffio_wfourcc(pb, \"colr\");\n    if (track->mode == MODE_MP4)\n        ffio_wfourcc(pb, \"nclx\");\n    else\n        ffio_wfourcc(pb, \"nclc\");\n    switch (track->par->color_primaries) {\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n    case AVCOL_PRI_SMPTE170M:\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n    default:                  avio_wb16(pb, 2);\n    }\n    switch (track->par->color_trc) {\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n    default:                  avio_wb16(pb, 2);\n    }\n    switch (track->par->color_space) {\n    case AVCOL_SPC_BT709:     avio_wb16(pb, 1); break;\n    case AVCOL_SPC_BT470BG:\n    case AVCOL_SPC_SMPTE170M: avio_wb16(pb, 6); break;\n    case AVCOL_SPC_SMPTE240M: avio_wb16(pb, 7); break;\n    default:                  avio_wb16(pb, 2);\n    }\n\n    if (track->mode == MODE_MP4) {\n        int full_range = track->par->color_range == AVCOL_RANGE_JPEG;\n        avio_w8(pb, full_range << 7);\n        return 19;\n    } else {\n        return 18;\n    }\n}\n\nstatic void find_compressor(char * compressor_name, int len, MOVTrack *track)\n{\n    AVDictionaryEntry *encoder;\n    int xdcam_res =  (track->par->width == 1280 && track->par->height == 720)\n                  || (track->par->width == 1440 && track->par->height == 1080)\n                  || (track->par->width == 1920 && track->par->height == 1080);\n\n    if (track->mode == MODE_MOV &&\n        (encoder = av_dict_get(track->st->metadata, \"encoder\", NULL, 0))) {\n        av_strlcpy(compressor_name, encoder->value, 32);\n    } else if (track->par->codec_id == AV_CODEC_ID_MPEG2VIDEO && xdcam_res) {\n        int interlaced = track->par->field_order > AV_FIELD_PROGRESSIVE;\n        AVStream *st = track->st;\n        int rate = av_q2d(find_fps(NULL, st));\n        av_strlcatf(compressor_name, len, \"XDCAM\");\n        if (track->par->format == AV_PIX_FMT_YUV422P) {\n            av_strlcatf(compressor_name, len, \" HD422\");\n        } else if(track->par->width == 1440) {\n            av_strlcatf(compressor_name, len, \" HD\");\n        } else\n            av_strlcatf(compressor_name, len, \" EX\");\n\n        av_strlcatf(compressor_name, len, \" %d%c\", track->par->height, interlaced ? 'i' : 'p');\n\n        av_strlcatf(compressor_name, len, \"%d\", rate * (interlaced + 1));\n    }\n}\n\nstatic int mov_write_video_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    char compressor_name[32] = { 0 };\n    int avid = 0;\n\n    avio_wb32(pb, 0); /* size */\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ffio_wfourcc(pb, \"encv\");\n    } else {\n        avio_wl32(pb, track->tag); // store it byteswapped\n    }\n    avio_wb32(pb, 0); /* Reserved */\n    avio_wb16(pb, 0); /* Reserved */\n    avio_wb16(pb, 1); /* Data-reference index */\n\n    avio_wb16(pb, 0); /* Codec stream version */\n    avio_wb16(pb, 0); /* Codec stream revision (=0) */\n    if (track->mode == MODE_MOV) {\n        ffio_wfourcc(pb, \"FFMP\"); /* Vendor */\n        if (track->par->codec_id == AV_CODEC_ID_RAWVIDEO) {\n            avio_wb32(pb, 0); /* Temporal Quality */\n            avio_wb32(pb, 0x400); /* Spatial Quality = lossless*/\n        } else {\n            avio_wb32(pb, 0x200); /* Temporal Quality = normal */\n            avio_wb32(pb, 0x200); /* Spatial Quality = normal */\n        }\n    } else {\n        avio_wb32(pb, 0); /* Reserved */\n        avio_wb32(pb, 0); /* Reserved */\n        avio_wb32(pb, 0); /* Reserved */\n    }\n    avio_wb16(pb, track->par->width); /* Video width */\n    avio_wb16(pb, track->height); /* Video height */\n    avio_wb32(pb, 0x00480000); /* Horizontal resolution 72dpi */\n    avio_wb32(pb, 0x00480000); /* Vertical resolution 72dpi */\n    avio_wb32(pb, 0); /* Data size (= 0) */\n    avio_wb16(pb, 1); /* Frame count (= 1) */\n\n    /* FIXME not sure, ISO 14496-1 draft where it shall be set to 0 */\n    find_compressor(compressor_name, 32, track);\n    avio_w8(pb, strlen(compressor_name));\n    avio_write(pb, compressor_name, 31);\n\n    if (track->mode == MODE_MOV && track->par->bits_per_coded_sample)\n        avio_wb16(pb, track->par->bits_per_coded_sample |\n                  (track->par->format == AV_PIX_FMT_GRAY8 ? 0x20 : 0));\n    else\n        avio_wb16(pb, 0x18); /* Reserved */\n\n    if (track->mode == MODE_MOV && track->par->format == AV_PIX_FMT_PAL8) {\n        int pal_size = 1 << track->par->bits_per_coded_sample;\n        int i;\n        avio_wb16(pb, 0);             /* Color table ID */\n        avio_wb32(pb, 0);             /* Color table seed */\n        avio_wb16(pb, 0x8000);        /* Color table flags */\n        avio_wb16(pb, pal_size - 1);  /* Color table size (zero-relative) */\n        for (i = 0; i < pal_size; i++) {\n            uint32_t rgb = track->palette[i];\n            uint16_t r = (rgb >> 16) & 0xff;\n            uint16_t g = (rgb >> 8)  & 0xff;\n            uint16_t b = rgb         & 0xff;\n            avio_wb16(pb, 0);\n            avio_wb16(pb, (r << 8) | r);\n            avio_wb16(pb, (g << 8) | g);\n            avio_wb16(pb, (b << 8) | b);\n        }\n    } else\n        avio_wb16(pb, 0xffff); /* Reserved */\n\n    if (track->tag == MKTAG('m','p','4','v'))\n        mov_write_esds_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_H263)\n        mov_write_d263_tag(pb);\n    else if (track->par->codec_id == AV_CODEC_ID_AVUI ||\n            track->par->codec_id == AV_CODEC_ID_SVQ3) {\n        mov_write_extradata_tag(pb, track);\n        avio_wb32(pb, 0);\n    } else if (track->par->codec_id == AV_CODEC_ID_DNXHD) {\n        mov_write_avid_tag(pb, track);\n        avid = 1;\n    } else if (track->par->codec_id == AV_CODEC_ID_HEVC)\n        mov_write_hvcc_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_H264 && !TAG_IS_AVCI(track->tag)) {\n        mov_write_avcc_tag(pb, track);\n        if (track->mode == MODE_IPOD)\n            mov_write_uuid_tag_ipod(pb);\n    } else if (track->par->codec_id == AV_CODEC_ID_VP9) {\n        mov_write_vpcc_tag(mov->fc, pb, track);\n    } else if (track->par->codec_id == AV_CODEC_ID_VC1 && track->vos_len > 0)\n        mov_write_dvc1_tag(pb, track);\n    else if (track->par->codec_id == AV_CODEC_ID_VP6F ||\n             track->par->codec_id == AV_CODEC_ID_VP6A) {\n        /* Don't write any potential extradata here - the cropping\n         * is signalled via the normal width/height fields. */\n    } else if (track->par->codec_id == AV_CODEC_ID_R10K) {\n        if (track->par->codec_tag == MKTAG('R','1','0','k'))\n            mov_write_dpxe_tag(pb, track);\n    } else if (track->vos_len > 0)\n        mov_write_glbl_tag(pb, track);\n\n    if (track->par->codec_id != AV_CODEC_ID_H264 &&\n        track->par->codec_id != AV_CODEC_ID_MPEG4 &&\n        track->par->codec_id != AV_CODEC_ID_DNXHD) {\n        int field_order = track->par->field_order;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    if (field_order != track->st->codec->field_order && track->st->codec->field_order != AV_FIELD_UNKNOWN)\n        field_order = track->st->codec->field_order;\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        if (field_order != AV_FIELD_UNKNOWN)\n            mov_write_fiel_tag(pb, track, field_order);\n    }\n\n    if (mov->flags & FF_MOV_FLAG_WRITE_GAMA) {\n        if (track->mode == MODE_MOV)\n            mov_write_gama_tag(pb, track, mov->gamma);\n        else\n            av_log(mov->fc, AV_LOG_WARNING, \"Not writing 'gama' atom. Format is not MOV.\\n\");\n    }\n    if (mov->flags & FF_MOV_FLAG_WRITE_COLR) {\n        if (track->mode == MODE_MOV || track->mode == MODE_MP4)\n            mov_write_colr_tag(pb, track);\n        else\n            av_log(mov->fc, AV_LOG_WARNING, \"Not writing 'colr' atom. Format is not MOV or MP4.\\n\");\n    }\n\n    if (track->par->sample_aspect_ratio.den && track->par->sample_aspect_ratio.num) {\n        mov_write_pasp_tag(pb, track);\n    }\n\n    if (mov->encryption_scheme != MOV_ENC_NONE) {\n        ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);\n    }\n\n    /* extra padding for avid stsd */\n    /* https://developer.apple.com/library/mac/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-61112 */\n    if (avid)\n        avio_wb32(pb, 0);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_rtp_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"rtp \");\n    avio_wb32(pb, 0); /* Reserved */\n    avio_wb16(pb, 0); /* Reserved */\n    avio_wb16(pb, 1); /* Data-reference index */\n\n    avio_wb16(pb, 1); /* Hint track version */\n    avio_wb16(pb, 1); /* Highest compatible version */\n    avio_wb32(pb, track->max_packet_size); /* Max packet size */\n\n    avio_wb32(pb, 12); /* size */\n    ffio_wfourcc(pb, \"tims\");\n    avio_wb32(pb, track->timescale);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_source_reference_tag(AVIOContext *pb, MOVTrack *track, const char *reel_name)\n{\n    uint64_t str_size =strlen(reel_name);\n    int64_t pos = avio_tell(pb);\n\n    if (str_size >= UINT16_MAX){\n        av_log(NULL, AV_LOG_ERROR, \"reel_name length %\"PRIu64\" is too large\\n\", str_size);\n        avio_wb16(pb, 0);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb32(pb, 0);                              /* size */\n    ffio_wfourcc(pb, \"name\");                      /* Data format */\n    avio_wb16(pb, str_size);                       /* string size */\n    avio_wb16(pb, track->language);                /* langcode */\n    avio_write(pb, reel_name, str_size);           /* reel name */\n    return update_size(pb,pos);\n}\n\nstatic int mov_write_tmcd_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n#if 1\n    int frame_duration;\n    int nb_frames;\n    AVDictionaryEntry *t = NULL;\n\n    if (!track->st->avg_frame_rate.num || !track->st->avg_frame_rate.den) {\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n        frame_duration = av_rescale(track->timescale, track->st->codec->time_base.num, track->st->codec->time_base.den);\n        nb_frames      = ROUNDED_DIV(track->st->codec->time_base.den, track->st->codec->time_base.num);\n    FF_ENABLE_DEPRECATION_WARNINGS\n#else\n        av_log(NULL, AV_LOG_ERROR, \"avg_frame_rate not set for tmcd track.\\n\");\n        return AVERROR(EINVAL);\n#endif\n    } else {\n        frame_duration = av_rescale(track->timescale, track->st->avg_frame_rate.num, track->st->avg_frame_rate.den);\n        nb_frames      = ROUNDED_DIV(track->st->avg_frame_rate.den, track->st->avg_frame_rate.num);\n    }\n\n    if (nb_frames > 255) {\n        av_log(NULL, AV_LOG_ERROR, \"fps %d is too large\\n\", nb_frames);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n    avio_wb32(pb, 0);                       /* Reserved */\n    avio_wb32(pb, 1);                       /* Data reference index */\n    avio_wb32(pb, 0);                       /* Flags */\n    avio_wb32(pb, track->timecode_flags);   /* Flags (timecode) */\n    avio_wb32(pb, track->timescale);        /* Timescale */\n    avio_wb32(pb, frame_duration);          /* Frame duration */\n    avio_w8(pb, nb_frames);                 /* Number of frames */\n    avio_w8(pb, 0);                         /* Reserved */\n\n    t = av_dict_get(track->st->metadata, \"reel_name\", NULL, 0);\n    if (t && utf8len(t->value) && track->mode != MODE_MP4)\n        mov_write_source_reference_tag(pb, track, t->value);\n    else\n        avio_wb16(pb, 0); /* zero size */\n#else\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tmcd\");               /* Data format */\n    avio_wb32(pb, 0);                       /* Reserved */\n    avio_wb32(pb, 1);                       /* Data reference index */\n    if (track->par->extradata_size)\n        avio_write(pb, track->par->extradata, track->par->extradata_size);\n#endif\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_stsd_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stsd\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, 1); /* entry count */\n    if (track->par->codec_type == AVMEDIA_TYPE_VIDEO)\n        mov_write_video_tag(pb, mov, track);\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_audio_tag(s, pb, mov, track);\n    else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)\n        mov_write_subtitle_tag(pb, track);\n    else if (track->par->codec_tag == MKTAG('r','t','p',' '))\n        mov_write_rtp_tag(pb, track);\n    else if (track->par->codec_tag == MKTAG('t','m','c','d'))\n        mov_write_tmcd_tag(pb, track);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_ctts_tag(AVIOContext *pb, MOVTrack *track)\n{\n    MOVStts *ctts_entries;\n    uint32_t entries = 0;\n    uint32_t atom_size;\n    int i;\n\n    ctts_entries = av_malloc_array((track->entry + 1), sizeof(*ctts_entries)); /* worst case */\n    if (!ctts_entries)\n        return AVERROR(ENOMEM);\n    ctts_entries[0].count = 1;\n    ctts_entries[0].duration = track->cluster[0].cts;\n    for (i = 1; i < track->entry; i++) {\n        if (track->cluster[i].cts == ctts_entries[entries].duration) {\n            ctts_entries[entries].count++; /* compress */\n        } else {\n            entries++;\n            ctts_entries[entries].duration = track->cluster[i].cts;\n            ctts_entries[entries].count = 1;\n        }\n    }\n    entries++; /* last one */\n    atom_size = 16 + (entries * 8);\n    avio_wb32(pb, atom_size); /* size */\n    ffio_wfourcc(pb, \"ctts\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, entries); /* entry count */\n    for (i = 0; i < entries; i++) {\n        avio_wb32(pb, ctts_entries[i].count);\n        avio_wb32(pb, ctts_entries[i].duration);\n    }\n    av_free(ctts_entries);\n    return atom_size;\n}\n\n/* Time to sample atom */\nstatic int mov_write_stts_tag(AVIOContext *pb, MOVTrack *track)\n{\n    MOVStts *stts_entries = NULL;\n    uint32_t entries = -1;\n    uint32_t atom_size;\n    int i;\n\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO && !track->audio_vbr) {\n        stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */\n        if (!stts_entries)\n            return AVERROR(ENOMEM);\n        stts_entries[0].count = track->sample_count;\n        stts_entries[0].duration = 1;\n        entries = 1;\n    } else {\n        if (track->entry) {\n            stts_entries = av_malloc_array(track->entry, sizeof(*stts_entries)); /* worst case */\n            if (!stts_entries)\n                return AVERROR(ENOMEM);\n        }\n        for (i = 0; i < track->entry; i++) {\n            int duration = get_cluster_duration(track, i);\n            if (i && duration == stts_entries[entries].duration) {\n                stts_entries[entries].count++; /* compress */\n            } else {\n                entries++;\n                stts_entries[entries].duration = duration;\n                stts_entries[entries].count = 1;\n            }\n        }\n        entries++; /* last one */\n    }\n    atom_size = 16 + (entries * 8);\n    avio_wb32(pb, atom_size); /* size */\n    ffio_wfourcc(pb, \"stts\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, entries); /* entry count */\n    for (i = 0; i < entries; i++) {\n        avio_wb32(pb, stts_entries[i].count);\n        avio_wb32(pb, stts_entries[i].duration);\n    }\n    av_free(stts_entries);\n    return atom_size;\n}\n\nstatic int mov_write_dref_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 28); /* size */\n    ffio_wfourcc(pb, \"dref\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb32(pb, 1); /* entry count */\n\n    avio_wb32(pb, 0xc); /* size */\n    //FIXME add the alis and rsrc atom\n    ffio_wfourcc(pb, \"url \");\n    avio_wb32(pb, 1); /* version & flags */\n\n    return 28;\n}\n\nstatic int mov_write_stbl_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int ret;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"stbl\");\n    mov_write_stsd_tag(s, pb, mov, track);\n    mov_write_stts_tag(pb, track);\n    if ((track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n         track->par->codec_tag == MKTAG('r','t','p',' ')) &&\n        track->has_keyframes && track->has_keyframes < track->entry)\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n    if (track->par->codec_type == AVMEDIA_TYPE_VIDEO &&\n        track->flags & MOV_TRACK_CTTS && track->entry) {\n\n        if ((ret = mov_write_ctts_tag(pb, track)) < 0)\n            return ret;\n    }\n    mov_write_stsc_tag(pb, track);\n    mov_write_stsz_tag(pb, track);\n    mov_write_stco_tag(pb, track);\n    if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n        ff_mov_cenc_write_stbl_atoms(&track->cenc, pb);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_dinf_tag(AVIOContext *pb)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"dinf\");\n    mov_write_dref_tag(pb);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_nmhd_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 12);\n    ffio_wfourcc(pb, \"nmhd\");\n    avio_wb32(pb, 0);\n    return 12;\n}\n\nstatic int mov_write_tcmi_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    const char *font = \"Lucida Grande\";\n    avio_wb32(pb, 0);                   /* size */\n    ffio_wfourcc(pb, \"tcmi\");           /* timecode media information atom */\n    avio_wb32(pb, 0);                   /* version & flags */\n    avio_wb16(pb, 0);                   /* text font */\n    avio_wb16(pb, 0);                   /* text face */\n    avio_wb16(pb, 12);                  /* text size */\n    avio_wb16(pb, 0);                   /* (unknown, not in the QT specs...) */\n    avio_wb16(pb, 0x0000);              /* text color (red) */\n    avio_wb16(pb, 0x0000);              /* text color (green) */\n    avio_wb16(pb, 0x0000);              /* text color (blue) */\n    avio_wb16(pb, 0xffff);              /* background color (red) */\n    avio_wb16(pb, 0xffff);              /* background color (green) */\n    avio_wb16(pb, 0xffff);              /* background color (blue) */\n    avio_w8(pb, strlen(font));          /* font len (part of the pascal string) */\n    avio_write(pb, font, strlen(font)); /* font name */\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_gmhd_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);      /* size */\n    ffio_wfourcc(pb, \"gmhd\");\n    avio_wb32(pb, 0x18);   /* gmin size */\n    ffio_wfourcc(pb, \"gmin\");/* generic media info */\n    avio_wb32(pb, 0);      /* version & flags */\n    avio_wb16(pb, 0x40);   /* graphics mode = */\n    avio_wb16(pb, 0x8000); /* opColor (r?) */\n    avio_wb16(pb, 0x8000); /* opColor (g?) */\n    avio_wb16(pb, 0x8000); /* opColor (b?) */\n    avio_wb16(pb, 0);      /* balance */\n    avio_wb16(pb, 0);      /* reserved */\n\n    /*\n     * This special text atom is required for\n     * Apple Quicktime chapters. The contents\n     * don't appear to be documented, so the\n     * bytes are copied verbatim.\n     */\n    if (track->tag != MKTAG('c','6','0','8')) {\n    avio_wb32(pb, 0x2C);   /* size */\n    ffio_wfourcc(pb, \"text\");\n    avio_wb16(pb, 0x01);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x01);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00);\n    avio_wb32(pb, 0x00004000);\n    avio_wb16(pb, 0x0000);\n    }\n\n    if (track->par->codec_tag == MKTAG('t','m','c','d')) {\n        int64_t tmcd_pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size */\n        ffio_wfourcc(pb, \"tmcd\");\n        mov_write_tcmi_tag(pb, track);\n        update_size(pb, tmcd_pos);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_smhd_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 16); /* size */\n    ffio_wfourcc(pb, \"smhd\");\n    avio_wb32(pb, 0); /* version & flags */\n    avio_wb16(pb, 0); /* reserved (balance, normally = 0) */\n    avio_wb16(pb, 0); /* reserved */\n    return 16;\n}\n\nstatic int mov_write_vmhd_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 0x14); /* size (always 0x14) */\n    ffio_wfourcc(pb, \"vmhd\");\n    avio_wb32(pb, 0x01); /* version & flags */\n    avio_wb64(pb, 0); /* reserved (graphics mode = copy) */\n    return 0x14;\n}\n\nstatic int is_clcp_track(MOVTrack *track)\n{\n    return track->tag == MKTAG('c','7','0','8') ||\n           track->tag == MKTAG('c','6','0','8');\n}\n\nstatic int mov_write_hdlr_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n    int64_t pos = avio_tell(pb);\n\n    hdlr      = \"dhlr\";\n    hdlr_type = \"url \";\n    descr     = \"DataHandler\";\n\n    if (track) {\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            hdlr_type = \"vide\";\n            descr     = \"VideoHandler\";\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            hdlr_type = \"soun\";\n            descr     = \"SoundHandler\";\n        } else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            if (is_clcp_track(track)) {\n                hdlr_type = \"clcp\";\n                descr = \"ClosedCaptionHandler\";\n            } else {\n                if (track->tag == MKTAG('t','x','3','g')) {\n                    hdlr_type = \"sbtl\";\n                } else if (track->tag == MKTAG('m','p','4','s')) {\n                    hdlr_type = \"subp\";\n                } else {\n                    hdlr_type = \"text\";\n                }\n            descr = \"SubtitleHandler\";\n            }\n        } else if (track->par->codec_tag == MKTAG('r','t','p',' ')) {\n            hdlr_type = \"hint\";\n            descr     = \"HintHandler\";\n        } else if (track->par->codec_tag == MKTAG('t','m','c','d')) {\n            hdlr_type = \"tmcd\";\n            descr = \"TimeCodeHandler\";\n        } else {\n            char tag_buf[32];\n            av_get_codec_tag_string(tag_buf, sizeof(tag_buf),\n                                    track->par->codec_tag);\n\n            av_log(s, AV_LOG_WARNING,\n                   \"Unknown hldr_type for %s / 0x%04X, writing dummy values\\n\",\n                   tag_buf, track->par->codec_tag);\n        }\n        if (track->st) {\n            // hdlr.name is used by some players to identify the content title\n            // of the track. So if an alternate handler description is\n            // specified, use it.\n            AVDictionaryEntry *t;\n            t = av_dict_get(track->st->metadata, \"handler\", NULL, 0);\n            if (t && utf8len(t->value))\n                descr = t->value;\n        }\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"hdlr\");\n    avio_wb32(pb, 0); /* Version & flags */\n    avio_write(pb, hdlr, 4); /* handler */\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    if (!track || track->mode == MODE_MOV)\n        avio_w8(pb, strlen(descr)); /* pascal string */\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n    if (track && track->mode != MODE_MOV)\n        avio_w8(pb, 0); /* c string */\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_hmhd_tag(AVIOContext *pb)\n{\n    /* This atom must be present, but leaving the values at zero\n     * seems harmless. */\n    avio_wb32(pb, 28); /* size */\n    ffio_wfourcc(pb, \"hmhd\");\n    avio_wb32(pb, 0); /* version, flags */\n    avio_wb16(pb, 0); /* maxPDUsize */\n    avio_wb16(pb, 0); /* avgPDUsize */\n    avio_wb32(pb, 0); /* maxbitrate */\n    avio_wb32(pb, 0); /* avgbitrate */\n    avio_wb32(pb, 0); /* reserved */\n    return 28;\n}\n\nstatic int mov_write_minf_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int ret;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"minf\");\n    if (track->par->codec_type == AVMEDIA_TYPE_VIDEO)\n        mov_write_vmhd_tag(pb);\n    else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        mov_write_smhd_tag(pb);\n    else if (track->par->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n        if (track->tag == MKTAG('t','e','x','t') || is_clcp_track(track)) {\n            mov_write_gmhd_tag(pb, track);\n        } else {\n            mov_write_nmhd_tag(pb);\n        }\n    } else if (track->tag == MKTAG('r','t','p',' ')) {\n        mov_write_hmhd_tag(pb);\n    } else if (track->tag == MKTAG('t','m','c','d')) {\n        if (track->mode != MODE_MOV)\n            mov_write_nmhd_tag(pb);\n        else\n            mov_write_gmhd_tag(pb, track);\n    }\n    if (track->mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */\n        mov_write_hdlr_tag(s, pb, NULL);\n    mov_write_dinf_tag(pb);\n    if ((ret = mov_write_stbl_tag(s, pb, mov, track)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track)\n{\n    int version = track->track_duration < INT32_MAX ? 0 : 1;\n\n    if (track->mode == MODE_ISM)\n        version = 1;\n\n    (version == 1) ? avio_wb32(pb, 44) : avio_wb32(pb, 32); /* size */\n    ffio_wfourcc(pb, \"mdhd\");\n    avio_w8(pb, version);\n    avio_wb24(pb, 0); /* flags */\n    if (version == 1) {\n        avio_wb64(pb, track->time);\n        avio_wb64(pb, track->time);\n    } else {\n        avio_wb32(pb, track->time); /* creation time */\n        avio_wb32(pb, track->time); /* modification time */\n    }\n    avio_wb32(pb, track->timescale); /* time scale (sample rate for audio) */\n    if (!track->entry && mov->mode == MODE_ISM)\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n    else if (!track->entry)\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n    else\n        (version == 1) ? avio_wb64(pb, track->track_duration) : avio_wb32(pb, track->track_duration); /* duration */\n    avio_wb16(pb, track->language); /* language */\n    avio_wb16(pb, 0); /* reserved (quality) */\n\n    if (version != 0 && track->mode == MODE_MOV) {\n        av_log(NULL, AV_LOG_ERROR,\n               \"FATAL error, file duration too long for timebase, this file will not be\\n\"\n               \"playable with quicktime. Choose a different timebase or a different\\n\"\n               \"container format\\n\");\n    }\n\n    return 32;\n}\n\nstatic int mov_write_mdia_tag(AVFormatContext *s, AVIOContext *pb,\n                              MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int ret;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"mdia\");\n    mov_write_mdhd_tag(pb, mov, track);\n    mov_write_hdlr_tag(s, pb, track);\n    if ((ret = mov_write_minf_tag(s, pb, mov, track)) < 0)\n        return ret;\n    return update_size(pb, pos);\n}\n\n/* transformation matrix\n     |a  b  u|\n     |c  d  v|\n     |tx ty w| */\nstatic void write_matrix(AVIOContext *pb, int16_t a, int16_t b, int16_t c,\n                         int16_t d, int16_t tx, int16_t ty)\n{\n    avio_wb32(pb, a << 16);  /* 16.16 format */\n    avio_wb32(pb, b << 16);  /* 16.16 format */\n    avio_wb32(pb, 0);        /* u in 2.30 format */\n    avio_wb32(pb, c << 16);  /* 16.16 format */\n    avio_wb32(pb, d << 16);  /* 16.16 format */\n    avio_wb32(pb, 0);        /* v in 2.30 format */\n    avio_wb32(pb, tx << 16); /* 16.16 format */\n    avio_wb32(pb, ty << 16); /* 16.16 format */\n    avio_wb32(pb, 1 << 30);  /* w in 2.30 format */\n}\n\nstatic int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, AVStream *st)\n{\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n                                      track->timescale, AV_ROUND_UP);\n    int version = duration < INT32_MAX ? 0 : 1;\n    int flags   = MOV_TKHD_FLAG_IN_MOVIE;\n    int rotation = 0;\n    int group   = 0;\n\n    uint32_t *display_matrix = NULL;\n    int      display_matrix_size, i;\n\n    if (st) {\n        if (mov->per_stream_grouping)\n            group = st->index;\n        else\n            group = st->codecpar->codec_type;\n\n        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,\n                                                            &display_matrix_size);\n        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))\n            display_matrix = NULL;\n    }\n\n    if (track->flags & MOV_TRACK_ENABLED)\n        flags |= MOV_TKHD_FLAG_ENABLED;\n\n    if (track->mode == MODE_ISM)\n        version = 1;\n\n    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */\n    ffio_wfourcc(pb, \"tkhd\");\n    avio_w8(pb, version);\n    avio_wb24(pb, flags);\n    if (version == 1) {\n        avio_wb64(pb, track->time);\n        avio_wb64(pb, track->time);\n    } else {\n        avio_wb32(pb, track->time); /* creation time */\n        avio_wb32(pb, track->time); /* modification time */\n    }\n    avio_wb32(pb, track->track_id); /* track-id */\n    avio_wb32(pb, 0); /* reserved */\n    if (!track->entry && mov->mode == MODE_ISM)\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n    else if (!track->entry)\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n    else\n        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);\n\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb16(pb, 0); /* layer */\n    avio_wb16(pb, group); /* alternate group) */\n    /* Volume, only for audio */\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n        avio_wb16(pb, 0x0100);\n    else\n        avio_wb16(pb, 0);\n    avio_wb16(pb, 0); /* reserved */\n\n    /* Matrix structure */\n    if (st && st->metadata) {\n        AVDictionaryEntry *rot = av_dict_get(st->metadata, \"rotate\", NULL, 0);\n        rotation = (rot && rot->value) ? atoi(rot->value) : 0;\n    }\n    if (display_matrix) {\n        for (i = 0; i < 9; i++)\n            avio_wb32(pb, display_matrix[i]);\n    } else if (rotation == 90) {\n        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);\n    } else if (rotation == 180) {\n        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);\n    } else if (rotation == 270) {\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n    } else {\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n    }\n    /* Track width and height, for visual only */\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n        int64_t track_width_1616;\n        if (track->mode == MODE_MOV) {\n            track_width_1616 = track->par->width * 0x10000ULL;\n        } else {\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n                                                  track->par->width * 0x10000LL,\n                                                  st->sample_aspect_ratio.den);\n            if (!track_width_1616 ||\n                track->height != track->par->height ||\n                track_width_1616 > UINT32_MAX)\n                track_width_1616 = track->par->width * 0x10000ULL;\n        }\n        if (track_width_1616 > UINT32_MAX) {\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n            track_width_1616 = 0;\n        }\n        avio_wb32(pb, track_width_1616);\n        if (track->height > 0xFFFF) {\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n            avio_wb32(pb, 0);\n        } else\n            avio_wb32(pb, track->height * 0x10000U);\n    } else {\n        avio_wb32(pb, 0);\n        avio_wb32(pb, 0);\n    }\n    return 0x5c;\n}\n\nstatic int mov_write_tapt_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int32_t width = av_rescale(track->par->sample_aspect_ratio.num, track->par->width,\n                               track->par->sample_aspect_ratio.den);\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tapt\");\n\n    avio_wb32(pb, 20);\n    ffio_wfourcc(pb, \"clef\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, width << 16);\n    avio_wb32(pb, track->par->height << 16);\n\n    avio_wb32(pb, 20);\n    ffio_wfourcc(pb, \"prof\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, width << 16);\n    avio_wb32(pb, track->par->height << 16);\n\n    avio_wb32(pb, 20);\n    ffio_wfourcc(pb, \"enof\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, track->par->width << 16);\n    avio_wb32(pb, track->par->height << 16);\n\n    return update_size(pb, pos);\n}\n\n// This box seems important for the psp playback ... without it the movie seems to hang\nstatic int mov_write_edts_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track)\n{\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n                                      track->timescale, AV_ROUND_UP);\n    int version = duration < INT32_MAX ? 0 : 1;\n    int entry_size, entry_count, size;\n    int64_t delay, start_ct = track->start_cts;\n    int64_t start_dts = track->start_dts;\n\n    if (track->entry) {\n        if (start_dts != track->cluster[0].dts || start_ct != track->cluster[0].cts) {\n\n            av_log(mov->fc, AV_LOG_DEBUG,\n                   \"EDTS using dts:%\"PRId64\" cts:%d instead of dts:%\"PRId64\" cts:%\"PRId64\" tid:%d\\n\",\n                   track->cluster[0].dts, track->cluster[0].cts,\n                   start_dts, start_ct, track->track_id);\n            start_dts = track->cluster[0].dts;\n            start_ct  = track->cluster[0].cts;\n        }\n    }\n\n    delay = av_rescale_rnd(start_dts + start_ct, MOV_TIMESCALE,\n                           track->timescale, AV_ROUND_DOWN);\n    version |= delay < INT32_MAX ? 0 : 1;\n\n    entry_size = (version == 1) ? 20 : 12;\n    entry_count = 1 + (delay > 0);\n    size = 24 + entry_count * entry_size;\n\n    /* write the atom data */\n    avio_wb32(pb, size);\n    ffio_wfourcc(pb, \"edts\");\n    avio_wb32(pb, size - 8);\n    ffio_wfourcc(pb, \"elst\");\n    avio_w8(pb, version);\n    avio_wb24(pb, 0); /* flags */\n\n    avio_wb32(pb, entry_count);\n    if (delay > 0) { /* add an empty edit to delay presentation */\n        /* In the positive delay case, the delay includes the cts\n         * offset, and the second edit list entry below trims out\n         * the same amount from the actual content. This makes sure\n         * that the offset last sample is included in the edit\n         * list duration as well. */\n        if (version == 1) {\n            avio_wb64(pb, delay);\n            avio_wb64(pb, -1);\n        } else {\n            avio_wb32(pb, delay);\n            avio_wb32(pb, -1);\n        }\n        avio_wb32(pb, 0x00010000);\n    } else {\n        /* Avoid accidentally ending up with start_ct = -1 which has got a\n         * special meaning. Normally start_ct should end up positive or zero\n         * here, but use FFMIN in case dts is a small positive integer\n         * rounded to 0 when represented in MOV_TIMESCALE units. */\n        av_assert0(av_rescale_rnd(start_dts, MOV_TIMESCALE, track->timescale, AV_ROUND_DOWN) <= 0);\n        start_ct  = -FFMIN(start_dts, 0);\n        /* Note, this delay is calculated from the pts of the first sample,\n         * ensuring that we don't reduce the duration for cases with\n         * dts<0 pts=0. */\n        duration += delay;\n    }\n\n    /* For fragmented files, we don't know the full length yet. Setting\n     * duration to 0 allows us to only specify the offset, including\n     * the rest of the content (from all future fragments) without specifying\n     * an explicit duration. */\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT)\n        duration = 0;\n\n    /* duration */\n    if (version == 1) {\n        avio_wb64(pb, duration);\n        avio_wb64(pb, start_ct);\n    } else {\n        avio_wb32(pb, duration);\n        avio_wb32(pb, start_ct);\n    }\n    avio_wb32(pb, 0x00010000);\n    return size;\n}\n\nstatic int mov_write_tref_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 20);   // size\n    ffio_wfourcc(pb, \"tref\");\n    avio_wb32(pb, 12);   // size (subatom)\n    avio_wl32(pb, track->tref_tag);\n    avio_wb32(pb, track->tref_id);\n    return 20;\n}\n\n// goes at the end of each track!  ... Critical for PSP playback (\"Incompatible data\" without it)\nstatic int mov_write_uuid_tag_psp(AVIOContext *pb, MOVTrack *mov)\n{\n    avio_wb32(pb, 0x34); /* size ... reports as 28 in mp4box! */\n    ffio_wfourcc(pb, \"uuid\");\n    ffio_wfourcc(pb, \"USMT\");\n    avio_wb32(pb, 0x21d24fce);\n    avio_wb32(pb, 0xbb88695c);\n    avio_wb32(pb, 0xfac9c740);\n    avio_wb32(pb, 0x1c);     // another size here!\n    ffio_wfourcc(pb, \"MTDT\");\n    avio_wb32(pb, 0x00010012);\n    avio_wb32(pb, 0x0a);\n    avio_wb32(pb, 0x55c40000);\n    avio_wb32(pb, 0x1);\n    avio_wb32(pb, 0x0);\n    return 0x34;\n}\n\nstatic int mov_write_udta_sdp(AVIOContext *pb, MOVTrack *track)\n{\n    AVFormatContext *ctx = track->rtp_ctx;\n    char buf[1000] = \"\";\n    int len;\n\n    ff_sdp_write_media(buf, sizeof(buf), ctx->streams[0], track->src_track,\n                       NULL, NULL, 0, 0, ctx);\n    av_strlcatf(buf, sizeof(buf), \"a=control:streamid=%d\\r\\n\", track->track_id);\n    len = strlen(buf);\n\n    avio_wb32(pb, len + 24);\n    ffio_wfourcc(pb, \"udta\");\n    avio_wb32(pb, len + 16);\n    ffio_wfourcc(pb, \"hnti\");\n    avio_wb32(pb, len + 8);\n    ffio_wfourcc(pb, \"sdp \");\n    avio_write(pb, buf, len);\n    return len + 24;\n}\n\nstatic int mov_write_track_metadata(AVIOContext *pb, AVStream *st,\n                                    const char *tag, const char *str)\n{\n    int64_t pos = avio_tell(pb);\n    AVDictionaryEntry *t = av_dict_get(st->metadata, str, NULL, 0);\n    if (!t || !utf8len(t->value))\n        return 0;\n\n    avio_wb32(pb, 0);   /* size */\n    ffio_wfourcc(pb, tag); /* type */\n    avio_write(pb, t->value, strlen(t->value)); /* UTF8 string value */\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_track_udta_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                    AVStream *st)\n{\n    AVIOContext *pb_buf;\n    int ret, size;\n    uint8_t *buf;\n\n    if (!st)\n        return 0;\n\n    ret = avio_open_dyn_buf(&pb_buf);\n    if (ret < 0)\n        return ret;\n\n    if (mov->mode & MODE_MP4)\n        mov_write_track_metadata(pb_buf, st, \"name\", \"title\");\n\n    if ((size = avio_close_dyn_buf(pb_buf, &buf)) > 0) {\n        avio_wb32(pb, size + 8);\n        ffio_wfourcc(pb, \"udta\");\n        avio_write(pb, buf, size);\n    }\n    av_free(buf);\n\n    return 0;\n}\n\nstatic int mov_write_trak_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, AVStream *st)\n{\n    int64_t pos = avio_tell(pb);\n    int entry_backup = track->entry;\n    int chunk_backup = track->chunkCount;\n    int ret;\n\n    /* If we want to have an empty moov, but some samples already have been\n     * buffered (delay_moov), pretend that no samples have been written yet. */\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV)\n        track->chunkCount = track->entry = 0;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"trak\");\n    mov_write_tkhd_tag(pb, mov, track, st);\n\n    av_assert2(mov->use_editlist >= 0);\n\n    if (track->start_dts != AV_NOPTS_VALUE) {\n        if (mov->use_editlist)\n            mov_write_edts_tag(pb, mov, track);  // PSP Movies and several other cases require edts box\n        else if ((track->entry && track->cluster[0].dts) || track->mode == MODE_PSP || is_clcp_track(track))\n            av_log(mov->fc, AV_LOG_WARNING,\n                   \"Not writing any edit list even though one would have been required\\n\");\n    }\n\n    if (track->tref_tag)\n        mov_write_tref_tag(pb, track);\n\n    if ((ret = mov_write_mdia_tag(s, pb, mov, track)) < 0)\n        return ret;\n    if (track->mode == MODE_PSP)\n        mov_write_uuid_tag_psp(pb, track); // PSP Movies require this uuid box\n    if (track->tag == MKTAG('r','t','p',' '))\n        mov_write_udta_sdp(pb, track);\n    if (track->mode == MODE_MOV) {\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            double sample_aspect_ratio = av_q2d(st->sample_aspect_ratio);\n            if (st->sample_aspect_ratio.num && 1.0 != sample_aspect_ratio) {\n                mov_write_tapt_tag(pb, track);\n            }\n        }\n        if (is_clcp_track(track) && st->sample_aspect_ratio.num) {\n            mov_write_tapt_tag(pb, track);\n        }\n    }\n    mov_write_track_udta_tag(pb, mov, st);\n    track->entry = entry_backup;\n    track->chunkCount = chunk_backup;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_iods_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int i, has_audio = 0, has_video = 0;\n    int64_t pos = avio_tell(pb);\n    int audio_profile = mov->iods_audio_profile;\n    int video_profile = mov->iods_video_profile;\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry > 0 || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            has_audio |= mov->tracks[i].par->codec_type == AVMEDIA_TYPE_AUDIO;\n            has_video |= mov->tracks[i].par->codec_type == AVMEDIA_TYPE_VIDEO;\n        }\n    }\n    if (audio_profile < 0)\n        audio_profile = 0xFF - has_audio;\n    if (video_profile < 0)\n        video_profile = 0xFF - has_video;\n    avio_wb32(pb, 0x0); /* size */\n    ffio_wfourcc(pb, \"iods\");\n    avio_wb32(pb, 0);    /* version & flags */\n    put_descr(pb, 0x10, 7);\n    avio_wb16(pb, 0x004f);\n    avio_w8(pb, 0xff);\n    avio_w8(pb, 0xff);\n    avio_w8(pb, audio_profile);\n    avio_w8(pb, video_profile);\n    avio_w8(pb, 0xff);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_trex_tag(AVIOContext *pb, MOVTrack *track)\n{\n    avio_wb32(pb, 0x20); /* size */\n    ffio_wfourcc(pb, \"trex\");\n    avio_wb32(pb, 0);   /* version & flags */\n    avio_wb32(pb, track->track_id); /* track ID */\n    avio_wb32(pb, 1);   /* default sample description index */\n    avio_wb32(pb, 0);   /* default sample duration */\n    avio_wb32(pb, 0);   /* default sample size */\n    avio_wb32(pb, 0);   /* default sample flags */\n    return 0;\n}\n\nstatic int mov_write_mvex_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    avio_wb32(pb, 0x0); /* size */\n    ffio_wfourcc(pb, \"mvex\");\n    for (i = 0; i < mov->nb_streams; i++)\n        mov_write_trex_tag(pb, &mov->tracks[i]);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mvhd_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int max_track_id = 1, i;\n    int64_t max_track_len = 0;\n    int version;\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry > 0 && mov->tracks[i].timescale) {\n            int64_t max_track_len_temp = av_rescale_rnd(mov->tracks[i].track_duration,\n                                                MOV_TIMESCALE,\n                                                mov->tracks[i].timescale,\n                                                AV_ROUND_UP);\n            if (max_track_len < max_track_len_temp)\n                max_track_len = max_track_len_temp;\n            if (max_track_id < mov->tracks[i].track_id)\n                max_track_id = mov->tracks[i].track_id;\n        }\n    }\n    /* If using delay_moov, make sure the output is the same as if no\n     * samples had been written yet. */\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n        max_track_len = 0;\n        max_track_id  = 1;\n    }\n\n    version = max_track_len < UINT32_MAX ? 0 : 1;\n    avio_wb32(pb, version == 1 ? 120 : 108); /* size */\n\n    ffio_wfourcc(pb, \"mvhd\");\n    avio_w8(pb, version);\n    avio_wb24(pb, 0); /* flags */\n    if (version == 1) {\n        avio_wb64(pb, mov->time);\n        avio_wb64(pb, mov->time);\n    } else {\n        avio_wb32(pb, mov->time); /* creation time */\n        avio_wb32(pb, mov->time); /* modification time */\n    }\n    avio_wb32(pb, MOV_TIMESCALE);\n    (version == 1) ? avio_wb64(pb, max_track_len) : avio_wb32(pb, max_track_len); /* duration of longest track */\n\n    avio_wb32(pb, 0x00010000); /* reserved (preferred rate) 1.0 = normal */\n    avio_wb16(pb, 0x0100); /* reserved (preferred volume) 1.0 = normal */\n    avio_wb16(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n    avio_wb32(pb, 0); /* reserved */\n\n    /* Matrix structure */\n    write_matrix(pb, 1, 0, 0, 1, 0, 0);\n\n    avio_wb32(pb, 0); /* reserved (preview time) */\n    avio_wb32(pb, 0); /* reserved (preview duration) */\n    avio_wb32(pb, 0); /* reserved (poster time) */\n    avio_wb32(pb, 0); /* reserved (selection time) */\n    avio_wb32(pb, 0); /* reserved (selection duration) */\n    avio_wb32(pb, 0); /* reserved (current time) */\n    avio_wb32(pb, max_track_id + 1); /* Next track id */\n    return 0x6c;\n}\n\nstatic int mov_write_itunes_hdlr_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                     AVFormatContext *s)\n{\n    avio_wb32(pb, 33); /* size */\n    ffio_wfourcc(pb, \"hdlr\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"mdir\");\n    ffio_wfourcc(pb, \"appl\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    avio_w8(pb, 0);\n    return 33;\n}\n\n/* helper function to write a data tag with the specified string as data */\nstatic int mov_write_string_data_tag(AVIOContext *pb, const char *data, int lang, int long_style)\n{\n    if (long_style) {\n        int size = 16 + strlen(data);\n        avio_wb32(pb, size); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 1);\n        avio_wb32(pb, 0);\n        avio_write(pb, data, strlen(data));\n        return size;\n    } else {\n        if (!lang)\n            lang = ff_mov_iso639_to_lang(\"und\", 1);\n        avio_wb16(pb, strlen(data)); /* string length */\n        avio_wb16(pb, lang);\n        avio_write(pb, data, strlen(data));\n        return strlen(data) + 4;\n    }\n}\n\nstatic int mov_write_string_tag(AVIOContext *pb, const char *name,\n                                const char *value, int lang, int long_style)\n{\n    int size = 0;\n    if (value && value[0]) {\n        int64_t pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size */\n        ffio_wfourcc(pb, name);\n        mov_write_string_data_tag(pb, value, lang, long_style);\n        size = update_size(pb, pos);\n    }\n    return size;\n}\n\nstatic AVDictionaryEntry *get_metadata_lang(AVFormatContext *s,\n                                            const char *tag, int *lang)\n{\n    int l, len, len2;\n    AVDictionaryEntry *t, *t2 = NULL;\n    char tag2[16];\n\n    *lang = 0;\n\n    if (!(t = av_dict_get(s->metadata, tag, NULL, 0)))\n        return NULL;\n\n    len = strlen(t->key);\n    snprintf(tag2, sizeof(tag2), \"%s-\", tag);\n    while ((t2 = av_dict_get(s->metadata, tag2, t2, AV_DICT_IGNORE_SUFFIX))) {\n        len2 = strlen(t2->key);\n        if (len2 == len + 4 && !strcmp(t->value, t2->value)\n            && (l = ff_mov_iso639_to_lang(&t2->key[len2 - 3], 1)) >= 0) {\n            *lang = l;\n            return t;\n        }\n    }\n    return t;\n}\n\nstatic int mov_write_string_metadata(AVFormatContext *s, AVIOContext *pb,\n                                     const char *name, const char *tag,\n                                     int long_style)\n{\n    int lang;\n    AVDictionaryEntry *t = get_metadata_lang(s, tag, &lang);\n    if (!t)\n        return 0;\n    return mov_write_string_tag(pb, name, t->value, lang, long_style);\n}\n\n/* iTunes bpm number */\nstatic int mov_write_tmpo_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVDictionaryEntry *t = av_dict_get(s->metadata, \"tmpo\", NULL, 0);\n    int size = 0, tmpo = t ? atoi(t->value) : 0;\n    if (tmpo) {\n        size = 26;\n        avio_wb32(pb, size);\n        ffio_wfourcc(pb, \"tmpo\");\n        avio_wb32(pb, size-8); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 0x15);  //type specifier\n        avio_wb32(pb, 0);\n        avio_wb16(pb, tmpo);        // data\n    }\n    return size;\n}\n\n/* 3GPP TS 26.244 */\nstatic int mov_write_loci_tag(AVFormatContext *s, AVIOContext *pb)\n{\n    int lang;\n    int64_t pos = avio_tell(pb);\n    double latitude, longitude, altitude;\n    int32_t latitude_fix, longitude_fix, altitude_fix;\n    AVDictionaryEntry *t = get_metadata_lang(s, \"location\", &lang);\n    const char *ptr, *place = \"\";\n    char *end;\n    static const char *astronomical_body = \"earth\";\n    if (!t)\n        return 0;\n\n    ptr = t->value;\n    longitude = strtod(ptr, &end);\n    if (end == ptr) {\n        av_log(s, AV_LOG_WARNING, \"malformed location metadata\\n\");\n        return 0;\n    }\n    ptr = end;\n    latitude = strtod(ptr, &end);\n    if (end == ptr) {\n        av_log(s, AV_LOG_WARNING, \"malformed location metadata\\n\");\n        return 0;\n    }\n    ptr = end;\n    altitude = strtod(ptr, &end);\n    /* If no altitude was present, the default 0 should be fine */\n    if (*end == '/')\n        place = end + 1;\n\n    latitude_fix  = (int32_t) ((1 << 16) * latitude);\n    longitude_fix = (int32_t) ((1 << 16) * longitude);\n    altitude_fix  = (int32_t) ((1 << 16) * altitude);\n\n    avio_wb32(pb, 0);         /* size */\n    ffio_wfourcc(pb, \"loci\"); /* type */\n    avio_wb32(pb, 0);         /* version + flags */\n    avio_wb16(pb, lang);\n    avio_write(pb, place, strlen(place) + 1);\n    avio_w8(pb, 0);           /* role of place (0 == shooting location, 1 == real location, 2 == fictional location) */\n    avio_wb32(pb, latitude_fix);\n    avio_wb32(pb, longitude_fix);\n    avio_wb32(pb, altitude_fix);\n    avio_write(pb, astronomical_body, strlen(astronomical_body) + 1);\n    avio_w8(pb, 0);           /* additional notes, null terminated string */\n\n    return update_size(pb, pos);\n}\n\n/* iTunes track or disc number */\nstatic int mov_write_trkn_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s, int disc)\n{\n    AVDictionaryEntry *t = av_dict_get(s->metadata,\n                                       disc ? \"disc\" : \"track\",\n                                       NULL, 0);\n    int size = 0, track = t ? atoi(t->value) : 0;\n    if (track) {\n        int tracks = 0;\n        char *slash = strchr(t->value, '/');\n        if (slash)\n            tracks = atoi(slash + 1);\n        avio_wb32(pb, 32); /* size */\n        ffio_wfourcc(pb, disc ? \"disk\" : \"trkn\");\n        avio_wb32(pb, 24); /* size */\n        ffio_wfourcc(pb, \"data\");\n        avio_wb32(pb, 0);        // 8 bytes empty\n        avio_wb32(pb, 0);\n        avio_wb16(pb, 0);        // empty\n        avio_wb16(pb, track);    // track / disc number\n        avio_wb16(pb, tracks);   // total track / disc number\n        avio_wb16(pb, 0);        // empty\n        size = 32;\n    }\n    return size;\n}\n\nstatic int mov_write_int8_metadata(AVFormatContext *s, AVIOContext *pb,\n                                   const char *name, const char *tag,\n                                   int len)\n{\n    AVDictionaryEntry *t = NULL;\n    uint8_t num;\n    int size = 24 + len;\n\n    if (len != 1 && len != 4)\n        return -1;\n\n    if (!(t = av_dict_get(s->metadata, tag, NULL, 0)))\n        return 0;\n    num = atoi(t->value);\n\n    avio_wb32(pb, size);\n    ffio_wfourcc(pb, name);\n    avio_wb32(pb, size - 8);\n    ffio_wfourcc(pb, \"data\");\n    avio_wb32(pb, 0x15);\n    avio_wb32(pb, 0);\n    if (len==4) avio_wb32(pb, num);\n    else        avio_w8 (pb, num);\n\n    return size;\n}\n\n/* iTunes meta data list */\nstatic int mov_write_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"ilst\");\n    mov_write_string_metadata(s, pb, \"\\251nam\", \"title\"    , 1);\n    mov_write_string_metadata(s, pb, \"\\251ART\", \"artist\"   , 1);\n    mov_write_string_metadata(s, pb, \"aART\", \"album_artist\", 1);\n    mov_write_string_metadata(s, pb, \"\\251wrt\", \"composer\" , 1);\n    mov_write_string_metadata(s, pb, \"\\251alb\", \"album\"    , 1);\n    mov_write_string_metadata(s, pb, \"\\251day\", \"date\"     , 1);\n    if (!mov_write_string_metadata(s, pb, \"\\251too\", \"encoding_tool\", 1)) {\n        if (!(s->flags & AVFMT_FLAG_BITEXACT))\n            mov_write_string_tag(pb, \"\\251too\", LIBAVFORMAT_IDENT, 0, 1);\n    }\n    mov_write_string_metadata(s, pb, \"\\251cmt\", \"comment\"  , 1);\n    mov_write_string_metadata(s, pb, \"\\251gen\", \"genre\"    , 1);\n    mov_write_string_metadata(s, pb, \"\\251cpy\", \"copyright\", 1);\n    mov_write_string_metadata(s, pb, \"\\251grp\", \"grouping\" , 1);\n    mov_write_string_metadata(s, pb, \"\\251lyr\", \"lyrics\"   , 1);\n    mov_write_string_metadata(s, pb, \"desc\",    \"description\",1);\n    mov_write_string_metadata(s, pb, \"ldes\",    \"synopsis\" , 1);\n    mov_write_string_metadata(s, pb, \"tvsh\",    \"show\"     , 1);\n    mov_write_string_metadata(s, pb, \"tven\",    \"episode_id\",1);\n    mov_write_string_metadata(s, pb, \"tvnn\",    \"network\"  , 1);\n    mov_write_int8_metadata  (s, pb, \"tves\",    \"episode_sort\",4);\n    mov_write_int8_metadata  (s, pb, \"tvsn\",    \"season_number\",4);\n    mov_write_int8_metadata  (s, pb, \"stik\",    \"media_type\",1);\n    mov_write_int8_metadata  (s, pb, \"hdvd\",    \"hd_video\",  1);\n    mov_write_int8_metadata  (s, pb, \"pgap\",    \"gapless_playback\",1);\n    mov_write_int8_metadata  (s, pb, \"cpil\",    \"compilation\", 1);\n    mov_write_trkn_tag(pb, mov, s, 0); // track number\n    mov_write_trkn_tag(pb, mov, s, 1); // disc number\n    mov_write_tmpo_tag(pb, s);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdta_hdlr_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                   AVFormatContext *s)\n{\n    avio_wb32(pb, 33); /* size */\n    ffio_wfourcc(pb, \"hdlr\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"mdta\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    avio_wb32(pb, 0);\n    avio_w8(pb, 0);\n    return 33;\n}\n\nstatic int mov_write_mdta_keys_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                   AVFormatContext *s)\n{\n    AVDictionaryEntry *t = NULL;\n    int64_t pos = avio_tell(pb);\n    int64_t curpos, entry_pos;\n    int count = 0;\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"keys\");\n    avio_wb32(pb, 0);\n    entry_pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* entry count */\n\n    while (t = av_dict_get(s->metadata, \"\", t, AV_DICT_IGNORE_SUFFIX)) {\n        avio_wb32(pb, strlen(t->key) + 8);\n        ffio_wfourcc(pb, \"mdta\");\n        avio_write(pb, t->key, strlen(t->key));\n        count += 1;\n    }\n    curpos = avio_tell(pb);\n    avio_seek(pb, entry_pos, SEEK_SET);\n    avio_wb32(pb, count); // rewrite entry count\n    avio_seek(pb, curpos, SEEK_SET);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdta_ilst_tag(AVIOContext *pb, MOVMuxContext *mov,\n                                   AVFormatContext *s)\n{\n    AVDictionaryEntry *t = NULL;\n    int64_t pos = avio_tell(pb);\n    int count = 1; /* keys are 1-index based */\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"ilst\");\n\n    while (t = av_dict_get(s->metadata, \"\", t, AV_DICT_IGNORE_SUFFIX)) {\n        int64_t entry_pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size */\n        avio_wb32(pb, count); /* key */\n        mov_write_string_data_tag(pb, t->value, 0, 1);\n        update_size(pb, entry_pos);\n        count += 1;\n    }\n    return update_size(pb, pos);\n}\n\n/* meta data tags */\nstatic int mov_write_meta_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    int size = 0;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"meta\");\n    avio_wb32(pb, 0);\n    if (mov->flags & FF_MOV_FLAG_USE_MDTA) {\n        mov_write_mdta_hdlr_tag(pb, mov, s);\n        mov_write_mdta_keys_tag(pb, mov, s);\n        mov_write_mdta_ilst_tag(pb, mov, s);\n    }\n    else {\n        /* iTunes metadata tag */\n        mov_write_itunes_hdlr_tag(pb, mov, s);\n        mov_write_ilst_tag(pb, mov, s);\n    }\n    size = update_size(pb, pos);\n    return size;\n}\n\nstatic int mov_write_raw_metadata_tag(AVFormatContext *s, AVIOContext *pb,\n                                      const char *name, const char *key)\n{\n    int len;\n    AVDictionaryEntry *t;\n\n    if (!(t = av_dict_get(s->metadata, key, NULL, 0)))\n        return 0;\n\n    len = strlen(t->value);\n    if (len > 0) {\n        int size = len + 8;\n        avio_wb32(pb, size);\n        ffio_wfourcc(pb, name);\n        avio_write(pb, t->value, len);\n        return size;\n    }\n    return 0;\n}\n\nstatic int ascii_to_wc(AVIOContext *pb, const uint8_t *b)\n{\n    int val;\n    while (*b) {\n        GET_UTF8(val, *b++, return -1;)\n        avio_wb16(pb, val);\n    }\n    avio_wb16(pb, 0x00);\n    return 0;\n}\n\nstatic uint16_t language_code(const char *str)\n{\n    return (((str[0] - 0x60) & 0x1F) << 10) +\n           (((str[1] - 0x60) & 0x1F) <<  5) +\n           (( str[2] - 0x60) & 0x1F);\n}\n\nstatic int mov_write_3gp_udta_tag(AVIOContext *pb, AVFormatContext *s,\n                                  const char *tag, const char *str)\n{\n    int64_t pos = avio_tell(pb);\n    AVDictionaryEntry *t = av_dict_get(s->metadata, str, NULL, 0);\n    if (!t || !utf8len(t->value))\n        return 0;\n    avio_wb32(pb, 0);   /* size */\n    ffio_wfourcc(pb, tag); /* type */\n    avio_wb32(pb, 0);   /* version + flags */\n    if (!strcmp(tag, \"yrrc\"))\n        avio_wb16(pb, atoi(t->value));\n    else {\n        avio_wb16(pb, language_code(\"eng\")); /* language */\n        avio_write(pb, t->value, strlen(t->value) + 1); /* UTF8 string value */\n        if (!strcmp(tag, \"albm\") &&\n            (t = av_dict_get(s->metadata, \"track\", NULL, 0)))\n            avio_w8(pb, atoi(t->value));\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_chpl_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    int64_t pos = avio_tell(pb);\n    int i, nb_chapters = FFMIN(s->nb_chapters, 255);\n\n    avio_wb32(pb, 0);            // size\n    ffio_wfourcc(pb, \"chpl\");\n    avio_wb32(pb, 0x01000000);   // version + flags\n    avio_wb32(pb, 0);            // unknown\n    avio_w8(pb, nb_chapters);\n\n    for (i = 0; i < nb_chapters; i++) {\n        AVChapter *c = s->chapters[i];\n        AVDictionaryEntry *t;\n        avio_wb64(pb, av_rescale_q(c->start, c->time_base, (AVRational){1,10000000}));\n\n        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {\n            int len = FFMIN(strlen(t->value), 255);\n            avio_w8(pb, len);\n            avio_write(pb, t->value, len);\n        } else\n            avio_w8(pb, 0);\n    }\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_udta_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    AVIOContext *pb_buf;\n    int ret, size;\n    uint8_t *buf;\n\n    ret = avio_open_dyn_buf(&pb_buf);\n    if (ret < 0)\n        return ret;\n\n    if (mov->mode & MODE_3GP) {\n        mov_write_3gp_udta_tag(pb_buf, s, \"perf\", \"artist\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"titl\", \"title\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"auth\", \"author\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"gnre\", \"genre\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"dscp\", \"comment\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"albm\", \"album\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"cprt\", \"copyright\");\n        mov_write_3gp_udta_tag(pb_buf, s, \"yrrc\", \"date\");\n        mov_write_loci_tag(s, pb_buf);\n    } else if (mov->mode == MODE_MOV && !(mov->flags & FF_MOV_FLAG_USE_MDTA)) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4\n        mov_write_string_metadata(s, pb_buf, \"\\251ART\", \"artist\",      0);\n        mov_write_string_metadata(s, pb_buf, \"\\251nam\", \"title\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251aut\", \"author\",      0);\n        mov_write_string_metadata(s, pb_buf, \"\\251alb\", \"album\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251day\", \"date\",        0);\n        mov_write_string_metadata(s, pb_buf, \"\\251swr\", \"encoder\",     0);\n        // currently ignored by mov.c\n        mov_write_string_metadata(s, pb_buf, \"\\251des\", \"comment\",     0);\n        // add support for libquicktime, this atom is also actually read by mov.c\n        mov_write_string_metadata(s, pb_buf, \"\\251cmt\", \"comment\",     0);\n        mov_write_string_metadata(s, pb_buf, \"\\251gen\", \"genre\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251cpy\", \"copyright\",   0);\n        mov_write_string_metadata(s, pb_buf, \"\\251mak\", \"make\",        0);\n        mov_write_string_metadata(s, pb_buf, \"\\251mod\", \"model\",       0);\n        mov_write_string_metadata(s, pb_buf, \"\\251xyz\", \"location\",    0);\n        mov_write_raw_metadata_tag(s, pb_buf, \"XMP_\", \"xmp\");\n    } else {\n        /* iTunes meta data */\n        mov_write_meta_tag(pb_buf, mov, s);\n        mov_write_loci_tag(s, pb_buf);\n    }\n\n    if (s->nb_chapters && !(mov->flags & FF_MOV_FLAG_DISABLE_CHPL))\n        mov_write_chpl_tag(pb_buf, s);\n\n    if ((size = avio_close_dyn_buf(pb_buf, &buf)) > 0) {\n        avio_wb32(pb, size + 8);\n        ffio_wfourcc(pb, \"udta\");\n        avio_write(pb, buf, size);\n    }\n    av_free(buf);\n\n    return 0;\n}\n\nstatic void mov_write_psp_udta_tag(AVIOContext *pb,\n                                   const char *str, const char *lang, int type)\n{\n    int len = utf8len(str) + 1;\n    if (len <= 0)\n        return;\n    avio_wb16(pb, len * 2 + 10);        /* size */\n    avio_wb32(pb, type);                /* type */\n    avio_wb16(pb, language_code(lang)); /* language */\n    avio_wb16(pb, 0x01);                /* ? */\n    ascii_to_wc(pb, str);\n}\n\nstatic int mov_write_uuidusmt_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVDictionaryEntry *title = av_dict_get(s->metadata, \"title\", NULL, 0);\n    int64_t pos, pos2;\n\n    if (title) {\n        pos = avio_tell(pb);\n        avio_wb32(pb, 0); /* size placeholder*/\n        ffio_wfourcc(pb, \"uuid\");\n        ffio_wfourcc(pb, \"USMT\");\n        avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n        avio_wb32(pb, 0xbb88695c);\n        avio_wb32(pb, 0xfac9c740);\n\n        pos2 = avio_tell(pb);\n        avio_wb32(pb, 0); /* size placeholder*/\n        ffio_wfourcc(pb, \"MTDT\");\n        avio_wb16(pb, 4);\n\n        // ?\n        avio_wb16(pb, 0x0C);                 /* size */\n        avio_wb32(pb, 0x0B);                 /* type */\n        avio_wb16(pb, language_code(\"und\")); /* language */\n        avio_wb16(pb, 0x0);                  /* ? */\n        avio_wb16(pb, 0x021C);               /* data */\n\n        if (!(s->flags & AVFMT_FLAG_BITEXACT))\n            mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      \"eng\", 0x04);\n        mov_write_psp_udta_tag(pb, title->value,          \"eng\", 0x01);\n        mov_write_psp_udta_tag(pb, \"2006/04/01 11:11:11\", \"und\", 0x03);\n\n        update_size(pb, pos2);\n        return update_size(pb, pos);\n    }\n\n    return 0;\n}\n\nstatic void build_chunks(MOVTrack *trk)\n{\n    int i;\n    MOVIentry *chunk = &trk->cluster[0];\n    uint64_t chunkSize = chunk->size;\n    chunk->chunkNum = 1;\n    if (trk->chunkCount)\n        return;\n    trk->chunkCount = 1;\n    for (i = 1; i<trk->entry; i++){\n        if (chunk->pos + chunkSize == trk->cluster[i].pos &&\n            chunkSize + trk->cluster[i].size < (1<<20)){\n            chunkSize             += trk->cluster[i].size;\n            chunk->samples_in_chunk += trk->cluster[i].entries;\n        } else {\n            trk->cluster[i].chunkNum = chunk->chunkNum+1;\n            chunk=&trk->cluster[i];\n            chunkSize = chunk->size;\n            trk->chunkCount++;\n        }\n    }\n}\n\n/**\n * Assign track ids. If option \"use_stream_ids_as_track_ids\" is set,\n * the stream ids are used as track ids.\n *\n * This assumes mov->tracks and s->streams are in the same order and\n * there are no gaps in either of them (so mov->tracks[n] refers to\n * s->streams[n]).\n *\n * As an exception, there can be more entries in\n * s->streams than in mov->tracks, in which case new track ids are\n * generated (starting after the largest found stream id).\n */\nstatic int mov_setup_track_ids(MOVMuxContext *mov, AVFormatContext *s)\n{\n    int i;\n\n    if (mov->track_ids_ok)\n        return 0;\n\n    if (mov->use_stream_ids_as_track_ids) {\n        int next_generated_track_id = 0;\n        for (i = 0; i < s->nb_streams; i++) {\n            if (s->streams[i]->id > next_generated_track_id)\n                next_generated_track_id = s->streams[i]->id;\n        }\n\n        for (i = 0; i < mov->nb_streams; i++) {\n            if (mov->tracks[i].entry <= 0 && !(mov->flags & FF_MOV_FLAG_FRAGMENT))\n                continue;\n\n            mov->tracks[i].track_id = i >= s->nb_streams ? ++next_generated_track_id : s->streams[i]->id;\n        }\n    } else {\n        for (i = 0; i < mov->nb_streams; i++) {\n            if (mov->tracks[i].entry <= 0 && !(mov->flags & FF_MOV_FLAG_FRAGMENT))\n                continue;\n\n            mov->tracks[i].track_id = i + 1;\n        }\n    }\n\n    mov->track_ids_ok = 1;\n\n    return 0;\n}\n\nstatic int mov_write_moov_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              AVFormatContext *s)\n{\n    int i;\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size placeholder*/\n    ffio_wfourcc(pb, \"moov\");\n\n    mov_setup_track_ids(mov, s);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry <= 0 && !(mov->flags & FF_MOV_FLAG_FRAGMENT))\n            continue;\n\n        mov->tracks[i].time     = mov->time;\n\n        if (mov->tracks[i].entry)\n            build_chunks(&mov->tracks[i]);\n    }\n\n    if (mov->chapter_track)\n        for (i = 0; i < s->nb_streams; i++) {\n            mov->tracks[i].tref_tag = MKTAG('c','h','a','p');\n            mov->tracks[i].tref_id  = mov->tracks[mov->chapter_track].track_id;\n        }\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (track->tag == MKTAG('r','t','p',' ')) {\n            track->tref_tag = MKTAG('h','i','n','t');\n            track->tref_id = mov->tracks[track->src_track].track_id;\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            int * fallback, size;\n            fallback = (int*)av_stream_get_side_data(track->st,\n                                                     AV_PKT_DATA_FALLBACK_TRACK,\n                                                     &size);\n            if (fallback != NULL && size == sizeof(int)) {\n                if (*fallback >= 0 && *fallback < mov->nb_streams) {\n                    track->tref_tag = MKTAG('f','a','l','l');\n                    track->tref_id = mov->tracks[*fallback].track_id;\n                }\n            }\n        }\n    }\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].tag == MKTAG('t','m','c','d')) {\n            int src_trk = mov->tracks[i].src_track;\n            mov->tracks[src_trk].tref_tag = mov->tracks[i].tag;\n            mov->tracks[src_trk].tref_id  = mov->tracks[i].track_id;\n            //src_trk may have a different timescale than the tmcd track\n            mov->tracks[i].track_duration = av_rescale(mov->tracks[src_trk].track_duration,\n                                                       mov->tracks[i].timescale,\n                                                       mov->tracks[src_trk].timescale);\n        }\n    }\n\n    mov_write_mvhd_tag(pb, mov);\n    if (mov->mode != MODE_MOV && !mov->iods_skip)\n        mov_write_iods_tag(pb, mov);\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].entry > 0 || mov->flags & FF_MOV_FLAG_FRAGMENT) {\n            int ret = mov_write_trak_tag(s, pb, mov, &(mov->tracks[i]), i < s->nb_streams ? s->streams[i] : NULL);\n            if (ret < 0)\n                return ret;\n        }\n    }\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT)\n        mov_write_mvex_tag(pb, mov); /* QuickTime requires trak to precede this */\n\n    if (mov->mode == MODE_PSP)\n        mov_write_uuidusmt_tag(pb, s);\n    else\n        mov_write_udta_tag(pb, mov, s);\n\n    return update_size(pb, pos);\n}\n\nstatic void param_write_int(AVIOContext *pb, const char *name, int value)\n{\n    avio_printf(pb, \"<param name=\\\"%s\\\" value=\\\"%d\\\" valuetype=\\\"data\\\"/>\\n\", name, value);\n}\n\nstatic void param_write_string(AVIOContext *pb, const char *name, const char *value)\n{\n    avio_printf(pb, \"<param name=\\\"%s\\\" value=\\\"%s\\\" valuetype=\\\"data\\\"/>\\n\", name, value);\n}\n\nstatic void param_write_hex(AVIOContext *pb, const char *name, const uint8_t *value, int len)\n{\n    char buf[150];\n    len = FFMIN(sizeof(buf) / 2 - 1, len);\n    ff_data_to_hex(buf, value, len, 0);\n    buf[2 * len] = '\\0';\n    avio_printf(pb, \"<param name=\\\"%s\\\" value=\\\"%s\\\" valuetype=\\\"data\\\"/>\\n\", name, buf);\n}\n\nstatic int mov_write_isml_manifest(AVIOContext *pb, MOVMuxContext *mov, AVFormatContext *s)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    int64_t manifest_bit_rate = 0;\n    AVCPBProperties *props = NULL;\n\n    static const uint8_t uuid[] = {\n        0xa5, 0xd4, 0x0b, 0x30, 0xe8, 0x14, 0x11, 0xdd,\n        0xba, 0x2f, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66\n    };\n\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"uuid\");\n    avio_write(pb, uuid, sizeof(uuid));\n    avio_wb32(pb, 0);\n\n    avio_printf(pb, \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\n    avio_printf(pb, \"<smil xmlns=\\\"http://www.w3.org/2001/SMIL20/Language\\\">\\n\");\n    avio_printf(pb, \"<head>\\n\");\n    if (!(mov->fc->flags & AVFMT_FLAG_BITEXACT))\n        avio_printf(pb, \"<meta name=\\\"creator\\\" content=\\\"%s\\\" />\\n\",\n                    LIBAVFORMAT_IDENT);\n    avio_printf(pb, \"</head>\\n\");\n    avio_printf(pb, \"<body>\\n\");\n    avio_printf(pb, \"<switch>\\n\");\n\n    mov_setup_track_ids(mov, s);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        const char *type;\n        int track_id = track->track_id;\n\n        AVStream *st = track->st;\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            type = \"video\";\n        } else if (track->par->codec_type == AVMEDIA_TYPE_AUDIO) {\n            type = \"audio\";\n        } else {\n            continue;\n        }\n\n        props = (AVCPBProperties*)av_stream_get_side_data(track->st, AV_PKT_DATA_CPB_PROPERTIES, NULL);\n\n        if (track->par->bit_rate) {\n            manifest_bit_rate = track->par->bit_rate;\n        } else if (props) {\n            manifest_bit_rate = props->max_bitrate;\n        }\n\n        avio_printf(pb, \"<%s systemBitrate=\\\"%\"PRId64\"\\\">\\n\", type,\n                    manifest_bit_rate);\n        param_write_int(pb, \"systemBitrate\", manifest_bit_rate);\n        param_write_int(pb, \"trackID\", track_id);\n        param_write_string(pb, \"systemLanguage\", lang ? lang->value : \"und\");\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            if (track->par->codec_id == AV_CODEC_ID_H264) {\n                uint8_t *ptr;\n                int size = track->par->extradata_size;\n                if (!ff_avc_write_annexb_extradata(track->par->extradata, &ptr,\n                                                   &size)) {\n                    param_write_hex(pb, \"CodecPrivateData\",\n                                    ptr ? ptr : track->par->extradata,\n                                    size);\n                    av_free(ptr);\n                }\n                param_write_string(pb, \"FourCC\", \"H264\");\n            } else if (track->par->codec_id == AV_CODEC_ID_VC1) {\n                param_write_string(pb, \"FourCC\", \"WVC1\");\n                param_write_hex(pb, \"CodecPrivateData\", track->par->extradata,\n                                track->par->extradata_size);\n            }\n            param_write_int(pb, \"MaxWidth\", track->par->width);\n            param_write_int(pb, \"MaxHeight\", track->par->height);\n            param_write_int(pb, \"DisplayWidth\", track->par->width);\n            param_write_int(pb, \"DisplayHeight\", track->par->height);\n        } else {\n            if (track->par->codec_id == AV_CODEC_ID_AAC) {\n                switch (track->par->profile)\n                {\n                    case FF_PROFILE_AAC_HE_V2:\n                        param_write_string(pb, \"FourCC\", \"AACP\");\n                        break;\n                    case FF_PROFILE_AAC_HE:\n                        param_write_string(pb, \"FourCC\", \"AACH\");\n                        break;\n                    default:\n                        param_write_string(pb, \"FourCC\", \"AACL\");\n                }\n            } else if (track->par->codec_id == AV_CODEC_ID_WMAPRO) {\n                param_write_string(pb, \"FourCC\", \"WMAP\");\n            }\n            param_write_hex(pb, \"CodecPrivateData\", track->par->extradata,\n                            track->par->extradata_size);\n            param_write_int(pb, \"AudioTag\", ff_codec_get_tag(ff_codec_wav_tags,\n                                                             track->par->codec_id));\n            param_write_int(pb, \"Channels\", track->par->channels);\n            param_write_int(pb, \"SamplingRate\", track->par->sample_rate);\n            param_write_int(pb, \"BitsPerSample\", 16);\n            param_write_int(pb, \"PacketSize\", track->par->block_align ?\n                                              track->par->block_align : 4);\n        }\n        avio_printf(pb, \"</%s>\\n\", type);\n    }\n    avio_printf(pb, \"</switch>\\n\");\n    avio_printf(pb, \"</body>\\n\");\n    avio_printf(pb, \"</smil>\\n\");\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mfhd_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    avio_wb32(pb, 16);\n    ffio_wfourcc(pb, \"mfhd\");\n    avio_wb32(pb, 0);\n    avio_wb32(pb, mov->fragments);\n    return 0;\n}\n\nstatic uint32_t get_sample_flags(MOVTrack *track, MOVIentry *entry)\n{\n    return entry->flags & MOV_SYNC_SAMPLE ? MOV_FRAG_SAMPLE_FLAG_DEPENDS_NO :\n           (MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES | MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC);\n}\n\nstatic int mov_write_tfhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int64_t moof_offset)\n{\n    int64_t pos = avio_tell(pb);\n    uint32_t flags = MOV_TFHD_DEFAULT_SIZE | MOV_TFHD_DEFAULT_DURATION |\n                     MOV_TFHD_BASE_DATA_OFFSET;\n    if (!track->entry) {\n        flags |= MOV_TFHD_DURATION_IS_EMPTY;\n    } else {\n        flags |= MOV_TFHD_DEFAULT_FLAGS;\n    }\n    if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET)\n        flags &= ~MOV_TFHD_BASE_DATA_OFFSET;\n    if (mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF) {\n        flags &= ~MOV_TFHD_BASE_DATA_OFFSET;\n        flags |= MOV_TFHD_DEFAULT_BASE_IS_MOOF;\n    }\n\n    /* Don't set a default sample size, the silverlight player refuses\n     * to play files with that set. Don't set a default sample duration,\n     * WMP freaks out if it is set. Don't set a base data offset, PIFF\n     * file format says it MUST NOT be set. */\n    if (track->mode == MODE_ISM)\n        flags &= ~(MOV_TFHD_DEFAULT_SIZE | MOV_TFHD_DEFAULT_DURATION |\n                   MOV_TFHD_BASE_DATA_OFFSET);\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"tfhd\");\n    avio_w8(pb, 0); /* version */\n    avio_wb24(pb, flags);\n\n    avio_wb32(pb, track->track_id); /* track-id */\n    if (flags & MOV_TFHD_BASE_DATA_OFFSET)\n        avio_wb64(pb, moof_offset);\n    if (flags & MOV_TFHD_DEFAULT_DURATION) {\n        track->default_duration = get_cluster_duration(track, 0);\n        avio_wb32(pb, track->default_duration);\n    }\n    if (flags & MOV_TFHD_DEFAULT_SIZE) {\n        track->default_size = track->entry ? track->cluster[0].size : 1;\n        avio_wb32(pb, track->default_size);\n    } else\n        track->default_size = -1;\n\n    if (flags & MOV_TFHD_DEFAULT_FLAGS) {\n        /* Set the default flags based on the second sample, if available.\n         * If the first sample is different, that can be signaled via a separate field. */\n        if (track->entry > 1)\n            track->default_sample_flags = get_sample_flags(track, &track->cluster[1]);\n        else\n            track->default_sample_flags =\n                track->par->codec_type == AVMEDIA_TYPE_VIDEO ?\n                (MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES | MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC) :\n                MOV_FRAG_SAMPLE_FLAG_DEPENDS_NO;\n        avio_wb32(pb, track->default_sample_flags);\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_trun_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int moof_size,\n                              int first, int end)\n{\n    int64_t pos = avio_tell(pb);\n    uint32_t flags = MOV_TRUN_DATA_OFFSET;\n    int i;\n\n    for (i = first; i < end; i++) {\n        if (get_cluster_duration(track, i) != track->default_duration)\n            flags |= MOV_TRUN_SAMPLE_DURATION;\n        if (track->cluster[i].size != track->default_size)\n            flags |= MOV_TRUN_SAMPLE_SIZE;\n        if (i > first && get_sample_flags(track, &track->cluster[i]) != track->default_sample_flags)\n            flags |= MOV_TRUN_SAMPLE_FLAGS;\n    }\n    if (!(flags & MOV_TRUN_SAMPLE_FLAGS) && track->entry > 0 &&\n         get_sample_flags(track, &track->cluster[0]) != track->default_sample_flags)\n        flags |= MOV_TRUN_FIRST_SAMPLE_FLAGS;\n    if (track->flags & MOV_TRACK_CTTS)\n        flags |= MOV_TRUN_SAMPLE_CTS;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"trun\");\n    avio_w8(pb, 0); /* version */\n    avio_wb24(pb, flags);\n\n    avio_wb32(pb, end - first); /* sample count */\n    if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET &&\n        !(mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF) &&\n        !mov->first_trun)\n        avio_wb32(pb, 0); /* Later tracks follow immediately after the previous one */\n    else\n        avio_wb32(pb, moof_size + 8 + track->data_offset +\n                      track->cluster[first].pos); /* data offset */\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS)\n        avio_wb32(pb, get_sample_flags(track, &track->cluster[first]));\n\n    for (i = first; i < end; i++) {\n        if (flags & MOV_TRUN_SAMPLE_DURATION)\n            avio_wb32(pb, get_cluster_duration(track, i));\n        if (flags & MOV_TRUN_SAMPLE_SIZE)\n            avio_wb32(pb, track->cluster[i].size);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)\n            avio_wb32(pb, get_sample_flags(track, &track->cluster[i]));\n        if (flags & MOV_TRUN_SAMPLE_CTS)\n            avio_wb32(pb, track->cluster[i].cts);\n    }\n\n    mov->first_trun = 0;\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_tfxd_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    static const uint8_t uuid[] = {\n        0x6d, 0x1d, 0x9b, 0x05, 0x42, 0xd5, 0x44, 0xe6,\n        0x80, 0xe2, 0x14, 0x1d, 0xaf, 0xf7, 0x57, 0xb2\n    };\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"uuid\");\n    avio_write(pb, uuid, sizeof(uuid));\n    avio_w8(pb, 1);\n    avio_wb24(pb, 0);\n    avio_wb64(pb, track->start_dts + track->frag_start +\n                  track->cluster[0].cts);\n    avio_wb64(pb, track->end_pts -\n                  (track->cluster[0].dts + track->cluster[0].cts));\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_tfrf_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int entry)\n{\n    int n = track->nb_frag_info - 1 - entry, i;\n    int size = 8 + 16 + 4 + 1 + 16*n;\n    static const uint8_t uuid[] = {\n        0xd4, 0x80, 0x7e, 0xf2, 0xca, 0x39, 0x46, 0x95,\n        0x8e, 0x54, 0x26, 0xcb, 0x9e, 0x46, 0xa7, 0x9f\n    };\n\n    if (entry < 0)\n        return 0;\n\n    avio_seek(pb, track->frag_info[entry].tfrf_offset, SEEK_SET);\n    avio_wb32(pb, size);\n    ffio_wfourcc(pb, \"uuid\");\n    avio_write(pb, uuid, sizeof(uuid));\n    avio_w8(pb, 1);\n    avio_wb24(pb, 0);\n    avio_w8(pb, n);\n    for (i = 0; i < n; i++) {\n        int index = entry + 1 + i;\n        avio_wb64(pb, track->frag_info[index].time);\n        avio_wb64(pb, track->frag_info[index].duration);\n    }\n    if (n < mov->ism_lookahead) {\n        int free_size = 16 * (mov->ism_lookahead - n);\n        avio_wb32(pb, free_size);\n        ffio_wfourcc(pb, \"free\");\n        ffio_fill(pb, 0, free_size - 8);\n    }\n\n    return 0;\n}\n\nstatic int mov_write_tfrf_tags(AVIOContext *pb, MOVMuxContext *mov,\n                               MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n    for (i = 0; i < mov->ism_lookahead; i++) {\n        /* Update the tfrf tag for the last ism_lookahead fragments,\n         * nb_frag_info - 1 is the next fragment to be written. */\n        mov_write_tfrf_tag(pb, mov, track, track->nb_frag_info - 2 - i);\n    }\n    avio_seek(pb, pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_add_tfra_entries(AVIOContext *pb, MOVMuxContext *mov, int tracks,\n                                int size)\n{\n    int i;\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        MOVFragmentInfo *info;\n        if ((tracks >= 0 && i != tracks) || !track->entry)\n            continue;\n        track->nb_frag_info++;\n        if (track->nb_frag_info >= track->frag_info_capacity) {\n            unsigned new_capacity = track->nb_frag_info + MOV_FRAG_INFO_ALLOC_INCREMENT;\n            if (av_reallocp_array(&track->frag_info,\n                                  new_capacity,\n                                  sizeof(*track->frag_info)))\n                return AVERROR(ENOMEM);\n            track->frag_info_capacity = new_capacity;\n        }\n        info = &track->frag_info[track->nb_frag_info - 1];\n        info->offset   = avio_tell(pb);\n        info->size     = size;\n        // Try to recreate the original pts for the first packet\n        // from the fields we have stored\n        info->time     = track->start_dts + track->frag_start +\n                         track->cluster[0].cts;\n        info->duration = track->end_pts -\n                         (track->cluster[0].dts + track->cluster[0].cts);\n        // If the pts is less than zero, we will have trimmed\n        // away parts of the media track using an edit list,\n        // and the corresponding start presentation time is zero.\n        if (info->time < 0) {\n            info->duration += info->time;\n            info->time = 0;\n        }\n        info->tfrf_offset = 0;\n        mov_write_tfrf_tags(pb, mov, track);\n    }\n    return 0;\n}\n\nstatic int mov_write_tfdt_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"tfdt\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n    avio_wb64(pb, track->frag_start);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_traf_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track, int64_t moof_offset,\n                              int moof_size)\n{\n    int64_t pos = avio_tell(pb);\n    int i, start = 0;\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"traf\");\n\n    mov_write_tfhd_tag(pb, mov, track, moof_offset);\n    if (mov->mode != MODE_ISM)\n        mov_write_tfdt_tag(pb, track);\n    for (i = 1; i < track->entry; i++) {\n        if (track->cluster[i].pos != track->cluster[i - 1].pos + track->cluster[i - 1].size) {\n            mov_write_trun_tag(pb, mov, track, moof_size, start, i);\n            start = i;\n        }\n    }\n    mov_write_trun_tag(pb, mov, track, moof_size, start, track->entry);\n    if (mov->mode == MODE_ISM) {\n        mov_write_tfxd_tag(pb, track);\n\n        if (mov->ism_lookahead) {\n            int i, size = 16 + 4 + 1 + 16 * mov->ism_lookahead;\n\n            if (track->nb_frag_info > 0) {\n                MOVFragmentInfo *info = &track->frag_info[track->nb_frag_info - 1];\n                if (!info->tfrf_offset)\n                    info->tfrf_offset = avio_tell(pb);\n            }\n            avio_wb32(pb, 8 + size);\n            ffio_wfourcc(pb, \"free\");\n            for (i = 0; i < size; i++)\n                avio_w8(pb, 0);\n        }\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_moof_tag_internal(AVIOContext *pb, MOVMuxContext *mov,\n                                       int tracks, int moof_size)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"moof\");\n    mov->first_trun = 1;\n\n    mov_write_mfhd_tag(pb, mov);\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (tracks >= 0 && i != tracks)\n            continue;\n        if (!track->entry)\n            continue;\n        mov_write_traf_tag(pb, mov, track, pos, moof_size);\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_sidx_tag(AVIOContext *pb,\n                              MOVTrack *track, int ref_size, int total_sidx_size)\n{\n    int64_t pos = avio_tell(pb), offset_pos, end_pos;\n    int64_t presentation_time, duration, offset;\n    int starts_with_SAP, i, entries;\n\n    if (track->entry) {\n        entries = 1;\n        presentation_time = track->start_dts + track->frag_start +\n                            track->cluster[0].cts;\n        duration = track->end_pts -\n                   (track->cluster[0].dts + track->cluster[0].cts);\n        starts_with_SAP = track->cluster[0].flags & MOV_SYNC_SAMPLE;\n\n        // pts<0 should be cut away using edts\n        if (presentation_time < 0) {\n            duration += presentation_time;\n            presentation_time = 0;\n        }\n    } else {\n        entries = track->nb_frag_info;\n        if (entries <= 0)\n            return 0;\n        presentation_time = track->frag_info[0].time;\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"sidx\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n    avio_wb32(pb, track->track_id); /* reference_ID */\n    avio_wb32(pb, track->timescale); /* timescale */\n    avio_wb64(pb, presentation_time); /* earliest_presentation_time */\n    offset_pos = avio_tell(pb);\n    avio_wb64(pb, 0); /* first_offset (offset to referenced moof) */\n    avio_wb16(pb, 0); /* reserved */\n\n    avio_wb16(pb, entries); /* reference_count */\n    for (i = 0; i < entries; i++) {\n        if (!track->entry) {\n            if (i > 1 && track->frag_info[i].offset != track->frag_info[i - 1].offset + track->frag_info[i - 1].size) {\n               av_log(NULL, AV_LOG_ERROR, \"Non-consecutive fragments, writing incorrect sidx\\n\");\n            }\n            duration = track->frag_info[i].duration;\n            ref_size = track->frag_info[i].size;\n            starts_with_SAP = 1;\n        }\n        avio_wb32(pb, (0 << 31) | (ref_size & 0x7fffffff)); /* reference_type (0 = media) | referenced_size */\n        avio_wb32(pb, duration); /* subsegment_duration */\n        avio_wb32(pb, (starts_with_SAP << 31) | (0 << 28) | 0); /* starts_with_SAP | SAP_type | SAP_delta_time */\n    }\n\n    end_pos = avio_tell(pb);\n    offset = pos + total_sidx_size - end_pos;\n    avio_seek(pb, offset_pos, SEEK_SET);\n    avio_wb64(pb, offset);\n    avio_seek(pb, end_pos, SEEK_SET);\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_sidx_tags(AVIOContext *pb, MOVMuxContext *mov,\n                               int tracks, int ref_size)\n{\n    int i, round, ret;\n    AVIOContext *avio_buf;\n    int total_size = 0;\n    for (round = 0; round < 2; round++) {\n        // First run one round to calculate the total size of all\n        // sidx atoms.\n        // This would be much simpler if we'd only write one sidx\n        // atom, for the first track in the moof.\n        if (round == 0) {\n            if ((ret = ffio_open_null_buf(&avio_buf)) < 0)\n                return ret;\n        } else {\n            avio_buf = pb;\n        }\n        for (i = 0; i < mov->nb_streams; i++) {\n            MOVTrack *track = &mov->tracks[i];\n            if (tracks >= 0 && i != tracks)\n                continue;\n            // When writing a sidx for the full file, entry is 0, but\n            // we want to include all tracks. ref_size is 0 in this case,\n            // since we read it from frag_info instead.\n            if (!track->entry && ref_size > 0)\n                continue;\n            total_size -= mov_write_sidx_tag(avio_buf, track, ref_size,\n                                             total_size);\n        }\n        if (round == 0)\n            total_size = ffio_close_null_buf(avio_buf);\n    }\n    return 0;\n}\n\nstatic int mov_write_moof_tag(AVIOContext *pb, MOVMuxContext *mov, int tracks,\n                              int64_t mdat_size)\n{\n    AVIOContext *avio_buf;\n    int ret, moof_size;\n\n    if ((ret = ffio_open_null_buf(&avio_buf)) < 0)\n        return ret;\n    mov_write_moof_tag_internal(avio_buf, mov, tracks, 0);\n    moof_size = ffio_close_null_buf(avio_buf);\n\n    if (mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX))\n        mov_write_sidx_tags(pb, mov, tracks, moof_size + 8 + mdat_size);\n\n    if ((ret = mov_add_tfra_entries(pb, mov, tracks, moof_size + 8 + mdat_size)) < 0)\n        return ret;\n\n    return mov_write_moof_tag_internal(pb, mov, tracks, moof_size);\n}\n\nstatic int mov_write_tfra_tag(AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"tfra\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n\n    avio_wb32(pb, track->track_id);\n    avio_wb32(pb, 0); /* length of traf/trun/sample num */\n    avio_wb32(pb, track->nb_frag_info);\n    for (i = 0; i < track->nb_frag_info; i++) {\n        avio_wb64(pb, track->frag_info[i].time);\n        avio_wb64(pb, track->frag_info[i].offset + track->data_offset);\n        avio_w8(pb, 1); /* traf number */\n        avio_w8(pb, 1); /* trun number */\n        avio_w8(pb, 1); /* sample number */\n    }\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mfra_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    int64_t pos = avio_tell(pb);\n    int i;\n\n    avio_wb32(pb, 0); /* size placeholder */\n    ffio_wfourcc(pb, \"mfra\");\n    /* An empty mfra atom is enough to indicate to the publishing point that\n     * the stream has ended. */\n    if (mov->flags & FF_MOV_FLAG_ISML)\n        return update_size(pb, pos);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (track->nb_frag_info)\n            mov_write_tfra_tag(pb, track);\n    }\n\n    avio_wb32(pb, 16);\n    ffio_wfourcc(pb, \"mfro\");\n    avio_wb32(pb, 0); /* version + flags */\n    avio_wb32(pb, avio_tell(pb) + 4 - pos);\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_mdat_tag(AVIOContext *pb, MOVMuxContext *mov)\n{\n    avio_wb32(pb, 8);    // placeholder for extended size field (64 bit)\n    ffio_wfourcc(pb, mov->mode == MODE_MOV ? \"wide\" : \"free\");\n\n    mov->mdat_pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size placeholder*/\n    ffio_wfourcc(pb, \"mdat\");\n    return 0;\n}\n\n/* TODO: This needs to be more general */\nstatic int mov_write_ftyp_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int64_t pos = avio_tell(pb);\n    int has_h264 = 0, has_video = 0;\n    int minor = 0x200;\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n            has_video = 1;\n        if (st->codecpar->codec_id == AV_CODEC_ID_H264)\n            has_h264 = 1;\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"ftyp\");\n\n    if (mov->major_brand && strlen(mov->major_brand) >= 4)\n        ffio_wfourcc(pb, mov->major_brand);\n    else if (mov->mode == MODE_3GP) {\n        ffio_wfourcc(pb, has_h264 ? \"3gp6\"  : \"3gp4\");\n        minor =     has_h264 ?   0x100 :   0x200;\n    } else if (mov->mode & MODE_3G2) {\n        ffio_wfourcc(pb, has_h264 ? \"3g2b\"  : \"3g2a\");\n        minor =     has_h264 ? 0x20000 : 0x10000;\n    } else if (mov->mode == MODE_PSP)\n        ffio_wfourcc(pb, \"MSNV\");\n    else if (mov->mode == MODE_MP4 && mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF)\n        ffio_wfourcc(pb, \"iso5\"); // Required when using default-base-is-moof\n    else if (mov->mode == MODE_MP4)\n        ffio_wfourcc(pb, \"isom\");\n    else if (mov->mode == MODE_IPOD)\n        ffio_wfourcc(pb, has_video ? \"M4V \":\"M4A \");\n    else if (mov->mode == MODE_ISM)\n        ffio_wfourcc(pb, \"isml\");\n    else if (mov->mode == MODE_F4V)\n        ffio_wfourcc(pb, \"f4v \");\n    else\n        ffio_wfourcc(pb, \"qt  \");\n\n    avio_wb32(pb, minor);\n\n    if (mov->mode == MODE_MOV)\n        ffio_wfourcc(pb, \"qt  \");\n    else if (mov->mode == MODE_ISM) {\n        ffio_wfourcc(pb, \"piff\");\n    } else if (!(mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF)) {\n        ffio_wfourcc(pb, \"isom\");\n        ffio_wfourcc(pb, \"iso2\");\n        if (has_h264)\n            ffio_wfourcc(pb, \"avc1\");\n    }\n\n    // We add tfdt atoms when fragmenting, signal this with the iso6 compatible\n    // brand. This is compatible with users that don't understand tfdt.\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT && mov->mode != MODE_ISM)\n        ffio_wfourcc(pb, \"iso6\");\n\n    if (mov->mode == MODE_3GP)\n        ffio_wfourcc(pb, has_h264 ? \"3gp6\":\"3gp4\");\n    else if (mov->mode & MODE_3G2)\n        ffio_wfourcc(pb, has_h264 ? \"3g2b\":\"3g2a\");\n    else if (mov->mode == MODE_PSP)\n        ffio_wfourcc(pb, \"MSNV\");\n    else if (mov->mode == MODE_MP4)\n        ffio_wfourcc(pb, \"mp41\");\n\n    if (mov->flags & FF_MOV_FLAG_DASH && mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n        ffio_wfourcc(pb, \"dash\");\n\n    return update_size(pb, pos);\n}\n\nstatic int mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVStream       *video_st    = s->streams[0];\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n    int audio_rate = audio_par->sample_rate;\n    int64_t frame_rate = (video_st->avg_frame_rate.num * 0x10000LL) / video_st->avg_frame_rate.den;\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n    if (frame_rate < 0 || frame_rate > INT32_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Frame rate %f outside supported range\\n\", frame_rate / (double)0x10000);\n        return AVERROR(EINVAL);\n    }\n\n    avio_wb32(pb, 0x94); /* size */\n    ffio_wfourcc(pb, \"uuid\");\n    ffio_wfourcc(pb, \"PROF\");\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n    avio_wb32(pb, 0xbb88695c);\n    avio_wb32(pb, 0xfac9c740);\n\n    avio_wb32(pb, 0x0);  /* ? */\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n    avio_wb32(pb, 0x14); /* size */\n    ffio_wfourcc(pb, \"FPRF\");\n    avio_wb32(pb, 0x0);  /* ? */\n    avio_wb32(pb, 0x0);  /* ? */\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x2c);  /* size */\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, 0x2);   /* TrackID */\n    ffio_wfourcc(pb, \"mp4a\");\n    avio_wb32(pb, 0x20f);\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, audio_kbitrate);\n    avio_wb32(pb, audio_kbitrate);\n    avio_wb32(pb, audio_rate);\n    avio_wb32(pb, audio_par->channels);\n\n    avio_wb32(pb, 0x34);  /* size */\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, 0x1);    /* TrackID */\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n        ffio_wfourcc(pb, \"avc1\");\n        avio_wb16(pb, 0x014D);\n        avio_wb16(pb, 0x0015);\n    } else {\n        ffio_wfourcc(pb, \"mp4v\");\n        avio_wb16(pb, 0x0000);\n        avio_wb16(pb, 0x0103);\n    }\n    avio_wb32(pb, 0x0);\n    avio_wb32(pb, video_kbitrate);\n    avio_wb32(pb, video_kbitrate);\n    avio_wb32(pb, frame_rate);\n    avio_wb32(pb, frame_rate);\n    avio_wb16(pb, video_par->width);\n    avio_wb16(pb, video_par->height);\n    avio_wb32(pb, 0x010001); /* ? */\n\n    return 0;\n}\n\nstatic int mov_write_identification(AVIOContext *pb, AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i;\n\n    mov_write_ftyp_tag(pb,s);\n    if (mov->mode == MODE_PSP) {\n        int video_streams_nb = 0, audio_streams_nb = 0, other_streams_nb = 0;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n                video_streams_nb++;\n            else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n                audio_streams_nb++;\n            else\n                other_streams_nb++;\n            }\n\n        if (video_streams_nb != 1 || audio_streams_nb != 1 || other_streams_nb) {\n            av_log(s, AV_LOG_ERROR, \"PSP mode need one video and one audio stream\\n\");\n            return AVERROR(EINVAL);\n        }\n        return mov_write_uuidprof_tag(pb, s);\n    }\n    return 0;\n}\n\nstatic int mov_parse_mpeg2_frame(AVPacket *pkt, uint32_t *flags)\n{\n    uint32_t c = -1;\n    int i, closed_gop = 0;\n\n    for (i = 0; i < pkt->size - 4; i++) {\n        c = (c << 8) + pkt->data[i];\n        if (c == 0x1b8) { // gop\n            closed_gop = pkt->data[i + 4] >> 6 & 0x01;\n        } else if (c == 0x100) { // pic\n            int temp_ref = (pkt->data[i + 1] << 2) | (pkt->data[i + 2] >> 6);\n            if (!temp_ref || closed_gop) // I picture is not reordered\n                *flags = MOV_SYNC_SAMPLE;\n            else\n                *flags = MOV_PARTIAL_SYNC_SAMPLE;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic void mov_parse_vc1_frame(AVPacket *pkt, MOVTrack *trk)\n{\n    const uint8_t *start, *next, *end = pkt->data + pkt->size;\n    int seq = 0, entry = 0;\n    int key = pkt->flags & AV_PKT_FLAG_KEY;\n    start = find_next_marker(pkt->data, end);\n    for (next = start; next < end; start = next) {\n        next = find_next_marker(start + 4, end);\n        switch (AV_RB32(start)) {\n        case VC1_CODE_SEQHDR:\n            seq = 1;\n            break;\n        case VC1_CODE_ENTRYPOINT:\n            entry = 1;\n            break;\n        case VC1_CODE_SLICE:\n            trk->vc1_info.slices = 1;\n            break;\n        }\n    }\n    if (!trk->entry && trk->vc1_info.first_packet_seen)\n        trk->vc1_info.first_frag_written = 1;\n    if (!trk->entry && !trk->vc1_info.first_frag_written) {\n        /* First packet in first fragment */\n        trk->vc1_info.first_packet_seq   = seq;\n        trk->vc1_info.first_packet_entry = entry;\n        trk->vc1_info.first_packet_seen  = 1;\n    } else if ((seq && !trk->vc1_info.packet_seq) ||\n               (entry && !trk->vc1_info.packet_entry)) {\n        int i;\n        for (i = 0; i < trk->entry; i++)\n            trk->cluster[i].flags &= ~MOV_SYNC_SAMPLE;\n        trk->has_keyframes = 0;\n        if (seq)\n            trk->vc1_info.packet_seq = 1;\n        if (entry)\n            trk->vc1_info.packet_entry = 1;\n        if (!trk->vc1_info.first_frag_written) {\n            /* First fragment */\n            if ((!seq   || trk->vc1_info.first_packet_seq) &&\n                (!entry || trk->vc1_info.first_packet_entry)) {\n                /* First packet had the same headers as this one, readd the\n                 * sync sample flag. */\n                trk->cluster[0].flags |= MOV_SYNC_SAMPLE;\n                trk->has_keyframes = 1;\n            }\n        }\n    }\n    if (trk->vc1_info.packet_seq && trk->vc1_info.packet_entry)\n        key = seq && entry;\n    else if (trk->vc1_info.packet_seq)\n        key = seq;\n    else if (trk->vc1_info.packet_entry)\n        key = entry;\n    if (key) {\n        trk->cluster[trk->entry].flags |= MOV_SYNC_SAMPLE;\n        trk->has_keyframes++;\n    }\n}\n\nstatic int mov_flush_fragment_interleaving(AVFormatContext *s, MOVTrack *track)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int ret, buf_size;\n    uint8_t *buf;\n    int i, offset;\n\n    if (!track->mdat_buf)\n        return 0;\n    if (!mov->mdat_buf) {\n        if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n            return ret;\n    }\n    buf_size = avio_close_dyn_buf(track->mdat_buf, &buf);\n    track->mdat_buf = NULL;\n\n    offset = avio_tell(mov->mdat_buf);\n    avio_write(mov->mdat_buf, buf, buf_size);\n    av_free(buf);\n\n    for (i = track->entries_flushed; i < track->entry; i++)\n        track->cluster[i].pos += offset;\n    track->entries_flushed = track->entry;\n    return 0;\n}\n\nstatic int mov_flush_fragment(AVFormatContext *s, int force)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i, first_track = -1;\n    int64_t mdat_size = 0;\n    int ret;\n    int has_video = 0, starts_with_key = 0, first_video_track = 1;\n\n    if (!(mov->flags & FF_MOV_FLAG_FRAGMENT))\n        return 0;\n\n    // Try to fill in the duration of the last packet in each stream\n    // from queued packets in the interleave queues. If the flushing\n    // of fragments was triggered automatically by an AVPacket, we\n    // already have reliable info for the end of that track, but other\n    // tracks may need to be filled in.\n    for (i = 0; i < s->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (!track->end_reliable) {\n            int64_t ts_offset;\n            const AVPacket *next = ff_interleaved_peek(s, i, &ts_offset);\n            if (next) {\n                track->track_duration = next->dts - track->start_dts + ts_offset;\n                if (next->pts != AV_NOPTS_VALUE)\n                    track->end_pts = next->pts;\n                else\n                    track->end_pts = next->dts;\n                track->end_pts += ts_offset;\n            }\n        }\n    }\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (track->entry <= 1)\n            continue;\n        // Sample durations are calculated as the diff of dts values,\n        // but for the last sample in a fragment, we don't know the dts\n        // of the first sample in the next fragment, so we have to rely\n        // on what was set as duration in the AVPacket. Not all callers\n        // set this though, so we might want to replace it with an\n        // estimate if it currently is zero.\n        if (get_cluster_duration(track, track->entry - 1) != 0)\n            continue;\n        // Use the duration (i.e. dts diff) of the second last sample for\n        // the last one. This is a wild guess (and fatal if it turns out\n        // to be too long), but probably the best we can do - having a zero\n        // duration is bad as well.\n        track->track_duration += get_cluster_duration(track, track->entry - 2);\n        track->end_pts        += get_cluster_duration(track, track->entry - 2);\n        if (!mov->missing_duration_warned) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Estimating the duration of the last packet in a \"\n                   \"fragment, consider setting the duration field in \"\n                   \"AVPacket instead.\\n\");\n            mov->missing_duration_warned = 1;\n        }\n    }\n\n    if (!mov->moov_written) {\n        int64_t pos = avio_tell(s->pb);\n        uint8_t *buf;\n        int buf_size, moov_size;\n\n        for (i = 0; i < mov->nb_streams; i++)\n            if (!mov->tracks[i].entry)\n                break;\n        /* Don't write the initial moov unless all tracks have data */\n        if (i < mov->nb_streams && !force)\n            return 0;\n\n        moov_size = get_moov_size(s);\n        for (i = 0; i < mov->nb_streams; i++)\n            mov->tracks[i].data_offset = pos + moov_size + 8;\n\n        avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_HEADER);\n        if (mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n            mov_write_identification(s->pb, s);\n        if ((ret = mov_write_moov_tag(s->pb, mov, s)) < 0)\n            return ret;\n\n        if (mov->flags & FF_MOV_FLAG_DELAY_MOOV) {\n            if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n                mov->reserved_header_pos = avio_tell(s->pb);\n            avio_flush(s->pb);\n            mov->moov_written = 1;\n            return 0;\n        }\n\n        buf_size = avio_close_dyn_buf(mov->mdat_buf, &buf);\n        mov->mdat_buf = NULL;\n        avio_wb32(s->pb, buf_size + 8);\n        ffio_wfourcc(s->pb, \"mdat\");\n        avio_write(s->pb, buf, buf_size);\n        av_free(buf);\n\n        if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n            mov->reserved_header_pos = avio_tell(s->pb);\n\n        mov->moov_written = 1;\n        mov->mdat_size = 0;\n        for (i = 0; i < mov->nb_streams; i++) {\n            if (mov->tracks[i].entry)\n                mov->tracks[i].frag_start += mov->tracks[i].start_dts +\n                                             mov->tracks[i].track_duration -\n                                             mov->tracks[i].cluster[0].dts;\n            mov->tracks[i].entry = 0;\n            mov->tracks[i].end_reliable = 0;\n        }\n        avio_flush(s->pb);\n        return 0;\n    }\n\n    if (mov->frag_interleave) {\n        for (i = 0; i < mov->nb_streams; i++) {\n            MOVTrack *track = &mov->tracks[i];\n            int ret;\n            if ((ret = mov_flush_fragment_interleaving(s, track)) < 0)\n                return ret;\n        }\n\n        if (!mov->mdat_buf)\n            return 0;\n        mdat_size = avio_tell(mov->mdat_buf);\n    }\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        if (mov->flags & FF_MOV_FLAG_SEPARATE_MOOF || mov->frag_interleave)\n            track->data_offset = 0;\n        else\n            track->data_offset = mdat_size;\n        if (track->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            has_video = 1;\n            if (first_video_track) {\n                if (track->entry)\n                    starts_with_key = track->cluster[0].flags & MOV_SYNC_SAMPLE;\n                first_video_track = 0;\n            }\n        }\n        if (!track->entry)\n            continue;\n        if (track->mdat_buf)\n            mdat_size += avio_tell(track->mdat_buf);\n        if (first_track < 0)\n            first_track = i;\n    }\n\n    if (!mdat_size)\n        return 0;\n\n    avio_write_marker(s->pb,\n                      av_rescale(mov->tracks[first_track].cluster[0].dts, AV_TIME_BASE, mov->tracks[first_track].timescale),\n                      (has_video ? starts_with_key : mov->tracks[first_track].cluster[0].flags & MOV_SYNC_SAMPLE) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *track = &mov->tracks[i];\n        int buf_size, write_moof = 1, moof_tracks = -1;\n        uint8_t *buf;\n        int64_t duration = 0;\n\n        if (track->entry)\n            duration = track->start_dts + track->track_duration -\n                       track->cluster[0].dts;\n        if (mov->flags & FF_MOV_FLAG_SEPARATE_MOOF) {\n            if (!track->mdat_buf)\n                continue;\n            mdat_size = avio_tell(track->mdat_buf);\n            moof_tracks = i;\n        } else {\n            write_moof = i == first_track;\n        }\n\n        if (write_moof) {\n            avio_flush(s->pb);\n\n            mov_write_moof_tag(s->pb, mov, moof_tracks, mdat_size);\n            mov->fragments++;\n\n            avio_wb32(s->pb, mdat_size + 8);\n            ffio_wfourcc(s->pb, \"mdat\");\n        }\n\n        if (track->entry)\n            track->frag_start += duration;\n        track->entry = 0;\n        track->entries_flushed = 0;\n        track->end_reliable = 0;\n        if (!mov->frag_interleave) {\n            if (!track->mdat_buf)\n                continue;\n            buf_size = avio_close_dyn_buf(track->mdat_buf, &buf);\n            track->mdat_buf = NULL;\n        } else {\n            if (!mov->mdat_buf)\n                continue;\n            buf_size = avio_close_dyn_buf(mov->mdat_buf, &buf);\n            mov->mdat_buf = NULL;\n        }\n\n        avio_write(s->pb, buf, buf_size);\n        av_free(buf);\n    }\n\n    mov->mdat_size = 0;\n\n    avio_flush(s->pb);\n    return 0;\n}\n\nstatic int mov_auto_flush_fragment(AVFormatContext *s, int force)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int had_moov = mov->moov_written;\n    int ret = mov_flush_fragment(s, force);\n    if (ret < 0)\n        return ret;\n    // If using delay_moov, the first flush only wrote the moov,\n    // not the actual moof+mdat pair, thus flush once again.\n    if (!had_moov && mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n        ret = mov_flush_fragment(s, force);\n    return ret;\n}\n\nstatic int check_pkt(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    int64_t ref;\n    uint64_t duration;\n\n    if (trk->entry) {\n        ref = trk->cluster[trk->entry - 1].dts;\n    } else if (   trk->start_dts != AV_NOPTS_VALUE\n               && !trk->frag_discont) {\n        ref = trk->start_dts + trk->track_duration;\n    } else\n        ref = pkt->dts; // Skip tests for the first packet\n\n    duration = pkt->dts - ref;\n    if (pkt->dts < ref || duration >= INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" / timestamp: %\"PRId64\" is out of range for mov/mp4 format\\n\",\n            duration, pkt->dts\n        );\n\n        pkt->dts = ref + 1;\n        pkt->pts = AV_NOPTS_VALUE;\n    }\n\n    if (pkt->duration < 0 || pkt->duration > INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" is invalid\\n\", pkt->duration);\n        return AVERROR(EINVAL);\n    }\n    return 0;\n}\n\nint ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecParameters *par = trk->par;\n    unsigned int samples_in_chunk = 0;\n    int size = pkt->size, ret = 0;\n    uint8_t *reformatted_data = NULL;\n\n    ret = check_pkt(s, pkt);\n    if (ret < 0)\n        return ret;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        int ret;\n        if (mov->moov_written || mov->flags & FF_MOV_FLAG_EMPTY_MOOV) {\n            if (mov->frag_interleave && mov->fragments > 0) {\n                if (trk->entry - trk->entries_flushed >= mov->frag_interleave) {\n                    if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)\n                        return ret;\n                }\n            }\n\n            if (!trk->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = trk->mdat_buf;\n        } else {\n            if (!mov->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = mov->mdat_buf;\n        }\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static const uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (par->codec_id == AV_CODEC_ID_ADPCM_MS ||\n               par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV) {\n        samples_in_chunk = trk->par->frame_size;\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n    else\n        samples_in_chunk = 1;\n\n    if (samples_in_chunk < 1) {\n        av_log(s, AV_LOG_ERROR, \"fatal error, input packet contains no samples\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* copy extradata if it exists */\n    if (trk->vos_len == 0 && par->extradata_size > 0 &&\n        !TAG_IS_AVCI(trk->tag) &&\n        (par->codec_id != AV_CODEC_ID_DNXHD)) {\n        trk->vos_len  = par->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, par->extradata, trk->vos_len);\n    }\n\n    if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&\n        (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {\n        if (!s->streams[pkt->stream_index]->nb_frames) {\n            av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"\n                   \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"\n                   \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");\n            return -1;\n        }\n        av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");\n    }\n    if (par->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {\n        /* from x264 or from bytestream H.264 */\n        /* NAL reformatting needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n                size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);\n                if (size < 0) {\n                    ret = size;\n                    goto err;\n                }\n            } else {\n                size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n            }\n        }\n    } else if (par->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&\n               (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {\n        /* extradata is Annex B, assume the bitstream is too and convert it */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);\n        }\n#if CONFIG_AC3_PARSER\n    } else if (par->codec_id == AV_CODEC_ID_EAC3) {\n        size = handle_eac3(mov, pkt, trk);\n        if (size < 0)\n            return size;\n        else if (!size)\n            goto end;\n        avio_write(pb, pkt->data, size);\n#endif\n    } else {\n        if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n            if (par->codec_id == AV_CODEC_ID_H264 && par->extradata_size > 4) {\n                int nal_size_length = (par->extradata[4] & 0x3) + 1;\n                ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);\n            } else {\n                ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);\n            }\n\n            if (ret) {\n                goto err;\n            }\n        } else {\n            avio_write(pb, pkt->data, size);\n        }\n    }\n\n    if ((par->codec_id == AV_CODEC_ID_DNXHD ||\n         par->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len  = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (trk->entry >= trk->cluster_capacity) {\n        unsigned new_capacity = 2 * (trk->entry + MOV_INDEX_CLUSTER_SIZE);\n        if (av_reallocp_array(&trk->cluster, new_capacity,\n                              sizeof(*trk->cluster))) {\n            ret = AVERROR(ENOMEM);\n            goto err;\n        }\n        trk->cluster_capacity = new_capacity;\n    }\n\n    trk->cluster[trk->entry].pos              = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].chunkNum         = 0;\n    trk->cluster[trk->entry].size             = size;\n    trk->cluster[trk->entry].entries          = samples_in_chunk;\n    trk->cluster[trk->entry].dts              = pkt->dts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        if (!trk->frag_discont) {\n            /* First packet of a new fragment. We already wrote the duration\n             * of the last packet of the previous fragment based on track_duration,\n             * which might not exactly match our dts. Therefore adjust the dts\n             * of this packet to be what the previous packets duration implies. */\n            trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n            /* We also may have written the pts and the corresponding duration\n             * in sidx/tfrf/tfxd tags; make sure the sidx pts and duration match up with\n             * the next fragment. This means the cts of the first sample must\n             * be the same in all fragments, unless end_pts was updated by\n             * the packet causing the fragment to be written. */\n            if ((mov->flags & FF_MOV_FLAG_DASH && !(mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)) ||\n                mov->mode == MODE_ISM)\n                pkt->pts = pkt->dts + trk->end_pts - trk->cluster[trk->entry].dts;\n        } else {\n            /* New fragment, but discontinuous from previous fragments.\n             * Pretend the duration sum of the earlier fragments is\n             * pkt->dts - trk->start_dts. */\n            trk->frag_start = pkt->dts - trk->start_dts;\n            trk->end_pts = AV_NOPTS_VALUE;\n            trk->frag_discont = 0;\n        }\n    }\n\n    if (!trk->entry && trk->start_dts == AV_NOPTS_VALUE && !mov->use_editlist &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        /* Not using edit lists and shifting the first track to start from zero.\n         * If the other streams start from a later timestamp, we won't be able\n         * to signal the difference in starting time without an edit list.\n         * Thus move the timestamp for this first sample to 0, increasing\n         * its duration instead. */\n        trk->cluster[trk->entry].dts = trk->start_dts = 0;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE) {\n        trk->start_dts = pkt->dts;\n        if (trk->frag_discont) {\n            if (mov->use_editlist) {\n                /* Pretend the whole stream started at pts=0, with earlier fragments\n                 * already written. If the stream started at pts=0, the duration sum\n                 * of earlier fragments would have been pkt->pts. */\n                trk->frag_start = pkt->pts;\n                trk->start_dts  = pkt->dts - pkt->pts;\n            } else {\n                /* Pretend the whole stream started at dts=0, with earlier fragments\n                 * already written, with a duration summing up to pkt->dts. */\n                trk->frag_start = pkt->dts;\n                trk->start_dts  = 0;\n            }\n            trk->frag_discont = 0;\n        } else if (pkt->dts && mov->moov_written)\n            av_log(s, AV_LOG_WARNING,\n                   \"Track %d starts with a nonzero dts %\"PRId64\", while the moov \"\n                   \"already has been written. Set the delay_moov flag to handle \"\n                   \"this case.\\n\",\n                   pkt->stream_index, pkt->dts);\n    }\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n    trk->last_sample_is_subtitle_end = 0;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts   = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (trk->start_cts == AV_NOPTS_VALUE)\n        trk->start_cts = pkt->pts - pkt->dts;\n    if (trk->end_pts == AV_NOPTS_VALUE)\n        trk->end_pts = trk->cluster[trk->entry].dts +\n                       trk->cluster[trk->entry].cts + pkt->duration;\n    else\n        trk->end_pts = FFMAX(trk->end_pts, trk->cluster[trk->entry].dts +\n                                           trk->cluster[trk->entry].cts +\n                                           pkt->duration);\n\n    if (par->codec_id == AV_CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && par->codec_id == AV_CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size    += size;\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n\nend:\nerr:\n\n    av_free(reformatted_data);\n    return ret;\n}\n\nstatic int mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)\n{\n        MOVMuxContext *mov = s->priv_data;\n        MOVTrack *trk = &mov->tracks[pkt->stream_index];\n        AVCodecParameters *par = trk->par;\n        int64_t frag_duration = 0;\n        int size = pkt->size;\n\n        int ret = check_pkt(s, pkt);\n        if (ret < 0)\n            return ret;\n\n        if (mov->flags & FF_MOV_FLAG_FRAG_DISCONT) {\n            int i;\n            for (i = 0; i < s->nb_streams; i++)\n                mov->tracks[i].frag_discont = 1;\n            mov->flags &= ~FF_MOV_FLAG_FRAG_DISCONT;\n        }\n\n        if (!pkt->size) {\n            if (trk->start_dts == AV_NOPTS_VALUE && trk->frag_discont) {\n                trk->start_dts = pkt->dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->start_cts = pkt->pts - pkt->dts;\n                else\n                    trk->start_cts = 0;\n            }\n\n            if (trk->par->codec_id == AV_CODEC_ID_MP4ALS) {\n                int side_size = 0;\n                uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n                if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n                    void *newextra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n                    if (!newextra)\n                        return AVERROR(ENOMEM);\n                    av_free(par->extradata);\n                    par->extradata = newextra;\n                    memcpy(par->extradata, side, side_size);\n                    par->extradata_size = side_size;\n                    mov->need_rewrite_extradata = 1;\n                }\n            }\n\n            return 0;             /* Discard 0 sized packets */\n        }\n\n        if (trk->entry && pkt->stream_index < s->nb_streams)\n            frag_duration = av_rescale_q(pkt->dts - trk->cluster[0].dts,\n                                         s->streams[pkt->stream_index]->time_base,\n                                         AV_TIME_BASE_Q);\n        if ((mov->max_fragment_duration &&\n             frag_duration >= mov->max_fragment_duration) ||\n             (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) ||\n             (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME &&\n              par->codec_type == AVMEDIA_TYPE_VIDEO &&\n              trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) {\n            if (frag_duration >= mov->min_fragment_duration) {\n                // Set the duration of this track to line up with the next\n                // sample in this track. This avoids relying on AVPacket\n                // duration, but only helps for this particular track, not\n                // for the other ones that are flushed at the same time.\n                trk->track_duration = pkt->dts - trk->start_dts;\n                if (pkt->pts != AV_NOPTS_VALUE)\n                    trk->end_pts = pkt->pts;\n                else\n                    trk->end_pts = pkt->dts;\n                trk->end_reliable = 1;\n                mov_auto_flush_fragment(s, 0);\n            }\n        }\n\n        return ff_mov_write_packet(s, pkt);\n}\n\nstatic int mov_write_subtitle_end_packet(AVFormatContext *s,\n                                         int stream_index,\n                                         int64_t dts) {\n    AVPacket end;\n    uint8_t data[2] = {0};\n    int ret;\n\n    av_init_packet(&end);\n    end.size = sizeof(data);\n    end.data = data;\n    end.pts = dts;\n    end.dts = dts;\n    end.duration = 0;\n    end.stream_index = stream_index;\n\n    ret = mov_write_single_packet(s, &end);\n    av_packet_unref(&end);\n\n    return ret;\n}\n\nstatic int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    if (!pkt) {\n        mov_flush_fragment(s, 1);\n        return 1;\n    } else {\n        int i;\n        MOVMuxContext *mov = s->priv_data;\n        MOVTrack *trk = &mov->tracks[pkt->stream_index];\n\n        if (!pkt->size)\n            return mov_write_single_packet(s, pkt); /* Passthrough. */\n\n        /*\n         * Subtitles require special handling.\n         *\n         * 1) For full complaince, every track must have a sample at\n         * dts == 0, which is rarely true for subtitles. So, as soon\n         * as we see any packet with dts > 0, write an empty subtitle\n         * at dts == 0 for any subtitle track with no samples in it.\n         *\n         * 2) For each subtitle track, check if the current packet's\n         * dts is past the duration of the last subtitle sample. If\n         * so, we now need to write an end sample for that subtitle.\n         *\n         * This must be done conditionally to allow for subtitles that\n         * immediately replace each other, in which case an end sample\n         * is not needed, and is, in fact, actively harmful.\n         *\n         * 3) See mov_write_trailer for how the final end sample is\n         * handled.\n         */\n        for (i = 0; i < mov->nb_streams; i++) {\n            MOVTrack *trk = &mov->tracks[i];\n            int ret;\n\n            if (trk->par->codec_id == AV_CODEC_ID_MOV_TEXT &&\n                trk->track_duration < pkt->dts &&\n                (trk->entry == 0 || !trk->last_sample_is_subtitle_end)) {\n                ret = mov_write_subtitle_end_packet(s, i, trk->track_duration);\n                if (ret < 0) return ret;\n                trk->last_sample_is_subtitle_end = 1;\n            }\n        }\n\n        if (trk->mode == MODE_MOV && trk->par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            AVPacket *opkt = pkt;\n            int reshuffle_ret, ret;\n            if (trk->is_unaligned_qt_rgb) {\n                int64_t bpc = trk->par->bits_per_coded_sample != 15 ? trk->par->bits_per_coded_sample : 16;\n                int expected_stride = ((trk->par->width * bpc + 15) >> 4)*2;\n                reshuffle_ret = ff_reshuffle_raw_rgb(s, &pkt, trk->par, expected_stride);\n                if (reshuffle_ret < 0)\n                    return reshuffle_ret;\n            } else\n                reshuffle_ret = 0;\n            if (trk->par->format == AV_PIX_FMT_PAL8 && !trk->pal_done) {\n                ret = ff_get_packet_palette(s, opkt, reshuffle_ret, trk->palette);\n                if (ret < 0)\n                    goto fail;\n                if (ret)\n                    trk->pal_done++;\n            } else if (trk->par->codec_id == AV_CODEC_ID_RAWVIDEO &&\n                       (trk->par->format == AV_PIX_FMT_GRAY8 ||\n                       trk->par->format == AV_PIX_FMT_MONOBLACK)) {\n                for (i = 0; i < pkt->size; i++)\n                    pkt->data[i] = ~pkt->data[i];\n            }\n            if (reshuffle_ret) {\n                ret = mov_write_single_packet(s, pkt);\nfail:\n                if (reshuffle_ret)\n                    av_packet_free(&pkt);\n                return ret;\n            }\n        }\n\n        return mov_write_single_packet(s, pkt);\n    }\n}\n\n// QuickTime chapters involve an additional text track with the chapter names\n// as samples, and a tref pointing from the other tracks to the chapter one.\nstatic int mov_create_chapter_track(AVFormatContext *s, int tracknum)\n{\n    AVIOContext *pb;\n\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *track = &mov->tracks[tracknum];\n    AVPacket pkt = { .stream_index = tracknum, .flags = AV_PKT_FLAG_KEY };\n    int i, len;\n\n    track->mode = mov->mode;\n    track->tag = MKTAG('t','e','x','t');\n    track->timescale = MOV_TIMESCALE;\n    track->par = avcodec_parameters_alloc();\n    if (!track->par)\n        return AVERROR(ENOMEM);\n    track->par->codec_type = AVMEDIA_TYPE_SUBTITLE;\n#if 0\n    // These properties are required to make QT recognize the chapter track\n    uint8_t chapter_properties[43] = { 0, 0, 0, 0, 0, 0, 0, 1, };\n    if (ff_alloc_extradata(track->par, sizeof(chapter_properties)))\n        return AVERROR(ENOMEM);\n    memcpy(track->par->extradata, chapter_properties, sizeof(chapter_properties));\n#else\n    if (avio_open_dyn_buf(&pb) >= 0) {\n        int size;\n        uint8_t *buf;\n\n        /* Stub header (usually for Quicktime chapter track) */\n        // TextSampleEntry\n        avio_wb32(pb, 0x01); // displayFlags\n        avio_w8(pb, 0x00);   // horizontal justification\n        avio_w8(pb, 0x00);   // vertical justification\n        avio_w8(pb, 0x00);   // bgColourRed\n        avio_w8(pb, 0x00);   // bgColourGreen\n        avio_w8(pb, 0x00);   // bgColourBlue\n        avio_w8(pb, 0x00);   // bgColourAlpha\n        // BoxRecord\n        avio_wb16(pb, 0x00); // defTextBoxTop\n        avio_wb16(pb, 0x00); // defTextBoxLeft\n        avio_wb16(pb, 0x00); // defTextBoxBottom\n        avio_wb16(pb, 0x00); // defTextBoxRight\n        // StyleRecord\n        avio_wb16(pb, 0x00); // startChar\n        avio_wb16(pb, 0x00); // endChar\n        avio_wb16(pb, 0x01); // fontID\n        avio_w8(pb, 0x00);   // fontStyleFlags\n        avio_w8(pb, 0x00);   // fontSize\n        avio_w8(pb, 0x00);   // fgColourRed\n        avio_w8(pb, 0x00);   // fgColourGreen\n        avio_w8(pb, 0x00);   // fgColourBlue\n        avio_w8(pb, 0x00);   // fgColourAlpha\n        // FontTableBox\n        avio_wb32(pb, 0x0D); // box size\n        ffio_wfourcc(pb, \"ftab\"); // box atom name\n        avio_wb16(pb, 0x01); // entry count\n        // FontRecord\n        avio_wb16(pb, 0x01); // font ID\n        avio_w8(pb, 0x00);   // font name length\n\n        if ((size = avio_close_dyn_buf(pb, &buf)) > 0) {\n            track->par->extradata = buf;\n            track->par->extradata_size = size;\n        } else {\n            av_freep(&buf);\n        }\n    }\n#endif\n\n    for (i = 0; i < s->nb_chapters; i++) {\n        AVChapter *c = s->chapters[i];\n        AVDictionaryEntry *t;\n\n        int64_t end = av_rescale_q(c->end, c->time_base, (AVRational){1,MOV_TIMESCALE});\n        pkt.pts = pkt.dts = av_rescale_q(c->start, c->time_base, (AVRational){1,MOV_TIMESCALE});\n        pkt.duration = end - pkt.dts;\n\n        if ((t = av_dict_get(c->metadata, \"title\", NULL, 0))) {\n            static const char encd[12] = {\n                0x00, 0x00, 0x00, 0x0C,\n                'e',  'n',  'c',  'd',\n                0x00, 0x00, 0x01, 0x00 };\n            len      = strlen(t->value);\n            pkt.size = len + 2 + 12;\n            pkt.data = av_malloc(pkt.size);\n            if (!pkt.data)\n                return AVERROR(ENOMEM);\n            AV_WB16(pkt.data, len);\n            memcpy(pkt.data + 2, t->value, len);\n            memcpy(pkt.data + len + 2, encd, sizeof(encd));\n            ff_mov_write_packet(s, &pkt);\n            av_freep(&pkt.data);\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int mov_check_timecode_track(AVFormatContext *s, AVTimecode *tc, int src_index, const char *tcstr)\n{\n    int ret;\n\n    /* compute the frame number */\n    ret = av_timecode_init_from_string(tc, find_fps(s,  s->streams[src_index]), tcstr, s);\n    return ret;\n}\n\nstatic int mov_create_timecode_track(AVFormatContext *s, int index, int src_index, AVTimecode tc)\n{\n    int ret;\n    MOVMuxContext *mov  = s->priv_data;\n    MOVTrack *track     = &mov->tracks[index];\n    AVStream *src_st    = s->streams[src_index];\n    AVPacket pkt    = {.stream_index = index, .flags = AV_PKT_FLAG_KEY, .size = 4};\n    AVRational rate = find_fps(s, src_st);\n\n    /* tmcd track based on video stream */\n    track->mode      = mov->mode;\n    track->tag       = MKTAG('t','m','c','d');\n    track->src_track = src_index;\n    track->timescale = mov->tracks[src_index].timescale;\n    if (tc.flags & AV_TIMECODE_FLAG_DROPFRAME)\n        track->timecode_flags |= MOV_TIMECODE_FLAG_DROPFRAME;\n\n    /* set st to src_st for metadata access*/\n    track->st = src_st;\n\n    /* encode context: tmcd data stream */\n    track->par = avcodec_parameters_alloc();\n    if (!track->par)\n        return AVERROR(ENOMEM);\n    track->par->codec_type = AVMEDIA_TYPE_DATA;\n    track->par->codec_tag  = track->tag;\n    track->st->avg_frame_rate = av_inv_q(rate);\n\n    /* the tmcd track just contains one packet with the frame number */\n    pkt.data = av_malloc(pkt.size);\n    if (!pkt.data)\n        return AVERROR(ENOMEM);\n    AV_WB32(pkt.data, tc.start);\n    ret = ff_mov_write_packet(s, &pkt);\n    av_free(pkt.data);\n    return ret;\n}\n\n/*\n * st->disposition controls the \"enabled\" flag in the tkhd tag.\n * QuickTime will not play a track if it is not enabled.  So make sure\n * that one track of each type (audio, video, subtitle) is enabled.\n *\n * Subtitles are special.  For audio and video, setting \"enabled\" also\n * makes the track \"default\" (i.e. it is rendered when played). For\n * subtitles, an \"enabled\" subtitle is not rendered by default, but\n * if no subtitle is enabled, the subtitle menu in QuickTime will be\n * empty!\n */\nstatic void enable_tracks(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i;\n    int enabled[AVMEDIA_TYPE_NB];\n    int first[AVMEDIA_TYPE_NB];\n\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        enabled[i] = 0;\n        first[i] = -1;\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n\n        if (st->codecpar->codec_type <= AVMEDIA_TYPE_UNKNOWN ||\n            st->codecpar->codec_type >= AVMEDIA_TYPE_NB)\n            continue;\n\n        if (first[st->codecpar->codec_type] < 0)\n            first[st->codecpar->codec_type] = i;\n        if (st->disposition & AV_DISPOSITION_DEFAULT) {\n            mov->tracks[i].flags |= MOV_TRACK_ENABLED;\n            enabled[st->codecpar->codec_type]++;\n        }\n    }\n\n    for (i = 0; i < AVMEDIA_TYPE_NB; i++) {\n        switch (i) {\n        case AVMEDIA_TYPE_VIDEO:\n        case AVMEDIA_TYPE_AUDIO:\n        case AVMEDIA_TYPE_SUBTITLE:\n            if (enabled[i] > 1)\n                mov->per_stream_grouping = 1;\n            if (!enabled[i] && first[i] >= 0)\n                mov->tracks[first[i]].flags |= MOV_TRACK_ENABLED;\n            break;\n        }\n    }\n}\n\nstatic void mov_free(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int i;\n\n    if (mov->chapter_track) {\n        if (mov->tracks[mov->chapter_track].par)\n            av_freep(&mov->tracks[mov->chapter_track].par->extradata);\n        av_freep(&mov->tracks[mov->chapter_track].par);\n    }\n\n    for (i = 0; i < mov->nb_streams; i++) {\n        if (mov->tracks[i].tag == MKTAG('r','t','p',' '))\n            ff_mov_close_hinting(&mov->tracks[i]);\n        else if (mov->tracks[i].tag == MKTAG('t','m','c','d') && mov->nb_meta_tmcd)\n            av_freep(&mov->tracks[i].par);\n        av_freep(&mov->tracks[i].cluster);\n        av_freep(&mov->tracks[i].frag_info);\n\n        if (mov->tracks[i].vos_len)\n            av_freep(&mov->tracks[i].vos_data);\n\n        ff_mov_cenc_free(&mov->tracks[i].cenc);\n    }\n\n    av_freep(&mov->tracks);\n}\n\nstatic uint32_t rgb_to_yuv(uint32_t rgb)\n{\n    uint8_t r, g, b;\n    int y, cb, cr;\n\n    r = (rgb >> 16) & 0xFF;\n    g = (rgb >>  8) & 0xFF;\n    b = (rgb      ) & 0xFF;\n\n    y  = av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000);\n    cb = av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000);\n    cr = av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000);\n\n    return (y << 16) | (cr << 8) | cb;\n}\n\nstatic int mov_create_dvd_sub_decoder_specific_info(MOVTrack *track,\n                                                    AVStream *st)\n{\n    int i, width = 720, height = 480;\n    int have_palette = 0, have_size = 0;\n    uint32_t palette[16];\n    char *cur = st->codecpar->extradata;\n\n    while (cur && *cur) {\n        if (strncmp(\"palette:\", cur, 8) == 0) {\n            int i, count;\n            count = sscanf(cur + 8,\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", \"\n                \"%06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\", %06\"PRIx32\"\",\n                &palette[ 0], &palette[ 1], &palette[ 2], &palette[ 3],\n                &palette[ 4], &palette[ 5], &palette[ 6], &palette[ 7],\n                &palette[ 8], &palette[ 9], &palette[10], &palette[11],\n                &palette[12], &palette[13], &palette[14], &palette[15]);\n\n            for (i = 0; i < count; i++) {\n                palette[i] = rgb_to_yuv(palette[i]);\n            }\n            have_palette = 1;\n        } else if (!strncmp(\"size:\", cur, 5)) {\n            sscanf(cur + 5, \"%dx%d\", &width, &height);\n            have_size = 1;\n        }\n        if (have_palette && have_size)\n            break;\n        cur += strcspn(cur, \"\\n\\r\");\n        cur += strspn(cur, \"\\n\\r\");\n    }\n    if (have_palette) {\n        track->vos_data = av_malloc(16*4);\n        if (!track->vos_data)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < 16; i++) {\n            AV_WB32(track->vos_data + i * 4, palette[i]);\n        }\n        track->vos_len = 16 * 4;\n    }\n    st->codecpar->width = width;\n    st->codecpar->height = track->height = height;\n\n    return 0;\n}\n\nstatic int mov_init(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVDictionaryEntry *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);\n    int i, ret, hint_track = 0, tmcd_track = 0;\n\n    mov->fc = s;\n\n    /* Default mode == MP4 */\n    mov->mode = MODE_MP4;\n\n    if (s->oformat) {\n        if (!strcmp(\"3gp\", s->oformat->name)) mov->mode = MODE_3GP;\n        else if (!strcmp(\"3g2\", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;\n        else if (!strcmp(\"mov\", s->oformat->name)) mov->mode = MODE_MOV;\n        else if (!strcmp(\"psp\", s->oformat->name)) mov->mode = MODE_PSP;\n        else if (!strcmp(\"ipod\",s->oformat->name)) mov->mode = MODE_IPOD;\n        else if (!strcmp(\"ismv\",s->oformat->name)) mov->mode = MODE_ISM;\n        else if (!strcmp(\"f4v\", s->oformat->name)) mov->mode = MODE_F4V;\n    }\n\n    if (mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV;\n\n    /* Set the FRAGMENT flag if any of the fragmentation methods are\n     * enabled. */\n    if (mov->max_fragment_duration || mov->max_fragment_size ||\n        mov->flags & (FF_MOV_FLAG_EMPTY_MOOV |\n                      FF_MOV_FLAG_FRAG_KEYFRAME |\n                      FF_MOV_FLAG_FRAG_CUSTOM))\n        mov->flags |= FF_MOV_FLAG_FRAGMENT;\n\n    /* Set other implicit flags immediately */\n    if (mov->mode == MODE_ISM)\n        mov->flags |= FF_MOV_FLAG_EMPTY_MOOV | FF_MOV_FLAG_SEPARATE_MOOF |\n                      FF_MOV_FLAG_FRAGMENT;\n    if (mov->flags & FF_MOV_FLAG_DASH)\n        mov->flags |= FF_MOV_FLAG_FRAGMENT | FF_MOV_FLAG_EMPTY_MOOV |\n                      FF_MOV_FLAG_DEFAULT_BASE_MOOF;\n\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV && s->flags & AVFMT_FLAG_AUTO_BSF) {\n        av_log(s, AV_LOG_VERBOSE, \"Empty MOOV enabled; disabling automatic bitstream filtering\\n\");\n        s->flags &= ~AVFMT_FLAG_AUTO_BSF;\n    }\n\n    if (mov->flags & FF_MOV_FLAG_FASTSTART) {\n        mov->reserved_moov_size = -1;\n    }\n\n    if (mov->use_editlist < 0) {\n        mov->use_editlist = 1;\n        if (mov->flags & FF_MOV_FLAG_FRAGMENT &&\n            !(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) {\n            // If we can avoid needing an edit list by shifting the\n            // tracks, prefer that over (trying to) write edit lists\n            // in fragmented output.\n            if (s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO ||\n                s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)\n                mov->use_editlist = 0;\n        }\n    }\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV &&\n        !(mov->flags & FF_MOV_FLAG_DELAY_MOOV) && mov->use_editlist)\n        av_log(s, AV_LOG_WARNING, \"No meaningful edit list will be written when using empty_moov without delay_moov\\n\");\n\n    if (!mov->use_editlist && s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_AUTO)\n        s->avoid_negative_ts = AVFMT_AVOID_NEG_TS_MAKE_ZERO;\n\n    /* Clear the omit_tfhd_offset flag if default_base_moof is set;\n     * if the latter is set that's enough and omit_tfhd_offset doesn't\n     * add anything extra on top of that. */\n    if (mov->flags & FF_MOV_FLAG_OMIT_TFHD_OFFSET &&\n        mov->flags & FF_MOV_FLAG_DEFAULT_BASE_MOOF)\n        mov->flags &= ~FF_MOV_FLAG_OMIT_TFHD_OFFSET;\n\n    if (mov->frag_interleave &&\n        mov->flags & (FF_MOV_FLAG_OMIT_TFHD_OFFSET | FF_MOV_FLAG_SEPARATE_MOOF)) {\n        av_log(s, AV_LOG_ERROR,\n               \"Sample interleaving in fragments is mutually exclusive with \"\n               \"omit_tfhd_offset and separate_moof\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* Non-seekable output is ok if using fragmentation. If ism_lookahead\n     * is enabled, we don't support non-seekable output at all. */\n    if (!s->pb->seekable &&\n        (!(mov->flags & FF_MOV_FLAG_FRAGMENT) || mov->ism_lookahead)) {\n        av_log(s, AV_LOG_ERROR, \"muxer does not support non seekable output\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    mov->nb_streams = s->nb_streams;\n    if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters)\n        mov->chapter_track = mov->nb_streams++;\n\n    if (mov->flags & FF_MOV_FLAG_RTP_HINT) {\n        /* Add hint tracks for each audio and video stream */\n        hint_track = mov->nb_streams;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n                mov->nb_streams++;\n            }\n        }\n    }\n\n    if (   mov->write_tmcd == -1 && (mov->mode == MODE_MOV || mov->mode == MODE_MP4)\n        || mov->write_tmcd == 1) {\n        tmcd_track = mov->nb_streams;\n\n        /* +1 tmcd track for each video stream with a timecode */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            AVDictionaryEntry *t = global_tcr;\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n                (t || (t=av_dict_get(st->metadata, \"timecode\", NULL, 0)))) {\n                AVTimecode tc;\n                ret = mov_check_timecode_track(s, &tc, i, t->value);\n                if (ret >= 0)\n                    mov->nb_meta_tmcd++;\n            }\n        }\n\n        /* check if there is already a tmcd track to remux */\n        if (mov->nb_meta_tmcd) {\n            for (i = 0; i < s->nb_streams; i++) {\n                AVStream *st = s->streams[i];\n                if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {\n                    av_log(s, AV_LOG_WARNING, \"You requested a copy of the original timecode track \"\n                           \"so timecode metadata are now ignored\\n\");\n                    mov->nb_meta_tmcd = 0;\n                }\n            }\n        }\n\n        mov->nb_streams += mov->nb_meta_tmcd;\n    }\n\n    // Reserve an extra stream for chapters for the case where chapters\n    // are written in the trailer\n    mov->tracks = av_mallocz_array((mov->nb_streams + 1), sizeof(*mov->tracks));\n    if (!mov->tracks)\n        return AVERROR(ENOMEM);\n\n    if (mov->encryption_scheme_str != NULL && strcmp(mov->encryption_scheme_str, \"none\") != 0) {\n        if (strcmp(mov->encryption_scheme_str, \"cenc-aes-ctr\") == 0) {\n            mov->encryption_scheme = MOV_ENC_CENC_AES_CTR;\n\n            if (mov->encryption_key_len != AES_CTR_KEY_SIZE) {\n                av_log(s, AV_LOG_ERROR, \"Invalid encryption key len %d expected %d\\n\",\n                    mov->encryption_key_len, AES_CTR_KEY_SIZE);\n                return AVERROR(EINVAL);\n            }\n\n            if (mov->encryption_kid_len != CENC_KID_SIZE) {\n                av_log(s, AV_LOG_ERROR, \"Invalid encryption kid len %d expected %d\\n\",\n                    mov->encryption_kid_len, CENC_KID_SIZE);\n                return AVERROR(EINVAL);\n            }\n        } else {\n            av_log(s, AV_LOG_ERROR, \"unsupported encryption scheme %s\\n\",\n                mov->encryption_scheme_str);\n            return AVERROR(EINVAL);\n        }\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st= s->streams[i];\n        MOVTrack *track= &mov->tracks[i];\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        track->st  = st;\n        track->par = st->codecpar;\n        track->language = ff_mov_iso639_to_lang(lang?lang->value:\"und\", mov->mode!=MODE_MOV);\n        if (track->language < 0)\n            track->language = 0;\n        track->mode = mov->mode;\n        track->tag  = mov_find_codec_tag(s, track);\n        if (!track->tag) {\n            av_log(s, AV_LOG_ERROR, \"Could not find tag for codec %s in stream #%d, \"\n                   \"codec not currently supported in container\\n\",\n                   avcodec_get_name(st->codecpar->codec_id), i);\n            return AVERROR(EINVAL);\n        }\n        /* If hinting of this track is enabled by a later hint track,\n         * this is updated. */\n        track->hint_track = -1;\n        track->start_dts  = AV_NOPTS_VALUE;\n        track->start_cts  = AV_NOPTS_VALUE;\n        track->end_pts    = AV_NOPTS_VALUE;\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            if (track->tag == MKTAG('m','x','3','p') || track->tag == MKTAG('m','x','3','n') ||\n                track->tag == MKTAG('m','x','4','p') || track->tag == MKTAG('m','x','4','n') ||\n                track->tag == MKTAG('m','x','5','p') || track->tag == MKTAG('m','x','5','n')) {\n                if (st->codecpar->width != 720 || (st->codecpar->height != 608 && st->codecpar->height != 512)) {\n                    av_log(s, AV_LOG_ERROR, \"D-10/IMX must use 720x608 or 720x512 video resolution\\n\");\n                    return AVERROR(EINVAL);\n                }\n                track->height = track->tag >> 24 == 'n' ? 486 : 576;\n            }\n            if (mov->video_track_timescale) {\n                track->timescale = mov->video_track_timescale;\n            } else {\n                track->timescale = st->time_base.den;\n                while(track->timescale < 10000)\n                    track->timescale *= 2;\n            }\n            if (st->codecpar->width > 65535 || st->codecpar->height > 65535) {\n                av_log(s, AV_LOG_ERROR, \"Resolution %dx%d too large for mov/mp4\\n\", st->codecpar->width, st->codecpar->height);\n                return AVERROR(EINVAL);\n            }\n            if (track->mode == MODE_MOV && track->timescale > 100000)\n                av_log(s, AV_LOG_WARNING,\n                       \"WARNING codec timebase is very high. If duration is too long,\\n\"\n                       \"file may not be playable by quicktime. Specify a shorter timebase\\n\"\n                       \"or choose different container.\\n\");\n            if (track->mode == MODE_MOV &&\n                track->par->codec_id == AV_CODEC_ID_RAWVIDEO &&\n                track->tag == MKTAG('r','a','w',' ')) {\n                enum AVPixelFormat pix_fmt = track->par->format;\n                if (pix_fmt == AV_PIX_FMT_NONE && track->par->bits_per_coded_sample == 1)\n                    pix_fmt = AV_PIX_FMT_MONOWHITE;\n                track->is_unaligned_qt_rgb =\n                        pix_fmt == AV_PIX_FMT_RGB24 ||\n                        pix_fmt == AV_PIX_FMT_BGR24 ||\n                        pix_fmt == AV_PIX_FMT_PAL8 ||\n                        pix_fmt == AV_PIX_FMT_GRAY8 ||\n                        pix_fmt == AV_PIX_FMT_MONOWHITE ||\n                        pix_fmt == AV_PIX_FMT_MONOBLACK;\n            }\n            if (track->mode == MODE_MP4 &&\n                track->par->codec_id == AV_CODEC_ID_VP9) {\n                if (s->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n                    av_log(s, AV_LOG_ERROR,\n                           \"VP9 in MP4 support is experimental, add \"\n                           \"'-strict %d' if you want to use it.\\n\",\n                           FF_COMPLIANCE_EXPERIMENTAL);\n                    return AVERROR_EXPERIMENTAL;\n                }\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            track->timescale = st->codecpar->sample_rate;\n            if (!st->codecpar->frame_size && !av_get_bits_per_sample(st->codecpar->codec_id)) {\n                av_log(s, AV_LOG_WARNING, \"track %d: codec frame size is not set\\n\", i);\n                track->audio_vbr = 1;\n            }else if (st->codecpar->codec_id == AV_CODEC_ID_ADPCM_MS ||\n                     st->codecpar->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||\n                     st->codecpar->codec_id == AV_CODEC_ID_ILBC){\n                if (!st->codecpar->block_align) {\n                    av_log(s, AV_LOG_ERROR, \"track %d: codec block align is not set for adpcm\\n\", i);\n                    return AVERROR(EINVAL);\n                }\n                track->sample_size = st->codecpar->block_align;\n            }else if (st->codecpar->frame_size > 1){ /* assume compressed audio */\n                track->audio_vbr = 1;\n            }else{\n                track->sample_size = (av_get_bits_per_sample(st->codecpar->codec_id) >> 3) * st->codecpar->channels;\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_ILBC ||\n                st->codecpar->codec_id == AV_CODEC_ID_ADPCM_IMA_QT) {\n                track->audio_vbr = 1;\n            }\n            if (track->mode != MODE_MOV &&\n                track->par->codec_id == AV_CODEC_ID_MP3 && track->timescale < 16000) {\n                if (s->strict_std_compliance >= FF_COMPLIANCE_NORMAL) {\n                    av_log(s, AV_LOG_ERROR, \"track %d: muxing mp3 at %dhz is not standard, to mux anyway set strict to -1\\n\",\n                        i, track->par->sample_rate);\n                    return AVERROR(EINVAL);\n                } else {\n                    av_log(s, AV_LOG_WARNING, \"track %d: muxing mp3 at %dhz is not standard in MP4\\n\",\n                           i, track->par->sample_rate);\n                }\n            }\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            track->timescale = st->time_base.den;\n        } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {\n            track->timescale = st->time_base.den;\n        } else {\n            track->timescale = MOV_TIMESCALE;\n        }\n        if (!track->height)\n            track->height = st->codecpar->height;\n        /* The ism specific timescale isn't mandatory, but is assumed by\n         * some tools, such as mp4split. */\n        if (mov->mode == MODE_ISM)\n            track->timescale = 10000000;\n\n        avpriv_set_pts_info(st, 64, 1, track->timescale);\n\n        if (mov->encryption_scheme == MOV_ENC_CENC_AES_CTR) {\n            ret = ff_mov_cenc_init(&track->cenc, mov->encryption_key,\n                track->par->codec_id == AV_CODEC_ID_H264, s->flags & AVFMT_FLAG_BITEXACT);\n            if (ret)\n                return ret;\n        }\n    }\n\n    enable_tracks(s);\n    return 0;\n}\n\nstatic int mov_write_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    MOVMuxContext *mov = s->priv_data;\n    AVDictionaryEntry *t, *global_tcr = av_dict_get(s->metadata, \"timecode\", NULL, 0);\n    int i, ret, hint_track = 0, tmcd_track = 0, nb_tracks = s->nb_streams;\n\n    if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters)\n        nb_tracks++;\n\n    if (mov->flags & FF_MOV_FLAG_RTP_HINT) {\n        /* Add hint tracks for each audio and video stream */\n        hint_track = nb_tracks;\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n                nb_tracks++;\n            }\n        }\n    }\n\n    if (mov->mode == MODE_MOV || mov->mode == MODE_MP4)\n        tmcd_track = nb_tracks;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        int j;\n        AVStream *st= s->streams[i];\n        MOVTrack *track= &mov->tracks[i];\n\n        /* copy extradata if it exists */\n        if (st->codecpar->extradata_size) {\n            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE)\n                mov_create_dvd_sub_decoder_specific_info(track, st);\n            else if (!TAG_IS_AVCI(track->tag) && st->codecpar->codec_id != AV_CODEC_ID_DNXHD) {\n                track->vos_len  = st->codecpar->extradata_size;\n                track->vos_data = av_malloc(track->vos_len);\n                if (!track->vos_data) {\n                    return AVERROR(ENOMEM);\n                }\n                memcpy(track->vos_data, st->codecpar->extradata, track->vos_len);\n            }\n        }\n\n        if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO ||\n            track->par->channel_layout != AV_CH_LAYOUT_MONO)\n            continue;\n\n        for (j = 0; j < s->nb_streams; j++) {\n            AVStream *stj= s->streams[j];\n            MOVTrack *trackj= &mov->tracks[j];\n            if (j == i)\n                continue;\n\n            if (stj->codecpar->codec_type != AVMEDIA_TYPE_AUDIO ||\n                trackj->par->channel_layout != AV_CH_LAYOUT_MONO ||\n                trackj->language != track->language ||\n                trackj->tag != track->tag\n            )\n                continue;\n            track->multichannel_as_mono++;\n        }\n    }\n\n    if (!(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) {\n        if ((ret = mov_write_identification(pb, s)) < 0)\n            return ret;\n    }\n\n    if (mov->reserved_moov_size){\n        mov->reserved_header_pos = avio_tell(pb);\n        if (mov->reserved_moov_size > 0)\n            avio_skip(pb, mov->reserved_moov_size);\n    }\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        /* If no fragmentation options have been set, set a default. */\n        if (!(mov->flags & (FF_MOV_FLAG_FRAG_KEYFRAME |\n                            FF_MOV_FLAG_FRAG_CUSTOM)) &&\n            !mov->max_fragment_duration && !mov->max_fragment_size)\n            mov->flags |= FF_MOV_FLAG_FRAG_KEYFRAME;\n    } else {\n        if (mov->flags & FF_MOV_FLAG_FASTSTART)\n            mov->reserved_header_pos = avio_tell(pb);\n        mov_write_mdat_tag(pb, mov);\n    }\n\n    ff_parse_creation_time_metadata(s, &mov->time, 1);\n    if (mov->time)\n        mov->time += 0x7C25B080; // 1970 based -> 1904 based\n\n    if (mov->chapter_track)\n        if ((ret = mov_create_chapter_track(s, mov->chapter_track)) < 0)\n            return ret;\n\n    if (mov->flags & FF_MOV_FLAG_RTP_HINT) {\n        /* Initialize the hint tracks for each audio and video stream */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||\n                st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n                if ((ret = ff_mov_init_hinting(s, hint_track, i)) < 0)\n                    return ret;\n                hint_track++;\n            }\n        }\n    }\n\n    if (mov->nb_meta_tmcd) {\n        /* Initialize the tmcd tracks */\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            t = global_tcr;\n\n            if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n                AVTimecode tc;\n                if (!t)\n                    t = av_dict_get(st->metadata, \"timecode\", NULL, 0);\n                if (!t)\n                    continue;\n                if (mov_check_timecode_track(s, &tc, i, t->value) < 0)\n                    continue;\n                if ((ret = mov_create_timecode_track(s, tmcd_track, i, tc)) < 0)\n                    return ret;\n                tmcd_track++;\n            }\n        }\n    }\n\n    avio_flush(pb);\n\n    if (mov->flags & FF_MOV_FLAG_ISML)\n        mov_write_isml_manifest(pb, mov, s);\n\n    if (mov->flags & FF_MOV_FLAG_EMPTY_MOOV &&\n        !(mov->flags & FF_MOV_FLAG_DELAY_MOOV)) {\n        if ((ret = mov_write_moov_tag(pb, mov, s)) < 0)\n            return ret;\n        avio_flush(pb);\n        mov->moov_written = 1;\n        if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX)\n            mov->reserved_header_pos = avio_tell(pb);\n    }\n\n    return 0;\n}\n\nstatic int get_moov_size(AVFormatContext *s)\n{\n    int ret;\n    AVIOContext *moov_buf;\n    MOVMuxContext *mov = s->priv_data;\n\n    if ((ret = ffio_open_null_buf(&moov_buf)) < 0)\n        return ret;\n    if ((ret = mov_write_moov_tag(moov_buf, mov, s)) < 0)\n        return ret;\n    return ffio_close_null_buf(moov_buf);\n}\n\nstatic int get_sidx_size(AVFormatContext *s)\n{\n    int ret;\n    AVIOContext *buf;\n    MOVMuxContext *mov = s->priv_data;\n\n    if ((ret = ffio_open_null_buf(&buf)) < 0)\n        return ret;\n    mov_write_sidx_tags(buf, mov, -1, 0);\n    return ffio_close_null_buf(buf);\n}\n\n/*\n * This function gets the moov size if moved to the top of the file: the chunk\n * offset table can switch between stco (32-bit entries) to co64 (64-bit\n * entries) when the moov is moved to the beginning, so the size of the moov\n * would change. It also updates the chunk offset tables.\n */\nstatic int compute_moov_size(AVFormatContext *s)\n{\n    int i, moov_size, moov_size2;\n    MOVMuxContext *mov = s->priv_data;\n\n    moov_size = get_moov_size(s);\n    if (moov_size < 0)\n        return moov_size;\n\n    for (i = 0; i < mov->nb_streams; i++)\n        mov->tracks[i].data_offset += moov_size;\n\n    moov_size2 = get_moov_size(s);\n    if (moov_size2 < 0)\n        return moov_size2;\n\n    /* if the size changed, we just switched from stco to co64 and need to\n     * update the offsets */\n    if (moov_size2 != moov_size)\n        for (i = 0; i < mov->nb_streams; i++)\n            mov->tracks[i].data_offset += moov_size2 - moov_size;\n\n    return moov_size2;\n}\n\nstatic int compute_sidx_size(AVFormatContext *s)\n{\n    int i, sidx_size;\n    MOVMuxContext *mov = s->priv_data;\n\n    sidx_size = get_sidx_size(s);\n    if (sidx_size < 0)\n        return sidx_size;\n\n    for (i = 0; i < mov->nb_streams; i++)\n        mov->tracks[i].data_offset += sidx_size;\n\n    return sidx_size;\n}\n\nstatic int shift_data(AVFormatContext *s)\n{\n    int ret = 0, moov_size;\n    MOVMuxContext *mov = s->priv_data;\n    int64_t pos, pos_end = avio_tell(s->pb);\n    uint8_t *buf, *read_buf[2];\n    int read_buf_id = 0;\n    int read_size[2];\n    AVIOContext *read_pb;\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT)\n        moov_size = compute_sidx_size(s);\n    else\n        moov_size = compute_moov_size(s);\n    if (moov_size < 0)\n        return moov_size;\n\n    buf = av_malloc(moov_size * 2);\n    if (!buf)\n        return AVERROR(ENOMEM);\n    read_buf[0] = buf;\n    read_buf[1] = buf + moov_size;\n\n    /* Shift the data: the AVIO context of the output can only be used for\n     * writing, so we re-open the same output, but for reading. It also avoids\n     * a read/seek/write/seek back and forth. */\n    avio_flush(s->pb);\n    ret = s->io_open(s, &read_pb, s->filename, AVIO_FLAG_READ, NULL);\n    if (ret < 0) {\n        av_log(s, AV_LOG_ERROR, \"Unable to re-open %s output file for \"\n               \"the second pass (faststart)\\n\", s->filename);\n        goto end;\n    }\n\n    /* mark the end of the shift to up to the last data we wrote, and get ready\n     * for writing */\n    pos_end = avio_tell(s->pb);\n    avio_seek(s->pb, mov->reserved_header_pos + moov_size, SEEK_SET);\n\n    /* start reading at where the new moov will be placed */\n    avio_seek(read_pb, mov->reserved_header_pos, SEEK_SET);\n    pos = avio_tell(read_pb);\n\n#define READ_BLOCK do {                                                             \\\n    read_size[read_buf_id] = avio_read(read_pb, read_buf[read_buf_id], moov_size);  \\\n    read_buf_id ^= 1;                                                               \\\n} while (0)\n\n    /* shift data by chunk of at most moov_size */\n    READ_BLOCK;\n    do {\n        int n;\n        READ_BLOCK;\n        n = read_size[read_buf_id];\n        if (n <= 0)\n            break;\n        avio_write(s->pb, read_buf[read_buf_id], n);\n        pos += n;\n    } while (pos < pos_end);\n    ff_format_io_close(s, &read_pb);\n\nend:\n    av_free(buf);\n    return ret;\n}\n\nstatic int mov_write_trailer(AVFormatContext *s)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int res = 0;\n    int i;\n    int64_t moov_pos;\n\n    if (mov->need_rewrite_extradata) {\n        for (i = 0; i < s->nb_streams; i++) {\n            MOVTrack *track = &mov->tracks[i];\n            AVCodecParameters *par = track->par;\n\n            track->vos_len  = par->extradata_size;\n            track->vos_data = av_malloc(track->vos_len);\n            if (!track->vos_data)\n                return AVERROR(ENOMEM);\n            memcpy(track->vos_data, par->extradata, track->vos_len);\n        }\n        mov->need_rewrite_extradata = 0;\n    }\n\n    /*\n     * Before actually writing the trailer, make sure that there are no\n     * dangling subtitles, that need a terminating sample.\n     */\n    for (i = 0; i < mov->nb_streams; i++) {\n        MOVTrack *trk = &mov->tracks[i];\n        if (trk->par->codec_id == AV_CODEC_ID_MOV_TEXT &&\n            !trk->last_sample_is_subtitle_end) {\n            mov_write_subtitle_end_packet(s, i, trk->track_duration);\n            trk->last_sample_is_subtitle_end = 1;\n        }\n    }\n\n    // If there were no chapters when the header was written, but there\n    // are chapters now, write them in the trailer.  This only works\n    // when we are not doing fragments.\n    if (!mov->chapter_track && !(mov->flags & FF_MOV_FLAG_FRAGMENT)) {\n        if (mov->mode & (MODE_MP4|MODE_MOV|MODE_IPOD) && s->nb_chapters) {\n            mov->chapter_track = mov->nb_streams++;\n            if ((res = mov_create_chapter_track(s, mov->chapter_track)) < 0)\n                return res;\n        }\n    }\n\n    if (!(mov->flags & FF_MOV_FLAG_FRAGMENT)) {\n        moov_pos = avio_tell(pb);\n\n        /* Write size of mdat tag */\n        if (mov->mdat_size + 8 <= UINT32_MAX) {\n            avio_seek(pb, mov->mdat_pos, SEEK_SET);\n            avio_wb32(pb, mov->mdat_size + 8);\n        } else {\n            /* overwrite 'wide' placeholder atom */\n            avio_seek(pb, mov->mdat_pos - 8, SEEK_SET);\n            /* special value: real atom size will be 64 bit value after\n             * tag field */\n            avio_wb32(pb, 1);\n            ffio_wfourcc(pb, \"mdat\");\n            avio_wb64(pb, mov->mdat_size + 16);\n        }\n        avio_seek(pb, mov->reserved_moov_size > 0 ? mov->reserved_header_pos : moov_pos, SEEK_SET);\n\n        if (mov->flags & FF_MOV_FLAG_FASTSTART) {\n            av_log(s, AV_LOG_INFO, \"Starting second pass: moving the moov atom to the beginning of the file\\n\");\n            res = shift_data(s);\n            if (res < 0)\n                return res;\n            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);\n            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)\n                return res;\n        } else if (mov->reserved_moov_size > 0) {\n            int64_t size;\n            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)\n                return res;\n            size = mov->reserved_moov_size - (avio_tell(pb) - mov->reserved_header_pos);\n            if (size < 8){\n                av_log(s, AV_LOG_ERROR, \"reserved_moov_size is too small, needed %\"PRId64\" additional\\n\", 8-size);\n                return AVERROR(EINVAL);\n            }\n            avio_wb32(pb, size);\n            ffio_wfourcc(pb, \"free\");\n            ffio_fill(pb, 0, size - 8);\n            avio_seek(pb, moov_pos, SEEK_SET);\n        } else {\n            if ((res = mov_write_moov_tag(pb, mov, s)) < 0)\n                return res;\n        }\n        res = 0;\n    } else {\n        mov_auto_flush_fragment(s, 1);\n        for (i = 0; i < mov->nb_streams; i++)\n           mov->tracks[i].data_offset = 0;\n        if (mov->flags & FF_MOV_FLAG_GLOBAL_SIDX) {\n            int64_t end;\n            av_log(s, AV_LOG_INFO, \"Starting second pass: inserting sidx atoms\\n\");\n            res = shift_data(s);\n            if (res < 0)\n                return res;\n            end = avio_tell(pb);\n            avio_seek(pb, mov->reserved_header_pos, SEEK_SET);\n            mov_write_sidx_tags(pb, mov, -1, 0);\n            avio_seek(pb, end, SEEK_SET);\n            avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER);\n            mov_write_mfra_tag(pb, mov);\n        } else {\n            avio_write_marker(s->pb, AV_NOPTS_VALUE, AVIO_DATA_MARKER_TRAILER);\n            mov_write_mfra_tag(pb, mov);\n        }\n    }\n\n    return res;\n}\n\nstatic int mov_check_bitstream(struct AVFormatContext *s, const AVPacket *pkt)\n{\n    int ret = 1;\n    AVStream *st = s->streams[pkt->stream_index];\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_AAC) {\n        if (pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0)\n            ret = ff_stream_add_bitstream_filter(st, \"aac_adtstoasc\", NULL);\n    }\n\n    return ret;\n}\n\n#if CONFIG_MOV_MUXER\nMOV_CLASS(mov)\nAVOutputFormat ff_mov_muxer = {\n    .name              = \"mov\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),\n    .extensions        = \"mov\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = CONFIG_LIBX264_ENCODER ?\n                         AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){\n        ff_codec_movvideo_tags, ff_codec_movaudio_tags, 0\n    },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &mov_muxer_class,\n};\n#endif\n#if CONFIG_TGP_MUXER\nMOV_CLASS(tgp)\nAVOutputFormat ff_tgp_muxer = {\n    .name              = \"3gp\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP (3GPP file format)\"),\n    .extensions        = \"3gp\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AMR_NB,\n    .video_codec       = AV_CODEC_ID_H263,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ codec_3gp_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &tgp_muxer_class,\n};\n#endif\n#if CONFIG_MP4_MUXER\nMOV_CLASS(mp4)\nAVOutputFormat ff_mp4_muxer = {\n    .name              = \"mp4\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"MP4 (MPEG-4 Part 14)\"),\n    .mime_type         = \"video/mp4\",\n    .extensions        = \"mp4\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = CONFIG_LIBX264_ENCODER ?\n                         AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ ff_mp4_obj_type, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &mp4_muxer_class,\n};\n#endif\n#if CONFIG_PSP_MUXER\nMOV_CLASS(psp)\nAVOutputFormat ff_psp_muxer = {\n    .name              = \"psp\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"PSP MP4 (MPEG-4 Part 14)\"),\n    .extensions        = \"mp4,psp\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = CONFIG_LIBX264_ENCODER ?\n                         AV_CODEC_ID_H264 : AV_CODEC_ID_MPEG4,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ ff_mp4_obj_type, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &psp_muxer_class,\n};\n#endif\n#if CONFIG_TG2_MUXER\nMOV_CLASS(tg2)\nAVOutputFormat ff_tg2_muxer = {\n    .name              = \"3g2\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"3GP2 (3GPP2 file format)\"),\n    .extensions        = \"3g2\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AMR_NB,\n    .video_codec       = AV_CODEC_ID_H263,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ codec_3gp_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &tg2_muxer_class,\n};\n#endif\n#if CONFIG_IPOD_MUXER\nMOV_CLASS(ipod)\nAVOutputFormat ff_ipod_muxer = {\n    .name              = \"ipod\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"iPod H.264 MP4 (MPEG-4 Part 14)\"),\n    .mime_type         = \"video/mp4\",\n    .extensions        = \"m4v,m4a\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_H264,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ codec_ipod_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &ipod_muxer_class,\n};\n#endif\n#if CONFIG_ISMV_MUXER\nMOV_CLASS(ismv)\nAVOutputFormat ff_ismv_muxer = {\n    .name              = \"ismv\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"ISMV/ISMA (Smooth Streaming)\"),\n    .mime_type         = \"video/mp4\",\n    .extensions        = \"ismv,isma\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_H264,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH | AVFMT_TS_NEGATIVE,\n    .codec_tag         = (const AVCodecTag* const []){ ff_mp4_obj_type, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &ismv_muxer_class,\n};\n#endif\n#if CONFIG_F4V_MUXER\nMOV_CLASS(f4v)\nAVOutputFormat ff_f4v_muxer = {\n    .name              = \"f4v\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"F4V Adobe Flash Video\"),\n    .mime_type         = \"application/f4v\",\n    .extensions        = \"f4v\",\n    .priv_data_size    = sizeof(MOVMuxContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_H264,\n    .init              = mov_init,\n    .write_header      = mov_write_header,\n    .write_packet      = mov_write_packet,\n    .write_trailer     = mov_write_trailer,\n    .deinit            = mov_free,\n    .flags             = AVFMT_GLOBALHEADER | AVFMT_ALLOW_FLUSH,\n    .codec_tag         = (const AVCodecTag* const []){ codec_f4v_tags, 0 },\n    .check_bitstream   = mov_check_bitstream,\n    .priv_class        = &f4v_muxer_class,\n};\n#endif\n"], "filenames": ["libavformat/movenc.c"], "buggy_code_start_loc": [917], "buggy_code_end_loc": [918], "fixing_code_start_loc": [917], "fixing_code_end_loc": [918], "type": "CWE-369", "message": "libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.", "other": {"cve": {"id": "CVE-2018-14395", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-19T05:29:00.273", "lastModified": "2021-02-05T21:57:07.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format."}, {"lang": "es", "value": "libavformat/movenc.c en FFmpeg versiones 3.2 y 4.0.2 permite que los atacantes provoquen una denegaci\u00f3n de servicio (cierre inesperado de la aplicaci\u00f3n provocado por un error de divisi\u00f3n entre cero) con un archivo de audio manipulado por el usuario al convertirlo al formato de audio MOV"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "21F765CB-B78E-42A3-BB22-D9FC515694B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "35169F84-5DDB-468A-9DB4-08CC657ABE8B"}]}]}], "references": [{"url": "http://www.securitytracker.com/id/1041394", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/2c0e98a0b478284bdff6d7a4062522605a8beae5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/fa19fbcf712a6a6cc5a5cfdc3254a97b9bce6582", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4258", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2c0e98a0b478284bdff6d7a4062522605a8beae5"}}