{"buggy_code": ["/*\n * Hisilicon clock driver\n *\n * Copyright (c) 2013-2017 Hisilicon Limited.\n * Copyright (c) 2017 Linaro Limited.\n *\n * Author: Kai Zhao <zhaokai1@hisilicon.com>\n *\t    Tao Wang <kevin.wangtao@hisilicon.com>\n *\t    Leo Yan <leo.yan@linaro.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/hi3660-clock.h>\n\n#define HI3660_STUB_CLOCK_DATA\t\t(0x70)\n#define MHZ\t\t\t\t(1000 * 1000)\n\n#define DEFINE_CLK_STUB(_id, _cmd, _name)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = (_id),\t\t\t\t\t\\\n\t\t.cmd = (_cmd),\t\t\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data) {\t\t\\\n\t\t\t.name = #_name,\t\t\t\t\\\n\t\t\t.ops = &hi3660_stub_clk_ops,\t\t\\\n\t\t\t.num_parents = 0,\t\t\t\\\n\t\t\t.flags = CLK_GET_RATE_NOCACHE,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\n\n#define to_stub_clk(_hw) container_of(_hw, struct hi3660_stub_clk, hw)\n\nstruct hi3660_stub_clk_chan {\n\tstruct mbox_client cl;\n\tstruct mbox_chan *mbox;\n};\n\nstruct hi3660_stub_clk {\n\tunsigned int id;\n\tstruct clk_hw hw;\n\tunsigned int cmd;\n\tunsigned int msg[8];\n\tunsigned int rate;\n};\n\nstatic void __iomem *freq_reg;\nstatic struct hi3660_stub_clk_chan stub_clk_chan;\n\nstatic unsigned long hi3660_stub_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct hi3660_stub_clk *stub_clk = to_stub_clk(hw);\n\n\t/*\n\t * LPM3 writes back the CPU frequency in shared SRAM so read\n\t * back the frequency.\n\t */\n\tstub_clk->rate = readl(freq_reg + (stub_clk->id << 2)) * MHZ;\n\treturn stub_clk->rate;\n}\n\nstatic long hi3660_stub_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\t/*\n\t * LPM3 handles rate rounding so just return whatever\n\t * rate is requested.\n\t */\n\treturn rate;\n}\n\nstatic int hi3660_stub_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct hi3660_stub_clk *stub_clk = to_stub_clk(hw);\n\n\tstub_clk->msg[0] = stub_clk->cmd;\n\tstub_clk->msg[1] = rate / MHZ;\n\n\tdev_dbg(stub_clk_chan.cl.dev, \"set rate msg[0]=0x%x msg[1]=0x%x\\n\",\n\t\tstub_clk->msg[0], stub_clk->msg[1]);\n\n\tmbox_send_message(stub_clk_chan.mbox, stub_clk->msg);\n\tmbox_client_txdone(stub_clk_chan.mbox, 0);\n\n\tstub_clk->rate = rate;\n\treturn 0;\n}\n\nstatic const struct clk_ops hi3660_stub_clk_ops = {\n\t.recalc_rate    = hi3660_stub_clk_recalc_rate,\n\t.round_rate     = hi3660_stub_clk_round_rate,\n\t.set_rate       = hi3660_stub_clk_set_rate,\n};\n\nstatic struct hi3660_stub_clk hi3660_stub_clks[HI3660_CLK_STUB_NUM] = {\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_CLUSTER0, 0x0001030A, \"cpu-cluster.0\")\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_CLUSTER1, 0x0002030A, \"cpu-cluster.1\")\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_GPU, 0x0003030A, \"clk-g3d\")\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_DDR, 0x00040309, \"clk-ddrc\")\n};\n\nstatic struct clk_hw *hi3660_stub_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t     void *data)\n{\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= HI3660_CLK_STUB_NUM) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &hi3660_stub_clks[idx].hw;\n}\n\nstatic int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}\n\nstatic const struct of_device_id hi3660_stub_clk_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3660-stub-clk\", },\n\t{}\n};\n\nstatic struct platform_driver hi3660_stub_clk_driver = {\n\t.probe\t= hi3660_stub_clk_probe,\n\t.driver = {\n\t\t.name = \"hi3660-stub-clk\",\n\t\t.of_match_table = hi3660_stub_clk_of_match,\n\t},\n};\n\nstatic int __init hi3660_stub_clk_init(void)\n{\n\treturn platform_driver_register(&hi3660_stub_clk_driver);\n}\nsubsys_initcall(hi3660_stub_clk_init);\n"], "fixing_code": ["/*\n * Hisilicon clock driver\n *\n * Copyright (c) 2013-2017 Hisilicon Limited.\n * Copyright (c) 2017 Linaro Limited.\n *\n * Author: Kai Zhao <zhaokai1@hisilicon.com>\n *\t    Tao Wang <kevin.wangtao@hisilicon.com>\n *\t    Leo Yan <leo.yan@linaro.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n */\n\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <dt-bindings/clock/hi3660-clock.h>\n\n#define HI3660_STUB_CLOCK_DATA\t\t(0x70)\n#define MHZ\t\t\t\t(1000 * 1000)\n\n#define DEFINE_CLK_STUB(_id, _cmd, _name)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.id = (_id),\t\t\t\t\t\\\n\t\t.cmd = (_cmd),\t\t\t\t\t\\\n\t\t.hw.init = &(struct clk_init_data) {\t\t\\\n\t\t\t.name = #_name,\t\t\t\t\\\n\t\t\t.ops = &hi3660_stub_clk_ops,\t\t\\\n\t\t\t.num_parents = 0,\t\t\t\\\n\t\t\t.flags = CLK_GET_RATE_NOCACHE,\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t},\n\n#define to_stub_clk(_hw) container_of(_hw, struct hi3660_stub_clk, hw)\n\nstruct hi3660_stub_clk_chan {\n\tstruct mbox_client cl;\n\tstruct mbox_chan *mbox;\n};\n\nstruct hi3660_stub_clk {\n\tunsigned int id;\n\tstruct clk_hw hw;\n\tunsigned int cmd;\n\tunsigned int msg[8];\n\tunsigned int rate;\n};\n\nstatic void __iomem *freq_reg;\nstatic struct hi3660_stub_clk_chan stub_clk_chan;\n\nstatic unsigned long hi3660_stub_clk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t unsigned long parent_rate)\n{\n\tstruct hi3660_stub_clk *stub_clk = to_stub_clk(hw);\n\n\t/*\n\t * LPM3 writes back the CPU frequency in shared SRAM so read\n\t * back the frequency.\n\t */\n\tstub_clk->rate = readl(freq_reg + (stub_clk->id << 2)) * MHZ;\n\treturn stub_clk->rate;\n}\n\nstatic long hi3660_stub_clk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t       unsigned long *prate)\n{\n\t/*\n\t * LPM3 handles rate rounding so just return whatever\n\t * rate is requested.\n\t */\n\treturn rate;\n}\n\nstatic int hi3660_stub_clk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t    unsigned long parent_rate)\n{\n\tstruct hi3660_stub_clk *stub_clk = to_stub_clk(hw);\n\n\tstub_clk->msg[0] = stub_clk->cmd;\n\tstub_clk->msg[1] = rate / MHZ;\n\n\tdev_dbg(stub_clk_chan.cl.dev, \"set rate msg[0]=0x%x msg[1]=0x%x\\n\",\n\t\tstub_clk->msg[0], stub_clk->msg[1]);\n\n\tmbox_send_message(stub_clk_chan.mbox, stub_clk->msg);\n\tmbox_client_txdone(stub_clk_chan.mbox, 0);\n\n\tstub_clk->rate = rate;\n\treturn 0;\n}\n\nstatic const struct clk_ops hi3660_stub_clk_ops = {\n\t.recalc_rate    = hi3660_stub_clk_recalc_rate,\n\t.round_rate     = hi3660_stub_clk_round_rate,\n\t.set_rate       = hi3660_stub_clk_set_rate,\n};\n\nstatic struct hi3660_stub_clk hi3660_stub_clks[HI3660_CLK_STUB_NUM] = {\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_CLUSTER0, 0x0001030A, \"cpu-cluster.0\")\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_CLUSTER1, 0x0002030A, \"cpu-cluster.1\")\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_GPU, 0x0003030A, \"clk-g3d\")\n\tDEFINE_CLK_STUB(HI3660_CLK_STUB_DDR, 0x00040309, \"clk-ddrc\")\n};\n\nstatic struct clk_hw *hi3660_stub_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t     void *data)\n{\n\tunsigned int idx = clkspec->args[0];\n\n\tif (idx >= HI3660_CLK_STUB_NUM) {\n\t\tpr_err(\"%s: invalid index %u\\n\", __func__, idx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &hi3660_stub_clks[idx].hw;\n}\n\nstatic int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t/* Use mailbox client without blocking */\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t/* Allocate mailbox channel */\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}\n\nstatic const struct of_device_id hi3660_stub_clk_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3660-stub-clk\", },\n\t{}\n};\n\nstatic struct platform_driver hi3660_stub_clk_driver = {\n\t.probe\t= hi3660_stub_clk_probe,\n\t.driver = {\n\t\t.name = \"hi3660-stub-clk\",\n\t\t.of_match_table = hi3660_stub_clk_of_match,\n\t},\n};\n\nstatic int __init hi3660_stub_clk_init(void)\n{\n\treturn platform_driver_register(&hi3660_stub_clk_driver);\n}\nsubsys_initcall(hi3660_stub_clk_init);\n"], "filenames": ["drivers/clk/hisilicon/clk-hi3660-stub.c"], "buggy_code_start_loc": [151], "buggy_code_end_loc": [151], "fixing_code_start_loc": [152], "fixing_code_end_loc": [154], "type": "CWE-476", "message": "The hi3660_stub_clk_probe function in drivers/clk/hisilicon/clk-hi3660-stub.c in the Linux kernel before 4.16 allows local users to cause a denial of service (NULL pointer dereference) by triggering a failure of resource retrieval.", "other": {"cve": {"id": "CVE-2018-10074", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-12T18:29:00.427", "lastModified": "2018-05-22T18:11:40.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The hi3660_stub_clk_probe function in drivers/clk/hisilicon/clk-hi3660-stub.c in the Linux kernel before 4.16 allows local users to cause a denial of service (NULL pointer dereference) by triggering a failure of resource retrieval."}, {"lang": "es", "value": "La funci\u00f3n hi3660_stub_clk_probe en drivers/clk/hisilicon/clk-hi3660-stub.c en el kernel de Linux, en versiones anteriores a la 4.16, permite que usuarios locales provoquen una denegaci\u00f3n de servicio (desreferencia de puntero NULL) al desencadenar un error de recuperaci\u00f3n de recursos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.16", "matchCriteriaId": "377F5B77-1BED-4B04-84A7-A585DCD2C01C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=9903e41ae1f5d50c93f268ca3304d4d7c64b9311", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9903e41ae1f5d50c93f268ca3304d4d7c64b9311"}}