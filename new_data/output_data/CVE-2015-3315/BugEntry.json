{"buggy_code": ["/*\n    abrt-hook-ccpp.cpp - the hook for C/C++ crashing program\n\n    Copyright (C) 2009\tZdenek Prikryl (zprikryl@redhat.com)\n    Copyright (C) 2009\tRedHat inc.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include <sys/utsname.h>\n#include \"libabrt.h\"\n\n#define  DUMP_SUID_UNSAFE 1\n#define  DUMP_SUID_SAFE 2\n\n\n/* I want to use -Werror, but gcc-4.4 throws a curveball:\n * \"warning: ignoring return value of 'ftruncate', declared with attribute warn_unused_result\"\n * and (void) cast is not enough to shut it up! Oh God...\n */\n#define IGNORE_RESULT(func_call) do { if (func_call) /* nothing */; } while (0)\n\nstatic char* malloc_readlink(const char *linkname)\n{\n    char buf[PATH_MAX + 1];\n    int len;\n\n    len = readlink(linkname, buf, sizeof(buf)-1);\n    if (len >= 0)\n    {\n        buf[len] = '\\0';\n        return xstrdup(buf);\n    }\n    return NULL;\n}\n\n/* Custom version of copyfd_xyz,\n * one which is able to write into two descriptors at once.\n */\n#define CONFIG_FEATURE_COPYBUF_KB 4\nstatic off_t copyfd_sparse(int src_fd, int dst_fd1, int dst_fd2, off_t size2)\n{\n\toff_t total = 0;\n\tint last_was_seek = 0;\n#if CONFIG_FEATURE_COPYBUF_KB <= 4\n\tchar buffer[CONFIG_FEATURE_COPYBUF_KB * 1024];\n\tenum { buffer_size = sizeof(buffer) };\n#else\n\tchar *buffer;\n\tint buffer_size;\n\n\t/* We want page-aligned buffer, just in case kernel is clever\n\t * and can do page-aligned io more efficiently */\n\tbuffer = mmap(NULL, CONFIG_FEATURE_COPYBUF_KB * 1024,\n\t\t\tPROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANON,\n\t\t\t/* ignored: */ -1, 0);\n\tbuffer_size = CONFIG_FEATURE_COPYBUF_KB * 1024;\n\tif (buffer == MAP_FAILED) {\n\t\tbuffer = alloca(4 * 1024);\n\t\tbuffer_size = 4 * 1024;\n\t}\n#endif\n\n\twhile (1) {\n\t\tssize_t rd = safe_read(src_fd, buffer, buffer_size);\n\t\tif (!rd) { /* eof */\n\t\t\tif (last_was_seek) {\n\t\t\t\tif (lseek(dst_fd1, -1, SEEK_CUR) < 0\n\t\t\t\t || safe_write(dst_fd1, \"\", 1) != 1\n\t\t\t\t || (dst_fd2 >= 0\n\t\t\t\t     && (lseek(dst_fd2, -1, SEEK_CUR) < 0\n\t\t\t\t\t || safe_write(dst_fd2, \"\", 1) != 1\n\t\t\t\t        )\n\t\t\t\t    )\n\t\t\t\t) {\n\t\t\t\t\tperror_msg(\"Write error\");\n\t\t\t\t\ttotal = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all done */\n\t\t\tgoto out;\n\t\t}\n\t\tif (rd < 0) {\n\t\t\tperror_msg(\"Read error\");\n\t\t\ttotal = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* checking sparseness */\n\t\tssize_t cnt = rd;\n\t\twhile (--cnt >= 0) {\n\t\t\tif (buffer[cnt] != 0) {\n\t\t\t\t/* not sparse */\n\t\t\t\terrno = 0;\n\t\t\t\tssize_t wr1 = full_write(dst_fd1, buffer, rd);\n\t\t\t\tssize_t wr2 = (dst_fd2 >= 0 ? full_write(dst_fd2, buffer, rd) : rd);\n\t\t\t\tif (wr1 < rd || wr2 < rd) {\n\t\t\t\t\tperror_msg(\"Write error\");\n\t\t\t\t\ttotal = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlast_was_seek = 0;\n\t\t\t\tgoto adv;\n\t\t\t}\n\t\t}\n\t\t/* sparse */\n\t\txlseek(dst_fd1, rd, SEEK_CUR);\n\t\tif (dst_fd2 >= 0)\n\t\t\txlseek(dst_fd2, rd, SEEK_CUR);\n\t\tlast_was_seek = 1;\n adv:\n\t\ttotal += rd;\n\t\tsize2 -= rd;\n\t\tif (size2 < 0)\n\t\t\tdst_fd2 = -1;\n//TODO: truncate to 0 or even delete the second file\n//(currently we delete the file later)\n\t}\n out:\n\n#if CONFIG_FEATURE_COPYBUF_KB > 4\n\tif (buffer_size != 4 * 1024)\n\t\tmunmap(buffer, buffer_size);\n#endif\n\treturn total;\n}\n\n\n/* Global data */\n\nstatic char *user_pwd;\nstatic char *proc_pid_status;\nstatic struct dump_dir *dd;\nstatic int user_core_fd = -1;\n/*\n * %s - signal number\n * %c - ulimit -c value\n * %p - pid\n * %u - uid\n * %g - gid\n * %t - UNIX time of dump\n * %e - executable filename\n * %h - hostname\n * %% - output one \"%\"\n */\n/* Hook must be installed with exactly the same sequence of %c specifiers.\n * Last one, %h, may be omitted (we can find it out).\n */\nstatic const char percent_specifiers[] = \"%scpugteh\";\nstatic char *core_basename = (char*) \"core\";\n/*\n * Used for error messages only.\n * It is either the same as core_basename if it is absolute,\n * or $PWD/core_basename.\n */\nstatic char *full_core_basename;\n\n\nstatic char* get_executable(pid_t pid, int *fd_p)\n{\n    char buf[sizeof(\"/proc/%lu/exe\") + sizeof(long)*3];\n\n    sprintf(buf, \"/proc/%lu/exe\", (long)pid);\n    if (fd_p)\n        *fd_p = open(buf, O_RDONLY); /* might fail and return -1, it's ok */\n    char *executable = malloc_readlink(buf);\n    if (!executable)\n        return NULL;\n    /* find and cut off \" (deleted)\" from the path */\n    char *deleted = executable + strlen(executable) - strlen(\" (deleted)\");\n    if (deleted > executable && strcmp(deleted, \" (deleted)\") == 0)\n    {\n        *deleted = '\\0';\n        log(\"File '%s' seems to be deleted\", executable);\n    }\n    /* find and cut off prelink suffixes from the path */\n    char *prelink = executable + strlen(executable) - strlen(\".#prelink#.XXXXXX\");\n    if (prelink > executable && strncmp(prelink, \".#prelink#.\", strlen(\".#prelink#.\")) == 0)\n    {\n        log(\"File '%s' seems to be a prelink temporary file\", executable);\n        *prelink = '\\0';\n    }\n    return executable;\n}\n\nstatic char* get_cwd(pid_t pid)\n{\n    char buf[sizeof(\"/proc/%lu/cwd\") + sizeof(long)*3];\n    sprintf(buf, \"/proc/%lu/cwd\", (long)pid);\n    return malloc_readlink(buf);\n}\n\nstatic char* get_rootdir(pid_t pid)\n{\n    char buf[sizeof(\"/proc/%lu/root\") + sizeof(long)*3];\n    sprintf(buf, \"/proc/%lu/root\", (long)pid);\n    return malloc_readlink(buf);\n}\n\nstatic int get_fsuid(void)\n{\n    int real, euid, saved;\n    /* if we fail to parse the uid, then make it root only readable to be safe */\n    int fs_uid = 0;\n\n    char *line = proc_pid_status; /* never NULL */\n    for (;;)\n    {\n        if (strncmp(line, \"Uid\", 3) == 0)\n        {\n            int n = sscanf(line, \"Uid:\\t%d\\t%d\\t%d\\t%d\\n\", &real, &euid, &saved, &fs_uid);\n            if (n != 4)\n            {\n                perror_msg_and_die(\"Can't parse Uid: line\");\n            }\n            break;\n        }\n        line = strchr(line, '\\n');\n        if (!line)\n            break;\n        line++;\n    }\n\n    return fs_uid;\n}\n\nstatic int dump_suid_policy()\n{\n    /*\n     - values are:\n       0 - don't dump suided programs - in this case the hook is not called by kernel\n       1 - create coredump readable by fs_uid\n       2 - create coredump readable by root only\n    */\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n\n    //log(\"suid dump policy is: %i\", suid_dump_policy);\n    return suid_dump_policy;\n}\n\nstatic int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)\n{\n    errno = 0;\n    if (user_pwd == NULL\n     || chdir(user_pwd) != 0\n    ) {\n        perror_msg(\"Can't cd to '%s'\", user_pwd);\n        return -1;\n    }\n\n    struct passwd* pw = getpwuid(uid);\n    gid_t gid = pw ? pw->pw_gid : uid;\n    //log(\"setting uid: %i gid: %i\", uid, gid);\n    xsetegid(gid);\n    xseteuid(fsuid);\n\n    if (strcmp(core_basename, \"core\") == 0)\n    {\n        /* Mimic \"core.PID\" if requested */\n        char buf[] = \"0\\n\";\n        int fd = open(\"/proc/sys/kernel/core_uses_pid\", O_RDONLY);\n        if (fd >= 0)\n        {\n            IGNORE_RESULT(read(fd, buf, sizeof(buf)));\n            close(fd);\n        }\n        if (strcmp(buf, \"1\\n\") == 0)\n        {\n            core_basename = xasprintf(\"%s.%lu\", core_basename, (long)pid);\n        }\n    }\n    else\n    {\n        /* Expand old core pattern, put expanded name in core_basename */\n        core_basename = xstrdup(core_basename);\n        unsigned idx = 0;\n        while (1)\n        {\n            char c = core_basename[idx];\n            if (!c)\n                break;\n            idx++;\n            if (c != '%')\n                continue;\n\n            /* We just copied %, look at following char and expand %c */\n            c = core_basename[idx];\n            unsigned specifier_num = strchrnul(percent_specifiers, c) - percent_specifiers;\n            if (percent_specifiers[specifier_num] != '\\0') /* valid %c (might be %% too) */\n            {\n                const char *val = \"%\";\n                if (specifier_num > 0) /* not %% */\n                    val = percent_values[specifier_num - 1];\n                //log(\"c:'%c'\", c);\n                //log(\"val:'%s'\", val);\n\n                /* Replace %c at core_basename[idx] by its value */\n                idx--;\n                char *old = core_basename;\n                core_basename = xasprintf(\"%.*s%s%s\", idx, core_basename, val, core_basename + idx + 2);\n                //log(\"pos:'%*s|'\", idx, \"\");\n                //log(\"new:'%s'\", core_basename);\n                //log(\"old:'%s'\", old);\n                free(old);\n                idx += strlen(val);\n            }\n            /* else: invalid %c, % is already copied verbatim,\n             * next loop iteration will copy c */\n        }\n    }\n\n    full_core_basename = core_basename;\n    if (core_basename[0] != '/')\n        core_basename = concat_path_file(user_pwd, core_basename);\n\n    /* Open (create) compat core file.\n     * man core:\n     * There are various circumstances in which a core dump file\n     * is not produced:\n     *\n     * [skipped obvious ones]\n     * The process does not have permission to write the core file.\n     * ...if a file with the same name exists and is not writable\n     * or is not a regular file (e.g., it is a directory or a symbolic link).\n     *\n     * A file with the same name already exists, but there is more\n     * than one hard link to that file.\n     *\n     * The file system where the core dump file would be created is full;\n     * or has run out of inodes; or is mounted read-only;\n     * or the user has reached their quota for the file system.\n     *\n     * The RLIMIT_CORE or RLIMIT_FSIZE resource limits for the process\n     * are set to zero.\n     * [we check RLIMIT_CORE, but how can we check RLIMIT_FSIZE?]\n     *\n     * The binary being executed by the process does not have\n     * read permission enabled. [how we can check it here?]\n     *\n     * The process is executing a set-user-ID (set-group-ID) program\n     * that is owned by a user (group) other than the real\n     * user (group) ID of the process. [TODO?]\n     * (However, see the description of the prctl(2) PR_SET_DUMPABLE operation,\n     * and the description of the /proc/sys/fs/suid_dumpable file in proc(5).)\n     */\n    struct stat sb;\n    errno = 0;\n    /* Do not O_TRUNC: if later checks fail, we do not want to have file already modified here */\n    int user_core_fd = open(core_basename, O_WRONLY | O_CREAT | O_NOFOLLOW, 0600); /* kernel makes 0600 too */\n    xsetegid(0);\n    xseteuid(0);\n    if (user_core_fd < 0\n     || fstat(user_core_fd, &sb) != 0\n     || !S_ISREG(sb.st_mode)\n     || sb.st_nlink != 1\n    /* kernel internal dumper checks this too: if (inode->i_uid != current->fsuid) <fail>, need to mimic? */\n    ) {\n        if (user_core_fd < 0)\n            perror_msg(\"Can't open '%s'\", full_core_basename);\n        else\n            perror_msg(\"'%s' is not a regular file with link count 1\", full_core_basename);\n        return -1;\n    }\n    if (ftruncate(user_core_fd, 0) != 0) {\n        /* perror first, otherwise unlink may trash errno */\n        perror_msg(\"Can't truncate '%s' to size 0\", full_core_basename);\n        unlink(core_basename);\n        return -1;\n    }\n\n    return user_core_fd;\n}\n\nstatic bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n\n    unsigned fd = 0;\n    while (fd <= 99999) /* paranoia check */\n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            /* in case the line is not terminated, terminate it */\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n\n    fclose(fp);\n    return true;\n}\n\n/* Like xopen, but on error, unlocks and deletes dd and user core */\nstatic int create_or_die(const char *filename)\n{\n    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_DUMP_DIR_MODE);\n    if (fd >= 0)\n    {\n        IGNORE_RESULT(fchown(fd, dd->dd_uid, dd->dd_gid));\n        return fd;\n    }\n\n    int sv_errno = errno;\n    if (dd)\n        dd_delete(dd);\n    if (user_core_fd >= 0)\n    {\n        xchdir(user_pwd);\n        unlink(core_basename);\n    }\n    errno = sv_errno;\n    perror_msg_and_die(\"Can't open '%s'\", filename);\n}\n\nint main(int argc, char** argv)\n{\n    /* Kernel starts us with all fd's closed.\n     * But it's dangerous:\n     * fprintf(stderr) can dump messages into random fds, etc.\n     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.\n     */\n    int fd = xopen(\"/dev/null\", O_RDWR);\n    while (fd < 2)\n\tfd = xdup(fd);\n    if (fd > 2)\n\tclose(fd);\n\n    if (argc < 8)\n    {\n        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */\n        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/\n        error_msg_and_die(\"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]\", argv[0]);\n    }\n\n    /* Not needed on 2.6.30.\n     * At least 2.6.18 has a bug where\n     * argv[1] = \"SIGNO CORE_SIZE_LIMIT PID ...\"\n     * argv[2] = \"CORE_SIZE_LIMIT PID ...\"\n     * and so on. Fixing it:\n     */\n    if (strchr(argv[1], ' '))\n    {\n        int i;\n        for (i = 1; argv[i]; i++)\n        {\n            strchrnul(argv[i], ' ')[0] = '\\0';\n        }\n    }\n\n    logmode = LOGMODE_JOURNAL;\n\n    /* Parse abrt.conf */\n    load_abrt_conf();\n    /* ... and plugins/CCpp.conf */\n    bool setting_MakeCompatCore;\n    bool setting_SaveBinaryImage;\n    {\n        map_string_t *settings = new_map_string();\n        load_abrt_plugin_conf_file(\"CCpp.conf\", settings);\n        const char *value;\n        value = get_map_string_item_or_NULL(settings, \"MakeCompatCore\");\n        setting_MakeCompatCore = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveBinaryImage\");\n        setting_SaveBinaryImage = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"VerboseLog\");\n        if (value)\n            g_verbose = xatoi_positive(value);\n        free_map_string(settings);\n    }\n\n    errno = 0;\n    const char* signal_str = argv[1];\n    int signal_no = xatoi_positive(signal_str);\n    off_t ulimit_c = strtoull(argv[2], NULL, 10);\n    if (ulimit_c < 0) /* unlimited? */\n    {\n        /* set to max possible >0 value */\n        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));\n    }\n    const char *pid_str = argv[3];\n    pid_t pid = xatoi_positive(argv[3]);\n    uid_t uid = xatoi_positive(argv[4]);\n    if (errno || pid <= 0)\n    {\n        perror_msg_and_die(\"PID '%s' or limit '%s' is bogus\", argv[3], argv[2]);\n    }\n\n    {\n        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN\"/abrt/saved_core_pattern\");\n        /* If we have a saved pattern and it's not a \"|PROG ARGS\" thing... */\n        if (s && s[0] != '|')\n            core_basename = s;\n        else\n            free(s);\n    }\n\n    struct utsname uts;\n    if (!argv[8]) /* no HOSTNAME? */\n    {\n        uname(&uts);\n        argv[8] = uts.nodename;\n    }\n\n    char path[PATH_MAX];\n\n    int src_fd_binary = -1;\n    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);\n    if (executable && strstr(executable, \"/abrt-hook-ccpp\"))\n    {\n        error_msg_and_die(\"PID %lu is '%s', not dumping it to avoid recursion\",\n                        (long)pid, executable);\n    }\n\n    user_pwd = get_cwd(pid); /* may be NULL on error */\n    log_notice(\"user_pwd:'%s'\", user_pwd);\n\n    sprintf(path, \"/proc/%lu/status\", (long)pid);\n    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);\n\n    uid_t fsuid = uid;\n    uid_t tmp_fsuid = get_fsuid();\n    int suid_policy = dump_suid_policy();\n    if (tmp_fsuid != uid)\n    {\n        /* use root for suided apps unless it's explicitly set to UNSAFE */\n        fsuid = 0;\n        if (suid_policy == DUMP_SUID_UNSAFE)\n        {\n            fsuid = tmp_fsuid;\n        }\n    }\n\n    /* Open a fd to compat coredump, if requested and is possible */\n    if (setting_MakeCompatCore && ulimit_c != 0)\n        /* note: checks \"user_pwd == NULL\" inside; updates core_basename */\n        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);\n\n    if (executable == NULL)\n    {\n        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */\n        error_msg(\"Can't read /proc/%lu/exe link\", (long)pid);\n        goto create_user_core;\n    }\n\n    const char *signame = NULL;\n    switch (signal_no)\n    {\n        case SIGILL : signame = \"ILL\" ; break;\n        case SIGFPE : signame = \"FPE\" ; break;\n        case SIGSEGV: signame = \"SEGV\"; break;\n        case SIGBUS : signame = \"BUS\" ; break; //Bus error (bad memory access)\n        case SIGABRT: signame = \"ABRT\"; break; //usually when abort() was called\n    // We have real-world reports from users who see buggy programs\n    // dying with SIGTRAP, uncommented it too:\n        case SIGTRAP: signame = \"TRAP\"; break; //Trace/breakpoint trap\n    // These usually aren't caused by bugs:\n      //case SIGQUIT: signame = \"QUIT\"; break; //Quit from keyboard\n      //case SIGSYS : signame = \"SYS\" ; break; //Bad argument to routine (SVr4)\n      //case SIGXCPU: signame = \"XCPU\"; break; //CPU time limit exceeded (4.2BSD)\n      //case SIGXFSZ: signame = \"XFSZ\"; break; //File size limit exceeded (4.2BSD)\n        default: goto create_user_core; // not a signal we care about\n    }\n\n    if (!daemon_is_ok())\n    {\n        /* not an error, exit with exit code 0 */\n        log(\"abrtd is not running. If it crashed, \"\n            \"/proc/sys/kernel/core_pattern contains a stale value, \"\n            \"consider resetting it to 'core'\"\n        );\n        goto create_user_core;\n    }\n\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        /* If free space is less than 1/4 of MaxCrashReportsSize... */\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            goto create_user_core;\n    }\n\n    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes\n     * if they happen too often. Else, write new marker value.\n     */\n    snprintf(path, sizeof(path), \"%s/last-ccpp\", g_settings_dump_location);\n    if (check_recent_crash_file(path, executable))\n    {\n        /* It is a repeating crash */\n        goto create_user_core;\n    }\n\n    const char *last_slash = strrchr(executable, '/');\n    if (last_slash && strncmp(++last_slash, \"abrt\", 4) == 0)\n    {\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n        snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash);\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        return 0;\n    }\n\n    unsigned path_len = snprintf(path, sizeof(path), \"%s/ccpp-%s-%lu.new\",\n            g_settings_dump_location, iso_date_string(NULL), (long)pid);\n    if (path_len >= (sizeof(path) - sizeof(\"/\"FILENAME_COREDUMP)))\n    {\n        goto create_user_core;\n    }\n\n    /* use fsuid instead of uid, so we don't expose any sensitive\n     * information of suided app in /var/tmp/abrt\n     */\n    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);\n    if (dd)\n    {\n        char *rootdir = get_rootdir(pid);\n\n        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, \"/\") != 0) ? rootdir : NULL);\n\n        char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];\n        int source_base_ofs = sprintf(source_filename, \"/proc/%lu/smaps\", (long)pid);\n        source_base_ofs -= strlen(\"smaps\");\n        char *dest_filename = concat_path_file(dd->dd_dirname, \"also_somewhat_longish_name\");\n        char *dest_base = strrchr(dest_filename, '/') + 1;\n\n        // Disabled for now: /proc/PID/smaps tends to be BIG,\n        // and not much more informative than /proc/PID/maps:\n        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(source_filename + source_base_ofs, \"maps\");\n        strcpy(dest_base, FILENAME_MAPS);\n        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(source_filename + source_base_ofs, \"limits\");\n        strcpy(dest_base, FILENAME_LIMITS);\n        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(source_filename + source_base_ofs, \"cgroup\");\n        strcpy(dest_base, FILENAME_CGROUP);\n        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(dest_base, FILENAME_OPEN_FDS);\n        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);\n\n        free(dest_filename);\n\n        dd_save_text(dd, FILENAME_ANALYZER, \"CCpp\");\n        dd_save_text(dd, FILENAME_TYPE, \"CCpp\");\n        dd_save_text(dd, FILENAME_EXECUTABLE, executable);\n        dd_save_text(dd, FILENAME_PID, pid_str);\n        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);\n        if (user_pwd)\n            dd_save_text(dd, FILENAME_PWD, user_pwd);\n        if (rootdir)\n        {\n            if (strcmp(rootdir, \"/\") != 0)\n                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);\n        }\n\n        char *reason = xasprintf(\"%s killed by SIG%s\",\n                                 last_slash, signame ? signame : signal_str);\n        dd_save_text(dd, FILENAME_REASON, reason);\n        free(reason);\n\n        char *cmdline = get_cmdline(pid);\n        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : \"\");\n        free(cmdline);\n\n        char *environ = get_environ(pid);\n        dd_save_text(dd, FILENAME_ENVIRON, environ ? : \"\");\n        free(environ);\n\n        char *fips_enabled = xmalloc_fopen_fgetline_fclose(\"/proc/sys/crypto/fips_enabled\");\n        if (fips_enabled)\n        {\n            if (strcmp(fips_enabled, \"0\") != 0)\n                dd_save_text(dd, \"fips_enabled\", fips_enabled);\n            free(fips_enabled);\n        }\n\n        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n        if (src_fd_binary > 0)\n        {\n            strcpy(path + path_len, \"/\"FILENAME_BINARY);\n            int dst_fd = create_or_die(path);\n            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);\n            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)\n            {\n                dd_delete(dd);\n                error_msg_and_die(\"Error saving '%s'\", path);\n            }\n            close(src_fd_binary);\n        }\n\n        strcpy(path + path_len, \"/\"FILENAME_COREDUMP);\n        int abrt_core_fd = create_or_die(path);\n\n        /* We write both coredumps at once.\n         * We can't write user coredump first, since it might be truncated\n         * and thus can't be copied and used as abrt coredump;\n         * and if we write abrt coredump first and then copy it as user one,\n         * then we have a race when process exits but coredump does not exist yet:\n         * $ echo -e '#include<signal.h>\\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -\n         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*\n         * 21631 Segmentation fault (core dumped) ./test\n         * ls: cannot access core*: No such file or directory <=== BAD\n         */\n        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);\n        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)\n        {\n            unlink(path);\n            dd_delete(dd);\n            if (user_core_fd >= 0)\n            {\n                xchdir(user_pwd);\n                unlink(core_basename);\n            }\n            /* copyfd_sparse logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error writing '%s'\", path);\n        }\n        if (user_core_fd >= 0\n            /* error writing user coredump? */\n         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0\n            /* user coredump is too big? */\n            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)\n            )\n        ) {\n            /* nuke it (silently) */\n            xchdir(user_pwd);\n            unlink(core_basename);\n        }\n\n        /* Save JVM crash log if it exists. (JVM's coredump per se\n         * is nearly useless for JVM developers)\n         */\n        {\n            char *java_log = xasprintf(\"/tmp/jvm-%lu/hs_error.log\", (long)pid);\n            int src_fd = open(java_log, O_RDONLY);\n            free(java_log);\n\n            /* If we couldn't open the error log in /tmp directory we can try to\n             * read the log from the current directory. It may produce AVC, it\n             * may produce some error log but all these are expected.\n             */\n            if (src_fd < 0)\n            {\n                java_log = xasprintf(\"%s/hs_err_pid%lu.log\", user_pwd, (long)pid);\n                src_fd = open(java_log, O_RDONLY);\n                free(java_log);\n            }\n\n            if (src_fd >= 0)\n            {\n                strcpy(path + path_len, \"/hs_err.log\");\n                int dst_fd = create_or_die(path);\n                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);\n                if (close(dst_fd) != 0 || sz < 0)\n                {\n                    dd_delete(dd);\n                    error_msg_and_die(\"Error saving '%s'\", path);\n                }\n                close(src_fd);\n            }\n        }\n\n        /* We close dumpdir before we start catering for crash storm case.\n         * Otherwise, delete_dump_dir's from other concurrent\n         * CCpp's won't be able to delete our dump (their delete_dump_dir\n         * will wait for us), and we won't be able to delete their dumps.\n         * Classic deadlock.\n         */\n        dd_close(dd);\n        path[path_len] = '\\0'; /* path now contains only directory name */\n        char *newpath = xstrndup(path, path_len - (sizeof(\".new\")-1));\n        if (rename(path, newpath) == 0)\n            strcpy(path, newpath);\n        free(newpath);\n\n        log(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n\n        notify_new_path(path);\n\n        /* rhbz#539551: \"abrt going crazy when crashing process is respawned\" */\n        if (g_settings_nMaxCrashReportsSize > 0)\n        {\n            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming\n             * kicks in first, and we don't \"fight\" with it:\n             */\n            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;\n            maxsize |= 63;\n            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);\n        }\n\n        free(rootdir);\n        return 0;\n    }\n\n    /* We didn't create abrt dump, but may need to create compat coredump */\n create_user_core:\n    if (user_core_fd >= 0)\n    {\n        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);\n        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)\n        {\n            /* perror first, otherwise unlink may trash errno */\n            perror_msg(\"Error writing '%s'\", full_core_basename);\n            xchdir(user_pwd);\n            unlink(core_basename);\n            return 1;\n        }\n        if (ulimit_c == 0 || core_size > ulimit_c)\n        {\n            xchdir(user_pwd);\n            unlink(core_basename);\n            return 1;\n        }\n        log(\"Saved core dump of pid %lu to %s (%llu bytes)\", (long)pid, full_core_basename, (long long)core_size);\n    }\n\n    return 0;\n}\n"], "fixing_code": ["/*\n    abrt-hook-ccpp.cpp - the hook for C/C++ crashing program\n\n    Copyright (C) 2009\tZdenek Prikryl (zprikryl@redhat.com)\n    Copyright (C) 2009\tRedHat inc.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include <sys/utsname.h>\n#include \"libabrt.h\"\n\n#define  DUMP_SUID_UNSAFE 1\n#define  DUMP_SUID_SAFE 2\n\n\n/* I want to use -Werror, but gcc-4.4 throws a curveball:\n * \"warning: ignoring return value of 'ftruncate', declared with attribute warn_unused_result\"\n * and (void) cast is not enough to shut it up! Oh God...\n */\n#define IGNORE_RESULT(func_call) do { if (func_call) /* nothing */; } while (0)\n\nstatic char* malloc_readlink(const char *linkname)\n{\n    char buf[PATH_MAX + 1];\n    int len;\n\n    len = readlink(linkname, buf, sizeof(buf)-1);\n    if (len >= 0)\n    {\n        buf[len] = '\\0';\n        return xstrdup(buf);\n    }\n    return NULL;\n}\n\n/* Custom version of copyfd_xyz,\n * one which is able to write into two descriptors at once.\n */\n#define CONFIG_FEATURE_COPYBUF_KB 4\nstatic off_t copyfd_sparse(int src_fd, int dst_fd1, int dst_fd2, off_t size2)\n{\n\toff_t total = 0;\n\tint last_was_seek = 0;\n#if CONFIG_FEATURE_COPYBUF_KB <= 4\n\tchar buffer[CONFIG_FEATURE_COPYBUF_KB * 1024];\n\tenum { buffer_size = sizeof(buffer) };\n#else\n\tchar *buffer;\n\tint buffer_size;\n\n\t/* We want page-aligned buffer, just in case kernel is clever\n\t * and can do page-aligned io more efficiently */\n\tbuffer = mmap(NULL, CONFIG_FEATURE_COPYBUF_KB * 1024,\n\t\t\tPROT_READ | PROT_WRITE,\n\t\t\tMAP_PRIVATE | MAP_ANON,\n\t\t\t/* ignored: */ -1, 0);\n\tbuffer_size = CONFIG_FEATURE_COPYBUF_KB * 1024;\n\tif (buffer == MAP_FAILED) {\n\t\tbuffer = alloca(4 * 1024);\n\t\tbuffer_size = 4 * 1024;\n\t}\n#endif\n\n\twhile (1) {\n\t\tssize_t rd = safe_read(src_fd, buffer, buffer_size);\n\t\tif (!rd) { /* eof */\n\t\t\tif (last_was_seek) {\n\t\t\t\tif (lseek(dst_fd1, -1, SEEK_CUR) < 0\n\t\t\t\t || safe_write(dst_fd1, \"\", 1) != 1\n\t\t\t\t || (dst_fd2 >= 0\n\t\t\t\t     && (lseek(dst_fd2, -1, SEEK_CUR) < 0\n\t\t\t\t\t || safe_write(dst_fd2, \"\", 1) != 1\n\t\t\t\t        )\n\t\t\t\t    )\n\t\t\t\t) {\n\t\t\t\t\tperror_msg(\"Write error\");\n\t\t\t\t\ttotal = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all done */\n\t\t\tgoto out;\n\t\t}\n\t\tif (rd < 0) {\n\t\t\tperror_msg(\"Read error\");\n\t\t\ttotal = -1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* checking sparseness */\n\t\tssize_t cnt = rd;\n\t\twhile (--cnt >= 0) {\n\t\t\tif (buffer[cnt] != 0) {\n\t\t\t\t/* not sparse */\n\t\t\t\terrno = 0;\n\t\t\t\tssize_t wr1 = full_write(dst_fd1, buffer, rd);\n\t\t\t\tssize_t wr2 = (dst_fd2 >= 0 ? full_write(dst_fd2, buffer, rd) : rd);\n\t\t\t\tif (wr1 < rd || wr2 < rd) {\n\t\t\t\t\tperror_msg(\"Write error\");\n\t\t\t\t\ttotal = -1;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlast_was_seek = 0;\n\t\t\t\tgoto adv;\n\t\t\t}\n\t\t}\n\t\t/* sparse */\n\t\txlseek(dst_fd1, rd, SEEK_CUR);\n\t\tif (dst_fd2 >= 0)\n\t\t\txlseek(dst_fd2, rd, SEEK_CUR);\n\t\tlast_was_seek = 1;\n adv:\n\t\ttotal += rd;\n\t\tsize2 -= rd;\n\t\tif (size2 < 0)\n\t\t\tdst_fd2 = -1;\n//TODO: truncate to 0 or even delete the second file\n//(currently we delete the file later)\n\t}\n out:\n\n#if CONFIG_FEATURE_COPYBUF_KB > 4\n\tif (buffer_size != 4 * 1024)\n\t\tmunmap(buffer, buffer_size);\n#endif\n\treturn total;\n}\n\n\n/* Global data */\n\nstatic char *user_pwd;\nstatic char *proc_pid_status;\nstatic struct dump_dir *dd;\nstatic int user_core_fd = -1;\n/*\n * %s - signal number\n * %c - ulimit -c value\n * %p - pid\n * %u - uid\n * %g - gid\n * %t - UNIX time of dump\n * %e - executable filename\n * %h - hostname\n * %% - output one \"%\"\n */\n/* Hook must be installed with exactly the same sequence of %c specifiers.\n * Last one, %h, may be omitted (we can find it out).\n */\nstatic const char percent_specifiers[] = \"%scpugteh\";\nstatic char *core_basename = (char*) \"core\";\n/*\n * Used for error messages only.\n * It is either the same as core_basename if it is absolute,\n * or $PWD/core_basename.\n */\nstatic char *full_core_basename;\n\n\nstatic char* get_executable(pid_t pid, int *fd_p)\n{\n    char buf[sizeof(\"/proc/%lu/exe\") + sizeof(long)*3];\n\n    sprintf(buf, \"/proc/%lu/exe\", (long)pid);\n    if (fd_p)\n        *fd_p = open(buf, O_RDONLY); /* might fail and return -1, it's ok */\n    char *executable = malloc_readlink(buf);\n    if (!executable)\n        return NULL;\n    /* find and cut off \" (deleted)\" from the path */\n    char *deleted = executable + strlen(executable) - strlen(\" (deleted)\");\n    if (deleted > executable && strcmp(deleted, \" (deleted)\") == 0)\n    {\n        *deleted = '\\0';\n        log(\"File '%s' seems to be deleted\", executable);\n    }\n    /* find and cut off prelink suffixes from the path */\n    char *prelink = executable + strlen(executable) - strlen(\".#prelink#.XXXXXX\");\n    if (prelink > executable && strncmp(prelink, \".#prelink#.\", strlen(\".#prelink#.\")) == 0)\n    {\n        log(\"File '%s' seems to be a prelink temporary file\", executable);\n        *prelink = '\\0';\n    }\n    return executable;\n}\n\nstatic char* get_cwd(pid_t pid)\n{\n    char buf[sizeof(\"/proc/%lu/cwd\") + sizeof(long)*3];\n    sprintf(buf, \"/proc/%lu/cwd\", (long)pid);\n    return malloc_readlink(buf);\n}\n\nstatic char* get_rootdir(pid_t pid)\n{\n    char buf[sizeof(\"/proc/%lu/root\") + sizeof(long)*3];\n    sprintf(buf, \"/proc/%lu/root\", (long)pid);\n    return malloc_readlink(buf);\n}\n\nstatic int get_fsuid(void)\n{\n    int real, euid, saved;\n    /* if we fail to parse the uid, then make it root only readable to be safe */\n    int fs_uid = 0;\n\n    char *line = proc_pid_status; /* never NULL */\n    for (;;)\n    {\n        if (strncmp(line, \"Uid\", 3) == 0)\n        {\n            int n = sscanf(line, \"Uid:\\t%d\\t%d\\t%d\\t%d\\n\", &real, &euid, &saved, &fs_uid);\n            if (n != 4)\n            {\n                perror_msg_and_die(\"Can't parse Uid: line\");\n            }\n            break;\n        }\n        line = strchr(line, '\\n');\n        if (!line)\n            break;\n        line++;\n    }\n\n    return fs_uid;\n}\n\nstatic int dump_suid_policy()\n{\n    /*\n     - values are:\n       0 - don't dump suided programs - in this case the hook is not called by kernel\n       1 - create coredump readable by fs_uid\n       2 - create coredump readable by root only\n    */\n    int c;\n    int suid_dump_policy = 0;\n    const char *filename = \"/proc/sys/fs/suid_dumpable\";\n    FILE *f  = fopen(filename, \"r\");\n    if (!f)\n    {\n        log(\"Can't open %s\", filename);\n        return suid_dump_policy;\n    }\n\n    c = fgetc(f);\n    fclose(f);\n    if (c != EOF)\n        suid_dump_policy = c - '0';\n\n    //log(\"suid dump policy is: %i\", suid_dump_policy);\n    return suid_dump_policy;\n}\n\nstatic int open_user_core(uid_t uid, uid_t fsuid, pid_t pid, char **percent_values)\n{\n    errno = 0;\n    if (user_pwd == NULL\n     || chdir(user_pwd) != 0\n    ) {\n        perror_msg(\"Can't cd to '%s'\", user_pwd);\n        return -1;\n    }\n\n    struct passwd* pw = getpwuid(uid);\n    gid_t gid = pw ? pw->pw_gid : uid;\n    //log(\"setting uid: %i gid: %i\", uid, gid);\n    xsetegid(gid);\n    xseteuid(fsuid);\n\n    if (strcmp(core_basename, \"core\") == 0)\n    {\n        /* Mimic \"core.PID\" if requested */\n        char buf[] = \"0\\n\";\n        int fd = open(\"/proc/sys/kernel/core_uses_pid\", O_RDONLY);\n        if (fd >= 0)\n        {\n            IGNORE_RESULT(read(fd, buf, sizeof(buf)));\n            close(fd);\n        }\n        if (strcmp(buf, \"1\\n\") == 0)\n        {\n            core_basename = xasprintf(\"%s.%lu\", core_basename, (long)pid);\n        }\n    }\n    else\n    {\n        /* Expand old core pattern, put expanded name in core_basename */\n        core_basename = xstrdup(core_basename);\n        unsigned idx = 0;\n        while (1)\n        {\n            char c = core_basename[idx];\n            if (!c)\n                break;\n            idx++;\n            if (c != '%')\n                continue;\n\n            /* We just copied %, look at following char and expand %c */\n            c = core_basename[idx];\n            unsigned specifier_num = strchrnul(percent_specifiers, c) - percent_specifiers;\n            if (percent_specifiers[specifier_num] != '\\0') /* valid %c (might be %% too) */\n            {\n                const char *val = \"%\";\n                if (specifier_num > 0) /* not %% */\n                    val = percent_values[specifier_num - 1];\n                //log(\"c:'%c'\", c);\n                //log(\"val:'%s'\", val);\n\n                /* Replace %c at core_basename[idx] by its value */\n                idx--;\n                char *old = core_basename;\n                core_basename = xasprintf(\"%.*s%s%s\", idx, core_basename, val, core_basename + idx + 2);\n                //log(\"pos:'%*s|'\", idx, \"\");\n                //log(\"new:'%s'\", core_basename);\n                //log(\"old:'%s'\", old);\n                free(old);\n                idx += strlen(val);\n            }\n            /* else: invalid %c, % is already copied verbatim,\n             * next loop iteration will copy c */\n        }\n    }\n\n    full_core_basename = core_basename;\n    if (core_basename[0] != '/')\n        core_basename = concat_path_file(user_pwd, core_basename);\n\n    /* Open (create) compat core file.\n     * man core:\n     * There are various circumstances in which a core dump file\n     * is not produced:\n     *\n     * [skipped obvious ones]\n     * The process does not have permission to write the core file.\n     * ...if a file with the same name exists and is not writable\n     * or is not a regular file (e.g., it is a directory or a symbolic link).\n     *\n     * A file with the same name already exists, but there is more\n     * than one hard link to that file.\n     *\n     * The file system where the core dump file would be created is full;\n     * or has run out of inodes; or is mounted read-only;\n     * or the user has reached their quota for the file system.\n     *\n     * The RLIMIT_CORE or RLIMIT_FSIZE resource limits for the process\n     * are set to zero.\n     * [we check RLIMIT_CORE, but how can we check RLIMIT_FSIZE?]\n     *\n     * The binary being executed by the process does not have\n     * read permission enabled. [how we can check it here?]\n     *\n     * The process is executing a set-user-ID (set-group-ID) program\n     * that is owned by a user (group) other than the real\n     * user (group) ID of the process. [TODO?]\n     * (However, see the description of the prctl(2) PR_SET_DUMPABLE operation,\n     * and the description of the /proc/sys/fs/suid_dumpable file in proc(5).)\n     */\n    struct stat sb;\n    errno = 0;\n    /* Do not O_TRUNC: if later checks fail, we do not want to have file already modified here */\n    int user_core_fd = open(core_basename, O_WRONLY | O_CREAT | O_NOFOLLOW, 0600); /* kernel makes 0600 too */\n    xsetegid(0);\n    xseteuid(0);\n    if (user_core_fd < 0\n     || fstat(user_core_fd, &sb) != 0\n     || !S_ISREG(sb.st_mode)\n     || sb.st_nlink != 1\n    /* kernel internal dumper checks this too: if (inode->i_uid != current->fsuid) <fail>, need to mimic? */\n    ) {\n        if (user_core_fd < 0)\n            perror_msg(\"Can't open '%s'\", full_core_basename);\n        else\n            perror_msg(\"'%s' is not a regular file with link count 1\", full_core_basename);\n        return -1;\n    }\n    if (ftruncate(user_core_fd, 0) != 0) {\n        /* perror first, otherwise unlink may trash errno */\n        perror_msg(\"Can't truncate '%s' to size 0\", full_core_basename);\n        unlink(core_basename);\n        return -1;\n    }\n\n    return user_core_fd;\n}\n\nstatic bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n\n    unsigned fd = 0;\n    while (fd <= 99999) /* paranoia check */\n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            /* in case the line is not terminated, terminate it */\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n\n    fclose(fp);\n    return true;\n}\n\n/* Like xopen, but on error, unlocks and deletes dd and user core */\nstatic int create_or_die(const char *filename)\n{\n    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_DUMP_DIR_MODE);\n    if (fd >= 0)\n    {\n        IGNORE_RESULT(fchown(fd, dd->dd_uid, dd->dd_gid));\n        return fd;\n    }\n\n    int sv_errno = errno;\n    if (dd)\n        dd_delete(dd);\n    if (user_core_fd >= 0)\n    {\n        xchdir(user_pwd);\n        unlink(core_basename);\n    }\n    errno = sv_errno;\n    perror_msg_and_die(\"Can't open '%s'\", filename);\n}\n\nint main(int argc, char** argv)\n{\n    /* Kernel starts us with all fd's closed.\n     * But it's dangerous:\n     * fprintf(stderr) can dump messages into random fds, etc.\n     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.\n     */\n    int fd = xopen(\"/dev/null\", O_RDWR);\n    while (fd < 2)\n\tfd = xdup(fd);\n    if (fd > 2)\n\tclose(fd);\n\n    if (argc < 8)\n    {\n        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %h */\n        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]*/\n        error_msg_and_die(\"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]\", argv[0]);\n    }\n\n    /* Not needed on 2.6.30.\n     * At least 2.6.18 has a bug where\n     * argv[1] = \"SIGNO CORE_SIZE_LIMIT PID ...\"\n     * argv[2] = \"CORE_SIZE_LIMIT PID ...\"\n     * and so on. Fixing it:\n     */\n    if (strchr(argv[1], ' '))\n    {\n        int i;\n        for (i = 1; argv[i]; i++)\n        {\n            strchrnul(argv[i], ' ')[0] = '\\0';\n        }\n    }\n\n    logmode = LOGMODE_JOURNAL;\n\n    /* Parse abrt.conf */\n    load_abrt_conf();\n    /* ... and plugins/CCpp.conf */\n    bool setting_MakeCompatCore;\n    bool setting_SaveBinaryImage;\n    {\n        map_string_t *settings = new_map_string();\n        load_abrt_plugin_conf_file(\"CCpp.conf\", settings);\n        const char *value;\n        value = get_map_string_item_or_NULL(settings, \"MakeCompatCore\");\n        setting_MakeCompatCore = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveBinaryImage\");\n        setting_SaveBinaryImage = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"VerboseLog\");\n        if (value)\n            g_verbose = xatoi_positive(value);\n        free_map_string(settings);\n    }\n\n    errno = 0;\n    const char* signal_str = argv[1];\n    int signal_no = xatoi_positive(signal_str);\n    off_t ulimit_c = strtoull(argv[2], NULL, 10);\n    if (ulimit_c < 0) /* unlimited? */\n    {\n        /* set to max possible >0 value */\n        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));\n    }\n    const char *pid_str = argv[3];\n    pid_t pid = xatoi_positive(argv[3]);\n    uid_t uid = xatoi_positive(argv[4]);\n    if (errno || pid <= 0)\n    {\n        perror_msg_and_die(\"PID '%s' or limit '%s' is bogus\", argv[3], argv[2]);\n    }\n\n    {\n        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN\"/abrt/saved_core_pattern\");\n        /* If we have a saved pattern and it's not a \"|PROG ARGS\" thing... */\n        if (s && s[0] != '|')\n            core_basename = s;\n        else\n            free(s);\n    }\n\n    struct utsname uts;\n    if (!argv[8]) /* no HOSTNAME? */\n    {\n        uname(&uts);\n        argv[8] = uts.nodename;\n    }\n\n    char path[PATH_MAX];\n\n    int src_fd_binary = -1;\n    char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);\n    if (executable && strstr(executable, \"/abrt-hook-ccpp\"))\n    {\n        error_msg_and_die(\"PID %lu is '%s', not dumping it to avoid recursion\",\n                        (long)pid, executable);\n    }\n\n    user_pwd = get_cwd(pid); /* may be NULL on error */\n    log_notice(\"user_pwd:'%s'\", user_pwd);\n\n    sprintf(path, \"/proc/%lu/status\", (long)pid);\n    proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);\n\n    uid_t fsuid = uid;\n    uid_t tmp_fsuid = get_fsuid();\n    int suid_policy = dump_suid_policy();\n    if (tmp_fsuid != uid)\n    {\n        /* use root for suided apps unless it's explicitly set to UNSAFE */\n        fsuid = 0;\n        if (suid_policy == DUMP_SUID_UNSAFE)\n        {\n            fsuid = tmp_fsuid;\n        }\n    }\n\n    /* Open a fd to compat coredump, if requested and is possible */\n    if (setting_MakeCompatCore && ulimit_c != 0)\n        /* note: checks \"user_pwd == NULL\" inside; updates core_basename */\n        user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);\n\n    if (executable == NULL)\n    {\n        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */\n        error_msg(\"Can't read /proc/%lu/exe link\", (long)pid);\n        goto create_user_core;\n    }\n\n    const char *signame = NULL;\n    switch (signal_no)\n    {\n        case SIGILL : signame = \"ILL\" ; break;\n        case SIGFPE : signame = \"FPE\" ; break;\n        case SIGSEGV: signame = \"SEGV\"; break;\n        case SIGBUS : signame = \"BUS\" ; break; //Bus error (bad memory access)\n        case SIGABRT: signame = \"ABRT\"; break; //usually when abort() was called\n    // We have real-world reports from users who see buggy programs\n    // dying with SIGTRAP, uncommented it too:\n        case SIGTRAP: signame = \"TRAP\"; break; //Trace/breakpoint trap\n    // These usually aren't caused by bugs:\n      //case SIGQUIT: signame = \"QUIT\"; break; //Quit from keyboard\n      //case SIGSYS : signame = \"SYS\" ; break; //Bad argument to routine (SVr4)\n      //case SIGXCPU: signame = \"XCPU\"; break; //CPU time limit exceeded (4.2BSD)\n      //case SIGXFSZ: signame = \"XFSZ\"; break; //File size limit exceeded (4.2BSD)\n        default: goto create_user_core; // not a signal we care about\n    }\n\n    if (!daemon_is_ok())\n    {\n        /* not an error, exit with exit code 0 */\n        log(\"abrtd is not running. If it crashed, \"\n            \"/proc/sys/kernel/core_pattern contains a stale value, \"\n            \"consider resetting it to 'core'\"\n        );\n        goto create_user_core;\n    }\n\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        /* If free space is less than 1/4 of MaxCrashReportsSize... */\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            goto create_user_core;\n    }\n\n    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes\n     * if they happen too often. Else, write new marker value.\n     */\n    snprintf(path, sizeof(path), \"%s/last-ccpp\", g_settings_dump_location);\n    if (check_recent_crash_file(path, executable))\n    {\n        /* It is a repeating crash */\n        goto create_user_core;\n    }\n\n    const char *last_slash = strrchr(executable, '/');\n    if (last_slash && strncmp(++last_slash, \"abrt\", 4) == 0)\n    {\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n        snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash);\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        return 0;\n    }\n\n    unsigned path_len = snprintf(path, sizeof(path), \"%s/ccpp-%s-%lu.new\",\n            g_settings_dump_location, iso_date_string(NULL), (long)pid);\n    if (path_len >= (sizeof(path) - sizeof(\"/\"FILENAME_COREDUMP)))\n    {\n        goto create_user_core;\n    }\n\n    /* use fsuid instead of uid, so we don't expose any sensitive\n     * information of suided app in /var/tmp/abrt\n     */\n    dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);\n    if (dd)\n    {\n        char *rootdir = get_rootdir(pid);\n\n        dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, \"/\") != 0) ? rootdir : NULL);\n\n        char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];\n        int source_base_ofs = sprintf(source_filename, \"/proc/%lu/smaps\", (long)pid);\n        source_base_ofs -= strlen(\"smaps\");\n        char *dest_filename = concat_path_file(dd->dd_dirname, \"also_somewhat_longish_name\");\n        char *dest_base = strrchr(dest_filename, '/') + 1;\n\n        // Disabled for now: /proc/PID/smaps tends to be BIG,\n        // and not much more informative than /proc/PID/maps:\n        //copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(source_filename + source_base_ofs, \"maps\");\n        strcpy(dest_base, FILENAME_MAPS);\n        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(source_filename + source_base_ofs, \"limits\");\n        strcpy(dest_base, FILENAME_LIMITS);\n        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(source_filename + source_base_ofs, \"cgroup\");\n        strcpy(dest_base, FILENAME_CGROUP);\n        copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);\n\n        strcpy(dest_base, FILENAME_OPEN_FDS);\n        dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);\n\n        free(dest_filename);\n\n        dd_save_text(dd, FILENAME_ANALYZER, \"CCpp\");\n        dd_save_text(dd, FILENAME_TYPE, \"CCpp\");\n        dd_save_text(dd, FILENAME_EXECUTABLE, executable);\n        dd_save_text(dd, FILENAME_PID, pid_str);\n        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);\n        if (user_pwd)\n            dd_save_text(dd, FILENAME_PWD, user_pwd);\n        if (rootdir)\n        {\n            if (strcmp(rootdir, \"/\") != 0)\n                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);\n        }\n\n        char *reason = xasprintf(\"%s killed by SIG%s\",\n                                 last_slash, signame ? signame : signal_str);\n        dd_save_text(dd, FILENAME_REASON, reason);\n        free(reason);\n\n        char *cmdline = get_cmdline(pid);\n        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : \"\");\n        free(cmdline);\n\n        char *environ = get_environ(pid);\n        dd_save_text(dd, FILENAME_ENVIRON, environ ? : \"\");\n        free(environ);\n\n        char *fips_enabled = xmalloc_fopen_fgetline_fclose(\"/proc/sys/crypto/fips_enabled\");\n        if (fips_enabled)\n        {\n            if (strcmp(fips_enabled, \"0\") != 0)\n                dd_save_text(dd, \"fips_enabled\", fips_enabled);\n            free(fips_enabled);\n        }\n\n        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n        if (src_fd_binary > 0)\n        {\n            strcpy(path + path_len, \"/\"FILENAME_BINARY);\n            int dst_fd = create_or_die(path);\n            off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);\n            if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)\n            {\n                dd_delete(dd);\n                error_msg_and_die(\"Error saving '%s'\", path);\n            }\n            close(src_fd_binary);\n        }\n\n        strcpy(path + path_len, \"/\"FILENAME_COREDUMP);\n        int abrt_core_fd = create_or_die(path);\n\n        /* We write both coredumps at once.\n         * We can't write user coredump first, since it might be truncated\n         * and thus can't be copied and used as abrt coredump;\n         * and if we write abrt coredump first and then copy it as user one,\n         * then we have a race when process exits but coredump does not exist yet:\n         * $ echo -e '#include<signal.h>\\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -\n         * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*\n         * 21631 Segmentation fault (core dumped) ./test\n         * ls: cannot access core*: No such file or directory <=== BAD\n         */\n        off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);\n        if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)\n        {\n            unlink(path);\n            dd_delete(dd);\n            if (user_core_fd >= 0)\n            {\n                xchdir(user_pwd);\n                unlink(core_basename);\n            }\n            /* copyfd_sparse logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error writing '%s'\", path);\n        }\n        if (user_core_fd >= 0\n            /* error writing user coredump? */\n         && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0\n            /* user coredump is too big? */\n            || (ulimit_c == 0 /* paranoia */ || core_size > ulimit_c)\n            )\n        ) {\n            /* nuke it (silently) */\n            xchdir(user_pwd);\n            unlink(core_basename);\n        }\n\n/* Because of #1211835 and #1126850 */\n#if 0\n        /* Save JVM crash log if it exists. (JVM's coredump per se\n         * is nearly useless for JVM developers)\n         */\n        {\n            char *java_log = xasprintf(\"/tmp/jvm-%lu/hs_error.log\", (long)pid);\n            int src_fd = open(java_log, O_RDONLY);\n            free(java_log);\n\n            /* If we couldn't open the error log in /tmp directory we can try to\n             * read the log from the current directory. It may produce AVC, it\n             * may produce some error log but all these are expected.\n             */\n            if (src_fd < 0)\n            {\n                java_log = xasprintf(\"%s/hs_err_pid%lu.log\", user_pwd, (long)pid);\n                src_fd = open(java_log, O_RDONLY);\n                free(java_log);\n            }\n\n            if (src_fd >= 0)\n            {\n                strcpy(path + path_len, \"/hs_err.log\");\n                int dst_fd = create_or_die(path);\n                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);\n                if (close(dst_fd) != 0 || sz < 0)\n                {\n                    dd_delete(dd);\n                    error_msg_and_die(\"Error saving '%s'\", path);\n                }\n                close(src_fd);\n            }\n        }\n#endif\n\n        /* We close dumpdir before we start catering for crash storm case.\n         * Otherwise, delete_dump_dir's from other concurrent\n         * CCpp's won't be able to delete our dump (their delete_dump_dir\n         * will wait for us), and we won't be able to delete their dumps.\n         * Classic deadlock.\n         */\n        dd_close(dd);\n        path[path_len] = '\\0'; /* path now contains only directory name */\n        char *newpath = xstrndup(path, path_len - (sizeof(\".new\")-1));\n        if (rename(path, newpath) == 0)\n            strcpy(path, newpath);\n        free(newpath);\n\n        log(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n\n        notify_new_path(path);\n\n        /* rhbz#539551: \"abrt going crazy when crashing process is respawned\" */\n        if (g_settings_nMaxCrashReportsSize > 0)\n        {\n            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming\n             * kicks in first, and we don't \"fight\" with it:\n             */\n            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;\n            maxsize |= 63;\n            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);\n        }\n\n        free(rootdir);\n        return 0;\n    }\n\n    /* We didn't create abrt dump, but may need to create compat coredump */\n create_user_core:\n    if (user_core_fd >= 0)\n    {\n        off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);\n        if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)\n        {\n            /* perror first, otherwise unlink may trash errno */\n            perror_msg(\"Error writing '%s'\", full_core_basename);\n            xchdir(user_pwd);\n            unlink(core_basename);\n            return 1;\n        }\n        if (ulimit_c == 0 || core_size > ulimit_c)\n        {\n            xchdir(user_pwd);\n            unlink(core_basename);\n            return 1;\n        }\n        log(\"Saved core dump of pid %lu to %s (%llu bytes)\", (long)pid, full_core_basename, (long long)core_size);\n    }\n\n    return 0;\n}\n"], "filenames": ["src/hooks/abrt-hook-ccpp.c"], "buggy_code_start_loc": [797], "buggy_code_end_loc": [829], "fixing_code_start_loc": [798], "fixing_code_end_loc": [833], "type": "CWE-59", "message": "Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm.", "other": {"cve": {"id": "CVE-2015-3315", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-26T15:29:00.427", "lastModified": "2018-02-19T02:29:00.263", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."}, {"lang": "es", "value": "Automatic Bug Reporting Tool (ABRT) permite a usuarios locales leer, cambiar la propiedad o realizar otras acciones no especificada en archivos arbitrarios mediante symlink attack en (1) / var / tmp / abrt / * / maps, (2) / tmp /jvm-*/hs_error.log, (3) / proc / * / exe, (4) / etc / os-release en un chroot, o (5) un directorio ra\u00edz no especificado relacionado con librpm."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:automatic_bug_reporting_tool:-:*:*:*:*:*:*:*", "matchCriteriaId": "A396CA2B-75FF-4BEE-8C0A-89B7C030D1E5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "7071F0C7-E43E-4F2E-9FEB-E8FB3DEA4749"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "0E8CD4EF-DC90-40BB-A721-6EC087507906"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2015-1083.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1210.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2015/04/14/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/04/16/12", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/75117", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1211835", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/abrt/abrt/commit/17cb66b13997b0159b4253b3f5722db79f476d68", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/80408e9e24a1c10f85fd969e1853e0f192157f92", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/d6e2f6f128cef4c21cb80941ae674c9842681aa7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/44097/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/abrt/abrt/commit/17cb66b13997b0159b4253b3f5722db79f476d68"}}