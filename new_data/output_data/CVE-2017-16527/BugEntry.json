{"buggy_code": ["/*\n *   (Tentative) USB Audio Driver for ALSA\n *\n *   Mixer control part\n *\n *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>\n *\n *   Many codes borrowed from audio.c by\n *\t    Alan Cox (alan@lxorguk.ukuu.org.uk)\n *\t    Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n/*\n * TODOs, for both the mixer and the streaming interfaces:\n *\n *  - support for UAC2 effect units\n *  - support for graphical equalizers\n *  - RANGE and MEM set commands (UAC2)\n *  - RANGE and MEM interrupt dispatchers (UAC2)\n *  - audio channel clustering (UAC2)\n *  - audio sample rate converter units (UAC2)\n *  - proper handling of clock multipliers (UAC2)\n *  - dispatch clock change notifications (UAC2)\n *  \t- stop PCM streams which use a clock that became invalid\n *  \t- stop PCM streams which use a clock selector that has changed\n *  \t- parse available sample rates again when clock sources changed\n */\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/hwdep.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"helper.h\"\n#include \"mixer_quirks.h\"\n#include \"power.h\"\n\n#define MAX_ID_ELEMS\t256\n\nstruct usb_audio_term {\n\tint id;\n\tint type;\n\tint channels;\n\tunsigned int chconfig;\n\tint name;\n};\n\nstruct usbmix_name_map;\n\nstruct mixer_build {\n\tstruct snd_usb_audio *chip;\n\tstruct usb_mixer_interface *mixer;\n\tunsigned char *buffer;\n\tunsigned int buflen;\n\tDECLARE_BITMAP(unitbitmap, MAX_ID_ELEMS);\n\tstruct usb_audio_term oterm;\n\tconst struct usbmix_name_map *map;\n\tconst struct usbmix_selector_map *selector_map;\n};\n\n/*E-mu 0202/0404/0204 eXtension Unit(XU) control*/\nenum {\n\tUSB_XU_CLOCK_RATE \t\t= 0xe301,\n\tUSB_XU_CLOCK_SOURCE\t\t= 0xe302,\n\tUSB_XU_DIGITAL_IO_STATUS\t= 0xe303,\n\tUSB_XU_DEVICE_OPTIONS\t\t= 0xe304,\n\tUSB_XU_DIRECT_MONITORING\t= 0xe305,\n\tUSB_XU_METERING\t\t\t= 0xe306\n};\nenum {\n\tUSB_XU_CLOCK_SOURCE_SELECTOR = 0x02,\t/* clock source*/\n\tUSB_XU_CLOCK_RATE_SELECTOR = 0x03,\t/* clock rate */\n\tUSB_XU_DIGITAL_FORMAT_SELECTOR = 0x01,\t/* the spdif format */\n\tUSB_XU_SOFT_LIMIT_SELECTOR = 0x03\t/* soft limiter */\n};\n\n/*\n * manual mapping of mixer names\n * if the mixer topology is too complicated and the parsed names are\n * ambiguous, add the entries in usbmixer_maps.c.\n */\n#include \"mixer_maps.c\"\n\nstatic const struct usbmix_name_map *\nfind_map(struct mixer_build *state, int unitid, int control)\n{\n\tconst struct usbmix_name_map *p = state->map;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tfor (p = state->map; p->id; p++) {\n\t\tif (p->id == unitid &&\n\t\t    (!control || !p->control || control == p->control))\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n/* get the mapped name if the unit matches */\nstatic int\ncheck_mapped_name(const struct usbmix_name_map *p, char *buf, int buflen)\n{\n\tif (!p || !p->name)\n\t\treturn 0;\n\n\tbuflen--;\n\treturn strlcpy(buf, p->name, buflen);\n}\n\n/* ignore the error value if ignore_ctl_error flag is set */\n#define filter_error(cval, err) \\\n\t((cval)->head.mixer->ignore_ctl_error ? 0 : (err))\n\n/* check whether the control should be ignored */\nstatic inline int\ncheck_ignored_ctl(const struct usbmix_name_map *p)\n{\n\tif (!p || p->name || p->dB)\n\t\treturn 0;\n\treturn 1;\n}\n\n/* dB mapping */\nstatic inline void check_mapped_dB(const struct usbmix_name_map *p,\n\t\t\t\t   struct usb_mixer_elem_info *cval)\n{\n\tif (p && p->dB) {\n\t\tcval->dBmin = p->dB->min;\n\t\tcval->dBmax = p->dB->max;\n\t\tcval->initialized = 1;\n\t}\n}\n\n/* get the mapped selector source name */\nstatic int check_mapped_selector_name(struct mixer_build *state, int unitid,\n\t\t\t\t      int index, char *buf, int buflen)\n{\n\tconst struct usbmix_selector_map *p;\n\n\tif (!state->selector_map)\n\t\treturn 0;\n\tfor (p = state->selector_map; p->id; p++) {\n\t\tif (p->id == unitid && index < p->count)\n\t\t\treturn strlcpy(buf, p->names[index], buflen);\n\t}\n\treturn 0;\n}\n\n/*\n * find an audio control unit with the given unit id\n */\nstatic void *find_audio_control_unit(struct mixer_build *state,\n\t\t\t\t     unsigned char unit)\n{\n\t/* we just parse the header */\n\tstruct uac_feature_unit_descriptor *hdr = NULL;\n\n\twhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\n\t\t\t\t\tUSB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (hdr->bLength >= 4 &&\n\t\t    hdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\n\t\t    hdr->bDescriptorSubtype <= UAC2_SAMPLE_RATE_CONVERTER &&\n\t\t    hdr->bUnitID == unit)\n\t\t\treturn hdr;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * copy a string with the given id\n */\nstatic int snd_usb_copy_string_desc(struct mixer_build *state,\n\t\t\t\t    int index, char *buf, int maxlen)\n{\n\tint len = usb_string(state->chip->dev, index, buf, maxlen - 1);\n\tbuf[len] = 0;\n\treturn len;\n}\n\n/*\n * convert from the byte/word on usb descriptor to the zero-based integer\n */\nstatic int convert_signed_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_U8:\n\t\tval &= 0xff;\n\t\tbreak;\n\tcase USB_MIXER_S8:\n\t\tval &= 0xff;\n\t\tif (val >= 0x80)\n\t\t\tval -= 0x100;\n\t\tbreak;\n\tcase USB_MIXER_U16:\n\t\tval &= 0xffff;\n\t\tbreak;\n\tcase USB_MIXER_S16:\n\t\tval &= 0xffff;\n\t\tif (val >= 0x8000)\n\t\t\tval -= 0x10000;\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n/*\n * convert from the zero-based int to the byte/word for usb descriptor\n */\nstatic int convert_bytes_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_S8:\n\tcase USB_MIXER_U8:\n\t\treturn val & 0xff;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn val & 0xffff;\n\t}\n\treturn 0; /* not reached */\n}\n\nstatic int get_relative_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tif (!cval->res)\n\t\tcval->res = 1;\n\tif (val < cval->min)\n\t\treturn 0;\n\telse if (val >= cval->max)\n\t\treturn (cval->max - cval->min + cval->res - 1) / cval->res;\n\telse\n\t\treturn (val - cval->min) / cval->res;\n}\n\nstatic int get_abs_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tif (val < 0)\n\t\treturn cval->min;\n\tif (!cval->res)\n\t\tcval->res = 1;\n\tval *= cval->res;\n\tval += cval->min;\n\tif (val > cval->max)\n\t\treturn cval->max;\n\treturn val;\n}\n\nstatic int uac2_ctl_value_size(int val_type)\n{\n\tswitch (val_type) {\n\tcase USB_MIXER_S32:\n\tcase USB_MIXER_U32:\n\t\treturn 4;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0; /* unreachable */\n}\n\n\n/*\n * retrieve a mixer value\n */\n\nstatic int get_ctl_value_v1(struct usb_mixer_elem_info *cval, int request,\n\t\t\t    int validx, int *value_ret)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[2];\n\tint val_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\n\tint timeout = 10;\n\tint idx = 0, err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn -EIO;\n\n\twhile (timeout-- > 0) {\n\t\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\t\terr = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), request,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t\t      validx, idx, buf, val_len);\n\t\tif (err >= val_len) {\n\t\t\t*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(buf, val_len));\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (err == -ETIMEDOUT) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tusb_audio_dbg(chip,\n\t\t\"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\trequest, validx, idx, cval->val_type);\n\terr = -EINVAL;\n\n out:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request,\n\t\t\t    int validx, int *value_ret)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[4 + 3 * sizeof(__u32)]; /* enough space for one range */\n\tunsigned char *val;\n\tint idx = 0, ret, size;\n\t__u8 bRequest;\n\n\tif (request == UAC_GET_CUR) {\n\t\tbRequest = UAC2_CS_CUR;\n\t\tsize = uac2_ctl_value_size(cval->val_type);\n\t} else {\n\t\tbRequest = UAC2_CS_RANGE;\n\t\tsize = sizeof(buf);\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tret = snd_usb_lock_shutdown(chip) ? -EIO : 0;\n\tif (ret)\n\t\tgoto error;\n\n\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      validx, idx, buf, size);\n\tsnd_usb_unlock_shutdown(chip);\n\n\tif (ret < 0) {\nerror:\n\t\tusb_audio_err(chip,\n\t\t\t\"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\t\trequest, validx, idx, cval->val_type);\n\t\treturn ret;\n\t}\n\n\t/* FIXME: how should we handle multiple triplets here? */\n\n\tswitch (request) {\n\tcase UAC_GET_CUR:\n\t\tval = buf;\n\t\tbreak;\n\tcase UAC_GET_MIN:\n\t\tval = buf + sizeof(__u16);\n\t\tbreak;\n\tcase UAC_GET_MAX:\n\t\tval = buf + sizeof(__u16) * 2;\n\t\tbreak;\n\tcase UAC_GET_RES:\n\t\tval = buf + sizeof(__u16) * 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(val, sizeof(__u16)));\n\n\treturn 0;\n}\n\nstatic int get_ctl_value(struct usb_mixer_elem_info *cval, int request,\n\t\t\t int validx, int *value_ret)\n{\n\tvalidx += cval->idx_off;\n\n\treturn (cval->head.mixer->protocol == UAC_VERSION_1) ?\n\t\tget_ctl_value_v1(cval, request, validx, value_ret) :\n\t\tget_ctl_value_v2(cval, request, validx, value_ret);\n}\n\nstatic int get_cur_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int validx, int *value)\n{\n\treturn get_ctl_value(cval, UAC_GET_CUR, validx, value);\n}\n\n/* channel = 0: master, 1 = first channel */\nstatic inline int get_cur_mix_raw(struct usb_mixer_elem_info *cval,\n\t\t\t\t  int channel, int *value)\n{\n\treturn get_ctl_value(cval, UAC_GET_CUR,\n\t\t\t     (cval->control << 8) | channel,\n\t\t\t     value);\n}\n\nint snd_usb_get_cur_mix_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int channel, int index, int *value)\n{\n\tint err;\n\n\tif (cval->cached & (1 << channel)) {\n\t\t*value = cval->cache_val[index];\n\t\treturn 0;\n\t}\n\terr = get_cur_mix_raw(cval, channel, value);\n\tif (err < 0) {\n\t\tif (!cval->head.mixer->ignore_ctl_error)\n\t\t\tusb_audio_dbg(cval->head.mixer->chip,\n\t\t\t\t\"cannot get current value for control %d ch %d: err = %d\\n\",\n\t\t\t\t      cval->control, channel, err);\n\t\treturn err;\n\t}\n\tcval->cached |= 1 << channel;\n\tcval->cache_val[index] = *value;\n\treturn 0;\n}\n\n/*\n * set a mixer value\n */\n\nint snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t\tint request, int validx, int value_set)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[4];\n\tint idx = 0, val_len, err, timeout = 10;\n\n\tvalidx += cval->idx_off;\n\n\tif (cval->head.mixer->protocol == UAC_VERSION_1) {\n\t\tval_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\n\t} else { /* UAC_VERSION_2 */\n\t\tval_len = uac2_ctl_value_size(cval->val_type);\n\n\t\t/* FIXME */\n\t\tif (request != UAC_SET_CUR) {\n\t\t\tusb_audio_dbg(chip, \"RANGE setting not yet supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trequest = UAC2_CS_CUR;\n\t}\n\n\tvalue_set = convert_bytes_value(cval, value_set);\n\tbuf[0] = value_set & 0xff;\n\tbuf[1] = (value_set >> 8) & 0xff;\n\tbuf[2] = (value_set >> 16) & 0xff;\n\tbuf[3] = (value_set >> 24) & 0xff;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn -EIO;\n\n\twhile (timeout-- > 0) {\n\t\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\t\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t\t      usb_sndctrlpipe(chip->dev, 0), request,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t\t      validx, idx, buf, val_len);\n\t\tif (err >= 0) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (err == -ETIMEDOUT) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tusb_audio_dbg(chip, \"cannot set ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d, data = %#x/%#x\\n\",\n\t\t      request, validx, idx, cval->val_type, buf[0], buf[1]);\n\terr = -EINVAL;\n\n out:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int set_cur_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int validx, int value)\n{\n\treturn snd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR, validx, value);\n}\n\nint snd_usb_set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,\n\t\t\t     int index, int value)\n{\n\tint err;\n\tunsigned int read_only = (channel == 0) ?\n\t\tcval->master_readonly :\n\t\tcval->ch_readonly & (1 << (channel - 1));\n\n\tif (read_only) {\n\t\tusb_audio_dbg(cval->head.mixer->chip,\n\t\t\t      \"%s(): channel %d of control %d is read_only\\n\",\n\t\t\t    __func__, channel, cval->control);\n\t\treturn 0;\n\t}\n\n\terr = snd_usb_mixer_set_ctl_value(cval,\n\t\t\t\t\t  UAC_SET_CUR, (cval->control << 8) | channel,\n\t\t\t\t\t  value);\n\tif (err < 0)\n\t\treturn err;\n\tcval->cached |= 1 << channel;\n\tcval->cache_val[index] = value;\n\treturn 0;\n}\n\n/*\n * TLV callback for mixer volume controls\n */\nint snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t unsigned int size, unsigned int __user *_tlv)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tDECLARE_TLV_DB_MINMAX(scale, 0, 0);\n\n\tif (size < sizeof(scale))\n\t\treturn -ENOMEM;\n\tif (cval->min_mute)\n\t\tscale[0] = SNDRV_CTL_TLVT_DB_MINMAX_MUTE;\n\tscale[2] = cval->dBmin;\n\tscale[3] = cval->dBmax;\n\tif (copy_to_user(_tlv, scale, sizeof(scale)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * parser routines begin here...\n */\n\nstatic int parse_audio_unit(struct mixer_build *state, int unitid);\n\n\n/*\n * check if the input/output channel routing is enabled on the given bitmap.\n * used for mixer unit parser\n */\nstatic int check_matrix_bitmap(unsigned char *bmap,\n\t\t\t       int ich, int och, int num_outs)\n{\n\tint idx = ich * num_outs + och;\n\treturn bmap[idx >> 3] & (0x80 >> (idx & 7));\n}\n\n/*\n * add an alsa control element\n * search and increment the index until an empty slot is found.\n *\n * if failed, give up and free the control instance.\n */\n\nint snd_usb_mixer_add_control(struct usb_mixer_elem_list *list,\n\t\t\t      struct snd_kcontrol *kctl)\n{\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint err;\n\n\twhile (snd_ctl_find_id(mixer->chip->card, &kctl->id))\n\t\tkctl->id.index++;\n\tif ((err = snd_ctl_add(mixer->chip->card, kctl)) < 0) {\n\t\tusb_audio_dbg(mixer->chip, \"cannot add control (err = %d)\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\tlist->kctl = kctl;\n\tlist->next_id_elem = mixer->id_elems[list->id];\n\tmixer->id_elems[list->id] = list;\n\treturn 0;\n}\n\n/*\n * get a terminal name string\n */\n\nstatic struct iterm_name_combo {\n\tint type;\n\tchar *name;\n} iterm_names[] = {\n\t{ 0x0300, \"Output\" },\n\t{ 0x0301, \"Speaker\" },\n\t{ 0x0302, \"Headphone\" },\n\t{ 0x0303, \"HMD Audio\" },\n\t{ 0x0304, \"Desktop Speaker\" },\n\t{ 0x0305, \"Room Speaker\" },\n\t{ 0x0306, \"Com Speaker\" },\n\t{ 0x0307, \"LFE\" },\n\t{ 0x0600, \"External In\" },\n\t{ 0x0601, \"Analog In\" },\n\t{ 0x0602, \"Digital In\" },\n\t{ 0x0603, \"Line\" },\n\t{ 0x0604, \"Legacy In\" },\n\t{ 0x0605, \"IEC958 In\" },\n\t{ 0x0606, \"1394 DA Stream\" },\n\t{ 0x0607, \"1394 DV Stream\" },\n\t{ 0x0700, \"Embedded\" },\n\t{ 0x0701, \"Noise Source\" },\n\t{ 0x0702, \"Equalization Noise\" },\n\t{ 0x0703, \"CD\" },\n\t{ 0x0704, \"DAT\" },\n\t{ 0x0705, \"DCC\" },\n\t{ 0x0706, \"MiniDisk\" },\n\t{ 0x0707, \"Analog Tape\" },\n\t{ 0x0708, \"Phonograph\" },\n\t{ 0x0709, \"VCR Audio\" },\n\t{ 0x070a, \"Video Disk Audio\" },\n\t{ 0x070b, \"DVD Audio\" },\n\t{ 0x070c, \"TV Tuner Audio\" },\n\t{ 0x070d, \"Satellite Rec Audio\" },\n\t{ 0x070e, \"Cable Tuner Audio\" },\n\t{ 0x070f, \"DSS Audio\" },\n\t{ 0x0710, \"Radio Receiver\" },\n\t{ 0x0711, \"Radio Transmitter\" },\n\t{ 0x0712, \"Multi-Track Recorder\" },\n\t{ 0x0713, \"Synthesizer\" },\n\t{ 0 },\n};\n\nstatic int get_term_name(struct mixer_build *state, struct usb_audio_term *iterm,\n\t\t\t unsigned char *name, int maxlen, int term_only)\n{\n\tstruct iterm_name_combo *names;\n\n\tif (iterm->name)\n\t\treturn snd_usb_copy_string_desc(state, iterm->name,\n\t\t\t\t\t\tname, maxlen);\n\n\t/* virtual type - not a real terminal */\n\tif (iterm->type >> 16) {\n\t\tif (term_only)\n\t\t\treturn 0;\n\t\tswitch (iterm->type >> 16) {\n\t\tcase UAC_SELECTOR_UNIT:\n\t\t\tstrcpy(name, \"Selector\");\n\t\t\treturn 8;\n\t\tcase UAC1_PROCESSING_UNIT:\n\t\t\tstrcpy(name, \"Process Unit\");\n\t\t\treturn 12;\n\t\tcase UAC1_EXTENSION_UNIT:\n\t\t\tstrcpy(name, \"Ext Unit\");\n\t\t\treturn 8;\n\t\tcase UAC_MIXER_UNIT:\n\t\t\tstrcpy(name, \"Mixer\");\n\t\t\treturn 5;\n\t\tdefault:\n\t\t\treturn sprintf(name, \"Unit %d\", iterm->id);\n\t\t}\n\t}\n\n\tswitch (iterm->type & 0xff00) {\n\tcase 0x0100:\n\t\tstrcpy(name, \"PCM\");\n\t\treturn 3;\n\tcase 0x0200:\n\t\tstrcpy(name, \"Mic\");\n\t\treturn 3;\n\tcase 0x0400:\n\t\tstrcpy(name, \"Headset\");\n\t\treturn 7;\n\tcase 0x0500:\n\t\tstrcpy(name, \"Phone\");\n\t\treturn 5;\n\t}\n\n\tfor (names = iterm_names; names->type; names++) {\n\t\tif (names->type == iterm->type) {\n\t\t\tstrcpy(name, names->name);\n\t\t\treturn strlen(names->name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * parse the source unit recursively until it reaches to a terminal\n * or a branched unit.\n */\nstatic int check_input_term(struct mixer_build *state, int id,\n\t\t\t    struct usb_audio_term *term)\n{\n\tint err;\n\tvoid *p1;\n\n\tmemset(term, 0, sizeof(*term));\n\twhile ((p1 = find_audio_control_unit(state, id)) != NULL) {\n\t\tunsigned char *hdr = p1;\n\t\tterm->id = id;\n\t\tswitch (hdr[2]) {\n\t\tcase UAC_INPUT_TERMINAL:\n\t\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\t\tstruct uac_input_terminal_descriptor *d = p1;\n\t\t\t\tterm->type = le16_to_cpu(d->wTerminalType);\n\t\t\t\tterm->channels = d->bNrChannels;\n\t\t\t\tterm->chconfig = le16_to_cpu(d->wChannelConfig);\n\t\t\t\tterm->name = d->iTerminal;\n\t\t\t} else { /* UAC_VERSION_2 */\n\t\t\t\tstruct uac2_input_terminal_descriptor *d = p1;\n\n\t\t\t\t/* call recursively to verify that the\n\t\t\t\t * referenced clock entity is valid */\n\t\t\t\terr = check_input_term(state, d->bCSourceID, term);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* save input term properties after recursion,\n\t\t\t\t * to ensure they are not overriden by the\n\t\t\t\t * recursion calls */\n\t\t\t\tterm->id = id;\n\t\t\t\tterm->type = le16_to_cpu(d->wTerminalType);\n\t\t\t\tterm->channels = d->bNrChannels;\n\t\t\t\tterm->chconfig = le32_to_cpu(d->bmChannelConfig);\n\t\t\t\tterm->name = d->iTerminal;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase UAC_FEATURE_UNIT: {\n\t\t\t/* the header is the same for v1 and v2 */\n\t\t\tstruct uac_feature_unit_descriptor *d = p1;\n\t\t\tid = d->bSourceID;\n\t\t\tbreak; /* continue to parse */\n\t\t}\n\t\tcase UAC_MIXER_UNIT: {\n\t\t\tstruct uac_mixer_unit_descriptor *d = p1;\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->channels = uac_mixer_unit_bNrChannels(d);\n\t\t\tterm->chconfig = uac_mixer_unit_wChannelConfig(d, state->mixer->protocol);\n\t\t\tterm->name = uac_mixer_unit_iMixer(d);\n\t\t\treturn 0;\n\t\t}\n\t\tcase UAC_SELECTOR_UNIT:\n\t\tcase UAC2_CLOCK_SELECTOR: {\n\t\t\tstruct uac_selector_unit_descriptor *d = p1;\n\t\t\t/* call recursively to retrieve the channel info */\n\t\t\terr = check_input_term(state, d->baSourceID[0], term);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->id = id;\n\t\t\tterm->name = uac_selector_unit_iSelector(d);\n\t\t\treturn 0;\n\t\t}\n\t\tcase UAC1_PROCESSING_UNIT:\n\t\tcase UAC1_EXTENSION_UNIT:\n\t\t/* UAC2_PROCESSING_UNIT_V2 */\n\t\t/* UAC2_EFFECT_UNIT */\n\t\tcase UAC2_EXTENSION_UNIT_V2: {\n\t\t\tstruct uac_processing_unit_descriptor *d = p1;\n\n\t\t\tif (state->mixer->protocol == UAC_VERSION_2 &&\n\t\t\t\thdr[2] == UAC2_EFFECT_UNIT) {\n\t\t\t\t/* UAC2/UAC1 unit IDs overlap here in an\n\t\t\t\t * uncompatible way. Ignore this unit for now.\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (d->bNrInPins) {\n\t\t\t\tid = d->baSourceID[0];\n\t\t\t\tbreak; /* continue to parse */\n\t\t\t}\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->channels = uac_processing_unit_bNrChannels(d);\n\t\t\tterm->chconfig = uac_processing_unit_wChannelConfig(d, state->mixer->protocol);\n\t\t\tterm->name = uac_processing_unit_iProcessing(d, state->mixer->protocol);\n\t\t\treturn 0;\n\t\t}\n\t\tcase UAC2_CLOCK_SOURCE: {\n\t\t\tstruct uac_clock_source_descriptor *d = p1;\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->id = id;\n\t\t\tterm->name = d->iClockSource;\n\t\t\treturn 0;\n\t\t}\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Feature Unit\n */\n\n/* feature unit control information */\nstruct usb_feature_control_info {\n\tconst char *name;\n\tint type;\t/* data type for uac1 */\n\tint type_uac2;\t/* data type for uac2 if different from uac1, else -1 */\n};\n\nstatic struct usb_feature_control_info audio_feature_info[] = {\n\t{ \"Mute\",\t\t\tUSB_MIXER_INV_BOOLEAN, -1 },\n\t{ \"Volume\",\t\t\tUSB_MIXER_S16, -1 },\n\t{ \"Tone Control - Bass\",\tUSB_MIXER_S8, -1 },\n\t{ \"Tone Control - Mid\",\t\tUSB_MIXER_S8, -1 },\n\t{ \"Tone Control - Treble\",\tUSB_MIXER_S8, -1 },\n\t{ \"Graphic Equalizer\",\t\tUSB_MIXER_S8, -1 }, /* FIXME: not implemeted yet */\n\t{ \"Auto Gain Control\",\t\tUSB_MIXER_BOOLEAN, -1 },\n\t{ \"Delay Control\",\t\tUSB_MIXER_U16, USB_MIXER_U32 },\n\t{ \"Bass Boost\",\t\t\tUSB_MIXER_BOOLEAN, -1 },\n\t{ \"Loudness\",\t\t\tUSB_MIXER_BOOLEAN, -1 },\n\t/* UAC2 specific */\n\t{ \"Input Gain Control\",\t\tUSB_MIXER_S16, -1 },\n\t{ \"Input Gain Pad Control\",\tUSB_MIXER_S16, -1 },\n\t{ \"Phase Inverter Control\",\tUSB_MIXER_BOOLEAN, -1 },\n};\n\n/* private_free callback */\nvoid snd_usb_mixer_elem_free(struct snd_kcontrol *kctl)\n{\n\tkfree(kctl->private_data);\n\tkctl->private_data = NULL;\n}\n\n/*\n * interface to ALSA control for feature/mixer units\n */\n\n/* volume control quirks */\nstatic void volume_control_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t  struct snd_kcontrol *kctl)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2030): /* M-Audio Fast Track C400 */\n\tcase USB_ID(0x0763, 0x2031): /* M-Audio Fast Track C600 */\n\t\tif (strcmp(kctl->id.name, \"Effect Duration\") == 0) {\n\t\t\tcval->min = 0x0000;\n\t\t\tcval->max = 0xffff;\n\t\t\tcval->res = 0x00e6;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(kctl->id.name, \"Effect Volume\") == 0 ||\n\t\t    strcmp(kctl->id.name, \"Effect Feedback Volume\") == 0) {\n\t\t\tcval->min = 0x00;\n\t\t\tcval->max = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(kctl->id.name, \"Effect Return\") != NULL) {\n\t\t\tcval->min = 0xb706;\n\t\t\tcval->max = 0xff7b;\n\t\t\tcval->res = 0x0073;\n\t\t\tbreak;\n\t\t}\n\t\tif ((strstr(kctl->id.name, \"Playback Volume\") != NULL) ||\n\t\t\t(strstr(kctl->id.name, \"Effect Send\") != NULL)) {\n\t\t\tcval->min = 0xb5fb; /* -73 dB = 0xb6ff */\n\t\t\tcval->max = 0xfcfe;\n\t\t\tcval->res = 0x0073;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0763, 0x2081): /* M-Audio Fast Track Ultra 8R */\n\tcase USB_ID(0x0763, 0x2080): /* M-Audio Fast Track Ultra */\n\t\tif (strcmp(kctl->id.name, \"Effect Duration\") == 0) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"set quirk for FTU Effect Duration\\n\");\n\t\t\tcval->min = 0x0000;\n\t\t\tcval->max = 0x7f00;\n\t\t\tcval->res = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(kctl->id.name, \"Effect Volume\") == 0 ||\n\t\t    strcmp(kctl->id.name, \"Effect Feedback Volume\") == 0) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"set quirks for FTU Effect Feedback/Volume\\n\");\n\t\t\tcval->min = 0x00;\n\t\t\tcval->max = 0x7f;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0471, 0x0101):\n\tcase USB_ID(0x0471, 0x0104):\n\tcase USB_ID(0x0471, 0x0105):\n\tcase USB_ID(0x0672, 0x1041):\n\t/* quirk for UDA1321/N101.\n\t * note that detection between firmware 2.1.1.7 (N101)\n\t * and later 2.1.1.21 is not very clear from datasheets.\n\t * I hope that the min value is -15360 for newer firmware --jk\n\t */\n\t\tif (!strcmp(kctl->id.name, \"PCM Playback Volume\") &&\n\t\t    cval->min == -15616) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t \"set volume quirk for UDA1321/N101 chip\\n\");\n\t\t\tcval->max = -256;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x046d, 0x09a4):\n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set volume quirk for QuickCam E3500\\n\");\n\t\t\tcval->min = 6080;\n\t\t\tcval->max = 8768;\n\t\t\tcval->res = 192;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x046d, 0x0807): /* Logitech Webcam C500 */\n\tcase USB_ID(0x046d, 0x0808):\n\tcase USB_ID(0x046d, 0x0809):\n\tcase USB_ID(0x046d, 0x0819): /* Logitech Webcam C210 */\n\tcase USB_ID(0x046d, 0x081b): /* HD Webcam c310 */\n\tcase USB_ID(0x046d, 0x081d): /* HD Webcam c510 */\n\tcase USB_ID(0x046d, 0x0825): /* HD Webcam c270 */\n\tcase USB_ID(0x046d, 0x0826): /* HD Webcam c525 */\n\tcase USB_ID(0x046d, 0x08ca): /* Logitech Quickcam Fusion */\n\tcase USB_ID(0x046d, 0x0991):\n\tcase USB_ID(0x046d, 0x09a2): /* QuickCam Communicate Deluxe/S7500 */\n\t/* Most audio usb devices lie about volume resolution.\n\t * Most Logitech webcams have res = 384.\n\t * Probably there is some logitech magic behind this number --fishor\n\t */\n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set resolution quirk: cval->res = 384\\n\");\n\t\t\tcval->res = 384;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/*\n * retrieve the minimum and maximum values for the specified control\n */\nstatic int get_min_max_with_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t   int default_min, struct snd_kcontrol *kctl)\n{\n\t/* for failsafe */\n\tcval->min = default_min;\n\tcval->max = cval->min + 1;\n\tcval->res = 1;\n\tcval->dBmin = cval->dBmax = 0;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tcval->initialized = 1;\n\t} else {\n\t\tint minchn = 0;\n\t\tif (cval->cmask) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < MAX_CHANNELS; i++)\n\t\t\t\tif (cval->cmask & (1 << i)) {\n\t\t\t\t\tminchn = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||\n\t\t    get_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {\n\t\t\tusb_audio_err(cval->head.mixer->chip,\n\t\t\t\t      \"%d:%d: cannot get min/max values for control %d (id %d)\\n\",\n\t\t\t\t   cval->head.id, snd_usb_ctrl_intf(cval->head.mixer->chip),\n\t\t\t\t\t\t\t       cval->control, cval->head.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t  (cval->control << 8) | minchn,\n\t\t\t\t  &cval->res) < 0) {\n\t\t\tcval->res = 1;\n\t\t} else {\n\t\t\tint last_valid_res = cval->res;\n\n\t\t\twhile (cval->res > 1) {\n\t\t\t\tif (snd_usb_mixer_set_ctl_value(cval, UAC_SET_RES,\n\t\t\t\t\t\t\t\t(cval->control << 8) | minchn,\n\t\t\t\t\t\t\t\tcval->res / 2) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res /= 2;\n\t\t\t}\n\t\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t\t  (cval->control << 8) | minchn, &cval->res) < 0)\n\t\t\t\tcval->res = last_valid_res;\n\t\t}\n\t\tif (cval->res == 0)\n\t\t\tcval->res = 1;\n\n\t\t/* Additional checks for the proper resolution\n\t\t *\n\t\t * Some devices report smaller resolutions than actually\n\t\t * reacting.  They don't return errors but simply clip\n\t\t * to the lower aligned value.\n\t\t */\n\t\tif (cval->min + cval->res < cval->max) {\n\t\t\tint last_valid_res = cval->res;\n\t\t\tint saved, test, check;\n\t\t\tget_cur_mix_raw(cval, minchn, &saved);\n\t\t\tfor (;;) {\n\t\t\t\ttest = saved;\n\t\t\t\tif (test < cval->max)\n\t\t\t\t\ttest += cval->res;\n\t\t\t\telse\n\t\t\t\t\ttest -= cval->res;\n\t\t\t\tif (test < cval->min || test > cval->max ||\n\t\t\t\t    snd_usb_set_cur_mix_value(cval, minchn, 0, test) ||\n\t\t\t\t    get_cur_mix_raw(cval, minchn, &check)) {\n\t\t\t\t\tcval->res = last_valid_res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (test == check)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res *= 2;\n\t\t\t}\n\t\t\tsnd_usb_set_cur_mix_value(cval, minchn, 0, saved);\n\t\t}\n\n\t\tcval->initialized = 1;\n\t}\n\n\tif (kctl)\n\t\tvolume_control_quirks(cval, kctl);\n\n\t/* USB descriptions contain the dB scale in 1/256 dB unit\n\t * while ALSA TLV contains in 1/100 dB unit\n\t */\n\tcval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;\n\tcval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;\n\tif (cval->dBmin > cval->dBmax) {\n\t\t/* something is wrong; assume it's either from/to 0dB */\n\t\tif (cval->dBmin < 0)\n\t\t\tcval->dBmax = 0;\n\t\telse if (cval->dBmin > 0)\n\t\t\tcval->dBmin = 0;\n\t\tif (cval->dBmin > cval->dBmax) {\n\t\t\t/* totally crap, return an error */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define get_min_max(cval, def)\tget_min_max_with_quirks(cval, def, NULL)\n\n/* get a feature/mixer unit info */\nstatic int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = cval->channels;\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 1;\n\t} else {\n\t\tif (!cval->initialized) {\n\t\t\tget_min_max_with_quirks(cval, 0, kcontrol);\n\t\t\tif (cval->initialized && cval->dBmin >= cval->dBmax) {\n\t\t\t\tkcontrol->vd[0].access &= \n\t\t\t\t\t~(SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK);\n\t\t\t\tsnd_ctl_notify(cval->head.mixer->chip->card,\n\t\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t\t\t       &kcontrol->id);\n\t\t\t}\n\t\t}\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max =\n\t\t\t(cval->max - cval->min + cval->res - 1) / cval->res;\n\t}\n\treturn 0;\n}\n\n/* get the current value from feature/mixer unit */\nstatic int mixer_ctl_feature_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint c, cnt, val, err;\n\n\tucontrol->value.integer.value[0] = cval->min;\n\tif (cval->cmask) {\n\t\tcnt = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\terr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &val);\n\t\t\tif (err < 0)\n\t\t\t\treturn filter_error(cval, err);\n\t\t\tval = get_relative_value(cval, val);\n\t\t\tucontrol->value.integer.value[cnt] = val;\n\t\t\tcnt++;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\t/* master channel */\n\t\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &val);\n\t\tif (err < 0)\n\t\t\treturn filter_error(cval, err);\n\t\tval = get_relative_value(cval, val);\n\t\tucontrol->value.integer.value[0] = val;\n\t}\n\treturn 0;\n}\n\n/* put the current value to feature/mixer unit */\nstatic int mixer_ctl_feature_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint c, cnt, val, oval, err;\n\tint changed = 0;\n\n\tif (cval->cmask) {\n\t\tcnt = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\terr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &oval);\n\t\t\tif (err < 0)\n\t\t\t\treturn filter_error(cval, err);\n\t\t\tval = ucontrol->value.integer.value[cnt];\n\t\t\tval = get_abs_value(cval, val);\n\t\t\tif (oval != val) {\n\t\t\t\tsnd_usb_set_cur_mix_value(cval, c + 1, cnt, val);\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t} else {\n\t\t/* master channel */\n\t\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &oval);\n\t\tif (err < 0)\n\t\t\treturn filter_error(cval, err);\n\t\tval = ucontrol->value.integer.value[0];\n\t\tval = get_abs_value(cval, val);\n\t\tif (val != oval) {\n\t\t\tsnd_usb_set_cur_mix_value(cval, 0, 0, val);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new usb_feature_unit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later manually */\n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_feature_get,\n\t.put = mixer_ctl_feature_put,\n};\n\n/* the read-only variant */\nstatic const struct snd_kcontrol_new usb_feature_unit_ctl_ro = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later manually */\n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_feature_get,\n\t.put = NULL,\n};\n\n/*\n * This symbol is exported in order to allow the mixer quirks to\n * hook up to the standard feature unit control mechanism\n */\nstruct snd_kcontrol_new *snd_usb_feature_unit_ctl = &usb_feature_unit_ctl;\n\n/*\n * build a feature control\n */\nstatic size_t append_ctl_name(struct snd_kcontrol *kctl, const char *str)\n{\n\treturn strlcat(kctl->id.name, str, sizeof(kctl->id.name));\n}\n\n/*\n * A lot of headsets/headphones have a \"Speaker\" mixer. Make sure we\n * rename it to \"Headphone\". We determine if something is a headphone\n * similar to how udev determines form factor.\n */\nstatic void check_no_speaker_on_headset(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_card *card)\n{\n\tconst char *names_to_check[] = {\n\t\t\"Headset\", \"headset\", \"Headphone\", \"headphone\", NULL};\n\tconst char **s;\n\tbool found = false;\n\n\tif (strcmp(\"Speaker\", kctl->id.name))\n\t\treturn;\n\n\tfor (s = names_to_check; *s; s++)\n\t\tif (strstr(card->shortname, *s)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found)\n\t\treturn;\n\n\tstrlcpy(kctl->id.name, \"Headphone\", sizeof(kctl->id.name));\n}\n\nstatic void build_feature_ctl(struct mixer_build *state, void *raw_desc,\n\t\t\t      unsigned int ctl_mask, int control,\n\t\t\t      struct usb_audio_term *iterm, int unitid,\n\t\t\t      int readonly_mask)\n{\n\tstruct uac_feature_unit_descriptor *desc = raw_desc;\n\tstruct usb_feature_control_info *ctl_info;\n\tunsigned int len = 0;\n\tint mapped_name = 0;\n\tint nameid = uac_feature_unit_iFeature(desc);\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *cval;\n\tconst struct usbmix_name_map *map;\n\tunsigned int range;\n\n\tcontrol++; /* change from zero-based to 1-based value */\n\n\tif (control == UAC_FU_GRAPHIC_EQUALIZER) {\n\t\t/* FIXME: not supported yet */\n\t\treturn;\n\t}\n\n\tmap = find_map(state, unitid, control);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->control = control;\n\tcval->cmask = ctl_mask;\n\tctl_info = &audio_feature_info[control-1];\n\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\tcval->val_type = ctl_info->type;\n\telse /* UAC_VERSION_2 */\n\t\tcval->val_type = ctl_info->type_uac2 >= 0 ?\n\t\t\tctl_info->type_uac2 : ctl_info->type;\n\n\tif (ctl_mask == 0) {\n\t\tcval->channels = 1;\t/* master channel */\n\t\tcval->master_readonly = readonly_mask;\n\t} else {\n\t\tint i, c = 0;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (ctl_mask & (1 << i))\n\t\t\t\tc++;\n\t\tcval->channels = c;\n\t\tcval->ch_readonly = readonly_mask;\n\t}\n\n\t/*\n\t * If all channels in the mask are marked read-only, make the control\n\t * read-only. snd_usb_set_cur_mix_value() will check the mask again and won't\n\t * issue write commands to read-only channels.\n\t */\n\tif (cval->channels == readonly_mask)\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\n\telse\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\n\tif (!kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tkfree(cval);\n\t\treturn;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tmapped_name = len != 0;\n\tif (!len && nameid)\n\t\tlen = snd_usb_copy_string_desc(state, nameid,\n\t\t\t\tkctl->id.name, sizeof(kctl->id.name));\n\n\tswitch (control) {\n\tcase UAC_FU_MUTE:\n\tcase UAC_FU_VOLUME:\n\t\t/*\n\t\t * determine the control name.  the rule is:\n\t\t * - if a name id is given in descriptor, use it.\n\t\t * - if the connected input can be determined, then use the name\n\t\t *   of terminal type.\n\t\t * - if the connected output can be determined, use it.\n\t\t * - otherwise, anonymous name.\n\t\t */\n\t\tif (!len) {\n\t\t\tlen = get_term_name(state, iterm, kctl->id.name,\n\t\t\t\t\t    sizeof(kctl->id.name), 1);\n\t\t\tif (!len)\n\t\t\t\tlen = get_term_name(state, &state->oterm,\n\t\t\t\t\t\t    kctl->id.name,\n\t\t\t\t\t\t    sizeof(kctl->id.name), 1);\n\t\t\tif (!len)\n\t\t\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t\t\t \"Feature %d\", unitid);\n\t\t}\n\n\t\tif (!mapped_name)\n\t\t\tcheck_no_speaker_on_headset(kctl, state->mixer->chip->card);\n\n\t\t/*\n\t\t * determine the stream direction:\n\t\t * if the connected output is USB stream, then it's likely a\n\t\t * capture stream.  otherwise it should be playback (hopefully :)\n\t\t */\n\t\tif (!mapped_name && !(state->oterm.type >> 16)) {\n\t\t\tif ((state->oterm.type & 0xff00) == 0x0100)\n\t\t\t\tappend_ctl_name(kctl, \" Capture\");\n\t\t\telse\n\t\t\t\tappend_ctl_name(kctl, \" Playback\");\n\t\t}\n\t\tappend_ctl_name(kctl, control == UAC_FU_MUTE ?\n\t\t\t\t\" Switch\" : \" Volume\");\n\t\tbreak;\n\tdefault:\n\t\tif (!len)\n\t\t\tstrlcpy(kctl->id.name, audio_feature_info[control-1].name,\n\t\t\t\tsizeof(kctl->id.name));\n\t\tbreak;\n\t}\n\n\t/* get min/max values */\n\tget_min_max_with_quirks(cval, 0, kctl);\n\n\tif (control == UAC_FU_VOLUME) {\n\t\tcheck_mapped_dB(map, cval);\n\t\tif (cval->dBmin < cval->dBmax || !cval->initialized) {\n\t\t\tkctl->tlv.c = snd_usb_mixer_vol_tlv;\n\t\t\tkctl->vd[0].access |=\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t\t}\n\t}\n\n\tsnd_usb_mixer_fu_apply_quirk(state->mixer, cval, unitid, kctl);\n\n\trange = (cval->max - cval->min) / cval->res;\n\t/*\n\t * Are there devices with volume range more than 255? I use a bit more\n\t * to be sure. 384 is a resolution magic number found on Logitech\n\t * devices. It will definitively catch all buggy Logitech devices.\n\t */\n\tif (range > 384) {\n\t\tusb_audio_warn(state->chip,\n\t\t\t       \"Warning! Unlikely big volume range (=%u), cval->res is probably wrong.\",\n\t\t\t       range);\n\t\tusb_audio_warn(state->chip,\n\t\t\t       \"[%d] FU [%s] ch = %d, val = %d/%d/%d\",\n\t\t\t       cval->head.id, kctl->id.name, cval->channels,\n\t\t\t       cval->min, cval->max, cval->res);\n\t}\n\n\tusb_audio_dbg(state->chip, \"[%d] FU [%s] ch = %d, val = %d/%d/%d\\n\",\n\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t      cval->min, cval->max, cval->res);\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic int parse_clock_source_unit(struct mixer_build *state, int unitid,\n\t\t\t\t   void *_ftr)\n{\n\tstruct uac_clock_source_descriptor *hdr = _ftr;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint ret;\n\n\tif (state->mixer->protocol != UAC_VERSION_2)\n\t\treturn -EINVAL;\n\n\tif (hdr->bLength != sizeof(*hdr)) {\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"Bogus clock source descriptor length of %d, ignoring.\\n\",\n\t\t\t      hdr->bLength);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The only property of this unit we are interested in is the\n\t * clock source validity. If that isn't readable, just bail out.\n\t */\n\tif (!uac2_control_is_readable(hdr->bmControls,\n\t\t\t\t      ilog2(UAC2_CS_CONTROL_CLOCK_VALID)))\n\t\treturn 0;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, hdr->bClockID);\n\n\tcval->min = 0;\n\tcval->max = 1;\n\tcval->channels = 1;\n\tcval->val_type = USB_MIXER_BOOLEAN;\n\tcval->control = UAC2_CS_CONTROL_CLOCK_VALID;\n\n\tif (uac2_control_is_writeable(hdr->bmControls,\n\t\t\t\t      ilog2(UAC2_CS_CONTROL_CLOCK_VALID)))\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\telse {\n\t\tcval->master_readonly = 1;\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\n\t}\n\n\tif (!kctl) {\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\tret = snd_usb_copy_string_desc(state, hdr->iClockSource,\n\t\t\t\t       name, sizeof(name));\n\tif (ret > 0)\n\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t \"%s Validity\", name);\n\telse\n\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t \"Clock Source %d Validity\", hdr->bClockID);\n\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n/*\n * parse a feature unit\n *\n * most of controls are defined here.\n */\nstatic int parse_audio_feature_unit(struct mixer_build *state, int unitid,\n\t\t\t\t    void *_ftr)\n{\n\tint channels, i, j;\n\tstruct usb_audio_term iterm;\n\tunsigned int master_bits, first_ch_bits;\n\tint err, csize;\n\tstruct uac_feature_unit_descriptor *hdr = _ftr;\n\t__u8 *bmaControls;\n\n\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\tcsize = hdr->bControlSize;\n\t\tif (!csize) {\n\t\t\tusb_audio_dbg(state->chip,\n\t\t\t\t      \"unit %u: invalid bControlSize == 0\\n\",\n\t\t\t\t      unitid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchannels = (hdr->bLength - 7) / csize - 1;\n\t\tbmaControls = hdr->bmaControls;\n\t\tif (hdr->bLength < 7 + csize) {\n\t\t\tusb_audio_err(state->chip,\n\t\t\t\t      \"unit %u: invalid UAC_FEATURE_UNIT descriptor\\n\",\n\t\t\t\t      unitid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tstruct uac2_feature_unit_descriptor *ftr = _ftr;\n\t\tcsize = 4;\n\t\tchannels = (hdr->bLength - 6) / 4 - 1;\n\t\tbmaControls = ftr->bmaControls;\n\t\tif (hdr->bLength < 6 + csize) {\n\t\t\tusb_audio_err(state->chip,\n\t\t\t\t      \"unit %u: invalid UAC_FEATURE_UNIT descriptor\\n\",\n\t\t\t\t      unitid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* parse the source unit */\n\tif ((err = parse_audio_unit(state, hdr->bSourceID)) < 0)\n\t\treturn err;\n\n\t/* determine the input source type and name */\n\terr = check_input_term(state, hdr->bSourceID, &iterm);\n\tif (err < 0)\n\t\treturn err;\n\n\tmaster_bits = snd_usb_combine_bytes(bmaControls, csize);\n\t/* master configuration quirks */\n\tswitch (state->chip->usb_id) {\n\tcase USB_ID(0x08bb, 0x2702):\n\t\tusb_audio_info(state->chip,\n\t\t\t       \"usbmixer: master volume quirk for PCM2702 chip\\n\");\n\t\t/* disable non-functional volume control */\n\t\tmaster_bits &= ~UAC_CONTROL_BIT(UAC_FU_VOLUME);\n\t\tbreak;\n\tcase USB_ID(0x1130, 0xf211):\n\t\tusb_audio_info(state->chip,\n\t\t\t       \"usbmixer: volume control quirk for Tenx TP6911 Audio Headset\\n\");\n\t\t/* disable non-functional volume control */\n\t\tchannels = 0;\n\t\tbreak;\n\n\t}\n\tif (channels > 0)\n\t\tfirst_ch_bits = snd_usb_combine_bytes(bmaControls + csize, csize);\n\telse\n\t\tfirst_ch_bits = 0;\n\n\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t/* check all control types */\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tunsigned int ch_bits = 0;\n\t\t\tfor (j = 0; j < channels; j++) {\n\t\t\t\tunsigned int mask;\n\n\t\t\t\tmask = snd_usb_combine_bytes(bmaControls +\n\t\t\t\t\t\t\t     csize * (j+1), csize);\n\t\t\t\tif (mask & (1 << i))\n\t\t\t\t\tch_bits |= (1 << j);\n\t\t\t}\n\t\t\t/* audio class v1 controls are never read-only */\n\n\t\t\t/*\n\t\t\t * The first channel must be set\n\t\t\t * (for ease of programming).\n\t\t\t */\n\t\t\tif (ch_bits & 1)\n\t\t\t\tbuild_feature_ctl(state, _ftr, ch_bits, i,\n\t\t\t\t\t\t  &iterm, unitid, 0);\n\t\t\tif (master_bits & (1 << i))\n\t\t\t\tbuild_feature_ctl(state, _ftr, 0, i, &iterm,\n\t\t\t\t\t\t  unitid, 0);\n\t\t}\n\t} else { /* UAC_VERSION_2 */\n\t\tfor (i = 0; i < ARRAY_SIZE(audio_feature_info); i++) {\n\t\t\tunsigned int ch_bits = 0;\n\t\t\tunsigned int ch_read_only = 0;\n\n\t\t\tfor (j = 0; j < channels; j++) {\n\t\t\t\tunsigned int mask;\n\n\t\t\t\tmask = snd_usb_combine_bytes(bmaControls +\n\t\t\t\t\t\t\t     csize * (j+1), csize);\n\t\t\t\tif (uac2_control_is_readable(mask, i)) {\n\t\t\t\t\tch_bits |= (1 << j);\n\t\t\t\t\tif (!uac2_control_is_writeable(mask, i))\n\t\t\t\t\t\tch_read_only |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * NOTE: build_feature_ctl() will mark the control\n\t\t\t * read-only if all channels are marked read-only in\n\t\t\t * the descriptors. Otherwise, the control will be\n\t\t\t * reported as writeable, but the driver will not\n\t\t\t * actually issue a write command for read-only\n\t\t\t * channels.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * The first channel must be set\n\t\t\t * (for ease of programming).\n\t\t\t */\n\t\t\tif (ch_bits & 1)\n\t\t\t\tbuild_feature_ctl(state, _ftr, ch_bits, i,\n\t\t\t\t\t\t  &iterm, unitid, ch_read_only);\n\t\t\tif (uac2_control_is_readable(master_bits, i))\n\t\t\t\tbuild_feature_ctl(state, _ftr, 0, i, &iterm, unitid,\n\t\t\t\t\t\t  !uac2_control_is_writeable(master_bits, i));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Mixer Unit\n */\n\n/*\n * build a mixer unit control\n *\n * the callbacks are identical with feature unit.\n * input channel number (zero based) is given in control field instead.\n */\nstatic void build_mixer_unit_ctl(struct mixer_build *state,\n\t\t\t\t struct uac_mixer_unit_descriptor *desc,\n\t\t\t\t int in_pin, int in_ch, int unitid,\n\t\t\t\t struct usb_audio_term *iterm)\n{\n\tstruct usb_mixer_elem_info *cval;\n\tunsigned int num_outs = uac_mixer_unit_bNrChannels(desc);\n\tunsigned int i, len;\n\tstruct snd_kcontrol *kctl;\n\tconst struct usbmix_name_map *map;\n\n\tmap = find_map(state, unitid, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->control = in_ch + 1; /* based on 1 */\n\tcval->val_type = USB_MIXER_S16;\n\tfor (i = 0; i < num_outs; i++) {\n\t\t__u8 *c = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (check_matrix_bitmap(c, in_ch, i, num_outs)) {\n\t\t\tcval->cmask |= (1 << i);\n\t\t\tcval->channels++;\n\t\t}\n\t}\n\n\t/* get min/max values */\n\tget_min_max(cval, 0);\n\n\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\tif (!kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tkfree(cval);\n\t\treturn;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tif (!len)\n\t\tlen = get_term_name(state, iterm, kctl->id.name,\n\t\t\t\t    sizeof(kctl->id.name), 0);\n\tif (!len)\n\t\tlen = sprintf(kctl->id.name, \"Mixer Source %d\", in_ch + 1);\n\tappend_ctl_name(kctl, \" Volume\");\n\n\tusb_audio_dbg(state->chip, \"[%d] MU [%s] ch = %d, val = %d/%d\\n\",\n\t\t    cval->head.id, kctl->id.name, cval->channels, cval->min, cval->max);\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n/*\n * parse a mixer unit\n */\nstatic int parse_audio_mixer_unit(struct mixer_build *state, int unitid,\n\t\t\t\t  void *raw_desc)\n{\n\tstruct uac_mixer_unit_descriptor *desc = raw_desc;\n\tstruct usb_audio_term iterm;\n\tint input_pins, num_ins, num_outs;\n\tint pin, ich, err;\n\n\tif (desc->bLength < 11 || !(input_pins = desc->bNrInPins) ||\n\t    !(num_outs = uac_mixer_unit_bNrChannels(desc))) {\n\t\tusb_audio_err(state->chip,\n\t\t\t      \"invalid MIXER UNIT descriptor %d\\n\",\n\t\t\t      unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = 0;\n\tich = 0;\n\tfor (pin = 0; pin < input_pins; pin++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[pin]);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\t\t/* no bmControls field (e.g. Maya44) -> ignore */\n\t\tif (desc->bLength <= 10 + input_pins)\n\t\t\tcontinue;\n\t\terr = check_input_term(state, desc->baSourceID[pin], &iterm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnum_ins += iterm.channels;\n\t\tfor (; ich < num_ins; ich++) {\n\t\t\tint och, ich_has_controls = 0;\n\n\t\t\tfor (och = 0; och < num_outs; och++) {\n\t\t\t\t__u8 *c = uac_mixer_unit_bmControls(desc,\n\t\t\t\t\t\tstate->mixer->protocol);\n\n\t\t\t\tif (check_matrix_bitmap(c, ich, och, num_outs)) {\n\t\t\t\t\tich_has_controls = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ich_has_controls)\n\t\t\t\tbuild_mixer_unit_ctl(state, desc, pin, ich,\n\t\t\t\t\t\t     unitid, &iterm);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Processing Unit / Extension Unit\n */\n\n/* get callback for processing/extension unit */\nstatic int mixer_ctl_procunit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint err, val;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\tif (err < 0) {\n\t\tucontrol->value.integer.value[0] = cval->min;\n\t\treturn filter_error(cval, err);\n\t}\n\tval = get_relative_value(cval, val);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\n/* put callback for processing/extension unit */\nstatic int mixer_ctl_procunit_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, oval, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &oval);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = ucontrol->value.integer.value[0];\n\tval = get_abs_value(cval, val);\n\tif (val != oval) {\n\t\tset_cur_ctl_value(cval, cval->control << 8, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* alsa control interface for processing/extension unit */\nstatic const struct snd_kcontrol_new mixer_procunit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later */\n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_procunit_get,\n\t.put = mixer_ctl_procunit_put,\n};\n\n/*\n * predefined data for processing units\n */\nstruct procunit_value_info {\n\tint control;\n\tchar *suffix;\n\tint val_type;\n\tint min_value;\n};\n\nstruct procunit_info {\n\tint type;\n\tchar *name;\n\tstruct procunit_value_info *values;\n};\n\nstatic struct procunit_value_info updown_proc_info[] = {\n\t{ UAC_UD_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_UD_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic struct procunit_value_info prologic_proc_info[] = {\n\t{ UAC_DP_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_DP_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic struct procunit_value_info threed_enh_proc_info[] = {\n\t{ UAC_3D_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_3D_SPACE, \"Spaciousness\", USB_MIXER_U8 },\n\t{ 0 }\n};\nstatic struct procunit_value_info reverb_proc_info[] = {\n\t{ UAC_REVERB_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_REVERB_LEVEL, \"Level\", USB_MIXER_U8 },\n\t{ UAC_REVERB_TIME, \"Time\", USB_MIXER_U16 },\n\t{ UAC_REVERB_FEEDBACK, \"Feedback\", USB_MIXER_U8 },\n\t{ 0 }\n};\nstatic struct procunit_value_info chorus_proc_info[] = {\n\t{ UAC_CHORUS_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_CHORUS_LEVEL, \"Level\", USB_MIXER_U8 },\n\t{ UAC_CHORUS_RATE, \"Rate\", USB_MIXER_U16 },\n\t{ UAC_CHORUS_DEPTH, \"Depth\", USB_MIXER_U16 },\n\t{ 0 }\n};\nstatic struct procunit_value_info dcr_proc_info[] = {\n\t{ UAC_DCR_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_DCR_RATE, \"Ratio\", USB_MIXER_U16 },\n\t{ UAC_DCR_MAXAMPL, \"Max Amp\", USB_MIXER_S16 },\n\t{ UAC_DCR_THRESHOLD, \"Threshold\", USB_MIXER_S16 },\n\t{ UAC_DCR_ATTACK_TIME, \"Attack Time\", USB_MIXER_U16 },\n\t{ UAC_DCR_RELEASE_TIME, \"Release Time\", USB_MIXER_U16 },\n\t{ 0 }\n};\n\nstatic struct procunit_info procunits[] = {\n\t{ UAC_PROCESS_UP_DOWNMIX, \"Up Down\", updown_proc_info },\n\t{ UAC_PROCESS_DOLBY_PROLOGIC, \"Dolby Prologic\", prologic_proc_info },\n\t{ UAC_PROCESS_STEREO_EXTENDER, \"3D Stereo Extender\", threed_enh_proc_info },\n\t{ UAC_PROCESS_REVERB, \"Reverb\", reverb_proc_info },\n\t{ UAC_PROCESS_CHORUS, \"Chorus\", chorus_proc_info },\n\t{ UAC_PROCESS_DYN_RANGE_COMP, \"DCR\", dcr_proc_info },\n\t{ 0 },\n};\n/*\n * predefined data for extension units\n */\nstatic struct procunit_value_info clock_rate_xu_info[] = {\n\t{ USB_XU_CLOCK_RATE_SELECTOR, \"Selector\", USB_MIXER_U8, 0 },\n\t{ 0 }\n};\nstatic struct procunit_value_info clock_source_xu_info[] = {\n\t{ USB_XU_CLOCK_SOURCE_SELECTOR, \"External\", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic struct procunit_value_info spdif_format_xu_info[] = {\n\t{ USB_XU_DIGITAL_FORMAT_SELECTOR, \"SPDIF/AC3\", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic struct procunit_value_info soft_limit_xu_info[] = {\n\t{ USB_XU_SOFT_LIMIT_SELECTOR, \" \", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic struct procunit_info extunits[] = {\n\t{ USB_XU_CLOCK_RATE, \"Clock rate\", clock_rate_xu_info },\n\t{ USB_XU_CLOCK_SOURCE, \"DigitalIn CLK source\", clock_source_xu_info },\n\t{ USB_XU_DIGITAL_IO_STATUS, \"DigitalOut format:\", spdif_format_xu_info },\n\t{ USB_XU_DEVICE_OPTIONS, \"AnalogueIn Soft Limit\", soft_limit_xu_info },\n\t{ 0 }\n};\n\n/*\n * build a processing/extension unit\n */\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\tif ((err = parse_audio_unit(state, desc->baSourceID[i])) < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (!(controls[valinfo->control / 8] & (1 << ((valinfo->control % 8) - 1))))\n\t\t\tcontinue;\n\t\tmap = find_map(state, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\t/* get min/max values */\n\t\tif (type == UAC_PROCESS_UP_DOWNMIX && cval->control == UAC_UD_MODE_SELECT) {\n\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc, state->mixer->protocol);\n\t\t\t/* FIXME: hard-coded */\n\t\t\tcval->min = 1;\n\t\t\tcval->max = control_spec[0];\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t} else {\n\t\t\tif (type == USB_XU_CLOCK_RATE) {\n\t\t\t\t/*\n\t\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t\t * samplerate control quirk\n\t\t\t\t */\n\t\t\t\tcval->min = 0;\n\t\t\t\tcval->max = 5;\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t} else\n\t\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state, nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int parse_audio_processing_unit(struct mixer_build *state, int unitid,\n\t\t\t\t       void *raw_desc)\n{\n\treturn build_audio_procunit(state, unitid, raw_desc,\n\t\t\t\t    procunits, \"Processing Unit\");\n}\n\nstatic int parse_audio_extension_unit(struct mixer_build *state, int unitid,\n\t\t\t\t      void *raw_desc)\n{\n\t/*\n\t * Note that we parse extension units with processing unit descriptors.\n\t * That's ok as the layout is the same.\n\t */\n\treturn build_audio_procunit(state, unitid, raw_desc,\n\t\t\t\t    extunits, \"Extension Unit\");\n}\n\n/*\n * Selector Unit\n */\n\n/*\n * info callback for selector unit\n * use an enumerator type for routing\n */\nstatic int mixer_ctl_selector_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tconst char **itemlist = (const char **)kcontrol->private_value;\n\n\tif (snd_BUG_ON(!itemlist))\n\t\treturn -EINVAL;\n\treturn snd_ctl_enum_info(uinfo, 1, cval->max, itemlist);\n}\n\n/* get callback for selector unit */\nstatic int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\tif (err < 0) {\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\treturn filter_error(cval, err);\n\t}\n\tval = get_relative_value(cval, val);\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\n/* put callback for selector unit */\nstatic int mixer_ctl_selector_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, oval, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &oval);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = ucontrol->value.enumerated.item[0];\n\tval = get_abs_value(cval, val);\n\tif (val != oval) {\n\t\tset_cur_ctl_value(cval, cval->control << 8, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* alsa control interface for selector unit */\nstatic const struct snd_kcontrol_new mixer_selectunit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later */\n\t.info = mixer_ctl_selector_info,\n\t.get = mixer_ctl_selector_get,\n\t.put = mixer_ctl_selector_put,\n};\n\n/*\n * private free callback.\n * free both private_data and private_value\n */\nstatic void usb_mixer_selector_elem_free(struct snd_kcontrol *kctl)\n{\n\tint i, num_ins = 0;\n\n\tif (kctl->private_data) {\n\t\tstruct usb_mixer_elem_info *cval = kctl->private_data;\n\t\tnum_ins = cval->max;\n\t\tkfree(cval);\n\t\tkctl->private_data = NULL;\n\t}\n\tif (kctl->private_value) {\n\t\tchar **itemlist = (char **)kctl->private_value;\n\t\tfor (i = 0; i < num_ins; i++)\n\t\t\tkfree(itemlist[i]);\n\t\tkfree(itemlist);\n\t\tkctl->private_value = 0;\n\t}\n}\n\n/*\n * parse a selector unit\n */\nstatic int parse_audio_selector_unit(struct mixer_build *state, int unitid,\n\t\t\t\t     void *raw_desc)\n{\n\tstruct uac_selector_unit_descriptor *desc = raw_desc;\n\tunsigned int i, nameid, len;\n\tint err;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tconst struct usbmix_name_map *map;\n\tchar **namelist;\n\n\tif (!desc->bNrInPins || desc->bLength < 5 + desc->bNrInPins) {\n\t\tusb_audio_err(state->chip,\n\t\t\t\"invalid SELECTOR UNIT descriptor %d\\n\", unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < desc->bNrInPins; i++) {\n\t\tif ((err = parse_audio_unit(state, desc->baSourceID[i])) < 0)\n\t\t\treturn err;\n\t}\n\n\tif (desc->bNrInPins == 1) /* only one ? nonsense! */\n\t\treturn 0;\n\n\tmap = find_map(state, unitid, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn 0;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->val_type = USB_MIXER_U8;\n\tcval->channels = 1;\n\tcval->min = 1;\n\tcval->max = desc->bNrInPins;\n\tcval->res = 1;\n\tcval->initialized = 1;\n\n\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\tcval->control = 0;\n\telse /* UAC_VERSION_2 */\n\t\tcval->control = (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR) ?\n\t\t\tUAC2_CX_CLOCK_SELECTOR : UAC2_SU_SELECTOR;\n\n\tnamelist = kmalloc(sizeof(char *) * desc->bNrInPins, GFP_KERNEL);\n\tif (!namelist) {\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n#define MAX_ITEM_NAME_LEN\t64\n\tfor (i = 0; i < desc->bNrInPins; i++) {\n\t\tstruct usb_audio_term iterm;\n\t\tlen = 0;\n\t\tnamelist[i] = kmalloc(MAX_ITEM_NAME_LEN, GFP_KERNEL);\n\t\tif (!namelist[i]) {\n\t\t\twhile (i--)\n\t\t\t\tkfree(namelist[i]);\n\t\t\tkfree(namelist);\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlen = check_mapped_selector_name(state, unitid, i, namelist[i],\n\t\t\t\t\t\t MAX_ITEM_NAME_LEN);\n\t\tif (! len && check_input_term(state, desc->baSourceID[i], &iterm) >= 0)\n\t\t\tlen = get_term_name(state, &iterm, namelist[i], MAX_ITEM_NAME_LEN, 0);\n\t\tif (! len)\n\t\t\tsprintf(namelist[i], \"Input %u\", i);\n\t}\n\n\tkctl = snd_ctl_new1(&mixer_selectunit_ctl, cval);\n\tif (! kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tkfree(namelist);\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_value = (unsigned long)namelist;\n\tkctl->private_free = usb_mixer_selector_elem_free;\n\n\tnameid = uac_selector_unit_iSelector(desc);\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tif (len)\n\t\t;\n\telse if (nameid)\n\t\tsnd_usb_copy_string_desc(state, nameid, kctl->id.name,\n\t\t\t\t\t sizeof(kctl->id.name));\n\telse {\n\t\tlen = get_term_name(state, &state->oterm,\n\t\t\t\t    kctl->id.name, sizeof(kctl->id.name), 0);\n\t\tif (!len)\n\t\t\tstrlcpy(kctl->id.name, \"USB\", sizeof(kctl->id.name));\n\n\t\tif (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR)\n\t\t\tappend_ctl_name(kctl, \" Clock Source\");\n\t\telse if ((state->oterm.type & 0xff00) == 0x0100)\n\t\t\tappend_ctl_name(kctl, \" Capture Source\");\n\t\telse\n\t\t\tappend_ctl_name(kctl, \" Playback Source\");\n\t}\n\n\tusb_audio_dbg(state->chip, \"[%d] SU [%s] items = %d\\n\",\n\t\t    cval->head.id, kctl->id.name, desc->bNrInPins);\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n/*\n * parse an audio unit recursively\n */\n\nstatic int parse_audio_unit(struct mixer_build *state, int unitid)\n{\n\tunsigned char *p1;\n\n\tif (test_and_set_bit(unitid, state->unitbitmap))\n\t\treturn 0; /* the unit already visited */\n\n\tp1 = find_audio_control_unit(state, unitid);\n\tif (!p1) {\n\t\tusb_audio_err(state->chip, \"unit %d not found!\\n\", unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p1[2]) {\n\tcase UAC_INPUT_TERMINAL:\n\t\treturn 0; /* NOP */\n\tcase UAC_MIXER_UNIT:\n\t\treturn parse_audio_mixer_unit(state, unitid, p1);\n\tcase UAC2_CLOCK_SOURCE:\n\t\treturn parse_clock_source_unit(state, unitid, p1);\n\tcase UAC_SELECTOR_UNIT:\n\tcase UAC2_CLOCK_SELECTOR:\n\t\treturn parse_audio_selector_unit(state, unitid, p1);\n\tcase UAC_FEATURE_UNIT:\n\t\treturn parse_audio_feature_unit(state, unitid, p1);\n\tcase UAC1_PROCESSING_UNIT:\n\t/*   UAC2_EFFECT_UNIT has the same value */\n\t\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\t\telse\n\t\t\treturn 0; /* FIXME - effect units not implemented yet */\n\tcase UAC1_EXTENSION_UNIT:\n\t/*   UAC2_PROCESSING_UNIT_V2 has the same value */\n\t\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\t\telse /* UAC_VERSION_2 */\n\t\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\tcase UAC2_EXTENSION_UNIT_V2:\n\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\tdefault:\n\t\tusb_audio_err(state->chip,\n\t\t\t\"unit %u: unexpected type 0x%02x\\n\", unitid, p1[2]);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}\n\nstatic int snd_usb_mixer_dev_free(struct snd_device *device)\n{\n\tstruct usb_mixer_interface *mixer = device->device_data;\n\tsnd_usb_mixer_free(mixer);\n\treturn 0;\n}\n\n/*\n * create mixer controls\n *\n * walk through all UAC_OUTPUT_TERMINAL descriptors to search for mixers\n */\nstatic int snd_usb_mixer_controls(struct usb_mixer_interface *mixer)\n{\n\tstruct mixer_build state;\n\tint err;\n\tconst struct usbmix_ctl_map *map;\n\tvoid *p;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.chip = mixer->chip;\n\tstate.mixer = mixer;\n\tstate.buffer = mixer->hostif->extra;\n\tstate.buflen = mixer->hostif->extralen;\n\n\t/* check the mapping table */\n\tfor (map = usbmix_ctl_maps; map->id; map++) {\n\t\tif (map->id == state.chip->usb_id) {\n\t\t\tstate.map = map->map;\n\t\t\tstate.selector_map = map->selector_map;\n\t\t\tmixer->ignore_ctl_error = map->ignore_ctl_error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = NULL;\n\twhile ((p = snd_usb_find_csint_desc(mixer->hostif->extra,\n\t\t\t\t\t    mixer->hostif->extralen,\n\t\t\t\t\t    p, UAC_OUTPUT_TERMINAL)) != NULL) {\n\t\tif (mixer->protocol == UAC_VERSION_1) {\n\t\t\tstruct uac1_output_terminal_descriptor *desc = p;\n\n\t\t\tif (desc->bLength < sizeof(*desc))\n\t\t\t\tcontinue; /* invalid descriptor? */\n\t\t\t/* mark terminal ID as visited */\n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = desc->iTerminal;\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\t\t} else { /* UAC_VERSION_2 */\n\t\t\tstruct uac2_output_terminal_descriptor *desc = p;\n\n\t\t\tif (desc->bLength < sizeof(*desc))\n\t\t\t\tcontinue; /* invalid descriptor? */\n\t\t\t/* mark terminal ID as visited */\n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = desc->iTerminal;\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\n\t\t\t/*\n\t\t\t * For UAC2, use the same approach to also add the\n\t\t\t * clock selectors\n\t\t\t */\n\t\t\terr = parse_audio_unit(&state, desc->bCSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer, int unitid)\n{\n\tstruct usb_mixer_elem_list *list;\n\n\tfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem)\n\t\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &list->kctl->id);\n}\n\nstatic void snd_usb_mixer_dump_cval(struct snd_info_buffer *buffer,\n\t\t\t\t    struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = (struct usb_mixer_elem_info *)list;\n\tstatic char *val_types[] = {\"BOOLEAN\", \"INV_BOOLEAN\",\n\t\t\t\t    \"S8\", \"U8\", \"S16\", \"U16\"};\n\tsnd_iprintf(buffer, \"    Info: id=%i, control=%i, cmask=0x%x, \"\n\t\t\t    \"channels=%i, type=\\\"%s\\\"\\n\", cval->head.id,\n\t\t\t    cval->control, cval->cmask, cval->channels,\n\t\t\t    val_types[cval->val_type]);\n\tsnd_iprintf(buffer, \"    Volume: min=%i, max=%i, dBmin=%i, dBmax=%i\\n\",\n\t\t\t    cval->min, cval->max, cval->dBmin, cval->dBmax);\n}\n\nstatic void snd_usb_mixer_proc_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_usb_audio *chip = entry->private_data;\n\tstruct usb_mixer_interface *mixer;\n\tstruct usb_mixer_elem_list *list;\n\tint unitid;\n\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\tsnd_iprintf(buffer,\n\t\t\t\"USB Mixer: usb_id=0x%08x, ctrlif=%i, ctlerr=%i\\n\",\n\t\t\t\tchip->usb_id, snd_usb_ctrl_intf(chip),\n\t\t\t\tmixer->ignore_ctl_error);\n\t\tsnd_iprintf(buffer, \"Card: %s\\n\", chip->card->longname);\n\t\tfor (unitid = 0; unitid < MAX_ID_ELEMS; unitid++) {\n\t\t\tfor (list = mixer->id_elems[unitid]; list;\n\t\t\t     list = list->next_id_elem) {\n\t\t\t\tsnd_iprintf(buffer, \"  Unit: %i\\n\", list->id);\n\t\t\t\tif (list->kctl)\n\t\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t\t    \"    Control: name=\\\"%s\\\", index=%i\\n\",\n\t\t\t\t\t\t    list->kctl->id.name,\n\t\t\t\t\t\t    list->kctl->id.index);\n\t\t\t\tif (list->dump)\n\t\t\t\t\tlist->dump(buffer, list);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,\n\t\t\t\t       int attribute, int value, int index)\n{\n\tstruct usb_mixer_elem_list *list;\n\t__u8 unitid = (index >> 8) & 0xff;\n\t__u8 control = (value >> 8) & 0xff;\n\t__u8 channel = value & 0xff;\n\tunsigned int count = 0;\n\n\tif (channel >= MAX_CHANNELS) {\n\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\"%s(): bogus channel number %d\\n\",\n\t\t\t__func__, channel);\n\t\treturn;\n\t}\n\n\tfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem)\n\t\tcount++;\n\n\tif (count == 0)\n\t\treturn;\n\n\tfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem) {\n\t\tstruct usb_mixer_elem_info *info;\n\n\t\tif (!list->kctl)\n\t\t\tcontinue;\n\n\t\tinfo = (struct usb_mixer_elem_info *)list;\n\t\tif (count > 1 && info->control != control)\n\t\t\tcontinue;\n\n\t\tswitch (attribute) {\n\t\tcase UAC2_CS_CUR:\n\t\t\t/* invalidate cache, so the value is read from the device */\n\t\t\tif (channel)\n\t\t\t\tinfo->cached &= ~(1 << channel);\n\t\t\telse /* master channel */\n\t\t\t\tinfo->cached = 0;\n\n\t\t\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &info->head.kctl->id);\n\t\t\tbreak;\n\n\t\tcase UAC2_CS_RANGE:\n\t\t\t/* TODO */\n\t\t\tbreak;\n\n\t\tcase UAC2_CS_MEM:\n\t\t\t/* TODO */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\t\"unknown attribute %d in interrupt\\n\",\n\t\t\t\tattribute);\n\t\t\tbreak;\n\t\t} /* switch */\n\t}\n}\n\nstatic void snd_usb_mixer_interrupt(struct urb *urb)\n{\n\tstruct usb_mixer_interface *mixer = urb->context;\n\tint len = urb->actual_length;\n\tint ustatus = urb->status;\n\n\tif (ustatus != 0)\n\t\tgoto requeue;\n\n\tif (mixer->protocol == UAC_VERSION_1) {\n\t\tstruct uac1_status_word *status;\n\n\t\tfor (status = urb->transfer_buffer;\n\t\t     len >= sizeof(*status);\n\t\t     len -= sizeof(*status), status++) {\n\t\t\tdev_dbg(&urb->dev->dev, \"status interrupt: %02x %02x\\n\",\n\t\t\t\t\t\tstatus->bStatusType,\n\t\t\t\t\t\tstatus->bOriginator);\n\n\t\t\t/* ignore any notifications not from the control interface */\n\t\t\tif ((status->bStatusType & UAC1_STATUS_TYPE_ORIG_MASK) !=\n\t\t\t\tUAC1_STATUS_TYPE_ORIG_AUDIO_CONTROL_IF)\n\t\t\t\tcontinue;\n\n\t\t\tif (status->bStatusType & UAC1_STATUS_TYPE_MEM_CHANGED)\n\t\t\t\tsnd_usb_mixer_rc_memory_change(mixer, status->bOriginator);\n\t\t\telse\n\t\t\t\tsnd_usb_mixer_notify_id(mixer, status->bOriginator);\n\t\t}\n\t} else { /* UAC_VERSION_2 */\n\t\tstruct uac2_interrupt_data_msg *msg;\n\n\t\tfor (msg = urb->transfer_buffer;\n\t\t     len >= sizeof(*msg);\n\t\t     len -= sizeof(*msg), msg++) {\n\t\t\t/* drop vendor specific and endpoint requests */\n\t\t\tif ((msg->bInfo & UAC2_INTERRUPT_DATA_MSG_VENDOR) ||\n\t\t\t    (msg->bInfo & UAC2_INTERRUPT_DATA_MSG_EP))\n\t\t\t\tcontinue;\n\n\t\t\tsnd_usb_mixer_interrupt_v2(mixer, msg->bAttribute,\n\t\t\t\t\t\t   le16_to_cpu(msg->wValue),\n\t\t\t\t\t\t   le16_to_cpu(msg->wIndex));\n\t\t}\n\t}\n\nrequeue:\n\tif (ustatus != -ENOENT &&\n\t    ustatus != -ECONNRESET &&\n\t    ustatus != -ESHUTDOWN) {\n\t\turb->dev = mixer->chip->dev;\n\t\tusb_submit_urb(urb, GFP_ATOMIC);\n\t}\n}\n\n/* create the handler for the optional status interrupt endpoint */\nstatic int snd_usb_mixer_status_create(struct usb_mixer_interface *mixer)\n{\n\tstruct usb_endpoint_descriptor *ep;\n\tvoid *transfer_buffer;\n\tint buffer_length;\n\tunsigned int epnum;\n\n\t/* we need one interrupt input endpoint */\n\tif (get_iface_desc(mixer->hostif)->bNumEndpoints < 1)\n\t\treturn 0;\n\tep = get_endpoint(mixer->hostif, 0);\n\tif (!usb_endpoint_dir_in(ep) || !usb_endpoint_xfer_int(ep))\n\t\treturn 0;\n\n\tepnum = usb_endpoint_num(ep);\n\tbuffer_length = le16_to_cpu(ep->wMaxPacketSize);\n\ttransfer_buffer = kmalloc(buffer_length, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\tmixer->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!mixer->urb) {\n\t\tkfree(transfer_buffer);\n\t\treturn -ENOMEM;\n\t}\n\tusb_fill_int_urb(mixer->urb, mixer->chip->dev,\n\t\t\t usb_rcvintpipe(mixer->chip->dev, epnum),\n\t\t\t transfer_buffer, buffer_length,\n\t\t\t snd_usb_mixer_interrupt, mixer, ep->bInterval);\n\tusb_submit_urb(mixer->urb, GFP_KERNEL);\n\treturn 0;\n}\n\nint snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,\n\t\t\t int ignore_error)\n{\n\tstatic struct snd_device_ops dev_ops = {\n\t\t.dev_free = snd_usb_mixer_dev_free\n\t};\n\tstruct usb_mixer_interface *mixer;\n\tstruct snd_info_entry *entry;\n\tint err;\n\n\tstrcpy(chip->card->mixername, \"USB Mixer\");\n\n\tmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\n\tif (!mixer)\n\t\treturn -ENOMEM;\n\tmixer->chip = chip;\n\tmixer->ignore_ctl_error = ignore_error;\n\tmixer->id_elems = kcalloc(MAX_ID_ELEMS, sizeof(*mixer->id_elems),\n\t\t\t\t  GFP_KERNEL);\n\tif (!mixer->id_elems) {\n\t\tkfree(mixer);\n\t\treturn -ENOMEM;\n\t}\n\n\tmixer->hostif = &usb_ifnum_to_if(chip->dev, ctrlif)->altsetting[0];\n\tswitch (get_iface_desc(mixer->hostif)->bInterfaceProtocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tmixer->protocol = UAC_VERSION_1;\n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\tmixer->protocol = UAC_VERSION_2;\n\t\tbreak;\n\t}\n\n\tif ((err = snd_usb_mixer_controls(mixer)) < 0 ||\n\t    (err = snd_usb_mixer_status_create(mixer)) < 0)\n\t\tgoto _error;\n\n\tsnd_usb_mixer_apply_create_quirk(mixer);\n\n\terr = snd_device_new(chip->card, SNDRV_DEV_CODEC, mixer, &dev_ops);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tif (list_empty(&chip->mixer_list) &&\n\t    !snd_card_proc_new(chip->card, \"usbmixer\", &entry))\n\t\tsnd_info_set_text_ops(entry, chip, snd_usb_mixer_proc_read);\n\n\tlist_add(&mixer->list, &chip->mixer_list);\n\treturn 0;\n\n_error:\n\tsnd_usb_mixer_free(mixer);\n\treturn err;\n}\n\nvoid snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}\n\n#ifdef CONFIG_PM\n/* stop any bus activity of a mixer */\nstatic void snd_usb_mixer_inactivate(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}\n\nstatic int snd_usb_mixer_activate(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\n\tif (mixer->urb) {\n\t\terr = usb_submit_urb(mixer->urb, GFP_NOIO);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_mixer_suspend(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_inactivate(mixer);\n\treturn 0;\n}\n\nstatic int restore_mixer_value(struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = (struct usb_mixer_elem_info *)list;\n\tint c, err, idx;\n\n\tif (cval->cmask) {\n\t\tidx = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\tif (cval->cached & (1 << (c + 1))) {\n\t\t\t\terr = snd_usb_set_cur_mix_value(cval, c + 1, idx,\n\t\t\t\t\t\t\tcval->cache_val[idx]);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t} else {\n\t\t/* master */\n\t\tif (cval->cached) {\n\t\t\terr = snd_usb_set_cur_mix_value(cval, 0, 0, *cval->cache_val);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_mixer_resume(struct usb_mixer_interface *mixer, bool reset_resume)\n{\n\tstruct usb_mixer_elem_list *list;\n\tint id, err;\n\n\tif (reset_resume) {\n\t\t/* restore cached mixer values */\n\t\tfor (id = 0; id < MAX_ID_ELEMS; id++) {\n\t\t\tfor (list = mixer->id_elems[id]; list;\n\t\t\t     list = list->next_id_elem) {\n\t\t\t\tif (list->resume) {\n\t\t\t\t\terr = list->resume(list);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snd_usb_mixer_activate(mixer);\n}\n#endif\n\nvoid snd_usb_mixer_elem_init_std(struct usb_mixer_elem_list *list,\n\t\t\t\t struct usb_mixer_interface *mixer,\n\t\t\t\t int unitid)\n{\n\tlist->mixer = mixer;\n\tlist->id = unitid;\n\tlist->dump = snd_usb_mixer_dump_cval;\n#ifdef CONFIG_PM\n\tlist->resume = restore_mixer_value;\n#endif\n}\n", "#ifndef __USBMIXER_H\n#define __USBMIXER_H\n\n#include <sound/info.h>\n\nstruct usb_mixer_interface {\n\tstruct snd_usb_audio *chip;\n\tstruct usb_host_interface *hostif;\n\tstruct list_head list;\n\tunsigned int ignore_ctl_error;\n\tstruct urb *urb;\n\t/* array[MAX_ID_ELEMS], indexed by unit id */\n\tstruct usb_mixer_elem_list **id_elems;\n\n\t/* the usb audio specification version this interface complies to */\n\tint protocol;\n\n\t/* Sound Blaster remote control stuff */\n\tconst struct rc_config *rc_cfg;\n\tu32 rc_code;\n\twait_queue_head_t rc_waitq;\n\tstruct urb *rc_urb;\n\tstruct usb_ctrlrequest *rc_setup_packet;\n\tu8 rc_buffer[6];\n};\n\n#define MAX_CHANNELS\t16\t/* max logical channels */\n\nenum {\n\tUSB_MIXER_BOOLEAN,\n\tUSB_MIXER_INV_BOOLEAN,\n\tUSB_MIXER_S8,\n\tUSB_MIXER_U8,\n\tUSB_MIXER_S16,\n\tUSB_MIXER_U16,\n\tUSB_MIXER_S32,\n\tUSB_MIXER_U32,\n};\n\ntypedef void (*usb_mixer_elem_dump_func_t)(struct snd_info_buffer *buffer,\n\t\t\t\t\t struct usb_mixer_elem_list *list);\ntypedef int (*usb_mixer_elem_resume_func_t)(struct usb_mixer_elem_list *elem);\n\nstruct usb_mixer_elem_list {\n\tstruct usb_mixer_interface *mixer;\n\tstruct usb_mixer_elem_list *next_id_elem; /* list of controls with same id */\n\tstruct snd_kcontrol *kctl;\n\tunsigned int id;\n\tusb_mixer_elem_dump_func_t dump;\n\tusb_mixer_elem_resume_func_t resume;\n};\n\nstruct usb_mixer_elem_info {\n\tstruct usb_mixer_elem_list head;\n\tunsigned int control;\t/* CS or ICN (high byte) */\n\tunsigned int cmask; /* channel mask bitmap: 0 = master */\n\tunsigned int idx_off; /* Control index offset */\n\tunsigned int ch_readonly;\n\tunsigned int master_readonly;\n\tint channels;\n\tint val_type;\n\tint min, max, res;\n\tint dBmin, dBmax;\n\tint cached;\n\tint cache_val[MAX_CHANNELS];\n\tu8 initialized;\n\tu8 min_mute;\n\tvoid *private_data;\n};\n\nint snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,\n\t\t\t int ignore_error);\nvoid snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer);\n\nvoid snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer, int unitid);\n\nint snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t\tint request, int validx, int value_set);\n\nint snd_usb_mixer_add_control(struct usb_mixer_elem_list *list,\n\t\t\t      struct snd_kcontrol *kctl);\n\nvoid snd_usb_mixer_elem_init_std(struct usb_mixer_elem_list *list,\n\t\t\t\t struct usb_mixer_interface *mixer,\n\t\t\t\t int unitid);\n\nint snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t  unsigned int size, unsigned int __user *_tlv);\n\n#ifdef CONFIG_PM\nint snd_usb_mixer_suspend(struct usb_mixer_interface *mixer);\nint snd_usb_mixer_resume(struct usb_mixer_interface *mixer, bool reset_resume);\n#endif\n\nint snd_usb_set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,\n                             int index, int value);\n\nint snd_usb_get_cur_mix_value(struct usb_mixer_elem_info *cval,\n                             int channel, int index, int *value);\n\nextern void snd_usb_mixer_elem_free(struct snd_kcontrol *kctl);\n\n#endif /* __USBMIXER_H */\n"], "fixing_code": ["/*\n *   (Tentative) USB Audio Driver for ALSA\n *\n *   Mixer control part\n *\n *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>\n *\n *   Many codes borrowed from audio.c by\n *\t    Alan Cox (alan@lxorguk.ukuu.org.uk)\n *\t    Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n */\n\n/*\n * TODOs, for both the mixer and the streaming interfaces:\n *\n *  - support for UAC2 effect units\n *  - support for graphical equalizers\n *  - RANGE and MEM set commands (UAC2)\n *  - RANGE and MEM interrupt dispatchers (UAC2)\n *  - audio channel clustering (UAC2)\n *  - audio sample rate converter units (UAC2)\n *  - proper handling of clock multipliers (UAC2)\n *  - dispatch clock change notifications (UAC2)\n *  \t- stop PCM streams which use a clock that became invalid\n *  \t- stop PCM streams which use a clock selector that has changed\n *  \t- parse available sample rates again when clock sources changed\n */\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/hwdep.h>\n#include <sound/info.h>\n#include <sound/tlv.h>\n\n#include \"usbaudio.h\"\n#include \"mixer.h\"\n#include \"helper.h\"\n#include \"mixer_quirks.h\"\n#include \"power.h\"\n\n#define MAX_ID_ELEMS\t256\n\nstruct usb_audio_term {\n\tint id;\n\tint type;\n\tint channels;\n\tunsigned int chconfig;\n\tint name;\n};\n\nstruct usbmix_name_map;\n\nstruct mixer_build {\n\tstruct snd_usb_audio *chip;\n\tstruct usb_mixer_interface *mixer;\n\tunsigned char *buffer;\n\tunsigned int buflen;\n\tDECLARE_BITMAP(unitbitmap, MAX_ID_ELEMS);\n\tstruct usb_audio_term oterm;\n\tconst struct usbmix_name_map *map;\n\tconst struct usbmix_selector_map *selector_map;\n};\n\n/*E-mu 0202/0404/0204 eXtension Unit(XU) control*/\nenum {\n\tUSB_XU_CLOCK_RATE \t\t= 0xe301,\n\tUSB_XU_CLOCK_SOURCE\t\t= 0xe302,\n\tUSB_XU_DIGITAL_IO_STATUS\t= 0xe303,\n\tUSB_XU_DEVICE_OPTIONS\t\t= 0xe304,\n\tUSB_XU_DIRECT_MONITORING\t= 0xe305,\n\tUSB_XU_METERING\t\t\t= 0xe306\n};\nenum {\n\tUSB_XU_CLOCK_SOURCE_SELECTOR = 0x02,\t/* clock source*/\n\tUSB_XU_CLOCK_RATE_SELECTOR = 0x03,\t/* clock rate */\n\tUSB_XU_DIGITAL_FORMAT_SELECTOR = 0x01,\t/* the spdif format */\n\tUSB_XU_SOFT_LIMIT_SELECTOR = 0x03\t/* soft limiter */\n};\n\n/*\n * manual mapping of mixer names\n * if the mixer topology is too complicated and the parsed names are\n * ambiguous, add the entries in usbmixer_maps.c.\n */\n#include \"mixer_maps.c\"\n\nstatic const struct usbmix_name_map *\nfind_map(struct mixer_build *state, int unitid, int control)\n{\n\tconst struct usbmix_name_map *p = state->map;\n\n\tif (!p)\n\t\treturn NULL;\n\n\tfor (p = state->map; p->id; p++) {\n\t\tif (p->id == unitid &&\n\t\t    (!control || !p->control || control == p->control))\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n/* get the mapped name if the unit matches */\nstatic int\ncheck_mapped_name(const struct usbmix_name_map *p, char *buf, int buflen)\n{\n\tif (!p || !p->name)\n\t\treturn 0;\n\n\tbuflen--;\n\treturn strlcpy(buf, p->name, buflen);\n}\n\n/* ignore the error value if ignore_ctl_error flag is set */\n#define filter_error(cval, err) \\\n\t((cval)->head.mixer->ignore_ctl_error ? 0 : (err))\n\n/* check whether the control should be ignored */\nstatic inline int\ncheck_ignored_ctl(const struct usbmix_name_map *p)\n{\n\tif (!p || p->name || p->dB)\n\t\treturn 0;\n\treturn 1;\n}\n\n/* dB mapping */\nstatic inline void check_mapped_dB(const struct usbmix_name_map *p,\n\t\t\t\t   struct usb_mixer_elem_info *cval)\n{\n\tif (p && p->dB) {\n\t\tcval->dBmin = p->dB->min;\n\t\tcval->dBmax = p->dB->max;\n\t\tcval->initialized = 1;\n\t}\n}\n\n/* get the mapped selector source name */\nstatic int check_mapped_selector_name(struct mixer_build *state, int unitid,\n\t\t\t\t      int index, char *buf, int buflen)\n{\n\tconst struct usbmix_selector_map *p;\n\n\tif (!state->selector_map)\n\t\treturn 0;\n\tfor (p = state->selector_map; p->id; p++) {\n\t\tif (p->id == unitid && index < p->count)\n\t\t\treturn strlcpy(buf, p->names[index], buflen);\n\t}\n\treturn 0;\n}\n\n/*\n * find an audio control unit with the given unit id\n */\nstatic void *find_audio_control_unit(struct mixer_build *state,\n\t\t\t\t     unsigned char unit)\n{\n\t/* we just parse the header */\n\tstruct uac_feature_unit_descriptor *hdr = NULL;\n\n\twhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\n\t\t\t\t\tUSB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (hdr->bLength >= 4 &&\n\t\t    hdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\n\t\t    hdr->bDescriptorSubtype <= UAC2_SAMPLE_RATE_CONVERTER &&\n\t\t    hdr->bUnitID == unit)\n\t\t\treturn hdr;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * copy a string with the given id\n */\nstatic int snd_usb_copy_string_desc(struct mixer_build *state,\n\t\t\t\t    int index, char *buf, int maxlen)\n{\n\tint len = usb_string(state->chip->dev, index, buf, maxlen - 1);\n\tbuf[len] = 0;\n\treturn len;\n}\n\n/*\n * convert from the byte/word on usb descriptor to the zero-based integer\n */\nstatic int convert_signed_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_U8:\n\t\tval &= 0xff;\n\t\tbreak;\n\tcase USB_MIXER_S8:\n\t\tval &= 0xff;\n\t\tif (val >= 0x80)\n\t\t\tval -= 0x100;\n\t\tbreak;\n\tcase USB_MIXER_U16:\n\t\tval &= 0xffff;\n\t\tbreak;\n\tcase USB_MIXER_S16:\n\t\tval &= 0xffff;\n\t\tif (val >= 0x8000)\n\t\t\tval -= 0x10000;\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n/*\n * convert from the zero-based int to the byte/word for usb descriptor\n */\nstatic int convert_bytes_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tswitch (cval->val_type) {\n\tcase USB_MIXER_BOOLEAN:\n\t\treturn !!val;\n\tcase USB_MIXER_INV_BOOLEAN:\n\t\treturn !val;\n\tcase USB_MIXER_S8:\n\tcase USB_MIXER_U8:\n\t\treturn val & 0xff;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn val & 0xffff;\n\t}\n\treturn 0; /* not reached */\n}\n\nstatic int get_relative_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tif (!cval->res)\n\t\tcval->res = 1;\n\tif (val < cval->min)\n\t\treturn 0;\n\telse if (val >= cval->max)\n\t\treturn (cval->max - cval->min + cval->res - 1) / cval->res;\n\telse\n\t\treturn (val - cval->min) / cval->res;\n}\n\nstatic int get_abs_value(struct usb_mixer_elem_info *cval, int val)\n{\n\tif (val < 0)\n\t\treturn cval->min;\n\tif (!cval->res)\n\t\tcval->res = 1;\n\tval *= cval->res;\n\tval += cval->min;\n\tif (val > cval->max)\n\t\treturn cval->max;\n\treturn val;\n}\n\nstatic int uac2_ctl_value_size(int val_type)\n{\n\tswitch (val_type) {\n\tcase USB_MIXER_S32:\n\tcase USB_MIXER_U32:\n\t\treturn 4;\n\tcase USB_MIXER_S16:\n\tcase USB_MIXER_U16:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0; /* unreachable */\n}\n\n\n/*\n * retrieve a mixer value\n */\n\nstatic int get_ctl_value_v1(struct usb_mixer_elem_info *cval, int request,\n\t\t\t    int validx, int *value_ret)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[2];\n\tint val_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\n\tint timeout = 10;\n\tint idx = 0, err;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn -EIO;\n\n\twhile (timeout-- > 0) {\n\t\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\t\terr = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), request,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t\t      validx, idx, buf, val_len);\n\t\tif (err >= val_len) {\n\t\t\t*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(buf, val_len));\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (err == -ETIMEDOUT) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tusb_audio_dbg(chip,\n\t\t\"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\trequest, validx, idx, cval->val_type);\n\terr = -EINVAL;\n\n out:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int get_ctl_value_v2(struct usb_mixer_elem_info *cval, int request,\n\t\t\t    int validx, int *value_ret)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[4 + 3 * sizeof(__u32)]; /* enough space for one range */\n\tunsigned char *val;\n\tint idx = 0, ret, size;\n\t__u8 bRequest;\n\n\tif (request == UAC_GET_CUR) {\n\t\tbRequest = UAC2_CS_CUR;\n\t\tsize = uac2_ctl_value_size(cval->val_type);\n\t} else {\n\t\tbRequest = UAC2_CS_RANGE;\n\t\tsize = sizeof(buf);\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tret = snd_usb_lock_shutdown(chip) ? -EIO : 0;\n\tif (ret)\n\t\tgoto error;\n\n\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\tret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,\n\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,\n\t\t\t      validx, idx, buf, size);\n\tsnd_usb_unlock_shutdown(chip);\n\n\tif (ret < 0) {\nerror:\n\t\tusb_audio_err(chip,\n\t\t\t\"cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d\\n\",\n\t\t\trequest, validx, idx, cval->val_type);\n\t\treturn ret;\n\t}\n\n\t/* FIXME: how should we handle multiple triplets here? */\n\n\tswitch (request) {\n\tcase UAC_GET_CUR:\n\t\tval = buf;\n\t\tbreak;\n\tcase UAC_GET_MIN:\n\t\tval = buf + sizeof(__u16);\n\t\tbreak;\n\tcase UAC_GET_MAX:\n\t\tval = buf + sizeof(__u16) * 2;\n\t\tbreak;\n\tcase UAC_GET_RES:\n\t\tval = buf + sizeof(__u16) * 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(val, sizeof(__u16)));\n\n\treturn 0;\n}\n\nstatic int get_ctl_value(struct usb_mixer_elem_info *cval, int request,\n\t\t\t int validx, int *value_ret)\n{\n\tvalidx += cval->idx_off;\n\n\treturn (cval->head.mixer->protocol == UAC_VERSION_1) ?\n\t\tget_ctl_value_v1(cval, request, validx, value_ret) :\n\t\tget_ctl_value_v2(cval, request, validx, value_ret);\n}\n\nstatic int get_cur_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int validx, int *value)\n{\n\treturn get_ctl_value(cval, UAC_GET_CUR, validx, value);\n}\n\n/* channel = 0: master, 1 = first channel */\nstatic inline int get_cur_mix_raw(struct usb_mixer_elem_info *cval,\n\t\t\t\t  int channel, int *value)\n{\n\treturn get_ctl_value(cval, UAC_GET_CUR,\n\t\t\t     (cval->control << 8) | channel,\n\t\t\t     value);\n}\n\nint snd_usb_get_cur_mix_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int channel, int index, int *value)\n{\n\tint err;\n\n\tif (cval->cached & (1 << channel)) {\n\t\t*value = cval->cache_val[index];\n\t\treturn 0;\n\t}\n\terr = get_cur_mix_raw(cval, channel, value);\n\tif (err < 0) {\n\t\tif (!cval->head.mixer->ignore_ctl_error)\n\t\t\tusb_audio_dbg(cval->head.mixer->chip,\n\t\t\t\t\"cannot get current value for control %d ch %d: err = %d\\n\",\n\t\t\t\t      cval->control, channel, err);\n\t\treturn err;\n\t}\n\tcval->cached |= 1 << channel;\n\tcval->cache_val[index] = *value;\n\treturn 0;\n}\n\n/*\n * set a mixer value\n */\n\nint snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t\tint request, int validx, int value_set)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tunsigned char buf[4];\n\tint idx = 0, val_len, err, timeout = 10;\n\n\tvalidx += cval->idx_off;\n\n\tif (cval->head.mixer->protocol == UAC_VERSION_1) {\n\t\tval_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;\n\t} else { /* UAC_VERSION_2 */\n\t\tval_len = uac2_ctl_value_size(cval->val_type);\n\n\t\t/* FIXME */\n\t\tif (request != UAC_SET_CUR) {\n\t\t\tusb_audio_dbg(chip, \"RANGE setting not yet supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trequest = UAC2_CS_CUR;\n\t}\n\n\tvalue_set = convert_bytes_value(cval, value_set);\n\tbuf[0] = value_set & 0xff;\n\tbuf[1] = (value_set >> 8) & 0xff;\n\tbuf[2] = (value_set >> 16) & 0xff;\n\tbuf[3] = (value_set >> 24) & 0xff;\n\n\terr = snd_usb_lock_shutdown(chip);\n\tif (err < 0)\n\t\treturn -EIO;\n\n\twhile (timeout-- > 0) {\n\t\tidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);\n\t\terr = snd_usb_ctl_msg(chip->dev,\n\t\t\t\t      usb_sndctrlpipe(chip->dev, 0), request,\n\t\t\t\t      USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_OUT,\n\t\t\t\t      validx, idx, buf, val_len);\n\t\tif (err >= 0) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (err == -ETIMEDOUT) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tusb_audio_dbg(chip, \"cannot set ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d, data = %#x/%#x\\n\",\n\t\t      request, validx, idx, cval->val_type, buf[0], buf[1]);\n\terr = -EINVAL;\n\n out:\n\tsnd_usb_unlock_shutdown(chip);\n\treturn err;\n}\n\nstatic int set_cur_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t     int validx, int value)\n{\n\treturn snd_usb_mixer_set_ctl_value(cval, UAC_SET_CUR, validx, value);\n}\n\nint snd_usb_set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,\n\t\t\t     int index, int value)\n{\n\tint err;\n\tunsigned int read_only = (channel == 0) ?\n\t\tcval->master_readonly :\n\t\tcval->ch_readonly & (1 << (channel - 1));\n\n\tif (read_only) {\n\t\tusb_audio_dbg(cval->head.mixer->chip,\n\t\t\t      \"%s(): channel %d of control %d is read_only\\n\",\n\t\t\t    __func__, channel, cval->control);\n\t\treturn 0;\n\t}\n\n\terr = snd_usb_mixer_set_ctl_value(cval,\n\t\t\t\t\t  UAC_SET_CUR, (cval->control << 8) | channel,\n\t\t\t\t\t  value);\n\tif (err < 0)\n\t\treturn err;\n\tcval->cached |= 1 << channel;\n\tcval->cache_val[index] = value;\n\treturn 0;\n}\n\n/*\n * TLV callback for mixer volume controls\n */\nint snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t unsigned int size, unsigned int __user *_tlv)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tDECLARE_TLV_DB_MINMAX(scale, 0, 0);\n\n\tif (size < sizeof(scale))\n\t\treturn -ENOMEM;\n\tif (cval->min_mute)\n\t\tscale[0] = SNDRV_CTL_TLVT_DB_MINMAX_MUTE;\n\tscale[2] = cval->dBmin;\n\tscale[3] = cval->dBmax;\n\tif (copy_to_user(_tlv, scale, sizeof(scale)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n/*\n * parser routines begin here...\n */\n\nstatic int parse_audio_unit(struct mixer_build *state, int unitid);\n\n\n/*\n * check if the input/output channel routing is enabled on the given bitmap.\n * used for mixer unit parser\n */\nstatic int check_matrix_bitmap(unsigned char *bmap,\n\t\t\t       int ich, int och, int num_outs)\n{\n\tint idx = ich * num_outs + och;\n\treturn bmap[idx >> 3] & (0x80 >> (idx & 7));\n}\n\n/*\n * add an alsa control element\n * search and increment the index until an empty slot is found.\n *\n * if failed, give up and free the control instance.\n */\n\nint snd_usb_mixer_add_control(struct usb_mixer_elem_list *list,\n\t\t\t      struct snd_kcontrol *kctl)\n{\n\tstruct usb_mixer_interface *mixer = list->mixer;\n\tint err;\n\n\twhile (snd_ctl_find_id(mixer->chip->card, &kctl->id))\n\t\tkctl->id.index++;\n\tif ((err = snd_ctl_add(mixer->chip->card, kctl)) < 0) {\n\t\tusb_audio_dbg(mixer->chip, \"cannot add control (err = %d)\\n\",\n\t\t\t      err);\n\t\treturn err;\n\t}\n\tlist->kctl = kctl;\n\tlist->next_id_elem = mixer->id_elems[list->id];\n\tmixer->id_elems[list->id] = list;\n\treturn 0;\n}\n\n/*\n * get a terminal name string\n */\n\nstatic struct iterm_name_combo {\n\tint type;\n\tchar *name;\n} iterm_names[] = {\n\t{ 0x0300, \"Output\" },\n\t{ 0x0301, \"Speaker\" },\n\t{ 0x0302, \"Headphone\" },\n\t{ 0x0303, \"HMD Audio\" },\n\t{ 0x0304, \"Desktop Speaker\" },\n\t{ 0x0305, \"Room Speaker\" },\n\t{ 0x0306, \"Com Speaker\" },\n\t{ 0x0307, \"LFE\" },\n\t{ 0x0600, \"External In\" },\n\t{ 0x0601, \"Analog In\" },\n\t{ 0x0602, \"Digital In\" },\n\t{ 0x0603, \"Line\" },\n\t{ 0x0604, \"Legacy In\" },\n\t{ 0x0605, \"IEC958 In\" },\n\t{ 0x0606, \"1394 DA Stream\" },\n\t{ 0x0607, \"1394 DV Stream\" },\n\t{ 0x0700, \"Embedded\" },\n\t{ 0x0701, \"Noise Source\" },\n\t{ 0x0702, \"Equalization Noise\" },\n\t{ 0x0703, \"CD\" },\n\t{ 0x0704, \"DAT\" },\n\t{ 0x0705, \"DCC\" },\n\t{ 0x0706, \"MiniDisk\" },\n\t{ 0x0707, \"Analog Tape\" },\n\t{ 0x0708, \"Phonograph\" },\n\t{ 0x0709, \"VCR Audio\" },\n\t{ 0x070a, \"Video Disk Audio\" },\n\t{ 0x070b, \"DVD Audio\" },\n\t{ 0x070c, \"TV Tuner Audio\" },\n\t{ 0x070d, \"Satellite Rec Audio\" },\n\t{ 0x070e, \"Cable Tuner Audio\" },\n\t{ 0x070f, \"DSS Audio\" },\n\t{ 0x0710, \"Radio Receiver\" },\n\t{ 0x0711, \"Radio Transmitter\" },\n\t{ 0x0712, \"Multi-Track Recorder\" },\n\t{ 0x0713, \"Synthesizer\" },\n\t{ 0 },\n};\n\nstatic int get_term_name(struct mixer_build *state, struct usb_audio_term *iterm,\n\t\t\t unsigned char *name, int maxlen, int term_only)\n{\n\tstruct iterm_name_combo *names;\n\n\tif (iterm->name)\n\t\treturn snd_usb_copy_string_desc(state, iterm->name,\n\t\t\t\t\t\tname, maxlen);\n\n\t/* virtual type - not a real terminal */\n\tif (iterm->type >> 16) {\n\t\tif (term_only)\n\t\t\treturn 0;\n\t\tswitch (iterm->type >> 16) {\n\t\tcase UAC_SELECTOR_UNIT:\n\t\t\tstrcpy(name, \"Selector\");\n\t\t\treturn 8;\n\t\tcase UAC1_PROCESSING_UNIT:\n\t\t\tstrcpy(name, \"Process Unit\");\n\t\t\treturn 12;\n\t\tcase UAC1_EXTENSION_UNIT:\n\t\t\tstrcpy(name, \"Ext Unit\");\n\t\t\treturn 8;\n\t\tcase UAC_MIXER_UNIT:\n\t\t\tstrcpy(name, \"Mixer\");\n\t\t\treturn 5;\n\t\tdefault:\n\t\t\treturn sprintf(name, \"Unit %d\", iterm->id);\n\t\t}\n\t}\n\n\tswitch (iterm->type & 0xff00) {\n\tcase 0x0100:\n\t\tstrcpy(name, \"PCM\");\n\t\treturn 3;\n\tcase 0x0200:\n\t\tstrcpy(name, \"Mic\");\n\t\treturn 3;\n\tcase 0x0400:\n\t\tstrcpy(name, \"Headset\");\n\t\treturn 7;\n\tcase 0x0500:\n\t\tstrcpy(name, \"Phone\");\n\t\treturn 5;\n\t}\n\n\tfor (names = iterm_names; names->type; names++) {\n\t\tif (names->type == iterm->type) {\n\t\t\tstrcpy(name, names->name);\n\t\t\treturn strlen(names->name);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * parse the source unit recursively until it reaches to a terminal\n * or a branched unit.\n */\nstatic int check_input_term(struct mixer_build *state, int id,\n\t\t\t    struct usb_audio_term *term)\n{\n\tint err;\n\tvoid *p1;\n\n\tmemset(term, 0, sizeof(*term));\n\twhile ((p1 = find_audio_control_unit(state, id)) != NULL) {\n\t\tunsigned char *hdr = p1;\n\t\tterm->id = id;\n\t\tswitch (hdr[2]) {\n\t\tcase UAC_INPUT_TERMINAL:\n\t\t\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t\t\tstruct uac_input_terminal_descriptor *d = p1;\n\t\t\t\tterm->type = le16_to_cpu(d->wTerminalType);\n\t\t\t\tterm->channels = d->bNrChannels;\n\t\t\t\tterm->chconfig = le16_to_cpu(d->wChannelConfig);\n\t\t\t\tterm->name = d->iTerminal;\n\t\t\t} else { /* UAC_VERSION_2 */\n\t\t\t\tstruct uac2_input_terminal_descriptor *d = p1;\n\n\t\t\t\t/* call recursively to verify that the\n\t\t\t\t * referenced clock entity is valid */\n\t\t\t\terr = check_input_term(state, d->bCSourceID, term);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\n\t\t\t\t/* save input term properties after recursion,\n\t\t\t\t * to ensure they are not overriden by the\n\t\t\t\t * recursion calls */\n\t\t\t\tterm->id = id;\n\t\t\t\tterm->type = le16_to_cpu(d->wTerminalType);\n\t\t\t\tterm->channels = d->bNrChannels;\n\t\t\t\tterm->chconfig = le32_to_cpu(d->bmChannelConfig);\n\t\t\t\tterm->name = d->iTerminal;\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase UAC_FEATURE_UNIT: {\n\t\t\t/* the header is the same for v1 and v2 */\n\t\t\tstruct uac_feature_unit_descriptor *d = p1;\n\t\t\tid = d->bSourceID;\n\t\t\tbreak; /* continue to parse */\n\t\t}\n\t\tcase UAC_MIXER_UNIT: {\n\t\t\tstruct uac_mixer_unit_descriptor *d = p1;\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->channels = uac_mixer_unit_bNrChannels(d);\n\t\t\tterm->chconfig = uac_mixer_unit_wChannelConfig(d, state->mixer->protocol);\n\t\t\tterm->name = uac_mixer_unit_iMixer(d);\n\t\t\treturn 0;\n\t\t}\n\t\tcase UAC_SELECTOR_UNIT:\n\t\tcase UAC2_CLOCK_SELECTOR: {\n\t\t\tstruct uac_selector_unit_descriptor *d = p1;\n\t\t\t/* call recursively to retrieve the channel info */\n\t\t\terr = check_input_term(state, d->baSourceID[0], term);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->id = id;\n\t\t\tterm->name = uac_selector_unit_iSelector(d);\n\t\t\treturn 0;\n\t\t}\n\t\tcase UAC1_PROCESSING_UNIT:\n\t\tcase UAC1_EXTENSION_UNIT:\n\t\t/* UAC2_PROCESSING_UNIT_V2 */\n\t\t/* UAC2_EFFECT_UNIT */\n\t\tcase UAC2_EXTENSION_UNIT_V2: {\n\t\t\tstruct uac_processing_unit_descriptor *d = p1;\n\n\t\t\tif (state->mixer->protocol == UAC_VERSION_2 &&\n\t\t\t\thdr[2] == UAC2_EFFECT_UNIT) {\n\t\t\t\t/* UAC2/UAC1 unit IDs overlap here in an\n\t\t\t\t * uncompatible way. Ignore this unit for now.\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (d->bNrInPins) {\n\t\t\t\tid = d->baSourceID[0];\n\t\t\t\tbreak; /* continue to parse */\n\t\t\t}\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->channels = uac_processing_unit_bNrChannels(d);\n\t\t\tterm->chconfig = uac_processing_unit_wChannelConfig(d, state->mixer->protocol);\n\t\t\tterm->name = uac_processing_unit_iProcessing(d, state->mixer->protocol);\n\t\t\treturn 0;\n\t\t}\n\t\tcase UAC2_CLOCK_SOURCE: {\n\t\t\tstruct uac_clock_source_descriptor *d = p1;\n\t\t\tterm->type = d->bDescriptorSubtype << 16; /* virtual type */\n\t\t\tterm->id = id;\n\t\t\tterm->name = d->iClockSource;\n\t\t\treturn 0;\n\t\t}\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Feature Unit\n */\n\n/* feature unit control information */\nstruct usb_feature_control_info {\n\tconst char *name;\n\tint type;\t/* data type for uac1 */\n\tint type_uac2;\t/* data type for uac2 if different from uac1, else -1 */\n};\n\nstatic struct usb_feature_control_info audio_feature_info[] = {\n\t{ \"Mute\",\t\t\tUSB_MIXER_INV_BOOLEAN, -1 },\n\t{ \"Volume\",\t\t\tUSB_MIXER_S16, -1 },\n\t{ \"Tone Control - Bass\",\tUSB_MIXER_S8, -1 },\n\t{ \"Tone Control - Mid\",\t\tUSB_MIXER_S8, -1 },\n\t{ \"Tone Control - Treble\",\tUSB_MIXER_S8, -1 },\n\t{ \"Graphic Equalizer\",\t\tUSB_MIXER_S8, -1 }, /* FIXME: not implemeted yet */\n\t{ \"Auto Gain Control\",\t\tUSB_MIXER_BOOLEAN, -1 },\n\t{ \"Delay Control\",\t\tUSB_MIXER_U16, USB_MIXER_U32 },\n\t{ \"Bass Boost\",\t\t\tUSB_MIXER_BOOLEAN, -1 },\n\t{ \"Loudness\",\t\t\tUSB_MIXER_BOOLEAN, -1 },\n\t/* UAC2 specific */\n\t{ \"Input Gain Control\",\t\tUSB_MIXER_S16, -1 },\n\t{ \"Input Gain Pad Control\",\tUSB_MIXER_S16, -1 },\n\t{ \"Phase Inverter Control\",\tUSB_MIXER_BOOLEAN, -1 },\n};\n\n/* private_free callback */\nvoid snd_usb_mixer_elem_free(struct snd_kcontrol *kctl)\n{\n\tkfree(kctl->private_data);\n\tkctl->private_data = NULL;\n}\n\n/*\n * interface to ALSA control for feature/mixer units\n */\n\n/* volume control quirks */\nstatic void volume_control_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t  struct snd_kcontrol *kctl)\n{\n\tstruct snd_usb_audio *chip = cval->head.mixer->chip;\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x0763, 0x2030): /* M-Audio Fast Track C400 */\n\tcase USB_ID(0x0763, 0x2031): /* M-Audio Fast Track C600 */\n\t\tif (strcmp(kctl->id.name, \"Effect Duration\") == 0) {\n\t\t\tcval->min = 0x0000;\n\t\t\tcval->max = 0xffff;\n\t\t\tcval->res = 0x00e6;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(kctl->id.name, \"Effect Volume\") == 0 ||\n\t\t    strcmp(kctl->id.name, \"Effect Feedback Volume\") == 0) {\n\t\t\tcval->min = 0x00;\n\t\t\tcval->max = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tif (strstr(kctl->id.name, \"Effect Return\") != NULL) {\n\t\t\tcval->min = 0xb706;\n\t\t\tcval->max = 0xff7b;\n\t\t\tcval->res = 0x0073;\n\t\t\tbreak;\n\t\t}\n\t\tif ((strstr(kctl->id.name, \"Playback Volume\") != NULL) ||\n\t\t\t(strstr(kctl->id.name, \"Effect Send\") != NULL)) {\n\t\t\tcval->min = 0xb5fb; /* -73 dB = 0xb6ff */\n\t\t\tcval->max = 0xfcfe;\n\t\t\tcval->res = 0x0073;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0763, 0x2081): /* M-Audio Fast Track Ultra 8R */\n\tcase USB_ID(0x0763, 0x2080): /* M-Audio Fast Track Ultra */\n\t\tif (strcmp(kctl->id.name, \"Effect Duration\") == 0) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"set quirk for FTU Effect Duration\\n\");\n\t\t\tcval->min = 0x0000;\n\t\t\tcval->max = 0x7f00;\n\t\t\tcval->res = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t\tif (strcmp(kctl->id.name, \"Effect Volume\") == 0 ||\n\t\t    strcmp(kctl->id.name, \"Effect Feedback Volume\") == 0) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t       \"set quirks for FTU Effect Feedback/Volume\\n\");\n\t\t\tcval->min = 0x00;\n\t\t\tcval->max = 0x7f;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x0471, 0x0101):\n\tcase USB_ID(0x0471, 0x0104):\n\tcase USB_ID(0x0471, 0x0105):\n\tcase USB_ID(0x0672, 0x1041):\n\t/* quirk for UDA1321/N101.\n\t * note that detection between firmware 2.1.1.7 (N101)\n\t * and later 2.1.1.21 is not very clear from datasheets.\n\t * I hope that the min value is -15360 for newer firmware --jk\n\t */\n\t\tif (!strcmp(kctl->id.name, \"PCM Playback Volume\") &&\n\t\t    cval->min == -15616) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t \"set volume quirk for UDA1321/N101 chip\\n\");\n\t\t\tcval->max = -256;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x046d, 0x09a4):\n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set volume quirk for QuickCam E3500\\n\");\n\t\t\tcval->min = 6080;\n\t\t\tcval->max = 8768;\n\t\t\tcval->res = 192;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ID(0x046d, 0x0807): /* Logitech Webcam C500 */\n\tcase USB_ID(0x046d, 0x0808):\n\tcase USB_ID(0x046d, 0x0809):\n\tcase USB_ID(0x046d, 0x0819): /* Logitech Webcam C210 */\n\tcase USB_ID(0x046d, 0x081b): /* HD Webcam c310 */\n\tcase USB_ID(0x046d, 0x081d): /* HD Webcam c510 */\n\tcase USB_ID(0x046d, 0x0825): /* HD Webcam c270 */\n\tcase USB_ID(0x046d, 0x0826): /* HD Webcam c525 */\n\tcase USB_ID(0x046d, 0x08ca): /* Logitech Quickcam Fusion */\n\tcase USB_ID(0x046d, 0x0991):\n\tcase USB_ID(0x046d, 0x09a2): /* QuickCam Communicate Deluxe/S7500 */\n\t/* Most audio usb devices lie about volume resolution.\n\t * Most Logitech webcams have res = 384.\n\t * Probably there is some logitech magic behind this number --fishor\n\t */\n\t\tif (!strcmp(kctl->id.name, \"Mic Capture Volume\")) {\n\t\t\tusb_audio_info(chip,\n\t\t\t\t\"set resolution quirk: cval->res = 384\\n\");\n\t\t\tcval->res = 384;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n/*\n * retrieve the minimum and maximum values for the specified control\n */\nstatic int get_min_max_with_quirks(struct usb_mixer_elem_info *cval,\n\t\t\t\t   int default_min, struct snd_kcontrol *kctl)\n{\n\t/* for failsafe */\n\tcval->min = default_min;\n\tcval->max = cval->min + 1;\n\tcval->res = 1;\n\tcval->dBmin = cval->dBmax = 0;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tcval->initialized = 1;\n\t} else {\n\t\tint minchn = 0;\n\t\tif (cval->cmask) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < MAX_CHANNELS; i++)\n\t\t\t\tif (cval->cmask & (1 << i)) {\n\t\t\t\t\tminchn = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||\n\t\t    get_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {\n\t\t\tusb_audio_err(cval->head.mixer->chip,\n\t\t\t\t      \"%d:%d: cannot get min/max values for control %d (id %d)\\n\",\n\t\t\t\t   cval->head.id, snd_usb_ctrl_intf(cval->head.mixer->chip),\n\t\t\t\t\t\t\t       cval->control, cval->head.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t  (cval->control << 8) | minchn,\n\t\t\t\t  &cval->res) < 0) {\n\t\t\tcval->res = 1;\n\t\t} else {\n\t\t\tint last_valid_res = cval->res;\n\n\t\t\twhile (cval->res > 1) {\n\t\t\t\tif (snd_usb_mixer_set_ctl_value(cval, UAC_SET_RES,\n\t\t\t\t\t\t\t\t(cval->control << 8) | minchn,\n\t\t\t\t\t\t\t\tcval->res / 2) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res /= 2;\n\t\t\t}\n\t\t\tif (get_ctl_value(cval, UAC_GET_RES,\n\t\t\t\t\t  (cval->control << 8) | minchn, &cval->res) < 0)\n\t\t\t\tcval->res = last_valid_res;\n\t\t}\n\t\tif (cval->res == 0)\n\t\t\tcval->res = 1;\n\n\t\t/* Additional checks for the proper resolution\n\t\t *\n\t\t * Some devices report smaller resolutions than actually\n\t\t * reacting.  They don't return errors but simply clip\n\t\t * to the lower aligned value.\n\t\t */\n\t\tif (cval->min + cval->res < cval->max) {\n\t\t\tint last_valid_res = cval->res;\n\t\t\tint saved, test, check;\n\t\t\tget_cur_mix_raw(cval, minchn, &saved);\n\t\t\tfor (;;) {\n\t\t\t\ttest = saved;\n\t\t\t\tif (test < cval->max)\n\t\t\t\t\ttest += cval->res;\n\t\t\t\telse\n\t\t\t\t\ttest -= cval->res;\n\t\t\t\tif (test < cval->min || test > cval->max ||\n\t\t\t\t    snd_usb_set_cur_mix_value(cval, minchn, 0, test) ||\n\t\t\t\t    get_cur_mix_raw(cval, minchn, &check)) {\n\t\t\t\t\tcval->res = last_valid_res;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (test == check)\n\t\t\t\t\tbreak;\n\t\t\t\tcval->res *= 2;\n\t\t\t}\n\t\t\tsnd_usb_set_cur_mix_value(cval, minchn, 0, saved);\n\t\t}\n\n\t\tcval->initialized = 1;\n\t}\n\n\tif (kctl)\n\t\tvolume_control_quirks(cval, kctl);\n\n\t/* USB descriptions contain the dB scale in 1/256 dB unit\n\t * while ALSA TLV contains in 1/100 dB unit\n\t */\n\tcval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;\n\tcval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;\n\tif (cval->dBmin > cval->dBmax) {\n\t\t/* something is wrong; assume it's either from/to 0dB */\n\t\tif (cval->dBmin < 0)\n\t\t\tcval->dBmax = 0;\n\t\telse if (cval->dBmin > 0)\n\t\t\tcval->dBmin = 0;\n\t\tif (cval->dBmin > cval->dBmax) {\n\t\t\t/* totally crap, return an error */\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define get_min_max(cval, def)\tget_min_max_with_quirks(cval, def, NULL)\n\n/* get a feature/mixer unit info */\nstatic int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = cval->channels;\n\tif (cval->val_type == USB_MIXER_BOOLEAN ||\n\t    cval->val_type == USB_MIXER_INV_BOOLEAN) {\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max = 1;\n\t} else {\n\t\tif (!cval->initialized) {\n\t\t\tget_min_max_with_quirks(cval, 0, kcontrol);\n\t\t\tif (cval->initialized && cval->dBmin >= cval->dBmax) {\n\t\t\t\tkcontrol->vd[0].access &= \n\t\t\t\t\t~(SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\t\t  SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK);\n\t\t\t\tsnd_ctl_notify(cval->head.mixer->chip->card,\n\t\t\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t\t\t       &kcontrol->id);\n\t\t\t}\n\t\t}\n\t\tuinfo->value.integer.min = 0;\n\t\tuinfo->value.integer.max =\n\t\t\t(cval->max - cval->min + cval->res - 1) / cval->res;\n\t}\n\treturn 0;\n}\n\n/* get the current value from feature/mixer unit */\nstatic int mixer_ctl_feature_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint c, cnt, val, err;\n\n\tucontrol->value.integer.value[0] = cval->min;\n\tif (cval->cmask) {\n\t\tcnt = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\terr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &val);\n\t\t\tif (err < 0)\n\t\t\t\treturn filter_error(cval, err);\n\t\t\tval = get_relative_value(cval, val);\n\t\t\tucontrol->value.integer.value[cnt] = val;\n\t\t\tcnt++;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\t/* master channel */\n\t\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &val);\n\t\tif (err < 0)\n\t\t\treturn filter_error(cval, err);\n\t\tval = get_relative_value(cval, val);\n\t\tucontrol->value.integer.value[0] = val;\n\t}\n\treturn 0;\n}\n\n/* put the current value to feature/mixer unit */\nstatic int mixer_ctl_feature_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint c, cnt, val, oval, err;\n\tint changed = 0;\n\n\tif (cval->cmask) {\n\t\tcnt = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\terr = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &oval);\n\t\t\tif (err < 0)\n\t\t\t\treturn filter_error(cval, err);\n\t\t\tval = ucontrol->value.integer.value[cnt];\n\t\t\tval = get_abs_value(cval, val);\n\t\t\tif (oval != val) {\n\t\t\t\tsnd_usb_set_cur_mix_value(cval, c + 1, cnt, val);\n\t\t\t\tchanged = 1;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t} else {\n\t\t/* master channel */\n\t\terr = snd_usb_get_cur_mix_value(cval, 0, 0, &oval);\n\t\tif (err < 0)\n\t\t\treturn filter_error(cval, err);\n\t\tval = ucontrol->value.integer.value[0];\n\t\tval = get_abs_value(cval, val);\n\t\tif (val != oval) {\n\t\t\tsnd_usb_set_cur_mix_value(cval, 0, 0, val);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\treturn changed;\n}\n\nstatic struct snd_kcontrol_new usb_feature_unit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later manually */\n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_feature_get,\n\t.put = mixer_ctl_feature_put,\n};\n\n/* the read-only variant */\nstatic const struct snd_kcontrol_new usb_feature_unit_ctl_ro = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later manually */\n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_feature_get,\n\t.put = NULL,\n};\n\n/*\n * This symbol is exported in order to allow the mixer quirks to\n * hook up to the standard feature unit control mechanism\n */\nstruct snd_kcontrol_new *snd_usb_feature_unit_ctl = &usb_feature_unit_ctl;\n\n/*\n * build a feature control\n */\nstatic size_t append_ctl_name(struct snd_kcontrol *kctl, const char *str)\n{\n\treturn strlcat(kctl->id.name, str, sizeof(kctl->id.name));\n}\n\n/*\n * A lot of headsets/headphones have a \"Speaker\" mixer. Make sure we\n * rename it to \"Headphone\". We determine if something is a headphone\n * similar to how udev determines form factor.\n */\nstatic void check_no_speaker_on_headset(struct snd_kcontrol *kctl,\n\t\t\t\t\tstruct snd_card *card)\n{\n\tconst char *names_to_check[] = {\n\t\t\"Headset\", \"headset\", \"Headphone\", \"headphone\", NULL};\n\tconst char **s;\n\tbool found = false;\n\n\tif (strcmp(\"Speaker\", kctl->id.name))\n\t\treturn;\n\n\tfor (s = names_to_check; *s; s++)\n\t\tif (strstr(card->shortname, *s)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found)\n\t\treturn;\n\n\tstrlcpy(kctl->id.name, \"Headphone\", sizeof(kctl->id.name));\n}\n\nstatic void build_feature_ctl(struct mixer_build *state, void *raw_desc,\n\t\t\t      unsigned int ctl_mask, int control,\n\t\t\t      struct usb_audio_term *iterm, int unitid,\n\t\t\t      int readonly_mask)\n{\n\tstruct uac_feature_unit_descriptor *desc = raw_desc;\n\tstruct usb_feature_control_info *ctl_info;\n\tunsigned int len = 0;\n\tint mapped_name = 0;\n\tint nameid = uac_feature_unit_iFeature(desc);\n\tstruct snd_kcontrol *kctl;\n\tstruct usb_mixer_elem_info *cval;\n\tconst struct usbmix_name_map *map;\n\tunsigned int range;\n\n\tcontrol++; /* change from zero-based to 1-based value */\n\n\tif (control == UAC_FU_GRAPHIC_EQUALIZER) {\n\t\t/* FIXME: not supported yet */\n\t\treturn;\n\t}\n\n\tmap = find_map(state, unitid, control);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->control = control;\n\tcval->cmask = ctl_mask;\n\tctl_info = &audio_feature_info[control-1];\n\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\tcval->val_type = ctl_info->type;\n\telse /* UAC_VERSION_2 */\n\t\tcval->val_type = ctl_info->type_uac2 >= 0 ?\n\t\t\tctl_info->type_uac2 : ctl_info->type;\n\n\tif (ctl_mask == 0) {\n\t\tcval->channels = 1;\t/* master channel */\n\t\tcval->master_readonly = readonly_mask;\n\t} else {\n\t\tint i, c = 0;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (ctl_mask & (1 << i))\n\t\t\t\tc++;\n\t\tcval->channels = c;\n\t\tcval->ch_readonly = readonly_mask;\n\t}\n\n\t/*\n\t * If all channels in the mask are marked read-only, make the control\n\t * read-only. snd_usb_set_cur_mix_value() will check the mask again and won't\n\t * issue write commands to read-only channels.\n\t */\n\tif (cval->channels == readonly_mask)\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\n\telse\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\n\tif (!kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tkfree(cval);\n\t\treturn;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tmapped_name = len != 0;\n\tif (!len && nameid)\n\t\tlen = snd_usb_copy_string_desc(state, nameid,\n\t\t\t\tkctl->id.name, sizeof(kctl->id.name));\n\n\tswitch (control) {\n\tcase UAC_FU_MUTE:\n\tcase UAC_FU_VOLUME:\n\t\t/*\n\t\t * determine the control name.  the rule is:\n\t\t * - if a name id is given in descriptor, use it.\n\t\t * - if the connected input can be determined, then use the name\n\t\t *   of terminal type.\n\t\t * - if the connected output can be determined, use it.\n\t\t * - otherwise, anonymous name.\n\t\t */\n\t\tif (!len) {\n\t\t\tlen = get_term_name(state, iterm, kctl->id.name,\n\t\t\t\t\t    sizeof(kctl->id.name), 1);\n\t\t\tif (!len)\n\t\t\t\tlen = get_term_name(state, &state->oterm,\n\t\t\t\t\t\t    kctl->id.name,\n\t\t\t\t\t\t    sizeof(kctl->id.name), 1);\n\t\t\tif (!len)\n\t\t\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t\t\t \"Feature %d\", unitid);\n\t\t}\n\n\t\tif (!mapped_name)\n\t\t\tcheck_no_speaker_on_headset(kctl, state->mixer->chip->card);\n\n\t\t/*\n\t\t * determine the stream direction:\n\t\t * if the connected output is USB stream, then it's likely a\n\t\t * capture stream.  otherwise it should be playback (hopefully :)\n\t\t */\n\t\tif (!mapped_name && !(state->oterm.type >> 16)) {\n\t\t\tif ((state->oterm.type & 0xff00) == 0x0100)\n\t\t\t\tappend_ctl_name(kctl, \" Capture\");\n\t\t\telse\n\t\t\t\tappend_ctl_name(kctl, \" Playback\");\n\t\t}\n\t\tappend_ctl_name(kctl, control == UAC_FU_MUTE ?\n\t\t\t\t\" Switch\" : \" Volume\");\n\t\tbreak;\n\tdefault:\n\t\tif (!len)\n\t\t\tstrlcpy(kctl->id.name, audio_feature_info[control-1].name,\n\t\t\t\tsizeof(kctl->id.name));\n\t\tbreak;\n\t}\n\n\t/* get min/max values */\n\tget_min_max_with_quirks(cval, 0, kctl);\n\n\tif (control == UAC_FU_VOLUME) {\n\t\tcheck_mapped_dB(map, cval);\n\t\tif (cval->dBmin < cval->dBmax || !cval->initialized) {\n\t\t\tkctl->tlv.c = snd_usb_mixer_vol_tlv;\n\t\t\tkctl->vd[0].access |=\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t\t}\n\t}\n\n\tsnd_usb_mixer_fu_apply_quirk(state->mixer, cval, unitid, kctl);\n\n\trange = (cval->max - cval->min) / cval->res;\n\t/*\n\t * Are there devices with volume range more than 255? I use a bit more\n\t * to be sure. 384 is a resolution magic number found on Logitech\n\t * devices. It will definitively catch all buggy Logitech devices.\n\t */\n\tif (range > 384) {\n\t\tusb_audio_warn(state->chip,\n\t\t\t       \"Warning! Unlikely big volume range (=%u), cval->res is probably wrong.\",\n\t\t\t       range);\n\t\tusb_audio_warn(state->chip,\n\t\t\t       \"[%d] FU [%s] ch = %d, val = %d/%d/%d\",\n\t\t\t       cval->head.id, kctl->id.name, cval->channels,\n\t\t\t       cval->min, cval->max, cval->res);\n\t}\n\n\tusb_audio_dbg(state->chip, \"[%d] FU [%s] ch = %d, val = %d/%d/%d\\n\",\n\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t      cval->min, cval->max, cval->res);\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\nstatic int parse_clock_source_unit(struct mixer_build *state, int unitid,\n\t\t\t\t   void *_ftr)\n{\n\tstruct uac_clock_source_descriptor *hdr = _ftr;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tint ret;\n\n\tif (state->mixer->protocol != UAC_VERSION_2)\n\t\treturn -EINVAL;\n\n\tif (hdr->bLength != sizeof(*hdr)) {\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"Bogus clock source descriptor length of %d, ignoring.\\n\",\n\t\t\t      hdr->bLength);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * The only property of this unit we are interested in is the\n\t * clock source validity. If that isn't readable, just bail out.\n\t */\n\tif (!uac2_control_is_readable(hdr->bmControls,\n\t\t\t\t      ilog2(UAC2_CS_CONTROL_CLOCK_VALID)))\n\t\treturn 0;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, hdr->bClockID);\n\n\tcval->min = 0;\n\tcval->max = 1;\n\tcval->channels = 1;\n\tcval->val_type = USB_MIXER_BOOLEAN;\n\tcval->control = UAC2_CS_CONTROL_CLOCK_VALID;\n\n\tif (uac2_control_is_writeable(hdr->bmControls,\n\t\t\t\t      ilog2(UAC2_CS_CONTROL_CLOCK_VALID)))\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\telse {\n\t\tcval->master_readonly = 1;\n\t\tkctl = snd_ctl_new1(&usb_feature_unit_ctl_ro, cval);\n\t}\n\n\tif (!kctl) {\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\tret = snd_usb_copy_string_desc(state, hdr->iClockSource,\n\t\t\t\t       name, sizeof(name));\n\tif (ret > 0)\n\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t \"%s Validity\", name);\n\telse\n\t\tsnprintf(kctl->id.name, sizeof(kctl->id.name),\n\t\t\t \"Clock Source %d Validity\", hdr->bClockID);\n\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n/*\n * parse a feature unit\n *\n * most of controls are defined here.\n */\nstatic int parse_audio_feature_unit(struct mixer_build *state, int unitid,\n\t\t\t\t    void *_ftr)\n{\n\tint channels, i, j;\n\tstruct usb_audio_term iterm;\n\tunsigned int master_bits, first_ch_bits;\n\tint err, csize;\n\tstruct uac_feature_unit_descriptor *hdr = _ftr;\n\t__u8 *bmaControls;\n\n\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\tcsize = hdr->bControlSize;\n\t\tif (!csize) {\n\t\t\tusb_audio_dbg(state->chip,\n\t\t\t\t      \"unit %u: invalid bControlSize == 0\\n\",\n\t\t\t\t      unitid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchannels = (hdr->bLength - 7) / csize - 1;\n\t\tbmaControls = hdr->bmaControls;\n\t\tif (hdr->bLength < 7 + csize) {\n\t\t\tusb_audio_err(state->chip,\n\t\t\t\t      \"unit %u: invalid UAC_FEATURE_UNIT descriptor\\n\",\n\t\t\t\t      unitid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tstruct uac2_feature_unit_descriptor *ftr = _ftr;\n\t\tcsize = 4;\n\t\tchannels = (hdr->bLength - 6) / 4 - 1;\n\t\tbmaControls = ftr->bmaControls;\n\t\tif (hdr->bLength < 6 + csize) {\n\t\t\tusb_audio_err(state->chip,\n\t\t\t\t      \"unit %u: invalid UAC_FEATURE_UNIT descriptor\\n\",\n\t\t\t\t      unitid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* parse the source unit */\n\tif ((err = parse_audio_unit(state, hdr->bSourceID)) < 0)\n\t\treturn err;\n\n\t/* determine the input source type and name */\n\terr = check_input_term(state, hdr->bSourceID, &iterm);\n\tif (err < 0)\n\t\treturn err;\n\n\tmaster_bits = snd_usb_combine_bytes(bmaControls, csize);\n\t/* master configuration quirks */\n\tswitch (state->chip->usb_id) {\n\tcase USB_ID(0x08bb, 0x2702):\n\t\tusb_audio_info(state->chip,\n\t\t\t       \"usbmixer: master volume quirk for PCM2702 chip\\n\");\n\t\t/* disable non-functional volume control */\n\t\tmaster_bits &= ~UAC_CONTROL_BIT(UAC_FU_VOLUME);\n\t\tbreak;\n\tcase USB_ID(0x1130, 0xf211):\n\t\tusb_audio_info(state->chip,\n\t\t\t       \"usbmixer: volume control quirk for Tenx TP6911 Audio Headset\\n\");\n\t\t/* disable non-functional volume control */\n\t\tchannels = 0;\n\t\tbreak;\n\n\t}\n\tif (channels > 0)\n\t\tfirst_ch_bits = snd_usb_combine_bytes(bmaControls + csize, csize);\n\telse\n\t\tfirst_ch_bits = 0;\n\n\tif (state->mixer->protocol == UAC_VERSION_1) {\n\t\t/* check all control types */\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tunsigned int ch_bits = 0;\n\t\t\tfor (j = 0; j < channels; j++) {\n\t\t\t\tunsigned int mask;\n\n\t\t\t\tmask = snd_usb_combine_bytes(bmaControls +\n\t\t\t\t\t\t\t     csize * (j+1), csize);\n\t\t\t\tif (mask & (1 << i))\n\t\t\t\t\tch_bits |= (1 << j);\n\t\t\t}\n\t\t\t/* audio class v1 controls are never read-only */\n\n\t\t\t/*\n\t\t\t * The first channel must be set\n\t\t\t * (for ease of programming).\n\t\t\t */\n\t\t\tif (ch_bits & 1)\n\t\t\t\tbuild_feature_ctl(state, _ftr, ch_bits, i,\n\t\t\t\t\t\t  &iterm, unitid, 0);\n\t\t\tif (master_bits & (1 << i))\n\t\t\t\tbuild_feature_ctl(state, _ftr, 0, i, &iterm,\n\t\t\t\t\t\t  unitid, 0);\n\t\t}\n\t} else { /* UAC_VERSION_2 */\n\t\tfor (i = 0; i < ARRAY_SIZE(audio_feature_info); i++) {\n\t\t\tunsigned int ch_bits = 0;\n\t\t\tunsigned int ch_read_only = 0;\n\n\t\t\tfor (j = 0; j < channels; j++) {\n\t\t\t\tunsigned int mask;\n\n\t\t\t\tmask = snd_usb_combine_bytes(bmaControls +\n\t\t\t\t\t\t\t     csize * (j+1), csize);\n\t\t\t\tif (uac2_control_is_readable(mask, i)) {\n\t\t\t\t\tch_bits |= (1 << j);\n\t\t\t\t\tif (!uac2_control_is_writeable(mask, i))\n\t\t\t\t\t\tch_read_only |= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * NOTE: build_feature_ctl() will mark the control\n\t\t\t * read-only if all channels are marked read-only in\n\t\t\t * the descriptors. Otherwise, the control will be\n\t\t\t * reported as writeable, but the driver will not\n\t\t\t * actually issue a write command for read-only\n\t\t\t * channels.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * The first channel must be set\n\t\t\t * (for ease of programming).\n\t\t\t */\n\t\t\tif (ch_bits & 1)\n\t\t\t\tbuild_feature_ctl(state, _ftr, ch_bits, i,\n\t\t\t\t\t\t  &iterm, unitid, ch_read_only);\n\t\t\tif (uac2_control_is_readable(master_bits, i))\n\t\t\t\tbuild_feature_ctl(state, _ftr, 0, i, &iterm, unitid,\n\t\t\t\t\t\t  !uac2_control_is_writeable(master_bits, i));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * Mixer Unit\n */\n\n/*\n * build a mixer unit control\n *\n * the callbacks are identical with feature unit.\n * input channel number (zero based) is given in control field instead.\n */\nstatic void build_mixer_unit_ctl(struct mixer_build *state,\n\t\t\t\t struct uac_mixer_unit_descriptor *desc,\n\t\t\t\t int in_pin, int in_ch, int unitid,\n\t\t\t\t struct usb_audio_term *iterm)\n{\n\tstruct usb_mixer_elem_info *cval;\n\tunsigned int num_outs = uac_mixer_unit_bNrChannels(desc);\n\tunsigned int i, len;\n\tstruct snd_kcontrol *kctl;\n\tconst struct usbmix_name_map *map;\n\n\tmap = find_map(state, unitid, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn;\n\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->control = in_ch + 1; /* based on 1 */\n\tcval->val_type = USB_MIXER_S16;\n\tfor (i = 0; i < num_outs; i++) {\n\t\t__u8 *c = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (check_matrix_bitmap(c, in_ch, i, num_outs)) {\n\t\t\tcval->cmask |= (1 << i);\n\t\t\tcval->channels++;\n\t\t}\n\t}\n\n\t/* get min/max values */\n\tget_min_max(cval, 0);\n\n\tkctl = snd_ctl_new1(&usb_feature_unit_ctl, cval);\n\tif (!kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tkfree(cval);\n\t\treturn;\n\t}\n\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tif (!len)\n\t\tlen = get_term_name(state, iterm, kctl->id.name,\n\t\t\t\t    sizeof(kctl->id.name), 0);\n\tif (!len)\n\t\tlen = sprintf(kctl->id.name, \"Mixer Source %d\", in_ch + 1);\n\tappend_ctl_name(kctl, \" Volume\");\n\n\tusb_audio_dbg(state->chip, \"[%d] MU [%s] ch = %d, val = %d/%d\\n\",\n\t\t    cval->head.id, kctl->id.name, cval->channels, cval->min, cval->max);\n\tsnd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n/*\n * parse a mixer unit\n */\nstatic int parse_audio_mixer_unit(struct mixer_build *state, int unitid,\n\t\t\t\t  void *raw_desc)\n{\n\tstruct uac_mixer_unit_descriptor *desc = raw_desc;\n\tstruct usb_audio_term iterm;\n\tint input_pins, num_ins, num_outs;\n\tint pin, ich, err;\n\n\tif (desc->bLength < 11 || !(input_pins = desc->bNrInPins) ||\n\t    !(num_outs = uac_mixer_unit_bNrChannels(desc))) {\n\t\tusb_audio_err(state->chip,\n\t\t\t      \"invalid MIXER UNIT descriptor %d\\n\",\n\t\t\t      unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ins = 0;\n\tich = 0;\n\tfor (pin = 0; pin < input_pins; pin++) {\n\t\terr = parse_audio_unit(state, desc->baSourceID[pin]);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\t\t/* no bmControls field (e.g. Maya44) -> ignore */\n\t\tif (desc->bLength <= 10 + input_pins)\n\t\t\tcontinue;\n\t\terr = check_input_term(state, desc->baSourceID[pin], &iterm);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tnum_ins += iterm.channels;\n\t\tfor (; ich < num_ins; ich++) {\n\t\t\tint och, ich_has_controls = 0;\n\n\t\t\tfor (och = 0; och < num_outs; och++) {\n\t\t\t\t__u8 *c = uac_mixer_unit_bmControls(desc,\n\t\t\t\t\t\tstate->mixer->protocol);\n\n\t\t\t\tif (check_matrix_bitmap(c, ich, och, num_outs)) {\n\t\t\t\t\tich_has_controls = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ich_has_controls)\n\t\t\t\tbuild_mixer_unit_ctl(state, desc, pin, ich,\n\t\t\t\t\t\t     unitid, &iterm);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Processing Unit / Extension Unit\n */\n\n/* get callback for processing/extension unit */\nstatic int mixer_ctl_procunit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint err, val;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\tif (err < 0) {\n\t\tucontrol->value.integer.value[0] = cval->min;\n\t\treturn filter_error(cval, err);\n\t}\n\tval = get_relative_value(cval, val);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n}\n\n/* put callback for processing/extension unit */\nstatic int mixer_ctl_procunit_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, oval, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &oval);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = ucontrol->value.integer.value[0];\n\tval = get_abs_value(cval, val);\n\tif (val != oval) {\n\t\tset_cur_ctl_value(cval, cval->control << 8, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* alsa control interface for processing/extension unit */\nstatic const struct snd_kcontrol_new mixer_procunit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later */\n\t.info = mixer_ctl_feature_info,\n\t.get = mixer_ctl_procunit_get,\n\t.put = mixer_ctl_procunit_put,\n};\n\n/*\n * predefined data for processing units\n */\nstruct procunit_value_info {\n\tint control;\n\tchar *suffix;\n\tint val_type;\n\tint min_value;\n};\n\nstruct procunit_info {\n\tint type;\n\tchar *name;\n\tstruct procunit_value_info *values;\n};\n\nstatic struct procunit_value_info updown_proc_info[] = {\n\t{ UAC_UD_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_UD_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic struct procunit_value_info prologic_proc_info[] = {\n\t{ UAC_DP_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_DP_MODE_SELECT, \"Mode Select\", USB_MIXER_U8, 1 },\n\t{ 0 }\n};\nstatic struct procunit_value_info threed_enh_proc_info[] = {\n\t{ UAC_3D_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_3D_SPACE, \"Spaciousness\", USB_MIXER_U8 },\n\t{ 0 }\n};\nstatic struct procunit_value_info reverb_proc_info[] = {\n\t{ UAC_REVERB_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_REVERB_LEVEL, \"Level\", USB_MIXER_U8 },\n\t{ UAC_REVERB_TIME, \"Time\", USB_MIXER_U16 },\n\t{ UAC_REVERB_FEEDBACK, \"Feedback\", USB_MIXER_U8 },\n\t{ 0 }\n};\nstatic struct procunit_value_info chorus_proc_info[] = {\n\t{ UAC_CHORUS_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_CHORUS_LEVEL, \"Level\", USB_MIXER_U8 },\n\t{ UAC_CHORUS_RATE, \"Rate\", USB_MIXER_U16 },\n\t{ UAC_CHORUS_DEPTH, \"Depth\", USB_MIXER_U16 },\n\t{ 0 }\n};\nstatic struct procunit_value_info dcr_proc_info[] = {\n\t{ UAC_DCR_ENABLE, \"Switch\", USB_MIXER_BOOLEAN },\n\t{ UAC_DCR_RATE, \"Ratio\", USB_MIXER_U16 },\n\t{ UAC_DCR_MAXAMPL, \"Max Amp\", USB_MIXER_S16 },\n\t{ UAC_DCR_THRESHOLD, \"Threshold\", USB_MIXER_S16 },\n\t{ UAC_DCR_ATTACK_TIME, \"Attack Time\", USB_MIXER_U16 },\n\t{ UAC_DCR_RELEASE_TIME, \"Release Time\", USB_MIXER_U16 },\n\t{ 0 }\n};\n\nstatic struct procunit_info procunits[] = {\n\t{ UAC_PROCESS_UP_DOWNMIX, \"Up Down\", updown_proc_info },\n\t{ UAC_PROCESS_DOLBY_PROLOGIC, \"Dolby Prologic\", prologic_proc_info },\n\t{ UAC_PROCESS_STEREO_EXTENDER, \"3D Stereo Extender\", threed_enh_proc_info },\n\t{ UAC_PROCESS_REVERB, \"Reverb\", reverb_proc_info },\n\t{ UAC_PROCESS_CHORUS, \"Chorus\", chorus_proc_info },\n\t{ UAC_PROCESS_DYN_RANGE_COMP, \"DCR\", dcr_proc_info },\n\t{ 0 },\n};\n/*\n * predefined data for extension units\n */\nstatic struct procunit_value_info clock_rate_xu_info[] = {\n\t{ USB_XU_CLOCK_RATE_SELECTOR, \"Selector\", USB_MIXER_U8, 0 },\n\t{ 0 }\n};\nstatic struct procunit_value_info clock_source_xu_info[] = {\n\t{ USB_XU_CLOCK_SOURCE_SELECTOR, \"External\", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic struct procunit_value_info spdif_format_xu_info[] = {\n\t{ USB_XU_DIGITAL_FORMAT_SELECTOR, \"SPDIF/AC3\", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic struct procunit_value_info soft_limit_xu_info[] = {\n\t{ USB_XU_SOFT_LIMIT_SELECTOR, \" \", USB_MIXER_BOOLEAN },\n\t{ 0 }\n};\nstatic struct procunit_info extunits[] = {\n\t{ USB_XU_CLOCK_RATE, \"Clock rate\", clock_rate_xu_info },\n\t{ USB_XU_CLOCK_SOURCE, \"DigitalIn CLK source\", clock_source_xu_info },\n\t{ USB_XU_DIGITAL_IO_STATUS, \"DigitalOut format:\", spdif_format_xu_info },\n\t{ USB_XU_DEVICE_OPTIONS, \"AnalogueIn Soft Limit\", soft_limit_xu_info },\n\t{ 0 }\n};\n\n/*\n * build a processing/extension unit\n */\nstatic int build_audio_procunit(struct mixer_build *state, int unitid,\n\t\t\t\tvoid *raw_desc, struct procunit_info *list,\n\t\t\t\tchar *name)\n{\n\tstruct uac_processing_unit_descriptor *desc = raw_desc;\n\tint num_ins = desc->bNrInPins;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tint i, err, nameid, type, len;\n\tstruct procunit_info *info;\n\tstruct procunit_value_info *valinfo;\n\tconst struct usbmix_name_map *map;\n\tstatic struct procunit_value_info default_value_info[] = {\n\t\t{ 0x01, \"Switch\", USB_MIXER_BOOLEAN },\n\t\t{ 0 }\n\t};\n\tstatic struct procunit_info default_info = {\n\t\t0, NULL, default_value_info\n\t};\n\n\tif (desc->bLength < 13 || desc->bLength < 13 + num_ins ||\n\t    desc->bLength < num_ins + uac_processing_unit_bControlSize(desc, state->mixer->protocol)) {\n\t\tusb_audio_err(state->chip, \"invalid %s descriptor (id %d)\\n\", name, unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_ins; i++) {\n\t\tif ((err = parse_audio_unit(state, desc->baSourceID[i])) < 0)\n\t\t\treturn err;\n\t}\n\n\ttype = le16_to_cpu(desc->wProcessType);\n\tfor (info = list; info && info->type; info++)\n\t\tif (info->type == type)\n\t\t\tbreak;\n\tif (!info || !info->type)\n\t\tinfo = &default_info;\n\n\tfor (valinfo = info->values; valinfo->control; valinfo++) {\n\t\t__u8 *controls = uac_processing_unit_bmControls(desc, state->mixer->protocol);\n\n\t\tif (!(controls[valinfo->control / 8] & (1 << ((valinfo->control % 8) - 1))))\n\t\t\tcontinue;\n\t\tmap = find_map(state, unitid, valinfo->control);\n\t\tif (check_ignored_ctl(map))\n\t\t\tcontinue;\n\t\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\t\tif (!cval)\n\t\t\treturn -ENOMEM;\n\t\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\t\tcval->control = valinfo->control;\n\t\tcval->val_type = valinfo->val_type;\n\t\tcval->channels = 1;\n\n\t\t/* get min/max values */\n\t\tif (type == UAC_PROCESS_UP_DOWNMIX && cval->control == UAC_UD_MODE_SELECT) {\n\t\t\t__u8 *control_spec = uac_processing_unit_specific(desc, state->mixer->protocol);\n\t\t\t/* FIXME: hard-coded */\n\t\t\tcval->min = 1;\n\t\t\tcval->max = control_spec[0];\n\t\t\tcval->res = 1;\n\t\t\tcval->initialized = 1;\n\t\t} else {\n\t\t\tif (type == USB_XU_CLOCK_RATE) {\n\t\t\t\t/*\n\t\t\t\t * E-Mu USB 0404/0202/TrackerPre/0204\n\t\t\t\t * samplerate control quirk\n\t\t\t\t */\n\t\t\t\tcval->min = 0;\n\t\t\t\tcval->max = 5;\n\t\t\t\tcval->res = 1;\n\t\t\t\tcval->initialized = 1;\n\t\t\t} else\n\t\t\t\tget_min_max(cval, valinfo->min_value);\n\t\t}\n\n\t\tkctl = snd_ctl_new1(&mixer_procunit_ctl, cval);\n\t\tif (!kctl) {\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkctl->private_free = snd_usb_mixer_elem_free;\n\n\t\tif (check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name))) {\n\t\t\t/* nothing */ ;\n\t\t} else if (info->name) {\n\t\t\tstrlcpy(kctl->id.name, info->name, sizeof(kctl->id.name));\n\t\t} else {\n\t\t\tnameid = uac_processing_unit_iProcessing(desc, state->mixer->protocol);\n\t\t\tlen = 0;\n\t\t\tif (nameid)\n\t\t\t\tlen = snd_usb_copy_string_desc(state, nameid,\n\t\t\t\t\t\t\t       kctl->id.name,\n\t\t\t\t\t\t\t       sizeof(kctl->id.name));\n\t\t\tif (!len)\n\t\t\t\tstrlcpy(kctl->id.name, name, sizeof(kctl->id.name));\n\t\t}\n\t\tappend_ctl_name(kctl, \" \");\n\t\tappend_ctl_name(kctl, valinfo->suffix);\n\n\t\tusb_audio_dbg(state->chip,\n\t\t\t      \"[%d] PU [%s] ch = %d, val = %d/%d\\n\",\n\t\t\t      cval->head.id, kctl->id.name, cval->channels,\n\t\t\t      cval->min, cval->max);\n\n\t\terr = snd_usb_mixer_add_control(&cval->head, kctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int parse_audio_processing_unit(struct mixer_build *state, int unitid,\n\t\t\t\t       void *raw_desc)\n{\n\treturn build_audio_procunit(state, unitid, raw_desc,\n\t\t\t\t    procunits, \"Processing Unit\");\n}\n\nstatic int parse_audio_extension_unit(struct mixer_build *state, int unitid,\n\t\t\t\t      void *raw_desc)\n{\n\t/*\n\t * Note that we parse extension units with processing unit descriptors.\n\t * That's ok as the layout is the same.\n\t */\n\treturn build_audio_procunit(state, unitid, raw_desc,\n\t\t\t\t    extunits, \"Extension Unit\");\n}\n\n/*\n * Selector Unit\n */\n\n/*\n * info callback for selector unit\n * use an enumerator type for routing\n */\nstatic int mixer_ctl_selector_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tconst char **itemlist = (const char **)kcontrol->private_value;\n\n\tif (snd_BUG_ON(!itemlist))\n\t\treturn -EINVAL;\n\treturn snd_ctl_enum_info(uinfo, 1, cval->max, itemlist);\n}\n\n/* get callback for selector unit */\nstatic int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &val);\n\tif (err < 0) {\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\treturn filter_error(cval, err);\n\t}\n\tval = get_relative_value(cval, val);\n\tucontrol->value.enumerated.item[0] = val;\n\treturn 0;\n}\n\n/* put callback for selector unit */\nstatic int mixer_ctl_selector_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct usb_mixer_elem_info *cval = kcontrol->private_data;\n\tint val, oval, err;\n\n\terr = get_cur_ctl_value(cval, cval->control << 8, &oval);\n\tif (err < 0)\n\t\treturn filter_error(cval, err);\n\tval = ucontrol->value.enumerated.item[0];\n\tval = get_abs_value(cval, val);\n\tif (val != oval) {\n\t\tset_cur_ctl_value(cval, cval->control << 8, val);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* alsa control interface for selector unit */\nstatic const struct snd_kcontrol_new mixer_selectunit_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"\", /* will be filled later */\n\t.info = mixer_ctl_selector_info,\n\t.get = mixer_ctl_selector_get,\n\t.put = mixer_ctl_selector_put,\n};\n\n/*\n * private free callback.\n * free both private_data and private_value\n */\nstatic void usb_mixer_selector_elem_free(struct snd_kcontrol *kctl)\n{\n\tint i, num_ins = 0;\n\n\tif (kctl->private_data) {\n\t\tstruct usb_mixer_elem_info *cval = kctl->private_data;\n\t\tnum_ins = cval->max;\n\t\tkfree(cval);\n\t\tkctl->private_data = NULL;\n\t}\n\tif (kctl->private_value) {\n\t\tchar **itemlist = (char **)kctl->private_value;\n\t\tfor (i = 0; i < num_ins; i++)\n\t\t\tkfree(itemlist[i]);\n\t\tkfree(itemlist);\n\t\tkctl->private_value = 0;\n\t}\n}\n\n/*\n * parse a selector unit\n */\nstatic int parse_audio_selector_unit(struct mixer_build *state, int unitid,\n\t\t\t\t     void *raw_desc)\n{\n\tstruct uac_selector_unit_descriptor *desc = raw_desc;\n\tunsigned int i, nameid, len;\n\tint err;\n\tstruct usb_mixer_elem_info *cval;\n\tstruct snd_kcontrol *kctl;\n\tconst struct usbmix_name_map *map;\n\tchar **namelist;\n\n\tif (!desc->bNrInPins || desc->bLength < 5 + desc->bNrInPins) {\n\t\tusb_audio_err(state->chip,\n\t\t\t\"invalid SELECTOR UNIT descriptor %d\\n\", unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < desc->bNrInPins; i++) {\n\t\tif ((err = parse_audio_unit(state, desc->baSourceID[i])) < 0)\n\t\t\treturn err;\n\t}\n\n\tif (desc->bNrInPins == 1) /* only one ? nonsense! */\n\t\treturn 0;\n\n\tmap = find_map(state, unitid, 0);\n\tif (check_ignored_ctl(map))\n\t\treturn 0;\n\n\tcval = kzalloc(sizeof(*cval), GFP_KERNEL);\n\tif (!cval)\n\t\treturn -ENOMEM;\n\tsnd_usb_mixer_elem_init_std(&cval->head, state->mixer, unitid);\n\tcval->val_type = USB_MIXER_U8;\n\tcval->channels = 1;\n\tcval->min = 1;\n\tcval->max = desc->bNrInPins;\n\tcval->res = 1;\n\tcval->initialized = 1;\n\n\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\tcval->control = 0;\n\telse /* UAC_VERSION_2 */\n\t\tcval->control = (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR) ?\n\t\t\tUAC2_CX_CLOCK_SELECTOR : UAC2_SU_SELECTOR;\n\n\tnamelist = kmalloc(sizeof(char *) * desc->bNrInPins, GFP_KERNEL);\n\tif (!namelist) {\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n#define MAX_ITEM_NAME_LEN\t64\n\tfor (i = 0; i < desc->bNrInPins; i++) {\n\t\tstruct usb_audio_term iterm;\n\t\tlen = 0;\n\t\tnamelist[i] = kmalloc(MAX_ITEM_NAME_LEN, GFP_KERNEL);\n\t\tif (!namelist[i]) {\n\t\t\twhile (i--)\n\t\t\t\tkfree(namelist[i]);\n\t\t\tkfree(namelist);\n\t\t\tkfree(cval);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tlen = check_mapped_selector_name(state, unitid, i, namelist[i],\n\t\t\t\t\t\t MAX_ITEM_NAME_LEN);\n\t\tif (! len && check_input_term(state, desc->baSourceID[i], &iterm) >= 0)\n\t\t\tlen = get_term_name(state, &iterm, namelist[i], MAX_ITEM_NAME_LEN, 0);\n\t\tif (! len)\n\t\t\tsprintf(namelist[i], \"Input %u\", i);\n\t}\n\n\tkctl = snd_ctl_new1(&mixer_selectunit_ctl, cval);\n\tif (! kctl) {\n\t\tusb_audio_err(state->chip, \"cannot malloc kcontrol\\n\");\n\t\tkfree(namelist);\n\t\tkfree(cval);\n\t\treturn -ENOMEM;\n\t}\n\tkctl->private_value = (unsigned long)namelist;\n\tkctl->private_free = usb_mixer_selector_elem_free;\n\n\tnameid = uac_selector_unit_iSelector(desc);\n\tlen = check_mapped_name(map, kctl->id.name, sizeof(kctl->id.name));\n\tif (len)\n\t\t;\n\telse if (nameid)\n\t\tsnd_usb_copy_string_desc(state, nameid, kctl->id.name,\n\t\t\t\t\t sizeof(kctl->id.name));\n\telse {\n\t\tlen = get_term_name(state, &state->oterm,\n\t\t\t\t    kctl->id.name, sizeof(kctl->id.name), 0);\n\t\tif (!len)\n\t\t\tstrlcpy(kctl->id.name, \"USB\", sizeof(kctl->id.name));\n\n\t\tif (desc->bDescriptorSubtype == UAC2_CLOCK_SELECTOR)\n\t\t\tappend_ctl_name(kctl, \" Clock Source\");\n\t\telse if ((state->oterm.type & 0xff00) == 0x0100)\n\t\t\tappend_ctl_name(kctl, \" Capture Source\");\n\t\telse\n\t\t\tappend_ctl_name(kctl, \" Playback Source\");\n\t}\n\n\tusb_audio_dbg(state->chip, \"[%d] SU [%s] items = %d\\n\",\n\t\t    cval->head.id, kctl->id.name, desc->bNrInPins);\n\treturn snd_usb_mixer_add_control(&cval->head, kctl);\n}\n\n/*\n * parse an audio unit recursively\n */\n\nstatic int parse_audio_unit(struct mixer_build *state, int unitid)\n{\n\tunsigned char *p1;\n\n\tif (test_and_set_bit(unitid, state->unitbitmap))\n\t\treturn 0; /* the unit already visited */\n\n\tp1 = find_audio_control_unit(state, unitid);\n\tif (!p1) {\n\t\tusb_audio_err(state->chip, \"unit %d not found!\\n\", unitid);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p1[2]) {\n\tcase UAC_INPUT_TERMINAL:\n\t\treturn 0; /* NOP */\n\tcase UAC_MIXER_UNIT:\n\t\treturn parse_audio_mixer_unit(state, unitid, p1);\n\tcase UAC2_CLOCK_SOURCE:\n\t\treturn parse_clock_source_unit(state, unitid, p1);\n\tcase UAC_SELECTOR_UNIT:\n\tcase UAC2_CLOCK_SELECTOR:\n\t\treturn parse_audio_selector_unit(state, unitid, p1);\n\tcase UAC_FEATURE_UNIT:\n\t\treturn parse_audio_feature_unit(state, unitid, p1);\n\tcase UAC1_PROCESSING_UNIT:\n\t/*   UAC2_EFFECT_UNIT has the same value */\n\t\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\t\telse\n\t\t\treturn 0; /* FIXME - effect units not implemented yet */\n\tcase UAC1_EXTENSION_UNIT:\n\t/*   UAC2_PROCESSING_UNIT_V2 has the same value */\n\t\tif (state->mixer->protocol == UAC_VERSION_1)\n\t\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\t\telse /* UAC_VERSION_2 */\n\t\t\treturn parse_audio_processing_unit(state, unitid, p1);\n\tcase UAC2_EXTENSION_UNIT_V2:\n\t\treturn parse_audio_extension_unit(state, unitid, p1);\n\tdefault:\n\t\tusb_audio_err(state->chip,\n\t\t\t\"unit %u: unexpected type 0x%02x\\n\", unitid, p1[2]);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\t/* kill pending URBs */\n\tsnd_usb_mixer_disconnect(mixer);\n\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}\n\nstatic int snd_usb_mixer_dev_free(struct snd_device *device)\n{\n\tstruct usb_mixer_interface *mixer = device->device_data;\n\tsnd_usb_mixer_free(mixer);\n\treturn 0;\n}\n\n/*\n * create mixer controls\n *\n * walk through all UAC_OUTPUT_TERMINAL descriptors to search for mixers\n */\nstatic int snd_usb_mixer_controls(struct usb_mixer_interface *mixer)\n{\n\tstruct mixer_build state;\n\tint err;\n\tconst struct usbmix_ctl_map *map;\n\tvoid *p;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.chip = mixer->chip;\n\tstate.mixer = mixer;\n\tstate.buffer = mixer->hostif->extra;\n\tstate.buflen = mixer->hostif->extralen;\n\n\t/* check the mapping table */\n\tfor (map = usbmix_ctl_maps; map->id; map++) {\n\t\tif (map->id == state.chip->usb_id) {\n\t\t\tstate.map = map->map;\n\t\t\tstate.selector_map = map->selector_map;\n\t\t\tmixer->ignore_ctl_error = map->ignore_ctl_error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = NULL;\n\twhile ((p = snd_usb_find_csint_desc(mixer->hostif->extra,\n\t\t\t\t\t    mixer->hostif->extralen,\n\t\t\t\t\t    p, UAC_OUTPUT_TERMINAL)) != NULL) {\n\t\tif (mixer->protocol == UAC_VERSION_1) {\n\t\t\tstruct uac1_output_terminal_descriptor *desc = p;\n\n\t\t\tif (desc->bLength < sizeof(*desc))\n\t\t\t\tcontinue; /* invalid descriptor? */\n\t\t\t/* mark terminal ID as visited */\n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = desc->iTerminal;\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\t\t} else { /* UAC_VERSION_2 */\n\t\t\tstruct uac2_output_terminal_descriptor *desc = p;\n\n\t\t\tif (desc->bLength < sizeof(*desc))\n\t\t\t\tcontinue; /* invalid descriptor? */\n\t\t\t/* mark terminal ID as visited */\n\t\t\tset_bit(desc->bTerminalID, state.unitbitmap);\n\t\t\tstate.oterm.id = desc->bTerminalID;\n\t\t\tstate.oterm.type = le16_to_cpu(desc->wTerminalType);\n\t\t\tstate.oterm.name = desc->iTerminal;\n\t\t\terr = parse_audio_unit(&state, desc->bSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\n\t\t\t/*\n\t\t\t * For UAC2, use the same approach to also add the\n\t\t\t * clock selectors\n\t\t\t */\n\t\t\terr = parse_audio_unit(&state, desc->bCSourceID);\n\t\t\tif (err < 0 && err != -EINVAL)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer, int unitid)\n{\n\tstruct usb_mixer_elem_list *list;\n\n\tfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem)\n\t\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &list->kctl->id);\n}\n\nstatic void snd_usb_mixer_dump_cval(struct snd_info_buffer *buffer,\n\t\t\t\t    struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = (struct usb_mixer_elem_info *)list;\n\tstatic char *val_types[] = {\"BOOLEAN\", \"INV_BOOLEAN\",\n\t\t\t\t    \"S8\", \"U8\", \"S16\", \"U16\"};\n\tsnd_iprintf(buffer, \"    Info: id=%i, control=%i, cmask=0x%x, \"\n\t\t\t    \"channels=%i, type=\\\"%s\\\"\\n\", cval->head.id,\n\t\t\t    cval->control, cval->cmask, cval->channels,\n\t\t\t    val_types[cval->val_type]);\n\tsnd_iprintf(buffer, \"    Volume: min=%i, max=%i, dBmin=%i, dBmax=%i\\n\",\n\t\t\t    cval->min, cval->max, cval->dBmin, cval->dBmax);\n}\n\nstatic void snd_usb_mixer_proc_read(struct snd_info_entry *entry,\n\t\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_usb_audio *chip = entry->private_data;\n\tstruct usb_mixer_interface *mixer;\n\tstruct usb_mixer_elem_list *list;\n\tint unitid;\n\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\tsnd_iprintf(buffer,\n\t\t\t\"USB Mixer: usb_id=0x%08x, ctrlif=%i, ctlerr=%i\\n\",\n\t\t\t\tchip->usb_id, snd_usb_ctrl_intf(chip),\n\t\t\t\tmixer->ignore_ctl_error);\n\t\tsnd_iprintf(buffer, \"Card: %s\\n\", chip->card->longname);\n\t\tfor (unitid = 0; unitid < MAX_ID_ELEMS; unitid++) {\n\t\t\tfor (list = mixer->id_elems[unitid]; list;\n\t\t\t     list = list->next_id_elem) {\n\t\t\t\tsnd_iprintf(buffer, \"  Unit: %i\\n\", list->id);\n\t\t\t\tif (list->kctl)\n\t\t\t\t\tsnd_iprintf(buffer,\n\t\t\t\t\t\t    \"    Control: name=\\\"%s\\\", index=%i\\n\",\n\t\t\t\t\t\t    list->kctl->id.name,\n\t\t\t\t\t\t    list->kctl->id.index);\n\t\t\t\tif (list->dump)\n\t\t\t\t\tlist->dump(buffer, list);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void snd_usb_mixer_interrupt_v2(struct usb_mixer_interface *mixer,\n\t\t\t\t       int attribute, int value, int index)\n{\n\tstruct usb_mixer_elem_list *list;\n\t__u8 unitid = (index >> 8) & 0xff;\n\t__u8 control = (value >> 8) & 0xff;\n\t__u8 channel = value & 0xff;\n\tunsigned int count = 0;\n\n\tif (channel >= MAX_CHANNELS) {\n\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\"%s(): bogus channel number %d\\n\",\n\t\t\t__func__, channel);\n\t\treturn;\n\t}\n\n\tfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem)\n\t\tcount++;\n\n\tif (count == 0)\n\t\treturn;\n\n\tfor (list = mixer->id_elems[unitid]; list; list = list->next_id_elem) {\n\t\tstruct usb_mixer_elem_info *info;\n\n\t\tif (!list->kctl)\n\t\t\tcontinue;\n\n\t\tinfo = (struct usb_mixer_elem_info *)list;\n\t\tif (count > 1 && info->control != control)\n\t\t\tcontinue;\n\n\t\tswitch (attribute) {\n\t\tcase UAC2_CS_CUR:\n\t\t\t/* invalidate cache, so the value is read from the device */\n\t\t\tif (channel)\n\t\t\t\tinfo->cached &= ~(1 << channel);\n\t\t\telse /* master channel */\n\t\t\t\tinfo->cached = 0;\n\n\t\t\tsnd_ctl_notify(mixer->chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &info->head.kctl->id);\n\t\t\tbreak;\n\n\t\tcase UAC2_CS_RANGE:\n\t\t\t/* TODO */\n\t\t\tbreak;\n\n\t\tcase UAC2_CS_MEM:\n\t\t\t/* TODO */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusb_audio_dbg(mixer->chip,\n\t\t\t\t\"unknown attribute %d in interrupt\\n\",\n\t\t\t\tattribute);\n\t\t\tbreak;\n\t\t} /* switch */\n\t}\n}\n\nstatic void snd_usb_mixer_interrupt(struct urb *urb)\n{\n\tstruct usb_mixer_interface *mixer = urb->context;\n\tint len = urb->actual_length;\n\tint ustatus = urb->status;\n\n\tif (ustatus != 0)\n\t\tgoto requeue;\n\n\tif (mixer->protocol == UAC_VERSION_1) {\n\t\tstruct uac1_status_word *status;\n\n\t\tfor (status = urb->transfer_buffer;\n\t\t     len >= sizeof(*status);\n\t\t     len -= sizeof(*status), status++) {\n\t\t\tdev_dbg(&urb->dev->dev, \"status interrupt: %02x %02x\\n\",\n\t\t\t\t\t\tstatus->bStatusType,\n\t\t\t\t\t\tstatus->bOriginator);\n\n\t\t\t/* ignore any notifications not from the control interface */\n\t\t\tif ((status->bStatusType & UAC1_STATUS_TYPE_ORIG_MASK) !=\n\t\t\t\tUAC1_STATUS_TYPE_ORIG_AUDIO_CONTROL_IF)\n\t\t\t\tcontinue;\n\n\t\t\tif (status->bStatusType & UAC1_STATUS_TYPE_MEM_CHANGED)\n\t\t\t\tsnd_usb_mixer_rc_memory_change(mixer, status->bOriginator);\n\t\t\telse\n\t\t\t\tsnd_usb_mixer_notify_id(mixer, status->bOriginator);\n\t\t}\n\t} else { /* UAC_VERSION_2 */\n\t\tstruct uac2_interrupt_data_msg *msg;\n\n\t\tfor (msg = urb->transfer_buffer;\n\t\t     len >= sizeof(*msg);\n\t\t     len -= sizeof(*msg), msg++) {\n\t\t\t/* drop vendor specific and endpoint requests */\n\t\t\tif ((msg->bInfo & UAC2_INTERRUPT_DATA_MSG_VENDOR) ||\n\t\t\t    (msg->bInfo & UAC2_INTERRUPT_DATA_MSG_EP))\n\t\t\t\tcontinue;\n\n\t\t\tsnd_usb_mixer_interrupt_v2(mixer, msg->bAttribute,\n\t\t\t\t\t\t   le16_to_cpu(msg->wValue),\n\t\t\t\t\t\t   le16_to_cpu(msg->wIndex));\n\t\t}\n\t}\n\nrequeue:\n\tif (ustatus != -ENOENT &&\n\t    ustatus != -ECONNRESET &&\n\t    ustatus != -ESHUTDOWN) {\n\t\turb->dev = mixer->chip->dev;\n\t\tusb_submit_urb(urb, GFP_ATOMIC);\n\t}\n}\n\n/* create the handler for the optional status interrupt endpoint */\nstatic int snd_usb_mixer_status_create(struct usb_mixer_interface *mixer)\n{\n\tstruct usb_endpoint_descriptor *ep;\n\tvoid *transfer_buffer;\n\tint buffer_length;\n\tunsigned int epnum;\n\n\t/* we need one interrupt input endpoint */\n\tif (get_iface_desc(mixer->hostif)->bNumEndpoints < 1)\n\t\treturn 0;\n\tep = get_endpoint(mixer->hostif, 0);\n\tif (!usb_endpoint_dir_in(ep) || !usb_endpoint_xfer_int(ep))\n\t\treturn 0;\n\n\tepnum = usb_endpoint_num(ep);\n\tbuffer_length = le16_to_cpu(ep->wMaxPacketSize);\n\ttransfer_buffer = kmalloc(buffer_length, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\tmixer->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!mixer->urb) {\n\t\tkfree(transfer_buffer);\n\t\treturn -ENOMEM;\n\t}\n\tusb_fill_int_urb(mixer->urb, mixer->chip->dev,\n\t\t\t usb_rcvintpipe(mixer->chip->dev, epnum),\n\t\t\t transfer_buffer, buffer_length,\n\t\t\t snd_usb_mixer_interrupt, mixer, ep->bInterval);\n\tusb_submit_urb(mixer->urb, GFP_KERNEL);\n\treturn 0;\n}\n\nint snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,\n\t\t\t int ignore_error)\n{\n\tstatic struct snd_device_ops dev_ops = {\n\t\t.dev_free = snd_usb_mixer_dev_free\n\t};\n\tstruct usb_mixer_interface *mixer;\n\tstruct snd_info_entry *entry;\n\tint err;\n\n\tstrcpy(chip->card->mixername, \"USB Mixer\");\n\n\tmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\n\tif (!mixer)\n\t\treturn -ENOMEM;\n\tmixer->chip = chip;\n\tmixer->ignore_ctl_error = ignore_error;\n\tmixer->id_elems = kcalloc(MAX_ID_ELEMS, sizeof(*mixer->id_elems),\n\t\t\t\t  GFP_KERNEL);\n\tif (!mixer->id_elems) {\n\t\tkfree(mixer);\n\t\treturn -ENOMEM;\n\t}\n\n\tmixer->hostif = &usb_ifnum_to_if(chip->dev, ctrlif)->altsetting[0];\n\tswitch (get_iface_desc(mixer->hostif)->bInterfaceProtocol) {\n\tcase UAC_VERSION_1:\n\tdefault:\n\t\tmixer->protocol = UAC_VERSION_1;\n\t\tbreak;\n\tcase UAC_VERSION_2:\n\t\tmixer->protocol = UAC_VERSION_2;\n\t\tbreak;\n\t}\n\n\tif ((err = snd_usb_mixer_controls(mixer)) < 0 ||\n\t    (err = snd_usb_mixer_status_create(mixer)) < 0)\n\t\tgoto _error;\n\n\tsnd_usb_mixer_apply_create_quirk(mixer);\n\n\terr = snd_device_new(chip->card, SNDRV_DEV_CODEC, mixer, &dev_ops);\n\tif (err < 0)\n\t\tgoto _error;\n\n\tif (list_empty(&chip->mixer_list) &&\n\t    !snd_card_proc_new(chip->card, \"usbmixer\", &entry))\n\t\tsnd_info_set_text_ops(entry, chip, snd_usb_mixer_proc_read);\n\n\tlist_add(&mixer->list, &chip->mixer_list);\n\treturn 0;\n\n_error:\n\tsnd_usb_mixer_free(mixer);\n\treturn err;\n}\n\nvoid snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tif (mixer->disconnected)\n\t\treturn;\n\tif (mixer->urb)\n\t\tusb_kill_urb(mixer->urb);\n\tif (mixer->rc_urb)\n\t\tusb_kill_urb(mixer->rc_urb);\n\tmixer->disconnected = true;\n}\n\n#ifdef CONFIG_PM\n/* stop any bus activity of a mixer */\nstatic void snd_usb_mixer_inactivate(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}\n\nstatic int snd_usb_mixer_activate(struct usb_mixer_interface *mixer)\n{\n\tint err;\n\n\tif (mixer->urb) {\n\t\terr = usb_submit_urb(mixer->urb, GFP_NOIO);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_mixer_suspend(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_inactivate(mixer);\n\treturn 0;\n}\n\nstatic int restore_mixer_value(struct usb_mixer_elem_list *list)\n{\n\tstruct usb_mixer_elem_info *cval = (struct usb_mixer_elem_info *)list;\n\tint c, err, idx;\n\n\tif (cval->cmask) {\n\t\tidx = 0;\n\t\tfor (c = 0; c < MAX_CHANNELS; c++) {\n\t\t\tif (!(cval->cmask & (1 << c)))\n\t\t\t\tcontinue;\n\t\t\tif (cval->cached & (1 << (c + 1))) {\n\t\t\t\terr = snd_usb_set_cur_mix_value(cval, c + 1, idx,\n\t\t\t\t\t\t\tcval->cache_val[idx]);\n\t\t\t\tif (err < 0)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t} else {\n\t\t/* master */\n\t\tif (cval->cached) {\n\t\t\terr = snd_usb_set_cur_mix_value(cval, 0, 0, *cval->cache_val);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_usb_mixer_resume(struct usb_mixer_interface *mixer, bool reset_resume)\n{\n\tstruct usb_mixer_elem_list *list;\n\tint id, err;\n\n\tif (reset_resume) {\n\t\t/* restore cached mixer values */\n\t\tfor (id = 0; id < MAX_ID_ELEMS; id++) {\n\t\t\tfor (list = mixer->id_elems[id]; list;\n\t\t\t     list = list->next_id_elem) {\n\t\t\t\tif (list->resume) {\n\t\t\t\t\terr = list->resume(list);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snd_usb_mixer_activate(mixer);\n}\n#endif\n\nvoid snd_usb_mixer_elem_init_std(struct usb_mixer_elem_list *list,\n\t\t\t\t struct usb_mixer_interface *mixer,\n\t\t\t\t int unitid)\n{\n\tlist->mixer = mixer;\n\tlist->id = unitid;\n\tlist->dump = snd_usb_mixer_dump_cval;\n#ifdef CONFIG_PM\n\tlist->resume = restore_mixer_value;\n#endif\n}\n", "#ifndef __USBMIXER_H\n#define __USBMIXER_H\n\n#include <sound/info.h>\n\nstruct usb_mixer_interface {\n\tstruct snd_usb_audio *chip;\n\tstruct usb_host_interface *hostif;\n\tstruct list_head list;\n\tunsigned int ignore_ctl_error;\n\tstruct urb *urb;\n\t/* array[MAX_ID_ELEMS], indexed by unit id */\n\tstruct usb_mixer_elem_list **id_elems;\n\n\t/* the usb audio specification version this interface complies to */\n\tint protocol;\n\n\t/* Sound Blaster remote control stuff */\n\tconst struct rc_config *rc_cfg;\n\tu32 rc_code;\n\twait_queue_head_t rc_waitq;\n\tstruct urb *rc_urb;\n\tstruct usb_ctrlrequest *rc_setup_packet;\n\tu8 rc_buffer[6];\n\n\tbool disconnected;\n};\n\n#define MAX_CHANNELS\t16\t/* max logical channels */\n\nenum {\n\tUSB_MIXER_BOOLEAN,\n\tUSB_MIXER_INV_BOOLEAN,\n\tUSB_MIXER_S8,\n\tUSB_MIXER_U8,\n\tUSB_MIXER_S16,\n\tUSB_MIXER_U16,\n\tUSB_MIXER_S32,\n\tUSB_MIXER_U32,\n};\n\ntypedef void (*usb_mixer_elem_dump_func_t)(struct snd_info_buffer *buffer,\n\t\t\t\t\t struct usb_mixer_elem_list *list);\ntypedef int (*usb_mixer_elem_resume_func_t)(struct usb_mixer_elem_list *elem);\n\nstruct usb_mixer_elem_list {\n\tstruct usb_mixer_interface *mixer;\n\tstruct usb_mixer_elem_list *next_id_elem; /* list of controls with same id */\n\tstruct snd_kcontrol *kctl;\n\tunsigned int id;\n\tusb_mixer_elem_dump_func_t dump;\n\tusb_mixer_elem_resume_func_t resume;\n};\n\nstruct usb_mixer_elem_info {\n\tstruct usb_mixer_elem_list head;\n\tunsigned int control;\t/* CS or ICN (high byte) */\n\tunsigned int cmask; /* channel mask bitmap: 0 = master */\n\tunsigned int idx_off; /* Control index offset */\n\tunsigned int ch_readonly;\n\tunsigned int master_readonly;\n\tint channels;\n\tint val_type;\n\tint min, max, res;\n\tint dBmin, dBmax;\n\tint cached;\n\tint cache_val[MAX_CHANNELS];\n\tu8 initialized;\n\tu8 min_mute;\n\tvoid *private_data;\n};\n\nint snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,\n\t\t\t int ignore_error);\nvoid snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer);\n\nvoid snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer, int unitid);\n\nint snd_usb_mixer_set_ctl_value(struct usb_mixer_elem_info *cval,\n\t\t\t\tint request, int validx, int value_set);\n\nint snd_usb_mixer_add_control(struct usb_mixer_elem_list *list,\n\t\t\t      struct snd_kcontrol *kctl);\n\nvoid snd_usb_mixer_elem_init_std(struct usb_mixer_elem_list *list,\n\t\t\t\t struct usb_mixer_interface *mixer,\n\t\t\t\t int unitid);\n\nint snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t  unsigned int size, unsigned int __user *_tlv);\n\n#ifdef CONFIG_PM\nint snd_usb_mixer_suspend(struct usb_mixer_interface *mixer);\nint snd_usb_mixer_resume(struct usb_mixer_interface *mixer, bool reset_resume);\n#endif\n\nint snd_usb_set_cur_mix_value(struct usb_mixer_elem_info *cval, int channel,\n                             int index, int value);\n\nint snd_usb_get_cur_mix_value(struct usb_mixer_elem_info *cval,\n                             int channel, int index, int *value);\n\nextern void snd_usb_mixer_elem_free(struct snd_kcontrol *kctl);\n\n#endif /* __USBMIXER_H */\n"], "filenames": ["sound/usb/mixer.c", "sound/usb/mixer.h"], "buggy_code_start_loc": [2236, 24], "buggy_code_end_loc": [2589, 24], "fixing_code_start_loc": [2237, 25], "fixing_code_end_loc": [2597, 27], "type": "CWE-416", "message": "sound/usb/mixer.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (snd_usb_mixer_interrupt use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.", "other": {"cve": {"id": "CVE-2017-16527", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.803", "lastModified": "2018-08-24T10:29:00.850", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "sound/usb/mixer.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (snd_usb_mixer_interrupt use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device."}, {"lang": "es", "value": "sound/usb/mixer.c en el kernel de Linux, en versiones anteriores a la 4.13.8, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (uso de memoria previamente liberada snd_usb_mixer_interrupt y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.7", "matchCriteriaId": "11C6B206-8716-4A16-81BD-F3B8C8ACBE19"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/jf7GTr_g2CU/iVlLhMciCQAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3754-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4"}}