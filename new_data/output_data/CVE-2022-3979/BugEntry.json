{"buggy_code": ["<?php\n/*****************************************************************************\n *\n * CoreLogonMultisite.php - Module for handling cookie based logins as\n *                          generated by multisite\n *\n * Copyright (c) 2004-2016 NagVis Project (Contact: info@nagvis.org)\n *\n * License:\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n *****************************************************************************/\n\nclass CoreLogonMultisite extends CoreLogonModule {\n    private $htpasswdPath;\n    private $serialsPath;\n    private $secretPath;\n    private $authFile;\n\n    public function __construct() {\n        $this->htpasswdPath = cfg('global', 'logon_multisite_htpasswd');\n        $this->serialsPath  = cfg('global', 'logon_multisite_serials');\n        $this->secretPath   = cfg('global', 'logon_multisite_secret');\n\n        // When the auth.serial file exists, use this instead of the htpasswd\n        // for validating the cookie. The structure of the file is equal, so\n        // the same code can be used.\n        if(file_exists($this->serialsPath)) {\n            $this->authFile = 'serial';\n\n        } elseif(file_exists($this->htpasswdPath)) {\n            $this->authFile = 'htpasswd';\n\n        } else {\n            throw new NagVisException(l('LogonMultisite: The htpasswd file &quot;[HTPASSWD]&quot; or '\n                                       .'the authentication serial file &quot;[SERIAL]&quot; do not exist.',\n                          array('HTPASSWD' => $this->htpasswdPath, 'SERIAL' => $this->serialsPath)));\n        }\n\n        if(!file_exists($this->secretPath)) {\n            $this->redirectToLogin();\n        }\n    }\n\n    private function loadAuthFile($path) {\n        $creds = array();\n        foreach(file($path) AS $line) {\n            if(strpos($line, ':') !== false) {\n                list($username, $secret) = explode(':', $line, 2);\n                $creds[$username] = rtrim($secret);\n            }\n        }\n        return $creds;\n    }\n\n    private function loadSecret() {\n        return trim(file_get_contents($this->secretPath));\n    }\n\n    private function generateHash($username, $session_id, $user_secret) {\n        $secret = $this->loadSecret();\n        return hash(\"sha256\", $username . $session_id. $user_secret . $secret);\n    }\n\n    private function generatePre20Hash($username, $issue_time, $user_secret) {\n        $secret = $this->loadSecret();\n        return md5($username . $issue_time . $user_secret . $secret);\n    }\n\n    private function checkAuthCookie($cookieName) {\n        if(!isset($_COOKIE[$cookieName]) || $_COOKIE[$cookieName] == '') {\n            throw new Exception();\n        }\n\n        // Checkmk 1.6+ may add double quotes round the value in some cases\n        // (e.g. when @ signs are found in the value)\n        $cookieValue = trim($_COOKIE[$cookieName], '\"');\n\n        // 2nd field is \"issue time\" in pre 2.0 cookies. Now it's the session ID\n        list($username, $sessionId, $cookieHash) = explode(':', $cookieValue, 3);\n\n        if($this->authFile == 'htpasswd')\n            $users = $this->loadAuthFile($this->htpasswdPath);\n        else\n            $users = $this->loadAuthFile($this->serialsPath);\n\n        if(!isset($users[$username])) {\n            throw new Exception();\n        }\n        $user_secret = $users[$username];\n\n        // Checkmk 2.0 changed the following:\n        // a) 2nd field from \"issue time\" to session ID\n        // b) 3rd field from md5 hash to sha256 hash\n        // NagVis is used with older and newer Checkmk versions. Be compatible\n        // to both cookie formats.\n        $is_pre_20_cookie = strlen($cookieHash) == 32;\n\n        if ($is_pre_20_cookie)\n            $hash = $this->generatePre20Hash($username, $sessionId, (string) $user_secret);\n        else\n            $hash = $this->generateHash($username, $sessionId, (string) $user_secret);\n\n        // Validate the hash\n        if ($cookieHash != $hash) {\n            throw new Exception();\n        }\n\n        // FIXME: Maybe renew the cookie here too\n\n        return $username;\n    }\n\n    private function checkAuth() {\n        // Loop all cookies trying to fetch a valid authentication\n        // cookie for this installation\n        foreach(array_keys($_COOKIE) AS $cookieName) {\n            if(substr($cookieName, 0, 5) != 'auth_') {\n                continue;\n            }\n            try {\n                $name = $this->checkAuthCookie($cookieName);\n\n                session_start();\n                $_SESSION['multisiteLogonCookie'] = $cookieName;\n                session_write_close();\n\n                return $name;\n            } catch(Exception $e) {}\n        }\n        return '';\n    }\n\n    private function redirectToLogin() {\n        // Do not redirect on ajax calls. Print out errors instead\n        if(CONST_AJAX) {\n            throw new NagVisException(l('LogonMultisite: Not authenticated.'));\n        }\n        // FIXME: Get the real path to multisite\n        header('Location:../../../check_mk/login.py?_origtarget=' . urlencode($_SERVER['REQUEST_URI']));\n    }\n\n    public function check($printErr = true) {\n        global $AUTH, $CORE;\n\n        // Try to auth using the environment auth\n        $ENV= new CoreLogonEnv();\n        if($ENV->check(false) === true) {\n            return true;\n        }\n\n        $username = $this->checkAuth();\n        if($username === '') {\n            $this->redirectToLogin();\n            return false;\n        }\n\n        // Check if the user exists\n        if($this->verifyUserExists($username,\n                        cfg('global', 'logon_multisite_createuser'),\n                        cfg('global', 'logon_multisite_createrole'),\n                        $printErr) === false) {\n            return false;\n        }\n\n        $AUTH->setTrustUsername(true);\n        $AUTH->setLogoutPossible(false);\n        $AUTH->passCredentials(Array('user' => $username));\n        return $AUTH->isAuthenticated();\n    }\n}\n\n?>\n"], "fixing_code": ["<?php\n/*****************************************************************************\n *\n * CoreLogonMultisite.php - Module for handling cookie based logins as\n *                          generated by multisite\n *\n * Copyright (c) 2004-2016 NagVis Project (Contact: info@nagvis.org)\n *\n * License:\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n *****************************************************************************/\n\nclass CoreLogonMultisite extends CoreLogonModule {\n    private $htpasswdPath;\n    private $serialsPath;\n    private $secretPath;\n    private $authFile;\n\n    public function __construct() {\n        $this->htpasswdPath = cfg('global', 'logon_multisite_htpasswd');\n        $this->serialsPath  = cfg('global', 'logon_multisite_serials');\n        $this->secretPath   = cfg('global', 'logon_multisite_secret');\n\n        // When the auth.serial file exists, use this instead of the htpasswd\n        // for validating the cookie. The structure of the file is equal, so\n        // the same code can be used.\n        if(file_exists($this->serialsPath)) {\n            $this->authFile = 'serial';\n\n        } elseif(file_exists($this->htpasswdPath)) {\n            $this->authFile = 'htpasswd';\n\n        } else {\n            throw new NagVisException(l('LogonMultisite: The htpasswd file &quot;[HTPASSWD]&quot; or '\n                                       .'the authentication serial file &quot;[SERIAL]&quot; do not exist.',\n                          array('HTPASSWD' => $this->htpasswdPath, 'SERIAL' => $this->serialsPath)));\n        }\n\n        if(!file_exists($this->secretPath)) {\n            $this->redirectToLogin();\n        }\n    }\n\n    private function loadAuthFile($path) {\n        $creds = array();\n        foreach(file($path) AS $line) {\n            if(strpos($line, ':') !== false) {\n                list($username, $secret) = explode(':', $line, 2);\n                $creds[$username] = rtrim($secret);\n            }\n        }\n        return $creds;\n    }\n\n    private function loadSecret() {\n        return trim(file_get_contents($this->secretPath));\n    }\n\n    private function generateHash($username, $session_id, $user_secret) {\n        $secret = $this->loadSecret();\n        return hash(\"sha256\", $username . $session_id. $user_secret . $secret);\n    }\n\n    private function generatePre20Hash($username, $issue_time, $user_secret) {\n        $secret = $this->loadSecret();\n        return md5($username . $issue_time . $user_secret . $secret);\n    }\n\n    private function checkAuthCookie($cookieName) {\n        if(!isset($_COOKIE[$cookieName]) || $_COOKIE[$cookieName] == '') {\n            throw new Exception();\n        }\n\n        // Checkmk 1.6+ may add double quotes round the value in some cases\n        // (e.g. when @ signs are found in the value)\n        $cookieValue = trim($_COOKIE[$cookieName], '\"');\n\n        // 2nd field is \"issue time\" in pre 2.0 cookies. Now it's the session ID\n        list($username, $sessionId, $cookieHash) = explode(':', $cookieValue, 3);\n\n        if($this->authFile == 'htpasswd')\n            $users = $this->loadAuthFile($this->htpasswdPath);\n        else\n            $users = $this->loadAuthFile($this->serialsPath);\n\n        if(!isset($users[$username])) {\n            throw new Exception();\n        }\n        $user_secret = $users[$username];\n\n        // Checkmk 2.0 changed the following:\n        // a) 2nd field from \"issue time\" to session ID\n        // b) 3rd field from md5 hash to sha256 hash\n        // NagVis is used with older and newer Checkmk versions. Be compatible\n        // to both cookie formats.\n        $is_pre_20_cookie = strlen($cookieHash) == 32;\n\n        if ($is_pre_20_cookie)\n            $hash = $this->generatePre20Hash($username, $sessionId, (string) $user_secret);\n        else\n            $hash = $this->generateHash($username, $sessionId, (string) $user_secret);\n\n        // Validate the hash\n        if ($cookieHash !== $hash) {\n            throw new Exception();\n        }\n\n        return $username;\n    }\n\n    private function checkAuth() {\n        // Loop all cookies trying to fetch a valid authentication\n        // cookie for this installation\n        foreach(array_keys($_COOKIE) AS $cookieName) {\n            if(substr($cookieName, 0, 5) != 'auth_') {\n                continue;\n            }\n            try {\n                $name = $this->checkAuthCookie($cookieName);\n\n                session_start();\n                $_SESSION['multisiteLogonCookie'] = $cookieName;\n                session_write_close();\n\n                return $name;\n            } catch(Exception $e) {}\n        }\n        return '';\n    }\n\n    private function redirectToLogin() {\n        // Do not redirect on ajax calls. Print out errors instead\n        if(CONST_AJAX) {\n            throw new NagVisException(l('LogonMultisite: Not authenticated.'));\n        }\n        // FIXME: Get the real path to multisite\n        header('Location:../../../check_mk/login.py?_origtarget=' . urlencode($_SERVER['REQUEST_URI']));\n    }\n\n    public function check($printErr = true) {\n        global $AUTH, $CORE;\n\n        // Try to auth using the environment auth\n        $ENV= new CoreLogonEnv();\n        if($ENV->check(false) === true) {\n            return true;\n        }\n\n        $username = $this->checkAuth();\n        if($username === '') {\n            $this->redirectToLogin();\n            return false;\n        }\n\n        // Check if the user exists\n        if($this->verifyUserExists($username,\n                        cfg('global', 'logon_multisite_createuser'),\n                        cfg('global', 'logon_multisite_createrole'),\n                        $printErr) === false) {\n            return false;\n        }\n\n        $AUTH->setTrustUsername(true);\n        $AUTH->setLogoutPossible(false);\n        $AUTH->passCredentials(Array('user' => $username));\n        return $AUTH->isAuthenticated();\n    }\n}\n\n?>\n"], "filenames": ["share/server/core/classes/CoreLogonMultisite.php"], "buggy_code_start_loc": [117], "buggy_code_end_loc": [122], "fixing_code_start_loc": [117], "fixing_code_end_loc": [119], "type": "CWE-704", "message": "A vulnerability was found in NagVis up to 1.9.33 and classified as problematic. This issue affects the function checkAuthCookie of the file share/server/core/classes/CoreLogonMultisite.php. The manipulation of the argument hash leads to incorrect type conversion. The attack may be initiated remotely. Upgrading to version 1.9.34 is able to address this issue. The name of the patch is 7574fd8a2903282c2e0d1feef5c4876763db21d5. It is recommended to upgrade the affected component. The identifier VDB-213557 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-3979", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-13T23:15:09.810", "lastModified": "2022-11-18T21:19:09.317", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in NagVis up to 1.9.33 and classified as problematic. This issue affects the function checkAuthCookie of the file share/server/core/classes/CoreLogonMultisite.php. The manipulation of the argument hash leads to incorrect type conversion. The attack may be initiated remotely. Upgrading to version 1.9.34 is able to address this issue. The name of the patch is 7574fd8a2903282c2e0d1feef5c4876763db21d5. It is recommended to upgrade the affected component. The identifier VDB-213557 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-704"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nagvis:nagvis:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.34", "matchCriteriaId": "6958F106-F947-4580-A8AF-D151A3E8CA12"}]}]}], "references": [{"url": "https://github.com/NagVis/nagvis/commit/7574fd8a2903282c2e0d1feef5c4876763db21d5", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NagVis/nagvis/releases/tag/nagvis-1.9.34", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.213557", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NagVis/nagvis/commit/7574fd8a2903282c2e0d1feef5c4876763db21d5"}}