{"buggy_code": ["// Copyright 2020-2023 Project Capsule Authors.\n// SPDX-License-Identifier: Apache-2.0\n\npackage controllers\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\tcapsulev1beta2 \"github.com/clastix/capsule/api/v1beta2\"\n\t\"github.com/pkg/errors\"\n\trbacv1 \"k8s.io/api/rbac/v1\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/apiserver/pkg/authentication/serviceaccount\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\t\"github.com/projectcapsule/capsule-proxy/internal/request\"\n)\n\nconst subjectIndex = \"subjectIndex\"\n\ntype RoleBindingReflector struct {\n\tstore     cache.Indexer\n\treflector *cache.Reflector\n}\n\nfunc NewRoleBindingReflector(config *rest.Config, resyncPeriod time.Duration) (*RoleBindingReflector, error) {\n\tclientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot create kubernetes clientset\")\n\t}\n\n\twatcher := cache.NewListWatchFromClient(clientset.RbacV1().RESTClient(), \"rolebindings\", \"\", fields.Everything())\n\n\tstore := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{subjectIndex: OwnerRoleBindingsIndexFunc})\n\n\treflector := cache.NewReflector(watcher, &rbacv1.RoleBinding{}, store, resyncPeriod)\n\n\treturn &RoleBindingReflector{\n\t\tstore:     store,\n\t\treflector: reflector,\n\t}, nil\n}\n\nfunc (r *RoleBindingReflector) GetUserNamespacesFromRequest(req request.Request) ([]string, error) {\n\tvar err error\n\n\tusername, groups, _ := req.GetUserAndGroups()\n\n\tnamespaces := sets.NewString()\n\n\tuserOwnerKind := capsulev1beta2.UserOwner\n\n\tvar userRoleBindings []interface{}\n\n\tif strings.HasPrefix(username, serviceaccount.ServiceAccountUsernamePrefix) {\n\t\tuserOwnerKind = capsulev1beta2.ServiceAccountOwner\n\n\t\t_, username, err = serviceaccount.SplitUsername(username)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"Unable to parse serviceAccount name\")\n\t\t}\n\t}\n\n\tuserRoleBindings, err = r.store.ByIndex(subjectIndex, fmt.Sprintf(\"%s-%s\", userOwnerKind, username))\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Unable to find rolebindings in index for user\")\n\t}\n\n\tfor _, rb := range userRoleBindings {\n\t\trb := rb.(*rbacv1.RoleBinding)\n\t\tnamespaces.Insert(rb.GetNamespace())\n\t}\n\n\tfor _, group := range groups {\n\t\tgroupRoleBindings, err := r.store.ByIndex(subjectIndex, fmt.Sprintf(\"%s-%s\", capsulev1beta2.GroupOwner, group))\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"Unable to find rolebindings in index for groups\")\n\t\t}\n\n\t\tfor _, rb := range groupRoleBindings {\n\t\t\trb := rb.(*rbacv1.RoleBinding)\n\t\t\tnamespaces.Insert(rb.GetNamespace())\n\t\t}\n\t}\n\n\treturn namespaces.List(), nil\n}\n\nfunc (r *RoleBindingReflector) Start(ctx context.Context) error {\n\tr.reflector.Run(ctx.Done())\n\n\treturn nil\n}\n\nfunc OwnerRoleBindingsIndexFunc(obj interface{}) (result []string, err error) {\n\trb := obj.(*rbacv1.RoleBinding)\n\n\tfor _, subject := range rb.Subjects {\n\t\tresult = append(result, fmt.Sprintf(\"%s-%s\", subject.Kind, subject.Name))\n\t}\n\n\treturn result, nil\n}\n"], "fixing_code": ["// Copyright 2020-2023 Project Capsule Authors.\n// SPDX-License-Identifier: Apache-2.0\n\npackage controllers\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\tcapsulev1beta2 \"github.com/clastix/capsule/api/v1beta2\"\n\t\"github.com/pkg/errors\"\n\trbacv1 \"k8s.io/api/rbac/v1\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\t\"k8s.io/apiserver/pkg/authentication/serviceaccount\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\t\"github.com/projectcapsule/capsule-proxy/internal/request\"\n)\n\nconst subjectIndex = \"subjectIndex\"\n\ntype RoleBindingReflector struct {\n\tstore     cache.Indexer\n\treflector *cache.Reflector\n}\n\nfunc NewRoleBindingReflector(config *rest.Config, resyncPeriod time.Duration) (*RoleBindingReflector, error) {\n\tclientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"cannot create kubernetes clientset\")\n\t}\n\n\twatcher := cache.NewListWatchFromClient(clientset.RbacV1().RESTClient(), \"rolebindings\", \"\", fields.Everything())\n\n\tstore := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{subjectIndex: OwnerRoleBindingsIndexFunc})\n\n\treflector := cache.NewReflector(watcher, &rbacv1.RoleBinding{}, store, resyncPeriod)\n\n\treturn &RoleBindingReflector{\n\t\tstore:     store,\n\t\treflector: reflector,\n\t}, nil\n}\n\nfunc (r *RoleBindingReflector) GetUserNamespacesFromRequest(req request.Request) ([]string, error) {\n\tvar err error\n\n\tusername, groups, _ := req.GetUserAndGroups()\n\n\tnamespaces := sets.NewString()\n\n\tuserOwnerKind := capsulev1beta2.UserOwner\n\n\tvar userRoleBindings []interface{}\n\n\tif strings.HasPrefix(username, serviceaccount.ServiceAccountUsernamePrefix) {\n\t\tuserOwnerKind = capsulev1beta2.ServiceAccountOwner\n\n\t\tnamespace, name, splitErr := serviceaccount.SplitUsername(username)\n\t\tif splitErr != nil {\n\t\t\treturn nil, errors.Wrap(splitErr, \"Unable to parse serviceAccount name\")\n\t\t}\n\n\t\tusername = fmt.Sprintf(\"%s-%s\", namespace, name)\n\t}\n\n\tuserRoleBindings, err = r.store.ByIndex(subjectIndex, fmt.Sprintf(\"%s-%s\", userOwnerKind, username))\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Unable to find rolebindings in index for user\")\n\t}\n\n\tfor _, rb := range userRoleBindings {\n\t\trb := rb.(*rbacv1.RoleBinding)\n\t\tnamespaces.Insert(rb.GetNamespace())\n\t}\n\n\tfor _, group := range groups {\n\t\tgroupRoleBindings, err := r.store.ByIndex(subjectIndex, fmt.Sprintf(\"%s-%s\", capsulev1beta2.GroupOwner, group))\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"Unable to find rolebindings in index for groups\")\n\t\t}\n\n\t\tfor _, rb := range groupRoleBindings {\n\t\t\trb := rb.(*rbacv1.RoleBinding)\n\t\t\tnamespaces.Insert(rb.GetNamespace())\n\t\t}\n\t}\n\n\treturn namespaces.List(), nil\n}\n\nfunc (r *RoleBindingReflector) Start(ctx context.Context) error {\n\tr.reflector.Run(ctx.Done())\n\n\treturn nil\n}\n\nfunc OwnerRoleBindingsIndexFunc(obj interface{}) (result []string, err error) {\n\trb := obj.(*rbacv1.RoleBinding)\n\n\tfor _, subject := range rb.Subjects {\n\t\tparts := []string{subject.Kind}\n\n\t\tif len(subject.Namespace) > 0 {\n\t\t\tparts = append(parts, subject.Namespace)\n\t\t}\n\n\t\tparts = append(parts, subject.Name)\n\n\t\tresult = append(result, strings.Join(parts, \"-\"))\n\t}\n\n\treturn result, nil\n}\n"], "filenames": ["internal/controllers/role_bindings.go"], "buggy_code_start_loc": [64], "buggy_code_end_loc": [106], "fixing_code_start_loc": [64], "fixing_code_end_loc": [116], "type": "NVD-CWE-noinfo", "message": "capsule-proxy is a reverse proxy for Capsule kubernetes multi-tenancy framework. A bug in the RoleBinding reflector used by `capsule-proxy` gives ServiceAccount tenant owners the right to list Namespaces of other tenants backed by the same owner kind and name. For example consider two tenants `solar` and `wind`. Tenant `solar`, owned by a ServiceAccount named `tenant-owner` in the Namespace `solar`. Tenant `wind`, owned by a ServiceAccount named `tenant-owner` in the Namespace `wind`. The Tenant owner `solar` would be able to list the namespaces of the Tenant `wind` and vice-versa, although this is not correct. The bug introduces an exfiltration vulnerability since allows the listing of Namespace resources of other Tenants, although just in some specific conditions: 1. `capsule-proxy` runs with the `--disable-caching=false` (default value: `false`) and 2. Tenant owners are ServiceAccount, with the same resource name, but in different Namespaces. This vulnerability doesn't allow any privilege escalation on the outer tenant Namespace-scoped resources, since the Kubernetes RBAC is enforcing this. This issue has been addressed in version 0.4.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-46254", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-06T19:15:09.230", "lastModified": "2023-11-14T19:35:14.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "capsule-proxy is a reverse proxy for Capsule kubernetes multi-tenancy framework. A bug in the RoleBinding reflector used by `capsule-proxy` gives ServiceAccount tenant owners the right to list Namespaces of other tenants backed by the same owner kind and name. For example consider two tenants `solar` and `wind`. Tenant `solar`, owned by a ServiceAccount named `tenant-owner` in the Namespace `solar`. Tenant `wind`, owned by a ServiceAccount named `tenant-owner` in the Namespace `wind`. The Tenant owner `solar` would be able to list the namespaces of the Tenant `wind` and vice-versa, although this is not correct. The bug introduces an exfiltration vulnerability since allows the listing of Namespace resources of other Tenants, although just in some specific conditions: 1. `capsule-proxy` runs with the `--disable-caching=false` (default value: `false`) and 2. Tenant owners are ServiceAccount, with the same resource name, but in different Namespaces. This vulnerability doesn't allow any privilege escalation on the outer tenant Namespace-scoped resources, since the Kubernetes RBAC is enforcing this. This issue has been addressed in version 0.4.5. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Capsule-proxy es un proxy inverso para el framework multi-tenancy de Capsule Kubernetes. Un bug en el reflector RoleBinding utilizado por `capsule-proxy` otorga a los propietarios de tenants de ServiceAccount el derecho de enumerar espacios de nombres de otros tenants respaldados por el mismo tipo y nombre de propietario. Por ejemplo, considere dos tenant \"\"\"\"solar\"\"\"\" y \"\"\"\"wind\"\"\"\". El tenant \"\"\"\"solar\"\"\"\", propiedad de una cuenta de servicio denominada \"\"\"\"tenant-owner\"\"\"\" en el espacio de nombres \"\"\"\"solar\"\"\"\". El tenant \"\"\"\"wind\"\"\"\", propiedad de una cuenta de servicio denominada \"\"\"\"tenant-owner\"\"\"\" en el espacio de nombres \"\"\"\"wind\"\"\"\". El propietario del inquilino \"\"\"\"solar\"\"\"\" podr\u00eda enumerar los espacios de nombres del inquilino \"\"\"\"wind\"\"\"\" y viceversa, aunque esto no es correcto. El error introduce una vulnerabilidad de exfiltraci\u00f3n ya que permite enumerar los recursos del espacio de nombres de otros tenant, aunque solo en algunas condiciones espec\u00edficas:\n1. `capsule-proxy` se ejecuta con `--disable-caching=false` (valor predeterminado: `false` ) y \n2. Los propietarios de los tenant son ServiceAccount, con el mismo nombre de recurso, pero en diferentes espacios de nombres.\nEsta vulnerabilidad no permite ninguna escalada de privilegios en los recursos con \u00e1mbito de espacio de nombres del inquilino externo, ya que Kubernetes RBAC lo est\u00e1 aplicando. \nEste problema se solucion\u00f3 en la versi\u00f3n 0.4.5. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clastix:capsule:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.5", "matchCriteriaId": "0A4C4DC0-2E0E-4FA7-92DA-30E31FC51CC9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:clastix:capsule-proxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.5", "matchCriteriaId": "ECFAD73A-15CD-473C-8D55-645E5E5E395F"}]}]}], "references": [{"url": "https://github.com/projectcapsule/capsule-proxy/commit/615202f7b02eaec7681336bd63daed1f39ae00c5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/projectcapsule/capsule-proxy/security/advisories/GHSA-6758-979h-249x", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/projectcapsule/capsule-proxy/commit/615202f7b02eaec7681336bd63daed1f39ae00c5"}}