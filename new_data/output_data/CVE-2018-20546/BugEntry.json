{"buggy_code": ["/*\n *  libcaca     Colour ASCII-Art library\n *  Copyright \u00a9 2002\u20142018 Sam Hocevar <sam@hocevar.net>\n *              All Rights Reserved\n *\n *  This library is free software. It comes without any warranty, to\n *  the extent permitted by applicable law. You can redistribute it\n *  and/or modify it under the terms of the Do What the Fuck You Want\n *  to Public License, Version 2, as published by Sam Hocevar. See\n *  http://www.wtfpl.net/ for more details.\n */\n\n/*\n *  This file contains bitmap dithering functions.\n */\n\n#include \"config.h\"\n\n#if !defined(__KERNEL__)\n#   if defined(HAVE_ENDIAN_H)\n#       include <endian.h>\n#   endif\n#   include <stdio.h>\n#   include <stdlib.h>\n#   include <limits.h>\n#   include <string.h>\n#endif\n\n#include \"caca.h\"\n#include \"caca_internals.h\"\n\n#define CP437 0\n\n/*\n * Local variables\n */\n#if !defined(_DOXYGEN_SKIP_ME)\n#   define LOOKUP_VAL 32\n#   define LOOKUP_SAT 32\n#   define LOOKUP_HUE 16\n#endif\nstatic uint8_t hsv_distances[LOOKUP_VAL][LOOKUP_SAT][LOOKUP_HUE];\nstatic uint16_t lookup_colors[8];\nstatic int lookup_initialised = 0;\n\nstatic int const hsv_palette[] =\n{\n    /* weight, hue, saturation, value */\n    4,    0x0,    0x0,    0x0,   /* black */\n    5,    0x0,    0x0,    0x5ff, /* 30% */\n    5,    0x0,    0x0,    0x9ff, /* 70% */\n    4,    0x0,    0x0,    0xfff, /* white */\n    3,    0x1000, 0xfff,  0x5ff, /* dark yellow */\n    2,    0x1000, 0xfff,  0xfff, /* light yellow */\n    3,    0x0,    0xfff,  0x5ff, /* dark red */\n    2,    0x0,    0xfff,  0xfff  /* light red */\n};\n\n/* RGB palette for the new colour picker */\nstatic int const rgb_palette[] =\n{\n    0x0,   0x0,   0x0,\n    0x0,   0x0,   0x7ff,\n    0x0,   0x7ff, 0x0,\n    0x0,   0x7ff, 0x7ff,\n    0x7ff, 0x0,   0x0,\n    0x7ff, 0x0,   0x7ff,\n    0x7ff, 0x7ff, 0x0,\n    0xaaa, 0xaaa, 0xaaa,\n    0x555, 0x555, 0x555,\n    0x000, 0x000, 0xfff,\n    0x000, 0xfff, 0x000,\n    0x000, 0xfff, 0xfff,\n    0xfff, 0x000, 0x000,\n    0xfff, 0x000, 0xfff,\n    0xfff, 0xfff, 0x000,\n    0xfff, 0xfff, 0xfff,\n};\n\nstatic int const rgb_weight[] =\n{\n    /* 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2 */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n};\n\n/* List of glyphs */\nstatic uint32_t ascii_glyphs[] =\n{\n    ' ', '.', ':', ';', 't', '%', 'S', 'X', '@', '8', '?'\n};\n\nstatic uint32_t shades_glyphs[] =\n{\n    /* ' '. '\u00b7', '\u2591', '\u2592', '?' */\n    ' ', 0xb7, 0x2591, 0x2592, '?'\n};\n\nstatic uint32_t blocks_glyphs[] =\n{\n    /* ' ', '\u2598', '\u259a', '?' */\n    ' ', 0x2598, 0x259a, '?'\n};\n\n#if !defined(_DOXYGEN_SKIP_ME)\nenum color_mode\n{\n    COLOR_MODE_MONO,\n    COLOR_MODE_GRAY,\n    COLOR_MODE_8,\n    COLOR_MODE_16,\n    COLOR_MODE_FULLGRAY,\n    COLOR_MODE_FULL8,\n    COLOR_MODE_FULL16\n};\n\nstruct caca_dither\n{\n    int bpp, has_palette, has_alpha;\n    int w, h, pitch;\n    int rmask, gmask, bmask, amask;\n    int rright, gright, bright, aright;\n    int rleft, gleft, bleft, aleft;\n    void (*get_hsv)(caca_dither_t *, char *, int, int);\n    int red[256], green[256], blue[256], alpha[256];\n\n    /* Colour features */\n    float gamma, brightness, contrast;\n    int gammatab[4097];\n\n    /* Dithering features */\n    char const *antialias_name;\n    int antialias;\n\n    char const *color_name;\n    enum color_mode color;\n\n    char const *algo_name;\n    void (*init_dither) (int);\n    int (*get_dither) (void);\n    void (*increment_dither) (void);\n\n    char const *glyph_name;\n    uint32_t const * glyphs;\n    int glyph_count;\n\n    int invert;\n};\n\n#define HSV_XRATIO 6\n#define HSV_YRATIO 3\n#define HSV_HRATIO 3\n\n#define HSV_DISTANCE(h, s, v, index) \\\n    (hsv_palette[index * 4] \\\n     * ((HSV_XRATIO * ((v) - hsv_palette[index * 4 + 3]) \\\n                    * ((v) - hsv_palette[index * 4 + 3])) \\\n       + (hsv_palette[index * 4 + 3] \\\n           ? (HSV_YRATIO * ((s) - hsv_palette[index * 4 + 2]) \\\n                         * ((s) - hsv_palette[index * 4 + 2])) \\\n           : 0) \\\n       + (hsv_palette[index * 4 + 2] \\\n           ? (HSV_HRATIO * ((h) - hsv_palette[index * 4 + 1]) \\\n                         * ((h) - hsv_palette[index * 4 + 1])) \\\n           : 0)))\n#endif\n\n/*\n * Local prototypes\n */\nstatic void mask2shift(uint32_t, int *, int *);\nstatic float gammapow(float x, float y);\n\nstatic void get_rgba_default(caca_dither_t const *, uint8_t const *, int, int,\n                             unsigned int *);\nstatic int init_lookup(void);\n\n/* Dithering algorithms */\nstatic void init_no_dither(int);\nstatic int get_no_dither(void);\nstatic void increment_no_dither(void);\n\nstatic void init_fstein_dither(int);\nstatic int get_fstein_dither(void);\nstatic void increment_fstein_dither(void);\n\nstatic void init_ordered2_dither(int);\nstatic int get_ordered2_dither(void);\nstatic void increment_ordered2_dither(void);\n\nstatic void init_ordered4_dither(int);\nstatic int get_ordered4_dither(void);\nstatic void increment_ordered4_dither(void);\n\nstatic void init_ordered8_dither(int);\nstatic int get_ordered8_dither(void);\nstatic void increment_ordered8_dither(void);\n\nstatic void init_random_dither(int);\nstatic int get_random_dither(void);\nstatic void increment_random_dither(void);\n\nstatic inline int sq(int x)\n{\n    return x * x;\n}\n\nstatic inline void rgb2hsv_default(int r, int g, int b,\n                                   int *hue, int *sat, int *val)\n{\n    int min, max, delta;\n\n    min = r; max = r;\n    if(min > g) min = g; if(max < g) max = g;\n    if(min > b) min = b; if(max < b) max = b;\n\n    delta = max - min; /* 0 - 0xfff */\n    *val = max; /* 0 - 0xfff */\n\n    if(delta)\n    {\n        *sat = 0xfff * delta / max; /* 0 - 0xfff */\n\n        /* Generate *hue between 0 and 0x5fff */\n        if( r == max )\n            *hue = 0x1000 + 0x1000 * (g - b) / delta;\n        else if( g == max )\n            *hue = 0x3000 + 0x1000 * (b - r) / delta;\n        else\n            *hue = 0x5000 + 0x1000 * (r - g) / delta;\n    }\n    else\n    {\n        *sat = 0;\n        *hue = 0;\n    }\n}\n\n/** \\brief Create an internal dither object.\n *\n *  Create a dither structure from its coordinates (depth, width, height and\n *  pitch) and pixel mask values. If the depth is 8 bits per pixel, the mask\n *  values are ignored and the colour palette should be set using the\n *  caca_set_dither_palette() function. For depths greater than 8 bits per\n *  pixel, a zero alpha mask causes the alpha values to be ignored.\n *\n *  If an error occurs, NULL is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Requested width, height, pitch or bits per pixel value was\n *    invalid.\n *  - \\c ENOMEM Not enough memory to allocate dither structure.\n *\n *  \\param bpp Bitmap depth in bits per pixel.\n *  \\param w Bitmap width in pixels.\n *  \\param h Bitmap height in pixels.\n *  \\param pitch Bitmap pitch in bytes.\n *  \\param rmask Bitmask for red values.\n *  \\param gmask Bitmask for green values.\n *  \\param bmask Bitmask for blue values.\n *  \\param amask Bitmask for alpha values.\n *  \\return Dither object upon success, NULL if an error occurred.\n */\ncaca_dither_t *caca_create_dither(int bpp, int w, int h, int pitch,\n                                    uint32_t rmask, uint32_t gmask,\n                                    uint32_t bmask, uint32_t amask)\n{\n    caca_dither_t *d;\n    int i;\n\n    /* Minor sanity test */\n    if(w < 0 || h < 0 || pitch < 0 || bpp > 32 || bpp < 8)\n    {\n        seterrno(EINVAL);\n        return NULL;\n    }\n\n    d = malloc(sizeof(caca_dither_t));\n    if(!d)\n    {\n        seterrno(ENOMEM);\n        return NULL;\n    }\n\n    if(!lookup_initialised)\n    {\n        /* XXX: because we do not wish to be thread-safe, there is a slight\n         * chance that the following code will be executed twice. It is\n         * totally harmless. */\n        init_lookup();\n        lookup_initialised = 1;\n    }\n\n    d->bpp = bpp;\n    d->has_palette = 0;\n    d->has_alpha = amask ? 1 : 0;\n\n    d->w = w;\n    d->h = h;\n    d->pitch = pitch;\n\n    d->rmask = rmask;\n    d->gmask = gmask;\n    d->bmask = bmask;\n    d->amask = amask;\n\n    /* Load bitmasks */\n    if(rmask || gmask || bmask || amask)\n    {\n        mask2shift(rmask, &d->rright, &d->rleft);\n        mask2shift(gmask, &d->gright, &d->gleft);\n        mask2shift(bmask, &d->bright, &d->bleft);\n        mask2shift(amask, &d->aright, &d->aleft);\n    }\n\n    /* In 8 bpp mode, default to a grayscale palette */\n    if(bpp == 8)\n    {\n        d->has_palette = 1;\n        d->has_alpha = 0;\n        for(i = 0; i < 256; i++)\n        {\n            d->red[i] = i * 0xfff / 256;\n            d->green[i] = i * 0xfff / 256;\n            d->blue[i] = i * 0xfff / 256;\n        }\n    }\n\n    /* Default gamma value */\n    d->gamma = 1.0;\n    for(i = 0; i < 4096; i++)\n        d->gammatab[i] = i;\n\n    /* Default colour properties */\n    d->brightness = 1.0;\n    d->contrast = 1.0;\n\n    /* Default features */\n    d->antialias_name = \"prefilter\";\n    d->antialias = 1;\n\n    d->color_name = \"full16\";\n    d->color = COLOR_MODE_FULL16;\n\n    d->glyph_name = \"ascii\";\n    d->glyphs = ascii_glyphs;\n    d->glyph_count = sizeof(ascii_glyphs) / sizeof(*ascii_glyphs);\n\n    d->algo_name = \"fstein\";\n    d->init_dither = init_fstein_dither;\n    d->get_dither = get_fstein_dither;\n    d->increment_dither = increment_fstein_dither;\n\n    d->invert = 0;\n\n    return d;\n}\n\n/** \\brief Set the palette of an 8bpp dither object.\n *\n *  Set the palette of an 8 bits per pixel bitmap. Values should be between\n *  0 and 4095 (0xfff).\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Dither bits per pixel value is not 8, or one of the pixel\n *   values was outside the range 0 - 4095.\n *\n *  \\param d Dither object.\n *  \\param red Array of 256 red values.\n *  \\param green Array of 256 green values.\n *  \\param blue Array of 256 blue values.\n *  \\param alpha Array of 256 alpha values.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_palette(caca_dither_t *d,\n                             uint32_t red[], uint32_t green[],\n                             uint32_t blue[], uint32_t alpha[])\n{\n    int i, has_alpha = 0;\n\n    if(d->bpp != 8)\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    for(i = 0; i < 256; i++)\n    {\n        if((red[i] | green[i] | blue[i] | alpha[i]) >= 0x1000)\n        {\n            seterrno(EINVAL);\n            return -1;\n        }\n    }\n\n    for(i = 0; i < 256; i++)\n    {\n        d->red[i] = red[i];\n        d->green[i] = green[i];\n        d->blue[i] = blue[i];\n        if(alpha[i])\n        {\n            d->alpha[i] = alpha[i];\n            has_alpha = 1;\n        }\n    }\n\n    d->has_alpha = has_alpha;\n\n    return 0;\n}\n\n/** \\brief Set the brightness of a dither object.\n *\n *  Set the brightness of dither.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Brightness value was out of range.\n *\n *  \\param d Dither object.\n *  \\param brightness brightness value.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_brightness(caca_dither_t *d, float brightness)\n{\n    /* FIXME */\n    d->brightness = brightness;\n\n    return 0;\n}\n\n/** \\brief Get the brightness of a dither object.\n *\n *  Get the brightness of the given dither object.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return Brightness value.\n */\nfloat caca_get_dither_brightness(caca_dither_t const *d)\n{\n    return d->brightness;\n}\n\n/** \\brief Set the gamma of a dither object.\n *\n *  Set the gamma of the given dither object. A negative value causes\n *  colour inversion.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Gamma value was out of range.\n *\n *  \\param d Dither object.\n *  \\param gamma Gamma value.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_gamma(caca_dither_t *d, float gamma)\n{\n    /* FIXME: we don't need 4096 calls to gammapow(), we could just compute\n     * a few of them and do linear interpolation for the rest. This will\n     * probably speed up things a lot. */\n    int i;\n\n    if(gamma < 0.0)\n    {\n        d->invert = 1;\n        gamma = -gamma;\n    }\n    else if(gamma == 0.0)\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    d->gamma = gamma;\n\n    for(i = 0; i < 4096; i++)\n        d->gammatab[i] = 4096.0 * gammapow((float)i / 4096.0, 1.0 / gamma);\n\n    return 0;\n}\n\n/** \\brief Get the gamma of a dither object.\n *\n *  Get the gamma of the given dither object.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return Gamma value.\n */\nfloat caca_get_dither_gamma(caca_dither_t const *d)\n{\n    return d->gamma;\n}\n\n/** \\brief Set the contrast of a dither object.\n *\n *  Set the contrast of dither.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Contrast value was out of range.\n *\n *  \\param d Dither object.\n *  \\param contrast contrast value.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_contrast(caca_dither_t *d, float contrast)\n{\n    /* FIXME */\n    d->contrast = contrast;\n\n    return 0;\n}\n\n/** \\brief Get the contrast of a dither object.\n *\n *  Get the contrast of the given dither object.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return Contrast value.\n */\nfloat caca_get_dither_contrast(caca_dither_t const *d)\n{\n    return d->contrast;\n}\n\n/** \\brief Set dither antialiasing\n *\n *  Tell the renderer whether to antialias the dither. Antialiasing smoothens\n *  the rendered image and avoids the commonly seen staircase effect.\n *  - \\c \"none\": no antialiasing.\n *  - \\c \"prefilter\" or \\c \"default\": simple prefilter antialiasing. This\n *    is the default value.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Invalid antialiasing mode.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the antialiasing method that will be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_antialias(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"none\"))\n    {\n        d->antialias_name = \"none\";\n        d->antialias = 0;\n    }\n    else if(!strcasecmp(str, \"prefilter\") || !strcasecmp(str, \"default\"))\n    {\n        d->antialias_name = \"prefilter\";\n        d->antialias = 1;\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get available antialiasing methods\n *\n *  Return a list of available antialiasing methods for a given dither. The\n *  list is a NULL-terminated array of strings, interleaving a string\n *  containing the internal value for the antialiasing method to be used with\n *  caca_set_dither_antialias(), and a string containing the natural\n *  language description for that antialiasing method.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const *\n    caca_get_dither_antialias_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"none\", \"No antialiasing\",\n        \"prefilter\", \"Prefilter antialiasing\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current antialiasing method\n *\n *  Return the given dither's current antialiasing method.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_antialias(caca_dither_t const *d)\n{\n    return d->antialias_name;\n}\n\n/** \\brief Choose colours used for dithering\n *\n *  Tell the renderer which colours should be used to render the\n *  bitmap. Valid values for \\c str are:\n *  - \\c \"mono\": use light gray on a black background.\n *  - \\c \"gray\": use white and two shades of gray on a black background.\n *  - \\c \"8\": use the 8 ANSI colours on a black background.\n *  - \\c \"16\": use the 16 ANSI colours on a black background.\n *  - \\c \"fullgray\": use black, white and two shades of gray for both the\n *    characters and the background.\n *  - \\c \"full8\": use the 8 ANSI colours for both the characters and the\n *    background.\n *  - \\c \"full16\" or \\c \"default\": use the 16 ANSI colours for both the\n *    characters and the background. This is the default value.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Invalid colour set.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the colour set that will be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_color(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"mono\"))\n    {\n        d->color_name = \"mono\";\n        d->color = COLOR_MODE_MONO;\n    }\n    else if(!strcasecmp(str, \"gray\"))\n    {\n        d->color_name = \"gray\";\n        d->color = COLOR_MODE_GRAY;\n    }\n    else if(!strcasecmp(str, \"8\"))\n    {\n        d->color_name = \"8\";\n        d->color = COLOR_MODE_8;\n    }\n    else if(!strcasecmp(str, \"16\"))\n    {\n        d->color_name = \"16\";\n        d->color = COLOR_MODE_16;\n    }\n    else if(!strcasecmp(str, \"fullgray\"))\n    {\n        d->color_name = \"fullgray\";\n        d->color = COLOR_MODE_FULLGRAY;\n    }\n    else if(!strcasecmp(str, \"full8\"))\n    {\n        d->color_name = \"full8\";\n        d->color = COLOR_MODE_FULL8;\n    }\n    else if(!strcasecmp(str, \"full16\") || !strcasecmp(str, \"default\"))\n    {\n        d->color_name = \"full16\";\n        d->color = COLOR_MODE_FULL16;\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get available colour modes\n *\n *  Return a list of available colour modes for a given dither. The list\n *  is a NULL-terminated array of strings, interleaving a string containing\n *  the internal value for the colour mode, to be used with\n *  caca_set_dither_color(), and a string containing the natural\n *  language description for that colour mode.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const *\n    caca_get_dither_color_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"mono\", \"white on black\",\n        \"gray\", \"grayscale on black\",\n        \"8\", \"8 colours on black\",\n        \"16\", \"16 colours on black\",\n        \"fullgray\", \"full grayscale\",\n        \"full8\", \"full 8 colours\",\n        \"full16\", \"full 16 colours\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current colour mode\n *\n *  Return the given dither's current colour mode.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_color(caca_dither_t const *d)\n{\n    return d->color_name;\n}\n\n/** \\brief Choose characters used for dithering\n *\n *  Tell the renderer which characters should be used to render the\n *  dither. Valid values for \\c str are:\n *  - \\c \"ascii\" or \\c \"default\": use only ASCII characters. This is the\n *    default value.\n *  - \\c \"shades\": use Unicode characters \"U+2591 LIGHT SHADE\", \"U+2592\n *    MEDIUM SHADE\" and \"U+2593 DARK SHADE\". These characters are also\n *    present in the CP437 codepage available on DOS and VGA.\n *  - \\c \"blocks\": use Unicode quarter-cell block combinations. These\n *    characters are only found in the Unicode set.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Invalid character set.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the characters that need to be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_charset(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"shades\"))\n    {\n        d->glyph_name = \"shades\";\n        d->glyphs = shades_glyphs;\n        d->glyph_count = sizeof(shades_glyphs) / sizeof(*shades_glyphs);\n    }\n    else if(!strcasecmp(str, \"blocks\"))\n    {\n        d->glyph_name = \"blocks\";\n        d->glyphs = blocks_glyphs;\n        d->glyph_count = sizeof(blocks_glyphs) / sizeof(*blocks_glyphs);\n    }\n    else if(!strcasecmp(str, \"ascii\") || !strcasecmp(str, \"default\"))\n    {\n        d->glyph_name = \"ascii\";\n        d->glyphs = ascii_glyphs;\n        d->glyph_count = sizeof(ascii_glyphs) / sizeof(*ascii_glyphs);\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get available dither character sets\n *\n *  Return a list of available character sets for a given dither. The list\n *  is a NULL-terminated array of strings, interleaving a string containing\n *  the internal value for the character set, to be used with\n *  caca_set_dither_charset(), and a string containing the natural\n *  language description for that character set.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const * caca_get_dither_charset_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"ascii\", \"plain ASCII\",\n        \"shades\", \"CP437 shades\",\n        \"blocks\", \"Unicode blocks\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current character set\n *\n *  Return the given dither's current character set.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_charset(caca_dither_t const *d)\n{\n    return d->glyph_name;\n}\n\n/** \\brief Set dithering algorithm\n *\n *  Tell the renderer which dithering algorithm should be used. Dithering is\n *  necessary because the picture being rendered has usually far more colours\n *  than the available palette. Valid values for \\c str are:\n *  - \\c \"none\": no dithering is used, the nearest matching colour is used.\n *  - \\c \"ordered2\": use a 2x2 Bayer matrix for dithering.\n *  - \\c \"ordered4\": use a 4x4 Bayer matrix for dithering.\n *  - \\c \"ordered8\": use a 8x8 Bayer matrix for dithering.\n *  - \\c \"random\": use random dithering.\n *  - \\c \"fstein\": use Floyd-Steinberg dithering. This is the default value.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Unknown dithering mode.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the algorithm that needs to be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_algorithm(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"none\"))\n    {\n        d->algo_name = \"none\";\n        d->init_dither = init_no_dither;\n        d->get_dither = get_no_dither;\n        d->increment_dither = increment_no_dither;\n    }\n    else if(!strcasecmp(str, \"ordered2\"))\n    {\n        d->algo_name = \"ordered2\";\n        d->init_dither = init_ordered2_dither;\n        d->get_dither = get_ordered2_dither;\n        d->increment_dither = increment_ordered2_dither;\n    }\n    else if(!strcasecmp(str, \"ordered4\"))\n    {\n        d->algo_name = \"ordered4\";\n        d->init_dither = init_ordered4_dither;\n        d->get_dither = get_ordered4_dither;\n        d->increment_dither = increment_ordered4_dither;\n    }\n    else if(!strcasecmp(str, \"ordered8\"))\n    {\n        d->algo_name = \"ordered8\";\n        d->init_dither = init_ordered8_dither;\n        d->get_dither = get_ordered8_dither;\n        d->increment_dither = increment_ordered8_dither;\n    }\n    else if(!strcasecmp(str, \"random\"))\n    {\n        d->algo_name = \"random\";\n        d->init_dither = init_random_dither;\n        d->get_dither = get_random_dither;\n        d->increment_dither = increment_random_dither;\n    }\n    else if(!strcasecmp(str, \"fstein\") || !strcasecmp(str, \"default\"))\n    {\n        d->algo_name = \"fstein\";\n        d->init_dither = init_fstein_dither;\n        d->get_dither = get_fstein_dither;\n        d->increment_dither = increment_fstein_dither;\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get dithering algorithms\n *\n *  Return a list of available dithering algorithms for a given dither. The\n *  list is a NULL-terminated array of strings, interleaving a string\n *  containing the internal value for the dithering algorithm, to be used\n *  with caca_set_dither_dithering(), and a string containing the natural\n *  language description for that algorithm.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const * caca_get_dither_algorithm_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"none\", \"no dithering\",\n        \"ordered2\", \"2x2 ordered dithering\",\n        \"ordered4\", \"4x4 ordered dithering\",\n        \"ordered8\", \"8x8 ordered dithering\",\n        \"random\", \"random dithering\",\n        \"fstein\", \"Floyd-Steinberg dithering\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current dithering algorithm\n *\n *  Return the given dither's current dithering algorithm.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_algorithm(caca_dither_t const *d)\n{\n    return d->algo_name;\n}\n\n/** \\brief Dither a bitmap on the canvas.\n *\n *  Dither a bitmap at the given coordinates. The dither can be of any size\n *  and will be stretched to the text area.\n *\n *  This function never fails.\n *\n *  \\param cv A handle to the libcaca canvas.\n *  \\param x X coordinate of the upper-left corner of the drawing area.\n *  \\param y Y coordinate of the upper-left corner of the drawing area.\n *  \\param w Width of the drawing area.\n *  \\param h Height of the drawing area.\n *  \\param d Dither object to be drawn.\n *  \\param pixels Bitmap's pixels.\n *  \\return This function always returns 0.\n */\nint caca_dither_bitmap(caca_canvas_t *cv, int x, int y, int w, int h,\n                        caca_dither_t const *d, void const *pixels)\n{\n    int *floyd_steinberg, *fs_r, *fs_g, *fs_b;\n    uint32_t savedattr;\n    int fs_length;\n    int x1, y1, x2, y2, pitch, deltax, deltay, dchmax;\n\n    if(!d || !pixels)\n        return 0;\n\n    savedattr = caca_get_attr(cv, -1, -1);\n\n    x1 = x; x2 = x + w - 1;\n    y1 = y; y2 = y + h - 1;\n\n    /* FIXME: do not overwrite arguments */\n    w = d->w;\n    h = d->h;\n    pitch = d->pitch;\n\n    deltax = x2 - x1 + 1;\n    deltay = y2 - y1 + 1;\n    dchmax = d->glyph_count;\n\n    fs_length = ((int)cv->width <= x2 ? (int)cv->width : x2) + 1;\n    floyd_steinberg = malloc(3 * (fs_length + 2) * sizeof(int));\n    memset(floyd_steinberg, 0, 3 * (fs_length + 2) * sizeof(int));\n    fs_r = floyd_steinberg + 1;\n    fs_g = fs_r + fs_length + 2;\n    fs_b = fs_g + fs_length + 2;\n\n    for(y = y1 > 0 ? y1 : 0; y <= y2 && y <= (int)cv->height; y++)\n    {\n        int remain_r = 0, remain_g = 0, remain_b = 0;\n\n        for(x = x1 > 0 ? x1 : 0, d->init_dither(y);\n            x <= x2 && x <= (int)cv->width;\n            x++)\n    {\n        unsigned int rgba[4];\n        int error[3];\n        int i, ch = 0, distmin;\n        int fg_r = 0, fg_g = 0, fg_b = 0, bg_r, bg_g, bg_b;\n        int fromx, fromy, tox, toy, myx, myy, dots, dist;\n\n        int outfg = 0, outbg = 0;\n        uint32_t outch;\n\n        rgba[0] = rgba[1] = rgba[2] = rgba[3] = 0;\n\n        /* First get RGB */\n        if(d->antialias)\n        {\n            fromx = (uint64_t)(x - x1) * w / deltax;\n            fromy = (uint64_t)(y - y1) * h / deltay;\n            tox = (uint64_t)(x - x1 + 1) * w / deltax;\n            toy = (uint64_t)(y - y1 + 1) * h / deltay;\n\n            /* We want at least one pixel */\n            if(tox == fromx) tox++;\n            if(toy == fromy) toy++;\n\n            dots = 0;\n\n            for(myx = fromx; myx < tox; myx++)\n                for(myy = fromy; myy < toy; myy++)\n            {\n                dots++;\n                get_rgba_default(d, pixels, myx, myy, rgba);\n            }\n\n            /* Normalize */\n            rgba[0] /= dots;\n            rgba[1] /= dots;\n            rgba[2] /= dots;\n            rgba[3] /= dots;\n        }\n        else\n        {\n            fromx = (uint64_t)(x - x1) * w / deltax;\n            fromy = (uint64_t)(y - y1) * h / deltay;\n            tox = (uint64_t)(x - x1 + 1) * w / deltax;\n            toy = (uint64_t)(y - y1 + 1) * h / deltay;\n\n            /* tox and toy can overflow the canvas, but they cannot overflow\n             * when averaged with fromx and fromy because these are guaranteed\n             * to be within the pixel boundaries. */\n            myx = (fromx + tox) / 2;\n            myy = (fromy + toy) / 2;\n\n            get_rgba_default(d, pixels, myx, myy, rgba);\n        }\n\n        /* FIXME: hack to force greyscale */\n        if(d->color == COLOR_MODE_FULLGRAY)\n        {\n            unsigned int gray = (3 * rgba[0] + 4 * rgba[1] + rgba[2] + 4) / 8;\n            rgba[0] = rgba[1] = rgba[2] = gray;\n        }\n\n        if(d->has_alpha && rgba[3] < 0x800)\n        {\n            remain_r = remain_g = remain_b = 0;\n            fs_r[x] = 0;\n            fs_g[x] = 0;\n            fs_b[x] = 0;\n            continue;\n        }\n\n        /* XXX: OMG HAX */\n        if(d->init_dither == init_fstein_dither)\n        {\n            rgba[0] += remain_r;\n            rgba[1] += remain_g;\n            rgba[2] += remain_b;\n        }\n        else\n        {\n            rgba[0] += (d->get_dither() - 0x80) * 4;\n            rgba[1] += (d->get_dither() - 0x80) * 4;\n            rgba[2] += (d->get_dither() - 0x80) * 4;\n        }\n\n        distmin = INT_MAX;\n        for(i = 0; i < 16; i++)\n        {\n            if(d->color == COLOR_MODE_FULLGRAY\n                && (rgb_palette[i * 3] != rgb_palette[i * 3 + 1]\n                     || rgb_palette[i * 3] != rgb_palette[i * 3 + 2]))\n                continue;\n            dist = sq(rgba[0] - rgb_palette[i * 3])\n                 + sq(rgba[1] - rgb_palette[i * 3 + 1])\n                 + sq(rgba[2] - rgb_palette[i * 3 + 2]);\n            dist *= rgb_weight[i];\n            if(dist < distmin)\n            {\n                outbg = i;\n                distmin = dist;\n            }\n        }\n        bg_r = rgb_palette[outbg * 3];\n        bg_g = rgb_palette[outbg * 3 + 1];\n        bg_b = rgb_palette[outbg * 3 + 2];\n\n        /* FIXME: we currently only honour \"full16\" */\n        if(d->color == COLOR_MODE_FULL16 || d->color == COLOR_MODE_FULLGRAY)\n        {\n            distmin = INT_MAX;\n            for(i = 0; i < 16; i++)\n            {\n                if(i == outbg)\n                    continue;\n                if(d->color == COLOR_MODE_FULLGRAY\n                    && (rgb_palette[i * 3] != rgb_palette[i * 3 + 1]\n                         || rgb_palette[i * 3] != rgb_palette[i * 3 + 2]))\n                    continue;\n                dist = sq(rgba[0] - rgb_palette[i * 3])\n                     + sq(rgba[1] - rgb_palette[i * 3 + 1])\n                     + sq(rgba[2] - rgb_palette[i * 3 + 2]);\n                dist *= rgb_weight[i];\n                if(dist < distmin)\n                {\n                    outfg = i;\n                    distmin = dist;\n                }\n            }\n            fg_r = rgb_palette[outfg * 3];\n            fg_g = rgb_palette[outfg * 3 + 1];\n            fg_b = rgb_palette[outfg * 3 + 2];\n\n            distmin = INT_MAX;\n            for(i = 0; i < dchmax - 1; i++)\n            {\n                int newr = i * fg_r + ((2*dchmax-1) - i) * bg_r;\n                int newg = i * fg_g + ((2*dchmax-1) - i) * bg_g;\n                int newb = i * fg_b + ((2*dchmax-1) - i) * bg_b;\n                dist = abs(rgba[0] * (2*dchmax-1) - newr)\n                     + abs(rgba[1] * (2*dchmax-1) - newg)\n                     + abs(rgba[2] * (2*dchmax-1) - newb);\n\n                if(dist < distmin)\n                {\n                    ch = i;\n                    distmin = dist;\n                }\n            }\n            outch = d->glyphs[ch];\n\n            /* XXX: OMG HAX */\n            if(d->init_dither == init_fstein_dither)\n            {\n                error[0] = rgba[0] - (fg_r * ch + bg_r * ((2*dchmax-1) - ch)) / (2*dchmax-1);\n                error[1] = rgba[1] - (fg_g * ch + bg_g * ((2*dchmax-1) - ch)) / (2*dchmax-1);\n                error[2] = rgba[2] - (fg_b * ch + bg_b * ((2*dchmax-1) - ch)) / (2*dchmax-1);\n            }\n        }\n        else\n        {\n            unsigned int lum = rgba[0];\n            if(rgba[1] > lum) lum = rgba[1];\n            if(rgba[2] > lum) lum = rgba[2];\n            outfg = outbg;\n            outbg = CACA_BLACK;\n\n            ch = lum * dchmax / 0x1000;\n            if(ch < 0)\n                ch = 0;\n            else if(ch > (int)(dchmax - 1))\n                ch = dchmax - 1;\n            outch = d->glyphs[ch];\n\n            /* XXX: OMG HAX */\n            if(d->init_dither == init_fstein_dither)\n            {\n                error[0] = rgba[0] - bg_r * ch / (dchmax-1);\n                error[1] = rgba[1] - bg_g * ch / (dchmax-1);\n                error[2] = rgba[2] - bg_b * ch / (dchmax-1);\n            }\n        }\n\n        /* XXX: OMG HAX */\n        if(d->init_dither == init_fstein_dither)\n        {\n            remain_r = fs_r[x+1] + 7 * error[0] / 16;\n            remain_g = fs_g[x+1] + 7 * error[1] / 16;\n            remain_b = fs_b[x+1] + 7 * error[2] / 16;\n            fs_r[x-1] += 3 * error[0] / 16;\n            fs_g[x-1] += 3 * error[1] / 16;\n            fs_b[x-1] += 3 * error[2] / 16;\n            fs_r[x] = 5 * error[0] / 16;\n            fs_g[x] = 5 * error[1] / 16;\n            fs_b[x] = 5 * error[2] / 16;\n            fs_r[x+1] = 1 * error[0] / 16;\n            fs_g[x+1] = 1 * error[1] / 16;\n            fs_b[x+1] = 1 * error[2] / 16;\n        }\n\n        if(d->invert)\n        {\n            outfg = 15 - outfg;\n            outbg = 15 - outbg;\n        }\n\n        /* Now output the character */\n        caca_set_color_ansi(cv, outfg, outbg);\n        caca_put_char(cv, x, y, outch);\n\n        d->increment_dither();\n    }\n        /* end loop */\n    }\n\n    free(floyd_steinberg);\n\n    caca_set_attr(cv, savedattr);\n\n    return 0;\n}\n\n/** \\brief Free the memory associated with a dither.\n *\n *  Free the memory allocated by caca_create_dither().\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return This function always returns 0.\n */\nint caca_free_dither(caca_dither_t *d)\n{\n    if(!d)\n        return 0;\n\n    free(d);\n\n    return 0;\n}\n\n/*\n * XXX: The following functions are local.\n */\n\n/* Convert a mask, eg. 0x0000ff00, to shift values, eg. 8 and -4. */\nstatic void mask2shift(uint32_t mask, int *right, int *left)\n{\n    int rshift = 0, lshift = 0;\n\n    if(!mask)\n    {\n        *right = *left = 0;\n        return;\n    }\n\n    while(!(mask & 1))\n    {\n        mask >>= 1;\n        rshift++;\n    }\n    *right = rshift;\n\n    while(mask & 1)\n    {\n        mask >>= 1;\n        lshift++;\n    }\n    *left = 12 - lshift;\n}\n\n/* Compute x^y without relying on the math library */\nstatic float gammapow(float x, float y)\n{\n#ifdef HAVE_FLDLN2\n    register double logx;\n    register long double v, e;\n#else\n    register float tmp, t, t2, r;\n    int i;\n#endif\n\n    if(x == 0.0)\n        return y == 0.0 ? 1.0 : 0.0;\n\n#ifdef HAVE_FLDLN2\n    /* FIXME: this can be optimised by directly calling fyl2x for x and y */\n    asm volatile(\"fldln2; fxch; fyl2x\"\n                 : \"=t\" (logx) : \"0\" (x) : \"st(1)\");\n\n    asm volatile(\"fldl2e\\n\\t\"\n                 \"fmul %%st(1)\\n\\t\"\n                 \"fst %%st(1)\\n\\t\"\n                 \"frndint\\n\\t\"\n                 \"fxch\\n\\t\"\n                 \"fsub %%st(1)\\n\\t\"\n                 \"f2xm1\\n\\t\"\n                 : \"=t\" (v), \"=u\" (e) : \"0\" (y * logx));\n    v += 1.0;\n    asm volatile(\"fscale\"\n                 : \"=t\" (v) : \"0\" (v), \"u\" (e));\n    return v;\n#else\n    /* Compute ln(x) for x \u2208 ]0,1]\n     *   ln(x) = 2 * (t + t^3/3 + t^5/5 + ...) with t = (x-1)/(x+1)\n     * The convergence is a bit slow, especially when x is near 0. */\n    t = (x - 1.0) / (x + 1.0);\n    t2 = t * t;\n    tmp = r = t;\n    for(i = 3; i < 20; i += 2)\n    {\n        r *= t2;\n        tmp += r / i;\n    }\n\n    /* Compute -y*ln(x) */\n    tmp = - y * 2.0 * tmp;\n\n    /* Compute x^-y as e^t where t = -y*ln(x):\n     *   e^t = 1 + t/1! + t^2/2! + t^3/3! + t^4/4! + t^5/5! ...\n     * The convergence is quite faster here, thanks to the factorial. */\n    r = t = tmp;\n    tmp = 1.0 + t;\n    for(i = 2; i < 16; i++)\n    {\n        r = r * t / i;\n        tmp += r;\n    }\n\n    /* Return x^y as 1/(x^-y) */\n    return 1.0 / tmp;\n#endif\n}\n\nstatic void get_rgba_default(caca_dither_t const *d, uint8_t const *pixels,\n                             int x, int y, unsigned int *rgba)\n{\n    uint32_t bits;\n\n    pixels += (d->bpp / 8) * x + d->pitch * y;\n\n    switch(d->bpp / 8)\n    {\n        case 4:\n            bits = *(uint32_t const *)pixels;\n            break;\n        case 3:\n        {\n#if defined(HAVE_ENDIAN_H)\n            if(__BYTE_ORDER == __BIG_ENDIAN)\n#else\n            /* This is compile-time optimised with at least -O1 or -Os */\n            uint32_t const tmp = 0x12345678;\n            if(*(uint8_t const *)&tmp == 0x12)\n#endif\n                bits = ((uint32_t)pixels[0] << 16) |\n                       ((uint32_t)pixels[1] << 8) |\n                       ((uint32_t)pixels[2]);\n            else\n                bits = ((uint32_t)pixels[2] << 16) |\n                       ((uint32_t)pixels[1] << 8) |\n                       ((uint32_t)pixels[0]);\n            break;\n        }\n        case 2:\n            bits = *(uint16_t const *)pixels;\n            break;\n        case 1:\n        default:\n            bits = pixels[0];\n            break;\n    }\n\n    if(d->has_palette)\n    {\n        rgba[0] += d->gammatab[d->red[bits]];\n        rgba[1] += d->gammatab[d->green[bits]];\n        rgba[2] += d->gammatab[d->blue[bits]];\n        rgba[3] += d->alpha[bits];\n    }\n    else\n    {\n        rgba[0] += d->gammatab[((bits & d->rmask) >> d->rright) << d->rleft];\n        rgba[1] += d->gammatab[((bits & d->gmask) >> d->gright) << d->gleft];\n        rgba[2] += d->gammatab[((bits & d->bmask) >> d->bright) << d->bleft];\n        rgba[3] += ((bits & d->amask) >> d->aright) << d->aleft;\n    }\n}\n\n/*\n * No dithering\n */\nstatic void init_no_dither(int line)\n{\n    ;\n}\n\nstatic int get_no_dither(void)\n{\n    return 0x80;\n}\n\nstatic void increment_no_dither(void)\n{\n    return;\n}\n\n/*\n * Floyd-Steinberg dithering\n */\nstatic void init_fstein_dither(int line)\n{\n    ;\n}\n\nstatic int get_fstein_dither(void)\n{\n    return 0x80;\n}\n\nstatic void increment_fstein_dither(void)\n{\n    return;\n}\n\n/*\n * Ordered 2 dithering\n */\nstatic int const *ordered2_table;\nstatic int ordered2_index;\n\nstatic void init_ordered2_dither(int line)\n{\n    static int const dither2x2[] =\n    {\n        0x00, 0x80,\n        0xc0, 0x40,\n    };\n\n    ordered2_table = dither2x2 + (line % 2) * 2;\n    ordered2_index = 0;\n}\n\nstatic int get_ordered2_dither(void)\n{\n    return ordered2_table[ordered2_index];\n}\n\nstatic void increment_ordered2_dither(void)\n{\n    ordered2_index = (ordered2_index + 1) % 2;\n}\n\n/*\n * Ordered 4 dithering\n */\n/*static int dither4x4[] = { 5,  0,  1,  6,\n                          -1, -6, -5,  2,\n                          -2, -7, -8,  3,\n                           4, -3, -4, -7};*/\nstatic int const *ordered4_table;\nstatic int ordered4_index;\n\nstatic void init_ordered4_dither(int line)\n{\n    static int const dither4x4[] =\n    {\n        0x00, 0x80, 0x20, 0xa0,\n        0xc0, 0x40, 0xe0, 0x60,\n        0x30, 0xb0, 0x10, 0x90,\n        0xf0, 0x70, 0xd0, 0x50\n    };\n\n    ordered4_table = dither4x4 + (line % 4) * 4;\n    ordered4_index = 0;\n}\n\nstatic int get_ordered4_dither(void)\n{\n    return ordered4_table[ordered4_index];\n}\n\nstatic void increment_ordered4_dither(void)\n{\n    ordered4_index = (ordered4_index + 1) % 4;\n}\n\n/*\n * Ordered 8 dithering\n */\nstatic int const *ordered8_table;\nstatic int ordered8_index;\n\nstatic void init_ordered8_dither(int line)\n{\n    static int const dither8x8[] =\n    {\n        0x00, 0x80, 0x20, 0xa0, 0x08, 0x88, 0x28, 0xa8,\n        0xc0, 0x40, 0xe0, 0x60, 0xc8, 0x48, 0xe8, 0x68,\n        0x30, 0xb0, 0x10, 0x90, 0x38, 0xb8, 0x18, 0x98,\n        0xf0, 0x70, 0xd0, 0x50, 0xf8, 0x78, 0xd8, 0x58,\n        0x0c, 0x8c, 0x2c, 0xac, 0x04, 0x84, 0x24, 0xa4,\n        0xcc, 0x4c, 0xec, 0x6c, 0xc4, 0x44, 0xe4, 0x64,\n        0x3c, 0xbc, 0x1c, 0x9c, 0x34, 0xb4, 0x14, 0x94,\n        0xfc, 0x7c, 0xdc, 0x5c, 0xf4, 0x74, 0xd4, 0x54,\n    };\n\n    ordered8_table = dither8x8 + (line % 8) * 8;\n    ordered8_index = 0;\n}\n\nstatic int get_ordered8_dither(void)\n{\n    return ordered8_table[ordered8_index];\n}\n\nstatic void increment_ordered8_dither(void)\n{\n    ordered8_index = (ordered8_index + 1) % 8;\n}\n\n/*\n * Random dithering\n */\nstatic void init_random_dither(int line)\n{\n    ;\n}\n\nstatic int get_random_dither(void)\n{\n    return caca_rand(0x00, 0x100);\n}\n\nstatic void increment_random_dither(void)\n{\n    return;\n}\n\n/*\n * Lookup tables\n */\nstatic int init_lookup(void)\n{\n    int v, s, h;\n\n    /* These ones are constant */\n    lookup_colors[0] = CACA_BLACK;\n    lookup_colors[1] = CACA_DARKGRAY;\n    lookup_colors[2] = CACA_LIGHTGRAY;\n    lookup_colors[3] = CACA_WHITE;\n\n    /* These ones will be overwritten */\n    lookup_colors[4] = CACA_MAGENTA;\n    lookup_colors[5] = CACA_LIGHTMAGENTA;\n    lookup_colors[6] = CACA_RED;\n    lookup_colors[7] = CACA_LIGHTRED;\n\n    for(v = 0; v < LOOKUP_VAL; v++)\n        for(s = 0; s < LOOKUP_SAT; s++)\n            for(h = 0; h < LOOKUP_HUE; h++)\n    {\n        int i, distbg, distfg, dist;\n        int val, sat, hue;\n        uint8_t outbg, outfg;\n\n        val = 0xfff * v / (LOOKUP_VAL - 1);\n        sat = 0xfff * s / (LOOKUP_SAT - 1);\n        hue = 0xfff * h / (LOOKUP_HUE - 1);\n\n        /* Initialise distances to the distance between pure black HSV\n         * coordinates and our white colour (3) */\n        outbg = outfg = 3;\n        distbg = distfg = HSV_DISTANCE(0, 0, 0, 3);\n\n        /* Calculate distances to eight major colour values and store the\n         * two nearest points in our lookup table. */\n        for(i = 0; i < 8; i++)\n        {\n            dist = HSV_DISTANCE(hue, sat, val, i);\n            if(dist <= distbg)\n            {\n                outfg = outbg;\n                distfg = distbg;\n                outbg = i;\n                distbg = dist;\n            }\n            else if(dist <= distfg)\n            {\n                outfg = i;\n                distfg = dist;\n            }\n        }\n\n        hsv_distances[v][s][h] = (outfg << 4) | outbg;\n    }\n\n    return 0;\n}\n\n"], "fixing_code": ["/*\n *  libcaca     Colour ASCII-Art library\n *  Copyright \u00a9 2002\u20142018 Sam Hocevar <sam@hocevar.net>\n *              All Rights Reserved\n *\n *  This library is free software. It comes without any warranty, to\n *  the extent permitted by applicable law. You can redistribute it\n *  and/or modify it under the terms of the Do What the Fuck You Want\n *  to Public License, Version 2, as published by the WTFPL Task Force.\n *  See http://www.wtfpl.net/ for more details.\n */\n\n/*\n *  This file contains bitmap dithering functions.\n */\n\n#include \"config.h\"\n\n#if !defined(__KERNEL__)\n#   if defined(HAVE_ENDIAN_H)\n#       include <endian.h>\n#   endif\n#   include <stdio.h>\n#   include <stdlib.h>\n#   include <limits.h>\n#   include <string.h>\n#endif\n\n#include \"caca.h\"\n#include \"caca_internals.h\"\n\n#define CP437 0\n\n/*\n * Local variables\n */\n#if !defined(_DOXYGEN_SKIP_ME)\n#   define LOOKUP_VAL 32\n#   define LOOKUP_SAT 32\n#   define LOOKUP_HUE 16\n#endif\nstatic uint8_t hsv_distances[LOOKUP_VAL][LOOKUP_SAT][LOOKUP_HUE];\nstatic uint16_t lookup_colors[8];\nstatic int lookup_initialised = 0;\n\nstatic int const hsv_palette[] =\n{\n    /* weight, hue, saturation, value */\n    4,    0x0,    0x0,    0x0,   /* black */\n    5,    0x0,    0x0,    0x5ff, /* 30% */\n    5,    0x0,    0x0,    0x9ff, /* 70% */\n    4,    0x0,    0x0,    0xfff, /* white */\n    3,    0x1000, 0xfff,  0x5ff, /* dark yellow */\n    2,    0x1000, 0xfff,  0xfff, /* light yellow */\n    3,    0x0,    0xfff,  0x5ff, /* dark red */\n    2,    0x0,    0xfff,  0xfff  /* light red */\n};\n\n/* RGB palette for the new colour picker */\nstatic int const rgb_palette[] =\n{\n    0x0,   0x0,   0x0,\n    0x0,   0x0,   0x7ff,\n    0x0,   0x7ff, 0x0,\n    0x0,   0x7ff, 0x7ff,\n    0x7ff, 0x0,   0x0,\n    0x7ff, 0x0,   0x7ff,\n    0x7ff, 0x7ff, 0x0,\n    0xaaa, 0xaaa, 0xaaa,\n    0x555, 0x555, 0x555,\n    0x000, 0x000, 0xfff,\n    0x000, 0xfff, 0x000,\n    0x000, 0xfff, 0xfff,\n    0xfff, 0x000, 0x000,\n    0xfff, 0x000, 0xfff,\n    0xfff, 0xfff, 0x000,\n    0xfff, 0xfff, 0xfff,\n};\n\nstatic int const rgb_weight[] =\n{\n    /* 2, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 2 */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n};\n\n/* List of glyphs */\nstatic uint32_t ascii_glyphs[] =\n{\n    ' ', '.', ':', ';', 't', '%', 'S', 'X', '@', '8', '?'\n};\n\nstatic uint32_t shades_glyphs[] =\n{\n    /* ' '. '\u00b7', '\u2591', '\u2592', '?' */\n    ' ', 0xb7, 0x2591, 0x2592, '?'\n};\n\nstatic uint32_t blocks_glyphs[] =\n{\n    /* ' ', '\u2598', '\u259a', '?' */\n    ' ', 0x2598, 0x259a, '?'\n};\n\n#if !defined(_DOXYGEN_SKIP_ME)\nenum color_mode\n{\n    COLOR_MODE_MONO,\n    COLOR_MODE_GRAY,\n    COLOR_MODE_8,\n    COLOR_MODE_16,\n    COLOR_MODE_FULLGRAY,\n    COLOR_MODE_FULL8,\n    COLOR_MODE_FULL16\n};\n\nstruct caca_dither\n{\n    int bpp, has_palette, has_alpha;\n    size_t w, h, pitch;\n    int rmask, gmask, bmask, amask;\n    int rright, gright, bright, aright;\n    int rleft, gleft, bleft, aleft;\n    void (*get_hsv)(caca_dither_t *, char *, int, int);\n    int red[256], green[256], blue[256], alpha[256];\n\n    /* Colour features */\n    float gamma, brightness, contrast;\n    int gammatab[4097];\n\n    /* Dithering features */\n    char const *antialias_name;\n    int antialias;\n\n    char const *color_name;\n    enum color_mode color;\n\n    char const *algo_name;\n    void (*init_dither) (int);\n    int (*get_dither) (void);\n    void (*increment_dither) (void);\n\n    char const *glyph_name;\n    uint32_t const * glyphs;\n    int glyph_count;\n\n    int invert;\n};\n\n#define HSV_XRATIO 6\n#define HSV_YRATIO 3\n#define HSV_HRATIO 3\n\n#define HSV_DISTANCE(h, s, v, index) \\\n    (hsv_palette[index * 4] \\\n     * ((HSV_XRATIO * ((v) - hsv_palette[index * 4 + 3]) \\\n                    * ((v) - hsv_palette[index * 4 + 3])) \\\n       + (hsv_palette[index * 4 + 3] \\\n           ? (HSV_YRATIO * ((s) - hsv_palette[index * 4 + 2]) \\\n                         * ((s) - hsv_palette[index * 4 + 2])) \\\n           : 0) \\\n       + (hsv_palette[index * 4 + 2] \\\n           ? (HSV_HRATIO * ((h) - hsv_palette[index * 4 + 1]) \\\n                         * ((h) - hsv_palette[index * 4 + 1])) \\\n           : 0)))\n#endif\n\n/*\n * Local prototypes\n */\nstatic void mask2shift(uint32_t, int *, int *);\nstatic float gammapow(float x, float y);\n\nstatic void get_rgba_default(caca_dither_t const *, uint8_t const *, int, int,\n                             unsigned int *);\nstatic int init_lookup(void);\n\n/* Dithering algorithms */\nstatic void init_no_dither(int);\nstatic int get_no_dither(void);\nstatic void increment_no_dither(void);\n\nstatic void init_fstein_dither(int);\nstatic int get_fstein_dither(void);\nstatic void increment_fstein_dither(void);\n\nstatic void init_ordered2_dither(int);\nstatic int get_ordered2_dither(void);\nstatic void increment_ordered2_dither(void);\n\nstatic void init_ordered4_dither(int);\nstatic int get_ordered4_dither(void);\nstatic void increment_ordered4_dither(void);\n\nstatic void init_ordered8_dither(int);\nstatic int get_ordered8_dither(void);\nstatic void increment_ordered8_dither(void);\n\nstatic void init_random_dither(int);\nstatic int get_random_dither(void);\nstatic void increment_random_dither(void);\n\nstatic inline int sq(int x)\n{\n    return x * x;\n}\n\nstatic inline void rgb2hsv_default(int r, int g, int b,\n                                   int *hue, int *sat, int *val)\n{\n    int min, max, delta;\n\n    min = r; max = r;\n    if(min > g) min = g; if(max < g) max = g;\n    if(min > b) min = b; if(max < b) max = b;\n\n    delta = max - min; /* 0 - 0xfff */\n    *val = max; /* 0 - 0xfff */\n\n    if(delta)\n    {\n        *sat = 0xfff * delta / max; /* 0 - 0xfff */\n\n        /* Generate *hue between 0 and 0x5fff */\n        if( r == max )\n            *hue = 0x1000 + 0x1000 * (g - b) / delta;\n        else if( g == max )\n            *hue = 0x3000 + 0x1000 * (b - r) / delta;\n        else\n            *hue = 0x5000 + 0x1000 * (r - g) / delta;\n    }\n    else\n    {\n        *sat = 0;\n        *hue = 0;\n    }\n}\n\n/** \\brief Create an internal dither object.\n *\n *  Create a dither structure from its coordinates (depth, width, height and\n *  pitch) and pixel mask values. If the depth is 8 bits per pixel, the mask\n *  values are ignored and the colour palette should be set using the\n *  caca_set_dither_palette() function. For depths greater than 8 bits per\n *  pixel, a zero alpha mask causes the alpha values to be ignored.\n *\n *  If an error occurs, NULL is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Requested width, height, pitch or bits per pixel value was\n *    invalid.\n *  - \\c ENOMEM Not enough memory to allocate dither structure.\n *\n *  \\param bpp Bitmap depth in bits per pixel.\n *  \\param w Bitmap width in pixels.\n *  \\param h Bitmap height in pixels.\n *  \\param pitch Bitmap pitch in bytes.\n *  \\param rmask Bitmask for red values.\n *  \\param gmask Bitmask for green values.\n *  \\param bmask Bitmask for blue values.\n *  \\param amask Bitmask for alpha values.\n *  \\return Dither object upon success, NULL if an error occurred.\n */\ncaca_dither_t *caca_create_dither(int bpp, int w, int h, int pitch,\n                                    uint32_t rmask, uint32_t gmask,\n                                    uint32_t bmask, uint32_t amask)\n{\n    caca_dither_t *d;\n    int i;\n\n    /* Minor sanity test */\n    if(w < 0 || h < 0 || pitch < 0 || bpp > 32 || bpp < 8)\n    {\n        seterrno(EINVAL);\n        return NULL;\n    }\n\n    d = malloc(sizeof(caca_dither_t));\n    if(!d)\n    {\n        seterrno(ENOMEM);\n        return NULL;\n    }\n\n    if(!lookup_initialised)\n    {\n        /* XXX: because we do not wish to be thread-safe, there is a slight\n         * chance that the following code will be executed twice. It is\n         * totally harmless. */\n        init_lookup();\n        lookup_initialised = 1;\n    }\n\n    d->bpp = bpp;\n    d->has_palette = 0;\n    d->has_alpha = amask ? 1 : 0;\n\n    d->w = w;\n    d->h = h;\n    d->pitch = pitch;\n\n    d->rmask = rmask;\n    d->gmask = gmask;\n    d->bmask = bmask;\n    d->amask = amask;\n\n    /* Load bitmasks */\n    if(rmask || gmask || bmask || amask)\n    {\n        mask2shift(rmask, &d->rright, &d->rleft);\n        mask2shift(gmask, &d->gright, &d->gleft);\n        mask2shift(bmask, &d->bright, &d->bleft);\n        mask2shift(amask, &d->aright, &d->aleft);\n    }\n\n    /* In 8 bpp mode, default to a grayscale palette */\n    if(bpp == 8)\n    {\n        d->has_palette = 1;\n        d->has_alpha = 0;\n        for(i = 0; i < 256; i++)\n        {\n            d->red[i] = i * 0xfff / 256;\n            d->green[i] = i * 0xfff / 256;\n            d->blue[i] = i * 0xfff / 256;\n        }\n    }\n\n    /* Default gamma value */\n    d->gamma = 1.0;\n    for(i = 0; i < 4096; i++)\n        d->gammatab[i] = i;\n\n    /* Default colour properties */\n    d->brightness = 1.0;\n    d->contrast = 1.0;\n\n    /* Default features */\n    d->antialias_name = \"prefilter\";\n    d->antialias = 1;\n\n    d->color_name = \"full16\";\n    d->color = COLOR_MODE_FULL16;\n\n    d->glyph_name = \"ascii\";\n    d->glyphs = ascii_glyphs;\n    d->glyph_count = sizeof(ascii_glyphs) / sizeof(*ascii_glyphs);\n\n    d->algo_name = \"fstein\";\n    d->init_dither = init_fstein_dither;\n    d->get_dither = get_fstein_dither;\n    d->increment_dither = increment_fstein_dither;\n\n    d->invert = 0;\n\n    return d;\n}\n\n/** \\brief Set the palette of an 8bpp dither object.\n *\n *  Set the palette of an 8 bits per pixel bitmap. Values should be between\n *  0 and 4095 (0xfff).\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Dither bits per pixel value is not 8, or one of the pixel\n *   values was outside the range 0 - 4095.\n *\n *  \\param d Dither object.\n *  \\param red Array of 256 red values.\n *  \\param green Array of 256 green values.\n *  \\param blue Array of 256 blue values.\n *  \\param alpha Array of 256 alpha values.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_palette(caca_dither_t *d,\n                             uint32_t red[], uint32_t green[],\n                             uint32_t blue[], uint32_t alpha[])\n{\n    int i, has_alpha = 0;\n\n    if(d->bpp != 8)\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    for(i = 0; i < 256; i++)\n    {\n        if((red[i] | green[i] | blue[i] | alpha[i]) >= 0x1000)\n        {\n            seterrno(EINVAL);\n            return -1;\n        }\n    }\n\n    for(i = 0; i < 256; i++)\n    {\n        d->red[i] = red[i];\n        d->green[i] = green[i];\n        d->blue[i] = blue[i];\n        if(alpha[i])\n        {\n            d->alpha[i] = alpha[i];\n            has_alpha = 1;\n        }\n    }\n\n    d->has_alpha = has_alpha;\n\n    return 0;\n}\n\n/** \\brief Set the brightness of a dither object.\n *\n *  Set the brightness of dither.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Brightness value was out of range.\n *\n *  \\param d Dither object.\n *  \\param brightness brightness value.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_brightness(caca_dither_t *d, float brightness)\n{\n    /* FIXME */\n    d->brightness = brightness;\n\n    return 0;\n}\n\n/** \\brief Get the brightness of a dither object.\n *\n *  Get the brightness of the given dither object.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return Brightness value.\n */\nfloat caca_get_dither_brightness(caca_dither_t const *d)\n{\n    return d->brightness;\n}\n\n/** \\brief Set the gamma of a dither object.\n *\n *  Set the gamma of the given dither object. A negative value causes\n *  colour inversion.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Gamma value was out of range.\n *\n *  \\param d Dither object.\n *  \\param gamma Gamma value.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_gamma(caca_dither_t *d, float gamma)\n{\n    /* FIXME: we don't need 4096 calls to gammapow(), we could just compute\n     * a few of them and do linear interpolation for the rest. This will\n     * probably speed up things a lot. */\n    int i;\n\n    if(gamma < 0.0)\n    {\n        d->invert = 1;\n        gamma = -gamma;\n    }\n    else if(gamma == 0.0)\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    d->gamma = gamma;\n\n    for(i = 0; i < 4096; i++)\n        d->gammatab[i] = 4096.0 * gammapow((float)i / 4096.0, 1.0 / gamma);\n\n    return 0;\n}\n\n/** \\brief Get the gamma of a dither object.\n *\n *  Get the gamma of the given dither object.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return Gamma value.\n */\nfloat caca_get_dither_gamma(caca_dither_t const *d)\n{\n    return d->gamma;\n}\n\n/** \\brief Set the contrast of a dither object.\n *\n *  Set the contrast of dither.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Contrast value was out of range.\n *\n *  \\param d Dither object.\n *  \\param contrast contrast value.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_contrast(caca_dither_t *d, float contrast)\n{\n    /* FIXME */\n    d->contrast = contrast;\n\n    return 0;\n}\n\n/** \\brief Get the contrast of a dither object.\n *\n *  Get the contrast of the given dither object.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return Contrast value.\n */\nfloat caca_get_dither_contrast(caca_dither_t const *d)\n{\n    return d->contrast;\n}\n\n/** \\brief Set dither antialiasing\n *\n *  Tell the renderer whether to antialias the dither. Antialiasing smoothens\n *  the rendered image and avoids the commonly seen staircase effect.\n *  - \\c \"none\": no antialiasing.\n *  - \\c \"prefilter\" or \\c \"default\": simple prefilter antialiasing. This\n *    is the default value.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Invalid antialiasing mode.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the antialiasing method that will be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_antialias(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"none\"))\n    {\n        d->antialias_name = \"none\";\n        d->antialias = 0;\n    }\n    else if(!strcasecmp(str, \"prefilter\") || !strcasecmp(str, \"default\"))\n    {\n        d->antialias_name = \"prefilter\";\n        d->antialias = 1;\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get available antialiasing methods\n *\n *  Return a list of available antialiasing methods for a given dither. The\n *  list is a NULL-terminated array of strings, interleaving a string\n *  containing the internal value for the antialiasing method to be used with\n *  caca_set_dither_antialias(), and a string containing the natural\n *  language description for that antialiasing method.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const *\n    caca_get_dither_antialias_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"none\", \"No antialiasing\",\n        \"prefilter\", \"Prefilter antialiasing\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current antialiasing method\n *\n *  Return the given dither's current antialiasing method.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_antialias(caca_dither_t const *d)\n{\n    return d->antialias_name;\n}\n\n/** \\brief Choose colours used for dithering\n *\n *  Tell the renderer which colours should be used to render the\n *  bitmap. Valid values for \\c str are:\n *  - \\c \"mono\": use light gray on a black background.\n *  - \\c \"gray\": use white and two shades of gray on a black background.\n *  - \\c \"8\": use the 8 ANSI colours on a black background.\n *  - \\c \"16\": use the 16 ANSI colours on a black background.\n *  - \\c \"fullgray\": use black, white and two shades of gray for both the\n *    characters and the background.\n *  - \\c \"full8\": use the 8 ANSI colours for both the characters and the\n *    background.\n *  - \\c \"full16\" or \\c \"default\": use the 16 ANSI colours for both the\n *    characters and the background. This is the default value.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Invalid colour set.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the colour set that will be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_color(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"mono\"))\n    {\n        d->color_name = \"mono\";\n        d->color = COLOR_MODE_MONO;\n    }\n    else if(!strcasecmp(str, \"gray\"))\n    {\n        d->color_name = \"gray\";\n        d->color = COLOR_MODE_GRAY;\n    }\n    else if(!strcasecmp(str, \"8\"))\n    {\n        d->color_name = \"8\";\n        d->color = COLOR_MODE_8;\n    }\n    else if(!strcasecmp(str, \"16\"))\n    {\n        d->color_name = \"16\";\n        d->color = COLOR_MODE_16;\n    }\n    else if(!strcasecmp(str, \"fullgray\"))\n    {\n        d->color_name = \"fullgray\";\n        d->color = COLOR_MODE_FULLGRAY;\n    }\n    else if(!strcasecmp(str, \"full8\"))\n    {\n        d->color_name = \"full8\";\n        d->color = COLOR_MODE_FULL8;\n    }\n    else if(!strcasecmp(str, \"full16\") || !strcasecmp(str, \"default\"))\n    {\n        d->color_name = \"full16\";\n        d->color = COLOR_MODE_FULL16;\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get available colour modes\n *\n *  Return a list of available colour modes for a given dither. The list\n *  is a NULL-terminated array of strings, interleaving a string containing\n *  the internal value for the colour mode, to be used with\n *  caca_set_dither_color(), and a string containing the natural\n *  language description for that colour mode.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const *\n    caca_get_dither_color_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"mono\", \"white on black\",\n        \"gray\", \"grayscale on black\",\n        \"8\", \"8 colours on black\",\n        \"16\", \"16 colours on black\",\n        \"fullgray\", \"full grayscale\",\n        \"full8\", \"full 8 colours\",\n        \"full16\", \"full 16 colours\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current colour mode\n *\n *  Return the given dither's current colour mode.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_color(caca_dither_t const *d)\n{\n    return d->color_name;\n}\n\n/** \\brief Choose characters used for dithering\n *\n *  Tell the renderer which characters should be used to render the\n *  dither. Valid values for \\c str are:\n *  - \\c \"ascii\" or \\c \"default\": use only ASCII characters. This is the\n *    default value.\n *  - \\c \"shades\": use Unicode characters \"U+2591 LIGHT SHADE\", \"U+2592\n *    MEDIUM SHADE\" and \"U+2593 DARK SHADE\". These characters are also\n *    present in the CP437 codepage available on DOS and VGA.\n *  - \\c \"blocks\": use Unicode quarter-cell block combinations. These\n *    characters are only found in the Unicode set.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Invalid character set.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the characters that need to be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_charset(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"shades\"))\n    {\n        d->glyph_name = \"shades\";\n        d->glyphs = shades_glyphs;\n        d->glyph_count = sizeof(shades_glyphs) / sizeof(*shades_glyphs);\n    }\n    else if(!strcasecmp(str, \"blocks\"))\n    {\n        d->glyph_name = \"blocks\";\n        d->glyphs = blocks_glyphs;\n        d->glyph_count = sizeof(blocks_glyphs) / sizeof(*blocks_glyphs);\n    }\n    else if(!strcasecmp(str, \"ascii\") || !strcasecmp(str, \"default\"))\n    {\n        d->glyph_name = \"ascii\";\n        d->glyphs = ascii_glyphs;\n        d->glyph_count = sizeof(ascii_glyphs) / sizeof(*ascii_glyphs);\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get available dither character sets\n *\n *  Return a list of available character sets for a given dither. The list\n *  is a NULL-terminated array of strings, interleaving a string containing\n *  the internal value for the character set, to be used with\n *  caca_set_dither_charset(), and a string containing the natural\n *  language description for that character set.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const * caca_get_dither_charset_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"ascii\", \"plain ASCII\",\n        \"shades\", \"CP437 shades\",\n        \"blocks\", \"Unicode blocks\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current character set\n *\n *  Return the given dither's current character set.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_charset(caca_dither_t const *d)\n{\n    return d->glyph_name;\n}\n\n/** \\brief Set dithering algorithm\n *\n *  Tell the renderer which dithering algorithm should be used. Dithering is\n *  necessary because the picture being rendered has usually far more colours\n *  than the available palette. Valid values for \\c str are:\n *  - \\c \"none\": no dithering is used, the nearest matching colour is used.\n *  - \\c \"ordered2\": use a 2x2 Bayer matrix for dithering.\n *  - \\c \"ordered4\": use a 4x4 Bayer matrix for dithering.\n *  - \\c \"ordered8\": use a 8x8 Bayer matrix for dithering.\n *  - \\c \"random\": use random dithering.\n *  - \\c \"fstein\": use Floyd-Steinberg dithering. This is the default value.\n *\n *  If an error occurs, -1 is returned and \\b errno is set accordingly:\n *  - \\c EINVAL Unknown dithering mode.\n *\n *  \\param d Dither object.\n *  \\param str A string describing the algorithm that needs to be used\n *         for the dithering.\n *  \\return 0 in case of success, -1 if an error occurred.\n */\nint caca_set_dither_algorithm(caca_dither_t *d, char const *str)\n{\n    if(!strcasecmp(str, \"none\"))\n    {\n        d->algo_name = \"none\";\n        d->init_dither = init_no_dither;\n        d->get_dither = get_no_dither;\n        d->increment_dither = increment_no_dither;\n    }\n    else if(!strcasecmp(str, \"ordered2\"))\n    {\n        d->algo_name = \"ordered2\";\n        d->init_dither = init_ordered2_dither;\n        d->get_dither = get_ordered2_dither;\n        d->increment_dither = increment_ordered2_dither;\n    }\n    else if(!strcasecmp(str, \"ordered4\"))\n    {\n        d->algo_name = \"ordered4\";\n        d->init_dither = init_ordered4_dither;\n        d->get_dither = get_ordered4_dither;\n        d->increment_dither = increment_ordered4_dither;\n    }\n    else if(!strcasecmp(str, \"ordered8\"))\n    {\n        d->algo_name = \"ordered8\";\n        d->init_dither = init_ordered8_dither;\n        d->get_dither = get_ordered8_dither;\n        d->increment_dither = increment_ordered8_dither;\n    }\n    else if(!strcasecmp(str, \"random\"))\n    {\n        d->algo_name = \"random\";\n        d->init_dither = init_random_dither;\n        d->get_dither = get_random_dither;\n        d->increment_dither = increment_random_dither;\n    }\n    else if(!strcasecmp(str, \"fstein\") || !strcasecmp(str, \"default\"))\n    {\n        d->algo_name = \"fstein\";\n        d->init_dither = init_fstein_dither;\n        d->get_dither = get_fstein_dither;\n        d->increment_dither = increment_fstein_dither;\n    }\n    else\n    {\n        seterrno(EINVAL);\n        return -1;\n    }\n\n    return 0;\n}\n\n/** \\brief Get dithering algorithms\n *\n *  Return a list of available dithering algorithms for a given dither. The\n *  list is a NULL-terminated array of strings, interleaving a string\n *  containing the internal value for the dithering algorithm, to be used\n *  with caca_set_dither_dithering(), and a string containing the natural\n *  language description for that algorithm.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return An array of strings.\n */\nchar const * const * caca_get_dither_algorithm_list(caca_dither_t const *d)\n{\n    static char const * const list[] =\n    {\n        \"none\", \"no dithering\",\n        \"ordered2\", \"2x2 ordered dithering\",\n        \"ordered4\", \"4x4 ordered dithering\",\n        \"ordered8\", \"8x8 ordered dithering\",\n        \"random\", \"random dithering\",\n        \"fstein\", \"Floyd-Steinberg dithering\",\n        NULL, NULL\n    };\n\n    return list;\n}\n\n/** \\brief Get current dithering algorithm\n *\n *  Return the given dither's current dithering algorithm.\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return A static string.\n */\nchar const * caca_get_dither_algorithm(caca_dither_t const *d)\n{\n    return d->algo_name;\n}\n\n/** \\brief Dither a bitmap on the canvas.\n *\n *  Dither a bitmap at the given coordinates. The dither can be of any size\n *  and will be stretched to the text area.\n *\n *  This function never fails.\n *\n *  \\param cv A handle to the libcaca canvas.\n *  \\param x X coordinate of the upper-left corner of the drawing area.\n *  \\param y Y coordinate of the upper-left corner of the drawing area.\n *  \\param w Width of the drawing area.\n *  \\param h Height of the drawing area.\n *  \\param d Dither object to be drawn.\n *  \\param pixels Bitmap's pixels.\n *  \\return This function always returns 0.\n */\nint caca_dither_bitmap(caca_canvas_t *cv, int x, int y, int w, int h,\n                        caca_dither_t const *d, void const *pixels)\n{\n    int *floyd_steinberg, *fs_r, *fs_g, *fs_b;\n    uint32_t savedattr;\n    int fs_length;\n    int x1, y1, x2, y2, pitch, deltax, deltay, dchmax;\n\n    if(!d || !pixels)\n        return 0;\n\n    savedattr = caca_get_attr(cv, -1, -1);\n\n    x1 = x; x2 = x + w - 1;\n    y1 = y; y2 = y + h - 1;\n\n    /* FIXME: do not overwrite arguments */\n    w = d->w;\n    h = d->h;\n    pitch = d->pitch;\n\n    deltax = x2 - x1 + 1;\n    deltay = y2 - y1 + 1;\n    dchmax = d->glyph_count;\n\n    fs_length = ((int)cv->width <= x2 ? (int)cv->width : x2) + 1;\n    floyd_steinberg = malloc(3 * (fs_length + 2) * sizeof(int));\n    memset(floyd_steinberg, 0, 3 * (fs_length + 2) * sizeof(int));\n    fs_r = floyd_steinberg + 1;\n    fs_g = fs_r + fs_length + 2;\n    fs_b = fs_g + fs_length + 2;\n\n    for(y = y1 > 0 ? y1 : 0; y <= y2 && y <= (int)cv->height; y++)\n    {\n        int remain_r = 0, remain_g = 0, remain_b = 0;\n\n        for(x = x1 > 0 ? x1 : 0, d->init_dither(y);\n            x <= x2 && x <= (int)cv->width;\n            x++)\n    {\n        unsigned int rgba[4];\n        int error[3];\n        int i, ch = 0, distmin;\n        int fg_r = 0, fg_g = 0, fg_b = 0, bg_r, bg_g, bg_b;\n        int fromx, fromy, tox, toy, myx, myy, dots, dist;\n\n        int outfg = 0, outbg = 0;\n        uint32_t outch;\n\n        rgba[0] = rgba[1] = rgba[2] = rgba[3] = 0;\n\n        /* First get RGB */\n        if(d->antialias)\n        {\n            fromx = (uint64_t)(x - x1) * w / deltax;\n            fromy = (uint64_t)(y - y1) * h / deltay;\n            tox = (uint64_t)(x - x1 + 1) * w / deltax;\n            toy = (uint64_t)(y - y1 + 1) * h / deltay;\n\n            /* We want at least one pixel */\n            if(tox == fromx) tox++;\n            if(toy == fromy) toy++;\n\n            dots = 0;\n\n            for(myx = fromx; myx < tox; myx++)\n                for(myy = fromy; myy < toy; myy++)\n            {\n                dots++;\n                get_rgba_default(d, pixels, myx, myy, rgba);\n            }\n\n            /* Normalize */\n            rgba[0] /= dots;\n            rgba[1] /= dots;\n            rgba[2] /= dots;\n            rgba[3] /= dots;\n        }\n        else\n        {\n            fromx = (uint64_t)(x - x1) * w / deltax;\n            fromy = (uint64_t)(y - y1) * h / deltay;\n            tox = (uint64_t)(x - x1 + 1) * w / deltax;\n            toy = (uint64_t)(y - y1 + 1) * h / deltay;\n\n            /* tox and toy can overflow the canvas, but they cannot overflow\n             * when averaged with fromx and fromy because these are guaranteed\n             * to be within the pixel boundaries. */\n            myx = (fromx + tox) / 2;\n            myy = (fromy + toy) / 2;\n\n            get_rgba_default(d, pixels, myx, myy, rgba);\n        }\n\n        /* FIXME: hack to force greyscale */\n        if(d->color == COLOR_MODE_FULLGRAY)\n        {\n            unsigned int gray = (3 * rgba[0] + 4 * rgba[1] + rgba[2] + 4) / 8;\n            rgba[0] = rgba[1] = rgba[2] = gray;\n        }\n\n        if(d->has_alpha && rgba[3] < 0x800)\n        {\n            remain_r = remain_g = remain_b = 0;\n            fs_r[x] = 0;\n            fs_g[x] = 0;\n            fs_b[x] = 0;\n            continue;\n        }\n\n        /* XXX: OMG HAX */\n        if(d->init_dither == init_fstein_dither)\n        {\n            rgba[0] += remain_r;\n            rgba[1] += remain_g;\n            rgba[2] += remain_b;\n        }\n        else\n        {\n            rgba[0] += (d->get_dither() - 0x80) * 4;\n            rgba[1] += (d->get_dither() - 0x80) * 4;\n            rgba[2] += (d->get_dither() - 0x80) * 4;\n        }\n\n        distmin = INT_MAX;\n        for(i = 0; i < 16; i++)\n        {\n            if(d->color == COLOR_MODE_FULLGRAY\n                && (rgb_palette[i * 3] != rgb_palette[i * 3 + 1]\n                     || rgb_palette[i * 3] != rgb_palette[i * 3 + 2]))\n                continue;\n            dist = sq(rgba[0] - rgb_palette[i * 3])\n                 + sq(rgba[1] - rgb_palette[i * 3 + 1])\n                 + sq(rgba[2] - rgb_palette[i * 3 + 2]);\n            dist *= rgb_weight[i];\n            if(dist < distmin)\n            {\n                outbg = i;\n                distmin = dist;\n            }\n        }\n        bg_r = rgb_palette[outbg * 3];\n        bg_g = rgb_palette[outbg * 3 + 1];\n        bg_b = rgb_palette[outbg * 3 + 2];\n\n        /* FIXME: we currently only honour \"full16\" */\n        if(d->color == COLOR_MODE_FULL16 || d->color == COLOR_MODE_FULLGRAY)\n        {\n            distmin = INT_MAX;\n            for(i = 0; i < 16; i++)\n            {\n                if(i == outbg)\n                    continue;\n                if(d->color == COLOR_MODE_FULLGRAY\n                    && (rgb_palette[i * 3] != rgb_palette[i * 3 + 1]\n                         || rgb_palette[i * 3] != rgb_palette[i * 3 + 2]))\n                    continue;\n                dist = sq(rgba[0] - rgb_palette[i * 3])\n                     + sq(rgba[1] - rgb_palette[i * 3 + 1])\n                     + sq(rgba[2] - rgb_palette[i * 3 + 2]);\n                dist *= rgb_weight[i];\n                if(dist < distmin)\n                {\n                    outfg = i;\n                    distmin = dist;\n                }\n            }\n            fg_r = rgb_palette[outfg * 3];\n            fg_g = rgb_palette[outfg * 3 + 1];\n            fg_b = rgb_palette[outfg * 3 + 2];\n\n            distmin = INT_MAX;\n            for(i = 0; i < dchmax - 1; i++)\n            {\n                int newr = i * fg_r + ((2*dchmax-1) - i) * bg_r;\n                int newg = i * fg_g + ((2*dchmax-1) - i) * bg_g;\n                int newb = i * fg_b + ((2*dchmax-1) - i) * bg_b;\n                dist = abs(rgba[0] * (2*dchmax-1) - newr)\n                     + abs(rgba[1] * (2*dchmax-1) - newg)\n                     + abs(rgba[2] * (2*dchmax-1) - newb);\n\n                if(dist < distmin)\n                {\n                    ch = i;\n                    distmin = dist;\n                }\n            }\n            outch = d->glyphs[ch];\n\n            /* XXX: OMG HAX */\n            if(d->init_dither == init_fstein_dither)\n            {\n                error[0] = rgba[0] - (fg_r * ch + bg_r * ((2*dchmax-1) - ch)) / (2*dchmax-1);\n                error[1] = rgba[1] - (fg_g * ch + bg_g * ((2*dchmax-1) - ch)) / (2*dchmax-1);\n                error[2] = rgba[2] - (fg_b * ch + bg_b * ((2*dchmax-1) - ch)) / (2*dchmax-1);\n            }\n        }\n        else\n        {\n            unsigned int lum = rgba[0];\n            if(rgba[1] > lum) lum = rgba[1];\n            if(rgba[2] > lum) lum = rgba[2];\n            outfg = outbg;\n            outbg = CACA_BLACK;\n\n            ch = lum * dchmax / 0x1000;\n            if(ch < 0)\n                ch = 0;\n            else if(ch > (int)(dchmax - 1))\n                ch = dchmax - 1;\n            outch = d->glyphs[ch];\n\n            /* XXX: OMG HAX */\n            if(d->init_dither == init_fstein_dither)\n            {\n                error[0] = rgba[0] - bg_r * ch / (dchmax-1);\n                error[1] = rgba[1] - bg_g * ch / (dchmax-1);\n                error[2] = rgba[2] - bg_b * ch / (dchmax-1);\n            }\n        }\n\n        /* XXX: OMG HAX */\n        if(d->init_dither == init_fstein_dither)\n        {\n            remain_r = fs_r[x+1] + 7 * error[0] / 16;\n            remain_g = fs_g[x+1] + 7 * error[1] / 16;\n            remain_b = fs_b[x+1] + 7 * error[2] / 16;\n            fs_r[x-1] += 3 * error[0] / 16;\n            fs_g[x-1] += 3 * error[1] / 16;\n            fs_b[x-1] += 3 * error[2] / 16;\n            fs_r[x] = 5 * error[0] / 16;\n            fs_g[x] = 5 * error[1] / 16;\n            fs_b[x] = 5 * error[2] / 16;\n            fs_r[x+1] = 1 * error[0] / 16;\n            fs_g[x+1] = 1 * error[1] / 16;\n            fs_b[x+1] = 1 * error[2] / 16;\n        }\n\n        if(d->invert)\n        {\n            outfg = 15 - outfg;\n            outbg = 15 - outbg;\n        }\n\n        /* Now output the character */\n        caca_set_color_ansi(cv, outfg, outbg);\n        caca_put_char(cv, x, y, outch);\n\n        d->increment_dither();\n    }\n        /* end loop */\n    }\n\n    free(floyd_steinberg);\n\n    caca_set_attr(cv, savedattr);\n\n    return 0;\n}\n\n/** \\brief Free the memory associated with a dither.\n *\n *  Free the memory allocated by caca_create_dither().\n *\n *  This function never fails.\n *\n *  \\param d Dither object.\n *  \\return This function always returns 0.\n */\nint caca_free_dither(caca_dither_t *d)\n{\n    if(!d)\n        return 0;\n\n    free(d);\n\n    return 0;\n}\n\n/*\n * XXX: The following functions are local.\n */\n\n/* Convert a mask, eg. 0x0000ff00, to shift values, eg. 8 and -4. */\nstatic void mask2shift(uint32_t mask, int *right, int *left)\n{\n    int rshift = 0, lshift = 0;\n\n    if(!mask)\n    {\n        *right = *left = 0;\n        return;\n    }\n\n    while(!(mask & 1))\n    {\n        mask >>= 1;\n        rshift++;\n    }\n    *right = rshift;\n\n    while(mask & 1)\n    {\n        mask >>= 1;\n        lshift++;\n    }\n    *left = 12 - lshift;\n}\n\n/* Compute x^y without relying on the math library */\nstatic float gammapow(float x, float y)\n{\n#ifdef HAVE_FLDLN2\n    register double logx;\n    register long double v, e;\n#else\n    register float tmp, t, t2, r;\n    int i;\n#endif\n\n    if(x == 0.0)\n        return y == 0.0 ? 1.0 : 0.0;\n\n#ifdef HAVE_FLDLN2\n    /* FIXME: this can be optimised by directly calling fyl2x for x and y */\n    asm volatile(\"fldln2; fxch; fyl2x\"\n                 : \"=t\" (logx) : \"0\" (x) : \"st(1)\");\n\n    asm volatile(\"fldl2e\\n\\t\"\n                 \"fmul %%st(1)\\n\\t\"\n                 \"fst %%st(1)\\n\\t\"\n                 \"frndint\\n\\t\"\n                 \"fxch\\n\\t\"\n                 \"fsub %%st(1)\\n\\t\"\n                 \"f2xm1\\n\\t\"\n                 : \"=t\" (v), \"=u\" (e) : \"0\" (y * logx));\n    v += 1.0;\n    asm volatile(\"fscale\"\n                 : \"=t\" (v) : \"0\" (v), \"u\" (e));\n    return v;\n#else\n    /* Compute ln(x) for x \u2208 ]0,1]\n     *   ln(x) = 2 * (t + t^3/3 + t^5/5 + ...) with t = (x-1)/(x+1)\n     * The convergence is a bit slow, especially when x is near 0. */\n    t = (x - 1.0) / (x + 1.0);\n    t2 = t * t;\n    tmp = r = t;\n    for(i = 3; i < 20; i += 2)\n    {\n        r *= t2;\n        tmp += r / i;\n    }\n\n    /* Compute -y*ln(x) */\n    tmp = - y * 2.0 * tmp;\n\n    /* Compute x^-y as e^t where t = -y*ln(x):\n     *   e^t = 1 + t/1! + t^2/2! + t^3/3! + t^4/4! + t^5/5! ...\n     * The convergence is quite faster here, thanks to the factorial. */\n    r = t = tmp;\n    tmp = 1.0 + t;\n    for(i = 2; i < 16; i++)\n    {\n        r = r * t / i;\n        tmp += r;\n    }\n\n    /* Return x^y as 1/(x^-y) */\n    return 1.0 / tmp;\n#endif\n}\n\nstatic void get_rgba_default(caca_dither_t const *d, uint8_t const *pixels,\n                             int x, int y, unsigned int *rgba)\n{\n    uint32_t bits;\n\n    pixels += (d->bpp / 8) * x + d->pitch * y;\n\n    switch(d->bpp / 8)\n    {\n        case 4:\n            bits = *(uint32_t const *)pixels;\n            break;\n        case 3:\n        {\n#if defined(HAVE_ENDIAN_H)\n            if(__BYTE_ORDER == __BIG_ENDIAN)\n#else\n            /* This is compile-time optimised with at least -O1 or -Os */\n            uint32_t const tmp = 0x12345678;\n            if(*(uint8_t const *)&tmp == 0x12)\n#endif\n                bits = ((uint32_t)pixels[0] << 16) |\n                       ((uint32_t)pixels[1] << 8) |\n                       ((uint32_t)pixels[2]);\n            else\n                bits = ((uint32_t)pixels[2] << 16) |\n                       ((uint32_t)pixels[1] << 8) |\n                       ((uint32_t)pixels[0]);\n            break;\n        }\n        case 2:\n            bits = *(uint16_t const *)pixels;\n            break;\n        case 1:\n        default:\n            bits = pixels[0];\n            break;\n    }\n\n    if(d->has_palette)\n    {\n        rgba[0] += d->gammatab[d->red[bits]];\n        rgba[1] += d->gammatab[d->green[bits]];\n        rgba[2] += d->gammatab[d->blue[bits]];\n        rgba[3] += d->alpha[bits];\n    }\n    else\n    {\n        rgba[0] += d->gammatab[((bits & d->rmask) >> d->rright) << d->rleft];\n        rgba[1] += d->gammatab[((bits & d->gmask) >> d->gright) << d->gleft];\n        rgba[2] += d->gammatab[((bits & d->bmask) >> d->bright) << d->bleft];\n        rgba[3] += ((bits & d->amask) >> d->aright) << d->aleft;\n    }\n}\n\n/*\n * No dithering\n */\nstatic void init_no_dither(int line)\n{\n    ;\n}\n\nstatic int get_no_dither(void)\n{\n    return 0x80;\n}\n\nstatic void increment_no_dither(void)\n{\n    return;\n}\n\n/*\n * Floyd-Steinberg dithering\n */\nstatic void init_fstein_dither(int line)\n{\n    ;\n}\n\nstatic int get_fstein_dither(void)\n{\n    return 0x80;\n}\n\nstatic void increment_fstein_dither(void)\n{\n    return;\n}\n\n/*\n * Ordered 2 dithering\n */\nstatic int const *ordered2_table;\nstatic int ordered2_index;\n\nstatic void init_ordered2_dither(int line)\n{\n    static int const dither2x2[] =\n    {\n        0x00, 0x80,\n        0xc0, 0x40,\n    };\n\n    ordered2_table = dither2x2 + (line % 2) * 2;\n    ordered2_index = 0;\n}\n\nstatic int get_ordered2_dither(void)\n{\n    return ordered2_table[ordered2_index];\n}\n\nstatic void increment_ordered2_dither(void)\n{\n    ordered2_index = (ordered2_index + 1) % 2;\n}\n\n/*\n * Ordered 4 dithering\n */\n/*static int dither4x4[] = { 5,  0,  1,  6,\n                          -1, -6, -5,  2,\n                          -2, -7, -8,  3,\n                           4, -3, -4, -7};*/\nstatic int const *ordered4_table;\nstatic int ordered4_index;\n\nstatic void init_ordered4_dither(int line)\n{\n    static int const dither4x4[] =\n    {\n        0x00, 0x80, 0x20, 0xa0,\n        0xc0, 0x40, 0xe0, 0x60,\n        0x30, 0xb0, 0x10, 0x90,\n        0xf0, 0x70, 0xd0, 0x50\n    };\n\n    ordered4_table = dither4x4 + (line % 4) * 4;\n    ordered4_index = 0;\n}\n\nstatic int get_ordered4_dither(void)\n{\n    return ordered4_table[ordered4_index];\n}\n\nstatic void increment_ordered4_dither(void)\n{\n    ordered4_index = (ordered4_index + 1) % 4;\n}\n\n/*\n * Ordered 8 dithering\n */\nstatic int const *ordered8_table;\nstatic int ordered8_index;\n\nstatic void init_ordered8_dither(int line)\n{\n    static int const dither8x8[] =\n    {\n        0x00, 0x80, 0x20, 0xa0, 0x08, 0x88, 0x28, 0xa8,\n        0xc0, 0x40, 0xe0, 0x60, 0xc8, 0x48, 0xe8, 0x68,\n        0x30, 0xb0, 0x10, 0x90, 0x38, 0xb8, 0x18, 0x98,\n        0xf0, 0x70, 0xd0, 0x50, 0xf8, 0x78, 0xd8, 0x58,\n        0x0c, 0x8c, 0x2c, 0xac, 0x04, 0x84, 0x24, 0xa4,\n        0xcc, 0x4c, 0xec, 0x6c, 0xc4, 0x44, 0xe4, 0x64,\n        0x3c, 0xbc, 0x1c, 0x9c, 0x34, 0xb4, 0x14, 0x94,\n        0xfc, 0x7c, 0xdc, 0x5c, 0xf4, 0x74, 0xd4, 0x54,\n    };\n\n    ordered8_table = dither8x8 + (line % 8) * 8;\n    ordered8_index = 0;\n}\n\nstatic int get_ordered8_dither(void)\n{\n    return ordered8_table[ordered8_index];\n}\n\nstatic void increment_ordered8_dither(void)\n{\n    ordered8_index = (ordered8_index + 1) % 8;\n}\n\n/*\n * Random dithering\n */\nstatic void init_random_dither(int line)\n{\n    ;\n}\n\nstatic int get_random_dither(void)\n{\n    return caca_rand(0x00, 0x100);\n}\n\nstatic void increment_random_dither(void)\n{\n    return;\n}\n\n/*\n * Lookup tables\n */\nstatic int init_lookup(void)\n{\n    int v, s, h;\n\n    /* These ones are constant */\n    lookup_colors[0] = CACA_BLACK;\n    lookup_colors[1] = CACA_DARKGRAY;\n    lookup_colors[2] = CACA_LIGHTGRAY;\n    lookup_colors[3] = CACA_WHITE;\n\n    /* These ones will be overwritten */\n    lookup_colors[4] = CACA_MAGENTA;\n    lookup_colors[5] = CACA_LIGHTMAGENTA;\n    lookup_colors[6] = CACA_RED;\n    lookup_colors[7] = CACA_LIGHTRED;\n\n    for(v = 0; v < LOOKUP_VAL; v++)\n        for(s = 0; s < LOOKUP_SAT; s++)\n            for(h = 0; h < LOOKUP_HUE; h++)\n    {\n        int i, distbg, distfg, dist;\n        int val, sat, hue;\n        uint8_t outbg, outfg;\n\n        val = 0xfff * v / (LOOKUP_VAL - 1);\n        sat = 0xfff * s / (LOOKUP_SAT - 1);\n        hue = 0xfff * h / (LOOKUP_HUE - 1);\n\n        /* Initialise distances to the distance between pure black HSV\n         * coordinates and our white colour (3) */\n        outbg = outfg = 3;\n        distbg = distfg = HSV_DISTANCE(0, 0, 0, 3);\n\n        /* Calculate distances to eight major colour values and store the\n         * two nearest points in our lookup table. */\n        for(i = 0; i < 8; i++)\n        {\n            dist = HSV_DISTANCE(hue, sat, val, i);\n            if(dist <= distbg)\n            {\n                outfg = outbg;\n                distfg = distbg;\n                outbg = i;\n                distbg = dist;\n            }\n            else if(dist <= distfg)\n            {\n                outfg = i;\n                distfg = dist;\n            }\n        }\n\n        hsv_distances[v][s][h] = (outfg << 4) | outbg;\n    }\n\n    return 0;\n}\n\n"], "filenames": ["caca/dither.c"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [120], "fixing_code_start_loc": [9], "fixing_code_end_loc": [120], "type": "CWE-190", "message": "There is an illegal READ memory access at caca/dither.c (function get_rgba_default) in libcaca 0.99.beta19 for the default bpp case.", "other": {"cve": {"id": "CVE-2018-20546", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-28T16:29:04.893", "lastModified": "2022-06-13T19:00:36.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is an illegal READ memory access at caca/dither.c (function get_rgba_default) in libcaca 0.99.beta19 for the default bpp case."}, {"lang": "es", "value": "Hay un acceso de LECTURA ilegal en la memoria en caca/dither.c (funci\u00f3n get_rgba_default) en libcaca 0.99.beta19 para el caso bpp por defecto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libcaca_project:libcaca:0.99:beta19:*:*:*:*:*:*", "matchCriteriaId": "27B545C0-6311-4AD1-AC52-F9C86040A90B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1652622", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/cacalabs/libcaca/commit/1022d97496c7899e8641515af363381b31ae2f05", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cacalabs/libcaca/issues/38", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6WFGYICNTMNDNMDDUV4G2RYFB5HNJCOV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PC7EGOEQ5C4OD66ZUJJIIYEXBTZOCMZX/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZSBCRN6EGQJUVOSD4OEEQ6XORHEM2CUL/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3860-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3860-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cacalabs/libcaca/commit/1022d97496c7899e8641515af363381b31ae2f05"}}