{"buggy_code": ["/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriCommon.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriCommon.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include \"UriCommon.h\"\n#endif\n\n\n\n/*extern*/ const URI_CHAR * const URI_FUNC(SafeToPointTo) = _UT(\"X\");\n/*extern*/ const URI_CHAR * const URI_FUNC(ConstPwd) = _UT(\".\");\n/*extern*/ const URI_CHAR * const URI_FUNC(ConstParent) = _UT(\"..\");\n\n\n\nvoid URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n\tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n}\n\n\n\n/* Compares two text ranges for equal text content */\nint URI_FUNC(CompareRange)(\n\t\tconst URI_TYPE(TextRange) * a,\n\t\tconst URI_TYPE(TextRange) * b) {\n\tint diff;\n\n\t/* NOTE: Both NULL means equal! */\n\tif ((a == NULL) || (b == NULL)) {\n\t\treturn ((a == NULL) ? 0 : 1) - ((b == NULL) ? 0 : 1);\n\t}\n\n\t/* NOTE: Both NULL means equal! */\n\tif ((a->first == NULL) || (b->first == NULL)) {\n\t\treturn ((a->first == NULL) ? 0 : 1) - ((b->first == NULL) ? 0 : 1);\n\t}\n\n\tdiff = ((int)(a->afterLast - a->first) - (int)(b->afterLast - b->first));\n\tif (diff > 0) {\n\t\treturn 1;\n\t} else if (diff < 0) {\n\t\treturn -1;\n\t}\n\n\tdiff = URI_STRNCMP(a->first, b->first, (a->afterLast - a->first));\n\n\tif (diff > 0) {\n\t\treturn 1;\n\t} else if (diff < 0) {\n\t\treturn -1;\n\t}\n\n\treturn diff;\n}\n\n\n\n/* Properly removes \".\" and \"..\" path segments */\nUriBool URI_FUNC(RemoveDotSegments)(URI_TYPE(Uri) * uri,\n\t\tUriBool relative, UriMemoryManager * memory) {\n\tif (uri == NULL) {\n\t\treturn URI_TRUE;\n\t}\n\treturn URI_FUNC(RemoveDotSegmentsEx)(uri, relative, uri->owner, memory);\n}\n\n\n\nUriBool URI_FUNC(RemoveDotSegmentsEx)(URI_TYPE(Uri) * uri,\n\t\tUriBool relative, UriBool pathOwned, UriMemoryManager * memory) {\n\tURI_TYPE(PathSegment) * walker;\n\tif ((uri == NULL) || (uri->pathHead == NULL)) {\n\t\treturn URI_TRUE;\n\t}\n\n\twalker = uri->pathHead;\n\twalker->reserved = NULL; /* Prev pointer */\n\tdo {\n\t\tUriBool removeSegment = URI_FALSE;\n\t\tint len = (int)(walker->text.afterLast - walker->text.first);\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\tif ((walker->text.first)[0] == _UT('.')) {\n\t\t\t\t/* \".\" segment -> remove if not essential */\n\t\t\t\tURI_TYPE(PathSegment) * const prev = walker->reserved;\n\t\t\t\tURI_TYPE(PathSegment) * const nextBackup = walker->next;\n\n\t\t\t\t/* Is this dot segment essential? */\n\t\t\t\tremoveSegment = URI_TRUE;\n\t\t\t\tif (relative && (walker == uri->pathHead) && (walker->next != NULL)) {\n\t\t\t\t\tconst URI_CHAR * ch = walker->next->text.first;\n\t\t\t\t\tfor (; ch < walker->next->text.afterLast; ch++) {\n\t\t\t\t\t\tif (*ch == _UT(':')) {\n\t\t\t\t\t\t\tremoveSegment = URI_FALSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeSegment) {\n\t\t\t\t\t/* Last segment? */\n\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t/* Not last segment */\n\t\t\t\t\t\twalker->next->reserved = prev;\n\n\t\t\t\t\t\tif (prev == NULL) {\n\t\t\t\t\t\t\t/* First but not last segment */\n\t\t\t\t\t\t\turi->pathHead = walker->next;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Middle segment */\n\t\t\t\t\t\t\tprev->next = walker->next;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemory->free(memory, walker);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Last segment */\n\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prev == NULL) {\n\t\t\t\t\t\t\t/* Last and first */\n\t\t\t\t\t\t\tif (URI_FUNC(IsHostSet)(uri)) {\n\t\t\t\t\t\t\t\t/* Replace \".\" with empty segment to represent trailing slash */\n\t\t\t\t\t\t\t\twalker->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\twalker->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\t\t\turi->pathHead = NULL;\n\t\t\t\t\t\t\t\turi->pathTail = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Last but not first, replace \".\" with empty segment to represent trailing slash */\n\t\t\t\t\t\t\twalker->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\twalker->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twalker = nextBackup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (((walker->text.first)[0] == _UT('.'))\n\t\t\t\t\t&& ((walker->text.first)[1] == _UT('.'))) {\n\t\t\t\t/* Path \"..\" -> remove this and the previous segment */\n\t\t\t\tURI_TYPE(PathSegment) * const prev = walker->reserved;\n\t\t\t\tURI_TYPE(PathSegment) * prevPrev;\n\t\t\t\tURI_TYPE(PathSegment) * const nextBackup = walker->next;\n\n\t\t\t\tremoveSegment = URI_TRUE;\n\t\t\t\tif (relative) {\n\t\t\t\t\tif (prev == NULL) {\n\t\t\t\t\t\tremoveSegment = URI_FALSE;\n\t\t\t\t\t} else if ((prev != NULL)\n\t\t\t\t\t\t\t&& ((prev->text.afterLast - prev->text.first) == 2)\n\t\t\t\t\t\t\t&& ((prev->text.first)[0] == _UT('.'))\n\t\t\t\t\t\t\t&& ((prev->text.first)[1] == _UT('.'))) {\n\t\t\t\t\t\tremoveSegment = URI_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeSegment) {\n\t\t\t\t\tif (prev != NULL) {\n\t\t\t\t\t\t/* Not first segment */\n\t\t\t\t\t\tprevPrev = prev->reserved;\n\t\t\t\t\t\tif (prevPrev != NULL) {\n\t\t\t\t\t\t\t/* Not even prev is the first one */\n\t\t\t\t\t\t\tprevPrev->next = walker->next;\n\t\t\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t\t\twalker->next->reserved = prevPrev;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Last segment -> insert \"\" segment to represent trailing slash, update tail */\n\t\t\t\t\t\t\t\tURI_TYPE(PathSegment) * const segment = memory->calloc(memory, 1, sizeof(URI_TYPE(PathSegment)));\n\t\t\t\t\t\t\t\tif (segment == NULL) {\n\t\t\t\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\t\t\t\tif (pathOwned && (prev->text.first != prev->text.afterLast)) {\n\t\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)prev->text.first);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmemory->free(memory, prev);\n\n\t\t\t\t\t\t\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsegment->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\tsegment->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\tprevPrev->next = segment;\n\t\t\t\t\t\t\t\turi->pathTail = segment;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\t\tif (pathOwned && (prev->text.first != prev->text.afterLast)) {\n\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)prev->text.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemory->free(memory, prev);\n\n\t\t\t\t\t\t\twalker = nextBackup;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Prev is the first segment */\n\t\t\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t\t\turi->pathHead = walker->next;\n\t\t\t\t\t\t\t\twalker->next->reserved = NULL;\n\n\t\t\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmemory->free(memory, walker);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Re-use segment for \"\" path segment to represent trailing slash, update tail */\n\t\t\t\t\t\t\t\tURI_TYPE(PathSegment) * const segment = walker;\n\t\t\t\t\t\t\t\tif (pathOwned && (segment->text.first != segment->text.afterLast)) {\n\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)segment->text.first);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsegment->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\tsegment->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\turi->pathHead = segment;\n\t\t\t\t\t\t\t\turi->pathTail = segment;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (pathOwned && (prev->text.first != prev->text.afterLast)) {\n\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)prev->text.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemory->free(memory, prev);\n\n\t\t\t\t\t\t\twalker = nextBackup;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tURI_TYPE(PathSegment) * const anotherNextBackup = walker->next;\n\t\t\t\t\t\t/* First segment -> update head pointer */\n\t\t\t\t\t\turi->pathHead = walker->next;\n\t\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t\twalker->next->reserved = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Last segment -> update tail */\n\t\t\t\t\t\t\turi->pathTail = NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\twalker = anotherNextBackup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif (!removeSegment) {\n\t\t\tif (walker->next != NULL) {\n\t\t\t\twalker->next->reserved = walker;\n\t\t\t} else {\n\t\t\t\t/* Last segment -> update tail */\n\t\t\t\turi->pathTail = walker;\n\t\t\t}\n\t\t\twalker = walker->next;\n\t\t}\n\t} while (walker != NULL);\n\n\treturn URI_TRUE;\n}\n\n\n\n/* Properly removes \".\" and \"..\" path segments */\nUriBool URI_FUNC(RemoveDotSegmentsAbsolute)(URI_TYPE(Uri) * uri,\n\t\tUriMemoryManager * memory) {\n\tconst UriBool ABSOLUTE = URI_FALSE;\n\treturn URI_FUNC(RemoveDotSegments)(uri, ABSOLUTE, memory);\n}\n\n\n\nunsigned char URI_FUNC(HexdigToInt)(URI_CHAR hexdig) {\n\tswitch (hexdig) {\n\tcase _UT('0'):\n\tcase _UT('1'):\n\tcase _UT('2'):\n\tcase _UT('3'):\n\tcase _UT('4'):\n\tcase _UT('5'):\n\tcase _UT('6'):\n\tcase _UT('7'):\n\tcase _UT('8'):\n\tcase _UT('9'):\n\t\treturn (unsigned char)(9 + hexdig - _UT('9'));\n\n\tcase _UT('a'):\n\tcase _UT('b'):\n\tcase _UT('c'):\n\tcase _UT('d'):\n\tcase _UT('e'):\n\tcase _UT('f'):\n\t\treturn (unsigned char)(15 + hexdig - _UT('f'));\n\n\tcase _UT('A'):\n\tcase _UT('B'):\n\tcase _UT('C'):\n\tcase _UT('D'):\n\tcase _UT('E'):\n\tcase _UT('F'):\n\t\treturn (unsigned char)(15 + hexdig - _UT('F'));\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nURI_CHAR URI_FUNC(HexToLetter)(unsigned int value) {\n\t/* Uppercase recommended in section 2.1. of RFC 3986 *\n\t * http://tools.ietf.org/html/rfc3986#section-2.1    */\n\treturn URI_FUNC(HexToLetterEx)(value, URI_TRUE);\n}\n\n\n\nURI_CHAR URI_FUNC(HexToLetterEx)(unsigned int value, UriBool uppercase) {\n\tswitch (value) {\n\tcase  0: return _UT('0');\n\tcase  1: return _UT('1');\n\tcase  2: return _UT('2');\n\tcase  3: return _UT('3');\n\tcase  4: return _UT('4');\n\tcase  5: return _UT('5');\n\tcase  6: return _UT('6');\n\tcase  7: return _UT('7');\n\tcase  8: return _UT('8');\n\tcase  9: return _UT('9');\n\n\tcase 10: return (uppercase == URI_TRUE) ? _UT('A') : _UT('a');\n\tcase 11: return (uppercase == URI_TRUE) ? _UT('B') : _UT('b');\n\tcase 12: return (uppercase == URI_TRUE) ? _UT('C') : _UT('c');\n\tcase 13: return (uppercase == URI_TRUE) ? _UT('D') : _UT('d');\n\tcase 14: return (uppercase == URI_TRUE) ? _UT('E') : _UT('e');\n\tdefault: return (uppercase == URI_TRUE) ? _UT('F') : _UT('f');\n\t}\n}\n\n\n\n/* Checks if a URI has the host component set. */\nUriBool URI_FUNC(IsHostSet)(const URI_TYPE(Uri) * uri) {\n\treturn (uri != NULL)\n\t\t\t&& ((uri->hostText.first != NULL)\n\t\t\t\t|| (uri->hostData.ip4 != NULL)\n\t\t\t\t|| (uri->hostData.ip6 != NULL)\n\t\t\t\t|| (uri->hostData.ipFuture.first != NULL)\n\t\t\t);\n}\n\n\n\n/* Copies the path segment list from one URI to another. */\nUriBool URI_FUNC(CopyPath)(URI_TYPE(Uri) * dest,\n\t\tconst URI_TYPE(Uri) * source, UriMemoryManager * memory) {\n\tif (source->pathHead == NULL) {\n\t\t/* No path component */\n\t\tdest->pathHead = NULL;\n\t\tdest->pathTail = NULL;\n\t} else {\n\t\t/* Copy list but not the text contained */\n\t\tURI_TYPE(PathSegment) * sourceWalker = source->pathHead;\n\t\tURI_TYPE(PathSegment) * destPrev = NULL;\n\t\tdo {\n\t\t\tURI_TYPE(PathSegment) * cur = memory->malloc(memory, sizeof(URI_TYPE(PathSegment)));\n\t\t\tif (cur == NULL) {\n\t\t\t\t/* Fix broken list */\n\t\t\t\tif (destPrev != NULL) {\n\t\t\t\t\tdestPrev->next = NULL;\n\t\t\t\t}\n\t\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t\t}\n\n\t\t\t/* From this functions usage we know that *\n\t\t\t * the dest URI cannot be uri->owner      */\n\t\t\tcur->text = sourceWalker->text;\n\t\t\tif (destPrev == NULL) {\n\t\t\t\t/* First segment ever */\n\t\t\t\tdest->pathHead = cur;\n\t\t\t} else {\n\t\t\t\tdestPrev->next = cur;\n\t\t\t}\n\t\t\tdestPrev = cur;\n\t\t\tsourceWalker = sourceWalker->next;\n\t\t} while (sourceWalker != NULL);\n\t\tdest->pathTail = destPrev;\n\t\tdest->pathTail->next = NULL;\n\t}\n\n\tdest->absolutePath = source->absolutePath;\n\treturn URI_TRUE;\n}\n\n\n\n/* Copies the authority part of an URI over to another. */\nUriBool URI_FUNC(CopyAuthority)(URI_TYPE(Uri) * dest,\n\t\tconst URI_TYPE(Uri) * source, UriMemoryManager * memory) {\n\t/* From this functions usage we know that *\n\t * the dest URI cannot be uri->owner      */\n\t\n\t/* Copy userInfo */\n\tdest->userInfo = source->userInfo;\n\n\t/* Copy hostText */\n\tdest->hostText = source->hostText;\n\n\t/* Copy hostData */\n\tif (source->hostData.ip4 != NULL) {\n\t\tdest->hostData.ip4 = memory->malloc(memory, sizeof(UriIp4));\n\t\tif (dest->hostData.ip4 == NULL) {\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\t\t*(dest->hostData.ip4) = *(source->hostData.ip4);\n\t\tdest->hostData.ip6 = NULL;\n\t\tdest->hostData.ipFuture.first = NULL;\n\t\tdest->hostData.ipFuture.afterLast = NULL;\n\t} else if (source->hostData.ip6 != NULL) {\n\t\tdest->hostData.ip4 = NULL;\n\t\tdest->hostData.ip6 = memory->malloc(memory, sizeof(UriIp6));\n\t\tif (dest->hostData.ip6 == NULL) {\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\t\t*(dest->hostData.ip6) = *(source->hostData.ip6);\n\t\tdest->hostData.ipFuture.first = NULL;\n\t\tdest->hostData.ipFuture.afterLast = NULL;\n\t} else {\n\t\tdest->hostData.ip4 = NULL;\n\t\tdest->hostData.ip6 = NULL;\n\t\tdest->hostData.ipFuture = source->hostData.ipFuture;\n\t}\n\n\t/* Copy portText */\n\tdest->portText = source->portText;\n\n\treturn URI_TRUE;\n}\n\n\n\nUriBool URI_FUNC(FixAmbiguity)(URI_TYPE(Uri) * uri,\n\t\tUriMemoryManager * memory) {\n\tURI_TYPE(PathSegment) * segment;\n\n\tif (\t/* Case 1: absolute path, empty first segment */\n\t\t\t(uri->absolutePath\n\t\t\t&& (uri->pathHead != NULL)\n\t\t\t&& (uri->pathHead->text.afterLast == uri->pathHead->text.first))\n\n\t\t\t/* Case 2: relative path, empty first and second segment */\n\t\t\t|| (!uri->absolutePath\n\t\t\t&& (uri->pathHead != NULL)\n\t\t\t&& (uri->pathHead->next != NULL)\n\t\t\t&& (uri->pathHead->text.afterLast == uri->pathHead->text.first)\n\t\t\t&& (uri->pathHead->next->text.afterLast == uri->pathHead->next->text.first))) {\n\t\t/* NOOP */\n\t} else {\n\t\treturn URI_TRUE;\n\t}\n\n\tsegment = memory->malloc(memory, 1 * sizeof(URI_TYPE(PathSegment)));\n\tif (segment == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\n\t/* Insert \".\" segment in front */\n\tsegment->next = uri->pathHead;\n\tsegment->text.first = URI_FUNC(ConstPwd);\n\tsegment->text.afterLast = URI_FUNC(ConstPwd) + 1;\n\turi->pathHead = segment;\n\treturn URI_TRUE;\n}\n\n\n\nvoid URI_FUNC(FixEmptyTrailSegment)(URI_TYPE(Uri) * uri,\n\t\tUriMemoryManager * memory) {\n\t/* Fix path if only one empty segment */\n\tif (!uri->absolutePath\n\t\t\t&& !URI_FUNC(IsHostSet)(uri)\n\t\t\t&& (uri->pathHead != NULL)\n\t\t\t&& (uri->pathHead->next == NULL)\n\t\t\t&& (uri->pathHead->text.first == uri->pathHead->text.afterLast)) {\n\t\tmemory->free(memory, uri->pathHead);\n\t\turi->pathHead = NULL;\n\t\turi->pathTail = NULL;\n\t}\n}\n\n\n\n#endif\n"], "fixing_code": ["/*\n * uriparser - RFC 3986 URI parsing library\n *\n * Copyright (C) 2007, Weijia Song <songweijia@gmail.com>\n * Copyright (C) 2007, Sebastian Pipping <sebastian@pipping.org>\n * All rights reserved.\n *\n * Redistribution  and use in source and binary forms, with or without\n * modification,  are permitted provided that the following conditions\n * are met:\n *\n *     * Redistributions   of  source  code  must  retain  the   above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer.\n *\n *     * Redistributions  in  binary  form must  reproduce  the  above\n *       copyright  notice, this list of conditions and the  following\n *       disclaimer   in  the  documentation  and/or  other  materials\n *       provided with the distribution.\n *\n *     * Neither  the name of the <ORGANIZATION> nor the names of  its\n *       contributors  may  be  used to endorse  or  promote  products\n *       derived  from  this software without specific  prior  written\n *       permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  NOT\n * LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS\n * FOR  A  PARTICULAR  PURPOSE ARE DISCLAIMED. IN NO EVENT  SHALL  THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL,    SPECIAL,   EXEMPLARY,   OR   CONSEQUENTIAL   DAMAGES\n * (INCLUDING,  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES;  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT  LIABILITY,  OR  TORT (INCLUDING  NEGLIGENCE  OR  OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* What encodings are enabled? */\n#include <uriparser/UriDefsConfig.h>\n#if (!defined(URI_PASS_ANSI) && !defined(URI_PASS_UNICODE))\n/* Include SELF twice */\n# ifdef URI_ENABLE_ANSI\n#  define URI_PASS_ANSI 1\n#  include \"UriCommon.c\"\n#  undef URI_PASS_ANSI\n# endif\n# ifdef URI_ENABLE_UNICODE\n#  define URI_PASS_UNICODE 1\n#  include \"UriCommon.c\"\n#  undef URI_PASS_UNICODE\n# endif\n#else\n# ifdef URI_PASS_ANSI\n#  include <uriparser/UriDefsAnsi.h>\n# else\n#  include <uriparser/UriDefsUnicode.h>\n#  include <wchar.h>\n# endif\n\n\n\n#ifndef URI_DOXYGEN\n# include <uriparser/Uri.h>\n# include \"UriCommon.h\"\n#endif\n\n\n\n/*extern*/ const URI_CHAR * const URI_FUNC(SafeToPointTo) = _UT(\"X\");\n/*extern*/ const URI_CHAR * const URI_FUNC(ConstPwd) = _UT(\".\");\n/*extern*/ const URI_CHAR * const URI_FUNC(ConstParent) = _UT(\"..\");\n\n\n\nvoid URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n\tif (uri == NULL) {\n\t\treturn;\n\t}\n\tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n}\n\n\n\n/* Compares two text ranges for equal text content */\nint URI_FUNC(CompareRange)(\n\t\tconst URI_TYPE(TextRange) * a,\n\t\tconst URI_TYPE(TextRange) * b) {\n\tint diff;\n\n\t/* NOTE: Both NULL means equal! */\n\tif ((a == NULL) || (b == NULL)) {\n\t\treturn ((a == NULL) ? 0 : 1) - ((b == NULL) ? 0 : 1);\n\t}\n\n\t/* NOTE: Both NULL means equal! */\n\tif ((a->first == NULL) || (b->first == NULL)) {\n\t\treturn ((a->first == NULL) ? 0 : 1) - ((b->first == NULL) ? 0 : 1);\n\t}\n\n\tdiff = ((int)(a->afterLast - a->first) - (int)(b->afterLast - b->first));\n\tif (diff > 0) {\n\t\treturn 1;\n\t} else if (diff < 0) {\n\t\treturn -1;\n\t}\n\n\tdiff = URI_STRNCMP(a->first, b->first, (a->afterLast - a->first));\n\n\tif (diff > 0) {\n\t\treturn 1;\n\t} else if (diff < 0) {\n\t\treturn -1;\n\t}\n\n\treturn diff;\n}\n\n\n\n/* Properly removes \".\" and \"..\" path segments */\nUriBool URI_FUNC(RemoveDotSegments)(URI_TYPE(Uri) * uri,\n\t\tUriBool relative, UriMemoryManager * memory) {\n\tif (uri == NULL) {\n\t\treturn URI_TRUE;\n\t}\n\treturn URI_FUNC(RemoveDotSegmentsEx)(uri, relative, uri->owner, memory);\n}\n\n\n\nUriBool URI_FUNC(RemoveDotSegmentsEx)(URI_TYPE(Uri) * uri,\n\t\tUriBool relative, UriBool pathOwned, UriMemoryManager * memory) {\n\tURI_TYPE(PathSegment) * walker;\n\tif ((uri == NULL) || (uri->pathHead == NULL)) {\n\t\treturn URI_TRUE;\n\t}\n\n\twalker = uri->pathHead;\n\twalker->reserved = NULL; /* Prev pointer */\n\tdo {\n\t\tUriBool removeSegment = URI_FALSE;\n\t\tint len = (int)(walker->text.afterLast - walker->text.first);\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\tif ((walker->text.first)[0] == _UT('.')) {\n\t\t\t\t/* \".\" segment -> remove if not essential */\n\t\t\t\tURI_TYPE(PathSegment) * const prev = walker->reserved;\n\t\t\t\tURI_TYPE(PathSegment) * const nextBackup = walker->next;\n\n\t\t\t\t/* Is this dot segment essential? */\n\t\t\t\tremoveSegment = URI_TRUE;\n\t\t\t\tif (relative && (walker == uri->pathHead) && (walker->next != NULL)) {\n\t\t\t\t\tconst URI_CHAR * ch = walker->next->text.first;\n\t\t\t\t\tfor (; ch < walker->next->text.afterLast; ch++) {\n\t\t\t\t\t\tif (*ch == _UT(':')) {\n\t\t\t\t\t\t\tremoveSegment = URI_FALSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeSegment) {\n\t\t\t\t\t/* Last segment? */\n\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t/* Not last segment */\n\t\t\t\t\t\twalker->next->reserved = prev;\n\n\t\t\t\t\t\tif (prev == NULL) {\n\t\t\t\t\t\t\t/* First but not last segment */\n\t\t\t\t\t\t\turi->pathHead = walker->next;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Middle segment */\n\t\t\t\t\t\t\tprev->next = walker->next;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemory->free(memory, walker);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Last segment */\n\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (prev == NULL) {\n\t\t\t\t\t\t\t/* Last and first */\n\t\t\t\t\t\t\tif (URI_FUNC(IsHostSet)(uri)) {\n\t\t\t\t\t\t\t\t/* Replace \".\" with empty segment to represent trailing slash */\n\t\t\t\t\t\t\t\twalker->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\twalker->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\t\t\turi->pathHead = NULL;\n\t\t\t\t\t\t\t\turi->pathTail = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Last but not first, replace \".\" with empty segment to represent trailing slash */\n\t\t\t\t\t\t\twalker->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\twalker->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twalker = nextBackup;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (((walker->text.first)[0] == _UT('.'))\n\t\t\t\t\t&& ((walker->text.first)[1] == _UT('.'))) {\n\t\t\t\t/* Path \"..\" -> remove this and the previous segment */\n\t\t\t\tURI_TYPE(PathSegment) * const prev = walker->reserved;\n\t\t\t\tURI_TYPE(PathSegment) * prevPrev;\n\t\t\t\tURI_TYPE(PathSegment) * const nextBackup = walker->next;\n\n\t\t\t\tremoveSegment = URI_TRUE;\n\t\t\t\tif (relative) {\n\t\t\t\t\tif (prev == NULL) {\n\t\t\t\t\t\tremoveSegment = URI_FALSE;\n\t\t\t\t\t} else if ((prev != NULL)\n\t\t\t\t\t\t\t&& ((prev->text.afterLast - prev->text.first) == 2)\n\t\t\t\t\t\t\t&& ((prev->text.first)[0] == _UT('.'))\n\t\t\t\t\t\t\t&& ((prev->text.first)[1] == _UT('.'))) {\n\t\t\t\t\t\tremoveSegment = URI_FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeSegment) {\n\t\t\t\t\tif (prev != NULL) {\n\t\t\t\t\t\t/* Not first segment */\n\t\t\t\t\t\tprevPrev = prev->reserved;\n\t\t\t\t\t\tif (prevPrev != NULL) {\n\t\t\t\t\t\t\t/* Not even prev is the first one */\n\t\t\t\t\t\t\tprevPrev->next = walker->next;\n\t\t\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t\t\twalker->next->reserved = prevPrev;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Last segment -> insert \"\" segment to represent trailing slash, update tail */\n\t\t\t\t\t\t\t\tURI_TYPE(PathSegment) * const segment = memory->calloc(memory, 1, sizeof(URI_TYPE(PathSegment)));\n\t\t\t\t\t\t\t\tif (segment == NULL) {\n\t\t\t\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\t\t\t\tif (pathOwned && (prev->text.first != prev->text.afterLast)) {\n\t\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)prev->text.first);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmemory->free(memory, prev);\n\n\t\t\t\t\t\t\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsegment->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\tsegment->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\tprevPrev->next = segment;\n\t\t\t\t\t\t\t\turi->pathTail = segment;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\t\tif (pathOwned && (prev->text.first != prev->text.afterLast)) {\n\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)prev->text.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemory->free(memory, prev);\n\n\t\t\t\t\t\t\twalker = nextBackup;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Prev is the first segment */\n\t\t\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t\t\turi->pathHead = walker->next;\n\t\t\t\t\t\t\t\twalker->next->reserved = NULL;\n\n\t\t\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmemory->free(memory, walker);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/* Re-use segment for \"\" path segment to represent trailing slash, update tail */\n\t\t\t\t\t\t\t\tURI_TYPE(PathSegment) * const segment = walker;\n\t\t\t\t\t\t\t\tif (pathOwned && (segment->text.first != segment->text.afterLast)) {\n\t\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)segment->text.first);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tsegment->text.first = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\tsegment->text.afterLast = URI_FUNC(SafeToPointTo);\n\t\t\t\t\t\t\t\turi->pathHead = segment;\n\t\t\t\t\t\t\t\turi->pathTail = segment;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (pathOwned && (prev->text.first != prev->text.afterLast)) {\n\t\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)prev->text.first);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemory->free(memory, prev);\n\n\t\t\t\t\t\t\twalker = nextBackup;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tURI_TYPE(PathSegment) * const anotherNextBackup = walker->next;\n\t\t\t\t\t\t/* First segment -> update head pointer */\n\t\t\t\t\t\turi->pathHead = walker->next;\n\t\t\t\t\t\tif (walker->next != NULL) {\n\t\t\t\t\t\t\twalker->next->reserved = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Last segment -> update tail */\n\t\t\t\t\t\t\turi->pathTail = NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pathOwned && (walker->text.first != walker->text.afterLast)) {\n\t\t\t\t\t\t\tmemory->free(memory, (URI_CHAR *)walker->text.first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemory->free(memory, walker);\n\n\t\t\t\t\t\twalker = anotherNextBackup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif (!removeSegment) {\n\t\t\tif (walker->next != NULL) {\n\t\t\t\twalker->next->reserved = walker;\n\t\t\t} else {\n\t\t\t\t/* Last segment -> update tail */\n\t\t\t\turi->pathTail = walker;\n\t\t\t}\n\t\t\twalker = walker->next;\n\t\t}\n\t} while (walker != NULL);\n\n\treturn URI_TRUE;\n}\n\n\n\n/* Properly removes \".\" and \"..\" path segments */\nUriBool URI_FUNC(RemoveDotSegmentsAbsolute)(URI_TYPE(Uri) * uri,\n\t\tUriMemoryManager * memory) {\n\tconst UriBool ABSOLUTE = URI_FALSE;\n\treturn URI_FUNC(RemoveDotSegments)(uri, ABSOLUTE, memory);\n}\n\n\n\nunsigned char URI_FUNC(HexdigToInt)(URI_CHAR hexdig) {\n\tswitch (hexdig) {\n\tcase _UT('0'):\n\tcase _UT('1'):\n\tcase _UT('2'):\n\tcase _UT('3'):\n\tcase _UT('4'):\n\tcase _UT('5'):\n\tcase _UT('6'):\n\tcase _UT('7'):\n\tcase _UT('8'):\n\tcase _UT('9'):\n\t\treturn (unsigned char)(9 + hexdig - _UT('9'));\n\n\tcase _UT('a'):\n\tcase _UT('b'):\n\tcase _UT('c'):\n\tcase _UT('d'):\n\tcase _UT('e'):\n\tcase _UT('f'):\n\t\treturn (unsigned char)(15 + hexdig - _UT('f'));\n\n\tcase _UT('A'):\n\tcase _UT('B'):\n\tcase _UT('C'):\n\tcase _UT('D'):\n\tcase _UT('E'):\n\tcase _UT('F'):\n\t\treturn (unsigned char)(15 + hexdig - _UT('F'));\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\n\nURI_CHAR URI_FUNC(HexToLetter)(unsigned int value) {\n\t/* Uppercase recommended in section 2.1. of RFC 3986 *\n\t * http://tools.ietf.org/html/rfc3986#section-2.1    */\n\treturn URI_FUNC(HexToLetterEx)(value, URI_TRUE);\n}\n\n\n\nURI_CHAR URI_FUNC(HexToLetterEx)(unsigned int value, UriBool uppercase) {\n\tswitch (value) {\n\tcase  0: return _UT('0');\n\tcase  1: return _UT('1');\n\tcase  2: return _UT('2');\n\tcase  3: return _UT('3');\n\tcase  4: return _UT('4');\n\tcase  5: return _UT('5');\n\tcase  6: return _UT('6');\n\tcase  7: return _UT('7');\n\tcase  8: return _UT('8');\n\tcase  9: return _UT('9');\n\n\tcase 10: return (uppercase == URI_TRUE) ? _UT('A') : _UT('a');\n\tcase 11: return (uppercase == URI_TRUE) ? _UT('B') : _UT('b');\n\tcase 12: return (uppercase == URI_TRUE) ? _UT('C') : _UT('c');\n\tcase 13: return (uppercase == URI_TRUE) ? _UT('D') : _UT('d');\n\tcase 14: return (uppercase == URI_TRUE) ? _UT('E') : _UT('e');\n\tdefault: return (uppercase == URI_TRUE) ? _UT('F') : _UT('f');\n\t}\n}\n\n\n\n/* Checks if a URI has the host component set. */\nUriBool URI_FUNC(IsHostSet)(const URI_TYPE(Uri) * uri) {\n\treturn (uri != NULL)\n\t\t\t&& ((uri->hostText.first != NULL)\n\t\t\t\t|| (uri->hostData.ip4 != NULL)\n\t\t\t\t|| (uri->hostData.ip6 != NULL)\n\t\t\t\t|| (uri->hostData.ipFuture.first != NULL)\n\t\t\t);\n}\n\n\n\n/* Copies the path segment list from one URI to another. */\nUriBool URI_FUNC(CopyPath)(URI_TYPE(Uri) * dest,\n\t\tconst URI_TYPE(Uri) * source, UriMemoryManager * memory) {\n\tif (source->pathHead == NULL) {\n\t\t/* No path component */\n\t\tdest->pathHead = NULL;\n\t\tdest->pathTail = NULL;\n\t} else {\n\t\t/* Copy list but not the text contained */\n\t\tURI_TYPE(PathSegment) * sourceWalker = source->pathHead;\n\t\tURI_TYPE(PathSegment) * destPrev = NULL;\n\t\tdo {\n\t\t\tURI_TYPE(PathSegment) * cur = memory->malloc(memory, sizeof(URI_TYPE(PathSegment)));\n\t\t\tif (cur == NULL) {\n\t\t\t\t/* Fix broken list */\n\t\t\t\tif (destPrev != NULL) {\n\t\t\t\t\tdestPrev->next = NULL;\n\t\t\t\t}\n\t\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t\t}\n\n\t\t\t/* From this functions usage we know that *\n\t\t\t * the dest URI cannot be uri->owner      */\n\t\t\tcur->text = sourceWalker->text;\n\t\t\tif (destPrev == NULL) {\n\t\t\t\t/* First segment ever */\n\t\t\t\tdest->pathHead = cur;\n\t\t\t} else {\n\t\t\t\tdestPrev->next = cur;\n\t\t\t}\n\t\t\tdestPrev = cur;\n\t\t\tsourceWalker = sourceWalker->next;\n\t\t} while (sourceWalker != NULL);\n\t\tdest->pathTail = destPrev;\n\t\tdest->pathTail->next = NULL;\n\t}\n\n\tdest->absolutePath = source->absolutePath;\n\treturn URI_TRUE;\n}\n\n\n\n/* Copies the authority part of an URI over to another. */\nUriBool URI_FUNC(CopyAuthority)(URI_TYPE(Uri) * dest,\n\t\tconst URI_TYPE(Uri) * source, UriMemoryManager * memory) {\n\t/* From this functions usage we know that *\n\t * the dest URI cannot be uri->owner      */\n\t\n\t/* Copy userInfo */\n\tdest->userInfo = source->userInfo;\n\n\t/* Copy hostText */\n\tdest->hostText = source->hostText;\n\n\t/* Copy hostData */\n\tif (source->hostData.ip4 != NULL) {\n\t\tdest->hostData.ip4 = memory->malloc(memory, sizeof(UriIp4));\n\t\tif (dest->hostData.ip4 == NULL) {\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\t\t*(dest->hostData.ip4) = *(source->hostData.ip4);\n\t\tdest->hostData.ip6 = NULL;\n\t\tdest->hostData.ipFuture.first = NULL;\n\t\tdest->hostData.ipFuture.afterLast = NULL;\n\t} else if (source->hostData.ip6 != NULL) {\n\t\tdest->hostData.ip4 = NULL;\n\t\tdest->hostData.ip6 = memory->malloc(memory, sizeof(UriIp6));\n\t\tif (dest->hostData.ip6 == NULL) {\n\t\t\treturn URI_FALSE; /* Raises malloc error */\n\t\t}\n\t\t*(dest->hostData.ip6) = *(source->hostData.ip6);\n\t\tdest->hostData.ipFuture.first = NULL;\n\t\tdest->hostData.ipFuture.afterLast = NULL;\n\t} else {\n\t\tdest->hostData.ip4 = NULL;\n\t\tdest->hostData.ip6 = NULL;\n\t\tdest->hostData.ipFuture = source->hostData.ipFuture;\n\t}\n\n\t/* Copy portText */\n\tdest->portText = source->portText;\n\n\treturn URI_TRUE;\n}\n\n\n\nUriBool URI_FUNC(FixAmbiguity)(URI_TYPE(Uri) * uri,\n\t\tUriMemoryManager * memory) {\n\tURI_TYPE(PathSegment) * segment;\n\n\tif (\t/* Case 1: absolute path, empty first segment */\n\t\t\t(uri->absolutePath\n\t\t\t&& (uri->pathHead != NULL)\n\t\t\t&& (uri->pathHead->text.afterLast == uri->pathHead->text.first))\n\n\t\t\t/* Case 2: relative path, empty first and second segment */\n\t\t\t|| (!uri->absolutePath\n\t\t\t&& (uri->pathHead != NULL)\n\t\t\t&& (uri->pathHead->next != NULL)\n\t\t\t&& (uri->pathHead->text.afterLast == uri->pathHead->text.first)\n\t\t\t&& (uri->pathHead->next->text.afterLast == uri->pathHead->next->text.first))) {\n\t\t/* NOOP */\n\t} else {\n\t\treturn URI_TRUE;\n\t}\n\n\tsegment = memory->malloc(memory, 1 * sizeof(URI_TYPE(PathSegment)));\n\tif (segment == NULL) {\n\t\treturn URI_FALSE; /* Raises malloc error */\n\t}\n\n\t/* Insert \".\" segment in front */\n\tsegment->next = uri->pathHead;\n\tsegment->text.first = URI_FUNC(ConstPwd);\n\tsegment->text.afterLast = URI_FUNC(ConstPwd) + 1;\n\turi->pathHead = segment;\n\treturn URI_TRUE;\n}\n\n\n\nvoid URI_FUNC(FixEmptyTrailSegment)(URI_TYPE(Uri) * uri,\n\t\tUriMemoryManager * memory) {\n\t/* Fix path if only one empty segment */\n\tif (!uri->absolutePath\n\t\t\t&& !URI_FUNC(IsHostSet)(uri)\n\t\t\t&& (uri->pathHead != NULL)\n\t\t\t&& (uri->pathHead->next == NULL)\n\t\t\t&& (uri->pathHead->text.first == uri->pathHead->text.afterLast)) {\n\t\tmemory->free(memory, uri->pathHead);\n\t\turi->pathHead = NULL;\n\t\turi->pathTail = NULL;\n\t}\n}\n\n\n\n#endif\n"], "filenames": ["src/UriCommon.c"], "buggy_code_start_loc": [77], "buggy_code_end_loc": [77], "fixing_code_start_loc": [78], "fixing_code_end_loc": [81], "type": "CWE-476", "message": "An issue was discovered in uriparser before 0.9.0. UriCommon.c allows attempted operations on NULL input via a uriResetUri* function.", "other": {"cve": {"id": "CVE-2018-19200", "sourceIdentifier": "cve@mitre.org", "published": "2018-11-12T15:29:00.337", "lastModified": "2018-12-12T14:16:05.367", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in uriparser before 0.9.0. UriCommon.c allows attempted operations on NULL input via a uriResetUri* function."}, {"lang": "es", "value": "Se ha descubierto un problema en versiones anteriores a la 0.9.0 de uriparser. UriCommon.c permite el intento de operaciones en entradas NULL mediante una funci\u00f3n uriResetUri*."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uriparser_project:uriparser:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.0", "matchCriteriaId": "2CDFDF1E-3FB8-4A74-875F-5F4857CE03E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.0", "matchCriteriaId": "8D9C360B-43DA-497A-BB54-6D312F42E4A0"}]}]}], "references": [{"url": "https://github.com/uriparser/uriparser/blob/uriparser-0.9.0/ChangeLog", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/uriparser/uriparser/commit/f58c25069cf4a986fe17a80c5b38687e31feb539", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00019.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uriparser/uriparser/commit/f58c25069cf4a986fe17a80c5b38687e31feb539"}}