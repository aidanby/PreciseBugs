{"buggy_code": ["'use strict';\n\nconst path = require('path');\nconst { promisify } = require('util');\nconst tmpDir = promisify(require('tmp').dir);\nconst fs = require('fs-extra');\nconst uuidv1 = require('uuid/v1');\nconst debug = require('debug')('git-diff-apply');\nconst utils = require('./utils');\nconst getRootDir = require('./get-root-dir');\nconst getSubDir = require('./get-sub-dir');\nconst gitInit = require('./git-init');\nconst gitStatus = require('./git-status');\nconst commit = require('./commit');\nconst checkOutTag = require('./check-out-tag');\nconst convertToObj = require('./convert-to-obj');\nconst resolveConflicts = require('./resolve-conflicts');\nconst commitAndTag = require('./commit-and-tag');\nconst gitRemoveAll = require('./git-remove-all');\nconst createCustomRemote = require('./create-custom-remote');\n\nconst { isGitClean } = gitStatus;\nconst { gitConfigInit } = gitInit;\n\nconst tempBranchName = uuidv1();\n\nasync function ensureDir(dir) {\n  debug('ensureDir', dir);\n  await fs.ensureDir(dir);\n}\n\nmodule.exports = async function gitDiffApply({\n  cwd = process.cwd(),\n  remoteUrl,\n  startTag,\n  endTag,\n  resolveConflicts: _resolveConflicts,\n  ignoredFiles = [],\n  reset,\n  init,\n  createCustomDiff,\n  startCommand,\n  endCommand\n}) {\n  let _tmpDir;\n  let tmpWorkingDir;\n\n  let hasConflicts;\n  let returnObject;\n\n  let isCodeUntracked;\n  let isCodeModified;\n\n  let root;\n\n  let err;\n\n  async function buildReturnObject() {\n    let from;\n\n    if (reset || init) {\n      from = {};\n    } else {\n      await checkOutTag(startTag, { cwd: _tmpDir });\n\n      from = convertToObj(_tmpDir, ignoredFiles);\n    }\n\n    await checkOutTag(endTag, { cwd: _tmpDir });\n\n    let to = convertToObj(_tmpDir, ignoredFiles);\n\n    return {\n      from,\n      to\n    };\n  }\n\n  async function namespaceRepoWithSubDir(subDir) {\n    let newTmpDir = await tmpDir();\n\n    await gitInit({ cwd: newTmpDir });\n\n    let newTmpSubDir = path.join(newTmpDir, subDir);\n\n    async function copyToSubDir(tag) {\n      await ensureDir(newTmpSubDir);\n\n      await checkOutTag(tag, { cwd: _tmpDir });\n\n      await utils.copy(_tmpDir, newTmpSubDir);\n\n      await commitAndTag(tag, { cwd: newTmpDir });\n    }\n\n    if (!(reset || init)) {\n      await copyToSubDir(startTag);\n\n      await gitRemoveAll({ cwd: newTmpDir });\n    }\n\n    await copyToSubDir(endTag);\n\n    _tmpDir = newTmpDir;\n    tmpWorkingDir = newTmpSubDir;\n  }\n\n  async function copy() {\n    await utils.copy(tmpWorkingDir, cwd);\n  }\n\n  async function resetIgnoredFiles(cwd) {\n    for (let ignoredFile of ignoredFiles) {\n      // An exist check is not good enough.\n      // `git checkout` will fail unless it is also tracked.\n      let isTracked = await utils.run(`git ls-files ${ignoredFile}`, { cwd });\n      if (isTracked) {\n        await utils.run(`git checkout -- ${ignoredFile}`, { cwd });\n      } else {\n        await fs.remove(path.join(cwd, ignoredFile));\n      }\n    }\n  }\n\n  async function createPatchFile() {\n    let patchFile = path.join(await tmpDir(), 'file.patch');\n    await utils.run(`git diff ${startTag} ${endTag} --binary > ${patchFile}`, { cwd: _tmpDir });\n    if (await fs.readFile(patchFile, 'utf8') !== '') {\n      return patchFile;\n    }\n  }\n\n  async function applyPatch(patchFile) {\n    // --whitespace=fix seems to prevent any unnecessary conflicts with line endings\n    // https://stackoverflow.com/questions/6308625/how-to-avoid-git-apply-changing-line-endings#comment54419617_11189296\n    await utils.run(`git apply --whitespace=fix ${patchFile}`, { cwd: _tmpDir });\n  }\n\n  async function go() {\n    if (reset || init) {\n      await checkOutTag(endTag, { cwd: _tmpDir });\n\n      isCodeUntracked = true;\n      isCodeModified = true;\n      if (reset) {\n        await utils.gitRemoveAll({ cwd: root });\n      }\n\n      await copy();\n\n      await utils.run('git reset', { cwd });\n\n      await resetIgnoredFiles(cwd);\n\n      return;\n    }\n\n    await checkOutTag(startTag, { cwd: _tmpDir });\n\n    await utils.run(`git branch ${tempBranchName}`, { cwd: _tmpDir });\n    await utils.run(`git checkout ${tempBranchName}`, { cwd: _tmpDir });\n\n    let patchFile = await createPatchFile();\n    if (!patchFile) {\n      return;\n    }\n\n    await applyPatch(patchFile);\n\n    await resetIgnoredFiles(tmpWorkingDir);\n\n    let wereAnyChanged = !await isGitClean({ cwd: _tmpDir });\n\n    if (wereAnyChanged) {\n      await commit({ cwd: _tmpDir });\n\n      let sha = await utils.run('git rev-parse HEAD', { cwd: _tmpDir });\n\n      await utils.run(`git remote add ${tempBranchName} ${_tmpDir}`, { cwd });\n      await utils.run(`git fetch --no-tags ${tempBranchName}`, { cwd });\n\n      try {\n        await utils.run(`git cherry-pick --no-commit ${sha.trim()}`, { cwd });\n      } catch (err) {\n        hasConflicts = true;\n      }\n\n      await utils.run(`git remote remove ${tempBranchName}`, { cwd });\n    }\n  }\n\n  try {\n    if (startTag === endTag && !(reset || init)) {\n      throw 'Tags match, nothing to apply';\n    }\n\n    let isClean;\n\n    try {\n      isClean = await isGitClean({ cwd });\n    } catch (err) {\n      throw 'Not a git repository';\n    }\n\n    if (!isClean) {\n      throw 'You must start with a clean working directory';\n    }\n\n    if (createCustomDiff) {\n      let tmpPath = await createCustomRemote({\n        startCommand,\n        endCommand,\n        startTag,\n        endTag,\n        reset,\n        init\n      });\n\n      remoteUrl = tmpPath;\n    }\n\n    _tmpDir = await tmpDir();\n    tmpWorkingDir = _tmpDir;\n\n    await utils.run(`git clone ${remoteUrl} ${_tmpDir}`);\n\n    // needed because we are going to be committing in here\n    await gitConfigInit({ cwd: _tmpDir });\n\n    returnObject = await buildReturnObject();\n\n    root = await getRootDir({ cwd });\n    let subDir = await getSubDir({ cwd });\n    if (subDir) {\n      debug('subDir', subDir);\n\n      await namespaceRepoWithSubDir(subDir);\n    }\n\n    await go();\n\n    debug('success');\n  } catch (_err) {\n    err = _err;\n\n    try {\n      if (isCodeUntracked) {\n        await utils.run('git clean -f', { cwd });\n      }\n      if (isCodeModified) {\n        await utils.run('git reset --hard', { cwd });\n      }\n    } catch (err2) {\n      throw {\n        err,\n        err2\n      };\n    }\n  }\n\n  if (err) {\n    debug('failure');\n\n    throw err;\n  }\n\n  if (hasConflicts && _resolveConflicts) {\n    returnObject.resolveConflictsProcess = resolveConflicts({ cwd });\n  }\n\n  return returnObject;\n};\n\nmodule.exports.run = utils.run;\nmodule.exports.gitInit = gitInit;\nmodule.exports.gitStatus = gitStatus;\nmodule.exports.isGitClean = isGitClean;\nmodule.exports.gitRemoveAll = gitRemoveAll;\n"], "fixing_code": ["'use strict';\n\nconst path = require('path');\nconst { promisify } = require('util');\nconst tmpDir = promisify(require('tmp').dir);\nconst fs = require('fs-extra');\nconst uuidv1 = require('uuid/v1');\nconst debug = require('debug')('git-diff-apply');\nconst utils = require('./utils');\nconst getRootDir = require('./get-root-dir');\nconst getSubDir = require('./get-sub-dir');\nconst gitInit = require('./git-init');\nconst gitStatus = require('./git-status');\nconst commit = require('./commit');\nconst checkOutTag = require('./check-out-tag');\nconst convertToObj = require('./convert-to-obj');\nconst resolveConflicts = require('./resolve-conflicts');\nconst commitAndTag = require('./commit-and-tag');\nconst gitRemoveAll = require('./git-remove-all');\nconst createCustomRemote = require('./create-custom-remote');\nconst { runWithSpawn } = require('./run');\n\nconst { isGitClean } = gitStatus;\nconst { gitConfigInit } = gitInit;\n\nconst tempBranchName = uuidv1();\n\nasync function ensureDir(dir) {\n  debug('ensureDir', dir);\n  await fs.ensureDir(dir);\n}\n\nmodule.exports = async function gitDiffApply({\n  cwd = process.cwd(),\n  remoteUrl,\n  startTag,\n  endTag,\n  resolveConflicts: _resolveConflicts,\n  ignoredFiles = [],\n  reset,\n  init,\n  createCustomDiff,\n  startCommand,\n  endCommand\n}) {\n  let _tmpDir;\n  let tmpWorkingDir;\n\n  let hasConflicts;\n  let returnObject;\n\n  let isCodeUntracked;\n  let isCodeModified;\n\n  let root;\n\n  let err;\n\n  async function buildReturnObject() {\n    let from;\n\n    if (reset || init) {\n      from = {};\n    } else {\n      await checkOutTag(startTag, { cwd: _tmpDir });\n\n      from = convertToObj(_tmpDir, ignoredFiles);\n    }\n\n    await checkOutTag(endTag, { cwd: _tmpDir });\n\n    let to = convertToObj(_tmpDir, ignoredFiles);\n\n    return {\n      from,\n      to\n    };\n  }\n\n  async function namespaceRepoWithSubDir(subDir) {\n    let newTmpDir = await tmpDir();\n\n    await gitInit({ cwd: newTmpDir });\n\n    let newTmpSubDir = path.join(newTmpDir, subDir);\n\n    async function copyToSubDir(tag) {\n      await ensureDir(newTmpSubDir);\n\n      await checkOutTag(tag, { cwd: _tmpDir });\n\n      await utils.copy(_tmpDir, newTmpSubDir);\n\n      await commitAndTag(tag, { cwd: newTmpDir });\n    }\n\n    if (!(reset || init)) {\n      await copyToSubDir(startTag);\n\n      await gitRemoveAll({ cwd: newTmpDir });\n    }\n\n    await copyToSubDir(endTag);\n\n    _tmpDir = newTmpDir;\n    tmpWorkingDir = newTmpSubDir;\n  }\n\n  async function copy() {\n    await utils.copy(tmpWorkingDir, cwd);\n  }\n\n  async function resetIgnoredFiles(cwd) {\n    for (let ignoredFile of ignoredFiles) {\n      // An exist check is not good enough.\n      // `git checkout` will fail unless it is also tracked.\n      let isTracked = await utils.run(`git ls-files ${ignoredFile}`, { cwd });\n      if (isTracked) {\n        await utils.run(`git checkout -- ${ignoredFile}`, { cwd });\n      } else {\n        await fs.remove(path.join(cwd, ignoredFile));\n      }\n    }\n  }\n\n  async function createPatchFile() {\n    let patchFile = path.join(await tmpDir(), 'file.patch');\n    await utils.run(`git diff ${startTag} ${endTag} --binary > ${patchFile}`, { cwd: _tmpDir });\n    if (await fs.readFile(patchFile, 'utf8') !== '') {\n      return patchFile;\n    }\n  }\n\n  async function applyPatch(patchFile) {\n    // --whitespace=fix seems to prevent any unnecessary conflicts with line endings\n    // https://stackoverflow.com/questions/6308625/how-to-avoid-git-apply-changing-line-endings#comment54419617_11189296\n    await utils.run(`git apply --whitespace=fix ${patchFile}`, { cwd: _tmpDir });\n  }\n\n  async function go() {\n    if (reset || init) {\n      await checkOutTag(endTag, { cwd: _tmpDir });\n\n      isCodeUntracked = true;\n      isCodeModified = true;\n      if (reset) {\n        await utils.gitRemoveAll({ cwd: root });\n      }\n\n      await copy();\n\n      await utils.run('git reset', { cwd });\n\n      await resetIgnoredFiles(cwd);\n\n      return;\n    }\n\n    await checkOutTag(startTag, { cwd: _tmpDir });\n\n    await utils.run(`git branch ${tempBranchName}`, { cwd: _tmpDir });\n    await utils.run(`git checkout ${tempBranchName}`, { cwd: _tmpDir });\n\n    let patchFile = await createPatchFile();\n    if (!patchFile) {\n      return;\n    }\n\n    await applyPatch(patchFile);\n\n    await resetIgnoredFiles(tmpWorkingDir);\n\n    let wereAnyChanged = !await isGitClean({ cwd: _tmpDir });\n\n    if (wereAnyChanged) {\n      await commit({ cwd: _tmpDir });\n\n      let sha = await utils.run('git rev-parse HEAD', { cwd: _tmpDir });\n\n      await utils.run(`git remote add ${tempBranchName} ${_tmpDir}`, { cwd });\n      await utils.run(`git fetch --no-tags ${tempBranchName}`, { cwd });\n\n      try {\n        await utils.run(`git cherry-pick --no-commit ${sha.trim()}`, { cwd });\n      } catch (err) {\n        hasConflicts = true;\n      }\n\n      await utils.run(`git remote remove ${tempBranchName}`, { cwd });\n    }\n  }\n\n  try {\n    if (startTag === endTag && !(reset || init)) {\n      throw 'Tags match, nothing to apply';\n    }\n\n    let isClean;\n\n    try {\n      isClean = await isGitClean({ cwd });\n    } catch (err) {\n      throw 'Not a git repository';\n    }\n\n    if (!isClean) {\n      throw 'You must start with a clean working directory';\n    }\n\n    if (createCustomDiff) {\n      let tmpPath = await createCustomRemote({\n        startCommand,\n        endCommand,\n        startTag,\n        endTag,\n        reset,\n        init\n      });\n\n      remoteUrl = tmpPath;\n    }\n\n    _tmpDir = await tmpDir();\n    tmpWorkingDir = _tmpDir;\n\n    await runWithSpawn('git', ['clone', remoteUrl, _tmpDir]);\n\n    // needed because we are going to be committing in here\n    await gitConfigInit({ cwd: _tmpDir });\n\n    returnObject = await buildReturnObject();\n\n    root = await getRootDir({ cwd });\n    let subDir = await getSubDir({ cwd });\n    if (subDir) {\n      debug('subDir', subDir);\n\n      await namespaceRepoWithSubDir(subDir);\n    }\n\n    await go();\n\n    debug('success');\n  } catch (_err) {\n    err = _err;\n\n    try {\n      if (isCodeUntracked) {\n        await utils.run('git clean -f', { cwd });\n      }\n      if (isCodeModified) {\n        await utils.run('git reset --hard', { cwd });\n      }\n    } catch (err2) {\n      throw {\n        err,\n        err2\n      };\n    }\n  }\n\n  if (err) {\n    debug('failure');\n\n    throw err;\n  }\n\n  if (hasConflicts && _resolveConflicts) {\n    returnObject.resolveConflictsProcess = resolveConflicts({ cwd });\n  }\n\n  return returnObject;\n};\n\nmodule.exports.run = utils.run;\nmodule.exports.gitInit = gitInit;\nmodule.exports.gitStatus = gitStatus;\nmodule.exports.isGitClean = isGitClean;\nmodule.exports.gitRemoveAll = gitRemoveAll;\n"], "filenames": ["src/index.js"], "buggy_code_start_loc": [20], "buggy_code_end_loc": [226], "fixing_code_start_loc": [21], "fixing_code_end_loc": [227], "type": "CWE-78", "message": "In \"index.js\" file line 240, the run command executes the git command with a user controlled variable called remoteUrl. This affects git-diff-apply all versions prior to 0.22.2.", "other": {"cve": {"id": "CVE-2019-10776", "sourceIdentifier": "report@snyk.io", "published": "2020-01-07T19:15:10.413", "lastModified": "2020-01-12T22:18:05.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In \"index.js\" file line 240, the run command executes the git command with a user controlled variable called remoteUrl. This affects git-diff-apply all versions prior to 0.22.2."}, {"lang": "es", "value": "En la l\u00ednea 240 del archivo \"index.js\", el comando run ejecuta el comando git con una variable controlada por el usuario llamada remoteUrl. Esto afecta a git-diff-apply todas las versiones anteriores a la versi\u00f3n  0.22.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:git-diff-apply_project:git-diff-apply:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.22.2", "matchCriteriaId": "39635B3E-B046-459A-A5B5-6BA1F8690845"}]}]}], "references": [{"url": "https://github.com/kellyselden/git-diff-apply/commit/106d61d3ae723b4257c2a13e67b95eb40a27e0b5", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-GITDIFFAPPLY-540774", "source": "nvd@nist.gov", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-GITDIFFAPPLY-540774,", "source": "report@snyk.io", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/kellyselden/git-diff-apply/commit/106d61d3ae723b4257c2a13e67b95eb40a27e0b5"}}