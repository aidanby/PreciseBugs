{"buggy_code": ["/* $OpenBSD: auth-passwd.c,v 1.44 2014/07/15 15:54:14 millert Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Password authentication.  This file contains the functions to check whether\n * the password is valid for the user.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 1999 Dug Song.  All rights reserved.\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"packet.h\"\n#include \"buffer.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"key.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n\nextern Buffer loginmsg;\nextern ServerOptions options;\n\n#ifdef HAVE_LOGIN_CAP\nextern login_cap_t *lc;\n#endif\n\n\n#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n\nvoid\ndisable_forwarding(void)\n{\n\tno_port_forwarding_flag = 1;\n\tno_agent_forwarding_flag = 1;\n\tno_x11_forwarding_flag = 1;\n}\n\n/*\n * Tries to authenticate the user using password.  Returns true if\n * authentication succeeds.\n */\nint\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}\n\n#ifdef BSD_AUTH\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tchar buf[256];\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tsnprintf(buf, sizeof(buf),\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\");\n\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tsnprintf(buf, sizeof(buf),\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\");\n\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n\t}\n}\n\nint\nsys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tdisable_forwarding();\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}\n#elif !defined(CUSTOM_SYS_AUTH_PASSWD)\nint\nsys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}\n#endif\n"], "fixing_code": ["/* $OpenBSD: auth-passwd.c,v 1.45 2016/07/21 01:39:35 dtucker Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Password authentication.  This file contains the functions to check whether\n * the password is valid for the user.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * Copyright (c) 1999 Dug Song.  All rights reserved.\n * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"includes.h\"\n\n#include <sys/types.h>\n\n#include <pwd.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"packet.h\"\n#include \"buffer.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"key.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"auth-options.h\"\n\nextern Buffer loginmsg;\nextern ServerOptions options;\n\n#ifdef HAVE_LOGIN_CAP\nextern login_cap_t *lc;\n#endif\n\n\n#define DAY\t\t(24L * 60 * 60) /* 1 day in seconds */\n#define TWO_WEEKS\t(2L * 7 * DAY)\t/* 2 weeks in seconds */\n\n#define MAX_PASSWORD_LEN\t1024\n\nvoid\ndisable_forwarding(void)\n{\n\tno_port_forwarding_flag = 1;\n\tno_agent_forwarding_flag = 1;\n\tno_x11_forwarding_flag = 1;\n}\n\n/*\n * Tries to authenticate the user using password.  Returns true if\n * authentication succeeds.\n */\nint\nauth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t\t/* Fall back to ordinary passwd authentication. */\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}\n\n#ifdef BSD_AUTH\nstatic void\nwarn_expiry(Authctxt *authctxt, auth_session_t *as)\n{\n\tchar buf[256];\n\tquad_t pwtimeleft, actimeleft, daysleft, pwwarntime, acwarntime;\n\n\tpwwarntime = acwarntime = TWO_WEEKS;\n\n\tpwtimeleft = auth_check_change(as);\n\tactimeleft = auth_check_expire(as);\n#ifdef HAVE_LOGIN_CAP\n\tif (authctxt->valid) {\n\t\tpwwarntime = login_getcaptime(lc, \"password-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t\tacwarntime = login_getcaptime(lc, \"expire-warn\", TWO_WEEKS,\n\t\t    TWO_WEEKS);\n\t}\n#endif\n\tif (pwtimeleft != 0 && pwtimeleft < pwwarntime) {\n\t\tdaysleft = pwtimeleft / DAY + 1;\n\t\tsnprintf(buf, sizeof(buf),\n\t\t    \"Your password will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\");\n\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n\t}\n\tif (actimeleft != 0 && actimeleft < acwarntime) {\n\t\tdaysleft = actimeleft / DAY + 1;\n\t\tsnprintf(buf, sizeof(buf),\n\t\t    \"Your account will expire in %lld day%s.\\n\",\n\t\t    daysleft, daysleft == 1 ? \"\" : \"s\");\n\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n\t}\n}\n\nint\nsys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tauth_session_t *as;\n\tstatic int expire_checked = 0;\n\n\tas = auth_usercheck(pw->pw_name, authctxt->style, \"auth-ssh\",\n\t    (char *)password);\n\tif (as == NULL)\n\t\treturn (0);\n\tif (auth_getstate(as) & AUTH_PWEXPIRED) {\n\t\tauth_close(as);\n\t\tdisable_forwarding();\n\t\tauthctxt->force_pwchange = 1;\n\t\treturn (1);\n\t} else {\n\t\tif (!expire_checked) {\n\t\t\texpire_checked = 1;\n\t\t\twarn_expiry(authctxt, as);\n\t\t}\n\t\treturn (auth_close(as));\n\t}\n}\n#elif !defined(CUSTOM_SYS_AUTH_PASSWD)\nint\nsys_auth_passwd(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd *pw = authctxt->pw;\n\tchar *encrypted_password, *salt = NULL;\n\n\t/* Just use the supplied fake password if authctxt is invalid */\n\tchar *pw_password = authctxt->valid ? shadow_pw(pw) : pw->pw_passwd;\n\n\t/* Check for users with no password. */\n\tif (strcmp(pw_password, \"\") == 0 && strcmp(password, \"\") == 0)\n\t\treturn (1);\n\n\t/*\n\t * Encrypt the candidate password using the proper salt, or pass a\n\t * NULL and let xcrypt pick one.\n\t */\n\tif (authctxt->valid && pw_password[0] && pw_password[1])\n\t\tsalt = pw_password;\n\tencrypted_password = xcrypt(password, salt);\n\n\t/*\n\t * Authentication is accepted if the encrypted passwords\n\t * are identical.\n\t */\n\treturn encrypted_password != NULL &&\n\t    strcmp(encrypted_password, pw_password) == 0;\n}\n#endif\n"], "filenames": ["auth-passwd.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [88], "fixing_code_start_loc": [1], "fixing_code_end_loc": [94], "type": "CWE-20", "message": "The auth_password function in auth-passwd.c in sshd in OpenSSH before 7.3 does not limit password lengths for password authentication, which allows remote attackers to cause a denial of service (crypt CPU consumption) via a long string.", "other": {"cve": {"id": "CVE-2016-6515", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-07T21:59:09.943", "lastModified": "2022-12-13T12:15:23.727", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The auth_password function in auth-passwd.c in sshd in OpenSSH before 7.3 does not limit password lengths for password authentication, which allows remote attackers to cause a denial of service (crypt CPU consumption) via a long string."}, {"lang": "es", "value": "La funci\u00f3n auth_password en auth-passwd.c en sshd en OpenSSH en versiones anteriores a 7.3 no limita longitudes de contrase\u00f1a para autenticaci\u00f3n de contrase\u00f1a, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (consumo de CPU clave) a trav\u00e9s de una cadena larga."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:p2:*:*:*:*:*:*", "versionEndIncluding": "7.2", "matchCriteriaId": "4AFA4267-E15B-4826-9B98-63F68AB1627F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2016/08/01/2", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://packetstormsecurity.com/files/140070/OpenSSH-7.2-Denial-Of-Service.html", "source": "cve@mitre.org"}, {"url": "http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/92212", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1036487", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2017:2029", "source": "cve@mitre.org"}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org"}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-676336.pdf", "source": "cve@mitre.org"}, {"url": "https://github.com/openssh/openssh-portable/commit/fcd135c9df440bcd2d5870405ad3311743d78d97", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/09/msg00010.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X2L6RW34VFNXYNVVN2CN73YAGJ5VMTFU/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.FreeBSD.org/advisories/FreeBSD-SA-17:06.openssh.asc", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20171130-0003/", "source": "cve@mitre.org"}, {"url": "https://support.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbhf03779en_us", "source": "cve@mitre.org"}, {"url": "https://www.exploit-db.com/exploits/40888/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/openssh/openssh-portable/commit/fcd135c9df440bcd2d5870405ad3311743d78d97"}}