{"buggy_code": ["require 'puppet/ssl/host'\nrequire 'puppet/ssl/certificate_request'\nrequire 'puppet/util/cacher'\n\n# The class that knows how to sign certificates.  It creates\n# a 'special' SSL::Host whose name is 'ca', thus indicating\n# that, well, it's the CA.  There's some magic in the\n# indirector/ssl_file terminus base class that does that\n# for us.\n#   This class mostly just signs certs for us, but\n# it can also be seen as a general interface into all of the\n# SSL stuff.\nclass Puppet::SSL::CertificateAuthority\n  # We will only sign extensions on this whitelist, ever.  Any CSR with a\n  # requested extension that we don't recognize is rejected, against the risk\n  # that it will introduce some security issue through our ignorance of it.\n  #\n  # Adding an extension to this whitelist simply means we will consider it\n  # further, not that we will always accept a certificate with an extension\n  # requested on this list.\n  RequestExtensionWhitelist = %w{subjectAltName}\n\n  require 'puppet/ssl/certificate_factory'\n  require 'puppet/ssl/inventory'\n  require 'puppet/ssl/certificate_revocation_list'\n  require 'puppet/ssl/certificate_authority/interface'\n  require 'puppet/network/authstore'\n\n  class CertificateVerificationError < RuntimeError\n    attr_accessor :error_code\n\n    def initialize(code)\n      @error_code = code\n    end\n  end\n\n  class CertificateSigningError < RuntimeError\n    attr_accessor :host\n\n    def initialize(host)\n      @host = host\n    end\n  end\n\n  class << self\n    include Puppet::Util::Cacher\n\n    cached_attr(:singleton_instance) { new }\n  end\n\n  def self.ca?\n    return false unless Puppet[:ca]\n    return false unless Puppet.run_mode.master?\n    true\n  end\n\n  # If this process can function as a CA, then return a singleton\n  # instance.\n  def self.instance\n    return nil unless ca?\n\n    singleton_instance\n  end\n\n  attr_reader :name, :host\n\n  # Create and run an applicator.  I wanted to build an interface where you could do\n  # something like 'ca.apply(:generate).to(:all) but I don't think it's really possible.\n  def apply(method, options)\n    raise ArgumentError, \"You must specify the hosts to apply to; valid values are an array or the symbol :all\" unless options[:to]\n    applier = Interface.new(method, options)\n    applier.apply(self)\n  end\n\n  # If autosign is configured, then autosign all CSRs that match our configuration.\n  def autosign\n    return unless auto = autosign?\n\n    store = nil\n    store = autosign_store(auto) if auto != true\n\n    Puppet::SSL::CertificateRequest.search(\"*\").each do |csr|\n      sign(csr.name) if auto == true or store.allowed?(csr.name, \"127.1.1.1\")\n    end\n  end\n\n  # Do we autosign?  This returns true, false, or a filename.\n  def autosign?\n    auto = Puppet[:autosign]\n    return false if ['false', false].include?(auto)\n    return true if ['true', true].include?(auto)\n\n    raise ArgumentError, \"The autosign configuration '#{auto}' must be a fully qualified file\" unless auto =~ /^\\//\n    FileTest.exist?(auto) && auto\n  end\n\n  # Create an AuthStore for autosigning.\n  def autosign_store(file)\n    auth = Puppet::Network::AuthStore.new\n    File.readlines(file).each do |line|\n      next if line =~ /^\\s*#/\n      next if line =~ /^\\s*$/\n      auth.allow(line.chomp)\n    end\n\n    auth\n  end\n\n  # Retrieve (or create, if necessary) the certificate revocation list.\n  def crl\n    unless defined?(@crl)\n      unless @crl = Puppet::SSL::CertificateRevocationList.find(Puppet::SSL::CA_NAME)\n        @crl = Puppet::SSL::CertificateRevocationList.new(Puppet::SSL::CA_NAME)\n        @crl.generate(host.certificate.content, host.key.content)\n        @crl.save\n      end\n    end\n    @crl\n  end\n\n  # Delegate this to our Host class.\n  def destroy(name)\n    Puppet::SSL::Host.destroy(name)\n  end\n\n  # Generate a new certificate.\n  def generate(name, options = {})\n    raise ArgumentError, \"A Certificate already exists for #{name}\" if Puppet::SSL::Certificate.find(name)\n\n    # Pass on any requested subjectAltName field.\n    san = options[:dns_alt_names]\n\n    host = Puppet::SSL::Host.new(name)\n    host.generate_certificate_request(:dns_alt_names => san)\n    sign(name, !!san)\n  end\n\n  # Generate our CA certificate.\n  def generate_ca_certificate\n    generate_password unless password?\n\n    host.generate_key unless host.key\n\n    # Create a new cert request.  We do this specially, because we don't want\n    # to actually save the request anywhere.\n    request = Puppet::SSL::CertificateRequest.new(host.name)\n\n    # We deliberately do not put any subjectAltName in here: the CA\n    # certificate absolutely does not need them. --daniel 2011-10-13\n    request.generate(host.key)\n\n    # Create a self-signed certificate.\n    @certificate = sign(host.name, false, request)\n\n    # And make sure we initialize our CRL.\n    crl\n  end\n\n  def initialize\n    Puppet.settings.use :main, :ssl, :ca\n\n    @name = Puppet[:certname]\n\n    @host = Puppet::SSL::Host.new(Puppet::SSL::Host.ca_name)\n\n    setup\n  end\n\n  # Retrieve (or create, if necessary) our inventory manager.\n  def inventory\n    @inventory ||= Puppet::SSL::Inventory.new\n  end\n\n  # Generate a new password for the CA.\n  def generate_password\n    pass = \"\"\n    20.times { pass += (rand(74) + 48).chr }\n\n    begin\n      Puppet.settings.write(:capass) { |f| f.print pass }\n    rescue Errno::EACCES => detail\n      raise Puppet::Error, \"Could not write CA password: #{detail}\"\n    end\n\n    @password = pass\n\n    pass\n  end\n\n  # List all signed certificates.\n  def list\n    Puppet::SSL::Certificate.search(\"*\").collect { |c| c.name }\n  end\n\n  # Read the next serial from the serial file, and increment the\n  # file so this one is considered used.\n  def next_serial\n    serial = nil\n\n    # This is slightly odd.  If the file doesn't exist, our readwritelock creates\n    # it, but with a mode we can't actually read in some cases.  So, use\n    # a default before the lock.\n    serial = 0x1 unless FileTest.exist?(Puppet[:serial])\n\n    Puppet.settings.readwritelock(:serial) { |f|\n      serial ||= File.read(Puppet.settings[:serial]).chomp.hex if FileTest.exist?(Puppet[:serial])\n\n      # We store the next valid serial, not the one we just used.\n      f << \"%04X\" % (serial + 1)\n    }\n\n    serial\n  end\n\n  # Does the password file exist?\n  def password?\n    FileTest.exist? Puppet[:capass]\n  end\n\n  # Print a given host's certificate as text.\n  def print(name)\n    (cert = Puppet::SSL::Certificate.find(name)) ? cert.to_text : nil\n  end\n\n  # Revoke a given certificate.\n  def revoke(name)\n    raise ArgumentError, \"Cannot revoke certificates when the CRL is disabled\" unless crl\n\n    if cert = Puppet::SSL::Certificate.find(name)\n      serial = cert.content.serial\n    elsif ! serial = inventory.serial(name)\n      raise ArgumentError, \"Could not find a serial number for #{name}\"\n    end\n    crl.revoke(serial, host.key.content)\n  end\n\n  # This initializes our CA so it actually works.  This should be a private\n  # method, except that you can't any-instance stub private methods, which is\n  # *awesome*.  This method only really exists to provide a stub-point during\n  # testing.\n  def setup\n    generate_ca_certificate unless @host.certificate\n  end\n\n  # Sign a given certificate request.\n  def sign(hostname, allow_dns_alt_names = false, self_signing_csr = nil)\n    # This is a self-signed certificate\n    if self_signing_csr\n      # # This is a self-signed certificate, which is for the CA.  Since this\n      # # forces the certificate to be self-signed, anyone who manages to trick\n      # # the system into going through this path gets a certificate they could\n      # # generate anyway.  There should be no security risk from that.\n      csr = self_signing_csr\n      cert_type = :ca\n      issuer = csr.content\n    else\n      allow_dns_alt_names = true if hostname == Puppet[:certname].downcase\n      unless csr = Puppet::SSL::CertificateRequest.find(hostname)\n        raise ArgumentError, \"Could not find certificate request for #{hostname}\"\n      end\n\n      cert_type = :server\n      issuer = host.certificate.content\n\n      # Make sure that the CSR conforms to our internal signing policies.\n      # This will raise if the CSR doesn't conform, but just in case...\n      check_internal_signing_policies(hostname, csr, allow_dns_alt_names) or\n        raise CertificateSigningError.new(hostname), \"CSR had an unknown failure checking internal signing policies, will not sign!\"\n    end\n\n    cert = Puppet::SSL::Certificate.new(hostname)\n    cert.content = Puppet::SSL::CertificateFactory.\n      build(cert_type, csr, issuer, next_serial)\n    cert.content.sign(host.key.content, OpenSSL::Digest::SHA1.new)\n\n    Puppet.notice \"Signed certificate request for #{hostname}\"\n\n    # Add the cert to the inventory before we save it, since\n    # otherwise we could end up with it being duplicated, if\n    # this is the first time we build the inventory file.\n    inventory.add(cert)\n\n    # Save the now-signed cert.  This should get routed correctly depending\n    # on the certificate type.\n    cert.save\n\n    # And remove the CSR if this wasn't self signed.\n    Puppet::SSL::CertificateRequest.destroy(csr.name) unless self_signing_csr\n\n    cert\n  end\n\n  def check_internal_signing_policies(hostname, csr, allow_dns_alt_names)\n    # Reject unknown request extensions.\n    unknown_req = csr.request_extensions.\n      reject {|x| RequestExtensionWhitelist.include? x[\"oid\"] }\n\n    if unknown_req and not unknown_req.empty?\n      names = unknown_req.map {|x| x[\"oid\"] }.sort.uniq.join(\", \")\n      raise CertificateSigningError.new(hostname), \"CSR has request extensions that are not permitted: #{names}\"\n    end\n\n    # Wildcards: we don't allow 'em at any point.\n    #\n    # The stringification here makes the content visible, and saves us having\n    # to scrobble through the content of the CSR subject field to make sure it\n    # is what we expect where we expect it.\n    if csr.content.subject.to_s.include? '*'\n      raise CertificateSigningError.new(hostname), \"CSR subject contains a wildcard, which is not allowed: #{csr.content.subject.to_s}\"\n    end\n\n    unless csr.subject_alt_names.empty?\n      # If you alt names are allowed, they are required. Otherwise they are\n      # disallowed. Self-signed certs are implicitly trusted, however.\n      unless allow_dns_alt_names\n        raise CertificateSigningError.new(hostname), \"CSR '#{csr.name}' contains subject alternative names (#{csr.subject_alt_names.join(', ')}), which are disallowed. Use `puppet cert --allow-dns-alt-names sign #{csr.name}` to sign this request.\"\n      end\n\n      # If subjectAltNames are present, validate that they are only for DNS\n      # labels, not any other kind.\n      unless csr.subject_alt_names.all? {|x| x =~ /^DNS:/ }\n        raise CertificateSigningError.new(hostname), \"CSR '#{csr.name}' contains a subjectAltName outside the DNS label space: #{csr.subject_alt_names.join(', ')}.  To continue, this CSR needs to be cleaned.\"\n      end\n\n      # Check for wildcards in the subjectAltName fields too.\n      if csr.subject_alt_names.any? {|x| x.include? '*' }\n        raise CertificateSigningError.new(hostname), \"CSR '#{csr.name}' subjectAltName contains a wildcard, which is not allowed: #{csr.subject_alt_names.join(', ')}  To continue, this CSR needs to be cleaned.\"\n      end\n    end\n\n    return true                 # good enough for us!\n  end\n\n  # Verify a given host's certificate.\n  def verify(name)\n    unless cert = Puppet::SSL::Certificate.find(name)\n      raise ArgumentError, \"Could not find a certificate for #{name}\"\n    end\n    store = OpenSSL::X509::Store.new\n    store.add_file Puppet[:cacert]\n    store.add_crl crl.content if self.crl\n    store.purpose = OpenSSL::X509::PURPOSE_SSL_CLIENT\n    store.flags = OpenSSL::X509::V_FLAG_CRL_CHECK_ALL|OpenSSL::X509::V_FLAG_CRL_CHECK if Puppet.settings[:certificate_revocation]\n\n    raise CertificateVerificationError.new(store.error), store.error_string unless store.verify(cert.content)\n  end\n\n  def fingerprint(name, md = :MD5)\n    unless cert = Puppet::SSL::Certificate.find(name) || Puppet::SSL::CertificateRequest.find(name)\n      raise ArgumentError, \"Could not find a certificate or csr for #{name}\"\n    end\n    cert.fingerprint(md)\n  end\n\n  # List the waiting certificate requests.\n  def waiting?\n    Puppet::SSL::CertificateRequest.search(\"*\").collect { |r| r.name }\n  end\nend\n", "#!/usr/bin/env ruby\n\nrequire File.dirname(__FILE__) + '/../../spec_helper'\n\nrequire 'puppet/ssl/certificate_authority'\n\ndescribe Puppet::SSL::CertificateAuthority do\n  after do\n    Puppet::Util::Cacher.expire\n    Puppet.settings.clearused\n  end\n\n  def stub_ca_host\n    @key = mock 'key'\n    @key.stubs(:content).returns \"cakey\"\n    @cacert = mock 'certificate'\n    @cacert.stubs(:content).returns \"cacertificate\"\n\n    @host = stub 'ssl_host', :key => @key, :certificate => @cacert, :name => Puppet::SSL::Host.ca_name\n  end\n\n  it \"should have a class method for returning a singleton instance\" do\n    Puppet::SSL::CertificateAuthority.should respond_to(:instance)\n  end\n\n  describe \"when finding an existing instance\" do\n    describe \"and the host is a CA host and the run_mode is master\" do\n      before do\n        Puppet.settings.stubs(:value).with(:ca).returns true\n        Puppet.run_mode.stubs(:master?).returns true\n\n        @ca = mock('ca')\n        Puppet::SSL::CertificateAuthority.stubs(:new).returns @ca\n      end\n\n      it \"should return an instance\" do\n        Puppet::SSL::CertificateAuthority.instance.should equal(@ca)\n      end\n\n      it \"should always return the same instance\" do\n        Puppet::SSL::CertificateAuthority.instance.should equal(Puppet::SSL::CertificateAuthority.instance)\n      end\n    end\n\n    describe \"and the host is not a CA host\" do\n      it \"should return nil\" do\n        Puppet.settings.stubs(:value).with(:ca).returns false\n        Puppet.run_mode.stubs(:master?).returns true\n\n        ca = mock('ca')\n        Puppet::SSL::CertificateAuthority.expects(:new).never\n        Puppet::SSL::CertificateAuthority.instance.should be_nil\n      end\n    end\n\n    describe \"and the run_mode is not master\" do\n      it \"should return nil\" do\n        Puppet.settings.stubs(:value).with(:ca).returns true\n        Puppet.run_mode.stubs(:master?).returns false\n\n        ca = mock('ca')\n        Puppet::SSL::CertificateAuthority.expects(:new).never\n        Puppet::SSL::CertificateAuthority.instance.should be_nil\n      end\n    end\n  end\n\n  describe \"when initializing\" do\n    before do\n      Puppet.settings.stubs(:use)\n      Puppet.settings.stubs(:value).returns \"ca_testing\"\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:setup)\n    end\n\n    it \"should always set its name to the value of :certname\" do\n      Puppet.settings.expects(:value).with(:certname).returns \"ca_testing\"\n\n      Puppet::SSL::CertificateAuthority.new.name.should == \"ca_testing\"\n    end\n\n    it \"should create an SSL::Host instance whose name is the 'ca_name'\" do\n      Puppet::SSL::Host.expects(:ca_name).returns \"caname\"\n\n      host = stub 'host'\n      Puppet::SSL::Host.expects(:new).with(\"caname\").returns host\n\n      Puppet::SSL::CertificateAuthority.new\n    end\n\n    it \"should use the :main, :ca, and :ssl settings sections\" do\n      Puppet.settings.expects(:use).with(:main, :ssl, :ca)\n      Puppet::SSL::CertificateAuthority.new\n    end\n\n    it \"should create an inventory instance\" do\n      Puppet::SSL::Inventory.expects(:new).returns \"inventory\"\n\n      Puppet::SSL::CertificateAuthority.new.inventory.should == \"inventory\"\n    end\n\n    it \"should make sure the CA is set up\" do\n      Puppet::SSL::CertificateAuthority.any_instance.expects(:setup)\n\n      Puppet::SSL::CertificateAuthority.new\n    end\n  end\n\n  describe \"when setting itself up\" do\n    it \"should generate the CA certificate if it does not have one\" do\n      Puppet.settings.stubs :use\n\n      host = stub 'host'\n      Puppet::SSL::Host.stubs(:new).returns host\n\n      host.expects(:certificate).returns nil\n\n      Puppet::SSL::CertificateAuthority.any_instance.expects(:generate_ca_certificate)\n      Puppet::SSL::CertificateAuthority.new\n    end\n  end\n\n  describe \"when retrieving the certificate revocation list\" do\n    before do\n      Puppet.settings.stubs(:use)\n      Puppet.settings.stubs(:value).returns \"ca_testing\"\n      Puppet.settings.stubs(:value).with(:cacrl).returns \"/my/crl\"\n\n      cert = stub(\"certificate\", :content => \"real_cert\")\n      key = stub(\"key\", :content => \"real_key\")\n      @host = stub 'host', :certificate => cert, :name => \"hostname\", :key => key\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:setup)\n      @ca = Puppet::SSL::CertificateAuthority.new\n\n      @ca.stubs(:host).returns @host\n    end\n\n    it \"should return any found CRL instance\" do\n      crl = mock 'crl'\n      Puppet::SSL::CertificateRevocationList.expects(:find).returns crl\n      @ca.crl.should equal(crl)\n    end\n\n    it \"should create, generate, and save a new CRL instance of no CRL can be found\" do\n      crl = mock 'crl'\n      Puppet::SSL::CertificateRevocationList.expects(:find).returns nil\n\n      Puppet::SSL::CertificateRevocationList.expects(:new).returns crl\n\n      crl.expects(:generate).with(@ca.host.certificate.content, @ca.host.key.content)\n      crl.expects(:save)\n\n      @ca.crl.should equal(crl)\n    end\n  end\n\n  describe \"when generating a self-signed CA certificate\" do\n    before do\n      Puppet.settings.stubs(:use)\n      Puppet.settings.stubs(:value).returns \"ca_testing\"\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:setup)\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:crl)\n      @ca = Puppet::SSL::CertificateAuthority.new\n\n      @host = stub 'host', :key => mock(\"key\"), :name => \"hostname\", :certificate => mock('certificate')\n\n      Puppet::SSL::CertificateRequest.any_instance.stubs(:generate)\n\n      @ca.stubs(:host).returns @host\n    end\n\n    it \"should create and store a password at :capass\" do\n      Puppet.settings.expects(:value).with(:capass).returns \"/path/to/pass\"\n\n      FileTest.expects(:exist?).with(\"/path/to/pass\").returns false\n\n      fh = mock 'filehandle'\n      Puppet.settings.expects(:write).with(:capass).yields fh\n\n      fh.expects(:print).with { |s| s.length > 18 }\n\n      @ca.stubs(:sign)\n\n      @ca.generate_ca_certificate\n    end\n\n    it \"should generate a key if one does not exist\" do\n      @ca.stubs :generate_password\n      @ca.stubs :sign\n\n      @ca.host.expects(:key).returns nil\n      @ca.host.expects(:generate_key)\n\n      @ca.generate_ca_certificate\n    end\n\n    it \"should create and sign a self-signed cert using the CA name\" do\n      request = mock 'request'\n      Puppet::SSL::CertificateRequest.expects(:new).with(@ca.host.name).returns request\n      request.expects(:generate).with(@ca.host.key)\n      request.stubs(:request_extensions => [])\n\n      @ca.expects(:sign).with(@host.name, false, request)\n\n      @ca.stubs :generate_password\n\n      @ca.generate_ca_certificate\n    end\n\n    it \"should generate its CRL\" do\n      @ca.stubs :generate_password\n      @ca.stubs :sign\n\n      @ca.host.expects(:key).returns nil\n      @ca.host.expects(:generate_key)\n\n      @ca.expects(:crl)\n\n      @ca.generate_ca_certificate\n    end\n  end\n\n  describe \"when signing\" do\n    before do\n      Puppet.settings.stubs(:use)\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:password?).returns true\n\n      stub_ca_host\n\n      Puppet::SSL::Host.expects(:new).with(Puppet::SSL::Host.ca_name).returns @host\n\n      @ca = Puppet::SSL::CertificateAuthority.new\n\n      @name = \"myhost\"\n      @real_cert = stub 'realcert', :sign => nil\n      @cert = stub 'certificate', :content => @real_cert\n\n      Puppet::SSL::Certificate.stubs(:new).returns @cert\n\n      @cert.stubs(:content=)\n      @cert.stubs(:save)\n\n      # Stub out the factory\n      Puppet::SSL::CertificateFactory.stubs(:build).returns \"my real cert\"\n\n      @request_content = stub \"request content stub\", :subject => @name\n      @request = stub 'request', :name => @name, :request_extensions => [], :subject_alt_names => [], :content => @request_content\n\n      # And the inventory\n      @inventory = stub 'inventory', :add => nil\n      @ca.stubs(:inventory).returns @inventory\n\n      Puppet::SSL::CertificateRequest.stubs(:destroy)\n    end\n\n    describe \"and calculating the next certificate serial number\" do\n      before do\n        @path = \"/path/to/serial\"\n        Puppet.settings.stubs(:value).with(:serial).returns @path\n\n        @filehandle = stub 'filehandle', :<< => @filehandle\n        Puppet.settings.stubs(:readwritelock).with(:serial).yields @filehandle\n      end\n\n      it \"should default to 0x1 for the first serial number\" do\n        @ca.next_serial.should == 0x1\n      end\n\n      it \"should return the current content of the serial file\" do\n        FileTest.stubs(:exist?).with(@path).returns true\n        File.expects(:read).with(@path).returns \"0002\"\n\n        @ca.next_serial.should == 2\n      end\n\n      it \"should write the next serial number to the serial file as hex\" do\n        @filehandle.expects(:<<).with(\"0002\")\n\n        @ca.next_serial\n      end\n\n      it \"should lock the serial file while writing\" do\n        Puppet.settings.expects(:readwritelock).with(:serial)\n\n        @ca.next_serial\n      end\n    end\n\n    describe \"its own certificate\" do\n      before do\n        @serial = 10\n        @ca.stubs(:next_serial).returns @serial\n      end\n\n      it \"should not look up a certificate request for the host\" do\n        Puppet::SSL::CertificateRequest.expects(:find).never\n\n        @ca.sign(@name, true, @request)\n      end\n\n      it \"should use a certificate type of :ca\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[0] == :ca\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should pass the provided CSR as the CSR\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[1] == @request\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should use the provided CSR's content as the issuer\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[2].subject == \"myhost\"\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should pass the next serial as the serial number\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[3] == @serial\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should sign the certificate request even if it contains alt names\" do\n        @request.stubs(:subject_alt_names).returns %w[DNS:foo DNS:bar DNS:baz]\n\n        expect do\n          @ca.sign(@name, false, @request)\n        end.should_not raise_error(Puppet::SSL::CertificateAuthority::CertificateSigningError)\n      end\n\n      it \"should save the resulting certificate\" do\n        @cert.expects(:save)\n\n        @ca.sign(@name, :ca, @request)\n      end\n    end\n\n    describe \"another host's certificate\" do\n      before do\n        @serial = 10\n        @ca.stubs(:next_serial).returns @serial\n\n        Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n        @cert.stubs :save\n      end\n\n      it \"should use a certificate type of :server\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[0] == :server\n        end.returns \"my real cert\"\n\n        @ca.sign(@name)\n      end\n\n      it \"should use look up a CSR for the host in the :ca_file terminus\" do\n        Puppet::SSL::CertificateRequest.expects(:find).with(@name).returns @request\n\n        @ca.sign(@name)\n      end\n\n      it \"should fail if no CSR can be found for the host\" do\n        Puppet::SSL::CertificateRequest.expects(:find).with(@name).returns nil\n\n        lambda { @ca.sign(@name) }.should raise_error(ArgumentError)\n      end\n\n      it \"should fail if an unknown request extension is present\" do\n        @request.stubs :request_extensions => [{ \"oid\"   => \"bananas\",\n                                                 \"value\" => \"delicious\" }]\n        expect { @ca.sign(@name) }.\n          should raise_error(/CSR has request extensions that are not permitted/)\n      end\n\n      it \"should fail if the CSR contains alt names and they are not expected\" do\n        @request.stubs(:subject_alt_names).returns %w[DNS:foo DNS:bar DNS:baz]\n\n        expect do\n          @ca.sign(@name, false)\n        end.to raise_error(Puppet::SSL::CertificateAuthority::CertificateSigningError, /CSR '#{@name}' contains subject alternative names \\(.*?\\), which are disallowed. Use `puppet cert --allow-dns-alt-names sign #{@name}` to sign this request./)\n      end\n\n      it \"should not fail if the CSR does not contain alt names and they are expected\" do\n        @request.stubs(:subject_alt_names).returns []\n        expect { @ca.sign(@name, true) }.should_not raise_error\n      end\n\n      it \"should reject alt names by default\" do\n        @request.stubs(:subject_alt_names).returns %w[DNS:foo DNS:bar DNS:baz]\n\n        expect do\n          @ca.sign(@name)\n        end.to raise_error(Puppet::SSL::CertificateAuthority::CertificateSigningError, /CSR '#{@name}' contains subject alternative names \\(.*?\\), which are disallowed. Use `puppet cert --allow-dns-alt-names sign #{@name}` to sign this request./)\n      end\n\n      it \"should use the CA certificate as the issuer\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[2] == @cacert.content\n        end.returns \"my real cert\"\n        @ca.sign(@name)\n      end\n\n      it \"should pass the next serial as the serial number\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[3] == @serial\n        end.returns \"my real cert\"\n        @ca.sign(@name)\n      end\n\n      it \"should sign the resulting certificate using its real key and a digest\" do\n        digest = mock 'digest'\n        OpenSSL::Digest::SHA1.expects(:new).returns digest\n\n        key = stub 'key', :content => \"real_key\"\n        @ca.host.stubs(:key).returns key\n\n        @cert.content.expects(:sign).with(\"real_key\", digest)\n        @ca.sign(@name)\n      end\n\n      it \"should save the resulting certificate\" do\n        @cert.expects(:save)\n        @ca.sign(@name)\n      end\n\n      it \"should remove the host's certificate request\" do\n        Puppet::SSL::CertificateRequest.expects(:destroy).with(@name)\n\n        @ca.sign(@name)\n      end\n\n      it \"should check the internal signing policies\" do\n        @ca.expects(:check_internal_signing_policies).returns true\n        @ca.sign(@name)\n      end\n    end\n\n    context \"#check_internal_signing_policies\" do\n      before do\n        @serial = 10\n        @ca.stubs(:next_serial).returns @serial\n\n        Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n        @cert.stubs :save\n      end\n\n      it \"should reject a critical extension that isn't on the whitelist\" do\n        @request.stubs(:request_extensions).returns [{ \"oid\" => \"banana\",\n                                                       \"value\" => \"yumm\",\n                                                       \"critical\" => true }]\n        expect { @ca.sign(@name) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /request extensions that are not permitted/\n        )\n      end\n\n      it \"should reject a non-critical extension that isn't on the whitelist\" do\n        @request.stubs(:request_extensions).returns [{ \"oid\" => \"peach\",\n                                                       \"value\" => \"meh\",\n                                                       \"critical\" => false }]\n        expect { @ca.sign(@name) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /request extensions that are not permitted/\n        )\n      end\n\n      it \"should reject non-whitelist extensions even if a valid extension is present\" do\n        @request.stubs(:request_extensions).returns [{ \"oid\" => \"peach\",\n                                                       \"value\" => \"meh\",\n                                                       \"critical\" => false },\n                                                     { \"oid\" => \"subjectAltName\",\n                                                       \"value\" => \"DNS:foo\",\n                                                       \"critical\" => true }]\n        expect { @ca.sign(@name) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /request extensions that are not permitted/\n        )\n      end\n\n      it \"should reject a subjectAltName for a non-DNS value\" do\n        @request.stubs(:subject_alt_names).returns ['DNS:foo', 'email:bar@example.com']\n        expect { @ca.sign(@name, true) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /subjectAltName outside the DNS label space/\n        )\n      end\n\n      it \"should reject a wildcard subject\" do\n        @request.content.stubs(:subject).\n          returns(OpenSSL::X509::Name.new([[\"CN\", \"*.local\"]]))\n\n        expect { @ca.sign(@name) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /subject contains a wildcard/\n        )\n      end\n\n      it \"should reject a wildcard subjectAltName\" do\n        @request.stubs(:subject_alt_names).returns ['DNS:foo', 'DNS:*.bar']\n        expect { @ca.sign(@name, true) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /subjectAltName contains a wildcard/\n        )\n      end\n    end\n\n    it \"should create a certificate instance with the content set to the newly signed x509 certificate\" do\n      @serial = 10\n      @ca.stubs(:next_serial).returns @serial\n\n      Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n      @cert.stubs :save\n      Puppet::SSL::Certificate.expects(:new).with(@name).returns @cert\n\n      @ca.sign(@name)\n    end\n\n    it \"should return the certificate instance\" do\n      @ca.stubs(:next_serial).returns @serial\n      Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n      @cert.stubs :save\n      @ca.sign(@name).should equal(@cert)\n    end\n\n    it \"should add the certificate to its inventory\" do\n      @ca.stubs(:next_serial).returns @serial\n      @inventory.expects(:add).with(@cert)\n\n      Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n      @cert.stubs :save\n      @ca.sign(@name)\n    end\n\n    it \"should have a method for triggering autosigning of available CSRs\" do\n      @ca.should respond_to(:autosign)\n    end\n\n    describe \"when autosigning certificates\" do\n      it \"should do nothing if autosign is disabled\" do\n        Puppet.settings.expects(:value).with(:autosign).returns 'false'\n\n        Puppet::SSL::CertificateRequest.expects(:search).never\n        @ca.autosign\n      end\n\n      it \"should do nothing if no autosign.conf exists\" do\n        Puppet.settings.expects(:value).with(:autosign).returns '/auto/sign'\n        FileTest.expects(:exist?).with(\"/auto/sign\").returns false\n\n        Puppet::SSL::CertificateRequest.expects(:search).never\n        @ca.autosign\n      end\n\n      describe \"and autosign is enabled and the autosign.conf file exists\" do\n        before do\n          Puppet.settings.stubs(:value).with(:autosign).returns '/auto/sign'\n          FileTest.stubs(:exist?).with(\"/auto/sign\").returns true\n          File.stubs(:readlines).with(\"/auto/sign\").returns [\"one\\n\", \"two\\n\"]\n\n          Puppet::SSL::CertificateRequest.stubs(:search).returns []\n\n          @store = stub 'store', :allow => nil\n          Puppet::Network::AuthStore.stubs(:new).returns @store\n        end\n\n        describe \"when creating the AuthStore instance to verify autosigning\" do\n          it \"should create an AuthStore with each line in the configuration file allowed to be autosigned\" do\n            Puppet::Network::AuthStore.expects(:new).returns @store\n\n            @store.expects(:allow).with(\"one\")\n            @store.expects(:allow).with(\"two\")\n\n            @ca.autosign\n          end\n\n          it \"should reparse the autosign configuration on each call\" do\n            Puppet::Network::AuthStore.expects(:new).times(2).returns @store\n\n            @ca.autosign\n            @ca.autosign\n          end\n\n          it \"should ignore comments\" do\n            File.stubs(:readlines).with(\"/auto/sign\").returns [\"one\\n\", \"#two\\n\"]\n\n            @store.expects(:allow).with(\"one\")\n            @ca.autosign\n          end\n\n          it \"should ignore blank lines\" do\n            File.stubs(:readlines).with(\"/auto/sign\").returns [\"one\\n\", \"\\n\"]\n\n            @store.expects(:allow).with(\"one\")\n            @ca.autosign\n          end\n        end\n\n        it \"should sign all CSRs whose hostname matches the autosign configuration\" do\n          csr1 = mock 'csr1'\n          csr2 = mock 'csr2'\n          Puppet::SSL::CertificateRequest.stubs(:search).returns [csr1, csr2]\n        end\n\n        it \"should not sign CSRs whose hostname does not match the autosign configuration\" do\n          csr1 = mock 'csr1'\n          csr2 = mock 'csr2'\n          Puppet::SSL::CertificateRequest.stubs(:search).returns [csr1, csr2]\n        end\n      end\n    end\n  end\n\n  describe \"when managing certificate clients\" do\n    before do\n      Puppet.settings.stubs(:use)\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:password?).returns true\n\n      stub_ca_host\n\n      Puppet::SSL::Host.expects(:new).returns @host\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:host).returns @host\n\n      @cacert = mock 'certificate'\n      @cacert.stubs(:content).returns \"cacertificate\"\n      @ca = Puppet::SSL::CertificateAuthority.new\n    end\n\n    it \"should have a method for acting on the SSL files\" do\n      @ca.should respond_to(:apply)\n    end\n\n    describe \"when applying a method to a set of hosts\" do\n      it \"should fail if no subjects have been specified\" do\n        lambda { @ca.apply(:generate) }.should raise_error(ArgumentError)\n      end\n\n      it \"should create an Interface instance with the specified method and the options\" do\n        Puppet::SSL::CertificateAuthority::Interface.expects(:new).with(:generate, :to => :host).returns(stub('applier', :apply => nil))\n        @ca.apply(:generate, :to => :host)\n      end\n\n      it \"should apply the Interface with itself as the argument\" do\n        applier = stub('applier')\n        applier.expects(:apply).with(@ca)\n        Puppet::SSL::CertificateAuthority::Interface.expects(:new).returns applier\n        @ca.apply(:generate, :to => :ca_testing)\n      end\n    end\n\n    it \"should be able to list waiting certificate requests\" do\n      req1 = stub 'req1', :name => \"one\"\n      req2 = stub 'req2', :name => \"two\"\n      Puppet::SSL::CertificateRequest.expects(:search).with(\"*\").returns [req1, req2]\n\n      @ca.waiting?.should == %w{one two}\n    end\n\n    it \"should delegate removing hosts to the Host class\" do\n      Puppet::SSL::Host.expects(:destroy).with(\"myhost\")\n\n      @ca.destroy(\"myhost\")\n    end\n\n    it \"should be able to verify certificates\" do\n      @ca.should respond_to(:verify)\n    end\n\n    it \"should list certificates as the sorted list of all existing signed certificates\" do\n      cert1 = stub 'cert1', :name => \"cert1\"\n      cert2 = stub 'cert2', :name => \"cert2\"\n      Puppet::SSL::Certificate.expects(:search).with(\"*\").returns [cert1, cert2]\n      @ca.list.should == %w{cert1 cert2}\n    end\n\n    describe \"and printing certificates\" do\n      it \"should return nil if the certificate cannot be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns nil\n        @ca.print(\"myhost\").should be_nil\n      end\n\n      it \"should print certificates by calling :to_text on the host's certificate\" do\n        cert1 = stub 'cert1', :name => \"cert1\", :to_text => \"mytext\"\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns cert1\n        @ca.print(\"myhost\").should == \"mytext\"\n      end\n    end\n\n    describe \"and fingerprinting certificates\" do\n      before :each do\n        @cert = stub 'cert', :name => \"cert\", :fingerprint => \"DIGEST\"\n        Puppet::SSL::Certificate.stubs(:find).with(\"myhost\").returns @cert\n        Puppet::SSL::CertificateRequest.stubs(:find).with(\"myhost\")\n      end\n\n      it \"should raise an error if the certificate or CSR cannot be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns nil\n        Puppet::SSL::CertificateRequest.expects(:find).with(\"myhost\").returns nil\n        lambda { @ca.fingerprint(\"myhost\") }.should raise_error\n      end\n\n      it \"should try to find a CSR if no certificate can be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns nil\n        Puppet::SSL::CertificateRequest.expects(:find).with(\"myhost\").returns @cert\n        @cert.expects(:fingerprint)\n        @ca.fingerprint(\"myhost\")\n      end\n\n      it \"should delegate to the certificate fingerprinting\" do\n        @cert.expects(:fingerprint)\n        @ca.fingerprint(\"myhost\")\n      end\n\n      it \"should propagate the digest algorithm to the certificate fingerprinting system\" do\n        @cert.expects(:fingerprint).with(:digest)\n        @ca.fingerprint(\"myhost\", :digest)\n      end\n    end\n\n    describe \"and verifying certificates\" do\n      before do\n        @store = stub 'store', :verify => true, :add_file => nil, :purpose= => nil, :add_crl => true, :flags= => nil\n\n        OpenSSL::X509::Store.stubs(:new).returns @store\n\n        Puppet.settings.stubs(:value).returns \"crtstuff\"\n\n        @cert = stub 'cert', :content => \"mycert\"\n        Puppet::SSL::Certificate.stubs(:find).returns @cert\n\n        @crl = stub('crl', :content => \"mycrl\")\n\n        @ca.stubs(:crl).returns @crl\n      end\n\n      it \"should fail if the host's certificate cannot be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"me\").returns(nil)\n\n        lambda { @ca.verify(\"me\") }.should raise_error(ArgumentError)\n      end\n\n      it \"should create an SSL Store to verify\" do\n        OpenSSL::X509::Store.expects(:new).returns @store\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should add the CA Certificate to the store\" do\n        Puppet.settings.stubs(:value).with(:cacert).returns \"/ca/cert\"\n        @store.expects(:add_file).with \"/ca/cert\"\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should add the CRL to the store if the crl is enabled\" do\n        @store.expects(:add_crl).with \"mycrl\"\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should set the store purpose to OpenSSL::X509::PURPOSE_SSL_CLIENT\" do\n        Puppet.settings.stubs(:value).with(:cacert).returns \"/ca/cert\"\n        @store.expects(:add_file).with \"/ca/cert\"\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should set the store flags to check the crl\" do\n        @store.expects(:flags=).with OpenSSL::X509::V_FLAG_CRL_CHECK_ALL|OpenSSL::X509::V_FLAG_CRL_CHECK\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should use the store to verify the certificate\" do\n        @cert.expects(:content).returns \"mycert\"\n\n        @store.expects(:verify).with(\"mycert\").returns true\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should fail if the verification returns false\" do\n        @cert.expects(:content).returns \"mycert\"\n\n        @store.expects(:verify).with(\"mycert\").returns false\n\n        lambda { @ca.verify(\"me\") }.should raise_error\n      end\n    end\n\n    describe \"and revoking certificates\" do\n      before do\n        @crl = mock 'crl'\n        @ca.stubs(:crl).returns @crl\n\n        @ca.stubs(:next_serial).returns 10\n\n        @real_cert = stub 'real_cert', :serial => 15\n        @cert = stub 'cert', :content => @real_cert\n        Puppet::SSL::Certificate.stubs(:find).returns @cert\n\n      end\n\n      it \"should fail if the certificate revocation list is disabled\" do\n        @ca.stubs(:crl).returns false\n\n        lambda { @ca.revoke('ca_testing') }.should raise_error(ArgumentError)\n\n      end\n\n      it \"should delegate the revocation to its CRL\" do\n        @ca.crl.expects(:revoke)\n\n        @ca.revoke('host')\n      end\n\n      it \"should get the serial number from the local certificate if it exists\" do\n        @ca.crl.expects(:revoke).with { |serial, key| serial == 15 }\n\n        Puppet::SSL::Certificate.expects(:find).with(\"host\").returns @cert\n\n        @ca.revoke('host')\n      end\n\n      it \"should get the serial number from inventory if no local certificate exists\" do\n        real_cert = stub 'real_cert', :serial => 15\n        cert = stub 'cert', :content => real_cert\n        Puppet::SSL::Certificate.expects(:find).with(\"host\").returns nil\n\n        @ca.inventory.expects(:serial).with(\"host\").returns 16\n\n        @ca.crl.expects(:revoke).with { |serial, key| serial == 16 }\n        @ca.revoke('host')\n      end\n    end\n\n    it \"should be able to generate a complete new SSL host\" do\n      @ca.should respond_to(:generate)\n    end\n\n    describe \"and generating certificates\" do\n      before do\n        @host = stub 'host', :generate_certificate_request => nil\n        Puppet::SSL::Host.stubs(:new).returns @host\n        Puppet::SSL::Certificate.stubs(:find).returns nil\n\n        @ca.stubs(:sign)\n      end\n\n      it \"should fail if a certificate already exists for the host\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"him\").returns \"something\"\n\n        lambda { @ca.generate(\"him\") }.should raise_error(ArgumentError)\n      end\n\n      it \"should create a new Host instance with the correct name\" do\n        Puppet::SSL::Host.expects(:new).with(\"him\").returns @host\n\n        @ca.generate(\"him\")\n      end\n\n      it \"should use the Host to generate the certificate request\" do\n        @host.expects :generate_certificate_request\n\n        @ca.generate(\"him\")\n      end\n\n      it \"should sign the generated request\" do\n        @ca.expects(:sign).with(\"him\", false)\n        @ca.generate(\"him\")\n      end\n    end\n  end\nend\n"], "fixing_code": ["require 'puppet/ssl/host'\nrequire 'puppet/ssl/certificate_request'\nrequire 'puppet/util/cacher'\n\n# The class that knows how to sign certificates.  It creates\n# a 'special' SSL::Host whose name is 'ca', thus indicating\n# that, well, it's the CA.  There's some magic in the\n# indirector/ssl_file terminus base class that does that\n# for us.\n#   This class mostly just signs certs for us, but\n# it can also be seen as a general interface into all of the\n# SSL stuff.\nclass Puppet::SSL::CertificateAuthority\n  # We will only sign extensions on this whitelist, ever.  Any CSR with a\n  # requested extension that we don't recognize is rejected, against the risk\n  # that it will introduce some security issue through our ignorance of it.\n  #\n  # Adding an extension to this whitelist simply means we will consider it\n  # further, not that we will always accept a certificate with an extension\n  # requested on this list.\n  RequestExtensionWhitelist = %w{subjectAltName}\n\n  require 'puppet/ssl/certificate_factory'\n  require 'puppet/ssl/inventory'\n  require 'puppet/ssl/certificate_revocation_list'\n  require 'puppet/ssl/certificate_authority/interface'\n  require 'puppet/network/authstore'\n\n  class CertificateVerificationError < RuntimeError\n    attr_accessor :error_code\n\n    def initialize(code)\n      @error_code = code\n    end\n  end\n\n  class CertificateSigningError < RuntimeError\n    attr_accessor :host\n\n    def initialize(host)\n      @host = host\n    end\n  end\n\n  class << self\n    include Puppet::Util::Cacher\n\n    cached_attr(:singleton_instance) { new }\n  end\n\n  def self.ca?\n    return false unless Puppet[:ca]\n    return false unless Puppet.run_mode.master?\n    true\n  end\n\n  # If this process can function as a CA, then return a singleton\n  # instance.\n  def self.instance\n    return nil unless ca?\n\n    singleton_instance\n  end\n\n  attr_reader :name, :host\n\n  # Create and run an applicator.  I wanted to build an interface where you could do\n  # something like 'ca.apply(:generate).to(:all) but I don't think it's really possible.\n  def apply(method, options)\n    raise ArgumentError, \"You must specify the hosts to apply to; valid values are an array or the symbol :all\" unless options[:to]\n    applier = Interface.new(method, options)\n    applier.apply(self)\n  end\n\n  # If autosign is configured, then autosign all CSRs that match our configuration.\n  def autosign\n    return unless auto = autosign?\n\n    store = nil\n    store = autosign_store(auto) if auto != true\n\n    Puppet::SSL::CertificateRequest.search(\"*\").each do |csr|\n      sign(csr.name) if auto == true or store.allowed?(csr.name, \"127.1.1.1\")\n    end\n  end\n\n  # Do we autosign?  This returns true, false, or a filename.\n  def autosign?\n    auto = Puppet[:autosign]\n    return false if ['false', false].include?(auto)\n    return true if ['true', true].include?(auto)\n\n    raise ArgumentError, \"The autosign configuration '#{auto}' must be a fully qualified file\" unless auto =~ /^\\//\n    FileTest.exist?(auto) && auto\n  end\n\n  # Create an AuthStore for autosigning.\n  def autosign_store(file)\n    auth = Puppet::Network::AuthStore.new\n    File.readlines(file).each do |line|\n      next if line =~ /^\\s*#/\n      next if line =~ /^\\s*$/\n      auth.allow(line.chomp)\n    end\n\n    auth\n  end\n\n  # Retrieve (or create, if necessary) the certificate revocation list.\n  def crl\n    unless defined?(@crl)\n      unless @crl = Puppet::SSL::CertificateRevocationList.find(Puppet::SSL::CA_NAME)\n        @crl = Puppet::SSL::CertificateRevocationList.new(Puppet::SSL::CA_NAME)\n        @crl.generate(host.certificate.content, host.key.content)\n        @crl.save\n      end\n    end\n    @crl\n  end\n\n  # Delegate this to our Host class.\n  def destroy(name)\n    Puppet::SSL::Host.destroy(name)\n  end\n\n  # Generate a new certificate.\n  def generate(name, options = {})\n    raise ArgumentError, \"A Certificate already exists for #{name}\" if Puppet::SSL::Certificate.find(name)\n\n    # Pass on any requested subjectAltName field.\n    san = options[:dns_alt_names]\n\n    host = Puppet::SSL::Host.new(name)\n    host.generate_certificate_request(:dns_alt_names => san)\n    sign(name, !!san)\n  end\n\n  # Generate our CA certificate.\n  def generate_ca_certificate\n    generate_password unless password?\n\n    host.generate_key unless host.key\n\n    # Create a new cert request.  We do this specially, because we don't want\n    # to actually save the request anywhere.\n    request = Puppet::SSL::CertificateRequest.new(host.name)\n\n    # We deliberately do not put any subjectAltName in here: the CA\n    # certificate absolutely does not need them. --daniel 2011-10-13\n    request.generate(host.key)\n\n    # Create a self-signed certificate.\n    @certificate = sign(host.name, false, request)\n\n    # And make sure we initialize our CRL.\n    crl\n  end\n\n  def initialize\n    Puppet.settings.use :main, :ssl, :ca\n\n    @name = Puppet[:certname]\n\n    @host = Puppet::SSL::Host.new(Puppet::SSL::Host.ca_name)\n\n    setup\n  end\n\n  # Retrieve (or create, if necessary) our inventory manager.\n  def inventory\n    @inventory ||= Puppet::SSL::Inventory.new\n  end\n\n  # Generate a new password for the CA.\n  def generate_password\n    pass = \"\"\n    20.times { pass += (rand(74) + 48).chr }\n\n    begin\n      Puppet.settings.write(:capass) { |f| f.print pass }\n    rescue Errno::EACCES => detail\n      raise Puppet::Error, \"Could not write CA password: #{detail}\"\n    end\n\n    @password = pass\n\n    pass\n  end\n\n  # List all signed certificates.\n  def list\n    Puppet::SSL::Certificate.search(\"*\").collect { |c| c.name }\n  end\n\n  # Read the next serial from the serial file, and increment the\n  # file so this one is considered used.\n  def next_serial\n    serial = nil\n\n    # This is slightly odd.  If the file doesn't exist, our readwritelock creates\n    # it, but with a mode we can't actually read in some cases.  So, use\n    # a default before the lock.\n    serial = 0x1 unless FileTest.exist?(Puppet[:serial])\n\n    Puppet.settings.readwritelock(:serial) { |f|\n      serial ||= File.read(Puppet.settings[:serial]).chomp.hex if FileTest.exist?(Puppet[:serial])\n\n      # We store the next valid serial, not the one we just used.\n      f << \"%04X\" % (serial + 1)\n    }\n\n    serial\n  end\n\n  # Does the password file exist?\n  def password?\n    FileTest.exist? Puppet[:capass]\n  end\n\n  # Print a given host's certificate as text.\n  def print(name)\n    (cert = Puppet::SSL::Certificate.find(name)) ? cert.to_text : nil\n  end\n\n  # Revoke a given certificate.\n  def revoke(name)\n    raise ArgumentError, \"Cannot revoke certificates when the CRL is disabled\" unless crl\n\n    if cert = Puppet::SSL::Certificate.find(name)\n      serial = cert.content.serial\n    elsif ! serial = inventory.serial(name)\n      raise ArgumentError, \"Could not find a serial number for #{name}\"\n    end\n    crl.revoke(serial, host.key.content)\n  end\n\n  # This initializes our CA so it actually works.  This should be a private\n  # method, except that you can't any-instance stub private methods, which is\n  # *awesome*.  This method only really exists to provide a stub-point during\n  # testing.\n  def setup\n    generate_ca_certificate unless @host.certificate\n  end\n\n  # Sign a given certificate request.\n  def sign(hostname, allow_dns_alt_names = false, self_signing_csr = nil)\n    # This is a self-signed certificate\n    if self_signing_csr\n      # # This is a self-signed certificate, which is for the CA.  Since this\n      # # forces the certificate to be self-signed, anyone who manages to trick\n      # # the system into going through this path gets a certificate they could\n      # # generate anyway.  There should be no security risk from that.\n      csr = self_signing_csr\n      cert_type = :ca\n      issuer = csr.content\n    else\n      allow_dns_alt_names = true if hostname == Puppet[:certname].downcase\n      unless csr = Puppet::SSL::CertificateRequest.find(hostname)\n        raise ArgumentError, \"Could not find certificate request for #{hostname}\"\n      end\n\n      cert_type = :server\n      issuer = host.certificate.content\n\n      # Make sure that the CSR conforms to our internal signing policies.\n      # This will raise if the CSR doesn't conform, but just in case...\n      check_internal_signing_policies(hostname, csr, allow_dns_alt_names) or\n        raise CertificateSigningError.new(hostname), \"CSR had an unknown failure checking internal signing policies, will not sign!\"\n    end\n\n    cert = Puppet::SSL::Certificate.new(hostname)\n    cert.content = Puppet::SSL::CertificateFactory.\n      build(cert_type, csr, issuer, next_serial)\n    cert.content.sign(host.key.content, OpenSSL::Digest::SHA1.new)\n\n    Puppet.notice \"Signed certificate request for #{hostname}\"\n\n    # Add the cert to the inventory before we save it, since\n    # otherwise we could end up with it being duplicated, if\n    # this is the first time we build the inventory file.\n    inventory.add(cert)\n\n    # Save the now-signed cert.  This should get routed correctly depending\n    # on the certificate type.\n    cert.save\n\n    # And remove the CSR if this wasn't self signed.\n    Puppet::SSL::CertificateRequest.destroy(csr.name) unless self_signing_csr\n\n    cert\n  end\n\n  def check_internal_signing_policies(hostname, csr, allow_dns_alt_names)\n    # Reject unknown request extensions.\n    unknown_req = csr.request_extensions.\n      reject {|x| RequestExtensionWhitelist.include? x[\"oid\"] }\n\n    if unknown_req and not unknown_req.empty?\n      names = unknown_req.map {|x| x[\"oid\"] }.sort.uniq.join(\", \")\n      raise CertificateSigningError.new(hostname), \"CSR has request extensions that are not permitted: #{names}\"\n    end\n\n    # Do not sign misleading CSRs\n    cn = csr.content.subject.to_a.assoc(\"CN\")[1]\n    if hostname != cn\n      raise CertificateSigningError.new(hostname), \"CSR subject common name #{cn.inspect} does not match expected certname #{hostname.inspect}\"\n    end\n\n    # Only allow printing ascii characters, excluding /\n    if hostname !~ /\\A[ -.0-~]+\\Z/\n      raise CertificateSigningError.new(hostname), \"CSR #{hostname.inspect} subject contains unprintable or non-ASCII characters\"\n    end\n\n    # Wildcards: we don't allow 'em at any point.\n    #\n    # The stringification here makes the content visible, and saves us having\n    # to scrobble through the content of the CSR subject field to make sure it\n    # is what we expect where we expect it.\n    if csr.content.subject.to_s.include? '*'\n      raise CertificateSigningError.new(hostname), \"CSR subject contains a wildcard, which is not allowed: #{csr.content.subject.to_s}\"\n    end\n\n    unless csr.subject_alt_names.empty?\n      # If you alt names are allowed, they are required. Otherwise they are\n      # disallowed. Self-signed certs are implicitly trusted, however.\n      unless allow_dns_alt_names\n        raise CertificateSigningError.new(hostname), \"CSR '#{csr.name}' contains subject alternative names (#{csr.subject_alt_names.join(', ')}), which are disallowed. Use `puppet cert --allow-dns-alt-names sign #{csr.name}` to sign this request.\"\n      end\n\n      # If subjectAltNames are present, validate that they are only for DNS\n      # labels, not any other kind.\n      unless csr.subject_alt_names.all? {|x| x =~ /^DNS:/ }\n        raise CertificateSigningError.new(hostname), \"CSR '#{csr.name}' contains a subjectAltName outside the DNS label space: #{csr.subject_alt_names.join(', ')}.  To continue, this CSR needs to be cleaned.\"\n      end\n\n      # Check for wildcards in the subjectAltName fields too.\n      if csr.subject_alt_names.any? {|x| x.include? '*' }\n        raise CertificateSigningError.new(hostname), \"CSR '#{csr.name}' subjectAltName contains a wildcard, which is not allowed: #{csr.subject_alt_names.join(', ')}  To continue, this CSR needs to be cleaned.\"\n      end\n    end\n\n    return true                 # good enough for us!\n  end\n\n  # Verify a given host's certificate.\n  def verify(name)\n    unless cert = Puppet::SSL::Certificate.find(name)\n      raise ArgumentError, \"Could not find a certificate for #{name}\"\n    end\n    store = OpenSSL::X509::Store.new\n    store.add_file Puppet[:cacert]\n    store.add_crl crl.content if self.crl\n    store.purpose = OpenSSL::X509::PURPOSE_SSL_CLIENT\n    store.flags = OpenSSL::X509::V_FLAG_CRL_CHECK_ALL|OpenSSL::X509::V_FLAG_CRL_CHECK if Puppet.settings[:certificate_revocation]\n\n    raise CertificateVerificationError.new(store.error), store.error_string unless store.verify(cert.content)\n  end\n\n  def fingerprint(name, md = :MD5)\n    unless cert = Puppet::SSL::Certificate.find(name) || Puppet::SSL::CertificateRequest.find(name)\n      raise ArgumentError, \"Could not find a certificate or csr for #{name}\"\n    end\n    cert.fingerprint(md)\n  end\n\n  # List the waiting certificate requests.\n  def waiting?\n    Puppet::SSL::CertificateRequest.search(\"*\").collect { |r| r.name }\n  end\nend\n", "#!/usr/bin/env ruby\n\nrequire File.dirname(__FILE__) + '/../../spec_helper'\n\nrequire 'puppet/ssl/certificate_authority'\n\ndescribe Puppet::SSL::CertificateAuthority do\n  after do\n    Puppet::Util::Cacher.expire\n    Puppet.settings.clearused\n  end\n\n  def stub_ca_host\n    @key = mock 'key'\n    @key.stubs(:content).returns \"cakey\"\n    @cacert = mock 'certificate'\n    @cacert.stubs(:content).returns \"cacertificate\"\n\n    @host = stub 'ssl_host', :key => @key, :certificate => @cacert, :name => Puppet::SSL::Host.ca_name\n  end\n\n  it \"should have a class method for returning a singleton instance\" do\n    Puppet::SSL::CertificateAuthority.should respond_to(:instance)\n  end\n\n  describe \"when finding an existing instance\" do\n    describe \"and the host is a CA host and the run_mode is master\" do\n      before do\n        Puppet.settings.stubs(:value).with(:ca).returns true\n        Puppet.run_mode.stubs(:master?).returns true\n\n        @ca = mock('ca')\n        Puppet::SSL::CertificateAuthority.stubs(:new).returns @ca\n      end\n\n      it \"should return an instance\" do\n        Puppet::SSL::CertificateAuthority.instance.should equal(@ca)\n      end\n\n      it \"should always return the same instance\" do\n        Puppet::SSL::CertificateAuthority.instance.should equal(Puppet::SSL::CertificateAuthority.instance)\n      end\n    end\n\n    describe \"and the host is not a CA host\" do\n      it \"should return nil\" do\n        Puppet.settings.stubs(:value).with(:ca).returns false\n        Puppet.run_mode.stubs(:master?).returns true\n\n        ca = mock('ca')\n        Puppet::SSL::CertificateAuthority.expects(:new).never\n        Puppet::SSL::CertificateAuthority.instance.should be_nil\n      end\n    end\n\n    describe \"and the run_mode is not master\" do\n      it \"should return nil\" do\n        Puppet.settings.stubs(:value).with(:ca).returns true\n        Puppet.run_mode.stubs(:master?).returns false\n\n        ca = mock('ca')\n        Puppet::SSL::CertificateAuthority.expects(:new).never\n        Puppet::SSL::CertificateAuthority.instance.should be_nil\n      end\n    end\n  end\n\n  describe \"when initializing\" do\n    before do\n      Puppet.settings.stubs(:use)\n      Puppet.settings.stubs(:value).returns \"ca_testing\"\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:setup)\n    end\n\n    it \"should always set its name to the value of :certname\" do\n      Puppet.settings.expects(:value).with(:certname).returns \"ca_testing\"\n\n      Puppet::SSL::CertificateAuthority.new.name.should == \"ca_testing\"\n    end\n\n    it \"should create an SSL::Host instance whose name is the 'ca_name'\" do\n      Puppet::SSL::Host.expects(:ca_name).returns \"caname\"\n\n      host = stub 'host'\n      Puppet::SSL::Host.expects(:new).with(\"caname\").returns host\n\n      Puppet::SSL::CertificateAuthority.new\n    end\n\n    it \"should use the :main, :ca, and :ssl settings sections\" do\n      Puppet.settings.expects(:use).with(:main, :ssl, :ca)\n      Puppet::SSL::CertificateAuthority.new\n    end\n\n    it \"should create an inventory instance\" do\n      Puppet::SSL::Inventory.expects(:new).returns \"inventory\"\n\n      Puppet::SSL::CertificateAuthority.new.inventory.should == \"inventory\"\n    end\n\n    it \"should make sure the CA is set up\" do\n      Puppet::SSL::CertificateAuthority.any_instance.expects(:setup)\n\n      Puppet::SSL::CertificateAuthority.new\n    end\n  end\n\n  describe \"when setting itself up\" do\n    it \"should generate the CA certificate if it does not have one\" do\n      Puppet.settings.stubs :use\n\n      host = stub 'host'\n      Puppet::SSL::Host.stubs(:new).returns host\n\n      host.expects(:certificate).returns nil\n\n      Puppet::SSL::CertificateAuthority.any_instance.expects(:generate_ca_certificate)\n      Puppet::SSL::CertificateAuthority.new\n    end\n  end\n\n  describe \"when retrieving the certificate revocation list\" do\n    before do\n      Puppet.settings.stubs(:use)\n      Puppet.settings.stubs(:value).returns \"ca_testing\"\n      Puppet.settings.stubs(:value).with(:cacrl).returns \"/my/crl\"\n\n      cert = stub(\"certificate\", :content => \"real_cert\")\n      key = stub(\"key\", :content => \"real_key\")\n      @host = stub 'host', :certificate => cert, :name => \"hostname\", :key => key\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:setup)\n      @ca = Puppet::SSL::CertificateAuthority.new\n\n      @ca.stubs(:host).returns @host\n    end\n\n    it \"should return any found CRL instance\" do\n      crl = mock 'crl'\n      Puppet::SSL::CertificateRevocationList.expects(:find).returns crl\n      @ca.crl.should equal(crl)\n    end\n\n    it \"should create, generate, and save a new CRL instance of no CRL can be found\" do\n      crl = mock 'crl'\n      Puppet::SSL::CertificateRevocationList.expects(:find).returns nil\n\n      Puppet::SSL::CertificateRevocationList.expects(:new).returns crl\n\n      crl.expects(:generate).with(@ca.host.certificate.content, @ca.host.key.content)\n      crl.expects(:save)\n\n      @ca.crl.should equal(crl)\n    end\n  end\n\n  describe \"when generating a self-signed CA certificate\" do\n    before do\n      Puppet.settings.stubs(:use)\n      Puppet.settings.stubs(:value).returns \"ca_testing\"\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:setup)\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:crl)\n      @ca = Puppet::SSL::CertificateAuthority.new\n\n      @host = stub 'host', :key => mock(\"key\"), :name => \"hostname\", :certificate => mock('certificate')\n\n      Puppet::SSL::CertificateRequest.any_instance.stubs(:generate)\n\n      @ca.stubs(:host).returns @host\n    end\n\n    it \"should create and store a password at :capass\" do\n      Puppet.settings.expects(:value).with(:capass).returns \"/path/to/pass\"\n\n      FileTest.expects(:exist?).with(\"/path/to/pass\").returns false\n\n      fh = mock 'filehandle'\n      Puppet.settings.expects(:write).with(:capass).yields fh\n\n      fh.expects(:print).with { |s| s.length > 18 }\n\n      @ca.stubs(:sign)\n\n      @ca.generate_ca_certificate\n    end\n\n    it \"should generate a key if one does not exist\" do\n      @ca.stubs :generate_password\n      @ca.stubs :sign\n\n      @ca.host.expects(:key).returns nil\n      @ca.host.expects(:generate_key)\n\n      @ca.generate_ca_certificate\n    end\n\n    it \"should create and sign a self-signed cert using the CA name\" do\n      request = mock 'request'\n      Puppet::SSL::CertificateRequest.expects(:new).with(@ca.host.name).returns request\n      request.expects(:generate).with(@ca.host.key)\n      request.stubs(:request_extensions => [])\n\n      @ca.expects(:sign).with(@host.name, false, request)\n\n      @ca.stubs :generate_password\n\n      @ca.generate_ca_certificate\n    end\n\n    it \"should generate its CRL\" do\n      @ca.stubs :generate_password\n      @ca.stubs :sign\n\n      @ca.host.expects(:key).returns nil\n      @ca.host.expects(:generate_key)\n\n      @ca.expects(:crl)\n\n      @ca.generate_ca_certificate\n    end\n  end\n\n  describe \"when signing\" do\n    before do\n      Puppet.settings.stubs(:use)\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:password?).returns true\n\n      stub_ca_host\n\n      Puppet::SSL::Host.expects(:new).with(Puppet::SSL::Host.ca_name).returns @host\n\n      @ca = Puppet::SSL::CertificateAuthority.new\n\n      @name = \"myhost\"\n      @real_cert = stub 'realcert', :sign => nil\n      @cert = stub 'certificate', :content => @real_cert\n\n      Puppet::SSL::Certificate.stubs(:new).returns @cert\n\n      @cert.stubs(:content=)\n      @cert.stubs(:save)\n\n      # Stub out the factory\n      Puppet::SSL::CertificateFactory.stubs(:build).returns \"my real cert\"\n\n      @request_content = stub \"request content stub\", :subject => OpenSSL::X509::Name.new([['CN', @name]])\n      @request = stub 'request', :name => @name, :request_extensions => [], :subject_alt_names => [], :content => @request_content\n\n      # And the inventory\n      @inventory = stub 'inventory', :add => nil\n      @ca.stubs(:inventory).returns @inventory\n\n      Puppet::SSL::CertificateRequest.stubs(:destroy)\n    end\n\n    describe \"and calculating the next certificate serial number\" do\n      before do\n        @path = \"/path/to/serial\"\n        Puppet.settings.stubs(:value).with(:serial).returns @path\n\n        @filehandle = stub 'filehandle', :<< => @filehandle\n        Puppet.settings.stubs(:readwritelock).with(:serial).yields @filehandle\n      end\n\n      it \"should default to 0x1 for the first serial number\" do\n        @ca.next_serial.should == 0x1\n      end\n\n      it \"should return the current content of the serial file\" do\n        FileTest.stubs(:exist?).with(@path).returns true\n        File.expects(:read).with(@path).returns \"0002\"\n\n        @ca.next_serial.should == 2\n      end\n\n      it \"should write the next serial number to the serial file as hex\" do\n        @filehandle.expects(:<<).with(\"0002\")\n\n        @ca.next_serial\n      end\n\n      it \"should lock the serial file while writing\" do\n        Puppet.settings.expects(:readwritelock).with(:serial)\n\n        @ca.next_serial\n      end\n    end\n\n    describe \"its own certificate\" do\n      before do\n        @serial = 10\n        @ca.stubs(:next_serial).returns @serial\n      end\n\n      it \"should not look up a certificate request for the host\" do\n        Puppet::SSL::CertificateRequest.expects(:find).never\n\n        @ca.sign(@name, true, @request)\n      end\n\n      it \"should use a certificate type of :ca\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[0].should == :ca\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should pass the provided CSR as the CSR\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[1].should == @request\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should use the provided CSR's content as the issuer\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[2].subject.to_s.should == \"/CN=myhost\"\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should pass the next serial as the serial number\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[3].should == @serial\n        end.returns \"my real cert\"\n        @ca.sign(@name, :ca, @request)\n      end\n\n      it \"should sign the certificate request even if it contains alt names\" do\n        @request.stubs(:subject_alt_names).returns %w[DNS:foo DNS:bar DNS:baz]\n\n        expect do\n          @ca.sign(@name, false, @request)\n        end.should_not raise_error(Puppet::SSL::CertificateAuthority::CertificateSigningError)\n      end\n\n      it \"should save the resulting certificate\" do\n        @cert.expects(:save)\n\n        @ca.sign(@name, :ca, @request)\n      end\n    end\n\n    describe \"another host's certificate\" do\n      before do\n        @serial = 10\n        @ca.stubs(:next_serial).returns @serial\n\n        Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n        @cert.stubs :save\n      end\n\n      it \"should use a certificate type of :server\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[0] == :server\n        end.returns \"my real cert\"\n\n        @ca.sign(@name)\n      end\n\n      it \"should use look up a CSR for the host in the :ca_file terminus\" do\n        Puppet::SSL::CertificateRequest.expects(:find).with(@name).returns @request\n\n        @ca.sign(@name)\n      end\n\n      it \"should fail if no CSR can be found for the host\" do\n        Puppet::SSL::CertificateRequest.expects(:find).with(@name).returns nil\n\n        lambda { @ca.sign(@name) }.should raise_error(ArgumentError)\n      end\n\n      it \"should fail if an unknown request extension is present\" do\n        @request.stubs :request_extensions => [{ \"oid\"   => \"bananas\",\n                                                 \"value\" => \"delicious\" }]\n        expect { @ca.sign(@name) }.\n          should raise_error(/CSR has request extensions that are not permitted/)\n      end\n\n      it \"should fail if the CSR contains alt names and they are not expected\" do\n        @request.stubs(:subject_alt_names).returns %w[DNS:foo DNS:bar DNS:baz]\n\n        expect do\n          @ca.sign(@name, false)\n        end.to raise_error(Puppet::SSL::CertificateAuthority::CertificateSigningError, /CSR '#{@name}' contains subject alternative names \\(.*?\\), which are disallowed. Use `puppet cert --allow-dns-alt-names sign #{@name}` to sign this request./)\n      end\n\n      it \"should not fail if the CSR does not contain alt names and they are expected\" do\n        @request.stubs(:subject_alt_names).returns []\n        expect { @ca.sign(@name, true) }.should_not raise_error\n      end\n\n      it \"should reject alt names by default\" do\n        @request.stubs(:subject_alt_names).returns %w[DNS:foo DNS:bar DNS:baz]\n\n        expect do\n          @ca.sign(@name)\n        end.to raise_error(Puppet::SSL::CertificateAuthority::CertificateSigningError, /CSR '#{@name}' contains subject alternative names \\(.*?\\), which are disallowed. Use `puppet cert --allow-dns-alt-names sign #{@name}` to sign this request./)\n      end\n\n      it \"should use the CA certificate as the issuer\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[2] == @cacert.content\n        end.returns \"my real cert\"\n        @ca.sign(@name)\n      end\n\n      it \"should pass the next serial as the serial number\" do\n        Puppet::SSL::CertificateFactory.expects(:build).with do |*args|\n          args[3] == @serial\n        end.returns \"my real cert\"\n        @ca.sign(@name)\n      end\n\n      it \"should sign the resulting certificate using its real key and a digest\" do\n        digest = mock 'digest'\n        OpenSSL::Digest::SHA1.expects(:new).returns digest\n\n        key = stub 'key', :content => \"real_key\"\n        @ca.host.stubs(:key).returns key\n\n        @cert.content.expects(:sign).with(\"real_key\", digest)\n        @ca.sign(@name)\n      end\n\n      it \"should save the resulting certificate\" do\n        @cert.expects(:save)\n        @ca.sign(@name)\n      end\n\n      it \"should remove the host's certificate request\" do\n        Puppet::SSL::CertificateRequest.expects(:destroy).with(@name)\n\n        @ca.sign(@name)\n      end\n\n      it \"should check the internal signing policies\" do\n        @ca.expects(:check_internal_signing_policies).returns true\n        @ca.sign(@name)\n      end\n    end\n\n    context \"#check_internal_signing_policies\" do\n      before do\n        @serial = 10\n        @ca.stubs(:next_serial).returns @serial\n\n        Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n        @cert.stubs :save\n      end\n\n      it \"should reject CSRs whose CN doesn't match the name for which we're signing them\" do\n        # Shorten this so the test doesn't take too long\n        Puppet[:keylength] = 1024\n        key = Puppet::SSL::Key.new('the_certname')\n        key.generate\n\n        csr = Puppet::SSL::CertificateRequest.new('the_certname')\n        csr.generate(key)\n\n        expect do\n          @ca.check_internal_signing_policies('not_the_certname', csr, false)\n        end.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /common name \"the_certname\" does not match expected certname \"not_the_certname\"/\n        )\n      end\n\n      describe \"when validating the CN\" do\n        before :all do\n          Puppet[:keylength] = 1024\n          @signing_key = Puppet::SSL::Key.new('my_signing_key')\n          @signing_key.generate\n        end\n\n        [\n         'completely_okay',\n         'sure, why not? :)',\n         'so+many(things)-are=allowed.',\n         'this\"is#just&madness%you[see]',\n         'and even a (an?) \\\\!',\n         'waltz, nymph, for quick jigs vex bud.',\n         '{552c04ca-bb1b-11e1-874b-60334b04494e}'\n        ].each do |name|\n          it \"should accept #{name.inspect}\" do\n            csr = Puppet::SSL::CertificateRequest.new(name)\n            csr.generate(@signing_key)\n\n            @ca.check_internal_signing_policies(name, csr, false)\n          end\n        end\n\n        [\n         'super/bad',\n         \"not\\neven\\tkind\\rof\",\n         \"ding\\adong\\a\",\n         \"hidden\\b\\b\\b\\b\\b\\bmessage\",\n         \"\u2603 :(\"\n        ].each do |name|\n          it \"should reject #{name.inspect}\" do\n            # We aren't even allowed to make objects with these names, so let's\n            # stub that to simulate an invalid one coming from outside Puppet\n            Puppet::SSL::CertificateRequest.stubs(:validate_certname)\n            csr = Puppet::SSL::CertificateRequest.new(name)\n            csr.generate(@signing_key)\n\n            expect do\n              @ca.check_internal_signing_policies(name, csr, false)\n            end.to raise_error(\n              Puppet::SSL::CertificateAuthority::CertificateSigningError,\n              /subject contains unprintable or non-ASCII characters/\n            )\n          end\n        end\n      end\n\n      it \"should reject a critical extension that isn't on the whitelist\" do\n        @request.stubs(:request_extensions).returns [{ \"oid\" => \"banana\",\n                                                       \"value\" => \"yumm\",\n                                                       \"critical\" => true }]\n        expect { @ca.check_internal_signing_policies(@name, @request, false) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /request extensions that are not permitted/\n        )\n      end\n\n      it \"should reject a non-critical extension that isn't on the whitelist\" do\n        @request.stubs(:request_extensions).returns [{ \"oid\" => \"peach\",\n                                                       \"value\" => \"meh\",\n                                                       \"critical\" => false }]\n        expect { @ca.check_internal_signing_policies(@name, @request, false) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /request extensions that are not permitted/\n        )\n      end\n\n      it \"should reject non-whitelist extensions even if a valid extension is present\" do\n        @request.stubs(:request_extensions).returns [{ \"oid\" => \"peach\",\n                                                       \"value\" => \"meh\",\n                                                       \"critical\" => false },\n                                                     { \"oid\" => \"subjectAltName\",\n                                                       \"value\" => \"DNS:foo\",\n                                                       \"critical\" => true }]\n        expect { @ca.check_internal_signing_policies(@name, @request, false) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /request extensions that are not permitted/\n        )\n      end\n\n      it \"should reject a subjectAltName for a non-DNS value\" do\n        @request.stubs(:subject_alt_names).returns ['DNS:foo', 'email:bar@example.com']\n        expect { @ca.check_internal_signing_policies(@name, @request, true) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /subjectAltName outside the DNS label space/\n        )\n      end\n\n      it \"should reject a wildcard subject\" do\n        @request.content.stubs(:subject).\n          returns(OpenSSL::X509::Name.new([[\"CN\", \"*.local\"]]))\n\n        expect { @ca.check_internal_signing_policies('*.local', @request, false) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /subject contains a wildcard/\n        )\n      end\n\n      it \"should reject a wildcard subjectAltName\" do\n        @request.stubs(:subject_alt_names).returns ['DNS:foo', 'DNS:*.bar']\n        expect { @ca.check_internal_signing_policies(@name, @request, true) }.to raise_error(\n          Puppet::SSL::CertificateAuthority::CertificateSigningError,\n          /subjectAltName contains a wildcard/\n        )\n      end\n    end\n\n    it \"should create a certificate instance with the content set to the newly signed x509 certificate\" do\n      @serial = 10\n      @ca.stubs(:next_serial).returns @serial\n\n      Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n      @cert.stubs :save\n      Puppet::SSL::Certificate.expects(:new).with(@name).returns @cert\n\n      @ca.sign(@name)\n    end\n\n    it \"should return the certificate instance\" do\n      @ca.stubs(:next_serial).returns @serial\n      Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n      @cert.stubs :save\n      @ca.sign(@name).should equal(@cert)\n    end\n\n    it \"should add the certificate to its inventory\" do\n      @ca.stubs(:next_serial).returns @serial\n      @inventory.expects(:add).with(@cert)\n\n      Puppet::SSL::CertificateRequest.stubs(:find).with(@name).returns @request\n      @cert.stubs :save\n      @ca.sign(@name)\n    end\n\n    it \"should have a method for triggering autosigning of available CSRs\" do\n      @ca.should respond_to(:autosign)\n    end\n\n    describe \"when autosigning certificates\" do\n      it \"should do nothing if autosign is disabled\" do\n        Puppet.settings.expects(:value).with(:autosign).returns 'false'\n\n        Puppet::SSL::CertificateRequest.expects(:search).never\n        @ca.autosign\n      end\n\n      it \"should do nothing if no autosign.conf exists\" do\n        Puppet.settings.expects(:value).with(:autosign).returns '/auto/sign'\n        FileTest.expects(:exist?).with(\"/auto/sign\").returns false\n\n        Puppet::SSL::CertificateRequest.expects(:search).never\n        @ca.autosign\n      end\n\n      describe \"and autosign is enabled and the autosign.conf file exists\" do\n        before do\n          Puppet.settings.stubs(:value).with(:autosign).returns '/auto/sign'\n          FileTest.stubs(:exist?).with(\"/auto/sign\").returns true\n          File.stubs(:readlines).with(\"/auto/sign\").returns [\"one\\n\", \"two\\n\"]\n\n          Puppet::SSL::CertificateRequest.stubs(:search).returns []\n\n          @store = stub 'store', :allow => nil\n          Puppet::Network::AuthStore.stubs(:new).returns @store\n        end\n\n        describe \"when creating the AuthStore instance to verify autosigning\" do\n          it \"should create an AuthStore with each line in the configuration file allowed to be autosigned\" do\n            Puppet::Network::AuthStore.expects(:new).returns @store\n\n            @store.expects(:allow).with(\"one\")\n            @store.expects(:allow).with(\"two\")\n\n            @ca.autosign\n          end\n\n          it \"should reparse the autosign configuration on each call\" do\n            Puppet::Network::AuthStore.expects(:new).times(2).returns @store\n\n            @ca.autosign\n            @ca.autosign\n          end\n\n          it \"should ignore comments\" do\n            File.stubs(:readlines).with(\"/auto/sign\").returns [\"one\\n\", \"#two\\n\"]\n\n            @store.expects(:allow).with(\"one\")\n            @ca.autosign\n          end\n\n          it \"should ignore blank lines\" do\n            File.stubs(:readlines).with(\"/auto/sign\").returns [\"one\\n\", \"\\n\"]\n\n            @store.expects(:allow).with(\"one\")\n            @ca.autosign\n          end\n        end\n\n        it \"should sign all CSRs whose hostname matches the autosign configuration\" do\n          csr1 = mock 'csr1'\n          csr2 = mock 'csr2'\n          Puppet::SSL::CertificateRequest.stubs(:search).returns [csr1, csr2]\n        end\n\n        it \"should not sign CSRs whose hostname does not match the autosign configuration\" do\n          csr1 = mock 'csr1'\n          csr2 = mock 'csr2'\n          Puppet::SSL::CertificateRequest.stubs(:search).returns [csr1, csr2]\n        end\n      end\n    end\n  end\n\n  describe \"when managing certificate clients\" do\n    before do\n      Puppet.settings.stubs(:use)\n\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:password?).returns true\n\n      stub_ca_host\n\n      Puppet::SSL::Host.expects(:new).returns @host\n      Puppet::SSL::CertificateAuthority.any_instance.stubs(:host).returns @host\n\n      @cacert = mock 'certificate'\n      @cacert.stubs(:content).returns \"cacertificate\"\n      @ca = Puppet::SSL::CertificateAuthority.new\n    end\n\n    it \"should have a method for acting on the SSL files\" do\n      @ca.should respond_to(:apply)\n    end\n\n    describe \"when applying a method to a set of hosts\" do\n      it \"should fail if no subjects have been specified\" do\n        lambda { @ca.apply(:generate) }.should raise_error(ArgumentError)\n      end\n\n      it \"should create an Interface instance with the specified method and the options\" do\n        Puppet::SSL::CertificateAuthority::Interface.expects(:new).with(:generate, :to => :host).returns(stub('applier', :apply => nil))\n        @ca.apply(:generate, :to => :host)\n      end\n\n      it \"should apply the Interface with itself as the argument\" do\n        applier = stub('applier')\n        applier.expects(:apply).with(@ca)\n        Puppet::SSL::CertificateAuthority::Interface.expects(:new).returns applier\n        @ca.apply(:generate, :to => :ca_testing)\n      end\n    end\n\n    it \"should be able to list waiting certificate requests\" do\n      req1 = stub 'req1', :name => \"one\"\n      req2 = stub 'req2', :name => \"two\"\n      Puppet::SSL::CertificateRequest.expects(:search).with(\"*\").returns [req1, req2]\n\n      @ca.waiting?.should == %w{one two}\n    end\n\n    it \"should delegate removing hosts to the Host class\" do\n      Puppet::SSL::Host.expects(:destroy).with(\"myhost\")\n\n      @ca.destroy(\"myhost\")\n    end\n\n    it \"should be able to verify certificates\" do\n      @ca.should respond_to(:verify)\n    end\n\n    it \"should list certificates as the sorted list of all existing signed certificates\" do\n      cert1 = stub 'cert1', :name => \"cert1\"\n      cert2 = stub 'cert2', :name => \"cert2\"\n      Puppet::SSL::Certificate.expects(:search).with(\"*\").returns [cert1, cert2]\n      @ca.list.should == %w{cert1 cert2}\n    end\n\n    describe \"and printing certificates\" do\n      it \"should return nil if the certificate cannot be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns nil\n        @ca.print(\"myhost\").should be_nil\n      end\n\n      it \"should print certificates by calling :to_text on the host's certificate\" do\n        cert1 = stub 'cert1', :name => \"cert1\", :to_text => \"mytext\"\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns cert1\n        @ca.print(\"myhost\").should == \"mytext\"\n      end\n    end\n\n    describe \"and fingerprinting certificates\" do\n      before :each do\n        @cert = stub 'cert', :name => \"cert\", :fingerprint => \"DIGEST\"\n        Puppet::SSL::Certificate.stubs(:find).with(\"myhost\").returns @cert\n        Puppet::SSL::CertificateRequest.stubs(:find).with(\"myhost\")\n      end\n\n      it \"should raise an error if the certificate or CSR cannot be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns nil\n        Puppet::SSL::CertificateRequest.expects(:find).with(\"myhost\").returns nil\n        lambda { @ca.fingerprint(\"myhost\") }.should raise_error\n      end\n\n      it \"should try to find a CSR if no certificate can be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"myhost\").returns nil\n        Puppet::SSL::CertificateRequest.expects(:find).with(\"myhost\").returns @cert\n        @cert.expects(:fingerprint)\n        @ca.fingerprint(\"myhost\")\n      end\n\n      it \"should delegate to the certificate fingerprinting\" do\n        @cert.expects(:fingerprint)\n        @ca.fingerprint(\"myhost\")\n      end\n\n      it \"should propagate the digest algorithm to the certificate fingerprinting system\" do\n        @cert.expects(:fingerprint).with(:digest)\n        @ca.fingerprint(\"myhost\", :digest)\n      end\n    end\n\n    describe \"and verifying certificates\" do\n      before do\n        @store = stub 'store', :verify => true, :add_file => nil, :purpose= => nil, :add_crl => true, :flags= => nil\n\n        OpenSSL::X509::Store.stubs(:new).returns @store\n\n        Puppet.settings.stubs(:value).returns \"crtstuff\"\n\n        @cert = stub 'cert', :content => \"mycert\"\n        Puppet::SSL::Certificate.stubs(:find).returns @cert\n\n        @crl = stub('crl', :content => \"mycrl\")\n\n        @ca.stubs(:crl).returns @crl\n      end\n\n      it \"should fail if the host's certificate cannot be found\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"me\").returns(nil)\n\n        lambda { @ca.verify(\"me\") }.should raise_error(ArgumentError)\n      end\n\n      it \"should create an SSL Store to verify\" do\n        OpenSSL::X509::Store.expects(:new).returns @store\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should add the CA Certificate to the store\" do\n        Puppet.settings.stubs(:value).with(:cacert).returns \"/ca/cert\"\n        @store.expects(:add_file).with \"/ca/cert\"\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should add the CRL to the store if the crl is enabled\" do\n        @store.expects(:add_crl).with \"mycrl\"\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should set the store purpose to OpenSSL::X509::PURPOSE_SSL_CLIENT\" do\n        Puppet.settings.stubs(:value).with(:cacert).returns \"/ca/cert\"\n        @store.expects(:add_file).with \"/ca/cert\"\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should set the store flags to check the crl\" do\n        @store.expects(:flags=).with OpenSSL::X509::V_FLAG_CRL_CHECK_ALL|OpenSSL::X509::V_FLAG_CRL_CHECK\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should use the store to verify the certificate\" do\n        @cert.expects(:content).returns \"mycert\"\n\n        @store.expects(:verify).with(\"mycert\").returns true\n\n        @ca.verify(\"me\")\n      end\n\n      it \"should fail if the verification returns false\" do\n        @cert.expects(:content).returns \"mycert\"\n\n        @store.expects(:verify).with(\"mycert\").returns false\n\n        lambda { @ca.verify(\"me\") }.should raise_error\n      end\n    end\n\n    describe \"and revoking certificates\" do\n      before do\n        @crl = mock 'crl'\n        @ca.stubs(:crl).returns @crl\n\n        @ca.stubs(:next_serial).returns 10\n\n        @real_cert = stub 'real_cert', :serial => 15\n        @cert = stub 'cert', :content => @real_cert\n        Puppet::SSL::Certificate.stubs(:find).returns @cert\n\n      end\n\n      it \"should fail if the certificate revocation list is disabled\" do\n        @ca.stubs(:crl).returns false\n\n        lambda { @ca.revoke('ca_testing') }.should raise_error(ArgumentError)\n\n      end\n\n      it \"should delegate the revocation to its CRL\" do\n        @ca.crl.expects(:revoke)\n\n        @ca.revoke('host')\n      end\n\n      it \"should get the serial number from the local certificate if it exists\" do\n        @ca.crl.expects(:revoke).with { |serial, key| serial == 15 }\n\n        Puppet::SSL::Certificate.expects(:find).with(\"host\").returns @cert\n\n        @ca.revoke('host')\n      end\n\n      it \"should get the serial number from inventory if no local certificate exists\" do\n        real_cert = stub 'real_cert', :serial => 15\n        cert = stub 'cert', :content => real_cert\n        Puppet::SSL::Certificate.expects(:find).with(\"host\").returns nil\n\n        @ca.inventory.expects(:serial).with(\"host\").returns 16\n\n        @ca.crl.expects(:revoke).with { |serial, key| serial == 16 }\n        @ca.revoke('host')\n      end\n    end\n\n    it \"should be able to generate a complete new SSL host\" do\n      @ca.should respond_to(:generate)\n    end\n\n    describe \"and generating certificates\" do\n      before do\n        @host = stub 'host', :generate_certificate_request => nil\n        Puppet::SSL::Host.stubs(:new).returns @host\n        Puppet::SSL::Certificate.stubs(:find).returns nil\n\n        @ca.stubs(:sign)\n      end\n\n      it \"should fail if a certificate already exists for the host\" do\n        Puppet::SSL::Certificate.expects(:find).with(\"him\").returns \"something\"\n\n        lambda { @ca.generate(\"him\") }.should raise_error(ArgumentError)\n      end\n\n      it \"should create a new Host instance with the correct name\" do\n        Puppet::SSL::Host.expects(:new).with(\"him\").returns @host\n\n        @ca.generate(\"him\")\n      end\n\n      it \"should use the Host to generate the certificate request\" do\n        @host.expects :generate_certificate_request\n\n        @ca.generate(\"him\")\n      end\n\n      it \"should sign the generated request\" do\n        @ca.expects(:sign).with(\"him\", false)\n        @ca.generate(\"him\")\n      end\n    end\n  end\nend\n"], "filenames": ["lib/puppet/ssl/certificate_authority.rb", "spec/unit/ssl/certificate_authority_spec.rb"], "buggy_code_start_loc": [302, 249], "buggy_code_end_loc": [302, 509], "fixing_code_start_loc": [303, 249], "fixing_code_end_loc": [314, 574], "type": "CWE-264", "message": "lib/puppet/ssl/certificate_authority.rb in Puppet before 2.6.17 and 2.7.x before 2.7.18, and Puppet Enterprise before 2.5.2, does not properly restrict the characters in the Common Name field of a Certificate Signing Request (CSR), which makes it easier for user-assisted remote attackers to trick administrators into signing a crafted agent certificate via ANSI control sequences.", "other": {"cve": {"id": "CVE-2012-3867", "sourceIdentifier": "cve@mitre.org", "published": "2012-08-06T16:55:06.680", "lastModified": "2019-07-10T18:02:28.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/puppet/ssl/certificate_authority.rb in Puppet before 2.6.17 and 2.7.x before 2.7.18, and Puppet Enterprise before 2.5.2, does not properly restrict the characters in the Common Name field of a Certificate Signing Request (CSR), which makes it easier for user-assisted remote attackers to trick administrators into signing a crafted agent certificate via ANSI control sequences."}, {"lang": "es", "value": "lib/puppet/ssl/certificate_authority.rb en Puppet anteriores a v2.6.17 y v2.7.x anteriores a v2.7.18, y Puppet Enterprise anterior a v2.5.2, no restringe de forma adecuada los caracteres en el campo Common Name de una Certificate Signing Request (CSR), lo que facilita a atacantes remotos asistidos por usuarios a enga\u00f1ar a los administradores para firmar un certificado manipulado a trav\u00e9s de secuencias de control ANSI.\r\n\r\n"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BEF50EE-4E4B-4641-BA34-B5024F1EF683"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "1CC72248-FD33-4CA0-A16E-0A174A864257"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "7CEFB16E-261F-4B81-BCBE-536CAD2EC44B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "652D28FC-7133-4C5F-95D9-3468548465B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "AEEEE59D-BC0E-4107-B55D-9B182825E557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "B4ED400E-48F7-475B-A87C-A14EC63DD93D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "D827D4C2-7438-4EDD-9025-38D46CD5153C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "E73C341A-6C07-4820-B1D3-4616B634F380"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "61381D4C-972F-4979-84D2-793E4C60E23E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "7D8C2A71-0277-4426-8627-D6FD275EFC62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "3FB3C44C-2C6C-496C-9D2E-C43FFB493C42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "AD2656B0-9606-477B-BEB3-35746218BF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.12:*:*:*:*:*:*:*", "matchCriteriaId": "848F82FB-ACCE-42C0-A208-55522A030835"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.13:*:*:*:*:*:*:*", "matchCriteriaId": "B0BBFAA7-BB3F-49D2-975B-01194C66D7C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.14:*:*:*:*:*:*:*", "matchCriteriaId": "515BBBBF-7F42-490E-BF9D-B01AA3DD61C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.6.15:*:*:*:*:*:*:*", "matchCriteriaId": "31C87FE4-D9E8-4619-9ADB-DFC2D3FE4FB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "BE56BA6B-BDC4-431E-81FD-D7ED5E8783E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "FDDDFB28-1971-4CCD-93D2-ABC08FE67F4A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "508105B4-619A-4A9D-8B2F-FE5992C1006A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "26DB96A5-A57D-452F-A452-98B11F51CAE6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "D33AF704-FA05-4EA8-BE95-0177871A810F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "390FC5AE-4939-468C-B323-6B4E267A0F4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "07DE4213-E233-402E-88C2-B7FF8D7B682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "4122D8E3-24AD-4A55-9F89-C3AAD50E638D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "AF6D6B90-62BA-4944-A699-6D7C48AFD0A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.11:*:*:*:*:*:*:*", "matchCriteriaId": "8EC6A7B3-5949-4439-994A-68DA65438F5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.12:*:*:*:*:*:*:*", "matchCriteriaId": "5140C34D-589C-43DB-BCA7-8434EB173205"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.13:*:*:*:*:*:*:*", "matchCriteriaId": "E561C081-6262-46D3-AB17-01EEA6D3E988"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.14:*:*:*:*:*:*:*", "matchCriteriaId": "4703802D-0E3A-4760-B660-6AE0AF74DD40"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.16:*:*:*:*:*:*:*", "matchCriteriaId": "BE3D39F6-F9C8-4E7F-981A-265B04E85579"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet:2.7.17:*:*:*:*:*:*:*", "matchCriteriaId": "FEBB3936-7A81-4BD9-80B2-3F614980BBCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppetlabs:puppet:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.16", "matchCriteriaId": "BE6F41EF-556F-42E0-B26C-B96CD9C77B2B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppetlabs:puppet:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "1E5192CB-094F-469E-A644-2255C4F44804"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puppetlabs:puppet:2.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "D17D2752-CB0D-4CC8-8604-FEBF8DEE16E0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "036E8A89-7A16-411F-9D31-676313BB7244"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:lts:*:*:*", "matchCriteriaId": "5D37DF0F-F863-45AC-853A-3E04F9FEC7CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:11.04:*:*:*:*:*:*:*", "matchCriteriaId": "EF49D26F-142E-468B-87C1-BABEA445255C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:11.10:*:*:*:*:*:*:*", "matchCriteriaId": "E4174F4F-149E-41A6-BBCC-D01114C05F38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.1:*:*:*:*:*:*:*", "matchCriteriaId": "EBB2C482-D2A4-48B3-ACE7-E1DFDCC409B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "60FBDD82-691C-4D9D-B71B-F9AFF6931B53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "00720D8C-3FF3-4B1C-B74B-91F01A544399"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "EE26596F-F10E-44EF-88CA-0080646E91B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:vmware:*:*", "matchCriteriaId": "A6B7CDCA-6F39-4113-B5D3-3AA9D7F3D809"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "F084E6C1-8DB0-4D1F-B8EB-5D2CD9AD6E87"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puppet:puppet_enterprise:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.1", "matchCriteriaId": "F66C1E54-FBEA-4008-BC88-A390D415F3F5"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2012-08/msg00006.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2012-07/msg00036.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://puppetlabs.com/security/cve/cve-2012-3867/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.debian.org/security/2012/dsa-2511", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1506-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=839158", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/puppetlabs/puppet/commit/dfedaa5fa841ccf335245a748b347b7c7c236640", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Issue Tracking"]}, {"url": "https://github.com/puppetlabs/puppet/commit/f3419620b42080dad3b0be14470b20a972f13c50", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/puppetlabs/puppet/commit/dfedaa5fa841ccf335245a748b347b7c7c236640"}}