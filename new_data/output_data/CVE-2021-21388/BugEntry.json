{"buggy_code": ["'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2021\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\n// const exec = require('child_process').exec;\nconst execFile = require('child_process').execFile;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        url: url,\n        ok: false,\n        status: 404,\n        ms: null\n      };\n      if (typeof url !== 'string') {\n        if (callback) { callback(result); }\n        return resolve(result);\n      }\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url, true);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1] && sl[0].length === 1) {\n            urlSanitized = urlSanitized + sl[0];\n          }\n        }\n      }\n      result.url = urlSanitized;\n      try {\n        if (urlSanitized && !util.isPrototypePolluted()) {\n          urlSanitized.__proto__.startsWith = util.stringStartWith;\n          if (urlSanitized.startsWith('file:')) {\n            if (callback) { callback(result); }\n            return resolve(result);\n          }\n          let t = Date.now();\n          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n            let args = ['-I', '--connect-timeout', '5', '-m', '5'];\n            args.push(urlSanitized);\n            let cmd = 'curl';\n            util.execSave(cmd, args).then((stdout) => {\n              const lines = stdout.split('\\n');\n              let statusCode = lines[0] && lines[0].indexOf(' ') >= 0 ? parseInt(lines[0].split(' ')[1], 10) : 404;\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n              result.ms = (result.ok ? Date.now() - t : null);\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          }\n          if (_windows) {   // if this is stable, this can be used for all OS types\n            const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n            try {\n              http.get(urlSanitized, (res) => {\n                const statusCode = res.statusCode;\n\n                result.status = statusCode || 404;\n                result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n                if (statusCode !== 200) {\n                  res.resume();\n                  result.ms = (result.ok ? Date.now() - t : null);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  res.on('data', () => { });\n                  res.on('end', () => {\n                    result.ms = (result.ok ? Date.now() - t : null);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              }).on('error', () => {\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } catch (err) {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } catch (err) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof host !== 'string') {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let hostSanitized = '';\n      const s = (util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host, true)).trim();\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1]) {\n            hostSanitized = hostSanitized + sl[0];\n          }\n        }\n      }\n      hostSanitized.__proto__.startsWith = util.stringStartWith;\n      if (hostSanitized.startsWith('file:')) {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let params;\n      let filt;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          params = '-c 2 -w 3 ' + hostSanitized;\n          filt = 'rtt';\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          params = '-c 2 -t 3 ' + hostSanitized;\n          filt = 'round-trip';\n        }\n        if (_darwin) {\n          params = '-c2 -t3 ' + hostSanitized;\n          filt = 'avg';\n        }\n        util.execSave('ping', params.split(' ')).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        const params = '-s -a ' + hostSanitized + ' 56 2';\n        const filt = 'avg';\n        util.execSave('ping', params.split(' '), { timeout: 3000 }).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = null;\n        try {\n          const params = hostSanitized + ' -n 1';\n          execFile('ping', params.split(' '), util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n"], "fixing_code": ["'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2021\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\n// const exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = {\n        url: url,\n        ok: false,\n        status: 404,\n        ms: null\n      };\n      if (typeof url !== 'string') {\n        if (callback) { callback(result); }\n        return resolve(result);\n      }\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url, true);\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1] && sl[0].length === 1) {\n            urlSanitized = urlSanitized + sl[0];\n          }\n        }\n      }\n      result.url = urlSanitized;\n      try {\n        if (urlSanitized && !util.isPrototypePolluted()) {\n          urlSanitized.__proto__.startsWith = util.stringStartWith;\n          if (urlSanitized.startsWith('file:')) {\n            if (callback) { callback(result); }\n            return resolve(result);\n          }\n          let t = Date.now();\n          if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n            let args = ['-I', '--connect-timeout', '5', '-m', '5'];\n            args.push(urlSanitized);\n            let cmd = 'curl';\n            util.execSave(cmd, args).then((stdout) => {\n              const lines = stdout.split('\\n');\n              let statusCode = lines[0] && lines[0].indexOf(' ') >= 0 ? parseInt(lines[0].split(' ')[1], 10) : 404;\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n              result.ms = (result.ok ? Date.now() - t : null);\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          }\n          if (_windows) {   // if this is stable, this can be used for all OS types\n            const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n            try {\n              http.get(urlSanitized, (res) => {\n                const statusCode = res.statusCode;\n\n                result.status = statusCode || 404;\n                result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n                if (statusCode !== 200) {\n                  res.resume();\n                  result.ms = (result.ok ? Date.now() - t : null);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                } else {\n                  res.on('data', () => { });\n                  res.on('end', () => {\n                    result.ms = (result.ok ? Date.now() - t : null);\n                    if (callback) { callback(result); }\n                    resolve(result);\n                  });\n                }\n              }).on('error', () => {\n                if (callback) { callback(result); }\n                resolve(result);\n              });\n            } catch (err) {\n              if (callback) { callback(result); }\n              resolve(result);\n            }\n          }\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      } catch (err) {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      if (typeof host !== 'string') {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let hostSanitized = '';\n      const s = (util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host, true)).trim();\n      for (let i = 0; i <= util.mathMin(s.length, 2000); i++) {\n        if (!(s[i] === undefined)) {\n          s[i].__proto__.toLowerCase = util.stringToLower;\n          const sl = s[i].toLowerCase();\n          if (sl && sl[0] && !sl[1]) {\n            hostSanitized = hostSanitized + sl[0];\n          }\n        }\n      }\n      hostSanitized.__proto__.startsWith = util.stringStartWith;\n      if (hostSanitized.startsWith('file:')) {\n        if (callback) { callback(null); }\n        return resolve(null);\n      }\n      let params;\n      let filt;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          params = '-c 2 -w 3 ' + hostSanitized;\n          filt = 'rtt';\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          params = '-c 2 -t 3 ' + hostSanitized;\n          filt = 'round-trip';\n        }\n        if (_darwin) {\n          params = '-c2 -t3 ' + hostSanitized;\n          filt = 'avg';\n        }\n        util.execSave('ping', params.split(' ')).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        const params = '-s -a ' + hostSanitized + ' 56 2';\n        const filt = 'avg';\n        util.execSave('ping', params.split(' '), { timeout: 3000 }).then((stdout) => {\n          let result = null;\n          if (stdout) {\n            const lines = stdout.split('\\n').filter(line => line.indexOf(filt) >= 0).join('\\n');\n            const line = lines.split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = null;\n        try {\n          const params = hostSanitized + ' -n 1';\n          util.execSave('ping', params.split(' '), util.execOptsWin).then((stdout) => {\n            if (stdout) {\n              let lines = stdout.split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n"], "filenames": ["lib/internet.js"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [219], "fixing_code_start_loc": [16], "fixing_code_end_loc": [218], "type": "CWE-78", "message": "systeminformation is an open source system and OS information library for node.js. A command injection vulnerability has been discovered in versions of systeminformation prior to 5.6.4. The issue has been fixed with a parameter check on user input. Please upgrade to version >= 5.6.4. If you cannot upgrade, be sure to check or sanitize service parameters that are passed to si.inetLatency(), si.inetChecksite(), si.services(), si.processLoad() and other commands. Only allow strings, reject any arrays. String sanitation works as expected.", "other": {"cve": {"id": "CVE-2021-21388", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-29T18:15:09.540", "lastModified": "2021-05-05T20:31:16.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "systeminformation is an open source system and OS information library for node.js. A command injection vulnerability has been discovered in versions of systeminformation prior to 5.6.4. The issue has been fixed with a parameter check on user input. Please upgrade to version >= 5.6.4. If you cannot upgrade, be sure to check or sanitize service parameters that are passed to si.inetLatency(), si.inetChecksite(), si.services(), si.processLoad() and other commands. Only allow strings, reject any arrays. String sanitation works as expected."}, {"lang": "es", "value": "systemminformation es un sistema de c\u00f3digo abierto y una biblioteca de informaci\u00f3n de SO para node.js.&#xa0;Se ha detectado una vulnerabilidad de inyecci\u00f3n de comandos en systeminformation versiones de anteriores a 5.6.4.&#xa0;El problema ha sido corregido con una comprobaci\u00f3n de par\u00e1metros en la entrada del usuario.&#xa0;Por favor actualice a  las versiones posteriores a 5.6.4 e incluy\u00e9ndola.&#xa0;Si no puede actualizar, aseg\u00farese de comprobar o sanear los par\u00e1metros de servicio que son pasados a si.inetLatency (), si.inetChecksite(), si.services(), si.processLoad() y otros comandos.&#xa0;Solo permita cadenas, rechace cualquier arreglo.&#xa0;El saneamiento de cuerdas funciona como se esperaba"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systeminformation:systeminformation:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.6.4", "matchCriteriaId": "2AA615B0-8C40-4213-8F73-1CAC8D0BF980"}]}]}], "references": [{"url": "https://github.com/sebhildebrandt/systeminformation/commit/01ef56cd5824ed6da1c11b37013a027fdef67524", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/commit/0be6fcd575c05687d1076d5cd6d75af2ebae5a46", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/commit/7922366d707de7f20995fc8e30ac3153636bf35f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/security/advisories/GHSA-jff2-qjw8-5476", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/systeminformation", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sebhildebrandt/systeminformation/commit/01ef56cd5824ed6da1c11b37013a027fdef67524"}}