{"buggy_code": ["/*\n * Copyright \u00a9 2013 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/******************************************************************\n\n              Copyright 1992 by Oki Technosystems Laboratory, Inc.\n              Copyright 1992 by Fuji Xerox Co., Ltd.\n\nPermission to use, copy, modify, distribute, and sell this software\nand its documentation for any purpose is hereby granted without fee,\nprovided that the above copyright notice appear in all copies and\nthat both that copyright notice and this permission notice appear\nin supporting documentation, and that the name of Oki Technosystems\nLaboratory and Fuji Xerox not be used in advertising or publicity\npertaining to distribution of the software without specific, written\nprior permission.\nOki Technosystems Laboratory and Fuji Xerox make no representations\nabout the suitability of this software for any purpose.  It is provided\n\"as is\" without express or implied warranty.\n\nOKI TECHNOSYSTEMS LABORATORY AND FUJI XEROX DISCLAIM ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL OKI TECHNOSYSTEMS\nLABORATORY AND FUJI XEROX BE LIABLE FOR ANY SPECIAL, INDIRECT OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\nOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE\nOR PERFORMANCE OF THIS SOFTWARE.\n\n  Author: Yasuhiro Kawai        Oki Technosystems Laboratory\n  Author: Kazunori Nishihara    Fuji Xerox\n\n******************************************************************/\n\n#include <errno.h>\n\n#include \"utils.h\"\n#include \"scanner-utils.h\"\n#include \"table.h\"\n#include \"paths.h\"\n#include \"utf8.h\"\n#include \"parser.h\"\n\n#define MAX_LHS_LEN 10\n#define MAX_INCLUDE_DEPTH 5\n\n/*\n * Grammar adapted from libX11/modules/im/ximcp/imLcPrs.c.\n * See also the XCompose(5) manpage.\n *\n * FILE          ::= { [PRODUCTION] [COMMENT] \"\\n\" | INCLUDE }\n * INCLUDE       ::= \"include\" '\"' INCLUDE_STRING '\"'\n * PRODUCTION    ::= LHS \":\" RHS [ COMMENT ]\n * COMMENT       ::= \"#\" {<any character except null or newline>}\n * LHS           ::= EVENT { EVENT }\n * EVENT         ::= [MODIFIER_LIST] \"<\" keysym \">\"\n * MODIFIER_LIST ::= ([\"!\"] {MODIFIER} ) | \"None\"\n * MODIFIER      ::= [\"~\"] MODIFIER_NAME\n * MODIFIER_NAME ::= (\"Ctrl\"|\"Lock\"|\"Caps\"|\"Shift\"|\"Alt\"|\"Meta\")\n * RHS           ::= ( STRING | keysym | STRING keysym )\n * STRING        ::= '\"' { CHAR } '\"'\n * CHAR          ::= GRAPHIC_CHAR | ESCAPED_CHAR\n * GRAPHIC_CHAR  ::= locale (codeset) dependent code\n * ESCAPED_CHAR  ::= ('\\\\' | '\\\"' | OCTAL | HEX )\n * OCTAL         ::= '\\' OCTAL_CHAR [OCTAL_CHAR [OCTAL_CHAR]]\n * OCTAL_CHAR    ::= (0|1|2|3|4|5|6|7)\n * HEX           ::= '\\' (x|X) HEX_CHAR [HEX_CHAR]]\n * HEX_CHAR      ::= (0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)\n *\n * INCLUDE_STRING is a filesystem path, with the following %-expansions:\n *     %% - '%'.\n *     %H - The user's home directory (the $HOME environment variable).\n *     %L - The name of the locale specific Compose file (e.g.,\n *          \"/usr/share/X11/locale/<localename>/Compose\").\n *     %S - The name of the system directory for Compose files (e.g.,\n *          \"/usr/share/X11/locale\").\n */\n\nenum rules_token {\n    TOK_END_OF_FILE = 0,\n    TOK_END_OF_LINE,\n    TOK_INCLUDE,\n    TOK_INCLUDE_STRING,\n    TOK_LHS_KEYSYM,\n    TOK_COLON,\n    TOK_BANG,\n    TOK_TILDE,\n    TOK_STRING,\n    TOK_IDENT,\n    TOK_ERROR\n};\n\n/* Values returned with some tokens, like yylval. */\nunion lvalue {\n    struct {\n        /* Still \\0-terminated. */\n        const char *str;\n        size_t len;\n    } string;\n};\n\nstatic enum rules_token\nlex(struct scanner *s, union lvalue *val)\n{\nskip_more_whitespace_and_comments:\n    /* Skip spaces. */\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    /* Skip comments. */\n    if (chr(s, '#')) {\n        skip_to_eol(s);\n        goto skip_more_whitespace_and_comments;\n    }\n\n    /* See if we're done. */\n    if (eof(s)) return TOK_END_OF_FILE;\n\n    /* New token. */\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    /* LHS Keysym. */\n    if (chr(s, '<')) {\n        while (peek(s) != '>' && !eol(s))\n            buf_append(s, next(s));\n        if (!chr(s, '>')) {\n            scanner_err(s, \"unterminated keysym literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"keysym literal is too long\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_LHS_KEYSYM;\n    }\n\n    /* Colon. */\n    if (chr(s, ':'))\n        return TOK_COLON;\n    if (chr(s, '!'))\n        return TOK_BANG;\n    if (chr(s, '~'))\n        return TOK_TILDE;\n\n    /* String literal. */\n    if (chr(s, '\\\"')) {\n        while (!eof(s) && !eol(s) && peek(s) != '\\\"') {\n            if (chr(s, '\\\\')) {\n                uint8_t o;\n                if (chr(s, '\\\\')) {\n                    buf_append(s, '\\\\');\n                }\n                else if (chr(s, '\"')) {\n                    buf_append(s, '\"');\n                }\n                else if (chr(s, 'x') || chr(s, 'X')) {\n                    if (hex(s, &o))\n                        buf_append(s, (char) o);\n                    else\n                        scanner_warn(s, \"illegal hexadecimal escape sequence in string literal\");\n                }\n                else if (oct(s, &o)) {\n                    buf_append(s, (char) o);\n                }\n                else {\n                    scanner_warn(s, \"unknown escape sequence (%c) in string literal\", peek(s));\n                    /* Ignore. */\n                }\n            } else {\n                buf_append(s, next(s));\n            }\n        }\n        if (!chr(s, '\\\"')) {\n            scanner_err(s, \"unterminated string literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"string literal is too long\");\n            return TOK_ERROR;\n        }\n        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {\n            scanner_err(s, \"string literal is not a valid UTF-8 string\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_STRING;\n    }\n\n    /* Identifier or include. */\n    if (is_alpha(peek(s)) || peek(s) == '_') {\n        s->buf_pos = 0;\n        while (is_alnum(peek(s)) || peek(s) == '_')\n            buf_append(s, next(s));\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"identifier is too long\");\n            return TOK_ERROR;\n        }\n\n        if (streq(s->buf, \"include\"))\n            return TOK_INCLUDE;\n\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_IDENT;\n    }\n\n    /* Discard rest of line. */\n    skip_to_eol(s);\n\n    scanner_err(s, \"unrecognized token\");\n    return TOK_ERROR;\n}\n\nstatic enum rules_token\nlex_include_string(struct scanner *s, struct xkb_compose_table *table,\n                   union lvalue *val_out)\n{\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    if (!chr(s, '\\\"')) {\n        scanner_err(s, \"include statement must be followed by a path\");\n        return TOK_ERROR;\n    }\n\n    while (!eof(s) && !eol(s) && peek(s) != '\\\"') {\n        if (chr(s, '%')) {\n            if (chr(s, '%')) {\n                buf_append(s, '%');\n            }\n            else if (chr(s, 'H')) {\n                const char *home = secure_getenv(\"HOME\");\n                if (!home) {\n                    scanner_err(s, \"%%H was used in an include statement, but the HOME environment variable is not set\");\n                    return TOK_ERROR;\n                }\n                if (!buf_appends(s, home)) {\n                    scanner_err(s, \"include path after expanding %%H is too long\");\n                    return TOK_ERROR;\n                }\n            }\n            else if (chr(s, 'L')) {\n                char *path = get_locale_compose_file_path(table->locale);\n                if (!path) {\n                    scanner_err(s, \"failed to expand %%L to the locale Compose file\");\n                    return TOK_ERROR;\n                }\n                if (!buf_appends(s, path)) {\n                    free(path);\n                    scanner_err(s, \"include path after expanding %%L is too long\");\n                    return TOK_ERROR;\n                }\n                free(path);\n            }\n            else if (chr(s, 'S')) {\n                const char *xlocaledir = get_xlocaledir_path();\n                if (!buf_appends(s, xlocaledir)) {\n                    scanner_err(s, \"include path after expanding %%S is too long\");\n                    return TOK_ERROR;\n                }\n            }\n            else {\n                scanner_err(s, \"unknown %% format (%c) in include statement\", peek(s));\n                return TOK_ERROR;\n            }\n        } else {\n            buf_append(s, next(s));\n        }\n    }\n    if (!chr(s, '\\\"')) {\n        scanner_err(s, \"unterminated include statement\");\n        return TOK_ERROR;\n    }\n    if (!buf_append(s, '\\0')) {\n        scanner_err(s, \"include path is too long\");\n        return TOK_ERROR;\n    }\n    val_out->string.str = s->buf;\n    val_out->string.len = s->buf_pos;\n    return TOK_INCLUDE_STRING;\n}\n\nstruct production {\n    xkb_keysym_t lhs[MAX_LHS_LEN];\n    unsigned int len;\n    xkb_keysym_t keysym;\n    char string[256];\n    /* At least one of these is true. */\n    bool has_keysym;\n    bool has_string;\n\n    /* The matching is as follows: (active_mods & modmask) == mods. */\n    xkb_mod_mask_t modmask;\n    xkb_mod_mask_t mods;\n};\n\nstatic uint32_t\nadd_node(struct xkb_compose_table *table, xkb_keysym_t keysym)\n{\n    struct compose_node new = {\n        .keysym = keysym,\n        .next = 0,\n        .is_leaf = true,\n    };\n    darray_append(table->nodes, new);\n    return darray_size(table->nodes) - 1;\n}\n\nstatic void\nadd_production(struct xkb_compose_table *table, struct scanner *s,\n               const struct production *production)\n{\n    unsigned lhs_pos;\n    uint32_t curr;\n    struct compose_node *node;\n\n    curr = 0;\n    node = &darray_item(table->nodes, curr);\n\n    /*\n     * Insert the sequence to the trie, creating new nodes as needed.\n     *\n     * TODO: This can be sped up a bit by first trying the path that the\n     * previous production took, and only then doing the linear search\n     * through the trie levels.  This will work because sequences in the\n     * Compose files are often clustered by a common prefix; especially\n     * in the 1st and 2nd keysyms, which is where the largest variation\n     * (thus, longest search) is.\n     */\n    for (lhs_pos = 0; lhs_pos < production->len; lhs_pos++) {\n        while (production->lhs[lhs_pos] != node->keysym) {\n            if (node->next == 0) {\n                uint32_t next = add_node(table, production->lhs[lhs_pos]);\n                /* Refetch since add_node could have realloc()ed. */\n                node = &darray_item(table->nodes, curr);\n                node->next = next;\n            }\n\n            curr = node->next;\n            node = &darray_item(table->nodes, curr);\n        }\n\n        if (lhs_pos + 1 == production->len)\n            break;\n\n        if (node->is_leaf) {\n            if (node->u.leaf.utf8 != 0 ||\n                node->u.leaf.keysym != XKB_KEY_NoSymbol) {\n                scanner_warn(s, \"a sequence already exists which is a prefix of this sequence; overriding\");\n                node->u.leaf.utf8 = 0;\n                node->u.leaf.keysym = XKB_KEY_NoSymbol;\n            }\n\n            {\n                uint32_t successor = add_node(table, production->lhs[lhs_pos + 1]);\n                /* Refetch since add_node could have realloc()ed. */\n                node = &darray_item(table->nodes, curr);\n                node->is_leaf = false;\n                node->u.successor = successor;\n            }\n        }\n\n        curr = node->u.successor;\n        node = &darray_item(table->nodes, curr);\n    }\n\n    if (!node->is_leaf) {\n        scanner_warn(s, \"this compose sequence is a prefix of another; skipping line\");\n        return;\n    }\n\n    if (node->u.leaf.utf8 != 0 || node->u.leaf.keysym != XKB_KEY_NoSymbol) {\n        bool same_string =\n            (node->u.leaf.utf8 == 0 && !production->has_string) ||\n            (\n                node->u.leaf.utf8 != 0 && production->has_string &&\n                streq(&darray_item(table->utf8, node->u.leaf.utf8),\n                      production->string)\n            );\n        bool same_keysym =\n            (node->u.leaf.keysym == XKB_KEY_NoSymbol && !production->has_keysym) ||\n            (\n                node->u.leaf.keysym != XKB_KEY_NoSymbol && production->has_keysym &&\n                node->u.leaf.keysym == production->keysym\n            );\n        if (same_string && same_keysym) {\n            scanner_warn(s, \"this compose sequence is a duplicate of another; skipping line\");\n            return;\n        }\n        scanner_warn(s, \"this compose sequence already exists; overriding\");\n    }\n\n    if (production->has_string) {\n        node->u.leaf.utf8 = darray_size(table->utf8);\n        darray_append_items(table->utf8, production->string,\n                            strlen(production->string) + 1);\n    }\n    if (production->has_keysym) {\n        node->u.leaf.keysym = production->keysym;\n    }\n}\n\n/* Should match resolve_modifier(). */\n#define ALL_MODS_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))\n\nstatic xkb_mod_index_t\nresolve_modifier(const char *name)\n{\n    static const struct {\n        const char *name;\n        xkb_mod_index_t mod;\n    } mods[] = {\n        { \"Shift\", 0 },\n        { \"Ctrl\", 2 },\n        { \"Alt\", 3 },\n        { \"Meta\", 3 },\n        { \"Lock\", 1 },\n        { \"Caps\", 1 },\n    };\n\n    for (unsigned i = 0; i < ARRAY_SIZE(mods); i++)\n        if (streq(name, mods[i].name))\n            return mods[i].mod;\n\n    return XKB_MOD_INVALID;\n}\n\nstatic bool\nparse(struct xkb_compose_table *table, struct scanner *s,\n      unsigned include_depth);\n\nstatic bool\ndo_include(struct xkb_compose_table *table, struct scanner *s,\n           const char *path, unsigned include_depth)\n{\n    FILE *file;\n    bool ok;\n    char *string;\n    size_t size;\n    struct scanner new_s;\n\n    if (include_depth >= MAX_INCLUDE_DEPTH) {\n        scanner_err(s, \"maximum include depth (%d) exceeded; maybe there is an include loop?\",\n                    MAX_INCLUDE_DEPTH);\n        return false;\n    }\n\n    file = fopen(path, \"r\");\n    if (!file) {\n        scanner_err(s, \"failed to open included Compose file \\\"%s\\\": %s\",\n                    path, strerror(errno));\n        return false;\n    }\n\n    ok = map_file(file, &string, &size);\n    if (!ok) {\n        scanner_err(s, \"failed to read included Compose file \\\"%s\\\": %s\",\n                    path, strerror(errno));\n        goto err_file;\n    }\n\n    scanner_init(&new_s, table->ctx, string, size, path, s->priv);\n\n    ok = parse(table, &new_s, include_depth + 1);\n    if (!ok)\n        goto err_unmap;\n\nerr_unmap:\n    unmap_file(string, size);\nerr_file:\n    fclose(file);\n    return ok;\n}\n\nstatic bool\nparse(struct xkb_compose_table *table, struct scanner *s,\n      unsigned include_depth)\n{\n    enum rules_token tok;\n    union lvalue val;\n    xkb_keysym_t keysym;\n    struct production production;\n    enum { MAX_ERRORS = 10 };\n    int num_errors = 0;\n\ninitial:\n    production.len = 0;\n    production.has_keysym = false;\n    production.has_string = false;\n    production.mods = 0;\n    production.modmask = 0;\n\n    /* fallthrough */\n\ninitial_eol:\n    switch (tok = lex(s, &val)) {\n    case TOK_END_OF_LINE:\n        goto initial_eol;\n    case TOK_END_OF_FILE:\n        goto finished;\n    case TOK_INCLUDE:\n        goto include;\n    default:\n        goto lhs_tok;\n    }\n\ninclude:\n    switch (tok = lex_include_string(s, table, &val)) {\n    case TOK_INCLUDE_STRING:\n        goto include_eol;\n    default:\n        goto unexpected;\n    }\n\ninclude_eol:\n    switch (tok = lex(s, &val)) {\n    case TOK_END_OF_LINE:\n        if (!do_include(table, s, val.string.str, include_depth))\n            goto fail;\n        goto initial;\n    default:\n        goto unexpected;\n    }\n\nlhs:\n    tok = lex(s, &val);\nlhs_tok:\n    switch (tok) {\n    case TOK_COLON:\n        if (production.len <= 0) {\n            scanner_warn(s, \"expected at least one keysym on left-hand side; skipping line\");\n            goto skip;\n        }\n        goto rhs;\n    case TOK_IDENT:\n        if (streq(val.string.str, \"None\")) {\n            production.mods = 0;\n            production.modmask = ALL_MODS_MASK;\n            goto lhs_keysym;\n        }\n        goto lhs_mod_list_tok;\n    case TOK_TILDE:\n        goto lhs_mod_list_tok;\n    case TOK_BANG:\n        production.modmask = ALL_MODS_MASK;\n        goto lhs_mod_list;\n    default:\n        goto lhs_keysym_tok;\n    }\n\nlhs_keysym:\n    tok = lex(s, &val);\nlhs_keysym_tok:\n    switch (tok) {\n    case TOK_LHS_KEYSYM:\n        keysym = xkb_keysym_from_name(val.string.str, XKB_KEYSYM_NO_FLAGS);\n        if (keysym == XKB_KEY_NoSymbol) {\n            scanner_err(s, \"unrecognized keysym \\\"%s\\\" on left-hand side\",\n                        val.string.str);\n            goto error;\n        }\n        if (production.len + 1 > MAX_LHS_LEN) {\n            scanner_warn(s, \"too many keysyms (%d) on left-hand side; skipping line\",\n                         MAX_LHS_LEN + 1);\n            goto skip;\n        }\n        production.lhs[production.len++] = keysym;\n        production.mods = 0;\n        production.modmask = 0;\n        goto lhs;\n    default:\n        goto unexpected;\n    }\n\nlhs_mod_list:\n    tok = lex(s, &val);\nlhs_mod_list_tok: {\n        bool tilde = false;\n        xkb_mod_index_t mod;\n\n        if (tok != TOK_TILDE && tok != TOK_IDENT)\n            goto lhs_keysym_tok;\n\n        if (tok == TOK_TILDE) {\n            tilde = true;\n            tok = lex(s, &val);\n        }\n\n        if (tok != TOK_IDENT)\n            goto unexpected;\n\n        mod = resolve_modifier(val.string.str);\n        if (mod == XKB_MOD_INVALID) {\n            scanner_err(s, \"unrecognized modifier \\\"%s\\\"\",\n                        val.string.str);\n            goto error;\n        }\n\n        production.modmask |= 1 << mod;\n        if (tilde)\n            production.mods &= ~(1 << mod);\n        else\n            production.mods |= 1 << mod;\n\n        goto lhs_mod_list;\n    }\n\nrhs:\n    switch (tok = lex(s, &val)) {\n    case TOK_STRING:\n        if (production.has_string) {\n            scanner_warn(s, \"right-hand side can have at most one string; skipping line\");\n            goto skip;\n        }\n        if (val.string.len <= 0) {\n            scanner_warn(s, \"right-hand side string must not be empty; skipping line\");\n            goto skip;\n        }\n        if (val.string.len >= sizeof(production.string)) {\n            scanner_warn(s, \"right-hand side string is too long; skipping line\");\n            goto skip;\n        }\n        strcpy(production.string, val.string.str);\n        production.has_string = true;\n        goto rhs;\n    case TOK_IDENT:\n        keysym = xkb_keysym_from_name(val.string.str, XKB_KEYSYM_NO_FLAGS);\n        if (keysym == XKB_KEY_NoSymbol) {\n            scanner_err(s, \"unrecognized keysym \\\"%s\\\" on right-hand side\",\n                        val.string.str);\n            goto error;\n        }\n        if (production.has_keysym) {\n            scanner_warn(s, \"right-hand side can have at most one keysym; skipping line\");\n            goto skip;\n        }\n        production.keysym = keysym;\n        production.has_keysym = true;\n\t/* fallthrough */\n    case TOK_END_OF_LINE:\n        if (!production.has_string && !production.has_keysym) {\n            scanner_warn(s, \"right-hand side must have at least one of string or keysym; skipping line\");\n            goto skip;\n        }\n        add_production(table, s, &production);\n        goto initial;\n    default:\n        goto unexpected;\n    }\n\nunexpected:\n    if (tok != TOK_ERROR)\n        scanner_err(s, \"unexpected token\");\nerror:\n    num_errors++;\n    if (num_errors <= MAX_ERRORS)\n        goto skip;\n\n    scanner_err(s, \"too many errors\");\n    goto fail;\n\nfail:\n    scanner_err(s, \"failed to parse file\");\n    return false;\n\nskip:\n    while (tok != TOK_END_OF_LINE && tok != TOK_END_OF_FILE)\n        tok = lex(s, &val);\n    goto initial;\n\nfinished:\n    return true;\n}\n\nbool\nparse_string(struct xkb_compose_table *table, const char *string, size_t len,\n             const char *file_name)\n{\n    struct scanner s;\n    scanner_init(&s, table->ctx, string, len, file_name, NULL);\n    if (!parse(table, &s, 0))\n        return false;\n    /* Maybe the allocator can use the excess space. */\n    darray_shrink(table->nodes);\n    darray_shrink(table->utf8);\n    return true;\n}\n\nbool\nparse_file(struct xkb_compose_table *table, FILE *file, const char *file_name)\n{\n    bool ok;\n    char *string;\n    size_t size;\n\n    ok = map_file(file, &string, &size);\n    if (!ok) {\n        log_err(table->ctx, \"Couldn't read Compose file %s: %s\\n\",\n                file_name, strerror(errno));\n        return false;\n    }\n\n    ok = parse_string(table, string, size, file_name);\n    unmap_file(string, size);\n    return ok;\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2013 Ran Benita <ran234@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice (including the next\n * paragraph) shall be included in all copies or substantial portions of the\n * Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/******************************************************************\n\n              Copyright 1992 by Oki Technosystems Laboratory, Inc.\n              Copyright 1992 by Fuji Xerox Co., Ltd.\n\nPermission to use, copy, modify, distribute, and sell this software\nand its documentation for any purpose is hereby granted without fee,\nprovided that the above copyright notice appear in all copies and\nthat both that copyright notice and this permission notice appear\nin supporting documentation, and that the name of Oki Technosystems\nLaboratory and Fuji Xerox not be used in advertising or publicity\npertaining to distribution of the software without specific, written\nprior permission.\nOki Technosystems Laboratory and Fuji Xerox make no representations\nabout the suitability of this software for any purpose.  It is provided\n\"as is\" without express or implied warranty.\n\nOKI TECHNOSYSTEMS LABORATORY AND FUJI XEROX DISCLAIM ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS, IN NO EVENT SHALL OKI TECHNOSYSTEMS\nLABORATORY AND FUJI XEROX BE LIABLE FOR ANY SPECIAL, INDIRECT OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\nOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE\nOR PERFORMANCE OF THIS SOFTWARE.\n\n  Author: Yasuhiro Kawai        Oki Technosystems Laboratory\n  Author: Kazunori Nishihara    Fuji Xerox\n\n******************************************************************/\n\n#include <errno.h>\n\n#include \"utils.h\"\n#include \"scanner-utils.h\"\n#include \"table.h\"\n#include \"paths.h\"\n#include \"utf8.h\"\n#include \"parser.h\"\n\n#define MAX_LHS_LEN 10\n#define MAX_INCLUDE_DEPTH 5\n\n/*\n * Grammar adapted from libX11/modules/im/ximcp/imLcPrs.c.\n * See also the XCompose(5) manpage.\n *\n * FILE          ::= { [PRODUCTION] [COMMENT] \"\\n\" | INCLUDE }\n * INCLUDE       ::= \"include\" '\"' INCLUDE_STRING '\"'\n * PRODUCTION    ::= LHS \":\" RHS [ COMMENT ]\n * COMMENT       ::= \"#\" {<any character except null or newline>}\n * LHS           ::= EVENT { EVENT }\n * EVENT         ::= [MODIFIER_LIST] \"<\" keysym \">\"\n * MODIFIER_LIST ::= ([\"!\"] {MODIFIER} ) | \"None\"\n * MODIFIER      ::= [\"~\"] MODIFIER_NAME\n * MODIFIER_NAME ::= (\"Ctrl\"|\"Lock\"|\"Caps\"|\"Shift\"|\"Alt\"|\"Meta\")\n * RHS           ::= ( STRING | keysym | STRING keysym )\n * STRING        ::= '\"' { CHAR } '\"'\n * CHAR          ::= GRAPHIC_CHAR | ESCAPED_CHAR\n * GRAPHIC_CHAR  ::= locale (codeset) dependent code\n * ESCAPED_CHAR  ::= ('\\\\' | '\\\"' | OCTAL | HEX )\n * OCTAL         ::= '\\' OCTAL_CHAR [OCTAL_CHAR [OCTAL_CHAR]]\n * OCTAL_CHAR    ::= (0|1|2|3|4|5|6|7)\n * HEX           ::= '\\' (x|X) HEX_CHAR [HEX_CHAR]]\n * HEX_CHAR      ::= (0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|a|b|c|d|e|f)\n *\n * INCLUDE_STRING is a filesystem path, with the following %-expansions:\n *     %% - '%'.\n *     %H - The user's home directory (the $HOME environment variable).\n *     %L - The name of the locale specific Compose file (e.g.,\n *          \"/usr/share/X11/locale/<localename>/Compose\").\n *     %S - The name of the system directory for Compose files (e.g.,\n *          \"/usr/share/X11/locale\").\n */\n\nenum rules_token {\n    TOK_END_OF_FILE = 0,\n    TOK_END_OF_LINE,\n    TOK_INCLUDE,\n    TOK_INCLUDE_STRING,\n    TOK_LHS_KEYSYM,\n    TOK_COLON,\n    TOK_BANG,\n    TOK_TILDE,\n    TOK_STRING,\n    TOK_IDENT,\n    TOK_ERROR\n};\n\n/* Values returned with some tokens, like yylval. */\nunion lvalue {\n    struct {\n        /* Still \\0-terminated. */\n        const char *str;\n        size_t len;\n    } string;\n};\n\nstatic enum rules_token\nlex(struct scanner *s, union lvalue *val)\n{\nskip_more_whitespace_and_comments:\n    /* Skip spaces. */\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    /* Skip comments. */\n    if (chr(s, '#')) {\n        skip_to_eol(s);\n        goto skip_more_whitespace_and_comments;\n    }\n\n    /* See if we're done. */\n    if (eof(s)) return TOK_END_OF_FILE;\n\n    /* New token. */\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    /* LHS Keysym. */\n    if (chr(s, '<')) {\n        while (peek(s) != '>' && !eol(s) && !eof(s))\n            buf_append(s, next(s));\n        if (!chr(s, '>')) {\n            scanner_err(s, \"unterminated keysym literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"keysym literal is too long\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_LHS_KEYSYM;\n    }\n\n    /* Colon. */\n    if (chr(s, ':'))\n        return TOK_COLON;\n    if (chr(s, '!'))\n        return TOK_BANG;\n    if (chr(s, '~'))\n        return TOK_TILDE;\n\n    /* String literal. */\n    if (chr(s, '\\\"')) {\n        while (!eof(s) && !eol(s) && peek(s) != '\\\"') {\n            if (chr(s, '\\\\')) {\n                uint8_t o;\n                if (chr(s, '\\\\')) {\n                    buf_append(s, '\\\\');\n                }\n                else if (chr(s, '\"')) {\n                    buf_append(s, '\"');\n                }\n                else if (chr(s, 'x') || chr(s, 'X')) {\n                    if (hex(s, &o))\n                        buf_append(s, (char) o);\n                    else\n                        scanner_warn(s, \"illegal hexadecimal escape sequence in string literal\");\n                }\n                else if (oct(s, &o)) {\n                    buf_append(s, (char) o);\n                }\n                else {\n                    scanner_warn(s, \"unknown escape sequence (%c) in string literal\", peek(s));\n                    /* Ignore. */\n                }\n            } else {\n                buf_append(s, next(s));\n            }\n        }\n        if (!chr(s, '\\\"')) {\n            scanner_err(s, \"unterminated string literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"string literal is too long\");\n            return TOK_ERROR;\n        }\n        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {\n            scanner_err(s, \"string literal is not a valid UTF-8 string\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_STRING;\n    }\n\n    /* Identifier or include. */\n    if (is_alpha(peek(s)) || peek(s) == '_') {\n        s->buf_pos = 0;\n        while (is_alnum(peek(s)) || peek(s) == '_')\n            buf_append(s, next(s));\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"identifier is too long\");\n            return TOK_ERROR;\n        }\n\n        if (streq(s->buf, \"include\"))\n            return TOK_INCLUDE;\n\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_IDENT;\n    }\n\n    /* Discard rest of line. */\n    skip_to_eol(s);\n\n    scanner_err(s, \"unrecognized token\");\n    return TOK_ERROR;\n}\n\nstatic enum rules_token\nlex_include_string(struct scanner *s, struct xkb_compose_table *table,\n                   union lvalue *val_out)\n{\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    if (!chr(s, '\\\"')) {\n        scanner_err(s, \"include statement must be followed by a path\");\n        return TOK_ERROR;\n    }\n\n    while (!eof(s) && !eol(s) && peek(s) != '\\\"') {\n        if (chr(s, '%')) {\n            if (chr(s, '%')) {\n                buf_append(s, '%');\n            }\n            else if (chr(s, 'H')) {\n                const char *home = secure_getenv(\"HOME\");\n                if (!home) {\n                    scanner_err(s, \"%%H was used in an include statement, but the HOME environment variable is not set\");\n                    return TOK_ERROR;\n                }\n                if (!buf_appends(s, home)) {\n                    scanner_err(s, \"include path after expanding %%H is too long\");\n                    return TOK_ERROR;\n                }\n            }\n            else if (chr(s, 'L')) {\n                char *path = get_locale_compose_file_path(table->locale);\n                if (!path) {\n                    scanner_err(s, \"failed to expand %%L to the locale Compose file\");\n                    return TOK_ERROR;\n                }\n                if (!buf_appends(s, path)) {\n                    free(path);\n                    scanner_err(s, \"include path after expanding %%L is too long\");\n                    return TOK_ERROR;\n                }\n                free(path);\n            }\n            else if (chr(s, 'S')) {\n                const char *xlocaledir = get_xlocaledir_path();\n                if (!buf_appends(s, xlocaledir)) {\n                    scanner_err(s, \"include path after expanding %%S is too long\");\n                    return TOK_ERROR;\n                }\n            }\n            else {\n                scanner_err(s, \"unknown %% format (%c) in include statement\", peek(s));\n                return TOK_ERROR;\n            }\n        } else {\n            buf_append(s, next(s));\n        }\n    }\n    if (!chr(s, '\\\"')) {\n        scanner_err(s, \"unterminated include statement\");\n        return TOK_ERROR;\n    }\n    if (!buf_append(s, '\\0')) {\n        scanner_err(s, \"include path is too long\");\n        return TOK_ERROR;\n    }\n    val_out->string.str = s->buf;\n    val_out->string.len = s->buf_pos;\n    return TOK_INCLUDE_STRING;\n}\n\nstruct production {\n    xkb_keysym_t lhs[MAX_LHS_LEN];\n    unsigned int len;\n    xkb_keysym_t keysym;\n    char string[256];\n    /* At least one of these is true. */\n    bool has_keysym;\n    bool has_string;\n\n    /* The matching is as follows: (active_mods & modmask) == mods. */\n    xkb_mod_mask_t modmask;\n    xkb_mod_mask_t mods;\n};\n\nstatic uint32_t\nadd_node(struct xkb_compose_table *table, xkb_keysym_t keysym)\n{\n    struct compose_node new = {\n        .keysym = keysym,\n        .next = 0,\n        .is_leaf = true,\n    };\n    darray_append(table->nodes, new);\n    return darray_size(table->nodes) - 1;\n}\n\nstatic void\nadd_production(struct xkb_compose_table *table, struct scanner *s,\n               const struct production *production)\n{\n    unsigned lhs_pos;\n    uint32_t curr;\n    struct compose_node *node;\n\n    curr = 0;\n    node = &darray_item(table->nodes, curr);\n\n    /*\n     * Insert the sequence to the trie, creating new nodes as needed.\n     *\n     * TODO: This can be sped up a bit by first trying the path that the\n     * previous production took, and only then doing the linear search\n     * through the trie levels.  This will work because sequences in the\n     * Compose files are often clustered by a common prefix; especially\n     * in the 1st and 2nd keysyms, which is where the largest variation\n     * (thus, longest search) is.\n     */\n    for (lhs_pos = 0; lhs_pos < production->len; lhs_pos++) {\n        while (production->lhs[lhs_pos] != node->keysym) {\n            if (node->next == 0) {\n                uint32_t next = add_node(table, production->lhs[lhs_pos]);\n                /* Refetch since add_node could have realloc()ed. */\n                node = &darray_item(table->nodes, curr);\n                node->next = next;\n            }\n\n            curr = node->next;\n            node = &darray_item(table->nodes, curr);\n        }\n\n        if (lhs_pos + 1 == production->len)\n            break;\n\n        if (node->is_leaf) {\n            if (node->u.leaf.utf8 != 0 ||\n                node->u.leaf.keysym != XKB_KEY_NoSymbol) {\n                scanner_warn(s, \"a sequence already exists which is a prefix of this sequence; overriding\");\n                node->u.leaf.utf8 = 0;\n                node->u.leaf.keysym = XKB_KEY_NoSymbol;\n            }\n\n            {\n                uint32_t successor = add_node(table, production->lhs[lhs_pos + 1]);\n                /* Refetch since add_node could have realloc()ed. */\n                node = &darray_item(table->nodes, curr);\n                node->is_leaf = false;\n                node->u.successor = successor;\n            }\n        }\n\n        curr = node->u.successor;\n        node = &darray_item(table->nodes, curr);\n    }\n\n    if (!node->is_leaf) {\n        scanner_warn(s, \"this compose sequence is a prefix of another; skipping line\");\n        return;\n    }\n\n    if (node->u.leaf.utf8 != 0 || node->u.leaf.keysym != XKB_KEY_NoSymbol) {\n        bool same_string =\n            (node->u.leaf.utf8 == 0 && !production->has_string) ||\n            (\n                node->u.leaf.utf8 != 0 && production->has_string &&\n                streq(&darray_item(table->utf8, node->u.leaf.utf8),\n                      production->string)\n            );\n        bool same_keysym =\n            (node->u.leaf.keysym == XKB_KEY_NoSymbol && !production->has_keysym) ||\n            (\n                node->u.leaf.keysym != XKB_KEY_NoSymbol && production->has_keysym &&\n                node->u.leaf.keysym == production->keysym\n            );\n        if (same_string && same_keysym) {\n            scanner_warn(s, \"this compose sequence is a duplicate of another; skipping line\");\n            return;\n        }\n        scanner_warn(s, \"this compose sequence already exists; overriding\");\n    }\n\n    if (production->has_string) {\n        node->u.leaf.utf8 = darray_size(table->utf8);\n        darray_append_items(table->utf8, production->string,\n                            strlen(production->string) + 1);\n    }\n    if (production->has_keysym) {\n        node->u.leaf.keysym = production->keysym;\n    }\n}\n\n/* Should match resolve_modifier(). */\n#define ALL_MODS_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3))\n\nstatic xkb_mod_index_t\nresolve_modifier(const char *name)\n{\n    static const struct {\n        const char *name;\n        xkb_mod_index_t mod;\n    } mods[] = {\n        { \"Shift\", 0 },\n        { \"Ctrl\", 2 },\n        { \"Alt\", 3 },\n        { \"Meta\", 3 },\n        { \"Lock\", 1 },\n        { \"Caps\", 1 },\n    };\n\n    for (unsigned i = 0; i < ARRAY_SIZE(mods); i++)\n        if (streq(name, mods[i].name))\n            return mods[i].mod;\n\n    return XKB_MOD_INVALID;\n}\n\nstatic bool\nparse(struct xkb_compose_table *table, struct scanner *s,\n      unsigned include_depth);\n\nstatic bool\ndo_include(struct xkb_compose_table *table, struct scanner *s,\n           const char *path, unsigned include_depth)\n{\n    FILE *file;\n    bool ok;\n    char *string;\n    size_t size;\n    struct scanner new_s;\n\n    if (include_depth >= MAX_INCLUDE_DEPTH) {\n        scanner_err(s, \"maximum include depth (%d) exceeded; maybe there is an include loop?\",\n                    MAX_INCLUDE_DEPTH);\n        return false;\n    }\n\n    file = fopen(path, \"r\");\n    if (!file) {\n        scanner_err(s, \"failed to open included Compose file \\\"%s\\\": %s\",\n                    path, strerror(errno));\n        return false;\n    }\n\n    ok = map_file(file, &string, &size);\n    if (!ok) {\n        scanner_err(s, \"failed to read included Compose file \\\"%s\\\": %s\",\n                    path, strerror(errno));\n        goto err_file;\n    }\n\n    scanner_init(&new_s, table->ctx, string, size, path, s->priv);\n\n    ok = parse(table, &new_s, include_depth + 1);\n    if (!ok)\n        goto err_unmap;\n\nerr_unmap:\n    unmap_file(string, size);\nerr_file:\n    fclose(file);\n    return ok;\n}\n\nstatic bool\nparse(struct xkb_compose_table *table, struct scanner *s,\n      unsigned include_depth)\n{\n    enum rules_token tok;\n    union lvalue val;\n    xkb_keysym_t keysym;\n    struct production production;\n    enum { MAX_ERRORS = 10 };\n    int num_errors = 0;\n\ninitial:\n    production.len = 0;\n    production.has_keysym = false;\n    production.has_string = false;\n    production.mods = 0;\n    production.modmask = 0;\n\n    /* fallthrough */\n\ninitial_eol:\n    switch (tok = lex(s, &val)) {\n    case TOK_END_OF_LINE:\n        goto initial_eol;\n    case TOK_END_OF_FILE:\n        goto finished;\n    case TOK_INCLUDE:\n        goto include;\n    default:\n        goto lhs_tok;\n    }\n\ninclude:\n    switch (tok = lex_include_string(s, table, &val)) {\n    case TOK_INCLUDE_STRING:\n        goto include_eol;\n    default:\n        goto unexpected;\n    }\n\ninclude_eol:\n    switch (tok = lex(s, &val)) {\n    case TOK_END_OF_LINE:\n        if (!do_include(table, s, val.string.str, include_depth))\n            goto fail;\n        goto initial;\n    default:\n        goto unexpected;\n    }\n\nlhs:\n    tok = lex(s, &val);\nlhs_tok:\n    switch (tok) {\n    case TOK_COLON:\n        if (production.len <= 0) {\n            scanner_warn(s, \"expected at least one keysym on left-hand side; skipping line\");\n            goto skip;\n        }\n        goto rhs;\n    case TOK_IDENT:\n        if (streq(val.string.str, \"None\")) {\n            production.mods = 0;\n            production.modmask = ALL_MODS_MASK;\n            goto lhs_keysym;\n        }\n        goto lhs_mod_list_tok;\n    case TOK_TILDE:\n        goto lhs_mod_list_tok;\n    case TOK_BANG:\n        production.modmask = ALL_MODS_MASK;\n        goto lhs_mod_list;\n    default:\n        goto lhs_keysym_tok;\n    }\n\nlhs_keysym:\n    tok = lex(s, &val);\nlhs_keysym_tok:\n    switch (tok) {\n    case TOK_LHS_KEYSYM:\n        keysym = xkb_keysym_from_name(val.string.str, XKB_KEYSYM_NO_FLAGS);\n        if (keysym == XKB_KEY_NoSymbol) {\n            scanner_err(s, \"unrecognized keysym \\\"%s\\\" on left-hand side\",\n                        val.string.str);\n            goto error;\n        }\n        if (production.len + 1 > MAX_LHS_LEN) {\n            scanner_warn(s, \"too many keysyms (%d) on left-hand side; skipping line\",\n                         MAX_LHS_LEN + 1);\n            goto skip;\n        }\n        production.lhs[production.len++] = keysym;\n        production.mods = 0;\n        production.modmask = 0;\n        goto lhs;\n    default:\n        goto unexpected;\n    }\n\nlhs_mod_list:\n    tok = lex(s, &val);\nlhs_mod_list_tok: {\n        bool tilde = false;\n        xkb_mod_index_t mod;\n\n        if (tok != TOK_TILDE && tok != TOK_IDENT)\n            goto lhs_keysym_tok;\n\n        if (tok == TOK_TILDE) {\n            tilde = true;\n            tok = lex(s, &val);\n        }\n\n        if (tok != TOK_IDENT)\n            goto unexpected;\n\n        mod = resolve_modifier(val.string.str);\n        if (mod == XKB_MOD_INVALID) {\n            scanner_err(s, \"unrecognized modifier \\\"%s\\\"\",\n                        val.string.str);\n            goto error;\n        }\n\n        production.modmask |= 1 << mod;\n        if (tilde)\n            production.mods &= ~(1 << mod);\n        else\n            production.mods |= 1 << mod;\n\n        goto lhs_mod_list;\n    }\n\nrhs:\n    switch (tok = lex(s, &val)) {\n    case TOK_STRING:\n        if (production.has_string) {\n            scanner_warn(s, \"right-hand side can have at most one string; skipping line\");\n            goto skip;\n        }\n        if (val.string.len <= 0) {\n            scanner_warn(s, \"right-hand side string must not be empty; skipping line\");\n            goto skip;\n        }\n        if (val.string.len >= sizeof(production.string)) {\n            scanner_warn(s, \"right-hand side string is too long; skipping line\");\n            goto skip;\n        }\n        strcpy(production.string, val.string.str);\n        production.has_string = true;\n        goto rhs;\n    case TOK_IDENT:\n        keysym = xkb_keysym_from_name(val.string.str, XKB_KEYSYM_NO_FLAGS);\n        if (keysym == XKB_KEY_NoSymbol) {\n            scanner_err(s, \"unrecognized keysym \\\"%s\\\" on right-hand side\",\n                        val.string.str);\n            goto error;\n        }\n        if (production.has_keysym) {\n            scanner_warn(s, \"right-hand side can have at most one keysym; skipping line\");\n            goto skip;\n        }\n        production.keysym = keysym;\n        production.has_keysym = true;\n\t/* fallthrough */\n    case TOK_END_OF_LINE:\n        if (!production.has_string && !production.has_keysym) {\n            scanner_warn(s, \"right-hand side must have at least one of string or keysym; skipping line\");\n            goto skip;\n        }\n        add_production(table, s, &production);\n        goto initial;\n    default:\n        goto unexpected;\n    }\n\nunexpected:\n    if (tok != TOK_ERROR)\n        scanner_err(s, \"unexpected token\");\nerror:\n    num_errors++;\n    if (num_errors <= MAX_ERRORS)\n        goto skip;\n\n    scanner_err(s, \"too many errors\");\n    goto fail;\n\nfail:\n    scanner_err(s, \"failed to parse file\");\n    return false;\n\nskip:\n    while (tok != TOK_END_OF_LINE && tok != TOK_END_OF_FILE)\n        tok = lex(s, &val);\n    goto initial;\n\nfinished:\n    return true;\n}\n\nbool\nparse_string(struct xkb_compose_table *table, const char *string, size_t len,\n             const char *file_name)\n{\n    struct scanner s;\n    scanner_init(&s, table->ctx, string, len, file_name, NULL);\n    if (!parse(table, &s, 0))\n        return false;\n    /* Maybe the allocator can use the excess space. */\n    darray_shrink(table->nodes);\n    darray_shrink(table->utf8);\n    return true;\n}\n\nbool\nparse_file(struct xkb_compose_table *table, FILE *file, const char *file_name)\n{\n    bool ok;\n    char *string;\n    size_t size;\n\n    ok = map_file(file, &string, &size);\n    if (!ok) {\n        log_err(table->ctx, \"Couldn't read Compose file %s: %s\\n\",\n                file_name, strerror(errno));\n        return false;\n    }\n\n    ok = parse_string(table, string, size, file_name);\n    unmap_file(string, size);\n    return ok;\n}\n"], "filenames": ["src/compose/parser.c"], "buggy_code_start_loc": [147], "buggy_code_end_loc": [148], "fixing_code_start_loc": [147], "fixing_code_end_loc": [148], "type": "CWE-835", "message": "An infinite loop when reaching EOL unexpectedly in compose/parser.c (aka the keymap parser) in xkbcommon before 0.8.1 could be used by local attackers to cause a denial of service during parsing of crafted keymap files.", "other": {"cve": {"id": "CVE-2018-15856", "sourceIdentifier": "cve@mitre.org", "published": "2018-08-25T21:29:01.860", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An infinite loop when reaching EOL unexpectedly in compose/parser.c (aka the keymap parser) in xkbcommon before 0.8.1 could be used by local attackers to cause a denial of service during parsing of crafted keymap files."}, {"lang": "es", "value": "Un bucle infinito al alcanzar EOL inesperadamente en compose/parser.c (tambi\u00e9n conocido como analizador keymap) en xkbcommon, en versiones anteriores a la 0.8.1, podr\u00eda ser empleado por atacantes locales para provocar una denegaci\u00f3n de servicio (DoS) durante el an\u00e1lisis de archivos keymap manipulados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xkbcommon:xkbcommon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.1", "matchCriteriaId": "C7D955F4-3540-42A7-8551-EA1A266DDEA6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:2079", "source": "cve@mitre.org"}, {"url": "https://github.com/xkbcommon/libxkbcommon/commit/842e4351c2c97de6051cab6ce36b4a81e709a0e1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.freedesktop.org/archives/wayland-devel/2018-August/039232.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3786-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/xkbcommon/libxkbcommon/commit/842e4351c2c97de6051cab6ce36b4a81e709a0e1"}}