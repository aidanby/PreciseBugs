{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n *\n * $Header$\n */\n#include \"k5-int.h\"\n#include        <sys/time.h>\n#include        <kadm5/admin.h>\n#include        <kdb.h>\n#include        \"server_internal.h\"\n#ifdef USE_PASSWORD_SERVER\n#include        <sys/wait.h>\n#include        <signal.h>\n#endif\n\n#include <krb5/kadm5_hook_plugin.h>\n\n#ifdef USE_VALGRIND\n#include <valgrind/memcheck.h>\n#else\n#define VALGRIND_CHECK_DEFINED(LVALUE) ((void)0)\n#endif\n\nextern  krb5_principal      master_princ;\nextern  krb5_principal      hist_princ;\nextern  krb5_keyblock       master_keyblock;\nextern  krb5_db_entry       master_db;\n\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys);\n\n/*\n * XXX Functions that ought to be in libkrb5.a, but aren't.\n */\nkadm5_ret_t krb5_copy_key_data_contents(context, from, to)\n    krb5_context context;\n    krb5_key_data *from, *to;\n{\n    int i, idx;\n\n    *to = *from;\n\n    idx = (from->key_data_ver == 1 ? 1 : 2);\n\n    for (i = 0; i < idx; i++) {\n        if ( from->key_data_length[i] ) {\n            to->key_data_contents[i] = malloc(from->key_data_length[i]);\n            if (to->key_data_contents[i] == NULL) {\n                for (i = 0; i < idx; i++)\n                    zapfree(to->key_data_contents[i], to->key_data_length[i]);\n                return ENOMEM;\n            }\n            memcpy(to->key_data_contents[i], from->key_data_contents[i],\n                   from->key_data_length[i]);\n        }\n    }\n    return 0;\n}\n\nstatic krb5_tl_data *dup_tl_data(krb5_tl_data *tl)\n{\n    krb5_tl_data *n;\n\n    n = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n    if (n == NULL)\n        return NULL;\n    n->tl_data_contents = malloc(tl->tl_data_length);\n    if (n->tl_data_contents == NULL) {\n        free(n);\n        return NULL;\n    }\n    memcpy(n->tl_data_contents, tl->tl_data_contents, tl->tl_data_length);\n    n->tl_data_type = tl->tl_data_type;\n    n->tl_data_length = tl->tl_data_length;\n    n->tl_data_next = NULL;\n    return n;\n}\n\n/* This is in lib/kdb/kdb_cpw.c, but is static */\nstatic void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i;\n\n    for (i = 0; i < count; i++)\n        krb5_free_key_data_contents(context, &data[i]);\n    free(data);\n}\n\n/* Check whether a ks_tuple is present in an array of ks_tuples. */\nstatic krb5_boolean\nks_tuple_present(int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                 krb5_key_salt_tuple *looking_for)\n{\n    int i;\n\n    for (i = 0; i < n_ks_tuple; i++) {\n        if (ks_tuple[i].ks_enctype == looking_for->ks_enctype &&\n            ks_tuple[i].ks_salttype == looking_for->ks_salttype)\n            return TRUE;\n    }\n    return FALSE;\n}\n\n/* Fetch a policy if it exists; set *have_pol_out appropriately.  Return\n * success whether or not the policy exists. */\nstatic kadm5_ret_t\nget_policy(kadm5_server_handle_t handle, const char *name,\n           kadm5_policy_ent_t policy_out, krb5_boolean *have_pol_out)\n{\n    kadm5_ret_t ret;\n\n    *have_pol_out = FALSE;\n    if (name == NULL)\n        return 0;\n    ret = kadm5_get_policy(handle->lhandle, (char *)name, policy_out);\n    if (ret == 0)\n        *have_pol_out = TRUE;\n    return (ret == KADM5_UNK_POLICY) ? 0 : ret;\n}\n\n/*\n * Apply the -allowedkeysalts policy (see kadmin(1)'s addpol/modpol\n * commands).  We use the allowed key/salt tuple list as a default if\n * no ks tuples as provided by the caller.  We reject lists that include\n * key/salts outside the policy.  We re-order the requested ks tuples\n * (which may be a subset of the policy) to reflect the policy order.\n */\nstatic kadm5_ret_t\napply_keysalt_policy(kadm5_server_handle_t handle, const char *policy,\n                     int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                     int *new_n_kstp, krb5_key_salt_tuple **new_kstp)\n{\n    kadm5_ret_t ret;\n    kadm5_policy_ent_rec polent;\n    krb5_boolean have_polent;\n    int ak_n_ks_tuple = 0;\n    int new_n_ks_tuple = 0;\n    krb5_key_salt_tuple *ak_ks_tuple = NULL;\n    krb5_key_salt_tuple *new_ks_tuple = NULL;\n    krb5_key_salt_tuple *subset;\n    int i, m;\n\n    if (new_n_kstp != NULL) {\n        *new_n_kstp = 0;\n        *new_kstp = NULL;\n    }\n\n    memset(&polent, 0, sizeof(polent));\n    ret = get_policy(handle, policy, &polent, &have_polent);\n    if (ret)\n        goto cleanup;\n\n    if (polent.allowed_keysalts == NULL) {\n        /* Requested keysalts allowed or default to supported_enctypes. */\n        if (n_ks_tuple == 0) {\n            /* Default to supported_enctypes. */\n            n_ks_tuple = handle->params.num_keysalts;\n            ks_tuple = handle->params.keysalts;\n        }\n        /* Dup the requested or defaulted keysalt tuples. */\n        new_ks_tuple = malloc(n_ks_tuple * sizeof(*new_ks_tuple));\n        if (new_ks_tuple == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        memcpy(new_ks_tuple, ks_tuple, n_ks_tuple * sizeof(*new_ks_tuple));\n        new_n_ks_tuple = n_ks_tuple;\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = krb5_string_to_keysalts(polent.allowed_keysalts,\n                                  \",\",   /* Tuple separators */\n                                  NULL,  /* Key/salt separators */\n                                  0,     /* No duplicates */\n                                  &ak_ks_tuple,\n                                  &ak_n_ks_tuple);\n    /*\n     * Malformed policy?  Shouldn't happen, but it's remotely possible\n     * someday, so we don't assert, just bail.\n     */\n    if (ret)\n        goto cleanup;\n\n    /* Check that the requested ks_tuples are within policy, if we have one. */\n    for (i = 0; i < n_ks_tuple; i++) {\n        if (!ks_tuple_present(ak_n_ks_tuple, ak_ks_tuple, &ks_tuple[i])) {\n            ret = KADM5_BAD_KEYSALTS;\n            goto cleanup;\n        }\n    }\n\n    /* Have policy but no ks_tuple input?  Output the policy. */\n    if (n_ks_tuple == 0) {\n        new_n_ks_tuple = ak_n_ks_tuple;\n        new_ks_tuple = ak_ks_tuple;\n        ak_ks_tuple = NULL;\n        goto cleanup;\n    }\n\n    /*\n     * Now filter the policy ks tuples by the requested ones so as to\n     * preserve in the requested sub-set the relative ordering from the\n     * policy.  We could optimize this (if (n_ks_tuple == ak_n_ks_tuple)\n     * then skip this), but we don't bother.\n     */\n    subset = calloc(n_ks_tuple, sizeof(*subset));\n    if (subset == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n    for (m = 0, i = 0; i < ak_n_ks_tuple && m < n_ks_tuple; i++) {\n        if (ks_tuple_present(n_ks_tuple, ks_tuple, &ak_ks_tuple[i]))\n            subset[m++] = ak_ks_tuple[i];\n    }\n    new_ks_tuple = subset;\n    new_n_ks_tuple = m;\n    ret = 0;\n\ncleanup:\n    if (have_polent)\n        kadm5_free_policy_ent(handle->lhandle, &polent);\n    free(ak_ks_tuple);\n\n    if (new_n_kstp != NULL) {\n        *new_n_kstp = new_n_ks_tuple;\n        *new_kstp = new_ks_tuple;\n    } else {\n        free(new_ks_tuple);\n    }\n    return ret;\n}\n\n\n/*\n * Set *passptr to NULL if the request looks like the first part of a krb5 1.6\n * addprinc -randkey operation.  The krb5 1.6 dummy password for these requests\n * was invalid UTF-8, which runs afoul of the arcfour string-to-key.\n */\nstatic void\ncheck_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}\n\n/* Return the number of keys with the newest kvno.  Assumes that all key data\n * with the newest kvno are at the front of the key data array. */\nstatic int\ncount_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}\n\nkadm5_ret_t\nkadm5_create_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask,\n                       char *password)\n{\n    return\n        kadm5_create_principal_3(server_handle, entry, mask,\n                                 0, NULL, password);\n}\nkadm5_ret_t\nkadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_timestamp              now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = calloc(1, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);\n    if (ret)\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}\n\n\nkadm5_ret_t\nkadm5_delete_principal(void *server_handle, krb5_principal principal)\n{\n    unsigned int                ret;\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n    ret = k5_kadm5_hook_remove(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal);\n    if (ret) {\n        kdb_free_entry(handle, kdb, &adb);\n        return ret;\n    }\n\n    ret = kdb_delete_entry(handle, principal);\n\n    kdb_free_entry(handle, kdb, &adb);\n\n    if (ret == 0)\n        (void) k5_kadm5_hook_remove(handle->context,\n                                    handle->hook_handles,\n                                    KADM5_HOOK_STAGE_POSTCOMMIT, principal);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if(entry == NULL)\n        return EINVAL;\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n    }\n    if (have_pol) {\n        /* set pw_max_life based on new policy */\n        if (pol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration = ts_incr(kdb->pw_expiration, pol.pw_max_life);\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {\n        free(adb.policy);\n        adb.policy = NULL;\n        adb.aux_attributes &= ~KADM5_POLICY;\n        kdb->pw_expiration = 0;\n    }\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_pol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_rename_principal(void *server_handle,\n                       krb5_principal source, krb5_principal target)\n{\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_error_code ret;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (source == NULL || target == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, target, &kdb, &adb)) == 0) {\n        kdb_free_entry(handle, kdb, &adb);\n        return(KADM5_DUP);\n    }\n\n    ret = k5_kadm5_hook_rename(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, source, target);\n    if (ret)\n        return ret;\n\n    ret = krb5_db_rename_principal(handle->context, source, target);\n    if (ret)\n        return ret;\n\n    /* Update the principal mod data. */\n    ret = kdb_get_entry(handle, target, &kdb, &adb);\n    if (ret)\n        return ret;\n    kdb->mask = 0;\n    ret = kdb_put_entry(handle, kdb, &adb);\n    kdb_free_entry(handle, kdb, &adb);\n    if (ret)\n        return ret;\n\n    (void) k5_kadm5_hook_rename(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, source, target);\n    return 0;\n}\n\nkadm5_ret_t\nkadm5_get_principal(void *server_handle, krb5_principal principal,\n                    kadm5_principal_ent_t entry,\n                    long in_mask)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_error_code             ret = 0;\n    long                        mask;\n    int i;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    /*\n     * In version 1, all the defined fields are always returned.\n     * entry is a pointer to a kadm5_principal_ent_t_v1 that should be\n     * filled with allocated memory.\n     */\n    mask = in_mask;\n\n    memset(entry, 0, sizeof(*entry));\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return ret;\n\n    if ((mask & KADM5_POLICY) &&\n        adb.policy && (adb.aux_attributes & KADM5_POLICY)) {\n        if ((entry->policy = strdup(adb.policy)) == NULL) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (mask & KADM5_AUX_ATTRIBUTES)\n        entry->aux_attributes = adb.aux_attributes;\n\n    if ((mask & KADM5_PRINCIPAL) &&\n        (ret = krb5_copy_principal(handle->context, kdb->princ,\n                                   &entry->principal))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PRINC_EXPIRE_TIME)\n        entry->princ_expire_time = kdb->expiration;\n\n    if ((mask & KADM5_LAST_PWD_CHANGE) &&\n        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                               &(entry->last_pwd_change)))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PW_EXPIRATION)\n        entry->pw_expiration = kdb->pw_expiration;\n    if (mask & KADM5_MAX_LIFE)\n        entry->max_life = kdb->max_life;\n\n    /* this is a little non-sensical because the function returns two */\n    /* values that must be checked separately against the mask */\n    if ((mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME)) {\n        ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,\n                                             &(entry->mod_date),\n                                             &(entry->mod_name));\n        if (ret) {\n            goto done;\n        }\n\n        if (! (mask & KADM5_MOD_TIME))\n            entry->mod_date = 0;\n        if (! (mask & KADM5_MOD_NAME)) {\n            krb5_free_principal(handle->context, entry->mod_name);\n            entry->mod_name = NULL;\n        }\n    }\n\n    if (mask & KADM5_ATTRIBUTES)\n        entry->attributes = kdb->attributes;\n\n    if (mask & KADM5_KVNO)\n        for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)\n            if ((krb5_kvno) kdb->key_data[i].key_data_kvno > entry->kvno)\n                entry->kvno = kdb->key_data[i].key_data_kvno;\n\n    if (mask & KADM5_MKVNO) {\n        ret = krb5_dbe_get_mkvno(handle->context, kdb, &entry->mkvno);\n        if (ret)\n            goto done;\n    }\n\n    if (mask & KADM5_MAX_RLIFE)\n        entry->max_renewable_life = kdb->max_renewable_life;\n    if (mask & KADM5_LAST_SUCCESS)\n        entry->last_success = kdb->last_success;\n    if (mask & KADM5_LAST_FAILED)\n        entry->last_failed = kdb->last_failed;\n    if (mask & KADM5_FAIL_AUTH_COUNT)\n        entry->fail_auth_count = kdb->fail_auth_count;\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl, *tl2;\n\n        entry->tl_data = NULL;\n\n        tl = kdb->tl_data;\n        while (tl) {\n            if (tl->tl_data_type > 255) {\n                if ((tl2 = dup_tl_data(tl)) == NULL) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                tl2->tl_data_next = entry->tl_data;\n                entry->tl_data = tl2;\n                entry->n_tl_data++;\n            }\n\n            tl = tl->tl_data_next;\n        }\n    }\n    if (mask & KADM5_KEY_DATA) {\n        entry->n_key_data = kdb->n_key_data;\n        if(entry->n_key_data) {\n            entry->key_data = k5calloc(entry->n_key_data,\n                                       sizeof(krb5_key_data), &ret);\n            if (entry->key_data == NULL)\n                goto done;\n        } else\n            entry->key_data = NULL;\n\n        for (i = 0; i < entry->n_key_data; i++)\n            ret = krb5_copy_key_data_contents(handle->context,\n                                              &kdb->key_data[i],\n                                              &entry->key_data[i]);\n        if (ret)\n            goto done;\n    }\n\n    ret = KADM5_OK;\n\ndone:\n    if (ret && entry->principal) {\n        krb5_free_principal(handle->context, entry->principal);\n        entry->principal = NULL;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n\n    return ret;\n}\n\n/*\n * Function: check_pw_reuse\n *\n * Purpose: Check if a key appears in a list of keys, in order to\n * enforce password history.\n *\n * Arguments:\n *\n *      context                 (r) the krb5 context\n *      hist_keyblock           (r) the key that hist_key_data is\n *                              encrypted in\n *      n_new_key_data          (r) length of new_key_data\n *      new_key_data            (r) keys to check against\n *                              pw_hist_data, encrypted in hist_keyblock\n *      n_pw_hist_data          (r) length of pw_hist_data\n *      pw_hist_data            (r) passwords to check new_key_data against\n *\n * Effects:\n * For each new_key in new_key_data:\n *      decrypt new_key with the master_keyblock\n *      for each password in pw_hist_data:\n *              for each hist_key in password:\n *                      decrypt hist_key with hist_keyblock\n *                      compare the new_key and hist_key\n *\n * Returns krb5 errors, KADM5_PASS_RESUSE if a key in\n * new_key_data is the same as a key in pw_hist_data, or 0.\n */\nstatic kadm5_ret_t\ncheck_pw_reuse(krb5_context context,\n               krb5_keyblock *hist_keyblocks,\n               int n_new_key_data, krb5_key_data *new_key_data,\n               unsigned int n_pw_hist_data, osa_pw_hist_ent *pw_hist_data)\n{\n    unsigned int x, y, z;\n    krb5_keyblock newkey, histkey, *kb;\n    krb5_key_data *key_data;\n    krb5_error_code ret;\n\n    assert (n_new_key_data >= 0);\n    for (x = 0; x < (unsigned) n_new_key_data; x++) {\n        /* Check only entries with the most recent kvno. */\n        if (new_key_data[x].key_data_kvno != new_key_data[0].key_data_kvno)\n            break;\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &(new_key_data[x]),\n                                        &newkey, NULL);\n        if (ret)\n            return(ret);\n        for (y = 0; y < n_pw_hist_data; y++) {\n            for (z = 0; z < (unsigned int) pw_hist_data[y].n_key_data; z++) {\n                for (kb = hist_keyblocks; kb->enctype != 0; kb++) {\n                    key_data = &pw_hist_data[y].key_data[z];\n                    ret = krb5_dbe_decrypt_key_data(context, kb, key_data,\n                                                    &histkey, NULL);\n                    if (ret)\n                        continue;\n                    if (newkey.length == histkey.length &&\n                        newkey.enctype == histkey.enctype &&\n                        memcmp(newkey.contents, histkey.contents,\n                               histkey.length) == 0) {\n                        krb5_free_keyblock_contents(context, &histkey);\n                        krb5_free_keyblock_contents(context, &newkey);\n                        return KADM5_PASS_REUSE;\n                    }\n                    krb5_free_keyblock_contents(context, &histkey);\n                }\n            }\n        }\n        krb5_free_keyblock_contents(context, &newkey);\n    }\n\n    return(0);\n}\n\nstatic void\nfree_history_entry(krb5_context context, osa_pw_hist_ent *hist)\n{\n    int i;\n\n    for (i = 0; i < hist->n_key_data; i++)\n        krb5_free_key_data_contents(context, &hist->key_data[i]);\n    free(hist->key_data);\n}\n\n/*\n * Function: create_history_entry\n *\n * Purpose: Creates a password history entry from an array of\n * key_data.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      mkey            (r) master keyblock to decrypt key data with\n *      hist_key        (r) history keyblock to encrypt key data with\n *      n_key_data      (r) number of elements in key_data\n *      key_data        (r) keys to add to the history entry\n *      hist_out        (w) history entry to fill in\n *\n * Effects:\n *\n * hist->key_data is allocated to store n_key_data key_datas.  Each\n * element of key_data is decrypted with master_keyblock, re-encrypted\n * in hist_key, and added to hist->key_data.  hist->n_key_data is\n * set to n_key_data.\n */\nstatic\nint create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist_out)\n{\n    int i;\n    krb5_error_code ret = 0;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    krb5_ui_2 kvno;\n    osa_pw_hist_ent hist;\n\n    hist_out->key_data = NULL;\n    hist_out->n_key_data = 0;\n\n    if (n_key_data < 0)\n        return EINVAL;\n\n    memset(&key, 0, sizeof(key));\n    memset(&hist, 0, sizeof(hist));\n\n    if (n_key_data == 0)\n        goto cleanup;\n\n    hist.key_data = k5calloc(n_key_data, sizeof(krb5_key_data), &ret);\n    if (hist.key_data == NULL)\n        goto cleanup;\n\n    /* We only want to store the most recent kvno, and key_data should already\n     * be sorted in descending order by kvno. */\n    kvno = key_data[0].key_data_kvno;\n\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_kvno < kvno)\n            break;\n        ret = krb5_dbe_decrypt_key_data(context, NULL,\n                                        &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            goto cleanup;\n\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist.key_data[hist.n_key_data]);\n        if (ret)\n            goto cleanup;\n        hist.n_key_data++;\n        krb5_free_keyblock_contents(context, &key);\n        /* krb5_free_keysalt(context, &salt); */\n    }\n\n    *hist_out = hist;\n    hist.n_key_data = 0;\n    hist.key_data = NULL;\n\ncleanup:\n    krb5_free_keyblock_contents(context, &key);\n    free_history_entry(context, &hist);\n    return ret;\n}\n\n/*\n * Function: add_to_history\n *\n * Purpose: Adds a password to a principal's password history.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      hist_kvno       (r) kvno of current history key\n *      adb             (r/w) admin principal entry to add keys to\n *      pol             (r) adb's policy\n *      pw              (r) keys for the password to add to adb's key history\n *\n * Effects:\n *\n * add_to_history adds a single password to adb's password history.\n * pw contains n_key_data keys in its key_data, in storage should be\n * allocated but not freed by the caller (XXX blech!).\n *\n * This function maintains adb->old_keys as a circular queue.  It\n * starts empty, and grows each time this function is called until it\n * is pol->pw_history_num items long.  adb->old_key_len holds the\n * number of allocated entries in the array, and must therefore be [0,\n * pol->pw_history_num).  adb->old_key_next is the index into the\n * array where the next element should be written, and must be [0,\n * adb->old_key_len).\n */\nstatic kadm5_ret_t add_to_history(krb5_context context,\n                                  krb5_kvno hist_kvno,\n                                  osa_princ_ent_t adb,\n                                  kadm5_policy_ent_t pol,\n                                  osa_pw_hist_ent *pw)\n{\n    osa_pw_hist_ent *histp;\n    uint32_t nhist;\n    unsigned int i, knext, nkeys;\n\n    nhist = pol->pw_history_num;\n    /* A history of 1 means just check the current password */\n    if (nhist <= 1)\n        return 0;\n\n    if (adb->admin_history_kvno != hist_kvno) {\n        /* The history key has changed since the last password change, so we\n         * have to reset the password history. */\n        free(adb->old_keys);\n        adb->old_keys = NULL;\n        adb->old_key_len = 0;\n        adb->old_key_next = 0;\n        adb->admin_history_kvno = hist_kvno;\n    }\n\n    nkeys = adb->old_key_len;\n    knext = adb->old_key_next;\n    /* resize the adb->old_keys array if necessary */\n    if (nkeys + 1 < nhist) {\n        if (adb->old_keys == NULL) {\n            adb->old_keys = (osa_pw_hist_ent *)\n                malloc((nkeys + 1) * sizeof (osa_pw_hist_ent));\n        } else {\n            adb->old_keys = (osa_pw_hist_ent *)\n                realloc(adb->old_keys,\n                        (nkeys + 1) * sizeof (osa_pw_hist_ent));\n        }\n        if (adb->old_keys == NULL)\n            return(ENOMEM);\n\n        memset(&adb->old_keys[nkeys], 0, sizeof(osa_pw_hist_ent));\n        nkeys = ++adb->old_key_len;\n        /*\n         * To avoid losing old keys, shift forward each entry after\n         * knext.\n         */\n        for (i = nkeys - 1; i > knext; i--) {\n            adb->old_keys[i] = adb->old_keys[i - 1];\n        }\n        memset(&adb->old_keys[knext], 0, sizeof(osa_pw_hist_ent));\n    } else if (nkeys + 1 > nhist) {\n        /*\n         * The policy must have changed!  Shrink the array.\n         * Can't simply realloc() down, since it might be wrapped.\n         * To understand the arithmetic below, note that we are\n         * copying into new positions 0 .. N-1 from old positions\n         * old_key_next-N .. old_key_next-1, modulo old_key_len,\n         * where N = pw_history_num - 1 is the length of the\n         * shortened list.        Matt Crawford, FNAL\n         */\n        /*\n         * M = adb->old_key_len, N = pol->pw_history_num - 1\n         *\n         * tmp[0] .. tmp[N-1] = old[(knext-N)%M] .. old[(knext-1)%M]\n         */\n        int j;\n        osa_pw_hist_t tmp;\n\n        tmp = (osa_pw_hist_ent *)\n            malloc((nhist - 1) * sizeof (osa_pw_hist_ent));\n        if (tmp == NULL)\n            return ENOMEM;\n        for (i = 0; i < nhist - 1; i++) {\n            /*\n             * Add nkeys once before taking remainder to avoid\n             * negative values.\n             */\n            j = (i + nkeys + knext - (nhist - 1)) % nkeys;\n            tmp[i] = adb->old_keys[j];\n        }\n        /* Now free the ones we don't keep (the oldest ones) */\n        for (i = 0; i < nkeys - (nhist - 1); i++) {\n            j = (i + nkeys + knext) % nkeys;\n            histp = &adb->old_keys[j];\n            for (j = 0; j < histp->n_key_data; j++) {\n                krb5_free_key_data_contents(context, &histp->key_data[j]);\n            }\n            free(histp->key_data);\n        }\n        free(adb->old_keys);\n        adb->old_keys = tmp;\n        nkeys = adb->old_key_len = nhist - 1;\n        knext = adb->old_key_next = 0;\n    }\n\n    /*\n     * If nhist decreased since the last password change, and nkeys+1\n     * is less than the previous nhist, it is possible for knext to\n     * index into unallocated space.  This condition would not be\n     * caught by the resizing code above.\n     */\n    if (knext + 1 > nkeys)\n        knext = adb->old_key_next = 0;\n    /* free the old pw history entry if it contains data */\n    histp = &adb->old_keys[knext];\n    for (i = 0; i < (unsigned int) histp->n_key_data; i++)\n        krb5_free_key_data_contents(context, &histp->key_data[i]);\n    free(histp->key_data);\n\n    /* store the new entry */\n    adb->old_keys[knext] = *pw;\n\n    /* update the next pointer */\n    if (++adb->old_key_next == nhist - 1)\n        adb->old_key_next = 0;\n\n    return(0);\n}\n\n/* FIXME: don't use global variable for this */\nkrb5_boolean use_password_server = 0;\n\n#ifdef USE_PASSWORD_SERVER\nstatic krb5_boolean\nkadm5_use_password_server (void)\n{\n    return use_password_server;\n}\n#endif\n\nvoid kadm5_set_use_password_server (void);\n\nvoid\nkadm5_set_use_password_server (void)\n{\n    use_password_server = 1;\n}\n\n#ifdef USE_PASSWORD_SERVER\n\n/*\n * kadm5_launch_task () runs a program (task_path) to synchronize the\n * Apple password server with the Kerberos database.  Password server\n * programs can receive arguments on the command line (task_argv)\n * and a block of data via stdin (data_buffer).\n *\n * Because a failure to communicate with the tool results in the\n * password server falling out of sync with the database,\n * kadm5_launch_task() always fails if it can't talk to the tool.\n */\n\nstatic kadm5_ret_t\nkadm5_launch_task (krb5_context context,\n                   const char *task_path, char * const task_argv[],\n                   const char *buffer)\n{\n    kadm5_ret_t ret;\n    int data_pipe[2];\n\n    ret = pipe (data_pipe);\n    if (ret)\n        ret = errno;\n\n    if (!ret) {\n        pid_t pid = fork ();\n        if (pid == -1) {\n            ret = errno;\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n        } else if (pid == 0) {\n            /* The child: */\n\n            if (dup2 (data_pipe[0], STDIN_FILENO) == -1)\n                _exit (1);\n\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n\n            execv (task_path, task_argv);\n\n            _exit (1); /* Fail if execv fails */\n        } else {\n            /* The parent: */\n            int status;\n\n            ret = 0;\n\n            close (data_pipe[0]);\n\n            /* Write out the buffer to the child, add \\n */\n            if (buffer) {\n                if (krb5_net_write (context, data_pipe[1], buffer, strlen (buffer)) < 0\n                    || krb5_net_write (context, data_pipe[1], \"\\n\", 1) < 0)\n                {\n                    /* kill the child to make sure waitpid() won't hang later */\n                    ret = errno;\n                    kill (pid, SIGKILL);\n                }\n            }\n            close (data_pipe[1]);\n\n            waitpid (pid, &status, 0);\n\n            if (!ret) {\n                if (WIFEXITED (status)) {\n                    /* child read password and exited.  Check the return value. */\n                    if ((WEXITSTATUS (status) != 0) && (WEXITSTATUS (status) != 252)) {\n                        ret = KRB5KDC_ERR_POLICY; /* password change rejected */\n                    }\n                } else {\n                    /* child read password but crashed or was killed */\n                    ret = KRB5KRB_ERR_GENERIC; /* FIXME: better error */\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\n#endif\n\nkadm5_ret_t\nkadm5_chpass_principal(void *server_handle,\n                       krb5_principal principal, char *password)\n{\n    return\n        kadm5_chpass_principal_3(server_handle, principal, FALSE,\n                                 0, NULL, password);\n}\n\nkadm5_ret_t\nkadm5_chpass_principal_3(void *server_handle,\n                         krb5_principal principal, krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_timestamp              now;\n    kadm5_policy_ent_rec        pol;\n    osa_princ_ent_rec           adb;\n    krb5_db_entry               *kdb;\n    int                         ret, ret2, hist_added;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    osa_pw_hist_ent             hist;\n    krb5_keyblock               *act_mkey, *hist_keyblocks = NULL;\n    krb5_kvno                   act_kvno, hist_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    hist_added = 0;\n    memset(&hist, 0, sizeof(hist));\n\n    if (principal == NULL || password == NULL)\n        return EINVAL;\n    if ((krb5_principal_compare(handle->context,\n                                principal, hist_princ)) == TRUE)\n        return KADM5_PROTECT_PRINCIPAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        /* Create a password history entry before we change kdb's key_data. */\n        ret = kdb_get_hist_key(handle, &hist_keyblocks, &hist_kvno);\n        if (ret)\n            goto done;\n        ret = create_history_entry(handle->context, &hist_keyblocks[0],\n                                   kdb->n_key_data, kdb->key_data, &hist);\n        if (ret)\n            goto done;\n    }\n\n    if ((ret = passwd_check(handle, password, have_pol ? &pol : NULL,\n                            principal)))\n        goto done;\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       password, 0 /* increment kvno */,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        /* the policy was loaded before */\n\n        ret = check_pw_reuse(handle->context, hist_keyblocks,\n                             kdb->n_key_data, kdb->key_data,\n                             1, &hist);\n        if (ret)\n            goto done;\n\n        if (pol.pw_history_num > 1) {\n            /* If hist_kvno has changed since the last password change, we\n             * can't check the history. */\n            if (adb.admin_history_kvno == hist_kvno) {\n                ret = check_pw_reuse(handle->context, hist_keyblocks,\n                                     kdb->n_key_data, kdb->key_data,\n                                     adb.old_key_len, adb.old_keys);\n                if (ret)\n                    goto done;\n            }\n\n            /* Don't save empty history. */\n            if (hist.n_key_data > 0) {\n                ret = add_to_history(handle->context, hist_kvno, &adb, &pol,\n                                     &hist);\n                if (ret)\n                    goto done;\n                hist_added = 1;\n            }\n        }\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n#ifdef USE_PASSWORD_SERVER\n    if (kadm5_use_password_server () &&\n        (krb5_princ_size (handle->context, principal) == 1)) {\n        krb5_data *princ = krb5_princ_component (handle->context, principal, 0);\n        const char *path = \"/usr/sbin/mkpassdb\";\n        char *argv[] = { \"mkpassdb\", \"-setpassword\", NULL, NULL };\n        char *pstring = NULL;\n\n        if (!ret) {\n            pstring = malloc ((princ->length + 1) * sizeof (char));\n            if (pstring == NULL) { ret = ENOMEM; }\n        }\n\n        if (!ret) {\n            memcpy (pstring, princ->data, princ->length);\n            pstring [princ->length] = '\\0';\n            argv[2] = pstring;\n\n            ret = kadm5_launch_task (handle->context, path, argv, password);\n        }\n\n        if (pstring != NULL)\n            free (pstring);\n\n        if (ret)\n            goto done;\n    }\n#endif\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    /* key data and attributes changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |\n        KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_CPW_FUNCTION */\n\n    if (hist_added)\n        kdb->mask |= KADM5_KEY_HIST;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto done;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, password);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    if (!hist_added && hist.key_data)\n        free_history_entry(handle->context, &hist);\n    kdb_free_entry(handle, kdb, &adb);\n    kdb_free_keyblocks(handle, hist_keyblocks);\n\n    if (have_pol && (ret2 = kadm5_free_policy_ent(handle->lhandle, &pol))\n        && !ret)\n        ret = ret2;\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_randkey_principal(void *server_handle,\n                        krb5_principal principal,\n                        krb5_keyblock **keyblocks,\n                        int *n_keys)\n{\n    return\n        kadm5_randkey_principal_3(server_handle, principal,\n                                  FALSE, 0, NULL,\n                                  keyblocks, n_keys);\n}\nkadm5_ret_t\nkadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_timestamp              now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, n_new_keys;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        /* Return only the new keys added by krb5_dbe_crk. */\n        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);\n        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\n/*\n * kadm5_setv4key_principal:\n *\n * Set only ONE key of the principal, removing all others.  This key\n * must have the DES_CBC_CRC enctype and is entered as having the\n * krb4 salttype.  This is to enable things like kadmind4 to work.\n */\nkadm5_ret_t\nkadm5_setv4key_principal(void *server_handle,\n                         krb5_principal principal,\n                         krb5_keyblock *keyblock)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_timestamp              now;\n    kadm5_policy_ent_rec        pol;\n    krb5_keysalt                keysalt;\n    int                         i, kvno, ret;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_key_data               tmp_key_data;\n    krb5_keyblock               *act_mkey;\n\n    memset( &tmp_key_data, 0, sizeof(tmp_key_data));\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || keyblock == NULL)\n        return EINVAL;\n    if (hist_princ && /* this will be NULL when initializing the databse */\n        ((krb5_principal_compare(handle->context,\n                                 principal, hist_princ)) == TRUE))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    if (keyblock->enctype != ENCTYPE_DES_CBC_CRC)\n        return KADM5_SETV4KEY_INVAL_ENCTYPE;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n        if (kdb->key_data[i].key_data_kvno > kvno)\n            kvno = kdb->key_data[i].key_data_kvno;\n\n    if (kdb->key_data != NULL)\n        cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n\n    kdb->key_data = calloc(1, sizeof(krb5_key_data));\n    if (kdb->key_data == NULL)\n        return ENOMEM;\n    kdb->n_key_data = 1;\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    /* XXX data.magic? */\n    keysalt.data.length = 0;\n    keysalt.data.data = NULL;\n\n    ret = kdb_get_active_mkey(handle, NULL, &act_mkey);\n    if (ret)\n        goto done;\n\n    /* use tmp_key_data as temporary location and reallocate later */\n    ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey, keyblock,\n                                    &keysalt, kvno + 1, kdb->key_data);\n    if (ret) {\n        goto done;\n    }\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = KADM5_OK;\ndone:\n    for (i = 0; i < tmp_key_data.key_data_ver; i++) {\n        if (tmp_key_data.key_data_contents[i]) {\n            memset (tmp_key_data.key_data_contents[i], 0, tmp_key_data.key_data_length[i]);\n            free (tmp_key_data.key_data_contents[i]);\n        }\n    }\n\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_setkey_principal(void *server_handle,\n                       krb5_principal principal,\n                       krb5_keyblock *keyblocks,\n                       int n_keys)\n{\n    return\n        kadm5_setkey_principal_3(server_handle, principal,\n                                 FALSE, 0, NULL,\n                                 keyblocks, n_keys);\n}\n\nkadm5_ret_t\nkadm5_setkey_principal_3(void *server_handle,\n                         krb5_principal principal,\n                         krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         krb5_keyblock *keyblocks,\n                         int n_keys)\n{\n    kadm5_key_data *key_data;\n    kadm5_ret_t ret;\n    int i;\n\n    if (keyblocks == NULL)\n        return EINVAL;\n\n    if (n_ks_tuple) {\n        if (n_ks_tuple != n_keys)\n            return KADM5_SETKEY3_ETYPE_MISMATCH;\n        for (i = 0; i < n_ks_tuple; i++) {\n            if (ks_tuple[i].ks_enctype != keyblocks[i].enctype)\n                return KADM5_SETKEY3_ETYPE_MISMATCH;\n        }\n    }\n\n    key_data = calloc(n_keys, sizeof(kadm5_key_data));\n    if (key_data == NULL)\n        return ENOMEM;\n\n    for (i = 0; i < n_keys; i++) {\n        key_data[i].key = keyblocks[i];\n        key_data[i].salt.type =\n            n_ks_tuple ? ks_tuple[i].ks_salttype : KRB5_KDB_SALTTYPE_NORMAL;\n    }\n\n    ret = kadm5_setkey_principal_4(server_handle, principal, keepold,\n                                   key_data, n_keys);\n    free(key_data);\n    return ret;\n}\n\n/* Create a key/salt list from a key_data array. */\nstatic kadm5_ret_t\nmake_ks_from_key_data(krb5_context context, kadm5_key_data *key_data,\n                      int n_key_data, krb5_key_salt_tuple **out)\n{\n    int i;\n    krb5_key_salt_tuple *ks;\n\n    *out = NULL;\n\n    ks = calloc(n_key_data, sizeof(*ks));\n    if (ks == NULL)\n        return ENOMEM;\n\n    for (i = 0; i < n_key_data; i++) {\n        ks[i].ks_enctype = key_data[i].key.enctype;\n        ks[i].ks_salttype = key_data[i].salt.type;\n    }\n    *out = ks;\n    return 0;\n}\n\nkadm5_ret_t\nkadm5_setkey_principal_4(void *server_handle, krb5_principal principal,\n                         krb5_boolean keepold, kadm5_key_data *key_data,\n                         int n_key_data)\n{\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_timestamp now;\n    kadm5_policy_ent_rec pol;\n    krb5_key_data *new_key_data = NULL;\n    int i, j, ret, n_new_key_data = 0;\n    krb5_kvno kvno;\n    krb5_boolean similar, have_pol = FALSE;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock *act_mkey;\n    krb5_key_salt_tuple *ks_from_keys = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || key_data == NULL || n_key_data == 0)\n        return EINVAL;\n\n    /* hist_princ will be NULL when initializing the database. */\n    if (hist_princ != NULL &&\n        krb5_principal_compare(handle->context, principal, hist_princ))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    /* For now, all keys must have the same kvno. */\n    kvno = key_data[0].kvno;\n    for (i = 1; i < n_key_data; i++) {\n        if (key_data[i].kvno != kvno)\n            return KADM5_SETKEY_BAD_KVNO;\n    }\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return ret;\n\n    if (kvno == 0) {\n        /* Pick the next kvno. */\n        for (i = 0; i < kdb->n_key_data; i++) {\n            if (kdb->key_data[i].key_data_kvno > kvno)\n                kvno = kdb->key_data[i].key_data_kvno;\n        }\n        kvno++;\n    } else if (keepold) {\n        /* Check that the kvno does collide with existing keys. */\n        for (i = 0; i < kdb->n_key_data; i++) {\n            if (kdb->key_data[i].key_data_kvno == kvno) {\n                ret = KADM5_SETKEY_BAD_KVNO;\n                goto done;\n            }\n        }\n    }\n\n    ret = make_ks_from_key_data(handle->context, key_data, n_key_data,\n                                &ks_from_keys);\n    if (ret)\n        goto done;\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_key_data, ks_from_keys,\n                               NULL, NULL);\n    free(ks_from_keys);\n    if (ret)\n        goto done;\n\n    for (i = 0; i < n_key_data; i++) {\n        for (j = i + 1; j < n_key_data; j++) {\n            ret = krb5_c_enctype_compare(handle->context,\n                                         key_data[i].key.enctype,\n                                         key_data[j].key.enctype,\n                                         &similar);\n            if (ret)\n                goto done;\n            if (similar) {\n                if (key_data[i].salt.type == key_data[j].salt.type) {\n                    ret = KADM5_SETKEY_DUP_ENCTYPES;\n                    goto done;\n                }\n            }\n        }\n    }\n\n    n_new_key_data = n_key_data + (keepold ? kdb->n_key_data : 0);\n    new_key_data = calloc(n_new_key_data, sizeof(krb5_key_data));\n    if (new_key_data == NULL) {\n        n_new_key_data = 0;\n        ret = ENOMEM;\n        goto done;\n    }\n\n    n_new_key_data = 0;\n    for (i = 0; i < n_key_data; i++) {\n\n        ret = kdb_get_active_mkey(handle, NULL, &act_mkey);\n        if (ret)\n            goto done;\n\n        ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey,\n                                        &key_data[i].key, &key_data[i].salt,\n                                        kvno, &new_key_data[i]);\n        if (ret)\n            goto done;\n\n        n_new_key_data++;\n    }\n\n    /* Copy old key data if necessary. */\n    if (keepold) {\n        memcpy(new_key_data + n_new_key_data, kdb->key_data,\n               kdb->n_key_data * sizeof(krb5_key_data));\n        memset(kdb->key_data, 0, kdb->n_key_data * sizeof(krb5_key_data));\n\n        /*\n         * Sort the keys to maintain the defined kvno order.  We only need to\n         * sort if we keep old keys, as otherwise we allow only a single kvno\n         * to be specified.\n         */\n        krb5_dbe_sort_key_data(new_key_data, n_new_key_data);\n    }\n\n    /* Replace kdb->key_data with the new keys. */\n    cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n    kdb->key_data = new_key_data;\n    kdb->n_key_data = n_new_key_data;\n    new_key_data = NULL;\n    n_new_key_data = 0;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if (adb.aux_attributes & KADM5_POLICY) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* Unlock principal on this KDC. */\n    kdb->fail_auth_count = 0;\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret)\n        goto done;\n\n    ret = KADM5_OK;\n\ndone:\n    cleanup_key_data(handle->context, n_new_key_data, new_key_data);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n    return ret;\n}\n\n/*\n * Return the list of keys like kadm5_randkey_principal,\n * but don't modify the principal.\n */\nkadm5_ret_t\nkadm5_get_principal_keys(void *server_handle /* IN */,\n                         krb5_principal principal /* IN */,\n                         krb5_kvno kvno /* IN */,\n                         kadm5_key_data **key_data_out /* OUT */,\n                         int *n_key_data_out /* OUT */)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_ret_t                 ret;\n    kadm5_server_handle_t       handle = server_handle;\n    kadm5_key_data              *key_data = NULL;\n    int i, nkeys = 0;\n\n    if (principal == NULL || key_data_out == NULL || n_key_data_out == NULL)\n        return EINVAL;\n\n    CHECK_HANDLE(server_handle);\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    key_data = calloc(kdb->n_key_data, sizeof(kadm5_key_data));\n    if (key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n\n    for (i = 0, nkeys = 0; i < kdb->n_key_data; i++) {\n        if (kvno != 0 && kvno != kdb->key_data[i].key_data_kvno)\n            continue;\n        key_data[nkeys].kvno = kdb->key_data[i].key_data_kvno;\n\n        ret = krb5_dbe_decrypt_key_data(handle->context, NULL,\n                                        &kdb->key_data[i],\n                                        &key_data[nkeys].key,\n                                        &key_data[nkeys].salt);\n        if (ret)\n            goto done;\n        nkeys++;\n    }\n\n    *n_key_data_out = nkeys;\n    *key_data_out = key_data;\n    key_data = NULL;\n    nkeys = 0;\n    ret = KADM5_OK;\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    kadm5_free_kadm5_key_data(handle->context, nkeys, key_data);\n\n    return ret;\n}\n\n\n/*\n * Allocate an array of n_key_data krb5_keyblocks, fill in each\n * element with the results of decrypting the nth key in key_data,\n * and if n_keys is not NULL fill it in with the\n * number of keys decrypted.\n */\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys)\n{\n    krb5_keyblock *keys;\n    int ret, i;\n\n    keys = (krb5_keyblock *) malloc(n_key_data*sizeof(krb5_keyblock));\n    if (keys == NULL)\n        return ENOMEM;\n    memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &keys[i],\n                                        NULL);\n        if (ret) {\n            for (; i >= 0; i--) {\n                if (keys[i].contents) {\n                    memset (keys[i].contents, 0, keys[i].length);\n                    free( keys[i].contents );\n                }\n            }\n\n            memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n            free(keys);\n            return ret;\n        }\n    }\n\n    *keyblocks = keys;\n    if (n_keys)\n        *n_keys = n_key_data;\n\n    return 0;\n}\n\n/*\n * Function: kadm5_decrypt_key\n *\n * Purpose: Retrieves and decrypts a principal key.\n *\n * Arguments:\n *\n *      server_handle   (r) kadm5 handle\n *      entry           (r) principal retrieved with kadm5_get_principal\n *      ktype           (r) enctype to search for, or -1 to ignore\n *      stype           (r) salt type to search for, or -1 to ignore\n *      kvno            (r) kvno to search for, -1 for max, 0 for max\n *                      only if it also matches ktype and stype\n *      keyblock        (w) keyblock to fill in\n *      keysalt         (w) keysalt to fill in, or NULL\n *      kvnop           (w) kvno to fill in, or NULL\n *\n * Effects: Searches the key_data array of entry, which must have been\n * retrived with kadm5_get_principal with the KADM5_KEY_DATA mask, to\n * find a key with a specified enctype, salt type, and kvno in a\n * principal entry.  If not found, return ENOENT.  Otherwise, decrypt\n * it with the master key, and return the key in keyblock, the salt\n * in salttype, and the key version number in kvno.\n *\n * If ktype or stype is -1, it is ignored for the search.  If kvno is\n * -1, ktype and stype are ignored and the key with the max kvno is\n * returned.  If kvno is 0, only the key with the max kvno is returned\n * and only if it matches the ktype and stype; otherwise, ENOENT is\n * returned.\n */\nkadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n\n    CHECK_HANDLE(server_handle);\n\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n\n    /* find_enctype only uses these two fields */\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n\n    /* find_mkey only uses this field */\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        /* try refreshing master key list */\n        /* XXX it would nice if we had the mkvno here for optimization */\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n\n    /*\n     * Coerce the enctype of the output keyblock in case we got an\n     * inexact match on the enctype; this behavior will go away when\n     * the key storage architecture gets redesigned for 1.3.\n     */\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n\n    return KADM5_OK;\n}\n\nkadm5_ret_t\nkadm5_purgekeys(void *server_handle,\n                krb5_principal principal,\n                int keepkvno)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_key_data *old_keydata;\n    int n_old_keydata;\n    int i, j, k;\n\n    CHECK_HANDLE(server_handle);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    if (keepkvno <= 0) {\n        keepkvno = krb5_db_get_key_data_kvno(handle->context, kdb->n_key_data,\n                                             kdb->key_data);\n    }\n\n    old_keydata = kdb->key_data;\n    n_old_keydata = kdb->n_key_data;\n    kdb->n_key_data = 0;\n    /* Allocate one extra key_data to avoid allocating 0 bytes. */\n    kdb->key_data = calloc(n_old_keydata, sizeof(krb5_key_data));\n    if (kdb->key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    memset(kdb->key_data, 0, n_old_keydata * sizeof(krb5_key_data));\n    for (i = 0, j = 0; i < n_old_keydata; i++) {\n        if (old_keydata[i].key_data_kvno < keepkvno)\n            continue;\n\n        /* Alias the key_data_contents pointers; we null them out in the\n         * source array immediately after. */\n        kdb->key_data[j] = old_keydata[i];\n        for (k = 0; k < old_keydata[i].key_data_ver; k++) {\n            old_keydata[i].key_data_contents[k] = NULL;\n        }\n        j++;\n    }\n    kdb->n_key_data = j;\n    cleanup_key_data(handle->context, n_old_keydata, old_keydata);\n\n    kdb->mask = KADM5_KEY_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret)\n        goto done;\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_get_strings(void *server_handle, krb5_principal principal,\n                  krb5_string_attr **strings_out, int *count_out)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb = NULL;\n\n    *strings_out = NULL;\n    *count_out = 0;\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, NULL);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_get_strings(handle->context, kdb, strings_out, count_out);\n    kdb_free_entry(handle, kdb, NULL);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_set_string(void *server_handle, krb5_principal principal,\n                 const char *key, const char *value)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL || key == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_set_string(handle->context, kdb, key, value);\n    if (ret)\n        goto done;\n\n    kdb->mask = KADM5_TL_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/kdb_ldap.h */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* */\n#ifndef _KDB_LDAP_H\n#define _KDB_LDAP_H 1\n\n#include \"k5-int.h\"\n#include <k5-thread.h>\n#include <kdb5.h>\n#include \"ldap_krbcontainer.h\"\n#include \"ldap_realm.h\"\n\n/* We want the interfaces marked \"deprecated\" in OpenLDAP.  */\n#define LDAP_DEPRECATED 1\n#include <ldap.h>\n\n/* Check for acceptable versions.\n\n   OpenLDAP version 2.2.6 is known to have some kind of problem that\n   is tickled by the use of multiple handles in this code.  Version\n   2.2.19 in Mac OS 10.4.7 seems to be buggy as well.  Version 2.2.24\n   doesn't have this problem.  Other in-between versions have not been\n   tested.  */\n#ifndef BUILD_WITH_BROKEN_LDAP\n# if defined(LDAP_API_FEATURE_X_OPENLDAP)\n#  if LDAP_VENDOR_VERSION < 20224\n#   error This code triggers bugs in old OpenLDAP implementations.  Please update to 2.2.24 or later.\n#  endif\n# endif\n#endif /* BUILD_WITH_BROKEN_LDAP */\n\nextern struct timeval timelimit;\n\n#define  DEFAULT_CONNS_PER_SERVER    5\n#define  REALM_READ_REFRESH_INTERVAL (5 * 60)\n\n#if !defined(LDAP_OPT_RESULT_CODE) && defined(LDAP_OPT_ERROR_NUMBER)\n#define LDAP_OPT_RESULT_CODE LDAP_OPT_ERROR_NUMBER\n#endif\n\n#define MAXINTLEN  10\n\n#define IGNORE_STATUS              0\n#define CHECK_STATUS               1\n\n#define SETUP_CONTEXT() if (context == NULL || context->dal_handle == NULL \\\n                            || context->dal_handle->db_context == NULL) { \\\n        return EINVAL;                                                  \\\n    }                                                                   \\\n    dal_handle = context->dal_handle;                                   \\\n    ldap_context = (krb5_ldap_context *) dal_handle->db_context;        \\\n    if (ldap_context == NULL || ldap_context->server_info_list == NULL) \\\n        return KRB5_KDB_DBNOTINITED;\n\n#define GET_HANDLE()  ld = NULL;                                        \\\n    st = krb5_ldap_request_handle_from_pool(ldap_context, &ldap_server_handle); \\\n    if (st != 0) {                                                      \\\n        k5_wrapmsg(context, st, KRB5_KDB_ACCESS_ERROR,                  \\\n                   \"LDAP handle unavailable\");                          \\\n        st = KRB5_KDB_ACCESS_ERROR;                                     \\\n        goto cleanup;                                                   \\\n    }                                                                   \\\n    ld = ldap_server_handle->ldap_handle;\n\nextern int set_ldap_error (krb5_context ctx, int st, int op);\n\n#define LDAP_SEARCH(base, scope, filter, attrs)   LDAP_SEARCH_1(base, scope, filter, attrs, CHECK_STATUS)\n\n#define LDAP_SEARCH_1(base, scope, filter, attrs, status_check)         \\\n    tempst = 0;                                                         \\\n    st = ldap_search_ext_s(ld, base, scope, filter, attrs, 0, NULL,     \\\n                           NULL, &timelimit, LDAP_NO_LIMIT, &result);   \\\n    if (translate_ldap_error(st, OP_SEARCH) == KRB5_KDB_ACCESS_ERROR) { \\\n        tempst = krb5_ldap_rebind(ldap_context, &ldap_server_handle);   \\\n        if (ldap_server_handle)                                         \\\n            ld = ldap_server_handle->ldap_handle;                       \\\n        if (tempst == 0)                                                \\\n            st = ldap_search_ext_s(ld, base, scope, filter, attrs, 0,   \\\n                                   NULL, NULL, &timelimit,              \\\n                                   LDAP_NO_LIMIT, &result);             \\\n    }                                                                   \\\n                                                                        \\\n    if (status_check != IGNORE_STATUS) {                                \\\n        if (tempst != 0) {                                              \\\n            k5_wrapmsg(context, st, KRB5_KDB_ACCESS_ERROR,              \\\n                       \"LDAP handle unavailable\");                      \\\n            st = KRB5_KDB_ACCESS_ERROR;                                 \\\n            goto cleanup;                                               \\\n        }                                                               \\\n        if (st != LDAP_SUCCESS) {                                       \\\n            st = set_ldap_error(context, st, OP_SEARCH);                \\\n            goto cleanup;                                               \\\n        }                                                               \\\n    }\n\n\n#define CHECK_CLASS_VALIDITY(st, mask, str)                             \\\n    if (st != 0 || mask == 0) {                                         \\\n        if (st == 0 && mask == 0) {                                     \\\n            st = set_ldap_error(context, LDAP_OBJECT_CLASS_VIOLATION, OP_SEARCH); \\\n        }                                                               \\\n        k5_prependmsg(context, st, str);                                \\\n        goto cleanup;                                                   \\\n    }\n\n#define CHECK_NULL(ptr) if (ptr == NULL) {      \\\n        st = ENOMEM;                            \\\n        goto cleanup;                           \\\n    }\n\n#define  STORE16_INT(ptr, val)  store_16_be(val, ptr)\n#define  STORE32_INT(ptr, val)  store_32_be(val, ptr)\n#define UNSTORE16_INT(ptr, val) (val = load_16_be(ptr))\n#define UNSTORE32_INT(ptr, val) (val = load_32_be(ptr))\n\n#define  KDB_TL_USER_INFO      0x7ffe\n\n#define KDB_TL_PRINCTYPE          0x01\n#define KDB_TL_PRINCCOUNT         0x02\n#define KDB_TL_USERDN             0x03\n#define KDB_TL_KEYINFO            0x04\n#define KDB_TL_MASK               0x05\n/* 0x06 was KDB_TL_CONTAINERDN but is no longer used */\n#define KDB_TL_LINKDN             0x07\n\n\n#define CHECK_LDAP_HANDLE(lcontext)     if (!(ldap_context              \\\n                                              && ldap_context->server_info_list)) { \\\n        return KRB5_KDB_DBNOTINITED;                                    \\\n    }\n\n#define HNDL_LOCK(lcontext) k5_mutex_lock(&lcontext->hndl_lock)\n#define HNDL_UNLOCK(lcontext) k5_mutex_unlock(&lcontext->hndl_lock)\n\n/* ldap server info structure */\n\ntypedef enum _server_type {PRIMARY, SECONDARY} krb5_ldap_server_type;\n\ntypedef enum _server_status {OFF, ON, NOTSET} krb5_ldap_server_status;\n\ntypedef struct _krb5_ldap_server_info krb5_ldap_server_info;\n\ntypedef struct  _krb5_ldap_server_handle {\n    int                              msgid;\n    LDAP                             *ldap_handle;\n    krb5_ldap_server_info            *server_info;\n    struct _krb5_ldap_server_handle  *next;\n} krb5_ldap_server_handle;\n\nstruct _krb5_ldap_server_info {\n    krb5_ldap_server_type        server_type;\n    krb5_ldap_server_status      server_status;\n    krb5_ui_4                    num_conns;\n    krb5_ldap_server_handle      *ldap_server_handles;\n    time_t                       downtime;\n    char                        *server_name;\n    int                          modify_increment;\n    struct _krb5_ldap_server_info *next;\n};\n\n\n/* ldap server structure */\n\ntypedef enum {SERVICE_DN_TYPE_SERVER, SERVICE_DN_TYPE_CLIENT} krb5_ldap_servicetype;\n\ntypedef struct _krb5_ldap_context {\n    krb5_ldap_servicetype         service_type;\n    krb5_ldap_server_info         **server_info_list;\n    krb5_ui_4                     max_server_conns;\n    char                          *conf_section;\n    char                          *bind_dn;\n    char                          *bind_pwd;\n    char                          *service_password_file;\n    char                          *sasl_mech;\n    char                          *sasl_authcid;\n    char                          *sasl_authzid;\n    char                          *sasl_realm;\n    char                          *root_certificate_file;\n    krb5_ui_4                     cert_count; /* certificate count */\n    k5_mutex_t                    hndl_lock;\n    char                          *container_dn;\n    krb5_ldap_realm_params        *lrparams;\n    krb5_boolean                  disable_last_success;\n    krb5_boolean                  disable_lockout;\n    int                           ldap_debug;\n    krb5_context                  kcontext;   /* to set the error code and message */\n} krb5_ldap_context;\n\n\ntypedef struct {\n    int           nkey;\n    struct berval **keys;\n}KEY;\n\n#define k5ldap_inited(c) (c && c->db_context                            \\\n                          && ((kdb5_dal_handle*)c->db_context)->db_context \\\n                          && ((krb5_ldap_context *) ((kdb5_dal_handle*)c->db_context)->db_context))\n\n\n/* misc functions */\n\nkrb5_error_code\nkrb5_ldap_db_init(krb5_context, krb5_ldap_context *);\n\nkrb5_error_code\nkrb5_ldap_db_single_init(krb5_ldap_context *);\n\nkrb5_error_code\nkrb5_ldap_rebind(krb5_ldap_context *, krb5_ldap_server_handle **);\n\nkrb5_error_code\nkrb5_ldap_get_age(krb5_context, char *, time_t *);\n\nkrb5_error_code\nkrb5_ldap_lib_init(void);\n\nkrb5_error_code\nkrb5_ldap_lib_cleanup(void);\n\nvoid *\nkrb5_ldap_alloc( krb5_context kcontext,  void *ptr, size_t size );\n\nvoid\nkrb5_ldap_free( krb5_context kcontext, void *ptr );\n\nkrb5_error_code\nkrb5_ldap_create(krb5_context , char *, char **);\n\nkrb5_error_code\nkrb5_ldap_open( krb5_context , char *,\n                char **db_args,\n                int mode );\nkrb5_error_code\nkrb5_ldap_close( krb5_context );\n\nkrb5_error_code\nkrb5_ldap_free_ldap_context(krb5_ldap_context *);\n\nkrb5_error_code\nkrb5_ldap_read_startup_information(krb5_context );\n\nkrb5_boolean\nhas_modify_increment(krb5_context, const char *);\n\nvoid\nkrb5_ldap_free_server_context_params(krb5_ldap_context *ldap_context);\n\nkrb5_error_code\nkrb5_ldap_check_policy_as(krb5_context kcontext, krb5_kdc_req *request,\n                          krb5_db_entry *client, krb5_db_entry *server,\n                          krb5_timestamp kdc_time, const char **status,\n                          krb5_pa_data ***e_data);\n\nvoid\nkrb5_ldap_audit_as_req(krb5_context kcontext, krb5_kdc_req *request,\n                       const krb5_address *local_addr,\n                       const krb5_address *remote_addr, krb5_db_entry *client,\n                       krb5_db_entry *server, krb5_timestamp authtime,\n                       krb5_error_code error_code);\n\nkrb5_error_code\nkrb5_ldap_check_allowed_to_delegate(krb5_context context,\n                                    krb5_const_principal client,\n                                    const krb5_db_entry *server,\n                                    krb5_const_principal proxy);\n\n/* DAL functions */\n\n\nkrb5_error_code\nkrb5_ldap_lock( krb5_context, int );\n\nkrb5_error_code\nkrb5_ldap_unlock( krb5_context );\n\n/* lockout.c */\nkrb5_error_code\nkrb5_ldap_lockout_check_policy(krb5_context context,\n                               krb5_db_entry *entry,\n                               krb5_timestamp stamp);\n\nkrb5_error_code\nkrb5_ldap_lockout_audit(krb5_context context,\n                        krb5_db_entry *entry,\n                        krb5_timestamp stamp,\n                        krb5_error_code status);\n\n#endif\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c */\n/*\n * Copyright (C) 2016 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in\n *   the documentation and/or other materials provided with the\n *   distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#include \"ldap_main.h\"\n#include \"kdb_ldap.h\"\n#include \"ldap_principal.h\"\n#include \"princ_xdr.h\"\n#include \"ldap_tkt_policy.h\"\n#include \"ldap_pwd_policy.h\"\n#include \"ldap_err.h\"\n#include <kadm5/admin.h>\n#include <time.h>\n\nextern char* principal_attributes[];\nextern char* max_pwd_life_attr[];\n\nstatic char *\ngetstringtime(krb5_timestamp);\n\nkrb5_error_code\nberval2tl_data(struct berval *in, krb5_tl_data **out)\n{\n    *out = (krb5_tl_data *) malloc (sizeof (krb5_tl_data));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->tl_data_length = in->bv_len - 2;\n    (*out)->tl_data_contents =  (krb5_octet *) malloc\n        ((*out)->tl_data_length * sizeof (krb5_octet));\n    if ((*out)->tl_data_contents == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    UNSTORE16_INT (in->bv_val, (*out)->tl_data_type);\n    memcpy ((*out)->tl_data_contents, in->bv_val + 2, (*out)->tl_data_length);\n\n    return 0;\n}\n\n/*\n * look up a principal in the directory.\n */\n\nkrb5_error_code\nkrb5_ldap_get_principal(krb5_context context, krb5_const_principal searchfor,\n                        unsigned int flags, krb5_db_entry **entry_ptr)\n{\n    char                        *user=NULL, *filter=NULL, *filtuser=NULL;\n    unsigned int                tree=0, ntrees=1, princlen=0;\n    krb5_error_code             tempst=0, st=0;\n    char                        **values=NULL, **subtree=NULL, *cname=NULL;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_principal              cprinc=NULL;\n    krb5_boolean                found=FALSE;\n    krb5_db_entry               *entry = NULL;\n\n    *entry_ptr = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    if (searchfor == NULL)\n        return EINVAL;\n\n    dal_handle = context->dal_handle;\n    ldap_context = (krb5_ldap_context *) dal_handle->db_context;\n\n    CHECK_LDAP_HANDLE(ldap_context);\n\n    if (!is_principal_in_realm(ldap_context, searchfor)) {\n        st = KRB5_KDB_NOENTRY;\n        k5_setmsg(context, st, _(\"Principal does not belong to realm\"));\n        goto cleanup;\n    }\n\n    if ((st=krb5_unparse_name(context, searchfor, &user)) != 0)\n        goto cleanup;\n\n    if ((st=krb5_ldap_unparse_principal_name(user)) != 0)\n        goto cleanup;\n\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    princlen = strlen(FILTER) + strlen(filtuser) + 2 + 1;  /* 2 for closing brackets */\n    if ((filter = malloc(princlen)) == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    snprintf(filter, princlen, FILTER\"%s))\", filtuser);\n\n    if ((st = krb5_get_subtree_info(ldap_context, &subtree, &ntrees)) != 0)\n        goto cleanup;\n\n    GET_HANDLE();\n    for (tree=0; tree < ntrees && !found; ++tree) {\n\n        LDAP_SEARCH(subtree[tree], ldap_context->lrparams->search_scope, filter, principal_attributes);\n        for (ent=ldap_first_entry(ld, result); ent != NULL && !found; ent=ldap_next_entry(ld, ent)) {\n\n            /* get the associated directory user information */\n            if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                int i;\n\n                /* a wild-card in a principal name can return a list of kerberos principals.\n                 * Make sure that the correct principal is returned.\n                 * NOTE: a principalname k* in ldap server will return all the principals starting with a k\n                 */\n                for (i=0; values[i] != NULL; ++i) {\n                    if (strcmp(values[i], user) == 0) {\n                        found = TRUE;\n                        break;\n                    }\n                }\n                ldap_value_free(values);\n\n                if (!found) /* no matching principal found */\n                    continue;\n            }\n\n            if ((values=ldap_get_values(ld, ent, \"krbcanonicalname\")) != NULL) {\n                if (values[0] && strcmp(values[0], user) != 0) {\n                    /* We matched an alias, not the canonical name. */\n                    if (flags & KRB5_KDB_FLAG_ALIAS_OK) {\n                        st = krb5_ldap_parse_principal_name(values[0], &cname);\n                        if (st != 0)\n                            goto cleanup;\n                        st = krb5_parse_name(context, cname, &cprinc);\n                        if (st != 0)\n                            goto cleanup;\n                    } else /* No canonicalization, so don't return aliases. */\n                        found = FALSE;\n                }\n                ldap_value_free(values);\n                if (!found)\n                    continue;\n            }\n\n            entry = k5alloc(sizeof(*entry), &st);\n            if (entry == NULL)\n                goto cleanup;\n            if ((st = populate_krb5_db_entry(context, ldap_context, ld, ent,\n                                             cprinc ? cprinc : searchfor,\n                                             entry)) != 0)\n                goto cleanup;\n        }\n        ldap_msgfree(result);\n        result = NULL;\n    } /* for (tree=0 ... */\n\n    if (found) {\n        *entry_ptr = entry;\n        entry = NULL;\n    } else\n        st = KRB5_KDB_NOENTRY;\n\ncleanup:\n    ldap_msgfree(result);\n    krb5_db_free_principal(context, entry);\n\n    if (filter)\n        free (filter);\n\n    if (subtree) {\n        for (; ntrees; --ntrees)\n            if (subtree[ntrees-1])\n                free (subtree[ntrees-1]);\n        free (subtree);\n    }\n\n    if (ldap_server_handle)\n        krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    if (cname)\n        free(cname);\n\n    if (cprinc)\n        krb5_free_principal(context, cprinc);\n\n    return st;\n}\n\ntypedef enum{ ADD_PRINCIPAL, MODIFY_PRINCIPAL } OPERATION;\n/*\n * ptype is creating confusions. Additionally the logic\n * surronding ptype is redundunt and can be achevied\n * with the help of dn and containerdn members.\n * so dropping the ptype member\n */\n\ntypedef struct _xargs_t {\n    char           *dn;\n    char           *linkdn;\n    krb5_boolean   dn_from_kbd;\n    char           *containerdn;\n    char           *tktpolicydn;\n}xargs_t;\n\nstatic void\nfree_xargs(xargs_t xargs)\n{\n    if (xargs.dn)\n        free (xargs.dn);\n    if (xargs.linkdn)\n        free(xargs.linkdn);\n    if (xargs.containerdn)\n        free (xargs.containerdn);\n    if (xargs.tktpolicydn)\n        free (xargs.tktpolicydn);\n}\n\nstatic krb5_error_code\nprocess_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n    if (db_args) {\n        for (i=0; db_args[i]; ++i) {\n            arg = strtok_r(db_args[i], \"=\", &arg_val);\n            arg = (arg != NULL) ? arg : \"\";\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                dptr = &xargs->tktpolicydn;\n            } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}\n\nkrb5int_access accessor;\n\nstatic krb5_error_code\nasn1_encode_sequence_of_keys(krb5_key_data *key_data, krb5_int16 n_key_data,\n                             krb5_int32 mkvno, krb5_data **code)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data val;\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    val.key_data = key_data;\n    val.n_key_data = n_key_data;\n    val.mkvno = mkvno;\n    val.kvno = key_data[0].key_data_kvno;\n\n    return accessor.asn1_ldap_encode_sequence_of_keys(&val, code);\n}\n\nstatic krb5_error_code\nasn1_decode_sequence_of_keys(krb5_data *in, ldap_seqof_key_data *out)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data *p;\n    int i;\n\n    memset(out, 0, sizeof(*out));\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    err = accessor.asn1_ldap_decode_sequence_of_keys(in, &p);\n    if (err)\n        return err;\n\n    /* Set kvno and key_data_ver in each key_data element. */\n    for (i = 0; i < p->n_key_data; i++) {\n        p->key_data[i].key_data_kvno = p->kvno;\n        /* The decoder sets key_data_ver to 1 if no salt is present, but leaves\n         * it at 0 if salt is present. */\n        if (p->key_data[i].key_data_ver == 0)\n            p->key_data[i].key_data_ver = 2;\n    }\n\n    *out = *p;\n    free(p);\n    return 0;\n}\n\n/*\n * Free a NULL-terminated struct berval *array[] and all its contents.\n * Does not set array to NULL after freeing it.\n */\nvoid\nfree_berdata(struct berval **array)\n{\n    int i;\n\n    if (array != NULL) {\n        for (i = 0; array[i] != NULL; i++) {\n            if (array[i]->bv_val != NULL)\n                free(array[i]->bv_val);\n            free(array[i]);\n        }\n        free(array);\n    }\n}\n\n/*\n * Encode krb5_key_data into a berval struct for insertion into LDAP.\n */\nstatic krb5_error_code\nencode_keys(krb5_key_data *key_data_in, int n_key_data, krb5_kvno mkvno,\n            struct berval **bval_out)\n{\n    krb5_error_code err = 0;\n    int i;\n    krb5_key_data *key_data = NULL;\n    struct berval *bval = NULL;\n    krb5_data *code;\n\n    *bval_out = NULL;\n    if (n_key_data <= 0) {\n        err = EINVAL;\n        goto cleanup;\n    }\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    bval = k5alloc(sizeof(struct berval), &err);\n    if (bval == NULL)\n        goto cleanup;\n\n    err = asn1_encode_sequence_of_keys(key_data, n_key_data, mkvno, &code);\n    if (err)\n        goto cleanup;\n\n    /* Steal the data pointer from code for bval and discard code. */\n    bval->bv_len = code->length;\n    bval->bv_val = code->data;\n    free(code);\n\n    *bval_out = bval;\n    bval = NULL;\n\ncleanup:\n    free(key_data);\n    free(bval);\n    return err;\n}\n\n/* Decoding ASN.1 encoded key */\nstruct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data, int n_key_data,\n                         krb5_kvno mkvno)\n{\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 0;\n    int i, j, last;\n    krb5_error_code err = 0;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Find the number of key versions */\n    if (n_key_data > 0) {\n        for (i = 0, num_versions = 1; i < n_key_data - 1; i++) {\n            if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n                num_versions++;\n        }\n    }\n\n    ret = calloc(num_versions + 1, sizeof(struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    ret[num_versions] = NULL;\n\n    /* n_key_data may be 0 if a principal is created without a key. */\n    if (n_key_data == 0)\n        goto cleanup;\n\n    currkvno = key_data[0].key_data_kvno;\n    for (i = 0, last = 0, j = 0; i < n_key_data; i++) {\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            err = encode_keys(key_data + last, (krb5_int16)i - last + 1, mkvno,\n                              &ret[j]);\n            if (err)\n                goto cleanup;\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\n/*\n * Encode a principal's key history for insertion into ldap.\n */\nstatic struct berval **\nkrb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n\n    ret[princ_ent->old_key_len] = NULL;\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\ntl_data2berval (krb5_tl_data *in, struct berval **out)\n{\n    *out = (struct berval *) malloc (sizeof (struct berval));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->bv_len = in->tl_data_length + 2;\n    (*out)->bv_val =  (char *) malloc ((*out)->bv_len);\n    if ((*out)->bv_val == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    STORE16_INT((*out)->bv_val, in->tl_data_type);\n    memcpy ((*out)->bv_val + 2, in->tl_data_contents, in->tl_data_length);\n\n    return 0;\n}\n\n/* Parse the \"require_auth\" string for auth indicators, adding them to the\n * krbPrincipalAuthInd attribute. */\nstatic krb5_error_code\nupdate_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\n\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}\n\nkrb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* make sure the DN falls in the subtree */\n        int              dnlen=0, subtreelen=0;\n        char             *dn=NULL;\n        krb5_boolean     outofsubtree=TRUE;\n\n        if (xargs.dn != NULL) {\n            dn = xargs.dn;\n        } else if (xargs.linkdn != NULL) {\n            dn = xargs.linkdn;\n        } else if (standalone_principal_dn != NULL) {\n            /*\n             * Even though the standalone_principal_dn is constructed\n             * within this function, there is the containerdn input\n             * from the user that can become part of the it.\n             */\n            dn = standalone_principal_dn;\n        }\n\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        for (tre=0; tre<ntrees; ++tre) {\n            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {\n                outofsubtree = FALSE;\n                break;\n            } else {\n                dnlen = strlen (dn);\n                subtreelen = strlen(subtreelist[tre]);\n                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {\n                    outofsubtree = FALSE;\n                    break;\n                }\n            }\n        }\n\n        if (outofsubtree == TRUE) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"DN is out of the realm subtree\"));\n            goto cleanup;\n        }\n\n        /*\n         * dn value will be set either by dn, linkdn or the standalone_principal_dn\n         * In the first 2 cases, the dn should be existing and in the last case we\n         * are supposed to create the ldap object. so the below should not be\n         * executed for the last case.\n         */\n\n        if (standalone_principal_dn == NULL) {\n            /*\n             * If the ldap object is missing, this results in an error.\n             */\n\n            /*\n             * Search for krbprincipalname attribute here.\n             * This is to find if a kerberos identity is already present\n             * on the ldap object, in which case adding a kerberos identity\n             * on the ldap object should result in an error.\n             */\n            char  *attributes[]={\"krbticketpolicyreference\", \"krbprincipalname\", NULL};\n\n            ldap_msgfree(result);\n            result = NULL;\n            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);\n            if (st == LDAP_SUCCESS) {\n                ent = ldap_first_entry(ld, result);\n                if (ent != NULL) {\n                    if ((values=ldap_get_values(ld, ent, \"krbticketpolicyreference\")) != NULL) {\n                        ldap_value_free(values);\n                    }\n\n                    if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                        krb_identity_exists = TRUE;\n                        ldap_value_free(values);\n                    }\n                }\n            } else {\n                st = set_ldap_error(context, st, OP_SEARCH);\n                goto cleanup;\n            }\n        }\n    }\n\n    /*\n     * If xargs.dn is set then the request is to add a\n     * kerberos principal on a ldap object, but if\n     * there is one already on the ldap object this\n     * should result in an error.\n     */\n\n    if (xargs.dn != NULL && krb_identity_exists == TRUE) {\n        st = EINVAL;\n        snprintf(errbuf, sizeof(errbuf),\n                 _(\"ldap object is already kerberized\"));\n        k5_setmsg(context, st, \"%s\", errbuf);\n        goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\nkrb5_error_code\nkrb5_read_tkt_policy(krb5_context context, krb5_ldap_context *ldap_context,\n                     krb5_db_entry *entries, char *policy)\n{\n    krb5_error_code             st=0;\n    int                         mask=0, omask=0;\n    int                         tkt_mask=(KDB_MAX_LIFE_ATTR | KDB_MAX_RLIFE_ATTR | KDB_TKT_FLAGS_ATTR);\n    krb5_ldap_policy_params     *tktpoldnparam=NULL;\n\n    if ((st=krb5_get_attributes_mask(context, entries, &mask)) != 0)\n        goto cleanup;\n\n    if ((mask & tkt_mask) == tkt_mask)\n        goto cleanup;\n\n    if (policy != NULL) {\n        st = krb5_ldap_read_policy(context, policy, &tktpoldnparam, &omask);\n        if (st && st != KRB5_KDB_NOENTRY) {\n            k5_prependmsg(context, st, _(\"Error reading ticket policy\"));\n            goto cleanup;\n        }\n\n        st = 0; /* reset the return status */\n    }\n\n    if ((mask & KDB_MAX_LIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_LIFE_ATTR) ==  KDB_MAX_LIFE_ATTR)\n            entries->max_life = tktpoldnparam->maxtktlife;\n        else if (ldap_context->lrparams->max_life)\n            entries->max_life = ldap_context->lrparams->max_life;\n    }\n\n    if ((mask & KDB_MAX_RLIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_RLIFE_ATTR) == KDB_MAX_RLIFE_ATTR)\n            entries->max_renewable_life = tktpoldnparam->maxrenewlife;\n        else if (ldap_context->lrparams->max_renewable_life)\n            entries->max_renewable_life = ldap_context->lrparams->max_renewable_life;\n    }\n\n    if ((mask & KDB_TKT_FLAGS_ATTR) == 0) {\n        if ((omask & KDB_TKT_FLAGS_ATTR) == KDB_TKT_FLAGS_ATTR)\n            entries->attributes = tktpoldnparam->tktflags;\n        else if (ldap_context->lrparams->tktflags)\n            entries->attributes |= ldap_context->lrparams->tktflags;\n    }\n    krb5_ldap_free_policy(context, tktpoldnparam);\n\ncleanup:\n    return st;\n}\n\nstatic void\nfree_ldap_seqof_key_data(ldap_seqof_key_data *keysets, krb5_int16 n_keysets)\n{\n    int i;\n\n    if (keysets == NULL)\n        return;\n\n    for (i = 0; i < n_keysets; i++)\n        k5_free_key_data(keysets[i].n_key_data, keysets[i].key_data);\n    free(keysets);\n}\n\n/*\n * Decode keys from ldap search results.\n *\n * Arguments:\n *  - bvalues\n *      The ldap search results containing the key data.\n *  - mkvno\n *      The master kvno that the keys were encrypted with.\n *  - keysets_out\n *      The decoded keys in a ldap_seqof_key_data struct.  Must be freed using\n *      free_ldap_seqof_key_data.\n *  - n_keysets_out\n *      The number of entries in keys_out.\n *  - total_keys_out\n *      An optional argument that if given will be set to the total number of\n *      keys found throughout all the entries: sum(keys_out.n_key_data)\n *      May be NULL.\n */\nstatic krb5_error_code\ndecode_keys(struct berval **bvalues, ldap_seqof_key_data **keysets_out,\n            krb5_int16 *n_keysets_out, krb5_int16 *total_keys_out)\n{\n    krb5_error_code err = 0;\n    krb5_int16 n_keys, i, ki, total_keys;\n    ldap_seqof_key_data *keysets = NULL;\n\n    *keysets_out = NULL;\n    *n_keysets_out = 0;\n    if (total_keys_out)\n        *total_keys_out = 0;\n\n    /* Precount the number of keys. */\n    for (n_keys = 0, i = 0; bvalues[i] != NULL; i++) {\n        if (bvalues[i]->bv_len > 0)\n            n_keys++;\n    }\n\n    keysets = k5calloc(n_keys, sizeof(ldap_seqof_key_data), &err);\n    if (keysets == NULL)\n        goto cleanup;\n    memset(keysets, 0, n_keys * sizeof(ldap_seqof_key_data));\n\n    for (i = 0, ki = 0, total_keys = 0; bvalues[i] != NULL; i++) {\n        krb5_data in;\n\n        if (bvalues[i]->bv_len == 0)\n            continue;\n        in.length = bvalues[i]->bv_len;\n        in.data = bvalues[i]->bv_val;\n\n        err = asn1_decode_sequence_of_keys(&in, &keysets[ki]);\n        if (err)\n            goto cleanup;\n\n        if (total_keys_out)\n            total_keys += keysets[ki].n_key_data;\n        ki++;\n    }\n\n    if (total_keys_out)\n        *total_keys_out = total_keys;\n\n    *n_keysets_out = n_keys;\n    *keysets_out = keysets;\n    keysets = NULL;\n    n_keys = 0;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keys);\n    return err;\n}\n\nkrb5_error_code\nkrb5_decode_krbsecretkey(krb5_context context, krb5_db_entry *entries,\n                         struct berval **bvalues, krb5_kvno *mkvno)\n{\n    krb5_key_data *key_data = NULL, *tmp;\n    krb5_error_code err = 0;\n    ldap_seqof_key_data *keysets = NULL;\n    krb5_int16 i, n_keysets = 0, total_keys = 0;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, &total_keys);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal key data\"));\n        goto cleanup;\n    }\n\n    key_data = k5calloc(total_keys, sizeof(krb5_key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memset(key_data, 0, total_keys * sizeof(krb5_key_data));\n\n    if (n_keysets > 0)\n        *mkvno = keysets[0].mkvno;\n\n    /* Transfer key data values from keysets to a flat list in entries. */\n    tmp = key_data;\n    for (i = 0; i < n_keysets; i++) {\n        memcpy(tmp, keysets[i].key_data,\n               sizeof(krb5_key_data) * keysets[i].n_key_data);\n        tmp += keysets[i].n_key_data;\n        keysets[i].n_key_data = 0;\n    }\n    entries->n_key_data = total_keys;\n    entries->key_data = key_data;\n    key_data = NULL;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    k5_free_key_data(total_keys, key_data);\n    return err;\n}\n\nstatic int\ncompare_osa_pw_hist_ent(const void *left_in, const void *right_in)\n{\n    int kvno_left, kvno_right;\n    osa_pw_hist_ent *left = (osa_pw_hist_ent *)left_in;\n    osa_pw_hist_ent *right = (osa_pw_hist_ent *)right_in;\n\n    kvno_left = left->n_key_data ? left->key_data[0].key_data_kvno : 0;\n    kvno_right = right->n_key_data ? right->key_data[0].key_data_kvno : 0;\n    return kvno_left - kvno_right;\n}\n\n/*\n * Decode the key history entries from an LDAP search.\n *\n * NOTE: the caller must free princ_ent->old_keys even on error.\n */\nkrb5_error_code\nkrb5_decode_histkey(krb5_context context, struct berval **bvalues,\n                    osa_princ_ent_rec *princ_ent)\n{\n    krb5_error_code err = 0;\n    krb5_int16 i, n_keysets = 0;\n    ldap_seqof_key_data *keysets = NULL;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, NULL);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal pw history\"));\n        goto cleanup;\n    }\n\n    princ_ent->old_keys = k5calloc(n_keysets, sizeof(osa_pw_hist_ent), &err);\n    if (princ_ent->old_keys == NULL)\n        goto cleanup;\n    princ_ent->old_key_len = n_keysets;\n\n    if (n_keysets > 0)\n        princ_ent->admin_history_kvno = keysets[0].mkvno;\n\n    /* Transfer key data pointers from keysets to princ_ent. */\n    for (i = 0; i < n_keysets; i++) {\n        princ_ent->old_keys[i].n_key_data = keysets[i].n_key_data;\n        princ_ent->old_keys[i].key_data = keysets[i].key_data;\n        keysets[i].n_key_data = 0;\n        keysets[i].key_data = NULL;\n    }\n\n    /* Sort the principal entries by kvno in ascending order. */\n    qsort(princ_ent->old_keys, princ_ent->old_key_len, sizeof(osa_pw_hist_ent),\n          &compare_osa_pw_hist_ent);\n\n    princ_ent->aux_attributes |= KADM5_KEY_HIST;\n\n    /* Set the next key to the end of the list.  The queue will be lengthened\n     * if it isn't full yet; the first entry will be replaced if it is full. */\n    princ_ent->old_key_next = princ_ent->old_key_len;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    return err;\n}\n\nstatic char *\ngetstringtime(krb5_timestamp epochtime)\n{\n    struct tm           tme;\n    char                *strtime=NULL;\n    time_t              posixtime = ts2tt(epochtime);\n\n    strtime = calloc (50, 1);\n    if (strtime == NULL)\n        return NULL;\n\n    if (gmtime_r(&posixtime, &tme) == NULL)\n        return NULL;\n\n    strftime(strtime, 50, \"%Y%m%d%H%M%SZ\", &tme);\n    return strtime;\n}\n", "#!/usr/bin/python\nfrom k5test import *\nimport time\nfrom itertools import imap\n\n# Run kdbtest against the BDB module.\nrealm = K5Realm(create_kdb=False)\nrealm.run(['./kdbtest'])\n\n# Set up an OpenLDAP test server if we can.\n\nif (not os.path.exists(os.path.join(plugins, 'kdb', 'kldap.so')) and\n    not os.path.exists(os.path.join(buildtop, 'lib', 'libkdb_ldap.a'))):\n    skip_rest('LDAP KDB tests', 'LDAP KDB module not built')\n\nif 'SLAPD' not in os.environ and not which('slapd'):\n    skip_rest('LDAP KDB tests', 'slapd not found')\n\nslapadd = which('slapadd')\nif not slapadd:\n    skip_rest('LDAP KDB tests', 'slapadd not found')\n\nldapdir = os.path.abspath('ldap')\ndbdir = os.path.join(ldapdir, 'ldap')\nslapd_conf = os.path.join(ldapdir, 'slapd.d')\nslapd_out = os.path.join(ldapdir, 'slapd.out')\nslapd_pidfile = os.path.join(ldapdir, 'pid')\nldap_pwfile = os.path.join(ldapdir, 'pw')\nldap_sock = os.path.join(ldapdir, 'sock')\nldap_uri = 'ldapi://%s/' % ldap_sock.replace(os.path.sep, '%2F')\nschema = os.path.join(srctop, 'plugins', 'kdb', 'ldap', 'libkdb_ldap',\n                      'kerberos.openldap.ldif')\ntop_dn = 'cn=krb5'\nadmin_dn = 'cn=admin,cn=krb5'\nadmin_pw = 'admin'\n\nshutil.rmtree(ldapdir, True)\nos.mkdir(ldapdir)\nos.mkdir(slapd_conf)\nos.mkdir(dbdir)\n\nif 'SLAPD' in os.environ:\n    slapd = os.environ['SLAPD']\nelse:\n    # Some Linux installations have AppArmor or similar restrictions\n    # on the slapd binary, which would prevent it from accessing the\n    # build directory.  Try to defeat this by copying the binary.\n    system_slapd = which('slapd')\n    slapd = os.path.join(ldapdir, 'slapd')\n    shutil.copy(system_slapd, slapd)\n\ndef slap_add(ldif):\n    proc = subprocess.Popen([slapadd, '-b', 'cn=config', '-F', slapd_conf],\n                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT)\n    (out, dummy) = proc.communicate(ldif)\n    output(out)\n    return proc.wait()\n\n\n# Configure the pid file and some authorization rules we will need for\n# SASL testing.\nif slap_add('dn: cn=config\\n'\n            'objectClass: olcGlobal\\n'\n            'olcPidFile: %s\\n'\n            'olcAuthzRegexp: '\n            '\".*uidNumber=%d,cn=peercred,cn=external,cn=auth\" \"%s\"\\n'\n            'olcAuthzRegexp: \"uid=digestuser,cn=digest-md5,cn=auth\" \"%s\"\\n' %\n            (slapd_pidfile, os.geteuid(), admin_dn, admin_dn)) != 0:\n    skip_rest('LDAP KDB tests', 'slapd basic configuration failed')\n\n# Find a working writable database type, trying mdb (added in OpenLDAP\n# 2.4.27) and bdb (deprecated and sometimes not built due to licensing\n# incompatibilities).\nfor dbtype in ('mdb', 'bdb'):\n    # Try to load the module.  This could fail if OpenLDAP is built\n    # without module support, so ignore errors.\n    slap_add('dn: cn=module,cn=config\\n'\n             'objectClass: olcModuleList\\n'\n             'olcModuleLoad: back_%s\\n' % dbtype)\n\n    dbclass = 'olc%sConfig' % dbtype.capitalize()\n    if slap_add('dn: olcDatabase=%s,cn=config\\n'\n                'objectClass: olcDatabaseConfig\\n'\n                'objectClass: %s\\n'\n                'olcSuffix: %s\\n'\n                'olcRootDN: %s\\n'\n                'olcRootPW: %s\\n'\n                'olcDbDirectory: %s\\n' %\n                (dbtype, dbclass, top_dn, admin_dn, admin_pw, dbdir)) == 0:\n        break\nelse:\n    skip_rest('LDAP KDB tests', 'could not find working slapd db type')\n\nif slap_add('include: file://%s\\n' % schema) != 0:\n    skip_rest('LDAP KDB tests', 'failed to load Kerberos schema')\n\n# Load the core schema if we can.\nldap_homes = ['/etc/ldap', '/etc/openldap', '/usr/local/etc/openldap',\n              '/usr/local/etc/ldap']\nlocal_schema_path = '/schema/core.ldif'\ncore_schema = next((i for i in imap(lambda x:x+local_schema_path, ldap_homes)\n                    if os.path.isfile(i)), None)\nif core_schema:\n    if slap_add('include: file://%s\\n' % core_schema) != 0:\n        core_schema = None\n\nslapd_pid = -1\ndef kill_slapd():\n    global slapd_pid\n    if slapd_pid != -1:\n        os.kill(slapd_pid, signal.SIGTERM)\n        slapd_pid = -1\natexit.register(kill_slapd)\n\nout = open(slapd_out, 'w')\nsubprocess.call([slapd, '-h', ldap_uri, '-F', slapd_conf], stdout=out,\n                stderr=out)\nout.close()\npidf = open(slapd_pidfile, 'r')\nslapd_pid = int(pidf.read())\npidf.close()\noutput('*** Started slapd (pid %d, output in %s)\\n' % (slapd_pid, slapd_out))\n\n# slapd detaches before it finishes setting up its listener sockets\n# (they are bound but listen() has not been called).  Give it a second\n# to finish.\ntime.sleep(1)\n\n# Run kdbtest against the LDAP module.\nconf = {'realms': {'$realm': {'database_module': 'ldap'}},\n        'dbmodules': {'ldap': {'db_library': 'kldap',\n                               'ldap_kerberos_container_dn': top_dn,\n                               'ldap_kdc_dn': admin_dn,\n                               'ldap_kadmind_dn': admin_dn,\n                               'ldap_service_password_file': ldap_pwfile,\n                               'ldap_servers': ldap_uri}}}\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\ninput = admin_pw + '\\n' + admin_pw + '\\n'\nrealm.run([kdb5_ldap_util, 'stashsrvpw', admin_dn], input=input)\nrealm.run(['./kdbtest'])\n\n# Run a kdb5_ldap_util command using the test server's admin DN and password.\ndef kldaputil(args, **kw):\n    return realm.run([kdb5_ldap_util, '-D', admin_dn, '-w', admin_pw] + args,\n                     **kw)\n\n# kdbtest can't currently clean up after itself since the LDAP module\n# doesn't support krb5_db_destroy.  So clean up after it with\n# kdb5_ldap_util before proceeding.\nkldaputil(['destroy', '-f'])\n\nldapmodify = which('ldapmodify')\nldapsearch = which('ldapsearch')\nif not ldapmodify or not ldapsearch:\n    skip_rest('some LDAP KDB tests', 'ldapmodify or ldapsearch not found')\n\ndef ldap_search(args):\n    proc = subprocess.Popen([ldapsearch, '-H', ldap_uri, '-b', top_dn,\n                             '-D', admin_dn, '-w', admin_pw, args],\n                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT)\n    (out, dummy) = proc.communicate()\n    return out\n\ndef ldap_modify(ldif, args=[]):\n    proc = subprocess.Popen([ldapmodify, '-H', ldap_uri, '-D', admin_dn,\n                             '-x', '-w', admin_pw] + args,\n                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT)\n    (out, dummy) = proc.communicate(ldif)\n    output(out)\n\ndef ldap_add(dn, objectclass, attrs=[]):\n    in_data = 'dn: %s\\nobjectclass: %s\\n' % (dn, objectclass)\n    in_data += '\\n'.join(attrs) + '\\n'\n    ldap_modify(in_data, ['-a'])\n\n# Create krbContainer objects for use as subtrees.\nldap_add('cn=t1,cn=krb5', 'krbContainer')\nldap_add('cn=t2,cn=krb5', 'krbContainer')\nldap_add('cn=x,cn=t1,cn=krb5', 'krbContainer')\nldap_add('cn=y,cn=t2,cn=krb5', 'krbContainer')\n\n# Create a realm, exercising all of the realm options.\nkldaputil(['create', '-s', '-P', 'master', '-subtrees', 'cn=t2,cn=krb5',\n           '-containerref', 'cn=t2,cn=krb5', '-sscope', 'one',\n           '-maxtktlife', '5min', '-maxrenewlife', '10min', '-allow_svr'])\n\n# Modify the realm, exercising overlapping subtree pruning.\nkldaputil(['modify', '-subtrees',\n           'cn=x,cn=t1,cn=krb5:cn=t1,cn=krb5:cn=t2,cn=krb5:cn=y,cn=t2,cn=krb5',\n           '-containerref', 'cn=t1,cn=krb5', '-sscope', 'sub',\n           '-maxtktlife', '5hour', '-maxrenewlife', '10hour', '+allow_svr'])\n\nout = kldaputil(['list'])\nif out != 'KRBTEST.COM\\n':\n    fail('Unexpected kdb5_ldap_util list output')\n\n# Create a principal at a specified DN.  This is a little dodgy\n# because we're sticking a krbPrincipalAux objectclass onto a subtree\n# krbContainer, but it works and it avoids having to load core.schema\n# in the test LDAP server.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=cn=krb5', 'princ1'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=cn=t2,cn=krb5', 'princ1'])\nrealm.run([kadminl, 'getprinc', 'princ1'], expected_msg='Principal: princ1')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=cn=t2,cn=krb5', 'again'],\n          expected_code=1, expected_msg='ldap object is already kerberized')\n# Check that we can't set linkdn on a non-standalone object.\nrealm.run([kadminl, 'modprinc', '-x', 'linkdn=cn=t1,cn=krb5', 'princ1'],\n          expected_code=1, expected_msg='link information can not be set')\n\n# Create a principal with a specified linkdn.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'linkdn=cn=krb5', 'princ2'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'linkdn=cn=t1,cn=krb5', 'princ2'])\n# Check that we can't reset linkdn.\nrealm.run([kadminl, 'modprinc', '-x', 'linkdn=cn=t2,cn=krb5', 'princ2'],\n          expected_code=1, expected_msg='kerberos principal is already linked')\n\n# Create a principal with a specified containerdn.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'containerdn=cn=krb5', 'princ3'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'containerdn=cn=t1,cn=krb5',\n           'princ3'])\nrealm.run([kadminl, 'modprinc', '-x', 'containerdn=cn=t2,cn=krb5', 'princ3'],\n          expected_code=1, expected_msg='containerdn option not supported')\n\n# Create and modify a ticket policy.\nkldaputil(['create_policy', '-maxtktlife', '3hour', '-maxrenewlife', '6hour',\n           '-allow_forwardable', 'tktpol'])\nkldaputil(['modify_policy', '-maxtktlife', '4hour', '-maxrenewlife', '8hour',\n           '+requires_preauth', 'tktpol'])\nout = kldaputil(['view_policy', 'tktpol'])\nif ('Ticket policy: tktpol\\n' not in out or\n    'Maximum ticket life: 0 days 04:00:00\\n' not in out or\n    'Maximum renewable life: 0 days 08:00:00\\n' not in out or\n    'Ticket flags: DISALLOW_FORWARDABLE REQUIRES_PRE_AUTH' not in out):\n    fail('Unexpected kdb5_ldap_util view_policy output')\n\nout = kldaputil(['list_policy'])\nif out != 'tktpol\\n':\n    fail('Unexpected kdb5_ldap_util list_policy output')\n\n# Associate the ticket policy to a principal.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'tktpolicy=tktpol', 'princ4'])\nout = realm.run([kadminl, 'getprinc', 'princ4'])\nif ('Maximum ticket life: 0 days 04:00:00\\n' not in out or\n    'Maximum renewable life: 0 days 08:00:00\\n' not in out or\n    'Attributes: DISALLOW_FORWARDABLE REQUIRES_PRE_AUTH\\n' not in out):\n    fail('Unexpected getprinc output with ticket policy')\n\n# Destroying the policy should fail while a principal references it.\nkldaputil(['destroy_policy', '-force', 'tktpol'], expected_code=1)\n\n# Dissociate the ticket policy from the principal.\nrealm.run([kadminl, 'modprinc', '-x', 'tktpolicy=', 'princ4'])\nout = realm.run([kadminl, 'getprinc', 'princ4'])\nif ('Maximum ticket life: 0 days 05:00:00\\n' not in out or\n    'Maximum renewable life: 0 days 10:00:00\\n' not in out or\n    'Attributes:\\n' not in out):\n    fail('Unexpected getprinc output without ticket policy')\n\n# Destroy the ticket policy.\nkldaputil(['destroy_policy', '-force', 'tktpol'])\nkldaputil(['view_policy', 'tktpol'], expected_code=1)\nout = kldaputil(['list_policy'])\nif out:\n    fail('Unexpected kdb5_ldap_util list_policy output after destroy')\n\n# Create another ticket policy to be destroyed with the realm.\nkldaputil(['create_policy', 'tktpol2'])\n\n# Try to create a password policy conflicting with a ticket policy.\nrealm.run([kadminl, 'addpol', 'tktpol2'], expected_code=1,\n          expected_msg='Already exists while creating policy \"tktpol2\"')\n\n# Try to create a ticket policy conflicting with a password policy.\nrealm.run([kadminl, 'addpol', 'pwpol'])\nout = kldaputil(['create_policy', 'pwpol'], expected_code=1)\nif 'Already exists while creating policy object' not in out:\n    fail('Expected error not seen in kdb5_ldap_util output')\n\n# Try to use a password policy as a ticket policy.\nrealm.run([kadminl, 'modprinc', '-x', 'tktpolicy=pwpol', 'princ4'],\n          expected_code=1, expected_msg='Object class violation')\n\n# Use a ticket policy as a password policy (CVE-2014-5353).  This\n# works with a warning; use kadmin.local -q so the warning is shown.\nrealm.run([kadminl, '-q', 'modprinc -policy tktpol2 princ4'],\n          expected_msg='WARNING: policy \"tktpol2\" does not exist')\n\n# Do some basic tests with a KDC against the LDAP module, exercising the\n# db_args processing code.\nrealm.start_kdc(['-x', 'nconns=3', '-x', 'host=' + ldap_uri,\n                 '-x', 'binddn=' + admin_dn, '-x', 'bindpwd=' + admin_pw])\nrealm.addprinc(realm.user_princ, password('user'))\nrealm.addprinc(realm.host_princ)\nrealm.extract_keytab(realm.host_princ, realm.keytab)\nrealm.kinit(realm.user_princ, password('user'))\nrealm.run([kvno, realm.host_princ])\nrealm.klist(realm.user_princ, realm.host_princ)\n\n# Test auth indicator support\nrealm.addprinc('authind', password('authind'))\nrealm.run([kadminl, 'setstr', 'authind', 'require_auth', 'otp radius'])\n\nout = ldap_search('(krbPrincipalName=authind*)')\nif 'krbPrincipalAuthInd: otp' not in out:\n    fail('Expected krbPrincipalAuthInd value not in output')\nif 'krbPrincipalAuthInd: radius' not in out:\n    fail('Expected krbPrincipalAuthInd value not in output')\n\nrealm.run([kadminl, 'getstrs', 'authind'],\n          expected_msg='require_auth: otp radius')\n\n# Test service principal aliases.\nrealm.addprinc('canon', password('canon'))\nldap_modify('dn: krbPrincipalName=canon@KRBTEST.COM,cn=t1,cn=krb5\\n'\n            'changetype: modify\\n'\n            'add: krbPrincipalName\\n'\n            'krbPrincipalName: alias@KRBTEST.COM\\n'\n            '-\\n'\n            'add: krbCanonicalName\\n'\n            'krbCanonicalName: canon@KRBTEST.COM\\n')\nrealm.run([kadminl, 'getprinc', 'alias'],\n          expected_msg='Principal: canon@KRBTEST.COM\\n')\nrealm.run([kadminl, 'getprinc', 'canon'],\n          expected_msg='Principal: canon@KRBTEST.COM\\n')\nrealm.run([kvno, 'alias', 'canon'])\nout = realm.run([klist])\nif 'alias@KRBTEST.COM\\n' not in out or 'canon@KRBTEST.COM' not in out:\n    fail('After fetching alias and canon, klist is missing one or both')\nrealm.kinit(realm.user_princ, password('user'), ['-S', 'alias'])\nrealm.klist(realm.user_princ, 'alias@KRBTEST.COM')\n\n# Make sure an alias to the local TGS is still treated like an alias.\nldap_modify('dn: krbPrincipalName=krbtgt/KRBTEST.COM@KRBTEST.COM,'\n            'cn=KRBTEST.COM,cn=krb5\\n'\n            'changetype: modify\\n'\n            'add:krbPrincipalName\\n'\n            'krbPrincipalName: tgtalias@KRBTEST.COM\\n'\n            '-\\n'\n            'add: krbCanonicalName\\n'\n            'krbCanonicalName: krbtgt/KRBTEST.COM@KRBTEST.COM\\n')\nrealm.run([kadminl, 'getprinc', 'tgtalias'],\n          expected_msg='Principal: krbtgt/KRBTEST.COM@KRBTEST.COM')\nrealm.kinit(realm.user_princ, password('user'))\nrealm.run([kvno, 'tgtalias'])\nrealm.klist(realm.user_princ, 'tgtalias@KRBTEST.COM')\n\n# Make sure aliases work in header tickets.\nrealm.run([kadminl, 'modprinc', '-maxrenewlife', '3 hours', 'user'])\nrealm.run([kadminl, 'modprinc', '-maxrenewlife', '3 hours',\n           'krbtgt/KRBTEST.COM'])\nrealm.kinit(realm.user_princ, password('user'), ['-l', '1h', '-r', '2h'])\nrealm.run([kvno, 'alias'])\nrealm.kinit(realm.user_princ, flags=['-R', '-S', 'alias'])\nrealm.klist(realm.user_princ, 'alias@KRBTEST.COM')\n\n# Test client principal aliases, with and without preauth.\nrealm.kinit('canon', password('canon'))\nrealm.kinit('alias', password('canon'), expected_code=1,\n            expected_msg='not found in Kerberos database')\nrealm.kinit('alias', password('canon'), ['-C'])\nrealm.run([kvno, 'alias'])\nrealm.klist('canon@KRBTEST.COM', 'alias@KRBTEST.COM')\nrealm.run([kadminl, 'modprinc', '+requires_preauth', 'canon'])\nrealm.kinit('canon', password('canon'))\nrealm.kinit('alias', password('canon'), ['-C'])\n\n# Test password history.\ndef test_pwhist(nhist):\n    def cpw(n, **kwargs):\n        realm.run([kadminl, 'cpw', '-pw', str(n), princ], **kwargs)\n    def cpw_fail(n):\n        cpw(n, expected_code=1)\n    output('*** Testing password history of size %d\\n' % nhist)\n    princ = 'pwhistprinc' + str(nhist)\n    pol = 'pwhistpol' + str(nhist)\n    realm.run([kadminl, 'addpol', '-history', str(nhist), pol])\n    realm.run([kadminl, 'addprinc', '-policy', pol, '-nokey', princ])\n    for i in range(nhist):\n        # Set a password, then check that all previous passwords fail.\n        cpw(i)\n        for j in range(i + 1):\n            cpw_fail(j)\n    # Set one more new password, and make sure the oldest key is\n    # rotated out.\n    cpw(nhist)\n    cpw_fail(1)\n    cpw(0)\n\nfor n in (1, 2, 3, 4, 5):\n    test_pwhist(n)\n\n# Regression test for #8193: test password character class requirements.\nprinc = 'charclassprinc'\npol = 'charclasspol'\nrealm.run([kadminl, 'addpol', '-minclasses', '3', pol])\nrealm.run([kadminl, 'addprinc', '-policy', pol, '-nokey', princ])\nrealm.run([kadminl, 'cpw', '-pw', 'abcdef', princ], expected_code=1)\nrealm.run([kadminl, 'cpw', '-pw', 'Abcdef', princ], expected_code=1)\nrealm.run([kadminl, 'cpw', '-pw', 'Abcdef1', princ])\n\n# Test principal renaming and make sure last modified is changed\ndef get_princ(princ):\n    out = realm.run([kadminl, 'getprinc', princ])\n    return dict(map(str.strip, x.split(\":\", 1)) for x in out.splitlines())\n\nrealm.addprinc(\"rename\", password('rename'))\nrenameprinc = get_princ(\"rename\")\nrealm.run([kadminl, '-p', 'fake@KRBTEST.COM', 'renprinc', 'rename', 'renamed'])\nrenamedprinc = get_princ(\"renamed\")\nif renameprinc['Last modified'] == renamedprinc['Last modified']:\n    fail('Last modified data not updated when principal was renamed')\n\n# Regression test for #7980 (fencepost when dividing keys up by kvno).\nrealm.run([kadminl, 'addprinc', '-randkey', '-e', 'aes256-cts,aes128-cts',\n           'kvnoprinc'])\nrealm.run([kadminl, 'cpw', '-randkey', '-keepold', '-e',\n           'aes256-cts,aes128-cts', 'kvnoprinc'])\nrealm.run([kadminl, 'getprinc', 'kvnoprinc'], expected_msg='Number of keys: 4')\nrealm.run([kadminl, 'cpw', '-randkey', '-keepold', '-e',\n           'aes256-cts,aes128-cts', 'kvnoprinc'])\nrealm.run([kadminl, 'getprinc', 'kvnoprinc'], expected_msg='Number of keys: 6')\n\n# Regression test for #8041 (NULL dereference on keyless principals).\nrealm.run([kadminl, 'addprinc', '-nokey', 'keylessprinc'])\nrealm.run([kadminl, 'getprinc', 'keylessprinc'],\n          expected_msg='Number of keys: 0')\nrealm.run([kadminl, 'cpw', '-randkey', '-e', 'aes256-cts,aes128-cts',\n           'keylessprinc'])\nrealm.run([kadminl, 'cpw', '-randkey', '-keepold', '-e',\n           'aes256-cts,aes128-cts', 'keylessprinc'])\nrealm.run([kadminl, 'getprinc', 'keylessprinc'],\n          expected_msg='Number of keys: 4')\nrealm.run([kadminl, 'purgekeys', '-all', 'keylessprinc'])\nrealm.run([kadminl, 'getprinc', 'keylessprinc'],\n          expected_msg='Number of keys: 0')\n\n# Test for 8354 (old password history entries when -keepold is used)\nrealm.run([kadminl, 'addpol', '-history', '2', 'keepoldpasspol'])\nrealm.run([kadminl, 'addprinc', '-policy', 'keepoldpasspol', '-pw', 'aaaa',\n           'keepoldpassprinc'])\nfor p in ('bbbb', 'cccc', 'aaaa'):\n    realm.run([kadminl, 'cpw', '-keepold', '-pw', p, 'keepoldpassprinc'])\n\nif runenv.sizeof_time_t <= 4:\n    skipped('y2038 LDAP test', 'platform has 32-bit time_t')\nelse:\n    # Test storage of timestamps after y2038.\n    realm.run([kadminl, 'modprinc', '-pwexpire', '2040-02-03', 'user'])\n    realm.run([kadminl, 'getprinc', 'user'], expected_msg=' 2040\\n')\n\nrealm.stop()\n\n# Briefly test dump and load.\ndumpfile = os.path.join(realm.testdir, 'dump')\nrealm.run([kdb5_util, 'dump', dumpfile])\nrealm.run([kdb5_util, 'load', dumpfile], expected_code=1,\n          expected_msg='KDB module requires -update argument')\nrealm.run([kdb5_util, 'load', '-update', dumpfile])\n\n# Destroy the realm.\nkldaputil(['destroy', '-f'])\nout = kldaputil(['list'])\nif out:\n    fail('Unexpected kdb5_ldap_util list output after destroy')\n\nif not core_schema:\n    skip_rest('LDAP SASL tests', 'core schema not found')\n\nif runenv.have_sasl != 'yes':\n    skip_rest('LDAP SASL tests', 'SASL support not built')\n\n# Test SASL EXTERNAL auth.  Remove the DNs and service password file\n# from the DB module config.\nos.remove(ldap_pwfile)\ndbmod = conf['dbmodules']['ldap']\ndbmod['ldap_kdc_sasl_mech'] = dbmod['ldap_kadmind_sasl_mech'] = 'EXTERNAL'\ndel dbmod['ldap_service_password_file']\ndel dbmod['ldap_kdc_dn'], dbmod['ldap_kadmind_dn']\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\nrealm.run([kdb5_ldap_util, 'create', '-s', '-P', 'master'])\nrealm.start_kdc()\nrealm.addprinc(realm.user_princ, password('user'))\nrealm.kinit(realm.user_princ, password('user'))\nrealm.stop()\nrealm.run([kdb5_ldap_util, 'destroy', '-f'])\n\n# Test SASL DIGEST-MD5 auth.  We need to set a clear-text password for\n# the admin DN, so create a person entry (requires the core schema).\n# Restore the service password file in the config and set authcids.\nldap_add('cn=admin,cn=krb5', 'person',\n         ['sn: dummy', 'userPassword: admin'])\ndbmod['ldap_kdc_sasl_mech'] = dbmod['ldap_kadmind_sasl_mech'] = 'DIGEST-MD5'\ndbmod['ldap_kdc_sasl_authcid'] = 'digestuser'\ndbmod['ldap_kadmind_sasl_authcid'] = 'digestuser'\ndbmod['ldap_service_password_file'] = ldap_pwfile\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\ninput = admin_pw + '\\n' + admin_pw + '\\n'\nrealm.run([kdb5_ldap_util, 'stashsrvpw', 'digestuser'], input=input)\nrealm.run([kdb5_ldap_util, 'create', '-s', '-P', 'master'])\nrealm.start_kdc()\nrealm.addprinc(realm.user_princ, password('user'))\nrealm.kinit(realm.user_princ, password('user'))\nrealm.stop()\n# Exercise DB options, which should cause binding to fail.\nrealm.run([kadminl, '-x', 'sasl_authcid=ab', 'getprinc', 'user'],\n          expected_code=1, expected_msg='Cannot bind to LDAP server')\nrealm.run([kadminl, '-x', 'bindpwd=wrong', 'getprinc', 'user'],\n          expected_code=1, expected_msg='Cannot bind to LDAP server')\nrealm.run([kdb5_ldap_util, 'destroy', '-f'])\n\n# We could still use tests to exercise:\n# * DB arg handling in krb5_ldap_create\n# * krbAllowedToDelegateTo attribute processing\n# * A load operation overwriting a standalone principal entry which\n#   already exists but doesn't have a krbPrincipalName attribute\n#   matching the principal name.\n# * A bunch of invalid-input error conditions\n#\n# There is no coverage for the following because it would be difficult:\n# * Out-of-memory error conditions\n# * Handling of failures from slapd (including krb5_retry_get_ldap_handle)\n# * Handling of servers which don't support mod-increment\n# * krb5_ldap_delete_krbcontainer (only happens if krb5_ldap_create fails)\n\nsuccess('LDAP and DB2 KDB tests')\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n *\n * $Header$\n */\n#include \"k5-int.h\"\n#include        <sys/time.h>\n#include        <kadm5/admin.h>\n#include        <kdb.h>\n#include        \"server_internal.h\"\n#ifdef USE_PASSWORD_SERVER\n#include        <sys/wait.h>\n#include        <signal.h>\n#endif\n\n#include <krb5/kadm5_hook_plugin.h>\n\n#ifdef USE_VALGRIND\n#include <valgrind/memcheck.h>\n#else\n#define VALGRIND_CHECK_DEFINED(LVALUE) ((void)0)\n#endif\n\nextern  krb5_principal      master_princ;\nextern  krb5_principal      hist_princ;\nextern  krb5_keyblock       master_keyblock;\nextern  krb5_db_entry       master_db;\n\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys);\n\n/*\n * XXX Functions that ought to be in libkrb5.a, but aren't.\n */\nkadm5_ret_t krb5_copy_key_data_contents(context, from, to)\n    krb5_context context;\n    krb5_key_data *from, *to;\n{\n    int i, idx;\n\n    *to = *from;\n\n    idx = (from->key_data_ver == 1 ? 1 : 2);\n\n    for (i = 0; i < idx; i++) {\n        if ( from->key_data_length[i] ) {\n            to->key_data_contents[i] = malloc(from->key_data_length[i]);\n            if (to->key_data_contents[i] == NULL) {\n                for (i = 0; i < idx; i++)\n                    zapfree(to->key_data_contents[i], to->key_data_length[i]);\n                return ENOMEM;\n            }\n            memcpy(to->key_data_contents[i], from->key_data_contents[i],\n                   from->key_data_length[i]);\n        }\n    }\n    return 0;\n}\n\nstatic krb5_tl_data *dup_tl_data(krb5_tl_data *tl)\n{\n    krb5_tl_data *n;\n\n    n = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n    if (n == NULL)\n        return NULL;\n    n->tl_data_contents = malloc(tl->tl_data_length);\n    if (n->tl_data_contents == NULL) {\n        free(n);\n        return NULL;\n    }\n    memcpy(n->tl_data_contents, tl->tl_data_contents, tl->tl_data_length);\n    n->tl_data_type = tl->tl_data_type;\n    n->tl_data_length = tl->tl_data_length;\n    n->tl_data_next = NULL;\n    return n;\n}\n\n/* This is in lib/kdb/kdb_cpw.c, but is static */\nstatic void cleanup_key_data(context, count, data)\n    krb5_context   context;\n    int                    count;\n    krb5_key_data        * data;\n{\n    int i;\n\n    for (i = 0; i < count; i++)\n        krb5_free_key_data_contents(context, &data[i]);\n    free(data);\n}\n\n/* Check whether a ks_tuple is present in an array of ks_tuples. */\nstatic krb5_boolean\nks_tuple_present(int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                 krb5_key_salt_tuple *looking_for)\n{\n    int i;\n\n    for (i = 0; i < n_ks_tuple; i++) {\n        if (ks_tuple[i].ks_enctype == looking_for->ks_enctype &&\n            ks_tuple[i].ks_salttype == looking_for->ks_salttype)\n            return TRUE;\n    }\n    return FALSE;\n}\n\n/* Fetch a policy if it exists; set *have_pol_out appropriately.  Return\n * success whether or not the policy exists. */\nstatic kadm5_ret_t\nget_policy(kadm5_server_handle_t handle, const char *name,\n           kadm5_policy_ent_t policy_out, krb5_boolean *have_pol_out)\n{\n    kadm5_ret_t ret;\n\n    *have_pol_out = FALSE;\n    if (name == NULL)\n        return 0;\n    ret = kadm5_get_policy(handle->lhandle, (char *)name, policy_out);\n    if (ret == 0)\n        *have_pol_out = TRUE;\n    return (ret == KADM5_UNK_POLICY) ? 0 : ret;\n}\n\n/*\n * Apply the -allowedkeysalts policy (see kadmin(1)'s addpol/modpol\n * commands).  We use the allowed key/salt tuple list as a default if\n * no ks tuples as provided by the caller.  We reject lists that include\n * key/salts outside the policy.  We re-order the requested ks tuples\n * (which may be a subset of the policy) to reflect the policy order.\n */\nstatic kadm5_ret_t\napply_keysalt_policy(kadm5_server_handle_t handle, const char *policy,\n                     int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                     int *new_n_kstp, krb5_key_salt_tuple **new_kstp)\n{\n    kadm5_ret_t ret;\n    kadm5_policy_ent_rec polent;\n    krb5_boolean have_polent;\n    int ak_n_ks_tuple = 0;\n    int new_n_ks_tuple = 0;\n    krb5_key_salt_tuple *ak_ks_tuple = NULL;\n    krb5_key_salt_tuple *new_ks_tuple = NULL;\n    krb5_key_salt_tuple *subset;\n    int i, m;\n\n    if (new_n_kstp != NULL) {\n        *new_n_kstp = 0;\n        *new_kstp = NULL;\n    }\n\n    memset(&polent, 0, sizeof(polent));\n    ret = get_policy(handle, policy, &polent, &have_polent);\n    if (ret)\n        goto cleanup;\n\n    if (polent.allowed_keysalts == NULL) {\n        /* Requested keysalts allowed or default to supported_enctypes. */\n        if (n_ks_tuple == 0) {\n            /* Default to supported_enctypes. */\n            n_ks_tuple = handle->params.num_keysalts;\n            ks_tuple = handle->params.keysalts;\n        }\n        /* Dup the requested or defaulted keysalt tuples. */\n        new_ks_tuple = malloc(n_ks_tuple * sizeof(*new_ks_tuple));\n        if (new_ks_tuple == NULL) {\n            ret = ENOMEM;\n            goto cleanup;\n        }\n        memcpy(new_ks_tuple, ks_tuple, n_ks_tuple * sizeof(*new_ks_tuple));\n        new_n_ks_tuple = n_ks_tuple;\n        ret = 0;\n        goto cleanup;\n    }\n\n    ret = krb5_string_to_keysalts(polent.allowed_keysalts,\n                                  \",\",   /* Tuple separators */\n                                  NULL,  /* Key/salt separators */\n                                  0,     /* No duplicates */\n                                  &ak_ks_tuple,\n                                  &ak_n_ks_tuple);\n    /*\n     * Malformed policy?  Shouldn't happen, but it's remotely possible\n     * someday, so we don't assert, just bail.\n     */\n    if (ret)\n        goto cleanup;\n\n    /* Check that the requested ks_tuples are within policy, if we have one. */\n    for (i = 0; i < n_ks_tuple; i++) {\n        if (!ks_tuple_present(ak_n_ks_tuple, ak_ks_tuple, &ks_tuple[i])) {\n            ret = KADM5_BAD_KEYSALTS;\n            goto cleanup;\n        }\n    }\n\n    /* Have policy but no ks_tuple input?  Output the policy. */\n    if (n_ks_tuple == 0) {\n        new_n_ks_tuple = ak_n_ks_tuple;\n        new_ks_tuple = ak_ks_tuple;\n        ak_ks_tuple = NULL;\n        goto cleanup;\n    }\n\n    /*\n     * Now filter the policy ks tuples by the requested ones so as to\n     * preserve in the requested sub-set the relative ordering from the\n     * policy.  We could optimize this (if (n_ks_tuple == ak_n_ks_tuple)\n     * then skip this), but we don't bother.\n     */\n    subset = calloc(n_ks_tuple, sizeof(*subset));\n    if (subset == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n    for (m = 0, i = 0; i < ak_n_ks_tuple && m < n_ks_tuple; i++) {\n        if (ks_tuple_present(n_ks_tuple, ks_tuple, &ak_ks_tuple[i]))\n            subset[m++] = ak_ks_tuple[i];\n    }\n    new_ks_tuple = subset;\n    new_n_ks_tuple = m;\n    ret = 0;\n\ncleanup:\n    if (have_polent)\n        kadm5_free_policy_ent(handle->lhandle, &polent);\n    free(ak_ks_tuple);\n\n    if (new_n_kstp != NULL) {\n        *new_n_kstp = new_n_ks_tuple;\n        *new_kstp = new_ks_tuple;\n    } else {\n        free(new_ks_tuple);\n    }\n    return ret;\n}\n\n\n/*\n * Set *passptr to NULL if the request looks like the first part of a krb5 1.6\n * addprinc -randkey operation.  The krb5 1.6 dummy password for these requests\n * was invalid UTF-8, which runs afoul of the arcfour string-to-key.\n */\nstatic void\ncheck_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    /* Old-style randkey operations disallowed tickets to start. */\n    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}\n\n/* Return the number of keys with the newest kvno.  Assumes that all key data\n * with the newest kvno are at the front of the key data array. */\nstatic int\ncount_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}\n\nkadm5_ret_t\nkadm5_create_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask,\n                       char *password)\n{\n    return\n        kadm5_create_principal_3(server_handle, entry, mask,\n                                 0, NULL, password);\n}\nkadm5_ret_t\nkadm5_create_principal_3(void *server_handle,\n                         kadm5_principal_ent_t entry, long mask,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_policy_ent_rec        polent;\n    krb5_boolean                have_polent = FALSE;\n    krb5_timestamp              now;\n    krb5_tl_data                *tl_data_tail;\n    unsigned int                ret;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        for (tl_data_tail = entry->tl_data; tl_data_tail != NULL;\n             tl_data_tail = tl_data_tail->tl_data_next) {\n            if (tl_data_tail->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n        }\n    }\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:\n        kdb_free_entry(handle, kdb, &adb);\n        return KADM5_DUP;\n    default:\n        return ret;\n    }\n\n    kdb = calloc(1, sizeof(*kdb));\n    if (kdb == NULL)\n        return ENOMEM;\n    memset(&adb, 0, sizeof(osa_princ_ent_rec));\n\n    /*\n     * If a policy was specified, load it.\n     * If we can not find the one specified return an error\n     */\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &polent, &have_polent);\n        if (ret)\n            goto cleanup;\n    }\n    if (password) {\n        ret = passwd_check(handle, password, have_polent ? &polent : NULL,\n                           entry->principal);\n        if (ret)\n            goto cleanup;\n    }\n    /*\n     * Start populating the various DB fields, using the\n     * \"defaults\" for fields that were not specified by the\n     * mask.\n     */\n    if ((ret = krb5_timeofday(handle->context, &now)))\n        goto cleanup;\n\n    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    else\n        kdb->attributes = handle->params.flags;\n\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    else\n        kdb->max_life = handle->params.max_life;\n\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n    else\n        kdb->max_renewable_life = handle->params.max_rlife;\n\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    else\n        kdb->expiration = handle->params.expiration;\n\n    kdb->pw_expiration = 0;\n    if (have_polent) {\n        if(polent.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    }\n    if ((mask & KADM5_PW_EXPIRATION))\n        kdb->pw_expiration = entry->pw_expiration;\n\n    kdb->last_success = 0;\n    kdb->last_failed = 0;\n    kdb->fail_auth_count = 0;\n\n    /* this is kind of gross, but in order to free the tl data, I need\n       to free the entire kdb entry, and that will try to free the\n       principal. */\n\n    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);\n    if (ret)\n        goto cleanup;\n\n    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n        goto cleanup;\n\n    if (mask & KADM5_TL_DATA) {\n        /* splice entry->tl_data onto the front of kdb->tl_data */\n        for (tl_data_tail = entry->tl_data; tl_data_tail;\n             tl_data_tail = tl_data_tail->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n            if( ret )\n                goto cleanup;\n        }\n    }\n\n    /*\n     * We need to have setup the TL data, so we have strings, so we can\n     * check enctype policy, which is why we check/initialize ks_tuple\n     * this late.\n     */\n    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto cleanup;\n\n    /* initialize the keys */\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto cleanup;\n\n    if (mask & KADM5_KEY_DATA) {\n        /* The client requested no keys for this principal. */\n        assert(entry->n_key_data == 0);\n    } else if (password) {\n        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,\n                           new_n_ks_tuple, password,\n                           (mask & KADM5_KVNO)?entry->kvno:1,\n                           FALSE, kdb);\n    } else {\n        /* Null password means create with random key (new in 1.8). */\n        ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);\n    }\n    if (ret)\n        goto cleanup;\n\n    /* Record the master key VNO used to encrypt this entry's keys */\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto cleanup;\n\n    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto cleanup;\n\n    /* populate the admin-server-specific fields.  In the OV server,\n       this used to be in a separate database.  Since there's already\n       marshalling code for the admin fields, to keep things simple,\n       I'm going to keep it, and make all the admin stuff occupy a\n       single tl_data record, */\n\n    adb.admin_history_kvno = INITIAL_HIST_KVNO;\n    if (mask & KADM5_POLICY) {\n        adb.aux_attributes = KADM5_POLICY;\n\n        /* this does *not* need to be strdup'ed, because adb is xdr */\n        /* encoded in osa_adb_create_princ, and not ever freed */\n\n        adb.policy = entry->policy;\n    }\n\n    /* In all cases key and the principal data is set, let the database provider know */\n    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n\n    /* store the new db entry */\n    ret = kdb_put_entry(handle, kdb, &adb);\n\n    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,\n                                new_n_ks_tuple, new_ks_tuple, password);\n\ncleanup:\n    free(new_ks_tuple);\n    krb5_db_free_principal(handle->context, kdb);\n    if (have_polent)\n        (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n    return ret;\n}\n\n\nkadm5_ret_t\nkadm5_delete_principal(void *server_handle, krb5_principal principal)\n{\n    unsigned int                ret;\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n    ret = k5_kadm5_hook_remove(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal);\n    if (ret) {\n        kdb_free_entry(handle, kdb, &adb);\n        return ret;\n    }\n\n    ret = kdb_delete_entry(handle, principal);\n\n    kdb_free_entry(handle, kdb, &adb);\n\n    if (ret == 0)\n        (void) k5_kadm5_hook_remove(handle->context,\n                                    handle->hook_handles,\n                                    KADM5_HOOK_STAGE_POSTCOMMIT, principal);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_modify_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask)\n{\n    int                     ret, ret2, i;\n    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if(entry == NULL)\n        return EINVAL;\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    /*\n     * This is pretty much the same as create ...\n     */\n\n    if ((mask & KADM5_POLICY)) {\n        ret = get_policy(handle, entry->policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n\n        /* set us up to use the new policy */\n        adb.aux_attributes |= KADM5_POLICY;\n        if (adb.policy)\n            free(adb.policy);\n        adb.policy = strdup(entry->policy);\n    }\n    if (have_pol) {\n        /* set pw_max_life based on new policy */\n        if (pol.pw_max_life) {\n            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                  &(kdb->pw_expiration));\n            if (ret)\n                goto done;\n            kdb->pw_expiration = ts_incr(kdb->pw_expiration, pol.pw_max_life);\n        } else {\n            kdb->pw_expiration = 0;\n        }\n    }\n\n    if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {\n        free(adb.policy);\n        adb.policy = NULL;\n        adb.aux_attributes &= ~KADM5_POLICY;\n        kdb->pw_expiration = 0;\n    }\n\n    if ((mask & KADM5_ATTRIBUTES))\n        kdb->attributes = entry->attributes;\n    if ((mask & KADM5_MAX_LIFE))\n        kdb->max_life = entry->max_life;\n    if ((mask & KADM5_PRINC_EXPIRE_TIME))\n        kdb->expiration = entry->princ_expire_time;\n    if (mask & KADM5_PW_EXPIRATION)\n        kdb->pw_expiration = entry->pw_expiration;\n    if (mask & KADM5_MAX_RLIFE)\n        kdb->max_renewable_life = entry->max_renewable_life;\n\n    if((mask & KADM5_KVNO)) {\n        for (i = 0; i < kdb->n_key_data; i++)\n            kdb->key_data[i].key_data_kvno = entry->kvno;\n    }\n\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl;\n\n        /* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */\n\n        for (tl = entry->tl_data; tl;\n             tl = tl->tl_data_next)\n        {\n            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n            if( ret )\n            {\n                goto done;\n            }\n        }\n    }\n\n    /*\n     * Setting entry->fail_auth_count to 0 can be used to manually unlock\n     * an account. It is not possible to set fail_auth_count to any other\n     * value using kadmin.\n     */\n    if (mask & KADM5_FAIL_AUTH_COUNT) {\n        if (entry->fail_auth_count != 0) {\n            ret = KADM5_BAD_SERVER_PARAMS;\n            goto done;\n        }\n\n        kdb->fail_auth_count = 0;\n    }\n\n    /* let the mask propagate to the database provider */\n    kdb->mask = mask;\n\n    ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);\n    if (ret)\n        goto done;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret) goto done;\n    (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);\n\n    ret = KADM5_OK;\ndone:\n    if (have_pol) {\n        ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);\n        ret = ret ? ret : ret2;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_rename_principal(void *server_handle,\n                       krb5_principal source, krb5_principal target)\n{\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_error_code ret;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (source == NULL || target == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, target, &kdb, &adb)) == 0) {\n        kdb_free_entry(handle, kdb, &adb);\n        return(KADM5_DUP);\n    }\n\n    ret = k5_kadm5_hook_rename(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, source, target);\n    if (ret)\n        return ret;\n\n    ret = krb5_db_rename_principal(handle->context, source, target);\n    if (ret)\n        return ret;\n\n    /* Update the principal mod data. */\n    ret = kdb_get_entry(handle, target, &kdb, &adb);\n    if (ret)\n        return ret;\n    kdb->mask = 0;\n    ret = kdb_put_entry(handle, kdb, &adb);\n    kdb_free_entry(handle, kdb, &adb);\n    if (ret)\n        return ret;\n\n    (void) k5_kadm5_hook_rename(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, source, target);\n    return 0;\n}\n\nkadm5_ret_t\nkadm5_get_principal(void *server_handle, krb5_principal principal,\n                    kadm5_principal_ent_t entry,\n                    long in_mask)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_error_code             ret = 0;\n    long                        mask;\n    int i;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    /*\n     * In version 1, all the defined fields are always returned.\n     * entry is a pointer to a kadm5_principal_ent_t_v1 that should be\n     * filled with allocated memory.\n     */\n    mask = in_mask;\n\n    memset(entry, 0, sizeof(*entry));\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return ret;\n\n    if ((mask & KADM5_POLICY) &&\n        adb.policy && (adb.aux_attributes & KADM5_POLICY)) {\n        if ((entry->policy = strdup(adb.policy)) == NULL) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n\n    if (mask & KADM5_AUX_ATTRIBUTES)\n        entry->aux_attributes = adb.aux_attributes;\n\n    if ((mask & KADM5_PRINCIPAL) &&\n        (ret = krb5_copy_principal(handle->context, kdb->princ,\n                                   &entry->principal))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PRINC_EXPIRE_TIME)\n        entry->princ_expire_time = kdb->expiration;\n\n    if ((mask & KADM5_LAST_PWD_CHANGE) &&\n        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                               &(entry->last_pwd_change)))) {\n        goto done;\n    }\n\n    if (mask & KADM5_PW_EXPIRATION)\n        entry->pw_expiration = kdb->pw_expiration;\n    if (mask & KADM5_MAX_LIFE)\n        entry->max_life = kdb->max_life;\n\n    /* this is a little non-sensical because the function returns two */\n    /* values that must be checked separately against the mask */\n    if ((mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME)) {\n        ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,\n                                             &(entry->mod_date),\n                                             &(entry->mod_name));\n        if (ret) {\n            goto done;\n        }\n\n        if (! (mask & KADM5_MOD_TIME))\n            entry->mod_date = 0;\n        if (! (mask & KADM5_MOD_NAME)) {\n            krb5_free_principal(handle->context, entry->mod_name);\n            entry->mod_name = NULL;\n        }\n    }\n\n    if (mask & KADM5_ATTRIBUTES)\n        entry->attributes = kdb->attributes;\n\n    if (mask & KADM5_KVNO)\n        for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)\n            if ((krb5_kvno) kdb->key_data[i].key_data_kvno > entry->kvno)\n                entry->kvno = kdb->key_data[i].key_data_kvno;\n\n    if (mask & KADM5_MKVNO) {\n        ret = krb5_dbe_get_mkvno(handle->context, kdb, &entry->mkvno);\n        if (ret)\n            goto done;\n    }\n\n    if (mask & KADM5_MAX_RLIFE)\n        entry->max_renewable_life = kdb->max_renewable_life;\n    if (mask & KADM5_LAST_SUCCESS)\n        entry->last_success = kdb->last_success;\n    if (mask & KADM5_LAST_FAILED)\n        entry->last_failed = kdb->last_failed;\n    if (mask & KADM5_FAIL_AUTH_COUNT)\n        entry->fail_auth_count = kdb->fail_auth_count;\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl, *tl2;\n\n        entry->tl_data = NULL;\n\n        tl = kdb->tl_data;\n        while (tl) {\n            if (tl->tl_data_type > 255) {\n                if ((tl2 = dup_tl_data(tl)) == NULL) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                tl2->tl_data_next = entry->tl_data;\n                entry->tl_data = tl2;\n                entry->n_tl_data++;\n            }\n\n            tl = tl->tl_data_next;\n        }\n    }\n    if (mask & KADM5_KEY_DATA) {\n        entry->n_key_data = kdb->n_key_data;\n        if(entry->n_key_data) {\n            entry->key_data = k5calloc(entry->n_key_data,\n                                       sizeof(krb5_key_data), &ret);\n            if (entry->key_data == NULL)\n                goto done;\n        } else\n            entry->key_data = NULL;\n\n        for (i = 0; i < entry->n_key_data; i++)\n            ret = krb5_copy_key_data_contents(handle->context,\n                                              &kdb->key_data[i],\n                                              &entry->key_data[i]);\n        if (ret)\n            goto done;\n    }\n\n    ret = KADM5_OK;\n\ndone:\n    if (ret && entry->principal) {\n        krb5_free_principal(handle->context, entry->principal);\n        entry->principal = NULL;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n\n    return ret;\n}\n\n/*\n * Function: check_pw_reuse\n *\n * Purpose: Check if a key appears in a list of keys, in order to\n * enforce password history.\n *\n * Arguments:\n *\n *      context                 (r) the krb5 context\n *      hist_keyblock           (r) the key that hist_key_data is\n *                              encrypted in\n *      n_new_key_data          (r) length of new_key_data\n *      new_key_data            (r) keys to check against\n *                              pw_hist_data, encrypted in hist_keyblock\n *      n_pw_hist_data          (r) length of pw_hist_data\n *      pw_hist_data            (r) passwords to check new_key_data against\n *\n * Effects:\n * For each new_key in new_key_data:\n *      decrypt new_key with the master_keyblock\n *      for each password in pw_hist_data:\n *              for each hist_key in password:\n *                      decrypt hist_key with hist_keyblock\n *                      compare the new_key and hist_key\n *\n * Returns krb5 errors, KADM5_PASS_RESUSE if a key in\n * new_key_data is the same as a key in pw_hist_data, or 0.\n */\nstatic kadm5_ret_t\ncheck_pw_reuse(krb5_context context,\n               krb5_keyblock *hist_keyblocks,\n               int n_new_key_data, krb5_key_data *new_key_data,\n               unsigned int n_pw_hist_data, osa_pw_hist_ent *pw_hist_data)\n{\n    unsigned int x, y, z;\n    krb5_keyblock newkey, histkey, *kb;\n    krb5_key_data *key_data;\n    krb5_error_code ret;\n\n    assert (n_new_key_data >= 0);\n    for (x = 0; x < (unsigned) n_new_key_data; x++) {\n        /* Check only entries with the most recent kvno. */\n        if (new_key_data[x].key_data_kvno != new_key_data[0].key_data_kvno)\n            break;\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &(new_key_data[x]),\n                                        &newkey, NULL);\n        if (ret)\n            return(ret);\n        for (y = 0; y < n_pw_hist_data; y++) {\n            for (z = 0; z < (unsigned int) pw_hist_data[y].n_key_data; z++) {\n                for (kb = hist_keyblocks; kb->enctype != 0; kb++) {\n                    key_data = &pw_hist_data[y].key_data[z];\n                    ret = krb5_dbe_decrypt_key_data(context, kb, key_data,\n                                                    &histkey, NULL);\n                    if (ret)\n                        continue;\n                    if (newkey.length == histkey.length &&\n                        newkey.enctype == histkey.enctype &&\n                        memcmp(newkey.contents, histkey.contents,\n                               histkey.length) == 0) {\n                        krb5_free_keyblock_contents(context, &histkey);\n                        krb5_free_keyblock_contents(context, &newkey);\n                        return KADM5_PASS_REUSE;\n                    }\n                    krb5_free_keyblock_contents(context, &histkey);\n                }\n            }\n        }\n        krb5_free_keyblock_contents(context, &newkey);\n    }\n\n    return(0);\n}\n\nstatic void\nfree_history_entry(krb5_context context, osa_pw_hist_ent *hist)\n{\n    int i;\n\n    for (i = 0; i < hist->n_key_data; i++)\n        krb5_free_key_data_contents(context, &hist->key_data[i]);\n    free(hist->key_data);\n}\n\n/*\n * Function: create_history_entry\n *\n * Purpose: Creates a password history entry from an array of\n * key_data.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      mkey            (r) master keyblock to decrypt key data with\n *      hist_key        (r) history keyblock to encrypt key data with\n *      n_key_data      (r) number of elements in key_data\n *      key_data        (r) keys to add to the history entry\n *      hist_out        (w) history entry to fill in\n *\n * Effects:\n *\n * hist->key_data is allocated to store n_key_data key_datas.  Each\n * element of key_data is decrypted with master_keyblock, re-encrypted\n * in hist_key, and added to hist->key_data.  hist->n_key_data is\n * set to n_key_data.\n */\nstatic\nint create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist_out)\n{\n    int i;\n    krb5_error_code ret = 0;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    krb5_ui_2 kvno;\n    osa_pw_hist_ent hist;\n\n    hist_out->key_data = NULL;\n    hist_out->n_key_data = 0;\n\n    if (n_key_data < 0)\n        return EINVAL;\n\n    memset(&key, 0, sizeof(key));\n    memset(&hist, 0, sizeof(hist));\n\n    if (n_key_data == 0)\n        goto cleanup;\n\n    hist.key_data = k5calloc(n_key_data, sizeof(krb5_key_data), &ret);\n    if (hist.key_data == NULL)\n        goto cleanup;\n\n    /* We only want to store the most recent kvno, and key_data should already\n     * be sorted in descending order by kvno. */\n    kvno = key_data[0].key_data_kvno;\n\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_kvno < kvno)\n            break;\n        ret = krb5_dbe_decrypt_key_data(context, NULL,\n                                        &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            goto cleanup;\n\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist.key_data[hist.n_key_data]);\n        if (ret)\n            goto cleanup;\n        hist.n_key_data++;\n        krb5_free_keyblock_contents(context, &key);\n        /* krb5_free_keysalt(context, &salt); */\n    }\n\n    *hist_out = hist;\n    hist.n_key_data = 0;\n    hist.key_data = NULL;\n\ncleanup:\n    krb5_free_keyblock_contents(context, &key);\n    free_history_entry(context, &hist);\n    return ret;\n}\n\n/*\n * Function: add_to_history\n *\n * Purpose: Adds a password to a principal's password history.\n *\n * Arguments:\n *\n *      context         (r) krb5_context to use\n *      hist_kvno       (r) kvno of current history key\n *      adb             (r/w) admin principal entry to add keys to\n *      pol             (r) adb's policy\n *      pw              (r) keys for the password to add to adb's key history\n *\n * Effects:\n *\n * add_to_history adds a single password to adb's password history.\n * pw contains n_key_data keys in its key_data, in storage should be\n * allocated but not freed by the caller (XXX blech!).\n *\n * This function maintains adb->old_keys as a circular queue.  It\n * starts empty, and grows each time this function is called until it\n * is pol->pw_history_num items long.  adb->old_key_len holds the\n * number of allocated entries in the array, and must therefore be [0,\n * pol->pw_history_num).  adb->old_key_next is the index into the\n * array where the next element should be written, and must be [0,\n * adb->old_key_len).\n */\nstatic kadm5_ret_t add_to_history(krb5_context context,\n                                  krb5_kvno hist_kvno,\n                                  osa_princ_ent_t adb,\n                                  kadm5_policy_ent_t pol,\n                                  osa_pw_hist_ent *pw)\n{\n    osa_pw_hist_ent *histp;\n    uint32_t nhist;\n    unsigned int i, knext, nkeys;\n\n    nhist = pol->pw_history_num;\n    /* A history of 1 means just check the current password */\n    if (nhist <= 1)\n        return 0;\n\n    if (adb->admin_history_kvno != hist_kvno) {\n        /* The history key has changed since the last password change, so we\n         * have to reset the password history. */\n        free(adb->old_keys);\n        adb->old_keys = NULL;\n        adb->old_key_len = 0;\n        adb->old_key_next = 0;\n        adb->admin_history_kvno = hist_kvno;\n    }\n\n    nkeys = adb->old_key_len;\n    knext = adb->old_key_next;\n    /* resize the adb->old_keys array if necessary */\n    if (nkeys + 1 < nhist) {\n        if (adb->old_keys == NULL) {\n            adb->old_keys = (osa_pw_hist_ent *)\n                malloc((nkeys + 1) * sizeof (osa_pw_hist_ent));\n        } else {\n            adb->old_keys = (osa_pw_hist_ent *)\n                realloc(adb->old_keys,\n                        (nkeys + 1) * sizeof (osa_pw_hist_ent));\n        }\n        if (adb->old_keys == NULL)\n            return(ENOMEM);\n\n        memset(&adb->old_keys[nkeys], 0, sizeof(osa_pw_hist_ent));\n        nkeys = ++adb->old_key_len;\n        /*\n         * To avoid losing old keys, shift forward each entry after\n         * knext.\n         */\n        for (i = nkeys - 1; i > knext; i--) {\n            adb->old_keys[i] = adb->old_keys[i - 1];\n        }\n        memset(&adb->old_keys[knext], 0, sizeof(osa_pw_hist_ent));\n    } else if (nkeys + 1 > nhist) {\n        /*\n         * The policy must have changed!  Shrink the array.\n         * Can't simply realloc() down, since it might be wrapped.\n         * To understand the arithmetic below, note that we are\n         * copying into new positions 0 .. N-1 from old positions\n         * old_key_next-N .. old_key_next-1, modulo old_key_len,\n         * where N = pw_history_num - 1 is the length of the\n         * shortened list.        Matt Crawford, FNAL\n         */\n        /*\n         * M = adb->old_key_len, N = pol->pw_history_num - 1\n         *\n         * tmp[0] .. tmp[N-1] = old[(knext-N)%M] .. old[(knext-1)%M]\n         */\n        int j;\n        osa_pw_hist_t tmp;\n\n        tmp = (osa_pw_hist_ent *)\n            malloc((nhist - 1) * sizeof (osa_pw_hist_ent));\n        if (tmp == NULL)\n            return ENOMEM;\n        for (i = 0; i < nhist - 1; i++) {\n            /*\n             * Add nkeys once before taking remainder to avoid\n             * negative values.\n             */\n            j = (i + nkeys + knext - (nhist - 1)) % nkeys;\n            tmp[i] = adb->old_keys[j];\n        }\n        /* Now free the ones we don't keep (the oldest ones) */\n        for (i = 0; i < nkeys - (nhist - 1); i++) {\n            j = (i + nkeys + knext) % nkeys;\n            histp = &adb->old_keys[j];\n            for (j = 0; j < histp->n_key_data; j++) {\n                krb5_free_key_data_contents(context, &histp->key_data[j]);\n            }\n            free(histp->key_data);\n        }\n        free(adb->old_keys);\n        adb->old_keys = tmp;\n        nkeys = adb->old_key_len = nhist - 1;\n        knext = adb->old_key_next = 0;\n    }\n\n    /*\n     * If nhist decreased since the last password change, and nkeys+1\n     * is less than the previous nhist, it is possible for knext to\n     * index into unallocated space.  This condition would not be\n     * caught by the resizing code above.\n     */\n    if (knext + 1 > nkeys)\n        knext = adb->old_key_next = 0;\n    /* free the old pw history entry if it contains data */\n    histp = &adb->old_keys[knext];\n    for (i = 0; i < (unsigned int) histp->n_key_data; i++)\n        krb5_free_key_data_contents(context, &histp->key_data[i]);\n    free(histp->key_data);\n\n    /* store the new entry */\n    adb->old_keys[knext] = *pw;\n\n    /* update the next pointer */\n    if (++adb->old_key_next == nhist - 1)\n        adb->old_key_next = 0;\n\n    return(0);\n}\n\n/* FIXME: don't use global variable for this */\nkrb5_boolean use_password_server = 0;\n\n#ifdef USE_PASSWORD_SERVER\nstatic krb5_boolean\nkadm5_use_password_server (void)\n{\n    return use_password_server;\n}\n#endif\n\nvoid kadm5_set_use_password_server (void);\n\nvoid\nkadm5_set_use_password_server (void)\n{\n    use_password_server = 1;\n}\n\n#ifdef USE_PASSWORD_SERVER\n\n/*\n * kadm5_launch_task () runs a program (task_path) to synchronize the\n * Apple password server with the Kerberos database.  Password server\n * programs can receive arguments on the command line (task_argv)\n * and a block of data via stdin (data_buffer).\n *\n * Because a failure to communicate with the tool results in the\n * password server falling out of sync with the database,\n * kadm5_launch_task() always fails if it can't talk to the tool.\n */\n\nstatic kadm5_ret_t\nkadm5_launch_task (krb5_context context,\n                   const char *task_path, char * const task_argv[],\n                   const char *buffer)\n{\n    kadm5_ret_t ret;\n    int data_pipe[2];\n\n    ret = pipe (data_pipe);\n    if (ret)\n        ret = errno;\n\n    if (!ret) {\n        pid_t pid = fork ();\n        if (pid == -1) {\n            ret = errno;\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n        } else if (pid == 0) {\n            /* The child: */\n\n            if (dup2 (data_pipe[0], STDIN_FILENO) == -1)\n                _exit (1);\n\n            close (data_pipe[0]);\n            close (data_pipe[1]);\n\n            execv (task_path, task_argv);\n\n            _exit (1); /* Fail if execv fails */\n        } else {\n            /* The parent: */\n            int status;\n\n            ret = 0;\n\n            close (data_pipe[0]);\n\n            /* Write out the buffer to the child, add \\n */\n            if (buffer) {\n                if (krb5_net_write (context, data_pipe[1], buffer, strlen (buffer)) < 0\n                    || krb5_net_write (context, data_pipe[1], \"\\n\", 1) < 0)\n                {\n                    /* kill the child to make sure waitpid() won't hang later */\n                    ret = errno;\n                    kill (pid, SIGKILL);\n                }\n            }\n            close (data_pipe[1]);\n\n            waitpid (pid, &status, 0);\n\n            if (!ret) {\n                if (WIFEXITED (status)) {\n                    /* child read password and exited.  Check the return value. */\n                    if ((WEXITSTATUS (status) != 0) && (WEXITSTATUS (status) != 252)) {\n                        ret = KRB5KDC_ERR_POLICY; /* password change rejected */\n                    }\n                } else {\n                    /* child read password but crashed or was killed */\n                    ret = KRB5KRB_ERR_GENERIC; /* FIXME: better error */\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\n#endif\n\nkadm5_ret_t\nkadm5_chpass_principal(void *server_handle,\n                       krb5_principal principal, char *password)\n{\n    return\n        kadm5_chpass_principal_3(server_handle, principal, FALSE,\n                                 0, NULL, password);\n}\n\nkadm5_ret_t\nkadm5_chpass_principal_3(void *server_handle,\n                         krb5_principal principal, krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         char *password)\n{\n    krb5_timestamp              now;\n    kadm5_policy_ent_rec        pol;\n    osa_princ_ent_rec           adb;\n    krb5_db_entry               *kdb;\n    int                         ret, ret2, hist_added;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    osa_pw_hist_ent             hist;\n    krb5_keyblock               *act_mkey, *hist_keyblocks = NULL;\n    krb5_kvno                   act_kvno, hist_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    hist_added = 0;\n    memset(&hist, 0, sizeof(hist));\n\n    if (principal == NULL || password == NULL)\n        return EINVAL;\n    if ((krb5_principal_compare(handle->context,\n                                principal, hist_princ)) == TRUE)\n        return KADM5_PROTECT_PRINCIPAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        /* Create a password history entry before we change kdb's key_data. */\n        ret = kdb_get_hist_key(handle, &hist_keyblocks, &hist_kvno);\n        if (ret)\n            goto done;\n        ret = create_history_entry(handle->context, &hist_keyblocks[0],\n                                   kdb->n_key_data, kdb->key_data, &hist);\n        if (ret)\n            goto done;\n    }\n\n    if ((ret = passwd_check(handle, password, have_pol ? &pol : NULL,\n                            principal)))\n        goto done;\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       password, 0 /* increment kvno */,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        /* the policy was loaded before */\n\n        ret = check_pw_reuse(handle->context, hist_keyblocks,\n                             kdb->n_key_data, kdb->key_data,\n                             1, &hist);\n        if (ret)\n            goto done;\n\n        if (pol.pw_history_num > 1) {\n            /* If hist_kvno has changed since the last password change, we\n             * can't check the history. */\n            if (adb.admin_history_kvno == hist_kvno) {\n                ret = check_pw_reuse(handle->context, hist_keyblocks,\n                                     kdb->n_key_data, kdb->key_data,\n                                     adb.old_key_len, adb.old_keys);\n                if (ret)\n                    goto done;\n            }\n\n            /* Don't save empty history. */\n            if (hist.n_key_data > 0) {\n                ret = add_to_history(handle->context, hist_kvno, &adb, &pol,\n                                     &hist);\n                if (ret)\n                    goto done;\n                hist_added = 1;\n            }\n        }\n\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n#ifdef USE_PASSWORD_SERVER\n    if (kadm5_use_password_server () &&\n        (krb5_princ_size (handle->context, principal) == 1)) {\n        krb5_data *princ = krb5_princ_component (handle->context, principal, 0);\n        const char *path = \"/usr/sbin/mkpassdb\";\n        char *argv[] = { \"mkpassdb\", \"-setpassword\", NULL, NULL };\n        char *pstring = NULL;\n\n        if (!ret) {\n            pstring = malloc ((princ->length + 1) * sizeof (char));\n            if (pstring == NULL) { ret = ENOMEM; }\n        }\n\n        if (!ret) {\n            memcpy (pstring, princ->data, princ->length);\n            pstring [princ->length] = '\\0';\n            argv[2] = pstring;\n\n            ret = kadm5_launch_task (handle->context, path, argv, password);\n        }\n\n        if (pstring != NULL)\n            free (pstring);\n\n        if (ret)\n            goto done;\n    }\n#endif\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    /* key data and attributes changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |\n        KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_CPW_FUNCTION */\n\n    if (hist_added)\n        kdb->mask |= KADM5_KEY_HIST;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, password);\n    if (ret)\n        goto done;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, password);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    if (!hist_added && hist.key_data)\n        free_history_entry(handle->context, &hist);\n    kdb_free_entry(handle, kdb, &adb);\n    kdb_free_keyblocks(handle, hist_keyblocks);\n\n    if (have_pol && (ret2 = kadm5_free_policy_ent(handle->lhandle, &pol))\n        && !ret)\n        ret = ret2;\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_randkey_principal(void *server_handle,\n                        krb5_principal principal,\n                        krb5_keyblock **keyblocks,\n                        int *n_keys)\n{\n    return\n        kadm5_randkey_principal_3(server_handle, principal,\n                                  FALSE, 0, NULL,\n                                  keyblocks, n_keys);\n}\nkadm5_ret_t\nkadm5_randkey_principal_3(void *server_handle,\n                          krb5_principal principal,\n                          krb5_boolean keepold,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          krb5_keyblock **keyblocks,\n                          int *n_keys)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_timestamp              now;\n    kadm5_policy_ent_rec        pol;\n    int                         ret, n_new_keys;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_keyblock               *act_mkey;\n    krb5_kvno                   act_kvno;\n    int                         new_n_ks_tuple = 0;\n    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    if (keyblocks)\n        *keyblocks = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,\n                               &new_n_ks_tuple, &new_ks_tuple);\n    if (ret)\n        goto done;\n\n    if (krb5_principal_compare(handle->context, principal, hist_princ)) {\n        /* If changing the history entry, the new entry must have exactly one\n         * key. */\n        if (keepold)\n            return KADM5_PROTECT_PRINCIPAL;\n        new_n_ks_tuple = 1;\n    }\n\n    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,\n                       keepold, kdb);\n    if (ret)\n        goto done;\n\n    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n    if (ret)\n        goto done;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    if (keyblocks) {\n        /* Return only the new keys added by krb5_dbe_crk. */\n        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);\n        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,\n                               keyblocks, n_keys);\n        if (ret)\n            goto done;\n    }\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n    /* | KADM5_RANDKEY_USED */;\n\n    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,\n                               new_n_ks_tuple, new_ks_tuple, NULL);\n    if (ret)\n        goto done;\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,\n                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,\n                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);\n    ret = KADM5_OK;\ndone:\n    free(new_ks_tuple);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\n/*\n * kadm5_setv4key_principal:\n *\n * Set only ONE key of the principal, removing all others.  This key\n * must have the DES_CBC_CRC enctype and is entered as having the\n * krb4 salttype.  This is to enable things like kadmind4 to work.\n */\nkadm5_ret_t\nkadm5_setv4key_principal(void *server_handle,\n                         krb5_principal principal,\n                         krb5_keyblock *keyblock)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_timestamp              now;\n    kadm5_policy_ent_rec        pol;\n    krb5_keysalt                keysalt;\n    int                         i, kvno, ret;\n    krb5_boolean                have_pol = FALSE;\n    kadm5_server_handle_t       handle = server_handle;\n    krb5_key_data               tmp_key_data;\n    krb5_keyblock               *act_mkey;\n\n    memset( &tmp_key_data, 0, sizeof(tmp_key_data));\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || keyblock == NULL)\n        return EINVAL;\n    if (hist_princ && /* this will be NULL when initializing the databse */\n        ((krb5_principal_compare(handle->context,\n                                 principal, hist_princ)) == TRUE))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    if (keyblock->enctype != ENCTYPE_DES_CBC_CRC)\n        return KADM5_SETV4KEY_INVAL_ENCTYPE;\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n        if (kdb->key_data[i].key_data_kvno > kvno)\n            kvno = kdb->key_data[i].key_data_kvno;\n\n    if (kdb->key_data != NULL)\n        cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n\n    kdb->key_data = calloc(1, sizeof(krb5_key_data));\n    if (kdb->key_data == NULL)\n        return ENOMEM;\n    kdb->n_key_data = 1;\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    /* XXX data.magic? */\n    keysalt.data.length = 0;\n    keysalt.data.data = NULL;\n\n    ret = kdb_get_active_mkey(handle, NULL, &act_mkey);\n    if (ret)\n        goto done;\n\n    /* use tmp_key_data as temporary location and reallocate later */\n    ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey, keyblock,\n                                    &keysalt, kvno + 1, kdb->key_data);\n    if (ret) {\n        goto done;\n    }\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if ((adb.aux_attributes & KADM5_POLICY)) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* unlock principal on this KDC */\n    kdb->fail_auth_count = 0;\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n\n    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n        goto done;\n\n    ret = KADM5_OK;\ndone:\n    for (i = 0; i < tmp_key_data.key_data_ver; i++) {\n        if (tmp_key_data.key_data_contents[i]) {\n            memset (tmp_key_data.key_data_contents[i], 0, tmp_key_data.key_data_length[i]);\n            free (tmp_key_data.key_data_contents[i]);\n        }\n    }\n\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_setkey_principal(void *server_handle,\n                       krb5_principal principal,\n                       krb5_keyblock *keyblocks,\n                       int n_keys)\n{\n    return\n        kadm5_setkey_principal_3(server_handle, principal,\n                                 FALSE, 0, NULL,\n                                 keyblocks, n_keys);\n}\n\nkadm5_ret_t\nkadm5_setkey_principal_3(void *server_handle,\n                         krb5_principal principal,\n                         krb5_boolean keepold,\n                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                         krb5_keyblock *keyblocks,\n                         int n_keys)\n{\n    kadm5_key_data *key_data;\n    kadm5_ret_t ret;\n    int i;\n\n    if (keyblocks == NULL)\n        return EINVAL;\n\n    if (n_ks_tuple) {\n        if (n_ks_tuple != n_keys)\n            return KADM5_SETKEY3_ETYPE_MISMATCH;\n        for (i = 0; i < n_ks_tuple; i++) {\n            if (ks_tuple[i].ks_enctype != keyblocks[i].enctype)\n                return KADM5_SETKEY3_ETYPE_MISMATCH;\n        }\n    }\n\n    key_data = calloc(n_keys, sizeof(kadm5_key_data));\n    if (key_data == NULL)\n        return ENOMEM;\n\n    for (i = 0; i < n_keys; i++) {\n        key_data[i].key = keyblocks[i];\n        key_data[i].salt.type =\n            n_ks_tuple ? ks_tuple[i].ks_salttype : KRB5_KDB_SALTTYPE_NORMAL;\n    }\n\n    ret = kadm5_setkey_principal_4(server_handle, principal, keepold,\n                                   key_data, n_keys);\n    free(key_data);\n    return ret;\n}\n\n/* Create a key/salt list from a key_data array. */\nstatic kadm5_ret_t\nmake_ks_from_key_data(krb5_context context, kadm5_key_data *key_data,\n                      int n_key_data, krb5_key_salt_tuple **out)\n{\n    int i;\n    krb5_key_salt_tuple *ks;\n\n    *out = NULL;\n\n    ks = calloc(n_key_data, sizeof(*ks));\n    if (ks == NULL)\n        return ENOMEM;\n\n    for (i = 0; i < n_key_data; i++) {\n        ks[i].ks_enctype = key_data[i].key.enctype;\n        ks[i].ks_salttype = key_data[i].salt.type;\n    }\n    *out = ks;\n    return 0;\n}\n\nkadm5_ret_t\nkadm5_setkey_principal_4(void *server_handle, krb5_principal principal,\n                         krb5_boolean keepold, kadm5_key_data *key_data,\n                         int n_key_data)\n{\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_timestamp now;\n    kadm5_policy_ent_rec pol;\n    krb5_key_data *new_key_data = NULL;\n    int i, j, ret, n_new_key_data = 0;\n    krb5_kvno kvno;\n    krb5_boolean similar, have_pol = FALSE;\n    kadm5_server_handle_t handle = server_handle;\n    krb5_keyblock *act_mkey;\n    krb5_key_salt_tuple *ks_from_keys = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if (principal == NULL || key_data == NULL || n_key_data == 0)\n        return EINVAL;\n\n    /* hist_princ will be NULL when initializing the database. */\n    if (hist_princ != NULL &&\n        krb5_principal_compare(handle->context, principal, hist_princ))\n        return KADM5_PROTECT_PRINCIPAL;\n\n    /* For now, all keys must have the same kvno. */\n    kvno = key_data[0].kvno;\n    for (i = 1; i < n_key_data; i++) {\n        if (key_data[i].kvno != kvno)\n            return KADM5_SETKEY_BAD_KVNO;\n    }\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return ret;\n\n    if (kvno == 0) {\n        /* Pick the next kvno. */\n        for (i = 0; i < kdb->n_key_data; i++) {\n            if (kdb->key_data[i].key_data_kvno > kvno)\n                kvno = kdb->key_data[i].key_data_kvno;\n        }\n        kvno++;\n    } else if (keepold) {\n        /* Check that the kvno does collide with existing keys. */\n        for (i = 0; i < kdb->n_key_data; i++) {\n            if (kdb->key_data[i].key_data_kvno == kvno) {\n                ret = KADM5_SETKEY_BAD_KVNO;\n                goto done;\n            }\n        }\n    }\n\n    ret = make_ks_from_key_data(handle->context, key_data, n_key_data,\n                                &ks_from_keys);\n    if (ret)\n        goto done;\n\n    ret = apply_keysalt_policy(handle, adb.policy, n_key_data, ks_from_keys,\n                               NULL, NULL);\n    free(ks_from_keys);\n    if (ret)\n        goto done;\n\n    for (i = 0; i < n_key_data; i++) {\n        for (j = i + 1; j < n_key_data; j++) {\n            ret = krb5_c_enctype_compare(handle->context,\n                                         key_data[i].key.enctype,\n                                         key_data[j].key.enctype,\n                                         &similar);\n            if (ret)\n                goto done;\n            if (similar) {\n                if (key_data[i].salt.type == key_data[j].salt.type) {\n                    ret = KADM5_SETKEY_DUP_ENCTYPES;\n                    goto done;\n                }\n            }\n        }\n    }\n\n    n_new_key_data = n_key_data + (keepold ? kdb->n_key_data : 0);\n    new_key_data = calloc(n_new_key_data, sizeof(krb5_key_data));\n    if (new_key_data == NULL) {\n        n_new_key_data = 0;\n        ret = ENOMEM;\n        goto done;\n    }\n\n    n_new_key_data = 0;\n    for (i = 0; i < n_key_data; i++) {\n\n        ret = kdb_get_active_mkey(handle, NULL, &act_mkey);\n        if (ret)\n            goto done;\n\n        ret = krb5_dbe_encrypt_key_data(handle->context, act_mkey,\n                                        &key_data[i].key, &key_data[i].salt,\n                                        kvno, &new_key_data[i]);\n        if (ret)\n            goto done;\n\n        n_new_key_data++;\n    }\n\n    /* Copy old key data if necessary. */\n    if (keepold) {\n        memcpy(new_key_data + n_new_key_data, kdb->key_data,\n               kdb->n_key_data * sizeof(krb5_key_data));\n        memset(kdb->key_data, 0, kdb->n_key_data * sizeof(krb5_key_data));\n\n        /*\n         * Sort the keys to maintain the defined kvno order.  We only need to\n         * sort if we keep old keys, as otherwise we allow only a single kvno\n         * to be specified.\n         */\n        krb5_dbe_sort_key_data(new_key_data, n_new_key_data);\n    }\n\n    /* Replace kdb->key_data with the new keys. */\n    cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n    kdb->key_data = new_key_data;\n    kdb->n_key_data = n_new_key_data;\n    new_key_data = NULL;\n    n_new_key_data = 0;\n\n    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n\n    ret = krb5_timeofday(handle->context, &now);\n    if (ret)\n        goto done;\n\n    if (adb.aux_attributes & KADM5_POLICY) {\n        ret = get_policy(handle, adb.policy, &pol, &have_pol);\n        if (ret)\n            goto done;\n    }\n    if (have_pol) {\n        if (pol.pw_max_life)\n            kdb->pw_expiration = ts_incr(now, pol.pw_max_life);\n        else\n            kdb->pw_expiration = 0;\n    } else {\n        kdb->pw_expiration = 0;\n    }\n\n    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n    if (ret)\n        goto done;\n\n    /* Unlock principal on this KDC. */\n    kdb->fail_auth_count = 0;\n\n    /* key data changed, let the database provider know */\n    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret)\n        goto done;\n\n    ret = KADM5_OK;\n\ndone:\n    cleanup_key_data(handle->context, n_new_key_data, new_key_data);\n    kdb_free_entry(handle, kdb, &adb);\n    if (have_pol)\n        kadm5_free_policy_ent(handle->lhandle, &pol);\n    return ret;\n}\n\n/*\n * Return the list of keys like kadm5_randkey_principal,\n * but don't modify the principal.\n */\nkadm5_ret_t\nkadm5_get_principal_keys(void *server_handle /* IN */,\n                         krb5_principal principal /* IN */,\n                         krb5_kvno kvno /* IN */,\n                         kadm5_key_data **key_data_out /* OUT */,\n                         int *n_key_data_out /* OUT */)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    kadm5_ret_t                 ret;\n    kadm5_server_handle_t       handle = server_handle;\n    kadm5_key_data              *key_data = NULL;\n    int i, nkeys = 0;\n\n    if (principal == NULL || key_data_out == NULL || n_key_data_out == NULL)\n        return EINVAL;\n\n    CHECK_HANDLE(server_handle);\n\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return(ret);\n\n    key_data = calloc(kdb->n_key_data, sizeof(kadm5_key_data));\n    if (key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n\n    for (i = 0, nkeys = 0; i < kdb->n_key_data; i++) {\n        if (kvno != 0 && kvno != kdb->key_data[i].key_data_kvno)\n            continue;\n        key_data[nkeys].kvno = kdb->key_data[i].key_data_kvno;\n\n        ret = krb5_dbe_decrypt_key_data(handle->context, NULL,\n                                        &kdb->key_data[i],\n                                        &key_data[nkeys].key,\n                                        &key_data[nkeys].salt);\n        if (ret)\n            goto done;\n        nkeys++;\n    }\n\n    *n_key_data_out = nkeys;\n    *key_data_out = key_data;\n    key_data = NULL;\n    nkeys = 0;\n    ret = KADM5_OK;\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    kadm5_free_kadm5_key_data(handle->context, nkeys, key_data);\n\n    return ret;\n}\n\n\n/*\n * Allocate an array of n_key_data krb5_keyblocks, fill in each\n * element with the results of decrypting the nth key in key_data,\n * and if n_keys is not NULL fill it in with the\n * number of keys decrypted.\n */\nstatic int decrypt_key_data(krb5_context context,\n                            int n_key_data, krb5_key_data *key_data,\n                            krb5_keyblock **keyblocks, int *n_keys)\n{\n    krb5_keyblock *keys;\n    int ret, i;\n\n    keys = (krb5_keyblock *) malloc(n_key_data*sizeof(krb5_keyblock));\n    if (keys == NULL)\n        return ENOMEM;\n    memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &keys[i],\n                                        NULL);\n        if (ret) {\n            for (; i >= 0; i--) {\n                if (keys[i].contents) {\n                    memset (keys[i].contents, 0, keys[i].length);\n                    free( keys[i].contents );\n                }\n            }\n\n            memset(keys, 0, n_key_data*sizeof(krb5_keyblock));\n            free(keys);\n            return ret;\n        }\n    }\n\n    *keyblocks = keys;\n    if (n_keys)\n        *n_keys = n_key_data;\n\n    return 0;\n}\n\n/*\n * Function: kadm5_decrypt_key\n *\n * Purpose: Retrieves and decrypts a principal key.\n *\n * Arguments:\n *\n *      server_handle   (r) kadm5 handle\n *      entry           (r) principal retrieved with kadm5_get_principal\n *      ktype           (r) enctype to search for, or -1 to ignore\n *      stype           (r) salt type to search for, or -1 to ignore\n *      kvno            (r) kvno to search for, -1 for max, 0 for max\n *                      only if it also matches ktype and stype\n *      keyblock        (w) keyblock to fill in\n *      keysalt         (w) keysalt to fill in, or NULL\n *      kvnop           (w) kvno to fill in, or NULL\n *\n * Effects: Searches the key_data array of entry, which must have been\n * retrived with kadm5_get_principal with the KADM5_KEY_DATA mask, to\n * find a key with a specified enctype, salt type, and kvno in a\n * principal entry.  If not found, return ENOENT.  Otherwise, decrypt\n * it with the master key, and return the key in keyblock, the salt\n * in salttype, and the key version number in kvno.\n *\n * If ktype or stype is -1, it is ignored for the search.  If kvno is\n * -1, ktype and stype are ignored and the key with the max kvno is\n * returned.  If kvno is 0, only the key with the max kvno is returned\n * and only if it matches the ktype and stype; otherwise, ENOENT is\n * returned.\n */\nkadm5_ret_t kadm5_decrypt_key(void *server_handle,\n                              kadm5_principal_ent_t entry, krb5_int32\n                              ktype, krb5_int32 stype, krb5_int32\n                              kvno, krb5_keyblock *keyblock,\n                              krb5_keysalt *keysalt, int *kvnop)\n{\n    kadm5_server_handle_t handle = server_handle;\n    krb5_db_entry dbent;\n    krb5_key_data *key_data;\n    krb5_keyblock *mkey_ptr;\n    int ret;\n\n    CHECK_HANDLE(server_handle);\n\n    if (entry->n_key_data == 0 || entry->key_data == NULL)\n        return EINVAL;\n\n    /* find_enctype only uses these two fields */\n    dbent.n_key_data = entry->n_key_data;\n    dbent.key_data = entry->key_data;\n    if ((ret = krb5_dbe_find_enctype(handle->context, &dbent, ktype,\n                                     stype, kvno, &key_data)))\n        return ret;\n\n    /* find_mkey only uses this field */\n    dbent.tl_data = entry->tl_data;\n    if ((ret = krb5_dbe_find_mkey(handle->context, &dbent, &mkey_ptr))) {\n        /* try refreshing master key list */\n        /* XXX it would nice if we had the mkvno here for optimization */\n        if (krb5_db_fetch_mkey_list(handle->context, master_princ,\n                                    &master_keyblock) == 0) {\n            if ((ret = krb5_dbe_find_mkey(handle->context, &dbent,\n                                          &mkey_ptr))) {\n                return ret;\n            }\n        } else {\n            return ret;\n        }\n    }\n\n    if ((ret = krb5_dbe_decrypt_key_data(handle->context, NULL, key_data,\n                                         keyblock, keysalt)))\n        return ret;\n\n    /*\n     * Coerce the enctype of the output keyblock in case we got an\n     * inexact match on the enctype; this behavior will go away when\n     * the key storage architecture gets redesigned for 1.3.\n     */\n    if (ktype != -1)\n        keyblock->enctype = ktype;\n\n    if (kvnop)\n        *kvnop = key_data->key_data_kvno;\n\n    return KADM5_OK;\n}\n\nkadm5_ret_t\nkadm5_purgekeys(void *server_handle,\n                krb5_principal principal,\n                int keepkvno)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n    krb5_key_data *old_keydata;\n    int n_old_keydata;\n    int i, j, k;\n\n    CHECK_HANDLE(server_handle);\n\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return(ret);\n\n    if (keepkvno <= 0) {\n        keepkvno = krb5_db_get_key_data_kvno(handle->context, kdb->n_key_data,\n                                             kdb->key_data);\n    }\n\n    old_keydata = kdb->key_data;\n    n_old_keydata = kdb->n_key_data;\n    kdb->n_key_data = 0;\n    /* Allocate one extra key_data to avoid allocating 0 bytes. */\n    kdb->key_data = calloc(n_old_keydata, sizeof(krb5_key_data));\n    if (kdb->key_data == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    memset(kdb->key_data, 0, n_old_keydata * sizeof(krb5_key_data));\n    for (i = 0, j = 0; i < n_old_keydata; i++) {\n        if (old_keydata[i].key_data_kvno < keepkvno)\n            continue;\n\n        /* Alias the key_data_contents pointers; we null them out in the\n         * source array immediately after. */\n        kdb->key_data[j] = old_keydata[i];\n        for (k = 0; k < old_keydata[i].key_data_ver; k++) {\n            old_keydata[i].key_data_contents[k] = NULL;\n        }\n        j++;\n    }\n    kdb->n_key_data = j;\n    cleanup_key_data(handle->context, n_old_keydata, old_keydata);\n\n    kdb->mask = KADM5_KEY_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n    if (ret)\n        goto done;\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_get_strings(void *server_handle, krb5_principal principal,\n                  krb5_string_attr **strings_out, int *count_out)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb = NULL;\n\n    *strings_out = NULL;\n    *count_out = 0;\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, NULL);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_get_strings(handle->context, kdb, strings_out, count_out);\n    kdb_free_entry(handle, kdb, NULL);\n    return ret;\n}\n\nkadm5_ret_t\nkadm5_set_string(void *server_handle, krb5_principal principal,\n                 const char *key, const char *value)\n{\n    kadm5_server_handle_t handle = server_handle;\n    kadm5_ret_t ret;\n    krb5_db_entry *kdb;\n    osa_princ_ent_rec adb;\n\n    CHECK_HANDLE(server_handle);\n    if (principal == NULL || key == NULL)\n        return EINVAL;\n\n    ret = kdb_get_entry(handle, principal, &kdb, &adb);\n    if (ret)\n        return ret;\n\n    ret = krb5_dbe_set_string(handle->context, kdb, key, value);\n    if (ret)\n        goto done;\n\n    kdb->mask = KADM5_TL_DATA;\n    ret = kdb_put_entry(handle, kdb, &adb);\n\ndone:\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/kdb_ldap.h */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* */\n#ifndef _KDB_LDAP_H\n#define _KDB_LDAP_H 1\n\n#include \"k5-int.h\"\n#include <k5-thread.h>\n#include <kdb5.h>\n#include \"ldap_krbcontainer.h\"\n#include \"ldap_realm.h\"\n\n/* We want the interfaces marked \"deprecated\" in OpenLDAP.  */\n#define LDAP_DEPRECATED 1\n#include <ldap.h>\n\n/* Check for acceptable versions.\n\n   OpenLDAP version 2.2.6 is known to have some kind of problem that\n   is tickled by the use of multiple handles in this code.  Version\n   2.2.19 in Mac OS 10.4.7 seems to be buggy as well.  Version 2.2.24\n   doesn't have this problem.  Other in-between versions have not been\n   tested.  */\n#ifndef BUILD_WITH_BROKEN_LDAP\n# if defined(LDAP_API_FEATURE_X_OPENLDAP)\n#  if LDAP_VENDOR_VERSION < 20224\n#   error This code triggers bugs in old OpenLDAP implementations.  Please update to 2.2.24 or later.\n#  endif\n# endif\n#endif /* BUILD_WITH_BROKEN_LDAP */\n\nextern struct timeval timelimit;\n\n#define  DEFAULT_CONNS_PER_SERVER    5\n#define  REALM_READ_REFRESH_INTERVAL (5 * 60)\n\n#if !defined(LDAP_OPT_RESULT_CODE) && defined(LDAP_OPT_ERROR_NUMBER)\n#define LDAP_OPT_RESULT_CODE LDAP_OPT_ERROR_NUMBER\n#endif\n\n#define MAXINTLEN  10\n\n#define IGNORE_STATUS              0\n#define CHECK_STATUS               1\n\n#define SETUP_CONTEXT() if (context == NULL || context->dal_handle == NULL \\\n                            || context->dal_handle->db_context == NULL) { \\\n        return EINVAL;                                                  \\\n    }                                                                   \\\n    dal_handle = context->dal_handle;                                   \\\n    ldap_context = (krb5_ldap_context *) dal_handle->db_context;        \\\n    if (ldap_context == NULL || ldap_context->server_info_list == NULL) \\\n        return KRB5_KDB_DBNOTINITED;\n\n#define GET_HANDLE()  ld = NULL;                                        \\\n    st = krb5_ldap_request_handle_from_pool(ldap_context, &ldap_server_handle); \\\n    if (st != 0) {                                                      \\\n        k5_wrapmsg(context, st, KRB5_KDB_ACCESS_ERROR,                  \\\n                   \"LDAP handle unavailable\");                          \\\n        st = KRB5_KDB_ACCESS_ERROR;                                     \\\n        goto cleanup;                                                   \\\n    }                                                                   \\\n    ld = ldap_server_handle->ldap_handle;\n\nextern int set_ldap_error (krb5_context ctx, int st, int op);\n\n#define LDAP_SEARCH(base, scope, filter, attrs)   LDAP_SEARCH_1(base, scope, filter, attrs, CHECK_STATUS)\n\n#define LDAP_SEARCH_1(base, scope, filter, attrs, status_check)         \\\n    tempst = 0;                                                         \\\n    st = ldap_search_ext_s(ld, base, scope, filter, attrs, 0, NULL,     \\\n                           NULL, &timelimit, LDAP_NO_LIMIT, &result);   \\\n    if (translate_ldap_error(st, OP_SEARCH) == KRB5_KDB_ACCESS_ERROR) { \\\n        tempst = krb5_ldap_rebind(ldap_context, &ldap_server_handle);   \\\n        if (ldap_server_handle)                                         \\\n            ld = ldap_server_handle->ldap_handle;                       \\\n        if (tempst == 0)                                                \\\n            st = ldap_search_ext_s(ld, base, scope, filter, attrs, 0,   \\\n                                   NULL, NULL, &timelimit,              \\\n                                   LDAP_NO_LIMIT, &result);             \\\n    }                                                                   \\\n                                                                        \\\n    if (status_check != IGNORE_STATUS) {                                \\\n        if (tempst != 0) {                                              \\\n            k5_wrapmsg(context, st, KRB5_KDB_ACCESS_ERROR,              \\\n                       \"LDAP handle unavailable\");                      \\\n            st = KRB5_KDB_ACCESS_ERROR;                                 \\\n            goto cleanup;                                               \\\n        }                                                               \\\n        if (st != LDAP_SUCCESS) {                                       \\\n            st = set_ldap_error(context, st, OP_SEARCH);                \\\n            goto cleanup;                                               \\\n        }                                                               \\\n    }\n\n\n#define CHECK_CLASS_VALIDITY(st, mask, str)                             \\\n    if (st != 0 || mask == 0) {                                         \\\n        if (st == 0 && mask == 0) {                                     \\\n            st = set_ldap_error(context, LDAP_OBJECT_CLASS_VIOLATION, OP_SEARCH); \\\n        }                                                               \\\n        k5_prependmsg(context, st, str);                                \\\n        goto cleanup;                                                   \\\n    }\n\n#define CHECK_NULL(ptr) if (ptr == NULL) {      \\\n        st = ENOMEM;                            \\\n        goto cleanup;                           \\\n    }\n\n#define  STORE16_INT(ptr, val)  store_16_be(val, ptr)\n#define  STORE32_INT(ptr, val)  store_32_be(val, ptr)\n#define UNSTORE16_INT(ptr, val) (val = load_16_be(ptr))\n#define UNSTORE32_INT(ptr, val) (val = load_32_be(ptr))\n\n#define  KDB_TL_USER_INFO      0xff\n\n#define KDB_TL_PRINCTYPE          0x01\n#define KDB_TL_PRINCCOUNT         0x02\n#define KDB_TL_USERDN             0x03\n#define KDB_TL_KEYINFO            0x04\n#define KDB_TL_MASK               0x05\n/* 0x06 was KDB_TL_CONTAINERDN but is no longer used */\n#define KDB_TL_LINKDN             0x07\n\n\n#define CHECK_LDAP_HANDLE(lcontext)     if (!(ldap_context              \\\n                                              && ldap_context->server_info_list)) { \\\n        return KRB5_KDB_DBNOTINITED;                                    \\\n    }\n\n#define HNDL_LOCK(lcontext) k5_mutex_lock(&lcontext->hndl_lock)\n#define HNDL_UNLOCK(lcontext) k5_mutex_unlock(&lcontext->hndl_lock)\n\n/* ldap server info structure */\n\ntypedef enum _server_type {PRIMARY, SECONDARY} krb5_ldap_server_type;\n\ntypedef enum _server_status {OFF, ON, NOTSET} krb5_ldap_server_status;\n\ntypedef struct _krb5_ldap_server_info krb5_ldap_server_info;\n\ntypedef struct  _krb5_ldap_server_handle {\n    int                              msgid;\n    LDAP                             *ldap_handle;\n    krb5_ldap_server_info            *server_info;\n    struct _krb5_ldap_server_handle  *next;\n} krb5_ldap_server_handle;\n\nstruct _krb5_ldap_server_info {\n    krb5_ldap_server_type        server_type;\n    krb5_ldap_server_status      server_status;\n    krb5_ui_4                    num_conns;\n    krb5_ldap_server_handle      *ldap_server_handles;\n    time_t                       downtime;\n    char                        *server_name;\n    int                          modify_increment;\n    struct _krb5_ldap_server_info *next;\n};\n\n\n/* ldap server structure */\n\ntypedef enum {SERVICE_DN_TYPE_SERVER, SERVICE_DN_TYPE_CLIENT} krb5_ldap_servicetype;\n\ntypedef struct _krb5_ldap_context {\n    krb5_ldap_servicetype         service_type;\n    krb5_ldap_server_info         **server_info_list;\n    krb5_ui_4                     max_server_conns;\n    char                          *conf_section;\n    char                          *bind_dn;\n    char                          *bind_pwd;\n    char                          *service_password_file;\n    char                          *sasl_mech;\n    char                          *sasl_authcid;\n    char                          *sasl_authzid;\n    char                          *sasl_realm;\n    char                          *root_certificate_file;\n    krb5_ui_4                     cert_count; /* certificate count */\n    k5_mutex_t                    hndl_lock;\n    char                          *container_dn;\n    krb5_ldap_realm_params        *lrparams;\n    krb5_boolean                  disable_last_success;\n    krb5_boolean                  disable_lockout;\n    int                           ldap_debug;\n    krb5_context                  kcontext;   /* to set the error code and message */\n} krb5_ldap_context;\n\n\ntypedef struct {\n    int           nkey;\n    struct berval **keys;\n}KEY;\n\n#define k5ldap_inited(c) (c && c->db_context                            \\\n                          && ((kdb5_dal_handle*)c->db_context)->db_context \\\n                          && ((krb5_ldap_context *) ((kdb5_dal_handle*)c->db_context)->db_context))\n\n\n/* misc functions */\n\nkrb5_error_code\nkrb5_ldap_db_init(krb5_context, krb5_ldap_context *);\n\nkrb5_error_code\nkrb5_ldap_db_single_init(krb5_ldap_context *);\n\nkrb5_error_code\nkrb5_ldap_rebind(krb5_ldap_context *, krb5_ldap_server_handle **);\n\nkrb5_error_code\nkrb5_ldap_get_age(krb5_context, char *, time_t *);\n\nkrb5_error_code\nkrb5_ldap_lib_init(void);\n\nkrb5_error_code\nkrb5_ldap_lib_cleanup(void);\n\nvoid *\nkrb5_ldap_alloc( krb5_context kcontext,  void *ptr, size_t size );\n\nvoid\nkrb5_ldap_free( krb5_context kcontext, void *ptr );\n\nkrb5_error_code\nkrb5_ldap_create(krb5_context , char *, char **);\n\nkrb5_error_code\nkrb5_ldap_open( krb5_context , char *,\n                char **db_args,\n                int mode );\nkrb5_error_code\nkrb5_ldap_close( krb5_context );\n\nkrb5_error_code\nkrb5_ldap_free_ldap_context(krb5_ldap_context *);\n\nkrb5_error_code\nkrb5_ldap_read_startup_information(krb5_context );\n\nkrb5_boolean\nhas_modify_increment(krb5_context, const char *);\n\nvoid\nkrb5_ldap_free_server_context_params(krb5_ldap_context *ldap_context);\n\nkrb5_error_code\nkrb5_ldap_check_policy_as(krb5_context kcontext, krb5_kdc_req *request,\n                          krb5_db_entry *client, krb5_db_entry *server,\n                          krb5_timestamp kdc_time, const char **status,\n                          krb5_pa_data ***e_data);\n\nvoid\nkrb5_ldap_audit_as_req(krb5_context kcontext, krb5_kdc_req *request,\n                       const krb5_address *local_addr,\n                       const krb5_address *remote_addr, krb5_db_entry *client,\n                       krb5_db_entry *server, krb5_timestamp authtime,\n                       krb5_error_code error_code);\n\nkrb5_error_code\nkrb5_ldap_check_allowed_to_delegate(krb5_context context,\n                                    krb5_const_principal client,\n                                    const krb5_db_entry *server,\n                                    krb5_const_principal proxy);\n\n/* DAL functions */\n\n\nkrb5_error_code\nkrb5_ldap_lock( krb5_context, int );\n\nkrb5_error_code\nkrb5_ldap_unlock( krb5_context );\n\n/* lockout.c */\nkrb5_error_code\nkrb5_ldap_lockout_check_policy(krb5_context context,\n                               krb5_db_entry *entry,\n                               krb5_timestamp stamp);\n\nkrb5_error_code\nkrb5_ldap_lockout_audit(krb5_context context,\n                        krb5_db_entry *entry,\n                        krb5_timestamp stamp,\n                        krb5_error_code status);\n\n#endif\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c */\n/*\n * Copyright (C) 2016 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in\n *   the documentation and/or other materials provided with the\n *   distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#include \"ldap_main.h\"\n#include \"kdb_ldap.h\"\n#include \"ldap_principal.h\"\n#include \"princ_xdr.h\"\n#include \"ldap_tkt_policy.h\"\n#include \"ldap_pwd_policy.h\"\n#include \"ldap_err.h\"\n#include <kadm5/admin.h>\n#include <time.h>\n\nextern char* principal_attributes[];\nextern char* max_pwd_life_attr[];\n\nstatic char *\ngetstringtime(krb5_timestamp);\n\nkrb5_error_code\nberval2tl_data(struct berval *in, krb5_tl_data **out)\n{\n    *out = (krb5_tl_data *) malloc (sizeof (krb5_tl_data));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->tl_data_length = in->bv_len - 2;\n    (*out)->tl_data_contents =  (krb5_octet *) malloc\n        ((*out)->tl_data_length * sizeof (krb5_octet));\n    if ((*out)->tl_data_contents == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    UNSTORE16_INT (in->bv_val, (*out)->tl_data_type);\n    memcpy ((*out)->tl_data_contents, in->bv_val + 2, (*out)->tl_data_length);\n\n    return 0;\n}\n\n/*\n * look up a principal in the directory.\n */\n\nkrb5_error_code\nkrb5_ldap_get_principal(krb5_context context, krb5_const_principal searchfor,\n                        unsigned int flags, krb5_db_entry **entry_ptr)\n{\n    char                        *user=NULL, *filter=NULL, *filtuser=NULL;\n    unsigned int                tree=0, ntrees=1, princlen=0;\n    krb5_error_code             tempst=0, st=0;\n    char                        **values=NULL, **subtree=NULL, *cname=NULL;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_principal              cprinc=NULL;\n    krb5_boolean                found=FALSE;\n    krb5_db_entry               *entry = NULL;\n\n    *entry_ptr = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    if (searchfor == NULL)\n        return EINVAL;\n\n    dal_handle = context->dal_handle;\n    ldap_context = (krb5_ldap_context *) dal_handle->db_context;\n\n    CHECK_LDAP_HANDLE(ldap_context);\n\n    if (!is_principal_in_realm(ldap_context, searchfor)) {\n        st = KRB5_KDB_NOENTRY;\n        k5_setmsg(context, st, _(\"Principal does not belong to realm\"));\n        goto cleanup;\n    }\n\n    if ((st=krb5_unparse_name(context, searchfor, &user)) != 0)\n        goto cleanup;\n\n    if ((st=krb5_ldap_unparse_principal_name(user)) != 0)\n        goto cleanup;\n\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    princlen = strlen(FILTER) + strlen(filtuser) + 2 + 1;  /* 2 for closing brackets */\n    if ((filter = malloc(princlen)) == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    snprintf(filter, princlen, FILTER\"%s))\", filtuser);\n\n    if ((st = krb5_get_subtree_info(ldap_context, &subtree, &ntrees)) != 0)\n        goto cleanup;\n\n    GET_HANDLE();\n    for (tree=0; tree < ntrees && !found; ++tree) {\n\n        LDAP_SEARCH(subtree[tree], ldap_context->lrparams->search_scope, filter, principal_attributes);\n        for (ent=ldap_first_entry(ld, result); ent != NULL && !found; ent=ldap_next_entry(ld, ent)) {\n\n            /* get the associated directory user information */\n            if ((values=ldap_get_values(ld, ent, \"krbprincipalname\")) != NULL) {\n                int i;\n\n                /* a wild-card in a principal name can return a list of kerberos principals.\n                 * Make sure that the correct principal is returned.\n                 * NOTE: a principalname k* in ldap server will return all the principals starting with a k\n                 */\n                for (i=0; values[i] != NULL; ++i) {\n                    if (strcmp(values[i], user) == 0) {\n                        found = TRUE;\n                        break;\n                    }\n                }\n                ldap_value_free(values);\n\n                if (!found) /* no matching principal found */\n                    continue;\n            }\n\n            if ((values=ldap_get_values(ld, ent, \"krbcanonicalname\")) != NULL) {\n                if (values[0] && strcmp(values[0], user) != 0) {\n                    /* We matched an alias, not the canonical name. */\n                    if (flags & KRB5_KDB_FLAG_ALIAS_OK) {\n                        st = krb5_ldap_parse_principal_name(values[0], &cname);\n                        if (st != 0)\n                            goto cleanup;\n                        st = krb5_parse_name(context, cname, &cprinc);\n                        if (st != 0)\n                            goto cleanup;\n                    } else /* No canonicalization, so don't return aliases. */\n                        found = FALSE;\n                }\n                ldap_value_free(values);\n                if (!found)\n                    continue;\n            }\n\n            entry = k5alloc(sizeof(*entry), &st);\n            if (entry == NULL)\n                goto cleanup;\n            if ((st = populate_krb5_db_entry(context, ldap_context, ld, ent,\n                                             cprinc ? cprinc : searchfor,\n                                             entry)) != 0)\n                goto cleanup;\n        }\n        ldap_msgfree(result);\n        result = NULL;\n    } /* for (tree=0 ... */\n\n    if (found) {\n        *entry_ptr = entry;\n        entry = NULL;\n    } else\n        st = KRB5_KDB_NOENTRY;\n\ncleanup:\n    ldap_msgfree(result);\n    krb5_db_free_principal(context, entry);\n\n    if (filter)\n        free (filter);\n\n    if (subtree) {\n        for (; ntrees; --ntrees)\n            if (subtree[ntrees-1])\n                free (subtree[ntrees-1]);\n        free (subtree);\n    }\n\n    if (ldap_server_handle)\n        krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    if (cname)\n        free(cname);\n\n    if (cprinc)\n        krb5_free_principal(context, cprinc);\n\n    return st;\n}\n\ntypedef enum{ ADD_PRINCIPAL, MODIFY_PRINCIPAL } OPERATION;\n/*\n * ptype is creating confusions. Additionally the logic\n * surronding ptype is redundunt and can be achevied\n * with the help of dn and containerdn members.\n * so dropping the ptype member\n */\n\ntypedef struct _xargs_t {\n    char           *dn;\n    char           *linkdn;\n    krb5_boolean   dn_from_kbd;\n    char           *containerdn;\n    char           *tktpolicydn;\n}xargs_t;\n\nstatic void\nfree_xargs(xargs_t xargs)\n{\n    if (xargs.dn)\n        free (xargs.dn);\n    if (xargs.linkdn)\n        free(xargs.linkdn);\n    if (xargs.containerdn)\n        free (xargs.containerdn);\n    if (xargs.tktpolicydn)\n        free (xargs.tktpolicydn);\n}\n\nstatic krb5_error_code\nprocess_db_args(krb5_context context, char **db_args, xargs_t *xargs,\n                OPERATION optype)\n{\n    int                   i=0;\n    krb5_error_code       st=0;\n    char                  *arg=NULL, *arg_val=NULL;\n    char                  **dptr=NULL;\n    unsigned int          arg_val_len=0;\n\n    if (db_args) {\n        for (i=0; db_args[i]; ++i) {\n            arg = strtok_r(db_args[i], \"=\", &arg_val);\n            arg = (arg != NULL) ? arg : \"\";\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                dptr = &xargs->tktpolicydn;\n            } else {\n                if (strcmp(arg, USERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL ||\n                        xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->dn;\n                } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {\n                    if (optype == MODIFY_PRINCIPAL ||\n                        xargs->dn != NULL || xargs->containerdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->containerdn;\n                } else if (strcmp(arg, LINKDN_ARG) == 0) {\n                    if (xargs->dn != NULL || xargs->linkdn != NULL) {\n                        st = EINVAL;\n                        k5_setmsg(context, st, _(\"%s option not supported\"),\n                                  arg);\n                        goto cleanup;\n                    }\n                    dptr = &xargs->linkdn;\n                } else {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"unknown option: %s\"), arg);\n                    goto cleanup;\n                }\n\n                xargs->dn_from_kbd = TRUE;\n                if (arg_val == NULL || strlen(arg_val) == 0) {\n                    st = EINVAL;\n                    k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                    goto cleanup;\n                }\n            }\n\n            if (arg_val == NULL) {\n                st = EINVAL;\n                k5_setmsg(context, st, _(\"%s option value missing\"), arg);\n                goto cleanup;\n            }\n            arg_val_len = strlen(arg_val) + 1;\n\n            if (strcmp(arg, TKTPOLICY_ARG) == 0) {\n                if ((st = krb5_ldap_name_to_policydn (context,\n                                                      arg_val,\n                                                      dptr)) != 0)\n                    goto cleanup;\n            } else {\n                *dptr = k5memdup(arg_val, arg_val_len, &st);\n                if (*dptr == NULL)\n                    goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    return st;\n}\n\nkrb5int_access accessor;\n\nstatic krb5_error_code\nasn1_encode_sequence_of_keys(krb5_key_data *key_data, krb5_int16 n_key_data,\n                             krb5_int32 mkvno, krb5_data **code)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data val;\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    val.key_data = key_data;\n    val.n_key_data = n_key_data;\n    val.mkvno = mkvno;\n    val.kvno = key_data[0].key_data_kvno;\n\n    return accessor.asn1_ldap_encode_sequence_of_keys(&val, code);\n}\n\nstatic krb5_error_code\nasn1_decode_sequence_of_keys(krb5_data *in, ldap_seqof_key_data *out)\n{\n    krb5_error_code err;\n    ldap_seqof_key_data *p;\n    int i;\n\n    memset(out, 0, sizeof(*out));\n\n    /*\n     * This should be pushed back into other library initialization\n     * code.\n     */\n    err = kldap_ensure_initialized ();\n    if (err)\n        return err;\n\n    err = accessor.asn1_ldap_decode_sequence_of_keys(in, &p);\n    if (err)\n        return err;\n\n    /* Set kvno and key_data_ver in each key_data element. */\n    for (i = 0; i < p->n_key_data; i++) {\n        p->key_data[i].key_data_kvno = p->kvno;\n        /* The decoder sets key_data_ver to 1 if no salt is present, but leaves\n         * it at 0 if salt is present. */\n        if (p->key_data[i].key_data_ver == 0)\n            p->key_data[i].key_data_ver = 2;\n    }\n\n    *out = *p;\n    free(p);\n    return 0;\n}\n\n/*\n * Free a NULL-terminated struct berval *array[] and all its contents.\n * Does not set array to NULL after freeing it.\n */\nvoid\nfree_berdata(struct berval **array)\n{\n    int i;\n\n    if (array != NULL) {\n        for (i = 0; array[i] != NULL; i++) {\n            if (array[i]->bv_val != NULL)\n                free(array[i]->bv_val);\n            free(array[i]);\n        }\n        free(array);\n    }\n}\n\n/*\n * Encode krb5_key_data into a berval struct for insertion into LDAP.\n */\nstatic krb5_error_code\nencode_keys(krb5_key_data *key_data_in, int n_key_data, krb5_kvno mkvno,\n            struct berval **bval_out)\n{\n    krb5_error_code err = 0;\n    int i;\n    krb5_key_data *key_data = NULL;\n    struct berval *bval = NULL;\n    krb5_data *code;\n\n    *bval_out = NULL;\n    if (n_key_data <= 0) {\n        err = EINVAL;\n        goto cleanup;\n    }\n\n    /* Make a shallow copy of the key data so we can alter it. */\n    key_data = k5calloc(n_key_data, sizeof(*key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memcpy(key_data, key_data_in, n_key_data * sizeof(*key_data));\n\n    /* Unpatched krb5 1.11 and 1.12 cannot decode KrbKey sequences with no salt\n     * field.  For compatibility, always encode a salt field. */\n    for (i = 0; i < n_key_data; i++) {\n        if (key_data[i].key_data_ver == 1) {\n            key_data[i].key_data_ver = 2;\n            key_data[i].key_data_type[1] = KRB5_KDB_SALTTYPE_NORMAL;\n            key_data[i].key_data_length[1] = 0;\n            key_data[i].key_data_contents[1] = NULL;\n        }\n    }\n\n    bval = k5alloc(sizeof(struct berval), &err);\n    if (bval == NULL)\n        goto cleanup;\n\n    err = asn1_encode_sequence_of_keys(key_data, n_key_data, mkvno, &code);\n    if (err)\n        goto cleanup;\n\n    /* Steal the data pointer from code for bval and discard code. */\n    bval->bv_len = code->length;\n    bval->bv_val = code->data;\n    free(code);\n\n    *bval_out = bval;\n    bval = NULL;\n\ncleanup:\n    free(key_data);\n    free(bval);\n    return err;\n}\n\n/* Decoding ASN.1 encoded key */\nstruct berval **\nkrb5_encode_krbsecretkey(krb5_key_data *key_data, int n_key_data,\n                         krb5_kvno mkvno)\n{\n    struct berval **ret = NULL;\n    int currkvno;\n    int num_versions = 0;\n    int i, j, last;\n    krb5_error_code err = 0;\n\n    if (n_key_data < 0)\n        return NULL;\n\n    /* Find the number of key versions */\n    if (n_key_data > 0) {\n        for (i = 0, num_versions = 1; i < n_key_data - 1; i++) {\n            if (key_data[i].key_data_kvno != key_data[i + 1].key_data_kvno)\n                num_versions++;\n        }\n    }\n\n    ret = calloc(num_versions + 1, sizeof(struct berval *));\n    if (ret == NULL) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n    ret[num_versions] = NULL;\n\n    /* n_key_data may be 0 if a principal is created without a key. */\n    if (n_key_data == 0)\n        goto cleanup;\n\n    currkvno = key_data[0].key_data_kvno;\n    for (i = 0, last = 0, j = 0; i < n_key_data; i++) {\n        if (i == n_key_data - 1 || key_data[i + 1].key_data_kvno != currkvno) {\n            err = encode_keys(key_data + last, (krb5_int16)i - last + 1, mkvno,\n                              &ret[j]);\n            if (err)\n                goto cleanup;\n            j++;\n            last = i + 1;\n\n            if (i < n_key_data - 1)\n                currkvno = key_data[i + 1].key_data_kvno;\n        }\n    }\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\n/*\n * Encode a principal's key history for insertion into ldap.\n */\nstatic struct berval **\nkrb5_encode_histkey(osa_princ_ent_rec *princ_ent)\n{\n    unsigned int i;\n    krb5_error_code err = 0;\n    struct berval **ret = NULL;\n\n    if (princ_ent->old_key_len <= 0)\n        return NULL;\n\n    ret = k5calloc(princ_ent->old_key_len + 1, sizeof(struct berval *), &err);\n    if (ret == NULL)\n        goto cleanup;\n\n    for (i = 0; i < princ_ent->old_key_len; i++) {\n        if (princ_ent->old_keys[i].n_key_data <= 0) {\n            err = EINVAL;\n            goto cleanup;\n        }\n        err = encode_keys(princ_ent->old_keys[i].key_data,\n                          princ_ent->old_keys[i].n_key_data,\n                          princ_ent->admin_history_kvno, &ret[i]);\n        if (err)\n            goto cleanup;\n    }\n\n    ret[princ_ent->old_key_len] = NULL;\n\ncleanup:\n    if (err != 0) {\n        free_berdata(ret);\n        ret = NULL;\n    }\n\n    return ret;\n}\n\nstatic krb5_error_code\ntl_data2berval (krb5_tl_data *in, struct berval **out)\n{\n    *out = (struct berval *) malloc (sizeof (struct berval));\n    if (*out == NULL)\n        return ENOMEM;\n\n    (*out)->bv_len = in->tl_data_length + 2;\n    (*out)->bv_val =  (char *) malloc ((*out)->bv_len);\n    if ((*out)->bv_val == NULL) {\n        free (*out);\n        return ENOMEM;\n    }\n\n    STORE16_INT((*out)->bv_val, in->tl_data_type);\n    memcpy ((*out)->bv_val + 2, in->tl_data_contents, in->tl_data_length);\n\n    return 0;\n}\n\n/* Parse the \"require_auth\" string for auth indicators, adding them to the\n * krbPrincipalAuthInd attribute. */\nstatic krb5_error_code\nupdate_ldap_mod_auth_ind(krb5_context context, krb5_db_entry *entry,\n                         LDAPMod ***mods)\n{\n    int i = 0;\n    krb5_error_code ret;\n    char *auth_ind = NULL;\n    char *strval[10] = {};\n    char *ai, *ai_save = NULL;\n    int sv_num = sizeof(strval) / sizeof(*strval);\n\n    ret = krb5_dbe_get_string(context, entry, KRB5_KDB_SK_REQUIRE_AUTH,\n                              &auth_ind);\n    if (ret || auth_ind == NULL)\n        goto cleanup;\n\n    ai = strtok_r(auth_ind, \" \", &ai_save);\n    while (ai != NULL && i < sv_num) {\n        strval[i++] = ai;\n        ai = strtok_r(NULL, \" \", &ai_save);\n    }\n\n    ret = krb5_add_str_mem_ldap_mod(mods, \"krbPrincipalAuthInd\",\n                                    LDAP_MOD_REPLACE, strval);\n\ncleanup:\n    krb5_dbe_free_string(context, auth_ind);\n    return ret;\n}\n\nstatic krb5_error_code\ncheck_dn_in_container(krb5_context context, const char *dn,\n                      char *const *subtrees, unsigned int ntrees)\n{\n    unsigned int i;\n    size_t dnlen = strlen(dn), stlen;\n\n    for (i = 0; i < ntrees; i++) {\n        if (subtrees[i] == NULL || *subtrees[i] == '\\0')\n            return 0;\n        stlen = strlen(subtrees[i]);\n        if (dnlen >= stlen &&\n            strcasecmp(dn + dnlen - stlen, subtrees[i]) == 0 &&\n            (dnlen == stlen || dn[dnlen - stlen - 1] == ','))\n            return 0;\n    }\n\n    k5_setmsg(context, EINVAL, _(\"DN is out of the realm subtree\"));\n    return EINVAL;\n}\n\nstatic krb5_error_code\ncheck_dn_exists(krb5_context context,\n                krb5_ldap_server_handle *ldap_server_handle,\n                const char *dn, krb5_boolean nonkrb_only)\n{\n    krb5_error_code st = 0, tempst;\n    krb5_ldap_context *ldap_context = context->dal_handle->db_context;\n    LDAP *ld = ldap_server_handle->ldap_handle;\n    LDAPMessage *result = NULL, *ent;\n    char *attrs[] = { \"krbticketpolicyreference\", \"krbprincipalname\", NULL };\n    char **values;\n\n    LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attrs, IGNORE_STATUS);\n    if (st != LDAP_SUCCESS)\n        return set_ldap_error(context, st, OP_SEARCH);\n\n    ent = ldap_first_entry(ld, result);\n    CHECK_NULL(ent);\n\n    values = ldap_get_values(ld, ent, \"krbticketpolicyreference\");\n    if (values != NULL)\n        ldap_value_free(values);\n\n    values = ldap_get_values(ld, ent, \"krbprincipalname\");\n    if (values != NULL) {\n        ldap_value_free(values);\n        if (nonkrb_only) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"ldap object is already kerberized\"));\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    return st;\n}\n\nstatic krb5_error_code\nvalidate_xargs(krb5_context context,\n               krb5_ldap_server_handle *ldap_server_handle,\n               const xargs_t *xargs, const char *standalone_dn,\n               char *const *subtrees, unsigned int ntrees)\n{\n    krb5_error_code st;\n\n    if (xargs->dn != NULL) {\n        /* The supplied dn must be within a realm container. */\n        st = check_dn_in_container(context, xargs->dn, subtrees, ntrees);\n        if (st)\n            return st;\n        /* The supplied dn must exist without Kerberos attributes. */\n        st = check_dn_exists(context, ldap_server_handle, xargs->dn, TRUE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->linkdn != NULL) {\n        /* The supplied linkdn must be within a realm container. */\n        st = check_dn_in_container(context, xargs->linkdn, subtrees, ntrees);\n        if (st)\n            return st;\n        /* The supplied linkdn must exist. */\n        st = check_dn_exists(context, ldap_server_handle, xargs->linkdn,\n                             FALSE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->containerdn != NULL && standalone_dn != NULL) {\n        /* standalone_dn (likely composed using containerdn) must be within a\n         * container. */\n        st = check_dn_in_container(context, standalone_dn, subtrees, ntrees);\n        if (st)\n            return st;\n    }\n\n    return 0;\n}\n\nkrb5_error_code\nkrb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,\n                        char **db_args)\n{\n    int                         l=0, kerberos_principal_object_type=0;\n    unsigned int                ntrees=0, tre=0;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    char                        **subtreelist = NULL;\n    char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;\n    char                        *strval[10]={NULL}, errbuf[1024];\n    char                        *filtuser=NULL;\n    struct berval               **bersecretkey=NULL;\n    LDAPMod                     **mods=NULL;\n    krb5_boolean                create_standalone=FALSE;\n    krb5_boolean                establish_links=FALSE;\n    char                        *standalone_principal_dn=NULL;\n    krb5_tl_data                *tl_data=NULL;\n    krb5_key_data               **keys=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    osa_princ_ent_rec           princ_ent = {0};\n    xargs_t                     xargs = {0};\n    char                        *polname = NULL;\n    OPERATION optype;\n    krb5_boolean                found_entry = FALSE;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)\n        return EINVAL;\n\n    /* get ldap handle */\n    GET_HANDLE();\n\n    if (!is_principal_in_realm(ldap_context, entry->princ)) {\n        st = EINVAL;\n        k5_setmsg(context, st,\n                  _(\"Principal does not belong to the default realm\"));\n        goto cleanup;\n    }\n\n    /* get the principal information to act on */\n    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||\n        ((st=krb5_ldap_unparse_principal_name(user)) != 0))\n        goto cleanup;\n    filtuser = ldap_filter_correct(user);\n    if (filtuser == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Identity the type of operation, it can be\n     * add principal or modify principal.\n     * hack if the entry->mask has KRB_PRINCIPAL flag set\n     * then it is a add operation\n     */\n    if (entry->mask & KADM5_PRINCIPAL)\n        optype = ADD_PRINCIPAL;\n    else\n        optype = MODIFY_PRINCIPAL;\n\n    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||\n        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))\n        goto cleanup;\n\n    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)\n        goto cleanup;\n\n    if (entry->mask & KADM5_LOAD) {\n        unsigned int     tree = 0;\n        int              numlentries = 0;\n        char             *filter = NULL;\n\n        /*  A load operation is special, will do a mix-in (add krbprinc\n         *  attrs to a non-krb object entry) if an object exists with a\n         *  matching krbprincipalname attribute so try to find existing\n         *  object and set principal_dn.  This assumes that the\n         *  krbprincipalname attribute is unique (only one object entry has\n         *  a particular krbprincipalname attribute).\n         */\n        if (asprintf(&filter, FILTER\"%s))\", filtuser) < 0) {\n            filter = NULL;\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        /* get the current subtree list */\n        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)\n            goto cleanup;\n\n        found_entry = FALSE;\n        /* search for entry with matching krbprincipalname attribute */\n        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {\n            if (principal_dn == NULL) {\n                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);\n            } else {\n                /* just look for entry with principal_dn */\n                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);\n            }\n            if (st == LDAP_SUCCESS) {\n                numlentries = ldap_count_entries(ld, result);\n                if (numlentries > 1) {\n                    free(filter);\n                    st = EINVAL;\n                    k5_setmsg(context, st,\n                              _(\"operation can not continue, more than one \"\n                                \"entry with principal name \\\"%s\\\" found\"),\n                              user);\n                    goto cleanup;\n                } else if (numlentries == 1) {\n                    found_entry = TRUE;\n                    if (principal_dn == NULL) {\n                        ent = ldap_first_entry(ld, result);\n                        if (ent != NULL) {\n                            /* setting principal_dn will cause that entry to be modified further down */\n                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {\n                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);\n                                st = set_ldap_error (context, st, 0);\n                                free(filter);\n                                goto cleanup;\n                            }\n                        }\n                    }\n                }\n            } else if (st != LDAP_NO_SUCH_OBJECT) {\n                /* could not perform search, return with failure */\n                st = set_ldap_error (context, st, 0);\n                free(filter);\n                goto cleanup;\n            }\n            ldap_msgfree(result);\n            result = NULL;\n            /*\n             * If it isn't found then assume a standalone princ entry is to\n             * be created.\n             */\n        } /* end for (tree = 0; principal_dn == ... */\n\n        free(filter);\n\n        if (found_entry == FALSE && principal_dn != NULL) {\n            /*\n             * if principal_dn is null then there is code further down to\n             * deal with setting standalone_principal_dn.  Also note that\n             * this will set create_standalone true for\n             * non-mix-in entries which is okay if loading from a dump.\n             */\n            create_standalone = TRUE;\n            standalone_principal_dn = strdup(principal_dn);\n            CHECK_NULL(standalone_principal_dn);\n        }\n    } /* end if (entry->mask & KADM5_LOAD */\n\n    /* time to generate the DN information with the help of\n     * containerdn, principalcontainerreference or\n     * realmcontainerdn information\n     */\n    if (principal_dn == NULL && xargs.dn == NULL) { /* creation of standalone principal */\n        /* get the subtree information */\n        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(\"krbtgt\") &&\n            strncmp(entry->princ->data[0].data, \"krbtgt\", entry->princ->data[0].length) == 0) {\n            /* if the principal is a inter-realm principal, always created in the realm container */\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        } else if (xargs.containerdn) {\n            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {\n                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {\n                    int ost = st;\n                    st = EINVAL;\n                    k5_wrapmsg(context, ost, st, _(\"'%s' not found\"),\n                               xargs.containerdn);\n                }\n                goto cleanup;\n            }\n            subtree = strdup(xargs.containerdn);\n        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {\n            /*\n             * Here the subtree should be changed with\n             * principalcontainerreference attribute value\n             */\n            subtree = strdup(ldap_context->lrparams->containerref);\n        } else {\n            subtree = strdup(ldap_context->lrparams->realmdn);\n        }\n        CHECK_NULL(subtree);\n\n        if (asprintf(&standalone_principal_dn, \"krbprincipalname=%s,%s\",\n                     filtuser, subtree) < 0)\n            standalone_principal_dn = NULL;\n        CHECK_NULL(standalone_principal_dn);\n        /*\n         * free subtree when you are done using the subtree\n         * set the boolean create_standalone to TRUE\n         */\n        create_standalone = TRUE;\n        free(subtree);\n        subtree = NULL;\n    }\n\n    /*\n     * If the DN information is presented by the user, time to\n     * validate the input to ensure that the DN falls under\n     * any of the subtrees\n     */\n    if (xargs.dn_from_kbd == TRUE) {\n        /* Get the current subtree list if we haven't already done so. */\n        if (subtreelist == NULL) {\n            st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);\n            if (st)\n                goto cleanup;\n        }\n\n        st = validate_xargs(context, ldap_server_handle, &xargs,\n                            standalone_principal_dn, subtreelist, ntrees);\n        if (st)\n            goto cleanup;\n    }\n\n    if (xargs.linkdn != NULL) {\n        /*\n         * link information can be changed using modprinc.\n         * However, link information can be changed only on the\n         * standalone kerberos principal objects. A standalone\n         * kerberos principal object is of type krbprincipal\n         * structural objectclass.\n         *\n         * NOTE: kerberos principals on an ldap object can't be\n         * linked to other ldap objects.\n         */\n        if (optype == MODIFY_PRINCIPAL &&\n            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {\n            st = EINVAL;\n            snprintf(errbuf, sizeof(errbuf),\n                     _(\"link information can not be set/updated as the \"\n                       \"kerberos principal belongs to an ldap object\"));\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n        /*\n         * Check the link information. If there is already a link\n         * existing then this operation is not allowed.\n         */\n        {\n            char **linkdns=NULL;\n            int  j=0;\n\n            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Failed getting object references\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            }\n            if (linkdns != NULL) {\n                st = EINVAL;\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"kerberos principal is already linked to a ldap \"\n                           \"object\"));\n                k5_setmsg(context, st, \"%s\", errbuf);\n                for (j=0; linkdns[j] != NULL; ++j)\n                    free (linkdns[j]);\n                free (linkdns);\n                goto cleanup;\n            }\n        }\n\n        establish_links = TRUE;\n    }\n\n    if (entry->mask & KADM5_LAST_SUCCESS) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_success)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastSuccessfulAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_LAST_FAILED) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastFailedAuth\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free(strval[0]);\n    }\n\n    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {\n        krb5_kvno fail_auth_count;\n\n        fail_auth_count = entry->fail_auth_count;\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            fail_auth_count++;\n\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_REPLACE,\n                                       fail_auth_count);\n        if (st != 0)\n            goto cleanup;\n    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {\n        int attr_mask = 0;\n        krb5_boolean has_fail_count;\n\n        /* Check if the krbLoginFailedCount attribute exists.  (Through\n         * krb5 1.8.1, it wasn't set in new entries.) */\n        st = krb5_get_attributes_mask(context, entry, &attr_mask);\n        if (st != 0)\n            goto cleanup;\n        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);\n\n        /*\n         * If the client library and server supports RFC 4525,\n         * then use it to increment by one the value of the\n         * krbLoginFailedCount attribute. Otherwise, assert the\n         * (provided) old value by deleting it before adding.\n         */\n#ifdef LDAP_MOD_INCREMENT\n        if (ldap_server_handle->server_info->modify_increment &&\n            has_fail_count) {\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_INCREMENT, 1);\n            if (st != 0)\n                goto cleanup;\n        } else {\n#endif /* LDAP_MOD_INCREMENT */\n            if (has_fail_count) {\n                st = krb5_add_int_mem_ldap_mod(&mods,\n                                               \"krbLoginFailedCount\",\n                                               LDAP_MOD_DELETE,\n                                               entry->fail_auth_count);\n                if (st != 0)\n                    goto cleanup;\n            }\n            st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                           LDAP_MOD_ADD,\n                                           entry->fail_auth_count + 1);\n            if (st != 0)\n                goto cleanup;\n#ifdef LDAP_MOD_INCREMENT\n        }\n#endif\n    } else if (optype == ADD_PRINCIPAL) {\n        /* Initialize krbLoginFailedCount in new entries to help avoid a\n         * race during the first failed login. */\n        st = krb5_add_int_mem_ldap_mod(&mods, \"krbLoginFailedCount\",\n                                       LDAP_MOD_ADD, 0);\n    }\n\n    if (entry->mask & KADM5_MAX_LIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxticketlife\", LDAP_MOD_REPLACE, entry->max_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_MAX_RLIFE) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbmaxrenewableage\", LDAP_MOD_REPLACE,\n                                          entry->max_renewable_life)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_ATTRIBUTES) {\n        if ((st=krb5_add_int_mem_ldap_mod(&mods, \"krbticketflags\", LDAP_MOD_REPLACE,\n                                          entry->attributes)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINCIPAL) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = user;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalname\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbprincipalexpiration\", LDAP_MOD_REPLACE, strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_PW_EXPIRATION) {\n        memset(strval, 0, sizeof(strval));\n        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n            goto cleanup;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpasswordexpiration\",\n                                          LDAP_MOD_REPLACE,\n                                          strval)) != 0) {\n            free (strval[0]);\n            goto cleanup;\n        }\n        free (strval[0]);\n    }\n\n    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {\n        memset(&princ_ent, 0, sizeof(princ_ent));\n        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {\n            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {\n                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {\n                    goto cleanup;\n                }\n                break;\n            }\n        }\n    }\n\n    if (entry->mask & KADM5_POLICY) {\n        if (princ_ent.aux_attributes & KADM5_POLICY) {\n            memset(strval, 0, sizeof(strval));\n            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)\n                goto cleanup;\n            strval[0] = polname;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n        } else {\n            st = EINVAL;\n            k5_setmsg(context, st, \"Password policy value null\");\n            goto cleanup;\n        }\n    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {\n        /*\n         * a load is special in that existing entries must have attrs that\n         * removed.\n         */\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_REPLACE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_POLICY_CLR) {\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbpwdpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n            goto cleanup;\n    }\n\n    if (entry->mask & KADM5_KEY_HIST) {\n        bersecretkey = krb5_encode_histkey(&princ_ent);\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n\n        st = krb5_add_ber_mem_ldap_mod(&mods, \"krbpwdhistory\",\n                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                       bersecretkey);\n        if (st != 0)\n            goto cleanup;\n        free_berdata(bersecretkey);\n        bersecretkey = NULL;\n    }\n\n    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {\n        krb5_kvno mkvno;\n\n        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)\n            goto cleanup;\n        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,\n                                                 entry->n_key_data, mkvno);\n\n        if (bersecretkey == NULL) {\n            st = ENOMEM;\n            goto cleanup;\n        }\n        /* An empty list of bervals is only accepted for modify operations,\n         * not add operations. */\n        if (bersecretkey[0] != NULL || !create_standalone) {\n            st = krb5_add_ber_mem_ldap_mod(&mods, \"krbprincipalkey\",\n                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,\n                                           bersecretkey);\n            if (st != 0)\n                goto cleanup;\n        }\n\n        if (!(entry->mask & KADM5_PRINCIPAL)) {\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)\n                goto cleanup;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods,\n                                              \"krbpasswordexpiration\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n        /* Update last password change whenever a new key is set */\n        {\n            krb5_timestamp last_pw_changed;\n            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,\n                                                    &last_pw_changed)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastPwdChange\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n\n    } /* Modify Key data ends here */\n\n    /* Auth indicators will also be stored in krbExtraData when processing\n     * tl_data. */\n    st = update_ldap_mod_auth_ind(context, entry, &mods);\n    if (st != 0)\n        goto cleanup;\n\n    /* Set tl_data */\n    if (entry->tl_data != NULL) {\n        int count = 0;\n        struct berval **ber_tl_data = NULL;\n        krb5_tl_data *ptr;\n        krb5_timestamp unlock_time;\n        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                || ptr->tl_data_type == KDB_TL_USER_INFO\n                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                continue;\n            count++;\n        }\n        if (count != 0) {\n            int j;\n            ber_tl_data = (struct berval **) calloc (count + 1,\n                                                     sizeof (struct berval*));\n            if (ber_tl_data == NULL) {\n                st = ENOMEM;\n                goto cleanup;\n            }\n            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {\n                /* Ignore tl_data that are stored in separate directory\n                 * attributes */\n                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE\n#ifdef SECURID\n                    || ptr->tl_data_type == KRB5_TL_DB_ARGS\n#endif\n                    || ptr->tl_data_type == KRB5_TL_KADM_DATA\n                    || ptr->tl_data_type == KDB_TL_USER_INFO\n                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL\n                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)\n                    continue;\n                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)\n                    break;\n                j++;\n            }\n            if (st == 0) {\n                ber_tl_data[count] = NULL;\n                st=krb5_add_ber_mem_ldap_mod(&mods, \"krbExtraData\",\n                                             LDAP_MOD_REPLACE |\n                                             LDAP_MOD_BVALUES, ber_tl_data);\n            }\n            free_berdata(ber_tl_data);\n            if (st != 0)\n                goto cleanup;\n        }\n        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,\n                                                  &unlock_time)) != 0)\n            goto cleanup;\n        if (unlock_time != 0) {\n            /* Update last admin unlock */\n            memset(strval, 0, sizeof(strval));\n            if ((strval[0] = getstringtime(unlock_time)) == NULL)\n                goto cleanup;\n\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbLastAdminUnlock\",\n                                              LDAP_MOD_REPLACE, strval)) != 0) {\n                free (strval[0]);\n                goto cleanup;\n            }\n            free (strval[0]);\n        }\n    }\n\n    /* Directory specific attribute */\n    if (xargs.tktpolicydn != NULL) {\n        int tmask=0;\n\n        if (strlen(xargs.tktpolicydn) != 0) {\n            st = checkattributevalue(ld, xargs.tktpolicydn, \"objectclass\", policyclass, &tmask);\n            CHECK_CLASS_VALIDITY(st, tmask, _(\"ticket policy object value: \"));\n\n            strval[0] = xargs.tktpolicydn;\n            strval[1] = NULL;\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_REPLACE, strval)) != 0)\n                goto cleanup;\n\n        } else {\n            /* if xargs.tktpolicydn is a empty string, then delete\n             * already existing krbticketpolicyreference attr */\n            if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbticketpolicyreference\", LDAP_MOD_DELETE, NULL)) != 0)\n                goto cleanup;\n        }\n\n    }\n\n    if (establish_links == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = xargs.linkdn;\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"krbObjectReferences\", LDAP_MOD_REPLACE, strval)) != 0)\n            goto cleanup;\n    }\n\n    /*\n     * in case mods is NULL then return\n     * not sure but can happen in a modprinc\n     * so no need to return an error\n     * addprinc will at least have the principal name\n     * and the keys passed in\n     */\n    if (mods == NULL)\n        goto cleanup;\n\n    if (create_standalone == TRUE) {\n        memset(strval, 0, sizeof(strval));\n        strval[0] = \"krbprincipal\";\n        strval[1] = \"krbprincipalaux\";\n        strval[2] = \"krbTicketPolicyAux\";\n\n        if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n            goto cleanup;\n\n        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {\n            /* a load operation must replace an existing entry */\n            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);\n            if (st != LDAP_SUCCESS) {\n                snprintf(errbuf, sizeof(errbuf),\n                         _(\"Principal delete failed (trying to replace \"\n                           \"entry): %s\"), ldap_err2string(st));\n                st = translate_ldap_error (st, OP_ADD);\n                k5_setmsg(context, st, \"%s\", errbuf);\n                goto cleanup;\n            } else {\n                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);\n            }\n        }\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"Principal add failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_ADD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n    } else {\n        /*\n         * Here existing ldap object is modified and can be related\n         * to any attribute, so always ensure that the ldap\n         * object is extended with all the kerberos related\n         * objectclasses so that there are no constraint\n         * violations.\n         */\n        {\n            char *attrvalues[] = {\"krbprincipalaux\", \"krbTicketPolicyAux\", NULL};\n            int p, q, r=0, amask=0;\n\n            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,\n                                        \"objectclass\", attrvalues, &amask)) != 0)\n                goto cleanup;\n\n            memset(strval, 0, sizeof(strval));\n            for (p=1, q=0; p<=2; p<<=1, ++q) {\n                if ((p & amask) == 0)\n                    strval[r++] = attrvalues[q];\n            }\n            if (r != 0) {\n                if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n                    goto cleanup;\n            }\n        }\n        if (xargs.dn != NULL)\n            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);\n        else\n            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);\n\n        if (st != LDAP_SUCCESS) {\n            snprintf(errbuf, sizeof(errbuf), _(\"User modification failed: %s\"),\n                     ldap_err2string(st));\n            st = translate_ldap_error (st, OP_MOD);\n            k5_setmsg(context, st, \"%s\", errbuf);\n            goto cleanup;\n        }\n\n        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)\n            entry->fail_auth_count++;\n    }\n\ncleanup:\n    if (user)\n        free(user);\n\n    if (filtuser)\n        free(filtuser);\n\n    free_xargs(xargs);\n\n    if (standalone_principal_dn)\n        free(standalone_principal_dn);\n\n    if (principal_dn)\n        free (principal_dn);\n\n    if (polname != NULL)\n        free(polname);\n\n    for (tre = 0; tre < ntrees; tre++)\n        free(subtreelist[tre]);\n    free(subtreelist);\n\n    if (subtree)\n        free (subtree);\n\n    if (bersecretkey) {\n        for (l=0; bersecretkey[l]; ++l) {\n            if (bersecretkey[l]->bv_val)\n                free (bersecretkey[l]->bv_val);\n            free (bersecretkey[l]);\n        }\n        free (bersecretkey);\n    }\n\n    if (keys)\n        free (keys);\n\n    ldap_mods_free(mods, 1);\n    ldap_osa_free_princ_ent(&princ_ent);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\nkrb5_error_code\nkrb5_read_tkt_policy(krb5_context context, krb5_ldap_context *ldap_context,\n                     krb5_db_entry *entries, char *policy)\n{\n    krb5_error_code             st=0;\n    int                         mask=0, omask=0;\n    int                         tkt_mask=(KDB_MAX_LIFE_ATTR | KDB_MAX_RLIFE_ATTR | KDB_TKT_FLAGS_ATTR);\n    krb5_ldap_policy_params     *tktpoldnparam=NULL;\n\n    if ((st=krb5_get_attributes_mask(context, entries, &mask)) != 0)\n        goto cleanup;\n\n    if ((mask & tkt_mask) == tkt_mask)\n        goto cleanup;\n\n    if (policy != NULL) {\n        st = krb5_ldap_read_policy(context, policy, &tktpoldnparam, &omask);\n        if (st && st != KRB5_KDB_NOENTRY) {\n            k5_prependmsg(context, st, _(\"Error reading ticket policy\"));\n            goto cleanup;\n        }\n\n        st = 0; /* reset the return status */\n    }\n\n    if ((mask & KDB_MAX_LIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_LIFE_ATTR) ==  KDB_MAX_LIFE_ATTR)\n            entries->max_life = tktpoldnparam->maxtktlife;\n        else if (ldap_context->lrparams->max_life)\n            entries->max_life = ldap_context->lrparams->max_life;\n    }\n\n    if ((mask & KDB_MAX_RLIFE_ATTR) == 0) {\n        if ((omask & KDB_MAX_RLIFE_ATTR) == KDB_MAX_RLIFE_ATTR)\n            entries->max_renewable_life = tktpoldnparam->maxrenewlife;\n        else if (ldap_context->lrparams->max_renewable_life)\n            entries->max_renewable_life = ldap_context->lrparams->max_renewable_life;\n    }\n\n    if ((mask & KDB_TKT_FLAGS_ATTR) == 0) {\n        if ((omask & KDB_TKT_FLAGS_ATTR) == KDB_TKT_FLAGS_ATTR)\n            entries->attributes = tktpoldnparam->tktflags;\n        else if (ldap_context->lrparams->tktflags)\n            entries->attributes |= ldap_context->lrparams->tktflags;\n    }\n    krb5_ldap_free_policy(context, tktpoldnparam);\n\ncleanup:\n    return st;\n}\n\nstatic void\nfree_ldap_seqof_key_data(ldap_seqof_key_data *keysets, krb5_int16 n_keysets)\n{\n    int i;\n\n    if (keysets == NULL)\n        return;\n\n    for (i = 0; i < n_keysets; i++)\n        k5_free_key_data(keysets[i].n_key_data, keysets[i].key_data);\n    free(keysets);\n}\n\n/*\n * Decode keys from ldap search results.\n *\n * Arguments:\n *  - bvalues\n *      The ldap search results containing the key data.\n *  - mkvno\n *      The master kvno that the keys were encrypted with.\n *  - keysets_out\n *      The decoded keys in a ldap_seqof_key_data struct.  Must be freed using\n *      free_ldap_seqof_key_data.\n *  - n_keysets_out\n *      The number of entries in keys_out.\n *  - total_keys_out\n *      An optional argument that if given will be set to the total number of\n *      keys found throughout all the entries: sum(keys_out.n_key_data)\n *      May be NULL.\n */\nstatic krb5_error_code\ndecode_keys(struct berval **bvalues, ldap_seqof_key_data **keysets_out,\n            krb5_int16 *n_keysets_out, krb5_int16 *total_keys_out)\n{\n    krb5_error_code err = 0;\n    krb5_int16 n_keys, i, ki, total_keys;\n    ldap_seqof_key_data *keysets = NULL;\n\n    *keysets_out = NULL;\n    *n_keysets_out = 0;\n    if (total_keys_out)\n        *total_keys_out = 0;\n\n    /* Precount the number of keys. */\n    for (n_keys = 0, i = 0; bvalues[i] != NULL; i++) {\n        if (bvalues[i]->bv_len > 0)\n            n_keys++;\n    }\n\n    keysets = k5calloc(n_keys, sizeof(ldap_seqof_key_data), &err);\n    if (keysets == NULL)\n        goto cleanup;\n    memset(keysets, 0, n_keys * sizeof(ldap_seqof_key_data));\n\n    for (i = 0, ki = 0, total_keys = 0; bvalues[i] != NULL; i++) {\n        krb5_data in;\n\n        if (bvalues[i]->bv_len == 0)\n            continue;\n        in.length = bvalues[i]->bv_len;\n        in.data = bvalues[i]->bv_val;\n\n        err = asn1_decode_sequence_of_keys(&in, &keysets[ki]);\n        if (err)\n            goto cleanup;\n\n        if (total_keys_out)\n            total_keys += keysets[ki].n_key_data;\n        ki++;\n    }\n\n    if (total_keys_out)\n        *total_keys_out = total_keys;\n\n    *n_keysets_out = n_keys;\n    *keysets_out = keysets;\n    keysets = NULL;\n    n_keys = 0;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keys);\n    return err;\n}\n\nkrb5_error_code\nkrb5_decode_krbsecretkey(krb5_context context, krb5_db_entry *entries,\n                         struct berval **bvalues, krb5_kvno *mkvno)\n{\n    krb5_key_data *key_data = NULL, *tmp;\n    krb5_error_code err = 0;\n    ldap_seqof_key_data *keysets = NULL;\n    krb5_int16 i, n_keysets = 0, total_keys = 0;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, &total_keys);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal key data\"));\n        goto cleanup;\n    }\n\n    key_data = k5calloc(total_keys, sizeof(krb5_key_data), &err);\n    if (key_data == NULL)\n        goto cleanup;\n    memset(key_data, 0, total_keys * sizeof(krb5_key_data));\n\n    if (n_keysets > 0)\n        *mkvno = keysets[0].mkvno;\n\n    /* Transfer key data values from keysets to a flat list in entries. */\n    tmp = key_data;\n    for (i = 0; i < n_keysets; i++) {\n        memcpy(tmp, keysets[i].key_data,\n               sizeof(krb5_key_data) * keysets[i].n_key_data);\n        tmp += keysets[i].n_key_data;\n        keysets[i].n_key_data = 0;\n    }\n    entries->n_key_data = total_keys;\n    entries->key_data = key_data;\n    key_data = NULL;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    k5_free_key_data(total_keys, key_data);\n    return err;\n}\n\nstatic int\ncompare_osa_pw_hist_ent(const void *left_in, const void *right_in)\n{\n    int kvno_left, kvno_right;\n    osa_pw_hist_ent *left = (osa_pw_hist_ent *)left_in;\n    osa_pw_hist_ent *right = (osa_pw_hist_ent *)right_in;\n\n    kvno_left = left->n_key_data ? left->key_data[0].key_data_kvno : 0;\n    kvno_right = right->n_key_data ? right->key_data[0].key_data_kvno : 0;\n    return kvno_left - kvno_right;\n}\n\n/*\n * Decode the key history entries from an LDAP search.\n *\n * NOTE: the caller must free princ_ent->old_keys even on error.\n */\nkrb5_error_code\nkrb5_decode_histkey(krb5_context context, struct berval **bvalues,\n                    osa_princ_ent_rec *princ_ent)\n{\n    krb5_error_code err = 0;\n    krb5_int16 i, n_keysets = 0;\n    ldap_seqof_key_data *keysets = NULL;\n\n    err = decode_keys(bvalues, &keysets, &n_keysets, NULL);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal pw history\"));\n        goto cleanup;\n    }\n\n    princ_ent->old_keys = k5calloc(n_keysets, sizeof(osa_pw_hist_ent), &err);\n    if (princ_ent->old_keys == NULL)\n        goto cleanup;\n    princ_ent->old_key_len = n_keysets;\n\n    if (n_keysets > 0)\n        princ_ent->admin_history_kvno = keysets[0].mkvno;\n\n    /* Transfer key data pointers from keysets to princ_ent. */\n    for (i = 0; i < n_keysets; i++) {\n        princ_ent->old_keys[i].n_key_data = keysets[i].n_key_data;\n        princ_ent->old_keys[i].key_data = keysets[i].key_data;\n        keysets[i].n_key_data = 0;\n        keysets[i].key_data = NULL;\n    }\n\n    /* Sort the principal entries by kvno in ascending order. */\n    qsort(princ_ent->old_keys, princ_ent->old_key_len, sizeof(osa_pw_hist_ent),\n          &compare_osa_pw_hist_ent);\n\n    princ_ent->aux_attributes |= KADM5_KEY_HIST;\n\n    /* Set the next key to the end of the list.  The queue will be lengthened\n     * if it isn't full yet; the first entry will be replaced if it is full. */\n    princ_ent->old_key_next = princ_ent->old_key_len;\n\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    return err;\n}\n\nstatic char *\ngetstringtime(krb5_timestamp epochtime)\n{\n    struct tm           tme;\n    char                *strtime=NULL;\n    time_t              posixtime = ts2tt(epochtime);\n\n    strtime = calloc (50, 1);\n    if (strtime == NULL)\n        return NULL;\n\n    if (gmtime_r(&posixtime, &tme) == NULL)\n        return NULL;\n\n    strftime(strtime, 50, \"%Y%m%d%H%M%SZ\", &tme);\n    return strtime;\n}\n", "#!/usr/bin/python\nfrom k5test import *\nimport time\nfrom itertools import imap\n\n# Run kdbtest against the BDB module.\nrealm = K5Realm(create_kdb=False)\nrealm.run(['./kdbtest'])\n\n# Set up an OpenLDAP test server if we can.\n\nif (not os.path.exists(os.path.join(plugins, 'kdb', 'kldap.so')) and\n    not os.path.exists(os.path.join(buildtop, 'lib', 'libkdb_ldap.a'))):\n    skip_rest('LDAP KDB tests', 'LDAP KDB module not built')\n\nif 'SLAPD' not in os.environ and not which('slapd'):\n    skip_rest('LDAP KDB tests', 'slapd not found')\n\nslapadd = which('slapadd')\nif not slapadd:\n    skip_rest('LDAP KDB tests', 'slapadd not found')\n\nldapdir = os.path.abspath('ldap')\ndbdir = os.path.join(ldapdir, 'ldap')\nslapd_conf = os.path.join(ldapdir, 'slapd.d')\nslapd_out = os.path.join(ldapdir, 'slapd.out')\nslapd_pidfile = os.path.join(ldapdir, 'pid')\nldap_pwfile = os.path.join(ldapdir, 'pw')\nldap_sock = os.path.join(ldapdir, 'sock')\nldap_uri = 'ldapi://%s/' % ldap_sock.replace(os.path.sep, '%2F')\nschema = os.path.join(srctop, 'plugins', 'kdb', 'ldap', 'libkdb_ldap',\n                      'kerberos.openldap.ldif')\ntop_dn = 'cn=krb5'\nadmin_dn = 'cn=admin,cn=krb5'\nadmin_pw = 'admin'\n\nshutil.rmtree(ldapdir, True)\nos.mkdir(ldapdir)\nos.mkdir(slapd_conf)\nos.mkdir(dbdir)\n\nif 'SLAPD' in os.environ:\n    slapd = os.environ['SLAPD']\nelse:\n    # Some Linux installations have AppArmor or similar restrictions\n    # on the slapd binary, which would prevent it from accessing the\n    # build directory.  Try to defeat this by copying the binary.\n    system_slapd = which('slapd')\n    slapd = os.path.join(ldapdir, 'slapd')\n    shutil.copy(system_slapd, slapd)\n\ndef slap_add(ldif):\n    proc = subprocess.Popen([slapadd, '-b', 'cn=config', '-F', slapd_conf],\n                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT)\n    (out, dummy) = proc.communicate(ldif)\n    output(out)\n    return proc.wait()\n\n\n# Configure the pid file and some authorization rules we will need for\n# SASL testing.\nif slap_add('dn: cn=config\\n'\n            'objectClass: olcGlobal\\n'\n            'olcPidFile: %s\\n'\n            'olcAuthzRegexp: '\n            '\".*uidNumber=%d,cn=peercred,cn=external,cn=auth\" \"%s\"\\n'\n            'olcAuthzRegexp: \"uid=digestuser,cn=digest-md5,cn=auth\" \"%s\"\\n' %\n            (slapd_pidfile, os.geteuid(), admin_dn, admin_dn)) != 0:\n    skip_rest('LDAP KDB tests', 'slapd basic configuration failed')\n\n# Find a working writable database type, trying mdb (added in OpenLDAP\n# 2.4.27) and bdb (deprecated and sometimes not built due to licensing\n# incompatibilities).\nfor dbtype in ('mdb', 'bdb'):\n    # Try to load the module.  This could fail if OpenLDAP is built\n    # without module support, so ignore errors.\n    slap_add('dn: cn=module,cn=config\\n'\n             'objectClass: olcModuleList\\n'\n             'olcModuleLoad: back_%s\\n' % dbtype)\n\n    dbclass = 'olc%sConfig' % dbtype.capitalize()\n    if slap_add('dn: olcDatabase=%s,cn=config\\n'\n                'objectClass: olcDatabaseConfig\\n'\n                'objectClass: %s\\n'\n                'olcSuffix: %s\\n'\n                'olcRootDN: %s\\n'\n                'olcRootPW: %s\\n'\n                'olcDbDirectory: %s\\n' %\n                (dbtype, dbclass, top_dn, admin_dn, admin_pw, dbdir)) == 0:\n        break\nelse:\n    skip_rest('LDAP KDB tests', 'could not find working slapd db type')\n\nif slap_add('include: file://%s\\n' % schema) != 0:\n    skip_rest('LDAP KDB tests', 'failed to load Kerberos schema')\n\n# Load the core schema if we can.\nldap_homes = ['/etc/ldap', '/etc/openldap', '/usr/local/etc/openldap',\n              '/usr/local/etc/ldap']\nlocal_schema_path = '/schema/core.ldif'\ncore_schema = next((i for i in imap(lambda x:x+local_schema_path, ldap_homes)\n                    if os.path.isfile(i)), None)\nif core_schema:\n    if slap_add('include: file://%s\\n' % core_schema) != 0:\n        core_schema = None\n\nslapd_pid = -1\ndef kill_slapd():\n    global slapd_pid\n    if slapd_pid != -1:\n        os.kill(slapd_pid, signal.SIGTERM)\n        slapd_pid = -1\natexit.register(kill_slapd)\n\nout = open(slapd_out, 'w')\nsubprocess.call([slapd, '-h', ldap_uri, '-F', slapd_conf], stdout=out,\n                stderr=out)\nout.close()\npidf = open(slapd_pidfile, 'r')\nslapd_pid = int(pidf.read())\npidf.close()\noutput('*** Started slapd (pid %d, output in %s)\\n' % (slapd_pid, slapd_out))\n\n# slapd detaches before it finishes setting up its listener sockets\n# (they are bound but listen() has not been called).  Give it a second\n# to finish.\ntime.sleep(1)\n\n# Run kdbtest against the LDAP module.\nconf = {'realms': {'$realm': {'database_module': 'ldap'}},\n        'dbmodules': {'ldap': {'db_library': 'kldap',\n                               'ldap_kerberos_container_dn': top_dn,\n                               'ldap_kdc_dn': admin_dn,\n                               'ldap_kadmind_dn': admin_dn,\n                               'ldap_service_password_file': ldap_pwfile,\n                               'ldap_servers': ldap_uri}}}\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\ninput = admin_pw + '\\n' + admin_pw + '\\n'\nrealm.run([kdb5_ldap_util, 'stashsrvpw', admin_dn], input=input)\nrealm.run(['./kdbtest'])\n\n# Run a kdb5_ldap_util command using the test server's admin DN and password.\ndef kldaputil(args, **kw):\n    return realm.run([kdb5_ldap_util, '-D', admin_dn, '-w', admin_pw] + args,\n                     **kw)\n\n# kdbtest can't currently clean up after itself since the LDAP module\n# doesn't support krb5_db_destroy.  So clean up after it with\n# kdb5_ldap_util before proceeding.\nkldaputil(['destroy', '-f'])\n\nldapmodify = which('ldapmodify')\nldapsearch = which('ldapsearch')\nif not ldapmodify or not ldapsearch:\n    skip_rest('some LDAP KDB tests', 'ldapmodify or ldapsearch not found')\n\ndef ldap_search(args):\n    proc = subprocess.Popen([ldapsearch, '-H', ldap_uri, '-b', top_dn,\n                             '-D', admin_dn, '-w', admin_pw, args],\n                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT)\n    (out, dummy) = proc.communicate()\n    return out\n\ndef ldap_modify(ldif, args=[]):\n    proc = subprocess.Popen([ldapmodify, '-H', ldap_uri, '-D', admin_dn,\n                             '-x', '-w', admin_pw] + args,\n                            stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                            stderr=subprocess.STDOUT)\n    (out, dummy) = proc.communicate(ldif)\n    output(out)\n\ndef ldap_add(dn, objectclass, attrs=[]):\n    in_data = 'dn: %s\\nobjectclass: %s\\n' % (dn, objectclass)\n    in_data += '\\n'.join(attrs) + '\\n'\n    ldap_modify(in_data, ['-a'])\n\n# Create krbContainer objects for use as subtrees.\nldap_add('cn=t1,cn=krb5', 'krbContainer')\nldap_add('cn=t2,cn=krb5', 'krbContainer')\nldap_add('cn=x,cn=t1,cn=krb5', 'krbContainer')\nldap_add('cn=y,cn=t2,cn=krb5', 'krbContainer')\n\n# Create a realm, exercising all of the realm options.\nkldaputil(['create', '-s', '-P', 'master', '-subtrees', 'cn=t2,cn=krb5',\n           '-containerref', 'cn=t2,cn=krb5', '-sscope', 'one',\n           '-maxtktlife', '5min', '-maxrenewlife', '10min', '-allow_svr'])\n\n# Modify the realm, exercising overlapping subtree pruning.\nkldaputil(['modify', '-subtrees',\n           'cn=x,cn=t1,cn=krb5:cn=t1,cn=krb5:cn=t2,cn=krb5:cn=y,cn=t2,cn=krb5',\n           '-containerref', 'cn=t1,cn=krb5', '-sscope', 'sub',\n           '-maxtktlife', '5hour', '-maxrenewlife', '10hour', '+allow_svr'])\n\nout = kldaputil(['list'])\nif out != 'KRBTEST.COM\\n':\n    fail('Unexpected kdb5_ldap_util list output')\n\n# Create a principal at a specified DN.  This is a little dodgy\n# because we're sticking a krbPrincipalAux objectclass onto a subtree\n# krbContainer, but it works and it avoids having to load core.schema\n# in the test LDAP server.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=cn=krb5', 'princ1'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\n# Check that the DN container check is a hierarchy test, not a simple\n# suffix match (CVE-2018-5730).  We expect this operation to fail\n# either way (because \"xcn\" isn't a valid DN tag) but the container\n# check should happen before the DN is parsed.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=xcn=t1,cn=krb5', 'princ1'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=cn=t2,cn=krb5', 'princ1'])\nrealm.run([kadminl, 'getprinc', 'princ1'], expected_msg='Principal: princ1')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'dn=cn=t2,cn=krb5', 'again'],\n          expected_code=1, expected_msg='ldap object is already kerberized')\n# Check that we can't set linkdn on a non-standalone object.\nrealm.run([kadminl, 'modprinc', '-x', 'linkdn=cn=t1,cn=krb5', 'princ1'],\n          expected_code=1, expected_msg='link information can not be set')\n\n# Create a principal with a specified linkdn.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'linkdn=cn=krb5', 'princ2'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'linkdn=cn=t1,cn=krb5', 'princ2'])\n# Check that we can't reset linkdn.\nrealm.run([kadminl, 'modprinc', '-x', 'linkdn=cn=t2,cn=krb5', 'princ2'],\n          expected_code=1, expected_msg='kerberos principal is already linked')\n\n# Create a principal with a specified containerdn.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'containerdn=cn=krb5', 'princ3'],\n          expected_code=1, expected_msg='DN is out of the realm subtree')\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'containerdn=cn=t1,cn=krb5',\n           'princ3'])\nrealm.run([kadminl, 'modprinc', '-x', 'containerdn=cn=t2,cn=krb5', 'princ3'],\n          expected_code=1, expected_msg='containerdn option not supported')\n# Verify that containerdn is checked when linkdn is also supplied\n# (CVE-2018-5730).\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'containerdn=cn=krb5',\n           '-x', 'linkdn=cn=t2,cn=krb5', 'princ4'], expected_code=1,\n          expected_msg='DN is out of the realm subtree')\n\n# Create and modify a ticket policy.\nkldaputil(['create_policy', '-maxtktlife', '3hour', '-maxrenewlife', '6hour',\n           '-allow_forwardable', 'tktpol'])\nkldaputil(['modify_policy', '-maxtktlife', '4hour', '-maxrenewlife', '8hour',\n           '+requires_preauth', 'tktpol'])\nout = kldaputil(['view_policy', 'tktpol'])\nif ('Ticket policy: tktpol\\n' not in out or\n    'Maximum ticket life: 0 days 04:00:00\\n' not in out or\n    'Maximum renewable life: 0 days 08:00:00\\n' not in out or\n    'Ticket flags: DISALLOW_FORWARDABLE REQUIRES_PRE_AUTH' not in out):\n    fail('Unexpected kdb5_ldap_util view_policy output')\n\nout = kldaputil(['list_policy'])\nif out != 'tktpol\\n':\n    fail('Unexpected kdb5_ldap_util list_policy output')\n\n# Associate the ticket policy to a principal.\nrealm.run([kadminl, 'ank', '-randkey', '-x', 'tktpolicy=tktpol', 'princ4'])\nout = realm.run([kadminl, 'getprinc', 'princ4'])\nif ('Maximum ticket life: 0 days 04:00:00\\n' not in out or\n    'Maximum renewable life: 0 days 08:00:00\\n' not in out or\n    'Attributes: DISALLOW_FORWARDABLE REQUIRES_PRE_AUTH\\n' not in out):\n    fail('Unexpected getprinc output with ticket policy')\n\n# Destroying the policy should fail while a principal references it.\nkldaputil(['destroy_policy', '-force', 'tktpol'], expected_code=1)\n\n# Dissociate the ticket policy from the principal.\nrealm.run([kadminl, 'modprinc', '-x', 'tktpolicy=', 'princ4'])\nout = realm.run([kadminl, 'getprinc', 'princ4'])\nif ('Maximum ticket life: 0 days 05:00:00\\n' not in out or\n    'Maximum renewable life: 0 days 10:00:00\\n' not in out or\n    'Attributes:\\n' not in out):\n    fail('Unexpected getprinc output without ticket policy')\n\n# Destroy the ticket policy.\nkldaputil(['destroy_policy', '-force', 'tktpol'])\nkldaputil(['view_policy', 'tktpol'], expected_code=1)\nout = kldaputil(['list_policy'])\nif out:\n    fail('Unexpected kdb5_ldap_util list_policy output after destroy')\n\n# Create another ticket policy to be destroyed with the realm.\nkldaputil(['create_policy', 'tktpol2'])\n\n# Try to create a password policy conflicting with a ticket policy.\nrealm.run([kadminl, 'addpol', 'tktpol2'], expected_code=1,\n          expected_msg='Already exists while creating policy \"tktpol2\"')\n\n# Try to create a ticket policy conflicting with a password policy.\nrealm.run([kadminl, 'addpol', 'pwpol'])\nout = kldaputil(['create_policy', 'pwpol'], expected_code=1)\nif 'Already exists while creating policy object' not in out:\n    fail('Expected error not seen in kdb5_ldap_util output')\n\n# Try to use a password policy as a ticket policy.\nrealm.run([kadminl, 'modprinc', '-x', 'tktpolicy=pwpol', 'princ4'],\n          expected_code=1, expected_msg='Object class violation')\n\n# Use a ticket policy as a password policy (CVE-2014-5353).  This\n# works with a warning; use kadmin.local -q so the warning is shown.\nrealm.run([kadminl, '-q', 'modprinc -policy tktpol2 princ4'],\n          expected_msg='WARNING: policy \"tktpol2\" does not exist')\n\n# Do some basic tests with a KDC against the LDAP module, exercising the\n# db_args processing code.\nrealm.start_kdc(['-x', 'nconns=3', '-x', 'host=' + ldap_uri,\n                 '-x', 'binddn=' + admin_dn, '-x', 'bindpwd=' + admin_pw])\nrealm.addprinc(realm.user_princ, password('user'))\nrealm.addprinc(realm.host_princ)\nrealm.extract_keytab(realm.host_princ, realm.keytab)\nrealm.kinit(realm.user_princ, password('user'))\nrealm.run([kvno, realm.host_princ])\nrealm.klist(realm.user_princ, realm.host_princ)\n\n# Test auth indicator support\nrealm.addprinc('authind', password('authind'))\nrealm.run([kadminl, 'setstr', 'authind', 'require_auth', 'otp radius'])\n\nout = ldap_search('(krbPrincipalName=authind*)')\nif 'krbPrincipalAuthInd: otp' not in out:\n    fail('Expected krbPrincipalAuthInd value not in output')\nif 'krbPrincipalAuthInd: radius' not in out:\n    fail('Expected krbPrincipalAuthInd value not in output')\n\nrealm.run([kadminl, 'getstrs', 'authind'],\n          expected_msg='require_auth: otp radius')\n\n# Test service principal aliases.\nrealm.addprinc('canon', password('canon'))\nldap_modify('dn: krbPrincipalName=canon@KRBTEST.COM,cn=t1,cn=krb5\\n'\n            'changetype: modify\\n'\n            'add: krbPrincipalName\\n'\n            'krbPrincipalName: alias@KRBTEST.COM\\n'\n            '-\\n'\n            'add: krbCanonicalName\\n'\n            'krbCanonicalName: canon@KRBTEST.COM\\n')\nrealm.run([kadminl, 'getprinc', 'alias'],\n          expected_msg='Principal: canon@KRBTEST.COM\\n')\nrealm.run([kadminl, 'getprinc', 'canon'],\n          expected_msg='Principal: canon@KRBTEST.COM\\n')\nrealm.run([kvno, 'alias', 'canon'])\nout = realm.run([klist])\nif 'alias@KRBTEST.COM\\n' not in out or 'canon@KRBTEST.COM' not in out:\n    fail('After fetching alias and canon, klist is missing one or both')\nrealm.kinit(realm.user_princ, password('user'), ['-S', 'alias'])\nrealm.klist(realm.user_princ, 'alias@KRBTEST.COM')\n\n# Make sure an alias to the local TGS is still treated like an alias.\nldap_modify('dn: krbPrincipalName=krbtgt/KRBTEST.COM@KRBTEST.COM,'\n            'cn=KRBTEST.COM,cn=krb5\\n'\n            'changetype: modify\\n'\n            'add:krbPrincipalName\\n'\n            'krbPrincipalName: tgtalias@KRBTEST.COM\\n'\n            '-\\n'\n            'add: krbCanonicalName\\n'\n            'krbCanonicalName: krbtgt/KRBTEST.COM@KRBTEST.COM\\n')\nrealm.run([kadminl, 'getprinc', 'tgtalias'],\n          expected_msg='Principal: krbtgt/KRBTEST.COM@KRBTEST.COM')\nrealm.kinit(realm.user_princ, password('user'))\nrealm.run([kvno, 'tgtalias'])\nrealm.klist(realm.user_princ, 'tgtalias@KRBTEST.COM')\n\n# Make sure aliases work in header tickets.\nrealm.run([kadminl, 'modprinc', '-maxrenewlife', '3 hours', 'user'])\nrealm.run([kadminl, 'modprinc', '-maxrenewlife', '3 hours',\n           'krbtgt/KRBTEST.COM'])\nrealm.kinit(realm.user_princ, password('user'), ['-l', '1h', '-r', '2h'])\nrealm.run([kvno, 'alias'])\nrealm.kinit(realm.user_princ, flags=['-R', '-S', 'alias'])\nrealm.klist(realm.user_princ, 'alias@KRBTEST.COM')\n\n# Test client principal aliases, with and without preauth.\nrealm.kinit('canon', password('canon'))\nrealm.kinit('alias', password('canon'), expected_code=1,\n            expected_msg='not found in Kerberos database')\nrealm.kinit('alias', password('canon'), ['-C'])\nrealm.run([kvno, 'alias'])\nrealm.klist('canon@KRBTEST.COM', 'alias@KRBTEST.COM')\nrealm.run([kadminl, 'modprinc', '+requires_preauth', 'canon'])\nrealm.kinit('canon', password('canon'))\nrealm.kinit('alias', password('canon'), ['-C'])\n\n# Test password history.\ndef test_pwhist(nhist):\n    def cpw(n, **kwargs):\n        realm.run([kadminl, 'cpw', '-pw', str(n), princ], **kwargs)\n    def cpw_fail(n):\n        cpw(n, expected_code=1)\n    output('*** Testing password history of size %d\\n' % nhist)\n    princ = 'pwhistprinc' + str(nhist)\n    pol = 'pwhistpol' + str(nhist)\n    realm.run([kadminl, 'addpol', '-history', str(nhist), pol])\n    realm.run([kadminl, 'addprinc', '-policy', pol, '-nokey', princ])\n    for i in range(nhist):\n        # Set a password, then check that all previous passwords fail.\n        cpw(i)\n        for j in range(i + 1):\n            cpw_fail(j)\n    # Set one more new password, and make sure the oldest key is\n    # rotated out.\n    cpw(nhist)\n    cpw_fail(1)\n    cpw(0)\n\nfor n in (1, 2, 3, 4, 5):\n    test_pwhist(n)\n\n# Regression test for #8193: test password character class requirements.\nprinc = 'charclassprinc'\npol = 'charclasspol'\nrealm.run([kadminl, 'addpol', '-minclasses', '3', pol])\nrealm.run([kadminl, 'addprinc', '-policy', pol, '-nokey', princ])\nrealm.run([kadminl, 'cpw', '-pw', 'abcdef', princ], expected_code=1)\nrealm.run([kadminl, 'cpw', '-pw', 'Abcdef', princ], expected_code=1)\nrealm.run([kadminl, 'cpw', '-pw', 'Abcdef1', princ])\n\n# Test principal renaming and make sure last modified is changed\ndef get_princ(princ):\n    out = realm.run([kadminl, 'getprinc', princ])\n    return dict(map(str.strip, x.split(\":\", 1)) for x in out.splitlines())\n\nrealm.addprinc(\"rename\", password('rename'))\nrenameprinc = get_princ(\"rename\")\nrealm.run([kadminl, '-p', 'fake@KRBTEST.COM', 'renprinc', 'rename', 'renamed'])\nrenamedprinc = get_princ(\"renamed\")\nif renameprinc['Last modified'] == renamedprinc['Last modified']:\n    fail('Last modified data not updated when principal was renamed')\n\n# Regression test for #7980 (fencepost when dividing keys up by kvno).\nrealm.run([kadminl, 'addprinc', '-randkey', '-e', 'aes256-cts,aes128-cts',\n           'kvnoprinc'])\nrealm.run([kadminl, 'cpw', '-randkey', '-keepold', '-e',\n           'aes256-cts,aes128-cts', 'kvnoprinc'])\nrealm.run([kadminl, 'getprinc', 'kvnoprinc'], expected_msg='Number of keys: 4')\nrealm.run([kadminl, 'cpw', '-randkey', '-keepold', '-e',\n           'aes256-cts,aes128-cts', 'kvnoprinc'])\nrealm.run([kadminl, 'getprinc', 'kvnoprinc'], expected_msg='Number of keys: 6')\n\n# Regression test for #8041 (NULL dereference on keyless principals).\nrealm.run([kadminl, 'addprinc', '-nokey', 'keylessprinc'])\nrealm.run([kadminl, 'getprinc', 'keylessprinc'],\n          expected_msg='Number of keys: 0')\nrealm.run([kadminl, 'cpw', '-randkey', '-e', 'aes256-cts,aes128-cts',\n           'keylessprinc'])\nrealm.run([kadminl, 'cpw', '-randkey', '-keepold', '-e',\n           'aes256-cts,aes128-cts', 'keylessprinc'])\nrealm.run([kadminl, 'getprinc', 'keylessprinc'],\n          expected_msg='Number of keys: 4')\nrealm.run([kadminl, 'purgekeys', '-all', 'keylessprinc'])\nrealm.run([kadminl, 'getprinc', 'keylessprinc'],\n          expected_msg='Number of keys: 0')\n\n# Test for 8354 (old password history entries when -keepold is used)\nrealm.run([kadminl, 'addpol', '-history', '2', 'keepoldpasspol'])\nrealm.run([kadminl, 'addprinc', '-policy', 'keepoldpasspol', '-pw', 'aaaa',\n           'keepoldpassprinc'])\nfor p in ('bbbb', 'cccc', 'aaaa'):\n    realm.run([kadminl, 'cpw', '-keepold', '-pw', p, 'keepoldpassprinc'])\n\nif runenv.sizeof_time_t <= 4:\n    skipped('y2038 LDAP test', 'platform has 32-bit time_t')\nelse:\n    # Test storage of timestamps after y2038.\n    realm.run([kadminl, 'modprinc', '-pwexpire', '2040-02-03', 'user'])\n    realm.run([kadminl, 'getprinc', 'user'], expected_msg=' 2040\\n')\n\nrealm.stop()\n\n# Briefly test dump and load.\ndumpfile = os.path.join(realm.testdir, 'dump')\nrealm.run([kdb5_util, 'dump', dumpfile])\nrealm.run([kdb5_util, 'load', dumpfile], expected_code=1,\n          expected_msg='KDB module requires -update argument')\nrealm.run([kdb5_util, 'load', '-update', dumpfile])\n\n# Destroy the realm.\nkldaputil(['destroy', '-f'])\nout = kldaputil(['list'])\nif out:\n    fail('Unexpected kdb5_ldap_util list output after destroy')\n\nif not core_schema:\n    skip_rest('LDAP SASL tests', 'core schema not found')\n\nif runenv.have_sasl != 'yes':\n    skip_rest('LDAP SASL tests', 'SASL support not built')\n\n# Test SASL EXTERNAL auth.  Remove the DNs and service password file\n# from the DB module config.\nos.remove(ldap_pwfile)\ndbmod = conf['dbmodules']['ldap']\ndbmod['ldap_kdc_sasl_mech'] = dbmod['ldap_kadmind_sasl_mech'] = 'EXTERNAL'\ndel dbmod['ldap_service_password_file']\ndel dbmod['ldap_kdc_dn'], dbmod['ldap_kadmind_dn']\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\nrealm.run([kdb5_ldap_util, 'create', '-s', '-P', 'master'])\nrealm.start_kdc()\nrealm.addprinc(realm.user_princ, password('user'))\nrealm.kinit(realm.user_princ, password('user'))\nrealm.stop()\nrealm.run([kdb5_ldap_util, 'destroy', '-f'])\n\n# Test SASL DIGEST-MD5 auth.  We need to set a clear-text password for\n# the admin DN, so create a person entry (requires the core schema).\n# Restore the service password file in the config and set authcids.\nldap_add('cn=admin,cn=krb5', 'person',\n         ['sn: dummy', 'userPassword: admin'])\ndbmod['ldap_kdc_sasl_mech'] = dbmod['ldap_kadmind_sasl_mech'] = 'DIGEST-MD5'\ndbmod['ldap_kdc_sasl_authcid'] = 'digestuser'\ndbmod['ldap_kadmind_sasl_authcid'] = 'digestuser'\ndbmod['ldap_service_password_file'] = ldap_pwfile\nrealm = K5Realm(create_kdb=False, kdc_conf=conf)\ninput = admin_pw + '\\n' + admin_pw + '\\n'\nrealm.run([kdb5_ldap_util, 'stashsrvpw', 'digestuser'], input=input)\nrealm.run([kdb5_ldap_util, 'create', '-s', '-P', 'master'])\nrealm.start_kdc()\nrealm.addprinc(realm.user_princ, password('user'))\nrealm.kinit(realm.user_princ, password('user'))\nrealm.stop()\n# Exercise DB options, which should cause binding to fail.\nrealm.run([kadminl, '-x', 'sasl_authcid=ab', 'getprinc', 'user'],\n          expected_code=1, expected_msg='Cannot bind to LDAP server')\nrealm.run([kadminl, '-x', 'bindpwd=wrong', 'getprinc', 'user'],\n          expected_code=1, expected_msg='Cannot bind to LDAP server')\nrealm.run([kdb5_ldap_util, 'destroy', '-f'])\n\n# We could still use tests to exercise:\n# * DB arg handling in krb5_ldap_create\n# * krbAllowedToDelegateTo attribute processing\n# * A load operation overwriting a standalone principal entry which\n#   already exists but doesn't have a krbPrincipalName attribute\n#   matching the principal name.\n# * A bunch of invalid-input error conditions\n#\n# There is no coverage for the following because it would be difficult:\n# * Out-of-memory error conditions\n# * Handling of failures from slapd (including krb5_retry_get_ldap_handle)\n# * Handling of servers which don't support mod-increment\n# * krb5_ldap_delete_krbcontainer (only happens if krb5_ldap_create fails)\n\nsuccess('LDAP and DB2 KDB tests')\n"], "filenames": ["src/lib/kadm5/srv/svr_principal.c", "src/plugins/kdb/ldap/libkdb_ldap/kdb_ldap.h", "src/plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c", "src/tests/t_kdb.py"], "buggy_code_start_loc": [332, 144, 653, 205], "buggy_code_end_loc": [332, 145, 963, 228], "fixing_code_start_loc": [333, 144, 654, 206], "fixing_code_end_loc": [340, 145, 975, 240], "type": "CWE-90", "message": "MIT krb5 1.6 or later allows an authenticated kadmin with permission to add principals to an LDAP Kerberos database to circumvent a DN containership check by supplying both a \"linkdn\" and \"containerdn\" database argument, or by supplying a DN string which is a left extension of a container DN string but is not hierarchically within the container DN.", "other": {"cve": {"id": "CVE-2018-5730", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-06T20:29:00.657", "lastModified": "2022-04-18T17:30:17.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MIT krb5 1.6 or later allows an authenticated kadmin with permission to add principals to an LDAP Kerberos database to circumvent a DN containership check by supplying both a \"linkdn\" and \"containerdn\" database argument, or by supplying a DN string which is a left extension of a container DN string but is not hierarchically within the container DN."}, {"lang": "es", "value": "MIT krb5, en versiones 1.6 o posteriores, permite que un kadmin autenticado con permiso para a\u00f1adir entidades de seguridad a una base de datos LDAP Kerberos sortee una comprobaci\u00f3n de containership DN proporcionando argumentos \"linkdn\" y \"containerdn\" de la base de datos, o proporcionando una cadena DN, que es una extensi\u00f3n a la izquierda de una cadena DN de contenedor pero que, jer\u00e1rquicamente, no est\u00e1 dentro del contenedor DN."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-90"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "5-1.6", "matchCriteriaId": "B91269F8-4F70-40CA-B5CD-F39EEDA01D36"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:26:*:*:*:*:*:*:*", "matchCriteriaId": "6E4D8269-B407-4C24-AAB0-02F885C7D752"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:27:*:*:*:*:*:*:*", "matchCriteriaId": "DBEACBFF-6D05-4B69-BF7A-F7E539D9BF6E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.securitytracker.com/id/1042071", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://access.redhat.com/errata/RHBA-2019:0327", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3071", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=891869", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1551082", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/e1caf6fb74981da62039846931ebdffed71309d1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/01/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/09/msg00019.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GK5T6JPMBHBPKS7HNGHYUUF4KKRMNSNU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OIFUL3CPM4S5TOXTTOCQ3CUZN6XCXUTR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/e1caf6fb74981da62039846931ebdffed71309d1"}}