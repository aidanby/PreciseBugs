{"buggy_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// XLA-specific dynamic stitch Op.\n\n#include \"tensorflow/compiler/tf2xla/shape_util.h\"\n#include \"tensorflow/compiler/tf2xla/type_util.h\"\n#include \"tensorflow/compiler/tf2xla/xla_helpers.h\"\n#include \"tensorflow/compiler/tf2xla/xla_op_kernel.h\"\n#include \"tensorflow/compiler/tf2xla/xla_op_registry.h\"\n#include \"tensorflow/compiler/xla/client/xla_builder.h\"\n#include \"tensorflow/compiler/xla/literal_util.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n\nnamespace tensorflow {\nnamespace {\n\nclass DynamicStitchOp : public XlaOpKernel {\n public:\n  explicit DynamicStitchOp(OpKernelConstruction* ctx) : XlaOpKernel(ctx) {\n    OP_REQUIRES(\n        ctx, ctx->num_inputs() > 0,\n        errors::InvalidArgument(\"DynamicStitchOp: Must have some inputs\"));\n    OP_REQUIRES(ctx, ctx->num_inputs() % 2 == 0,\n                errors::InvalidArgument(\n                    \"DynamicStitchOp: Must have even number of arguments\"));\n    // Compute expected input signature\n    const int n = ctx->num_inputs() / 2;\n    const DataType dt = ctx->input_type(n);\n    DataTypeVector expected;\n    for (int i = 0; i < n; i++) {\n      expected.push_back(DT_INT32);\n    }\n    for (int i = 0; i < n; i++) {\n      expected.push_back(dt);\n    }\n    OP_REQUIRES_OK(ctx, ctx->MatchSignature(expected, {dt}));\n  }\n\n  void Compile(XlaOpKernelContext* ctx) override {\n    // Validate that data_shape[i] = indices[i].shape() + constant\n    std::vector<xla::Literal> indices_input;\n    OP_REQUIRES_OK(ctx, ctx->ConstantInputList(\"indices\", &indices_input));\n\n    std::vector<xla::XlaOp> data;\n    std::vector<TensorShape> data_shapes;\n    OP_REQUIRES_OK(ctx, ctx->InputList(\"data\", &data, &data_shapes));\n\n    std::vector<xla::Literal> indices(indices_input.size());\n\n    const TensorShape& data0_shape = data_shapes[0];\n    TensorShape indices0_shape;\n    OP_REQUIRES_OK(\n        ctx, XLAShapeToTensorShape(indices_input[0].shape(), &indices0_shape));\n    for (int input_num = 0; input_num < indices_input.size(); input_num++) {\n      TensorShape indices_shape;\n      OP_REQUIRES_OK(ctx,\n                     XLAShapeToTensorShape(indices_input[input_num].shape(),\n                                           &indices_shape));\n      TensorShape& data_shape = data_shapes[input_num];\n      if (!TensorShapeUtils::StartsWith(data_shape, indices_shape)) {\n        // This happens when data shape is a dynamic shape with bound with\n        // indices_shape is a concrete shape. We use slice to reconcile the\n        // mismatch.\n        for (int64_t i = 0; i < indices_shape.dims(); ++i) {\n          data_shape.set_dim(i, indices_shape.dim_size(i));\n          data[input_num] = xla::SliceInDim(data[input_num], 0,\n                                            indices_shape.dim_size(i), 1, i);\n        }\n      }\n      OP_REQUIRES(\n          ctx, TensorShapeUtils::StartsWith(data_shape, indices_shape),\n          errors::InvalidArgument(\"data[\", input_num,\n                                  \"].shape = \", data_shape.DebugString(),\n                                  \" does not start with indices[\", input_num,\n                                  \"].shape = \", indices_shape.DebugString()));\n      OP_REQUIRES(\n          ctx,\n          input_num == 0 || SameExtraShape(data0_shape, indices0_shape,\n                                           data_shape, indices_shape),\n          errors::InvalidArgument(\n              \"Need data[0].shape[\", indices0_shape.dims(), \":] = data[\",\n              input_num, \"].shape[\", indices_shape.dims(),\n              \":], got data[0].shape = \", data0_shape.DebugString(), \", data[\",\n              input_num, \"].shape = \", data_shape.DebugString(),\n              \", indices[0].shape = \", indices0_shape.DebugString(),\n              \", indices[\", input_num,\n              \"].shape = \", indices_shape.DebugString()));\n\n      OP_REQUIRES_OK(ctx,\n                     XlaHelpers::ReshapeLiteral(indices_input[input_num],\n                                                {indices_shape.num_elements()},\n                                                &indices[input_num]));\n    }\n\n    // Find which slice will be used for each index. If the same index\n    // appears in multiple inputs, the last one is used. The logic\n    // here is different from that in third_party/tensorflow because\n    // it is important for XLA that there be a well-formed Concat\n    // operation at the end. The existing CPU/GPU code copies multiple\n    // source slices to the same destination slice if there are\n    // repeated indices, whereas the XLA code works out which\n    // source slice will 'win' and only uses that in the Concat.\n    int max_index = -1;\n    for (int input_num = 0; input_num < indices.size(); input_num++) {\n      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {\n        max_index = std::max(max_index, indices[input_num].Get<int>({i}));\n      }\n    }\n    int number_of_indices = max_index + 1;\n    int64_t result_rank = 1 + data0_shape.dims() - indices0_shape.dims();\n    if (number_of_indices == 0) {\n      std::vector<int64_t> result_shape(result_rank);\n      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {\n        result_shape[d - indices0_shape.dims() + 1] = data0_shape.dim_size(d);\n      }\n      xla::PrimitiveType element_type =\n          ctx->input_xla_type(ctx->num_inputs() - 1);\n      xla::Literal empty_literal = xla::Literal::CreateFromShape(\n          xla::ShapeUtil::MakeShape(element_type, result_shape));\n      ctx->SetOutput(0, xla::ConstantLiteral(ctx->builder(), empty_literal));\n      return;\n    }\n\n    // Construct the reverse mapping, for each index, of which slice of which\n    // input it comes from.\n    std::vector<int32> src_input_vector(number_of_indices);\n    std::vector<int32> src_slice_vector(number_of_indices);\n    std::vector<bool> src_index_used(number_of_indices);\n    int index_used_count = 0;\n    for (int input_num = 0; input_num < indices.size(); input_num++) {\n      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {\n        int index = indices[input_num].Get<int>({i});\n        src_input_vector[index] = input_num;\n        src_slice_vector[index] = i;\n        if (!src_index_used[index]) {\n          src_index_used[index] = true;\n          ++index_used_count;\n        }\n      }\n    }\n    OP_REQUIRES(ctx, index_used_count == number_of_indices,\n                errors::InvalidArgument(\"not all indices are used\"));\n\n    // Look up all the children expressions that represent the data\n    // inputs.\n    std::vector<xla::XlaOp> input(indices.size());\n    for (int input_num = 0; input_num < indices.size(); input_num++) {\n      TensorShape new_shape;\n      // first reshaped dimension is the number of indices for this input.\n      new_shape.AddDim(indices[input_num].shape().dimensions(0));\n      // Then the rest are the common extra shape.\n      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {\n        new_shape.AddDim(data0_shape.dim_size(d));\n      }\n      // Get the data, shaped appropriately.\n      auto handle = data[input_num];\n      if (new_shape == data_shapes[input_num]) {\n        input[input_num] = handle;\n      } else {\n        input[input_num] = xla::Reshape(handle, new_shape.dim_sizes());\n      }\n    }\n\n    // Set up the vectors for slicing: the first dimension will vary\n    // slice by slice, and the rest take the full common extra shape.\n    std::vector<int64_t> slice_start(result_rank);\n    std::vector<int64_t> slice_limit(result_rank);\n    std::vector<int64_t> stride(result_rank, 1);\n    for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {\n      slice_limit[1 + d - indices0_shape.dims()] = data0_shape.dim_size(d);\n    }\n    std::vector<xla::XlaOp> to_concat(number_of_indices);\n    for (int index_num = 0; index_num < number_of_indices; index_num++) {\n      const auto& expression = input[src_input_vector[index_num]];\n      // Take the appropriate slice of data.\n      slice_start[0] = src_slice_vector[index_num];\n      slice_limit[0] = src_slice_vector[index_num] + 1;\n      // And place it in the concat list in the place indicated by\n      // the index.\n      to_concat[index_num] =\n          xla::Slice(expression, slice_start, slice_limit, stride);\n    }\n\n    ctx->SetOutput(0, xla::ConcatInDim(ctx->builder(), to_concat, 0));\n  }\n\n private:\n  // Check if data0_shape[indices0.dims():] == data1_shape[indices1.dims():]\n  static bool SameExtraShape(const TensorShape& data0_shape,\n                             const TensorShape& indices0,\n                             const TensorShape& data1_shape,\n                             const TensorShape& indices1) {\n    const int extra0 = data0_shape.dims() - indices0.dims();\n    const int extra1 = data1_shape.dims() - indices1.dims();\n    if (extra0 != extra1) return false;\n    for (int i = 0; i < extra0; i++) {\n      if (data0_shape.dim_size(indices0.dims() + i) !=\n          data1_shape.dim_size(indices1.dims() + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nREGISTER_XLA_OP(Name(\"DynamicStitch\").CompileTimeConstantInput(\"indices\"),\n                DynamicStitchOp);\nREGISTER_XLA_OP(\n    Name(\"ParallelDynamicStitch\").CompileTimeConstantInput(\"indices\"),\n    DynamicStitchOp);\n\n}  // namespace\n}  // namespace tensorflow\n", "/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/gpu_device_array.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntypedef Eigen::GpuDevice GPUDevice;\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass DynamicStitchOpImplBase : public OpKernel {\n public:\n  explicit DynamicStitchOpImplBase(OpKernelConstruction* c,\n                                   const string& op_name)\n      : OpKernel(c) {\n    // Compute expected input signature\n    const DataType dt = DataTypeToEnum<T>::v();\n    const int n = c->num_inputs() / 2;\n    DataTypeVector expected;\n    for (int i = 0; i < n; i++) {\n      expected.push_back(DT_INT32);\n    }\n    for (int i = 0; i < n; i++) {\n      expected.push_back(dt);\n    }\n    OP_REQUIRES_OK(c, c->MatchSignature(expected, {dt}));\n    OP_REQUIRES(c, c->num_inputs() > 0,\n                errors::InvalidArgument(op_name + \": Must have some inputs\"));\n    OP_REQUIRES(c, c->num_inputs() % 2 == 0,\n                errors::InvalidArgument(\n                    op_name + \": Must have even number of arguments\"));\n  }\n\n protected:\n  // Check if data0.shape[indices0.dims():] == data1.shape[indices1.dims():]\n  static bool SameExtraShape(const Tensor& data0, const Tensor& indices0,\n                             const Tensor& data1, const Tensor& indices1) {\n    const int extra0 = data0.dims() - indices0.dims();\n    const int extra1 = data1.dims() - indices1.dims();\n    if (extra0 != extra1) return false;\n    for (int i = 0; i < extra0; i++) {\n      if (data0.dim_size(indices0.dims() + i) !=\n          data1.dim_size(indices1.dims() + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void CheckArgsAndAllocateResult(OpKernelContext* c,\n                                  OpInputList* indices_inputs,\n                                  OpInputList* data_inputs, int* first_dim_size,\n                                  int* data_elements_size,\n                                  Tensor** result_ptr) {\n    // Find maximum index in the indices vectors\n    OP_REQUIRES_OK(c, c->input_list(\"indices\", indices_inputs));\n\n    int32_t max_index = -1;\n    if (data_elements_size) {\n      *data_elements_size = 0;\n    }\n    for (const Tensor& indices : *indices_inputs) {\n      if (indices.NumElements() > 0) {\n        Eigen::Tensor<int32, 0, Eigen::RowMajor> m =\n            indices.flat<int32>().maximum();\n        max_index = std::max(m(), max_index);\n      }\n      if (data_elements_size) {\n        *data_elements_size += indices.NumElements();\n      }\n    }\n\n    *first_dim_size = max_index + 1;\n\n    // Validate that data[i].shape = indices[i].shape + constant\n    OP_REQUIRES_OK(c, c->input_list(\"data\", data_inputs));\n    const Tensor& data0 = (*data_inputs)[0];\n    const Tensor& indices0 = (*indices_inputs)[0];\n    for (int input_num = 0; input_num < indices_inputs->size(); input_num++) {\n      const Tensor& indices = (*indices_inputs)[input_num];\n      const Tensor& data = (*data_inputs)[input_num];\n      OP_REQUIRES(\n          c, TensorShapeUtils::StartsWith(data.shape(), indices.shape()),\n          errors::InvalidArgument(\"data[\", input_num,\n                                  \"].shape = \", data.shape().DebugString(),\n                                  \" does not start with indices[\", input_num,\n                                  \"].shape = \", indices.shape().DebugString()));\n      OP_REQUIRES(\n          c, input_num == 0 || SameExtraShape(data0, indices0, data, indices),\n          errors::InvalidArgument(\n              \"Need data[0].shape[\", indices0.dims(), \":] = data[\", input_num,\n              \"].shape[\", indices.dims(),\n              \":], got data[0].shape = \", data0.shape().DebugString(),\n              \", data[\", input_num, \"].shape = \", data.shape().DebugString(),\n              \", indices[0].shape = \", indices0.shape().DebugString(),\n              \", indices[\", input_num,\n              \"].shape = \", indices.shape().DebugString()));\n    }\n\n    // Allocate result tensor of shape\n    //   [*first_dim_size] + data.shape[indices.dims:]\n    TensorShape result_shape;\n    OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(*first_dim_size));\n    for (int d = indices0.dims(); d < data0.dims(); d++) {\n      OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(data0.dim_size(d)));\n    }\n    OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, result_ptr));\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nvoid DynamicStitchGPUImpl(const Eigen::GpuDevice& gpu_device,\n                          const int32_t slice_size,\n                          const int32_t first_dim_size,\n                          const GpuDeviceArrayStruct<int>& input_indices,\n                          const GpuDeviceArrayStruct<const T*>& input_ptrs,\n                          T* output);\n#define REGISTER_GPU(T)                                           \\\n  extern template void DynamicStitchGPUImpl(                      \\\n      const Eigen::GpuDevice& gpu_device, const int32 slice_size, \\\n      const int32 first_dim_size,                                 \\\n      const GpuDeviceArrayStruct<int32>& input_indices,           \\\n      const GpuDeviceArrayStruct<const T*>& input_ptrs, T* output);\n\nTF_CALL_int32(REGISTER_GPU);\nTF_CALL_int64(REGISTER_GPU);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU);\nTF_CALL_COMPLEX_TYPES(REGISTER_GPU);\n#undef REGISTER_GPU\n\ntemplate <class T>\nclass DynamicStitchOpGPU : public DynamicStitchOpImplBase<T> {\n public:\n  explicit DynamicStitchOpGPU(OpKernelConstruction* c)\n      : DynamicStitchOpImplBase<T>(c, \"DynamicStitchOp\") {}\n\n  void Compute(OpKernelContext* c) override {\n    OpInputList indices_inputs;\n    OpInputList data_inputs;\n    int first_dim_size;\n    int data_elements_size;\n    Tensor* merged = nullptr;\n    this->CheckArgsAndAllocateResult(c, &indices_inputs, &data_inputs,\n                                     &first_dim_size, &data_elements_size,\n                                     &merged);\n    if (!c->status().ok()) {\n      // Avoid segmentation faults if merged cannot be allocated and an error is\n      // passed back in the context.\n      return;\n    }\n\n    // TODO(jeff): Currently we leave uninitialized any portions of\n    // merged that aren't covered by an index in indices.  What should we do?\n    if (first_dim_size > 0) {\n      // because the collision requirements, we have to deal with\n      // collision first before send data to gpu kernel.\n      // TODO(ekelsen): Instead of doing a serial scan on the CPU to pick the\n      // last of duplicated indices, it could instead be done of the GPU\n      // implicitly using atomics to make sure the last index is the final\n      // write.\n      const int slice_size = merged->flat_outer_dims<T>().dimension(1);\n      GpuDeviceArrayOnHost<int32> indices_flat(c, first_dim_size);\n      GpuDeviceArrayOnHost<const T*> data_flat(c, data_elements_size);\n      OP_REQUIRES_OK(c, indices_flat.Init());\n      OP_REQUIRES_OK(c, data_flat.Init());\n      // initialize the indices_flat (-1 represents missing indices)\n      for (int i = 0; i < first_dim_size; ++i) {\n        indices_flat.Set(i, -1);\n      }\n\n      // data_flat index\n      int32_t idx = 0;\n      // sum of indices_inputs[i].NumElements() for compute indices_flat value.\n      int32_t base_size = 0;\n      for (int i = 0; i < indices_inputs.size(); ++i) {\n        auto indices_vec = indices_inputs[i].flat<int32>();\n        auto data_ptr_base = data_inputs[i].template flat<T>().data();\n        for (int j = 0; j < indices_vec.size(); ++j) {\n          // indices_flat's indices represent the indices of output.\n          // indices_flat's values represent the indices of input_data where the\n          // data located.\n          indices_flat.Set(indices_vec(j), base_size + j);\n          data_flat.Set(\n              idx, const_cast<T*>(reinterpret_cast<const T*>(data_ptr_base) +\n                                  j * slice_size));\n          ++idx;\n        }\n        base_size += indices_vec.size();\n      }\n      OP_REQUIRES_OK(c, indices_flat.Finalize());\n      OP_REQUIRES_OK(c, data_flat.Finalize());\n\n      auto output = merged->template flat<T>().data();\n      DynamicStitchGPUImpl<T>(c->eigen_gpu_device(), slice_size, first_dim_size,\n                              indices_flat.data(), data_flat.data(), output);\n    }\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T, bool Parallel>\nclass DynamicStitchOpImplCPU : public DynamicStitchOpImplBase<T> {\n public:\n  explicit DynamicStitchOpImplCPU(OpKernelConstruction* c)\n      : DynamicStitchOpImplBase<T>(\n            c, (Parallel ? \"ParallelDynamicStitchOp\" : \"DynamicStitchOp\")) {}\n\n  void Compute(OpKernelContext* c) override {\n    OpInputList indices_inputs;\n    OpInputList data_inputs;\n    int first_dim_size;\n    Tensor* merged = nullptr;\n    this->CheckArgsAndAllocateResult(c, &indices_inputs, &data_inputs,\n                                     &first_dim_size, nullptr, &merged);\n    if (!c->status().ok()) {\n      // Avoid segmentation faults if merged cannot be allocated and an error is\n      // passed back in the context.\n      return;\n    }\n\n    // TODO(jeff): Currently we leave uninitialized any portions of\n    // merged that aren't covered by an index in indices.  What should we do?\n    if (first_dim_size > 0) {\n      auto merged_flat = merged->flat_outer_dims<T>();\n      // slice_size must not be stored as int for cases of tensors over 2GB.\n      const auto slice_size = merged_flat.dimension(1);\n      const size_t slice_bytes = slice_size * sizeof(T);\n      auto OnInputNumber = [&](int input_num) {\n        const Tensor& indices = indices_inputs[input_num];\n        auto indices_vec = indices.flat<int32>();\n        const Tensor& data = data_inputs[input_num];\n        auto data_flat =\n            data.shaped<T, 2>({indices_vec.dimension(0), slice_size});\n\n        if (DataTypeCanUseMemcpy(DataTypeToEnum<T>::v())) {\n          T* merged_base = merged_flat.data();\n          const T* data_base = data_flat.data();\n          for (int i = 0; i < indices_vec.size(); i++) {\n            int32_t index = internal::SubtleMustCopy(indices_vec(i));\n            OP_REQUIRES(\n                c, FastBoundsCheck(index, first_dim_size),\n                errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));\n            memcpy(merged_base + index * slice_size, data_base + i * slice_size,\n                   slice_bytes);\n          }\n        } else {\n          Eigen::DSizes<Eigen::DenseIndex, 2> sizes(1, slice_size);\n          for (int i = 0; i < indices_vec.size(); i++) {\n            // Copy slice data[i] to merged[indices[i]]\n            Eigen::DSizes<Eigen::DenseIndex, 2> data_indices(i, 0);\n            int32_t index = internal::SubtleMustCopy(indices_vec(i));\n            OP_REQUIRES(\n                c, FastBoundsCheck(index, first_dim_size),\n                errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));\n            Eigen::DSizes<Eigen::DenseIndex, 2> merged_indices(index, 0);\n            merged_flat.slice(merged_indices, sizes) =\n                data_flat.slice(data_indices, sizes);\n          }\n        }\n      };\n      if (Parallel &&\n          c->device()->tensorflow_cpu_worker_threads()->num_threads > 1) {\n        auto thread_pool =\n            c->device()->tensorflow_cpu_worker_threads()->workers;\n        size_t total_indices_size = 0;\n        for (int input_num = 0; input_num < indices_inputs.size();\n             ++input_num) {\n          total_indices_size += indices_inputs[input_num].NumElements();\n        }\n        const double avg_indices_size =\n            static_cast<double>(total_indices_size) / indices_inputs.size();\n        auto bytes_processed = slice_bytes * avg_indices_size;\n        auto LoopBody = [&](int first, int last) {\n          for (int input_num = first; input_num < last; ++input_num) {\n            OnInputNumber(input_num);\n          }\n        };\n        thread_pool->ParallelFor(indices_inputs.size(), bytes_processed,\n                                 LoopBody);\n      } else {\n        for (int input_num = 0; input_num < indices_inputs.size();\n             input_num++) {\n          OnInputNumber(input_num);\n        }\n      }\n    }\n  }\n};\n\n// Using inheritance rather than a typedef so that these classes might have more\n// functionality later.\n\ntemplate <typename T>\nstruct DynamicStitchOpCPU : DynamicStitchOpImplCPU<T, false> {\n  using DynamicStitchOpImplCPU<T, false>::DynamicStitchOpImplCPU;\n};\n\ntemplate <typename T>\nstruct ParallelDynamicStitchOpCPU : DynamicStitchOpImplCPU<T, true> {\n  using DynamicStitchOpImplCPU<T, true>::DynamicStitchOpImplCPU;\n};\n\n#define REGISTER_DYNAMIC_STITCH(type)                    \\\n  REGISTER_KERNEL_BUILDER(Name(\"DynamicStitch\")          \\\n                              .Device(DEVICE_CPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          DynamicStitchOpCPU<type>)      \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParallelDynamicStitch\")  \\\n                              .Device(DEVICE_CPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          ParallelDynamicStitchOpCPU<type>)\n\nTF_CALL_POD_STRING_TYPES(REGISTER_DYNAMIC_STITCH);\nTF_CALL_variant(REGISTER_DYNAMIC_STITCH);\nTF_CALL_QUANTIZED_TYPES(REGISTER_DYNAMIC_STITCH);\n#undef REGISTER_DYNAMIC_STITCH\n\n#define REGISTER_PARALLEL_DYNAMIC_STITCH(type)           \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParallelDynamicStitch\")  \\\n                              .Device(DEVICE_DEFAULT)    \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\")     \\\n                              .HostMemory(\"data\")        \\\n                              .HostMemory(\"merged\"),     \\\n                          ParallelDynamicStitchOpCPU<type>)\n\nTF_CALL_int32(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_int64(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_COMPLEX_TYPES(REGISTER_PARALLEL_DYNAMIC_STITCH);\n#undef REGISTER_PARALLEL_DYNAMIC_STITCH\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_DYNAMIC_STITCH_GPU(type)                \\\n  REGISTER_KERNEL_BUILDER(Name(\"DynamicStitch\")          \\\n                              .Device(DEVICE_GPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          DynamicStitchOpGPU<type>)\n\nTF_CALL_int32(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_int64(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_COMPLEX_TYPES(REGISTER_DYNAMIC_STITCH_GPU);\n#undef REGISTER_DYNAMIC_STITCH_GPU\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.data_flow_ops.{,parallel_}dynamic_stitch.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import data_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import gradients_impl\nimport tensorflow.python.ops.data_flow_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass DynamicStitchTestBase(object):\n\n  def __init__(self, stitch_op):\n    self.stitch_op = stitch_op\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40, 60][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testShapeInferenceForScalarWithNonConstantIndices(self):\n    with test_util.use_gpu():\n      indices = [\n          array_ops.placeholder(dtype=dtypes.int32),\n          constant_op.constant(1)\n      ]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        # Dimension 0 is max(flatten(indices))+1, but the first indices input is\n        # not a constant tensor, so we can only infer it as a vector of unknown\n        # length.\n        self.assertEqual([None], stitched_t.get_shape().as_list())\n\n  @test_util.disable_tfrt(\"b/169901260\")\n  def testSimpleOneDimensional(self):\n    # Test various datatypes in the simple case to ensure that the op was\n    # registered under those types.\n    dtypes_to_test = [\n        dtypes.float32,\n        dtypes.float16,\n        dtypes.bfloat16,\n        dtypes.qint8,\n        dtypes.quint8,\n        dtypes.qint32,\n    ]\n    for dtype in dtypes_to_test:\n      indices = [\n          constant_op.constant([0, 4, 7]),\n          constant_op.constant([1, 6, 2, 3, 5])\n      ]\n      data = [\n          math_ops.cast(constant_op.constant([0, 40, 70]), dtype=dtype),\n          math_ops.cast(\n              constant_op.constant([10, 60, 20, 30, 50]), dtype=dtype)\n      ]\n      stitched_t = self.stitch_op(indices, data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testOneListOneDimensional(self):\n    indices = [constant_op.constant([1, 6, 2, 3, 5, 0, 4, 7])]\n    data = [constant_op.constant([10, 60, 20, 30, 50, 0, 40, 70])]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testSimpleTwoDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testZeroSizeTensor(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5]),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]]),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testAllZeroSizeTensor(self):\n    indices = [\n        array_ops.zeros([0], dtype=dtypes.int32),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        array_ops.zeros([0, 2], dtype=dtypes.int32),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual(np.zeros((0, 2)), stitched_val)\n    self.assertEqual([0, 2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61., 62.]),\n        constant_op.constant([[41., 42.], [11., 12.]]),\n        constant_op.constant([[[51., 52.], [21., 22.]],\n                              [[1., 2.], [31., 32.]]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10. * np.arange(7)[:, None] + [1., 2.]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7. * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7. * self.evaluate(datum), grad)\n\n  @test_util.run_deprecated_v1\n  def testErrorIndicesMultiDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([[1, 6, 2, 3, 5]])\n    ]\n    data = [\n        constant_op.constant([[0, 40, 70]]),\n        constant_op.constant([10, 60, 20, 30, 50])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataNumDimsMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([[10, 60, 20, 30, 50]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataDimSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 5]),\n        constant_op.constant([1, 6, 2, 3])\n    ]\n    data = [\n        constant_op.constant([[0], [40], [70]]),\n        constant_op.constant([[10, 11], [60, 61], [20, 21], [30, 31]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataAndIndicesSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([10, 60, 20, 30])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n\nclass DynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.dynamic_stitch)\n\n\nclass ParallelDynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.parallel_dynamic_stitch)\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n      for step in -1, 1:\n        stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  # GPU version unit tests\n  def testScalarGPU(self):\n    indices = [constant_op.constant(0), constant_op.constant(1)]\n    data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n    for step in -1, 1:\n      stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRankGPU(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testMismatchedDataAndIndexListSizes(self):\n    indices = [\n        constant_op.constant([2]),\n        constant_op.constant([1]),\n        constant_op.constant([0]),\n        constant_op.constant([3]),\n    ]\n    data = [\n        constant_op.constant([1.0]),\n        constant_op.constant([2.0]),\n        constant_op.constant([3.0]),\n        constant_op.constant([4.0])\n    ]\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"expected inputs .* do not match|List argument .* must match\"):\n      self.evaluate(data_flow_ops.dynamic_stitch(indices[0:2], data))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"expected inputs .* do not match|List argument .* must match\"):\n      self.evaluate(data_flow_ops.dynamic_stitch(indices, data[0:2]))\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// XLA-specific dynamic stitch Op.\n\n#include \"tensorflow/compiler/tf2xla/shape_util.h\"\n#include \"tensorflow/compiler/tf2xla/type_util.h\"\n#include \"tensorflow/compiler/tf2xla/xla_helpers.h\"\n#include \"tensorflow/compiler/tf2xla/xla_op_kernel.h\"\n#include \"tensorflow/compiler/tf2xla/xla_op_registry.h\"\n#include \"tensorflow/compiler/xla/client/xla_builder.h\"\n#include \"tensorflow/compiler/xla/literal_util.h\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n\nnamespace tensorflow {\nnamespace {\n\nclass DynamicStitchOp : public XlaOpKernel {\n public:\n  explicit DynamicStitchOp(OpKernelConstruction* ctx) : XlaOpKernel(ctx) {\n    OP_REQUIRES(\n        ctx, ctx->num_inputs() > 0,\n        errors::InvalidArgument(\"DynamicStitchOp: Must have some inputs\"));\n    OP_REQUIRES(ctx, ctx->num_inputs() % 2 == 0,\n                errors::InvalidArgument(\n                    \"DynamicStitchOp: Must have even number of arguments\"));\n    // Compute expected input signature\n    const int n = ctx->num_inputs() / 2;\n    const DataType dt = ctx->input_type(n);\n    DataTypeVector expected;\n    for (int i = 0; i < n; i++) {\n      expected.push_back(DT_INT32);\n    }\n    for (int i = 0; i < n; i++) {\n      expected.push_back(dt);\n    }\n    OP_REQUIRES_OK(ctx, ctx->MatchSignature(expected, {dt}));\n  }\n\n  void Compile(XlaOpKernelContext* ctx) override {\n    // Validate that data_shape[i] = indices[i].shape() + constant\n    std::vector<xla::Literal> indices_input;\n    OP_REQUIRES_OK(ctx, ctx->ConstantInputList(\"indices\", &indices_input));\n\n    std::vector<xla::XlaOp> data;\n    std::vector<TensorShape> data_shapes;\n    OP_REQUIRES_OK(ctx, ctx->InputList(\"data\", &data, &data_shapes));\n\n    std::vector<xla::Literal> indices(indices_input.size());\n\n    const TensorShape& data0_shape = data_shapes[0];\n    TensorShape indices0_shape;\n    OP_REQUIRES_OK(\n        ctx, XLAShapeToTensorShape(indices_input[0].shape(), &indices0_shape));\n    for (int input_num = 0; input_num < indices_input.size(); input_num++) {\n      TensorShape indices_shape;\n      OP_REQUIRES_OK(ctx,\n                     XLAShapeToTensorShape(indices_input[input_num].shape(),\n                                           &indices_shape));\n      TensorShape& data_shape = data_shapes[input_num];\n      if (!TensorShapeUtils::StartsWith(data_shape, indices_shape)) {\n        // This happens when data shape is a dynamic shape with bound with\n        // indices_shape is a concrete shape. We use slice to reconcile the\n        // mismatch.\n        for (int64_t i = 0; i < indices_shape.dims(); ++i) {\n          data_shape.set_dim(i, indices_shape.dim_size(i));\n          data[input_num] = xla::SliceInDim(data[input_num], 0,\n                                            indices_shape.dim_size(i), 1, i);\n        }\n      }\n      OP_REQUIRES(\n          ctx, TensorShapeUtils::StartsWith(data_shape, indices_shape),\n          errors::InvalidArgument(\"data[\", input_num,\n                                  \"].shape = \", data_shape.DebugString(),\n                                  \" does not start with indices[\", input_num,\n                                  \"].shape = \", indices_shape.DebugString()));\n      OP_REQUIRES(\n          ctx,\n          input_num == 0 || SameExtraShape(data0_shape, indices0_shape,\n                                           data_shape, indices_shape),\n          errors::InvalidArgument(\n              \"Need data[0].shape[\", indices0_shape.dims(), \":] = data[\",\n              input_num, \"].shape[\", indices_shape.dims(),\n              \":], got data[0].shape = \", data0_shape.DebugString(), \", data[\",\n              input_num, \"].shape = \", data_shape.DebugString(),\n              \", indices[0].shape = \", indices0_shape.DebugString(),\n              \", indices[\", input_num,\n              \"].shape = \", indices_shape.DebugString()));\n\n      OP_REQUIRES_OK(ctx,\n                     XlaHelpers::ReshapeLiteral(indices_input[input_num],\n                                                {indices_shape.num_elements()},\n                                                &indices[input_num]));\n    }\n\n    // Find which slice will be used for each index. If the same index\n    // appears in multiple inputs, the last one is used. The logic\n    // here is different from that in third_party/tensorflow because\n    // it is important for XLA that there be a well-formed Concat\n    // operation at the end. The existing CPU/GPU code copies multiple\n    // source slices to the same destination slice if there are\n    // repeated indices, whereas the XLA code works out which\n    // source slice will 'win' and only uses that in the Concat.\n    int max_index = -1;\n    for (int input_num = 0; input_num < indices.size(); input_num++) {\n      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {\n        max_index = std::max(max_index, indices[input_num].Get<int>({i}));\n      }\n    }\n    int number_of_indices = max_index + 1;\n    int64_t result_rank = 1 + data0_shape.dims() - indices0_shape.dims();\n    if (number_of_indices == 0) {\n      std::vector<int64_t> result_shape(result_rank);\n      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {\n        result_shape[d - indices0_shape.dims() + 1] = data0_shape.dim_size(d);\n      }\n      xla::PrimitiveType element_type =\n          ctx->input_xla_type(ctx->num_inputs() - 1);\n      xla::Literal empty_literal = xla::Literal::CreateFromShape(\n          xla::ShapeUtil::MakeShape(element_type, result_shape));\n      ctx->SetOutput(0, xla::ConstantLiteral(ctx->builder(), empty_literal));\n      return;\n    }\n\n    // Construct the reverse mapping, for each index, of which slice of which\n    // input it comes from.\n    std::vector<int32> src_input_vector(number_of_indices);\n    std::vector<int32> src_slice_vector(number_of_indices);\n    std::vector<bool> src_index_used(number_of_indices);\n    int index_used_count = 0;\n    for (int input_num = 0; input_num < indices.size(); input_num++) {\n      for (int i = 0; i < indices[input_num].shape().dimensions(0); ++i) {\n        int index = indices[input_num].Get<int>({i});\n        OP_REQUIRES(\n            ctx, index >= 0,\n            errors::InvalidArgument(\"indices[\", index, \"] is out of range\"));\n\n        src_input_vector[index] = input_num;\n        src_slice_vector[index] = i;\n        if (!src_index_used[index]) {\n          src_index_used[index] = true;\n          ++index_used_count;\n        }\n      }\n    }\n    OP_REQUIRES(ctx, index_used_count == number_of_indices,\n                errors::InvalidArgument(\"not all indices are used\"));\n\n    // Look up all the children expressions that represent the data\n    // inputs.\n    std::vector<xla::XlaOp> input(indices.size());\n    for (int input_num = 0; input_num < indices.size(); input_num++) {\n      TensorShape new_shape;\n      // first reshaped dimension is the number of indices for this input.\n      new_shape.AddDim(indices[input_num].shape().dimensions(0));\n      // Then the rest are the common extra shape.\n      for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {\n        new_shape.AddDim(data0_shape.dim_size(d));\n      }\n      // Get the data, shaped appropriately.\n      auto handle = data[input_num];\n      if (new_shape == data_shapes[input_num]) {\n        input[input_num] = handle;\n      } else {\n        input[input_num] = xla::Reshape(handle, new_shape.dim_sizes());\n      }\n    }\n\n    // Set up the vectors for slicing: the first dimension will vary\n    // slice by slice, and the rest take the full common extra shape.\n    std::vector<int64_t> slice_start(result_rank);\n    std::vector<int64_t> slice_limit(result_rank);\n    std::vector<int64_t> stride(result_rank, 1);\n    for (int d = indices0_shape.dims(); d < data0_shape.dims(); d++) {\n      slice_limit[1 + d - indices0_shape.dims()] = data0_shape.dim_size(d);\n    }\n    std::vector<xla::XlaOp> to_concat(number_of_indices);\n    for (int index_num = 0; index_num < number_of_indices; index_num++) {\n      const auto& expression = input[src_input_vector[index_num]];\n      // Take the appropriate slice of data.\n      slice_start[0] = src_slice_vector[index_num];\n      slice_limit[0] = src_slice_vector[index_num] + 1;\n      // And place it in the concat list in the place indicated by\n      // the index.\n      to_concat[index_num] =\n          xla::Slice(expression, slice_start, slice_limit, stride);\n    }\n\n    ctx->SetOutput(0, xla::ConcatInDim(ctx->builder(), to_concat, 0));\n  }\n\n private:\n  // Check if data0_shape[indices0.dims():] == data1_shape[indices1.dims():]\n  static bool SameExtraShape(const TensorShape& data0_shape,\n                             const TensorShape& indices0,\n                             const TensorShape& data1_shape,\n                             const TensorShape& indices1) {\n    const int extra0 = data0_shape.dims() - indices0.dims();\n    const int extra1 = data1_shape.dims() - indices1.dims();\n    if (extra0 != extra1) return false;\n    for (int i = 0; i < extra0; i++) {\n      if (data0_shape.dim_size(indices0.dims() + i) !=\n          data1_shape.dim_size(indices1.dims() + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nREGISTER_XLA_OP(Name(\"DynamicStitch\").CompileTimeConstantInput(\"indices\"),\n                DynamicStitchOp);\nREGISTER_XLA_OP(\n    Name(\"ParallelDynamicStitch\").CompileTimeConstantInput(\"indices\"),\n    DynamicStitchOp);\n\n}  // namespace\n}  // namespace tensorflow\n", "/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// See docs in ../ops/data_flow_ops.cc.\n\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/lib/core/threadpool.h\"\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#include \"tensorflow/core/kernels/gpu_device_array.h\"\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\nnamespace tensorflow {\n\ntypedef Eigen::ThreadPoolDevice CPUDevice;\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\ntypedef Eigen::GpuDevice GPUDevice;\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T>\nclass DynamicStitchOpImplBase : public OpKernel {\n public:\n  explicit DynamicStitchOpImplBase(OpKernelConstruction* c,\n                                   const string& op_name)\n      : OpKernel(c) {\n    // Compute expected input signature\n    const DataType dt = DataTypeToEnum<T>::v();\n    const int n = c->num_inputs() / 2;\n    DataTypeVector expected;\n    for (int i = 0; i < n; i++) {\n      expected.push_back(DT_INT32);\n    }\n    for (int i = 0; i < n; i++) {\n      expected.push_back(dt);\n    }\n    OP_REQUIRES_OK(c, c->MatchSignature(expected, {dt}));\n    OP_REQUIRES(c, c->num_inputs() > 0,\n                errors::InvalidArgument(op_name + \": Must have some inputs\"));\n    OP_REQUIRES(c, c->num_inputs() % 2 == 0,\n                errors::InvalidArgument(\n                    op_name + \": Must have even number of arguments\"));\n  }\n\n protected:\n  // Check if data0.shape[indices0.dims():] == data1.shape[indices1.dims():]\n  static bool SameExtraShape(const Tensor& data0, const Tensor& indices0,\n                             const Tensor& data1, const Tensor& indices1) {\n    const int extra0 = data0.dims() - indices0.dims();\n    const int extra1 = data1.dims() - indices1.dims();\n    if (extra0 != extra1) return false;\n    for (int i = 0; i < extra0; i++) {\n      if (data0.dim_size(indices0.dims() + i) !=\n          data1.dim_size(indices1.dims() + i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void CheckArgsAndAllocateResult(OpKernelContext* c,\n                                  OpInputList* indices_inputs,\n                                  OpInputList* data_inputs, int* first_dim_size,\n                                  int* data_elements_size,\n                                  Tensor** result_ptr) {\n    // Find maximum index in the indices vectors\n    OP_REQUIRES_OK(c, c->input_list(\"indices\", indices_inputs));\n\n    int32_t max_index = -1;\n    if (data_elements_size) {\n      *data_elements_size = 0;\n    }\n    for (const Tensor& indices : *indices_inputs) {\n      if (indices.NumElements() > 0) {\n        Eigen::Tensor<int32, 0, Eigen::RowMajor> m =\n            indices.flat<int32>().maximum();\n        max_index = std::max(m(), max_index);\n      }\n      if (data_elements_size) {\n        *data_elements_size += indices.NumElements();\n      }\n    }\n\n    *first_dim_size = max_index + 1;\n\n    for (const Tensor& indices : *indices_inputs) {\n      auto indices_vec = indices.flat<int32>();\n\n      for (int i = 0; i < indices_vec.size(); i++) {\n        int32_t index = internal::SubtleMustCopy(indices_vec(i));\n        OP_REQUIRES(\n            c, FastBoundsCheck(index, *first_dim_size),\n            errors::InvalidArgument(\"indices[\", i, \"] is out of range\"));\n      }\n    }\n\n    // Validate that data[i].shape = indices[i].shape + constant\n    OP_REQUIRES_OK(c, c->input_list(\"data\", data_inputs));\n    const Tensor& data0 = (*data_inputs)[0];\n    const Tensor& indices0 = (*indices_inputs)[0];\n    for (int input_num = 0; input_num < indices_inputs->size(); input_num++) {\n      const Tensor& indices = (*indices_inputs)[input_num];\n      const Tensor& data = (*data_inputs)[input_num];\n      OP_REQUIRES(\n          c, TensorShapeUtils::StartsWith(data.shape(), indices.shape()),\n          errors::InvalidArgument(\"data[\", input_num,\n                                  \"].shape = \", data.shape().DebugString(),\n                                  \" does not start with indices[\", input_num,\n                                  \"].shape = \", indices.shape().DebugString()));\n      OP_REQUIRES(\n          c, input_num == 0 || SameExtraShape(data0, indices0, data, indices),\n          errors::InvalidArgument(\n              \"Need data[0].shape[\", indices0.dims(), \":] = data[\", input_num,\n              \"].shape[\", indices.dims(),\n              \":], got data[0].shape = \", data0.shape().DebugString(),\n              \", data[\", input_num, \"].shape = \", data.shape().DebugString(),\n              \", indices[0].shape = \", indices0.shape().DebugString(),\n              \", indices[\", input_num,\n              \"].shape = \", indices.shape().DebugString()));\n    }\n\n    // Allocate result tensor of shape\n    //   [*first_dim_size] + data.shape[indices.dims:]\n    TensorShape result_shape;\n    OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(*first_dim_size));\n    for (int d = indices0.dims(); d < data0.dims(); d++) {\n      OP_REQUIRES_OK(c, result_shape.AddDimWithStatus(data0.dim_size(d)));\n    }\n    OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, result_ptr));\n  }\n};\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <typename T>\nvoid DynamicStitchGPUImpl(const Eigen::GpuDevice& gpu_device,\n                          const int32_t slice_size,\n                          const int32_t first_dim_size,\n                          const GpuDeviceArrayStruct<int>& input_indices,\n                          const GpuDeviceArrayStruct<const T*>& input_ptrs,\n                          T* output);\n#define REGISTER_GPU(T)                                           \\\n  extern template void DynamicStitchGPUImpl(                      \\\n      const Eigen::GpuDevice& gpu_device, const int32 slice_size, \\\n      const int32 first_dim_size,                                 \\\n      const GpuDeviceArrayStruct<int32>& input_indices,           \\\n      const GpuDeviceArrayStruct<const T*>& input_ptrs, T* output);\n\nTF_CALL_int32(REGISTER_GPU);\nTF_CALL_int64(REGISTER_GPU);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_GPU);\nTF_CALL_COMPLEX_TYPES(REGISTER_GPU);\n#undef REGISTER_GPU\n\ntemplate <class T>\nclass DynamicStitchOpGPU : public DynamicStitchOpImplBase<T> {\n public:\n  explicit DynamicStitchOpGPU(OpKernelConstruction* c)\n      : DynamicStitchOpImplBase<T>(c, \"DynamicStitchOp\") {}\n\n  void Compute(OpKernelContext* c) override {\n    OpInputList indices_inputs;\n    OpInputList data_inputs;\n    int first_dim_size;\n    int data_elements_size;\n    Tensor* merged = nullptr;\n    this->CheckArgsAndAllocateResult(c, &indices_inputs, &data_inputs,\n                                     &first_dim_size, &data_elements_size,\n                                     &merged);\n    if (!c->status().ok()) {\n      // Avoid segmentation faults if merged cannot be allocated and an error is\n      // passed back in the context.\n      return;\n    }\n\n    // TODO(jeff): Currently we leave uninitialized any portions of\n    // merged that aren't covered by an index in indices.  What should we do?\n    if (first_dim_size > 0) {\n      // because the collision requirements, we have to deal with\n      // collision first before send data to gpu kernel.\n      // TODO(ekelsen): Instead of doing a serial scan on the CPU to pick the\n      // last of duplicated indices, it could instead be done of the GPU\n      // implicitly using atomics to make sure the last index is the final\n      // write.\n      const int slice_size = merged->flat_outer_dims<T>().dimension(1);\n      GpuDeviceArrayOnHost<int32> indices_flat(c, first_dim_size);\n      GpuDeviceArrayOnHost<const T*> data_flat(c, data_elements_size);\n      OP_REQUIRES_OK(c, indices_flat.Init());\n      OP_REQUIRES_OK(c, data_flat.Init());\n      // initialize the indices_flat (-1 represents missing indices)\n      for (int i = 0; i < first_dim_size; ++i) {\n        indices_flat.Set(i, -1);\n      }\n\n      // data_flat index\n      int32_t idx = 0;\n      // sum of indices_inputs[i].NumElements() for compute indices_flat value.\n      int32_t base_size = 0;\n      for (int i = 0; i < indices_inputs.size(); ++i) {\n        auto indices_vec = indices_inputs[i].flat<int32>();\n        auto data_ptr_base = data_inputs[i].template flat<T>().data();\n        for (int j = 0; j < indices_vec.size(); ++j) {\n          // indices_flat's indices represent the indices of output.\n          // indices_flat's values represent the indices of input_data where the\n          // data located.\n          indices_flat.Set(indices_vec(j), base_size + j);\n          data_flat.Set(\n              idx, const_cast<T*>(reinterpret_cast<const T*>(data_ptr_base) +\n                                  j * slice_size));\n          ++idx;\n        }\n        base_size += indices_vec.size();\n      }\n      OP_REQUIRES_OK(c, indices_flat.Finalize());\n      OP_REQUIRES_OK(c, data_flat.Finalize());\n\n      auto output = merged->template flat<T>().data();\n      DynamicStitchGPUImpl<T>(c->eigen_gpu_device(), slice_size, first_dim_size,\n                              indices_flat.data(), data_flat.data(), output);\n    }\n  }\n};\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\ntemplate <class T, bool Parallel>\nclass DynamicStitchOpImplCPU : public DynamicStitchOpImplBase<T> {\n public:\n  explicit DynamicStitchOpImplCPU(OpKernelConstruction* c)\n      : DynamicStitchOpImplBase<T>(\n            c, (Parallel ? \"ParallelDynamicStitchOp\" : \"DynamicStitchOp\")) {}\n\n  void Compute(OpKernelContext* c) override {\n    OpInputList indices_inputs;\n    OpInputList data_inputs;\n    int first_dim_size;\n    Tensor* merged = nullptr;\n    this->CheckArgsAndAllocateResult(c, &indices_inputs, &data_inputs,\n                                     &first_dim_size, nullptr, &merged);\n    if (!c->status().ok()) {\n      // Avoid segmentation faults if merged cannot be allocated and an error is\n      // passed back in the context.\n      return;\n    }\n\n    // TODO(jeff): Currently we leave uninitialized any portions of\n    // merged that aren't covered by an index in indices.  What should we do?\n    if (first_dim_size > 0) {\n      auto merged_flat = merged->flat_outer_dims<T>();\n      // slice_size must not be stored as int for cases of tensors over 2GB.\n      const auto slice_size = merged_flat.dimension(1);\n      const size_t slice_bytes = slice_size * sizeof(T);\n      auto OnInputNumber = [&](int input_num) {\n        const Tensor& indices = indices_inputs[input_num];\n        auto indices_vec = indices.flat<int32>();\n        const Tensor& data = data_inputs[input_num];\n        auto data_flat =\n            data.shaped<T, 2>({indices_vec.dimension(0), slice_size});\n\n        if (DataTypeCanUseMemcpy(DataTypeToEnum<T>::v())) {\n          T* merged_base = merged_flat.data();\n          const T* data_base = data_flat.data();\n          for (int i = 0; i < indices_vec.size(); i++) {\n            int32_t index = internal::SubtleMustCopy(indices_vec(i));\n            memcpy(merged_base + index * slice_size, data_base + i * slice_size,\n                   slice_bytes);\n          }\n        } else {\n          Eigen::DSizes<Eigen::DenseIndex, 2> sizes(1, slice_size);\n          for (int i = 0; i < indices_vec.size(); i++) {\n            // Copy slice data[i] to merged[indices[i]]\n            Eigen::DSizes<Eigen::DenseIndex, 2> data_indices(i, 0);\n            int32_t index = internal::SubtleMustCopy(indices_vec(i));\n            Eigen::DSizes<Eigen::DenseIndex, 2> merged_indices(index, 0);\n            merged_flat.slice(merged_indices, sizes) =\n                data_flat.slice(data_indices, sizes);\n          }\n        }\n      };\n      if (Parallel &&\n          c->device()->tensorflow_cpu_worker_threads()->num_threads > 1) {\n        auto thread_pool =\n            c->device()->tensorflow_cpu_worker_threads()->workers;\n        size_t total_indices_size = 0;\n        for (int input_num = 0; input_num < indices_inputs.size();\n             ++input_num) {\n          total_indices_size += indices_inputs[input_num].NumElements();\n        }\n        const double avg_indices_size =\n            static_cast<double>(total_indices_size) / indices_inputs.size();\n        auto bytes_processed = slice_bytes * avg_indices_size;\n        auto LoopBody = [&](int first, int last) {\n          for (int input_num = first; input_num < last; ++input_num) {\n            OnInputNumber(input_num);\n          }\n        };\n        thread_pool->ParallelFor(indices_inputs.size(), bytes_processed,\n                                 LoopBody);\n      } else {\n        for (int input_num = 0; input_num < indices_inputs.size();\n             input_num++) {\n          OnInputNumber(input_num);\n        }\n      }\n    }\n  }\n};\n\n// Using inheritance rather than a typedef so that these classes might have more\n// functionality later.\n\ntemplate <typename T>\nstruct DynamicStitchOpCPU : DynamicStitchOpImplCPU<T, false> {\n  using DynamicStitchOpImplCPU<T, false>::DynamicStitchOpImplCPU;\n};\n\ntemplate <typename T>\nstruct ParallelDynamicStitchOpCPU : DynamicStitchOpImplCPU<T, true> {\n  using DynamicStitchOpImplCPU<T, true>::DynamicStitchOpImplCPU;\n};\n\n#define REGISTER_DYNAMIC_STITCH(type)                    \\\n  REGISTER_KERNEL_BUILDER(Name(\"DynamicStitch\")          \\\n                              .Device(DEVICE_CPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          DynamicStitchOpCPU<type>)      \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParallelDynamicStitch\")  \\\n                              .Device(DEVICE_CPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          ParallelDynamicStitchOpCPU<type>)\n\nTF_CALL_POD_STRING_TYPES(REGISTER_DYNAMIC_STITCH);\nTF_CALL_variant(REGISTER_DYNAMIC_STITCH);\nTF_CALL_QUANTIZED_TYPES(REGISTER_DYNAMIC_STITCH);\n#undef REGISTER_DYNAMIC_STITCH\n\n#define REGISTER_PARALLEL_DYNAMIC_STITCH(type)           \\\n  REGISTER_KERNEL_BUILDER(Name(\"ParallelDynamicStitch\")  \\\n                              .Device(DEVICE_DEFAULT)    \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\")     \\\n                              .HostMemory(\"data\")        \\\n                              .HostMemory(\"merged\"),     \\\n                          ParallelDynamicStitchOpCPU<type>)\n\nTF_CALL_int32(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_int64(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_PARALLEL_DYNAMIC_STITCH);\nTF_CALL_COMPLEX_TYPES(REGISTER_PARALLEL_DYNAMIC_STITCH);\n#undef REGISTER_PARALLEL_DYNAMIC_STITCH\n\n#if GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n#define REGISTER_DYNAMIC_STITCH_GPU(type)                \\\n  REGISTER_KERNEL_BUILDER(Name(\"DynamicStitch\")          \\\n                              .Device(DEVICE_GPU)        \\\n                              .TypeConstraint<type>(\"T\") \\\n                              .HostMemory(\"indices\"),    \\\n                          DynamicStitchOpGPU<type>)\n\nTF_CALL_int32(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_int64(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_GPU_NUMBER_TYPES(REGISTER_DYNAMIC_STITCH_GPU);\nTF_CALL_COMPLEX_TYPES(REGISTER_DYNAMIC_STITCH_GPU);\n#undef REGISTER_DYNAMIC_STITCH_GPU\n\n#endif  // GOOGLE_CUDA || TENSORFLOW_USE_ROCM\n\n}  // namespace tensorflow\n", "# Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for tensorflow.ops.data_flow_ops.{,parallel_}dynamic_stitch.\"\"\"\n\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import data_flow_ops\nfrom tensorflow.python.ops import math_ops\nfrom tensorflow.python.ops import gradients_impl\nimport tensorflow.python.ops.data_flow_grad  # pylint: disable=unused-import\nfrom tensorflow.python.platform import test\n\n\nclass DynamicStitchTestBase(object):\n\n  def __init__(self, stitch_op):\n    self.stitch_op = stitch_op\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40, 60][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testShapeInferenceForScalarWithNonConstantIndices(self):\n    with test_util.use_gpu():\n      indices = [\n          array_ops.placeholder(dtype=dtypes.int32),\n          constant_op.constant(1)\n      ]\n      data = [constant_op.constant(40), constant_op.constant(60)]\n      for step in -1, 1:\n        stitched_t = self.stitch_op(indices[::step], data)\n        # Dimension 0 is max(flatten(indices))+1, but the first indices input is\n        # not a constant tensor, so we can only infer it as a vector of unknown\n        # length.\n        self.assertEqual([None], stitched_t.get_shape().as_list())\n\n  @test_util.disable_tfrt(\"b/169901260\")\n  def testSimpleOneDimensional(self):\n    # Test various datatypes in the simple case to ensure that the op was\n    # registered under those types.\n    dtypes_to_test = [\n        dtypes.float32,\n        dtypes.float16,\n        dtypes.bfloat16,\n        dtypes.qint8,\n        dtypes.quint8,\n        dtypes.qint32,\n    ]\n    for dtype in dtypes_to_test:\n      indices = [\n          constant_op.constant([0, 4, 7]),\n          constant_op.constant([1, 6, 2, 3, 5])\n      ]\n      data = [\n          math_ops.cast(constant_op.constant([0, 40, 70]), dtype=dtype),\n          math_ops.cast(\n              constant_op.constant([10, 60, 20, 30, 50]), dtype=dtype)\n      ]\n      stitched_t = self.stitch_op(indices, data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testOneListOneDimensional(self):\n    indices = [constant_op.constant([1, 6, 2, 3, 5, 0, 4, 7])]\n    data = [constant_op.constant([10, 60, 20, 30, 50, 0, 40, 70])]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([0, 10, 20, 30, 40, 50, 60, 70], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8], stitched_t.get_shape().as_list())\n\n  def testSimpleTwoDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testZeroSizeTensor(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6]),\n        constant_op.constant([2, 3, 5]),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        constant_op.constant([[0, 1], [40, 41], [70, 71]]),\n        constant_op.constant([[10, 11], [60, 61]]),\n        constant_op.constant([[20, 21], [30, 31], [50, 51]]),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual([[0, 1], [10, 11], [20, 21], [30, 31], [40, 41],\n                         [50, 51], [60, 61], [70, 71]], stitched_val)\n    # Dimension 0 is max(flatten(indices))+1.\n    self.assertEqual([8, 2], stitched_t.get_shape().as_list())\n\n  def testAllZeroSizeTensor(self):\n    indices = [\n        array_ops.zeros([0], dtype=dtypes.int32),\n        array_ops.zeros([0], dtype=dtypes.int32)\n    ]\n    data = [\n        array_ops.zeros([0, 2], dtype=dtypes.int32),\n        array_ops.zeros([0, 2], dtype=dtypes.int32)\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    self.assertAllEqual(np.zeros((0, 2)), stitched_val)\n    self.assertEqual([0, 2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61., 62.]),\n        constant_op.constant([[41., 42.], [11., 12.]]),\n        constant_op.constant([[[51., 52.], [21., 22.]],\n                              [[1., 2.], [31., 32.]]])\n    ]\n    stitched_t = self.stitch_op(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10. * np.arange(7)[:, None] + [1., 2.]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7. * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7. * self.evaluate(datum), grad)\n\n  @test_util.run_deprecated_v1\n  def testErrorIndicesMultiDimensional(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([[1, 6, 2, 3, 5]])\n    ]\n    data = [\n        constant_op.constant([[0, 40, 70]]),\n        constant_op.constant([10, 60, 20, 30, 50])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataNumDimsMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([[10, 60, 20, 30, 50]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataDimSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 5]),\n        constant_op.constant([1, 6, 2, 3])\n    ]\n    data = [\n        constant_op.constant([[0], [40], [70]]),\n        constant_op.constant([[10, 11], [60, 61], [20, 21], [30, 31]])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  @test_util.run_deprecated_v1\n  def testErrorDataAndIndicesSizeMismatch(self):\n    indices = [\n        constant_op.constant([0, 4, 7]),\n        constant_op.constant([1, 6, 2, 3, 5])\n    ]\n    data = [\n        constant_op.constant([0, 40, 70]),\n        constant_op.constant([10, 60, 20, 30])\n    ]\n    with self.assertRaises(ValueError):\n      self.stitch_op(indices, data)\n\n  def testOutOfBoundsIndexRaisesInvalidArgument(self):\n    with self.assertRaisesRegex(errors.InvalidArgumentError, \"out of range\"):\n      indices = [[-1000], [405], [519], [758], [1015]]\n      data = [\n          [110.27793884277344],\n          [120.29475402832031],\n          [157.2418212890625],\n          [157.2626953125],\n          [188.45382690429688],\n      ]\n\n      self.evaluate(self.stitch_op(indices, data))\n\n\nclass DynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.dynamic_stitch)\n\n\nclass ParallelDynamicStitchTest(DynamicStitchTestBase, test.TestCase):\n\n  def __init__(self, *test_case_args):\n    test.TestCase.__init__(self, *test_case_args)\n    DynamicStitchTestBase.__init__(self, data_flow_ops.parallel_dynamic_stitch)\n\n  def testScalar(self):\n    with test_util.use_gpu():\n      indices = [constant_op.constant(0), constant_op.constant(1)]\n      data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n      for step in -1, 1:\n        stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n        stitched_val = self.evaluate(stitched_t)\n        self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n        # Dimension 0 is max(flatten(indices))+1.\n        self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRank(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  # GPU version unit tests\n  def testScalarGPU(self):\n    indices = [constant_op.constant(0), constant_op.constant(1)]\n    data = [constant_op.constant(40.0), constant_op.constant(60.0)]\n    for step in -1, 1:\n      stitched_t = data_flow_ops.dynamic_stitch(indices[::step], data)\n      stitched_val = self.evaluate(stitched_t)\n      self.assertAllEqual([40.0, 60.0][::step], stitched_val)\n      # Dimension 0 is max(flatten(indices))+1.\n      self.assertEqual([2], stitched_t.get_shape().as_list())\n\n  @test_util.run_deprecated_v1\n  def testHigherRankGPU(self):\n    indices = [\n        constant_op.constant(6),\n        constant_op.constant([4, 1]),\n        constant_op.constant([[5, 2], [0, 3]])\n    ]\n    data = [\n        constant_op.constant([61, 62], dtype=dtypes.float32),\n        constant_op.constant([[41, 42], [11, 12]], dtype=dtypes.float32),\n        constant_op.constant(\n            [[[51, 52], [21, 22]], [[1, 2], [31, 32]]], dtype=dtypes.float32)\n    ]\n    stitched_t = data_flow_ops.dynamic_stitch(indices, data)\n    stitched_val = self.evaluate(stitched_t)\n    correct = 10 * np.arange(7)[:, None] + [1.0, 2.0]\n    self.assertAllEqual(correct, stitched_val)\n    self.assertEqual([7, 2], stitched_t.get_shape().as_list())\n    # Test gradients\n    stitched_grad = 7 * stitched_val\n    grads = gradients_impl.gradients(stitched_t, indices + data,\n                                     stitched_grad)\n    self.assertEqual(grads[:3], [None] * 3)  # Indices have no gradients\n    for datum, grad in zip(data, self.evaluate(grads[3:])):\n      self.assertAllEqual(7.0 * self.evaluate(datum), grad)\n\n  @test_util.run_in_graph_and_eager_modes\n  def testMismatchedDataAndIndexListSizes(self):\n    indices = [\n        constant_op.constant([2]),\n        constant_op.constant([1]),\n        constant_op.constant([0]),\n        constant_op.constant([3]),\n    ]\n    data = [\n        constant_op.constant([1.0]),\n        constant_op.constant([2.0]),\n        constant_op.constant([3.0]),\n        constant_op.constant([4.0])\n    ]\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"expected inputs .* do not match|List argument .* must match\"):\n      self.evaluate(data_flow_ops.dynamic_stitch(indices[0:2], data))\n\n    with self.assertRaisesRegex(\n        (ValueError, errors.InvalidArgumentError),\n        \"expected inputs .* do not match|List argument .* must match\"):\n      self.evaluate(data_flow_ops.dynamic_stitch(indices, data[0:2]))\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/compiler/tf2xla/kernels/dynamic_stitch_op.cc", "tensorflow/core/kernels/dynamic_stitch_op.cc", "tensorflow/python/kernel_tests/data_structures/dynamic_stitch_op_test.py"], "buggy_code_start_loc": [148, 98, 228], "buggy_code_end_loc": [148, 283, 228], "fixing_code_start_loc": [149, 99, 229], "fixing_code_end_loc": [153, 287, 242], "type": "CWE-125", "message": "TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, if the parameter `indices` for `DynamicStitch` does not match the shape of the parameter `data`, it can trigger an stack OOB read. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.", "other": {"cve": {"id": "CVE-2023-25659", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-25T00:15:07.143", "lastModified": "2023-03-30T19:38:28.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, if the parameter `indices` for `DynamicStitch` does not match the shape of the parameter `data`, it can trigger an stack OOB read. A fix is included in TensorFlow version 2.12.0 and version 2.11.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.12.0", "matchCriteriaId": "FAC3DE54-93B4-4D6C-9648-B9D416B9770F"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/ee004b18b976eeb5a758020af8880236cd707d05", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-93vr-9q9m-pj8p", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/ee004b18b976eeb5a758020af8880236cd707d05"}}